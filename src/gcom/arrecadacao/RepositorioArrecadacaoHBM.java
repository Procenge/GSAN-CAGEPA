/*
 * Copyright (C) 2007-2007 the GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 *
 * This file is part of GSAN, an integrated service management system for Sanitation
 *
 * GSAN is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * GSAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place – Suite 330, Boston, MA 02111-1307, USA
 */

/*
 * GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 * Copyright (C) <2007> 
 * Adriano Britto Siqueira
 * Alexandre Santos Cabral
 * Ana Carolina Alves Breda
 * Ana Maria Andrade Cavalcante
 * Aryed Lins de Araújo
 * Bruno Leonardo Rodrigues Barros
 * Carlos Elmano Rodrigues Ferreira
 * Cláudio de Andrade Lira
 * Denys Guimarães Guenes Tavares
 * Eduardo Breckenfeld da Rosa Borges
 * Fabíola Gomes de Araújo
 * Flávio Leonardo Cavalcanti Cordeiro
 * Francisco do Nascimento Júnior
 * Homero Sampaio Cavalcanti
 * Ivan Sérgio da Silva Júnior
 * José Edmar de Siqueira
 * José Thiago Tenório Lopes
 * Kássia Regina Silvestre de Albuquerque
 * Leonardo Luiz Vieira da Silva
 * Márcio Roberto Batista da Silva
 * Maria de Fátima Sampaio Leite
 * Micaela Maria Coelho de Araújo
 * Nelson Mendonça de Carvalho
 * Newton Morais e Silva
 * Pedro Alexandre Santos da Silva Filho
 * Rafael Corrêa Lima e Silva
 * Rafael Francisco Pinto
 * Rafael Koury Monteiro
 * Rafael Palermo de Araújo
 * Raphael Veras Rossiter
 * Roberto Sobreira Barbalho
 * Rodrigo Avellar Silveira
 * Rosana Carvalho Barbosa
 * Sávio Luiz de Andrade Cavalcante
 * Tai Mu Shih
 * Thiago Augusto Souza do Nascimento
 * Tiago Moreno Rodrigues
 * Vivianne Barbosa Sousa
 *
 * Este programa é software livre; você pode redistribuí-lo e/ou
 * modificá-lo sob os termos de Licença Pública Geral GNU, conforme
 * publicada pela Free Software Foundation; versão 2 da
 * Licença.
 * Este programa é distribuído na expectativa de ser útil, mas SEM
 * QUALQUER GARANTIA; sem mesmo a garantia implícita de
 * COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM
 * PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais
 * detalhes.
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU
 * junto com este programa; se não, escreva para Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307, USA.
 */

package gcom.arrecadacao;

import gcom.arrecadacao.aviso.AvisoBancario;
import gcom.arrecadacao.aviso.bean.AvisoBancarioHelper;
import gcom.arrecadacao.aviso.bean.MovimentarPagamentosDevolucoesHelper;
import gcom.arrecadacao.aviso.bean.PagamentosDevolucoesHelper;
import gcom.arrecadacao.aviso.bean.ValoresArrecadacaoDevolucaoAvisoBancarioHelper;
import gcom.arrecadacao.banco.Agencia;
import gcom.arrecadacao.banco.Banco;
import gcom.arrecadacao.bean.ArrecadadorContratoTarifaHelper;
import gcom.arrecadacao.bean.MovimentoArrecadadoresPorNSAHelper;
import gcom.arrecadacao.debitoautomatico.DebitoAutomaticoMovimento;
import gcom.arrecadacao.pagamento.*;
import gcom.arrecadacao.pagamento.bean.ClassificarLotePagamentosNaoClassificadosHelper;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.cadastro.cliente.*;
import gcom.cadastro.endereco.LogradouroBairro;
import gcom.cadastro.endereco.LogradouroCep;
import gcom.cadastro.imovel.Categoria;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.imovel.ImovelCobrancaSituacao;
import gcom.cobranca.*;
import gcom.cobranca.bean.IntervaloReferenciaHelper;
import gcom.cobranca.contrato.CobrancaContrato;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.faturamento.ImpostoTipo;
import gcom.faturamento.conta.Conta;
import gcom.faturamento.conta.ContaHistorico;
import gcom.faturamento.credito.CreditoOrigem;
import gcom.faturamento.credito.CreditoRealizado;
import gcom.faturamento.debito.*;
import gcom.financeiro.FinanciamentoTipo;
import gcom.financeiro.lancamento.AjusteContabilidade;
import gcom.relatorio.arrecadacao.GuiaDevolucaoRelatorioHelper;
import gcom.util.*;
import gcom.util.filtro.GeradorHQLCondicional;
import gcom.util.filtro.ParametroSimples;
import gcom.util.parametrizacao.faturamento.ExecutorParametrosFaturamento;
import gcom.util.parametrizacao.faturamento.ParametroFaturamento;

import java.math.BigDecimal;
import java.sql.*;
import java.util.*;
import java.util.Date;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;

import org.hibernate.*;
import org.hibernate.criterion.Expression;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Restrictions;
import org.hibernate.dialect.Dialect;
import org.hibernate.exception.GenericJDBCException;

/**
 * O repositório faz a comunicação com a base de dados através do hibernate. O
 * cliente usa o repositório como fonte de dados.
 * 
 * @author Sávio Luiz
 */
public final class RepositorioArrecadacaoHBM
				implements IRepositorioArrecadacao {

	private static IRepositorioArrecadacao instancia;

	/**
	 * Construtor da classe RepositorioCargaFuncionalidadesHBM
	 */
	private RepositorioArrecadacaoHBM() {

	}

	/**
	 * Retorna o valor de instancia
	 * 
	 * @return O valor de instancia
	 */
	public static IRepositorioArrecadacao getInstancia(){

		if(instancia == null){
			instancia = new RepositorioArrecadacaoHBM();
		}

		return instancia;
	}

	/**
	 * @param colecaoReferencias
	 * @return
	 */

	private String montarConsultaReferencias(Collection<IntervaloReferenciaHelper> colecaoReferencias){

		String consultaReferencia = " a.cnta_amreferenciaconta ";
		Iterator it = colecaoReferencias.iterator();
		boolean primeiro = true;
		while(it.hasNext()){

			IntervaloReferenciaHelper helper = (IntervaloReferenciaHelper) it.next();

			if(primeiro){
				consultaReferencia = consultaReferencia + " between "
								+ Util.formatarMesAnoComBarraParaAnoMes(helper.getReferenciaInicial())
								+ " and " + Util.formatarMesAnoComBarraParaAnoMes(helper.getReferenciaFinal());
				primeiro = false;
			}else{
				consultaReferencia = consultaReferencia + " OR a.cnta_amreferenciaconta between "
								+ Util.formatarMesAnoComBarraParaAnoMes(helper.getReferenciaInicial()) + " and "
								+ Util.formatarMesAnoComBarraParaAnoMes(helper.getReferenciaFinal());
			}
		}

		return consultaReferencia;
	}

	public Integer pesquisarIdRegistroCodigo(String codigoRegistro) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT rc.id " + "FROM RegistroCodigo rc " + "WHERE rc.codigo = :codigoRegistro";

			retorno = (Integer) session.createQuery(consulta).setCacheable(true).setString("codigoRegistro", codigoRegistro).setMaxResults(
							1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Short pesquisarNumeroDiasFloat(Integer idArrecadadorContrato, Integer idFormaArrecadacao) throws ErroRepositorioException{

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT act.numeroDiaFloat " + "FROM ArrecadadorContratoTarifa act " + "INNER JOIN act.arrecadadorContrato ac "
							+ "INNER JOIN act.arrecadacaoForma af " + "WHERE ac.id = :idArrecadadorContrato AND "
							+ "af.id = :idFormaArrecadacao";

			retorno = (Short) session.createQuery(consulta).setInteger("idArrecadadorContrato", idArrecadadorContrato).setInteger(
							"idFormaArrecadacao", idFormaArrecadacao).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public AvisoBancario pesquisarAvisoBancario(Integer codigoBanco, Date dataGeracaoArquivo, Date dataPrevistaCredito,
					Integer idArrecadadorMovimento) throws ErroRepositorioException{

		AvisoBancario retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT ab ");
			consulta.append("FROM AvisoBancario ab ");
			consulta.append("INNER JOIN ab.arrecadador arrec ");
			consulta.append("LEFT JOIN ab.arrecadadorMovimento arrecMov ");
			consulta.append("WHERE arrec.codigoAgente = :codigoBanco AND ");
			consulta.append("ab.dataLancamento = :dataGeracaoArquivo AND ");

			if(idArrecadadorMovimento != null){

				consulta.append("arrecMov.id = " + idArrecadadorMovimento.toString() + " AND ");
			}else{

				consulta.append("arrecMov.id is null AND ");
			}

			consulta.append("(ab.dataPrevista = :dataPrevistaCredito ");
			consulta.append("OR ab.dataRealizada = :dataPrevistaCredito)");

			retorno = (AvisoBancario) session.createQuery(consulta.toString()).setInteger("codigoBanco", codigoBanco)
							.setDate(
							"dataGeracaoArquivo", dataGeracaoArquivo).setDate("dataPrevistaCredito", dataPrevistaCredito).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Double pesquisarDeducoesAvisoBancario(String codigoAgente, Date dataLancamento, String numeroSequencial)
					throws ErroRepositorioException{

		Double retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT sum(vd.valorDeducao) ").append("FROM AvisoDeducoes vd ").append("LEFT JOIN vd.avisoBancario aviso ")
							.append("LEFT JOIN aviso.arrecadador arrecadador ").append("WHERE arrecadador.codigoAgente = :codigoAgente ")
							.append("AND aviso.dataLancamento = :dataLancamento ").append("AND aviso.numeroSequencial = :numeroSequencial");

			BigDecimal big = (BigDecimal) session.createQuery(consulta.toString()).setShort("codigoAgente", Short.parseShort(codigoAgente))
							.setDate("dataLancamento", dataLancamento).setShort("numeroSequencial", Short.parseShort(numeroSequencial))
							.setMaxResults(1).uniqueResult();

			if(big != null){
				retorno = new Double(big.toString());
			}else{
				retorno = null;
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/*
	 * [UC0235] Inserir Aviso Bancário [FS0003] Verificar existência de avisos
	 * bancários não realizados [FS0004] Verificar seleção de aviso Retorna o
	 * valor do maior número sequencial do arrecadador selecionado @author
	 * Rafael Corrêa
	 */

	public Short pesquisarValorMaximoNumeroSequencial(Date dataLancamento, String idArrecadador) throws ErroRepositorioException{

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT max(aviso.numeroSequencial) " + "FROM AvisoBancario aviso " + "LEFT JOIN aviso.arrecadador arrecadador "
							+ "WHERE arrecadador.id = :idArrecadador " + "AND aviso.dataLancamento = :dataLancamento";

			Number number = ((Number) session.createQuery(consulta).setInteger("idArrecadador", Integer.parseInt(idArrecadador)).setDate(
							"dataLancamento", dataLancamento).setMaxResults(1).uniqueResult());

			if(number != null){
				retorno = number.shortValue();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaGuiaPagamento(Imovel imovel, Integer idDebitoTipo) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select gp.id from GuiaPagamento gp " + "inner join gp.imovel " + "inner join gp.debitoTipo "
							+ "where gp.debitoTipo = :idDebitoTipo " + "and gp.imovel.id = :imovel  and "
							+ "gp.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (Integer) session.createQuery(consulta).setInteger("imovel", imovel.getId()).setInteger("idDebitoTipo", idDebitoTipo)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL).setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaGuiaPagamentoCliente(Integer idCliente, Integer idDebitoTipo) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select gp.id from GuiaPagamento gp " + "inner join gp.cliente clie " + "inner join gp.debitoTipo dbtp "
							+ "where dbtp.id = :idDebitoTipo " + "and clie.id = :idCliente  and "
							+ "gp.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada)";

			retorno = (Integer) session.createQuery(consulta).setInteger("idCliente", idCliente).setInteger("idDebitoTipo", idDebitoTipo)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL).setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarIdArrecadacaoForma(String codigoArrecadacaoForma) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try{
			consulta = "select af.id from ArrecadacaoForma af " + "where af.codigoArrecadacaoForma = :codigoArrecadacaoForma ";

			retorno = (Integer) session.createQuery(consulta).setString("codigoArrecadacaoForma", codigoArrecadacaoForma).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<ArrecadadorContrato> pesquisarNumeroSequecialArrecadadorContrato(Short idArrecadador, String cdConvenio)
					throws ErroRepositorioException{

		Collection<ArrecadadorContrato> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta;

		try{
			consulta = "SELECT ac " + "FROM ArrecadadorContrato ac " + "INNER JOIN ac.arrecadador arr "
							+ "WHERE arr.codigoAgente = :codigoAgente AND " + "ac.dataContratoEncerramento is null";

			if(cdConvenio != null && !cdConvenio.equals("")){
				consulta += " AND ac.codigoConvenioParcelamentoResposavel = :cdConvenio";

				retorno = (Collection<ArrecadadorContrato>) session.createQuery(consulta).setShort("codigoAgente", idArrecadador)
								.setString("cdConvenio", cdConvenio).list();
			}else{

				retorno = (Collection<ArrecadadorContrato>) session.createQuery(consulta).setShort("codigoAgente", idArrecadador).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * Verifica a Existência do Banco na Base de Dados @author Roberta Costa
	 * @created 23/02/2006
	 */
	public Integer verificarExistenciaBanco(Integer idBanco) throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "select banco.id " + "from Banco banco " + "where banco.id = :idBanco";

			retorno = (Integer) session.createQuery(consulta).setInteger("idBanco", idBanco.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/*
	 * Verifica a Existência da Agência bancária na Base de Dados @author
	 * Roberta Costa @created 23/02/2006
	 */
	public Integer verificarExistenciaAgencia(String codigoAgencia, Integer idBanco) throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "select agencia.id " + "from Agencia agencia "
							+ "where agencia.codigoAgencia = :codigoAgencia and agencia.banco.id = :idBanco";

			retorno = (Integer) session.createQuery(consulta).setString("codigoAgencia", codigoAgencia).setInteger("idBanco", idBanco)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa a agencia
	 * 
	 * @author Sávio Luiz
	 * @date 05/11/2007
	 * @return Agencia
	 * @throws ErroRepositorioException
	 */
	public Agencia pesquisarAgencia(String codigoAgencia, Integer idBanco) throws ErroRepositorioException{

		Agencia retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "select agencia " + "from Agencia agencia "
							+ "where agencia.codigoAgencia = :codigoAgencia and agencia.banco.id = :idBanco";

			retorno = (Agencia) session.createQuery(consulta).setString("codigoAgencia", codigoAgencia).setInteger("idBanco", idBanco)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro do movimento dos arrecadadores
	 * [UC0263] - Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Raphael Rossiter
	 * @date 02/03/2006
	 * @param filtroArrecadadorMovimento
	 * @return Uma coleção de objetos do tipo ArrecadadorMovimento de acordo com
	 *         os parâmetros recebidos através do filtro. Está consulta inclui
	 *         os movimentos abertos e fechados
	 * @throws ErroRepositorioException
	 */
	public Collection<ArrecadadorMovimento> filtrarMovimentoArrecadadores(FiltroArrecadadorMovimento filtroArrecadadorMovimento)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try{

			retorno = new ArrayList(new CopyOnWriteArrayList<ArrecadadorMovimento>(GeradorHQLCondicional.gerarCondicionalQuery(
							filtroArrecadadorMovimento,
							"gcom.arrecadacao.ArrecadadorMovimento",
							"arrecadadorMovimento",
							"SELECT DISTINCT arrecadadorMovimento " + "FROM ArrecadadorMovimento arrecadadorMovimento "
											+ "LEFT JOIN arrecadadorMovimento.arrecadadorMovimentoItens "
											+ FiltroArrecadadorMovimento.ALIAS_ARRECADADOR_MOVIMENTO_ITEM + "", session).list()));

			/*
			 * if
			 * (!filtroArrecadadorMovimento.getColecaoCaminhosParaCarregamentoEntidades().isEmpty())
			 * {
			 * PersistenciaUtil.processaObjetosParaCarregamento(filtroArrecadadorMovimento.
			 * getColecaoCaminhosParaCarregamentoEntidades(),
			 * retorno); }
			 */
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém o número de registros em ocorrência de um determinado movimento
	 * (número de linhas da tabela ARRECADADOR_MOVIMENTO_ITEM com ARMV_ID =
	 * ARMV_ID da tabela ARRECADADOR_MOVIMENTO e AMIT_DSOCORRENCIA diferente de
	 * "OK")
	 * 
	 * @author Raphael Rossiter
	 * @date 06/03/2006
	 * @param arrecadadorMovimento
	 * @return Um Integer que representa a quantidade de registros selecionados
	 * @throws ErroRepositorioException
	 */
	public Integer obterNumeroRegistrosEmOcorrenciaPorMovimentoArrecadadores(ArrecadadorMovimento arrecadadorMovimento,
					String descricaoOcorrencia) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT COUNT(*) " + "FROM ArrecadadorMovimentoItem amit " + "INNER JOIN amit.arrecadadorMovimento armv "
							+ "WHERE armv.id = :idArrecadadorMovimento " + "AND amit.descricaoOcorrencia <> :descricaoOcorrencia";

			retorno = ((Number) session.createQuery(consulta).setInteger("idArrecadadorMovimento", arrecadadorMovimento.getId()).setString(
							"descricaoOcorrencia", descricaoOcorrencia).setMaxResults(1).uniqueResult()).intValue();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém o número de registros que não foram aceitos de um determinado
	 * movimento (número de linhas da tabela ARRECADADOR_MOVIMENTO_ITEM com
	 * ARMV_ID = ARMV_ID da tabela ARRECADADOR_MOVIMENTO e AMIT_ICACEITACAO
	 * igual a 2 (NÃO))
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * @param arrecadadorMovimento
	 * @return Um integer que representa a quantidade de registros selecionados
	 * @throws ControladorException
	 */
	public Integer obterNumeroRegistrosNaoAceitosPorMovimentoArrecadadores(ArrecadadorMovimento arrecadadorMovimento,
					Short indicadorAceitacao) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT COUNT(*) " + "FROM ArrecadadorMovimentoItem amit " + "INNER JOIN amit.arrecadadorMovimento armv "
							+ "WHERE armv.id = :idArrecadadorMovimento " + "AND amit.indicadorAceitacao = :indicadorAceitacao";

			retorno = ((Number) session.createQuery(consulta).setInteger("idArrecadadorMovimento", arrecadadorMovimento.getId().intValue())
							.setInteger("indicadorAceitacao", indicadorAceitacao.intValue()).setMaxResults(1).uniqueResult()).intValue();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os avisos bancários de um determinado movimento
	 * 
	 * @author Raphael Rossiter
	 * @date 09/03/2006
	 * @param arrecadadorMovimento
	 * @return Uma Collection com os avisos bancários de um determinado
	 *         movimento
	 * @throws ErroRepositorioException
	 */
	public Collection<AvisoBancario> obterAvisosBancariosPorArrecadadorMovimento(ArrecadadorMovimento arrecadadorMovimento)
					throws ErroRepositorioException{

		Collection<AvisoBancario> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT avbc " + "FROM AvisoBancario avbc " + "INNER JOIN avbc.arrecadadorMovimento armv "
							+ "WHERE armv.id = :idArrecadadorMovimento ";

			retorno = session.createQuery(consulta).setInteger("idArrecadadorMovimento", arrecadadorMovimento.getId().intValue()).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Calcula o valor total das devoluções associados a um determinado aviso
	 * bancário (soma (DEVL_VLDEVOLUCAO) da tabela DEVOLUCAO com AVBC_ID =
	 * AVBC_ID da tabela AVISO_BANCARIO)
	 * 
	 * @author Raphael Rossiter
	 * @date 09/03/2006
	 * @param avisoBancario
	 * @return Um BigDecimal que representa o somatório de todos as devoluções
	 *         de um determinado aviso
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterTotalDevolucaoPorAvisoBancario(AvisoBancario avisoBancario) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT SUM(devl.valorDevolucao) " + "FROM Devolucao devl " + "INNER JOIN devl.avisoBancario avbc "
							+ "WHERE avbc.id = :idAvisoBancario ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idAvisoBancario", avisoBancario.getId().intValue())
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * O sistema seleciona os itens do movimento do arrecadador.
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author Raphael Rossiter,Vivianne Sousa
	 * @data 20/03/2006,05/12/2006
	 * @param arrecadadorMovimento
	 * @return Collection<ArrecadadorMovimentoItem>
	 */
	public Collection<ArrecadadorMovimentoItem> consultarItensMovimentoArrecadador(ArrecadadorMovimento arrecadadorMovimento,
					Integer idImovel, Short indicadorAceitacao, String descricaoOcorrencia) throws ErroRepositorioException{

		Collection<ArrecadadorMovimentoItem> retorno = new ArrayList<ArrecadadorMovimentoItem>();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT amit " + "FROM ArrecadadorMovimentoItem amit " + "INNER JOIN FETCH amit.registroCodigo rgcd "
							+ "INNER JOIN amit.arrecadadorMovimento armv " + "WHERE armv.id = :idArrecadadorMovimento ";

			if(idImovel != null && !idImovel.equals("")){
				consulta = consulta + " AND amit.imovel.id = " + idImovel;
			}

			if(indicadorAceitacao != null && !indicadorAceitacao.equals("")){
				consulta = consulta + " AND amit.indicadorAceitacao = " + indicadorAceitacao;
			}

			if(descricaoOcorrencia != null && !descricaoOcorrencia.equals("")){
				if(descricaoOcorrencia.equals("" + ConstantesSistema.SEM_ITENS)){
					// sem itens em ocorrência
					consulta = consulta + " AND amit.descricaoOcorrencia = 'OK' ";
				}else{
					// com itens em ocorrência
					consulta = consulta + " AND amit.descricaoOcorrencia <> 'OK' ";
				}
			}
			consulta = consulta + " order by amit.id ";

			retorno = session.createQuery(consulta).setInteger("idArrecadadorMovimento", arrecadadorMovimento.getId()).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * O sistema seleciona os itens do movimento do arrecadador.
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author Raphael Rossiter,Vivianne Sousa, Kassia Albuquerque
	 * @data 20/03/2006,05/12/2006,22/08/2007
	 * @param arrecadadorMovimento
	 * @return Collection<ArrecadadorMovimentoItem>
	 */
	public Collection<ArrecadadorMovimentoItem> consultarItensMovimentoArrecadador(ArrecadadorMovimento arrecadadorMovimento,
					Integer idImovel, Short indicadorAceitacao, String descricaoOcorrencia, String codigoArrecadacaoForma)
					throws ErroRepositorioException{

		Collection<ArrecadadorMovimentoItem> retorno = new ArrayList<ArrecadadorMovimentoItem>();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT amit " + "FROM ArrecadadorMovimentoItem amit " + "INNER JOIN FETCH amit.registroCodigo rgcd "
							+ "INNER JOIN amit.arrecadadorMovimento armv " + "WHERE armv.id = :idArrecadadorMovimento ";

			if(idImovel != null && !idImovel.equals("")){
				consulta = consulta + " AND amit.imovel.id = " + idImovel;
			}

			if(indicadorAceitacao != null && !indicadorAceitacao.equals("")){
				consulta = consulta + " AND amit.indicadorAceitacao = " + indicadorAceitacao;
			}

			if(descricaoOcorrencia != null && !descricaoOcorrencia.equals("")){
				if(descricaoOcorrencia.equals("" + ConstantesSistema.SEM_ITENS)){
					// sem itens em ocorrência
					consulta = consulta + " AND amit.descricaoOcorrencia = 'OK' ";
				}else{
					// com itens em ocorrência
					consulta = consulta + " AND amit.descricaoOcorrencia <> 'OK' ";
				}
			}

			// ------------- Forma de Arrecadação -------- Kassia Albuquerque
			if(codigoArrecadacaoForma != null && !codigoArrecadacaoForma.equals("")){
				if(codigoArrecadacaoForma.equalsIgnoreCase("1")){

					consulta = consulta
									+ " AND ( substr(amit.conteudoRegistro, 117,1) =  '1' OR substr(amit.conteudoRegistro, 117,1) is null )"
									+ "AND rgcd.id = 7";

				}else if(codigoArrecadacaoForma.equalsIgnoreCase("Z")){

					consulta = consulta + " AND rgcd.id = 6 OR (rgcd.id = 7 AND substr(amit.conteudoRegistro, 117,1) = 'Z')";

				}else if(codigoArrecadacaoForma.equalsIgnoreCase("W")){

					consulta = consulta + " AND rgcd.id = 19 AND substr(amit.conteudoRegistro, 8,1) = '3')";

				}else{

					consulta = consulta + " AND rgcd.id = 7 AND substr(amit.conteudoRegistro, 117,1) = '" + codigoArrecadacaoForma + "'";

				}

			}

			retorno = session.createQuery(consulta).setInteger("idArrecadadorMovimento", arrecadadorMovimento.getId()).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz a pesquisa de devolução fazendo os carregamentos de clienteContas,
	 * clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * @param FiltroDevolucao
	 * @return Collection<Devolucao>
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucao(FiltroDevolucao filtroDevolucao) throws ErroRepositorioException{

		Collection<Devolucao> retorno = null;

		Session session = HibernateUtil.getSession();

		try{

			retorno = new ArrayList(new CopyOnWriteArrayList<Devolucao>(GeradorHQLCondicional.gerarCondicionalQuery(filtroDevolucao,
							"gcom.arrecadacao.Devolucao", "devolucao", "SELECT DISTINCT devolucao " + "FROM Devolucao devolucao " + "",
							session).list()));

			if(!Util.isVazioOrNulo(retorno)){
				for(Devolucao devolucao : retorno){
					Hibernate.initialize(devolucao.getGuiaDevolucao());

					if(devolucao.getGuiaDevolucao() != null){
						Hibernate.initialize(devolucao.getGuiaDevolucao().getContaGeral());

						if(devolucao.getGuiaDevolucao().getContaGeral() != null){
							if(devolucao.getGuiaDevolucao().getContaGeral().getIndicadorHistorico() == ConstantesSistema.SIM.shortValue()){
								Hibernate.initialize(devolucao.getGuiaDevolucao().getContaGeral().getContaHistorico());
							}else{
								Hibernate.initialize(devolucao.getGuiaDevolucao().getContaGeral().getConta());

								if(devolucao.getGuiaDevolucao().getContaGeral().getConta() != null){
									Hibernate.initialize(devolucao.getGuiaDevolucao().getContaGeral().getConta().getClienteContas());
								}
							}
						}

						Hibernate.initialize(devolucao.getGuiaDevolucao().getDocumentoTipo());

						Hibernate.initialize(devolucao.getGuiaDevolucao().getGuiaPagamentoGeral());

						if(devolucao.getGuiaDevolucao().getGuiaPagamentoGeral() != null){
							if(devolucao.getGuiaDevolucao().getGuiaPagamentoGeral().getIndicadorHistorico() == ConstantesSistema.SIM
											.shortValue()){
								Hibernate.initialize(devolucao.getGuiaDevolucao().getGuiaPagamentoGeral().getGuiaPagamentoHistorico());
							}else{
								Hibernate.initialize(devolucao.getGuiaDevolucao().getGuiaPagamentoGeral().getGuiaPagamento());

								if(devolucao.getGuiaDevolucao().getGuiaPagamentoGeral().getGuiaPagamento() != null){
									Hibernate.initialize(devolucao.getGuiaDevolucao().getGuiaPagamentoGeral().getGuiaPagamento()
													.getClientesGuiaPagamento());
								}
							}
						}
					}

					Hibernate.initialize(devolucao.getImovel());

					if(devolucao.getImovel() != null){
						Hibernate.initialize(devolucao.getImovel().getClienteImoveis());
						Hibernate.initialize(devolucao.getImovel().getLocalidade());

						if(devolucao.getImovel().getLocalidade() != null){
							Hibernate.initialize(devolucao.getImovel().getLocalidade().getGerenciaRegional());
						}

						Hibernate.initialize(devolucao.getImovel().getSetorComercial());
						Hibernate.initialize(devolucao.getImovel().getQuadra());
					}

					Hibernate.initialize(devolucao.getDebitoTipo());

					Hibernate.initialize(devolucao.getAvisoBancario());

					if(devolucao.getAvisoBancario() != null){
						Hibernate.initialize(devolucao.getAvisoBancario().getArrecadador());

						if(devolucao.getAvisoBancario().getArrecadador() != null){
							Hibernate.initialize(devolucao.getAvisoBancario().getArrecadador().getCliente());
						}
					}

					Hibernate.initialize(devolucao.getDevolucaoSituacaoAtual());
				}
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Rafael Corrêa
	 * @date 21/12/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Collection<Pagamento> pesquisarPagamentoImovel(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = new HashSet<Pagamento>();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal,
							indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = " select distinct pagamento " 
							+ " from gcom.arrecadacao.pagamento.Pagamento pagamento "
							+ " INNER JOIN FETCH pagamento.avisoBancario avbc " 
							+ " INNER JOIN FETCH avbc.arrecadador arrec "
							+ " INNER JOIN FETCH arrec.cliente clie " 
							+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp "
							+ " LEFT JOIN FETCH pagamento.conta conta " 
							+ " LEFT JOIN FETCH pagamento.guiaPagamentoGeral gpagGeral "
							+ " LEFT JOIN FETCH gpagGeral.guiaPagamento gpag "
							+ " LEFT JOIN FETCH gpag.guiasPagamentoPrestacao gPagPrestacao "
							+ " LEFT JOIN FETCH gPagPrestacao.debitoTipo debitoTipo "
							+ " LEFT JOIN FETCH gpag.guiasPagamentoPrestacaoHistorico gPagPrestacaoHistorico "

							+ " LEFT JOIN FETCH gpagGeral.guiaPagamentoHistorico gpagHist "
							+ " LEFT JOIN FETCH gpag.guiasPagamentoPrestacao gpagGppr "
							+ " LEFT JOIN FETCH gpagHist.guiasPagamentoPrestacaoHistorico gpagGpprHist "
							+ " LEFT JOIN FETCH pagamento.debitoACobrar dbcb " + " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
							+ " LEFT JOIN FETCH pagamento.debitoTipo dbtp "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ " LEFT JOIN pagamento.imovel.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem"
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb " + condicionais
							+ "  order by pagamento.localidade.id, pagamento.imovel.id, "
							+ "           pagamento.anoMesReferenciaPagamento, pagamento.dataPagamento " + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Exclui os dados diários da arrecadação do ano/mês da arrecadação corrente
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 11/04/2006
	 * @param anoMesReferenciaArrecadacao
	 * @throws ErroRepositorioException
	 */
	public void excluirDadosDiariosArrecadacaoPorAnoMesArrecadacao(int anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try{

			// Constroi o hql para remover os dados diários da arrecadação
			// referentes ao ano/mês de arrecadação atual
			consulta = "delete ArrecadacaoDadosDiarios ardd where ardd.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao";

			// Executa o hql
			session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).executeUpdate();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Exclui os dados diários da arrecadação do ano/mês da arrecadação corrente
	 * por localidade
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 11/04/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 */
	public void excluirDadosDiariosArrecadacaoPorAnoMesArrecadacaoPorLocalidade(int anoMesReferenciaArrecadacao, Integer idLocalidade)
					throws ErroRepositorioException{

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try{

			// Constroi o hql para remover os dados diários da arrecadação
			// referentes ao ano/mês de arrecadação atual
			consulta = "delete ArrecadacaoDadosDiarios ardd where ardd.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao and ardd.localidade.id = :idLocalidade";

			// Executa o hql
			session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger("idLocalidade",
							idLocalidade).executeUpdate();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Acumula a quantidade e o valor dos pagamentos com ano/mês de referência
	 * da arrecadação igual ao ano/mês de referência da arrecadação corrente
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 11/04/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return Collection<Object>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object> acumularQuantidadeEValorPagamentoPorAnoMesArrecadacao(int anoMesReferenciaArrecadacao, Integer idLocalidade)
					throws ErroRepositorioException{

		// Cria a variávelque vai armazenar a coleção de pagamentos
		Collection<Object> retorno = new ArrayList<Object>();

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try{

			// Cria o hql para acumular o valor e quantidade de pagamentos
			consulta = "SELECT imov.id, " // 0
							+ "SUM(pgmt.valorPagamento), " // 1
							+ "COUNT(pgmt.id), " // 2
							+ "stcm.id, " // 3
							+ "stcm.codigo, " // 4
							+ "rota.id, " // 5
							+ "qdra.id, " // 6
							+ "qdra.numeroQuadra, " // 7
							+ "iper.id, " // 8
							+ "last.id, " // 9
							+ "lest.id, " // 10
							+ "greg.id, " // 11
							+ "avbc.id, " // 12
							+ "arrc.id, " // 13
							+ "dotp.id, " // 14
							+ "arfm.id, " // 15
							+ "pgmt.dataPagamento, "// 16
							+ "uneg.id " // 17
							+ "FROM Pagamento pgmt "
							+ "LEFT JOIN pgmt.avisoBancario avbc "
							+ "LEFT JOIN avbc.arrecadador arrc "
							+ "LEFT JOIN pgmt.documentoTipo dotp "
							+ "LEFT JOIN pgmt.arrecadacaoForma arfm "
							+ "LEFT JOIN pgmt.localidade loca "
							+ "LEFT JOIN loca.unidadeNegocio uneg "
							+ "LEFT JOIN loca.gerenciaRegional greg "
							+ "LEFT JOIN pgmt.imovel imov "
							+ "LEFT JOIN imov.setorComercial stcm "
							+ "LEFT JOIN imov.quadra qdra "
							+ "LEFT JOIN imov.rota rota "
							+ "LEFT JOIN imov.imovelPerfil iper "
							+ "LEFT JOIN imov.ligacaoAguaSituacao last "
							+ "LEFT JOIN imov.ligacaoEsgotoSituacao lest "
							+ "WHERE pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao AND loca.id = :idLocalidade "
							+ "GROUP BY imov.id, stcm.id, stcm.codigo, rota.id, qdra.id, qdra.numeroQuadra, iper.id, last.id, lest.id, "
							+ "greg.id, avbc.id, arrc.id, dotp.id, arfm.id, pgmt.dataPagamento, uneg.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de pagamentos
		return retorno;
	}

	/**
	 * Acumula a quantidade e o valor dos pagamentos com ano/mês de referência
	 * da arrecadação igual ao ano/mês de referência da arrecadação corrente do PagamentoHistórico
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Saulo Lima
	 * @date 19/01/2009
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return Collection<Object>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object> acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoDoHistorico(int anoMesReferenciaArrecadacao,
					Integer idLocalidade) throws ErroRepositorioException{

		// Cria a variávelque vai armazenar a coleção de pagamentos
		Collection<Object> retorno = new ArrayList<Object>();

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta;

		try{

			// Cria o hql para acumular o valor e quantidade de pagamentos
			consulta = "SELECT imov.id, " // 0
							+ "SUM(pagamentoHistorico.valorPagamento), " // 1
							+ "COUNT(pagamentoHistorico.id), " // 2
							+ "stcm.id, " // 3
							+ "stcm.codigo, " // 4
							+ "rota.id, " // 5
							+ "qdra.id, " // 6
							+ "qdra.numeroQuadra, " // 7
							+ "iper.id, " // 8
							+ "last.id, " // 9
							+ "lest.id, " // 10
							+ "greg.id, " // 11
							+ "avbc.id, " // 12
							+ "arrc.id, " // 13
							+ "dotp.id, " // 14
							+ "arfm.id, " // 15
							+ "pagamentoHistorico.dataPagamento, "// 16
							+ "uneg.id " // 17
							+ "FROM PagamentoHistorico pagamentoHistorico "
							+ "LEFT JOIN pagamentoHistorico.avisoBancario avbc "
							+ "LEFT JOIN avbc.arrecadador arrc "
							+ "LEFT JOIN pagamentoHistorico.documentoTipo dotp "
							+ "LEFT JOIN pagamentoHistorico.arrecadacaoForma arfm "
							+ "LEFT JOIN pagamentoHistorico.localidade loca "
							+ "LEFT JOIN loca.unidadeNegocio uneg "
							+ "LEFT JOIN loca.gerenciaRegional greg "
							+ "LEFT JOIN pagamentoHistorico.imovel imov "
							+ "LEFT JOIN imov.setorComercial stcm "
							+ "LEFT JOIN imov.quadra qdra "
							+ "LEFT JOIN imov.rota rota "
							+ "LEFT JOIN imov.imovelPerfil iper "
							+ "LEFT JOIN imov.ligacaoAguaSituacao last "
							+ "LEFT JOIN imov.ligacaoEsgotoSituacao lest "
							+ "WHERE pagamentoHistorico.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao AND loca.id = :idLocalidade "
							+ "GROUP BY imov.id, stcm.id, stcm.codigo, rota.id, qdra.id, qdra.numeroQuadra, iper.id, last.id, lest.id, "
							+ "greg.id, avbc.id, arrc.id, dotp.id, arfm.id, pagamentoHistorico.dataPagamento, uneg.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de pagamentos
		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a pagamento classificado (tabela PAGAMENTO_SITUACAO) e
	 * atualiza o id da conta nos pagamentos (seta CNTA_ID da tabela PAGAMENTO
	 * para CNTA_ID da tabela CONTA)
	 * [SF0002] Processar Pagamento de Conta
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 19/04/2006, 06/12/2006
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Modificando de Map para Collection
	 * @param colecaoPagamentosProcessados
	 * @param idConta
	 * @return void
	 */
	public void processarPagamentoConta(Collection<Pagamento> colecaoPagamentosProcessados, Integer idConta)
					throws ErroRepositorioException{

		// System.out.println("conta id" + idConta);

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();
		StringBuffer processarPagamentoConta = new StringBuffer("UPDATE Pagamento pgmt ");
		processarPagamentoConta.append(" SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, ");
		processarPagamentoConta.append(" pgmt.conta.id = :conta, pgmt.valorExcedente = :valorExcedente, ");
		processarPagamentoConta.append(" pgmt.ultimaAlteracao = :dataAlteracao ");
		processarPagamentoConta.append(" WHERE pgmt IN (:idsPagamentos)");

		try{

			session.createQuery(processarPagamentoConta.toString()).setInteger("pagamentoSituacao",
							PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("conta", idConta).setBigDecimal("valorExcedente",
							BigDecimal.ZERO).setTimestamp("dataAlteracao", new Date()).setParameterList("idsPagamentos",
							colecaoPagamentosProcessados).executeUpdate();

			session.flush();
			session.clear();
		}catch(Exception e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
			processarPagamentoConta = null;
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualiza a situacao atual dos pagamentos (PGST_IDATUAL) (tabela
	 * PAGAMENTO_SITUACAO)
	 * [SF0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter
	 * @date 19/04/2006
	 * @param idsPagamentos
	 * @return void
	 */
	public void atualizarSituacaoPagamento(String[] idsPagamentos, Integer pagamentoSituacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try{

			// System.out.println("################### ATUALIZANDO SITUACAO ");

			atualizarSituacaoPagamento = "UPDATE Pagamento "
							+ "SET pgst_idatual = :pagamentoSituacao, pgmt_tmultimaalteracao = :dataAlteracao "
							+ "WHERE pgmt_id IN(:idsPagamentos)";

			session.createQuery(atualizarSituacaoPagamento).setInteger("pagamentoSituacao", pagamentoSituacao).setTimestamp(
							"dataAlteracao", new Date()).setParameterList("idsPagamentos", idsPagamentos).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualiza a situacao atual dos pagamentos (PGST_IDATUAL) (tabela
	 * PAGAMENTO_SITUACAO)
	 * [SF0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 19/04/2006, 30/11/2006
	 * @param colecaoIdsPagamentos
	 * @param pagamentoSituacao
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoPagamento(Collection colecaoIdsPagamentos, Integer pagamentoSituacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		// Iterator iteratorPagamentos = colecaoIdsPagamentos.iterator();
		String atualizarSituacaoPagamento;
		// String idPagamento = null;
		try{
			// System.out.println("################### ATUALIZANDO SITUACAO ");

			atualizarSituacaoPagamento = "UPDATE Pagamento "
							+ "SET pgst_idatual = :pagamentoSituacao, pgmt_tmultimaalteracao = :dataAlteracao "
							+ "WHERE pgmt_id in(:idsPagamentos)";

			session.createQuery(atualizarSituacaoPagamento).setInteger("pagamentoSituacao", pagamentoSituacao).setTimestamp(
							"dataAlteracao", new Date()).setParameterList("idsPagamentos", colecaoIdsPagamentos).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualiza a situacao anterior dos pagamentos (PGST_IDANTERIOR) (tabela
	 * PAGAMENTO_SITUACAO)
	 * [SF0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter
	 * @date 19/04/2006
	 * @param idsPagamentos
	 * @return void
	 */
	public void atualizarSituacaoAnteriorPagamento(String[] idsPagamentos, Integer pagamentoSituacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try{

			atualizarSituacaoPagamento = "UPDATE Pagamento "
							+ "SET pgst_idanterior = :pagamentoSituacao, pgmt_tmultimaalteracao = :dataAlteracao "
							+ "WHERE pgmt_id IN(:idsPagamentos)";

			session.createQuery(atualizarSituacaoPagamento).setInteger("pagamentoSituacao", pagamentoSituacao).setTimestamp(
							"dataAlteracao", new Date()).setParameterList("idsPagamentos", idsPagamentos).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualiza a situacao atual das devolucoes (DVST_IDATUAL) com valor
	 * correspondente a pagamento em duplicidade não encontrado (tabela
	 * DEVOLUCAO_SITUACAO)
	 * [SF0011] Processar Devoluções de Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 15/06/2006
	 * @param idsDevolucoes
	 * @return void
	 */
	public void atualizarSituacaoDevolucao(String[] idsDevolucao, Integer devolucaoSituacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoDevolucao;

		try{

			atualizarSituacaoDevolucao = "UPDATE Devolucao "
							+ "SET dvst_idatual = :devolucaoSituacao, devl_tmultimaalteracao = :dataAlteracao "
							+ "WHERE devl_id IN(:idsDevolucao)";

			session.createQuery(atualizarSituacaoDevolucao).setInteger("devolucaoSituacao", devolucaoSituacao).setTimestamp(
							"dataAlteracao", new Date()).setParameterList("idsDevolucao", idsDevolucao).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * obtêm uma Devolucao
	 * 
	 * @param devolucao
	 * @return Devolucao
	 * @throws ErroRepositorioException
	 */
	public Devolucao obterDevolucao(Devolucao devolucao) throws ErroRepositorioException{

		Devolucao retorno = new Devolucao();
		Session session = HibernateUtil.getSession();

		try{
			Criteria criteria = session.createCriteria(Devolucao.class).add(Restrictions.eq("id", devolucao.getId()));

			return retorno = (Devolucao) criteria.uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualizar Valor Excedente do Pagamento
	 * [SF0009] Atualizar Valor Excedente do Pagamento
	 * 
	 * @author Raphael Rossiter
	 * @date 25/04/2006
	 * @param pagamento
	 * @return void
	 */
	public void atualizarValorExcedentePagamento(Pagamento pagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuffer atualizarValorExcedente = new StringBuffer();

		try{
			// System.out.println("################### ATUALIZANDO VALOR EXCEDENTE ");

			atualizarValorExcedente.append("UPDATE Pagamento ").append(
							"SET pgmt_vlexcedente = :valorExcedente, pgmt_tmultimaalteracao = :dataAlteracao ").append(
							"WHERE pgmt_id = :idPagamento ");

			session.createQuery(atualizarValorExcedente.toString()).setBigDecimal("valorExcedente", pagamento.getValorExcedente())
							.setTimestamp("dataAlteracao", new Date()).setInteger("idPagamento", pagamento.getId()).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualizar Valor Excedente do Pagamento
	 * [SF0009] Atualizar Valor Excedente do Pagamento
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 25/04/2006, 29/11/2006
	 * @param colecaoPagamento
	 * @return void
	 */
	public void atualizarValorExcedentePagamento(Collection<Pagamento> colecaoPagamento) throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		String atualizarValorExcedente;
		Pagamento pagamento = null;

		try{
			Iterator iteratorPagamentos = colecaoPagamento.iterator();

			atualizarValorExcedente = "UPDATE Pagamento pgmt " + "SET pgmt.valorExcedente = :valorExcedente, "
							+ "pgmt.ultimaAlteracao = :dataAlteracao " + "WHERE pgmt.id = :idPagamento ";

			int i = 1;
			while(iteratorPagamentos.hasNext()){
				pagamento = (Pagamento) iteratorPagamentos.next();

				// System.out.println("################### ATUALIZANDO VALOR EXCEDENTE : " + i);

				session.createQuery(atualizarValorExcedente).setBigDecimal("valorExcedente", pagamento.getValorExcedente()).setTimestamp(
								"dataAlteracao", new Date()).setInteger("idPagamento", pagamento.getId()).executeUpdate();

				if(i % 50 == 0){
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a pagamento classificado (tabela PAGAMENTO_SITUACAO) e
	 * atualiza o id da guia de pagamento nos pagamentos (seta GPAG_ID da tabela
	 * PAGAMENTO para GPAG_ID da tabela GUIA_PAGAMENTO)
	 * [SF0004] Processar Pagamento de Guia de Pagamento
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 26/04/2006, 11/12/2006
	 * @author Saulo Lima
	 * @date 25/11/2008
	 *       Atualizar o campo NumeroPrestacao
	 * @param mapPagamentosProcessados
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoGuiaPagamento(Map<Integer, Collection> mapPagamentosProcessados, Integer numeroPrestacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{

			String processarPagamentoGuiaPagamento = "UPDATE Pagamento " + "SET pgst_idatual = :pagamentoSituacao, "
							+ "gpag_id = :guiaPagamento, pgmt_nnPrestacao = :numeroPrestacao, "
							+ "pgmt_tmultimaalteracao = :dataAlteracao " + "WHERE pgmt_id IN(:idsPagamentos)";

			Collection colecaoIdsGuias = mapPagamentosProcessados.keySet();
			Iterator iteratorIdsGuias = colecaoIdsGuias.iterator();

			int i = 1;

			while(iteratorIdsGuias.hasNext()){
				// System.out.println("PROCESSANDO PAGAMENTOS GUIA....");
				Integer idGuiaPagamento = (Integer) iteratorIdsGuias.next();

				Collection colecaoIdsPagamentos = mapPagamentosProcessados.get(idGuiaPagamento);

				session.createQuery(processarPagamentoGuiaPagamento).setInteger("pagamentoSituacao",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("guiaPagamento", idGuiaPagamento).setTimestamp(
								"dataAlteracao", new Date()).setInteger("numeroPrestacao", numeroPrestacao).setParameterList(
								"idsPagamentos", colecaoIdsPagamentos).executeUpdate();

				if(i % 50 == 0){
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor correspondente a pagamento
	 * classificado (tabela PAGAMENTO_SITUACAO) e
	 * atualiza o id do débito a cobrar nos pagamentos (seta DBAC_ID da tabela PAGAMENTO para
	 * DBAC_ID da tabela DEBITO_A_COBRAR)
	 * [SF0004] Processar Pagamento de Débito a Cobrar
	 * 
	 * @author Raphael Rossiter ,Pedro Alexandre
	 * @date 27/04/2006, 12/12/2006
	 * @param mapPagamentosProcessados
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoDebitoACobrar(Map<Integer, Collection> mapPagamentosProcessados) throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		try{

			String processarPagamentoGuiaPagamento = "UPDATE Pagamento pgmt " + "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
							+ "pgmt.debitoACobrar.id = :debitoACobrar, " + "pgmt.ultimaAlteracao = :dataAlteracao "
							+ "WHERE pgmt IN(:idsPagamentos)";

			Collection colecaoIdsDebitosACobrar = mapPagamentosProcessados.keySet();
			Iterator iteratorIdsDebitosACobrar = colecaoIdsDebitosACobrar.iterator();

			int i = 1;

			while(iteratorIdsDebitosACobrar.hasNext()){
				// System.out.println("PROCESSANDO PAGAMENTOS DEBITO....");
				Integer idDebitoACobrar = (Integer) iteratorIdsDebitosACobrar.next();

				Collection colecaoIdsPagamentos = mapPagamentosProcessados.get(idDebitoACobrar);

				session.createQuery(processarPagamentoGuiaPagamento).setInteger("pagamentoSituacao",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("debitoACobrar", idDebitoACobrar).setTimestamp(
								"dataAlteracao", new Date()).setParameterList("idsPagamentos", colecaoIdsPagamentos).executeUpdate();

				if(i % 50 == 0){
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona a guia de pagamento correspondente ao pagamento
	 * através do imóvel, cliente e do tipo de débito (a partir da tabela
	 * GUIA_PAGAMENTO com IMOV_ID, CLIE_ID e DBTP_ID da tabela PAGAMENTO e
	 * DCST_IDATUAL com valor correspondente a normal da tabela
	 * DEBITO_CREDITO_SITUACAO)
	 * [SF0003] Selecionar Guia de Pagamento pela Localidade, Imóvel, Cliente e
	 * Débito Tipo
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 26/04/2006, 14/03/2007, 05/06/2007, 02/10/2007
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Removendo parâmetro não utilizado
	 * @param imovel
	 * @param cliente
	 * @param debitoTipo
	 * @return Collection<GuiaPagamento>
	 */
	public Collection<GuiaPagamento> selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(Imovel imovel, Cliente cliente,
					DebitoTipo debitoTipo) throws ErroRepositorioException{

		Collection<GuiaPagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			if(imovel != null && debitoTipo != null){
				consulta = "SELECT DISTINCT guiaPagamento " + "FROM GuiaPagamento guiaPagamento "
								+ "LEFT JOIN FETCH guiaPagamento.guiasPagamentoPrestacao gpagGppr "
								+ "LEFT JOIN FETCH gpagGppr.debitoTipo debitoTipo " + "WHERE guiaPagamento.imovel.id = :idImovel "
								+ "AND debitoTipo.id = :idDebitoTipo "
								+ "AND guiaPagamento.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao";

				retorno = session.createQuery(consulta).setInteger("idImovel", imovel.getId()).setInteger("idDebitoTipo",
								debitoTipo.getId()).setInteger("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL).list();

			}else if(cliente != null && debitoTipo != null){
				consulta = "SELECT DISTINCT guiaPagamento " + "FROM GuiaPagamento guiaPagamento "
								+ "LEFT JOIN FETCH guiaPagamento.guiasPagamentoPrestacao gpagGppr "
								+ "LEFT JOIN FETCH gpagGppr.debitoTipo debitoTipo " + "WHERE guiaPagamento.cliente.id = :idCliente "
								+ "AND debitoTipo.id = :idDebitoTipo "
								+ "AND guiaPagamento.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao";

				retorno = session.createQuery(consulta).setInteger("idCliente", cliente.getId()).setInteger("idDebitoTipo",
								debitoTipo.getId()).setInteger("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona o débito a cobrar correspondente ao pagamento através
	 * do imóvel e do tipo de débito (a partir da tabela DEBITO_A_COBRAR com
	 * IMOV_ID e DBTP_ID da tabela PAGAMENTO e DCST_IDATUAL com valor
	 * correspondente a normal da tabela DEBITO_CREDITO_SITUACAO)
	 * [SF0005] Selecionar Débito a Cobrar pela Localidade, Imóvel e Débito Tipo
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 26/04/2006, 05/06/2007, 02/10/2007
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Removendo parâmetro não utilizado
	 * @param imovel
	 * @param debitoTipo
	 * @return Collection<DebitoACobrar>
	 */
	public Collection<DebitoACobrar> selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(Imovel imovel, DebitoTipo debitoTipo)
					throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "SELECT debitoACobrar FROM DebitoACobrar debitoACobrar " + "WHERE debitoACobrar.imovel.id = :idImovel "
							+ "AND debitoACobrar.debitoTipo.id = :idDebitoTipo "
							+ "AND debitoACobrar.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao "
							+ "ORDER BY debitoACobrar.geracaoDebito";

			retorno = session.createQuery(consulta).setInteger("idImovel", imovel.getId()).setInteger("idDebitoTipo", debitoTipo.getId())
							.setInteger("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SF0010] Selecionar Pagamentos não Classificados de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 26/04/2006
	 * @param imovel
	 *            ,
	 *            anoMesReferenciaDevolucao
	 * @return Collection<Pagamento>
	 */
	public Collection<Pagamento> selecionarPagamentosNaoClassificadosConta(Imovel imovel, Integer anoMesReferenciaDevolucao)
					throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			if(anoMesReferenciaDevolucao != null){
				consulta = "SELECT pgmt FROM Pagamento pgmt "
								+ "WHERE pgmt.imovel.id = :idImovel AND pgmt.anoMesReferenciaPagamento = :anoMesReferenciaDevolucao "
								+ "AND pgmt.pagamentoSituacaoAtual.id NOT IN(:classificado, :movimentoAberto)";

				retorno = session.createQuery(consulta).setInteger("idImovel", imovel.getId()).setInteger("anoMesReferenciaDevolucao",
								anoMesReferenciaDevolucao).setInteger("classificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
								"movimentoAberto", PagamentoSituacao.MOVIMENTO_ABERTO).list();
			}else{
				consulta = "SELECT pgmt FROM Pagamento pgmt " + "WHERE pgmt.imovel.id = :idImovel "
								+ "AND pgmt.pagamentoSituacaoAtual.id NOT IN(:classificado, :movimentoAberto)";

				retorno = session.createQuery(consulta).setInteger("idImovel", imovel.getId()).setInteger("classificado",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("movimentoAberto", PagamentoSituacao.MOVIMENTO_ABERTO)
								.list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SF0012] Selecionar Pagamentos não classificados de guia de pagamento ou
	 * débito a cobrar
	 * 
	 * @author Raphael Rossiter
	 * @date 15/06/2006
	 * @param imovel
	 *            ,
	 *            anoMesReferenciaDevolucao
	 * @return Collection<Pagamento>
	 */
	public Collection<Pagamento> selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(Imovel imovel, Cliente cliente,
					DebitoTipo debitoTipo) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "SELECT pgmt FROM Pagamento pgmt " + "WHERE pgmt.imovel.id = :idImovel AND pgmt.cliente.id = :idCliente AND "
							+ " pgmt.debitoTipo.id = :idDebitoTipo "
							+ "AND pgmt.pagamentoSituacaoAtual.id NOT IN(:classificado, :movimentoAberto)";

			retorno = session.createQuery(consulta).setInteger("idImovel", imovel.getId()).setInteger("idCliente", cliente.getId())
							.setInteger("idDebitoTipo", debitoTipo.getId()).setInteger("classificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("movimentoAberto",
											PagamentoSituacao.MOVIMENTO_ABERTO).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o tipo do documento correspondente a
	 * conta
	 * 
	 * @author Raphael Rossiter
	 * @data 18/04/2006
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Pagamento>
	 */
	public Collection<Object[]> pesquisarPagamentosPorConta(Integer anoMesReferencia) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id " + "FROM Pagamento pgmt " + "LEFT JOIN pgmt.documentoTipo dotp "
							+ "LEFT JOIN pgmt.localidade loca " + "LEFT JOIN pgmt.imovel imov "
							+ "LEFT JOIN pgmt.pagamentoSituacaoAtual pgst "
							+ "WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND dotp.id = :conta "
							+ "ORDER BY loca.id, imov.id, pgmt.anoMesReferenciaPagamento, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("conta",
							DocumentoTipo.CONTA).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * -------------------------------------------------------------------
	 * 
	 * @deprecated JNS 06/10/2010
	 * @see pesquisarPagamentosPorContaMovimentoArrecadadores
	 *      -------------------------------------------------------------------
	 *      [UC0300] Classificar Pagamentos e Devoluções
	 *      O sistema seleciona os pagamentos com ano/mês de referência da
	 *      arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 *      corrente (seleciona a partir da tabela PAGAMENTO para
	 *      PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 *      PARM_AMREFERENCIAARRECADACAO) e com o tipo do documento correspondente a
	 *      conta
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 28/11/2006
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Removendo parâmetro não utilizado e order by
	 * @param idImovel
	 * @param anoMesReferenciaPagamento
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarPagamentosPorConta(Integer idImovel, Integer anoMesReferenciaPagamento)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta
							.append(
											"SELECT pgmt.id, pgmt.documentoTipo.id, pgmt.localidade.id, pgmt.valorPagamento, pgst.id, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento, pgmt.avisoBancario ")
							.append("FROM Pagamento pgmt ").append("LEFT JOIN pgmt.imovel imov ").append(
											"LEFT JOIN pgmt.pagamentoSituacaoAtual pgst ").append(
											"WHERE imov.id = :idImovel AND pgmt.anoMesReferenciaPagamento = :anoMesReferenciaPagamento ");
			// + "ORDER BY imov.id, pgmt.anoMesReferenciaPagamento, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta.toString()).setInteger("idImovel", idImovel).setInteger("anoMesReferenciaPagamento",
							anoMesReferenciaPagamento).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarPagamentosPorContaNovo(Integer idImovel, Integer anoMesReferenciaPagamento) throws ErroRepositorioException{

		Collection<Pagamento> listaResultado = new ArrayList<Pagamento>();

		Session sessao = HibernateUtil.getSession();
		try{
			StringBuffer hql = new StringBuffer(
							"select p from Pagamento p join fetch p.imovel i join fetch i.setorComercial join fetch i.quadra where p.imovel.id =:idImovel and p.anoMesReferenciaPagamento =:anoMesReferenciaPagamento");
			// StringBuffer hql = new
			// StringBuffer("select p from Pagamento p where p.imovel.id =:idImovel and p.anoMesReferenciaPagamento =:anoMesReferenciaPagamento");
			Query qry = sessao.createQuery(hql.toString()).setInteger("idImovel", idImovel).setInteger("anoMesReferenciaPagamento",
							anoMesReferenciaPagamento);
			listaResultado = qry.list();
			// for(Pagamento p : listaResultado){
			// Hibernate.initialize(p.getImovel());
			// Hibernate.initialize(p.getImovel().getSetorComercial());
			// Hibernate.initialize(p.getImovel().getQuadra());
			// Hibernate.initialize(p.getConta());
			// if(p.getConta().getPagamentos()!=null){
			// Hibernate.initialize(p.getConta().getPagamentos());
			// }
			// if(p.getConta().getDebitoCobrados()!=null){
			// Hibernate.initialize(p.getConta().getDebitoCobrados());
			// }
			// }
		}catch(Exception e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(sessao);
		}
		return listaResultado;
	}

	public Collection<Object[]> pesquisarPagamentosPorContaJDBC(Integer idImovel, Integer anoMesReferenciaPagamento)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection<Object[]> listaResultado = new ArrayList<Object[]>();

		String sql = "select pgmt_id, pgmt_vlpagamento, pgst_idatual, "
						+ "avbc_id, cnta_id, dotp_id, pgmt_dtpagamento, pgmt_amreferenciaarrecadacao " + "from pagamento "
						+ "where imov_id = ? " + "and pgmt_amreferenciapagamento = ?";

		try{

			Connection c = session.connection();
			PreparedStatement statement = c.prepareStatement(sql);
			statement.setInt(1, idImovel);
			statement.setInt(2, anoMesReferenciaPagamento);

			ResultSet rs = statement.executeQuery();

			while(rs.next()){
				Object[] item = new Object[8];
				item[0] = rs.getInt(1);
				item[1] = rs.getBigDecimal(2);
				item[2] = rs.getInt(3);
				item[3] = rs.getInt(4);
				if(rs.wasNull()) item[3] = null;
				item[4] = rs.getInt(5);
				if(rs.wasNull()) item[4] = null;
				item[5] = rs.getInt(6);
				item[6] = rs.getDate(7);
				item[7] = rs.getInt(8);
				listaResultado.add(item);
			}

			rs.close();
			statement.close();
			c.close();

		}catch(HibernateException e){
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}catch(SQLException e){
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
			sql = null;
		}
		return listaResultado;
	}

	/**
	 * @author jns
	 * @date 06/10/2010
	 *       ----------------------------------------------------------------
	 *       Otimização do método pesquisarPagamentosPorConta. Trazendo apenas
	 *       valores necessários. Mantido o método original para evitar possíveis
	 *       erros em lógicas anteriores.
	 * @see pesquisarPagamentosPorConta
	 *      ----------------------------------------------------------------
	 * @param idImovel
	 * @param anoMesReferenciaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosPorContaMovimentoArrecadadores(Integer idImovel, Integer anoMesReferenciaPagamento)
					throws ErroRepositorioException{

		Collection<Pagamento> retorno = new ArrayList<Pagamento>();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		// StringBuffer consulta2 = new StringBuffer();
		// StringBuffer consulta3 = new StringBuffer();

		// consulta2.append("select pgmt from Pagamento pgmt join fetch pgmt.avisoBancario avisoBancario join fetch pgmt.pagamentoSituacaoAtual left join pgmt.imovel imovel")
		// .append(" where imovel.id = :idImovel and pgmt.anoMesReferenciaPagamento = :anoMesReferenciaPagamento");

		consulta.append("select pgmt from Pagamento pgmt ").append(
						" where pgmt.imovel.id = :idImovel and pgmt.anoMesReferenciaPagamento = :anoMesReferenciaPagamento");

		try{

			// consulta.append("SELECT pgmt.id, pgmt.valorPagamento, pgst.id, pgmt.avisoBancario ")
			// .append("FROM Pagamento pgmt ")
			// .append("LEFT JOIN pgmt.imovel imov ")
			// .append("LEFT JOIN pgmt.pagamentoSituacaoAtual pgst ")
			// .append("WHERE imov.id = :idImovel AND pgmt.anoMesReferenciaPagamento = :anoMesReferenciaPagamento ");

			retorno = session.createQuery(consulta.toString()).setInteger("idImovel", idImovel).setInteger("anoMesReferenciaPagamento",
							anoMesReferenciaPagamento).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o tipo do documento correspondente a
	 * conta
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 28/11/2006
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idImovel
	 * @param anoMesReferenciaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarPagamentosHistoricoPorConta(Integer idLocalidade, Integer idImovel,
					Integer anoMesReferenciaPagamento) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{

			consulta = "SELECT pgmt.id, pgmt.documentoTipo.id, pgmt.localidade.id, pgmt.valorPagamento, pgst.id, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento "
							+ "FROM PagamentoHistorico pgmt "
							+ "LEFT JOIN pgmt.imovel imov "
							+ "LEFT JOIN pgmt.pagamentoSituacaoAtual pgst "
							+ "WHERE imov.id = :idImovel AND pgmt.anoMesReferenciaPagamento = :anoMesReferenciaPagamento "
							+ "ORDER BY imov.id, pgmt.anoMesReferenciaPagamento, pgmt.dataPagamento ";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("anoMesReferenciaPagamento",
							anoMesReferenciaPagamento).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona os pagamentos com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela PAGAMENTO para
	 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO), com o tipo do documento correspondente a
	 * guia de pagamento e o campo GPAG_ID informado
	 * 
	 * @author Raphael Rossiter
	 * @data 18/04/2006
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoComGuiaInformada(Integer anoMesReferencia)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id, gpag ").append("FROM Pagamento pgmt ").append(
							"LEFT JOIN pgmt.documentoTipo dotp ").append("LEFT JOIN pgmt.localidade loca ").append(
							"LEFT JOIN pgmt.imovel imov ").append("LEFT JOIN pgmt.pagamentoSituacaoAtual pgst ").append(
							"LEFT JOIN pgmt.guiaPagamentoGeral gpag ").append(
							"WHERE pgmt.anoMesReferenciaArrecadacao <= :anoMesReferencia AND dotp.id = :guiaPagamento ").append(
							"AND pgmt.guiaPagamentoGeral IS NOT NULL ").append("ORDER BY gpag.id, pgmt.dataPagamento ");

			retorno = session.createQuery(consulta.toString()).setInteger("anoMesReferencia", anoMesReferencia).setInteger("guiaPagamento",
							DocumentoTipo.GUIA_PAGAMENTO).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Saulo Lima
	 * @data 18/04/2006, 28/11/2006, 24/11/2008
	 * @author Yara Souza
	 * @data 29/07/2010
	 *       Acrescentando aviso bancário no retorno da consulta.
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoComGuiaInformada(Integer idLocalidade, Integer idGuiaPagamento,
					Integer numeroPrestacao) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta
							.append("SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, gpag.id, pgmt.valorPagamento, pgmt.dataPagamento,")
							.append(
											"pgmt.anoMesReferenciaPagamento, gpag.valorDebito, pgmt.numeroPrestacao, avbc.id , gpagGeral.indicadorHistorico ")
							.append("FROM Pagamento pgmt ").append("LEFT JOIN pgmt.documentoTipo dotp ").append(
											"LEFT JOIN pgmt.localidade loca ").append("LEFT JOIN pgmt.imovel imov ").append(
											"LEFT JOIN pgmt.pagamentoSituacaoAtual pgst ").append("LEFT JOIN pgmt.avisoBancario avbc ")
							.append("LEFT JOIN pgmt.guiaPagamentoGeral gpagGeral ").append("LEFT JOIN gpagGeral.guiaPagamento gpag ")
							.append("WHERE dotp.id = :guiaPagamento ").append(
											"AND gpag.id = :idGuiaPagamento AND pgmt.numeroPrestacao = :numeroPrestacao ").append(
											"AND loca.id = :idLocalidade ").append(
											"ORDER BY gpag.id, pgmt.numeroPrestacao, pgmt.dataPagamento");

			retorno = session.createQuery(consulta.toString()).setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO).setInteger(
							"idLocalidade", idLocalidade).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger("numeroPrestacao",
							numeroPrestacao).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 12/12/2006
	 * @author Saulo Lima
	 * @date 07/08/2009
	 *       Novos Parâmetros idImovel e idCliente
	 * @param idLocalidade
	 * @param idImovel
	 * @param idCliente
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoSemGuiaInformada(Integer idLocalidade, Integer idImovel,
					Integer idCliente) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		String condicaoImovelOuCliente = null;

		try{

			if(idImovel != null){
				condicaoImovelOuCliente = "AND pgmt.imovel.id = :idImovel ";
			}else{
				condicaoImovelOuCliente = "AND pgmt.cliente.id = :idCliente ";
			}

			consulta
							.append(
											"SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, clie.id, dbtp.id, pgmt.valorPagamento, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento, avbc.id ")
							.append("FROM Pagamento pgmt ").append("LEFT JOIN pgmt.documentoTipo dotp ").append(
											"LEFT JOIN pgmt.localidade loca ").append("LEFT JOIN pgmt.imovel imov ").append(
											"LEFT JOIN pgmt.pagamentoSituacaoAtual pgst ").append("LEFT JOIN pgmt.cliente clie ").append(
											"LEFT JOIN pgmt.debitoTipo dbtp ").append("LEFT JOIN pgmt.avisoBancario avbc ").append(
											"WHERE dotp.id = :guiaPagamento ").append("AND pgmt.guiaPagamentoGeral IS NULL ").append(
											"AND loca.id = :idLocalidade ").append(condicaoImovelOuCliente).append(
											"ORDER BY loca.id, imov.id, clie.id, dbtp.id, pgmt.dataPagamento");

			if(idImovel != null){
				retorno = session.createQuery(consulta.toString()).setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO).setInteger(
								"idLocalidade", idLocalidade).setInteger("idImovel", idImovel).list();
			}else{
				retorno = session.createQuery(consulta.toString()).setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO).setInteger(
								"idLocalidade", idLocalidade).setInteger("idCliente", idCliente).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Saulo Lima
	 * @data 18/04/2006, 28/11/2006, 24/11/2008
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosHistoricoPorGuiaPagamentoComGuiaInformada(Integer idLocalidade, Integer idGuiaPagamento,
					Integer numeroPrestacao) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, gpag.id, pgmt.valorPagamento, pgmt.dataPagamento, "
							+ "pgmt.anoMesReferenciaPagamento, gpag.valorDebito, pgmt.numeroPrestacao " + "FROM PagamentoHistorico pgmt "
							+ "LEFT JOIN pgmt.documentoTipo dotp " + "LEFT JOIN pgmt.localidade loca " + "LEFT JOIN pgmt.imovel imov "
							+ "LEFT JOIN pgmt.pagamentoSituacaoAtual pgst " + "LEFT JOIN pgmt.guiaPagamentoGeral gpagGeral "
							+ "LEFT JOIN gpagGeral.guiaPagamento gpag " + "WHERE dotp.id = :guiaPagamento "
							+ "AND gpag.id = :idGuiaPagamento AND pgmt.numeroPrestacao = :numeroPrestacao "
							+ "AND loca.id = :idLocalidade " + "ORDER BY gpag.id, pgmt.numeroPrestacao, pgmt.dataPagamento";

			retorno = session.createQuery(consulta).setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO).setInteger("idLocalidade",
							idLocalidade).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger("numeroPrestacao", numeroPrestacao)
							.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 12/12/2006
	 * @author Saulo Lima
	 * @date 07/08/2009
	 *       Novos Parâmetros idImovel e idCliente
	 * @param idLocalidade
	 * @param idImovel
	 * @param idCliente
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarPagamentosHistoricoPorGuiaPagamentoSemGuiaInformada(Integer idLocalidade, Integer idImovel,
					Integer idCliente) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;
		String condicaoImovelOuCliente = null;

		try{

			if(idImovel != null){
				condicaoImovelOuCliente = "AND pgmt.imovel.id = :idImovel ";
			}else{
				condicaoImovelOuCliente = "AND pgmt.cliente.id = :idCliente ";
			}

			consulta = "SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, clie.id, dbtp.id, pgmt.valorPagamento, pgmt.dataPagamento, pgmt.anoMesReferenciaPagamento "
							+ "FROM PagamentoHistorico pgmt "
							+ "LEFT JOIN pgmt.documentoTipo dotp "
							+ "LEFT JOIN pgmt.localidade loca "
							+ "LEFT JOIN pgmt.imovel imov "
							+ "LEFT JOIN pgmt.pagamentoSituacaoAtual pgst "
							+ "LEFT JOIN pgmt.cliente clie "
							+ "LEFT JOIN pgmt.debitoTipo dbtp "
							+ "WHERE dotp.id = :guiaPagamento "
							+ "AND pgmt.guiaPagamentoGeral IS NULL "
							+ "AND loca.id = :idLocalidade "
							+ condicaoImovelOuCliente
							+ "ORDER BY loca.id, imov.id, clie.id, dbtp.id, pgmt.dataPagamento";

			if(idImovel != null){
				retorno = session.createQuery(consulta).setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO).setInteger(
								"idLocalidade", idLocalidade).setInteger("idImovel", idImovel).list();
			}else{
				retorno = session.createQuery(consulta).setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO).setInteger(
								"idLocalidade", idLocalidade).setInteger("idCliente", idCliente).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 28/11/2006
	 * @author Virgínia Melo
	 * @date 10/03/2009
	 *       Correção de HQL.
	 * @author Saulo Lima
	 * @date 04/08/2009
	 *       Novo parâmetro idImovel
	 * @author Thiago Toscano
	 * @date 05/10/09
	 *       Novo parâmetro prestacao
	 * @param idLocalidade
	 * @param idImovel
	 * @parm prestacao - prestacao
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarComDebitoInformado(Integer idLocalidade, Integer idImovel,
					Integer prestacao) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		StringBuffer restricao = new StringBuffer();
		if(prestacao != null && prestacao.intValue() != 0){
			restricao.append(" and pgmt.numeroPrestacao  = ").append(prestacao).append(" ");
		}

		try{
			consulta.append("SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id, dbac ").append("FROM Pagamento pgmt ").append(
							"INNER JOIN pgmt.debitoACobrar dbac ").append("LEFT JOIN pgmt.documentoTipo dotp ").append(
							"LEFT JOIN pgmt.localidade loca ").append("LEFT JOIN pgmt.imovel imov ").append(
							"LEFT JOIN pgmt.pagamentoSituacaoAtual pgst ").append("WHERE dotp.id = :debitoACobrar ").append(
							"AND pgmt.imovel.id = :idImovel ").append("AND loca.id = :idLocalidade ").append(restricao).append(
							"ORDER BY dbac.id, pgmt.dataPagamento");

			retorno = session.createQuery(consulta.toString()).setInteger("debitoACobrar", DocumentoTipo.DEBITO_A_COBRAR).setInteger(
							"idImovel", idImovel).setInteger("idLocalidade", idLocalidade).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 18/04/2006, 28/11/2006
	 * @author Saulo Lima
	 * @date 04/08/2009
	 *       Novo parâmetro idImovel
	 * @param idLocalidade
	 * @param idImovel
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarSemDebitoInformada(Integer idLocalidade, Integer idImovel)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id ").append("FROM Pagamento pgmt ").append(
							"LEFT JOIN pgmt.documentoTipo dotp ").append("LEFT JOIN pgmt.localidade loca ").append(
							"LEFT JOIN pgmt.imovel imov ").append("LEFT JOIN pgmt.pagamentoSituacaoAtual pgst ").append(
							"LEFT JOIN pgmt.debitoTipo dbtp ").append("LEFT JOIN pgmt.debitoACobrar dbac ").append(
							"WHERE dotp.id = :debitoACobrar ").append("AND pgmt.imovel.id = :idImovel ").append(
							"AND pgmt.debitoACobrar IS NULL ").append("AND loca.id= :idLocalidade ").append(
							"ORDER BY loca.id, imov.id, dbtp.id, pgmt.dataPagamento");

			retorno = session.createQuery(consulta.toString()).setInteger("debitoACobrar", DocumentoTipo.DEBITO_A_COBRAR).setInteger(
							"idImovel", idImovel).setInteger("idLocalidade", idLocalidade).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona as devoluções com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela DEVOLUCAO para
	 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o ano/mês de referência preenchido
	 * (DEVL_AMREFERENCIADEVOLUCAO com valor diferente de nulo)
	 * 
	 * @author Raphael Rossiter
	 * @data 14/06/2006
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarDevolucoesEmDuplicidadeOUExcesso(Integer anoMesReferencia) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT devl, loca.id, imov.id, gdev.id " + "FROM Devolucao  devl " + "LEFT JOIN devl.localidade  loca "
							+ "LEFT JOIN devl.imovel  imov " + "LEFT JOIN devl.guiaDevolucao  gdev "
							+ "WHERE devl.anoMesReferenciaArrecadacao <= :anoMesReferencia AND "
							+ "devl.anoMesReferenciaDevolucao IS NOT NULL "
							+ "ORDER BY loca.id, imov.id, devl.anoMesReferenciaDevolucao, devl.dataDevolucao ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona as devoluções com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela DEVOLUCAO para
	 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o ano/mês de referência preenchido
	 * (DEVL_AMREFERENCIADEVOLUCAO com valor diferente de nulo)
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 14/06/2006, 28/11/2006
	 * @autor
	 * @param Devolucao
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarDevolucoesEmDuplicidadeOUExcesso(Devolucao devolucao) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT devl, loca.id, imov.id, gdev.id  " + "FROM Devolucao devl " + "LEFT JOIN devl.localidade loca "
							+ "LEFT JOIN devl.imovel imov " + "LEFT JOIN devl.guiaDevolucao gdev "
							+ "LEFT JOIN fetch devl.arrecadadorMovimentoItem amit " + "LEFT JOIN fetch devl.avisoBancario avbc " + "WHERE "
							+ " devl.dataDevolucao IS NOT NULL " + " and loca.id = :idLocalidade " + " and imov.id = :idImovel ";

			if(devolucao.getAnoMesReferenciaDevolucao() != null){

				consulta = consulta + " and devl.anoMesReferenciaDevolucao = :anoMesReferenciaDevolucao "
								+ "ORDER BY loca.id, imov.id, devl.anoMesReferenciaDevolucao, devl.dataDevolucao ";

				retorno = session.createQuery(consulta).setInteger("idLocalidade", devolucao.getLocalidade().getId()).setInteger(
								"idImovel", devolucao.getImovel().getId()).setInteger("anoMesReferenciaDevolucao",
								devolucao.getAnoMesReferenciaDevolucao()).list();

			}else{

				consulta = consulta + "ORDER BY loca.id, imov.id, devl.anoMesReferenciaDevolucao, devl.dataDevolucao ";

				retorno = session.createQuery(consulta).setInteger("idLocalidade", devolucao.getLocalidade().getId()).setInteger(
								"idImovel", devolucao.getImovel().getId()).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona as devoluções com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela DEVOLUCAO para
	 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o ano/mês de referência não
	 * preenchido (DEVL_AMREFERENCIADEVOLUCAO com valor diferente nulo)
	 * 
	 * @author Raphael Rossiter
	 * @data 14/06/2006
	 * @param anoMesReferenciaFaturamento
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarDevolucoesCobradasIndevidamente(Integer anoMesReferencia) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT devl, loca.id, imov.id, gdev.id, clie.id, dbtp.id " + "FROM Devolucao  devl "
							+ "LEFT JOIN devl.localidade  loca " + "LEFT JOIN devl.imovel  imov " + "LEFT JOIN devl.guiaDevolucao  gdev "
							+ "LEFT JOIN devl.cliente  clie " + "LEFT JOIN devl.debitoTipo  dbtp "
							+ "WHERE devl.anoMesReferenciaArrecadacao <= :anoMesReferencia AND "
							+ "devl.anoMesReferenciaDevolucao IS NULL "
							+ "ORDER BY loca.id, imov.id, clie.id, dbtp.id, devl.dataDevolucao ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona as devoluções com ano/mês de referência da
	 * arrecadação igual ou menor que o ano/mês de referência da arrecadação
	 * corrente (seleciona a partir da tabela DEVOLUCAO para
	 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao
	 * PARM_AMREFERENCIAARRECADACAO) e com o ano/mês de referência não
	 * preenchido (DEVL_AMREFERENCIADEVOLUCAO com valor diferente nulo)
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @data 14/06/2006, 28/11/2006
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarDevolucoesCobradasIndevidamente(Integer anoMesReferencia, Integer idLocalidade)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT devl, loca.id, imov.id, gdev.id, clie.id, dbtp.id " + "FROM Devolucao  devl "
							+ "LEFT JOIN devl.localidade  loca " + "LEFT JOIN devl.imovel  imov " + "LEFT JOIN devl.guiaDevolucao  gdev "
							+ "LEFT JOIN devl.cliente  clie " + "LEFT JOIN devl.debitoTipo  dbtp "
							+ "WHERE devl.anoMesReferenciaArrecadacao <= :anoMesReferencia AND "
							+ "devl.anoMesReferenciaDevolucao IS NULL AND loca.id = :idLocalidade "
							+ "ORDER BY loca.id, imov.id, clie.id, dbtp.id, devl.dataDevolucao ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("idLocalidade",
							idLocalidade).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona a conta correspondente ao pagamento através do imóvel
	 * e ano/mês de referência do pagamento (a partir da tabela CONTA com
	 * IMOV_ID = IMOV_ID da tabela PAGAMENTO, PGMT_AMREFERENCIAPAGAMENTO da
	 * tabela PAGAMENTO e DCST_IDATUAL com o valor correspondente a normal,
	 * retificada ou incluída, da tabela DEBTIO_CREDITO_SITUACAO)
	 * [SF0001] Selecionar Conta pelo Imóvel e Ano/Mês de Referência
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2006, 05/06/2007, 02/10/2007
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Removendo parâmetro não utilizado e removendo INNER JOIN desnecessário
	 * @param imovel
	 * @param anoMesReferenciaPagamento
	 * @return Conta
	 */
	public Object[] selecionarContaPorImovelAnoMesReferencia(Imovel imovel, Integer anoMesReferenciaPagamento)
					throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT cnta.id, ").append("cnta.valorAgua, ").append("cnta.valorEsgoto, ").append("cnta.debitos, ").append(
							"cnta.valorCreditos, ").append("cnta.valorImposto, ").append("cnta.referenciaContabil, ").append("dcst.id, ")
							.append("cnta.dataVencimentoConta, ").append("cnta.referencia, ").append("cnta.indicadorCobrancaMulta, ")
							.append("cnta.dataEmissao ").append("FROM Conta cnta ").append(
											"INNER JOIN cnta.debitoCreditoSituacaoAtual dcst ").append(
											"WHERE cnta.imovel.id = :imovelPagamento ").append(
											"AND cnta.referencia = :anoMesReferenciaPagamento ").append(
											"AND cnta.debitoCreditoSituacaoAtual IS NOT NULL");

			retorno = (Object[]) session.createQuery(consulta.toString()).setInteger("imovelPagamento", imovel.getId()).setInteger(
							"anoMesReferenciaPagamento", anoMesReferenciaPagamento).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a ContaHistorico para o imóvel no ano/mês de referência informados
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 15/01/2008
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Removendo parâmetro não utilizado e situações desnecessárias
	 * @param imovel
	 * @param anoMesReferenciaPagamento
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] selecionarContaHistoricoPorImovelAnoMesReferencia(Imovel imovel, Integer anoMesReferenciaPagamento)
					throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select cnhi.id, ").append("cnhi.valorAgua, ").append("cnhi.valorEsgoto, ").append("cnhi.valorDebitos, ")
							.append("cnhi.valorCreditos, ").append("cnhi.valorImposto, ").append("cnhi.anoMesReferenciaContabil, ").append(
											"dcst.id ").append("FROM ContaHistorico as cnhi ").append(
											"INNER JOIN cnhi.debitoCreditoSituacaoAtual dcst ").append(
											"where cnhi.imovel.id = :imovelPagamento ").append(
											"and cnhi.anoMesReferenciaConta = :anoMesReferenciaPagamento ").append(
											"and cnhi.debitoCreditoSituacaoAtual is not null");

			retorno = (Object[]) session.createQuery(consulta.toString()).setInteger("imovelPagamento", imovel.getId()).setInteger(
							"anoMesReferenciaPagamento", anoMesReferenciaPagamento).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * pesquisa todos os bancos que tenham contrato vigente para arrecadador
	 * contas com forma de arrecadação correspondente a debito automático
	 * [SB0002] - Carregar Lista de Bancos
	 * 
	 * @author Sávio Luiz
	 * @date 18/04/2006
	 * @return Coleção de Bancos
	 * @throws ErroRepositorioException
	 */

	public Collection<Banco> pesquisaBancosDebitoAutomatico() throws ErroRepositorioException{

		Collection<Banco> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			consulta = "select banco.id " + "from Banco banco " + "where banco.id in( " + "select arrecadador.codigoAgente "
							+ "from ArrecadadorContratoTarifa arrcConTarifa "
							+ "inner join arrcConTarifa.arrecadacaoForma arrecadadorForma "
							+ "inner join arrcConTarifa.arrecadadorContrato arrecadadorContrato "
							+ "inner join arrecadadorContrato.arrecadador arrecadador " + "where arrecadadorForma.id = :debitoAutomatico "
							+ "and arrecadadorContrato.concessionaria.id = :idConcessionaria "
							+ "and arrecadadorContrato.dataContratoEncerramento is null) " + "order by banco.id";

			retorno = session.createQuery(consulta).setInteger("debitoAutomatico", ArrecadacaoForma.DEBITO_AUTOMATICO)
							.setInteger("idConcessionaria", Concessionaria.EMPRESA_CONCEDENTE).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * pesquisa os movimentos de débito automático para o banco,referentes ao
	 * grupo e ano/mês de faturamento informados
	 * [SB0002] - Carregar Lista de Bancos
	 * 
	 * @author Sávio Luiz
	 * @date 18/04/2006
	 * @param idFaturamentoGrupo
	 *            ,anoMesReferenciaFaturamento,idBanco
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisaDebitoAutomaticoMovimento(Collection colecaoFaturamentoGrupo, Integer anoMesReferenciaFaturamento,
					Collection colecaoidsBanco, String opcaoDebitoAutomatico) throws ErroRepositorioException{

		Collection<DebitoAutomaticoMovimento> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("select ");
			consulta.append(" 	banco,debAutoMovimento ");
			consulta.append("from gcom.arrecadacao.debitoautomatico.DebitoAutomaticoMovimento debAutoMovimento ");
			consulta.append("inner join debAutoMovimento.faturamentoGrupo fatGrupo ");
			consulta.append("inner join fetch debAutoMovimento.debitoAutomatico debAutomatico ");
			consulta.append("inner join fetch debAutomatico.agencia agencia ");
			consulta.append("inner join agencia.banco banco ");

			if(opcaoDebitoAutomatico.equals(DebitoAutomaticoMovimento.GERAR_MOVIMENTO_DE_DEBITO_AUTOMATICO)){
				consulta.append("left join fetch debAutoMovimento.contaGeral contaGeral ");
				consulta.append("left join fetch contaGeral.conta conta ");
				consulta.append("left join fetch contaGeral.contaHistorico contaHistorico ");
			}

			if(opcaoDebitoAutomatico.equals(DebitoAutomaticoMovimento.GERAR_MOVIMENTO_DE_DEBITO_AUTOMATICO_PREFEITURA)){
				consulta.append("left join fetch debAutoMovimento.guiaPagamento guiaPagamento ");
				consulta.append("left join fetch guiaPagamento.imovel imovel ");
				consulta.append("left join fetch imovel.localidade localidade ");
				consulta.append("left join fetch localidade.municipio municipio ");
			}

			consulta.append(" where debAutoMovimento.numeroSequenciaArquivoEnviado is null ");
			consulta.append("	and debAutoMovimento.debitoAutomaticoMovimentoCancelamentoMotivo is null ");
			if(!Util.isVazioOrNulo(colecaoFaturamentoGrupo)){
				consulta.append("	and fatGrupo.id in (:colecaoFaturamentoGrupo) ");
			}

			if(opcaoDebitoAutomatico.equals(DebitoAutomaticoMovimento.GERAR_MOVIMENTO_DE_DEBITO_AUTOMATICO)){
				consulta.append("	and contaGeral.id is not null ");
			}

			if(!Util.isVazioOuBranco(anoMesReferenciaFaturamento)){
				consulta.append("	and (conta.referencia = :anoMesReferenciaFaturamento or ");
				consulta.append("	     contaHistorico.anoMesReferenciaConta = :anoMesReferenciaFaturamento) ");
			}

			if(opcaoDebitoAutomatico.equals(DebitoAutomaticoMovimento.GERAR_MOVIMENTO_DE_DEBITO_AUTOMATICO_PREFEITURA)){
				consulta.append("	and guiaPagamento.id is not null ");
				consulta.append("	and debAutoMovimento.numeroPrestacao in ( ");
				consulta.append(" 			select ");
				consulta.append(" 				guiaPagamentoPrestacao.comp_id.numeroPrestacao ");
				consulta.append(" 			FROM gcom.arrecadacao.pagamento.GuiaPagamentoPrestacao guiaPagamentoPrestacao ");
				consulta.append(" 			inner join guiaPagamentoPrestacao.guiaPagamento guiaPagto ");
				consulta.append("			where ");
				consulta.append(" 				guiaPagto.id = guiaPagamento.id  ");
				consulta.append(" 			)");
			}

			if(!Util.isVazioOrNulo(colecaoidsBanco)){
				consulta.append("	and banco.id in (:idsBanco) ");
			}
			consulta.append(" order by banco.id");

			Query query = session.createQuery(consulta.toString());

			if(!Util.isVazioOrNulo(colecaoFaturamentoGrupo)){
				query.setParameterList("colecaoFaturamentoGrupo", colecaoFaturamentoGrupo);
			}

			if(!Util.isVazioOuBranco(anoMesReferenciaFaturamento)){
				query.setInteger("anoMesReferenciaFaturamento", anoMesReferenciaFaturamento);
			}

			if(!Util.isVazioOrNulo(colecaoidsBanco)){
				query.setParameterList("idsBanco", colecaoidsBanco);
			}

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * @author Vivianne Sousa
	 * @date 20/04/2006
	 * @param avisoBancarioHelper
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarAvisoBancarioAbertoFechado(AvisoBancarioHelper avisoBancarioHelper) throws ErroRepositorioException{

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Consulta
		try{

			// cria a variável que vai conter o hql
			String consulta = "";

			Short arrecadadorCodAgente = avisoBancarioHelper.getCodigoAgenteArrecadador();
			Date dataLancamentoInicio = avisoBancarioHelper.getDataLancamentoInicial();
			Date dataLancamentoFim = avisoBancarioHelper.getDataLancamentoFinal();
			Short indicadorCreditoDebito = avisoBancarioHelper.getIndicadorCreditoDebito();
			Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
			Integer idMovimento = avisoBancarioHelper.getIdMovimentoArrecadador();
			Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper.getDataPrevistaInicial();
			Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper.getDataPrevistaFinal();
			Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper.getDataRealizadaInicial();
			Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper.getDataRealizadaFinal();
			int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper.getAnoMesReferenciaArrecadacaoInicial();
			int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper.getAnoMesReferenciaArrecadacaoFinal();
			BigDecimal valorRealizadoInicial = avisoBancarioHelper.getValorRealizadoInicial();
			BigDecimal valorRealizadoFinal = avisoBancarioHelper.getValorRealizadoFinal();
			BigDecimal valorPrevistoInicial = avisoBancarioHelper.getValorPrevistoInicial();
			BigDecimal valorPrevistoFinal = avisoBancarioHelper.getValorPrevistoFinal();
			Integer idConcessionaria = avisoBancarioHelper.getIdConcessionaria();
			String cdConvenio = avisoBancarioHelper.getCdConvenio();
			String tipoServico = avisoBancarioHelper.getTipoServico();
			String select = "";

			select = this.selectFiltrarAvisoBancario(avisoBancarioHelper);

			int flag = 0;
			if(arrecadadorCodAgente == null && (dataLancamentoInicio == null || dataLancamentoFim == null)
							&& (indicadorCreditoDebito == 0 || indicadorCreditoDebito == 3) && idContaBancaria == null
							&& idMovimento == null && (dataPrevisaoCreditoDebitoInicio == null || dataPrevisaoCreditoDebitoFim == null)
							&& (dataRealizacaoCreditoDebitoInicio == null || dataRealizacaoCreditoDebitoFim == null)
							&& (anoMesReferenciaArrecadacaoInicial == 0 || anoMesReferenciaArrecadacaoFinal == 0)
							&& (valorPrevistoInicial == null || valorPrevistoFinal == null)
							&& (valorRealizadoInicial == null || valorRealizadoFinal == null) && idConcessionaria == null
							&& cdConvenio == null){
				flag = 1;
				consulta = select;

				if(avisoBancarioHelper.getIdAvisoBancario() != null){

					consulta += " where avisoBancario.id = " + avisoBancarioHelper.getIdAvisoBancario().toString() + "    ";
				}

			}else{

				consulta = select + " where ";

				if(avisoBancarioHelper.getIdAvisoBancario() != null){

					consulta += " avisoBancario.id = " + avisoBancarioHelper.getIdAvisoBancario().toString() + " and";
				}
			}

			if(idConcessionaria != null){
				consulta += " avisoBancario.contaBancaria.id = arrecadadorContrato.contaBancariaDepositoArrecadacao and";
				consulta += " arrecadadorContrato.concessionaria = " + idConcessionaria + " and";
			}

			if(arrecadadorCodAgente != null){
				consulta += " avisoBancario.arrecadador.codigoAgente = " + arrecadadorCodAgente + " and";
			}

			if(cdConvenio != null && tipoServico != null){

				if(tipoServico.equals(ConstantesSistema.COBRANCA_BANCARIA)){
					consulta += " avisoBancario.contaBancaria.id = arrecadadorContrato.contaBancariaDepositoArrecadacaoBoleto and";
					consulta += " arrecadadorContrato.codigoConvenioBoletoBancario = '" + cdConvenio + "'  and";
				}else{
					// a partir da tabela AVISO_BANCARIO com CTBC_ID=CTBC_IDDEPOSITOARRECADACAO da
					// tabela ARRECADADOR_CONTRATO
					consulta += " avisoBancario.contaBancaria.id = arrecadadorContrato.contaBancariaDepositoArrecadacao and";

					if(tipoServico.equals(ConstantesSistema.DEBITO_AUTOMATICO)){
						consulta += " (arrecadadorContrato.codigoConvenioDebitoAutomatico = '" + cdConvenio + "'  or "
										+ "arrecadadorContrato.codigoConvenioParcelamentoResposavel = '" + cdConvenio + "') and";
					}
					if(tipoServico.equals(ConstantesSistema.CODIGO_DE_BARRAS)){
						consulta += " arrecadadorContrato.codigoConvenio = '" + cdConvenio + "'  and";
					}
					if(tipoServico.equals(ConstantesSistema.FICHA_DE_COMPENSACAO)){
						consulta += " arrecadadorContrato.codigoConvenioFichaCompensacao = '" + cdConvenio + "'  and";
					}
				}
				
				consulta += " arrecadadorMovimento.descricaoIdentificacaoServico = '" + tipoServico + "'  and";

			}

			if((dataLancamentoInicio != null) && (dataLancamentoFim != null)){
				consulta += " avisoBancario.dataLancamento between :dataLancamentoInicio  and " + ":dataLancamentoFim and";

			}

			if(indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3){
				consulta += " avisoBancario.indicadorCreditoDebito = " + indicadorCreditoDebito + " and";
			}

			if(idContaBancaria != null){
				consulta += " avisoBancario.contaBancaria.id = " + idContaBancaria + " and";
			}

			if(idMovimento != null){
				consulta += " avisoBancario.arrecadadorMovimento.id = " + idMovimento + " and";
			}

			if((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)){
				consulta += " avisoBancario.dataPrevista between :dataPrevisaoCreditoDebitoInicio  and "
								+ ":dataPrevisaoCreditoDebitoFim and";

			}

			if((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null)){
				consulta += " avisoBancario.dataRealizada between :dataRealizacaoCreditoDebitoInicio  and "
								+ ":dataRealizacaoCreditoDebitoFim and";

			}

			if((anoMesReferenciaArrecadacaoInicial != 0) && (anoMesReferenciaArrecadacaoFinal != 0)){
				consulta += " avisoBancario.anoMesReferenciaArrecadacao between " + anoMesReferenciaArrecadacaoInicial + " and "
								+ anoMesReferenciaArrecadacaoFinal + " and";
			}

			if((valorRealizadoInicial != null) && (valorRealizadoFinal != null)){

				BigDecimal valorInicialNegativo = valorRealizadoFinal.multiply(new BigDecimal("-1.00"));
				BigDecimal valorFinalNegativo = valorRealizadoInicial.multiply(new BigDecimal("-1.00"));
				consulta += " ((avisoBancario.valorRealizado between " + valorInicialNegativo + " and " + valorFinalNegativo
								+ ") or (avisoBancario.valorRealizado between " + valorRealizadoInicial + " and " + valorRealizadoFinal
								+ "))" + " and";
			}

			String consultarComOrderBy = "";

			if(flag != 1){
				consultarComOrderBy = Util.formatarHQL(consulta, 4)
								+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
			}else{
				consultarComOrderBy = Util.formatarHQL(consulta, 0)
								+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
			}

			if((((dataLancamentoInicio != null) && (dataLancamentoFim != null)) && ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.setDate("dataRealizacaoCreditoDebitoInicio", dataRealizacaoCreditoDebitoInicio).setDate(
												"dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).list();

			}else if(((dataLancamentoInicio != null) && (dataLancamentoFim != null))
							&& ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.list();

			}else if(((dataLancamentoInicio != null) && (dataLancamentoFim != null))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataRealizacaoCreditoDebitoInicio",
								dataRealizacaoCreditoDebitoInicio)
								.setDate("dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).list();

			}else if(((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataPrevisaoCreditoDebitoInicio", dataPrevisaoCreditoDebitoInicio)
								.setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim).setDate(
												"dataRealizacaoCreditoDebitoInicio", dataRealizacaoCreditoDebitoInicio).setDate(
												"dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).list();

			}else if((dataLancamentoInicio != null) && (dataLancamentoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).list();

			}else if((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataPrevisaoCreditoDebitoInicio", dataPrevisaoCreditoDebitoInicio)
								.setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim).list();

			}else if((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataRealizacaoCreditoDebitoInicio",
								dataRealizacaoCreditoDebitoInicio)
								.setDate("dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).list();

			}else{

				return session.createQuery(consultarComOrderBy).list();
			}
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * pesquisa 2 campos do arrecadador contrato
	 * 
	 * @author Sávio Luiz, eduardo henrique
	 * @date 17/07/2009
	 * @param idBanco
	 * @return Código do Convênio, numero sequencial de envio
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisaCamposArrecadadorContrato(Integer idBanco) throws ErroRepositorioException{

		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			consulta = "select arreContrato.id, "// 0
							+ "arreContrato.codigoConvenioDebitoAutomatico, "// 1
							+ "arreContrato.numeroSequencialArquivoEnvioDebitoAutomatico, "// 2
							+ "arreContrato.descricaoEmail, "// 3
							+ "arreContrato.codigoConvenioParcelamentoResposavel, "// 4
							+ "arreContrato.numeroSequencialArquivoEnvioParcelamentoResposavel "// 5
							+ "from ArrecadadorContrato arreContrato "
							+ "inner join arreContrato.arrecadador arrec "
							+ "where arrec.codigoAgente = :idBanco and " + "arreContrato.dataContratoEncerramento is null";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idBanco", idBanco).setMaxResults(1).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * pesquisa a agencia passando o id do banco
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * @param idBanco
	 * @return Agencia
	 * @throws ErroRepositorioException
	 */
	public Agencia pesquisaAgenciaPorBanco(Integer idBanco) throws ErroRepositorioException{

		Agencia retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			consulta = "select agencia " + "from Agencia agencia " + "inner join agencia.banco banco " + "where banco.id = :idBanco ";

			retorno = (Agencia) session.createQuery(consulta).setInteger("idBanco", idBanco).setMaxResults(1).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * atualiza o numero sequencial arquivo envio debito automatico
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * @param idBanco
	 * @return Código do Convênio, numero sequencial de envio
	 * @throws ErroRepositorioException
	 */
	public void atualizarNumeroSequencialArrecadadorContrato(Integer idArrecadadorContrato, Integer numeroSequencialArquivo,
					String opcaoDebitoAutomatico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarImovel = "";

		try{
			if(DebitoAutomaticoMovimento.GERAR_MOVIMENTO_DE_DEBITO_AUTOMATICO.equals(opcaoDebitoAutomatico)){
				atualizarImovel = "update gcom.arrecadacao.ArrecadadorContrato "
								+ "set arct_nnnsaenviodebaut = :numeroSequencialArquivo,arct_tmultimaalteracao = :dataUltimaAlteracao where arct_id = :idArrecadadorContrato";
			}else if(DebitoAutomaticoMovimento.GERAR_MOVIMENTO_DE_DEBITO_AUTOMATICO_PREFEITURA.equals(opcaoDebitoAutomatico)){
				atualizarImovel = "update gcom.arrecadacao.ArrecadadorContrato "
								+ "set arct_nnnsaenvioparcelresp = :numeroSequencialArquivo,arct_tmultimaalteracao = :dataUltimaAlteracao where arct_id = :idArrecadadorContrato";
			}

			session.createQuery(atualizarImovel).setInteger("idArrecadadorContrato", idArrecadadorContrato.intValue()).setTimestamp(
							"dataUltimaAlteracao", new Date()).setInteger("numeroSequencialArquivo", numeroSequencialArquivo.intValue())
							.executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * pesquisa o email do arrecadador contrato passando o código do banco
	 * [SB0003] - Regerar arquivo TXT para um movimento de débito automático
	 * gerado anteriormente
	 * 
	 * @author Sávio Luiz
	 * @date 25/04/2006
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public String pesquisarEmailArrecadadorContrato(Short codigoBanco) throws ErroRepositorioException{

		String retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			consulta = "select arrecadadorContrato.descricaoEmail " + "from ArrecadadorContrato arrecadadorContrato "
							+ "inner join arrecadadorContrato.arrecadador arrecadador " + "where arrecadador.codigoAgente = :codigoBanco "
							+ "and arrecadadorContrato.dataContratoEncerramento is null";

			retorno = (String) session.createQuery(consulta).setShort("codigoBanco", codigoBanco).setMaxResults(1).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualizar Devolucao
	 * 
	 * @author Fernanda Paiva
	 * @created 03/05/2006
	 * @param valor
	 *            arrecadacao
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public void atualizaValorArrecadacaoAvisoBancario(BigDecimal valor, Integer codigoAvisoBancario) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizaAvisoBancario;

		try{
			// Atualiza em AvisoBancario o valor da arrecadacao
			atualizaAvisoBancario = "update gcom.arrecadacao.aviso.AvisoBancario "
							+ "set avbc_vldevolucaocalculado = :valor, avbc_tmultimaalteracao = :ultimaAlteracao, "
							+ "avbc_vldevolucaoinformado = :valor " + "where avbc_id = :codigoAvisoBancario";

			session.createQuery(atualizaAvisoBancario).setBigDecimal("valor", (valor)).setInteger("codigoAvisoBancario",
							(codigoAvisoBancario)).setTimestamp("ultimaAlteracao", new Date()).executeUpdate();
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Faz a pesquisa de guia de devolução para o relatório fazendo os
	 * carregamentos de clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 11/09/2006
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaDevolucao> pesquisarGuiaDevolucaoRelatorio(FiltroGuiaDevolucao filtroGuiaDevolucao)
					throws ErroRepositorioException{

		Collection<GuiaDevolucao> retorno = null;

		Session session = HibernateUtil.getSession();

		try{

			retorno = new ArrayList(
							new CopyOnWriteArraySet<GuiaDevolucao>(
											GeradorHQLCondicional
															.gerarCondicionalQuery(
																			filtroGuiaDevolucao,
																			"gcom.arrecadacao.GuiaDevolucao",
																			"guiaDevolucao",
																			"select distinct guiaDevolucao from gcom.arrecadacao.GuiaDevolucao  guiaDevolucao "
																							+ "left join guiaDevolucao.contaGeral.conta.clienteContas clienteContas "
																							+ "left join guiaDevolucao.debitoACobrarGeral.debitoACobrar.imovel.clienteImoveis clienteImoveis "
																							+ "left join guiaDevolucao.guiaPagamentoGeral.guiaPagamento.clientesGuiaPagamento clientesGuiaPagamento ",
																			session).list()));
			/*
			 * if
			 * (!filtroGuiaDevolucao.getColecaoCaminhosParaCarregamentoEntidades().isEmpty()) {
			 * PersistenciaUtil.processaObjetosParaCarregamento(filtroGuiaDevolucao.
			 * getColecaoCaminhosParaCarregamentoEntidades(),
			 * retorno); }
			 */
		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0324] - Filtrar Guia de Devolucao
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * Faz a pesquisa de guia de devolução fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaDevolucao> pesquisarGuiaDevolucao(FiltroGuiaDevolucao filtroGuiaDevolucao, Integer numeroPagina)
					throws ErroRepositorioException{

		Collection<GuiaDevolucao> retorno = null;

		Session session = HibernateUtil.getSession();

		try{

			retorno = new ArrayList(
							new CopyOnWriteArraySet<GuiaDevolucao>(
											GeradorHQLCondicional
															.gerarCondicionalQuery(
																			filtroGuiaDevolucao,
																			"gcom.arrecadacao.GuiaDevolucao",
																			"guiaDevolucao",
																			"select distinct guiaDevolucao from gcom.arrecadacao.GuiaDevolucao  guiaDevolucao "
																							+ "left join guiaDevolucao.contaGeral.conta.clienteContas clienteContas "
																							+ "left join guiaDevolucao.debitoACobrarGeral.debitoACobrar.imovel.clienteImoveis clienteImoveis "
																							+ "left join guiaDevolucao.guiaPagamentoGeral.guiaPagamento.clientesGuiaPagamento clientesGuiaPagamento ",
																			session).setFirstResult(10 * numeroPagina).setMaxResults(10)
															.list()));
			/*
			 * if
			 * (!filtroGuiaDevolucao.getColecaoCaminhosParaCarregamentoEntidades().isEmpty()) {
			 * PersistenciaUtil.processaObjetosParaCarregamento(filtroGuiaDevolucao.
			 * getColecaoCaminhosParaCarregamentoEntidades(),
			 * retorno); }
			 */
		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0324] - Filtrar Guia de Devolucao
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * Cria um contador para a pesquisa de guia de devolução para ser utilizado
	 * pelo componente de paginação
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarGuiaDevolucaoCount(FiltroGuiaDevolucao filtroGuiaDevolucao) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		try{

			filtroGuiaDevolucao.getColecaoCaminhosParaCarregamentoEntidades().clear();

			retorno = ((Number) GeradorHQLCondicional.gerarCondicionalQuery(
							filtroGuiaDevolucao,
							"gcom.arrecadacao.GuiaDevolucao",
							"guiaDevolucao",
							"select count (guiaDevolucao.id) from gcom.arrecadacao.GuiaDevolucao  guiaDevolucao "
															+ "left join guiaDevolucao.contaGeral.conta.clienteContas clienteContas "
															+ "left join guiaDevolucao.debitoACobrarGeral.debitoACobrar.imovel.clienteImoveis clienteImoveis "
															+ "left join guiaDevolucao.guiaPagamentoGeral.guiaPagamento.clientesGuiaPagamento clientesGuiaPagamento "
							/* + " group by guiaDevolucao.creditoTipo.id " */, session).uniqueResult()).intValue();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstado(int anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(ra.valorItemArrecadacao)," + " rt.descricao," + " lt.descricao," + " li.descricao," + " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id," + " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " rt.id," + " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento"
							+ " from ResumoArrecadacao ra" + " left join ra.lancamentoTipo lt" + " left join ra.lancamentoItem li"
							+ " left join ra.lancamentoItemContabil lic" + " left join ra.recebimentoTipo rt"
							+ " where ra.anoMesReferencia = :anoMesReferencia and" + " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
							+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)" + " group by " + " rt.descricao," + " lt.descricao,"
							+ " li.descricao," + " lic.descricao," + " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id,"
							+ " lt.lancamentoTipo.id," + " ra.categoria.id," + " rt.id," + " ra.sequenciaTipoLancamento,"
							+ " ra.sequenciaItemTipoLancamento" + " order by rt.id," + " ra.sequenciaTipoLancamento,"
							+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorGerenciaRegional(int anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "select sum(ra.valorItemArrecadacao)," + " rt.descricao," + " lt.descricao," + " li.descricao," + " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id," + " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id," + " rt.id,"
							+ " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento" + " from ResumoArrecadacao ra"
							+ " left join ra.lancamentoTipo lt" + " left join ra.lancamentoItem li"
							+ " left join ra.lancamentoItemContabil lic" + " left join ra.recebimentoTipo rt"
							+ " where ra.anoMesReferencia = :anoMesReferencia and" + " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
							+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)" + " group by " + " ra.gerenciaRegional.nome,"
							+ " ra.gerenciaRegional.id," + " rt.descricao," + " lt.descricao," + " li.descricao," + " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id," + " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " rt.id," + " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento"
							+ " order by ra.gerenciaRegional.id," + " rt.id," + " ra.sequenciaTipoLancamento,"
							+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorLocalidade(int anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select "
							+ " sum(ra.valorItemArrecadacao),"// 0
							+ " rt.descricao," // 1
							+ " lt.descricao," // 2
							+ " li.descricao," // 3
							+ " lic.descricao," // 4
							+ " lt.indicadorImpressao," // 5
							+ " lt.indicadorTotal," // 6
							+ " lt.id,"// 7
							+ " lt.lancamentoTipo.id,"// 8
							+ " ra.categoria.id,"// 9
							+ " ra.gerenciaRegional.nome,"// 10
							+ " ra.gerenciaRegional.id,"// 11
							+ " ra.localidade.descricao," // 12
							+ " ra.localidade.id,"// 13
							+ " rt.id," // 14
							+ " ra.sequenciaTipoLancamento,"// 15
							+ " ra.sequenciaItemTipoLancamento,"// 16
							+ " ra.unidadeNegocio.nome, " // 17
							+ " ra.unidadeNegocio.id " // 18
							+ " from ResumoArrecadacao ra" + " left join ra.lancamentoTipo lt" + " left join ra.lancamentoItem li"
							+ " left join ra.lancamentoItemContabil lic" + " left join ra.recebimentoTipo rt"
							+ " where ra.anoMesReferencia = :anoMesReferencia and" + " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or"
							+ " ra.categoria.id = 3 or" + " ra.categoria.id = 4)" + " group by " + " ra.gerenciaRegional.nome,"
							+ " ra.gerenciaRegional.id," + " ra.localidade.descricao," + " ra.localidade.id," + " rt.descricao,"
							+ " lt.descricao," + " li.descricao," + " lic.descricao," + " lt.indicadorImpressao," + " lt.indicadorTotal,"
							+ " lt.id," + " lt.lancamentoTipo.id," + " ra.categoria.id," + " rt.id," + " ra.sequenciaTipoLancamento,"
							+ " ra.sequenciaItemTipoLancamento," + " ra.unidadeNegocio.nome, " + " ra.unidadeNegocio.id " + " order by "
							+ " ra.localidade.id," + " ra.unidadeNegocio.id," + " ra.gerenciaRegional.id," + " rt.id,"
							+ " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorGerenciaRegional(int anoMesReferencia, Integer gerenciaRegional)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(ra.valorItemArrecadacao)," + " rt.descricao," + " lt.descricao," + " li.descricao," + " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id," + " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id," + " rt.id,"
							+ " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento" + " from ResumoArrecadacao ra"
							+ " left join ra.lancamentoTipo lt" + " left join ra.lancamentoItem li"
							+ " left join ra.lancamentoItemContabil lic" + " left join ra.recebimentoTipo rt"
							+ " where ra.anoMesReferencia = :anoMesReferencia and" + " ra.gerenciaRegional = :gerenciaRegional and "
							+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or" + " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
							+ " group by " + " rt.descricao," + " lt.descricao," + " li.descricao," + " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id," + " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id," + " rt.id,"
							+ " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento" + " order by rt.id,"
							+ " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("gerenciaRegional",
							gerenciaRegional).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorGerenciaRegionalPorLocalidade(int anoMesReferencia, Integer gerenciaRegional)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(ra.valorItemArrecadacao)," + " rt.descricao," + " lt.descricao," + " li.descricao," + " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id," + " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id," + " ra.localidade.descricao,"
							+ " ra.localidade.id," + " rt.id," + " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento"
							+ " from ResumoArrecadacao ra" + " left join ra.lancamentoTipo lt" + " left join ra.lancamentoItem li"
							+ " left join ra.lancamentoItemContabil lic" + " left join ra.recebimentoTipo rt"
							+ " where ra.anoMesReferencia = :anoMesReferencia and" + " ra.gerenciaRegional = :gerenciaRegional and"
							+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or" + " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
							+ " group by " + " ra.localidade.descricao," + " ra.localidade.id," + " rt.descricao," + " lt.descricao,"
							+ " li.descricao," + " lic.descricao," + " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id,"
							+ " lt.lancamentoTipo.id," + " ra.categoria.id," + " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id,"
							+ " rt.id," + " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento" + " order by "
							+ " ra.localidade.id," + " rt.id," + " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento,"
							+ " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("gerenciaRegional",
							gerenciaRegional).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 23/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorLocalidade(int anoMesReferencia, Integer localidade)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(ra.valorItemArrecadacao)," + " rt.descricao," + " lt.descricao," + " li.descricao," + " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id," + " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " ra.localidade.descricao," + " ra.localidade.id," + " rt.id,"
							+ " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento" + " from ResumoArrecadacao ra"
							+ " left join ra.lancamentoTipo lt" + " left join ra.lancamentoItem li"
							+ " left join ra.lancamentoItemContabil lic" + " left join ra.recebimentoTipo rt"
							+ " where ra.anoMesReferencia = :anoMesReferencia and" + " ra.localidade = :localidade and"
							+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or" + " ra.categoria.id = 3 or" + " ra.categoria.id = 4)"
							+ " group by " + " rt.descricao," + " lt.descricao," + " li.descricao," + " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id," + " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " ra.localidade.descricao," + " ra.localidade.id," + " rt.id,"
							+ " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento" + " order by rt.id,"
							+ " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("localidade", localidade)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @created 02/06/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQtdeRegistrosResumoArrecadacaoRelatorio(int anoMesReferencia, Integer localidade, Integer gerenciaRegional,
					String opcaoTotalizacao, Integer idSetorComercial) throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select count(ra.id)" + " from ResumoArrecadacao ra" + " where ra.anoMesReferencia = :anoMesReferencia and"
							+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or" + " ra.categoria.id = 3 or" + " ra.categoria.id = 4)";

			if(opcaoTotalizacao.equals("localidade") && localidade != null){

				consulta = consulta + " and ra.localidade = :localidade";

				if(idSetorComercial != null){
					consulta = consulta + " and ra.setorComercial.id = :idSetorComercial ";

					retorno = ((Number) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger(
									"localidade", localidade).setInteger("idSetorComercial", idSetorComercial).uniqueResult()).intValue();
				}else{
					retorno = ((Number) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger(
									"localidade", localidade).uniqueResult()).intValue();
				}

			}else if((opcaoTotalizacao.equals("gerenciaRegionalLocalidade") || opcaoTotalizacao.equals("gerenciaRegional"))
							&& gerenciaRegional != null){

				consulta = consulta + " and ra.gerenciaRegional = :gerenciaRegional";

				retorno = ((Number) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger(
								"gerenciaRegional", gerenciaRegional).uniqueResult()).intValue();
			}else{
				retorno = ((Number) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult())
								.intValue();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0352] Emitir Conta
	 * pesquisa o nome do banco e código da agencia passando o id do imóvel
	 * [SB0017] - Gerar Linhas das contas com Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 26/05/2006
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsDebitoAutomatico(Integer idImovel) throws ErroRepositorioException{

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "select banco.descricao," + "agencia.codigoAgencia, " + "banco.id, " + "debAutomatico.identificacaoClienteBanco "
							+ "from DebitoAutomatico debAutomatico " + "inner join debAutomatico.agencia agencia "
							+ "inner join debAutomatico.imovel imov " + "inner join agencia.banco banco " + "where imov.id = :idImovel "
							+ "and debAutomatico.dataExclusao is null ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Inseri os resumos das arrecadações gerados pelo batch no sistema
	 * 
	 * @author Pedro Alexandre
	 * @date 17/05/2006
	 * @param colecaoResumoArrecadacao
	 * @throws ErroRepositorioException
	 */
	public void inserirResumoArrecadacao(Collection<ResumoArrecadacao> colecaoResumoArrecadacao) throws ErroRepositorioException{

		StatelessSession session = HibernateUtil.getStatelessSession();
		try{

			// Caso a coleção de resumos da arrecadação seja diferente de nulo
			// insere os resumos e a cada 50 registros inseridos comita e limpa
			// a sessão
			if(colecaoResumoArrecadacao != null){
				// int i = 1;
				for(ResumoArrecadacao resumoArrecadacao : colecaoResumoArrecadacao){
					session.insert(resumoArrecadacao);
					/*
					 * if (i % 50 == 0) { session.flush(); session.clear(); }
					 * i++;
					 */
				}
				// session.flush();
				// session.clear();
			}
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// session.clear();
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Verifica se já existe resumo da arrecadação para o ano/mês de referência
	 * da arrecadação
	 * [FS0003] - Verificar a existência do resumo da arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoArrecadacaoPorAnoMesArrecadacao(Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from ResumoArrecadacao resumoArrecadacao "
							+ "where resumoArrecadacao.anoMesReferencia = :anoMesReferenciaArrecadacao ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de resumo de faturamento pesquisada
		// ou nulo se não existir dados para o ano/mês da arrecadação informado
		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Verifica se já existe resumo da arrecadação para o ano/mês de referência
	 * da arrecadação
	 * [FS0003] - Verificar a existência do resumo da arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoArrecadacaoPorAnoMesArrecadacao(Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from ResumoArrecadacao resumoArrecadacao "
							+ "where resumoArrecadacao.anoMesReferencia = :anoMesReferenciaArrecadacao "
							+ "and resumoArrecadacao.localidade.id = :idLocalidade";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de resumo de faturamento pesquisada
		// ou nulo se não existir dados para o ano/mês da arrecadação informado
		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos classificados de conta do ano/mês de referência da
	 * arrecadação com a situação atual(PGST_IDATUAL) igual a pagamento
	 * classificado ou baixar valor excedente e com o código da conta diferente
	 * de nulo (CNTA_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosClassificadosContas(Integer anoMesReferenciaArrecadacao)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.conta.id is not null " + "order by pgmt.conta.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos classificados de guia de pagamento do ano/mês de
	 * referência da arrecadação com a situação atual(PGST_IDATUAL) igual a
	 * pagamento classificado ou baixar valor excedente e com o código da guia
	 * de pagamento diferente de nulo (GPAG_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosClassificadosGuiasPagamento(Integer anoMesReferenciaArrecadacao)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao = :anoMesRefereciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.guiaPagamentoGeral.id is not null " + "order by pgmt.guiaPagamentoGeral.id";
			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos classificados de débito a cobrar do ano/mês de
	 * referência da arrecadação com a situação atual(PGST_IDATUAL) igual a
	 * pagamento classificado ou baixar valor excedente e com o código do débito
	 * a cobrar diferente de nulo (DBAC_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosClassificadosDebitoACobrar(Integer anoMesReferenciaArrecadacao)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.debitoACobrar.id is not null " + "order by pgmt.debitoACobrar.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos não classificados do mês, que são do ano/mês de
	 * referência da arrecadação com a situação atual(PGST_IDATUAL) diferente de
	 * pagamento classificado
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosNaoClassificadosMes(Integer anoMesReferenciaArrecadacao)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções classificadas do ano/mês de referência da
	 * arrecadação e com situação atual igual a devolução classificada ou
	 * devolução de outros valores
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesClassificadas(Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Devolucao devl " + "where devl.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and (devl.devolucaoSituacaoAtual.id = " + DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " or "
							+ "devl.devolucaoSituacaoAtual.id = " + DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES + ") ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções não classificadas do mês, para situação atual
	 * diferente de devolução classificada e devolução de outros valores
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesNaoClassificadasMes(Integer anoMesReferenciaArrecadacao)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Devolucao devl " + "where devl.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and devl.devolucaoSituacaoAtual.id <> " + DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " and "
							+ "devl.devolucaoSituacaoAtual.id <> " + DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês, que sãoos do ano/mês de referência anterior ao da
	 * arrecadação, que foram classificados no mês, com situação atual igual a
	 * pagamento classificado ou baixar valor excedente e com código da conta
	 * diferente de nulo (CNTA_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosContasEfetuadosEmMesesAnterioresClassificadosMes(Integer anoMesReferenciaArrecadacao)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.conta.id is not null " + "order by pgmt.conta.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos de guias de pagamento efetuados em meses
	 * anteriores classificados no mês, que são os do ano/mês de referência
	 * anterior ao da arrecadação, que foram classificados no mês, com situação
	 * atual igual a pagamento classificado ou baixar valor excedente e com
	 * código da guia de pagamento diferente de nulo (GPAG_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosGuiasPagamentoEfetuadosEmMesesAnterioresClassificadosMes(
					Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao < :anoMesRefereciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.guiaPagamentoGeral.id is not null " + "order by pgmt.guiaPagamentoGeral.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos de débitos a cobrar efetuados em meses anteriores
	 * classificados no mês, que são os do ano/mês de referência anterior ao da
	 * arrecadação, que foram classificados no mês, com situação atual igual a
	 * pagamento classificado ou baixar valor excedente e com código do débito a
	 * cobrar diferente de nulo (DBAC_ID <> NULL)
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosDebitoACobrarEfetuadosEmMesesAnterioresClassificadosMes(
					Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.debitoACobrar.id is not null " + "order by pgmt.debitoACobrar.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções efetuadas em meses anteriores classificadas no
	 * mês, que são as do ano/mês de referência anterior ao da arrecadação e que
	 * foram classificadas no mês, comsituação atual igual a devolução
	 * classificada ou devolução de outros valores.
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMes(Integer anoMesReferenciaArrecadacao)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Devolucao devl " + "where devl.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and (devl.devolucaoSituacaoAtual.id = " + DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " or "
							+ "devl.devolucaoSituacaoAtual.id = " + DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES + ") ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos não classificados com baixa comandada, que são os
	 * que estão com a situação atual com o valor correspondente a baixar
	 * excedente
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosNaoClassificadosComBaixaComandada() throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + "where pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacaoAtual ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("pagamentoSituacaoAtual", PagamentoSituacao.VALOR_A_BAIXAR).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos não classificados, que são os do ano/mês de
	 * referência igual ou anterior ao da arrecadação e que estão não
	 * classificados,com situação atual diferente de pagamento classificado e de
	 * baixar valor excedente
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosNaoClassificados(Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + " where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao"
							+ " and pgmt.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO
							+ " and pgmt.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.VALOR_A_BAIXAR;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções não classificadas, que são as do ano/mês de
	 * referência igual ou anterior ao da arrecadação e que continuam não
	 * classificados, com situação atual com o valor diferente de devolução
	 * classificada e devolução de outros valores.
	 * 
	 * @author Pedro Alexandre
	 * @date 16/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesNaoClassificadas(Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Devolucao devl " + "where devl.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
							+ "and devl.devolucaoSituacaoAtual.id <> " + DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " and "
							+ "devl.devolucaoSituacaoAtual.id <> " + DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 100
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor de água por categoria e localidade paa os pagamentos
	 * classificados de conta
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorAguaPagamentosClassificadosConta(Integer idLocalidade, Integer anoMesReferenciaArrecadacao,
					Integer idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(ctcg.valorAgua) " + "from ContaCategoria ctcg " + "where ctcg.comp_id.categoria.id= :idCategoria "
							+ " and ctcg.comp_id.conta.id in ( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id =:idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger("idLocalidade", idLocalidade)
							.setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
											"idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 200
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor de esgoto por categoria e localidade paa os pagamentos
	 * classificados de conta
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEsgotoPagamentosClassificadosConta(Integer idLocalidade, Integer anoMesReferenciaArrecadacao,
					Integer idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(ctcg.valorEsgoto) " + "from ContaCategoria ctcg " + "where ctcg.comp_id.categoria.id= :idCategoria "
							+ " and ctcg.comp_id.conta.id in ( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger("idLocalidade", idLocalidade)
							.setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
											"idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 300
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor do débitos cobrados por localidade, categoria e item
	 * contábil dos pagamentos classificados de conta para tipo de financiamento
	 * igual a serviço
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico(Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer
	 * idLancamentoItemContabil, Integer idCategoria) throws
	 * ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where
	 * dccg.categoria.id=" + idCategoria + " and dccg.debitoCobrado.id in (
	 * select dbcb.id from DebitoCobrado dbcb " + "where
	 * dbcb.lancamentoItemContabil.id = " + idLancamentoItemContabil + " and
	 * (dbcb.financiamentoTipo.id = " + FinanciamentoTipo.SERVICO_NORMAL + " or
	 * dbcb.financiamentoTipo.id = "+ FinanciamentoTipo.ARRASTO_AGUA + " or
	 * dbcb.financiamentoTipo.id = "+ FinanciamentoTipo.ARRASTO_ESGOTO + " or
	 * dbcb.financiamentoTipo.id = "+ FinanciamentoTipo.ARRASTO_SERVICO + ")" + "
	 * and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento
	 * pgmt " + "where pgmt.anoMesReferenciaArrecadacao =
	 * :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id =" +
	 * idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 400
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * parcelamento de água
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua(Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria)
	 * throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where
	 * dccg.categoria.id=" + idCategoria + " and dccg.debitoCobrado.id in (
	 * select dbcb.id from DebitoCobrado dbcb " + "where
	 * dbcb.financiamentoTipo.id = " + FinanciamentoTipo.PARCELAMENTO_AGUA + "
	 * and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento
	 * pgmt " + "where pgmt.anoMesReferenciaArrecadacao =
	 * :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id =" +
	 * idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 500
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * parcelamento de esgoto
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto(Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria)
	 * throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where
	 * dccg.categoria.id =" + idCategoria + " and dccg.debitoCobrado.id in (
	 * select dbcb.id from DebitoCobrado dbcb " + "where
	 * dbcb.financiamentoTipo.id = " + FinanciamentoTipo.PARCELAMENTO_ESGOTO + "
	 * and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento
	 * pgmt " + "where pgmt.anoMesReferenciaArrecadacao =
	 * :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id =" +
	 * idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */
	/**
	 * Sequencial do tipo lançamento igual a 600
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * parcelamento de serviço e grupo de parcelamento diferente de juros
	 * cobrados
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
	 * (Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria,
	 * Integer idLancamentoItemContabil) throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where
	 * dccg.categoria.id=" + idCategoria + " and dccg.debitoCobrado.id in (
	 * select dbcb.id from DebitoCobrado dbcb " + "where
	 * dbcb.lancamentoItemContabil.id = " + idLancamentoItemContabil + " and
	 * dbcb.financiamentoTipo.id =" + FinanciamentoTipo.PARCELAMENTO_SERVICO +
	 * //"and dbcb.parcelamentoGrupo.id <>" + ParcelamentoGrupo.JUROS_COBRADOS + "
	 * and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento
	 * pgmt " + "where pgmt.anoMesReferenciaArrecadacao =
	 * :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id =" +
	 * idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 700
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * parcelamento de serviço e grupo de parcelamento igual a juros cobrados
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id= :idCategoria "
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.financiamentoTipo.id = :idFinanciamentoTipo "
							+ " and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.JUROS_PARCELAMENTO).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
							.setInteger("idLocalidade", idLocalidade).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 800
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos créditos realizados por localidade e categoria para
	 * os pagamentos classificados de contas, para origem de crédito igual a
	 * contas pagas em duplicidade/excesso.
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso
	 * (Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria)
	 * throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg " +
	 * "where crcg.categoria.id=" + idCategoria + " and crcg.creditoRealizado.id
	 * in ( select crrz.id from CreditoRealizado crrz " + "where
	 * crrz.creditoOrigem.id =" +
	 * CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO + " and crrz.conta.id
	 * in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt " + "where
	 * pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao " + "and
	 * pgmt.localidade.id =" + idLocalidade + " " + "and
	 * (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 900
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos créditos realizados por localidade, categoria e item
	 * contábil para os pagamentos classificados de contas, para origem de
	 * crédito igual a valores cobrados indevidamente.
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idLancamentoItemContabil)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		Collection idsCreditosOrigem = new ArrayList();
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_AGUA);
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO);
		idsCreditosOrigem.add(CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE);
		idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO);

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg "
							+ "where crcg.comp_id.categoria.id= :idCategoria "
							+ " and crcg.creditoRealizado.id in ( select crrz.id from CreditoRealizado crrz "
							+ "where crrz.lancamentoItemContabil.id = :idLancamentoItemContabil"
							+ " and crrz.creditoOrigem.id in (:idsCreditosOrigem)"
							+ " and crrz.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade " + "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado "
							+ " or " + "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar" + ") "
							+ "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"idLancamentoItemContabil", idLancamentoItemContabil).setParameterList("idsCreditosOrigem", idsCreditosOrigem)
							.setInteger("idLocalidade", idLocalidade).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).setInteger("anoMesReferenciaArrecadacao",
											anoMesReferenciaArrecadacao).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1000
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos créditos realizados por localidade e categoria para
	 * os pagamentos classificados de contas, para origem de crédito igual a
	 * descontos concedidos.
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idCreditoOrigem) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg "
							+ "where crcg.comp_id.categoria.id= :idCategoria"
							+ " and crcg.creditoRealizado.id in ( select crrz.id from CreditoRealizado crrz "
							+ "where crrz.creditoOrigem.id = :idCreditoOrigem " + " and crrz.conta.id in( select distinct(pgmt.conta.id) "
							+ "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar ) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger("idCreditoOrigem",
							idCreditoOrigem).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1700
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor da entrada do parcelamento por localidade e categoria dos
	 * pagamentos classificados de guias de pagamento com tipo de financiamento
	 * igual a entrada de parcelamento
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoEntradaParcelamento(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{
			// Cria o hql de pesquisa
			consulta = "select sum(gpcg.valorCategoria) " + "from GuiaPagamentoCategoria gpcg " + "where gpcg.categoria.id= :idCategoria "
							+ " and gpcg.guiaPagamento.id in ( select gpag.id from GuiaPagamento gpag "
							+ "where gpag.financiamentoTipo.id = :idFinanciamentoTipo "
							+ " and gpag.id in( select distinct(pgmt.guiaPagamentoGeral.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id =:idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.guiaPagamentoGeral.id is not null "
							+ ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.ENTRADA_PARCELAMENTO).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
							.setInteger("idLocalidade", idLocalidade).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1800
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor da guia de pagamento por localidade, categoria e item
	 * contábil dos pagamentos classificados de guias de pagamento com tipo de
	 * financiamento igual a serviço
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idLancamentoItemContabil, Integer idCategoria)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(gpcg.valorCategoria) " + "from GuiaPagamentoCategoria gpcg " + "where gpcg.categoria.id= :idCategoria "
							+ " and gpcg.guiaPagamento.id in ( select gpag.id from GuiaPagamento gpag "
							+ "where gpag.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ " and gpag.financiamentoTipo.id = :idFinanciamentoTipo "
							+ " and gpag.id in( select distinct(pgmt.guiaPagamentoGeral.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.guiaPagamentoGeral.id is not null "
							+ ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"idLancamentoItemContabil", idLancamentoItemContabil).setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.SERVICO_NORMAL).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
							.setInteger("idLocalidade", idLocalidade).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1900
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor que falta ser cobrado dos débitos a cobrar dos pagamentos
	 * classificados de débito a cobrar por localidade, categoria e item
	 * contábil
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idLancamentoItemContabil, Integer idCategoria)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa

			consulta = "select sum(dbcg.valorCategoria - ((dbcg.valorCategoria / dbac.numeroPrestacaoDebito) * dbac.numeroPrestacaoCobradas)) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.debitoACobrar dbac "
							+ "where dbcg.debitoACobrar.id = dbac.id and dbac.lancamentoItemContabil.id= :idLancamentoItemContabil "
							+ " and dbac.localidade.id= :idLocalidade "
							+ " and dbcg.categoria.id= :idCategoria "
							+ " and dbac.id in ("
							+ "select distinct(pgmt.debitoACobrar.id)"
							+ "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
							+ "and pgmt.debitoACobrar.id is not null "
							+ " )";

			// Executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria).setInteger(
											"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
											"idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
											"idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 2600
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções classificadas para acumular o valor da devolução
	 * por categoria com situação igual a devolução classificada.
	 * 
	 * @author Pedro Alexandre
	 * @date 25/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesClassificadasSituacaoAtualDevolucaoClassificada(Integer anoMesReferenciaArrecadacao,
					Integer idLocalidade) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select devl.valorDevolucao, imov.id from Devolucao devl " + "inner join devl.localidade loca "
							+ "left join devl.imovel imov " + "left join devl.devolucaoSituacaoAtual desa "
							+ "where devl.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and desa.id = :idDevolucaoSituacaoAtual " + "and loca.id = :idLocalidade";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idDevolucaoSituacaoAtual",
							DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA)
							.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 2700
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções classificadas para acumular o valor da devolução
	 * por categoria e item contábil com situação igual a devolução de outros
	 * valores.
	 * 
	 * @author Pedro Alexandre
	 * @date 25/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores(Integer anoMesReferenciaArrecadacao,
					Integer idLocalidade, Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select devl.valorDevolucao, imov.id from Devolucao devl " + "inner join devl.localidade loca "
							+ "left join devl.imovel imov " + "left join devl.devolucaoSituacaoAtual dvsa "
							+ "inner join devl.debitoTipo dbtp " + "inner join dbtp.lancamentoItemContabil lict "
							+ "where devl.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and dvsa.id = :idDevolucaoSituacaoAtual " + "and loca.id = :idLocalidade "
							+ "and lict.id = :idLancamentoItemContabil";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idDevolucaoSituacaoAtual", DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES)
							.setInteger("idLocalidade", idLocalidade)
							.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger("idLancamentoItemContabil",
											idLancamentoItemContabil).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3500
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor de água por localidade e categoria para os pagamentos de
	 * contas efetuados em meses anteriores classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(ctcg.valorAgua) " + "from ContaCategoria ctcg " + "where ctcg.comp_id.categoria.id= :idCategoria "
							+ " and ctcg.comp_id.conta.id in ( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger("idLocalidade", idLocalidade)
							.setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
											"idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3600
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor de esgoto por localidade e categoria para os pagamentos
	 * de contas efetuados em meses anteriores classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(ctcg.valorEsgoto) " + "from ContaCategoria ctcg " + "where ctcg.comp_id.categoria.id= :idCategoria "
							+ " and ctcg.comp_id.conta.id in ( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger("idLocalidade", idLocalidade)
							.setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
											"idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3700
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual a serviço.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico
	 * (Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer
	 * idLancamentoItemContabil, Integer idCategoria) throws
	 * ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where
	 * dccg.categoria.id=" + idCategoria + " and dccg.debitoCobrado.id in (
	 * select dbcb.id from DebitoCobrado dbcb " + "where
	 * dbcb.lancamentoItemContabil.id = " + idLancamentoItemContabil + " and
	 * (dbcb.financiamentoTipo.id = " + FinanciamentoTipo.SERVICO_NORMAL + " or
	 * dbcb.financiamentoTipo.id ="+ FinanciamentoTipo.ARRASTO_AGUA + " or
	 * dbcb.financiamentoTipo.id ="+ FinanciamentoTipo.ARRASTO_ESGOTO + " or
	 * dbcb.financiamentoTipo.id ="+ FinanciamentoTipo.ARRASTO_SERVICO + ")"+ "
	 * and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento
	 * pgmt " + "where pgmt.anoMesReferenciaArrecadacao <
	 * :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id =" +
	 * idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 3800
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade e categoria para os
	 * pagamentos de contas efetuados em meses anteriores classificados no mês
	 * para tipo de financiamento igual a parcelamento de água.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua
	 * (Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria)
	 * throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where
	 * dccg.categoria.id=" + idCategoria + " and dccg.debitoCobrado.id in (
	 * select dbcb.id from DebitoCobrado dbcb " + "where
	 * dbcb.financiamentoTipo.id = " + FinanciamentoTipo.PARCELAMENTO_AGUA + "
	 * and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento
	 * pgmt " + "where pgmt.anoMesReferenciaArrecadacao <
	 * :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id =" +
	 * idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 3900
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade e categoria para os
	 * pagamentos de contas efetuados em meses anteriores classificados no mês
	 * para tipo de financiamento igual a parcelamento de esgoto.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto
	 * (Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria)
	 * throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where
	 * dccg.categoria.id=" + idCategoria + " and dccg.debitoCobrado.id in (
	 * select dbcb.id from DebitoCobrado dbcb " + "where
	 * dbcb.financiamentoTipo.id = " + FinanciamentoTipo.PARCELAMENTO_ESGOTO + "
	 * and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento
	 * pgmt " + "where pgmt.anoMesReferenciaArrecadacao <
	 * :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id =" +
	 * idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 4000
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual a parcelamento de
	 * serviço e grupo de parcelamento diferente de juros cobrados.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
	 * (Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria,
	 * Integer idLancamentoItemContabil) throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where
	 * dccg.categoria.id=" + idCategoria + " and dccg.debitoCobrado.id in (
	 * select dbcb.id from DebitoCobrado dbcb " + "where
	 * dbcb.lancamentoItemContabil.id = " + idLancamentoItemContabil + " and
	 * dbcb.financiamentoTipo.id =" + FinanciamentoTipo.PARCELAMENTO_SERVICO +
	 * //"and dbcb.parcelamentoGrupo.id <>" + ParcelamentoGrupo.JUROS_COBRADOS + "
	 * and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento
	 * pgmt " + "where pgmt.anoMesReferenciaArrecadacao <
	 * :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id =" +
	 * idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 4100
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual a parcelamento de
	 * serviço e grupo de parcelamento igual a juros cobrados.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id= :idCategoria "
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.financiamentoTipo.id = :idFinanciamentoTipo "
							+ " and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.JUROS_PARCELAMENTO).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
							.setInteger("idLocalidade", idLocalidade).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4200
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos créditos realizados por localidade e categoria para
	 * os pagamentos de contas efetuados em meses anteriores classificados no
	 * mês, para origem do crédito igual a documentos pagos em
	 * duplicidade/excesso.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso
	 * (Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria)
	 * throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg " +
	 * "where crcg.categoria.id=" + idCategoria + " and crcg.creditoRealizado.id
	 * in ( select crrz.id from CreditoRealizado crrz " + "where
	 * crrz.creditoOrigem.id =" +
	 * CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO + " and crrz.conta.id
	 * in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt " + "where
	 * pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao " + "and
	 * pgmt.localidade.id =" + idLocalidade + " " + "and
	 * (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal)
	 * session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao",
	 * anoMesReferenciaArrecadacao).uniqueResult(); // erro no hibernate } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */
	/**
	 * Sequencial do tipo lançamento igual a 4300
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos créditos realizados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês, para origem do crédito igual a valores cobrados
	 * indevidamente.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idLancamentoItemContabil)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Coleção de crédito origem de valores cobrados indevidamente
			Collection idsCreditosOrigem = new ArrayList();
			idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_AGUA);
			idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO);
			idsCreditosOrigem.add(CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE);
			idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO);

			// Cria o hql de pesquisa
			consulta = "select sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg "
							+ "where crcg.comp_id.categoria.id= :idCategoria "
							+ " and crcg.creditoRealizado.id in ( select crrz.id from CreditoRealizado crrz "
							+ "where crrz.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ " and crrz.creditoOrigem.id in (:idsCreditosOrigem) "
							+ " and crrz.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar ) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"idLancamentoItemContabil", idLancamentoItemContabil).setParameterList("idsCreditosOrigem", idsCreditosOrigem)
							.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
							.setInteger("idLocalidade", idLocalidade).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4400
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos créditos realizados por localidade e categoria, para
	 * os pagamentos de contas efetuados em meses anteriores classificados no
	 * mês, para origem do crédito igual a descontos concedidos.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public BigDecimal
	 * acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos
	 * (Integer
	 * idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria)
	 * throws ErroRepositorioException {
	 * BigDecimal retorno = null; // cria uma sessão com o hibernate Session
	 * session = HibernateUtil.getSession(); // cria a variável que vai conter o
	 * hql String consulta = "";
	 * try { // Cria o hql de pesquisa consulta = "select
	 * sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg " +
	 * "where crcg.comp_id.categoria.id=" + idCategoria + " and
	 * crcg.creditoRealizado.id in ( select crrz.id from CreditoRealizado crrz " +
	 * "where crrz.creditoOrigem.id =" +
	 * CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO + " and crrz.conta.id
	 * in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt " + "where
	 * pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao " + "and
	 * pgmt.localidade.id =" + idLocalidade + " " + "and
	 * (pgmt.pagamentoSituacaoAtual.id = " +
	 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
	 * "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") " +
	 * "and pgmt.conta.id is not null " + ") )";
	 * retorno = (BigDecimal) session.createQuery(consulta)
	 * .setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
	 * .uniqueResult(); // erro no hibernate } catch (HibernateException e) { //
	 * levanta a exceção para a próxima camada throw new
	 * ErroRepositorioException(e, "Erro no Hibernate"); } finally { // fecha a
	 * sessão com o hibernate HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * Sequencial do tipo lançamento igual a 5100
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor das entrads do parcelamento por localidade e categoria
	 * dos pagamento de guias de pagamento efetuados em meses anteriores
	 * classificados no mês com tipo de financiamento igual a entrada de
	 * parcelamento.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(gpcg.valorCategoria) " + "from GuiaPagamentoCategoria gpcg " + "where gpcg.categoria.id= :idCategoria "
							+ " and gpcg.guiaPagamento.id in ( select gpag.id from GuiaPagamento gpag "
							+ "where gpag.financiamentoTipo.id = :idFinanciamentoTipo "
							+ "and gpag.id in( select distinct(pgmt.guiaPagamentoGeral.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.guiaPagamentoGeral.id is not null "
							+ ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.ENTRADA_PARCELAMENTO).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
							.setInteger("idLocalidade", idLocalidade).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 5200
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor das entrads do parcelamento por localidade, categoria e
	 * item contábil dos pagamento de guias de pagamento efetuados em meses
	 * anteriores classificados no mês com tipo de financiamento igual a
	 * serviço.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idLancamentoItemContabil, Integer idCategoria)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(gpcg.valorCategoria) " + "from GuiaPagamentoCategoria gpcg " + "where gpcg.categoria.id= :idCategoria "
							+ " and gpcg.guiaPagamento.id in ( select gpag.id from GuiaPagamento gpag "
							+ "where gpag.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ " and gpag.financiamentoTipo.id = :idFinanciamentoTipo "
							+ " and gpag.id in( select distinct(pgmt.guiaPagamentoGeral.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.guiaPagamentoGeral.id is not null "
							+ ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"idLancamentoItemContabil", idLancamentoItemContabil).setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.SERVICO_NORMAL).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
							.setInteger("idLocalidade", idLocalidade).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 5300
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor que falta ser cobrado dos débitos a cobrar por
	 * localidade, categoria e item contábil para os pagamentos de débitos a
	 * cobrar efetuados em meses anteriores classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idLancamentoItemContabil, Integer idCategoria)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		BigDecimal retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa

			consulta = "select sum(dbcg.valorCategoria - ((dbcg.valorCategoria / dbac.numeroPrestacaoDebito) * dbac.numeroPrestacaoCobradas)) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.debitoACobrar dbac "
							+ "where dbcg.debitoACobrar.id = dbac.id and dbac.lancamentoItemContabil.id= :idLancamentoItemContabil "
							+ " and dbac.localidade.id= :idLocalidade "
							+ " and dbcg.categoria.id= :idCategoria "
							+ " and dbac.id in ("
							+ "select distinct(pgmt.debitoACobrar.id)"
							+ "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
							+ "and pgmt.debitoACobrar.id is not null "
							+ " )";

			// Executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria).setInteger(
											"anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
											"idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger(
											"idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 5500
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções efetuadas em meses anteriores classificadas no mês
	 * para acumular o valor da devolução por localidade e categoria com
	 * situação atual igual a devolução classificada.
	 * 
	 * @author Pedro Alexandre
	 * @date 30/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada(
					Integer anoMesReferenciaArrecadacao, Integer idLocalidade) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select devl.valorDevolucao, imov.id from Devolucao devl " + "inner join devl.localidade loca "
							+ "left join devl.imovel imov " + "left join devl.devolucaoSituacaoAtual dvstatual "
							+ "where devl.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and dvstatual.id = :idDevolucaoSituacaoAtual " + "and loca.id = :idLocalidade";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idDevolucaoSituacaoAtual", DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA).setInteger("idLocalidade", idLocalidade)
							.list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 5600
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções efetuadas em meses anteriores classificadas no mês
	 * para acumular o valor da devolução por localidade, categoria e item
	 * contábil, com situação atual igual a devolução de outros valores.
	 * 
	 * @author Pedro Alexandre
	 * @date 31/05/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores(
					Integer anoMesReferenciaArrecadacao, Integer idLocalidade, Integer idLancamentoItemContabil)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{
			// Cria o hql de pesquisa
			consulta = "select devl.valorDevolucao, imov.id from Devolucao devl " + "inner join devl.localidade loca "
							+ "left join devl.imovel imov " + "left join devl.devolucaoSituacaoAtual dvsa "
							+ "inner join devl.debitoTipo dbtp " + "inner join dbtp.lancamentoItemContabil lict "
							+ "where devl.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and dvsa.id = :idDevolucaoSituacaoAtual " + "and loca.id = :idLocalidade "
							+ "and lict.id = :idLancamentoItemContabil";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idDevolucaoSituacaoAtual", DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES)
							.setInteger("idLocalidade", idLocalidade).setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 6200 (SOMA DOS
	 * SEQ.1200,1300,1400,1500,4600,4700,4800 e 4900)
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Este metódo acumular os valores dos sequencias : 1200, 1300, 1400, 1500,
	 * 4600, 4700, 4800 e 4900, para ser acumulado negativamente á soma dos
	 * recebimentos de valores contabilizados como perdas.
	 * 
	 * @author Pedro Alexandre
	 * @date 02/06/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpostosDeduzidosPagamentosClassificadosNoMesMesesAnterioresContaContabilizadasComoPerdasImpostoTipoIRCSLLCOFINSPISPASEP(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select cnid.valorImposto, imov.id " + "from ContaImpostosDeduzidos cnid " + "inner join cnid.conta cnta "
							+ "inner join cnta.imovel imov " + "inner join cnid.impostoTipo imtp " + "where (imtp.id ="
							+ ImpostoTipo.IR
							+ " "
							+ "or imtp.id ="
							+ ImpostoTipo.CSLL
							+ " "
							+ "or imtp.id ="
							+ ImpostoTipo.COFINS
							+ " "
							+ "or imtp.id ="
							+ ImpostoTipo.PIS_PASEP
							+ ") "
							+ "and cnta.id in ( select distinct(pgmt.conta.id) "
							+ "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ " "
							+ "and (pgmt.pagamentoSituacaoAtual.id = "
							+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO
							+ " or "
							+ "pgmt.pagamentoSituacaoAtual.id = "
							+ PagamentoSituacao.VALOR_A_BAIXAR + ") " + "and pgmt.conta.id is not null )";
			// + "order by pgmt.conta.id) ";

			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os débitos cobrados das contas dos pagamentos classificados de
	 * contas e dos pagamentos anteriores de conta classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 02/06/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoCobrado> pesquisarDebitosCobradosContasPagamentosClassificadosPagamentosAnterioresContaClassificadosNoMes(
					Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<DebitoCobrado> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from DebitoCobrado dbcb " + "where dbcb.conta.id in (" + "select pgmt.conta.id from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.conta.id is not null " + "order by pgmt.conta.id)";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os créditos realizados das contas dos pagamentos classificados
	 * de contas e dos pagamentos anteriores de conta classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 02/06/2006
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CreditoRealizado> pesquisarCreditosRealizadosContasPagamentosClassificadosPagamentosAnterioresContaClassificadosNoMes(
					Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<CreditoRealizado> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from CreditoRealizado crrz " + "where crrz.conta.id in (" + "select pgmt.conta.id from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.conta.id is not null " + "order by pgmt.conta.id)";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Conta do Cliente
	 * pesquisarPagamentoClienteConta
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteConta(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria)
					throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			// hql = " select distinct pagamento "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + " inner join pagamento.conta as conta "
			// + " inner join conta.clienteContas as clienteContas "
			// + " left join clienteContas.clienteRelacaoTipo as
			// clienteRelacaoTipo "
			// + condicionais
			// + " order by pagamento.localidade.id, pagamento.imovel.id, "
			// + " pagamento.anoMesReferenciaPagamento, pagamento.dataPagamento
			// "
			// + " ";

			hql = " select c.pgmt_id as idPagamento, i.cnta_id as idConta, i.cnta_amreferenciaconta as anoMesConta, i.cnta_vlagua as valorAguaConta, "
							+ " i.cnta_vlesgoto as valorEsgotoConta, i.cnta_vldebitos as valorDebitosConta, i.cnta_vlcreditos as valorCreditosConta, "
							+ " c.pgmt_dtpagamento as dataPagamento, c.pgmt_amreferenciapagamento as anoMesPagamento, "
							+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " k.pgst_id as idSituacaoPagamentoAnterior, k.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, c.imov_id as idImovel, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento c "
							+ " INNER JOIN conta i  on i.cnta_id = c.cnta_id "
							+ " INNER JOIN cliente_conta b on b.cnta_id = c.cnta_id "
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id "
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id "
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao k on c.pgst_idanterior = k.pgst_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id)"
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " WHERE "
							+ condicionais
							+ " order by c.loca_id, c.imov_id, c.pgmt_amreferenciapagamento, c.pgmt_dtpagamento";

			// colecaoPagamento = session.createQuery(hql).list();

			retorno = session.createSQLQuery(hql).addScalar("idPagamento", Hibernate.INTEGER).addScalar("idConta", Hibernate.INTEGER)
							.addScalar("anoMesConta", Hibernate.INTEGER).addScalar("valorAguaConta", Hibernate.BIG_DECIMAL).addScalar(
											"valorEsgotoConta", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitosConta", Hibernate.BIG_DECIMAL).addScalar("valorCreditosConta", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE).addScalar("anoMesPagamento", Hibernate.INTEGER).addScalar(
											"valorPagamento", Hibernate.BIG_DECIMAL).addScalar("idSituacaoPagamentoAtual",
											Hibernate.INTEGER).addScalar("situacaoPagamentoAtual", Hibernate.STRING).addScalar(
											"idSituacaoPagamentoAnterior", Hibernate.INTEGER).addScalar("situacaoPagamentoAnterior",
											Hibernate.STRING).addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar("idImovel",
											Hibernate.INTEGER).addScalar("avisoBancario", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Guia de Pagamento do Cliente
	 * pesquisarPagamentoClienteGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @author Virgínia Melo
	 * @date 30/03/2009
	 *       Correção na consulta para nova estrutura da guia.
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteGuiaPagamento(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection retorno = null;
		String hql = "";
		Session session = HibernateUtil.getSession();

		try{
			// 2. O sistema seleciona os pagamentos de guia de pagamento do cliente informado (a
			// partir da tabela
			// PAGAMENTO com CLIE_ID = Id do cliente informado ou com GPAG_ID = GPAG_ID da tabela
			// CLIENTE_GUIA_PAGAMENTO com CLIE_ID = Id do cliente informado e CRTP_ID correspondente
			// a um dos Tipos de Relação do Cliente com o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = " SELECT c.pgmt_id as idPagamento, gPagGeral.gpag_id as idGuiaPagamento, c.clie_id as idCliente, "
							+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento,  "
							+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
							+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
							+ " c.imov_id as idImovel, c.loca_id as idLocalidade, "
							+ " c.pgmt_nnprestacao as numeroPrestacao, "
							+ " f.avbc_id as avisoBancario" 
							+ " FROM pagamento c "
							+ " INNER JOIN guia_pagamento_geral gPagGeral on c.gpag_id = gPagGeral.gpag_id "
							+ " INNER JOIN cliente_guia_pagamento b on b.gpag_id = gpagGeral.gpag_id "
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id " + " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id " 
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id)"
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id " + " WHERE "
							+ condicionais
							+ " union "
							+ " SELECT c.pgmt_id as idPagamento, gPagGeral.gpag_id as idGuiaPagamento, c.clie_id as idCliente,  "
							+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, "
							+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
							+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
							+ " c.imov_id as idImovel, c.loca_id as idLocalidade, c.pgmt_nnprestacao as numeroPrestacao, "
							+ " f.avbc_id as avisoBancario"
							+ " FROM pagamento c "
							+ " INNER JOIN cliente a on a.clie_id = c.clie_id "
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id "
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " LEFT OUTER JOIN guia_pagamento_geral gPagGeral on c.gpag_id = gPagGeral.gpag_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id)"
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id " + " WHERE ";

			String condicionaisClientePagamento = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, null, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = hql + condicionaisClientePagamento + " order by idLocalidade, idImovel, idTipoDebitoPagamento, dataPagamento ";

			retorno = session.createSQLQuery(hql).addScalar("idPagamento", Hibernate.INTEGER).addScalar("idGuiaPagamento",
							Hibernate.INTEGER).addScalar("idCliente", Hibernate.INTEGER).addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("anoMesPagamento", Hibernate.INTEGER).addScalar("idTipoDebitoPagamento", Hibernate.INTEGER)
							.addScalar("tipoDebitoPagamento", Hibernate.STRING).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER).addScalar("situacaoPagamentoAtual", Hibernate.STRING)
							.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER).addScalar("situacaoPagamentoAnterior",
											Hibernate.STRING).addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar("idImovel",
											Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER).addScalar("numeroPrestacao",
											Hibernate.INTEGER).addScalar("avisoBancario", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoClienteDebitoACobrar
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteDebitoACobrar(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.dbac_id as idDebitoACobrar, "
							+ " b1.dbac_vldebito as valorDebito, b1.dbac_nnprestacaocobradas as numeroPrestacaoCobradas, "
							+ " b1.dbac_nnprestacaodebito as numeroPrestacaoDebito,  c.pgmt_dtpagamento as dataPagamento, "
							+ " c.pgmt_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoDebito, k.dbtp_dsdebitotipo as tipoDebitoDebito, "
							+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, c.pgmt_vlpagamento as valorPagamento, "
							+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, j.pgst_id as idSituacaoPagamentoAnterior, "
							+ " j.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, b1.imov_id as idImovelDebito, c.loca_id as idLocalidade, "
							+ " f.avbc_id as avisoBancario"
							+ " FROM pagamento c " 
							+ " INNER JOIN debito_a_cobrar b1 on b1.dbac_id = c.dbac_id "
							+ " INNER JOIN cliente_imovel b on b.imov_id = b1.imov_id " 
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id "
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id " 
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " INNER JOIN debito_tipo k on b1.dbtp_id = k.dbtp_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id " + " WHERE " + condicionais
							+ " order by idLocalidade, idImovel, idTipoDebitoPagamento, dataPagamento ";

			retorno = session.createSQLQuery(hql).addScalar("idPagamento", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idDebitoACobrar", Hibernate.INTEGER).addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar(
											"numeroPrestacaoCobradas", Hibernate.SHORT).addScalar("numeroPrestacaoDebito", Hibernate.SHORT)
							.addScalar("dataPagamento", Hibernate.DATE).addScalar("anoMesPagamento", Hibernate.INTEGER).addScalar(
											"idTipoDebitoDebito", Hibernate.INTEGER).addScalar("tipoDebitoDebito", Hibernate.STRING)
							.addScalar("idTipoDebitoPagamento", Hibernate.INTEGER).addScalar("tipoDebitoPagamento", Hibernate.STRING)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
							.addScalar("situacaoPagamentoAtual", Hibernate.STRING).addScalar("idSituacaoPagamentoAnterior",
											Hibernate.INTEGER).addScalar("situacaoPagamentoAnterior", Hibernate.STRING).addScalar(
											"idDocumentoTipo", Hibernate.INTEGER).addScalar("idImovelDebito", Hibernate.INTEGER).addScalar(
											"idLocalidade", Hibernate.INTEGER).addScalar("avisoBancario", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoLocalidade(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal,
							indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = "select DISTINCT pagamento" + " from gcom.arrecadacao.pagamento.Pagamento  pagamento"
							+ " INNER JOIN FETCH pagamento.avisoBancario avbc" 
							+ " INNER JOIN FETCH avbc.arrecadador arrec"
							+ " INNER JOIN FETCH arrec.cliente cliArrec" + " INNER JOIN FETCH pagamento.documentoTipo doctoTp"
							+ " LEFT JOIN FETCH pagamento.conta conta" + " LEFT JOIN pagamento.imovel imov"
							+ " LEFT JOIN imov.localidade locImov" + " LEFT JOIN imov.setorComercial setComImov"
							+ " LEFT JOIN imov.quadra quadra" + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN FETCH pagamento.localidade loc" + " LEFT JOIN FETCH loc.gerenciaRegional gr"
							+ " LEFT JOIN FETCH pagamento.guiaPagamentoGeral gpagGeral " + " LEFT JOIN FETCH gpagGeral.guiaPagamento gpag "
							+ " LEFT JOIN FETCH gpag.guiasPagamentoPrestacao gpagGppr" + " LEFT JOIN FETCH gpagGppr.debitoTipo dbtpGpag"
							+ " LEFT JOIN FETCH pagamento.debitoACobrar dbcb" + " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb"
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual"
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior"
							+ " LEFT JOIN pagamento.imovel.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem" + " " + condicionais;

			// olecaoPagamento = session.createQuery(hql).list();

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setFirstResult(
								10 * numeroPagina).setMaxResults(10).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setFirstResult(10 * numeroPagina)
								.setMaxResults(10).list();
			}else{
				retorno = session.createQuery(hql).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancario(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal,
							indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamento " 
							+ " from gcom.arrecadacao.pagamento.Pagamento  pagamento "
							+ " INNER JOIN FETCH pagamento.avisoBancario  avisoBancario " 
							+ " INNER JOIN FETCH avisoBancario.arrecadador arrec"
							+ " LEFT JOIN FETCH pagamento.conta conta "
							+ " LEFT JOIN FETCH pagamento.guiaPagamentoGeral gpagGeral " 
							+ " LEFT JOIN FETCH pagamento.documentoTipo docTip "
							+ " LEFT JOIN FETCH gpagGeral.guiaPagamento gpag "
							+ " LEFT JOIN FETCH gpag.guiasPagamentoPrestacao gpagGppr " 
							+ " LEFT JOIN FETCH gpagGppr.debitoTipo dbtpGpag "
							+ " LEFT JOIN FETCH pagamento.debitoACobrar dbcb " 
							+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem" + condicionais + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadador(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal,
							indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamento " 
							+ " from gcom.arrecadacao.pagamento.Pagamento  pagamento "
							+ " INNER JOIN FETCH pagamento.arrecadadorMovimentoItem  arrecadadorMovimentoItem "
							+ " INNER JOIN FETCH arrecadadorMovimentoItem.arrecadadorMovimento  arrecadadorMovimento "
							+ " INNER JOIN FETCH pagamento.avisoBancario avbc "
							+ " INNER JOIN FETCH avbc.arrecadador arrec "
							+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp " + " LEFT JOIN FETCH pagamento.conta conta "
							+ " LEFT JOIN pagamento.debitoTipo dbtpPagto " + " LEFT JOIN FETCH pagamento.guiaPagamentoGeral gpagGeral "
							+ " LEFT JOIN FETCH gpagGeral.guiaPagamento gpag " + " LEFT JOIN gpag.guiasPagamentoPrestacao gpagGppr "
							+ " LEFT JOIN gpagGppr.debitoTipo dbtpGpag " + " LEFT JOIN FETCH pagamento.debitoACobrar dbcb "
							+ " LEFT JOIN dbcb.debitoTipo dbtpDbcb " + " LEFT JOIN pagamento.arrecadacaoForma arrecForma "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + " LEFT JOIN pagamento.cliente cli " + condicionais
							+ " order by pagamento.localidade.id, pagamento.imovel.id, "
							+ " pagamento.debitoTipo.id, pagamento.dataPagamento " + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadadorParaPaginacao(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal,
							indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamento " + " from gcom.arrecadacao.pagamento.Pagamento  pagamento "
							+ " INNER JOIN FETCH pagamento.arrecadadorMovimentoItem  arrecadadorMovimentoItem "
							+ " INNER JOIN FETCH arrecadadorMovimentoItem.arrecadadorMovimento  arrecadadorMovimento "
							+ " INNER JOIN FETCH pagamento.avisoBancario avbc " 
							+ " INNER JOIN FETCH avbc.arrecadador arrec "
							+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp " + " LEFT JOIN FETCH pagamento.conta conta "
							+ " LEFT JOIN FETCH pagamento.debitoTipo dbtpPagto "
							+ " LEFT JOIN FETCH pagamento.guiaPagamentoGeral gpagGeral " + " LEFT JOIN FETCH gpagGeral.guiaPagamento gpag "
							+ " LEFT JOIN FETCH gpag.guiasPagamentoPrestacao gpagGppr " + " LEFT JOIN FETCH gpagGppr.debitoTipo dbtpGpag "
							+ " LEFT JOIN FETCH pagamento.debitoACobrar dbcb " + " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
							+ " LEFT JOIN FETCH pagamento.arrecadacaoForma arrecForma "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + " LEFT JOIN FETCH pagamento.cliente cli " + condicionais
							+ " order by pagamento.localidade.id, pagamento.imovel.id, "
							+ " pagamento.debitoTipo.id, pagamento.dataPagamento " + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setFirstResult(
								10 * numeroPagina).setMaxResults(10).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setFirstResult(10 * numeroPagina)
								.setMaxResults(10).list();
			}else{
				retorno = session.createQuery(hql).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Saulo Lima
	 * @date 25/08/2009
	 * @return Collection<PagamentoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoMovimentoArrecadadorParaPaginacao(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = null;
		String hql = "";
		Session session = HibernateUtil.getSession();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		try{
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT DISTINCT pagamentoHistorico " 
							+ " FROM gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
							+ " INNER JOIN FETCH pagamentoHistorico.arrecadadorMovimentoItem arrecadadorMovimentoItem "
							+ " INNER JOIN FETCH arrecadadorMovimentoItem.arrecadadorMovimento arrecadadorMovimento "
							+ " INNER JOIN FETCH pagamentoHistorico.avisoBancario avbc " 
							+ " INNER JOIN FETCH avbc.arrecadador arrec "
							+ " INNER JOIN FETCH pagamentoHistorico.documentoTipo doctoTp "
							+ " LEFT JOIN FETCH pagamentoHistorico.conta conta "
							+ " LEFT JOIN FETCH pagamentoHistorico.debitoTipo dbtpPagto "
							+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamentoGeral gpagGeral "
							+ " LEFT JOIN FETCH gpagGeral.guiaPagamento gpag " + " LEFT JOIN FETCH gpag.guiasPagamentoPrestacao gpagGppr "
							+ " LEFT JOIN FETCH gpagGppr.debitoTipo dbtpGpag " + " LEFT JOIN FETCH pagamentoHistorico.debitoACobrar dbcb "
							+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
							+ " LEFT JOIN FETCH pagamentoHistorico.arrecadacaoForma arrecForma "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + " LEFT JOIN FETCH pagamentoHistorico.cliente cli " + condicionais
							+ " ORDER BY pagamentoHistorico.dataPagamento DESC";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

			// Solucao para evitar erro do setMaxResult
			List lista = (List) retorno;

			int posicaoInicial = 10 * numeroPagina;
			int posicaoFinal = 10 * numeroPagina + 10;

			retorno = lista.subList(posicaoInicial, (posicaoFinal > lista.size() ? lista.size() : posicaoFinal));

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * @author eduardo henrique
	 * @date 02/01/2009
	 *       Correção no filtro do nr. do Movimento Arrecadador.
	 * @author Saulo Lima
	 * @date 16/01/2009
	 *       Modificação nas condicionais de DATA (dataPagamentoInicial e Final) do formado
	 *       AAAA-MM-DD para DD-MM-AAAA
	 * @param idImovel
	 * @param idCliente
	 * @param idTipoRelacao
	 * @param localidadeInicial
	 * @param localidadeFinal
	 * @param idAvisoBancario
	 * @param idArrecadador
	 * @param periodoArrecadacaoInicial
	 * @param periodoArrecadacaoFinal
	 * @param periodoPagamentoInicio
	 * @param periodoPagamentoFim
	 * @param dataPagamentoInicial
	 * @param dataPagamentoFinal
	 * @param idsPagamentosSituacoes
	 * @param idsDebitosTipos
	 * @param idsArrecadacaoForma
	 * @param idsDocumentosTipos
	 * @param idsCategoria
	 *            TODO
	 * @return
	 */
	private String criarCondicionaisPagamento(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria){

		String sql = " where ";
		if(idImovel != null && !idImovel.equals("")){
			sql = sql + " pagamento.imovel.id = " + Integer.valueOf(idImovel) + " and ";
		}
		if(idCliente != null && !idCliente.equals("")){
			// sql = sql + " clienteContas.cliente.id = " + idCliente + " and "
			// ;
			sql = sql + " pagamento.cliente.id = " + idCliente + " and ";
		}
		if(idTipoRelacao != null && !idTipoRelacao.equals("")){
			sql = sql + " clienteRelacaoTipo.id = " + idTipoRelacao + " and ";
		}
		if(localidadeInicial != null && localidadeFinal != null && !localidadeInicial.equals("") && !localidadeFinal.equals("")){
			sql = sql + " pagamento.localidade.id >= " + localidadeInicial + " and ";
			sql = sql + " pagamento.localidade.id <= " + localidadeFinal + " and ";
		}
		if(!Util.isVazioOuBranco(codigoSetorComercialInicial) && !Util.isVazioOuBranco(codigoSetorComercialFinal)){
			sql = sql + " stcm.codigo >= " + codigoSetorComercialInicial + " and ";
			sql = sql + " stcm.codigo <= " + codigoSetorComercialFinal + " and ";
		}
		if(!Util.isVazioOrNulo(idsArrecadadores)){
			String valoresIn = "";

			for(Integer idArrecadadorAux : idsArrecadadores){
				valoresIn = valoresIn + idArrecadadorAux + ",";
			}

			if(!valoresIn.equals("")){
				sql = sql + " pagamento.avisoBancario.arrecadador.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idAvisoBancario != null && !idAvisoBancario.equals("")){
			sql = sql + " pagamento.avisoBancario.id = " + idAvisoBancario + " and ";
		}
		if(idArrecadador != null && !idArrecadador.equals("")){
			sql = sql + " arrecadadorMovimentoItem.arrecadadorMovimento.id = " + idArrecadador + " and ";
		}
		if(periodoArrecadacaoInicial != null && !periodoArrecadacaoInicial.equals("")){
			sql = sql + " pagamento.anoMesReferenciaArrecadacao >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
							+ " and ";
		}
		if(periodoArrecadacaoFinal != null && !periodoArrecadacaoFinal.equals("")){
			sql = sql + " pagamento.anoMesReferenciaArrecadacao <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal)
							+ " and ";
		}
		if(periodoPagamentoInicio != null && !periodoPagamentoInicio.equals("")){
			sql = sql + " pagamento.anoMesReferenciaPagamento >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
							+ " and ";
		}
		if(periodoPagamentoFim != null && !periodoPagamentoFim.equals("")){
			sql = sql + " pagamento.anoMesReferenciaPagamento <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim) + " and ";
		}

		if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){

			sql = sql + " pagamento.dataPagamento >= :dataPagamentoInicial  and ";
		}
		if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){

			sql = sql + " pagamento.dataPagamento <= :dataPagamentoFinal  and ";
		}

		if(idsPagamentosSituacoes != null && !idsPagamentosSituacoes.equals("")){
			String valoresIn = "";
			for(int i = 0; i < idsPagamentosSituacoes.length; i++){
				if(!idsPagamentosSituacoes[i].equals("")){
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " pagamento.pagamentoSituacaoAtual.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDebitosTipos != null && !idsDebitosTipos.equals("")
						&& !idsDebitosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDebitosTipos.length; i++){
				if(!idsDebitosTipos[i].equals("")){
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				// sql = sql +
				// " pagamento.guiaPagamentoGeral.guiaPagamento.guiasPagamentoPrestacao.debitoTipo.id in ("
				// + valoresIn;
				sql = sql + " pagamento.guiaPagamentoGeral.guiaPagamento.id in (SELECT gpag.id "
								+ " FROM gcom.arrecadacao.pagamento.GuiaPagamento gpag "
								+ " INNER JOIN gpag.guiasPagamentoPrestacao gpagprest" + " WHERE gpagprest.debitoTipo.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ")) and ";
			}
		}
		if(idsArrecadacaoForma != null && !idsArrecadacaoForma.equals("")
						&& !idsArrecadacaoForma[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsArrecadacaoForma.length; i++){
				if(!idsArrecadacaoForma[i].equals("")){
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " pagamento.arrecadacaoForma.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}

		if(idsDocumentosTipos != null && !idsDocumentosTipos.equals("")
						&& !idsDocumentosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDocumentosTipos.length; i++){
				if(!idsDocumentosTipos[i].equals("")){
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " pagamento.documentoTipo.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}

		if(idsCategoria != null && idsCategoria.length != 0){

			String valoresIn = "";

			for(int i = 0; i < idsCategoria.length; i++){
				if(!idsCategoria[i].equals("")){
					valoresIn = valoresIn + idsCategoria[i] + ",";
				}
			}

			if(!valoresIn.equals("")){

				sql = sql + " imsb.comp_id.subcategoria.categoria.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";

			}

		}

		// retira o " and " q fica sobrando no final da query
		sql = Util.formatarHQL(sql, 4);
		// System.out.println(sql);

		// [SB0006] Ordenar Pagamentos de Acordo com o Tipo de Documento
		// 1. Para os pagamentos com tipo de documento(DOPT_ID) com valor
		// correspondente a conta,
		// ordena os pagamentos pela localidade (LOCA_ID), matrícula do imóvel
		// (IMOV_ID), ano/mês
		// de referênca do pagamento(PGMT_AMREFERENCIAPAGAMENTO), e data de
		// pagamento (PGMT_DTPAGAMENTO)

		// 2. Para os pagamentos com tipo do documento(DOPT_ID) com o valor
		// correspondente a guia de
		// pagamento, ordena os pagamentos pela localidade (LOCA_ID), matrícula
		// do imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGMT_DTPAGAMENTO)

		// 3. Para os pagamentos com tipo de documento(DOPT_ID) com o valor
		// correspondente a débito a
		// cobrar, ordena os pagamentos pela localidade (LOCA_ID), matrícula do
		// imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGMT_DTPAGAMENTO)

		return sql;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamentoRelatorio
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @param idImovel
	 * @param idCliente
	 * @param idTipoRelacao
	 * @param localidadeInicial
	 * @param localidadeFinal
	 * @param idAvisoBancario
	 * @param idArrecadador
	 * @param periodoArrecadacaoInicial
	 * @param periodoArrecadacaoFinal
	 * @param periodoPagamentoInicio
	 * @param periodoPagamentoFim
	 * @param dataPagamentoInicial
	 * @param dataPagamentoFinal
	 * @param idsPagamentosSituacoes
	 * @param idsDebitosTipos
	 * @param idsArrecadacaoForma
	 * @param idsDocumentosTipos
	 * @param idsCategoria
	 *            TODO
	 * @return
	 */
	private String criarCondicionaisPagamentoCliente(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria){

		String sql = " ";
		if(idImovel != null && !idImovel.equals("")){
			sql = sql + " c.imov_id = " + idImovel + " and ";
		}
		if(idCliente != null && !idCliente.equals("")){
			sql = sql + " a.clie_id = " + idCliente + " and ";
		}
		if(idTipoRelacao != null && !idTipoRelacao.equals("")){
			sql = sql + " b.crtp_id = " + idTipoRelacao + " and ";
		}
		if(localidadeInicial != null && localidadeFinal != null && !localidadeInicial.equals("") && !localidadeFinal.equals("")){
			sql = sql + " c.loca_id >= " + localidadeInicial + " and ";
			sql = sql + " c.loca_id <= " + localidadeFinal + " and ";
		}
		if(!Util.isVazioOuBranco(codigoSetorComercialInicial) && !Util.isVazioOuBranco(codigoSetorComercialFinal)){
			sql = sql + " stcm.stcm_cdsetorcomercial >= " + codigoSetorComercialInicial + " and ";
			sql = sql + " stcm.stcm_cdsetorcomercial <= " + codigoSetorComercialFinal + " and ";
		}
		if(!Util.isVazioOrNulo(idsArrecadadores)){
			String valoresIn = "";

			for(Integer idArrecadadorAux : idsArrecadadores){
				valoresIn = valoresIn + idArrecadadorAux + ",";
			}

			if(!valoresIn.equals("")){
				sql = sql + " f.arrc_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idAvisoBancario != null && !idAvisoBancario.equals("")){
			sql = sql + " c.avbc_id = " + idAvisoBancario + " and ";
		}
		if(idArrecadador != null && !idArrecadador.equals("")){
			sql = sql + " f.armv_id = " + idArrecadador + " and ";
		}
		if(periodoArrecadacaoInicial != null && !periodoArrecadacaoInicial.equals("")){
			sql = sql + " c.pgmt_amreferenciaarrecadacao >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial) + " and ";
		}
		if(periodoArrecadacaoFinal != null && !periodoArrecadacaoFinal.equals("")){
			sql = sql + " c.pgmt_amreferenciaarrecadacao <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal) + " and ";
		}
		if(periodoPagamentoInicio != null && !periodoPagamentoInicio.equals("")){
			sql = sql + " c.pgmt_amreferenciapagamento >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio) + " and ";
		}
		if(periodoPagamentoFim != null && !periodoPagamentoFim.equals("")){
			sql = sql + " c.pgmt_amreferenciapagamento <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim) + " and ";
		}

		if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
			// sql = sql + " pagamento.dataPagamento >= '" +
			// Util.formatarData(dataPagamentoInicial) + "' and " ;
			String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

			if(data1 != null && !data1.equals("") && data1.trim().length() == 8){

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6) + "-" + data1.substring(6, 8);
			}
			sql = sql + " c.pgmt_dtpagamento >= '" + data1 + "' and ";
		}
		if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
			// sql = sql + " pagamento.dataPagamento <= '" +
			// Util.formatarData(dataPagamentoFinal) + "' and " ;
			String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

			if(data2 != null && !data2.equals("") && data2.trim().length() == 8){

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6) + "-" + data2.substring(6, 8);
			}
			sql = sql + " c.pgmt_dtpagamento <= '" + data2 + "' and ";
		}

		if(idsPagamentosSituacoes != null && !idsPagamentosSituacoes.equals("")){
			String valoresIn = "";
			for(int i = 0; i < idsPagamentosSituacoes.length; i++){
				if(!idsPagamentosSituacoes[i].equals("")){
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " c.pgst_idatual in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDebitosTipos != null && !idsDebitosTipos.equals("")
						&& !idsDebitosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDebitosTipos.length; i++){
				if(!idsDebitosTipos[i].equals("")){
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " c.dbtp_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsArrecadacaoForma != null && !idsArrecadacaoForma.equals("")
						&& !idsArrecadacaoForma[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsArrecadacaoForma.length; i++){
				if(!idsArrecadacaoForma[i].equals("")){
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " c.arfm_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDocumentosTipos != null && !idsDocumentosTipos.equals("")
						&& !idsDocumentosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDocumentosTipos.length; i++){
				if(!idsDocumentosTipos[i].equals("")){
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " c.dotp_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsCategoria != null && idsCategoria.length != 0){

			String valoresIn = "";
			for(int i = 0; i < idsCategoria.length; i++){
				if(!idsCategoria[i].equals("")){
					valoresIn = valoresIn + idsCategoria[i] + ",";
				}
			}
			if(!valoresIn.equals("")){

				sql = sql + " imsb.catg_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";

			}

		}
		// retira o " and " q fica sobrando no final da query
		sql = Util.formatarHQL(sql, 4);

		return sql;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * @author Saulo Lima
	 * @date 16/01/2009
	 *       Modificação nas condicionais de DATA (dataPagamentoInicial e Final) do formado
	 *       AAAA-MM-DD para DD-MM-AAAA
	 * @param idImovel
	 * @param idCliente
	 * @param idTipoRelacao
	 * @param localidadeInicial
	 * @param localidadeFinal
	 * @param idAvisoBancario
	 * @param idArrecadador
	 * @param periodoArrecadacaoInicial
	 * @param periodoArrecadacaoFinal
	 * @param periodoPagamentoInicio
	 * @param periodoPagamentoFim
	 * @param dataPagamentoInicial
	 * @param dataPagamentoFinal
	 * @param idsPagamentosSituacoes
	 * @param idsDebitosTipos
	 * @param idsArrecadacaoForma
	 * @param idsDocumentosTipos
	 * @param idsCategoria
	 *            TODO
	 * @return
	 */
	private String criarCondicionaisPagamentoRelatorio(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria){

		String sql = " WHERE ";
		if(idImovel != null && !idImovel.equals("")){
			sql = sql + " imov.id = " + idImovel + " and ";
		}
		if(idCliente != null && !idCliente.equals("")){
			// sql = sql + " clienteContas.cliente.id = " + idCliente + " and "
			// ;
			sql = sql + " cli.id = " + idCliente + " and ";
		}
		if(idTipoRelacao != null && !idTipoRelacao.equals("")){
			sql = sql + " clienteRelacaoTipo.id = " + idTipoRelacao + " and ";
		}

		if(localidadeInicial != null && localidadeFinal != null && !localidadeInicial.equals("") && !localidadeFinal.equals("")){
			sql = sql + " loc.id >= " + localidadeInicial + " and ";
			sql = sql + " loc.id <= " + localidadeFinal + " and ";
		}
		if(!Util.isVazioOuBranco(codigoSetorComercialInicial) && !Util.isVazioOuBranco(codigoSetorComercialFinal)){
			sql = sql + " stcm.codigo >= " + codigoSetorComercialInicial + " and ";
			sql = sql + " stcm.codigo <= " + codigoSetorComercialFinal + " and ";
		}
		if(!Util.isVazioOrNulo(idsArrecadadores)){
			String valoresIn = "";

			for(Integer idArrecadadorAux : idsArrecadadores){
				valoresIn = valoresIn + idArrecadadorAux + ",";
			}

			if(!valoresIn.equals("")){
				sql = sql + " avbc.arrecadador.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idAvisoBancario != null && !idAvisoBancario.equals("")){
			sql = sql + " avbc.id = " + idAvisoBancario + " and ";
		}
		if(idArrecadador != null && !idArrecadador.equals("")){
			sql = sql + " arrecMov.id = " + idArrecadador + " and ";
		}
		if(periodoArrecadacaoInicial != null && !periodoArrecadacaoInicial.equals("")){
			sql = sql + " pagto.anoMesReferenciaArrecadacao >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial)
							+ " and ";
		}
		if(periodoArrecadacaoFinal != null && !periodoArrecadacaoFinal.equals("")){
			sql = sql + " pagto.anoMesReferenciaArrecadacao <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal) + " and ";
		}
		if(periodoPagamentoInicio != null && !periodoPagamentoInicio.equals("")){
			sql = sql + " pagto.anoMesReferenciaPagamento >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio) + " and ";
		}
		if(periodoPagamentoFim != null && !periodoPagamentoFim.equals("")){
			sql = sql + " pagto.anoMesReferenciaPagamento <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim) + " and ";
		}

		if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){

			sql = sql + " pagto.dataPagamento >= :dataPagamentoInicial  and ";
		}
		if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){

			sql = sql + " pagto.dataPagamento <= :dataPagamentoFinal  and ";
		}

		if(idsPagamentosSituacoes != null && !idsPagamentosSituacoes.equals("")){
			String valoresIn = "";
			for(int i = 0; i < idsPagamentosSituacoes.length; i++){
				if(!idsPagamentosSituacoes[i].equals("")){
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " pagtoSitAtual.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDebitosTipos != null && !idsDebitosTipos.equals("")
						&& !idsDebitosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDebitosTipos.length; i++){
				if(!idsDebitosTipos[i].equals("")){
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " dbtp.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsArrecadacaoForma != null && !idsArrecadacaoForma.equals("")
						&& !idsArrecadacaoForma[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsArrecadacaoForma.length; i++){
				if(!idsArrecadacaoForma[i].equals("")){
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " arrecForma.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDocumentosTipos != null && !idsDocumentosTipos.equals("")
						&& !idsDocumentosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDocumentosTipos.length; i++){
				if(!idsDocumentosTipos[i].equals("")){
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " doctoTp.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}

		if(idsCategoria != null && idsCategoria.length != 0){

			String valoresIn = "";

			for(int i = 0; i < idsCategoria.length; i++){
				if(!idsCategoria[i].equals("")){
					valoresIn = valoresIn + idsCategoria[i] + ",";
				}
			}

			if(!valoresIn.equals("")){

				sql = sql + " imsb.comp_id.subcategoria.categoria.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";

			}

		}

		// retira o " and " q fica sobrando no final da query
		sql = Util.formatarHQL(sql, 4);

		// [SB0006] Ordenar Pagamentos de Acordo com o Tipo de Documento
		// 1. Para os pagamentos com tipo de documento(DOPT_ID) com valor
		// correspondente a conta,
		// ordena os pagamentos pela localidade (LOCA_ID), matrícula do imóvel
		// (IMOV_ID), ano/mês
		// de referênca do pagamento(PGMT_AMREFERENCIAPAGAMENTO), e data de
		// pagamento (PGMT_DTPAGAMENTO)

		// 2. Para os pagamentos com tipo do documento(DOPT_ID) com o valor
		// correspondente a guia de
		// pagamento, ordena os pagamentos pela localidade (LOCA_ID), matrícula
		// do imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGMT_DTPAGAMENTO)

		// 3. Para os pagamentos com tipo de documento(DOPT_ID) com o valor
		// correspondente a débito a
		// cobrar, ordena os pagamentos pela localidade (LOCA_ID), matrícula do
		// imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGMT_DTPAGAMENTO)

		return sql;
	}

	/**
	 * Consulta dados da tabela dados diarios arrecadacao
	 * 
	 * @author Fernanda Paiva
	 * @created 09/06/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarDadosDiarios(int anoMesReferencia, int id, String descricao, int idElo) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			if(descricao == "ELO"){
				consulta = "select localidade.localidade.id,sum(re.valorPagamentos), re.gerenciaRegional.id, eloPolo.descricao, "
								+ " eloPolo.localidade.id, re.anoMesReferenciaArrecadacao"
								+ " from ArrecadacaoDadosDiarios re,Localidade localidade, Localidade eloPolo "
								+ " where  re.localidade.id = localidade.id " + "and localidade.localidade.id = eloPolo.id "
								+ "and re.anoMesReferenciaArrecadacao = :anoMesReferencia and " + " re.gerenciaRegional.id = :id "
								+ " group by localidade.localidade.id,re.gerenciaRegional.id, eloPolo.descricao, "
								+ " eloPolo.localidade.id, re.anoMesReferenciaArrecadacao";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).list();

			}
			if(descricao == "LOCALIDADE"){
				consulta = "select re.localidade.id, sum(re.valorPagamentos), re.gerenciaRegional.id, eloPolo.descricao, "
								+ " eloPolo.id, re.anoMesReferenciaArrecadacao " + " from ArrecadacaoDadosDiarios re, Localidade eloPolo "
								+ " where  re.localidade.id = eloPolo.id and re.anoMesReferenciaArrecadacao = :anoMesReferencia and "
								+ " re.gerenciaRegional.id = :id and eloPolo.localidade = :idElo"
								+ " group by re.localidade.id, re.gerenciaRegional.id, eloPolo.descricao, "
								+ " eloPolo.id, re.anoMesReferenciaArrecadacao ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).setInteger(
								"idElo", idElo).list();
			}
			if(descricao == "ARRECADADOR"){
				consulta = "select cliente.nome, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao, arrecadador.id "
								+ " from ArrecadacaoDadosDiarios re, Arrecadador arrecadador " + "left join arrecadador.cliente cliente"
								+ " where  re.arrecadador.id = arrecadador.id and re.anoMesReferenciaArrecadacao = :anoMesReferencia "
								+ " group by cliente.nome, re.anoMesReferenciaArrecadacao, arrecadador.id ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();
			}
			if(descricao == "VALORES"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re " + " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia "
								+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();
			}
			if(descricao == "VALORESGERENCIA"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re "
								+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.gerenciaRegional.id = :id "
								+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).list();
			}
			if(descricao == "VALORESELO"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re,Localidade localidade, Localidade eloPolo "
								+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and eloPolo.localidade.id = :idElo "
								+ " and re.localidade.id = localidade.id " + " and localidade.localidade.id = eloPolo.id "
								+ " and  re.gerenciaRegional.id = :id " + " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).setInteger(
								"idElo", idElo).list();
			}
			if(descricao == "VALORESLOCALIDADE"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re, Localidade localidade, Localidade eloPolo "
								+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and eloPolo.id = :idElo "
								+ " and re.localidade.id = eloPolo.id " + " and re.gerenciaRegional.id = :id "
								+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).setInteger(
								"idElo", idElo).list();
			}
			if(descricao == "VALORESPORDIA"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re, Localidade localidade "
								+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia " + " and localidade.id = re.localidade.id "
								+ "and localidade.id = :idLocalidade " + " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("idLocalidade", idElo)
								.list();
			}

			if(descricao == "VALORESARRECADADOR"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re "
								+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.arrecadador.id = :id "
								+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).list();
			}
			if(descricao == "VALORESCATEGORIA"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re "
								+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.categoria.id = :id "
								+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).list();
			}
			if(descricao == "VALORESPERFIL"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re "
								+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.imovelPerfil.id = :id "
								+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).list();
			}
			if(descricao == "VALORESDOCUMENTO"){
				consulta = "select re.dataPagamento, sum(re.valorPagamentos), " + " re.anoMesReferenciaArrecadacao "
								+ " from ArrecadacaoDadosDiarios re "
								+ " where  re.anoMesReferenciaArrecadacao = :anoMesReferencia and re.documentoTipo.id = :id "
								+ " group by re.anoMesReferenciaArrecadacao, re.dataPagamento "
								+ " order by re.anoMesReferenciaArrecadacao, re.dataPagamento ";
				retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("id", id).list();
			}
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * @param avisoBancarioHelper
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */
	public Integer filtrarAvisoBancarioAbertoFechadoCount(AvisoBancarioHelper avisoBancarioHelper,
					AvisoBancarioHelper avisoBancarioHelperNovo) throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		Object resultado = null;

		// Consulta
		try{

			Short arrecadadorCodAgente = avisoBancarioHelper.getCodigoAgenteArrecadador();
			Date dataLancamentoInicio = avisoBancarioHelper.getDataLancamentoInicial();
			Date dataLancamentoFim = avisoBancarioHelper.getDataLancamentoFinal();
			Short indicadorCreditoDebito = avisoBancarioHelper.getIndicadorCreditoDebito();
			Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
			Integer idMovimento = avisoBancarioHelper.getIdMovimentoArrecadador();
			Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper.getDataPrevistaInicial();
			Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper.getDataPrevistaFinal();
			Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper.getDataRealizadaInicial();
			Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper.getDataRealizadaFinal();
			int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper.getAnoMesReferenciaArrecadacaoInicial();
			int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper.getAnoMesReferenciaArrecadacaoFinal();
			BigDecimal valorRealizadoInicial = avisoBancarioHelper.getValorRealizadoInicial();
			BigDecimal valorRealizadoFinal = avisoBancarioHelper.getValorRealizadoFinal();
			BigDecimal valorPrevistoInicial = avisoBancarioHelper.getValorPrevistoInicial();
			BigDecimal valorPrevistoFinal = avisoBancarioHelper.getValorPrevistoFinal();
			String tipoAviso = avisoBancarioHelper.getTipoAviso();
			int flag = 0;

			if(arrecadadorCodAgente == null && (dataLancamentoInicio == null || dataLancamentoFim == null)
							&& (indicadorCreditoDebito == 0 || indicadorCreditoDebito == 3) && idContaBancaria == null
							&& idMovimento == null && (dataPrevisaoCreditoDebitoInicio == null || dataPrevisaoCreditoDebitoFim == null)
							&& (dataRealizacaoCreditoDebitoInicio == null || dataRealizacaoCreditoDebitoFim == null)
							&& (anoMesReferenciaArrecadacaoInicial == 0 || anoMesReferenciaArrecadacaoFinal == 0)
							&& (valorPrevistoInicial == null || valorPrevistoFinal == null)
							&& (valorRealizadoInicial == null || valorRealizadoFinal == null) && tipoAviso.equalsIgnoreCase("1")){
				flag = 1;
				consulta = "select count (avisoBancario.id) from AvisoBancario avisoBancario ";
			}else{
				consulta = "select count (avisoBancario.id) from AvisoBancario avisoBancario " + "where ";
			}

			if(arrecadadorCodAgente != null){
				consulta += " avisoBancario.arrecadador.codigoAgente = " + arrecadadorCodAgente + " and";
			}

			if((dataLancamentoInicio != null) && (dataLancamentoFim != null)){
				consulta += " avisoBancario.dataLancamento between :dataLancamentoInicio  and " + ":dataLancamentoFim and";

			}

			if(indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3){
				consulta += " avisoBancario.indicadorCreditoDebito = " + indicadorCreditoDebito + " and";
			}

			if(idContaBancaria != null){
				consulta += " avisoBancario.contaBancaria.id = " + idContaBancaria + " and";
			}

			if(idMovimento != null){
				consulta += " avisoBancario.arrecadadorMovimento.id = " + idMovimento + " and";
			}

			if((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)){
				consulta += " avisoBancario.dataPrevista between :dataPrevisaoCreditoDebitoInicio  and "
								+ ":dataPrevisaoCreditoDebitoFim and";

			}

			if((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null)){
				consulta += " avisoBancario.dataRealizada between :dataRealizacaoCreditoDebitoInicio  and "
								+ ":dataRealizacaoCreditoDebitoFim and";

			}

			if((anoMesReferenciaArrecadacaoInicial != 0) && (anoMesReferenciaArrecadacaoFinal != 0)){
				consulta += " avisoBancario.anoMesReferenciaArrecadacao between " + anoMesReferenciaArrecadacaoInicial + " and "
								+ anoMesReferenciaArrecadacaoFinal + " and";
			}

			if((valorRealizadoInicial != null) && (valorRealizadoFinal != null)){
				BigDecimal valorInicialNegativo = valorRealizadoFinal.multiply(new BigDecimal("-1.00"));
				BigDecimal valorFinalNegativo = valorRealizadoInicial.multiply(new BigDecimal("-1.00"));
				consulta += " ((avisoBancario.valorRealizado between " + valorInicialNegativo + " and " + valorFinalNegativo
								+ ") or (avisoBancario.valorRealizado between " + valorRealizadoInicial + " and " + valorRealizadoFinal
								+ "))" + " and";

			}

			// tipoAviso
			if(tipoAviso != null){
				if(tipoAviso.equalsIgnoreCase("3")){
					BigDecimal valorSomatorioAcertoCredito = this.pesquisarSomatorioAvisoAcerto(1, avisoBancarioHelperNovo
									.getAvisoBancario().getId(), 1);
					BigDecimal valorSomatorioAcertoDebito = this.pesquisarSomatorioAvisoAcerto(2, avisoBancarioHelperNovo
									.getAvisoBancario().getId(), 1);

					BigDecimal valorSomatorioAcertoCredito2 = this.pesquisarSomatorioAvisoAcerto(1, avisoBancarioHelperNovo
									.getAvisoBancario().getId(), 2);
					BigDecimal valorSomatorioAcertoDebito2 = this.pesquisarSomatorioAvisoAcerto(2, avisoBancarioHelperNovo
									.getAvisoBancario().getId(), 2);
					if(valorSomatorioAcertoCredito == null){
						valorSomatorioAcertoCredito = new BigDecimal("0.00");
					}
					if(valorSomatorioAcertoDebito == null){
						valorSomatorioAcertoDebito = new BigDecimal("0.00");
					}

					if(valorSomatorioAcertoCredito2 == null){
						valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
					}
					if(valorSomatorioAcertoDebito2 == null){
						valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
					}
					// FECHADO
					consulta += " ((avisoBancario.valorArrecadacaoCalculado = " + "(( " + "    avisoBancario.valorArrecadacaoInformado + "
									+ valorSomatorioAcertoCredito + ") - " + valorSomatorioAcertoDebito + ")) and "
									+ " (avisoBancario.valorDevolucaoCalculado = " + "(( " + "    avisoBancario.valorDevolucaoInformado + "
									+ valorSomatorioAcertoCredito2 + ") - " + valorSomatorioAcertoDebito2 + "))) and ";
				}else if(tipoAviso.equalsIgnoreCase("2")){
					// ABERTO
					BigDecimal valorSomatorioAcertoCredito = this.pesquisarSomatorioAvisoAcerto(1, avisoBancarioHelperNovo
									.getAvisoBancario().getId(), 1);
					BigDecimal valorSomatorioAcertoDebito = this.pesquisarSomatorioAvisoAcerto(2, avisoBancarioHelperNovo
									.getAvisoBancario().getId(), 1);

					BigDecimal valorSomatorioAcertoCredito2 = this.pesquisarSomatorioAvisoAcerto(1, avisoBancarioHelperNovo
									.getAvisoBancario().getId(), 2);
					BigDecimal valorSomatorioAcertoDebito2 = this.pesquisarSomatorioAvisoAcerto(2, avisoBancarioHelperNovo
									.getAvisoBancario().getId(), 2);
					if(valorSomatorioAcertoCredito == null){
						valorSomatorioAcertoCredito = new BigDecimal("0.00");
					}
					if(valorSomatorioAcertoDebito == null){
						valorSomatorioAcertoDebito = new BigDecimal("0.00");
					}

					if(valorSomatorioAcertoCredito2 == null){
						valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
					}
					if(valorSomatorioAcertoDebito2 == null){
						valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
					}
					consulta += " ((avisoBancario.valorArrecadacaoCalculado <> " + "(( " + "    avisoBancario.valorArrecadacaoInformado + "
									+ valorSomatorioAcertoCredito + ") - " + valorSomatorioAcertoDebito + ")) or "
									+ " (avisoBancario.valorDevolucaoCalculado <> " + "(( "
									+ "    avisoBancario.valorDevolucaoInformado + " + valorSomatorioAcertoCredito2 + ") - "
									+ valorSomatorioAcertoDebito2 + "))) and ";
				}

			}

			String consultarComOrderBy = "";

			if(flag != 1){
				consultarComOrderBy = Util.formatarHQL(consulta, 4);
			}else{
				consultarComOrderBy = Util.formatarHQL(consulta, 0);
			}

			if(arrecadadorCodAgente != null){

				// consultarComOrderBy += " group by avisoBancario.arrecadador.id ";
			}

			if((((dataLancamentoInicio != null) && (dataLancamentoFim != null)) && ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				resultado = session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.setDate("dataRealizacaoCreditoDebitoInicio", dataRealizacaoCreditoDebitoInicio).setDate(
												"dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).uniqueResult();

			}else if(((dataLancamentoInicio != null) && (dataLancamentoFim != null))
							&& ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))){

				resultado = session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.uniqueResult();

			}else if(((dataLancamentoInicio != null) && (dataLancamentoFim != null))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				resultado = session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataRealizacaoCreditoDebitoInicio",
								dataRealizacaoCreditoDebitoInicio)
								.setDate("dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).uniqueResult();

			}else if(((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				resultado = session.createQuery(consultarComOrderBy).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.setDate("dataRealizacaoCreditoDebitoInicio", dataRealizacaoCreditoDebitoInicio).setDate(
												"dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).uniqueResult();

			}else if((dataLancamentoInicio != null) && (dataLancamentoFim != null)){

				resultado = session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).uniqueResult();

			}else if((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)){

				resultado = session.createQuery(consultarComOrderBy).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.uniqueResult();

			}else if((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null)){

				resultado = session.createQuery(consultarComOrderBy).setDate("dataRealizacaoCreditoDebitoInicio",
								dataRealizacaoCreditoDebitoInicio)
								.setDate("dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).uniqueResult();

			}else{
				resultado = session.createQuery(consultarComOrderBy).uniqueResult();
			}

			if(resultado != null){
				retorno = ((Number) resultado).intValue();
			}
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection filtrarAvisoBancarioAbertoFechadoParaPaginacao(AvisoBancarioHelper avisoBancarioHelper, Integer numeroPagina)
					throws ErroRepositorioException{

		// Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		// Consulta
		try{

			Integer idAviso = avisoBancarioHelper.getAvisoBancario().getId();
			String tipoAviso = avisoBancarioHelper.getTipoAviso();

			Short arrecadadorCodAgente = avisoBancarioHelper.getCodigoAgenteArrecadador();
			Date dataLancamentoInicio = avisoBancarioHelper.getDataLancamentoInicial();
			Date dataLancamentoFim = avisoBancarioHelper.getDataLancamentoFinal();
			Short indicadorCreditoDebito = avisoBancarioHelper.getIndicadorCreditoDebito();
			Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
			Integer idMovimento = avisoBancarioHelper.getIdMovimentoArrecadador();
			Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper.getDataPrevistaInicial();
			Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper.getDataPrevistaFinal();
			Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper.getDataRealizadaInicial();
			Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper.getDataRealizadaFinal();
			int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper.getAnoMesReferenciaArrecadacaoInicial();
			int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper.getAnoMesReferenciaArrecadacaoFinal();
			BigDecimal valorRealizadoInicial = avisoBancarioHelper.getValorRealizadoInicial();
			BigDecimal valorRealizadoFinal = avisoBancarioHelper.getValorRealizadoFinal();
			BigDecimal valorPrevistoInicial = avisoBancarioHelper.getValorPrevistoInicial();
			BigDecimal valorPrevistoFinal = avisoBancarioHelper.getValorPrevistoFinal();

			int flag = 0;
			BigDecimal valorSomatorioAcertoCredito = this.pesquisarSomatorioAvisoAcerto(1, idAviso, 1);
			BigDecimal valorSomatorioAcertoDebito = this.pesquisarSomatorioAvisoAcerto(2, idAviso, 1);

			BigDecimal valorSomatorioAcertoCredito2 = this.pesquisarSomatorioAvisoAcerto(1, idAviso, 2);
			BigDecimal valorSomatorioAcertoDebito2 = this.pesquisarSomatorioAvisoAcerto(2, idAviso, 2);
			if(valorSomatorioAcertoCredito == null){
				valorSomatorioAcertoCredito = new BigDecimal("0.00");
			}
			if(valorSomatorioAcertoDebito == null){
				valorSomatorioAcertoDebito = new BigDecimal("0.00");
			}

			if(valorSomatorioAcertoCredito2 == null){
				valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
			}
			if(valorSomatorioAcertoDebito2 == null){
				valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
			}
			if(arrecadadorCodAgente == null && (dataLancamentoInicio == null || dataLancamentoFim == null)
							&& (indicadorCreditoDebito == 0 || indicadorCreditoDebito == 3) && idContaBancaria == null
							&& idMovimento == null && (dataPrevisaoCreditoDebitoInicio == null || dataPrevisaoCreditoDebitoFim == null)
							&& (dataRealizacaoCreditoDebitoInicio == null || dataRealizacaoCreditoDebitoFim == null)
							&& (anoMesReferenciaArrecadacaoInicial == 0 || anoMesReferenciaArrecadacaoFinal == 0)
							&& (valorPrevistoInicial == null || valorPrevistoFinal == null)
							&& (valorRealizadoInicial == null || valorRealizadoFinal == null) && tipoAviso.equalsIgnoreCase("1")){
				flag = 1;
				consulta = "select avisoBancario, " + " case when (" + " (avisoBancario.valorArrecadacaoCalculado = "
								+ " ((avisoBancario.valorArrecadacaoInformado + " + valorSomatorioAcertoCredito + " ) " + " - "
								+ valorSomatorioAcertoDebito + ")" + " ) " + " and " + "(avisoBancario.valorDevolucaoCalculado = "
								+ " ((avisoBancario.valorDevolucaoInformado + " + valorSomatorioAcertoCredito2 + " ) " + " - "
								+ valorSomatorioAcertoDebito2 + ")" + " )) then 'FECHADO' " + " else 'ABERTO' end "
								+ " from AvisoBancario avisoBancario ";

			}else{
				consulta = "select avisoBancario, " + " case when (" + " (avisoBancario.valorArrecadacaoCalculado = "
								+ " ((avisoBancario.valorArrecadacaoInformado + " + valorSomatorioAcertoCredito + " ) " + " - "
								+ valorSomatorioAcertoDebito + ")" + " ) " + " and " + "(avisoBancario.valorDevolucaoCalculado = "
								+ " ((avisoBancario.valorDevolucaoInformado + " + valorSomatorioAcertoCredito2 + " ) " + " - "
								+ valorSomatorioAcertoDebito2 + ")" + " )) then 'FECHADO' " + " else 'ABERTO' end "
								+ " from AvisoBancario avisoBancario " + " where ";
			}

			if(idAviso != null){
				consulta += " avisoBancario.id = " + idAviso + " and";
			}

			if(arrecadadorCodAgente != null){
				consulta += " avisoBancario.arrecadador.codigoAgente = " + arrecadadorCodAgente + " and";
			}

			if((dataLancamentoInicio != null) && (dataLancamentoFim != null)){
				consulta += " avisoBancario.dataLancamento between :dataLancamentoInicio  and " + ":dataLancamentoFim and";

			}

			if(indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3){
				consulta += " avisoBancario.indicadorCreditoDebito = " + indicadorCreditoDebito + " and";
			}

			if(idContaBancaria != null){
				consulta += " avisoBancario.contaBancaria.id = " + idContaBancaria + " and";
			}

			if(idMovimento != null){
				consulta += " avisoBancario.arrecadadorMovimento.id = " + idMovimento + " and";
			}

			if((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)){
				consulta += " avisoBancario.dataPrevista between :dataPrevisaoCreditoDebitoInicio  and "
								+ ":dataPrevisaoCreditoDebitoFim and";

			}

			if((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null)){
				consulta += " avisoBancario.dataRealizada between :dataRealizacaoCreditoDebitoInicio  and "
								+ ":dataRealizacaoCreditoDebitoFim and";

			}

			if((anoMesReferenciaArrecadacaoInicial != 0) && (anoMesReferenciaArrecadacaoFinal != 0)){
				consulta += " avisoBancario.anoMesReferenciaArrecadacao between " + anoMesReferenciaArrecadacaoInicial + " and "
								+ anoMesReferenciaArrecadacaoFinal + " and";
			}

			if((valorRealizadoInicial != null) && (valorRealizadoFinal != null)){

				BigDecimal valorInicialNegativo = valorRealizadoFinal.multiply(new BigDecimal("-1.00"));
				BigDecimal valorFinalNegativo = valorRealizadoInicial.multiply(new BigDecimal("-1.00"));
				consulta += " ((avisoBancario.valorRealizado between " + valorInicialNegativo + " and " + valorFinalNegativo
								+ ") or (avisoBancario.valorRealizado between " + valorRealizadoInicial + " and " + valorRealizadoFinal
								+ "))" + " and";
			}

			// tipoAviso
			if(tipoAviso != null){
				if(tipoAviso.equalsIgnoreCase("3")){
					// FECHADO
					consulta += " ((avisoBancario.valorArrecadacaoCalculado = " + " ((avisoBancario.valorArrecadacaoInformado + "
									+ valorSomatorioAcertoCredito + " ) " + " - " + valorSomatorioAcertoDebito + ")" + " ) " + " and "
									+ "(avisoBancario.valorDevolucaoCalculado = " + " ((avisoBancario.valorDevolucaoInformado + "
									+ valorSomatorioAcertoCredito2 + " ) " + " - " + valorSomatorioAcertoDebito2 + ")" + " )) and ";
				}else if(tipoAviso.equalsIgnoreCase("2")){
					// ABERTO
					consulta += " ((avisoBancario.valorArrecadacaoCalculado <> " + " ((avisoBancario.valorArrecadacaoInformado + "
									+ valorSomatorioAcertoCredito + " ) " + " - " + valorSomatorioAcertoDebito + ")" + " ) " + " or "
									+ "(avisoBancario.valorDevolucaoCalculado <> " + " ((avisoBancario.valorDevolucaoInformado + "
									+ valorSomatorioAcertoCredito2 + " ) " + " - " + valorSomatorioAcertoDebito2 + ")" + " )) and ";
				}
			}
			String consultarComOrderBy = "";

			if(flag != 1){
				consultarComOrderBy = Util.formatarHQL(consulta, 4)
								+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
			}else{
				consultarComOrderBy = Util.formatarHQL(consulta, 0)
								+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
			}

			if((((dataLancamentoInicio != null) && (dataLancamentoFim != null)) && ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.setDate("dataRealizacaoCreditoDebitoInicio", dataRealizacaoCreditoDebitoInicio).setDate(
												"dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).setFirstResult(
												10 * numeroPagina).setMaxResults(10).list();

			}else if(((dataLancamentoInicio != null) && (dataLancamentoFim != null))
							&& ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

			}else if(((dataLancamentoInicio != null) && (dataLancamentoFim != null))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataRealizacaoCreditoDebitoInicio",
								dataRealizacaoCreditoDebitoInicio)
								.setDate("dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim)
								.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

			}else if(((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataPrevisaoCreditoDebitoInicio", dataPrevisaoCreditoDebitoInicio)
								.setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim).setDate(
												"dataRealizacaoCreditoDebitoInicio", dataRealizacaoCreditoDebitoInicio).setDate(
												"dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).setFirstResult(
												10 * numeroPagina).setMaxResults(10).list();

			}else if((dataLancamentoInicio != null) && (dataLancamentoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setFirstResult(10 * numeroPagina).setMaxResults(10).list();

			}else if((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataPrevisaoCreditoDebitoInicio", dataPrevisaoCreditoDebitoInicio)
								.setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim).setFirstResult(10 * numeroPagina)
								.setMaxResults(10).list();

			}else if((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataRealizacaoCreditoDebitoInicio",
								dataRealizacaoCreditoDebitoInicio)
								.setDate("dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim)
								.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

			}else{
				return session.createQuery(consultarComOrderBy).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 21/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoCliente(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, Integer numeroPagina, String codigoSetorComercialInicial,
					String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		String sql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			sql = " select c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
							+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
							+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
							+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " k.pgst_id as idSituacaoPagamentoAnterior, k.pgst_dsabreviado as situacaoPagamentoAnterior, "
							+ " c.pgmt_nnprestacao as numeroPrestacao, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento c "
							+ " INNER JOIN conta i on i.cnta_id = c.cnta_id " + " INNER JOIN cliente_conta b on b.cnta_id = c.cnta_id "
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id " + " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id " + " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " INNER JOIN documento_tipo n on n.dotp_id = c.dotp_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao k on c.pgst_idanterior = k.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id " + " WHERE "
							+ condicionais
							+ " union "
							+ " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
							+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
							+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
							+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, "
							+ " c.pgmt_nnprestacao as numeroPrestacao, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento c "
							+ " INNER JOIN debito_a_cobrar b1 on b1.dbac_id = c.dbac_id "
							+ " INNER JOIN cliente_imovel b on b.imov_id = b1.imov_id "
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id "
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id "
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " INNER JOIN documento_tipo n on n.dotp_id = c.dotp_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " WHERE "
							+ condicionais
							+ " union "
							+ " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
							+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
							+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
							+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, "
							+ " c.pgmt_nnprestacao as numeroPrestacao, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento c "
							+ " INNER JOIN guia_pagamento_geral b1 on b1.gpag_id = c.gpag_id "
							+ " INNER JOIN cliente_guia_pagamento b on b.gpag_id = c.gpag_id "
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id "
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id "
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " INNER JOIN documento_tipo n on n.dotp_id = c.dotp_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " WHERE "
							+ condicionais
							+ " union "
							+ " SELECT c.pgmt_id as idPagamento, c.imov_id as idImovel, c.clie_id as idCliente, g.arrc_cdagente as codigoAgente, "
							+ " f.avbc_dtlancamento as dataLancamento, f.avbc_nnsequencial as numeroSequencial, c.dotp_id as idDocumentoTipo, "
							+ " n.dotp_dsdocumentotipo as nomeDocumentoTipo, c.pgmt_vlpagamento as valorPagamento, c.pgmt_dtpagamento as dataPagamento, "
							+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, "
							+ " c.pgmt_nnprestacao as numeroPrestacao, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento c "
							+ " INNER JOIN cliente a on a.clie_id = c.clie_id "
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id "
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " INNER JOIN documento_tipo n on n.dotp_id = c.dotp_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id " + " WHERE ";

			String condicionaisClientePagamento = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, null, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			sql = sql + condicionaisClientePagamento + " order by idDocumentoTipo, dataPagamento ";

			retorno = session.createSQLQuery(sql).addScalar("idPagamento", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idCliente", Hibernate.INTEGER).addScalar("codigoAgente", Hibernate.SHORT).addScalar(
											"dataLancamento", Hibernate.DATE).addScalar("numeroSequencial", Hibernate.SHORT).addScalar(
											"idDocumentoTipo", Hibernate.INTEGER).addScalar("nomeDocumentoTipo", Hibernate.STRING)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("dataPagamento", Hibernate.DATE).addScalar(
											"idSituacaoPagamentoAtual", Hibernate.INTEGER).addScalar("situacaoPagamentoAtual",
											Hibernate.STRING).addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER).addScalar(
											"situacaoPagamentoAnterior", Hibernate.STRING).addScalar("numeroPrestacao", Hibernate.INTEGER)
											.addScalar("avisoBancario", Hibernate.INTEGER).setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 21/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteCount(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection retorno = null;
		// Object pagamentoClienteCount;
		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, null, idsArrecadadores, idsCategoria);

			hql = " SELECT COUNT(c.pgmt_id) as qtde" + " FROM pagamento c" + " INNER JOIN conta i on i.cnta_id = c.cnta_id"
							+ " INNER JOIN cliente_conta b on b.cnta_id = c.cnta_id" + " INNER JOIN cliente a on a.clie_id = b.clie_id"
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id" + " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id"
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id" + " INNER JOIN cliente h on h.clie_id = g.clie_id"
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id " + " WHERE "
							+ condicionais
							+ " union all"
							+ " SELECT COUNT(c.pgmt_id) as qtde"
							+ " FROM pagamento c"
							+ " INNER JOIN debito_a_cobrar b1  on b1.dbac_id = c.dbac_id"
							+ " INNER JOIN cliente_imovel b on b.imov_id = b1.imov_id"
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id"
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id"
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id"
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id"
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id"
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " WHERE "
							+ condicionais
							+ " union all"
							+ " SELECT COUNT(c.pgmt_id) as qtde"
							+ " FROM pagamento c"
							+ " INNER JOIN guia_pagamento b1 on b1.gpag_id = c.gpag_id"
							+ " INNER JOIN cliente_guia_pagamento b on b.gpag_id = c.gpag_id"
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id"
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id"
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id"
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id"
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id"
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " WHERE "
							+ condicionais
							+ " union all"
							+ " SELECT COUNT(c.pgmt_id) as qtde"
							+ " FROM pagamento c"
							+ " INNER JOIN cliente a on a.clie_id = c.clie_id"
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id"
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id"
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id"
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id"
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id " + " WHERE ";

			String condicionaisClientePagamento = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, null, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, null, idsArrecadadores, idsCategoria);

			hql = hql + condicionaisClientePagamento;

			retorno = session.createSQLQuery(hql).addScalar("qtde", Hibernate.INTEGER).list();

			// hql = " select count (pagamento.id) "
			// + " from gcom.arrecadacao.pagamento.Pagamento as pagamento "
			// + " inner join pagamento.cliente as cliente "
			// + condicionais + " ";

			// pagamentoClienteCount = session.createQuery(hql).setMaxResults(1)
			// .uniqueResult();
			//
			// if (pagamentoClienteCount != null) {
			// retorno = (Integer) pagamentoClienteCount;
			// }

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Vivianne Sousa
	 * @date 21/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancarioParaPaginacao(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		// Collection<Pagamento> colecaoPagamento = null;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal,
							indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = " SELECT DISTINCT pagamento " 
							+ " FROM gcom.arrecadacao.pagamento.Pagamento  pagamento "
							+ " INNER JOIN FETCH pagamento.avisoBancario  avisoBancario "
							+ " INNER JOIN FETCH avisoBancario.arrecadador arrec " 
							+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp "
							+ " LEFT JOIN FETCH pagamento.conta conta " + " LEFT JOIN FETCH pagamento.guiaPagamentoGeral gpagGeral "
							+ " LEFT JOIN FETCH gpagGeral.guiaPagamento gpag " + " LEFT JOIN FETCH gpag.guiasPagamentoPrestacao gpagGppr "
							+ " LEFT JOIN FETCH gpagGppr.debitoTipo dbtpGpag " + " LEFT JOIN FETCH pagamento.debitoTipo dbtpPagto "
							+ " LEFT JOIN FETCH pagamento.cliente cliente "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual "
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem " + condicionais + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setFirstResult(
								10 * numeroPagina).setMaxResults(10).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setFirstResult(10 * numeroPagina)
								.setMaxResults(10).list();
			}else{
				retorno = session.createQuery(hql).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Vivianne Sousa
	 * @date 21/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoAvisoBancarioCount(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		int retorno = 0;
		Object pagamentoAvisoBancarioCount;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal, null,
							idsArrecadadores, idsCategoria);

			hql = "SELECT COUNT(pagamento.id)" + " FROM gcom.arrecadacao.pagamento.Pagamento pagamento"
							+ " INNER JOIN pagamento.avisoBancario avisoBancario" + " LEFT JOIN pagamento.imovel imov "
							+ " LEFT JOIN imov.imovelSubcategorias imsb " + " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem " + condicionais + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoAvisoBancarioCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoAvisoBancarioCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setMaxResults(1).uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoAvisoBancarioCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal)
								.setMaxResults(1).uniqueResult();
			}else{
				pagamentoAvisoBancarioCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			if(pagamentoAvisoBancarioCount != null){
				retorno = ((Number) pagamentoAvisoBancarioCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Vivianne Sousa
	 * @date 22/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Collection<Pagamento> pesquisarPagamentoImovelParaPaginacao(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com o Imóvel, caso
			// selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal,
							indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT distinct pagamento" 
							+ " FROM gcom.arrecadacao.pagamento.Pagamento  pagamento"
							+ " INNER JOIN FETCH pagamento.avisoBancario avbc" 
							+ " INNER JOIN FETCH avbc.arrecadador arrec"
							+ " INNER JOIN FETCH pagamento.documentoTipo doctoTp" 
							+ " LEFT JOIN pagamento.conta conta"
							+ " LEFT JOIN pagamento.guiaPagamentoGeral gpagGeral " 
							+ " LEFT JOIN gpagGeral.guiaPagamento gpag"
							+ " LEFT JOIN gpag.guiasPagamentoPrestacao gppr" 
							+ " LEFT JOIN gppr.debitoTipo dbtpGppr"
							+ " LEFT JOIN pagamento.debitoACobrar dbcb" 
							+ " LEFT JOIN dbcb.debitoTipo dbtpDbcb"
							+ " LEFT JOIN pagamento.debitoTipo dbtpPagto"
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagtoSitAtual"
							+ " LEFT JOIN FETCH pagamento.pagamentoSituacaoAnterior pagtoSitAnterior" + " LEFT JOIN pagamento.imovel imov "
							+ " LEFT JOIN imov.imovelSubcategorias imsb " 
							+ " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem " + condicionais
							+ " order by pagamento.localidade.id, pagamento.imovel.id,"
							+ " pagamento.documentoTipo.id, pagamento.dataPagamento";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setFirstResult(
								10 * numeroPagina).setMaxResults(10).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setFirstResult(10 * numeroPagina)
								.setMaxResults(10).list();
			}else{
				retorno = session.createQuery(hql).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Vivianne Sousa
	 * @date 22/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoImovelCount(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Integer retorno = Integer.valueOf(0);
		Object pagamentoImovelCount;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal, null,
							idsArrecadadores, idsCategoria);

			hql = "SELECT COUNT(pagamento.id)" + " FROM gcom.arrecadacao.pagamento.Pagamento pagamento"
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem " + condicionais + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoImovelCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoImovelCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setMaxResults(1)
								.uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoImovelCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1)
								.uniqueResult();
			}else{
				pagamentoImovelCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			if(pagamentoImovelCount != null){
				retorno = ((Number) pagamentoImovelCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}catch(Exception e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Collection pesquisarPagamentoImovelRelatorio(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria)
					throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT pagto.id, loc.id, loc.descricao, "
							+ "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
							+ "cliArrec.nome, pagto.dataPagamento, "
							+ "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
							+ "conta.valorAgua, conta.valorEsgoto, conta.debitos, "
							+ "conta.valorCreditos, dbcb.valorDebito, dbcb.numeroPrestacaoDebito, "
							+ "dbcb.numeroPrestacaoCobradas, gpag.valorDebito, pagto.valorPagamento, "
							+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id, conta.dataVencimentoConta,gpag.id, pagto.numeroPrestacao, "
							+ "dbcb.id, stcm.codigo, pagto.conta.id " + "FROM Pagamento pagto " + "LEFT JOIN pagto.localidade loc "
							+ "LEFT JOIN loc.gerenciaRegional gr " + "LEFT JOIN pagto.avisoBancario avbc "
							+ "LEFT JOIN avbc.arrecadador arrec " + "LEFT JOIN arrec.cliente cliArrec "
							+ "LEFT JOIN pagto.documentoTipo doctoTp " + "LEFT JOIN pagto.imovel imov " + "LEFT JOIN pagto.cliente cli "
							+ "LEFT JOIN pagto.debitoTipo dbtp " + "LEFT JOIN pagto.conta conta "
							+ "LEFT JOIN pagto.guiaPagamentoGeral gpagGeral " + "LEFT JOIN gpagGeral.guiaPagamento gpag "
							+ "LEFT JOIN pagto.debitoACobrar dbcb " + "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
							+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem " + "LEFT JOIN imov.imovelSubcategorias imsb "
							+ "LEFT JOIN imov.setorComercial stcm " + "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
							+ "LEFT JOIN pagto.arrecadacaoForma arrecForma " + condicionais;

			if(indicadorTotalizarPorDataPagamento != null && indicadorTotalizarPorDataPagamento.equals(ConstantesSistema.SIM.toString())){
				hql = hql + " ORDER BY pagto.dataPagamento, loc.id, stcm.codigo, imov.id ";
			}else{
				hql = hql + " ORDER BY loc.id, imov.id, pagto.anoMesReferenciaPagamento, pagto.dataPagamento ";
			}

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @author Virgínia Melo
	 * @date 02/04/2009
	 *       Correção na consulta para nova estrutura da guia.
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoClienteRelatorio(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria)
					throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		String sql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			sql = " select 'CONTA' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
							+ " c.pgmt_dtpagamento as dataPagamento, c.pgmt_amreferenciapagamento as anoMesPagamento, null as tipoDebito, (cnta_vlagua + cnta_vlesgoto + cnta_vldebitos - cnta_vlcreditos) as valorDocumento, "
							+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo, stcm.stcm_cdsetorcomercial as codigoSetorComercial, c.cnta_id as idConta "
							+ " from cliente a, cliente_conta b, localidade d, gerencia_regional e, "
							+ " aviso_bancario f, arrecadador g, cliente h, conta i, pagamento c "
							+ " left join pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " where a.clie_id = b.clie_id "
							+ " and b.cnta_id = c.cnta_id "
							+ " and c.loca_id = d.loca_id "
							+ " and d.greg_id = e.greg_id "
							+ " and c.avbc_id = f.avbc_id "
							+ " and f.arrc_id = g.arrc_id "
							+ " and g.clie_id = h.clie_id "
							+ " and b.cnta_id = i.cnta_id " + " and "
							+ condicionais
							+ " union "
							+ " select 'DÉBITO A COBRAR' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
							+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
							+ " ((dbac_nnprestacaodebito - dbac_nnprestacaocobradas) * (dbac_vldebito/ dbac_nnprestacaodebito)) as valorDocumento, "
							+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo, stcm.stcm_cdsetorcomercial as codigoSetorComercial, c.cnta_id as idConta "
							+ " from cliente a, cliente_imovel b, debito_a_cobrar b1, localidade d, gerencia_regional e, "
							+ " aviso_bancario f, arrecadador g, cliente h, debito_tipo k, pagamento c "
							+ " left join pagamento_situacao j "
							+ " on c.pgst_idatual = j.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " where a.clie_id = b.clie_id "
							+ " and b.imov_id = b1.imov_id "
							+ " and b1.dbac_id = c.dbac_id "
							+ " and c.loca_id = d.loca_id "
							+ " and d.greg_id = e.greg_id "
							+ " and c.avbc_id = f.avbc_id "
							+ " and f.arrc_id = g.arrc_id "
							+ " and g.clie_id = h.clie_id "
							+ " and b1.dbtp_id = k.dbtp_id "
							+ " and "
							+ condicionais
							+ " union "
							+ " select 'GUIA PAGAMENTO IMOVEL' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
							+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
							+ " (gpag_vldebito) as valorDocumento, "
							+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo, stcm.stcm_cdsetorcomercial as codigoSetorComercial, c.cnta_id as idConta "
							+ " from cliente a, cliente_guia_pagamento b, guia_pagamento b1, guia_pagamento_prestacao gpp, localidade d, gerencia_regional e, "
							+ " aviso_bancario f, arrecadador g, cliente h, debito_tipo k, pagamento c "
							+ " left join pagamento_situacao j "
							+ " on c.pgst_idatual = j.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " where a.clie_id = b.clie_id "
							+ " and b.gpag_id = b1.gpag_id "
							+ " and b1.gpag_id = c.gpag_id "
							+ " and c.loca_id = d.loca_id "
							+ " and d.greg_id = e.greg_id "
							+ " and c.avbc_id = f.avbc_id "
							+ " and f.arrc_id = g.arrc_id "
							+ " and g.clie_id = h.clie_id "
							+ " and gpp.dbtp_id = k.dbtp_id "
							+ " and gpp.gppr_nnprestacao = c.pgmt_nnprestacao "
							+ " and "
							+ condicionais
							+ " union "
							+ " select 'GUIA PAGAMENTO CLIENTE' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente, a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
							+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
							+ " (gpag_vldebito) as valorDocumento, "
							+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo, stcm.stcm_cdsetorcomercial as codigoSetorComercial, c.cnta_id as idConta "
							+ " from cliente a, cliente_guia_pagamento b, guia_pagamento b1, guia_pagamento_prestacao gpp, localidade d, gerencia_regional e, "
							+ " aviso_bancario f, arrecadador g, cliente h, debito_tipo k, pagamento c "
							+ " left join pagamento_situacao j "
							+ " on c.pgst_idatual = j.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " where a.clie_id = b.clie_id "
							+ " and a.clie_id = c.clie_id "
							+ " and b.gpag_id = b1.gpag_id "
							+ " and b1.gpag_id = c.gpag_id "
							+ " and c.loca_id = d.loca_id "
							+ " and d.greg_id = e.greg_id "
							+ " and c.avbc_id = f.avbc_id "
							+ " and f.arrc_id = g.arrc_id "
							+ " and g.clie_id = h.clie_id "
							+ " and gpp.dbtp_id = k.dbtp_id "
							+ " and gpp.gppr_nnprestacao = c.pgmt_nnprestacao "
							+ " and "
							+ condicionais
							+ " union "
							+ " select 'PAGAMENTO CLIENTE' as tipo, d.loca_id as idLocalidade, d.loca_nmlocalidade as nomeLocalidade, e.greg_id as idGerencia, e.greg_nmregional as nomeGerencia, c.imov_id as idImovel, c.clie_id as idCliente , a.clie_nmcliente as nomeCliente, h.clie_nmcliente as nomeArrecadador, "
							+ " c.pgmt_dtpagamento as dataPagamento,  c.pgmt_amreferenciapagamento as anoMesPagamento, dbtp_dsdebitotipo as tipoDebito, "
							+ " null as valorDocumento, "
							+ " c.pgmt_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamento, j.pgst_dspagamentosituacao as situacaoPagamento, c.dotp_id as idDocumentoTipo, stcm.stcm_cdsetorcomercial as codigoSetorComercial, c.cnta_id as idConta "
							+ " from cliente a, localidade d, gerencia_regional e, "
							+ " aviso_bancario f, arrecadador g, cliente h, debito_tipo k, pagamento c "
							+ " left join pagamento_situacao j "
							+ " on c.pgst_idatual = j.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " where a.clie_id = c.clie_id "
							+ " and   c.loca_id = d.loca_id "
							+ " and   d.greg_id = e.greg_id "
							+ " and   c.avbc_id = f.avbc_id "
							+ " and   f.arrc_id = g.arrc_id " + " and   g.clie_id = h.clie_id " + " and   c.dbtp_id = k.dbtp_id " + " and ";

			String condicionaisClientePagamento = this.criarCondicionaisPagamentoCliente(idImovel, idCliente, null, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			sql = sql + condicionaisClientePagamento;

			if(indicadorTotalizarPorDataPagamento != null && indicadorTotalizarPorDataPagamento.equals(ConstantesSistema.SIM.toString())){
				sql = sql + " ORDER BY dataPagamento, idLocalidade, codigoSetorComercial, idImovel ";
			}

			retorno = session.createSQLQuery(sql).addScalar("tipo", Hibernate.STRING).addScalar("idLocalidade", Hibernate.INTEGER)
							.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("idGerencia", Hibernate.INTEGER).addScalar(
											"nomeGerencia", Hibernate.STRING).addScalar("idImovel", Hibernate.INTEGER).addScalar(
											"idCliente", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING).addScalar(
											"nomeArrecadador", Hibernate.STRING).addScalar("dataPagamento", Hibernate.DATE).addScalar(
											"anoMesPagamento", Hibernate.INTEGER).addScalar("tipoDebito", Hibernate.STRING).addScalar(
											"valorDocumento", Hibernate.BIG_DECIMAL).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("idSituacaoPagamento", Hibernate.INTEGER).addScalar("situacaoPagamento", Hibernate.STRING)
							.addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("idConta", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancarioRelatorio(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT pagto.id, loc.id, loc.descricao, " + "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
							+ "cliArrec.nome, pagto.dataPagamento, " + "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
							+ "conta.valorAgua, conta.valorEsgoto, conta.debitos, "
							+ "conta.valorCreditos, dbcb.valorDebito, dbcb.numeroPrestacaoDebito, "
							+ "dbcb.numeroPrestacaoCobradas, gpag.valorDebito, pagto.valorPagamento, "
							+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id, stcm.codigo, pagto.conta.id "
							+ "FROM Pagamento pagto " + "INNER JOIN pagto.localidade loc " + "INNER JOIN loc.gerenciaRegional gr "
							+ "INNER JOIN pagto.avisoBancario avbc " + "INNER JOIN avbc.arrecadador arrec "
							+ "INNER JOIN arrec.cliente cliArrec " + "INNER JOIN pagto.documentoTipo doctoTp "
							+ "LEFT JOIN pagto.imovel imov " + "LEFT JOIN pagto.cliente cli " + "LEFT JOIN pagto.debitoTipo dbtp "
							+ "LEFT JOIN pagto.conta conta " + "LEFT JOIN pagto.guiaPagamentoGeral gpagGeral "
							+ "LEFT JOIN gpagGeral.guiaPagamento gpag " + "LEFT JOIN pagto.debitoACobrar dbcb "
							+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
							+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem " + "LEFT JOIN imov.imovelSubcategorias imsb "
							+ "LEFT JOIN imov.setorComercial stcm " + "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
							+ "LEFT JOIN pagto.arrecadacaoForma arrecForma " + condicionais;

			if(indicadorTotalizarPorDataPagamento != null && indicadorTotalizarPorDataPagamento.equals(ConstantesSistema.SIM.toString())){
				hql = hql + " ORDER BY pagto.dataPagamento, loc.id, stcm.codigo, imov.id ";
			}else{
				hql = hql + " ORDER BY loc.id, imov.id, pagto.anoMesReferenciaPagamento, pagto.dataPagamento ";
			}

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadadorRelatorio(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT pagto.id, loc.id, loc.descricao, " + "gr.id, gr.nome, imov.id, cli.id, cli.nome, "
							+ "cliArrec.nome, pagto.dataPagamento, " + "pagto.anoMesReferenciaPagamento, dbtp.descricao, "
							+ "conta.valorAgua, conta.valorEsgoto, conta.debitos, "
							+ "conta.valorCreditos, dbcb.valorDebito, dbcb.numeroPrestacaoDebito, "
							+ "dbcb.numeroPrestacaoCobradas, gpag.valorDebito, pagto.valorPagamento, "
							+ "pagtoSitAtual.id, pagtoSitAtual.descricao, doctoTp.id, stcm.codigo, pagto.conta.id "
							+ "FROM Pagamento pagto " + "INNER JOIN pagto.localidade loc " + "INNER JOIN loc.gerenciaRegional gr "
							+ "INNER JOIN pagto.avisoBancario avbc " + "INNER JOIN avbc.arrecadador arrec "
							+ "INNER JOIN arrec.cliente cliArrec " + "INNER JOIN pagto.documentoTipo doctoTp "
							+ "LEFT JOIN pagto.imovel imov " + "LEFT JOIN pagto.cliente cli " + "LEFT JOIN pagto.debitoTipo dbtp "
							+ "LEFT JOIN pagto.conta conta " + "LEFT JOIN pagto.guiaPagamentoGeral gpagGeral "
							+ "LEFT JOIN gpagGeral.guiaPagamento gpag " + "LEFT JOIN pagto.debitoACobrar dbcb "
							+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
							+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem " + "LEFT JOIN imov.imovelSubcategorias imsb "
							+ "LEFT JOIN imov.setorComercial stcm " + "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
							+ "LEFT JOIN pagto.arrecadacaoForma arrecForma " + condicionais;

			if(indicadorTotalizarPorDataPagamento != null && indicadorTotalizarPorDataPagamento.equals(ConstantesSistema.SIM.toString())){
				hql = hql + " ORDER BY pagto.dataPagamento, loc.id, stcm.codigo, imov.id ";
			}else{
				hql = hql + " ORDER BY loc.id, imov.id, dbtp.id, pagto.dataPagamento ";
			}

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @author Saulo Lima
	 * @date 13/01/2009
	 *       Alteração nos campos de retorno e Generics na coleção de retorno
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<Object> pesquisarPagamentoLocalidadeRelatorio(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Object> retorno = new ArrayList();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente informado (a partir da
			// tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com CLIE_ID = Id do cliente
			// informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com o Imóvel, caso
			// selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT pagto.id, " // 0
							+ "loc.id, " // 1
							+ "loc.descricao, " // 2
							+ "gr.id, " // 3
							+ "gr.nome, " // 4
							+ "imov.id, " // 5
							+ "cli.id, " // 6
							+ "cli.nome, " // 7
							+ "cliArrec.nome, " // 8
							+ "pagto.dataPagamento, " // 9
							+ "pagto.anoMesReferenciaPagamento, " // 10
							+ "dbtp.descricao, " // 11
							+ "pagto.valorPagamento, " // 12
							+ "pagtoSitAtual.id, " // 13
							+ "pagtoSitAtual.descricao, " // 14
							+ "doctoTp.id, " // 15
							+ "pagto.debitoACobrar.id, " // 16
							+ "pagto.guiaPagamentoGeral.id, " // 17
							+ "pagto.numeroPrestacao, " // 18
							+ "stcm.codigo, " + "pagto.conta.id " + "FROM Pagamento pagto "
							+ "INNER JOIN pagto.localidade loc "
							+ "INNER JOIN loc.gerenciaRegional gr "
							+ "INNER JOIN pagto.avisoBancario avbc "
							+ "INNER JOIN avbc.arrecadador arrec "
							+ "INNER JOIN arrec.cliente cliArrec "
							+ "INNER JOIN pagto.documentoTipo doctoTp "
							+ "LEFT JOIN pagto.imovel imov "
							+ "LEFT JOIN pagto.cliente cli "
							+ "LEFT JOIN pagto.debitoTipo dbtp "
							+ "LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual "
							+ "LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem "
							+ "LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov "
							+ "LEFT JOIN pagto.arrecadacaoForma arrecForma "
							+ "LEFT JOIN imov.imovelSubcategorias imsb " + "LEFT JOIN imov.setorComercial stcm " + condicionais;

			if(indicadorTotalizarPorDataPagamento != null && indicadorTotalizarPorDataPagamento.equals(ConstantesSistema.SIM.toString())){
				hql = hql + " ORDER BY pagto.dataPagamento, loc.id, stcm.codigo, imov.id ";
			}else{
				hql = hql + " ORDER BY loc.id, imov.id, dbtp.id, pagto.dataPagamento ";
			}

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoMovimentoArrecadadorCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ErroRepositorioException{

		int retorno = 0;
		Object pagamentoMovimentoArrecadadorCount;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal, null,
							idsArrecadadores, idsCategoria);

			hql = "SELECT COUNT(pagamento.id)" + " FROM gcom.arrecadacao.pagamento.Pagamento pagamento"
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem" + " " + condicionais;

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoMovimentoArrecadadorCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoMovimentoArrecadadorCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setMaxResults(1).uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoMovimentoArrecadadorCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal)
								.setMaxResults(1).uniqueResult();
			}else{
				pagamentoMovimentoArrecadadorCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			if(pagamentoMovimentoArrecadadorCount != null){
				retorno = ((Number) pagamentoMovimentoArrecadadorCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Saulo Lima
	 * @date 25/08/2009
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoMovimentoArrecadadorCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ErroRepositorioException{

		int retorno = 0;
		Object pagamentoMovimentoArrecadadorCount;
		String hql = "";
		Session session = HibernateUtil.getSession();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		try{

			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, null, idsArrecadadores, idsCategoria);

			hql = "SELECT COUNT(pagamentoHistorico.id)" + " FROM gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico"
							+ " LEFT JOIN pagamentoHistorico.arrecadadorMovimentoItem arrecadadorMovimentoItem "
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN arrecadadorMovimentoItem.arrecadadorMovimento arrecadadorMovimento " + condicionais;

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoMovimentoArrecadadorCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoMovimentoArrecadadorCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setMaxResults(1).uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoMovimentoArrecadadorCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal)
								.setMaxResults(1).uniqueResult();
			}else{
				pagamentoMovimentoArrecadadorCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			if(pagamentoMovimentoArrecadadorCount != null){
				retorno = ((Number) pagamentoMovimentoArrecadadorCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoLocalidadeCount(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		int retorno = 0;
		Object pagamentoLocalidadeCount;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamento(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal, null,
							idsArrecadadores, idsCategoria);

			hql = "SELECT COUNT(pagamento.id) " + " FROM gcom.arrecadacao.pagamento.Pagamento pagamento"
							+ " LEFT JOIN pagamento.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN pagamento.arrecadadorMovimentoItem arrecadadorMovimentoItem " + condicionais;

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoLocalidadeCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoLocalidadeCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setMaxResults(1).uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoLocalidadeCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1)
								.uniqueResult();
			}else{
				pagamentoLocalidadeCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			if(pagamentoLocalidadeCount != null){
				retorno = ((Number) pagamentoLocalidadeCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer verificarExistenciaGuiaDevolucao(Integer idGuiaDevolucao) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada

		Integer retorno = null;

		// cria a variável que vai armazenar a coleção pesquisada
		// Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select guiaDevolucao.id " + "from GuiaDevolucao guiaDevolucao "
							+ "where guiaDevolucao.id = :idGuiaDevolucao";

			retorno = (Integer) session.createQuery(consulta).setInteger("idGuiaDevolucao", idGuiaDevolucao.intValue()).setMaxResults(1)
							.uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa os avisos bancários para o relatório através das opções
	 * selecionadas no Filtrar Aviso Bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 04/09/06
	 * @return Collection<AvisoBancarioRelatorioHelper>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAvisoBancarioRelatorio(AvisoBancarioHelper avisoBancarioHelper) throws ErroRepositorioException{

		String consulta = "";

		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// Consulta
		try{

			consulta = "select ab.id, c.nomeAbreviado, ab.dataLancamento, ab.numeroSequencial, "
							+ "ab.indicadorCreditoDebito, ab.numeroDocumento, b.descricaoAbreviada, "
							+ "ag.codigoAgencia, cb.numeroConta, ab.dataRealizada, "
							+ "ab.valorArrecadacaoInformado, ab.valorDevolucaoInformado, ab.valorRealizado, "
							+ "ab.valorArrecadacaoCalculado, ab.valorDevolucaoCalculado " + "from AvisoBancario ab "
							+ "inner join ab.arrecadador arrec " + "inner join ab.contaBancaria cb " + "inner join cb.agencia ag "
							+ "inner join ag.banco b " + "inner join arrec.cliente c where ";

			consulta += " ab.id = " + avisoBancarioHelper.getAvisoBancario().getId().toString() + " and ";

			consulta = Util.formatarHQL(consulta, 4) + " order by arrec.codigoAgente, ab.dataLancamento";

			retorno = session.createQuery(consulta).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa os avisos deduções de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 05/09/06
	 * @return Collection<DeducoesRelatorioHelper>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAvisoDeducoesAvisoBancarioRelatorio(Integer idAvisoBancario) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select dt.descricaoAbreviada, ad.valorDeducao " + "from AvisoDeducoes ad " + "inner join ad.deducaoTipo dt "
							+ "inner join ad.avisoBancario ab " + "where ab.id = :idAvisoBancario";

			retorno = session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario.intValue()).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa os avisos acertos de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 05/09/06
	 * @return Collection<AcertosRelatorioHelper>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAvisoAcertosAvisoBancarioRelatorio(Integer idAvisoBancario) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada

		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select b.descricaoAbreviada, ag.codigoAgencia, cb.numeroConta, "
							+ "aa.indicadorCreditoDebito, aa.dataAcerto, aa.valorAcerto " + "from AvisoAcerto aa "
							+ "inner join aa.contaBancaria cb " + "inner join cb.agencia ag " + "inner join ag.banco b "
							+ "inner join aa.avisoBancario ab " + "where ab.id = :idAvisoBancario";

			retorno = session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario.intValue()).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa dos dados diários da arrecadação
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Rafael Santos
	 * @date 05/09/2006
	 * @return
	 */
	public Collection filtrarDadosDiariosArrecadacao(String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String idLocalidade,
					String idGerenciaRegional, String unidadeNegocioId, String idArrecadador, String idElo, String[] idsImovelPerfil,
					String[] idsLigacaoAgua, String[] idsLigacaoEsgoto, String[] idsDocumentosTipos, String[] idsCategoria,
					String[] idsEsferaPoder, String setorComercial, String idConcessionaria) throws ErroRepositorioException{

		Collection retorno = new ArrayList();
		// Collection<ArrecadacaoDadosDiarios> colecaoPagamento = null;

		String sql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisDadosDiariosArrecadacao(periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							idLocalidade, idGerenciaRegional, unidadeNegocioId, idArrecadador, idElo, idsImovelPerfil, idsLigacaoAgua,
							idsLigacaoEsgoto, idsDocumentosTipos, idsCategoria, idsEsferaPoder, setorComercial, idConcessionaria);

			sql = " select distinct ardd.ardd_amreferenciaarrecadacao as anoMesReferenciaArrecadacao, "
							+ // 0
							"ardd.ardd_dtpagamento as dataPagamento, "
							+ // 1
							"sum(ardd.ardd_qtpagamentos) as quantidadePagamentos, "
							+ // 2
							"sum(ardd.ardd_vlpagamentos) as valorPagamentos, "
							+ // 3
							"ardd.arrc_id as arrecadador, "
							+ // 4
								// "ardd.arrecadacaoForma.id, " + //5
							"ardd.dotp_id as documentoTipo, "
							+ // 5
							"ardd.iper_id as imovelPerfil, "
							+ // 6
							"ardd.greg_id as gerenciaRegional, "
							+ // 7
							"ardd.loca_id as localidade, "
							+ // 8
							"ardd.catg_id as categoria, "
							+ // 9
							// "localidade.descricao, " + //11
							// "gerenciaRegional.nome, " + //12
							// "gerenciaRegional.nomeAbreviado, " + //13
							// "documentoTipo.descricaoDocumentoTipo, " + //14
							// "categoria.descricao, " + //15
							// "cliente.nome," + //16
							// "imovelPerfil.descricao," + //17
							"loca.loca_cdelo as elo, "
							+ // 10
							"ardd.uneg_id as unidadeNegocio, "
							+ // 11
							"ardd.ardd_cdsetorcomercial as codigoSetorComercial, "
							+ // 12
							"stcm.stcm_nmsetorcomercial as nomeSetorComercial, "
							+ // 13
							"stcm.loca_id as localidadeSetorComercial"
							+ // 14
							(idConcessionaria != null && !idConcessionaria.equals("") ? ", " + "conc.conc_id as concessionaria, "
							+ // 15
											"conc.conc_nmconcessionaria as nomeConcessionaria, " +
							// 16
											"conc.conc_nmabreviadoconcessionaria as nomeAbreviadoConcessionaria" : "")
							// 17

							// "elo.id " //19
							+ "\n from arrecadacao_dados_diarios ardd "
							+ "\n left join setor_comercial stcm on stcm.stcm_id = ardd.stcm_id "
							+ " inner join gerencia_regional greg on greg.greg_id = ardd.greg_id "
							+ " inner join localidade loca on loca.loca_id = ardd.loca_id "
							+ " inner join localidade elo on elo.loca_id = loca.loca_cdelo "
							+
							(idConcessionaria != null && !idConcessionaria.equals("") ? "\n join concessionaria_localidade cnlc on cnlc.loca_id = ardd.loca_id "
											+ "\n and ((cnlc.cnlc_dtvigenciafim is null and ardd.ardd_dtpagamento >= cnlc.cnlc_dtvigenciainicio) "
											+ " or (cnlc.cnlc_dtvigenciafim is not null "
											+ "  and ardd.ardd_dtpagamento between cnlc.cnlc_dtvigenciainicio and cnlc.cnlc_dtvigenciafim))"
											+ "\n join concessionaria conc on conc.conc_id = cnlc.conc_id "
											: "")

							// "left join ardd.localidade localidade
							// " +
							// "left join localidade.localidade elo " +
							// "left join ardd.gerenciaRegional
							// gerenciaRegional " +
							// "left join ardd.documentoTipo
							// documentoTipo " +
							// "left join ardd.categoria categoria "
							// +
							// "left join ardd.arrecadador
							// arrecadador " +
							// "left join arrecadador.cliente cliente " +
							// "left join ardd.imovelPerfil
							// imovelPerfil "
							+ condicionais
							+ " group by "
							+

							(idConcessionaria != null && !idConcessionaria.equals("") ? "conc.conc_id, conc.conc_nmconcessionaria, conc.conc_nmabreviadoconcessionaria, "
											: "")

							+ "ardd.ardd_amreferenciaarrecadacao,"
							+ "ardd.arrc_id,"
							// "cliente.nome, " +
							+ "ardd.greg_id,"
							+
							// "gerenciaRegional.nome, " +
							// "gerenciaRegional.nomeAbreviado, " +
							"ardd.loca_id,"
							+
							// "localidade.descricao," +
							// "elo.descricao, " +
							// "ardd.localidade.localidade.id, "
							 "ardd.iper_id,"
							+
							// "imovelPerfil.descricao, " +
							"ardd.catg_id,"
							+
							// "categoria.descricao, " +
							"ardd.dotp_id,"
							+
							// "documentoTipo.descricaoDocumentoTipo, " +
							// "ardd.arrecadacaoForma.id," +
							"ardd.ardd_dtpagamento," + "loca.loca_cdelo, " + "ardd.uneg_id, " + "ardd.ardd_cdsetorcomercial, "
							+ "stcm.stcm_nmsetorcomercial, " + "stcm.loca_id "
							+ " order by ardd.ardd_amreferenciaarrecadacao, " + "ardd.ardd_dtpagamento ";
			// "cliente.nome," +
			// "gerenciaRegional.nome, " +
			// "elo.descricao, " +
			// "localidade.descricao ";

			// "categoria.id, " +
			// "imovelPerfil.descricao, " +
			// "documentoTipo.descricaoDocumentoTipo ";

			// + " order by
			// ardd.anoMesReferenciaArrecadacao,ardd.dataPagamento,categoria.id
			// ";

			SQLQuery query = session.createSQLQuery(sql);

			query.addScalar("anoMesReferenciaArrecadacao", Hibernate.INTEGER);
			query.addScalar("dataPagamento", Hibernate.DATE);
			query.addScalar("quantidadePagamentos", Hibernate.INTEGER);
			query.addScalar("valorPagamentos", Hibernate.BIG_DECIMAL);
			query.addScalar("arrecadador", Hibernate.INTEGER);
			query.addScalar("documentoTipo", Hibernate.INTEGER);
			query.addScalar("imovelPerfil", Hibernate.INTEGER);
			query.addScalar("gerenciaRegional", Hibernate.INTEGER);
			query.addScalar("localidade", Hibernate.INTEGER);
			query.addScalar("categoria", Hibernate.INTEGER);
			query.addScalar("elo", Hibernate.INTEGER);
			query.addScalar("unidadeNegocio", Hibernate.INTEGER);
			query.addScalar("codigoSetorComercial", Hibernate.INTEGER);
			query.addScalar("nomeSetorComercial", Hibernate.STRING);
			query.addScalar("localidadeSetorComercial", Hibernate.INTEGER);

			if(!Util.isVazioOuBranco(idConcessionaria)){
				query.addScalar("concessionaria", Hibernate.INTEGER);
				query.addScalar("nomeConcessionaria", Hibernate.STRING);
				query.addScalar("nomeAbreviadoConcessionaria", Hibernate.STRING);
			}

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa dos dados diários da arrecadação pela Gerencia
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Rafael Santos
	 * @date 05/09/2006
	 * @return
	 */
	public Collection filtrarDadosDiariosArrecadacaoValoresDiarios(String idGerenciaRegional) throws ErroRepositorioException{

		Collection retorno = null;

		String sql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisDadosDiariosArrecadacao(null, null, null, idGerenciaRegional, null, null, null,
							null, null, null, null, null, null, null, null);

			sql = " select  greg.greg_nmregional, loca.loca_nmlocalidade, elo.loca_nmlocalidade "
							+ " from arrecadacao_dados_diarios  ardd "
							+ " inner join gerencia_regional greg on greg.greg_id = ardd.greg_id "
							+ " inner join localidade loca on loca.loca_id = ardd.loca_id "
							+ " inner join arrecadacaoDadosDiarios.gerenciaRegional gerenciaRegional "
							+ " inner join localidade elo on elo.loca_id = loca.loca_cdelo " + condicionais + " ";

			retorno = session.createSQLQuery(sql).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de dados
	 * diarios da arrecadacao
	 * [UC0333] Filtrar Dados Diarios da Arrecadação
	 * Pesquisa os dados diarios com os condicionais informados
	 * 
	 * @author Rafael Santos
	 * @date 05/09/06
	 * @return
	 */
	private String criarCondicionaisDadosDiariosArrecadacao(String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
					String idLocalidade, String idGerenciaRegional, String unidadeNegocioId, String idArrecadador, String idElo,
					String[] idsImovelPerfil, String[] idsLigacaoAgua, String[] idsLigacaoEsgoto, String[] idsDocumentosTipos,
					String[] idsCategoria, String[] idsEsferaPoder, String setorComercial, String idConcessionaria){

		String sql = " where ";

		// periodo inicial e final
		if(periodoArrecadacaoInicial != null && periodoArrecadacaoInicial != null && !periodoArrecadacaoFinal.equals("")
						&& !periodoArrecadacaoFinal.equals("")){

			sql = sql + "ardd.ardd_amreferenciaarrecadacao >= " + periodoArrecadacaoInicial + " and ";
			sql = sql + "ardd.ardd_amreferenciaarrecadacao <= " + periodoArrecadacaoFinal + " and ";
		}

		// localidade
		if(idLocalidade != null && !idLocalidade.equals("")){
			sql = sql + " ardd.loca_id = " + idLocalidade + " and ";
			if(!Util.isVazioOuBranco(setorComercial)){
				sql += " ardd.stcm_id = " + setorComercial + " and ";
			}
		}

		// Concessionária
		if(idConcessionaria != null && !idConcessionaria.equals("")
						&& !idConcessionaria.equals(ConstantesSistema.NUMERO_NAO_INFORMADO_STRING)){
			sql += "cnlc.conc_id = " + idConcessionaria + " and ";

		}

		// gerencia regional
		if(idGerenciaRegional != null && !idGerenciaRegional.equals("")
						&& !idGerenciaRegional.equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")){
			sql = sql + " ardd.greg_id = " + idGerenciaRegional + " and ";
		}
		// arrecadador
		if(idArrecadador != null && !idArrecadador.equals("")){
			sql = sql + " ardd.arrc_id = " + idArrecadador + " and ";
		}
		// elo
		if(idElo != null && !idElo.equals("")){
			sql = sql + " elo.loca_id = " + idElo + " and ";
		}

		// Imovel Perfil
		if(idsImovelPerfil != null && idsImovelPerfil.length > 0){

			if(!idsImovelPerfil[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")){
				int i = 0;
				sql = sql + " ( ";
				while(i < idsImovelPerfil.length){
					if(!idsImovelPerfil[i].equals("")){

						if(i + 1 < idsImovelPerfil.length){

							sql = sql + " ardd.iper_id = " + idsImovelPerfil[i] + " or ";

						}else{

							sql = sql + " ardd.iper_id = " + idsImovelPerfil[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.formatarHQL(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Situação Ligação Água
		if(idsLigacaoAgua != null && idsLigacaoAgua.length > 0){
			if(!idsLigacaoAgua[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")){
				int i = 0;
				sql = sql + " ( ";
				while(i < idsLigacaoAgua.length){
					if(!idsLigacaoAgua[i].equals("")){

						if(i + 1 < idsLigacaoAgua.length){

							sql = sql + " ardd.last_id = " + idsLigacaoAgua[i] + " or ";

						}else{

							sql = sql + " ardd.last_id = " + idsLigacaoAgua[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.formatarHQL(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Situação Ligação Esgoto
		if(idsLigacaoEsgoto != null && idsLigacaoEsgoto.length > 0){
			if(!idsLigacaoEsgoto[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")){
				int i = 0;
				sql = sql + " ( ";
				while(i < idsLigacaoEsgoto.length){
					if(!idsLigacaoEsgoto[i].equals("")){

						if(i + 1 < idsLigacaoEsgoto.length){

							sql = sql + " ardd.lest_id = " + idsLigacaoEsgoto[i] + " or ";

						}else{

							sql = sql + " ardd.lest_id = " + idsLigacaoEsgoto[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.formatarHQL(sql, 4);

				sql = sql + " ) and ";
			}
		}

		// Categoria
		if(idsCategoria != null && idsCategoria.length > 0){
			if(!idsCategoria[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")){
				int i = 0;
				sql = sql + " ( ";
				while(i < idsCategoria.length){
					if(!idsCategoria[i].equals("")){

						if(i + 1 < idsCategoria.length){

							sql = sql + " ardd.catg_id = " + idsCategoria[i] + " or ";

						}else{

							sql = sql + " ardd.catg_id = " + idsCategoria[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.formatarHQL(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// Esfera Poder
		if(idsEsferaPoder != null && idsEsferaPoder.length > 0){
			if(!idsEsferaPoder[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")){
				int i = 0;
				sql = sql + " ( ";
				while(i < idsEsferaPoder.length){
					if(!idsEsferaPoder[i].equals("")){

						if(i + 1 < idsEsferaPoder.length){

							sql = sql + " ardd.epod_id = " + idsEsferaPoder[i] + " or ";

						}else{

							sql = sql + " ardd.epod_id = " + idsEsferaPoder[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.formatarHQL(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// documento tipo
		if(idsDocumentosTipos != null && idsDocumentosTipos.length > 0){
			if(!idsDocumentosTipos[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")){
				int i = 0;
				sql = sql + " ( ";
				while(i < idsDocumentosTipos.length){
					if(!idsDocumentosTipos[i].equals("")){

						if(i + 1 < idsDocumentosTipos.length){

							sql = sql + " ardd.dotp_id = " + idsDocumentosTipos[i] + " or ";

						}else{

							sql = sql + " ardd.dotp_id = " + idsDocumentosTipos[i] + " and ";
						}
					}
					i++;
				}
				sql = Util.formatarHQL(sql, 4);

				sql = sql + " ) and ";
			}

		}

		// retira o " and " q fica sobrando no final da query
		sql = Util.formatarHQL(sql, 4);

		return sql;
	}

	/**
	 * Retornar Coleção do movimento do arrecadador
	 * Seleciona Movimento Arrecadadores
	 * 
	 * @author Fernanda Paiva
	 * @date
	 * @throws ErroRepositorioException
	 */
	public Collection<ArrecadadorMovimento> retornarColecaoMovimentoArrecadadores(FiltroArrecadadorMovimento filtro, Integer numeroPagina)
					throws ErroRepositorioException{

		Collection<ArrecadadorMovimento> retorno = null;

		Session session = HibernateUtil.getSession();

		try{

			retorno = new ArrayList(new CopyOnWriteArraySet<ArrecadadorMovimento>(GeradorHQLCondicional.gerarCondicionalQuery(
							filtro,
							"gcom.arrecadacao.ArrecadadorMovimento",
							"arrecadadorMovimento",
							"SELECT DISTINCT arrecadadorMovimento " + "FROM ArrecadadorMovimento  arrecadadorMovimento "
											+ "LEFT JOIN arrecadadorMovimento.arrecadadorMovimentoItens  "
											+ FiltroArrecadadorMovimento.ALIAS_ARRECADADOR_MOVIMENTO_ITEM + "", session).setFirstResult(
							10 * numeroPagina).setMaxResults(10).list()));
			/*
			 * if
			 * (!filtro.getColecaoCaminhosParaCarregamentoEntidades().isEmpty()) {
			 * PersistenciaUtil.processaObjetosParaCarregamento(filtro.
			 * getColecaoCaminhosParaCarregamentoEntidades(),
			 * retorno); }
			 */
		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public BigDecimal pesquisarSomatorioAvisoAcerto(Integer indicadorCreditoDebito, Integer idAviso, Integer indicadorArrecadacaoDevolucao)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select sum(avisoAcerto.valorAcerto) from AvisoAcerto avisoAcerto "
							+ " inner join avisoAcerto.avisoBancario avisoBancario "
							+ " where avisoAcerto.indicadorCreditoDebito = :indicadorCreditoDebito"
							+ " and avisoAcerto.indicadorArrecadacaoDevolucao = :indicadorArrecadacaoDevolucao "
							+ " and avisoBancario.id = :idAviso";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("indicadorCreditoDebito", indicadorCreditoDebito).setInteger(
							"indicadorArrecadacaoDevolucao", indicadorArrecadacaoDevolucao).setInteger("idAviso", idAviso).setMaxResults(1)
							.uniqueResult();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection filtrarAvisoBancarioAbertoFechadoFinal(AvisoBancarioHelper avisoBancarioHelper) throws ErroRepositorioException{

		// Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		// Consulta
		try{

			Short arrecadadorCodAgente = avisoBancarioHelper.getCodigoAgenteArrecadador();
			Date dataLancamentoInicio = avisoBancarioHelper.getDataLancamentoInicial();
			Date dataLancamentoFim = avisoBancarioHelper.getDataLancamentoFinal();
			Short indicadorCreditoDebito = avisoBancarioHelper.getIndicadorCreditoDebito();
			Integer idContaBancaria = avisoBancarioHelper.getIdContaBancaria();
			Integer idMovimento = avisoBancarioHelper.getIdMovimentoArrecadador();
			Date dataPrevisaoCreditoDebitoInicio = avisoBancarioHelper.getDataPrevistaInicial();
			Date dataPrevisaoCreditoDebitoFim = avisoBancarioHelper.getDataPrevistaFinal();
			Date dataRealizacaoCreditoDebitoInicio = avisoBancarioHelper.getDataRealizadaInicial();
			Date dataRealizacaoCreditoDebitoFim = avisoBancarioHelper.getDataRealizadaFinal();
			int anoMesReferenciaArrecadacaoInicial = avisoBancarioHelper.getAnoMesReferenciaArrecadacaoInicial();
			int anoMesReferenciaArrecadacaoFinal = avisoBancarioHelper.getAnoMesReferenciaArrecadacaoFinal();
			BigDecimal valorRealizadoInicial = avisoBancarioHelper.getValorRealizadoInicial();
			BigDecimal valorRealizadoFinal = avisoBancarioHelper.getValorRealizadoFinal();

			Integer idAviso = avisoBancarioHelper.getAvisoBancario().getId();
			String tipoAviso = avisoBancarioHelper.getTipoAviso();

			int flag = 0;
			BigDecimal valorSomatorioAcertoCredito = this.pesquisarSomatorioAvisoAcerto(1, idAviso, 1);
			BigDecimal valorSomatorioAcertoDebito = this.pesquisarSomatorioAvisoAcerto(2, idAviso, 1);

			BigDecimal valorSomatorioAcertoCredito2 = this.pesquisarSomatorioAvisoAcerto(1, idAviso, 2);
			BigDecimal valorSomatorioAcertoDebito2 = this.pesquisarSomatorioAvisoAcerto(2, idAviso, 2);
			if(valorSomatorioAcertoCredito == null){
				valorSomatorioAcertoCredito = new BigDecimal("0.00");
			}
			if(valorSomatorioAcertoDebito == null){
				valorSomatorioAcertoDebito = new BigDecimal("0.00");
			}

			if(valorSomatorioAcertoCredito2 == null){
				valorSomatorioAcertoCredito2 = new BigDecimal("0.00");
			}
			if(valorSomatorioAcertoDebito2 == null){
				valorSomatorioAcertoDebito2 = new BigDecimal("0.00");
			}

			if(arrecadadorCodAgente == null && (dataLancamentoInicio == null || dataLancamentoFim == null)
							&& (indicadorCreditoDebito == 0 || indicadorCreditoDebito == 3) && idContaBancaria == null
							&& idMovimento == null && (dataPrevisaoCreditoDebitoInicio == null || dataPrevisaoCreditoDebitoFim == null)
							&& (dataRealizacaoCreditoDebitoInicio == null || dataRealizacaoCreditoDebitoFim == null)
							&& (anoMesReferenciaArrecadacaoInicial == 0 || anoMesReferenciaArrecadacaoFinal == 0)
							&& (valorRealizadoInicial == null || valorRealizadoFinal == null) && tipoAviso.equalsIgnoreCase("1")){
				flag = 1;
				consulta = "select avisoBancario, " + " case when (" + " (avisoBancario.valorArrecadacaoCalculado = "
								+ " ((avisoBancario.valorArrecadacaoInformado + " + valorSomatorioAcertoCredito + " ) " + " - "
								+ valorSomatorioAcertoDebito + ")" + " ) " + " and " + "(avisoBancario.valorDevolucaoCalculado = "
								+ " ((avisoBancario.valorDevolucaoInformado + " + valorSomatorioAcertoCredito2 + " ) " + " - "
								+ valorSomatorioAcertoDebito2 + ")" + " )) then 'FECHADO' " + " else 'ABERTO' end "
								+ " from AvisoBancario avisoBancario ";

			}else{
				consulta = "select avisoBancario, " + " case when (" + " (avisoBancario.valorArrecadacaoCalculado = "
								+ " ((avisoBancario.valorArrecadacaoInformado + " + valorSomatorioAcertoCredito + " ) " + " - "
								+ valorSomatorioAcertoDebito + ")" + " ) " + " and " + "(avisoBancario.valorDevolucaoCalculado = "
								+ " ((avisoBancario.valorDevolucaoInformado + " + valorSomatorioAcertoCredito2 + " ) " + " - "
								+ valorSomatorioAcertoDebito2 + ")" + " )) then 'FECHADO' " + " else 'ABERTO' end "
								+ " from AvisoBancario avisoBancario " + " where ";
			}

			if(idAviso != null && !idAviso.equals(0)){
				consulta += " avisoBancario.id = " + idAviso + " and";
			}

			if(arrecadadorCodAgente != null){
				consulta += " avisoBancario.arrecadador.codigoAgente = " + arrecadadorCodAgente + " and";
			}

			if((dataLancamentoInicio != null) && (dataLancamentoFim != null)){
				consulta += " avisoBancario.dataLancamento between :dataLancamentoInicio  and " + ":dataLancamentoFim and";

			}

			if(indicadorCreditoDebito != 0 && indicadorCreditoDebito != 3){
				consulta += " avisoBancario.indicadorCreditoDebito = " + indicadorCreditoDebito + " and";
			}

			if(idContaBancaria != null){
				consulta += " avisoBancario.contaBancaria.id = " + idContaBancaria + " and";
			}

			if(idMovimento != null){
				consulta += " avisoBancario.arrecadadorMovimento.id = " + idMovimento + " and";
			}

			if((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)){
				consulta += " avisoBancario.dataPrevista between :dataPrevisaoCreditoDebitoInicio  and "
								+ ":dataPrevisaoCreditoDebitoFim and";

			}

			if((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null)){
				consulta += " avisoBancario.dataRealizada between :dataRealizacaoCreditoDebitoInicio  and "
								+ ":dataRealizacaoCreditoDebitoFim and";

			}

			if((anoMesReferenciaArrecadacaoInicial != 0) && (anoMesReferenciaArrecadacaoFinal != 0)){
				consulta += " avisoBancario.anoMesReferenciaArrecadacao between " + anoMesReferenciaArrecadacaoInicial + " and "
								+ anoMesReferenciaArrecadacaoFinal + " and";
			}

			if((valorRealizadoInicial != null) && (valorRealizadoFinal != null)){

				BigDecimal valorInicialNegativo = valorRealizadoFinal.multiply(new BigDecimal("-1.00"));
				BigDecimal valorFinalNegativo = valorRealizadoInicial.multiply(new BigDecimal("-1.00"));
				consulta += " ((avisoBancario.valorRealizado between " + valorInicialNegativo + " and " + valorFinalNegativo
								+ ") or (avisoBancario.valorRealizado between " + valorRealizadoInicial + " and " + valorRealizadoFinal
								+ "))" + " and";
			}

			// tipoAviso
			if(tipoAviso != null && !tipoAviso.equalsIgnoreCase("1")){
				if(tipoAviso.equalsIgnoreCase("3")){
					// FECHADO
					consulta += " ((avisoBancario.valorArrecadacaoCalculado = " + " ((avisoBancario.valorArrecadacaoInformado + "
									+ valorSomatorioAcertoCredito + " ) " + " - " + valorSomatorioAcertoDebito + ")" + " ) " + " and "
									+ "(avisoBancario.valorDevolucaoCalculado = " + " ((avisoBancario.valorDevolucaoInformado + "
									+ valorSomatorioAcertoCredito2 + " ) " + " - " + valorSomatorioAcertoDebito2 + ")" + " )) and ";
				}else if(tipoAviso.equalsIgnoreCase("2")){
					// ABERTO
					consulta += " ((avisoBancario.valorArrecadacaoCalculado <> " + " ((avisoBancario.valorArrecadacaoInformado + "
									+ valorSomatorioAcertoCredito + " ) " + " - " + valorSomatorioAcertoDebito + ")" + " ) " + " or "
									+ "(avisoBancario.valorDevolucaoCalculado <> " + " ((avisoBancario.valorDevolucaoInformado + "
									+ valorSomatorioAcertoCredito2 + " ) " + " - " + valorSomatorioAcertoDebito2 + ")" + " )) and ";
				}
			}
			String consultarComOrderBy = "";
			if(flag != 1){
				consultarComOrderBy = Util.formatarHQL(consulta, 4)
								+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
			}else{
				consultarComOrderBy = Util.formatarHQL(consulta, 0)
								+ " order by avisoBancario.arrecadador.id,avisoBancario.dataLancamento,avisoBancario.numeroSequencial";
			}

			if((((dataLancamentoInicio != null) && (dataLancamentoFim != null)) && ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.setDate("dataRealizacaoCreditoDebitoInicio", dataRealizacaoCreditoDebitoInicio).setDate(
												"dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).list();

			}else if(((dataLancamentoInicio != null) && (dataLancamentoFim != null))
							&& ((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataPrevisaoCreditoDebitoInicio",
								dataPrevisaoCreditoDebitoInicio).setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim)
								.list();

			}else if(((dataLancamentoInicio != null) && (dataLancamentoFim != null))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).setDate("dataRealizacaoCreditoDebitoInicio",
								dataRealizacaoCreditoDebitoInicio)
								.setDate("dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).list();

			}else if(((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null))
							&& ((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null))){

				return session.createQuery(consultarComOrderBy).setDate("dataPrevisaoCreditoDebitoInicio", dataPrevisaoCreditoDebitoInicio)
								.setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim).setDate(
												"dataRealizacaoCreditoDebitoInicio", dataRealizacaoCreditoDebitoInicio).setDate(
												"dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).list();

			}else if((dataLancamentoInicio != null) && (dataLancamentoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataLancamentoInicio", dataLancamentoInicio).setDate(
								"dataLancamentoFim", dataLancamentoFim).list();

			}else if((dataPrevisaoCreditoDebitoInicio != null) && (dataPrevisaoCreditoDebitoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataPrevisaoCreditoDebitoInicio", dataPrevisaoCreditoDebitoInicio)
								.setDate("dataPrevisaoCreditoDebitoFim", dataPrevisaoCreditoDebitoFim).list();

			}else if((dataRealizacaoCreditoDebitoInicio != null) && (dataRealizacaoCreditoDebitoFim != null)){

				return session.createQuery(consultarComOrderBy).setDate("dataRealizacaoCreditoDebitoInicio",
								dataRealizacaoCreditoDebitoInicio)
								.setDate("dataRealizacaoCreditoDebitoFim", dataRealizacaoCreditoDebitoFim).list();

			}else{
				return session.createQuery(consultarComOrderBy).list();
			}
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisa os dados da Guia de Pagamento necessários para o relatório
	 * através do id da Guia de Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 03/10/06
	 * @author eduardo henrique
	 * @date 14/08/2008
	 *       Alteração na Consulta para Considerar Prestações da Guia de Pagamento
	 * @param numeroPrestacoesGuiaPagamento
	 *            (Prestações da Guia que deverão ser Impressas)
	 * @return GuiaPagamentoRelatorioHelper
	 * @throws ErroRepositorioException
	 */

	public Collection<Object[]> pesquisarGuiaPagamentoRelatorio(Integer idGuiaPagamento, List numeroPrestacoesGuiaPagamento)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar o objeto pesquisada
		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append(" select imov.imov_id as idImovel, ");
			consulta.append("        gppr.gppr_dtvencimento as dataVencimentoPrestacao, ");
			consulta.append("        loca.loca_id as idLocalidade, ");
			consulta.append("        loca.loca_nmlocalidade as nomeLocalidade, ");
			consulta.append("        gppr.gppr_vlprestacao as valorPrestacao, ");
			consulta.append("        gppr.gppr_dtemissao as dataEmissaoPrestacao, ");
			consulta.append("        dbtp.dbtp_id as idDebitoTipo, ");
			consulta.append("        dbtp.dbtp_dsdebitotipo as descricaoDebitoTipo, ");
			consulta.append("        gppr.gppr_nnprestacao as numeroPrestacao, ");
			consulta.append("        gpag.gpag_nnprestacaototal as numeroPrestacaoTotal, ");
			consulta.append("        dotp.dotp_id as idDocumentoTipo, ");
			consulta.append("        dotp.dotp_dsdocumentotipo as descricaoDocumentoTipo, ");
			consulta.append("        '' as indicadorPrestacaoNoHistorico, ");
			consulta.append("        gppr.gppr_amreferenciafaturamento as anoMesReferenciaFaturamento, ");
			consulta.append("        gppr.gppr_iccobrancamulta as indicadorCobrancaMulta, ");
			consulta.append("        gpag.gpag_icemissaoobservacaora as indicadorEmissaoObservacaoRA, ");
			consulta.append("        ra.rgat_dsobservacao as descricaoObservacao, ");
			consulta.append("        gpag.gpag_nncontratoparcorgaopublic as nuContrParcelOrgaoPublico ");
			consulta.append(" from guia_pagamento gpag ");
			consulta.append(" inner join guia_pagamento_prestacao gppr on (gppr.gpag_id = gpag.gpag_id) ");
			consulta.append(" left join documento_tipo dotp on (dotp.dotp_id = gpag.dotp_id) ");
			consulta.append(" left join localidade loca on (loca.loca_id = gpag.loca_id) ");
			consulta.append(" left join imovel imov on (imov.imov_id = gpag.imov_id) ");
			consulta.append(" left join debito_tipo dbtp on (dbtp.dbtp_id = gppr.dbtp_id) ");
			consulta.append(" left join registro_atendimento ra on (ra.rgat_id = gpag.rgat_id) ");
			consulta.append(" where gpag.gpag_id = :idGuiaPagamento ");
			consulta.append("   and gppr.gppr_nnprestacao in (:numeroPrestacoes) ");

			consulta.append(" union all ");

			consulta.append(" select imov.imov_id as idImovel, ");
			consulta.append("        gpph.gpph_dtvencimento as dataVencimentoPrestacao, ");
			consulta.append("        loca.loca_id as idLocalidade, ");
			consulta.append("        loca.loca_nmlocalidade as nomeLocalidade, ");
			consulta.append("        gpph.gpph_vlprestacao as valorPrestacao, ");
			consulta.append("        gpph.gpph_dtemissao as dataEmissaoPrestacao, ");
			consulta.append("        dbtp.dbtp_id as idDebitoTipo, ");
			consulta.append("        dbtp.dbtp_dsdebitotipo as descricaoDebitoTipo, ");
			consulta.append("        gpph.gpph_nnprestacao as numeroPrestacao, ");
			consulta.append("        gpag.gpag_nnprestacaototal as numeroPrestacaoTotal, ");
			consulta.append("        dotp.dotp_id as idDocumentoTipo, ");
			consulta.append("        dotp.dotp_dsdocumentotipo as descricaoDocumentoTipo, ");
			consulta.append("        'S' as indicadorPrestacaoNoHistorico, ");
			consulta.append("        gpph.gpph_amreferenciafaturamento as anoMesReferenciaFaturamento, ");
			consulta.append("        gpph.gpph_iccobrancamulta as indicadorCobrancaMulta, ");
			consulta.append("        gpag.gpag_icemissaoobservacaora as indicadorEmissaoObservacaoRA, ");
			consulta.append("        ra.rgat_dsobservacao as descricaoObservacao, ");
			consulta.append("        gpag.gpag_nncontratoparcorgaopublic as nuContrParcelOrgaoPublico ");
			consulta.append(" from guia_pagamento gpag ");
			consulta.append(" inner join guia_pagamento_prestacao_hist gpph on (gpph.gpag_id = gpag.gpag_id) ");
			consulta.append(" left join documento_tipo dotp on (dotp.dotp_id = gpag.dotp_id) ");
			consulta.append(" left join localidade loca on (loca.loca_id = gpag.loca_id) ");
			consulta.append(" left join imovel imov on (imov.imov_id = gpag.imov_id) ");
			consulta.append(" left join debito_tipo dbtp on (dbtp.dbtp_id = gpph.dbtp_id) ");
			consulta.append(" left join registro_atendimento ra on (ra.rgat_id = gpag.rgat_id) ");
			consulta.append(" where gpag.gpag_id = :idGuiaPagamento ");
			consulta.append("   and gpph.gpph_nnprestacao in (:numeroPrestacoes) ");

			consulta.append(" union all ");

			consulta.append(" select imov.imov_id as idImovel, ");
			consulta.append("        gppr.gppr_dtvencimento as dataVencimentoPrestacao, ");
			consulta.append("        loca.loca_id as idLocalidade, ");
			consulta.append("        loca.loca_nmlocalidade as nomeLocalidade, ");
			consulta.append("        gppr.gppr_vlprestacao as valorPrestacao, ");
			consulta.append("        gppr.gppr_dtemissao, ");
			consulta.append("        dbtp.dbtp_id as idDebitoTipo, ");
			consulta.append("        dbtp.dbtp_dsdebitotipo as descricaoDebitoTipo, ");
			consulta.append("        gppr.gppr_nnprestacao as numeroPrestacao, ");
			consulta.append("        gphi.gphi_nnprestacaototal as numeroPrestacaoTotal, ");
			consulta.append("        dotp.dotp_id as idDocumentoTipo, ");
			consulta.append("        dotp.dotp_dsdocumentotipo as descricaoDocumentoTipo, ");
			consulta.append("        '' as indicadorPrestacaoNoHistorico, ");
			consulta.append("        gppr.gppr_amreferenciafaturamento as anoMesReferenciaFaturamento, ");
			consulta.append("        gppr.gppr_iccobrancamulta as indicadorCobrancaMulta, ");
			consulta.append("        gphi.gphi_icemissaoobservacaora as indicadorEmissaoObservacaoRA, ");
			consulta.append("        ra.rgat_dsobservacao as descricaoObservacao, ");
			consulta.append("        gphi.gphi_nncontratoparcorgaopublic as nuContrParcelOrgaoPublico ");
			consulta.append(" from guia_pagamento_historico gphi ");
			consulta.append(" inner join guia_pagamento_prestacao gppr on (gppr.gpag_id = gphi.gpag_id) ");
			consulta.append(" left join documento_tipo dotp on (dotp.dotp_id = gphi.dotp_id) ");
			consulta.append(" left join localidade loca on (loca.loca_id = gphi.loca_id) ");
			consulta.append(" left join imovel imov on (imov.imov_id = gphi.imov_id) ");
			consulta.append(" left join debito_tipo dbtp on (dbtp.dbtp_id = gppr.dbtp_id) ");
			consulta.append(" left join registro_atendimento ra on (ra.rgat_id = gphi.rgat_id) ");
			consulta.append(" where gphi.gpag_id = :idGuiaPagamento ");
			consulta.append("   and gppr.gppr_nnprestacao in (:numeroPrestacoes) ");

			consulta.append(" union all ");

			consulta.append(" select imov.imov_id as idImovel, ");
			consulta.append("        gpph.gpph_dtvencimento as dataVencimentoPrestacao, ");
			consulta.append("        loca.loca_id as idLocalidade, ");
			consulta.append("        loca.loca_nmlocalidade as nomeLocalidade, ");
			consulta.append("        gpph.gpph_vlprestacao as valorPrestacao, ");
			consulta.append("        gpph.gpph_dtemissao as dataEmissaoPrestacao, ");
			consulta.append("        dbtp.dbtp_id as idDebitoTipo, ");
			consulta.append("        dbtp.dbtp_dsdebitotipo as descricaoDebitoTipo, ");
			consulta.append("        gpph.gpph_nnprestacao as numeroPrestacao, ");
			consulta.append("        gphi.gphi_nnprestacaototal as numeroPrestacaoTotal, ");
			consulta.append("        dotp.dotp_id as idDocumentoTipo, ");
			consulta.append("        dotp.dotp_dsdocumentotipo as descricaoDocumentoTipo, ");
			consulta.append("        'S' as indicadorPrestacaoNoHistorico, ");
			consulta.append("        gpph.gpph_amreferenciafaturamento as anoMesReferenciaFaturamento, ");
			consulta.append("        gpph.gpph_iccobrancamulta as indicadorCobrancaMulta, ");
			consulta.append("        gphi.gphi_icemissaoobservacaora as indicadorEmissaoObservacaoRA, ");
			consulta.append("        ra.rgat_dsobservacao as descricaoObservacao, ");
			consulta.append("        gphi.gphi_nncontratoparcorgaopublic as nuContrParcelOrgaoPublico ");
			consulta.append(" from guia_pagamento_historico gphi ");
			consulta.append(" inner join guia_pagamento_prestacao_hist gpph on (gpph.gpag_id = gphi.gpag_id) ");
			consulta.append(" left join documento_tipo dotp on (dotp.dotp_id = gphi.dotp_id) ");
			consulta.append(" left join localidade loca on (loca.loca_id = gphi.loca_id) ");
			consulta.append(" left join imovel imov on (imov.imov_id = gphi.imov_id) ");
			consulta.append(" left join debito_tipo dbtp on (dbtp.dbtp_id = gpph.dbtp_id) ");
			consulta.append(" left join registro_atendimento ra on (ra.rgat_id = gphi.rgat_id) ");
			consulta.append(" where gphi.gpag_id = :idGuiaPagamento ");
			consulta.append("   and gpph.gpph_nnprestacao in (:numeroPrestacoes) ");
			consulta.append(" order by numeroPrestacao ");

			SQLQuery sql = session.createSQLQuery(consulta.toString());

			sql.addScalar("idImovel", Hibernate.INTEGER);
			sql.addScalar("dataVencimentoPrestacao", Hibernate.DATE);
			sql.addScalar("idLocalidade", Hibernate.INTEGER);
			sql.addScalar("nomeLocalidade", Hibernate.STRING);
			sql.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL);
			sql.addScalar("dataEmissaoPrestacao", Hibernate.DATE);
			sql.addScalar("idDebitoTipo", Hibernate.INTEGER);
			sql.addScalar("descricaoDebitoTipo", Hibernate.STRING);
			sql.addScalar("numeroPrestacao", Hibernate.SHORT);
			sql.addScalar("numeroPrestacaoTotal", Hibernate.SHORT);
			sql.addScalar("idDocumentoTipo", Hibernate.INTEGER);
			sql.addScalar("descricaoDocumentoTipo", Hibernate.STRING);
			sql.addScalar("indicadorPrestacaoNoHistorico", Hibernate.STRING);
			sql.addScalar("anoMesReferenciaFaturamento", Hibernate.INTEGER);
			sql.addScalar("indicadorCobrancaMulta", Hibernate.SHORT);
			sql.addScalar("indicadorEmissaoObservacaoRA", Hibernate.SHORT);
			sql.addScalar("descricaoObservacao", Hibernate.STRING);
			sql.addScalar("nuContrParcelOrgaoPublico", Hibernate.INTEGER);

			sql.setInteger("idGuiaPagamento", idGuiaPagamento);
			sql.setParameterList("numeroPrestacoes", numeroPrestacoesGuiaPagamento);

			retorno = sql.list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa o nome do cliente da guia de pagamento através do id da Guia de
	 * Pagamento e com CRTP_ID com o valor correspondente a usuário(2)
	 * 
	 * @author Vivianne Sousa
	 * @date 04/10/06
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public String pesquisarNomeClienteGuiaPagamentoRelatorio(Integer idGuiaPagamento) throws ErroRepositorioException{

		// cria a variável que vai armazenar o objeto pesquisada
		String retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select cli.nome " + "from ClienteGuiaPagamento cgp " + "inner join cgp.cliente cli "
							+ "inner join cgp.clienteRelacaoTipo crtp " + "inner join cgp.guiaPagamento guia "
							+ "where  crtp.id = 2 and guia.id =:idGuiaPagamento ";

			retorno = (String) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento.intValue()).setMaxResults(1)
							.uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados da Guia de Devolução necessários para o relatório
	 * através do id da Guia de Devolução
	 * 
	 * @author Ana Maria
	 * @date 05/10/06
	 * @return GuiaDevolucaoRelatorioHelper
	 * @throws ErroRepositorioException
	 */

	public GuiaDevolucaoRelatorioHelper pesquisarGuiaDevolucaoRelatorio(Integer idGuiaDevolucao) throws ErroRepositorioException{

		// cria a variável que vai armazenar o objeto pesquisada
		GuiaDevolucaoRelatorioHelper retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{

			String consulta = "select " + " new " + GuiaDevolucaoRelatorioHelper.class.getName() + " ( " + "gdev.id, gdev.valorDevolucao, "
							+ "rgat.id, rgat.observacao, gdev.imovel.id, " + "clie.id, clie.nome, clie.cpf, clie.cnpj, clie.rg, "
							+ "orrg.descricaoAbreviada, unfe.sigla, fuan.nome, " + "fuau.nome, usua.nomeUsuario, gdev.dataValidade) "
							+ "from GuiaDevolucao gdev " + "left join gdev.cliente clie " + "left join clie.orgaoExpedidorRg orrg "
							+ "left join clie.unidadeFederacao unfe " + "left join gdev.registroAtendimento rgat "
							+ "left join gdev.funcionarioAnalista fuan " + "left join gdev.funcionarioAutorizador fuau "
							+ "left join gdev.usuario usua " + "where gdev.id =:idGuiaDevolucao ";

			retorno = (GuiaDevolucaoRelatorioHelper) session.createQuery(consulta)
							.setInteger("idGuiaDevolucao", idGuiaDevolucao.intValue()).setMaxResults(1).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa os dados do Cliente pelo Imóvel
	 * 
	 * @author Ana Maria
	 * @date 06/10/06
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarClienteImovel(Integer idImovel) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = "select clie.nome, clie.cpf, clie.cnpj, clie.rg, " + "orrg.descricaoAbreviada, unfe.sigla "
							+ "from ClienteImovel clim " + "inner join clim.cliente clie " + "left join clie.orgaoExpedidorRg orrg "
							+ "left join clie.unidadeFederacao unfe "
							+ "where clim.clienteRelacaoTipo.id = 2 and clim.imovel.id =:idImovel and clim.dataFimRelacao is null ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para pesquisar os pagamento historicos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos historicos do Imóvel
	 * 
	 * @author Rafael Corrêa
	 * @date 20/12/2006
	 * @author Saulo Lima
	 * @date 15/01/2009
	 *       Adicionar o LEFT JOIN com GuiaPagamentoPrestacao e DebitoTipo
	 * @param FiltroPagamento
	 * @return Collection<pagamentoHistorico>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoImovel(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = new HashSet<PagamentoHistorico>();

		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, null);

			hql = "SELECT DISTINCT pagamentoHistorico " 
							+ "FROM gcom.arrecadacao.pagamento.PagamentoHistorico  pagamentoHistorico "
							+ "LEFT JOIN FETCH pagamentoHistorico.avisoBancario avbc " 
							+ "LEFT JOIN FETCH avbc.arrecadador arrec "
							+ "LEFT outer JOIN FETCH pagamentoHistorico.cliente " 
							+ "LEFT JOIN FETCH arrec.cliente clie "
							+ "LEFT JOIN FETCH pagamentoHistorico.documentoTipo doctoTp "
							+ "LEFT JOIN FETCH pagamentoHistorico.conta conta "
							+ "LEFT JOIN FETCH pagamentoHistorico.guiaPagamentoGeral gpagGeral "
							+ "LEFT JOIN FETCH gpagGeral.guiaPagamento gpag "
							+ "LEFT JOIN FETCH gpag.guiasPagamentoPrestacao gPagPrestacao "
							+ "LEFT JOIN FETCH gPagPrestacao.debitoTipo debitoTipo "
							+ "LEFT JOIN FETCH gpag.guiasPagamentoPrestacaoHistorico gPagPrestacaoHistorico "
							+ "LEFT JOIN FETCH gpagGeral.guiaPagamentoHistorico gpagHistorico "
							+ "LEFT JOIN FETCH gpagHistorico.guiasPagamentoPrestacaoHistorico gPagHistoricoPrestacaoHistorico "
							+ "LEFT JOIN FETCH pagamentoHistorico.debitoACobrar dbcb " + "LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
							+ "LEFT JOIN pagamentoHistorico.imovel imovel " + "LEFT JOIN imovel.imovelSubcategorias imsb "
							+ "LEFT JOIN FETCH pagamentoHistorico.debitoTipo dbtp "
							+ "LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
							+ "LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ "LEFT JOIN FETCH pagamentoHistorico.localidade localidade "
							+ "LEFT JOIN FETCH localidade.gerenciaRegional gerReg "
							+ "LEFT JOIN FETCH pagamentoHistorico.avisoBancario avisoBancario "
							+ "LEFT JOIN FETCH avisoBancario.contaBancaria contaBancaria "
							+ "LEFT JOIN FETCH contaBancaria.agencia agencia " + "LEFT JOIN FETCH agencia.banco banco "
							+ "LEFT JOIN imovel.setorComercial stcm " + "LEFT JOIN FETCH pagamentoHistorico.debitoTipo dbtTipo "
							+ condicionais + " ORDER BY pagamentoHistorico.localidade.id, pagamentoHistorico.imovel.id, "
							+ "          pagamentoHistorico.anoMesReferenciaPagamento, pagamentoHistorico.dataPagamento";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno.addAll(session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list());
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno.addAll(session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list());
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno.addAll(session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list());
			}else{
				retorno.addAll(session.createQuery(hql).list());
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que pesquisa os pagamentos histórico para tela de consulta de Imóvel
	 * 
	 * @author Saulo Lima
	 * @date 09/02/2009
	 * @param idImovel
	 * @return Collection<PagamentoHistorico>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoConsultaImovel(Integer idImovel) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = null;

		String hql = "";
		Session session = HibernateUtil.getSession();

		try{

			hql = "SELECT DISTINCT pagamentoHistorico " + "FROM gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
							+ "LEFT JOIN FETCH pagamentoHistorico.avisoBancario avbc " + "LEFT JOIN FETCH avbc.arrecadador arrec "
							+ "LEFT JOIN FETCH arrec.cliente clie " + "LEFT JOIN FETCH pagamentoHistorico.debitoTipo dbtp "
							+ "LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
							+ "LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ "WHERE pagamentoHistorico.imovel.id = " + idImovel + " "
							+ "ORDER BY pagamentoHistorico.localidade.id, pagamentoHistorico.imovel.id, "
							+ "pagamentoHistorico.anoMesReferenciaPagamento, pagamentoHistorico.dataPagamento";

			retorno = session.createQuery(hql).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Filtar a quantiade de pagamento historicos do imovel [UC0255] Filtrar
	 * Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoHistoricoImovelCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ErroRepositorioException{

		int retorno = 0;
		Object pagamentoHistoricoImovelCount;

		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, null, idsArrecadadores, idsCategoria);

			hql = " select count(pagamentoHistorico.id) " + " from gcom.arrecadacao.pagamento.PagamentoHistorico  pagamentoHistorico "
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN imov.imovelSubcategorias imsb " + condicionais + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoHistoricoImovelCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoHistoricoImovelCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setMaxResults(1).uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoHistoricoImovelCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal)
								.setMaxResults(1).uniqueResult();
			}else{
				pagamentoHistoricoImovelCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			if(pagamentoHistoricoImovelCount != null){
				retorno = ((Number) pagamentoHistoricoImovelCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os pagamento historicos do Imovel para paginação
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoImovelParaPaginacao(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = new ArrayList();

		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{

			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT distinct pagamentoHistorico " 
							+ " FROM gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
							+ " LEFT JOIN FETCH pagamentoHistorico.conta " 
							+ " LEFT JOIN FETCH pagamentoHistorico.documentoTipo "
							+ " LEFT JOIN FETCH pagamentoHistorico.debitoTipo "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior "
							+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamentoGeral guiaPagamentoGeral "
							+ " LEFT JOIN FETCH pagamentoHistorico.avisoBancario avisoBancario "
							+ " LEFT JOIN FETCH avisoBancario.arrecadador arrecadador "
							+ " LEFT JOIN FETCH guiaPagamentoGeral.guiaPagamento guiaPagamento "
							+ " LEFT JOIN FETCH pagamentoHistorico.debitoACobrar debitoACobrar "
							+ " LEFT JOIN FETCH guiaPagamento.guiasPagamentoPrestacao guiaPagamentoPrestacao"
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + " LEFT JOIN FETCH guiaPagamentoPrestacao.debitoTipo "
							+ " LEFT JOIN FETCH debitoACobrar.debitoTipo " + condicionais
							+ " order by pagamentoHistorico.dataPagamento DESC";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

			// Solucao para evitar erro do setMaxResult
			List lista = (List) retorno;

			int posicaoInicial = 10 * numeroPagina;
			int posicaoFinal = 10 * numeroPagina + 10;

			retorno = lista.subList(posicaoInicial, (posicaoFinal > lista.size() ? lista.size() : posicaoFinal));

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Filtra os Pagamento Historicos do Cliente Conta
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 20/12/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoClienteConta(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistoricoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = " select c.pghi_id as idPagamento, i.cnta_id as idConta, i.cnhi_amreferenciaconta as anoMesConta, i.cnhi_vlagua as valorAguaConta, "
							+ " i.cnhi_vlesgoto as valorEsgotoConta, i.cnhi_vldebitos as valorDebitosConta, i.cnhi_vlcreditos as valorCreditosConta, "
							+ " c.pghi_dtpagamento as dataPagamento, c.pghi_amreferenciapagamento as anoMesPagamento, "
							+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " k.pgst_id as idSituacaoPagamentoAnterior, k.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, c.imov_id as idImovel, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento_historico c "
							+ " INNER JOIN conta_historico i on i.imov_id = c.imov_id and i.cnhi_amreferenciaconta = c.pghi_amreferenciapagamento "
							+ " INNER JOIN cliente_conta_historico b on b.cnta_id = i.cnta_id "
							+ " LEFT JOIN aviso_bancario f on f.avbc_id = c.avbc_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT OUTER JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " INNER JOIN  cliente a on a.clie_id = b.clie_id ";
			// + " INNER JOIN "
			// + " cadastro.localidade d "
			// + " on c.loca_id = d.loca_id "

			hql = hql
							// + " INNER JOIN "
							// + " arrecadacao.arrecadador g "
							// + " on f.arrc_id = g.arrc_id "
							// + " INNER JOIN "
							// + " cadastro.cliente h "
							// + " on h.clie_id = g.clie_id "
							+ " LEFT OUTER JOIN " + " pagamento_situacao j " + "  on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao k on c.pgst_idanterior = k.pgst_id "
							// + " LEFT OUTER JOIN "
							// + " faturamento.debito_tipo m "
							// + " on c.dbtp_id = m.dbtp_id "
							+ " WHERE " + condicionais
							+ " order by c.loca_id, c.imov_id, c.pghi_amreferenciapagamento, c.pghi_dtpagamento ";

			// colecaoPagamento = session.createQuery(hql).list();

			retorno = session.createSQLQuery(hql).addScalar("idPagamento", Hibernate.INTEGER).addScalar("idConta", Hibernate.INTEGER)
							.addScalar("anoMesConta", Hibernate.INTEGER).addScalar("valorAguaConta", Hibernate.BIG_DECIMAL).addScalar(
											"valorEsgotoConta", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitosConta", Hibernate.BIG_DECIMAL).addScalar("valorCreditosConta", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE).addScalar("anoMesPagamento", Hibernate.INTEGER).addScalar(
											"valorPagamento", Hibernate.BIG_DECIMAL).addScalar("idSituacaoPagamentoAtual",
											Hibernate.INTEGER).addScalar("situacaoPagamentoAtual", Hibernate.STRING).addScalar(
											"idSituacaoPagamentoAnterior", Hibernate.INTEGER).addScalar("situacaoPagamentoAnterior",
											Hibernate.STRING).addScalar("idDocumentoTipo", Hibernate.INTEGER).
											addScalar("idImovel", Hibernate.INTEGER).addScalar("avisoBancario", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtrar os pagamentos historicos do Cliente Guia Pagamento
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 06/10/06
	 * @author Virgínia Melo
	 * @date 30/03/2009
	 *       Correção na consulta para nova estrutura da guia.
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarPagamentoHistoricoClienteGuiaPagamento(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Object[]> retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 2. O sistema seleciona os pagamentos de guia de pagamento do cliente informado (a
			// partir da tabela
			// PAGAMENTO com CLIE_ID = Id do cliente informado ou com GPAG_ID = GPAG_ID da tabela
			// CLIENTE_GUIA_PAGAMENTO
			// com CLIE_ID = Id do cliente informado e CRTP_ID correspondente a um dos Tipos de
			// Relação do Cliente
			// com o Imóvel, caso selecionados e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistoricoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = " SELECT c.pghi_id as idPagamento, gPagGeral.gpag_id as idGuiaPagamento, c.clie_id as idCliente,  "
							+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento,  "
							+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
							+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
							+ " c.imov_id as idImovel, c.loca_id as idLocalidade , c.pghi_nnprestacao as numeroPrestacao, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento_historico c "
							+ " INNER JOIN guia_pagamento_geral gPagGeral  on c.gpag_id = gPagGeral.gpag_id "
							+ " INNER JOIN cliente_guia_pagamento b on gPagGeral.gpag_id = b.gpag_id "
							+ " INNER JOIN cliente a on a.clie_id = b.clie_id " 
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id " 
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT OUTER JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id " 
							+ " WHERE "
							+ condicionais
							+ " union "
							+ " SELECT c.pghi_id as idPagamento, gPagGeral.gpag_id as idGuiaPagamento, c.clie_id as idCliente,  "
							+ " c.pghi_dtpagamento as dataPagamento,  c.pghi_amreferenciapagamento as anoMesPagamento,  "
							+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, "
							+ " c.pghi_vlpagamento as valorPagamento, j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, "
							+ " l.pgst_id as idSituacaoPagamentoAnterior, l.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, "
							+ " c.imov_id as idImovel, c.loca_id as idLocalidade, c.pghi_nnprestacao as numeroPrestacao, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento_historico c "
							+ " INNER JOIN cliente a on a.clie_id = c.clie_id "
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id "
							+ " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " LEFT OUTER JOIN guia_pagamento_geral gPagGeral  on c.gpag_id = gPagGeral.gpag_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT OUTER JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id " + " WHERE ";

			String condicionaisClientePagamento = this.criarCondicionaisPagamentoHistoricoCliente(idImovel, idCliente, null,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = hql + condicionaisClientePagamento + " order by idLocalidade, idImovel, idTipoDebitoPagamento, dataPagamento ";

			retorno = session.createSQLQuery(hql).addScalar("idPagamento", Hibernate.INTEGER).addScalar("idGuiaPagamento",
							Hibernate.INTEGER).addScalar("idCliente", Hibernate.INTEGER).addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("anoMesPagamento", Hibernate.INTEGER).addScalar("idTipoDebitoPagamento", Hibernate.INTEGER)
							.addScalar("tipoDebitoPagamento", Hibernate.STRING).addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER).addScalar("situacaoPagamentoAtual", Hibernate.STRING)
							.addScalar("idSituacaoPagamentoAnterior", Hibernate.INTEGER).addScalar("situacaoPagamentoAnterior",
											Hibernate.STRING).addScalar("idDocumentoTipo", Hibernate.INTEGER).addScalar("idImovel",
											Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER).addScalar("numeroPrestacao",
											Hibernate.INTEGER).addScalar("avisoBancario", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os pagamentos historicos do debito a cobrar
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 12/06/06,06/10/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoClienteDebitoACobrar(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection retorno = new ArrayList();
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			String condicionais = this.criarCondicionaisPagamentoHistoricoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " SELECT c.pghi_id as idPagamento, c.imov_id as idImovel, c.dbac_id as idDebitoACobrar, "
							+ " b1.dbac_vldebito as valorDebito, b1.dbac_nnprestacaocobradas as numeroPrestacaoCobradas, "
							+ " b1.dbac_nnprestacaodebito as numeroPrestacaoDebito,  c.pghi_dtpagamento as dataPagamento, "
							+ " c.pghi_amreferenciapagamento as anoMesPagamento, k.dbtp_id as idTipoDebitoDebito, k.dbtp_dsdebitotipo as tipoDebitoDebito, "
							+ " m.dbtp_id as idTipoDebitoPagamento, m.dbtp_dsdebitotipo as tipoDebitoPagamento, c.pghi_vlpagamento as valorPagamento, "
							+ " j.pgst_id as idSituacaoPagamentoAtual, j.pgst_dsabreviado as situacaoPagamentoAtual, j.pgst_id as idSituacaoPagamentoAnterior, "
							+ " j.pgst_dsabreviado as situacaoPagamentoAnterior, c.dotp_id as idDocumentoTipo, b1.imov_id as idImovelDebito, c.loca_id as idLocalidade, "
							+ " f.avbc_id as avisoBancario "
							+ " FROM pagamento_historico c " + " INNER JOIN debito_a_cobrar b1 on b1.dbac_id = c.dbac_id "
							+ " INNER JOIN cliente_imovel b on b.imov_id = b1.imov_id " + " INNER JOIN cliente a on a.clie_id = b.clie_id "
							+ " INNER JOIN localidade d on c.loca_id = d.loca_id "
							+ " INNER JOIN aviso_bancario f on c.avbc_id = f.avbc_id "
							+ " INNER JOIN arrecadador g on f.arrc_id = g.arrc_id " + " INNER JOIN cliente h on h.clie_id = g.clie_id "
							+ " INNER JOIN debito_tipo k on b1.dbtp_id = k.dbtp_id "
							+ " LEFT OUTER JOIN pagamento_situacao j on c.pgst_idatual = j.pgst_id "
							+ " LEFT OUTER JOIN pagamento_situacao l on c.pgst_idanterior = l.pgst_id "
							+ " LEFT JOIN imovel imov on imov.imov_id = c.imov_id "
							+ " LEFT JOIN imovel_subcategoria imsb on (imov.imov_id = imsb.imov_id) "
							+ " LEFT JOIN setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
							+ " LEFT OUTER JOIN debito_tipo m on c.dbtp_id = m.dbtp_id " + " WHERE " + condicionais
							+ " order by idLocalidade, idImovel, idTipoDebitoPagamento, dataPagamento ";

			retorno = session.createSQLQuery(hql).addScalar("idPagamento", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idDebitoACobrar", Hibernate.INTEGER).addScalar("valorDebito", Hibernate.BIG_DECIMAL).addScalar(
											"numeroPrestacaoCobradas", Hibernate.SHORT).addScalar("numeroPrestacaoDebito", Hibernate.SHORT)
							.addScalar("dataPagamento", Hibernate.DATE).addScalar("anoMesPagamento", Hibernate.INTEGER).addScalar(
											"idTipoDebitoDebito", Hibernate.INTEGER).addScalar("tipoDebitoDebito", Hibernate.STRING)
							.addScalar("idTipoDebitoPagamento", Hibernate.INTEGER).addScalar("tipoDebitoPagamento", Hibernate.STRING)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("idSituacaoPagamentoAtual", Hibernate.INTEGER)
							.addScalar("situacaoPagamentoAtual", Hibernate.STRING).addScalar("idSituacaoPagamentoAnterior",
											Hibernate.INTEGER).addScalar("situacaoPagamentoAnterior", Hibernate.STRING).addScalar(
											"idDocumentoTipo", Hibernate.INTEGER).addScalar("idImovelDebito", Hibernate.INTEGER).addScalar(
											"idLocalidade", Hibernate.INTEGER).addScalar("avisoBancario", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtrar a quantidade de pagamento historicos do cliente
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Santos
	 * @date 06/10/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoClienteCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ErroRepositorioException{

		int retorno = 0;
		Object pagamentoHistoricoClienteCount;
		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, null, idsArrecadadores, idsCategoria);

			hql = " select count (pagamentoHistorico.id) " + " from gcom.arrecadacao.pagamento.PagamentoHistorico  pagamentoHistorico "
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + " inner join pagamentoHistorico.cliente  cliente " + condicionais
							+ " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoHistoricoClienteCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoHistoricoClienteCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setMaxResults(1).uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoHistoricoClienteCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal)
								.setMaxResults(1).uniqueResult();
			}else{
				pagamentoHistoricoClienteCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			// Alteração na conversão do retorno da query, pois a query retorna um Long.
			if(pagamentoHistoricoClienteCount != null){
				retorno = ((Number) pagamentoHistoricoClienteCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os pagamento historicos do cliente
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 21/08/06,06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoCliente(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = new ArrayList();

		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = " select distinct pagamentoHistorico " + " from gcom.arrecadacao.pagamento.PagamentoHistorico  pagamentoHistorico "
							+ " inner join pagamentoHistorico.cliente  cliente " + " LEFT JOIN FETCH pagamentoHistorico.conta "
							+ " LEFT JOIN FETCH pagamentoHistorico.documentoTipo " + " LEFT JOIN FETCH pagamentoHistorico.debitoTipo "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior "
							+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamentoGeral guiaPagamentoGeral "
							+ " LEFT JOIN FETCH guiaPagamentoGeral.guiaPagamento guiaPagamento "
							+ " LEFT JOIN FETCH guiaPagamento.guiasPagamentoPrestacao guiaPagamentoPrestacao "
							+ " LEFT JOIN FETCH guiaPagamentoPrestacao.debitoTipo "
							+ " LEFT JOIN FETCH pagamentoHistorico.avisoBancario avisoBancario "
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + " LEFT JOIN FETCH avisoBancario.arrecadador " + condicionais
							+ " order by pagamentoHistorico.dataPagamento DESC";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

			// Solucao para evitar erro do setMaxResult
			List lista = (List) retorno;

			int posicaoInicial = 10 * numeroPagina;
			int posicaoFinal = 10 * numeroPagina + 10;

			retorno = lista.subList(posicaoInicial, (posicaoFinal > lista.size() ? lista.size() : posicaoFinal));

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra a quantiadade dos Pagamento Historicos da Localidade
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoHistoricoLocalidadeCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ErroRepositorioException{

		int retorno = 0;
		Object pagamentoHistoricoLocalidadeCount;

		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente
			// informado (a partir da tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com
			// CLIE_ID = Id do cliente informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com
			// o Imóvel, caso selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, null, idsArrecadadores, idsCategoria);

			hql = " select count(pagamentoHistorico.id) " + " from gcom.arrecadacao.pagamento.PagamentoHistorico  pagamentoHistorico "
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + condicionais + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoHistoricoLocalidadeCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoHistoricoLocalidadeCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setMaxResults(1).uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoHistoricoLocalidadeCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal)
								.setMaxResults(1).uniqueResult();
			}else{
				pagamentoHistoricoLocalidadeCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			if(pagamentoHistoricoLocalidadeCount != null){
				retorno = ((Number) pagamentoHistoricoLocalidadeCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os Pagamento Historicos da Localidade
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @author Saulo Lima
	 * @date 24/08/2009
	 *       Correção no HQL
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoLocalidade(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = null;
		Session session = HibernateUtil.getSession();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		try{
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			// 3. O sistema seleciona os pagamentos de débito a cobrar do cliente informado (a
			// partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com IMOV_ID = IMOV_ID da
			// tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID com valor
			// correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e demais parâmetros de
			// seleção informados)

			String hql = "SELECT DISTINCT pagamentoHistorico " 
							+ "FROM PagamentoHistorico pagamentoHistorico "
							+ "INNER JOIN FETCH pagamentoHistorico.avisoBancario avbc " 
							+ "INNER JOIN FETCH avbc.arrecadador arrec "
							+ "INNER JOIN FETCH arrec.cliente cliArrec " 
							+ "INNER JOIN FETCH pagamentoHistorico.documentoTipo doctoTp "
							+ "LEFT JOIN FETCH pagamentoHistorico.conta conta " + "LEFT JOIN pagamentoHistorico.imovel imov "
							+ "LEFT JOIN imov.localidade locImov " + "LEFT JOIN imov.setorComercial setComImov "
							+ "LEFT JOIN imov.quadra quadra " + "LEFT JOIN imov.imovelSubcategorias imsb "
							+ "LEFT JOIN FETCH pagamentoHistorico.localidade loc " + "LEFT JOIN FETCH loc.gerenciaRegional gr "
							+ "LEFT JOIN FETCH pagamentoHistorico.guiaPagamentoGeral gpag "
							+ "LEFT JOIN FETCH pagamentoHistorico.debitoACobrar dbcb " + "LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
							+ "LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
							+ "LEFT JOIN imov.setorComercial stcm "
							+ "LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior " + condicionais
							+ " order by pagamentoHistorico.dataPagamento DESC";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

			// Solucao para evitar erro do setMaxResult
			List lista = (List) retorno;

			int posicaoInicial = 10 * numeroPagina;
			int posicaoFinal = 10 * numeroPagina + 10;

			retorno = lista.subList(posicaoInicial, (posicaoFinal > lista.size() ? lista.size() : posicaoFinal));

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Filtra oas pagamento historicos do Aviso Bancario
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @author eduardo henrique
	 * @date 17/12/2008
	 *       Correção no método para retirada do Join de GuiaPagamento com DebitoTipo
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoAvisoBancario(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamentoHistorico " 
							+ " from gcom.arrecadacao.pagamento.PagamentoHistorico  pagamentoHistorico "
							+ " INNER JOIN FETCH pagamentoHistorico.avisoBancario  avisoBancario "
							+ " INNER JOIN FETCH avisoBancario.arrecadador arrec"
							+ " LEFT JOIN FETCH pagamentoHistorico.conta conta " 
							+ " LEFT JOIN FETCH pagamentoHistorico.documentoTipo docTip "
							+ " LEFT outer JOIN FETCH pagamentoHistorico.cliente"
							+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamentoGeral gpagGeral "
							+ " LEFT JOIN FETCH gpagGeral.guiaPagamentoHistorico gpag "
							+ " LEFT JOIN FETCH pagamentoHistorico.debitoACobrar dbcb "
							+ " LEFT JOIN FETCH gpag.guiasPagamentoPrestacaoHistorico gpagGpph "
							+ " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior " + condicionais + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra a quantidade de pagamento historicos do avio bancario
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoAvisoBancarioCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ErroRepositorioException{

		int retorno = 0;
		Object pagamentoHistoricoAvisoBancarioCount;

		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, null, idsArrecadadores, idsCategoria);

			hql = " select count (pagamentoHistorico.id) " + " from gcom.arrecadacao.pagamento.PagamentoHistorico  pagamentoHistorico "
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + " inner join pagamentoHistorico.avisoBancario  avisoBancario "
							+ condicionais + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				pagamentoHistoricoAvisoBancarioCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setTimestamp("dataPagamentoFinal", dataPagamentoFinal).setMaxResults(1).uniqueResult();
			}else if(possuiDataInicial && !possuiDataFinal){
				pagamentoHistoricoAvisoBancarioCount = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial)
								.setMaxResults(1).uniqueResult();
			}else if(!possuiDataInicial && possuiDataFinal){
				pagamentoHistoricoAvisoBancarioCount = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal)
								.setMaxResults(1).uniqueResult();
			}else{
				pagamentoHistoricoAvisoBancarioCount = session.createQuery(hql).setMaxResults(1).uniqueResult();
			}

			if(pagamentoHistoricoAvisoBancarioCount != null){
				retorno = ((Number) pagamentoHistoricoAvisoBancarioCount).intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Filtra os pagamento historicos do aviso bancario para paginação
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<PagamentoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoAvisoBancarioParaPaginacao(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = new ArrayList();
		String hql = "";
		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;
		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT DISTINCT pagamentoHistorico " 
							+ " FROM gcom.arrecadacao.pagamento.PagamentoHistorico pagamentoHistorico "
							+ " INNER JOIN FETCH pagamentoHistorico.avisoBancario avisoBancario "
							+ " LEFT JOIN FETCH avisoBancario.arrecadador "
							+ " LEFT JOIN FETCH pagamentoHistorico.conta " 
							+ " LEFT JOIN FETCH pagamentoHistorico.cliente "
							+ " LEFT JOIN FETCH pagamentoHistorico.documentoTipo " 
							+ " LEFT JOIN FETCH pagamentoHistorico.debitoTipo "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior "
							+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamentoGeral guiaPagamentoGeral "
							+ " LEFT JOIN FETCH guiaPagamentoGeral.guiaPagamento guiaPagamento "
							+ " LEFT JOIN FETCH guiaPagamento.guiasPagamentoPrestacao guiaPagamentoPrestacao "
							+ " LEFT JOIN FETCH guiaPagamentoPrestacao.debitoTipo " 
							+ " LEFT JOIN pagamentoHistorico.imovel imov " 
							+ " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + condicionais + " ORDER BY pagamentoHistorico.dataPagamento DESC";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

			// Solucao para evitar erro do setMaxResult
			List lista = (List) retorno;

			int posicaoInicial = 10 * numeroPagina;
			int posicaoFinal = 10 * numeroPagina + 10;

			retorno = lista.subList(posicaoInicial, (posicaoFinal > lista.size() ? lista.size() : posicaoFinal));

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Filtrar pagamentos historicos do movimento arrecador
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @author eduardo henrique
	 * @date 17/12/2008
	 *       Correção no método no Join de Debito Tipo de Guia
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoMovimentoArrecadador(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = null;
		// Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;

		String hql = "";

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisPagamentoHistorico(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
			// 3. O sistema seleciona os pagamentos de débito a cobrar do
			// cliente informado (a partir da tabela
			// PAGAMENTO com DBAC_ID = DBAC_ID da tabela DEBITO_A_COBRAR com
			// IMOV_ID = IMOV_ID da tabela
			// CLIENTE_IMOVEL com CLIE_ID = Id do cliente informado e CRTP_ID
			// com valor correspondente a um dos
			// tipos de relação do Cliente com o Imóvel, caso selecionados e
			// demais parâmetros de seleção informados)

			hql = " select distinct pagamentoHistorico " 
							+ " from gcom.arrecadacao.pagamento.PagamentoHistorico  pagamentoHistorico "
							+ " INNER JOIN FETCH pagamentoHistorico.arrecadadorMovimentoItem  arrecadadorMovimentoItem "
							+ " INNER JOIN FETCH arrecadadorMovimentoItem.arrecadadorMovimento  arrecadadorMovimento "
							+ " INNER JOIN FETCH pagamentoHistorico.avisoBancario avbc " 
							+ " INNER JOIN FETCH avbc.arrecadador arrec "
							+ " INNER JOIN FETCH pagamentoHistorico.documentoTipo doctoTp "
							+ " LEFT JOIN FETCH pagamentoHistorico.conta conta "
							+ " LEFT JOIN FETCH pagamentoHistorico.guiaPagamentoGeral gpag "
							+ " LEFT JOIN FETCH pagamentoHistorico.debitoACobrar dbcb " + " LEFT JOIN FETCH dbcb.debitoTipo dbtpDbcb "
							+ " LEFT JOIN FETCH pagamentoHistorico.arrecadacaoForma arrecForma "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAtual pagtoSitAtual "
							+ " LEFT JOIN FETCH pagamentoHistorico.pagamentoSituacaoAnterior pagtoSitAnterior "
							+ " LEFT JOIN pagamentoHistorico.imovel imov " + " LEFT JOIN imov.imovelSubcategorias imsb "
							+ " LEFT JOIN imov.setorComercial stcm " + " LEFT JOIN FETCH pagamentoHistorico.cliente cli " + condicionais
							+ " order by pagamentoHistorico.localidade.id, pagamentoHistorico.imovel.id, "
							+ " pagamentoHistorico.debitoTipo.id, pagamentoHistorico.dataPagamento " + " ";

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}

			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * por historico
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos com os condicionais informados
	 * criarCondicionaisPagamentoHistorico
	 * 
	 * @author Rafael Santos
	 * @date 07/10/2006
	 * @author Saulo Lima
	 * @date 16/01/2009
	 *       Modificação nas condicionais de DATA (dataPagamentoInicial e Final) do formado
	 *       AAAA-MM-DD para DD-MM-AAAA
	 * @param idImovel
	 * @param idCliente
	 * @param idTipoRelacao
	 * @param localidadeInicial
	 * @param localidadeFinal
	 * @param idAvisoBancario
	 * @param idArrecadador
	 * @param periodoArrecadacaoInicial
	 * @param periodoArrecadacaoFinal
	 * @param periodoPagamentoInicio
	 * @param periodoPagamentoFim
	 * @param dataPagamentoInicial
	 * @param dataPagamentoFinal
	 * @param idsPagamentosSituacoes
	 * @param idsDebitosTipos
	 * @param idsArrecadacaoForma
	 * @param idsDocumentosTipos
	 * @param idsCategoria
	 *            TODO
	 * @return
	 */
	private String criarCondicionaisPagamentoHistorico(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria){

		String sql = " where ";
		if(idImovel != null && !idImovel.equals("")){
			sql = sql + " pagamentoHistorico.imovel.id = " + idImovel + " and ";
		}
		if(idCliente != null && !idCliente.equals("")){
			sql = sql + " pagamentoHistorico.cliente.id = " + idCliente + " and ";
		}
		if(idTipoRelacao != null && !idTipoRelacao.equals("")){
			sql = sql + " clienteRelacaoTipo.id = " + idTipoRelacao + " and ";
		}
		if(localidadeInicial != null && localidadeFinal != null && !localidadeInicial.equals("") && !localidadeFinal.equals("")){
			sql = sql + " pagamentoHistorico.localidade.id >= " + localidadeInicial + " and ";
			sql = sql + " pagamentoHistorico.localidade.id <= " + localidadeFinal + " and ";
		}
		if(!Util.isVazioOuBranco(codigoSetorComercialInicial) && !Util.isVazioOuBranco(codigoSetorComercialFinal)){
			sql = sql + " stcm.codigo >= " + codigoSetorComercialInicial + " and ";
			sql = sql + " stcm.codigo <= " + codigoSetorComercialFinal + " and ";
		}
		if(!Util.isVazioOrNulo(idsArrecadadores)){
			String valoresIn = "";

			for(Integer idArrecadadorAux : idsArrecadadores){
				valoresIn = valoresIn + idArrecadadorAux + ",";
			}

			if(!valoresIn.equals("")){
				sql = sql + " pagamentoHistorico.avisoBancario.arrecadador.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idAvisoBancario != null && !idAvisoBancario.equals("")){
			sql = sql + " pagamentoHistorico.avisoBancario.id = " + idAvisoBancario + " and ";
		}
		if(idArrecadador != null && !idArrecadador.equals("")){
			sql = sql + " arrecadadorMovimento.id = " + idArrecadador + " and ";
		}
		if(periodoArrecadacaoInicial != null && !periodoArrecadacaoInicial.equals("")){
			sql = sql + " pagamentoHistorico.anoMesReferenciaArrecadacao >= "
							+ Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial) + " and ";
		}
		if(periodoArrecadacaoFinal != null && !periodoArrecadacaoFinal.equals("")){
			sql = sql + " pagamentoHistorico.anoMesReferenciaArrecadacao <= "
							+ Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal) + " and ";
		}
		if(periodoPagamentoInicio != null && !periodoPagamentoInicio.equals("")){
			sql = sql + " pagamentoHistorico.anoMesReferenciaPagamento >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio)
							+ " and ";
		}
		if(periodoPagamentoFim != null && !periodoPagamentoFim.equals("")){
			sql = sql + " pagamentoHistorico.anoMesReferenciaPagamento <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim)
							+ " and ";
		}

		if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
			sql = sql + " pagamentoHistorico.dataPagamento >= :dataPagamentoInicial  and ";
		}

		if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
			sql = sql + " pagamentoHistorico.dataPagamento <= :dataPagamentoFinal  and ";
		}

		if(idsPagamentosSituacoes != null && !idsPagamentosSituacoes.equals("")){
			String valoresIn = "";
			for(int i = 0; i < idsPagamentosSituacoes.length; i++){
				if(!idsPagamentosSituacoes[i].equals("")){
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " pagamentoHistorico.pagamentoSituacaoAtual.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDebitosTipos != null && !idsDebitosTipos.equals("")
						&& !idsDebitosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDebitosTipos.length; i++){
				if(!idsDebitosTipos[i].equals("")){
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " pagamentoHistorico.debitoTipo.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsArrecadacaoForma != null && !idsArrecadacaoForma.equals("")
						&& !idsArrecadacaoForma[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsArrecadacaoForma.length; i++){
				if(!idsArrecadacaoForma[i].equals("")){
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " pagamentoHistorico.arrecadacaoForma.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDocumentosTipos != null && !idsDocumentosTipos.equals("")
						&& !idsDocumentosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDocumentosTipos.length; i++){
				if(!idsDocumentosTipos[i].equals("")){
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " pagamentoHistorico.documentoTipo.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}

		if(idsCategoria != null && idsCategoria.length != 0){

			String valoresIn = "";

			for(int i = 0; i < idsCategoria.length; i++){
				if(!idsCategoria[i].equals("")){
					valoresIn = valoresIn + idsCategoria[i] + ",";
				}
			}

			if(!valoresIn.equals("")){

				sql = sql + " imsb.comp_id.subcategoria.categoria.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";

			}

		}

		if(idsCategoria != null && idsCategoria.length != 0){

			String valoresIn = "";

			for(int i = 0; i < idsCategoria.length; i++){
				if(!idsCategoria[i].equals("")){
					valoresIn = valoresIn + idsCategoria[i] + ",";
				}
			}

			if(!valoresIn.equals("")){

				sql = sql + " imsb.comp_id.subcategoria.categoria.id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";

			}

		}

		// retira o " and " q fica sobrando no final da query
		sql = Util.formatarHQL(sql, 4);

		// [SB0006] Ordenar Pagamentos de Acordo com o Tipo de Documento
		// 1. Para os pagamentos com tipo de documento(DOPT_ID) com valor
		// correspondente a conta,
		// ordena os pagamentos pela localidade (LOCA_ID), matrícula do imóvel
		// (IMOV_ID), ano/mês
		// de referênca do pagamento(PGHI_AMREFERENCIAPAGAMENTO), e data de
		// pagamento (PGHI_DTPAGAMENTO)

		// 2. Para os pagamentos com tipo do documento(DOPT_ID) com o valor
		// correspondente a guia de
		// pagamento, ordena os pagamentos pela localidade (LOCA_ID), matrícula
		// do imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGHI_DTPAGAMENTO)

		// 3. Para os pagamentos com tipo de documento(DOPT_ID) com o valor
		// correspondente a débito a
		// cobrar, ordena os pagamentos pela localidade (LOCA_ID), matrícula do
		// imóvel(IMOV_ID),
		// tipo do débito(DBTP_ID), e data de pagamento (PGHI_DTPAGAMENTO)

		return sql;
	}

	/**
	 * Faz a pesquisa de devoluçãoHistorico fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 09/10/2006
	 * @param FiltroDevolucaoHistorico
	 * @return Collection<DevolucaoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<DevolucaoHistorico> pesquisarDevolucaoHistorico(FiltroDevolucaoHistorico filtroDevolucaoHistorico)
					throws ErroRepositorioException{

		Collection<DevolucaoHistorico> retorno = null;

		Session session = HibernateUtil.getSession();

		try{

			retorno = new ArrayList(new CopyOnWriteArraySet<DevolucaoHistorico>(GeradorHQLCondicional.gerarCondicionalQuery(
							filtroDevolucaoHistorico, "gcom.arrecadacao.DevolucaoHistorico", "devolucaoHistorico",
							"select distinct devolucaoHistorico from gcom.arrecadacao.DevolucaoHistorico  devolucaoHistorico ", session)
							.list()));

			if(!filtroDevolucaoHistorico.getColecaoCaminhosParaCarregamentoEntidades().isEmpty()){

				/*
				 * System.out.println(filtroDevolucaoHistorico
				 * .getColecaoCaminhosParaCarregamentoEntidades()
				 * .toString());
				 */
				// PersistenciaUtil.processaObjetosParaCarregamento(filtroDevolucaoHistorico.getColecaoCaminhosParaCarregamentoEntidades(),
				// retorno);
			}

			if(!Util.isVazioOrNulo(retorno)){
				for(DevolucaoHistorico devolucaoHistorico : retorno){
					Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao());

					if(devolucaoHistorico.getGuiaDevolucao() != null){
						Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getContaGeral());

						if(devolucaoHistorico.getGuiaDevolucao().getContaGeral() != null){
							if(devolucaoHistorico.getGuiaDevolucao().getContaGeral().getIndicadorHistorico() == ConstantesSistema.SIM
											.shortValue()){
								Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getContaGeral().getContaHistorico());
							}else{
								Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getContaGeral().getConta());

								if(devolucaoHistorico.getGuiaDevolucao().getContaGeral().getConta() != null){
									Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getContaGeral().getConta()
													.getClienteContas());
								}
							}
						}

						Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getDocumentoTipo());

						Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getGuiaPagamentoGeral());

						if(devolucaoHistorico.getGuiaDevolucao().getGuiaPagamentoGeral() != null){
							if(devolucaoHistorico.getGuiaDevolucao().getGuiaPagamentoGeral().getIndicadorHistorico() == ConstantesSistema.SIM
											.shortValue()){
								Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getGuiaPagamentoGeral()
												.getGuiaPagamentoHistorico());
							}else{
								Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getGuiaPagamentoGeral().getGuiaPagamento());

								if(devolucaoHistorico.getGuiaDevolucao().getGuiaPagamentoGeral().getGuiaPagamento() != null){
									Hibernate.initialize(devolucaoHistorico.getGuiaDevolucao().getGuiaPagamentoGeral().getGuiaPagamento()
													.getClientesGuiaPagamento());
								}
							}
						}
					}

					Hibernate.initialize(devolucaoHistorico.getImovel());

					if(devolucaoHistorico.getImovel() != null){
						Hibernate.initialize(devolucaoHistorico.getImovel().getClienteImoveis());
						Hibernate.initialize(devolucaoHistorico.getImovel().getLocalidade());

						if(devolucaoHistorico.getImovel().getLocalidade() != null){
							Hibernate.initialize(devolucaoHistorico.getImovel().getLocalidade().getGerenciaRegional());
						}

						Hibernate.initialize(devolucaoHistorico.getImovel().getSetorComercial());
						Hibernate.initialize(devolucaoHistorico.getImovel().getQuadra());
					}

					Hibernate.initialize(devolucaoHistorico.getDebitoTipo());

					Hibernate.initialize(devolucaoHistorico.getAvisoBancario());

					if(devolucaoHistorico.getAvisoBancario() != null){
						Hibernate.initialize(devolucaoHistorico.getAvisoBancario().getArrecadador());

						if(devolucaoHistorico.getAvisoBancario().getArrecadador() != null){
							Hibernate.initialize(devolucaoHistorico.getAvisoBancario().getArrecadador().getCliente());
						}
					}

					Hibernate.initialize(devolucaoHistorico.getDevolucaoSituacaoAtual());
				}
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * histórico para o Relatório
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos histórico do tipo Debito a Cobrar do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 13/11/06
	 * @author Saulo Lima
	 * @date 13/01/2009
	 *       Alteração nos campos de retorno e Generics na coleção de retorno
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<Object> pesquisarPagamentoHistoricoLocalidadeRelatorio(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ErroRepositorioException{

		Collection<Object> retorno = new ArrayList();

		boolean possuiDataInicial = false;
		boolean possuiDataFinal = false;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{
			// 1. O sistema seleciona os pagamentos de conta do cliente informado (a partir da
			// tabela
			// PAGAMENTO com CNTA_ID = CNTA_ID da tabela CLIENTE_CONTA com CLIE_ID = Id do cliente
			// informado
			// e CRTP_ID correspondente a um dos Tipos de Relação do Cliente com o Imóvel, caso
			// selecionados
			// e demais parâmetros de seleção informados)
			String condicionais = this.criarCondicionaisPagamentoRelatorio(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			hql = "SELECT pagto.id," // 0
							+ " loc.id," // 1
							+ " loc.descricao," // 2
							+ " gr.id," // 3
							+ " gr.nome," // 4
							+ " imov.id," // 5
							+ " cli.id," // 6
							+ " cli.nome," // 7
							+ " cliArrec.nome," // 8
							+ " pagto.dataPagamento," // 9
							+ " pagto.anoMesReferenciaPagamento," // 10
							+ " dbtp.descricao," // 11
							+ " pagto.valorPagamento," // 12
							+ " pagtoSitAtual.id," // 13
							+ " pagtoSitAtual.descricao," // 14
							+ " doctoTp.id," // 15
							+ " pagto.debitoACobrar.id," // 16
							+ " pagto.guiaPagamentoGeral.id," // 17
							+ " pagto.numeroPrestacao," // 18
							+ " stcm.codigo, " + " pagto.conta.id " + " FROM PagamentoHistorico pagto"
							+ " INNER JOIN pagto.localidade loc"
							+ " INNER JOIN loc.gerenciaRegional gr"
							+ " INNER JOIN pagto.avisoBancario avbc"
							+ " INNER JOIN avbc.arrecadador arrec"
							+ " INNER JOIN arrec.cliente cliArrec"
							+ " INNER JOIN pagto.documentoTipo doctoTp"
							+ " LEFT JOIN pagto.imovel imov"
							+ " LEFT JOIN pagto.cliente cli"
							+ " LEFT JOIN pagto.debitoTipo dbtp"
							+ " LEFT JOIN pagto.pagamentoSituacaoAtual pagtoSitAtual"
							+ " LEFT JOIN pagto.arrecadadorMovimentoItem arrecMovItem"
							+ " LEFT JOIN arrecMovItem.arrecadadorMovimento arrecMov"
							+ " LEFT JOIN pagto.arrecadacaoForma arrecForma "
							+ " LEFT JOIN imov.imovelSubcategorias imsb " + " LEFT JOIN imov.setorComercial stcm " + condicionais;

			if(indicadorTotalizarPorDataPagamento != null && indicadorTotalizarPorDataPagamento.equals(ConstantesSistema.SIM.toString())){
				hql = hql + " ORDER BY pagto.dataPagamento, loc.id, stcm.codigo, imov.id ";
			}else{
				hql = hql + " ORDER BY loc.id, imov.id, dbtp.id, pagto.dataPagamento ";
			}

			if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
				possuiDataInicial = true;
			}
			if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
				possuiDataFinal = true;
			}

			if(possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).setTimestamp(
								"dataPagamentoFinal", dataPagamentoFinal).list();
			}else if(possuiDataInicial && !possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoInicial", dataPagamentoInicial).list();
			}else if(!possuiDataInicial && possuiDataFinal){
				retorno = session.createQuery(hql).setTimestamp("dataPagamentoFinal", dataPagamentoFinal).list();
			}else{
				retorno = session.createQuery(hql).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta dados da tabela dados diarios arrecadacao
	 * 
	 * @author Rafael Santos
	 * @created 21/10/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarDadosDiarios(int idGerenciaRegional, int idLocalidade, int idElo) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select gerenciaRegional.nome,localidade.descricao,elo.descricao "
							+ " from ArrecadacaoDadosDiarios arrecadacaoDadosDiarios "
							+ "left join arrecadacaoDadosDiarios.localidade localidade " + "left join localidade.localidade elo "
							+ "left join arrecadacaoDadosDiarios.gerenciaRegional gerenciaRegional" + " where "
							+ "localidade.id = :idLocalidade ";
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setMaxResults(1).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa conta e agência do sistema de parâmetros
	 * 
	 * @author Ana Maria
	 * @date 23/10/06
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaAgenciaSistemaParametro() throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = " select cont.numeroConta, agen.codigoAgencia" + " from SistemaParametro parm"
							+ " left join parm.contaBancaria cont" + " left join cont.agencia agen";

			retorno = (Object[]) session.createQuery(consulta).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa id do lançamento contabil
	 * 
	 * @author Sávio Luiz
	 * @date 08/11/06
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdLancamentoItemContabil(Integer idCreditoTipo) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = " select lancamentoItemContab.id " + " from CreditoTipo credTipo "
							+ " left join credTipo.lancamentoItemContabil lancamentoItemContab " + " where credTipo.id = :idCreditoTipo";

			retorno = (Integer) session.createQuery(consulta).setInteger("idCreditoTipo", idCreditoTipo).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * pesquisar descrição do Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 22/11/06
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public String pesquisarDescricaoDebitoAutomatico(Integer codigoRetorno) throws ErroRepositorioException{

		String retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = " select debAutomaticoRetCod.descricaoDebitoAutomaticoRetornoCodigo "
							+ " from DebitoAutomaticoRetornoCodigo debAutomaticoRetCod " + " where debAutomaticoRetCod.id = :codigoRetorno";

			retorno = (String) session.createQuery(consulta).setInteger("codigoRetorno", codigoRetorno).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a lista de ano/mês de arrecadaçaõ menores e igual ao ano/mês de
	 * arrecadação atual.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 18/04/2006, 29/11/2006
	 * @param anoMesArrecadacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesArrecadacaoMenorIgualAtual(Integer anoMesArrecadacaoAtual) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = " select distinct(anoMesReferenciaArrecadacao) from Pagamento pagamento "
							+ " where pagamento.anoMesReferenciaArrecadacao <= :anoMesArrecadacaoAtual";

			retorno = session.createQuery(consulta).setInteger("anoMesArrecadacaoAtual", anoMesArrecadacaoAtual).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a lista de ano/mês de arrecadação menores e igual ao ano/mês de
	 * arrecadação atual e igual ao id do imóvel informado.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 18/04/2006, 29/11/2006
	 * @param anoMesArrecadacaoAtual
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesArrecadacaoMenorIgualAtualPorImovel(Integer anoMesArrecadacaoAtual, Integer idImovel)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = " select distinct(anoMesReferenciaArrecadacao) from Pagamento pagamento "
							+ " where pagamento.anoMesReferenciaArrecadacao <= :anoMesArrecadacaoAtual "
							+ "and pagamento.imovel.id = :idImovel";

			retorno = session.createQuery(consulta).setInteger("anoMesArrecadacaoAtual", anoMesArrecadacaoAtual).setInteger("idImovel",
							idImovel).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar uma coleção de ids de localidades que possuem pagamentos
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 29/11/2006
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsImovelPorLocalidade(Integer idLocalidade, Integer numeroIndice, Integer quantidadeRegistros)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select distinct(imov.id) from Imovel imov, Pagamento pgmt " + "left join imov.localidade loca "
							+ "where loca.id = :idLocalidade and imov.id = pgmt.imovel.id " + "order by imov.id";

			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setMaxResults(quantidadeRegistros)
							.setFirstResult(numeroIndice).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de Movimento
	 * Arrecadadores
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * @author Eduardo Henrique
	 * @date 18/12/2008
	 *       Alteração nos filtros de Data para adequação ao Oracle
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param concessionaria
	 * @return
	 */
	private String criarCondicionaisMovimentoArrecadador(String codigoBanco, String codigoRemessa, String descricaoIdentificacaoServico,
					String idImovel, String numeroSequencialArquivo, Date dataGeracaoInicio, Date dataGeracaoFim,
					Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia, String indicadorAceitacao){

		// String from = " FROM arrecadacao.arrecadador_movimento
		// arrecadadorMovimento ";
		String where = " WHERE ";

		// ------------------- Where -------------------------
		if(codigoBanco != null && !codigoBanco.equals("")){
			where = where + " arrecadadorMovimento.armv_cdbanco = " + codigoBanco + " and ";
		}

		if(codigoRemessa != null && !codigoRemessa.equals("")){
			where = where + " arrecadadorMovimento.armv_cdremessa = " + codigoRemessa + " and ";
		}

		if(descricaoIdentificacaoServico != null && !descricaoIdentificacaoServico.trim().equals("")){
			where = where + " arrecadadorMovimento.armv_dsidentificacaoservico = '" + descricaoIdentificacaoServico.trim() + "' and ";
		}

		if(idImovel != null && !idImovel.trim().equals("")){
			where = where + " arrecadadorMovimento.armv_id in (select armv_id from arrecadador_movimento_item where imov_id = " + idImovel
							+ " ) and ";
		}

		if(numeroSequencialArquivo != null && !numeroSequencialArquivo.equals("")){
			where = where + " arrecadadorMovimento.armv_nnnsa = " + numeroSequencialArquivo + " and ";
		}

		if(dataGeracaoInicio != null && !dataGeracaoInicio.equals("")){

			String data1 = Util.recuperaDataInvertida(dataGeracaoInicio);

			if(data1 != null && !data1.equals("") && data1.trim().length() == 8){

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6) + "-" + data1.substring(6, 8);
			}
			where = where + " arrecadadorMovimento.armv_dtgeracao >= to_date('" + data1 + "', 'yyyy-mm-dd') and ";
		}

		if(dataGeracaoFim != null && !dataGeracaoFim.equals("")){

			String data2 = Util.recuperaDataInvertida(dataGeracaoFim);

			if(data2 != null && !data2.equals("") && data2.trim().length() == 8){

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6) + "-" + data2.substring(6, 8);
			}
			where = where + " arrecadadorMovimento.armv_dtgeracao <= to_date('" + data2 + "', 'yyyy-mm-dd') and ";
		}
		// comentado por sávio em 02/05/2007,foi colocado essa parte no método
		// if (ultimaAlteracaoInicio != null &&
		// !ultimaAlteracaoInicio.equals("")) {
		//
		// where = where + " arrecadadorMovimento.armv_tmultimaalteracao >= '"
		// + Util.formatarDataInicial(ultimaAlteracaoInicio)
		// + "' and ";
		// }
		//
		// if (ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")) {
		//
		// where = where + " arrecadadorMovimento.armv_tmultimaalteracao <= '"
		// + Util.formatarDataFinal(ultimaAlteracaoFim) + "' and ";
		// }

		if(ultimaAlteracaoInicio != null && !ultimaAlteracaoInicio.equals("")){
			where = where + " arrecadadorMovimento.armv_tmultimaalteracao >= :ultimaAlteracaoInicio and ";
		}

		if(ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")){
			where = where + " arrecadadorMovimento.armv_tmultimaalteracao <= :ultimaAlteracaoFim and ";
		}

		String subSelectMovimentoArrecadadorItem = "";

		if(indicadorAceitacao != null && !indicadorAceitacao.equals("")){

			subSelectMovimentoArrecadadorItem = " 0 < (select count(*)" + " from arrecadador_movimento_item arrecadadorMovimentoItem"
							+ " where amit_icaceitacao = " + indicadorAceitacao
							+ " and arrecadadorMovimento.armv_id = arrecadadorMovimentoItem.armv_id";

			if(descricaoOcorrencia != null && !descricaoOcorrencia.equals("")){
				if(descricaoOcorrencia.equals("" + ConstantesSistema.SEM_ITENS)){
					// sem itens em ocorrência
					subSelectMovimentoArrecadadorItem = subSelectMovimentoArrecadadorItem + " and amit_dsocorrencia = 'OK'";
				}else{
					// com itens em ocorrência
					subSelectMovimentoArrecadadorItem = subSelectMovimentoArrecadadorItem + " and amit_dsocorrencia <> 'OK'";
				}
			}

			subSelectMovimentoArrecadadorItem = subSelectMovimentoArrecadadorItem + ")";

		}else if(descricaoOcorrencia != null && !descricaoOcorrencia.equals("")){
			if(descricaoOcorrencia.equals("" + ConstantesSistema.SEM_ITENS)){
				// sem itens em ocorrência
				subSelectMovimentoArrecadadorItem = " 0 < (select count(*)" + " from arrecadador_movimento_item arrecadadorMovimentoItem"
								+ " where amit_dsocorrencia = 'OK'"
								+ " and  arrecadadorMovimento.armv_id = arrecadadorMovimentoItem.armv_id)";

			}else{
				// com itens em ocorrência
				subSelectMovimentoArrecadadorItem = " 0 < (select count(*)" + " from arrecadador_movimento_item arrecadadorMovimentoItem"
								+ " where amit_dsocorrencia <> 'OK'"
								+ " and  arrecadadorMovimento.armv_id = arrecadadorMovimentoItem.armv_id)";
			}
		}

		if(!subSelectMovimentoArrecadadorItem.equals("")){
			where = where + subSelectMovimentoArrecadadorItem;
		}else{
			// retira o " and " q fica sobrando no final da query
			if(!where.trim().equals("WHERE")){
				where = Util.formatarHQL(where, 4);
			}
		}

		String sql = where;
		return sql;
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * @author eduardo henrique
	 * @date 18/12/2008
	 *       Inclusão de Ordenação e correção no filtro de Datas.
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param numeroPagina
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarMovimentoArrecadadorParaPaginacao(String codigoBanco, String codigoRemessa,
					String descricaoIdentificacaoServico, String idImovel, String numeroSequencialArquivo, Date dataGeracaoInicio,
					Date dataGeracaoFim, Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia,
					String indicadorAceitacao, Integer numeroPagina, String idConcessionaria) throws ErroRepositorioException{

		Collection retorno = null;
		StringBuilder sql = new StringBuilder();

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisMovimentoArrecadador(codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
							idImovel, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim, ultimaAlteracaoInicio,
							ultimaAlteracaoFim, descricaoOcorrencia, indicadorAceitacao);

			String condicionaisConcessionaria = "";

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				condicionaisConcessionaria = " WHERE idConcessionaria = :idConcessionaria ";
			}

			sql.append("       SELECT codBanco, ");
			sql.append("       codRemessa, ");
			sql.append("       descIdentServico, ");
			sql.append("       numeroSeqArquivo, ");
			sql.append("       id, ");
			sql.append("       dataGeracao, ");
			sql.append("       numRegistroMovimento, ");
			sql.append("       vlTotalMovimento, ");
			sql.append("       ultimaAlteracao, ");
			sql.append("       nomeBanco, ");
			sql.append("       idConcessionaria, ");
			sql.append("       nomeConcessionaria ");
			sql.append("       FROM (SELECT arrecadadorMovimento.armv_cdbanco AS codBanco, ");
			sql.append("             arrecadadorMovimento.armv_cdremessa AS codRemessa, ");
			sql.append("             arrecadadorMovimento.armv_dsidentificacaoservico AS descIdentServico, ");
			sql.append("             arrecadadorMovimento.armv_nnnsa AS numeroSeqArquivo, ");
			sql.append("             arrecadadorMovimento.armv_id AS id, ");
			sql.append("             arrecadadorMovimento.armv_dtgeracao AS dataGeracao, ");
			sql.append("             arrecadadorMovimento.armv_nnregistrosmovimento AS numRegistroMovimento, ");
			sql.append("             arrecadadorMovimento.armv_vltotalmovimento AS vlTotalMovimento, ");
			sql.append("             arrecadadorMovimento.armv_tmultimaalteracao AS ultimaAlteracao, ");
			sql.append("             arrecadadorMovimento.armv_nmbanco AS nomeBanco, ");
			sql.append("             (CASE arrecadadorMovimento.armv_dsidentificacaoservico WHEN 'DEBITO AUTOMATICO' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconveniodebaut = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              WHEN 'COBRANCA BANCARIA' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconvenioboleto = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              ELSE ");
			sql.append("               (SELECT concessionaria.conc_id ");
			sql.append("                FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("                INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("                WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                  AND arrecadadorContrato.arct_cdconvenio = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              END) AS idConcessionaria, ");
			sql.append("             (CASE arrecadadorMovimento.armv_dsidentificacaoservico WHEN 'DEBITO AUTOMATICO' then ");
			sql.append("              (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconveniodebaut = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              WHEN 'COBRANCA BANCARIA' then ");
			sql.append("              (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconvenioboleto = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              ELSE ");
			sql.append("               (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("                FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("                INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("                WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                  AND arrecadadorContrato.arct_cdconvenio = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              END) AS nomeConcessionaria ");
			sql.append("             FROM arrecadador_movimento arrecadadorMovimento ");
			sql.append(condicionais);
			sql.append("            ) tabAux1 ");
			sql.append(condicionaisConcessionaria);

			sql.append(" ORDER BY codBanco, numeroSeqArquivo DESC ");

			SQLQuery sqlQuery = session.createSQLQuery(sql.toString());
			sqlQuery.addScalar("codBanco", Hibernate.SHORT);
			sqlQuery.addScalar("codRemessa", Hibernate.SHORT);
			sqlQuery.addScalar("descIdentServico", Hibernate.STRING);
			sqlQuery.addScalar("numeroSeqArquivo", Hibernate.INTEGER);
			sqlQuery.addScalar("id", Hibernate.INTEGER);
			sqlQuery.addScalar("dataGeracao", Hibernate.DATE);
			sqlQuery.addScalar("numRegistroMovimento", Hibernate.INTEGER);
			sqlQuery.addScalar("vlTotalMovimento", Hibernate.BIG_DECIMAL);
			sqlQuery.addScalar("ultimaAlteracao", Hibernate.TIMESTAMP);
			sqlQuery.addScalar("nomeBanco", Hibernate.STRING);
			sqlQuery.addScalar("idConcessionaria", Hibernate.INTEGER);
			sqlQuery.addScalar("nomeConcessionaria", Hibernate.STRING);

			if(ultimaAlteracaoInicio != null && !ultimaAlteracaoInicio.equals("")){
				Date dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);

				sqlQuery.setTimestamp("ultimaAlteracaoInicio", dataInicio);
			}

			if(ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")){
				Date dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);

				sqlQuery.setTimestamp("ultimaAlteracaoFim", dataFim);
			}

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				sqlQuery.setString("idConcessionaria", idConcessionaria);
			}

			retorno = sqlQuery.setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	/**
	 * 
	 * @author Victon Santos
	 * @date 02/01/14
	 */
	public Collection filtrarItemMovimentoArrecadadorAjustado(Integer movimentoArrecadadorItem) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";
		try{
			consulta = "select acba_dsocorrencia from ajuste_codigo_barras where amit_id = :movimentoArrecadadorItem";

			retorno = session.createSQLQuery(consulta).setInteger("movimentoArrecadadorItem", movimentoArrecadadorItem).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer filtrarMovimentoArrecadadoresCount(String codigoBanco, String codigoRemessa, String descricaoIdentificacaoServico,
					String idImovel, String numeroSequencialArquivo, Date dataGeracaoInicio, Date dataGeracaoFim,
					Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia, String indicadorAceitacao,
					String idConcessionaria) throws ErroRepositorioException{

		Integer movimentoArrecadadorCount = null;
		StringBuilder sql = new StringBuilder();

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisMovimentoArrecadador(codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
							idImovel, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim, ultimaAlteracaoInicio,
							ultimaAlteracaoFim, descricaoOcorrencia, indicadorAceitacao);

			String condicionaisConcessionaria = "";

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				condicionaisConcessionaria = " WHERE idConcessionaria = :idConcessionaria ";
			}

			sql.append(" SELECT COUNT(id) as qtdeMovimentoArrecadador ");
			sql.append(" FROM (SELECT codBanco, ");
			sql.append("       codRemessa, ");
			sql.append("       descIdentServico, ");
			sql.append("       numeroSeqArquivo, ");
			sql.append("       id, ");
			sql.append("       dataGeracao, ");
			sql.append("       numRegistroMovimento, ");
			sql.append("       vlTotalMovimento, ");
			sql.append("       ultimaAlteracao, ");
			sql.append("       nomeBanco, ");
			sql.append("       idConcessionaria ");
			sql.append("       FROM (SELECT arrecadadorMovimento.armv_cdbanco AS codBanco, ");
			sql.append("             arrecadadorMovimento.armv_cdremessa AS codRemessa, ");
			sql.append("             arrecadadorMovimento.armv_dsidentificacaoservico AS descIdentServico, ");
			sql.append("             arrecadadorMovimento.armv_nnnsa AS numeroSeqArquivo, ");
			sql.append("             arrecadadorMovimento.armv_id AS id, ");
			sql.append("             arrecadadorMovimento.armv_dtgeracao AS dataGeracao, ");
			sql.append("             arrecadadorMovimento.armv_nnregistrosmovimento AS numRegistroMovimento, ");
			sql.append("             arrecadadorMovimento.armv_vltotalmovimento AS vlTotalMovimento, ");
			sql.append("             arrecadadorMovimento.armv_tmultimaalteracao AS ultimaAlteracao, ");
			sql.append("             arrecadadorMovimento.armv_nmbanco AS nomeBanco, ");
			sql.append("             (CASE arrecadadorMovimento.armv_dsidentificacaoservico WHEN 'DEBITO AUTOMATICO' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconveniodebaut = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              WHEN 'COBRANCA BANCARIA' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconvenioboleto = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              ELSE ");
			sql.append("               (SELECT concessionaria.conc_id ");
			sql.append("                FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("                INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("                WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                  AND arrecadadorContrato.arct_cdconvenio = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              END) AS idConcessionaria ");
			sql.append("             FROM arrecadador_movimento arrecadadorMovimento ");
			sql.append(condicionais);
			sql.append("            ) tabAux1 ");
			sql.append(condicionaisConcessionaria);
			sql.append(" ) tabAux2 ");

			SQLQuery sqlQuery = session.createSQLQuery(sql.toString());
			sqlQuery.addScalar("qtdeMovimentoArrecadador", Hibernate.INTEGER);

			if(ultimaAlteracaoInicio != null && !ultimaAlteracaoInicio.equals("")){
				Date dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);

				sqlQuery.setTimestamp("ultimaAlteracaoInicio", dataInicio);
			}

			if(ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")){
				Date dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);

				sqlQuery.setTimestamp("ultimaAlteracaoFim", dataFim);
			}

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				sqlQuery.setString("idConcessionaria", idConcessionaria);
			}

			movimentoArrecadadorCount = (Integer) sqlQuery.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return movimentoArrecadadorCount;
	}

	/**
	 * retorna o somatorio de PGMT_VLPAGAMENTO da tabela PAGAMENTO com AMIT_ID
	 * =AMIT_ID da tabela ARRECADADOR_MOVIMENTO_ITEM
	 * [UC0254] Efetuar Análise do Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 05/12/2006
	 * @param idArrecadadorMovimentoItem
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal recuperaValorPagamentoArrecadadorMovimentoItem(Integer idArrecadadorMovimentoItem) throws ErroRepositorioException{

		BigDecimal retorno = null;
		BigDecimal retornoHistorico = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";
		String consultaHistorico = "";

		try{
			consulta = " select sum(pagamento.valorPagamento) from Pagamento pagamento "
							+ " where pagamento.arrecadadorMovimentoItem.id = :idArrecadadorMovimentoItem";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idArrecadadorMovimentoItem", idArrecadadorMovimentoItem)
							.setMaxResults(1).uniqueResult();

			consultaHistorico = "  select sum(pagamentoHistorico.valorPagamento) from PagamentoHistorico pagamentoHistorico "
							+ " where pagamentoHistorico.arrecadadorMovimentoItem.id = :idArrecadadorMovimentoItem";

			retornoHistorico = (BigDecimal) session.createQuery(consultaHistorico).setInteger("idArrecadadorMovimentoItem",
							idArrecadadorMovimentoItem).setMaxResults(1).uniqueResult();

			if(retorno != null && retornoHistorico != null){

				retorno = retorno.add(retornoHistorico);
			}else if(retorno == null){

				retorno = retornoHistorico;
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * retorna a decrição da Forma de Arrecadação (arfm_dsarrecadacaoforma) da
	 * tabela ARRECADACAO_FORMA a partir do codigoArrecadacaoForma
	 * (arfm_cdarrecadacaoforma) passado
	 * [UC0262] Distribuir Dados do Registro do Movimento do Arrecadador
	 * 
	 * @author Vivianne Sousa
	 * @date 06/12/2006
	 * @param codigoArrecadacaoForma
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String recuperaDescricaoArrecadacaoForma(String codigoArrecadacaoForma) throws ErroRepositorioException{

		String retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = " select descricao from ArrecadacaoForma " + " where codigoArrecadacaoForma = :codigoArrecadacaoForma";

			retorno = (String) session.createQuery(consulta).setString("codigoArrecadacaoForma", codigoArrecadacaoForma.trim())
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * ------------------------------------------------------------
	 * 
	 * @deprecated
	 * @see atualizarSituacaoValorExcedentePagamento
	 *      ------------------------------------------------------------
	 *      Atualiza o valor excedente e a situação dos pagamentos informados para o
	 *      tipode situação informada.
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2006, 12/12/2006, 02/10/2007
	 * @param colecaoPagamento
	 * @param pagamentoSituacao
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoEValorExcedentePagamento(Collection<Pagamento> colecaoPagamento, Integer pagamentoSituacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarValorExcedente;
		Pagamento pagamento = null;

		try{

			int i = 1;
			Iterator<Pagamento> iteratorPagamentos = colecaoPagamento.iterator();
			while(iteratorPagamentos.hasNext()){
				pagamento = iteratorPagamentos.next();

				// System.out.println(" ATUALIZANDO PAGAMENTO");

				// Conta
				if(pagamento.getConta() != null){

					atualizarValorExcedente = "UPDATE Pagamento pgmt " + "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
									+ "pgmt.valorExcedente = :valorExcedente, " + "pgmt.ultimaAlteracao = :dataAlteracao, "
									+ "pgmt.conta.id = :idConta " + "WHERE pgmt.id = :idPagamento ";

					session.createQuery(atualizarValorExcedente).setBigDecimal("valorExcedente", pagamento.getValorExcedente())
									.setTimestamp("dataAlteracao", new Date()).setInteger("pagamentoSituacao", pagamentoSituacao)
									.setInteger("idPagamento", pagamento.getId()).setInteger("idConta", pagamento.getConta().getId())
									.executeUpdate();

					// Guia de Pagamento
				}else if(pagamento.getGuiaPagamentoGeral() != null && pagamento.getGuiaPagamentoGeral().getGuiaPagamento() != null){

					atualizarValorExcedente = "UPDATE Pagamento pgmt " + "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
									+ "pgmt.valorExcedente = :valorExcedente, " + "pgmt.ultimaAlteracao = :dataAlteracao, "
									+ "pgmt.guiaPagamentoGeral.id = :idGuiaPagamento " + "WHERE pgmt.id = :idPagamento ";

					session.createQuery(atualizarValorExcedente).setBigDecimal("valorExcedente", pagamento.getValorExcedente())
									.setTimestamp("dataAlteracao", new Date()).setInteger("pagamentoSituacao", pagamentoSituacao)
									.setInteger("idPagamento", pagamento.getId()).setInteger("idGuiaPagamento",
													pagamento.getGuiaPagamentoGeral().getGuiaPagamento().getId()).executeUpdate();

					// Débito a Cobrar
				}else if(pagamento.getDebitoACobrar() != null){

					atualizarValorExcedente = "UPDATE Pagamento pgmt " + "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
									+ "pgmt.valorExcedente = :valorExcedente, " + "pgmt.ultimaAlteracao = :dataAlteracao, "
									+ "pgmt.debitoACobrar.id = :idDebitoACobrar " + "WHERE pgmt.id = :idPagamento ";

					session.createQuery(atualizarValorExcedente).setBigDecimal("valorExcedente", pagamento.getValorExcedente())
									.setTimestamp("dataAlteracao", new Date()).setInteger("pagamentoSituacao", pagamentoSituacao)
									.setInteger("idPagamento", pagamento.getId()).setInteger("idDebitoACobrar",
													pagamento.getDebitoACobrar().getId()).executeUpdate();

				}else{
					atualizarValorExcedente = "UPDATE Pagamento pgmt " + "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
									+ "pgmt.valorExcedente = :valorExcedente, " + "pgmt.ultimaAlteracao = :dataAlteracao "
									+ "WHERE pgmt.id = :idPagamento ";

					session.createQuery(atualizarValorExcedente).setBigDecimal("valorExcedente", pagamento.getValorExcedente())
									.setTimestamp("dataAlteracao", new Date()).setInteger("pagamentoSituacao", pagamentoSituacao)
									.setInteger("idPagamento", pagamento.getId()).executeUpdate();
				}

				if(i % 50 == 0){
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Otimização do método atualizarSituacaoEValorExcedentePagamento
	 * 
	 * @see atualizarSituacaoEValorExcedentePagamento
	 * @author jns
	 * @param colecaoPagamento
	 * @param pagamentoSituacao
	 * @throws ErroRepositorioException
	 */

	public void atualizarSituacaoValorExcedentePagamento(Collection<Pagamento> colecaoPagamento, Integer pagamentoSituacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer atualizarValorExcedente = new StringBuffer();

		// StringBuffer nomePropriedade = null;
		// Integer idPropriedade = null;

		try{

			int i = 1;
			Iterator<Pagamento> iteratorPagamentos = colecaoPagamento.iterator();

			while(iteratorPagamentos.hasNext()){

				Pagamento pagamento = iteratorPagamentos.next();

				atualizarValorExcedente.delete(0, atualizarValorExcedente.length());

				atualizarValorExcedente.append("UPDATE Pagamento pgmt ")
								.append("SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, ").append(
												"pgmt.valorExcedente = :valorExcedente, ").append("pgmt.ultimaAlteracao = :dataAlteracao ");

				if(pagamento.getConta() != null){
					atualizarValorExcedente.append(", pgmt.conta.id = :idConta ");
					// .append(pagamento.getConta().getId());
				}

				atualizarValorExcedente.append(" WHERE pgmt.id = :idPagamento ");

				Query query = session.createQuery(atualizarValorExcedente.toString());

				query.setBigDecimal("valorExcedente", pagamento.getValorExcedente()).setTimestamp("dataAlteracao", new Date()).setInteger(
								"pagamentoSituacao", pagamentoSituacao)
				// .setInteger("idConta", pagamento.getConta().getId())
								.setInteger("idPagamento", pagamento.getId());

				if(pagamento.getConta() != null){
					query.setInteger("idConta", pagamento.getConta().getId());
				}

				query.executeUpdate();

				if(i++ % 50 == 0){
					session.flush();
					session.clear();
				}
			}
			session.flush();
			session.clear();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisar os ids das localidades que possuem pagamentos
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 04/12/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsLocalidadeComPagamentosOuDevolucoes() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select loca_id as localidade from devolucao " + "union " + "select loca_id as localidade from pagamento "
							+ "order by localidade";

			retorno = session.createSQLQuery(consulta).addScalar("localidade", Hibernate.INTEGER).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar os ano/mês de referência do pagamentos para um imóvel e ano/mês
	 * de arrecadação informados para o tipo de documento informado.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 06/12/2006
	 * @param anoMesArrecadacaoAtual
	 * @param idImovel
	 * @param idDocumentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesReferenciaPagamentoParaImovel(Integer anoMesArrecadacaoAtual, Integer idImovel, Integer idDocumentoTipo)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = " select distinct(anoMesReferenciaPagamento) from Pagamento pagamento "
							+ " where pagamento.anoMesReferenciaArrecadacao = :anoMesArrecadacaoAtual "
							+ "and pagamento.imovel.id = :idImovel and pagamento.documentoTipo.id = :idDocumentoTipo";

			retorno = session.createQuery(consulta).setInteger("anoMesArrecadacaoAtual", anoMesArrecadacaoAtual).setInteger("idImovel",
							idImovel).setInteger("idDocumentoTipo", idDocumentoTipo).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a esfera do poder do cliente responsável pelo imóvel.
	 * [UC0301] - Gerar Dados Diários da Arrecadacao
	 * 
	 * @author Pedro Alexandre
	 * @date 05/12/2006
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarEsferaPoderClienteResponsavelPeloImovel(Integer idImovel) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select cltp.esferaPoder.id from ClienteTipo cltp where cltp.id in "
							+ "(select clie.clienteTipo.id from Cliente clie where clie.id in "
							+ "(select clim.cliente.id from ClienteImovel clim "
							+ "where clim.imovel.id = :idImovel and clim.dataFimRelacao is null and clim.clienteRelacaoTipo.id= :idRelacaoTipo ) ) ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idRelacaoTipo",
							ClienteRelacaoTipo.RESPONSAVEL).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualiza a situção dos pagamentos informados.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 18/04/2006, 12/12/2006
	 * @param pagamentoSituacao
	 * @param colecaoPagamentos
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoPagamento(Integer pagamentoSituacao, Collection<Pagamento> colecaoPagamentos)
					throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		StringBuffer atualizarSituacaoPagamento = new StringBuffer();
		Pagamento pagamento = null;
		try{

			atualizarSituacaoPagamento.append("UPDATE Pagamento pgmt ").append("SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, ")
							.append("pgmt.ultimaAlteracao = :dataAlteracao ").append("WHERE pgmt.id = :idPagamento");

			int i = 1;
			Iterator<Pagamento> iteratorPagamentos = colecaoPagamentos.iterator();
			while(iteratorPagamentos.hasNext()){
				pagamento = iteratorPagamentos.next();

				// System.out.println("################### ATUALIZANDO SITUACAO ");

				session.createQuery(atualizarSituacaoPagamento.toString()).setInteger("pagamentoSituacao", pagamentoSituacao).setTimestamp(
								"dataAlteracao", new Date()).setInteger("idPagamento", pagamento.getId()).executeUpdate();
				if(i % 50 == 0){
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa uma coleção de ids das categorias cadastradas
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 15/12/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsCategorias() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select cate.id from Categoria cate order by cate.id";

			retorno = session.createQuery(consulta).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa uma coleção de ids dos lançamentos de itens contábeis
	 * cadastrados
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 15/12/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosLancamentosItemContabil() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select lict.id,lict.sequenciaImpressao from LancamentoItemContabil lict order by lict.id";

			retorno = session.createQuery(consulta).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa alguns valores necessarios para obter a situação do aviso
	 * bancario, se aberto ou fechado
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2006
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarAvisoBancarioAvisoAcertos(Integer idAvisoBancario) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			// consulta = " select avbc.valorArrecadacaoCalculado,"
			// + " avbc.valorArrecadacaoInformado,"
			// + " (select sum(avac.valorAcerto)"
			// + " from AvisoAcerto  avac"
			// + " where avac.avisoBancario.id = :idAvisoBancario and"
			// + " avac.indicadorCreditoDebito = 1"
			// + " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao1,"
			// + " (select sum(avac.valorAcerto)"
			// + " from AvisoAcerto  avac"
			// + " where avac.avisoBancario.id = :idAvisoBancario and"
			// + " avac.indicadorCreditoDebito = 2"
			// + " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao2,"
			// + " avbc.valorDevolucaoCalculado,"
			// + " avbc.valorDevolucaoInformado,"
			// + " (select sum(avac.valorAcerto)"
			// + " from AvisoAcerto  avac"
			// + " where avac.avisoBancario.id = :idAvisoBancario and"
			// + " avac.indicadorCreditoDebito = 1"
			// + " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao1,"
			// + " (select sum(avac.valorAcerto)"
			// + " from AvisoAcerto  avac"
			// + " where avac.avisoBancario.id = :idAvisoBancario and"
			// + " avac.indicadorCreditoDebito = 2"
			// + " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao2"
			// + " from AvisoBancario  avbc"
			// + " where avbc.id = :idAvisoBancario";

			consulta = " select avbc.valorArrecadacaoCalculado," // 0
							+ " avbc.valorArrecadacaoInformado,"// 1
							+ " avbc.valorRealizado" // 2
							+ " from AvisoBancario  avbc" + " where avbc.id = :idAvisoBancario";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select avbc, " + // 0
							"avbc.arrecadador.codigoAgente, " + // 1
							"avbc.arrecadador.cliente.nome, " + // 2
							"avbc.arrecadadorMovimento.id, " + // 3
							"avbc.contaBancaria.agencia.banco.id, " + // 4
							"avbc.contaBancaria.agencia.codigoAgencia, " + // 5
							"avbc.contaBancaria.numeroConta " + // 6
							"from AvisoBancario  avbc " + "where avbc.id = :idAvisoBancario";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * somatorio do valor das deduções existentes para o aviso bancario
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarSomatorioDeducoesAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT sum(vd.valorDeducao) " + "FROM AvisoDeducoes vd " + "LEFT JOIN vd.avisoBancario aviso "
							+ "WHERE aviso.id = :idAvisoBancario ";

			BigDecimal big = (BigDecimal) session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario).setMaxResults(1)
							.uniqueResult();
			if(big != null){
				retorno = big;
			}else{
				retorno = BigDecimal.ZERO;
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarValorAcertosAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = " select "
							+ " (select sum(avac.valorAcerto)"
							+ " from AvisoAcerto  avac"
							+ " where avac.avisoBancario.id = :idAvisoBancario and"
							+ " avac.indicadorCreditoDebito = 1"
							+ " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao1,"
							+ // 0
							" (select sum(avac.valorAcerto)"
							+ " from AvisoAcerto  avac"
							+ " where avac.avisoBancario.id = :idAvisoBancario and"
							+ " avac.indicadorCreditoDebito = 2"
							+ " and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao2,"
							+ // 1
							" (select sum(avac.valorAcerto)" + " from AvisoAcerto  avac"
							+ " where avac.avisoBancario.id = :idAvisoBancario and"
							+ " avac.indicadorCreditoDebito = 1"
							+ " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao1,"
							+ // 2
							" (select sum(avac.valorAcerto)" + " from AvisoAcerto  avac"
							+ " where avac.avisoBancario.id = :idAvisoBancario and" + " avac.indicadorCreditoDebito = 2"
							+ " and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao2" + // 3
							" from AvisoBancario  avbc" + " where avbc.id = :idAvisoBancario";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os avisos deduções de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDeducoesAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select dt.descricao, ad.valorDeducao " + "from AvisoDeducoes ad " + "inner join ad.deducaoTipo dt "
							+ "inner join ad.avisoBancario ab " + "where ab.id = :idAvisoBancario";

			retorno = session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario.intValue()).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * pesquisa a lista dos acertos da Arrecadação/Devolucao do Aviso Bancario
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAcertosAvisoBancario(Integer idAvisoBancario, Integer indicadorArrecadacaoDevolucao)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "SELECT " + "avisoAcerto.contaBancaria.agencia.banco.id, "
							+ "avisoAcerto.contaBancaria.agencia.codigoAgencia, " + "avisoAcerto.contaBancaria.numeroConta, "
							+ "avisoAcerto.indicadorCreditoDebito,  " + "avisoAcerto.dataAcerto, " + "avisoAcerto.valorAcerto "
							+ "FROM AvisoAcerto avisoAcerto " + "WHERE avisoAcerto.avisoBancario.id = :idAvisoBancario "
							+ "AND avisoAcerto.indicadorArrecadacaoDevolucao = :indicadorArrecadacaoDevolucao";

			retorno = session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario.intValue()).setInteger(
							"indicadorArrecadacaoDevolucao", indicadorArrecadacaoDevolucao.intValue()).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * O sistema seleciona a lista de pagamentos associados ao aviso bancário a
	 * partir da tabela PAGAMENTO com AVBC_ID=AVBC_ID da tabela AVISO_BANCARIO
	 * classificados por LOCA_ID ,IMOV_ID e PGMT_AMREFERENCIAPAGAMENTO
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 15/12/2006
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "select "
							+ "documentoTipo.descricaoAbreviado, "
							+ // 0
							"pagamento.dataPagamento, "
							+ // 1
							"pagamento.localidade.id, "
							+ // 2
							"imovel.id, "
							+ // 3
							"cliente.id, "
							+ // 4
							"pagamento.anoMesReferenciaPagamento, "
							+ // 5
							"debitoTipo.id, "
							+ // 6
							"pagamento.valorPagamento, "
							+ // 7
							"pagamentoSituacaoAtual.descricaoAbreviada, "
							+ // 8
							"pagamento.id,"
							+ // 9
							"pagamento.numeroPrestacao, "
							+ // 10

							"conta.id, "
							+ // 11
							"guiaPagamento.id, "
							+ // 12
							"debitoACobrar.id, "
							+ // 13
							"preParcelamentoOpcao.id "
							+ // 14

							"from gcom.arrecadacao.pagamento.Pagamento  pagamento " + "left join pagamento.imovel  imovel "
							+ "left join pagamento.cliente  cliente " + "left join pagamento.debitoTipo  debitoTipo "
							+ "left join pagamento.pagamentoSituacaoAtual  pagamentoSituacaoAtual "
							+ "left join pagamento.documentoTipo  documentoTipo "

							+ "left join pagamento.conta  conta " + "left join pagamento.guiaPagamentoGeral  guiaPagamentoGeral "
							+ "left join guiaPagamentoGeral.guiaPagamento  guiaPagamento "
							+ "left join pagamento.debitoACobrar  debitoACobrar "
							+ "left join pagamento.preParcelamentoOpcao  preParcelamentoOpcao "

							+ "where pagamento.avisoBancario.id = :idAvisoBancario "
							+ "order by pagamento.localidade.id,imovel.id,pagamento.anoMesReferenciaPagamento ";

			retorno = session.createQuery(hql).setInteger("idAvisoBancario", idAvisoBancario).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * O sistema seleciona a lista de desvoluções associados ao aviso bancário a
	 * partir da tabela DEVOLUCAO com AVBC_ID=AVBC_ID da tabela AVISO_BANCARIO
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 15/12/2006
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucaoAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "select "
							+ "documentoTipo.descricaoAbreviado, "
							+ // 0
							"devolucao.dataDevolucao, "
							+ // 1
							"devolucao.localidade.id, "
							+ // 2
							"imovel.id, "
							+ // 3
							"cliente.id, "
							+ // 4
							"devolucao.anoMesReferenciaDevolucao, "
							+ // 5
							"debitoTipo.id, "
							+ // 6
							"devolucao.valorDevolucao, "
							+ // 7
							"devolucaoSituacaoAtual.descricaoAbreviada "
							+ // 8
							"from gcom.arrecadacao.Devolucao  devolucao " + "left join devolucao.imovel  imovel "
							+ "left join devolucao.cliente  cliente " + "left join devolucao.debitoTipo  debitoTipo "
							+ "left join devolucao.devolucaoSituacaoAtual  devolucaoSituacaoAtual "
							+ "left join devolucao.guiaDevolucao  guiaDevolucao " + "left join guiaDevolucao.documentoTipo  documentoTipo "
							+ "where devolucao.avisoBancario.id = :idAvisoBancario ";

			retorno = session.createQuery(hql).setInteger("idAvisoBancario", idAvisoBancario).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0239] - Filtrar Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 15/12/2006
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	private String selectFiltrarAvisoBancario(AvisoBancarioHelper avisoBancarioHelper){

		String retorno = "";

		retorno = "select "
						+ "avisoBancario.arrecadador.id, "
						+ // 0
						"avisoBancario.dataLancamento, "
						+ // 1
						"avisoBancario.numeroSequencial, "
						+ // 2
						"avisoBancario.indicadorCreditoDebito, "
						+ // 3
						"avisoBancario.dataPrevista, "
						+ // 4
						"avisoBancario.dataRealizada, "
						+ // 5
						"avisoBancario.valorRealizado, "
						+ // 6
						"avisoBancario.valorArrecadacaoCalculado, "
						+ // 7
						"avisoBancario.valorArrecadacaoInformado, "
						+ // 8
						"(select sum(avac.valorAcerto) "
						+ "from AvisoAcerto  avac "
						+ "where "
						+ "avac.avisoBancario.id = avisoBancario.id and "
						+ "avac.indicadorCreditoDebito = 1 "
						+ "and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao1, "
						+ // 9
						"(select sum(avac.valorAcerto) "
						+ "from AvisoAcerto  avac "
						+ "where "
						+ "avac.avisoBancario.id = avisoBancario.id and "
						+ "avac.indicadorCreditoDebito = 2 "
						+ "and avac.indicadorArrecadacaoDevolucao = 1)as vlAcertosArrecadacao2, "
						+ // 10
						"avisoBancario.valorDevolucaoCalculado, "
						+ // 11
						"avisoBancario.valorDevolucaoInformado, "
						+ // 12
						"(select sum(avac.valorAcerto) " + "from AvisoAcerto  avac " + "where "
						+ "avac.avisoBancario.id = avisoBancario.id and "
						+ "avac.indicadorCreditoDebito = 1 "
						+ "and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao1, "
						+ // 13
						"(select sum(avac.valorAcerto) " + "from AvisoAcerto  avac " + "where "
						+ "avac.avisoBancario.id = avisoBancario.id and " + "avac.indicadorCreditoDebito = 2 "
						+ "and avac.indicadorArrecadacaoDevolucao = 2)as vlAcertosDevolucao2, " + // 14
						"avisoBancario.id, " + // 15

						"avisoBancario.numeroDocumento, " +
						// 16
						"avisoBancario.arrecadadorMovimento.numeroSequencialArquivo " +
						// 17
						"from AvisoBancario avisoBancario " + "left join avisoBancario.arrecadadorMovimento";

		if(avisoBancarioHelper.getIdConcessionaria() != null
						|| (avisoBancarioHelper.getCdConvenio() != null && !avisoBancarioHelper.getCdConvenio().equals(""))){
			retorno += "\n inner join avisoBancario.arrecadador.arrecadadorContratos arrecadadorContrato";

			if(avisoBancarioHelper.getCdConvenio() != null && !avisoBancarioHelper.getCdConvenio().equals("")){
				retorno += " inner join avisoBancario.arrecadadorMovimento arrecadadorMovimento";
			}
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 1200
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os daods de ContaImpostosDeduzidos dos pagamentos classificados
	 * de contas para acumular o valor do imposto por localidade e categoria e
	 * tipo de imposto.
	 * 
	 * @author Pedro ALexandre
	 * @date 15/12/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idTipoImposto
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpostosDeduzidosPagamentosClassificadosContaPorTipoImposto(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idTipoImposto) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select cnid.valorImposto, imov.id " + "from ContaImpostosDeduzidos cnid " + "inner join cnid.conta cnta "
							+ "inner join cnta.imovel imov " + "inner join cnid.impostoTipo imtp " + "where imtp.id = :idImpostoTipo "
							+ "and cnid.conta.id in ( select distinct(cnta.id) " + "from Pagamento pgmt " + "inner join pgmt.conta cnta "
							+ "inner join pgmt.localidade loca " + "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and loca.id = :idLocalidade " + "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and cnta.id is not null " + ") ";

			retorno = session.createQuery(consulta).setInteger("idImpostoTipo", idTipoImposto).setInteger("idLocalidade", idLocalidade)
							.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger("idPagamentoClassificado",
											PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
											PagamentoSituacao.VALOR_A_BAIXAR).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 18/12/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
					Integer idSituacaoAnterior) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select pgmt.valorExcedente, imov.id from Pagamento pgmt " + "inner join pgmt.localidade loca "
							+ "left join pgmt.imovel imov " + "where loca.id= :idLocalidade "
							+ "and pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " "
							+ "and pgmt.pagamentoSituacaoAnterior.id = :idSituacaoAnterior";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAnterior",
							idSituacaoAnterior).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 18/12/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idDevolucaoSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesNaoClassificadasMesPorSituacaoAtual(Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
					Integer idDevolucaoSituacaoAtual) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select devl.valorDevolucao, imov.id from Devolucao devl " + "inner join devl.localidade loca "
							+ "left join devl.imovel imov " + "left join devl.devolucaoSituacaoAtual dvst "
							+ "where devl.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao and "
							+ "dvst.id = :idDevolucaoSituacaoAtual and " + "loca.id = :idLocalidade";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idDevolucaoSituacaoAtual", idDevolucaoSituacaoAtual).setInteger("idLocalidade", idLocalidade).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 18/12/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idImpostoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idImpostoTipo) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select cnid.valorImposto, imov.id " + "from ContaImpostosDeduzidos cnid " + "inner join cnid.conta cnta "
							+ "inner join cnta.imovel imov " + "inner join cnid.impostoTipo imtp " + "where imtp.id = :idImpostoTipo "
							+ "and cnta.id in ( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade and " + "(pgmt.pagamentoSituacaoAtual.id = "
							+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " + "pgmt.pagamentoSituacaoAtual.id = "
							+ PagamentoSituacao.VALOR_A_BAIXAR + ") " + "and pgmt.conta.id is not null )";
			// + "order by pgmt.conta.id) ";

			retorno = session.createQuery(consulta).setInteger("idImpostoTipo", idImpostoTipo).setInteger("idLocalidade", idLocalidade)
							.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 18/12/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idPagamentoSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idPagamentoSituacaoAnterior) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select pgmt.valorExcedente, imov.id from Pagamento pgmt " + "inner join pgmt.localidade loca "
							+ "left join pgmt.imovel imov " + "left join pgmt.pagamentoSituacaoAtual pgstatual "
							+ "left join pgmt.pagamentoSituacaoAnterior pgstanterior " + "where loca.id = :idLocalidade "
							+ "and pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
							+ "and pgstatual.id = :idPagamentoSituacaoAtual " + "and pgstanterior.id = :idPagamentoSituacaoAnterior";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).setInteger("idPagamentoSituacaoAnterior", idPagamentoSituacaoAnterior).setInteger(
							"idPagamentoSituacaoAtual", PagamentoSituacao.VALOR_A_BAIXAR).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 18/12/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idPagamentoSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(Integer anoMesReferenciaArrecadacao,
					Integer idLocalidade, Integer idPagamentoSituacaoAtual) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select pgmt.valorExcedente, imov.id, pgmt.valorPagamento from Pagamento pgmt " + "inner join pgmt.localidade loca "
							+ "left join pgmt.imovel imov " + "left join pgmt.pagamentoSituacaoAtual pgstatual "
							+ "where loca.id= :idLocalidade " + "and pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
							+ "and pgstatual.id = :idPagamentoSituacaoAtual";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).setInteger("idPagamentoSituacaoAtual", idPagamentoSituacaoAtual).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro ALexandre
	 * @date 18/12/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idDevolucaoSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDevolucoesNaoClassificadasMesEAnterioresPorSituacaoAtual(Integer anoMesReferenciaArrecadacao,
					Integer idLocalidade, Integer idDevolucaoSituacaoAtual) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select devl.valorDevolucao, imov.id from Devolucao devl " + "inner join devl.localidade loca "
							+ "left join devl.imovel imov " + "left join devl.devolucaoSituacaoAtual dvstatual "
							+ "where devl.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao and "
							+ "dvstatual.id = :idDevolucaoSituacaoAtual" + " and " + "loca.id = :idLocalidade";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idDevolucaoSituacaoAtual", idDevolucaoSituacaoAtual).setInteger("idLocalidade", idLocalidade).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 16/12/2006
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
					Integer idSituacaoAtual) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select pgmt.valorPagamento, imov.id from Pagamento pgmt " + "inner join pgmt.localidade loca "
							+ "left join pgmt.imovel imov " + "where loca.id= :idLocalidade "
							+ "and pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " "
							+ "and pgmt.pagamentoSituacaoAtual.id = :idSituacaoAtual";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).setInteger("idSituacaoAtual", idSituacaoAtual).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoImovelAmbosRelatorio(String idImovel) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "SELECT pagto.pgmt_id as idPagamento, loc.loca_id as idLocalidade, loc.loca_nmlocalidade as nomeLocalidade, "
							+ "gr.greg_id as idGerencia, gr.greg_nmregional as nomeGerencia, imov.imov_id as idImovel, cli.clie_id as idCliente, cli.clie_nmcliente as nomeCliente, "
							+ "cliArrec.clie_nmcliente as nomeClienteArrecadador, pagto.pgmt_dtpagamento as dataPagamento, "
							+ "pagto.pgmt_amreferenciapagamento as anoMesReferenciaPagamento, dbtp.dbtp_dsdebitotipo as descricaoDebitoTipo, "
							+ "conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, conta.cnta_vldebitos as debitosConta, "
							+ "conta.cnta_vlcreditos as valorCreditos, dbcb.dbac_vldebito as valorDebitoACobrar, dbcb.dbac_nnprestacaodebito as numeroPrestacaoDebito, "
							+ "dbcb.dbac_nnprestacaocobradas as numeroPrestacaoCobradas, gpag.gpag_vldebito as valorDebitoGuia, pagto.pgmt_vlpagamento as valorPagamento, "
							+ "pagtoSitAtual.pgst_id as idPagamentoSituacao, pagtoSitAtual.pgst_dsabreviado as descricaoPagamentoSituacao, doctoTp.dotp_id as idDocumentoTipo, "
							// +
							// "doctoTp.dotp_dsdocumentotipo as descricaoDocumentoTipo, pagtoSitAnterior.pgst_dsabreviado as descricaoPagamentoSituacaoAnterior "
							+ "doctoTp.dotp_dsdocumentotipo as descricaoDocumentoTipo, pagtoSitAnterior.pgst_dsabreviado as descPagSituacaoAnterior, "
							+ "conta.cnta_dtvencimentoconta as dataVencimentoConta, pagto.gpag_id as idGuiaPagamento, pagto.pgmt_nnprestacao as numeroPrestacao, "
							+ "gpagpres.gppr_dtvencimento as dataVencimentoGuia, dbhi.dbac_id as iDdebitoACobrarHistorico, dbcb.dbac_id as iDdebitoACobrar "
							+ "FROM pagamento pagto " + "INNER JOIN localidade loc on pagto.loca_id = loc.loca_id "
							+ "INNER JOIN gerencia_regional gr on loc.greg_id = gr.greg_id "
							+ "INNER JOIN documento_tipo doctoTp on pagto.dotp_id = doctoTp.dotp_id "
							+ "INNER JOIN imovel imov on pagto.imov_id = imov.imov_id "
							+ "LEFT OUTER JOIN aviso_bancario avbc on pagto.avbc_id = avbc.avbc_id "
							+ "LEFT OUTER JOIN arrecadador arrec on avbc.arrc_id = arrec.arrc_id "
							+ "LEFT OUTER JOIN cliente cliArrec on arrec.clie_id = cliArrec.clie_id "
							+ "LEFT OUTER JOIN cliente cli on pagto.clie_id = cli.clie_id "
							+ "LEFT OUTER JOIN debito_tipo dbtp on pagto.dbtp_id = dbtp.dbtp_id "
							+ "LEFT OUTER JOIN conta conta on pagto.cnta_id = conta.cnta_id "
							+ "LEFT OUTER JOIN guia_pagamento gpag on pagto.gpag_id = gpag.gpag_id "
							+ "LEFT OUTER JOIN guia_pagamento_prestacao gpagpres ON ( gpag.gpag_id = gpagpres.gpag_id AND gpagpres.gppr_nnprestacao = pagto.pgmt_nnprestacao ) "
							+ "LEFT OUTER JOIN guia_pagamento_prestacao_hist gpagpreshist ON ( gpag.gpag_id  = gpagpreshist.gpag_id AND gpagpreshist.gpph_nnprestacao = pagto.pgmt_nnprestacao ) "
							+ "LEFT OUTER JOIN debito_a_cobrar dbcb on pagto.dbac_id = dbcb.dbac_id "
							+ "LEFT OUTER JOIN debito_a_cobrar_historico dbhi on pagto.dbac_id = dbhi.dbac_id "
							+ "LEFT OUTER JOIN pagamento_situacao pagtoSitAtual on pagto.pgst_idatual = pagtoSitAtual.pgst_id "
							+ "LEFT OUTER JOIN pagamento_situacao pagtoSitAnterior on pagto.pgst_idanterior = pagtoSitAnterior.pgst_id "
							+ "LEFT OUTER JOIN arrecadador_movimento_item arrecMovItem on pagto.amit_id = arrecMovItem.amit_id "
							+ "LEFT OUTER JOIN arrecadador_movimento arrecMov on arrecMovItem.armv_id = arrecMov.armv_id "
							+ "LEFT OUTER JOIN arrecadacao_forma arrecForma on pagto.arfm_id = arrecForma.arfm_id "
							+ "WHERE pagto.imov_id = "
							+ idImovel
							+ " UNION "
							+ "SELECT pagto.pghi_id as idPagamento, loc.loca_id as idLocalidade, loc.loca_nmlocalidade as nomeLocalidade, "
							+ "gr.greg_id as idGerencia, gr.greg_nmregional as nomeGerencia, imov.imov_id as idImovel, cli.clie_id as idCliente, cli.clie_nmcliente as nomeCliente, "
							+ "cliArrec.clie_nmcliente as nomeClienteArrecadador, pagto.pghi_dtpagamento as dataPagamento, "
							+ "pagto.pghi_amreferenciapagamento as anoMesReferenciaPagamento, dbtp.dbtp_dsdebitotipo as descricaoDebitoTipo, "
							+ "contahist.cnhi_vlagua as valorAgua, contahist.cnhi_vlesgoto as valorEsgoto, contahist.cnhi_vldebitos as debitosConta, "
							+ "contahist.cnhi_vlcreditos as valorCreditos, dbhi.dahi_vldebito as valorDebitoACobrar, dbhi.dahi_nnprestacaodebito as numeroPrestacaoDebito, "
							+ "dbhi.dahi_nnprestacaocobradas as numeroPrestacaoCobradas, gpag.gpag_vldebito as valorDebitoGuia, pagto.pghi_vlpagamento as valorPagamento, "
							+ "pagtoSitAtual.pgst_id as idPagamentoSituacao, pagtoSitAtual.pgst_dsabreviado as descricaoPagamentoSituacao, doctoTp.dotp_id as idDocumentoTipo, "
							// +
							// "doctoTp.dotp_dsdocumentotipo as descricaoDocumentoTipo, pagtoSitAnterior.pgst_dsabreviado as descricaoPagamentoSituacaoAnterior "
							+ "doctoTp.dotp_dsdocumentotipo as descricaoDocumentoTipo, pagtoSitAnterior.pgst_dsabreviado as descPagSituacaoAnterior, "
							+ "contahist.cnhi_dtvencimentoconta as dataVencimentoConta, pagto.gpag_id as idGuiaPagamento, pagto.pghi_nnprestacao as numeroPrestacao, "
							+ "gpagpreshist.gpph_dtvencimento as dataVencimentoGuia, dbhi.dbac_id as iDdebitoACobrarHistorico, dbcb.dbac_id as iDdebitoACobrar "
							+ "FROM pagamento_historico pagto "
							+ "INNER JOIN localidade loc on pagto.loca_id = loc.loca_id "
							+ "INNER JOIN gerencia_regional gr on loc.greg_id = gr.greg_id "
							+ "INNER JOIN documento_tipo doctoTp on pagto.dotp_id = doctoTp.dotp_id "
							+ "INNER JOIN imovel imov on pagto.imov_id = imov.imov_id "
							+ "LEFT OUTER JOIN aviso_bancario avbc on pagto.avbc_id = avbc.avbc_id "
							+ "LEFT OUTER JOIN arrecadador arrec on avbc.arrc_id = arrec.arrc_id "
							+ "LEFT OUTER JOIN cliente cliArrec on arrec.clie_id = cliArrec.clie_id "
							+ "LEFT OUTER JOIN cliente cli on pagto.clie_id = cli.clie_id "
							+ "LEFT OUTER JOIN debito_tipo dbtp on pagto.dbtp_id = dbtp.dbtp_id "
							+ "LEFT OUTER JOIN conta_historico contahist on pagto.cnta_id = contahist.cnta_id "
							+ "LEFT OUTER JOIN guia_pagamento gpag on pagto.gpag_id = gpag.gpag_id "
							+ "LEFT OUTER JOIN guia_pagamento_prestacao gpagpres ON ( gpag.gpag_id = gpagpres.gpag_id AND gpagpres.gppr_nnprestacao = pagto.pghi_nnprestacao ) "
							+ "LEFT OUTER JOIN guia_pagamento_prestacao_hist gpagpreshist ON ( gpag.gpag_id  = gpagpreshist.gpag_id AND gpagpreshist.gpph_nnprestacao = pagto.pghi_nnprestacao ) "
							+ "LEFT OUTER JOIN debito_a_cobrar dbcb on pagto.dbac_id = dbcb.dbac_id "
							+ "LEFT OUTER JOIN debito_a_cobrar_historico dbhi on pagto.dbac_id = dbhi.dbac_id "
							+ "LEFT OUTER JOIN pagamento_situacao pagtoSitAtual on pagto.pgst_idatual = pagtoSitAtual.pgst_id "
							+ "LEFT OUTER JOIN pagamento_situacao pagtoSitAnterior on pagto.pgst_idanterior = pagtoSitAnterior.pgst_id "
							+ "LEFT OUTER JOIN arrecadador_movimento_item arrecMovItem on pagto.amit_id = arrecMovItem.amit_id "
							+ "LEFT OUTER JOIN arrecadador_movimento arrecMov on arrecMovItem.armv_id = arrecMov.armv_id "
							+ "LEFT OUTER JOIN arrecadacao_forma arrecForma on pagto.arfm_id = arrecForma.arfm_id "
							+ "WHERE pagto.imov_id = "
							+ idImovel
							+ " ORDER BY anoMesReferenciaPagamento desc, idDocumentoTipo, "
							+ " dataPagamento ";

			retorno = session.createSQLQuery(hql).addScalar("idPagamento", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
							.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("idGerencia", Hibernate.INTEGER).addScalar(
											"nomeGerencia", Hibernate.STRING).addScalar("idImovel", Hibernate.INTEGER).addScalar(
											"idCliente", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING).addScalar(
											"nomeClienteArrecadador", Hibernate.STRING).addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("anoMesReferenciaPagamento", Hibernate.INTEGER).addScalar("descricaoDebitoTipo", Hibernate.STRING)
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar(
											"debitosConta", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitoACobrar", Hibernate.BIG_DECIMAL).addScalar("numeroPrestacaoDebito", Hibernate.SHORT)
							.addScalar("numeroPrestacaoCobradas", Hibernate.SHORT).addScalar("valorDebitoGuia", Hibernate.BIG_DECIMAL)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("idPagamentoSituacao", Hibernate.INTEGER)
							.addScalar("descricaoPagamentoSituacao", Hibernate.STRING)
							.addScalar("idDocumentoTipo", Hibernate.INTEGER)
							.addScalar("descricaoDocumentoTipo", Hibernate.STRING)
							// .addScalar("descricaoPagamentoSituacaoAnterior",
							.addScalar("descPagSituacaoAnterior", Hibernate.STRING).addScalar("dataVencimentoConta", Hibernate.DATE)
							.addScalar("idGuiaPagamento", Hibernate.INTEGER).addScalar("numeroPrestacao", Hibernate.INTEGER).addScalar(
											"dataVencimentoGuia", Hibernate.DATE).addScalar("iDdebitoACobrarHistorico", Hibernate.INTEGER)
							.addScalar("iDdebitoACobrar", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o imóvel pelo id fazendo os carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return Imovel
	 * @throws ErroRepositorioException
	 */
	public Imovel pesquisarImovelPagamento(Integer idImovel) throws ErroRepositorioException{

		Imovel imovel = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "SELECT imov " + " FROM Imovel imov " + " INNER JOIN FETCH imov.localidade loc "
							+ " INNER JOIN FETCH imov.setorComercial sc " + " INNER JOIN FETCH sc.municipio municipioSc "
							+ " INNER JOIN FETCH municipioSc.unidadeFederacao unidFedSc " + " INNER JOIN FETCH imov.quadra quadra "
							+ " INNER JOIN FETCH imov.ligacaoAguaSituacao ligAguaSit "
							+ " INNER JOIN FETCH imov.ligacaoEsgotoSituacao ligEsgSit "
							+ " LEFT JOIN FETCH imov.logradouroBairro logrBairro " + " LEFT JOIN FETCH logrBairro.bairro bairro "
							+ " LEFT JOIN FETCH bairro.municipio municipioBairro "
							+ " LEFT JOIN FETCH municipioBairro.unidadeFederacao unidFedBairro "
							+ " LEFT JOIN FETCH imov.logradouroCep logrCep " + " LEFT JOIN FETCH logrCep.logradouro logr "
							+ " LEFT JOIN FETCH logrCep.cep cep " + " LEFT JOIN FETCH logr.logradouroTipo logrTp "
							+ " LEFT JOIN FETCH logr.logradouroTitulo logrTit " + " LEFT JOIN FETCH imov.enderecoReferencia endRef "
							+ " WHERE imov.id = :idImovel ";

			imovel = (Imovel) session.createQuery(hql).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return imovel;

	}

	/**
	 * Pesquisa o cliente pelo id fazendo os carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @author Virgínia Melo
	 * @date 06/04/2009
	 *       Adicionado join com Profissão.
	 * @return Cliente
	 * @throws ErroRepositorioException
	 */
	public Cliente pesquisarClientePagamento(Integer idCliente) throws ErroRepositorioException{

		Cliente cliente = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "SELECT cli " + " FROM Cliente cli " + " INNER JOIN FETCH cli.clienteTipo cliTp "
							+ " LEFT JOIN FETCH cli.ramoAtividade ramo " + " LEFT JOIN FETCH cli.profissao prof "
							+ " WHERE cli.id = :idCliente ";

			cliente = (Cliente) session.createQuery(hql).setInteger("idCliente", idCliente).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return cliente;

	}

	/**
	 * Pesquisa o endereço de correspondência do cliente pelo seu id fazendo os
	 * carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return ClienteEndereco
	 * @throws ErroRepositorioException
	 */
	public ClienteEndereco pesquisarClienteEnderecoPagamento(Integer idCliente) throws ErroRepositorioException{

		ClienteEndereco clienteEndereco = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "SELECT cliEnd " + " FROM ClienteEndereco cliEnd " + " INNER JOIN FETCH cliEnd.cliente cli "
							+ " LEFT JOIN FETCH cliEnd.logradouroCep logrCep " + " LEFT JOIN FETCH cliEnd.enderecoReferencia endRef "
							+ " LEFT JOIN FETCH cliEnd.logradouroBairro logrBairro " + " LEFT JOIN FETCH logrCep.cep cep "
							+ " LEFT JOIN FETCH logrCep.logradouro logr " + " LEFT JOIN FETCH logr.municipio municipioLogr "
							+ " LEFT JOIN FETCH municipioLogr.unidadeFederacao unidFedLogr "
							+ " LEFT JOIN FETCH logr.logradouroTipo logrTp " + " LEFT JOIN FETCH logr.logradouroTitulo logrTit "
							+ " LEFT JOIN FETCH logrBairro.bairro bairro " + " LEFT JOIN FETCH bairro.municipio municipioBairro "
							+ " LEFT JOIN FETCH municipioBairro.unidadeFederacao unidFedBairro " + " WHERE cli.id = :idCliente "
							+ " AND cliEnd.indicadorEnderecoCorrespondencia = "
							+ ClienteEndereco.INDICADOR_ENDERECO_CORRESPONDENCIA.toString();

			clienteEndereco = (ClienteEndereco) session.createQuery(hql).setInteger("idCliente", idCliente).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return clienteEndereco;

	}

	/**
	 * Pesquisa o telefone padrão do cliente pelo seu id fazendo os
	 * carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return ClienteFone
	 * @throws ErroRepositorioException
	 */
	public ClienteFone pesquisarClienteFonePagamento(Integer idCliente) throws ErroRepositorioException{

		ClienteFone clienteFone = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "SELECT cliFone " + " FROM ClienteFone cliFone " + " INNER JOIN FETCH cliFone.foneTipo foneTp "
							+ " INNER JOIN cliFone.cliente cli " + " WHERE cli.id = :idCliente "
							+ " AND cliFone.indicadorTelefonePadrao = " + ClienteFone.INDICADOR_FONE_PADRAO.toString();

			clienteFone = (ClienteFone) session.createQuery(hql).setInteger("idCliente", idCliente).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return clienteFone;

	}

	/**
	 * Pesquisa os clientes do imóvel pelo seu id do imóvel fazendo os
	 * carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return Collection<ClienteImovel>
	 * @throws ErroRepositorioException
	 */
	public Collection<ClienteImovel> pesquisarClientesImoveisPagamento(Integer idImovel) throws ErroRepositorioException{

		Collection<ClienteImovel> retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "SELECT cliImovel " + " FROM ClienteImovel cliImovel " + " INNER JOIN FETCH cliImovel.cliente cli "
							+ " INNER JOIN FETCH cliImovel.clienteRelacaoTipo crtp " + " INNER JOIN cliImovel.imovel imov "
							+ " WHERE imov.id = :idImovel ";

			retorno = session.createQuery(hql).setInteger("idImovel", idImovel).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarMovimentoArrecadadorParaRelatorio(String codigoBanco, String codigoRemessa,
					String descricaoIdentificacaoServico, String numeroSequencialArquivo, Date dataGeracaoInicio, Date dataGeracaoFim,
					Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia, String indicadorAceitacao,
					String indicadorAbertoFechado, String idConcessionaria) throws ErroRepositorioException{

		Collection retorno = null;
		StringBuilder sql = new StringBuilder();

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisMovimentoArrecadador(codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
							null, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim, ultimaAlteracaoInicio, ultimaAlteracaoFim,
							descricaoOcorrencia, indicadorAceitacao);

			String condicionaisConcessionaria = "";

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				condicionaisConcessionaria = " WHERE idConcessionaria = :idConcessionaria ";
			}

			sql.append("       SELECT codBanco, ");
			sql.append("       codRemessa, ");
			sql.append("       descIdentServico, ");
			sql.append("       numeroSeqArquivo, ");
			sql.append("       id, ");
			sql.append("       dataGeracao, ");
			sql.append("       numRegistroMovimento, ");
			sql.append("       vlTotalMovimento, ");
			sql.append("       ultimaAlteracao, ");
			sql.append("       nomeBanco, ");
			sql.append("       idConcessionaria, ");
			sql.append("       nomeConcessionaria ");
			sql.append("       FROM (SELECT arrecadadorMovimento.armv_cdbanco AS codBanco, ");
			sql.append("             arrecadadorMovimento.armv_cdremessa AS codRemessa, ");
			sql.append("             arrecadadorMovimento.armv_dsidentificacaoservico AS descIdentServico, ");
			sql.append("             arrecadadorMovimento.armv_nnnsa AS numeroSeqArquivo, ");
			sql.append("             arrecadadorMovimento.armv_id AS id, ");
			sql.append("             arrecadadorMovimento.armv_dtgeracao AS dataGeracao, ");
			sql.append("             arrecadadorMovimento.armv_nnregistrosmovimento AS numRegistroMovimento, ");
			sql.append("             arrecadadorMovimento.armv_vltotalmovimento AS vlTotalMovimento, ");
			sql.append("             arrecadadorMovimento.armv_tmultimaalteracao AS ultimaAlteracao, ");
			sql.append("             arrecadadorMovimento.armv_nmbanco AS nomeBanco, ");
			sql.append("             (CASE arrecadadorMovimento.armv_dsidentificacaoservico WHEN 'DEBITO AUTOMATICO' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconveniodebaut = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              WHEN 'COBRANCA BANCARIA' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconvenioboleto = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              ELSE ");
			sql.append("               (SELECT concessionaria.conc_id ");
			sql.append("                FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("                INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("                WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                  AND arrecadadorContrato.arct_cdconvenio = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              END) AS idConcessionaria, ");
			sql.append("             (CASE arrecadadorMovimento.armv_dsidentificacaoservico WHEN 'DEBITO AUTOMATICO' then ");
			sql.append("              (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconveniodebaut = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              WHEN 'COBRANCA BANCARIA' then ");
			sql.append("              (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconvenioboleto = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              ELSE ");
			sql.append("               (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("                FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("                INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("                WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                  AND arrecadadorContrato.arct_cdconvenio = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              END) AS nomeConcessionaria ");
			sql.append("             FROM arrecadador_movimento arrecadadorMovimento ");
			sql.append(condicionais);
			sql.append("            ) tabAux1 ");
			sql.append(condicionaisConcessionaria);

			sql.append(" ORDER BY codBanco, numeroSeqArquivo DESC ");

			SQLQuery sqlQuery = session.createSQLQuery(sql.toString());
			sqlQuery.addScalar("codBanco", Hibernate.SHORT);
			sqlQuery.addScalar("codRemessa", Hibernate.SHORT);
			sqlQuery.addScalar("descIdentServico", Hibernate.STRING);
			sqlQuery.addScalar("numeroSeqArquivo", Hibernate.INTEGER);
			sqlQuery.addScalar("id", Hibernate.INTEGER);
			sqlQuery.addScalar("dataGeracao", Hibernate.DATE);
			sqlQuery.addScalar("numRegistroMovimento", Hibernate.INTEGER);
			sqlQuery.addScalar("vlTotalMovimento", Hibernate.BIG_DECIMAL);
			sqlQuery.addScalar("ultimaAlteracao", Hibernate.TIMESTAMP);
			sqlQuery.addScalar("nomeBanco", Hibernate.STRING);
			sqlQuery.addScalar("idConcessionaria", Hibernate.INTEGER);
			sqlQuery.addScalar("nomeConcessionaria", Hibernate.STRING);

			if(ultimaAlteracaoInicio != null && !ultimaAlteracaoInicio.equals("")){
				Date dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);

				sqlQuery.setTimestamp("ultimaAlteracaoInicio", dataInicio);
			}

			if(ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")){
				Date dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);

				sqlQuery.setTimestamp("ultimaAlteracaoFim", dataFim);
			}

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				sqlQuery.setString("idConcessionaria", idConcessionaria);
			}

			retorno = sqlQuery.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 04/01/07
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @throws ControladorException
	 */
	public Integer filtrarMovimentoArrecadadoresRelatorioCount(String codigoBanco, String codigoRemessa,
					String descricaoIdentificacaoServico, String numeroSequencialArquivo, Date dataGeracaoInicio, Date dataGeracaoFim,
					Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia, String indicadorAceitacao,
					String indicadorAbertoFechado, String idConcessionaria) throws ErroRepositorioException{

		Integer movimentoArrecadadorCount = null;
		StringBuilder sql = new StringBuilder();

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisMovimentoArrecadador(codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
							null, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim, ultimaAlteracaoInicio, ultimaAlteracaoFim,
							descricaoOcorrencia, indicadorAceitacao);

			String condicionaisConcessionaria = "";

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				condicionaisConcessionaria = " WHERE idConcessionaria = :idConcessionaria ";
			}

			sql.append(" SELECT COUNT(id) as qtdeMovimentoArrecadador ");
			sql.append(" FROM (SELECT codBanco, ");
			sql.append("       codRemessa, ");
			sql.append("       descIdentServico, ");
			sql.append("       numeroSeqArquivo, ");
			sql.append("       id, ");
			sql.append("       dataGeracao, ");
			sql.append("       numRegistroMovimento, ");
			sql.append("       vlTotalMovimento, ");
			sql.append("       ultimaAlteracao, ");
			sql.append("       nomeBanco, ");
			sql.append("       idConcessionaria ");
			sql.append("       FROM (SELECT arrecadadorMovimento.armv_cdbanco AS codBanco, ");
			sql.append("             arrecadadorMovimento.armv_cdremessa AS codRemessa, ");
			sql.append("             arrecadadorMovimento.armv_dsidentificacaoservico AS descIdentServico, ");
			sql.append("             arrecadadorMovimento.armv_nnnsa AS numeroSeqArquivo, ");
			sql.append("             arrecadadorMovimento.armv_id AS id, ");
			sql.append("             arrecadadorMovimento.armv_dtgeracao AS dataGeracao, ");
			sql.append("             arrecadadorMovimento.armv_nnregistrosmovimento AS numRegistroMovimento, ");
			sql.append("             arrecadadorMovimento.armv_vltotalmovimento AS vlTotalMovimento, ");
			sql.append("             arrecadadorMovimento.armv_tmultimaalteracao AS ultimaAlteracao, ");
			sql.append("             arrecadadorMovimento.armv_nmbanco AS nomeBanco, ");
			sql.append("             (CASE arrecadadorMovimento.armv_dsidentificacaoservico WHEN 'DEBITO AUTOMATICO' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconveniodebaut = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              WHEN 'COBRANCA BANCARIA' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconvenioboleto = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              ELSE ");
			sql.append("               (SELECT concessionaria.conc_id ");
			sql.append("                FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("                INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("                WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                  AND arrecadadorContrato.arct_cdconvenio = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              END) AS idConcessionaria ");
			sql.append("             FROM arrecadador_movimento arrecadadorMovimento ");
			sql.append(condicionais);
			sql.append("            ) tabAux1 ");
			sql.append(condicionaisConcessionaria);
			sql.append(" ) tabAux2 ");

			SQLQuery sqlQuery = session.createSQLQuery(sql.toString());
			sqlQuery.addScalar("qtdeMovimentoArrecadador", Hibernate.INTEGER);

			if(ultimaAlteracaoInicio != null && !ultimaAlteracaoInicio.equals("")){
				Date dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);

				sqlQuery.setTimestamp("ultimaAlteracaoInicio", dataInicio);
			}

			if(ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")){
				Date dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);

				sqlQuery.setTimestamp("ultimaAlteracaoFim", dataFim);
			}

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				sqlQuery.setString("idConcessionaria", idConcessionaria);
			}

			movimentoArrecadadorCount = (Integer) sqlQuery.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return movimentoArrecadadorCount;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa a coleção de guias de pagamento categoria para o id da guia
	 * informada.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param idGuiaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoCategoria(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select guiaPagamentoCategoria " + "from GuiaPagamentoCategoria guiaPagamentoCategoria "
							+ "inner join guiaPagamentoCategoria.guiaPagamento guiaPagamento "
							+ "where guiaPagamento.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa a coleção de guias de pagamento categoria para o id da guia
	 * informada.
	 * 
	 * @author Vitor
	 * @date 14/08/2008
	 * @param idGuiaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoPrestacao(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select guiaPagamentoPrestacao "

			+ "from GuiaPagamentoPrestacao guiaPagamentoPrestacao "

			+ "where guiaPagamentoPrestacao.guiaPagamento.id = :idGuiaPagamento";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa a coleção de cliente de guias de pagamento para o id da guia
	 * informada.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param idGuiaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteGuiaPagamento(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select clienteGuiaPagamento " + "from ClienteGuiaPagamento clienteGuiaPagamento "
							+ "inner join clienteGuiaPagamento.guiaPagamento guiaPagamento " + "where guiaPagamento.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a coleção de "cliente de guias de pagamento histórico" para o id da guia informada.
	 * 
	 * @author Saulo Lima
	 * @date 13/07/2009
	 * @param idGuiaPagamentoHistorico
	 * @return Collection<ClienteGuiaPagamentoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<ClienteGuiaPagamentoHistorico> pesquisarClienteGuiaPagamentoHistorico(Integer idGuiaPagamentoHistorico)
					throws ErroRepositorioException{

		Collection<ClienteGuiaPagamentoHistorico> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT clienteGuiaPagamentoHistorico " + "FROM ClienteGuiaPagamentoHistorico clienteGuiaPagamentoHistorico "
							+ "INNER JOIN  fetch clienteGuiaPagamentoHistorico.guiaPagamentoHistorico guiaPagamentoHistorico "
							+ "INNER JOIN  fetch clienteGuiaPagamentoHistorico.cliente cliente "
							+ "INNER JOIN  fetch clienteGuiaPagamentoHistorico.clienteRelacaoTipo clienteRelacaoTipo "
							+ "WHERE guiaPagamentoHistorico.id = :idGuiaPagamentoHistorico";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamentoHistorico", idGuiaPagamentoHistorico).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Para cada guia de pagamento transferida para o histórico atualiza o
	 * indicador de que a guia de pagamento está no histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param idsGuiasPagamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorGuiaPagamentoNoHistorico(Collection idsGuiasPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarGuiaPagamentoGeral;

		try{
			atualizarGuiaPagamentoGeral = "update GuiaPagamentoGeral gpge "
							+ "set gpge.indicadorHistorico = :indicadorHistorico, gpge.ultimaAlteracao = :dataUltimaAlteracao where gpge.id in (:idsGuiasPagamento)";

			session.createQuery(atualizarGuiaPagamentoGeral).setInteger("indicadorHistorico", ConstantesSistema.SIM).setDate(
							"dataUltimaAlteracao", new Date()).setParameterList("idsGuiasPagamento", idsGuiasPagamento).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Atualiza o ano/mês de referência da arrecadação.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param anoMesArrecadacaoAtual
	 * @param anoMesArrecadacaoNovo
	 * @throws ErroRepositorioException
	 */
	public void atualizarAnoMesArrecadacao(int anoMesArrecadacaoAtual, int anoMesArrecadacaoNovo) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarAnoMesArrecadacao;

		try{
			atualizarAnoMesArrecadacao = "update SistemaParametro " + "set parm_amreferenciaarrecadacao = " + anoMesArrecadacaoNovo + " "
							+ "where parm_amreferenciaarrecadacao = :anoMesArrecadacaoAtual and parmId = "
							+ ConstantesConfig.getIdEmpresa();

			session.createQuery(atualizarAnoMesArrecadacao).setInteger("anoMesArrecadacaoAtual", anoMesArrecadacaoAtual).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa as contas correspondentes aos pagamentos classificados de conta
	 * e os pagamentos anteriores de conta classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param numeroIndice
	 * @param quantidadeRegistros
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarContasDePagamentosClassificadosContaEPagamentosAnterioresContaClassificadosNoMes(
					Integer anoMesReferenciaArrecadacao, Integer idLocalidade, Integer numeroIndice, Integer quantidadeRegistros,
					Integer idSetorComercial) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select cnta.id from Conta cnta "
							+ "inner join cnta.quadraConta qdra "
							+ "inner join qdra.setorComercial stcm "
							+ "where cnta.id in "
							+ "(select distinct pgmt.conta.id from Pagamento pgmt where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) "
							+ " and pgmt.conta.id is not null and pgmt.localidade.id = :idLocalidade) "
							+ " and stcm.id = :idSetorComercial ";

			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idSetorComercial",
							idSetorComercial).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO).setInteger("idPagamentoValorABaixar",
							PagamentoSituacao.VALOR_A_BAIXAR).setMaxResults(quantidadeRegistros).setFirstResult(numeroIndice).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa as guias de pagamento correspondentes aos pagamentos
	 * classificados de guia de pagamento e aos pagamentos anteriores de guia de
	 * pagamento classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param numeroIndice
	 * @param quantidadeRegistros
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaPagamento> pesquisarGuiasPagamentoDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
					Integer anoMesReferenciaArrecadacao, Integer idLocalidade, Integer numeroIndice, Integer quantidadeRegistros)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<GuiaPagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select gpagGeral.guiaPagamento from Pagamento pgmt " + "inner join pgmt.guiaPagamentoGeral gpagGeral "
							+ "inner join pgmt.localidade loca "
							+ "where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or "
							+ "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.guiaPagamentoGeral.id is not null " + "and loca.id = :idLocalidade "
							+ "order by pgmt.guiaPagamentoGeral.id";
			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).setMaxResults(quantidadeRegistros).setFirstResult(numeroIndice).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa as guias de pagamento correspondentes aos pagamentos
	 * classificados de guia de pagamento e aos pagamentos anteriores de guia de
	 * pagamento classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaPagamento> pesquisarGuiasPagamentoDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
					Integer anoMesReferenciaArrecadacao, Integer idLocalidade) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<GuiaPagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			consulta = "select gpag from GuiaPagamento gpag "
							+ "inner join gpag.localidade loca "
							+ "where gpag.id in "
							+ "(select distinct pgmt.guiaPagamentoGeral.id from Pagamento pgmt where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO
							+ " or pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ " and pgmt.guiaPagamentoGeral.id is not null and pgmt.localidade.id = :idLocalidade) "
							+ " and loca.id = :idLocalidade ";

			/*
			 * // Cria o hql de pesquisa consulta = "select pgmt.guiaPagamento
			 * from Pagamento pgmt " + "inner join pgmt.localidade loca " +
			 * "where pgmt.anoMesReferenciaArrecadacao <=
			 * :anoMesReferenciaArrecadacao " + "and
			 * (pgmt.pagamentoSituacaoAtual.id = " +
			 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
			 * "pgmt.pagamentoSituacaoAtual.id = " +
			 * PagamentoSituacao.VALOR_A_BAIXAR + ") " + "and
			 * pgmt.guiaPagamento.id is not null " + "and loca.id =
			 * :idLocalidade " ;
			 */

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisar os pagamentos classificados ou com valor excedente baixado e
	 * com valor excedente maior do que zero para transferir para o histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param numeroIndice
	 * @param quantidadeRegistros
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarPagamentosClassificadosOuValorExcedenteBaixado(Integer anoMesReferenciaArrecadacao,
					Integer idLocalidade, int numeroIndice, int quantidadeRegistros) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Integer> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select pgmt.id from Pagamento pgmt "
							+ "inner join pgmt.localidade loca "
							+ "where ((loca.id= :idLocalidade) and "
							+ "(pgmt.pagamentoSituacaoAtual.id = :situacaoClassificado) "
							+ "and (pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao))"
							+ " or ((pgmt.pagamentoSituacaoAtual.id = :situacaoValorABaixar) and (pgmt.valorExcedente > 0) and (pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao)) "
							+ " order by pgmt.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).setInteger("situacaoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("situacaoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).setFirstResult(numeroIndice)
							.setMaxResults(quantidadeRegistros).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisar os pagamentos classificados ou com valor excedente baixado e
	 * com valor excedente maior do que zero para transferir para o histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentosClassificadosOuValorExcedenteBaixado(Integer anoMesReferenciaArrecadacao,
					Integer idLocalidade) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select pgmt from Pagamento pgmt " + "inner join pgmt.localidade loca " + "where loca.id= :idLocalidade and "
							+ "pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao " + "and pgmt.pagamentoSituacaoAtual.id = "
							+ PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or (pgmt.pagamentoSituacaoAtual.id = "
							+ PagamentoSituacao.VALOR_A_BAIXAR + " and pgmt.valorExcedente > 0) ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções classificadas para transferir para o histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param numeroIndice
	 * @param quantidadeRegistros
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesClassificadasPorLocalidade(Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
					Integer numeroIndice, Integer quantidadeRegistros) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select devl from Devolucao devl " + "inner join devl.localidade loca " + "where loca.id= :idLocalidade and "
							+ "devl.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao " + "and devl.devolucaoSituacaoAtual.id = "
							+ DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA + " order by devl.id";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).setMaxResults(quantidadeRegistros).setFirstResult(numeroIndice).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * O sistema seleciona a lista de pagamentos associados ao aviso bancário a
	 * partir da tabela PAGAMENTO com AVBC_ID=AVBC_ID da tabela AVISO_BANCARIO
	 * 
	 * @author Vivianne Sousa
	 * @date 17/01/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoPorAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "select pagamento " + "from gcom.arrecadacao.pagamento.Pagamento  pagamento "
							+ "where pagamento.avisoBancario.id = :idAvisoBancario ";

			retorno = session.createQuery(hql).setInteger("idAvisoBancario", idAvisoBancario).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Ana Maria
	 * @date 29/01/2007
	 * @param idGuiaPagamento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarGuiaPagamento(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT guiaPagamento " + "FROM GuiaPagamento guiaPagamento " + "WHERE guiaPagamento.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Atualiza logradouroBairro de um ou mais imóveis
	 * [UC0] Atualizar Logradouro
	 * 
	 * @author Raphael Rossiter
	 * @date 22/02/2007
	 * @param
	 * @return void
	 */
	public void atualizarLogradouroBairro(LogradouroBairro logradouroBairroAntigo, LogradouroBairro logradouroBairroNovo)
					throws ErroRepositorioException{

		String consulta = "";

		Session session = HibernateUtil.getSession();

		try{

			consulta = "UPDATE gcom.arrecadacao.banco.Agencia SET "
							+ "lgbr_id = :idLogradouroBairroNovo, agen_tmultimaalteracao = :ultimaAlteracao "
							+ "WHERE lgbr_id = :idLogradouroBairroAntigo ";

			session.createQuery(consulta).setInteger("idLogradouroBairroNovo", logradouroBairroNovo.getId()).setTimestamp(
							"ultimaAlteracao", new Date()).setInteger("idLogradouroBairroAntigo", logradouroBairroAntigo.getId())
							.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualiza logradouroCep de um ou mais imóveis
	 * [UC0] Atualizar Logradouro
	 * 
	 * @author Raphael Rossiter
	 * @date 22/02/2007
	 * @param
	 * @return void
	 */
	public void atualizarLogradouroCep(LogradouroCep logradouroCepAntigo, LogradouroCep logradouroCepNovo) throws ErroRepositorioException{

		String consulta = "";

		Session session = HibernateUtil.getSession();

		try{

			consulta = "UPDATE gcom.arrecadacao.banco.Agencia SET "
							+ "lgcp_id = :idLogradouroCepNovo, agen_tmultimaalteracao = :ultimaAlteracao "
							+ "WHERE lgcp_id = :idLogradouroCepAntigo ";

			session.createQuery(consulta).setInteger("idLogradouroCepNovo", logradouroCepNovo.getId()).setTimestamp("ultimaAlteracao",
							new Date()).setInteger("idLogradouroCepAntigo", logradouroCepAntigo.getId()).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa o cliente da guia de pagamento através do id da Guia de
	 * Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 28/02/2007
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarClienteDeGuiaPagamento(Integer idGuiaPagamento) throws ErroRepositorioException{

		// cria a variável que vai armazenar o objeto pesquisada
		Object[] retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select cli.id, cli.nome " + "from GuiaPagamento  guia " + "inner join guia.cliente cli "
							+ "where guia.id =:idGuiaPagamento ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento.intValue()).setMaxResults(1)
							.uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o cliente da guia de pagamento através do id da Guia de
	 * Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarImovelDeClienteGuiaPagamento(Integer idGuiaPagamento) throws ErroRepositorioException{

		// cria a variável que vai armazenar o objeto pesquisada
		Object[] retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select cli.id, cli.nome " + "from ClienteGuiaPagamento cgp " + "inner join cgp.cliente cli "
							+ "inner join cgp.clienteRelacaoTipo crtp " + "inner join cgp.guiaPagamento guia "
							+ "where  crtp.id = :clienteRelacaoTipo and guia.id =:idGuiaPagamento ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento.intValue()).setInteger(
							"clienteRelacaoTipo", ClienteRelacaoTipo.USUARIO).setMaxResults(1).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o cliente da guia de pagamento através do id da Guia de
	 * Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 28/02/2007
	 * @return String
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarClienteDeClienteImovel(Integer idGuiaPagamento) throws ErroRepositorioException{

		// cria a variável que vai armazenar o objeto pesquisada
		Object[] retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select " + "clie.clie_id as idCliente, " + "clie.clie_nmcliente as nomeCliente "
							+ "FROM guia_pagamento gp  " + "INNER JOIN imovel imov  on gp.imov_id = imov.imov_id  "
							+ "LEFT JOIN cliente_imovel cliImov on cliImov.imov_id = imov.imov_id "
							+ "LEFT JOIN cliente clie on cliImov.clie_id = clie.clie_id "
							+ "LEFT JOIN cliente_relacao_tipo crt on cliImov.crtp_id = crt.crtp_id " + "WHERE gp.gpag_id = "
							+ idGuiaPagamento + "AND crt.crtp_id = " + ClienteRelacaoTipo.USUARIO;

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar("idCliente", Hibernate.INTEGER).addScalar("nomeCliente",
							Hibernate.STRING).setMaxResults(1).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito - remover guia pagamento referente
	 * ao parcelamento
	 * remove a guia de pagamento do Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * @param
	 * @return void
	 */
	public void removerGuiaPagamentoPagamento(Integer idPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{

			String processarPagamentoConta = "UPDATE Pagamento " + "SET gpag_id = null, pgmt_tmultimaalteracao = :dataAlteracao "
							+ "WHERE pgmt_id =:idPagamento)";

			session.createQuery(processarPagamentoConta).setTimestamp("dataAlteracao", new Date()).setInteger("idPagamento", idPagamento)
							.executeUpdate();

		}catch(Exception e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito - remover guia pagamento referente
	 * ao parcelamento
	 * remove a guia de pagamento do Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * @param
	 * @return void
	 */
	public void removerGuiaPagamentoPagamentoHistorico(Integer idPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{

			String processarPagamentoConta = "UPDATE PagamentoHistorico " + "SET gpag_id = null, pgmt_tmultimaalteracao = :dataAlteracao "
							+ "WHERE pgmt_id =:idPagamento)";

			session.createQuery(processarPagamentoConta).setTimestamp("dataAlteracao", new Date()).setInteger("idPagamento", idPagamento)
							.executeUpdate();

		}catch(Exception e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * Pesquisa os ano/mês de referência dos pagamentos para ano/mês de
	 * referência maior ou igual ao ano/mês de referência atual da arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 07/03/2007
	 * @param anoMesArrecadacaoAtual
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesArrecadacaoPagamentoMaiorIgualAnoMesArrecadacaoAtual(Integer anoMesArrecadacaoAtual,
					Integer idLocalidade) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = "select distinct(pagamento.anoMesReferenciaArrecadacao) " + "from Pagamento pagamento "
							+ "inner join pagamento.localidade localidade "
							+ "where pagamento.anoMesReferenciaArrecadacao >= :anoMesArrecadacaoAtual "
							+ "and localidade.id = :idLocalidade";

			retorno = session.createQuery(consulta).setInteger("anoMesArrecadacaoAtual", anoMesArrecadacaoAtual).setInteger("idLocalidade",
							idLocalidade).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * Pesquisa os ano/mês de referência dos pagamentos no histórico para ano/mês de
	 * referência maior ou igual ao ano/mês de referência atual da arrecadação
	 * 
	 * @author Hugo Lima
	 * @date 02/05/2012
	 * @param anoMesArrecadacaoAtual
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesArrecadacaoPagamentoMaiorIgualAnoMesArrecadacaoAtualHistorico(Integer anoMesArrecadacaoAtual,
					Integer idLocalidade) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = "select distinct(pagamentoHistorico.anoMesReferenciaArrecadacao) " + "from PagamentoHistorico pagamentoHistorico "
							+ "inner join pagamentoHistorico.localidade localidade "
							+ "where pagamentoHistorico.anoMesReferenciaArrecadacao >= :anoMesArrecadacaoAtual "
							+ "and localidade.id = :idLocalidade";

			retorno = session.createQuery(consulta).setInteger("anoMesArrecadacaoAtual", anoMesArrecadacaoAtual).setInteger("idLocalidade",
							idLocalidade).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 20/03/2007
	 * @param idDebitoACobrar
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadePagamentosPorDebitoACobrar(Integer idDebitoACobrar) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = "SELECT COUNT(*) " + "FROM Pagamento pagamento " + "INNER JOIN pagamento.debitoACobrar debitoACobrar "
							+ "WHERE debitoACobrar.id = :idDebitoACobrar ";

			retorno = ((Number) session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).setMaxResults(1)
							.uniqueResult()).intValue();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualiza a situacao atual dos pagamentos (PGST_IDATUAL) (tabela
	 * PAGAMENTO_SITUACAO)
	 * 
	 * @author Pedro Alexandre
	 * @date 23/03/2007
	 * @param colecaoIdsPagamentos
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoPagamentoClassificado(Collection colecaoIdsPagamentos) throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;
		Integer idPagamento = null;
		try{
			Iterator iteratorPagamentos = colecaoIdsPagamentos.iterator();
			// System.out.println("################### ATUALIZANDO PAGAMENTO CLASSIFICADO ");

			atualizarSituacaoPagamento = "UPDATE Pagamento pgmt " + "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao,"
							+ " pgmt.ultimaAlteracao = :dataAlteracao," + " pgmt.valorExcedente = null " + "WHERE pgmt.id =:idPagamento";

			int i = 1;
			while(iteratorPagamentos.hasNext()){

				Pagamento pagamento = (Pagamento) iteratorPagamentos.next();
				idPagamento = pagamento.getId();

				// System.out.println("################### ATUALIZANDO SITUACAO ");

				session.createQuery(atualizarSituacaoPagamento).setInteger("pagamentoSituacao", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
								.setTimestamp("dataAlteracao", new Date()).setInteger("idPagamento", idPagamento).executeUpdate();

				if(i % 50 == 0){
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Caso o valor total dos pagamentos seja menor que o valor do documento,
	 * atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a valor não confere (tabela PAGAMENTO_SITUACAO) e atualiza
	 * o id da conta nos pagamentos (seta CNTA_ID da tabela PAGAMENTO para
	 * CNTA_ID da tabela CONTA)
	 * [SB0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Pedro Alexandre
	 * @date 28/03/2007
	 * @param mapPagamentosValorNaoConfere
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoValorNaoConfereConta(Map<Integer, Collection> mapPagamentosValorNaoConfere)
					throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		try{

			StringBuffer processarPagamentoConta = new StringBuffer("UPDATE Pagamento pgmt ").append(
							"SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, ").append("pgmt.conta.id = :idConta, ").append(
							"pgmt.ultimaAlteracao = :dataAlteracao ").append("WHERE pgmt.id IN(:idsPagamentos)");

			Collection colecaoIdsContas = mapPagamentosValorNaoConfere.keySet();
			Iterator iteratorIdsContas = colecaoIdsContas.iterator();

			int i = 1;

			while(iteratorIdsContas.hasNext()){
				// System.out.println("VALOR NAO CONFERE CONTA ....");
				Integer idConta = (Integer) iteratorIdsContas.next();

				Collection colecaoIdsPagamentos = mapPagamentosValorNaoConfere.get(idConta);

				if(colecaoIdsPagamentos != null && !colecaoIdsPagamentos.isEmpty()){
					session.createQuery(processarPagamentoConta.toString()).setInteger("pagamentoSituacao",
									PagamentoSituacao.VALOR_NAO_CONFERE).setInteger("idConta", idConta).setTimestamp("dataAlteracao",
									new Date()).setParameterList("idsPagamentos", colecaoIdsPagamentos).executeUpdate();

					if(i % 50 == 0){
						session.flush();
						session.clear();
					}
					i++;
				}
			}
			session.flush();
			session.clear();
		}catch(Exception e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Caso o valor total dos pagamentos seja menor que o valor do documento,
	 * atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a valor não confere (tabela PAGAMENTO_SITUACAO) e atualiza
	 * o id da guia de pagamento nos pagamentos (seta GPAG_ID da tabela
	 * PAGAMENTO para GPAG_ID da tabela GUIA PAGAMENTO)
	 * [SB0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Pedro Alexandre
	 * @date 28/03/2007
	 * @author Saulo Lima
	 * @date 27/11/2008
	 *       Adicionar parametro numeroPrestacao
	 * @param mapPagamentosValorNaoConfere
	 * @param numeroPrestacao
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoValorNaoConfereGuiaPagamento(Map<Integer, Collection> mapPagamentosValorNaoConfere,
					Integer numeroPrestacao) throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		try{

			int i = 1;

			String processarPagamentoGuiaPagamento = "UPDATE Pagamento pgmt " + "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
							+ "pgmt.guiaPagamentoGeral.id = :idGuiaPagamento, pgmt.numeroPrestacao = :numeroPrestacao, "
							+ "pgmt.ultimaAlteracao = :dataAlteracao " + "WHERE pgmt.id IN(:idsPagamentos)";

			Collection colecaoIdsGuias = mapPagamentosValorNaoConfere.keySet();
			Iterator iteratorIdsGuias = colecaoIdsGuias.iterator();

			while(iteratorIdsGuias.hasNext()){
				// System.out.println("VALOR NAO CONFERE GUIA...");
				Integer idGuiaPagamento = (Integer) iteratorIdsGuias.next();

				Collection colecaoIdsPagamentos = mapPagamentosValorNaoConfere.get(idGuiaPagamento);

				if(colecaoIdsPagamentos != null && !colecaoIdsPagamentos.isEmpty()){
					session.createQuery(processarPagamentoGuiaPagamento).setInteger("pagamentoSituacao",
									PagamentoSituacao.VALOR_NAO_CONFERE).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger(
									"numeroPrestacao", numeroPrestacao).setTimestamp("dataAlteracao", new Date()).setParameterList(
									"idsPagamentos", colecaoIdsPagamentos).executeUpdate();

					if(i % 50 == 0){
						session.flush();
						session.clear();
					}
					i++;
				}
			}
			session.flush();
			session.clear();
		}catch(Exception e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Caso o valor total dos pagamentos seja menor que o valor do documento,
	 * atualiza a situação atual dos pagamentos (PGST_IDATUAL) com valor
	 * correspondente a valor não confere (tabela PAGAMENTO_SITUACAO) e atualiza
	 * o id do débito a cobrar nos pagamentos (seta DBAC_ID da tabela PAGAMENTO
	 * para DBAC_ID da tabela DEBITO A COBRAR)
	 * [SB0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Pedro Alexandre
	 * @date 28/03/2007
	 * @param mapPagamentosValorNaoConfere
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoValorNaoConfereDebitoACobrar(Map<Integer, Collection> mapPagamentosValorNaoConfere)
					throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		String processarPagamentoDebitoACobrar = "UPDATE Pagamento pgmt " + "SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, "
						+ "pgmt.debitoACobrar.id = :idDebitoACobrar, " + "pgmt.ultimaAlteracao = :dataAlteracao "
						+ "WHERE pgmt.id IN(:idsPagamentos)";

		try{
			Collection colecaoIdsDebitosACobrar = mapPagamentosValorNaoConfere.keySet();
			Iterator iteratorIdsDebitosACobrar = colecaoIdsDebitosACobrar.iterator();

			int i = 1;

			while(iteratorIdsDebitosACobrar.hasNext()){
				// System.out.println("VALOR NAO CONFERE DEBITO ....");
				Integer idDebitoACobrar = (Integer) iteratorIdsDebitosACobrar.next();

				Collection colecaoIdsPagamentos = mapPagamentosValorNaoConfere.get(idDebitoACobrar);

				if(colecaoIdsPagamentos != null && !colecaoIdsPagamentos.isEmpty()){
					session.createQuery(processarPagamentoDebitoACobrar).setInteger("pagamentoSituacao",
									PagamentoSituacao.VALOR_NAO_CONFERE).setInteger("idDebitoACobrar", idDebitoACobrar).setTimestamp(
									"dataAlteracao", new Date()).setParameterList("idsPagamentos", colecaoIdsPagamentos).executeUpdate();

					if(i % 50 == 0){

						session.flush();
						session.clear();
					}
					i++;
				}
			}
			session.flush();
			session.clear();
		}catch(Exception e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0300] - Classificar Pagamentos e Devoluções
	 * [SB0008] - Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre, Saulo Lima
	 * @date 28/03/2007, 11/06/2007, 24/11/2008
	 * @param colecaoPagamentos
	 * @throws ErroRepositorioException
	 */
	public void processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo(Collection colecaoPagamentos)
					throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();
		Session session = HibernateUtil.getSession();

		try{

			StringBuffer processarPagamento = new StringBuffer("UPDATE Pagamento pgmt ").append(
							"SET pgmt.pagamentoSituacaoAtual.id = :pagamentoSituacao, ").append(
							"pgmt.conta = null, pgmt.guiaPagamentoGeral = null, pgmt.debitoACobrar = null, pgmt.numeroPrestacao = null, ")
							.append("pgmt.ultimaAlteracao = :dataAlteracao ").append("WHERE pgmt.id = :idPagamento");

			Iterator<Pagamento> iteratorPagamentos = colecaoPagamentos.iterator();

			int i = 1;

			while(iteratorPagamentos.hasNext()){

				Pagamento pagamento = iteratorPagamentos.next();
				// System.out.println("VALOR NAO CONFERE NULO... PAGM_ID = " + pagamento.getId());

				session.createQuery(processarPagamento.toString()).setInteger("pagamentoSituacao", PagamentoSituacao.VALOR_NAO_CONFERE)
								.setTimestamp("dataAlteracao", new Date()).setInteger("idPagamento", pagamento.getId()).executeUpdate();

				if(i % 50 == 0){
					session.flush();
					session.clear();
				}
				i++;
			}
			session.flush();
			session.clear();
		}catch(Exception e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Remove o id da guia de pagamento dos pagamentos referentes a conta para
	 * poder mandar a guia de pagamento para o histórico.
	 * [UC0000] Gerar Histórco para encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 01/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void apagarIdGuiaPagamentoPagamentos(Integer idGuiaPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "UPDATE Pagamento " + "SET guiaPagamento = null "
							+ "WHERE id in (select pgmt.id from Pagamento pgmt where pgmt.guiaPagamentoGeral.id = :idGuiaPagamento) ";

			session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisa os movimentos dos arrecadores para a geração do relatório
	 * [UCXXXX] Acompanhar Movimento dos Arrecadadores
	 * 
	 * @author Rafael Corrêa
	 * @date 02/04/2007
	 * @author Saulo Lima
	 * @date 28/04/209
	 *       Alterado pra consultar também no histórico
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarMovimentoArrecadadoresRelatorio(Integer mesAnoReferencia, Integer idArrecadador, Integer idFormaArrecadacao,
					Date dataPagamentoInicial, Date dataPagamentoFinal, Integer idConcessionaria) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Collection retorno = null;

		boolean indEmpresaTrabalhaConcessionaria = true;
		if(idConcessionaria == null){
			indEmpresaTrabalhaConcessionaria = false;
		}

		// Juro qua não queria fazer esse SELECT de um SELECT, mas fui obrigado dada a situação. :/
		// 28/01/2009 Saulo Lima
		try{
			consulta = "SELECT anoMesReferencia, nomeArrecadador, arrecadacaoForma, dataPagamento, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " Cconcessionaria, ";
			}
			consulta += " SUM(valorPagamento) AS valorPagamento, SUM(qtdeDocumentos) AS qtdeDocumentos, SUM(qtdePagamentos) AS qtdePagamentos FROM ";

			consulta = consulta
							+ " (select pg.pgmt_amreferenciaarrecadacao as anoMesReferencia, cli.clie_nmcliente as nomeArrecadador, arf.arfm_dsarrecadacaoforma as arrecadacaoForma,to_char(pg.pgmt_dtpagamento, 'yyyy-MM-dd') as dataPagamento, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " c.conc_nmconcessionaria as Cconcessionaria, ";
			}
			consulta += "  sum(pg.pgmt_vlpagamento) as valorPagamento, count(distinct pg.amit_id) as qtdeDocumentos, count(pgmt_id) as qtdePagamentos "
							+ " from pagamento pg "
							+ " inner join aviso_bancario avb on (pg.avbc_id = avb.avbc_id) "
							+ " inner join arrecadador arr on (avb.arrc_id = arr.arrc_id) "
							+ " inner join cliente cli on (arr.clie_id = cli.clie_id) "
							+ " inner join arrecadacao_forma arf on (pg.arfm_id = arf.arfm_id) ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " inner join CONCESSIONARIA_LOCALIDADE b on b.loca_id=pg.loca_id ";
				if(idConcessionaria != -1){
					consulta += " and b.conc_id= "

					+ idConcessionaria.intValue();
				}
				consulta += " and ((b.CNLC_DTVIGENCIAFIM is null" + " and pgmt_dtpagamento>=b.CNLC_DTVIGENCIAINICIO) "
								+ " or (b.CNLC_DTVIGENCIAFIM is not null " + " and pgmt_dtpagamento between b.CNLC_DTVIGENCIAINICIO"
								+ " and b.CNLC_DTVIGENCIAFIM))" + " inner join CONCESSIONARIA c on c.conc_id=b.conc_id";
			}
			consulta += " where pgmt_amreferenciaarrecadacao = :mesAnoReferencia and pg.pgmt_dtpagamento between :dataPagamentoInicial and :dataPagamentoFinal ";

			if(idArrecadador != null){
				consulta = consulta + " and arr.arrc_id = " + idArrecadador;
			}
			if(idFormaArrecadacao != null){
				consulta = consulta + " and arf.arfm_id = " + idFormaArrecadacao;
			}

			consulta = consulta
 + " group by pg.pgmt_amreferenciaarrecadacao, cli.clie_nmcliente, arf.arfm_dsarrecadacaoforma,";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " c.conc_nmconcessionaria,";
			}
			consulta += " pgmt_dtpagamento "
							+ " UNION "
							+ " select pg.pgmt_amreferenciaarrecadacao as anoMesReferencia, cli.clie_nmcliente as nomeArrecadador, arf.arfm_dsarrecadacaoforma as  arrecadacaoForma, '9999-12-01' as dataPagamento, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " c.conc_nmconcessionaria as Cconcessionaria, ";

			}
			consulta += " sum(pg.pgmt_vlpagamento) as valorPagamento, count(distinct pg.amit_id) as qtdeDocumentos, count(pgmt_id) as qtdePagamentos "
							+ " from pagamento pg " + " inner join aviso_bancario avb on (pg.avbc_id = avb.avbc_id) "
							+ " inner join arrecadador arr on (avb.arrc_id = arr.arrc_id) "
							+ " inner join cliente cli on (arr.clie_id = cli.clie_id) "
							+ " inner join arrecadacao_forma arf on (pg.arfm_id = arf.arfm_id) ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " inner join CONCESSIONARIA_LOCALIDADE b on b.loca_id=pg.loca_id";
				if(idConcessionaria != -1){
						consulta += " and b.conc_id= "

						+ idConcessionaria.intValue();
					}
					consulta += " and ((b.CNLC_DTVIGENCIAFIM is null" + " and pgmt_dtpagamento>=b.CNLC_DTVIGENCIAINICIO)"
								+ " or (b.CNLC_DTVIGENCIAFIM is not null" + " and pgmt_dtpagamento between b.CNLC_DTVIGENCIAINICIO"
								+ " and b.CNLC_DTVIGENCIAFIM))" + " inner join CONCESSIONARIA c on c.conc_id=b.conc_id";
			}
			consulta += " where pgmt_amreferenciaarrecadacao = :mesAnoReferencia and pg.pgmt_dtpagamento < :dataPagamentoInicial ";

			if(idArrecadador != null){
				consulta = consulta + " and arr.arrc_id = " + idArrecadador;
			}
			if(idFormaArrecadacao != null){
				consulta = consulta + " and arf.arfm_id = " + idFormaArrecadacao;
			}

			consulta = consulta
 + " group by pg.pgmt_amreferenciaarrecadacao, cli.clie_nmcliente, arf.arfm_dsarrecadacaoforma, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " c.conc_nmconcessionaria, ";
			}
			consulta += "'9999-12-01' ";

			consulta = consulta + " UNION ";

			consulta = consulta
							+ " select pghi.pghi_amreferenciaarrecadacao as anoMesReferencia, cli.clie_nmcliente as nomeArrecadador, arf.arfm_dsarrecadacaoforma as arrecadacaoForma,  to_char(pghi.pghi_dtpagamento, 'yyyy-MM-dd') as dataPagamento, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += "	c.conc_nmconcessionaria as Cconcessionaria, ";
			}

			consulta = consulta
							+ " sum(pghi.pghi_vlpagamento) as valorPagamento, count(distinct pghi.amit_id) as qtdeDocumentos, count(pghi_id) as qtdePagamentos "
							+ " from pagamento_historico pghi "
							+ " inner join aviso_bancario avb on (pghi.avbc_id = avb.avbc_id) "
							+ " inner join arrecadador arr on (avb.arrc_id = arr.arrc_id) "
							+ " inner join cliente cli on (arr.clie_id = cli.clie_id) "
							+ " inner join arrecadacao_forma arf on (pghi.arfm_id = arf.arfm_id) ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " inner join CONCESSIONARIA_LOCALIDADE b on b.loca_id=pghi.loca_id" ;
				if(idConcessionaria != -1){
						consulta += " and b.conc_id= "

						+ idConcessionaria.intValue();
					}
					consulta += " and ((b.CNLC_DTVIGENCIAFIM is null " + " and pghi_dtpagamento>=b.CNLC_DTVIGENCIAINICIO)"
								+ " or (b.CNLC_DTVIGENCIAFIM is not null " + "and pghi_dtpagamento between	b.CNLC_DTVIGENCIAINICIO"
								+ " and 	b.CNLC_DTVIGENCIAFIM))" + "inner join CONCESSIONARIA c on c.conc_id=b.conc_id";
			}
			consulta += " where pghi_amreferenciaarrecadacao = :mesAnoReferencia and pghi.pghi_dtpagamento between :dataPagamentoInicial and :dataPagamentoFinal ";

			if(idArrecadador != null){
				consulta = consulta + " and arr.arrc_id = " + idArrecadador;
			}
			if(idFormaArrecadacao != null){
				consulta = consulta + " and arf.arfm_id = " + idFormaArrecadacao;
			}

			consulta = consulta
 + " group by pghi.pghi_amreferenciaarrecadacao, cli.clie_nmcliente, arf.arfm_dsarrecadacaoforma, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " c.conc_nmconcessionaria, ";
			}
			consulta += "pghi_dtpagamento "
							+ " UNION "
							+ " select pghi.pghi_amreferenciaarrecadacao as anoMesReferencia, cli.clie_nmcliente as nomeArrecadador, arf.arfm_dsarrecadacaoforma as  arrecadacaoForma, '9999-12-01' as dataPagamento, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += "c.conc_nmconcessionaria as Cconcessionaria,";
			}
			consulta += " sum(pghi.pghi_vlpagamento) as valorPagamento, count(distinct pghi.amit_id) as qtdeDocumentos, count(pghi_id) as qtdePagamentos "
							+ " from pagamento_historico pghi " + " inner join aviso_bancario avb on (pghi.avbc_id = avb.avbc_id) "
							+ " inner join arrecadador arr on (avb.arrc_id = arr.arrc_id) "
							+ " inner join cliente cli on (arr.clie_id = cli.clie_id) "
							+ " inner join arrecadacao_forma arf on (pghi.arfm_id = arf.arfm_id) ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " inner join CONCESSIONARIA_LOCALIDADE b on b.loca_id=pghi.loca_id" ;
				if(idConcessionaria != -1){
						consulta += " and b.conc_id= "

						+ idConcessionaria.intValue();
					}
					consulta += " and ((b.CNLC_DTVIGENCIAFIM is null" + " and pghi_dtpagamento>=b.CNLC_DTVIGENCIAINICIO)"
								+ " or (b.CNLC_DTVIGENCIAFIM is not null" + " and pghi_dtpagamento between	b.CNLC_DTVIGENCIAINICIO"
								+ " and 	b.CNLC_DTVIGENCIAFIM))" + " inner join CONCESSIONARIA c on c.conc_id=b.conc_id";
			}

			consulta += " where pghi_amreferenciaarrecadacao = :mesAnoReferencia and pghi.pghi_dtpagamento < :dataPagamentoInicial ";

			if(idArrecadador != null){
				consulta = consulta + " and arr.arrc_id = " + idArrecadador;
			}
			if(idFormaArrecadacao != null){
				consulta = consulta + " and arf.arfm_id = " + idFormaArrecadacao;
			}

			consulta = consulta
							+ " group by pghi.pghi_amreferenciaarrecadacao, cli.clie_nmcliente, arf.arfm_dsarrecadacaoforma, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " c.conc_nmconcessionaria, ";
			}
			consulta += " '9999-12-01') "

			+ " group by anoMesReferencia, nomeArrecadador, arrecadacaoForma, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += " Cconcessionaria, ";
			}
			consulta += "dataPagamento "
							+ " order by nomeArrecadador, arrecadacaoforma, ";
			if(indEmpresaTrabalhaConcessionaria){
				consulta += "Cconcessionaria, ";
			}
			consulta += " dataPagamento";

			SQLQuery sqlQuery = session.createSQLQuery(consulta).addScalar("anoMesReferencia", Hibernate.INTEGER)
							.addScalar("nomeArrecadador",
							Hibernate.STRING).addScalar("arrecadacaoForma", Hibernate.STRING).addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL).addScalar("qtdeDocumentos", Hibernate.INTEGER).addScalar(
"qtdePagamentos", Hibernate.INTEGER);

			if(indEmpresaTrabalhaConcessionaria){
				sqlQuery = sqlQuery.addScalar("Cconcessionaria", Hibernate.STRING);
			}

			retorno = sqlQuery.setInteger("mesAnoReferencia", mesAnoReferencia)
							.setDate("dataPagamentoInicial", dataPagamentoInicial).setDate("dataPagamentoFinal", dataPagamentoFinal).list();
		
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Sequencial do tipo lançamento igual a 1550
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * doações
	 * 
	 * @author Pedro Alexandre
	 * @date 03/04/2007
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idLancamentoItemContabil)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id= :idCategoria "
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ " and dbcb.financiamentoTipo.id = :idFinanciamentoTipo "
							+ " and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"idLancamentoItemContabil", idLancamentoItemContabil).setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.DOACOES).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4150
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual doações.
	 * 
	 * @author Pedro Alexandre
	 * @date 03/04/2007
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoDoacoes(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idLancamentoItemContabil)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id=" + idCategoria
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.lancamentoItemContabil.id = " + idLancamentoItemContabil + " and dbcb.financiamentoTipo.id ="
							+ FinanciamentoTipo.DOACOES + " and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao " + "and pgmt.localidade.id ="
							+ idLocalidade + " " + "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO
							+ " or " + "pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao)
							.uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4000
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual a parcelamento de
	 * serviço e grupo de parcelamento diferente de juros cobrados.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idLancamentoItemContabil)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id= :idCategoria "
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ " and dbcb.financiamentoTipo.id = :idFinanciamentoTipo "
							+ " and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"idLancamentoItemContabil", idLancamentoItemContabil).setInteger("idFinanciamentoTipo",
							FinanciamentoTipo.DOACOES).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa as devoluções classificadas para transferir para o histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Devolucao> pesquisarDevolucoesClassificadasPorLocalidade(Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
					throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Devolucao> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select devl from Devolucao devl " + "inner join devl.localidade loca " + "where loca.id= :idLocalidade and "
							+ "devl.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao " + "and devl.devolucaoSituacaoAtual.id = "
							+ DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA;

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa as contas correspondentes aos pagamentos classificados de conta
	 * e os pagamentos anteriores de conta classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContasDePagamentosClassificadosContaEPagamentosAnterioresContaClassificadosNoMes(
					Integer anoMesReferenciaArrecadacao, Integer idLocalidade) throws ErroRepositorioException{

		Collection<Conta> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select cnta from Conta cnta "
							+ "inner join cnta.localidade loca "
							+ "where cnta.id in "
							+ "(select distinct pgmt.conta.id from Pagamento pgmt where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO
							+ " or pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ " and pgmt.conta.id is not null and pgmt.localidade.id = :idLocalidade) " + " and loca.id = :idLocalidade ";

			/*
			 * consulta = "select pgmt.conta from Pagamento pgmt " + "inner join
			 * pgmt.localidade loca " + "where loca.id =:idLocalidade and
			 * pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao " +
			 * "and (pgmt.pagamentoSituacaoAtual.id = " +
			 * PagamentoSituacao.PAGAMENTO_CLASSIFICADO + " or " +
			 * "pgmt.pagamentoSituacaoAtual.id = " +
			 * PagamentoSituacao.VALOR_A_BAIXAR + ") " + "and pgmt.conta.id is
			 * not null " ;
			 */
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa a conta
	 * 
	 * @author Pedro Alexandre
	 * @date 10/01/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarConta(Integer idConta) throws ErroRepositorioException{

		Conta retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = "select cnta from Conta cnta where cnta.id = :idConta ";

			retorno = (Conta) session.createQuery(consulta).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa a ContaHistorico
	 * 
	 * @author Saulo Lima
	 * @date 11/08/2009
	 * @param idContaGeral
	 * @return ContaHistorico
	 * @throws ErroRepositorioException
	 */
	public ContaHistorico pesquisarContaHistorico(Integer idContaGeral) throws ErroRepositorioException{

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT contaHistorico " + "FROM ContaHistorico contaHistorico " + "WHERE contaHistorico.id = :idContaGeral";

			retorno = (ContaHistorico) session.createQuery(consulta).setInteger("idContaGeral", idContaGeral).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisar o pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 10/04/2007
	 * @param idPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Pagamento pesquisarPagamento(Integer idPagamento) throws ErroRepositorioException{

		Pagamento retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select pgmt from Pagamento pgmt where pgmt.id = :idPagamento ";

			// Executa o hql
			retorno = (Pagamento) session.createQuery(consulta).setInteger("idPagamento", idPagamento).uniqueResult();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public String[] pesquisarIdsPagamentoAjsuteDESO(String idMovimentoCorreto, String idMovimentoDuplicado) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retornoConsulta = null;
		String[] retorno = null;

		StringBuilder consulta = new StringBuilder();

		try{

			// consulta.append("select pg.pgmt_id ");
			// consulta.append("from pagamento pg where imov_id = 218430 ");

			consulta.append("select pg.pgmt_id ");
			consulta.append(" from pagamento pg, arrecadador_movimento_item arrec where pg.amit_id = arrec.amit_id and armv_id =  "
							+ idMovimentoDuplicado);
			consulta.append(" union ");
			consulta.append(" select p.pgmt_id ");
			consulta.append(" from pagamento p ");
			consulta.append("  inner join arrecadador_movimento_item ami on p.amit_id = ami.amit_id and ami.armv_id = "
							+ idMovimentoDuplicado);
			consulta.append("  inner join pagamento_historico ph on p.imov_id = ph.imov_id and p.pgmt_amreferenciapagamento = ph.pghi_amreferenciapagamento ");
			consulta.append("  inner join arrecadador_movimento_item ami2 on ph.amit_id = ami2.amit_id and ami2.armv_id =  "
							+ idMovimentoCorreto);

			retornoConsulta = session.createSQLQuery(consulta.toString()).list();

			if(retornoConsulta != null && !retornoConsulta.isEmpty()){

				System.out.println(" ### Tamanho pesquisarIdsPagamentoAjsuteDESO = " + retornoConsulta.size());

				retorno = new String[retornoConsulta.size()];
				int i = 0;
				Iterator it = retornoConsulta.iterator();

				while(it.hasNext()){
					BigDecimal id = (BigDecimal) it.next();
					retorno[i] = id.toString();
					i++;
				}
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Integer> pesquisarIdsSetoresComPagamentosOuDevolucoes() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select stcm_id as setorComercial from setor_comercial where loca_id in (select loca_id from devolucao " + "union "
							+ "select loca_id as localidade from pagamento)";

			retorno = session.createSQLQuery(consulta).addScalar("setorComercial", Hibernate.INTEGER).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer pesquisarIdLocalidadePorSetorComercial(Integer idSetorComercial) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select stcm.localidade.id from SetorComercial stcm where stcm.id = :idSetorComercial";

			retorno = (Integer) session.createQuery(consulta).setInteger("idSetorComercial", idSetorComercial).uniqueResult();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa os débitos a cobrar correspondentes aos pagamentos classificados
	 * de débito a cobrar e aos pagamentos anteriores de débito a cobrar
	 * classificados no mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/04/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoACobrar> pesquisarDebitosACobrarDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
					Integer anoMesReferenciaArrecadacao, Integer idLocalidade) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<DebitoACobrar> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			consulta = "select dbac from DebitoACobrar dbac "
							+ "inner join dbac.localidade loca "
							+ "where dbac.id in "
							+ "(select distinct pgmt.debitoACobrar.id from Pagamento pgmt where pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao "
							+ "and (pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO
							+ " or pgmt.pagamentoSituacaoAtual.id = " + PagamentoSituacao.VALOR_A_BAIXAR + ") "
							+ " and pgmt.debitoACobrar.id is not null and pgmt.localidade.id = :idLocalidade) "
							+ " and loca.id = :idLocalidade ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 4400, 4410, 4420, 4430
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos créditos realizados por localidade e categoria, para
	 * os pagamentos de contas efetuados em meses anteriores classificados no
	 * mês, para origem do crédito igual a descontos concedidos.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idOrigemCredito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idOrigemCredito)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg "
							+ "where crcg.comp_id.categoria.id= :idCategoria "
							+ " and crcg.creditoRealizado.id in ( select crrz.id from CreditoRealizado crrz "
							+ "where crrz.creditoOrigem.id = :idOrigemCredito " + "and crrz.conta.id in( select distinct(pgmt.conta.id) "
							+ "from Pagamento pgmt " + "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar ) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger("idOrigemCredito",
							idOrigemCredito).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 400 e 500
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor do débitos cobrados por localidade, categoria dos
	 * pagamentos classificados de conta para tipo de financiamento igual a
	 * parcelamento de água ou parcelamento de esgoto.
	 * 
	 * @author Pedro Alexandre
	 * @date 18/04/2007
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idFinanciamentoTipo) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id= :idCategoria "
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.financiamentoTipo.id = :idFinanciamentoTipo "
							+ "and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger("idFinanciamentoTipo",
							idFinanciamentoTipo).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3800
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade e categoria para os
	 * pagamentos de contas efetuados em meses anteriores classificados no mês
	 * para tipo de financiamento igual a parcelamento de água.
	 * 
	 * @author Pedro Alexandre
	 * @date 18/04/2007
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idCategoria, Integer idFinanciamentoTipo)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id= :idCategoria "
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.financiamentoTipo.id = :idFinanciamentoTipo "
							+ " and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger("idFinanciamentoTipo",
							idFinanciamentoTipo).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 300
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor do débitos cobrados por localidade, categoria e item
	 * contábil dos pagamentos classificados de conta para tipo de financiamento
	 * igual a serviço
	 * 
	 * @author Pedro Alexandre
	 * @date 22/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @param colecaoIdsFinanciamentoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(Integer idLocalidade,
					Integer anoMesReferenciaArrecadacao, Integer idLancamentoItemContabil, Integer idCategoria,
					Collection<Integer> colecaoIdsFinanciamentoTipo) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id= :idCategoria "
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ " and (dbcb.financiamentoTipo.id in (:idsFinanciamentosTipo) )"
							+ " and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"idLancamentoItemContabil", idLancamentoItemContabil).setParameterList("idsFinanciamentosTipo",
							colecaoIdsFinanciamentoTipo).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Sequencial do tipo lançamento igual a 3700
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Acumula o valor dos débitos cobrados por localidade, categoria e item
	 * contábil para os pagamentos de contas efetuados em meses anteriores
	 * classificados no mês para tipo de financiamento igual a serviço.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/05/2006
	 * @param idLocalidade
	 * @param anoMesReferenciaArrecadacao
	 * @param idLancamentoItemContabil
	 * @param idCategoria
	 * @param idsFinanciamentoTipos
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(
					Integer idLocalidade, Integer anoMesReferenciaArrecadacao, Integer idLancamentoItemContabil, Integer idCategoria,
					Collection<Integer> idsFinanciamentoTipos) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "where dccg.categoria.id= :idCategoria "
							+ " and dccg.debitoCobrado.id in ( select dbcb.id from DebitoCobrado dbcb "
							+ "where dbcb.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ " and (dbcb.financiamentoTipo.id in(:idsFinanciamentoTipos) " + ")"
							+ " and dbcb.conta.id in( select distinct(pgmt.conta.id) " + "from Pagamento pgmt "
							+ "where pgmt.anoMesReferenciaArrecadacao < :anoMesReferenciaArrecadacao "
							+ "and pgmt.localidade.id = :idLocalidade "
							+ "and (pgmt.pagamentoSituacaoAtual.id = :idPagamentoClassificado or "
							+ "pgmt.pagamentoSituacaoAtual.id = :idPagamentoValorABaixar) " + "and pgmt.conta.id is not null " + ") )";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idCategoria", idCategoria).setInteger(
							"idLancamentoItemContabil", idLancamentoItemContabil).setParameterList("idsFinanciamentoTipos",
							idsFinanciamentoTipos).setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).setInteger(
							"idLocalidade", idLocalidade).setInteger("idPagamentoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("idPagamentoValorABaixar", PagamentoSituacao.VALOR_A_BAIXAR).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] Registrar Movimento Arrecadadores
	 * Atualiza o arrecadador contrato
	 * 
	 * @author Sávio Luiz,Vivianne Sousa
	 * @date 19/04/2007,28/11/2007
	 * @return Coleção de Bancos
	 * @throws ErroRepositorioException
	 */

	public void atualizarDadosArrecadadorContrato(ArrecadadorContrato arrecadadorContrato, boolean flagEnvioDebitoAutomatico,
					boolean flagRetornoCodigoBarras, boolean flagRetornoDebitoAutomatico, boolean flagRetornoFichaCompensacao,
					boolean flagRetornoBoletoBancario, boolean indicadorAtualizaNSADebitoAutomatico,
					boolean indicadorAtualizaNSAParcelamentoResponsavel) throws ErroRepositorioException{

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta = "";

		try{

			consulta = "UPDATE gcom.arrecadacao.ArrecadadorContrato " + "SET arct_tmultimaalteracao = :ultimaAlteracao";

			if(flagRetornoCodigoBarras){

				consulta += ", arct_nnnsaretornocdbarras = :numeroSequecialArquivoRetornoCodigoBarras";
			}

			if(flagRetornoDebitoAutomatico){

				if(indicadorAtualizaNSADebitoAutomatico){

					consulta += ", arct_nnnsaretornodebaut = :numeroSequencialArquivoRetornoDebitoAutomatico";
				}else if(indicadorAtualizaNSAParcelamentoResponsavel){

					consulta += ", arct_nnnsaretornoparcelresp = :numeroSequencialArquivoRetornoParcelamentoResponsavel";
				}
			}

			if(flagEnvioDebitoAutomatico){

				if(flagRetornoCodigoBarras || flagRetornoDebitoAutomatico){

					consulta += ", arct_nnnsaenviodebaut = :numeroSequencialArquivoEnvioDebitoAutomatico";
				}else{

					consulta += ", arct_nnnsaenviodebaut = :numeroSequencialArquivoEnvioDebitoAutomatico";
				}
			}

			if(flagRetornoFichaCompensacao){

				consulta += ", arct_nnnsaretornofichacomp = :numeroSequencialArquivoRetornoFichaCompensacao";
			}

			if(flagRetornoBoletoBancario){

				consulta += ", arct_nnnsaretornoboleto = :numeroSequencialArquivoRetornoBoletoBancario";
			}

			consulta += " WHERE arct_id = :idArrecadadorContrato";

			Query query = session.createQuery(consulta);

			query.setTimestamp("ultimaAlteracao", new Date());

			if(flagRetornoCodigoBarras){

				query.setInteger("numeroSequecialArquivoRetornoCodigoBarras", arrecadadorContrato
								.getNumeroSequecialArquivoRetornoCodigoBarras());
			}

			if(flagRetornoDebitoAutomatico){

				if(indicadorAtualizaNSADebitoAutomatico){

					query.setInteger("numeroSequencialArquivoRetornoDebitoAutomatico", arrecadadorContrato
									.getNumeroSequencialArquivoRetornoDebitoAutomatico());
				}else if(indicadorAtualizaNSAParcelamentoResponsavel){

					query.setInteger("numeroSequencialArquivoRetornoParcelamentoResponsavel", arrecadadorContrato
									.getNumeroSequencialArquivoRetornoParcelamentoResposavel());
				}
			}

			if(flagEnvioDebitoAutomatico){

				if(flagRetornoCodigoBarras || flagRetornoDebitoAutomatico){

					query.setInteger("numeroSequencialArquivoEnvioDebitoAutomatico", arrecadadorContrato
									.getNumeroSequencialArquivoEnvioDebitoAutomatico());
				}else{

					query.setInteger("numeroSequencialArquivoEnvioDebitoAutomatico", arrecadadorContrato
									.getNumeroSequencialArquivoEnvioDebitoAutomatico());
				}
			}

			if(flagRetornoFichaCompensacao){

				query.setInteger("numeroSequencialArquivoRetornoFichaCompensacao", arrecadadorContrato
								.getNumeroSequencialArquivoRetornoFichaCompensacao());
			}

			if(flagRetornoBoletoBancario){

				query.setInteger("numeroSequencialArquivoRetornoBoletoBancario", arrecadadorContrato
								.getNumeroSequencialArquivoRetornoBoleto());
			}

			query.setInteger("idArrecadadorContrato", arrecadadorContrato.getId()).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisar os ano/mês de referência do pagamentos para um imóvel e ano/mês
	 * de arrecadação informados para o tipo de documento informado.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 06/12/2006
	 * @param anoMesArrecadacaoAtual
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAnoMesReferenciaPagamentoParaImovel(Integer anoMesArrecadacaoAtual, Integer idImovel)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = " select distinct(anoMesReferenciaPagamento) from Pagamento pagamento "
							+ " where pagamento.anoMesReferenciaArrecadacao = :anoMesArrecadacaoAtual "
							+ "and pagamento.imovel.id = :idImovel and pagamento.anoMesReferenciaPagamento is not null ";

			retorno = session.createQuery(consulta).setInteger("anoMesArrecadacaoAtual", anoMesArrecadacaoAtual).setInteger("idImovel",
							idImovel).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os pagamentos histórios de um aviso
	 * 
	 * @author Rafael Corrêa
	 * @date 23/04/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoHistoricoAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		Collection retorno = null;

		String hql = "";

		Session session = HibernateUtil.getSession();

		try{

			hql = "select "
							+ "documentoTipo.descricaoAbreviado, "
							+ // 0
							"pagamento.dataPagamento, "
							+ // 1
							"pagamento.localidade.id, "
							+ // 2
							"imovel.id, "
							+ // 3
							"cliente.id, "
							+ // 4
							"pagamento.anoMesReferenciaPagamento, "
							+ // 5
							"debitoTipo.id, "
							+ // 6
							"pagamento.valorPagamento, "
							+ // 7
							"pagamentoSituacaoAtual.descricaoAbreviada, "
							+ // 8
							"pagamento.numeroPrestacao, "
							+ // 9
							"pagamento.debitoACobrar.id, "
							+ // 10
							"pagamento.conta.id, "
							+ // 11
							"pagamento.guiaPagamentoGeral.id "
							+ // 12
							"from gcom.arrecadacao.pagamento.PagamentoHistorico  pagamento " + "left join pagamento.imovel  imovel "
							+ "left join pagamento.cliente  cliente " + "left join pagamento.debitoTipo  debitoTipo "
							+ "left join pagamento.pagamentoSituacaoAtual  pagamentoSituacaoAtual "
							+ "left join pagamento.documentoTipo documentoTipo " + "where pagamento.avisoBancario.id = :idAvisoBancario "
							+ "order by imovel.id,pagamento.anoMesReferenciaPagamento ";

			retorno = session.createQuery(hql).setInteger("idAvisoBancario", idAvisoBancario).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// /**
	// * Seleciona os pagamentos histórios de um aviso
	// *
	// * @author Rafael Corrêa
	// * @date 23/04/2007
	// *
	// * @return Collection
	// * @throws ErroRepositorioException
	// */
	// public Collection pesquisarPagamentoHistoricoAvisoBancario(
	// Integer idAvisoBancario) throws ErroRepositorioException {
	//
	// Collection retorno = null;
	//
	// String consulta = "";
	//
	// Session session = HibernateUtil.getSession();
	//
	// try {
	//
	//
	// consulta = "select pghi.dotp_id as idDocumentoTipo,  " + //0
	// "pghi.pghi_dtpagamento as dtpagamento, " + //1
	// "pghi.loca_id as idLocalidade, " + //2
	// "pghi.imov_id as idImovel, " + //3
	// "pghi.clie_id as idCliente, " + //4
	// "pghi.pghi_amreferenciapagamento as anoMesReferencia, " + //5
	// "pghi.dbtp_id as idDebitoTipo, " + //6
	// "pghi.pghi_vlpagamento as valorPagamento, " + //7
	// "pgst.pgst_dsabreviado as descDebCredSit " + //8
	// "from pagamento_historico pghi " +
	// "left join pagamento_situacao pgst on  pgst.pgst_id = pghi.pgst_idatual " +
	// "where pghi.avbc_id = :idAvisoBancario";
	//
	//
	//
	// retorno = session.createSQLQuery(consulta)
	// .addScalar("idDocumentoTipo" , Hibernate.INTEGER)
	// .addScalar("dtpagamento" , Hibernate.DATE)
	// .addScalar("idLocalidade" , Hibernate.INTEGER)
	// .addScalar("idImovel" , Hibernate.INTEGER)
	// .addScalar("idCliente" , Hibernate.INTEGER)
	// .addScalar("anoMesReferencia" , Hibernate.INTEGER)
	// .addScalar("idDebitoTipo" , Hibernate.INTEGER)
	// .addScalar("valorPagamento" , Hibernate.BIG_DECIMAL)
	// .addScalar("descDebCredSit" , Hibernate.STRING)
	// .setInteger("idAvisoBancario",idAvisoBancario).list();
	//
	//
	// } catch (HibernateException e) {
	// throw new ErroRepositorioException("Erro no Hibernate");
	// } finally {
	// HibernateUtil.closeSession(session);
	// }
	//
	// return retorno;
	// }
	//
	//

	/**
	 * [UC0150] Retificar Conta
	 * 
	 * @author Vivianne Sousa
	 * @data 23/04/2006
	 * @param idConta
	 * @return idParcelamento
	 */
	public Object[] pesquisarPagamentoDeConta(Integer idConta) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT pgmt.id,pgmt.valorPagamento " + "FROM Pagamento  pgmt " + "WHERE pgmt.conta.id = :idConta ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idConta", idConta).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Sávio Luiz
	 * @data 23/04/2006
	 * @param idConta
	 * @return idParcelamento
	 */
	public Integer pesquisarIdPagamentoDaGuia(Integer idGuiaPagamento) throws ErroRepositorioException{

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT pgmt.id " + "FROM Pagamento  pgmt " + "WHERE pgmt.guiaPagamentoGeral.id = :idGuiaPagamento ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Sávio Luiz
	 * @data 23/04/2006
	 * @param idConta
	 * @return idParcelamento
	 */
	public Integer pesquisarIdPagamentoDoDebitoACobrar(Integer idDebitoACobrar) throws ErroRepositorioException{

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT pgmt.id " + "FROM Pagamento  pgmt " + "WHERE pgmt.debitoACobrar.id = :idDebitoACobrar ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] Retificar Conta
	 * 
	 * @author Vivianne Sousa
	 * @data 23/04/2006
	 * @param idPagamento
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarContaEmPagamento(Integer idPagamento, Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "UPDATE Pagamento pgmt " + "SET pgmt.conta.id = :idConta " + "WHERE pgmt.id = :idPagamento ";

			session.createQuery(consulta).setInteger("idPagamento", idPagamento).setInteger("idConta", idConta).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	private String criarCondicionaisPagamentoHistoricoCliente(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria){

		String sql = " ";
		if(idImovel != null && !idImovel.equals("")){
			sql = sql + " c.imov_id = " + idImovel + " and ";
		}
		if(idCliente != null && !idCliente.equals("")){
			sql = sql + " a.clie_id = " + idCliente + " and ";
		}
		if(idTipoRelacao != null && !idTipoRelacao.equals("")){
			sql = sql + " b.crtp_id = " + idTipoRelacao + " and ";
		}
		if(localidadeInicial != null && localidadeFinal != null && !localidadeInicial.equals("") && !localidadeFinal.equals("")){
			sql = sql + " c.loca_id >= " + localidadeInicial + " and ";
			sql = sql + " c.loca_id <= " + localidadeFinal + " and ";
		}
		if(!Util.isVazioOuBranco(codigoSetorComercialInicial) && !Util.isVazioOuBranco(codigoSetorComercialFinal)){
			sql = sql + " stcm.stcm_cdsetorcomercial >= " + codigoSetorComercialInicial + " and ";
			sql = sql + " stcm.stcm_cdsetorcomercial <= " + codigoSetorComercialFinal + " and ";
		}
		if(!Util.isVazioOrNulo(idsArrecadadores)){
			String valoresIn = "";

			for(Integer idArrecadadorAux : idsArrecadadores){
				valoresIn = valoresIn + idArrecadadorAux + ",";
			}

			if(!valoresIn.equals("")){
				sql = sql + " f.arrc_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idAvisoBancario != null && !idAvisoBancario.equals("")){
			sql = sql + " c.avbc_id = " + idAvisoBancario + " and ";
		}
		if(idArrecadador != null && !idArrecadador.equals("")){
			sql = sql + " f.armv_id = " + idArrecadador + " and ";
		}
		if(periodoArrecadacaoInicial != null && !periodoArrecadacaoInicial.equals("")){
			sql = sql + " c.pghi_amreferenciaarrecadacao >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoInicial) + " and ";
		}
		if(periodoArrecadacaoFinal != null && !periodoArrecadacaoFinal.equals("")){
			sql = sql + " c.pghi_amreferenciaarrecadacao <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoArrecadacaoFinal) + " and ";
		}
		if(periodoPagamentoInicio != null && !periodoPagamentoInicio.equals("")){
			sql = sql + " c.pghi_amreferenciapagamento >= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoInicio) + " and ";
		}
		if(periodoPagamentoFim != null && !periodoPagamentoFim.equals("")){
			sql = sql + " c.pghi_amreferenciapagamento <= " + Util.formatarMesAnoParaAnoMesSemBarra(periodoPagamentoFim) + " and ";
		}

		if(dataPagamentoInicial != null && !dataPagamentoInicial.equals("")){
			// sql = sql + " pagamento.dataPagamento >= '" +
			// Util.formatarData(dataPagamentoInicial) + "' and " ;
			String data1 = Util.recuperaDataInvertida(dataPagamentoInicial);

			if(data1 != null && !data1.equals("") && data1.trim().length() == 8){

				data1 = data1.substring(0, 4) + "-" + data1.substring(4, 6) + "-" + data1.substring(6, 8);
			}
			sql = sql + " c.pghi_dtpagamento >= '" + data1 + "' and ";
		}
		if(dataPagamentoFinal != null && !dataPagamentoFinal.equals("")){
			// sql = sql + " pagamento.dataPagamento <= '" +
			// Util.formatarData(dataPagamentoFinal) + "' and " ;
			String data2 = Util.recuperaDataInvertida(dataPagamentoFinal);

			if(data2 != null && !data2.equals("") && data2.trim().length() == 8){

				data2 = data2.substring(0, 4) + "-" + data2.substring(4, 6) + "-" + data2.substring(6, 8);
			}
			sql = sql + " c.pghi_dtpagamento <= '" + data2 + "' and ";
		}

		if(idsPagamentosSituacoes != null && !idsPagamentosSituacoes.equals("")){
			String valoresIn = "";
			for(int i = 0; i < idsPagamentosSituacoes.length; i++){
				if(!idsPagamentosSituacoes[i].equals("")){
					valoresIn = valoresIn + idsPagamentosSituacoes[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " c.pgst_idatual in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDebitosTipos != null && !idsDebitosTipos.equals("")
						&& !idsDebitosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDebitosTipos.length; i++){
				if(!idsDebitosTipos[i].equals("")){
					valoresIn = valoresIn + idsDebitosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " c.dbtp_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsArrecadacaoForma != null && !idsArrecadacaoForma.equals("")
						&& !idsArrecadacaoForma[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsArrecadacaoForma.length; i++){
				if(!idsArrecadacaoForma[i].equals("")){
					valoresIn = valoresIn + idsArrecadacaoForma[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " c.arfm_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsDocumentosTipos != null && !idsDocumentosTipos.equals("")
						&& !idsDocumentosTipos[0].equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			String valoresIn = "";
			for(int i = 0; i < idsDocumentosTipos.length; i++){
				if(!idsDocumentosTipos[i].equals("")){
					valoresIn = valoresIn + idsDocumentosTipos[i] + ",";
				}
			}
			if(!valoresIn.equals("")){
				sql = sql + " c.dotp_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";
			}
		}
		if(idsCategoria != null && idsCategoria.length != 0){

			String valoresIn = "";
			for(int i = 0; i < idsCategoria.length; i++){
				if(!idsCategoria[i].equals("")){
					valoresIn = valoresIn + idsCategoria[i] + ",";
				}
			}
			if(!valoresIn.equals("")){

				sql = sql + " imsb.catg_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";

			}

		}

		if(idsCategoria != null && idsCategoria.length != 0){

			String valoresIn = "";
			for(int i = 0; i < idsCategoria.length; i++){
				if(!idsCategoria[i].equals("")){
					valoresIn = valoresIn + idsCategoria[i] + ",";
				}
			}
			if(!valoresIn.equals("")){

				sql = sql + " imsb.catg_id in (" + valoresIn;
				sql = Util.formatarHQL(sql, 1);
				sql = sql + ") and ";

			}

		}
		// retira o " and " q fica sobrando no final da query
		sql = Util.formatarHQL(sql, 4);

		return sql;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 04/06/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorUnidadeNegocio(int anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(ra.valorItemArrecadacao)," // 0
							+ " rt.descricao," // 1
							+ " lt.descricao," // 2
							+ " li.descricao," // 3
							+ " lic.descricao," // 4
							+ " lt.indicadorImpressao," // 5
							+ " lt.indicadorTotal," // 6
							+ " lt.id," // 7
							+ " lt.lancamentoTipo.id," // 8
							+ " ra.categoria.id," // 9
							+ " ra.unidadeNegocio.nome," // 10
							+ " ra.unidadeNegocio.id," // 11
							+ " rt.id," // 12
							+ " ra.sequenciaTipoLancamento," // 13
							+ " ra.sequenciaItemTipoLancamento," // 14
							+ " ra.gerenciaRegional.nome," // 15
							+ " ra.gerenciaRegional.id " // 16
							+ " from ResumoArrecadacao ra" + " left join ra.lancamentoTipo lt"
							+ " left join ra.lancamentoItem li"
							+ " left join ra.lancamentoItemContabil lic"
							+ " left join ra.recebimentoTipo rt"
							+ " where ra.anoMesReferencia = :anoMesReferencia and"
							+ " (ra.categoria.id = 1 or"
							+ " ra.categoria.id = 2 or"
							+ " ra.categoria.id = 3 or"
							+ " ra.categoria.id = 4)"
							+ " group by "
							+ " ra.unidadeNegocio.nome,ra.unidadeNegocio.id,"
							+ " rt.descricao, lt.descricao, li.descricao, lic.descricao,"
							+ " lt.indicadorImpressao, lt.indicadorTotal, lt.id, lt.lancamentoTipo.id,"
							+ " ra.categoria.id, rt.id, ra.sequenciaTipoLancamento, ra.sequenciaItemTipoLancamento,"
							+ " ra.gerenciaRegional.nome, ra.gerenciaRegional.id"
							+ " order by "
							+ " ra.gerenciaRegional.nome, ra.unidadeNegocio.nome," + " rt.id,"
							+ " ra.sequenciaTipoLancamento,"
							+ " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 04/06/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(int anoMesReferencia, Integer unidadeNegocio)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(ra.valorItemArrecadacao),"// 0
							+ " rt.descricao," // 1
							+ " lt.descricao," // 2
							+ " li.descricao," // 3
							+ " lic.descricao," // 4
							+ " lt.indicadorImpressao," // 5
							+ " lt.indicadorTotal," // 6
							+ " lt.id," // 7
							+ " lt.lancamentoTipo.id," // 8
							+ " ra.categoria.id," // 9
							+ " ra.unidadeNegocio.nome, " // 10
							+ " ra.unidadeNegocio.id, " // 11
							+ " rt.id," // 12
							+ " ra.sequenciaTipoLancamento," // 13
							+ " ra.sequenciaItemTipoLancamento," // 14
							+ " ra.gerenciaRegional.nome," // 15
							+ " ra.gerenciaRegional.id " // 16
							+ " from ResumoArrecadacao ra" + " left join ra.lancamentoTipo lt"
							+ " left join ra.lancamentoItem li"
							+ " left join ra.lancamentoItemContabil lic"
							+ " left join ra.recebimentoTipo rt"
							+ " where ra.anoMesReferencia = :anoMesReferencia and"
							+ " ra.unidadeNegocio = :unidadeNegocio and"
							+ " (ra.categoria.id = 1 or" + " ra.categoria.id = 2 or" + " ra.categoria.id = 3 or"
							+ " ra.categoria.id = 4)"
							+ " group by " + " rt.descricao," + " lt.descricao," + " li.descricao,"
							+ " lic.descricao,"
							+ " lt.indicadorImpressao," + " lt.indicadorTotal," + " lt.id,"
							+ " lt.lancamentoTipo.id,"
							+ " ra.categoria.id," + " ra.gerenciaRegional.nome," + " ra.gerenciaRegional.id, "
							+ " ra.unidadeNegocio.nome,"
							+ " ra.unidadeNegocio.id," + " rt.id," + " ra.sequenciaTipoLancamento,"
							+ " ra.sequenciaItemTipoLancamento"
							+ " order by rt.id," + " ra.sequenciaTipoLancamento," + " ra.sequenciaItemTipoLancamento," + " ra.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("unidadeNegocio",
							unidadeNegocio).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisar pagamentos pelo aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 11/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public PagamentosDevolucoesHelper filtrarPagamentos(FiltroPagamento filtroPagamento, FiltroPagamentoHistorico filtroPagamentoHistorico)
					throws ErroRepositorioException{

		// Collection<MovimentarPagamentosDevolucoesHelper> retorno = null;
		Session session = HibernateUtil.getSession();
		Collection<Object[]> consulta = new ArrayList();
		PagamentosDevolucoesHelper retorno = null;
		Integer qtdPagamentos = 0;

		try{
			Collection<MovimentarPagamentosDevolucoesHelper> colecaoMovimentarPagamentosDevolucoes = new ArrayList();
			retorno = new PagamentosDevolucoesHelper();

			if(filtroPagamento != null){
				consulta = new ArrayList(new CopyOnWriteArrayList<Pagamento>(GeradorHQLCondicional.gerarCondicionalQuery(
								filtroPagamento,
								"gcom.arrecadacao.pagamento.Pagamento",
								"pagamento",
								"select dotp.descricaoAbreviado, pagamento.anoMesReferenciaPagamento, "
												+ "pagamento.valorPagamento, pagamento.dataPagamento, dbtp.descricao, pagamento.id "
												+ "from Pagamento pagamento " + "inner join pagamento.documentoTipo dotp "
												+ "left join pagamento.debitoTipo dbtp" + "", session).list()));

				if(consulta.size() > 0){

					BigDecimal valorTotal = BigDecimal.ZERO;
					MovimentarPagamentosDevolucoesHelper helper = null;
					for(Iterator iter = consulta.iterator(); iter.hasNext();){
						qtdPagamentos = qtdPagamentos + 1;
						Object[] element = (Object[]) iter.next();
						helper = new MovimentarPagamentosDevolucoesHelper();
						helper.setTipoDocumento((String) element[0]);
						if(element[1] != null && !element[1].equals("")){
							helper.setMesAnoReferencia(Util.formatarAnoMesParaMesAno((Integer) element[1]));
						}
						helper.setValor(Util.formatarMoedaReal((BigDecimal) element[2]));
						valorTotal = valorTotal.add((BigDecimal) element[2]);
						helper.setData(Util.formatarData((Date) element[3]));
						if(element[4] != null && !element[4].equals("")){
							helper.setTipoDebito((String) element[4]);
						}
						helper.setId((Integer) element[5]);

						colecaoMovimentarPagamentosDevolucoes.add(helper);
					}
					retorno.setValorTotalPagamentos(Util.formatarMoedaReal(valorTotal));
				}
			}

			if(filtroPagamentoHistorico != null){
				consulta = new ArrayList(
								new CopyOnWriteArrayList<Pagamento>(
												GeradorHQLCondicional
																.gerarCondicionalQuery(
																				filtroPagamentoHistorico,
																				"gcom.arrecadacao.pagamento.PagamentoHistorico",
																				"pagamentoHistorico",
																				"select dotp.descricaoAbreviado, pagamentoHistorico.anoMesReferenciaPagamento, "
																								+ "pagamentoHistorico.valorPagamento, pagamentoHistorico.dataPagamento, dbtp.descricao, pagamentoHistorico.id "
																								+ "from PagamentoHistorico pagamentoHistorico "
																								+ "inner join pagamentoHistorico.documentoTipo dotp "
																								+ "left join pagamentoHistorico.debitoTipo dbtp"
																								+ "", session).list()));

				if(consulta.size() > 0){

					BigDecimal valorTotal = BigDecimal.ZERO;
					MovimentarPagamentosDevolucoesHelper helper = null;
					for(Iterator iter = consulta.iterator(); iter.hasNext();){
						qtdPagamentos = qtdPagamentos + 1;
						Object[] element = (Object[]) iter.next();
						helper = new MovimentarPagamentosDevolucoesHelper();
						helper.setTipoDocumento((String) element[0]);
						if(element[1] != null && !element[1].equals("")){
							helper.setMesAnoReferencia(Util.formatarAnoMesParaMesAno((Integer) element[1]));
						}
						helper.setValor(Util.formatarMoedaReal((BigDecimal) element[2]));
						valorTotal = valorTotal.add((BigDecimal) element[2]);
						helper.setData(Util.formatarData((Date) element[3]));
						if(element[4] != null && !element[4].equals("")){
							helper.setTipoDebito((String) element[4]);
						}
						helper.setId((Integer) element[5]);
						helper.setHistorico(true);

						colecaoMovimentarPagamentosDevolucoes.add(helper);
					}

					retorno.setValorTotalPagamentosHistorico(Util.formatarMoedaReal(valorTotal));
				}
			}
			retorno.setValorTotal(Util.formatarMoedaReal(Util.formatarMoedaRealparaBigDecimal(retorno.getValorTotalPagamentos()).add(
							Util.formatarMoedaRealparaBigDecimal(retorno.getValorTotalPagamentosHistorico()))));
			retorno.setColecaoMovimentarPagamentos(colecaoMovimentarPagamentosDevolucoes);
			retorno.setQtdPagamentos(qtdPagamentos);

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar devoluçãoes pelo aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 11/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public PagamentosDevolucoesHelper filtrarDevolucoes(FiltroDevolucao filtroDevolucao, FiltroDevolucaoHistorico filtroDevolucaoHistorico)
					throws ErroRepositorioException{

		// Collection<MovimentarPagamentosDevolucoesHelper> retorno = null;
		Session session = HibernateUtil.getSession();
		Collection<Object[]> consulta = new ArrayList();
		PagamentosDevolucoesHelper retorno = null;
		Integer qtdDevolucoes = 0;

		try{

			Collection<MovimentarPagamentosDevolucoesHelper> colecaoMovimentarPagamentosDevolucoes = new ArrayList();
			retorno = new PagamentosDevolucoesHelper();

			if(filtroDevolucao != null){
				consulta = new ArrayList(new CopyOnWriteArrayList<Devolucao>(GeradorHQLCondicional.gerarCondicionalQuery(
								filtroDevolucao,
								"gcom.arrecadacao.Devolucao",
								"devolucao",
								"select devolucao.anoMesReferenciaArrecadacao, devolucao.valorDevolucao, "
												+ "devolucao.dataDevolucao, dbtp.descricao, devolucao.id " + "from Devolucao devolucao "
												+ "left join devolucao.debitoTipo dbtp " + "", session).list()));

				if(consulta.size() > 0){

					BigDecimal valorTotal = BigDecimal.ZERO;
					MovimentarPagamentosDevolucoesHelper helper = null;
					for(Iterator iter = consulta.iterator(); iter.hasNext();){
						qtdDevolucoes++;
						Object[] element = (Object[]) iter.next();
						helper = new MovimentarPagamentosDevolucoesHelper();
						helper.setTipoDocumento("GDEV");
						if(element[0] != null && !element[0].equals("")){
							helper.setMesAnoReferencia(Util.formatarAnoMesParaMesAno((Integer) element[0]));
						}
						helper.setValor(Util.formatarMoedaReal((BigDecimal) element[1]));
						valorTotal = valorTotal.add((BigDecimal) element[1]);
						helper.setData(Util.formatarData((Date) element[2]));
						if(element[3] != null && !element[3].equals("")){
							helper.setTipoDebito((String) element[3]);
						}
						helper.setId((Integer) element[4]);

						colecaoMovimentarPagamentosDevolucoes.add(helper);
					}
					retorno.setValorTotalDevolucoes(Util.formatarMoedaReal(valorTotal));
				}
			}
			if(filtroDevolucaoHistorico != null){
				consulta = new ArrayList(new CopyOnWriteArrayList<Devolucao>(GeradorHQLCondicional.gerarCondicionalQuery(
								filtroDevolucaoHistorico,
								"gcom.arrecadacao.DevolucaoHistorico",
								"devolucaoHistorico",
								"select devolucaoHistorico.anoMesReferenciaArrecadacao, devolucaoHistorico.valorDevolucao, "
												+ "devolucaoHistorico.dataDevolucao, dbtp.descricao, devolucaoHistorico.id "
												+ "from DevolucaoHistorico devolucaoHistorico "
												+ "left join devolucaoHistorico.debitoTipo dbtp " + "", session).list()));

				if(consulta.size() > 0){

					BigDecimal valorTotal = BigDecimal.ZERO;
					MovimentarPagamentosDevolucoesHelper helper = null;
					for(Iterator iter = consulta.iterator(); iter.hasNext();){
						qtdDevolucoes++;
						Object[] element = (Object[]) iter.next();
						helper = new MovimentarPagamentosDevolucoesHelper();
						helper.setTipoDocumento("GDEV");
						if(element[0] != null && !element[0].equals("")){
							helper.setMesAnoReferencia(Util.formatarAnoMesParaMesAno((Integer) element[0]));
						}
						helper.setValor(Util.formatarMoedaReal((BigDecimal) element[1]));
						valorTotal = valorTotal.add((BigDecimal) element[1]);
						helper.setData(Util.formatarData((Date) element[2]));
						if(element[3] != null && !element[3].equals("")){
							helper.setTipoDebito((String) element[3]);
						}
						helper.setId((Integer) element[4]);
						helper.setHistorico(true);

						colecaoMovimentarPagamentosDevolucoes.add(helper);
					}
					retorno.setValorTotalDevolucoesHistorico(Util.formatarMoedaReal(valorTotal));
				}
			}
			retorno.setValorTotal(Util.formatarMoedaReal(Util.formatarMoedaRealparaBigDecimal(retorno.getValorTotalDevolucoes()).add(
							Util.formatarMoedaRealparaBigDecimal(retorno.getValorTotalDevolucoesHistorico()))));
			retorno.setColecaoMovimentarDevolucoes(colecaoMovimentarPagamentosDevolucoes);
			retorno.setQtdDevolucoes(qtdDevolucoes);

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar valores de arrecadação e devolução do aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 14/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public ValoresArrecadacaoDevolucaoAvisoBancarioHelper pesquisarValoresAvisoBancario(Integer idAvisoBancario)
					throws ErroRepositorioException{

		ValoresArrecadacaoDevolucaoAvisoBancarioHelper retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select " + " new " + ValoresArrecadacaoDevolucaoAvisoBancarioHelper.class.getName() + " ( "
							+ "avbc.valorArrecadacaoInformado, avbc.valorArrecadacaoCalculado, "
							+ "avbc.valorDevolucaoInformado, avbc.valorDevolucaoCalculado) " + "from AvisoBancario avbc "
							+ "where avbc.id = :idAvisoBancario ";

			retorno = (ValoresArrecadacaoDevolucaoAvisoBancarioHelper) session.createQuery(consulta).setInteger("idAvisoBancario",
							idAvisoBancario.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualizar Pagamentos
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public void atualizarAvisoBancarioPagamentos(Collection<Integer> idsPagamentos, Collection<Integer> idsPagamentosHistorico,
					Integer idAvisoBancarioD) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try{

			if(idsPagamentos != null && !idsPagamentos.isEmpty()){

				atualizarSituacaoPagamento = "UPDATE Pagamento "
								+ "SET avbc_id = :idAvisoBancarioD, pgmt_tmultimaalteracao = :dataAlteracao "
								+ "WHERE pgmt_id IN(:idsPagamentos)";

				Collection<Integer> ids = new ArrayList<Integer>();
				for(Integer id : idsPagamentos){
					ids.add(id);

					if(ids.size() == 100){

						session.createQuery(atualizarSituacaoPagamento).setInteger("idAvisoBancarioD", idAvisoBancarioD).setTimestamp(
										"dataAlteracao", new Date()).setParameterList("idsPagamentos", ids).executeUpdate();

						ids = new ArrayList<Integer>();
					}

				}
				if(ids != null && !ids.isEmpty()){

					session.createQuery(atualizarSituacaoPagamento).setInteger("idAvisoBancarioD", idAvisoBancarioD).setTimestamp(
									"dataAlteracao", new Date()).setParameterList("idsPagamentos", ids).executeUpdate();
					ids = null;
				}
			}

			if(idsPagamentosHistorico != null && !idsPagamentosHistorico.isEmpty()){

				atualizarSituacaoPagamento = "UPDATE PagamentoHistorico "
								+ "SET avbc_id = :idAvisoBancarioD, pghi_tmultimaalteracao = :dataAlteracao "
								+ "WHERE pghi_id IN(:idsPagamentosHistorico)";

				Collection<Integer> ids = new ArrayList<Integer>();
				for(Integer id : idsPagamentosHistorico){
					ids.add(id);

					if(ids.size() == 100){

						session.createQuery(atualizarSituacaoPagamento).setInteger("idAvisoBancarioD", idAvisoBancarioD).setTimestamp(
										"dataAlteracao", new Date()).setParameterList("idsPagamentosHistorico", ids).executeUpdate();
						ids = new ArrayList<Integer>();
					}

				}
				if(ids != null && !ids.isEmpty()){

					session.createQuery(atualizarSituacaoPagamento).setInteger("idAvisoBancarioD", idAvisoBancarioD).setTimestamp(
									"dataAlteracao", new Date()).setParameterList("idsPagamentosHistorico", ids).executeUpdate();
					ids = null;
				}

			}
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar valor de arrecadação calculado
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public void atualizarValorArrecadacaoAvisoBancario(String valorArrecadacaoCalculado, Integer idAvisoBancario)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try{

			atualizarSituacaoPagamento = "UPDATE AvisoBancario " + "SET avbc_vlarrecadacaocalculado = :valorArrecadacaoCalculado, "
							+ "avbc_tmultimaalteracao = :dataAlteracao " + "WHERE avbc_id = :idAvisoBancario";

			session.createQuery(atualizarSituacaoPagamento).setBigDecimal("valorArrecadacaoCalculado",
							Util.formatarMoedaRealparaBigDecimal(valorArrecadacaoCalculado)).setTimestamp("dataAlteracao", new Date())
							.setInteger("idAvisoBancario", idAvisoBancario).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar Devoluções
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public void atualizarAvisoBancarioDevolucoes(Collection<Integer> idsDevolucoes, Collection<Integer> idsDevolucoesHistorico,
					Integer idAvisoBancarioD) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try{
			if(idsDevolucoes != null && !idsDevolucoes.isEmpty()){
				atualizarSituacaoPagamento = "UPDATE Devolucao "
								+ "SET avbc_id = :idAvisoBancarioD, devl_tmultimaalteracao = :dataAlteracao "
								+ "WHERE devl_id IN(:idsDevolucoes)";

				session.createQuery(atualizarSituacaoPagamento).setInteger("idAvisoBancarioD", idAvisoBancarioD).setTimestamp(
								"dataAlteracao", new Date()).setParameterList("idsDevolucoes", idsDevolucoes).executeUpdate();
			}

			if(idsDevolucoesHistorico != null && !idsDevolucoesHistorico.isEmpty()){

				atualizarSituacaoPagamento = "UPDATE Devolucao "
								+ "SET avbc_id = :idAvisoBancarioD, dehi_tmultimaalteracao = :dataAlteracao "
								+ "WHERE dehi_id IN(:idsDevolucoesHistorico)";

				session.createQuery(atualizarSituacaoPagamento).setInteger("idAvisoBancarioD", idAvisoBancarioD).setTimestamp(
								"dataAlteracao", new Date()).setParameterList("idsDevolucoesHistorico", idsDevolucoesHistorico)
								.executeUpdate();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar valor de devolução calculado
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public void atualizarValorDevolucaoAvisoBancario(String valorDevolucaoInformado, String valorDevolucaoCalculado, Integer idAvisoBancario)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoPagamento;

		try{

			atualizarSituacaoPagamento = "UPDATE AvisoBancario " + "SET avbc_vldevolucaoinformado = :valorDevolucaoInformado, "
							+ "avbc_vldevolucaocalculado = :valorDevolucaoCalculado, " + "avbc_tmultimaalteracao = :dataAlteracao "
							+ "WHERE avbc_id = :idAvisoBancario";

			session.createQuery(atualizarSituacaoPagamento).setBigDecimal("valorDevolucaoInformado",
							Util.formatarMoedaRealparaBigDecimal(valorDevolucaoInformado)).setBigDecimal("valorDevolucaoCalculado",
							Util.formatarMoedaRealparaBigDecimal(valorDevolucaoCalculado)).setTimestamp("dataAlteracao", new Date())
							.setInteger("idAvisoBancario", idAvisoBancario).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores - Relatório
	 * 
	 * @author Ana Maria
	 * @date 13/07/2007
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> filtrarIdsMovimentoArrecadador(String codigoBanco, String codigoRemessa,
					String descricaoIdentificacaoServico, String idImovel, String numeroSequencialArquivo, Date dataGeracaoInicio,
					Date dataGeracaoFim, Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia,
					String indicadorAceitacao, String idConcessionaria) throws ErroRepositorioException{

		Collection<Integer> idsMovimentoArrecadador = null;
		StringBuilder sql = new StringBuilder();

		Session session = HibernateUtil.getSession();

		try{
			String condicionais = this.criarCondicionaisMovimentoArrecadador(codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
							idImovel, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim, ultimaAlteracaoInicio,
							ultimaAlteracaoFim, descricaoOcorrencia, indicadorAceitacao);

			String condicionaisConcessionaria = "";

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				condicionaisConcessionaria = " WHERE idConcessionaria = :idConcessionaria ";
			}

			sql.append("       SELECT id ");
			sql.append("       FROM (SELECT arrecadadorMovimento.armv_cdbanco AS codBanco, ");
			sql.append("             arrecadadorMovimento.armv_cdremessa AS codRemessa, ");
			sql.append("             arrecadadorMovimento.armv_dsidentificacaoservico AS descIdentServico, ");
			sql.append("             arrecadadorMovimento.armv_nnnsa AS numeroSeqArquivo, ");
			sql.append("             arrecadadorMovimento.armv_id AS id, ");
			sql.append("             arrecadadorMovimento.armv_dtgeracao AS dataGeracao, ");
			sql.append("             arrecadadorMovimento.armv_nnregistrosmovimento AS numRegistroMovimento, ");
			sql.append("             arrecadadorMovimento.armv_vltotalmovimento AS vlTotalMovimento, ");
			sql.append("             arrecadadorMovimento.armv_tmultimaalteracao AS ultimaAlteracao, ");
			sql.append("             arrecadadorMovimento.armv_nmbanco AS nomeBanco, ");
			sql.append("             (CASE arrecadadorMovimento.armv_dsidentificacaoservico WHEN 'DEBITO AUTOMATICO' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconveniodebaut = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              WHEN 'COBRANCA BANCARIA' then ");
			sql.append("              (SELECT concessionaria.conc_id ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconvenioboleto = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              ELSE ");
			sql.append("               (SELECT concessionaria.conc_id ");
			sql.append("                FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("                INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("                WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                  AND arrecadadorContrato.arct_cdconvenio = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              END) AS idConcessionaria, ");
			sql.append("             (CASE arrecadadorMovimento.armv_dsidentificacaoservico WHEN 'DEBITO AUTOMATICO' then ");
			sql.append("              (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconveniodebaut = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              WHEN 'COBRANCA BANCARIA' then ");
			sql.append("              (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("               FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("               INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("               WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                 AND arrecadadorContrato.arct_cdconvenioboleto = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              ELSE ");
			sql.append("               (SELECT concessionaria.conc_nmconcessionaria ");
			sql.append("                FROM arrecadador arrecadador ");
			sql.append("               INNER JOIN arrecadador_contrato arrecadadorContrato ");
			sql.append("                       ON arrecadadorContrato.arrc_id = arrecadador.arrc_id ");
			sql.append("                INNER JOIN concessionaria ON arrecadadorContrato.conc_id = concessionaria.conc_id ");
			sql.append("                WHERE arrecadador.arrc_cdagente = arrecadadorMovimento.armv_cdbanco ");
			sql.append("                  AND arrecadadorContrato.arct_cdconvenio = arrecadadorMovimento.armv_cdconvenio) ");
			sql.append("              END) AS nomeConcessionaria ");
			sql.append("             FROM arrecadador_movimento arrecadadorMovimento ");
			sql.append(condicionais);
			sql.append("            ) tabAux1 ");
			sql.append(condicionaisConcessionaria);

			SQLQuery sqlQuery = session.createSQLQuery(sql.toString());
			sqlQuery.addScalar("id", Hibernate.INTEGER);

			if(ultimaAlteracaoInicio != null && !ultimaAlteracaoInicio.equals("")){
				Date dataInicio = Util.formatarDataInicial(ultimaAlteracaoInicio);

				sqlQuery.setTimestamp("ultimaAlteracaoInicio", dataInicio);
			}

			if(ultimaAlteracaoFim != null && !ultimaAlteracaoFim.equals("")){
				Date dataFim = Util.formatarDataFinal(ultimaAlteracaoFim);

				sqlQuery.setTimestamp("ultimaAlteracaoFim", dataFim);
			}

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				sqlQuery.setString("idConcessionaria", idConcessionaria);
			}

			idsMovimentoArrecadador = sqlQuery.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return idsMovimentoArrecadador;
	}

	/**
	 * [UC0619] Gerar Relação de Acompanhamento dos Movimentos Arrecadadores por NSA
	 * 
	 * @author Ana Maria
	 * @date 12/07/2007
	 * @param idMovimentoArrecadador
	 * @return
	 */
	public Collection<MovimentoArrecadadoresPorNSAHelper> gerarMovimentoArrecadadoresNSA(Collection<Integer> idsArrecadadorMovimento,
					Integer codigoFormaArrecadacao, String idConcessionaria) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retornoConsulta1 = new ArrayList();
		Collection retornoConsulta2 = new ArrayList();
		Collection retornoConsulta3 = new ArrayList();
		Collection retornoTotal = new ArrayList();
		Collection<MovimentoArrecadadoresPorNSAHelper> retorno = new ArrayList();

		try{
			String condicaoConcessionaria = "";

			if(idConcessionaria != null && !idConcessionaria.equals("") && !idConcessionaria.equals("-1")){
				condicaoConcessionaria = " and arct.conc_id = " + idConcessionaria;
			}

			// Convenio
			retornoConsulta1 = this.gerarMovimentoArrecadadoresNSAConsultaUm(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconvenio");
			retornoTotal.addAll(retornoConsulta1);

			// Convenio - DebitoAutomatico
			retornoConsulta1 = this.gerarMovimentoArrecadadoresNSAConsultaUm(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconveniodebaut");
			retornoTotal.addAll(retornoConsulta1);

			// Convenio - BoletoBancario
			retornoConsulta1 = this.gerarMovimentoArrecadadoresNSAConsultaUm(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconvenioboleto");
			retornoTotal.addAll(retornoConsulta1);

			// Convenio
			retornoConsulta2 = this.gerarMovimentoArrecadadoresNSAConsultaDois(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconvenio");
			retornoTotal.addAll(retornoConsulta2);

			// Convenio - DebitoAutomatico
			retornoConsulta2 = this.gerarMovimentoArrecadadoresNSAConsultaDois(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconveniodebaut");
			retornoTotal.addAll(retornoConsulta2);

			// Convenio - BoletoBancario
			retornoConsulta2 = this.gerarMovimentoArrecadadoresNSAConsultaDois(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconvenioboleto");
			retornoTotal.addAll(retornoConsulta2);

			// Convenio
			retornoConsulta3 = this.gerarMovimentoArrecadadoresNSAConsultaTres(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconvenio");
			retornoTotal.addAll(retornoConsulta3);

			// Convenio - DebitoAutomatico
			retornoConsulta3 = this.gerarMovimentoArrecadadoresNSAConsultaTres(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconveniodebaut");
			retornoTotal.addAll(retornoConsulta3);

			// Convenio - BoletoBancario
			retornoConsulta3 = this.gerarMovimentoArrecadadoresNSAConsultaTres(idsArrecadadorMovimento, codigoFormaArrecadacao,
							idConcessionaria, session, condicaoConcessionaria, "arct_cdconvenioboleto");
			retornoTotal.addAll(retornoConsulta3);

			if(retornoTotal.size() > 0){
				MovimentoArrecadadoresPorNSAHelper helper = null;
				for(Iterator iter = retornoTotal.iterator(); iter.hasNext();){
					Object[] element = (Object[]) iter.next();
					helper = new MovimentoArrecadadoresPorNSAHelper();
					helper.setQtdeRegistros((Integer) element[0]);

					if(element[1] != null && !element[1].equals("")){
						helper.setBanco((String) element[1]);
					}

					helper.setDataGeracao((Date) element[2]);
					helper.setNsa((Integer) element[3]);
					helper.setValor((Long) element[4]);
					helper.setTarifa((BigDecimal) element[5]);
					helper.setFormaArrecadacao((String) element[6]);

					if(idConcessionaria != null && !idConcessionaria.equals("")){
						helper.setConcessionaria((String) element[7]);
					}

					retorno.add(helper);
				}
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Processamento Rápido
	 * 
	 * @author Raphael Rossiter
	 * @date 17/08/2007
	 * @return Collection<Conta>
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContaComPagamentoHistorico() throws ErroRepositorioException{

		Collection<Conta> retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{
			consulta = "SELECT b FROM Conta b " + "WHERE b.id IN(13527, 2861, 2079563, 2079188, 2077402, 1882161, "
							+ " 2077450, 2608045, 2545376, 53582, 53581, 53584, 53583, 53586, 53585, 53580, " + " 53579, 2606143) ";

			retorno = (Collection<Conta>) session.createQuery(consulta).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0626] Gerar Resumo de Metas Acumulado no Mês (CAERN)
	 * 
	 * @author Sávio Luiz
	 * @data 28/11/2007
	 * @author eduardo henrique
	 * @date 12/11/2008
	 *       Alteração de método para nao utilizar palavra-chave 'now'
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarPagamentoDeContas(Collection idsColecaoConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT pgmt.id " + "FROM Pagamento  pgmt " + "INNER JOIN pgmt.conta cnta "
							+ "WHERE cnta.id in (:colecaoIdsContas) and cnta.dataVencimentoConta < :dataAtual ";

			retorno = session.createQuery(consulta).setParameterList("colecaoIdsContas", idsColecaoConta).setDate("dataAtual", new Date())
							.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0739] Informar Situação de Expurgo do Pagamento
	 * 
	 * @author Sávio Luiz
	 * @data 02/01/2008
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarDadosPagamentoExpurgado(String dataPagamento, Integer idCliente) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT pgto.id,pgto.valorPagamento,pgto.indicadorExpurgado " + "FROM Pagamento pgto "
							+ "WHERE to_char( pgto.dataPagamento, 'dd/mm/yyyy' ) = :dataPagamento AND pgto.imovel.id in "
							+ "(SELECT clieImov.imovel.id FROM ClienteImovel clieImov "
							+ "	WHERE clieImov.clienteRelacaoTipo.id = :clienteResponsavel AND clieImov.cliente.id = :idCliente)";

			retorno = session.createQuery(consulta).setString("dataPagamento", dataPagamento).setInteger("clienteResponsavel",
							ClienteRelacaoTipo.RESPONSAVEL).setInteger("idCliente", idCliente).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0739] Informar Situação de Expurgo do Pagamento
	 * 
	 * @author Sávio Luiz
	 * @data 02/01/2008
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarDadosPagamentoHistoricoExpurgado(String dataPagamento, Integer idCliente) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT pgto.id,pgto.valorPagamento,pgto.indicadorExpurgado " + "FROM PagamentoHistorico pgto "
							+ "WHERE to_char( pgto.dataPagamento, 'dd/mm/yyyy' ) = :dataPagamento AND pgto.imovel.id in "
							+ "(SELECT clieImov.imovel.id FROM ClienteImovel clieImov "
							+ "	WHERE clieImov.clienteRelacaoTipo.id = :clienteResponsavel AND clieImov.cliente.id = :idCliente)";

			retorno = session.createQuery(consulta).setString("dataPagamento", dataPagamento).setInteger("clienteResponsavel",
							ClienteRelacaoTipo.RESPONSAVEL).setInteger("idCliente", idCliente).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0739] Informar Situação de Expurgadodo Pagamento
	 * 
	 * @author Sávio Luiz
	 * @date 04/01/2008
	 * @param idsPagamentos
	 * @return void
	 */
	public void atualizarSituacaoExpurgado(Collection colecaoPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		try{

			if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
				Iterator ite = colecaoPagamento.iterator();
				while(ite.hasNext()){
					Pagamento pagamento = (Pagamento) ite.next();

					String consulta;
					Integer retorno = null;
					String atualizarSituacaoPagamento;

					consulta = "SELECT pgto.id " + "FROM Pagamento pgto " + "WHERE pgto.id = :idPagamento";

					retorno = (Integer) session.createQuery(consulta).setInteger("idPagamento", pagamento.getId()).setMaxResults(1)
									.uniqueResult();

					if(retorno != null){
						atualizarSituacaoPagamento = "UPDATE Pagamento "
										+ "SET pgmt_icexpurgado = :indicadorExpurgado, pgmt_tmultimaalteracao = :dataAlteracao "
										+ "WHERE pgmt_id = :idPagamento";

						session.createQuery(atualizarSituacaoPagamento).setShort("indicadorExpurgado", pagamento.getIndicadorExpurgado())
										.setTimestamp("dataAlteracao", new Date()).setInteger("idPagamento", pagamento.getId())
										.executeUpdate();
					}else{
						atualizarSituacaoPagamento = "UPDATE PagamentoHistorico "
										+ "SET pghi_icexpurgado = :indicadorExpurgado, pghi_tmultimaalteracao = :dataAlteracao "
										+ "WHERE pgmt_id = :idPagamento";

						session.createQuery(atualizarSituacaoPagamento).setShort("indicadorExpurgado", pagamento.getIndicadorExpurgado())
										.setTimestamp("dataAlteracao", new Date()).setInteger("idPagamento", pagamento.getId())
										.executeUpdate();
					}
				}
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author eduardo henrique
	 * @date 18/08/2008
	 *       [UC0188] - Manter Guia de Pagamento
	 * @param idGuiaPagamento
	 *            - Guia de Pagamento a ser verificada
	 * @param prestacoesNaoConsideradas
	 *            - Nr's das Prestações que não serão consideradas para verificação. Ex.: As mesmas
	 *            podem estar sendo canceladas.
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaPrestacaoGuiaPagamento(Integer idGuiaPagamento, List prestacoesNaoConsideradas)
					throws ErroRepositorioException{

		Integer retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = " select guiaPagamento.id " + " from GuiaPagamentoPrestacao guiaPrestacao "
							+ " join guiaPrestacao.guiaPagamento guiaPagamento " + " where guiaPagamento.id = :idGuiaPagamento "
							+ " and guiaPrestacao.comp_id.numeroPrestacao not in (:numeroPrestacoesNaoConsideradas)";

			retorno = (Integer) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).setParameterList(
							"numeroPrestacoesNaoConsideradas", prestacoesNaoConsideradas).setMaxResults(1).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * @author Saulo Lima
	 * @date 23/01/2009
	 * @param idPagamento
	 * @return idContaGeral
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdDaContaGeralNoPagamento(Integer idPagamento) throws ErroRepositorioException{

		Integer retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String sql = "SELECT cnta_id AS idConta " + "FROM Pagamento " + "WHERE pgmt_id = " + idPagamento;

			List listaRetorno = session.createSQLQuery(sql).addScalar("idConta", Hibernate.INTEGER).list();

			if(listaRetorno != null && !listaRetorno.isEmpty()){
				retorno = (Integer) listaRetorno.iterator().next();
			}

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção pesquisada
		return retorno;
	}

	public List consultarPagamentoHistoricoSemAcrescimoImpontualidade(Integer grupoFaturamento) throws ErroRepositorioException{

		List retorno = new ArrayList<Object[]>();

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = " select ch.cnta_id as idConta, ch.cnhi_dtvencimentoconta as vencimentoOriginal, ph.pghi_dtpagamento as dataPagamento, to_char(ch.cnhi_dtvencimentoconta,'D') as dia"
							+ " from conta_historico ch "
							+ "  inner join pagamento_historico ph on ph.cnta_id = ch.cnta_id "
							+ "  left join municipio_feriado mf on mf.mfer_dtferiado = ch.cnhi_dtvencimentoconta "
							+ " where ((not mf.mfer_id is null) or (to_char(ch.cnhi_dtvencimentoconta,'D') = 7) "
							+ "  or (to_char(ch.cnhi_dtvencimentoconta,'D') = 1)) "
							+ "  and ph.pghi_dtpagamento >= to_date('09/02/2009', 'dd/mm/yyyy') "
							+ "  and (ph.pghi_dtpagamento - ch.cnhi_dtvencimentoconta) between 0 and 4 "
							+ "  and ch.cnhi_iccobrancamulta = 1 "
							+ "  and ch.imov_id in 	(select imovel.imov_id from imovel inner join rota on imovel.rota_id = rota.rota_id where rota.ftgr_id = :grupo) ";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("vencimentoOriginal",
							Hibernate.DATE).addScalar("dataPagamento", Hibernate.DATE).addScalar("dia", Hibernate.STRING).setParameter(
							"grupo", grupoFaturamento).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por consultar os dados de um PagamentoHistorico
	 * 
	 * @date 17/08/2009
	 * @author Virgínia Melo
	 * @param idPagamentoHistorico
	 * @return PagamentoHistorico
	 */
	public PagamentoHistorico consultarPagamentoHistorico(Integer idPagamentoHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PagamentoHistorico retorno = null;

		try{

			Criteria criteria = session.createCriteria(PagamentoHistorico.class).add(Expression.eq("id", idPagamentoHistorico))
							.setFetchMode("avisoBancario", FetchMode.JOIN).setFetchMode("avisoBancario.arrecadador", FetchMode.JOIN)
							.setFetchMode("documentoTipo", FetchMode.JOIN).setFetchMode("localidade", FetchMode.JOIN).setFetchMode(
											"cliente", FetchMode.JOIN).setFetchMode("arrecadacaoForma", FetchMode.JOIN).setFetchMode(
											"pagamentoSituacaoAtual", FetchMode.JOIN).setFetchMode("debitoTipo", FetchMode.JOIN)
							.setFetchMode("conta", FetchMode.JOIN).setFetchMode("guiaPagamentoGeral", FetchMode.JOIN).setFetchMode(
											"debitoACobrar", FetchMode.JOIN);

			List<PagamentoHistorico> lista = criteria.list();
			if(lista != null && !lista.isEmpty()){
				retorno = lista.get(0);
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer consultarQtdePagamentoHistoricoParaDebitoACobrarParcelamentoComPrestacaoNula(Integer idDebitoACobrar)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = new Integer(0);

		try{

			String sql = "select count(*) as contador from Pagamento_Historico where dbac_id = " + idDebitoACobrar
							+ " and pghi_nnprestacao is not null and  pghi_nnprestacao <> 0";

			List lista = session.createSQLQuery(sql).addScalar("contador", Hibernate.INTEGER).list();
			if(lista != null && !lista.isEmpty()){
				retorno = (Integer) lista.iterator().next();
			}

			/*
			 * Criteria criteria = session.createCriteria(PagamentoHistorico.class).
			 * .add(Expression.eq("debitoACobrar.id",
			 * idDebitoACobrar)).add(org.hibernate.criterion.RowCountProjection)
			 * List<PagamentoHistorico> lista = criteria.list();
			 */

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoCriteria(FiltroPagamentoHistorico filtroPagamentoHistorico)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection<PagamentoHistorico> retorno = null;
		try{
			Collection colecaoParametros = filtroPagamentoHistorico.getParametros();
			Collection colecaoCaminhos = filtroPagamentoHistorico.getColecaoCaminhosParaCarregamentoEntidades();

			Criteria criteria = session.createCriteria(PagamentoHistorico.class);
			for(Object objetoParam : colecaoParametros){
				if(objetoParam.getClass().equals(ParametroSimples.class)){
					ParametroSimples parametro = (ParametroSimples) objetoParam;
					criteria.add(Expression.eq(parametro.getNomeAtributo(), parametro.getValor()));
				}
			}
			for(Object objetoCaminho : colecaoCaminhos){
				String caminho = (String) objetoCaminho;
				criteria.setFetchMode(caminho, FetchMode.JOIN);
			}
			retorno = criteria.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Yara Souza
	 * @date 22/07/2010
	 */
	public Collection pesquisarArrecadadorMovimentoItem(Integer idArrecadadorMovimento, Short indicadorAceitacao)
					throws ErroRepositorioException{

		Collection<ArrecadadorMovimentoItem> retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			Criteria criteria = session.createCriteria(ArrecadadorMovimentoItem.class).add(
							Expression.eq("arrecadadorMovimento.id", idArrecadadorMovimento)).add(
							Expression.eq("indicadorAceitacao", indicadorAceitacao)).setFetchMode("arrecadadorMovimento", FetchMode.JOIN);

			retorno = criteria.list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * @author Yara Souza
	 * @date 22/07/2010
	 */
	public BigDecimal pesquisarValorDevolucao(Integer idAvisoBancario) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select sum(dev.valorDevolucao) from Devolucao dev " + " where dev.avisoBancario.id = :idAvisoBancario";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * @author Yara Souza
	 * @date 22/07/2010
	 */
	public BigDecimal pesquisarValorDevolucaoHistorico(Integer idAvisoBancario) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select sum(devh.valorDevolucao) from DevolucaoHistorico devh " + " where devh.avisoBancario.id = :idAvisoBancario";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idAvisoBancario", idAvisoBancario).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * @author Yara Souza
	 * @date 22/07/2010
	 */
	public Collection pesquisarAvisoBancarioPorMovimentoArrecadador(Integer idArrecadadorMovimento) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select avbc " + // 0
							"from AvisoBancario  avbc " + "where avbc.arrecadadorMovimento.id= :idArrecadadorMovimento";

			retorno = (Collection) session.createQuery(consulta).setInteger("idArrecadadorMovimento", idArrecadadorMovimento).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Yara Souza
	 * @date 22/07/2010
	 */
	public Collection pesquisarGuiaPagamentoHistorico(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select gphi " + "from GuiaPagamentoHistorico  gphi " + "where gphi.id= :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento.intValue()).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa a coleção de guias de pagamento categoria para o id da guia
	 * informada.
	 * 
	 * @author Vitor
	 * @date 14/08/2008
	 * @param idGuiaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoPrestacaoHistorico(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select guiaPagamentoPrestacaoHistorico "

			+ "from GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico "

			+ "where guiaPagamentoPrestacaoHistorico.guiaPagamento.id = :idGuiaPagamento";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Yara Souza
	 * @date 22/07/2010
	 */
	public PagamentoHistorico pesquisarPagamentoHistorico(Integer idGuiaPagamento) throws ErroRepositorioException{

		PagamentoHistorico retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select pmhi " + // 0
							"from PagamentoHistorico  pmhi " + "where gphi.id= :idGuiaPagamento";

			retorno = (PagamentoHistorico) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Saulo Lima
	 * @data 18/04/2006, 28/11/2006, 24/11/2008
	 * @author Yara Souza
	 * @data 29/07/2010
	 *       Acrescentando aviso bancário no retorno da consulta.
	 * @param anoMesReferenciaFaturamento
	 * @param idLocalidade
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return Collection<Object[]>
	 */
	public Collection<Object[]> pesquisarPagamentosPorGuiaPagamentoHistorico(Integer idLocalidade, Integer idGuiaPagamento,
					Integer numeroPrestacao, Integer idAvisoBancario) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta
							.append("SELECT pgmt.id, dotp.id, loca.id, imov.id, pgst.id, gphi.id, pgmt.valorPagamento, pgmt.dataPagamento,")
							.append(
											"pgmt.anoMesReferenciaPagamento, gphi.valorDebito, pgmt.numeroPrestacao, avbc.id , gpagGeral.indicadorHistorico ")
							.append("FROM Pagamento pgmt ").append("LEFT JOIN pgmt.documentoTipo dotp ").append(
											"LEFT JOIN pgmt.localidade loca ").append("LEFT JOIN pgmt.imovel imov ").append(
											"LEFT JOIN pgmt.pagamentoSituacaoAtual pgst ").append("LEFT JOIN pgmt.avisoBancario avbc ")
							.append("LEFT JOIN pgmt.guiaPagamentoGeral gpagGeral ").append(
											"INNER JOIN gpagGeral.guiaPagamentoHistorico gphi ").append("WHERE dotp.id = :guiaPagamento ")
							.append("AND gphi.id = :idGuiaPagamento AND pgmt.numeroPrestacao = :numeroPrestacao ").append(
											"AND loca.id = :idLocalidade ").append("AND avbc.id = :idAvisoBancario ").append(
											"ORDER BY gphi.id, pgmt.numeroPrestacao, pgmt.dataPagamento");

			retorno = session.createQuery(consulta.toString()).setInteger("guiaPagamento", DocumentoTipo.GUIA_PAGAMENTO).setInteger(
							"idLocalidade", idLocalidade).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger("numeroPrestacao",
							numeroPrestacao).setInteger("idAvisoBancario", idAvisoBancario).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Pesquisa a coleção de guias de pagamento categoria para o id da guia
	 * informada.
	 * 
	 * @author Vitor
	 * @date 14/08/2008
	 * @param idGuiaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaPagamentoPrestacaoHistorico> pesquisarGuiaPagamentoPrestacaoHistorico(Integer idGuiaPagamento,
					Integer numeroPrestacao) throws ErroRepositorioException{

		Collection<GuiaPagamentoPrestacaoHistorico> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select guiaPagamentoPrestacaoHistorico " + "from GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico "
							+ "inner join fetch guiaPagamentoPrestacaoHistorico.debitoCreditoSituacao dcst "
							+ "where guiaPagamentoPrestacaoHistorico.guiaPagamento.id = :idGuiaPagamento "
							+ "and guiaPagamentoPrestacaoHistorico.comp_id.numeroPrestacao = :numeroPrestacao ";

			retorno = (Collection<GuiaPagamentoPrestacaoHistorico>) session.createQuery(consulta).setInteger("idGuiaPagamento",
							idGuiaPagamento).setInteger("numeroPrestacao", numeroPrestacao).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por consultar os Débitos a Cobrar do Imóvel
	 * 
	 * @date 11/08/2010
	 * @author Yara Souza
	 */
	public Collection pesquisarDebitoACobrar(Integer idImovel, Integer idDebitoTipo) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select debitoACobrar " + "from DebitoACobrar debitoACobrar " + "inner join fetch debitoACobrar.imovel imovel "
							+ "inner join fetch debitoACobrar.debitoTipo debitoTipo " + "where imovel.id = :idImovel "
							+ "and debitoTipo.id = :idDebitoTipo ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idDebitoTipo", idDebitoTipo)
							.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por consultar os Débitos a Cobrar Histórico do Imóvel
	 * 
	 * @date 11/08/2010
	 * @author Yara Souza
	 */
	public Collection pesquisarDebitoACobrarHistorico(Integer idImovel, Integer idDebitoTipo) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select debitoACobrarHistorico " + "from DebitoACobrarHistorico debitoACobrarHistorico "
							+ "inner join fetch debitoACobrarHistorico.imovel imovel "
							+ "inner join fetch debitoACobrarHistorico.debitoTipo debitoTipo " + "where imovel.id = :idImovel "
							+ "and debitoTipo.id = :idDebitoTipo ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idDebitoTipo", idDebitoTipo)
							.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 */

	public Collection<Object[]> pesquisarPagamentosPorDebitoACobrarHistoricoComDebitoInformado(Integer idDebitoTipo, Integer idImovel,
					Integer prestacao) throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		String restricao = "";
		if(prestacao != null && prestacao.intValue() != 0){
			restricao = " and pgmt.numeroPrestacao  = " + prestacao + " ";
		}

		try{
			consulta = "SELECT pgmt, dotp.id, loca.id, imov.id, pgst.id " + "FROM Pagamento pgmt " + "LEFT JOIN pgmt.debitoACobrar dbac "
							+ "LEFT JOIN pgmt.documentoTipo dotp " + "LEFT JOIN pgmt.localidade loca " + "LEFT JOIN pgmt.imovel imov "
							+ "LEFT JOIN pgmt.pagamentoSituacaoAtual pgst "
							+ "WHERE dbac.id in ( SELECT dbac.id FROM  DebitoACobrarGeral dacg  "
							+ " INNER JOIN dacg.debitoACobrarHistorico dchi  " + " INNER JOIN dchi.imovel imovel  "
							+ " INNER JOIN dchi.debitoTipo dbtp  " + " WHERE  dacg.indicadorHistorico = 1 "
							+ " AND  imovel.id = :idImovel " + " AND  dbtp.id = :idDebitoTipo )" + restricao
							+ "ORDER BY pgmt.dataPagamento";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("idDebitoTipo", idDebitoTipo).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por consultar o ultimo cobranca documento
	 * 
	 * @date 13/05/2010
	 * @author Willian Pereira
	 * @param idContaHistorico
	 */
	@Deprecated
	public CobrancaDocumento consultarUltimoCobrancaDocumento(Integer idContaHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		CobrancaDocumento cobrancaDocumento = null;

		try{

			StringBuffer query1 = new StringBuffer();
			query1.append("select cd ");
			query1.append("from CobrancaDocumento cd ");
			query1.append("left join fetch cd.empresa empre ");
			query1.append("left join fetch empre.cobrancaContratos ct ");
			query1.append("left join fetch cd.cobrancaAcaoAtividadeComando caac ");
			query1.append("left join fetch cd.cobrancaAcaoAtividadeCronograma caacr ");
			query1.append("left join fetch cd.cobrancaAcao ca ");
			query1.append("where cd.id = ");
			query1.append("(select max(cdoc.id) from CobrancaDocumento cdoc ");
			query1.append("inner join cdoc.cobrancaDocumentoItems cdit ");
			query1.append("inner join cdit.contaGeral cg ");
			query1.append("inner join cg.contaHistorico ch where ch.id = :idContaHistorico)");

			cobrancaDocumento = (CobrancaDocumento) session.createQuery(query1.toString()).setInteger("idContaHistorico", idContaHistorico)
							.uniqueResult();

			if(cobrancaDocumento != null){

				StringBuffer query2 = new StringBuffer();
				query2.append("select os ");
				query2.append("from OrdemServico os ");
				query2.append("left join fetch os.servicoTipo servTipo ");
				query2.append("left join fetch os.supressaoTipo supreTipo ");
				query2.append("left join fetch os.corteTipo corteTipo ");
				query2.append("where os.cobrancaDocumento.id = :idCobrancaDocumento");

				Collection<OrdemServico> collOrdemServico = session.createQuery(query2.toString()).setInteger("idCobrancaDocumento",
								cobrancaDocumento.getId()).list();
				Set<OrdemServico> setOrdemServico = new HashSet<OrdemServico>();

				if(collOrdemServico != null && !collOrdemServico.isEmpty()){
					setOrdemServico.addAll(collOrdemServico);
				}
				cobrancaDocumento.setOrdensServico(setOrdemServico);

				if(cobrancaDocumento.getEmpresa() != null){

					Set<CobrancaContrato> contratos = cobrancaDocumento.getEmpresa().getCobrancaContratos();

					if(contratos != null && !contratos.isEmpty()){

						StringBuffer query3 = new StringBuffer();
						query3.append("select ccr ");
						query3.append("from CobrancaContratoRemuneracao ccr ");
						query3.append("inner join fetch ccr.contratoTipo ct ");
						query3.append("left join fetch ccr.cobrancaContratoRemuneracaoVencimentos ccrv ");
						query3.append("where ccr.cobrancaContrato.id = :idContrato");

						for(CobrancaContrato contrato : contratos){
							// entidade CobrancaContratoRemuneracao dropada
							// Collection<CobrancaContratoRemuneracao>
							// collCobrancaContratoRemuneracao = session
							// .createQuery(query3.toString()).setInteger("idContrato",
							// contrato.getId()).list();
							// Set<CobrancaContratoRemuneracao> setCobrancaContratoRemuneracao = new
							// HashSet<CobrancaContratoRemuneracao>();
							//
							// if(collCobrancaContratoRemuneracao != null &&
							// !collCobrancaContratoRemuneracao.isEmpty()){
							// setCobrancaContratoRemuneracao.addAll(collCobrancaContratoRemuneracao);
							// }
							// contrato.setCobrancaContratoRemuneracoes(setCobrancaContratoRemuneracao);
						}
					}
				}
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return cobrancaDocumento;
	}

	/**
	 * Método responsável por consultar o ultimo cobranca documento
	 * 
	 * @date 19/11/2010
	 * @author Saulo Lima
	 *         Melhorando Performance
	 * @param idContaHistorico
	 */
	public CobrancaDocumento consultarUltimoCobrancaDocumentoRemuneracao(Integer idContaHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		CobrancaDocumento cobrancaDocumento = null;
		StringBuffer query1 = new StringBuffer();

		try{

			query1.append("SELECT cd ");
			query1.append("FROM CobrancaDocumento cd ");
			query1.append("LEFT JOIN FETCH cd.empresa empre "); // fetch
			query1.append("LEFT JOIN FETCH empre.cobrancaContratos ct "); // fetch
			query1.append("LEFT JOIN cd.cobrancaAcaoAtividadeComando caac "); // fetch
			query1.append("LEFT JOIN cd.cobrancaAcaoAtividadeCronograma caacr "); // fetch
			query1.append("LEFT JOIN cd.cobrancaAcao ca "); // fetch
			query1.append("WHERE cd.id = ");
			query1.append("(SELECT MAX(cdoc.id) FROM CobrancaDocumento cdoc ");
			query1.append("INNER JOIN cdoc.cobrancaDocumentoItems cdit ");
			query1.append("INNER JOIN cdit.contaGeral cg ");
			query1.append("WHERE cg.id = :idContaHistorico ");
			query1.append("AND cg.indicadorHistorico = 1)");

			cobrancaDocumento = (CobrancaDocumento) session.createQuery(query1.toString()).setInteger("idContaHistorico", idContaHistorico)
							.uniqueResult();

			if(cobrancaDocumento != null){

				query1.delete(0, query1.length());

				query1.append("select os ");
				query1.append("from OrdemServico os ");
				query1.append("left join os.servicoTipo servTipo "); // fetch
				query1.append("left join os.supressaoTipo supreTipo "); // fetch
				query1.append("left join os.corteTipo corteTipo "); // fetch
				query1.append("where os.cobrancaDocumento.id = :idCobrancaDocumento");

				Collection<OrdemServico> collOrdemServico = session.createQuery(query1.toString()).setInteger("idCobrancaDocumento",
								cobrancaDocumento.getId()).list();

				Set<OrdemServico> setOrdemServico = new HashSet<OrdemServico>();

				if(collOrdemServico != null && !collOrdemServico.isEmpty()){
					setOrdemServico.addAll(collOrdemServico);
				}
				cobrancaDocumento.setOrdensServico(setOrdemServico);
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
			query1 = null;
		}

		return cobrancaDocumento;
	}

	/**
	 * Método responsável por consultar o ultimo cobranca documento
	 * 
	 * @date 13/05/2010
	 * @author Willian Pereira
	 * @param idContaHistorico
	 */
	@Deprecated
	public ContaHistorico consultarContaHistorico(Integer idContaHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		ContaHistorico contaHistorico = null;

		try{

			StringBuffer query1 = new StringBuffer();
			query1.append("select ch ");
			query1.append("from ContaHistorico ch ");
			query1.append("left join fetch ch.parcelamento par ");
			query1.append("left join fetch par.cobrancaDocumento cd ");
			query1.append("left join fetch cd.empresa empre ");
			query1.append("left join fetch empre.cobrancaContratos ct ");
			query1.append("where ch.id = :idContaHistorico");

			contaHistorico = (ContaHistorico) session.createQuery(query1.toString()).setInteger("idContaHistorico", idContaHistorico)
							.uniqueResult();

			if(contaHistorico != null){

				if(contaHistorico.getParcelamento() != null && contaHistorico.getParcelamento().getCobrancaDocumento() != null){

					CobrancaDocumento cobrancaDocumentoParcelamento = contaHistorico.getParcelamento().getCobrancaDocumento();

					StringBuffer query2 = new StringBuffer();
					query2.append("select os ");
					query2.append("from OrdemServico os ");
					query2.append("left join fetch os.servicoTipo servTipo ");
					query2.append("left join fetch os.supressaoTipo supreTipo ");
					query2.append("left join fetch os.corteTipo corteTipo ");
					query2.append("where os.cobrancaDocumento.id = :idCobrancaDocumento");

					Collection<OrdemServico> collOrdemServico = session.createQuery(query2.toString()).setInteger("idCobrancaDocumento",
									cobrancaDocumentoParcelamento.getId()).list();
					Set<OrdemServico> setOrdemServico = new HashSet<OrdemServico>();

					if(collOrdemServico != null && !collOrdemServico.isEmpty()){
						setOrdemServico.addAll(collOrdemServico);
					}

					cobrancaDocumentoParcelamento.setOrdensServico(setOrdemServico);

					if(cobrancaDocumentoParcelamento.getEmpresa() != null){

						Set<CobrancaContrato> contratos = cobrancaDocumentoParcelamento.getEmpresa().getCobrancaContratos();

						if(contratos != null && !contratos.isEmpty()){
							StringBuffer query3 = new StringBuffer();
							query3.append("select ccr ");
							query3.append("from CobrancaContratoRemuneracao ccr ");
							query3.append("inner join fetch ccr.contratoTipo ct ");
							query3.append("left join fetch ccr.cobrancaContratoRemuneracaoVencimentos ccrv ");
							query3.append("where ccr.cobrancaContrato.id = :idContrato");

							for(CobrancaContrato contrato : contratos){
								// entidade CobrancaContratoRemuneracao dropada
								// Collection<CobrancaContratoRemuneracao>
								// collCobrancaContratoRemuneracao = session.createQuery(
								// query3.toString()).setInteger("idContrato",
								// contrato.getId()).list();
								// Set<CobrancaContratoRemuneracao> setCobrancaContratoRemuneracao =
								// new HashSet<CobrancaContratoRemuneracao>();
								//
								// if(collCobrancaContratoRemuneracao != null &&
								// !collCobrancaContratoRemuneracao.isEmpty()){
								// setCobrancaContratoRemuneracao.addAll(collCobrancaContratoRemuneracao);
								// }
								// contrato.setCobrancaContratoRemuneracoes(setCobrancaContratoRemuneracao);
							}
						}
					}
				}

				StringBuffer query4 = new StringBuffer();
				query4.append("select dch ");
				query4.append("from DebitoCobradoHistorico dch ");
				query4.append("left join fetch dch.parcelamento parc ");
				query4.append("left join fetch parc.cobrancaDocumento cdp ");
				query4.append("left join fetch cdp.empresa empre ");
				query4.append("left join fetch cdp.ordensServico os ");
				query4.append("where dch.contaHistorico.id = :idContaHistorico");

				Collection<DebitoCobradoHistorico> collDebitoCobradoHistorico = session.createQuery(query4.toString()).setInteger(
								"idContaHistorico", contaHistorico.getId()).list();
				Set<DebitoCobradoHistorico> setDebitoCobradoHistorico = new HashSet<DebitoCobradoHistorico>();

				if(collDebitoCobradoHistorico != null && !collDebitoCobradoHistorico.isEmpty()){
					for(DebitoCobradoHistorico debitoCobradoHistorico : collDebitoCobradoHistorico){
						setDebitoCobradoHistorico.add(debitoCobradoHistorico);

						if(debitoCobradoHistorico.getParcelamento() != null){

							CobrancaDocumento cobrancaDocumentoParcelamento = debitoCobradoHistorico.getParcelamento()
											.getCobrancaDocumento();

							if(cobrancaDocumentoParcelamento != null && cobrancaDocumentoParcelamento.getEmpresa() != null){

								Set<CobrancaContrato> contratos = cobrancaDocumentoParcelamento.getEmpresa().getCobrancaContratos();

								if(contratos != null && !contratos.isEmpty()){

									StringBuffer query5 = new StringBuffer();
									query5.append("select ccr ");
									query5.append("from CobrancaContratoRemuneracao ccr ");
									query5.append("inner join fetch ccr.contratoTipo ct ");
									query5.append("left join fetch ccr.cobrancaContratoRemuneracaoVencimentos ccrv ");
									query5.append("where ccr.cobrancaContrato.id = :idContrato");

									for(CobrancaContrato contrato : contratos){
										// entidade CobrancaContratoRemuneracao dropada
										// Collection<CobrancaContratoRemuneracao>
										// collCobrancaContratoRemuneracao = session.createQuery(
										// query5.toString()).setInteger("idContrato",
										// contrato.getId()).list();
										// Set<CobrancaContratoRemuneracao>
										// setCobrancaContratoRemuneracao = new
										// HashSet<CobrancaContratoRemuneracao>();
										//
										// if(collCobrancaContratoRemuneracao != null &&
										// !collCobrancaContratoRemuneracao.isEmpty()){
										// setCobrancaContratoRemuneracao.addAll(collCobrancaContratoRemuneracao);
										// }
										// contrato.setCobrancaContratoRemuneracoes(setCobrancaContratoRemuneracao);

									}
								}
							}
						}
					}
				}
				contaHistorico.setDebitoCobradoHistoricos(setDebitoCobradoHistorico);
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return contaHistorico;
	}

	public Parcelamento consultarParcelamentoConta(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Parcelamento parcelamento = null;
		Integer idParcelamento = null;

		StringBuffer query = new StringBuffer();
		try{

			query.append("SELECT c.parcelamento.id ");
			query.append("FROM Conta c ");
			query.append("WHERE c.id = :idConta");

			idParcelamento = (Integer) session.createQuery(query.toString()).setInteger("idConta", idConta).uniqueResult();

			if(idParcelamento != null){
				parcelamento = new Parcelamento();
				parcelamento.setId(idParcelamento);
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
			query = null;
		}

		return parcelamento;
	}

	public ContaHistorico consultarContaHistoricoRemuneracoes(Integer idContaHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		ContaHistorico contaHistorico = null;
		StringBuffer query1 = new StringBuffer();

		try{

			query1.append("SELECT ch ");
			query1.append("FROM ContaHistorico ch ");
			query1.append("LEFT JOIN fetch ch.debitoCobradoHistoricos dch "); // fetch
			query1.append("LEFT JOIN ch.parcelamento par "); // fetch
			query1.append("LEFT JOIN par.cobrancaDocumento cd "); // fetch
			query1.append("LEFT JOIN cd.empresa empre "); // fetch
			query1.append("LEFT JOIN empre.cobrancaContratos ct "); // fetch
			query1.append("LEFT JOIN ct.cobrancaContratoRemuneracoes ccr "); // fetch
			query1.append("LEFT JOIN ccr.cobrancaContratoRemuneracaoVencimentos ccrv "); // fetch
			query1.append("WHERE ch.id = :idContaHistorico");

			contaHistorico = (ContaHistorico) session.createQuery(query1.toString()).setInteger("idContaHistorico", idContaHistorico)
							.uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
			query1 = null;
		}

		return contaHistorico;
	}

	public Collection<DebitoCobradoHistorico> consultarHistoricoDebitoCobrado(Integer idContaHistorico) throws ErroRepositorioException{

		Collection<DebitoCobradoHistorico> listaDebitoHistorico = null;
		Session session = HibernateUtil.getSession();
		ContaHistorico ch = (ContaHistorico) session.load(ContaHistorico.class, idContaHistorico);
		try{

			// StringBuffer query = new
			// StringBuffer("select dc from ContaHistorico ch join fetch ch.debitoCobradoHistoricos dc where ch.id = :idContaHistorico");
			Hibernate.initialize(ch.getDebitoCobradoHistoricos());
			listaDebitoHistorico = ch.getDebitoCobradoHistoricos();

			for(DebitoCobradoHistorico debitoCobrado : listaDebitoHistorico){
				if(debitoCobrado.getParcelamento() != null && debitoCobrado.getParcelamento().getCobrancaDocumento() != null){
					Hibernate.initialize(debitoCobrado.getParcelamento().getCobrancaDocumento());
					Hibernate.initialize(debitoCobrado.getParcelamento().getCobrancaDocumento().getEmpresa());
					if(debitoCobrado.getParcelamento().getCobrancaDocumento().getEmpresa() != null){
						Set<CobrancaContrato> listaContratos = debitoCobrado.getParcelamento().getCobrancaDocumento().getEmpresa()
										.getCobrancaContratos();
						Hibernate.initialize(listaContratos);
						if(listaContratos != null){
							for(CobrancaContrato c : listaContratos){
								// entidade CobrancaContratoRemuneracao dropada
								// Hibernate.initialize(c.getCobrancaContratoRemuneracoes());
							}
						}
					}
				}
			}

		}catch(HibernateException ex){
			ex.printStackTrace();
			throw new ErroRepositorioException(ex, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return listaDebitoHistorico;
	}

	public DebitoACobrar pesquisarDebitoACobrar(Integer idDebitoACobrar) throws ErroRepositorioException{

		DebitoACobrar retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "SELECT debitoACobrar FROM DebitoACobrar debitoACobrar " + "WHERE debitoACobrar.id = :idDebitoACobrar ";

			retorno = (DebitoACobrar) session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void atualizarIndPagamentoContaNaoClassif(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer atualizarValorExcedente = new StringBuffer();

		try{

			atualizarValorExcedente.append("UPDATE Conta cnta ").append("SET cnta.indicadorPagamento = 1 ").append(
							" WHERE cnta.id = :idConta ");

			Query query = session.createQuery(atualizarValorExcedente.toString()).setInteger("idConta", idConta);

			query.executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
			atualizarValorExcedente = null;
		}
	}

	public CobrancaDocumento consultarCobrancaDocumentoParcelamento(Integer idParcelamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		CobrancaDocumento cobrancaDocumento = null;

		StringBuffer query = new StringBuffer();
		try{

			query.append("SELECT p.cobrancaDocumento ");
			query.append("FROM Parcelamento p ");
			query.append("WHERE p.id = :idParcelamento");

			cobrancaDocumento = (CobrancaDocumento) session.createQuery(query.toString()).setInteger("idParcelamento", idParcelamento)
							.uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
			query = null;
		}

		return cobrancaDocumento;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadação' de acordo com a opção de totalização.
	 * 
	 * @author Hebert Falcão
	 * @created 22/07/2011
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorLocalidadePorSetorComercial(int anoMesReferencia, Integer idLocalidade,
					Integer idSetorComercial) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append(" select sum(ra.valorItemArrecadacao), ");
			consulta.append("        rt.descricao, ");
			consulta.append("        lt.descricao, ");
			consulta.append("        li.descricao, ");
			consulta.append("        lic.descricao, ");
			consulta.append("        lt.indicadorImpressao, ");
			consulta.append("        lt.indicadorTotal, ");
			consulta.append("        lt.id, ");
			consulta.append("        lt.lancamentoTipo.id, ");
			consulta.append("        ra.categoria.id, ");
			consulta.append("        ra.localidade.descricao, ");
			consulta.append("        ra.localidade.id, ");
			consulta.append("        rt.id, ");
			consulta.append("        ra.sequenciaTipoLancamento, ");
			consulta.append("        ra.sequenciaItemTipoLancamento, ");
			consulta.append("        ra.setorComercial.id, ");
			consulta.append("        ra.setorComercial.codigo, ");
			consulta.append("        ra.setorComercial.descricao ");
			consulta.append(" from ResumoArrecadacao ra ");
			consulta.append(" left join ra.lancamentoTipo lt ");
			consulta.append(" left join ra.lancamentoItem li ");
			consulta.append(" left join ra.lancamentoItemContabil lic ");
			consulta.append(" left join ra.recebimentoTipo rt ");
			consulta.append(" where ra.anoMesReferencia = :anoMesReferencia and ");
			consulta.append("       ra.localidade = :localidade and ");
			consulta.append("       (   ra.categoria.id = " + Categoria.RESIDENCIAL_INT);
			consulta.append("        or ra.categoria.id = " + Categoria.COMERCIAL_INT);
			consulta.append("        or ra.categoria.id = " + Categoria.INDUSTRIAL_INT);
			consulta.append("        or ra.categoria.id = " + Categoria.PUBLICO_INT + ") and ");
			consulta.append("       ra.setorComercial.id = :idSetorComercial ");
			consulta.append(" group by rt.descricao, lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, ");
			consulta.append("          lt.indicadorTotal, lt.id, lt.lancamentoTipo.id, ra.categoria.id, ra.localidade.descricao, ");
			consulta.append("          ra.localidade.id, rt.id, ra.sequenciaTipoLancamento, ra.sequenciaItemTipoLancamento, ");
			consulta.append("          ra.setorComercial.id, ra.setorComercial.codigo, ra.setorComercial.descricao ");
			consulta.append(" order by ra.setorComercial.id, rt.id, ra.sequenciaTipoLancamento, ");
			consulta.append("          ra.sequenciaItemTipoLancamento, ra.categoria.id");

			retorno = session.createQuery(consulta.toString()).setInteger("anoMesReferencia", anoMesReferencia).setInteger("localidade",
							idLocalidade).setInteger("idSetorComercial", idSetorComercial).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta dados da tabela dados diarios arrecadacao
	 * 
	 * @author Genival Barbosa
	 * @created 25/07/2011
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarDadosRelatorioControleDocumentosArrecadacaoAnalitico(int anoMesReferencia, Integer idArrecadador,
					Integer idArrecadaoForma) throws ErroRepositorioException{

		Collection<ArrecadacaoDadosDiarios> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "select arrecadacaoForma.id, arrecadacaoForma.descricao, arrecadacaoDadosDiarios.dataPagamento, "
							+ " arrecadador.id, cliente.nome, "
							+ " sum(arrecadacaoDadosDiarios.quantidadePagamentos), sum(arrecadacaoDadosDiarios.valorPagamentos), arrecadador.codigoAgente "
							+ " from ArrecadacaoDadosDiarios arrecadacaoDadosDiarios "
							+ " INNER JOIN arrecadacaoDadosDiarios.arrecadador arrecadador "
							+ " INNER JOIN arrecadacaoDadosDiarios.arrecadacaoForma arrecadacaoForma "
							+ " INNER JOIN arrecadador.cliente cliente "
							+ " where arrecadacaoDadosDiarios.anoMesReferenciaArrecadacao = :anoMesReferencia ";

			if(idArrecadador != null){
				consulta = consulta + " and arrecadador.id = :idArrecadador ";
			}
			if(idArrecadaoForma != null){
				consulta = consulta + " and arrecadacaoForma.id = :idArrecadacaoForma ";
			}

			consulta = consulta + " GROUP BY arrecadacaoForma.id, arrecadacaoForma.descricao, arrecadacaoDadosDiarios.dataPagamento, "
							+ " arrecadador.id, cliente.nome, arrecadador.codigoAgente "
							+ " ORDER BY arrecadador.id, arrecadacaoDadosDiarios.dataPagamento asc ";

			Query query = session.createQuery(consulta);
			query.setInteger("anoMesReferencia", anoMesReferencia);
			if(idArrecadador != null){
				query.setInteger("idArrecadador", idArrecadador);
			}
			if(idArrecadaoForma != null){
				query.setInteger("idArrecadacaoForma", idArrecadaoForma);
			}

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Retorna imovel com os dados para o processamento de código de barras para o legado do cliente
	 * DESO.
	 * 
	 * @author Péricles Tavares
	 * @created 15/09/2011
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Imovel pesquisarImovelCodigoBarrasLegadoDESO(Integer idImovel) throws ErroRepositorioException{

		// cria a coleção de retorno

		Imovel imovel = null;

		// Query

		String consulta = "";

		// obtém a sessão

		Session session = HibernateUtil.getSession();

		try{

			consulta = "SELECT imov " + " FROM Imovel imov "

			+ " LEFT JOIN FETCH imov.imovelPerfil imovelPerfil "

			+ " LEFT JOIN FETCH imov.localidade lo"

			+ " LEFT JOIN FETCH imov.setorComercial sc"

			+ " WHERE "

			+ " imov.id = :idImovel";

			imovel = (Imovel) session.createQuery(consulta).setInteger(

			"idImovel", idImovel).setMaxResults(1).uniqueResult();

			// erro no hibernate

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			// fecha a sessão

			HibernateUtil.closeSession(session);

		}

		// retorna o imóvel

		return imovel;

	}

	/**
	 * Retorna Debito Tipo com os dados para o processamento de código de barras para o legado do
	 * cliente DESO.
	 * 
	 * @author Péricles Tavares
	 * @created 15/09/2011
	 * @return
	 * @throws ErroRepositorioException
	 */
	public DebitoTipo pesquisarDebitoTipoPorServicoTipo(Integer idServicoTipo) throws ErroRepositorioException{

		// cria a coleção de retorno

		DebitoTipo debitoTipo = null;

		// Query

		String consulta = "";

		// obtém a sessão

		Session session = HibernateUtil.getSession();

		try{

			consulta = "SELECT st.debitoTipo FROM ServicoTipo st "
							+ "LEFT JOIN st.debitoTipo dt LEFT JOIN FETCH dt.lancamentoItemContabil LEFT JOIN FETCH dt.financiamentoTipo "
							+ "WHERE st.id = :idServicoTipo";

			debitoTipo = (DebitoTipo) session.createQuery(consulta).setInteger(

			"idServicoTipo", idServicoTipo).setMaxResults(1).uniqueResult();

			// erro no hibernate

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			// fecha a sessão

			HibernateUtil.closeSession(session);

		}

		// retorna o imóvel

		return debitoTipo;

	}

	/**
	 * Retorna o Documento Cobranca com os dados para o processamento de código de barras para o
	 * legado do cliente DESO.
	 * 
	 * @author Péricles Tavares
	 * @created 16/09/2011
	 * @return
	 * @throws ErroRepositorioException
	 */
	public CobrancaDocumento pesquisarDocumentoCobrancaPorImovelSequencial(Integer idImovel, Integer numeroSequencialDocumento)
					throws ErroRepositorioException{

		// cria a coleção de retorno

		CobrancaDocumento cobrancaDocumento = null;

		// Query

		String consulta = "";

		// obtém a sessão

		Session session = HibernateUtil.getSession();

		try{

			consulta = "SELECT cobrancaDocumento FROM CobrancaDocumento cobrancaDocumento WHERE cobrancaDocumento.imovel.id = :idImovel and cobrancaDocumento.numeroSequenciaDocumento = :numeroSequencialDocumento";

			cobrancaDocumento = (CobrancaDocumento) session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger(
							"numeroSequencialDocumento", numeroSequencialDocumento).setMaxResults(1).uniqueResult();

			// erro no hibernate

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			// fecha a sessão

			HibernateUtil.closeSession(session);

		}

		// retorna o imóvel

		return cobrancaDocumento;

	}

	/**
	 * Retorna o Documento Cobranca Item com os dados para o processamento de código de barras para
	 * o legado do cliente DESO.
	 * 
	 * @author Péricles Tavares
	 * @date 16/09/2011
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(int idCobrancaDocumento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{
			consulta = "select cobrancaDocumentoItem from CobrancaDocumentoItem cobrancaDocumentoItem LEFT JOIN FETCH cobrancaDocumentoItem.contaGeral "
							+ "LEFT JOIN FETCH cobrancaDocumentoItem.contaGeral.conta LEFT JOIN FETCH cobrancaDocumentoItem.contaGeral.contaHistorico "
							+ "LEFT JOIN FETCH cobrancaDocumentoItem.debitoACobrarGeral LEFT JOIN FETCH cobrancaDocumentoItem.guiaPagamentoGeral "
							+ "LEFT JOIN FETCH cobrancaDocumentoItem.debitoACobrarGeral.debitoACobrar LEFT JOIN FETCH cobrancaDocumentoItem.guiaPagamentoGeral.guiaPagamento "
							+ "WHERE cobrancaDocumentoItem.cobrancaDocumento.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna a Guia Pagamento Prestacao com os dados para o processamento de código de barras para
	 * o legado do cliente DESO.
	 * 
	 * @author Péricles Tavares
	 * @date 16/09/2011
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public GuiaPagamentoPrestacao pesquisarGuiaPagamentoPrestacao(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		GuiaPagamentoPrestacao retorno = null;
		String consulta = null;

		try{
			consulta = "select guiaPagamentoPrestacao FROM GuiaPagamentoPrestacao guiaPagamentoPrestacao LEFT JOIN guiaPagamentoPrestacao.debitoTipo "
							+ "WHERE guiaPagamentoPrestacao.comp_id.guiaPagamentoId = :idGuiaPagamento and guiaPagamentoPrestacao.comp_id.numeroPrestacao = :numeroPrestacao";

			retorno = (GuiaPagamentoPrestacao) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger(
							"numeroPrestacao", numeroPrestacao).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna a Guia Pagamento Prestacao Historico com os dados para o processamento de código de
	 * barras para
	 * o legado do cliente DESO.
	 * 
	 * @author Péricles Tavares
	 * @date 16/09/2011
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public GuiaPagamentoPrestacaoHistorico pesquisarGuiaPagamentoHistoricoPrestacao(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		GuiaPagamentoPrestacaoHistorico retorno = null;
		String consulta = null;

		try{
			consulta = "select guiaPagamentoPrestacaoHistorico FROM from GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico LEFT JOIN guiaPagamentoPrestacaoHistorico.debitoTipo "
							+ "WHERE guiaPagamentoPrestacaoHistorico.comp_id.guiaPagamentoId = :idGuiaPagamento and guiaPagamentoPrestacaoHistorico.comp_id.numeroPrestacao = :numeroPrestacao";

			retorno = (GuiaPagamentoPrestacaoHistorico) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento)
							.setInteger("numeroPrestacao", numeroPrestacao).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores
	 * [SB0016] – Processar Pagamento Legado DESO
	 * Retorna a Guia Pagamento com os dados para o processamento de código de
	 * barras para
	 * o legado do cliente DESO.
	 * 
	 * @author Péricles Tavares
	 * @date 16/09/2011
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public GuiaPagamento pesquisarGuiaPagamentoNormalRetificadaIncluidaEntradaParcelamento(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		GuiaPagamento retorno = null;
		String consulta = null;

		try{
			consulta = "Select guiaPagamento from GuiaPagamentoPrestacao guiaPrestacao "
							+ "INNER JOIN guiaPrestacao.guiaPagamento guiaPagamento WHERE guiaPagamento.id = :idGuiaPagamento "
							+ "and guiaPrestacao.comp_id.numeroPrestacao =:numeroPrestacao "
							+ "and guiaPrestacao.debitoCreditoSituacao.id in (:debitoCreditoSituacaoAtual) ";

			retorno = (GuiaPagamento) session
							.createQuery(consulta)
							.setInteger("idGuiaPagamento", idGuiaPagamento)
							.setInteger("numeroPrestacao", numeroPrestacao)
							.setParameterList(
											"debitoCreditoSituacaoAtual",
											new Object[] {DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.RETIFICADA, DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO, DebitoCreditoSituacao.PRESCRITA})
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Bruno Ferreira dos Santos
	 * @throws ErroRepositorioException
	 * @date 26/09/2011
	 */
	public Collection pesquisarAcrescimoImpontualidade(Integer imovelId) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			Integer[] idAtualInt = null;

			String parametroVerificarSituacaoContaPermitida = (String) ParametroFaturamento.P_VERIFICAR_SITUACAO_CONTA.executar();

			if(parametroVerificarSituacaoContaPermitida != null
							&& parametroVerificarSituacaoContaPermitida.equals(ConstantesSistema.SIM.toString())){

				String[] idAtual = ((String) ParametroFaturamento.P_SITUACAO_CONTA_PERMITIDA.executar(ExecutorParametrosFaturamento
								.getInstancia())).split(",");

				idAtualInt = new Integer[idAtual.length];
				for(int i = 0; i < idAtual.length; i++){
					idAtualInt[i] = Util.obterInteger(idAtual[i]);
				}
			}

			String[] debitoTipo = ((String) ParametroFaturamento.P_DEBITO_TIPO_MULTA.executar(ExecutorParametrosFaturamento.getInstancia()))
							.split(",");
			Integer[] debitoTipoInt = new Integer[debitoTipo.length];
			for(int i = 0; i < debitoTipo.length; i++){
				debitoTipoInt[i] = Util.obterInteger(debitoTipo[i]);
			}

			consulta = " SELECT DISTINCT C.referencia, " + "   C.dataVencimentoConta, "
							+ "   ((C.valorAgua+C.valorEsgoto+C.debitos)-(C.valorCreditos+coalesce(C.valorImposto, 0))), "
							+ "   DC.valorDebito, " + "   (cast(P.dataPagamento as date) - cast(C.dataVencimentoConta as date)), "
							+ "   P.dataPagamento, " + "   DC.anoMesCobrancaDebito " + " FROM Conta C, " + "   DebitoACobrar DC, "
							+ "   Pagamento P " + " WHERE C.imovel.id              = DC.imovel.id "
							+ " AND C.imovel.id                = :idImovel " + " AND P.conta.id                = C.id "
							+ " AND C.referencia = DC.anoMesReferenciaDebito " + " AND DC.debitoTipo.id              IN (:debitoTipo) ";

			if(idAtualInt != null){
				consulta = consulta + " AND C.debitoCreditoSituacaoAtual.id  IN (:idAtual)  order by C.referencia desc  ";
				retorno = session.createQuery(consulta).setInteger("idImovel", imovelId).setParameterList("debitoTipo", debitoTipoInt)
								.setParameterList("idAtual", idAtualInt).list();
			}else{
				consulta = consulta + " order by C.referencia desc  ";
				retorno = session.createQuery(consulta).setInteger("idImovel", imovelId).setParameterList("debitoTipo", debitoTipoInt)
								.list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}catch(ControladorException e){
			throw new ErroRepositorioException(e, "Erro no Parametro");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Retorna o BoletoBancarioMovimentacao dado o ID do ArrecadadorMovimentoItem.
	 * 
	 * @author Péricles Tavares
	 * @date 06/10/2011
	 * @param idArrecadadorMovimentoItem
	 * @return BoletoBancarioMovimentacao
	 * @throws ErroRepositorioException
	 */
	public BoletoBancarioMovimentacao pesquisarBoletoBancarioMovimentacao(Integer idArrecadadorMovimentoItem)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		BoletoBancarioMovimentacao retorno = null;
		String consulta = null;

		try{
			consulta = "select boletoBancarioMovimentacao from BoletoBancarioMovimentacao boletoBancarioMovimentacao "
							+ "WHERE boletoBancarioMovimentacao.arrecadadorMovimentoItem.id = :idArrecadadorMovimentoItem";

			retorno = (BoletoBancarioMovimentacao) session.createQuery(consulta).setInteger("idArrecadadorMovimentoItem",
							idArrecadadorMovimentoItem).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna Guia de pagamento.
	 * 
	 * @param idGuiaPagamento
	 *            idGuiaPagamento
	 * @author Péricles Tavares
	 * @date 06/10/2011
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public GuiaPagamento pesquisarGuiaPagamentoCliente(Integer idGuiaPagamento) throws ErroRepositorioException{

		GuiaPagamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select gp from GuiaPagamento gp inner join gp.cliente clie inner join gp.imovel imo where gp.id = :idGuiaPagamento and where clie is not null";

			retorno = (GuiaPagamento) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna Documento cobranca.
	 * 
	 * @param idDocumentoCobranca
	 *            idDocumentoCobranca
	 * @author Péricles Tavares
	 * @date 06/10/2011
	 * @return Documento cobranca
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public CobrancaDocumento pesquisarDocumentoCobrancaCliente(Integer idDocumentoCobranca) throws ErroRepositorioException{

		CobrancaDocumento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select dc from CobrancaDocumento dc inner join dc.cliente clie inner join dc.imovel imo where dc.id = :idDocumentoCobranca and where clie is not null";

			retorno = (CobrancaDocumento) session.createQuery(consulta).setInteger("idDocumentoCobranca", idDocumentoCobranca)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna Boleto Bancário Lançamento Retorno.
	 * 
	 * @param idBoletoBancarioLancamentoRetorno
	 *            idBoletoBancarioLancamentoRetorno
	 * @author Péricles Tavares
	 * @date 06/10/2011
	 * @return Boleto Bancário Lançamento Retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public BoletoBancarioLancamentoRetorno pesquisarBoletoBancarioLancamentoRetorno(Integer idBoletoBancarioLancamentoRetorno)
					throws ErroRepositorioException{

		BoletoBancarioLancamentoRetorno retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select bblr from BoletoBancarioLancamentoRetorno bblr where bblr.id = :idBoletoBancarioLancamentoRetorno";

			retorno = (BoletoBancarioLancamentoRetorno) session.createQuery(consulta).setInteger("idBoletoBancarioLancamentoRetorno",
							idBoletoBancarioLancamentoRetorno).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o BoletoBancarioMotivoOcorrencia dado o ID do ArrecadadorMovimentoItem.
	 * 
	 * @author Péricles Tavares
	 * @date 06/10/2011
	 * @param idArrecadadorMovimentoItem
	 * @return BoletoBancarioMovimentacao
	 * @throws ErroRepositorioException
	 */
	public List<BoletoBancarioMotivoOcorrencia> pesquisarBoletoBancarioMotivoOcorrencia(Integer idArrecadadorMovimentoItem)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		List<BoletoBancarioMotivoOcorrencia> retorno = null;
		String consulta = null;

		try{
			consulta = "select bbo.boletoBancarioMotivoOcorrencia from BoletoBancarioOcorrencias bbo inner join bbo.boletoBancarioMotivoOcorrencia bbm "
							+ "WHERE bbo.boletoBancarioMovimentacao.arrecadadorMovimentoItem.id = :idArrecadadorMovimentoItem";

			retorno = (List<BoletoBancarioMotivoOcorrencia>) session.createQuery(consulta).setInteger("idArrecadadorMovimentoItem",
							idArrecadadorMovimentoItem).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o BoletoBancarioLancamentoEnvio dado o ID do idBoletoBancarioLancamentoEnvio.
	 * 
	 * @author Péricles Tavares
	 * @date 10/10/2011
	 * @param idBoletoBancarioLancamentoEnvio
	 * @return BoletoBancarioMovimentacao
	 * @throws ErroRepositorioException
	 */
	public BoletoBancarioLancamentoEnvio pesquisarBoletoBancarioLancamentoEnvio(Integer... idBoletoBancarioLancamentoEnvio)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		BoletoBancarioLancamentoEnvio retorno = null;
		String consulta = null;

		try{
			consulta = "select bble from BoletoBancarioLancamentoEnvio bble WHERE bble.id in (:idBoletoBancarioLancamentoEnvio)";

			retorno = (BoletoBancarioLancamentoEnvio) session.createQuery(consulta).setParameterList("idBoletoBancarioLancamentoEnvio",
							idBoletoBancarioLancamentoEnvio).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0017] – Gerar boletos bancários para prestações de guia de pagamento
	 * 
	 * @author Ailton Sousa
	 * @date 21/10/2011
	 * @param idGuiaPagamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarBoletoBancarioAssociadoParcelamento(Integer idGuiaPagamento) throws ErroRepositorioException{

		Integer idBoletoBancario = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select bb.bbco_id boleto from boleto_bancario bb " + " inner join guia_pagamento gp on gp.parc_id = bb.parc_id "
							+ " where gp.gpag_id = :idGuiaPagamento and bb.cbdo_id is not null and bb.bbco_idoriginal is null "
							+ " and not exists (select b2.bbco_id from boleto_bancario b2 where b2.bbco_idoriginal = bb.bbco_id)";

			SQLQuery query = session.createSQLQuery(consulta);

			query.addScalar("boleto", Hibernate.INTEGER);

			idBoletoBancario = (Integer) query.setInteger("idGuiaPagamento", idGuiaPagamento).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return idBoletoBancario;
	}

	/**
	 * [UC3024] – Processar Movimento de Retorno do Boleto Bancário
	 * [SB0002] – Inserir ocorrências do retorno
	 * Método que obtém os motivos de ocorrência restringindo ou não pelo tipo da ocorrência
	 * 
	 * @author Anderson Italo
	 * @date 21/10/2011
	 * @throws ErroRepositorioException
	 */
	public List<BoletoBancarioMotivoOcorrencia> pesquisarBoletoBancarioMotivoOcorrencia(Integer idTipoOcorrencia,
					String codigosMotivosOcorrencias) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		List<BoletoBancarioMotivoOcorrencia> retorno = null;
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("from BoletoBancarioMotivoOcorrencia motivoOcorrencia ");
			consulta.append("left join fetch motivoOcorrencia.boletoBancarioTipoOcorrencia tipoOcorrencia ");
			consulta.append(" where motivoOcorrencia.codigoMotivoOcorrencia in (" + codigosMotivosOcorrencias + ")");

			if(idTipoOcorrencia != null){

				consulta.append(" and tipoOcorrencia.id = " + idTipoOcorrencia.toString());
			}

			retorno = (List<BoletoBancarioMotivoOcorrencia>) session.createQuery(consulta.toString()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.arrecadacao.IRepositorioArrecadacao#pesquisarUltimoDebitoAutomaticoMovimentoConta(java
	 * .lang.Integer)
	 */
	public DebitoAutomaticoMovimento pesquisarUltimoDebitoAutomaticoMovimentoConta(Integer idConta) throws ErroRepositorioException{

		DebitoAutomaticoMovimento debitoAutomaticoMovimento = null;
		Session session = HibernateUtil.getSession();

		try{

			Criteria criteria = session.createCriteria(DebitoAutomaticoMovimento.class);
			criteria.add(Restrictions.eq("contaGeral.id", idConta));
			criteria.addOrder(Order.desc("id"));
			criteria.setMaxResults(1);

			debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) criteria.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

		return debitoAutomaticoMovimento;

	}

	/**
	 * [UC0319] – Gerar Movimento de Débito Automático para o Banco.
	 * 
	 * @author Ailton Sousa
	 * @date 03/11/2011
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarDataVencimentoGuiaPagamentoPrestacao(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try{
			consulta = "select guiaPagamentoPrestacao.dataVencimento FROM GuiaPagamentoPrestacao guiaPagamentoPrestacao "
							+ "WHERE guiaPagamentoPrestacao.comp_id.guiaPagamentoId = :idGuiaPagamento and guiaPagamentoPrestacao.comp_id.numeroPrestacao = :numeroPrestacao";

			retorno = (Date) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger("numeroPrestacao",
							numeroPrestacao).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0319] – Gerar Movimento de Débito Automático para o Banco.
	 * Pesquisa o valor total da guia de pagamentro prestação, pela guia de pagamento e pelo número
	 * da prestação.
	 * 
	 * @author Ailton Sousa
	 * @date 03/11/2011
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorTotalGuiaPagamentoPrestacao(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		String consulta = null;

		try{
			consulta = "select sum(guiaPagamentoPrestacao.valorPrestacao) FROM GuiaPagamentoPrestacao guiaPagamentoPrestacao "
							+ "WHERE guiaPagamentoPrestacao.comp_id.guiaPagamentoId = :idGuiaPagamento and guiaPagamentoPrestacao.comp_id.numeroPrestacao = :numeroPrestacao";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger(
							"numeroPrestacao", numeroPrestacao).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 */
	public Collection pesquisarAcrescimoImpontualidadeHistorico(Integer imovelId) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			Integer[] idAtualInt = null;

			String parametroVerificarSituacaoContaPermitida = (String) ParametroFaturamento.P_VERIFICAR_SITUACAO_CONTA.executar();

			if(parametroVerificarSituacaoContaPermitida != null
							&& parametroVerificarSituacaoContaPermitida.equals(ConstantesSistema.SIM.toString())){

				String[] idAtual = ((String) ParametroFaturamento.P_SITUACAO_CONTA_PERMITIDA.executar(ExecutorParametrosFaturamento
								.getInstancia())).split(",");

				idAtualInt = new Integer[idAtual.length];
				for(int i = 0; i < idAtual.length; i++){
					idAtualInt[i] = Util.obterInteger(idAtual[i]);
				}
			}

			String[] debitoTipo = ((String) ParametroFaturamento.P_DEBITO_TIPO_MULTA.executar(ExecutorParametrosFaturamento.getInstancia()))
							.split(",");
			Integer[] debitoTipoInt = new Integer[debitoTipo.length];
			for(int i = 0; i < debitoTipo.length; i++){
				debitoTipoInt[i] = Util.obterInteger(debitoTipo[i]);
			}

			consulta = " SELECT DISTINCT CH.anoMesReferenciaConta, " + "   CH.dataVencimentoConta, "
							+ "   ((CH.valorAgua+CH.valorEsgoto+CH.valorDebitos)-(CH.valorCreditos+coalesce(CH.valorImposto, 0))), "
							+ "   DCH.valorDebito, " + "   (cast(PH.dataPagamento as date) - cast(CH.dataVencimentoConta as date)), "
							+ "   PH.dataPagamento, " + "   DCH.anoMesCobrancaDebito " + " FROM ContaHistorico CH, "
							+ "   DebitoACobrarHistorico DCH, " + "   PagamentoHistorico PH "
							+ " WHERE CH.imovel.id              = DCH.imovel.id " + " AND CH.imovel.id                = :idImovel "
							+ " AND PH.conta.id                = CH.id " + " AND CH.anoMesReferenciaConta = DCH.anoMesReferenciaDebito "
							+ " AND DCH.debitoTipo.id              IN (:debitoTipo) ";

			if(idAtualInt != null){
				consulta = consulta + " AND CH.debitoCreditoSituacaoAtual.id  IN (:idAtual)  order by CH.anoMesReferenciaConta desc  ";
				retorno = session.createQuery(consulta).setInteger("idImovel", imovelId).setParameterList("debitoTipo", debitoTipoInt)
								.setParameterList("idAtual", idAtualInt).list();
			}else{
				consulta = consulta + " order by CH.anoMesReferenciaConta desc  ";
				retorno = session.createQuery(consulta).setInteger("idImovel", imovelId).setParameterList("debitoTipo", debitoTipoInt)
								.list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}catch(ControladorException e){
			throw new ErroRepositorioException(e, "Erro no Parametro");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0276] - Encerrar Arrecadação do Mês
	 * Pesquisa os pagamentos não classificados, que são os do ano/mês de
	 * referência igual ou anterior ao da arrecadação e que estão não
	 * classificados,com situação atual diferente de pagamento classificado e de
	 * baixar valor excedente
	 * 
	 * @author Josenildo Neves
	 * @date 02/03/2012
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoNaoClassificado(Integer anoMes) throws ErroRepositorioException{

		// Cria a varável que vai armazenar a coleção de retorno da pesquisa
		Collection<Pagamento> retorno = null;

		// Cria uma instância da sessão
		Session session = HibernateUtil.getSession();

		// Cria a variável que vai conter o hql
		String consulta = "";

		try{

			// Cria o hql de pesquisa
			consulta = "from Pagamento pgmt " + " where pgmt.anoMesReferenciaArrecadacao = :anoMes"
							+ " and pgmt.pagamentoSituacaoAtual.id <> :pagamentoClassificado";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("pagamentoClassificado",
							PagamentoSituacao.PAGAMENTO_CLASSIFICADO).list();

			// Erro no hibernate
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores
	 * [SB0002] – Processar Pagamento de Guia de Pagamento Matrícula
	 * 
	 * @author Anderson
	 * @date 09/03/2012
	 */
	public GuiaPagamentoHistorico pesquisarGuiaPagamentoHistoricoNormalRetificadaIncluidaEntradaParcelamento(Integer idGuiaPagamento,
					Integer numeroPrestacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		GuiaPagamentoHistorico retorno = null;
		String consulta = null;

		try{
			consulta = "select guiaPrestacao.guiaPagamento from GuiaPagamentoPrestacaoHistorico guiaPrestacao "
							+ "where guiaPrestacao.comp_id.guiaPagamentoId = :idGuiaPagamento "
							+ "and guiaPrestacao.comp_id.numeroPrestacao = :numeroPrestacao "
							+ "and guiaPrestacao.debitoCreditoSituacao.id in (:debitoCreditoSituacaoAtual) ";

			retorno = (GuiaPagamentoHistorico) session
							.createQuery(consulta)
							.setInteger("idGuiaPagamento", idGuiaPagamento)
							.setInteger("numeroPrestacao", numeroPrestacao)
							.setParameterList(
											"debitoCreditoSituacaoAtual",
											new Object[] {DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.RETIFICADA, DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO})
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void atualizarContaESituacaoPagamento(String idsPagamento, Integer idConta, Integer idSituacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "UPDATE Pagamento pgmt SET pgmt.conta.id = " + idConta.toString() + ", pgmt.pagamentoSituacaoAtual.id = "
							+ idSituacao.toString() + " WHERE pgmt.id in ( " + idsPagamento + ")";

			session.createQuery(consulta).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * Método que obtém os dados do último movimento processado para gerar o relatório e enviar por
	 * email
	 * 
	 * @author Anderson Italo
	 * @date 11/03/2010
	 * @throws ErroRepositorioException
	 */
	public ArrecadadorMovimento obterUltimoMovimentoGerado() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		ArrecadadorMovimento retorno = null;
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("from ArrecadadorMovimento movimento ");
			consulta.append(" where movimento.id  = (select max(movimento2.id) from ArrecadadorMovimento movimento2) ");

			retorno = (ArrecadadorMovimento) session.createQuery(consulta.toString()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3046] Filtrar Guia Pagamento Para Geração Débito Automático
	 * 
	 * @author Carlos Chrystian
	 * @created 20/03/2012
	 *          Filtrar Guia Pagamento Para Geração Débito Automático.
	 */
	public Collection pesquisarGuiaPagamentoPrestacao(Date dataVencimentoGuiaPagamentoInicial, Date dataVencimentoGuiaPagamentoFinal,
					Integer clienteResponsavel, Short indicadorTipoGuia, Integer pageOffset) throws ErroRepositorioException{

		// Objeto de retorno
		Collection retorno = null;

		// Cria sessão
		Session session = HibernateUtil.getSession();

		// Armazena os parâmetros da consulta
		Map parameters = new HashMap();
		SQLQuery sqlquery = null;

		// Cria objeto de consulta
		String consulta = new String();
		Date dataAtual = new Date();

		try{
			consulta = ("SELECT ");
			consulta += ("gppr.gpag_id as guiaPagamento, "); // 1
			consulta += ("gppr.gppr_nnprestacao as numeroPrestacao, "); // 2
			consulta += ("gp.gpag_nnprestacaototal as numeroPrestacaoTotal, "); // 3
			consulta += ("gp.imov_id as idImovel,  "); // 4
			consulta += ("gppr.gppr_dtvencimento as dataVencimento, "); // 5
			consulta += ("sum(gppr_vlprestacao) as valorPrestacao "); // 6
			consulta += ("FROM guia_pagamento_prestacao gppr ");
			consulta += ("INNER JOIN guia_pagamento gp ON gppr.gpag_id = gp.gpag_id ");
			consulta += ("INNER JOIN imovel imov ON gp.imov_id = imov.imov_id ");
			consulta += ("INNER JOIN localidade loca ON imov.loca_id = loca.loca_id ");
			consulta += ("INNER JOIN municipio muni ON loca.muni_id = muni.muni_id ");
			consulta += ("INNER JOIN debito_automatico da ON imov.imov_id = da.imov_id ");
			consulta += ("WHERE ");
			consulta += ("da.deba_dtexclusao is null ");
			consulta += ("and muni.muni_nncnpjprefeitura is not null ");
			consulta += ("and muni.muni_nncnpjprefeitura <> ' ' ");
			consulta += ("and not exists(select gpag_id from boleto_bancario bb ");
			consulta += ("where gppr.gpag_id = bb.gpag_id and bb.bbco_nnprestacao = gppr.gppr_nnprestacao) ");
			consulta += ("and( ");
			consulta += ("not exists(select gpag_id from debito_automatico_movimento damv ");
			consulta += ("where gppr.gpag_id = damv.gpag_id and damv.damv_nnprestacao = gppr.gppr_nnprestacao) ");
			consulta += ("or exists(select gpag_id from debito_automatico_movimento damv ");
			consulta += ("where gppr.gpag_id = damv.gpag_id and damv.damv_nnprestacao = gppr.gppr_nnprestacao ");
			consulta += ("and damv.damv_nnnsaenvio is null and damc_id is null) ");
			consulta += ("or exists(select gpag_id from debito_automatico_movimento damv ");
			consulta += ("where gppr.gpag_id = damv.gpag_id	and damv.damv_nnprestacao = gppr.gppr_nnprestacao ");
			consulta += ("and damv.damv_nnnsaenvio is not null and damc_id is null ");
			consulta += ("and damv.damv_dtvencimento <= :dataAtual) ");
			consulta += (") ");

			parameters.put("dataAtual", dataAtual);

			if(!Util.isVazioOuBranco(dataVencimentoGuiaPagamentoInicial) && !Util.isVazioOuBranco(dataVencimentoGuiaPagamentoFinal)){
				consulta = consulta
								+ ("and gppr.gppr_dtvencimento between :dataVencimentoGuiaPagamentoInicial and :dataVencimentoGuiaPagamentoFinal ");
				parameters.put("dataVencimentoGuiaPagamentoInicial", dataVencimentoGuiaPagamentoInicial);
				parameters.put("dataVencimentoGuiaPagamentoFinal", dataVencimentoGuiaPagamentoFinal);
			}

			if(!Util.isVazioOuBranco(clienteResponsavel)){
				consulta += ("and exists(select * from cliente_guia_pagamento clgpg ");
				consulta += ("where gppr.gpag_id = clgpg.gpag_id and clgpg.crtp_id = 3 and clgpg.clie_id = :clienteResponsavel) ");
				parameters.put("clienteResponsavel", clienteResponsavel);
			}

			if(!Util.isVazioOuBranco(indicadorTipoGuia) && indicadorTipoGuia.equals(ConstantesSistema.INDICADOR_TIPO_GUIA_NAO_VENCIDA)){
				consulta += ("and gppr.gppr_dtvencimento >= :dataAtualIndicador ");
				parameters.put("dataAtualIndicador", dataAtual);
			}else if(!Util.isVazioOuBranco(indicadorTipoGuia) && indicadorTipoGuia.equals(ConstantesSistema.INDICADOR_TIPO_GUIA_VENCIDA)){
				consulta += ("and gppr.gppr_dtvencimento < :dataAtualIndicador ");
				parameters.put("dataAtualIndicador", dataAtual);
			}

			consulta += ("group by gppr.gpag_id, gppr.gppr_nnprestacao, gp.gpag_nnprestacaototal, ");
			consulta += ("gp.imov_id, gppr.gppr_dtvencimento ");
			consulta += ("order by gppr.gpag_id, gppr.gppr_nnprestacao, gp.gpag_nnprestacaototal, ");
			consulta += ("gp.imov_id, gppr.gppr_dtvencimento ");

			sqlquery = session.createSQLQuery(consulta).addScalar("guiaPagamento", Hibernate.INTEGER).addScalar("numeroPrestacao",
							Hibernate.INTEGER).addScalar("numeroPrestacaoTotal", Hibernate.INTEGER)
							.addScalar("idImovel", Hibernate.INTEGER).addScalar("dataVencimento", Hibernate.DATE).addScalar(
											"valorPrestacao", Hibernate.BIG_DECIMAL);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Integer){
					sqlquery.setInteger(key, (Integer) parameters.get(key));
				}else if(parameters.get(key) instanceof Date){
					sqlquery.setDate(key, (Date) parameters.get(key));
				}else{
					sqlquery.setParameter(key, parameters.get(key));
				}
			}

			if(pageOffset < 0){
				retorno = sqlquery.list();
			}else{
				retorno = sqlquery.setFirstResult(10 * pageOffset).setMaxResults(10).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3046] Filtrar Guia Pagamento Para Geração Débito Automático
	 * 
	 * @author Carlos Chrystian
	 * @created 20/03/2012
	 *          Filtrar Guia Pagamento Para Geração Débito Automático.
	 */
	public Integer pesquisarQuantidadeGuiaPagamentoPrestacao(Date dataVencimentoGuiaPagamentoInicial,
					Date dataVencimentoGuiaPagamentoFinal, Integer clienteResponsavel, Short indicadorTipoGuia)
					throws ErroRepositorioException{

		// Objeto de retorno
		Integer retorno = null;

		// Cria sessão
		Session session = HibernateUtil.getSession();

		// Armazena os parâmetros da consulta
		Map parameters = new HashMap();
		SQLQuery sqlquery = null;

		// Cria objeto de consulta
		String consulta = new String();
		Date dataAtual = new Date();

		try{
			consulta = ("SELECT count(distinct gppr.gpag_id) as contadorGuiaPagamento ");
			consulta += ("FROM guia_pagamento_prestacao gppr ");
			consulta += ("INNER JOIN guia_pagamento gp ON gppr.gpag_id = gp.gpag_id ");
			consulta += ("INNER JOIN imovel imov ON gp.imov_id = imov.imov_id ");
			consulta += ("INNER JOIN localidade loca ON imov.loca_id = loca.loca_id ");
			consulta += ("INNER JOIN municipio muni ON loca.muni_id = muni.muni_id ");
			consulta += ("INNER JOIN debito_automatico da ON imov.imov_id = da.imov_id ");
			consulta += ("WHERE ");
			consulta += ("da.deba_dtexclusao is null ");
			consulta += ("and muni.muni_nncnpjprefeitura is not null ");
			consulta += ("and muni.muni_nncnpjprefeitura <> ' ' ");
			consulta += ("and not exists(select gpag_id from boleto_bancario bb ");
			consulta += ("where gppr.gpag_id = bb.gpag_id and bb.bbco_nnprestacao = gppr.gppr_nnprestacao) ");
			consulta += ("and( ");
			consulta += ("not exists(select gpag_id from debito_automatico_movimento damv ");
			consulta += ("where gppr.gpag_id = damv.gpag_id and damv.damv_nnprestacao = gppr.gppr_nnprestacao) ");
			consulta += ("or exists(select gpag_id from debito_automatico_movimento damv ");
			consulta += ("where gppr.gpag_id = damv.gpag_id and damv.damv_nnprestacao = gppr.gppr_nnprestacao ");
			consulta += ("and damv.damv_nnnsaenvio is null and damc_id is null) ");
			consulta += ("or exists(select gpag_id from debito_automatico_movimento damv ");
			consulta += ("where gppr.gpag_id = damv.gpag_id	and damv.damv_nnprestacao = gppr.gppr_nnprestacao ");
			consulta += ("and damv.damv_nnnsaenvio is not null and damc_id is null ");
			consulta += ("and damv.damv_dtvencimento <= :dataAtual) ");
			consulta += (") ");

			parameters.put("dataAtual", dataAtual);

			if(!Util.isVazioOuBranco(dataVencimentoGuiaPagamentoInicial) && !Util.isVazioOuBranco(dataVencimentoGuiaPagamentoFinal)){
				consulta = consulta
								+ ("and gppr.gppr_dtvencimento between :dataVencimentoGuiaPagamentoInicial and :dataVencimentoGuiaPagamentoFinal ");
				parameters.put("dataVencimentoGuiaPagamentoInicial", dataVencimentoGuiaPagamentoInicial);
				parameters.put("dataVencimentoGuiaPagamentoFinal", dataVencimentoGuiaPagamentoFinal);
			}

			if(!Util.isVazioOuBranco(clienteResponsavel)){
				consulta += ("and exists(select * from cliente_guia_pagamento clgpg ");
				consulta += ("where gppr.gpag_id = clgpg.gpag_id and clgpg.crtp_id = 3 and clgpg.clie_id = :clienteResponsavel) ");
				parameters.put("clienteResponsavel", clienteResponsavel);
			}

			if(!Util.isVazioOuBranco(indicadorTipoGuia) && indicadorTipoGuia.equals(ConstantesSistema.INDICADOR_TIPO_GUIA_NAO_VENCIDA)){
				consulta += ("and gppr.gppr_dtvencimento >= :dataAtualIndicador ");
				parameters.put("dataAtualIndicador", dataAtual);
			}else if(!Util.isVazioOuBranco(indicadorTipoGuia) && indicadorTipoGuia.equals(ConstantesSistema.INDICADOR_TIPO_GUIA_VENCIDA)){
				consulta += ("and gppr.gppr_dtvencimento < :dataAtualIndicador ");
				parameters.put("dataAtualIndicador", dataAtual);
			}

			sqlquery = session.createSQLQuery(consulta).addScalar("contadorGuiaPagamento", Hibernate.INTEGER);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Integer){
					sqlquery.setInteger(key, (Integer) parameters.get(key));
				}else if(parameters.get(key) instanceof Date){
					sqlquery.setDate(key, (Date) parameters.get(key));
				}else{
					sqlquery.setParameter(key, parameters.get(key));
				}
			}

			if(!Util.isVazioOuBranco(sqlquery.setMaxResults(1).uniqueResult())){
				retorno = ((Number) sqlquery.setMaxResults(1).uniqueResult()).intValue();
			}else{
				retorno = 0;
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * Remover Guia de Pagamento Categoria
	 * 
	 * @author Hebert Falcão
	 * @date 27/04/2012
	 */
	public void removerGuiaPagamentoCategoria(Integer idGuiaPagamento, Short numeroPrestacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("DELETE FROM GuiaPagamentoCategoria gpcg ");
			consulta.append("WHERE gpcg.comp_id.guiaPagamentoId = :idGuiaPagamento ");
			consulta.append("  AND gpcg.comp_id.numeroPrestacao = :numeroPrestacao ");

			session.createQuery(consulta.toString()).setInteger("idGuiaPagamento", idGuiaPagamento).setShort("numeroPrestacao",
							numeroPrestacao).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 */
	public void atualizarValorImpostoConta(Integer idConta, BigDecimal valorImposto) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("UPDATE gcom.faturamento.conta.Conta ");
			consulta.append("SET cnta_vlimpostos = :valorImposto ");
			consulta.append("WHERE cnta_id = :idConta ");

			session.createQuery(consulta.toString()).setBigDecimal("valorImposto", valorImposto).setInteger("idConta", idConta)
							.executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * @param idConta
	 * @throws ErroRepositorioException
	 */

	public void removerContaImpostosDeduzidos(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("DELETE FROM gcom.faturamento.conta.ContaImpostosDeduzidos ");
			consulta.append("WHERE cnta_id = :idConta ");

			session.createQuery(consulta.toString()).setInteger("idConta", idConta).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0001] - Validar Arquivo de Movimento de Arrecadador
	 * Verificar a já existência do Movimento em Questão na tabela ARRECADADOR_MOVIMENTO
	 * 
	 * @author Anderson Italo
	 * @date 13/05/2012
	 * @throws ErroRepositorioException
	 */
	public ArrecadadorMovimento pesquisaArrecadadorMovimentoExistente(Short codigoBanco, String codigoConvenio,
					Integer numeroSequencialArquivo) throws ErroRepositorioException{

		ArrecadadorMovimento retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("from ArrecadadorMovimento movimento where movimento.codigoBanco = :codigoBanco ");
			consulta.append("and movimento.codigoConvenio = :codigoConvenio ");
			consulta.append("and movimento.numeroSequencialArquivo = :numeroSequencialArquivo ");
			consulta.append("and movimento.codigoRemessa = :codigoRemessa ");

			retorno = (ArrecadadorMovimento) session.createQuery(consulta.toString()).setShort("codigoBanco", codigoBanco).setString(
							"codigoConvenio", codigoConvenio).setInteger("numeroSequencialArquivo", numeroSequencialArquivo).setShort(
							"codigoRemessa", ArrecadadorMovimento.CODIGO_RETORNO).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0268] Apresentar Análise do Aviso Bancário
	 * Obter Valor Total de Pagamentos Não Classificados associados ao Aviso Bancário
	 * 
	 * @author Anderson Italo
	 * @date 14/06/2012
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterValorTotalPagamentosNaoClassificadosPorAviso(AvisoBancario avisoBancario) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT SUM(pagt.valorPagamento) FROM Pagamento pagt WHERE pagt.avisoBancario.id = :idAvisoBancario ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idAvisoBancario", avisoBancario.getId().intValue())
							.setMaxResults(1).uniqueResult();

			if(retorno == null){

				retorno = BigDecimal.ZERO;
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0268] Apresentar Análise do Aviso Bancário
	 * Obter Valor Total de Pagamentos Classificados associados ao Aviso Bancário
	 * 
	 * @author Anderson Italo
	 * @date 14/06/2012
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterValorTotalPagamentosClassificadosPorAviso(AvisoBancario avisoBancario) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT SUM(pagt.valorPagamento) FROM PagamentoHistorico pagt WHERE pagt.avisoBancario.id = :idAvisoBancario ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idAvisoBancario", avisoBancario.getId().intValue())
							.setMaxResults(1).uniqueResult();

			if(retorno == null){

				retorno = BigDecimal.ZERO;
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0339] - Consultar Dados Diários da Arrecadação
	 * [SB0011] – Obter Valor Despesa Bancária do Arrecadador
	 * Obtém os dados da tarifa do arrecadador a partir da tabela ARRECADADOR_CONTRATO_TARIFA.
	 * 
	 * @author Josenildo Neves
	 * @date 19/06/2012
	 * @throws ErroRepositorioException
	 */
	public List<ArrecadadorContratoTarifaHelper> pesquisarArrecadadorContratoTarifaPorArrecadacaoDadosDiarios(
					Integer idArrecadacaoDadosDiarios, Integer anoMesArrecadacao, String localidade, String idElo, String setorComercial,
					String idGerenciaRegional, String unidadeNegocioId, String[] idsImovelPerfil, String[] idsLigacaoAgua,
					String[] idsLigacaoEsgoto, String[] idsCategoria, String[] idsEsferaPoder, String[] idsDocumentosTipos)
					throws ErroRepositorioException{

		ArrecadadorContratoTarifaHelper arrecadadorContratoTarifaHelper = new ArrecadadorContratoTarifaHelper();
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		List listaArrecadadorContratoTarifa = null;

		List<ArrecadadorContratoTarifaHelper> retorno = null;

		try{
			consulta.append("SELECT ");
			consulta.append("	act.ARCT_ID AS arrecadadorContratoId, ");
			consulta.append("	act.ARFM_ID AS arrecadacaoFormaId, ");
			consulta.append("	act.ACTF_VLTARIFA  AS valorTarifa, ");
			consulta.append("	act.ACTF_PCCALCULOTARIFA  AS percentualTarifa, ");
			consulta.append("	SUM(addi.ARDD_QTPAGAMENTOS) AS quantidadePagamentos, ");
			consulta.append("	SUM(addi.ARDD_VLPAGAMENTOS) AS valorPagamentos ");
			consulta.append("	,cl.cnlc_dtvigenciainicio AS dtIniVigencia ");
			consulta.append("FROM ARRECADADOR_CONTRATO_TARIFA act ");
			consulta.append("INNER JOIN ARRECADACAO_DADOS_DIARIOS addi ON act.ARFM_ID = addi.ARFM_ID ");
			consulta.append("INNER JOIN ARRECADADOR_CONTRATO ac ON act.ARCT_ID = ac.ARCT_ID ");
			consulta.append("inner join concessionaria_localidade cl on ac.CONC_ID = cl.CONC_ID and cl.loca_id = addi.loca_id ");
			consulta.append("inner join localidade l on l.loca_id = cl.loca_id ");
			
			consulta.append("WHERE ");
			consulta.append("	ac.ARCT_DTCONTRATOENCERRAMENTO IS NULL ");
			consulta.append("	AND ac.ARRC_ID = addi.ARRC_ID ");
			consulta.append("	AND addi.ARRC_ID = :idArrecadacaoDadosDiarios ");
			consulta.append("	AND addi.ARDD_AMREFERENCIAARRECADACAO =  :anoMesArrecadacao ");
			// consulta.append("	AND ac.conc_id = " + Concessionaria.EMPRESA_CONCEDENTE.toString());
			// consulta.append("	AND addi.LOCA_ID IS NOT NULL ");
			// consulta.append("	AND addi.STCM_ID IS NOT NULL ");

			// consulta.append("	and cl.cnlc_dtvigenciainicio = ");
			// consulta.append("	  (select max(cnlc_dtvigenciainicio) data ");
			// consulta.append("	    	from concessionaria_localidade b ");
			// consulta.append("	    	join arrecadacao_dados_diarios a on b.loca_id=a.loca_id ");
			// consulta.append("	    where b.cnlc_dtvigenciainicio<=addi.ardd_dtpagamento ");
			// consulta.append("	    and b.loca_id  = addi.loca_id group by b.loca_id ) ");

			if(Util.isNaoNuloBrancoZero(localidade)){
				consulta.append("	AND addi.LOCA_ID = " + localidade);
				if(Util.isNaoNuloBrancoZero(setorComercial)){
					consulta.append("	AND addi.STCM_ID  = " + setorComercial);
				}
			}

			if(Util.isNaoNuloBrancoZero(idGerenciaRegional) && !idGerenciaRegional.equals("-1")){
				consulta.append("	AND addi.GREG_ID  = " + idGerenciaRegional);
			}

			if(Util.isNaoNuloBrancoZero(unidadeNegocioId) && !unidadeNegocioId.equals("-1")){
				consulta.append("	AND addi.UNEG_ID  = " + unidadeNegocioId);
			}

			if(Util.isNaoNuloBrancoZero(idElo)){
				consulta.append("	AND l.LOCA_CDELO = " + idElo);
			}

			// Imovel Perfil
			addCondicaoFiltroDadosDiarios(idsImovelPerfil, consulta, "addi.iper_id");

			// Ligação água
			addCondicaoFiltroDadosDiarios(idsLigacaoAgua, consulta, "addi.last_id");

			// Ligação esgoto
			addCondicaoFiltroDadosDiarios(idsLigacaoEsgoto, consulta, "addi.lest_id");

			// Categorias
			addCondicaoFiltroDadosDiarios(idsCategoria, consulta, "addi.catg_id");

			// Esfera Poder
			addCondicaoFiltroDadosDiarios(idsEsferaPoder, consulta, "addi.epod_id");

			// Documento Tipo
			addCondicaoFiltroDadosDiarios(idsDocumentosTipos, consulta, "addi.dotp_id");

			consulta.append("	GROUP BY ");
			consulta.append("		addi.ARDD_AMREFERENCIAARRECADACAO, act.ARFM_ID, act.ARCT_ID, act.ACTF_VLTARIFA, act.ACTF_PCCALCULOTARIFA, act.ACTF_NNDIAFLOAT");
			consulta.append("	,cl.cnlc_dtvigenciainicio ");
			consulta.append("	ORDER BY ");
			consulta.append("		act.ARCT_ID ASC   ");
			consulta.append("		, cl.cnlc_dtvigenciainicio DESC   ");

			listaArrecadadorContratoTarifa = session.createSQLQuery(consulta.toString())
							.addScalar("arrecadadorContratoId", Hibernate.INTEGER).addScalar("arrecadacaoFormaId", Hibernate.INTEGER)
							.addScalar("valorTarifa", Hibernate.BIG_DECIMAL).addScalar("percentualTarifa", Hibernate.BIG_DECIMAL)
							.addScalar("quantidadePagamentos", Hibernate.INTEGER).addScalar("valorPagamentos", Hibernate.BIG_DECIMAL)
							.addScalar("dtIniVigencia", Hibernate.DATE)
							.setInteger("idArrecadacaoDadosDiarios", idArrecadacaoDadosDiarios)
							.setInteger("anoMesArrecadacao", anoMesArrecadacao).list();

			if(!Util.isVazioOrNulo(listaArrecadadorContratoTarifa)){

				retorno = new ArrayList<ArrecadadorContratoTarifaHelper>();

				for(Object object : listaArrecadadorContratoTarifa){

					Object objArrecadadorContratoTarifa[] = (Object[]) object;

					arrecadadorContratoTarifaHelper = new ArrecadadorContratoTarifaHelper();

					arrecadadorContratoTarifaHelper.setId((Integer) objArrecadadorContratoTarifa[0]);
					arrecadadorContratoTarifaHelper.setIdFormaArrecadacao((Integer) objArrecadadorContratoTarifa[1]);
					arrecadadorContratoTarifaHelper.setValorTarifa((BigDecimal) objArrecadadorContratoTarifa[2]);
					arrecadadorContratoTarifaHelper.setPercentualTarifa((BigDecimal) objArrecadadorContratoTarifa[3]);
					arrecadadorContratoTarifaHelper.setQuantidadePagamentos((Integer) objArrecadadorContratoTarifa[4]);
					arrecadadorContratoTarifaHelper.setValorPagamentos((BigDecimal) objArrecadadorContratoTarifa[5]);
					arrecadadorContratoTarifaHelper.setDataVigencia((Date) objArrecadadorContratoTarifa[6]);

					if(!retorno.contains(arrecadadorContratoTarifaHelper))
					retorno.add(arrecadadorContratoTarifaHelper);
				}
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	private void addCondicaoFiltroDadosDiarios(String[] arrayStringConsulta, StringBuilder consulta, String coluna){

		if(arrayStringConsulta != null && arrayStringConsulta.length > 0){
			String condicao = "";
			if(!arrayStringConsulta[0].equals(ConstantesSistema.NUMERO_NAO_INFORMADO + "")){
				int i = 0;
				consulta.append(" AND ( ");
				while(i < arrayStringConsulta.length){
					if(!arrayStringConsulta[i].equals("")){
						consulta.append(condicao);
						if(i + 1 < arrayStringConsulta.length){
							consulta.append(coluna + " = " + arrayStringConsulta[i]);
							condicao = " OR ";
						}else{
							consulta.append(coluna + " = " + arrayStringConsulta[i]);
							condicao = " AND ";
						}
					}
					i++;
				}
				consulta.append(" ) ");
			}
		}
	}

	/**
	 * [UC0235] - Inserir aviso bancário
	 * [SB0001] - Preparar Preenchimento da Conta Bancária
	 * 
	 * @author André Lopes
	 * @date 07/05/2013
	 * @throws ErroRepositorioException
	 */
	public List<ArrecadadorContrato> pesquisarContaBancaria(Integer idArrecadacao)  throws ErroRepositorioException{

		List<ArrecadadorContrato> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("  select cb ");
			consulta.append("  from ArrecadadorContrato cb ");
			consulta.append("  inner join fetch cb.contaBancariaDepositoArrecadacao cbda ");
			consulta.append("  inner join fetch cbda.agencia ag ");
			consulta.append("  inner join fetch ag.banco bco ");
			consulta.append("  inner join cb.arrecadador a ");

			consulta.append(" where cb.dataContratoEncerramento is null ");
			consulta.append(" and a.codigoAgente = :idArrecadacao ");

			retorno = session.createQuery(consulta.toString()).setInteger("idArrecadacao", idArrecadacao).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public ImovelCobrancaSituacao pesquisarImovelEmCobrancaAdministrativa(Integer idImovel) throws ErroRepositorioException{

		ImovelCobrancaSituacao retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("from ImovelCobrancaSituacao imovCobrancaSit where imovCobrancaSit.imovel.id = :idImovel ");
			consulta.append("and imovCobrancaSit.cobrancaSituacao.id = :idSituacao ");
			consulta.append("and imovCobrancaSit.dataRetiradaCobranca is null ");

			retorno = (ImovelCobrancaSituacao) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel).setInteger(
							"idSituacao", CobrancaSituacao.COBRANCA_ADMINISTRATIVA).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa
	 * Obtém os itens dos documentos de cobrança associados ao comando informado
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public Collection pesquisarItensCobrancaDocumentoPorComando(Integer idCobrancaAcaoAtividadeComando, Integer idConta,
					Integer idGuiaPagamento, Integer idImovel, Integer numeroPrestacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("SELECT cdi, "); // 0
			consulta.append("contaGeral.indicadorHistorico "); // 1
			consulta.append("FROM CobrancaDocumentoItem cdi ");
			consulta.append("LEFT JOIN cdi.cobrancaDocumento cd ");
			consulta.append("LEFT JOIN cdi.contaGeral contaGeral ");
			consulta.append("LEFT JOIN contaGeral.conta conta ");
			consulta.append("LEFT JOIN contaGeral.contaHistorico contaHistorico ");
			consulta.append("LEFT JOIN cdi.guiaPagamentoGeral guiaPagamentoGeral ");
			consulta.append("LEFT JOIN cdi.debitoACobrarGeral debitoACobrarGeral ");
			consulta.append("LEFT JOIN debitoACobrarGeral.debitoACobrar debitoACobrar ");
			consulta.append("LEFT JOIN debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico ");
			consulta.append("WHERE cd.cobrancaAcaoAtividadeComando.id = :idCobrancaAcaoAtividadeComando ");

			if(idConta != null){

				consulta.append("and contaGeral.id = :idConta ");
			}else if(idGuiaPagamento != null){

				consulta.append("and guiaPagamentoGeral.id = :idGuia ");
			}else{

				consulta.append("and cd.imovel.id = :idImovel ");
			}

			if(numeroPrestacao != null){

				consulta.append("and cdi.numeroDaPrestacao = " + numeroPrestacao.toString());
			}

			if(idConta != null){

				retorno = session.createQuery(consulta.toString()).setInteger("idCobrancaAcaoAtividadeComando",
								idCobrancaAcaoAtividadeComando).setInteger("idConta", idConta).list();
			}else if(idGuiaPagamento != null){

				retorno = session.createQuery(consulta.toString()).setInteger("idCobrancaAcaoAtividadeComando",
								idCobrancaAcaoAtividadeComando).setInteger("idGuia", idGuiaPagamento).list();
			}else{

				retorno = session.createQuery(consulta.toString()).setInteger("idCobrancaAcaoAtividadeComando",
								idCobrancaAcaoAtividadeComando).setInteger("idImovel", idImovel).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public DebitoCobradoHistorico pesquisarDebitoCobradoCobrancaAdministrativa(Integer idConta,
					String parametroTiposDebitosCobrancaAdministrativa, Date dataImplantacaoCobranca, Date dataRetiradaCobranca)
					throws ErroRepositorioException{

		DebitoCobradoHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select debito from DebitoCobradoHistorico debito  ");
			consulta.append("inner join debito.parcelamento parc ");
			consulta.append("where debito.contaHistorico.id = :idConta ");
			consulta.append("and debito.debitoTipo.id in (" + parametroTiposDebitosCobrancaAdministrativa.toString() + ") ");
			consulta.append("and parc.parcelamento >=  :dataImplantacaoCobranca ");

			if(dataRetiradaCobranca != null){

				consulta.append("and parc.parcelamento <=  :dataRetiradaCobranca");
				retorno = (DebitoCobradoHistorico) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setDate("dataRetiradaCobranca", dataRetiradaCobranca)
								.setMaxResults(1).uniqueResult();
			}else{

				retorno = (DebitoCobradoHistorico) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setMaxResults(1).uniqueResult();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public Object pesquisarGuiaPagamentoCobrancaAdministrativa(Integer idGuiaPagamento, Integer idGuiaPagamentoHistorico,
					Date dataImplantacaoCobranca, Date dataRetiradaCobranca, String parametroTiposDebitosCobrancaAdministrativa,
					Integer idDebitoTipoEntradaParcelamentoCobrancaAdm) throws ErroRepositorioException{

		Object retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		Integer idRegistro = null;

		try{

			if(idGuiaPagamento != null){

				idRegistro = idGuiaPagamento;
				consulta.append(" from GuiaPagamento guia ");
			}else{

				idRegistro = idGuiaPagamentoHistorico;
				consulta.append(" from GuiaPagamentoHistorico guia ");
			}

			consulta.append(" inner join guia.parcelamento parc ");
			consulta.append(" inner join guia.guiasPagamentoPrestacaoHistorico prestacao ");
			consulta.append(" where guia.id = :idGuia ");
			consulta.append(" and parc.parcelamento >=  :dataImplantacaoCobranca ");
			consulta.append(" and (prestacao.debitoTipo.id in (" + parametroTiposDebitosCobrancaAdministrativa.toString() + ") ");
			consulta.append(" or prestacao.debitoTipo.id = " + idDebitoTipoEntradaParcelamentoCobrancaAdm.toString() + ") ");

			if(dataRetiradaCobranca != null){

				consulta.append("and parc.parcelamento <=  :dataRetiradaCobranca");
				retorno = session.createQuery(consulta.toString()).setInteger("idGuia", idRegistro).setDate("dataImplantacaoCobranca",
								dataImplantacaoCobranca).setDate("dataRetiradaCobranca", dataRetiradaCobranca).setMaxResults(1)
								.uniqueResult();
			}else{

				retorno = session.createQuery(consulta.toString()).setInteger("idGuia", idRegistro).setDate("dataImplantacaoCobranca",
								dataImplantacaoCobranca).setMaxResults(1).uniqueResult();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public ContaHistorico pesquisarContaEntradaParcelamentoCobrancaAdministrativa(Integer idConta, Date dataImplantacaoCobranca,
					Date dataRetiradaCobranca) throws ErroRepositorioException{

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select conta from ContaHistorico conta ");
			consulta.append("inner join conta.parcelamento parc ");
			consulta.append("where conta.id = :idConta ");
			consulta.append("and parc.parcelamento >=  :dataImplantacaoCobranca ");

			if(dataRetiradaCobranca != null){

				consulta.append("and parc.parcelamento <=  :dataRetiradaCobranca");
				retorno = (ContaHistorico) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setDate("dataRetiradaCobranca", dataRetiradaCobranca)
								.setMaxResults(1).uniqueResult();
			}else{

				retorno = (ContaHistorico) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setMaxResults(1).uniqueResult();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções.
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa.
	 * Obtém o somatório dos valores dos srviços cobrados de
	 * parcelamento associados a itens da cobrança.
	 * Administrativa.
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public BigDecimal obterValorBaseParcelamentoCobrancaAdministrativa(Integer idConta, String parametroTiposDebitosCobrancaAdministrativa,
					Date dataImplantacaoCobranca, Date dataRetiradaCobranca) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select sum(debito.valorPrestacao) from DebitoCobradoHistorico debito ");
			consulta.append("inner join debito.parcelamento parc ");
			consulta.append("where debito.contaHistorico.id = :idConta ");
			consulta.append("and debito.debitoTipo.id in (" + parametroTiposDebitosCobrancaAdministrativa + ") ");
			consulta.append("and parc.parcelamento >=  :dataImplantacaoCobranca ");

			if(dataRetiradaCobranca != null){

				consulta.append("and parc.parcelamento <=  :dataRetiradaCobranca");
				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setDate("dataRetiradaCobranca", dataRetiradaCobranca)
								.setMaxResults(1).uniqueResult();
			}else{

				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setMaxResults(1).uniqueResult();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções.
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa.
	 * Obtém o somatório dos valores dos serviços cobrados ditos
	 * especiais (Remuneráveis).
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public BigDecimal obterValorBaseEspecialCobrancaAdministrativa(Integer idConta, String parametroTiposDebitosCobrancaAdministrativa,
					String parametroServicoEspecialCobrancaAdministrativa, Date dataImplantacaoCobranca, Date dataRetiradaCobranca)
					throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select sum(debito.valorPrestacao) from DebitoCobradoHistorico debito ");
			consulta.append("inner join debito.parcelamento parc ");
			consulta.append("where debito.contaHistorico.id = :idConta ");
			consulta.append("and debito.debitoTipo.id in (" + parametroTiposDebitosCobrancaAdministrativa + ") ");
			consulta.append("and debito.debitoTipo.id in (" + parametroServicoEspecialCobrancaAdministrativa + ") ");
			consulta.append("and parc.parcelamento >=  :dataImplantacaoCobranca ");

			if(dataRetiradaCobranca != null){

				consulta.append("and parc.parcelamento <=  :dataRetiradaCobranca");
				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setDate("dataRetiradaCobranca", dataRetiradaCobranca)
								.setMaxResults(1).uniqueResult();
			}else{

				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setMaxResults(1).uniqueResult();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções.
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa.
	 * Obtém o somatório dos valores dos serviços cobrados ditos (Não Remuneráveis).
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public BigDecimal obterValorServicosComumCobrancaAdministrativa(Integer idConta, String parametroTiposDebitosCobrancaAdministrativa,
					String parametroServicoEspecialCobrancaAdministrativa, Date dataImplantacaoCobranca, Date dataRetiradaCobranca)
					throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select sum(debito.valorPrestacao) from DebitoCobradoHistorico debito ");
			consulta.append("inner join debito.parcelamento parc ");
			consulta.append("where debito.contaHistorico.id = :idConta ");
			consulta.append("and debito.debitoTipo.id in (" + parametroTiposDebitosCobrancaAdministrativa + ") ");
			consulta.append("and debito.debitoTipo.id not in (" + parametroServicoEspecialCobrancaAdministrativa + ") ");
			consulta.append("and parc.parcelamento >  :dataImplantacaoCobranca ");

			if(dataRetiradaCobranca != null){

				consulta.append("and parc.parcelamento <  :dataRetiradaCobranca");
				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setDate("dataRetiradaCobranca", dataRetiradaCobranca)
								.setMaxResults(1).uniqueResult();
			}else{

				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setDate(
								"dataImplantacaoCobranca", dataImplantacaoCobranca).setMaxResults(1).uniqueResult();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções.
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa.
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	public CobrancaContrato pesquisarContratoCobrancaAdministrativa(Integer idCobrancaAcaoAtividadeComando) throws ErroRepositorioException{

		CobrancaContrato retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("from CobrancaContrato contrato ");
			consulta.append("where contrato.empresa.id = ( ");
			consulta.append("select comando.empresa.id from ");
			consulta.append("CobrancaAcaoAtividadeComando comando ");
			consulta.append("where comando.id = :idComando) ");
			consulta.append("and contrato.dataEncerramento is null ");

			retorno = (CobrancaContrato) session.createQuery(consulta.toString()).setInteger("idComando", idCobrancaAcaoAtividadeComando)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções.
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa.
	 * Método que obtém o valor total das prestações referentes a guia e a prestação informada.
	 * 
	 * @author Anderson Italo
	 * @date 09/07/2012
	 */
	public BigDecimal pesquisarValorTotalGuiaPagamentoPrestacaoHistorico(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select sum(guiaPagamentoPrestacao.valorPrestacao) ");
			consulta.append("FROM GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacao ");
			consulta.append("WHERE guiaPagamentoPrestacao.comp_id.guiaPagamentoId = :idGuiaPagamento ");
			consulta.append("and guiaPagamentoPrestacao.comp_id.numeroPrestacao = :numeroPrestacao ");

			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idGuiaPagamento", idGuiaPagamento).setInteger(
							"numeroPrestacao", numeroPrestacao).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções.
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa.
	 * Obtemm guia de pagamento prestação associada ao imóvel e ao comando de ação de cobrança
	 * informado
	 * 
	 * @author Anderson Italo
	 * @date 09/07/2012
	 */
	public Collection<GuiaPagamentoPrestacao> pesquisarGuiaPagamentoPrestacaoCobrancaAdministrativa(Integer idImovel,
					Integer idCobrancaAcaoAtividadeComando) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection<GuiaPagamentoPrestacao> retorno = null;
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("from GuiaPagamentoPrestacao guiaPagamentoPrestacao ");
			consulta.append("where  exists (select item from CobrancaDocumentoItem item ");
			consulta.append("inner join item.cobrancaDocumento documento ");
			consulta.append("where documento.imovel.id = :idImovel ");
			consulta.append("and documento.cobrancaAcaoAtividadeComando.id= :idCobrancaAcaoAtividadeComando ");
			consulta.append("and guiaPagamentoPrestacao.comp_id.guiaPagamentoId = item.guiaPagamentoGeral.id) ");

			retorno = (Collection<GuiaPagamentoPrestacao>) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("idCobrancaAcaoAtividadeComando", idCobrancaAcaoAtividadeComando).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0238] Manter Aviso Bancário
	 * 
	 * @author Hugo Lima
	 * @date 30/08/2012
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarDataPagamentoAvisoBancario(Integer idAvisoBancario) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" (select pgmt_dtpagamento as dataPagamento ");
			consulta.append("  from pagamento ");
			consulta.append("  where avbc_id = :idAvisoBancario ");
			consulta.append("  union ");
			consulta.append("  select pghi_dtpagamento as dataPagamento ");
			consulta.append("  from pagamento_historico ");
			consulta.append("  where avbc_id = :idAvisoBancario) ");
			consulta.append(" order by dataPagamento ");

			retorno = (Date) session.createSQLQuery(consulta.toString()).addScalar("dataPagamento", Hibernate.DATE).setInteger(
							"idAvisoBancario", idAvisoBancario).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0238] Manter Aviso Bancário
	 * 
	 * @author Hugo Lima
	 * @date 30/08/2012
	 * @param idAvisoBancario
	 * @param indicadorCreditoDebito
	 * @param indicadorArrecadacaoDevolucao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterValorTotalAcertosAvisoBancario(Integer idAvisoBancario, Short indicadorCreditoDebito,
					Short indicadorArrecadacaoDevolucao) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append(" select sum(avac_vlacerto) as somaAcertos ");
			consulta.append(" from aviso_acertos ");
			consulta.append(" where avbc_id = :idAvisoBancario ");
			consulta.append(" and avac_iccreditodebito = :indicadorCreditoDebito ");
			consulta.append(" and avac_icarrecadacaodevolucao = :indicadorArrecadacaoDevolucao ");

			BigDecimal big = (BigDecimal) session.createSQLQuery(consulta.toString()).addScalar("somaAcertos", Hibernate.BIG_DECIMAL)
							.setInteger("idAvisoBancario", idAvisoBancario).setShort("indicadorCreditoDebito", indicadorCreditoDebito)
							.setShort("indicadorArrecadacaoDevolucao", indicadorArrecadacaoDevolucao).setMaxResults(1).uniqueResult();
			if(big != null){
				retorno = big;
			}else{
				retorno = BigDecimal.ZERO;
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquiar Parâmetros de Acrescimos
	 * 
	 * @author Hebert Falcão
	 * @date 07/09/2012
	 */
	public ParametroAcrescimosEmissaoDocumento pesquisarParametroAcrescimosEmissaoDocumento(Date dataEmissao)
					throws ErroRepositorioException{

		ParametroAcrescimosEmissaoDocumento retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append(" select paed ");
			consulta.append(" from ParametroAcrescimosEmissaoDocumento paed ");
			consulta.append(" where :dataEmissao between paed.dataInicioValidade and paed.dataFimValidade ");

			Query query = session.createQuery(consulta.toString());
			query.setDate("dataEmissao", dataEmissao);

			retorno = (ParametroAcrescimosEmissaoDocumento) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obter Valor Total das Prestações da Guia em Histórico
	 * 
	 * @author Hebert Falcão
	 * @date 21/09/2012
	 */
	public BigDecimal obterValorTotalDasPrestacoesDaGuiaEmHistorico(Integer idGuiaPagamento) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append(" select sum(gpph.valorPrestacao) ");
			consulta.append(" from GuiaPagamentoPrestacaoHistorico gpph ");
			consulta.append(" where gpph.comp_id.guiaPagamentoId = :idGuiaPagamento ");

			Query query = session.createQuery(consulta.toString());
			query.setInteger("idGuiaPagamento", idGuiaPagamento);

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.arrecadacao.IRepositorioArrecadacao#atualizarIndicadorPagamentoConta(java.lang.Integer,
	 * java.lang.Short)
	 */
	public void atualizarIndicadorPagamentoConta(Integer idConta, Short indicadorPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuffer query = new StringBuffer();

		try{

			query.append("update Conta c ");
			query.append("set c.indicadorPagamento = :indicadorPagamento ");
			query.append("where c.id = :idConta");

			session.createQuery(query.toString()).setShort("indicadorPagamento", indicadorPagamento).setInteger("idConta", idConta)
							.executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.arrecadacao.IRepositorioArrecadacao#atualizarIndicadorGuiaPagamentoPrestacao(java.lang
	 * .Integer, java.lang.Short, java.lang.Short)
	 */
	public void atualizarIndicadorGuiaPagamentoPrestacao(Integer idGuiaPagamento, Short numeroPrestacao, Short indicadorPagamento)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuffer query = new StringBuffer();

		try{

			query.append("update GuiaPagamentoPrestacao g ");
			query.append("set g.indicadorPagamentoPendente = :indicadorPagamento ");
			query.append("where g.comp_id.guiaPagamentoId = :guiaPagamentoId ");
			query.append("and g.comp_id.numeroPrestacao = :numeroPrestacao");

			session.createQuery(query.toString()).setShort("indicadorPagamento", indicadorPagamento).setInteger("guiaPagamentoId",
							idGuiaPagamento).setShort("numeroPrestacao", numeroPrestacao).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.arrecadacao.IRepositorioArrecadacao#atualizarIndicadorGuiaPagamentoPrestacaoHistorico
	 * (java.lang.Integer, java.lang.Short, java.lang.Short)
	 */
	public void atualizarIndicadorGuiaPagamentoPrestacaoHistorico(Integer idGuiaPagamento, Short numeroPrestacao, Short indicadorPagamento)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuffer query = new StringBuffer();

		try{

			query.append("update GuiaPagamentoPrestacaoHistorico g ");
			query.append("set g.indicadorPagamentoPendente = :indicadorPagamento ");
			query.append("where g.comp_id.guiaPagamentoId = :guiaPagamentoId ");
			query.append("and g.comp_id.numeroPrestacao = :numeroPrestacao");

			session.createQuery(query.toString()).setShort("indicadorPagamento", indicadorPagamento).setInteger("guiaPagamentoId",
							idGuiaPagamento).setShort("numeroPrestacao", numeroPrestacao).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

	}

	/**
	 * Retornar o somatório dos valores pagos da conta
	 * 
	 * @author Hebert Falcão
	 * @date 16/10/2012
	 */
	public BigDecimal retornarSomatorioPagamentoDaConta(Integer idConta) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select sum(pgmt.valorPagamento) ");
			consulta.append("from Pagamento pgmt ");
			consulta.append("where pgmt.conta.id = :idConta ");

			Query query = session.createQuery(consulta.toString());
			query.setInteger("idConta", idConta);

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retornar o somatório dos valores pagos da conta
	 * 
	 * @author Hebert Falcão
	 * @date 16/10/2012
	 */
	public BigDecimal retornarSomatorioPagamentoHistoricoDaConta(Integer idConta) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select sum(pghi.valorPagamento) ");
			consulta.append("from PagamentoHistorico pghi ");
			consulta.append("where pghi.conta.id = :idConta ");

			Query query = session.createQuery(consulta.toString());
			query.setInteger("idConta", idConta);

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retornar o somatório dos valores pagos da guia
	 * 
	 * @author Hebert Falcão
	 * @date 16/10/2012
	 */
	public BigDecimal retornarSomatorioPagamentoDaGuia(Integer idGuiaPagamento, Integer numeroPrestacao) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select sum(pgmt.valorPagamento) ");
			consulta.append("from Pagamento pgmt ");
			consulta.append("where pgmt.guiaPagamentoGeral.id = :idGuiaPagamento ");
			consulta.append("  and pgmt.numeroPrestacao = :numeroPrestacao ");

			Query query = session.createQuery(consulta.toString());
			query.setInteger("idGuiaPagamento", idGuiaPagamento);
			query.setInteger("numeroPrestacao", numeroPrestacao);

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retornar o somatório dos valores pagos da guia
	 * 
	 * @author Hebert Falcão
	 * @date 16/10/2012
	 */
	public BigDecimal retornarSomatorioPagamentoHistoricoDaGuia(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta = new StringBuffer();
			consulta.append("select sum(pghi.valorPagamento) ");
			consulta.append("from PagamentoHistorico pghi ");
			consulta.append("where pghi.guiaPagamentoGeral.id = :idGuiaPagamento ");
			consulta.append("  and pghi.numeroPrestacao = :numeroPrestacao ");

			Query query = session.createQuery(consulta.toString());
			query.setInteger("idGuiaPagamento", idGuiaPagamento);
			query.setInteger("numeroPrestacao", numeroPrestacao);

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0247] Consultar Pagamentos
	 * Retornar Valor de Remuneração da Conta Histórico
	 * 
	 * @author Hebert Falcão
	 * @date 11/10/2012
	 */
	public BigDecimal retornarValorRemuneracaoContaHistorico(Integer idConta, Integer referencia) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select cnhi.valorAgua + cnhi.valorEsgoto + cnhi.valorDebitos + cnhi.valorCreditos ");
			hql.append("from ContaHistorico cnhi ");
			hql.append("where cnhi.debitoCreditoSituacaoAtual.id in (" + DebitoCreditoSituacao.NORMAL + ", ");
			hql.append("                                             " + DebitoCreditoSituacao.RETIFICADA + ", ");
			hql.append("                                             " + DebitoCreditoSituacao.INCLUIDA + ", ");
			hql.append("                                             " + DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO + ") ");
			hql.append("  and cnhi.anoMesReferenciaConta >= :referencia ");
			hql.append("  and cnhi.id = :idConta ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("referencia", referencia);
			query.setInteger("idConta", idConta);

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0247] Consultar Pagamentos
	 * Retornar Valor de Remuneração da Conta
	 * 
	 * @author Hebert Falcão
	 * @date 11/10/2012
	 */
	public BigDecimal retornarValorRemuneracaoConta(Integer idConta, Integer referencia) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select cnta.valorAgua + cnta.valorEsgoto + cnta.debitos+ cnta.valorCreditos ");
			hql.append("from Conta cnta ");
			hql.append("where cnta.debitoCreditoSituacaoAtual.id in (" + DebitoCreditoSituacao.NORMAL + ", ");
			hql.append("                                             " + DebitoCreditoSituacao.RETIFICADA + ", ");
			hql.append("                                             " + DebitoCreditoSituacao.INCLUIDA + ", ");
			hql.append("                                             " + DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO + ") ");
			hql.append("  and cnta.referencia >= :referencia ");
			hql.append("  and cnta.id = :idConta ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("referencia", referencia);
			query.setInteger("idConta", idConta);

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método pesquisarIdsLocalidadeComPagamentosOuPagamentosHistoricos
	 * <p>
	 * Esse método implementa pesquisa dos Ids das Localidade Com {@link Pagamento} Ou
	 * {@link PagamentoHistorico}
	 * </p>
	 * RASTREIO: [OC920431][UC0301]
	 * 
	 * @return Lista de {@link Integer}.
	 * @author Marlos Ribeiro
	 * @param referenciaArrecadacao
	 * @since 14/11/2012
	 */
	public Collection<Integer> pesquisarIdsLocalidadeComPagamentosOuPagamentosHistoricos(Integer referenciaArrecadacao)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		try{
			StringBuilder consulta = new StringBuilder();
			consulta.append(" SELECT * FROM (");
			consulta.append(" 	SELECT loca_id AS localidade");
			consulta.append(" 	FROM pagamento p");
			consulta.append(" 	WHERE p.PGMT_AMREFERENCIAARRECADACAO >= :referenciaArrecadacao");
			consulta.append(" UNION");
			consulta.append(" 	SELECT loca_id AS localidade");
			consulta.append(" 	FROM PAGAMENTO_HISTORICO ph");
			consulta.append(" 	WHERE ph.PGHI_AMREFERENCIAARRECADACAO >= :referenciaArrecadacao");
			consulta.append(" 	) TAB1 ");
			consulta.append(" GROUP BY localidade ORDER BY 1");

			SQLQuery sqlQuery = session.createSQLQuery(consulta.toString());
			sqlQuery.setInteger("referenciaArrecadacao", referenciaArrecadacao);
			retorno = sqlQuery.addScalar("localidade", Hibernate.INTEGER).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Collection<AjusteContabilidade> pesquisarPagamentoHistoricoParaAjusteContabilidadeArrecadacao(Integer limite)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection<AjusteContabilidade> retorno = null;
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select ajct ");
			consulta.append("from AjusteContabilidade ajct ");
			consulta.append("where ajct.icProcessado = 2 ");
			// consulta.append("where ajct.idPagamento = 34823614 ");
			consulta.append("order by ajct.id ");

			Query query = session.createQuery(consulta.toString());

			if(limite != null && limite != -1){
				retorno = (Collection<AjusteContabilidade>) query.setMaxResults(limite).list();
			}else{
				retorno = (Collection<AjusteContabilidade>) query.list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Integer> pesquisarClassificarPagamentosAjuste() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection<Integer> retorno = new ArrayList();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select p.pgmt_id id ");
			consulta.append("from pagamento p ");
			consulta.append("   inner join conta c on c.cnta_id = p.cnta_id ");
			consulta.append("   inner join cobranca_documento cd on cd.imov_id = p.imov_id and cd.rdir_id is not null ");
			consulta.append("   inner join cobranca_documento_item cdi on cd.cbdo_id = cdi.cbdo_id and cdi.cnta_id = c.cnta_id ");
			consulta.append("   inner join arrecadador_movimento_item ami on ami.amit_id = p.amit_id ");
			consulta.append("where p.pgst_idatual = 14 ");
			consulta.append("   and cd.cbdo_id = substr(ami.amit_cnregistro, 70, 9) ");
			consulta.append("   and p.pgmt_vlpagamento = cdi.cdit_vlitemcobrado + cdi.cdit_vlmonetaria + cdi.cdit_vlmora + cdi.cdit_vlmulta ");
			consulta.append("order by p.pgmt_id ");

			SQLQuery query = session.createSQLQuery(consulta.toString());
			query.addScalar("id", Hibernate.INTEGER);

			retorno = (Collection<Integer>) query.list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void removerGuiaPagamentoCategoriaHistorico(Integer idGuiaPagamento, Short numeroPrestacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("DELETE FROM GuiaPagamentoCategoriaHistorico gpch ");
			consulta.append("WHERE gpch.comp_id.guiaPagamentoId = :idGuiaPagamento ");
			consulta.append("  AND gpch.comp_id.numeroPrestacao = :numeroPrestacao ");

			session.createQuery(consulta.toString()).setInteger("idGuiaPagamento", idGuiaPagamento).setShort("numeroPrestacao",
							numeroPrestacao).executeUpdate();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	public Collection<Object[]> pesquisarGuiaPagamentoPrestacaoComCategoriaInvalida() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = new ArrayList();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select id, prestacao ");
			consulta.append("from (select gpag_id id, gppr_nnprestacao prestacao, sum(gppr_vlprestacao) vlprestacao ");
			consulta.append("      from guia_pagamento_prestacao ");
			consulta.append("      group by gpag_id, gppr_nnprestacao) ");
			consulta.append("where vlprestacao <> (select sum(gpcg_vlcategoria) ");
			consulta.append("                      from guia_pagamento_categoria ");
			consulta.append("                      where gpag_id = id ");
			consulta.append("                        and gpcg_nnprestacao = prestacao ");
			consulta.append("                      group by gpag_id, gpcg_nnprestacao) ");
			consulta.append("order by id, prestacao ");

			SQLQuery query = session.createSQLQuery(consulta.toString());
			query.addScalar("id", Hibernate.INTEGER);
			query.addScalar("prestacao", Hibernate.SHORT);

			retorno = (Collection<Object[]>) query.list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Object[]> pesquisarGuiaPagamentoPrestacaoHistoricoComCategoriaInvalida() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = new ArrayList();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select id, prestacao ");
			consulta.append("from (select gpag_id id, gpph_nnprestacao prestacao, sum(gpph_vlprestacao) vlprestacao ");
			consulta.append("      from guia_pagamento_prestacao_hist ");
			consulta.append("      group by gpag_id, gpph_nnprestacao) ");
			consulta.append("where vlprestacao <> (select sum(gpch_vlcategoria) ");
			consulta.append("                      from guia_pagamento_categoria_hist ");
			consulta.append("                      where gpag_id = id ");
			consulta.append("                        and gpch_nnprestacao = prestacao ");
			consulta.append("                      group by gpag_id, gpch_nnprestacao) ");
			consulta.append("order by id, prestacao ");

			SQLQuery query = session.createSQLQuery(consulta.toString());
			query.addScalar("id", Hibernate.INTEGER);
			query.addScalar("prestacao", Hibernate.SHORT);

			retorno = (Collection<Object[]>) query.list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void removerContaCategoria(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("delete from ContaCategoriaConsumoFaixa cccf ");
			consulta.append("where cccf.contaCategoria.comp_id.conta.id = :idConta ");

			session.createQuery(consulta.toString()).setInteger("idConta", idConta).executeUpdate();

			consulta = new StringBuilder();
			consulta.append("delete from ContaCategoria ctcg ");
			consulta.append("where ctcg.comp_id.conta.id = :idConta ");

			session.createQuery(consulta.toString()).setInteger("idConta", idConta).executeUpdate();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	public void removerContaCategoriaHistorico(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("delete from ContaCategoriaConsumoFaixaHistorico ccfh ");
			consulta.append("where ccfh.contaCategoriaHistorico.comp_id.contaHistorico.id = :idConta ");

			session.createQuery(consulta.toString()).setInteger("idConta", idConta).executeUpdate();

			consulta = new StringBuilder();
			consulta.append("delete from ContaCategoriaHistorico ctch ");
			consulta.append("where ctch.comp_id.contaHistorico.id = :idConta ");

			session.createQuery(consulta.toString()).setInteger("idConta", idConta).executeUpdate();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	public Collection<Integer> pesquisarContaComCategoriaInvalida() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection<Integer> retorno = new ArrayList();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select distinct cnta_id id ");
			consulta.append("from TMP_PCG_35 ");

			// consulta.append("select distinct ctcg.cnta_id id ");
			// consulta.append("from conta_categoria ctcg ");
			// consulta.append("where ctcg.ctcg_vlagua = 0 ");
			// consulta.append("  and exists (select 1 ");
			// consulta.append("              from conta cnta ");
			// consulta.append("              where cnta.cnta_id = ctcg.cnta_id ");
			// consulta.append("                and cnta.cnta_vlagua <> 0) ");

			SQLQuery query = session.createSQLQuery(consulta.toString());
			query.addScalar("id", Hibernate.INTEGER);

			retorno = (Collection<Integer>) query.list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Integer> pesquisarContaHistoricoComCategoriaInvalida() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection<Integer> retorno = new ArrayList();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select distinct cnta_id id ");
			consulta.append("from TMP_PCG_36 ");

			// consulta.append("select distinct ctch.cnta_id id ");
			// consulta.append("from conta_categoria_historico ctch ");
			// consulta.append("where ctch.ctch_vlagua = 0 ");
			// consulta.append(" and exists (select 1 ");
			// consulta.append("             from conta_historico cnhi ");
			// consulta.append("             where cnhi.cnta_id = ctch.cnta_id ");
			// consulta.append("               and cnhi.cnhi_vlagua <> 0) ");

			SQLQuery query = session.createSQLQuery(consulta.toString());
			query.addScalar("id", Hibernate.INTEGER);

			retorno = (Collection<Integer>) query.list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer obterNextValContaCategoriaConsumoFaixaHistorico() throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			Dialect dialect = Dialect.getDialect();

			consulta = dialect.getSequenceNextValString("sq_conta_catg_consumo_faixa");

			Number retornoConsulta = (Number) session.createSQLQuery(consulta).uniqueResult();

			if(retornoConsulta != null){
				retorno = retornoConsulta.intValue();
			}
		}catch(GenericJDBCException ex){
			throw new ErroRepositorioException(ex, "Erro no Hibernate");
		}catch(CallbackException e){
			throw new ErroRepositorioException(e, e.getMessage());
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metódo responsável por encerrar a arrecadação do mês.
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 14/02/2013
	 * @param idMotivoBaixa
	 * @param dataBaixa
	 * @param amReferenciaBaixa
	 * @param dataInicialConta
	 * @param dataFinalConta
	 * @param idSituacaoAtualConta
	 * @throws ErroRepositorioException
	 */
	public void atualizarProvisaoDevedoresDuvidosos(Integer idMotivoBaixa, Date dataBaixa, Integer amReferenciaBaixa,
					Date dataInicialConta, Date dataFinalConta, String[] idSituacaoAtualConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String atualizarProvisaoDevedoresDuvidosos = "";

		try{

			String idsSituacaoAtualConta = "";

			if(!Util.isVazioOrNulo(idSituacaoAtualConta)){
				for(int i = 0; i < idSituacaoAtualConta.length; i++){
					if(!Util.isVazioOuBranco(idSituacaoAtualConta[i])){
						idsSituacaoAtualConta = idsSituacaoAtualConta + idSituacaoAtualConta[i] + ",";
					}
				}

				if(!Util.isVazioOuBranco(idsSituacaoAtualConta)){
					idsSituacaoAtualConta = Util.formatarHQL(idsSituacaoAtualConta, 1);
				}
			}

			String dataInicialContaAux = Util.formatarDataAAAAMMDD(dataInicialConta);
			String dataFinalContaAux = Util.formatarDataAAAAMMDD(dataFinalConta);

			atualizarProvisaoDevedoresDuvidosos += "update provisao_devedores_duvidosos ";
			atualizarProvisaoDevedoresDuvidosos += "set pddb_id = :idMotivoBaixa, ";
			atualizarProvisaoDevedoresDuvidosos += "pddv_dtbaixa = :dataBaixa, ";
			atualizarProvisaoDevedoresDuvidosos += "pddv_amreferenciabaixa = :amReferenciaBaixa ";
			atualizarProvisaoDevedoresDuvidosos += "where pddb_id is null ";
			atualizarProvisaoDevedoresDuvidosos += "and cnta_id not in (select cnta_id from conta) ";
			atualizarProvisaoDevedoresDuvidosos += "and cnta_id in (select cnta_id from conta_historico ";
			atualizarProvisaoDevedoresDuvidosos += "where to_char(cnhi_tmcontahistorico,'yyyymmdd') >= " + dataInicialContaAux + " ";
			atualizarProvisaoDevedoresDuvidosos += "and to_char(cnhi_tmcontahistorico,'yyyymmdd') <= " + dataFinalContaAux + " ";
			atualizarProvisaoDevedoresDuvidosos += "and dcst_idatual in(" + idsSituacaoAtualConta + "))";

			session.createSQLQuery(atualizarProvisaoDevedoresDuvidosos).setInteger("idMotivoBaixa", idMotivoBaixa).setDate("dataBaixa",
							dataBaixa).setInteger("amReferenciaBaixa", amReferenciaBaixa).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados
	 * 2.6. Situação do Pagamento
	 * 
	 * @author Josenildo Neves
	 * @since 29/11/2012
	 * @return listaPagamentoSituacao
	 * @throws ControladorException
	 */
	public Collection<PagamentoSituacao> pesquisarPagamentoSituacao() throws ErroRepositorioException{

		Collection retorno = null;

		Collection<PagamentoSituacao> colecaoPagamentoSituacao = null;

		Session session = HibernateUtil.getSession();
		try{
			StringBuilder consulta = new StringBuilder();
			consulta.append(" SELECT * FROM (");
			consulta.append(" 	SELECT ps.PGST_ID AS idPagamentoSituacao, ps.PGST_DSPAGAMENTOSITUACAO AS descricao");
			consulta.append(" 	FROM pagamento p ");
			consulta.append(" 	INNER JOIN PAGAMENTO_SITUACAO ps ON ps.PGST_ID = p.PGST_IDATUAL ");
			consulta.append(" 	WHERE ");
			consulta.append(" 		ps.PGST_ID <> " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO); // 0_RECEBIMENTO
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.VALOR_A_BAIXAR); // 4_BAIXA
																							// PAG._DUP/EXC.
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.CONTA_EM_FATURAMENTO_); // 16_CONTA_EMFATURAMENTO
			consulta.append("		AND ps.PGST_ID <> " + PagamentoSituacao.CONTA_EM_FATURAMENTO); // 17_CONTA_EMFATURAMENTO
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.MIGRACAO); // 8_MIGRACAO
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.VALOR_NAO_CONFERE); // 5_VALOR_NAO_CONFERE
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.MOVIMENTO_ABERTO); // 7_MOVIMENTO_ABERTO
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO); // 9_DEVOLUCOES
			consulta.append(" UNION ");
			consulta.append(" 	SELECT ps.PGST_ID AS idPagamentoSituacao, ps.PGST_DSPAGAMENTOSITUACAO AS descricao");
			consulta.append(" 	FROM PAGAMENTO_HISTORICO ph");
			consulta.append(" 	INNER JOIN PAGAMENTO_SITUACAO ps ON ps.PGST_ID = ph.PGST_IDATUAL ");
			consulta.append(" 	WHERE ");
			consulta.append(" 		ps.PGST_ID <> " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO); // 0
																								// RECEBIMENTO
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.VALOR_A_BAIXAR); // 4
																							// BAIXA_PAG._DUP/EXC.
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.CONTA_EM_FATURAMENTO_); // 16_CONTA_EMFATURAMENTO
			consulta.append("		AND ps.PGST_ID <> " + PagamentoSituacao.CONTA_EM_FATURAMENTO); // 17_CONTA_EMFATURAMENTO
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.MIGRACAO); // 8 MIGRACAO
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.VALOR_NAO_CONFERE); // 5_VALOR_NAO_CONFERE
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.MOVIMENTO_ABERTO); // 7_MOVIMENTO_ABERTO
			consulta.append(" 		AND ps.PGST_ID <> " + PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO); // 9_DEVOLUCOES
			consulta.append(" 	) TAB1 ");
			consulta.append(" GROUP BY idPagamentoSituacao, descricao ");
			consulta.append(" ORDER BY descricao ");

			SQLQuery sqlQuery = session.createSQLQuery(consulta.toString());

			retorno = sqlQuery.addScalar("idPagamentoSituacao", Hibernate.INTEGER).addScalar("descricao", Hibernate.STRING).list();

			PagamentoSituacao pagamentoSituacao = null;
			colecaoPagamentoSituacao = new ArrayList<PagamentoSituacao>();

			for(Object object : retorno){

				Object situacao[] = (Object[]) object;

				pagamentoSituacao = new PagamentoSituacao();
				pagamentoSituacao.setId((Integer) situacao[0]);
				pagamentoSituacao.setDescricao((String) situacao[1]);

				colecaoPagamentoSituacao.add(pagamentoSituacao);

			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return colecaoPagamentoSituacao;
	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * Retorna a quantidade de pagamentos a serem processados.
	 * 
	 * @author Josenildo Neves
	 * @date 14/11/2012
	 */
	public Integer pesquisarQuantidadePagamentos(ClassificarLotePagamentosNaoClassificadosHelper helper) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;
		Map parameters = new HashMap();

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT COUNT(pagamento.id) ");
			consulta.append("FROM Pagamento pagamento ");
			consulta.append("LEFT JOIN pagamento.imovel imovel ");
			consulta.append("INNER JOIN imovel.quadra quadra ");
			consulta.append("INNER JOIN imovel.localidade localidade ");
			consulta.append("INNER JOIN imovel.setorComercial setorComercial ");
			consulta.append("INNER JOIN imovel.quadra quadra ");
			consulta.append("LEFT JOIN pagamento.cliente cliente ");
			consulta.append("INNER JOIN pagamento.localidade localidade ");
			consulta.append("INNER JOIN pagamento.documentoTipo documentoTipo ");
			consulta.append("LEFT JOIN pagamento.guiaPagamentoGeral guiaPagamentoGeral ");
			consulta.append("LEFT JOIN guiaPagamentoGeral.guiaPagamento guiaPagamento ");
			consulta.append("LEFT JOIN pagamento.debitoTipo debitoTipo ");
			consulta.append("LEFT JOIN pagamento.debitoACobrar debitoACobrar ");
			consulta.append("LEFT JOIN pagamento.pagamentoSituacaoAtual pagamentoSituacao ");
			consulta.append("INNER JOIN pagamento.conta conta ");
			consulta.append("INNER JOIN conta.debitoCreditoSituacaoAtual contaSituacao ");
			consulta.append("WHERE ");
			consulta.append("contaSituacao.id in (:situacoesConta)");

			Collection<Integer> situacoesConta = new ArrayList<Integer>();
			situacoesConta.add(DebitoCreditoSituacao.NORMAL);
			situacoesConta.add(DebitoCreditoSituacao.RETIFICADA);
			situacoesConta.add(DebitoCreditoSituacao.INCLUIDA);
			situacoesConta.add(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);

			parameters.put("situacoesConta", situacoesConta);

			if(helper.getLocalidadeInicial() != null && helper.getLocalidadeFinal() != null
							&& helper.getLocalidadeInicial().shortValue() != ConstantesSistema.ZERO
							&& helper.getLocalidadeFinal().shortValue() != ConstantesSistema.ZERO){

				consulta.append(" AND pagamento.localidade.id BETWEEN :localidadeInicial AND :localidadeFinal ");

				parameters.put("localidadeInicial", helper.getLocalidadeInicial());
				parameters.put("localidadeFinal", helper.getLocalidadeFinal());

			}

			if(helper.getReferenciaArrecadacaoInicial() != null && helper.getReferenciaArrecadacaoFinal() != null
							&& helper.getReferenciaArrecadacaoInicial().shortValue() != ConstantesSistema.ZERO
							&& helper.getReferenciaArrecadacaoFinal().shortValue() != ConstantesSistema.ZERO){

				consulta.append(" AND pagamento.anoMesReferenciaArrecadacao BETWEEN :referenciaArrecadacaoInicial AND :referenciaArrecadacaoFinal ");

				parameters.put("referenciaArrecadacaoInicial", helper.getReferenciaArrecadacaoInicial());
				parameters.put("referenciaArrecadacaoFinal", helper.getReferenciaArrecadacaoFinal());

			}

			if(helper.getReferenciaPagamentoInicial() != null && helper.getReferenciaPagamentoFinal() != null
							&& helper.getReferenciaPagamentoInicial().shortValue() != ConstantesSistema.ZERO
							&& helper.getReferenciaPagamentoFinal().shortValue() != ConstantesSistema.ZERO){

				consulta.append(" AND pagamento.anoMesReferenciaPagamento BETWEEN :referenciaPagamentoInicial AND :referenciaPagamentoFinal ");

				parameters.put("referenciaPagamentoInicial", helper.getReferenciaPagamentoInicial());
				parameters.put("referenciaPagamentoFinal", helper.getReferenciaPagamentoFinal());
			}

			if(helper.getDataPagamentoInicial() != null && helper.getDataPagamentoFinal() != null){

				consulta.append(" AND pagamento.dataPagamento BETWEEN :dataPagamentoInicial AND :dataPagamentoFinal ");

				parameters.put("dataPagamentoInicial", helper.getDataPagamentoInicial());
				parameters.put("dataPagamentoFinal", helper.getDataPagamentoFinal());
			}

			if(helper.getSituacaoPagamento() != null){

				consulta.append(" AND pagamento.pagamentoSituacaoAtual.id =:idPagamentoSituacaoAtual ");

				parameters.put("idPagamentoSituacaoAtual", helper.getSituacaoPagamento());
			}

			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO); // 0_RECEBIMENTO
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.VALOR_A_BAIXAR); // 4_BAIXA_PAG._DUP/EXC.
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.CONTA_EM_FATURAMENTO_); // 16_CONTA_EMFATURAMENTO
			consulta.append("		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.CONTA_EM_FATURAMENTO); // 17_CONTA_EMFATURAMENTO
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.MIGRACAO); // 8
																											// MIGRACAO
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.VALOR_NAO_CONFERE); // 5_VALOR_NAO_CONFERE
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.MOVIMENTO_ABERTO); // 7_MOVIMENTO_ABERTO
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO); // 9_DEVOLUCOES

			query = session.createQuery(consulta.toString());

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Set){
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				}else if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else if(parameters.get(key) instanceof Integer[]){
					Integer[] collection = (Integer[]) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = ((Number) query.setMaxResults(1).uniqueResult()).intValue();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * 3. O sistema seleciona lista pagamentos conforme os critérios informados, verificando os
	 * seguintes itens:
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public Collection<Pagamento> pesquisarPagamentos(ClassificarLotePagamentosNaoClassificadosHelper helper)
					throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;
		Map parameters = new HashMap();

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT pagamento ");
			consulta.append("FROM Pagamento pagamento ");
			consulta.append("LEFT JOIN FETCH pagamento.imovel imovel ");
			consulta.append("INNER JOIN FETCH imovel.quadra quadra ");
			consulta.append("INNER JOIN FETCH imovel.localidade localidade ");
			consulta.append("INNER JOIN FETCH imovel.setorComercial setorComercial ");
			consulta.append("INNER JOIN FETCH imovel.quadra quadra ");
			consulta.append("LEFT JOIN FETCH pagamento.cliente cliente ");
			consulta.append("INNER JOIN FETCH pagamento.localidade localidade ");
			consulta.append("INNER JOIN FETCH pagamento.documentoTipo documentoTipo ");
			consulta.append("LEFT JOIN FETCH pagamento.guiaPagamentoGeral guiaPagamentoGeral ");
			consulta.append("LEFT JOIN FETCH guiaPagamentoGeral.guiaPagamento guiaPagamento ");
			consulta.append("LEFT JOIN FETCH pagamento.debitoTipo debitoTipo ");
			consulta.append("LEFT JOIN FETCH pagamento.debitoACobrar debitoACobrar ");
			consulta.append("LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagamentoSituacao ");
			consulta.append("LEFT JOIN FETCH pagamento.avisoBancario avisoBancario ");
			consulta.append("INNER JOIN FETCH pagamento.conta conta ");
			consulta.append("INNER JOIN FETCH conta.debitoCreditoSituacaoAtual contaSituacao ");
			consulta.append("WHERE ");
			consulta.append("contaSituacao.id in (:situacoesConta)");

			Collection<Integer> situacoesConta = new ArrayList<Integer>();
			situacoesConta.add(DebitoCreditoSituacao.NORMAL);
			situacoesConta.add(DebitoCreditoSituacao.RETIFICADA);
			situacoesConta.add(DebitoCreditoSituacao.INCLUIDA);
			situacoesConta.add(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);

			parameters.put("situacoesConta", situacoesConta);

			if(helper.getLocalidadeInicial() != null && helper.getLocalidadeFinal() != null
							&& helper.getLocalidadeInicial().shortValue() != ConstantesSistema.ZERO
							&& helper.getLocalidadeFinal().shortValue() != ConstantesSistema.ZERO){

				consulta.append(" AND pagamento.localidade.id BETWEEN :localidadeInicial AND :localidadeFinal ");

				parameters.put("localidadeInicial", helper.getLocalidadeInicial());
				parameters.put("localidadeFinal", helper.getLocalidadeFinal());

			}

			if(helper.getReferenciaArrecadacaoInicial() != null && helper.getReferenciaArrecadacaoFinal() != null
							&& helper.getReferenciaArrecadacaoInicial().shortValue() != ConstantesSistema.ZERO
							&& helper.getReferenciaArrecadacaoFinal().shortValue() != ConstantesSistema.ZERO){

				consulta.append(" AND pagamento.anoMesReferenciaArrecadacao BETWEEN :referenciaArrecadacaoInicial AND :referenciaArrecadacaoFinal ");

				parameters.put("referenciaArrecadacaoInicial", helper.getReferenciaArrecadacaoInicial());
				parameters.put("referenciaArrecadacaoFinal", helper.getReferenciaArrecadacaoFinal());

			}

			if(helper.getReferenciaPagamentoInicial() != null && helper.getReferenciaPagamentoFinal() != null
							&& helper.getReferenciaPagamentoInicial().shortValue() != ConstantesSistema.ZERO
							&& helper.getReferenciaPagamentoFinal().shortValue() != ConstantesSistema.ZERO){

				consulta.append(" AND pagamento.anoMesReferenciaPagamento BETWEEN :referenciaPagamentoInicial AND :referenciaPagamentoFinal ");

				parameters.put("referenciaPagamentoInicial", helper.getReferenciaPagamentoInicial());
				parameters.put("referenciaPagamentoFinal", helper.getReferenciaPagamentoFinal());
			}

			if(helper.getDataPagamentoInicial() != null && helper.getDataPagamentoFinal() != null){

				consulta.append(" AND pagamento.dataPagamento BETWEEN :dataPagamentoInicial AND :dataPagamentoFinal ");

				parameters.put("dataPagamentoInicial", helper.getDataPagamentoInicial());
				parameters.put("dataPagamentoFinal", helper.getDataPagamentoFinal());
			}

			if(helper.getSituacaoPagamento() != null){
				consulta.append(" AND pagamento.pagamentoSituacaoAtual.id =:idPagamentoSituacaoAtual ");

				parameters.put("idPagamentoSituacaoAtual", helper.getSituacaoPagamento());
			}

			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.PAGAMENTO_CLASSIFICADO); // 0_RECEBIMENTO
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.VALOR_A_BAIXAR); // 4_BAIXA_PAG._DUP/EXC.
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.CONTA_EM_FATURAMENTO_); // 16_CONTA_EMFATURAMENTO
			consulta.append("		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.CONTA_EM_FATURAMENTO); // 17_CONTA_EMFATURAMENTO
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.MIGRACAO); // 8
																											// MIGRACAO
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.VALOR_NAO_CONFERE); // 5_VALOR_NAO_CONFERE
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.MOVIMENTO_ABERTO); // 7_MOVIMENTO_ABERTO
			consulta.append(" 		AND pagamento.pagamentoSituacaoAtual.id <> " + PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO); // 9_DEVOLUCOES

			// Os pagamentos devem ser ordenados por conta (CNTA_ID), situação atual do pagamento
			// (PGST_IDATUAL) e data de pagamento (PGMT_DTPAGAMENTO)
			consulta.append(" ORDER BY conta.id, pagamento.pagamentoSituacaoAtual.id, pagamento.dataPagamento");

			query = session.createQuery(consulta.toString());

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Set){
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				}else if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else if(parameters.get(key) instanceof Integer[]){
					Integer[] collection = (Integer[]) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * Consulta o objeto Pagamento mais recente do banco, para chamada do Atualizar Pagamento
	 * 
	 * @author Luciano Galvão
	 * @date 11/09/2013
	 */
	public Pagamento consultarPagamentoParaAtualizacao(Integer pagamentoId) throws ErroRepositorioException{

		Pagamento retorno = null;
		Session session = HibernateUtil.getSession();
		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT pagamento ");
			consulta.append("FROM Pagamento pagamento ");
			consulta.append("LEFT JOIN FETCH pagamento.imovel imovel ");
			consulta.append("INNER JOIN FETCH imovel.quadra quadra ");
			consulta.append("INNER JOIN FETCH imovel.localidade localidade ");
			consulta.append("INNER JOIN FETCH imovel.setorComercial setorComercial ");
			consulta.append("INNER JOIN FETCH imovel.quadra quadra ");
			consulta.append("LEFT JOIN FETCH pagamento.cliente cliente ");
			consulta.append("INNER JOIN FETCH pagamento.localidade localidade ");
			consulta.append("INNER JOIN FETCH pagamento.documentoTipo documentoTipo ");
			consulta.append("LEFT JOIN FETCH pagamento.guiaPagamentoGeral guiaPagamentoGeral ");
			consulta.append("LEFT JOIN FETCH guiaPagamentoGeral.guiaPagamento guiaPagamento ");
			consulta.append("LEFT JOIN FETCH pagamento.debitoTipo debitoTipo ");
			consulta.append("LEFT JOIN FETCH pagamento.debitoACobrar debitoACobrar ");
			consulta.append("LEFT JOIN FETCH pagamento.pagamentoSituacaoAtual pagamentoSituacao ");
			consulta.append("LEFT JOIN FETCH pagamento.avisoBancario avisoBancario ");
			consulta.append("LEFT JOIN FETCH pagamento.conta conta ");
			consulta.append("LEFT JOIN FETCH conta.debitoCreditoSituacaoAtual contaSituacao ");
			consulta.append("WHERE ");
			consulta.append("pagamento.id = :pagamentoId ");

			query = session.createQuery(consulta.toString()).setParameter("pagamentoId", pagamentoId);

			retorno = (Pagamento) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * [SB0001] – Selecionar Conta pelo Imóvel e Ano/Mês de Referência
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public Conta selecionarContaPorImovelAnoMesReferenciaPagamento(Integer idImovel, Integer anoMesReferenciaPagamento)
					throws ErroRepositorioException{

		Conta retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT conta ");
			consulta.append("FROM Pagamento pagamento ");
			consulta.append("INNER JOIN pagamento.conta conta ");
			consulta.append("INNER JOIN conta.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual ");
			consulta.append("WHERE ");
			consulta.append("	(pagamento.imovel = conta.imovel ");
			consulta.append("	AND pagamento.anoMesReferenciaPagamento = conta.referencia) ");
			consulta.append("	AND (pagamento.imovel.id = :idImovel ");
			consulta.append("	AND pagamento.anoMesReferenciaPagamento = :anoMesReferenciaPagamento) ");
			consulta.append("	AND debitoCreditoSituacaoAtual.id IN ( " + DebitoCreditoSituacao.NORMAL + ","
							+ DebitoCreditoSituacao.RETIFICADA + "," + DebitoCreditoSituacao.INCLUIDA + ","
							+ DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO + " )");

			query = session.createQuery(consulta.toString());
			query.setInteger("idImovel", idImovel);
			query.setInteger("anoMesReferenciaPagamento", anoMesReferenciaPagamento);

			retorno = (Conta) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * [SB0001] – Selecionar Conta pelo Imóvel e Ano/Mês de Referência
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public ContaHistorico selecionarContaHistoricoPorImovelAnoMesReferenciaPagamento(Integer idImovel, Integer anoMesReferenciaPagamento)
					throws ErroRepositorioException{

		ContaHistorico retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT contaHistorico ");
			consulta.append("FROM ContaHistorico contaHistorico ");
			consulta.append("INNER JOIN contaHistorico.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual ");
			consulta.append("WHERE ");
			consulta.append("	debitoCreditoSituacaoAtual.id IN ( " + DebitoCreditoSituacao.NORMAL + "," + DebitoCreditoSituacao.RETIFICADA
							+ "," + DebitoCreditoSituacao.INCLUIDA + "," + DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO + " )");
			consulta.append("	AND  (contaHistorico.imovel.id, contaHistorico.anoMesReferenciaConta) in ");
			consulta.append("		(SELECT pagamento.imovel.id, pagamento.anoMesReferenciaPagamento");
			consulta.append("		FROM Pagamento pagamento ");
			consulta.append("		WHERE ");
			consulta.append("			pagamento.imovel.id = :idImovel ");
			consulta.append("			AND pagamento.anoMesReferenciaPagamento = :anoMesReferenciaPagamento)");

			query = session.createQuery(consulta.toString());
			query.setInteger("idImovel", idImovel);
			query.setInteger("anoMesReferenciaPagamento", anoMesReferenciaPagamento);

			retorno = (ContaHistorico) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * [SB0002] – Verificar Pagamento de Conta
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public Collection<Pagamento> selecionarPagamentoPorConta(Integer idConta) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT pagamento ");
			consulta.append("FROM Pagamento pagamento ");
			consulta.append("INNER JOIN FETCH pagamento.documentoTipo documentoTipo ");
			consulta.append("WHERE ");
			consulta.append("	pagamento.conta.id = :idConta ");
			consulta.append("	ORDER BY ");
			consulta.append("		pagamento.dataPagamento ");

			query = session.createQuery(consulta.toString());
			query.setInteger("idConta", idConta);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * 3.2.1.2. Seleciona a guia de pagamento correspondente (a partir da tabela GUIA_PAGAMENTO com
	 * GPAG_ID do pagamento e da tabela GUIA_PAGAMENTO_PRESTACAO com GPAG_ID do pagamento e
	 * GPPR_NNPRESTACAO=PGMT_NNPRESTACAO).
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public GuiaPagamentoPrestacao selecionarGuiaPagamentoPorGuiaPagamentoNumeroPrestacao(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		GuiaPagamentoPrestacao retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append(" SELECT gpp ");
			consulta.append(" FROM GuiaPagamentoPrestacao gpp ");
			consulta.append(" INNER JOIN FETCH gpp.guiaPagamento guiaPagamento ");
			consulta.append(" WHERE ");
			consulta.append("	guiaPagamento.id = :idGuiaPagamento ");
			consulta.append("	AND gpp.comp_id.numeroPrestacao = :numeroPrestacao ");

			query = session.createQuery(consulta.toString());

			query.setInteger("idGuiaPagamento", idGuiaPagamento);
			query.setShort("numeroPrestacao", numeroPrestacao.shortValue());

			retorno = (GuiaPagamentoPrestacao) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * Seleciona Pagamentos da guia de pagamento.
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public Collection<Pagamento> selecionarPagamentoPorGuiaPagamento(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT pagamento ");
			consulta.append("FROM Pagamento pagamento ");
			consulta.append("INNER JOIN pagamento.guiaPagamentoGeral.guiaPagamento guiaPagamento ");
			consulta.append("WHERE ");
			consulta.append("	guiaPagamento.id = :idGuiaPagamento ");
			consulta.append("	and pagamento.numeroPrestacao = :numeroPrestacao ");
			consulta.append("	ORDER BY ");
			consulta.append("		pagamento.dataPagamento ");

			query = session.createQuery(consulta.toString());
			query.setInteger("idGuiaPagamento", idGuiaPagamento);
			query.setInteger("numeroPrestacao", numeroPrestacao);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * [SB0003] – Selecionar Guia de Pagamento pela Localidade, Imóvel, Cliente e Tipo do Débito
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public List<GuiaPagamentoPrestacao> selecionarGuiaPagamentoPorLocalidadeImovelClienteTipoDebito(Integer idLocalidade, Integer idImovel,
					Integer idCliente, Integer idTipoDepito) throws ErroRepositorioException{

		List<GuiaPagamentoPrestacao> retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;
		Map parameters = new HashMap();

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT guiaPagamentoPrestacao ");
			consulta.append("FROM GuiaPagamentoPrestacao guiaPagamentoPrestacao ");
			consulta.append("INNER JOIN FETCH guiaPagamentoPrestacao.guiaPagamento guiaPagamento ");
			consulta.append("WHERE ");
			consulta.append("	guiaPagamento.localidade.id = :idLocalidade");

			parameters.put("idLocalidade", idLocalidade);

			if(!Util.isVazioOuBranco(idImovel)){
				consulta.append("	AND guiaPagamento.imovel.id = :idImovel ");
				parameters.put("idImovel", idImovel);
			}

			if(!Util.isVazioOuBranco(idCliente)){
				consulta.append("	AND guiaPagamento.cliente.id = :idCliente ");
				parameters.put("idDebitoTipo", idTipoDepito);
			}

			if(!Util.isVazioOuBranco(idTipoDepito)){
				consulta.append("	AND guiaPagamentoPrestacao.debitoTipo.id = :idDebitoTipo");
				parameters.put("idCliente", idCliente);
			}

			consulta.append("	AND guiaPagamentoPrestacao.debitoCreditoSituacao.id = :idDebitoCreditoSituacao");

			consulta.append(" ORDER BY guiaPagamentoPrestacao.dataVencimento");

			parameters.put("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL);

			query = session.createQuery(consulta.toString());

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Set){
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				}else if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else if(parameters.get(key) instanceof Integer[]){
					Integer[] collection = (Integer[]) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * Seleciona Pagamentos do debito a cobrar.
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public Collection<Pagamento> selecionarPagamentoPorDebitoACobrar(Integer idDebitoACobrar) throws ErroRepositorioException{

		Collection<Pagamento> retorno = null;
		Session session = HibernateUtil.getSession();
		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT pagamento ");
			consulta.append("FROM Pagamento pagamento ");
			consulta.append("INNER JOIN FETCH pagamento.debitoACobrar debitoACobrar ");
			consulta.append("WHERE ");
			consulta.append("	debitoACobrar.id = :idDebitoACobrar ");
			consulta.append("	ORDER BY ");
			consulta.append("		pagamento.dataPagamento ");

			query = session.createQuery(consulta.toString());
			query.setInteger("idDebitoACobrar", idDebitoACobrar);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * [SB0005 – Selecionar Débito a Cobrar pela Localidade, Imóvel, e Tipo do Débito]
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public DebitoACobrar selecionarDebitoACobrarPorImovelTipoDebito(Integer idImovel, Integer idTipoDepito) throws ErroRepositorioException{

		DebitoACobrar retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT debitoACobrar ");
			consulta.append("FROM Pagamento pagamento ");
			consulta.append("INNER JOIN pagamento.debitoACobrar debitoACobrar ");
			consulta.append("WHERE ");
			consulta.append("	pagamento.imovel.id = :idImovel ");
			consulta.append("	AND pagamento.debitoTipo.id = :idDebitoTipo");
			consulta.append("	AND debitoACobrar IS NOT NULL ");
			consulta.append("	AND debitoACobrar.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao");

			query = session.createQuery(consulta.toString());
			query.setInteger("idImovel", idImovel);
			query.setInteger("idDebitoTipo", idTipoDepito);
			query.setInteger("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL);

			retorno = (DebitoACobrar) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Collection<PagamentoHistorico> selecionarPagamentoHistoricoPorGuiaPagamentoHistorico(Integer idGuiaPagamento)
					throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = null;
		Session session = HibernateUtil.getSession();
		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT pagamentoHistorico ");
			consulta.append("FROM PagamentoHistorico pagamentoHistorico ");
			consulta.append("WHERE ");
			consulta.append("	pagamentoHistorico.guiaPagamentoGeral.id = :idGuiaPagamento ");

			query = session.createQuery(consulta.toString());
			query.setInteger("idGuiaPagamento", idGuiaPagamento);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection<PagamentoHistorico> selecionarPagamentoHistoricoPorContaHistorico(Integer idConta) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT pagamentoHistorico ");
			consulta.append("FROM PagamentoHistorico pagamentoHistorico ");
			consulta.append("WHERE ");
			consulta.append("	pagamentoHistorico.conta.id = :idConta ");
			consulta.append("	ORDER BY ");
			consulta.append("		pagamentoHistorico.dataPagamento ");

			query = session.createQuery(consulta.toString());
			query.setInteger("idConta", idConta);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0266] Manter Pagamentos.
	 * 1.2.2. Caso a guia não seja NULL, pesquisar em GUIA_PAGAMENTO_PRESTACAO pelo Id da guia e
	 * Número da prestação do pagamento:
	 * 
	 * @author Josenildo Neves
	 * @date 21/03/2013
	 */
	public BigDecimal selecionarGuiaPagamentoPrestacaoPorGuiaPagamentoENumeroPrestacao(Integer idGuiaPagamento,
					Integer numeroPrestacao) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append(" SELECT SUM(gpp.valorPrestacao) ");
			consulta.append(" FROM GuiaPagamentoPrestacao gpp ");
			consulta.append(" INNER JOIN gpp.guiaPagamento guiaPagamento ");
			consulta.append(" WHERE ");
			consulta.append("	guiaPagamento.id = :idGuiaPagamento ");
			consulta.append("	AND gpp.comp_id.numeroPrestacao = :numeroPrestacao ");

			query = session.createQuery(consulta.toString());

			query.setInteger("idGuiaPagamento", idGuiaPagamento);
			query.setShort("numeroPrestacao", numeroPrestacao.shortValue());

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Consulta generica
	 */
	public Collection<ArrecadadorContrato> consultarArrecadadorContratoGenerico(ArrecadadorContrato contrato, String parametroConsulta,
					String valorConsulta, boolean isAlteracao) throws ErroRepositorioException{

		Collection<ArrecadadorContrato> retorno = null;

		Session session = HibernateUtil.getSession();

		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append(" SELECT ac  ");
			consulta.append(" FROM ArrecadadorContrato ac ");
			consulta.append(" INNER JOIN ac.arrecadador a ");
			consulta.append(" WHERE ac.dataContratoEncerramento is null  ");
			consulta.append("  AND a.id = " + contrato.getArrecadador().getId());
			
			Collection<String> parametrosChar = Arrays.asList(FiltroArrecadadorContrato.CODIGO_CONVENIO_BOLETO_BANCARIO,
							FiltroArrecadadorContrato.CODIGO_CONVENIO_FICHA_COMPENSACAO,
							FiltroArrecadadorContrato.CODIGO_CONVENIO_PARCELAMENTO_RESP);
			if(parametrosChar.contains(parametroConsulta)){
				consulta.append("  AND trim(ac." + parametroConsulta + ") = " + valorConsulta.trim());
			}else{
				consulta.append("  AND trim(ac." + parametroConsulta + ") = '" + valorConsulta.trim() + "'");
			}

			if(isAlteracao){
				consulta.append("  AND ac.id not in (" + contrato.getId() + ")");
			}
			query = session.createQuery(consulta.toString());

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
		// trim( imo.numeroImovel )
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Retornar Percentual de Remuneração Reincidencia
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	public BigDecimal retornarPercentualRemuneracaoReincidencia(Integer idCobrancaAcaoAtividadeComando, Date dataPagamento)
					throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select cbco_pcremunreincidencia as percentual ");
			consulta.append("from cobranca_contrato cbco ");
			consulta.append("inner join cobranca_acao_atividade_comand cacm on cacm.empr_id = cbco.empr_id ");
			consulta.append("where cacm.cacm_id = :idCobrancaAcaoAtividadeComando ");
			consulta.append("  and cbco.cbco_dtcontratoinicio <= :dataPagamento ");
			consulta.append("order by cbco_dtcontratoinicio desc ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("percentual", Hibernate.BIG_DECIMAL);

			query.setInteger("idCobrancaAcaoAtividadeComando", idCobrancaAcaoAtividadeComando);
			query.setDate("dataPagamento", dataPagamento);

			retorno = (BigDecimal) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Retornar Número de dias mínimo determinado para remuneração dos acréscimos
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	public Integer retornarNumeroDeDiasMinimoDeterminadoParaRemuneracaoAcrescimos(Integer idCobrancaAcaoAtividadeComando, Date dataPagamento)
					throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select cbco_qtdiasreincidencia as qtdDias ");
			consulta.append("from cobranca_contrato cbco ");
			consulta.append("inner join cobranca_acao_atividade_comand cacm on cacm.empr_id = cbco.empr_id ");
			consulta.append("where cacm.cacm_id = :idCobrancaAcaoAtividadeComando ");
			consulta.append("  and cbco.cbco_dtcontratoinicio <= :dataPagamento ");
			consulta.append("order by cbco_dtcontratoinicio desc ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("qtdDias", Hibernate.INTEGER);

			query.setInteger("idCobrancaAcaoAtividadeComando", idCobrancaAcaoAtividadeComando);
			query.setDate("dataPagamento", dataPagamento);

			retorno = (Integer) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 */
	public Collection<PagamentoHistorico> selecionarPagamentoHistoricoPorGuiaPagamentoHistorico(Integer idGuiaPagamento,
					Integer numeroPrestacao) throws ErroRepositorioException{

		Collection<PagamentoHistorico> retorno = null;
		Session session = HibernateUtil.getSession();
		Query query = null;

		try{

			StringBuilder consulta = new StringBuilder();

			consulta.append("SELECT pagamentoHistorico ");
			consulta.append("FROM PagamentoHistorico pagamentoHistorico ");
			consulta.append("inner join PagamentoHistorico.guiaPagamentoGeral guiaPagamentoGeral ");
			consulta.append("WHERE ");
			consulta.append("	pagamentoHistorico.guiaPagamentoGeral.id = :idGuiaPagamento ");
			consulta.append("	pagamentoHistorico.numeroPrestacao = :numeroPrestacao ");

			query = session.createQuery(consulta.toString());
			query.setInteger("idGuiaPagamento", idGuiaPagamento);
			query.setInteger("numeroPrestacao", numeroPrestacao);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * @param idImovel
	 * @param idCobrancaSituacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarImovelCobrancaSituacao(Integer idImovel, Integer idCobrancaSituacao, Integer prazoGeracao)
					throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select ics.iscb_id AS id from IMOVEL_COBRANCA_SITUACAO ics ");
			consulta.append("where ");
			consulta.append("  ics.IMOV_ID = :idImovel");
			consulta.append("  and ics.CBST_ID = :idCobrancaSituacao");
			consulta.append("  and ics.ISCB_DTRETIRADACOBRANCA is not null");
			consulta.append("  and ics.ISCB_DTRETIRADACOBRANCA >= :dataRetiradaCobranca ");

			SQLQuery query = session.createSQLQuery(consulta.toString());
			query.addScalar("id", Hibernate.INTEGER);

			query.setInteger("idImovel", idImovel);
			query.setInteger("idCobrancaSituacao", idCobrancaSituacao);
			query.setDate("dataRetiradaCobranca", Util.subtrairNumeroDiasDeUmaData(new Date(), prazoGeracao));

			retorno = (Integer) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection<Object[]> pesquisarConcessionariaPorArrecadadorMovimento(Integer idArrecadadorMovimento)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select conc.conc_id as idConcessionaria, conc.conc_nmconcessionaria as nomeConcessionaria ");
			consulta.append("from aviso_bancario avbc ");
			consulta.append("inner join arrecadador_movimento armv on avbc.armv_id=armv.armv_id  ");
			consulta.append("inner join arrecadador arrc on avbc.arrc_id=arrc.arrc_id ");
			consulta.append("inner join arrecadador_contrato arct on arrc.arrc_id=arct.arrc_id ");
			consulta.append("inner join concessionaria conc on conc.conc_id = arct.conc_id ");
			consulta.append("where avbc.ctbc_id=arct.ctbc_iddepositoarrecadacao ");
			consulta.append("and armv.armv_id=:idArrecadadorMovimento ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("idConcessionaria", Hibernate.STRING);
			query.addScalar("nomeConcessionaria", Hibernate.STRING);

			query.setInteger("idArrecadadorMovimento", idArrecadadorMovimento);

			retorno = (Collection<Object[]>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	private Collection gerarMovimentoArrecadadoresNSAConsultaTres(Collection<Integer> idsArrecadadorMovimento,
					Integer codigoFormaArrecadacao, String idConcessionaria, Session session, String condicaoConcessionaria,
					String colunaConvenio){

		String consulta3 = " select count(armv_nmbanco) as qtdeRegistros, bnco_nmbanco as banco, "// 0,1
						+ " armv_dtgeracao as dataGeracao, armv_nnnsa as nsa,"// 2,3
						+ " sum(to_number(substr(amit_cnregistro,53,15), '000000000000000')) as valor,"// 4
						+ " actf.actf_vltarifa as tarifa, arfm.arfm_dsarrecadacaoforma as formaArrecadacao";// 5,6

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta3 += " ,conces.CONC_NMCONCESSIONARIA as concessionaria";// 7
		}

		consulta3 += " from arrecadador_movimento_item amit," + " arrecadador_movimento armv, arrecadador arrc, arrecadador_contrato arct,"
						+ " arrecadador_contrato_tarifa actf, arrecadacao_forma arfm," + " banco bnco";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta3 += " ,concessionaria conces";
		}

		consulta3 += " where amit.armv_id = armv.armv_id and" + " armv.armv_cdconvenio = arct." + colunaConvenio + " and ";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta3 += " arct.conc_id=conces.conc_id and";
		}

		consulta3 += " armv.armv_cdbanco = arrc.arrc_cdagente and" + " arct.arrc_id = arrc.arrc_id and "
						+ " arfm.arfm_cdarrecadacaoforma = 'Z' and" + " (actf.arfm_id = arfm.arfm_id and actf.arct_id = arct.arct_id) and"
						+ " armv.armv_cdbanco = bnco.bnco_id and" + " rgcd_id = 6 and armv.armv_id in(:idsArrecadadorMovimento)"
						+ condicaoConcessionaria;

		if(codigoFormaArrecadacao != null){
			consulta3 = consulta3 + " and arfm.arfm_id=" + codigoFormaArrecadacao;
		}

		consulta3 = consulta3 + " group by bnco_nmbanco, armv_dtgeracao, armv_nnnsa, "
						+ " actf.actf_vltarifa, actf.actf_vltarifa, arfm.arfm_dsarrecadacaoforma ";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta3 += " ,conces.CONC_NMCONCESSIONARIA";
		}

		consulta3 += " order by";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta3 += " conces.CONC_NMCONCESSIONARIA,";
		}

		consulta3 += " formaArrecadacao, bnco_nmbanco, armv_dtgeracao, armv_nnnsa, actf.actf_vltarifa ";

		SQLQuery query3 = session.createSQLQuery(consulta3).addScalar("qtdeRegistros", Hibernate.INTEGER).addScalar("banco",
						Hibernate.STRING).addScalar("dataGeracao", Hibernate.DATE).addScalar("nsa", Hibernate.INTEGER).addScalar("valor",
						Hibernate.LONG).addScalar("tarifa", Hibernate.BIG_DECIMAL).addScalar("formaArrecadacao", Hibernate.STRING);
		if(idConcessionaria != null && !idConcessionaria.equals("")){
			query3 = query3.addScalar("concessionaria", Hibernate.STRING);
		}

		Collection retornoConsulta3 = query3.setParameterList("idsArrecadadorMovimento", idsArrecadadorMovimento).list();

		return retornoConsulta3;
	}

	private Collection gerarMovimentoArrecadadoresNSAConsultaDois(Collection<Integer> idsArrecadadorMovimento,
					Integer codigoFormaArrecadacao, String idConcessionaria, Session session, String condicaoConcessionaria,
					String colunaConvenio){

		String consulta2 = " select count(armv_nmbanco) as qtdeRegistros, bnco_nmbanco as banco, "// 0,1
						+ " armv_dtgeracao as dataGeracao, armv_nnnsa as nsa,"// 2,3
						+ " sum(to_number(substr(amit_cnregistro, 82,12), '000000000000')) as valor,"// 4
						+ " actf.actf_vltarifa as tarifa, arfm.arfm_dsarrecadacaoforma as formaArrecadacao";// 5,6

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta2 += " ,conces.CONC_NMCONCESSIONARIA as concessionaria";
		}// 7

		consulta2 += " from arrecadador_movimento_item amit," + " arrecadador_movimento armv, arrecadador arrc, arrecadador_contrato arct,"
						+ " arrecadador_contrato_tarifa actf, arrecadacao_forma arfm," + " banco bnco";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta2 += " ,concessionaria conces";
		}

		consulta2 += " where amit.armv_id = armv.armv_id and " + " armv.armv_cdconvenio = arct." + colunaConvenio + " and ";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta2 += " arct.conc_id=conces.conc_id and";
		}

		consulta2 += " substr(amit_cnregistro, 117,1) = ' ' and" + " armv.armv_cdbanco = arrc.arrc_cdagente and"
						+ " arct.arrc_id = arrc.arrc_id and" + " arfm.arfm_cdarrecadacaoforma = '1' and"
						+ " (actf.arfm_id = arfm.arfm_id and actf.arct_id = arct.arct_id) and" + " armv.armv_cdbanco = bnco.bnco_id and"
						+ " rgcd_id = 7 and armv.armv_id in(:idsArrecadadorMovimento)" + condicaoConcessionaria;

		if(codigoFormaArrecadacao != null){
			consulta2 = consulta2 + " and arfm.arfm_id=" + codigoFormaArrecadacao;
		}

		consulta2 = consulta2 + " group by bnco_nmbanco, armv_dtgeracao, armv_nnnsa, "
						+ " actf.actf_vltarifa, actf.actf_vltarifa, arfm.arfm_dsarrecadacaoforma ";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta2 += " ,conces.CONC_NMCONCESSIONARIA";
		}

		consulta2 += " order by formaArrecadacao, bnco_nmbanco,";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta2 += "conces.CONC_NMCONCESSIONARIA, ";
		}

		consulta2 += " armv_dtgeracao, armv_nnnsa, actf.actf_vltarifa ";

		SQLQuery query2 = session.createSQLQuery(consulta2).addScalar("qtdeRegistros", Hibernate.INTEGER).addScalar("banco",
						Hibernate.STRING).addScalar("dataGeracao", Hibernate.DATE).addScalar("nsa", Hibernate.INTEGER).addScalar("valor",
						Hibernate.LONG).addScalar("tarifa", Hibernate.BIG_DECIMAL).addScalar("formaArrecadacao", Hibernate.STRING);

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			query2 = query2.addScalar("concessionaria", Hibernate.STRING);
		}
		Collection retornoConsulta2 = query2.setParameterList("idsArrecadadorMovimento", idsArrecadadorMovimento).list();

		return retornoConsulta2;
	}

	private Collection gerarMovimentoArrecadadoresNSAConsultaUm(Collection<Integer> idsArrecadadorMovimento,
					Integer codigoFormaArrecadacao, String idConcessionaria, Session session, String condicaoConcessionaria,
					String colunaConvenio){

		String consulta1 = " select count(armv_nmbanco) as qtdeRegistros, bnco_nmbanco as banco, "// 0,1
						+ " armv_dtgeracao as dataGeracao, armv_nnnsa as nsa,"// 2,3
						+ " sum(to_number(substr(amit_cnregistro, 82,12), '000000000000')) as valor,"// 4
						+ " actf.actf_vltarifa as tarifa, arfm.arfm_dsarrecadacaoforma as formaArrecadacao";// 5,6

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta1 += " ,conces.conc_nmconcessionaria as concessionaria";// 7
		}

		consulta1 += " from arrecadador_movimento_item amit, arrecadacao_forma arfm,"
						+ " arrecadador_movimento armv, arrecadador arrc, arrecadador_contrato arct,"
						+ " arrecadador_contrato_tarifa actf," + " banco bnco";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta1 += " ,concessionaria conces";
		}

		consulta1 += " where amit.armv_id = armv.armv_id and" + " armv.armv_cdconvenio = arct." + colunaConvenio + " and ";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta1 += " arct.conc_id=conces.conc_id and";
		}

		// DECODE-> se "substr(amit_cnregistro, 117,1)" for igual a
		// "arfm.arfm_cdarrecadacaoformacompara" retorna
		// "arfm.arfm_cdarrecadacaoforma", caso contrário retorna 4 (Outros
		// Meios)

		consulta1 += " DECODE (substr(amit_cnregistro, 117,1), arfm.arfm_cdarrecadacaoforma, arfm.arfm_cdarrecadacaoforma, '4') = arfm.arfm_cdarrecadacaoforma and"
						+ " substr(amit_cnregistro, 117,1) = arfm.arfm_cdarrecadacaoforma and"
						+ " armv.armv_cdbanco = arrc.arrc_cdagente and"
						+ " arct.arrc_id = arrc.arrc_id and"
						+ " (actf.arfm_id = arfm.arfm_id and actf.arct_id = arct.arct_id) and"
						+ " armv.armv_cdbanco = bnco.bnco_id and"
						+ " rgcd_id = 7 and armv.armv_id in (:idsArrecadadorMovimento)" + condicaoConcessionaria;

		if(codigoFormaArrecadacao != null){
			consulta1 = consulta1 + " and arfm.arfm_id=" + codigoFormaArrecadacao;
		}

		consulta1 = consulta1 + " group by bnco_nmbanco, armv_dtgeracao, armv_nnnsa, "
						+ " actf.actf_vltarifa, actf.actf_vltarifa, arfm.arfm_dsarrecadacaoforma ";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta1 += " ,conces.conc_nmconcessionaria";
		}

		consulta1 += " order by ";

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			consulta1 += " conces.conc_nmconcessionaria, ";
		}

		consulta1 += " formaArrecadacao, bnco_nmbanco, armv_dtgeracao, armv_nnnsa, actf.actf_vltarifa ";

		SQLQuery query = session.createSQLQuery(consulta1).addScalar("qtdeRegistros", Hibernate.INTEGER).addScalar("banco",
						Hibernate.STRING).addScalar("dataGeracao", Hibernate.DATE).addScalar("nsa", Hibernate.INTEGER).addScalar("valor",
						Hibernate.LONG).addScalar("tarifa", Hibernate.BIG_DECIMAL).addScalar("formaArrecadacao", Hibernate.STRING);

		if(idConcessionaria != null && !idConcessionaria.equals("")){
			query = query.addScalar("concessionaria", Hibernate.STRING);
		}

		Collection retornoConsulta1 = query.setParameterList("idsArrecadadorMovimento", idsArrecadadorMovimento).list();

		return retornoConsulta1;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.arrecadacao.IRepositorioArrecadacao#atualizarIndicadorPagamentoConta(java.lang.Integer,
	 * java.lang.Integer)
	 */
	public void atualizarIndicadorPagamentoConta(Integer idImovel, Integer anoMesReferenciaConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();

		try{

			sql.append("UPDATE Conta cnta ").append("SET cnta.indicadorPagamento = " + ConstantesSistema.SIM)
							.append(" WHERE cnta.imovel.id = :idImovel and cnta.referencia = :anoMesReferenciaConta ");

			Query query = session.createQuery(sql.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferenciaConta", anoMesReferenciaConta);

			query.executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
			sql = null;
		}

	}

	/**
	 * Método que retorna o objeto de AcrescimoImpontualidadeDesconto mais atual de acordo com o
	 * periodo informado.
	 * 
	 * @see gcom.arrecadacao.IRepositorioArrecadacao#pesquisarAcrescimoImpontualidadeFiltro(gcom.arrecadacao.FiltroAcrescimoImpontualidadeDesconto)
	 */
	public AcrescimoImpontualidadeDesconto pesquisarAcrescimoImpontualidadeFiltro(FiltroAcrescimoImpontualidadeDesconto filtro){

		AcrescimoImpontualidadeDesconto retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		consulta.append("select aid ");
		consulta.append("from AcrescimoImpontualidadeDesconto aid ");

		String concatenar = " where ";

		if(Util.isNaoNuloBrancoZero(filtro.getDtPagamento())){
			consulta.append(concatenar);
			concatenar = " AND ";
			consulta.append("  (aid.dtPagamentoInicial < :dataPagamento OR aid.dtPagamentoInicial is null)");
			consulta.append(concatenar);
			consulta.append(" ( aid.dtPagamentoFinal > :dataPagamento OR aid.dtPagamentoFinal is null ) ");
		}

		if(Util.isNaoNuloBrancoZero(filtro.getAnoMesReferencia())){
			consulta.append(concatenar);
			concatenar = " AND ";
			consulta.append("  (aid.anoMesReferenciaInicial < :anoMesReferencia OR aid.anoMesReferenciaInicial is null) ");
			consulta.append(concatenar);
			consulta.append("  (aid.anoMesReferenciaFinal > :anoMesReferencia OR aid.anoMesReferenciaFinal is null) ");
		}

		if(Util.isNaoNuloBrancoZero(filtro.getDtVencimento())){
			consulta.append(concatenar);
			concatenar = " AND ";
			consulta.append(" ( aid.dtVencimentoInicial < :dataVencimento OR aid.dtVencimentoInicial is null) ");
			consulta.append(concatenar);
			consulta.append(" ( aid.dtVencimentoFinal > :dataVencimento OR aid.dtVencimentoFinal is null ) ");
		}

		consulta.append(" order by aid.ultimaAlteracao desc");

		Query query = session.createQuery(consulta.toString());

		if(Util.isNaoNuloBrancoZero(filtro.getDtPagamento())){
			query.setDate("dataPagamento", filtro.getDtPagamento());
		}

		if(Util.isNaoNuloBrancoZero(filtro.getAnoMesReferencia())){
			query.setInteger("anoMesReferencia", filtro.getAnoMesReferencia());
		}

		if(Util.isNaoNuloBrancoZero(filtro.getDtVencimento())){
			query.setDate("dataVencimento", filtro.getDtVencimento());
		}

		retorno = (AcrescimoImpontualidadeDesconto) query.setMaxResults(1).uniqueResult();

		return retorno;
	}

	/**
	 * Comprovantes da Arrecadação por Recebedor
	 * 
	 * @author Hebert Falcão
	 * @since 28/09/2013
	 */
	public Integer pesquisarComprovantesDaArrecadacaoPorRecebedorCount(Integer anoMesReferencia) throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT COUNT(*) AS count ");
			consulta.append("FROM AVISO_BANCARIO AVBC ");
			consulta.append("INNER JOIN CONTA_BANCARIA CTBC ON CTBC.CTBC_ID = AVBC.CTBC_ID ");
			consulta.append("INNER JOIN AGENCIA AGEN ON AGEN.AGEN_ID = CTBC.CTBC_ID ");
			consulta.append("INNER JOIN BANCO BNCO ON BNCO.BNCO_ID =  AGEN.BNCO_ID ");
			consulta.append("LEFT JOIN LOGRADOURO LOGR ON LOGR.LOGR_ID = AGEN.LOGR_ID ");
			consulta.append("LEFT JOIN MUNICIPIO MUNI ON MUNI.MUNI_ID = LOGR.MUNI_ID ");
			consulta.append("WHERE AVBC.AVBC_AMREFERENCIAARRECADACAO = :anoMesReferencia ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("count", Hibernate.INTEGER);

			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = ((Number) query.setMaxResults(1).uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Comprovantes da Arrecadação por Recebedor
	 * 
	 * @author Hebert Falcão
	 * @since 28/09/2013
	 */
	public Collection<Object[]> pesquisarComprovantesDaArrecadacaoPorRecebedorSintetico(Integer anoMesReferencia)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT BNCO.BNCO_ID AS idBanco, ");
			consulta.append("       BNCO.BNCO_NMBANCO AS nomeBanco, ");
			consulta.append("       SUM(AVBC.AVBC_VLARRECADACAOINFORMADO) AS valorInformadoCredito, ");
			consulta.append("       SUM(AVBC.AVBC_VLARRECADACAOCALCULADO) AS valorCalculadoCredito, ");
			consulta.append("       SUM(AVBC.AVBC_VLDEVOLUCAOINFORMADO) AS valorInformadoDebito, ");
			consulta.append("       SUM(AVBC.AVBC_VLDEVOLUCAOCALCULADO) AS valorCalculadoDebito ");
			consulta.append("FROM AVISO_BANCARIO AVBC ");
			consulta.append("INNER JOIN CONTA_BANCARIA CTBC ON CTBC.CTBC_ID = AVBC.CTBC_ID ");
			consulta.append("INNER JOIN AGENCIA AGEN ON AGEN.AGEN_ID = CTBC.AGEN_ID ");
			consulta.append("INNER JOIN BANCO BNCO ON BNCO.BNCO_ID = AGEN.BNCO_ID ");
			consulta.append("WHERE AVBC.AVBC_AMREFERENCIAARRECADACAO = :anoMesReferencia ");
			consulta.append("GROUP BY BNCO.BNCO_ID, BNCO.BNCO_NMBANCO ");
			consulta.append("ORDER BY BNCO.BNCO_ID ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("idBanco", Hibernate.INTEGER);
			query.addScalar("nomeBanco", Hibernate.STRING);
			query.addScalar("valorInformadoCredito", Hibernate.BIG_DECIMAL);
			query.addScalar("valorCalculadoCredito", Hibernate.BIG_DECIMAL);
			query.addScalar("valorInformadoDebito", Hibernate.BIG_DECIMAL);
			query.addScalar("valorCalculadoDebito", Hibernate.BIG_DECIMAL);

			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Comprovantes da Arrecadação por Recebedor
	 * 
	 * @author Hebert Falcão
	 * @since 28/09/2013
	 */
	public Collection<Object[]> pesquisarComprovantesDaArrecadacaoPorRecebedorAnalitico(Integer anoMesReferencia)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT BNCO.BNCO_ID AS idBanco, ");
			consulta.append("       BNCO.BNCO_NMBANCO AS nomeBanco, ");
			consulta.append("       AGEN.AGEN_CDAGENCIA AS codigoAgencia, ");
			consulta.append("       AGEN.AGEN_NMAGENCIA AS nomeAgencia, ");
			consulta.append("       MUNI.MUNI_NMMUNICIPIO AS nomeLocalidade, ");
			consulta.append("       ' ' AS codigoContabil, ");
			consulta.append("       AVBC.AVBC_DTLANCAMENTO AS dataLancamento, ");
			consulta.append("       AVBC.AVBC_ID AS idAviso, ");
			consulta.append("       AVBC.AVBC_ICCREDITODEBITO AS indicadorCreditoDebito, ");
			consulta.append("       (CASE WHEN AVBC.AVBC_ICCREDITODEBITO = 1 THEN AVBC.AVBC_VLARRECADACAOINFORMADO ELSE AVBC.AVBC_VLDEVOLUCAOINFORMADO END) AS valorInformado, ");
			consulta.append("       (CASE WHEN AVBC.AVBC_ICCREDITODEBITO = 1 THEN AVBC.AVBC_VLARRECADACAOCALCULADO ELSE AVBC.AVBC_VLDEVOLUCAOCALCULADO END) AS valorCalculado ");
			consulta.append("FROM AVISO_BANCARIO AVBC ");
			consulta.append("INNER JOIN CONTA_BANCARIA CTBC ON CTBC.CTBC_ID = AVBC.CTBC_ID ");
			consulta.append("INNER JOIN AGENCIA AGEN ON AGEN.AGEN_ID = CTBC.AGEN_ID ");
			consulta.append("INNER JOIN BANCO BNCO ON BNCO.BNCO_ID = AGEN.BNCO_ID ");
			consulta.append("LEFT JOIN LOGRADOURO LOGR ON LOGR.LOGR_ID = AGEN.LOGR_ID ");
			consulta.append("LEFT JOIN MUNICIPIO MUNI ON MUNI.MUNI_ID = LOGR.MUNI_ID ");
			consulta.append("WHERE AVBC.AVBC_AMREFERENCIAARRECADACAO = :anoMesReferencia ");
			consulta.append("ORDER BY BNCO.BNCO_ID, AGEN.AGEN_CDAGENCIA, AVBC.AVBC_DTLANCAMENTO ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("idBanco", Hibernate.INTEGER);
			query.addScalar("nomeBanco", Hibernate.STRING);
			query.addScalar("codigoAgencia", Hibernate.STRING);
			query.addScalar("nomeAgencia", Hibernate.STRING);
			query.addScalar("nomeLocalidade", Hibernate.STRING);
			query.addScalar("codigoContabil", Hibernate.STRING);
			query.addScalar("dataLancamento", Hibernate.DATE);
			query.addScalar("idAviso", Hibernate.INTEGER);
			query.addScalar("indicadorCreditoDebito", Hibernate.SHORT);
			query.addScalar("valorInformado", Hibernate.BIG_DECIMAL);
			query.addScalar("valorCalculado", Hibernate.BIG_DECIMAL);

			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Situação dos avisos bancários
	 * 
	 * @author Hebert Falcão
	 * @since 04/10/2013
	 */
	public int pesquisarSituacaoDosAvisosBancariosCount(Integer anoMesReferencia) throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT COUNT(*) AS count ");
			consulta.append("FROM AVISO_BANCARIO AVBC ");
			consulta.append("INNER JOIN CONTA_BANCARIA CTBC ON CTBC.CTBC_ID = AVBC.CTBC_ID ");
			consulta.append("INNER JOIN AGENCIA AGEN ON AGEN.AGEN_ID = CTBC.CTBC_ID ");
			consulta.append("INNER JOIN BANCO BNCO ON BNCO.BNCO_ID = AGEN.BNCO_ID ");
			consulta.append("WHERE AVBC.AVBC_AMREFERENCIAARRECADACAO = :anoMesReferencia ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("count", Hibernate.INTEGER);

			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = ((Number) query.setMaxResults(1).uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Situação dos avisos bancários
	 * 
	 * @author Hebert Falcão
	 * @since 04/10/2013
	 */
	public Collection<Object[]> pesquisarSituacaoDosAvisosBancarios(Integer anoMesReferencia) throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT BNCO.BNCO_ID AS idBanco, ");
			consulta.append("       BNCO.BNCO_NMBANCO AS nomeBanco, ");
			consulta.append("       AGEN.AGEN_CDAGENCIA AS codigoAgencia, ");
			consulta.append("       AGEN.AGEN_NMAGENCIA AS nomeAgencia, ");
			consulta.append("       AVBC.AVBC_DTLANCAMENTO AS dataLancamento, ");
			consulta.append("       AVBC.AVBC_ID AS idAviso, ");
			consulta.append("       AVBC.AVBC_VLARRECADACAOINFORMADO AS valorInformadoCredito, ");
			consulta.append("       AVBC.AVBC_VLARRECADACAOCALCULADO AS valorCalculadoCredito, ");
			consulta.append("       AVBC.AVBC_VLDEVOLUCAOINFORMADO AS valorInformadoDebito, ");
			consulta.append("       AVBC.AVBC_VLDEVOLUCAOCALCULADO AS valorCalculadoDebito, ");
			consulta.append("       AVBC.AVBC_ICCREDITODEBITO AS indicadorCreditoDebito, ");
			consulta.append("       AVBC.AVBC_VLREALIZADO AS valorRealizado ");
			consulta.append("FROM AVISO_BANCARIO AVBC ");
			consulta.append("INNER JOIN CONTA_BANCARIA CTBC ON CTBC.CTBC_ID = AVBC.CTBC_ID ");
			consulta.append("INNER JOIN AGENCIA AGEN ON AGEN.AGEN_ID = CTBC.AGEN_ID ");
			consulta.append("INNER JOIN BANCO BNCO ON BNCO.BNCO_ID = AGEN.BNCO_ID ");
			consulta.append("WHERE AVBC.AVBC_AMREFERENCIAARRECADACAO = :anoMesReferencia ");
			consulta.append("ORDER BY BNCO.BNCO_ID, AGEN.AGEN_CDAGENCIA, AVBC.AVBC_DTLANCAMENTO ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("idBanco", Hibernate.INTEGER);
			query.addScalar("nomeBanco", Hibernate.STRING);
			query.addScalar("codigoAgencia", Hibernate.STRING);
			query.addScalar("nomeAgencia", Hibernate.STRING);
			query.addScalar("dataLancamento", Hibernate.DATE);
			query.addScalar("idAviso", Hibernate.INTEGER);
			query.addScalar("valorInformadoCredito", Hibernate.BIG_DECIMAL);
			query.addScalar("valorCalculadoCredito", Hibernate.BIG_DECIMAL);
			query.addScalar("valorInformadoDebito", Hibernate.BIG_DECIMAL);
			query.addScalar("valorCalculadoDebito", Hibernate.BIG_DECIMAL);
			query.addScalar("indicadorCreditoDebito", Hibernate.SHORT);
			query.addScalar("valorRealizado", Hibernate.BIG_DECIMAL);

			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0265] Inserir Pagamentos
	 * 
	 * @author Anderson Italo
	 * @date 21/10/2013
	 */
	public Pagamento pesquisarPagamentoComSituacaoAtual(Integer idPagamento) throws ErroRepositorioException{

		Pagamento retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select pag from Pagamento pag   ");
			consulta.append(" inner join fetch pag.pagamentoSituacaoAtual pagSitAtual ");
			consulta.append(" where pag.id = :idPagamento ");

			retorno = (Pagamento) session.createQuery(consulta.toString()).setInteger("idPagamento", idPagamento).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar arrecadador movimento item inválido
	 * 
	 * @author Hebert Falcão
	 * @date 10/12/2014
	 */
	public Collection<ArrecadadorMovimentoItem> pesquisarArrecadadorMovimentoItemCodigoBarrasInvalido(String conteudoRegistro,
					String ocorrenciaImovel, Short indicadorAceitacao) throws ErroRepositorioException{

		Collection<ArrecadadorMovimentoItem> retorno = new ArrayList<ArrecadadorMovimentoItem>();

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select amit ");
			consulta.append("from ArrecadadorMovimentoItem amit ");
			consulta.append("where amit.descricaoOcorrencia = :ocorrenciaImovel ");
			consulta.append("  and amit.indicadorAceitacao = :indicadorAceitacao ");
			consulta.append("  and amit.ultimaAlteracao >= :dataHoraInicial ");
			consulta.append("  and amit.conteudoRegistro like :conteudoRegistro ");
			consulta.append("  and amit.id not in (select acba.idArrecadadorMovimentoItem ");
			consulta.append("                      from AjusteCodigoBarras acba) ");
			consulta.append("order by amit.id ");

			Date dataHoraInicial = Util.criarData(1, 12, 2013);

			Query query = session.createQuery(consulta.toString());

			query.setString("ocorrenciaImovel", ocorrenciaImovel);
			query.setShort("indicadorAceitacao", indicadorAceitacao);
			query.setTimestamp("dataHoraInicial", dataHoraInicial);
			query.setString("conteudoRegistro", conteudoRegistro);

			retorno = (Collection<ArrecadadorMovimentoItem>) query.list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [OC1196098] - Quadro Comparativo de Faturamento e Arrecadação
	 * 
	 * @author Ado Rocha
	 * @date 26/12/2013
	 * @throws ControladorException
	 */
	public void gerarQuadroComparativoFaturamentoArrecadacao(String dateInicioMes, String dateFimMes, Integer anoMesInicio,
					Integer anoMesFim) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		
		Connection con = null;
		Statement stmt = null;
		
		try{

			con = session.connection();
			stmt = con.createStatement();
			
			String query = "INSERT INTO QUADRO_FATURAMENTO_ARRECADACAO " + " SELECT SQ_QUADRO_FATURAMENTO_ARREC.NEXTVAL, " + "LOCAL, "
							+ "REFERENCIA, " + "CATEGORIA, " + "0, " + "VALOR_FATURADO, " + "0, " + "0, " + "0, " + "0, " + "0, " + "0, "
							+ "0, " + "0, " + "0, " + "0, " + "VALOR_PARCELAMENTO, " + "SYSTIMESTAMP " + "FROM "
							+ "(SELECT UNCO_ID LOCAL, " + "TO_CHAR(LACS_DTCONTABIL,'YYYYMM') REFERENCIA, " + "CATG_ID CATEGORIA, "
							+ "SUM(LACS_VL) VALOR_FATURADO, " + "SUM(DECODE(EVCO_ID,84,LACS_VL,0)) VALOR_PARCELAMENTO "
							+ "FROM LANCAMENTO_CONTABIL_SINTETICO " + "WHERE EVCO_ID IN (80,81,82,84) "
 + "AND LACS_DTCONTABIL BETWEEN '"
							+ dateInicioMes + "' AND '" + dateFimMes + "' GROUP BY UNCO_ID, " + "TO_CHAR(LACS_DTCONTABIL,'YYYYMM'), "
							+ "CATG_ID)";

			stmt.execute(query);

			String query2 = "UPDATE QUADRO_FATURAMENTO_ARRECADACAO QFA "
							+ "SET QDFA_VLCONTAINCLUIDA = QDFA_VLCONTAINCLUIDA + NVL("
							+ "(SELECT SUM(DECODE(LCS.EVCO_ID,4,LCA.LACA_VL  * -1, LCA.LACA_VL)) "
							+ "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, "
							+ "LANCAMENTO_CONTABIL_ANALITICO LCA, "
							+ "CONTA CO "
							+ "WHERE LCS.LACS_ID = LCA.LACS_ID "
							+ "AND LCS.EVCO_ID  IN (1,2,3,4,5) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes "
							+ "AND LCA.LACA_IDOBJETO = CO.CNTA_ID " + "AND QFA.LOCA_ID = LCS.UNCO_ID " + "AND QFA.CATG_ID = LCS.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CO.CNTA_AMREFERENCIACONTA "
							+ "GROUP BY LCS.UNCO_ID, " + "CO.CNTA_AMREFERENCIACONTA, " + "LCS.CATG_ID),0) " + "WHERE LOCA_ID IN "
							+ "(SELECT DISTINCT LCS.UNCO_ID " + "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, "
							+ "LANCAMENTO_CONTABIL_ANALITICO LCA, " + "CONTA CO " + "WHERE LCS.LACS_ID = LCA.LACS_ID "
							+ "AND LCS.EVCO_ID  IN (1,2,3,4,5) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes "
							+ "AND LCA.LACA_IDOBJETO = CO.CNTA_ID " + "AND QFA.LOCA_ID = LCS.UNCO_ID " + "AND QFA.CATG_ID = LCS.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CO.CNTA_AMREFERENCIACONTA)";

			session.createSQLQuery(query2).setString("dateInicioMes", dateInicioMes).setString("dateFimMes", dateFimMes).executeUpdate();

			String query3 = "UPDATE QUADRO_FATURAMENTO_ARRECADACAO QFA " + "SET QDFA_VLCONTAINCLUIDA = QDFA_VLCONTAINCLUIDA + NVL("
							+ "(SELECT SUM(DECODE(LCS.EVCO_ID,4,LCA.LACA_VL  * -1, LCA.LACA_VL)) "
							+ "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, " + "LANCAMENTO_CONTABIL_ANALITICO LCA, " + "CONTA_HISTORICO CO "
							+ "WHERE LCS.LACS_ID = LCA.LACS_ID " + "AND LCS.EVCO_ID  IN (1,2,3,4,5) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes "
							+ "AND LCA.LACA_IDOBJETO     = CO.CNTA_ID "
							+ "AND QFA.LOCA_ID = LCS.UNCO_ID " + "AND QFA.CATG_ID = LCS.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CO.CNHI_AMREFERENCIACONTA " + "GROUP BY LCS.UNCO_ID, "
							+ "CO.CNHI_AMREFERENCIACONTA, " + "LCS.CATG_ID),0) " + "WHERE LOCA_ID IN " + "(SELECT DISTINCT LCS.UNCO_ID "
							+ "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, " + "LANCAMENTO_CONTABIL_ANALITICO LCA, " + "CONTA_HISTORICO CO "
							+ "WHERE LCS.LACS_ID = LCA.LACS_ID "
							+ "AND LCS.EVCO_ID  IN (1,2,3,4,5) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes "
							+ "AND LCA.LACA_IDOBJETO = CO.CNTA_ID " + "AND QFA.LOCA_ID = LCS.UNCO_ID " + "AND QFA.CATG_ID = LCS.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CO.CNHI_AMREFERENCIACONTA)";

			session.createSQLQuery(query3).setString("dateInicioMes", dateInicioMes).setString("dateFimMes", dateFimMes).executeUpdate();

			String query4 = "UPDATE QUADRO_FATURAMENTO_ARRECADACAO QFA "
							+ "SET QDFA_VLCONTACANCELADA = QDFA_VLCONTACANCELADA + NVL("
							+ "(SELECT SUM(DECODE(LCS.EVCO_ID,10,LCA.LACA_VL   * -1, LCA.LACA_VL)) "
							+ "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, " + "LANCAMENTO_CONTABIL_ANALITICO LCA, " + "CONTA_HISTORICO CO "
							+ "WHERE LCS.LACS_ID = LCA.LACS_ID " + "AND LCS.EVCO_ID  IN (7,8,9,10,11) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes " + "AND LCA.LACA_IDOBJETO = CO.CNTA_ID "
							+ "AND QFA.LOCA_ID = LCS.UNCO_ID " + "AND QFA.CATG_ID = LCS.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CO.CNHI_AMREFERENCIACONTA " + "GROUP BY LCS.UNCO_ID, "
							+ "CO.CNHI_AMREFERENCIACONTA, " + "LCS.CATG_ID),0) " + "WHERE LOCA_ID IN " + "(SELECT DISTINCT LCS.UNCO_ID "
							+ "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, " + "LANCAMENTO_CONTABIL_ANALITICO LCA, " + "CONTA_HISTORICO CO "
							+ "WHERE LCS.LACS_ID = LCA.LACS_ID "
							+ "AND LCS.EVCO_ID  IN (7,8,9,10,11) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes "
							+ "AND LCA.LACA_IDOBJETO = CO.CNTA_ID " + "AND QFA.LOCA_ID = LCS.UNCO_ID " + "AND QFA.CATG_ID = LCS.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CO.CNHI_AMREFERENCIACONTA)";

			session.createSQLQuery(query4).setString("dateInicioMes", dateInicioMes).setString("dateFimMes", dateFimMes).executeUpdate();

			String query5 = "UPDATE QUADRO_FATURAMENTO_ARRECADACAO QFA "
							+ "SET QDFA_VLCONTACANCPARC = QDFA_VLCONTACANCPARC + NVL("
							+ "(SELECT SUM(NVL(CCH.CTCH_VLAGUA,0) + NVL(CCH.CTCH_VLESGOTO,0)) "
							+ "FROM CONTA_HISTORICO CH, "
							+ "CONTA_CATEGORIA_HISTORICO CCH "
							+ "WHERE CH.CNTA_ID = CCH.CNTA_ID "
							+ "AND CH.DCST_IDATUAL = 5 "
							+ "AND CH.CNHI_AMREFERENCIACONTABIL BETWEEN :anoMesInicio AND :anoMesFim "
							+ "AND QFA.LOCA_ID = CH.LOCA_ID " + "AND QFA.CATG_ID = CCH.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CH.CNHI_AMREFERENCIACONTA " + "GROUP BY CH.LOCA_ID, "
							+ "CH.CNHI_AMREFERENCIACONTA, " + "CCH.CATG_ID),0) " + "WHERE LOCA_ID IN " + "(SELECT DISTINCT CH.LOCA_ID "
							+ "FROM CONTA_HISTORICO CH, " + "CONTA_CATEGORIA_HISTORICO CCH " + "WHERE CH.CNTA_ID    = CCH.CNTA_ID "
							+ "AND CH.DCST_IDATUAL = 5 "
							+ "AND CH.CNHI_AMREFERENCIACONTABIL BETWEEN :anoMesInicio AND :anoMesFim "
							+ "AND QFA.LOCA_ID = CH.LOCA_ID " + "AND QFA.CATG_ID = CCH.CATG_ID "
 + "AND QFA.QDFA_AMREFERENCIA = CH.CNHI_AMREFERENCIACONTA)";

			session.createSQLQuery(query5).setInteger("anoMesInicio", anoMesInicio).setInteger("anoMesFim", anoMesFim).executeUpdate();

			String query6 = "UPDATE QUADRO_FATURAMENTO_ARRECADACAO QFA "
							+ "SET QDFA_VLCONTACANCPARC = QDFA_VLCONTACANCPARC + NVL("
							+ "(SELECT SUM(NVL(DCC.DCCH_VLCATEGORIA,0)) "
							+ "FROM CONTA_HISTORICO CH, "
							+ "DEBITO_COBRADO_HISTORICO DC, "
							+ "DEBITO_COBRADO_CATEGORIA_HIST DCC "
							+ "WHERE CH.DCST_IDATUAL = 5 "
							+ "AND CH.CNHI_AMREFERENCIACONTABIL BETWEEN :anoMesInicio AND :anoMesFim "
							+ "AND CH.CNTA_ID = DC.CNTA_ID " + "AND DC.DBHI_ID = DCC.DBHI_ID " + "AND QFA.LOCA_ID = CH.LOCA_ID "
							+ "AND QFA.CATG_ID = DCC.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CH.CNHI_AMREFERENCIACONTA " + "GROUP BY CH.LOCA_ID, "
							+ "CH.CNHI_AMREFERENCIACONTA, " + "DCC.CATG_ID),0) " + "WHERE LOCA_ID IN " + "(SELECT DISTINCT CH.LOCA_ID "
							+ "FROM CONTA_HISTORICO CH, " + "DEBITO_COBRADO_HISTORICO DC, "
							+ "DEBITO_COBRADO_CATEGORIA_HIST DCC "
							+ "WHERE CH.DCST_IDATUAL = 5 "
 + "AND CH.CNHI_AMREFERENCIACONTABIL BETWEEN :anoMesInicio AND :anoMesFim "
							+ "AND CH.CNHI_VLDEBITOS > 0 " + "AND CH.CNTA_ID = DC.CNTA_ID " + "AND DC.DBHI_ID = DCC.DBHI_ID "
							+ "AND QFA.LOCA_ID = CH.LOCA_ID " + "AND QFA.CATG_ID = DCC.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CH.CNHI_AMREFERENCIACONTA)";

			session.createSQLQuery(query6).setInteger("anoMesInicio", anoMesInicio).setInteger("anoMesFim", anoMesFim).executeUpdate();

			String query7 = "UPDATE QUADRO_FATURAMENTO_ARRECADACAO QFA " + "SET QDFA_VLCONTAPAGA = QDFA_VLCONTAPAGA + NVL("
							+ "(SELECT SUM(LCA.LACA_VL) " + "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, "
							+ "LANCAMENTO_CONTABIL_ANALITICO LCA, " + "CONTA_HISTORICO CO " + "WHERE LCS.LACS_ID = LCA.LACS_ID "
							+ "AND LCS.EVCO_ID  IN (23,24,25,26,27,31,32,33,34,35) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes " + "AND LCA.LACA_IDOBJETO = CO.CNTA_ID "
							+ "AND QFA.LOCA_ID = LCS.UNCO_ID " + "AND QFA.CATG_ID = LCS.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CO.CNHI_AMREFERENCIACONTA " + "GROUP BY LCS.UNCO_ID, "
							+ "CO.CNHI_AMREFERENCIACONTA, LCS.CATG_ID),0) " + "WHERE LOCA_ID IN " + "(SELECT DISTINCT LCS.UNCO_ID "
							+ "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, " + "LANCAMENTO_CONTABIL_ANALITICO LCA, " + "CONTA_HISTORICO CO "
							+ "WHERE LCS.LACS_ID = LCA.LACS_ID "
							+ "AND LCS.EVCO_ID IN (23,24,25,26,27,31,32,33,34,35) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes "
							+ "AND LCA.LACA_IDOBJETO = CO.CNTA_ID " + "AND QFA.LOCA_ID = LCS.UNCO_ID " + "AND QFA.CATG_ID = LCS.CATG_ID "
							+ "AND QFA.QDFA_AMREFERENCIA = CO.CNHI_AMREFERENCIACONTA)";

			session.createSQLQuery(query7).setString("dateInicioMes", dateInicioMes).setString("dateFimMes", dateFimMes).executeUpdate();

			String query8 = "UPDATE QUADRO_FATURAMENTO_ARRECADACAO QFA "
							+ "SET QDFA_VLCONTAPAGAEMDIA = QDFA_VLCONTAPAGAEMDIA + NVL("
							+ "(SELECT SUM(LCA.LACA_VL) "
							+ "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, "
							+ "LANCAMENTO_CONTABIL_ANALITICO LCA, "
							+ "CONTA_HISTORICO CO, "
							+ "PAGAMENTO_HISTORICO PH "
							+ "WHERE LCS.LACS_ID = LCA.LACS_ID "
							+ "AND LCS.EVCO_ID  IN (23,24,25,26,27,31,32,33,34,35) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes "
							+ "AND LCA.LACA_IDOBJETO = CO.CNTA_ID " + "AND PH.CNTA_ID IS NOT NULL " + "AND CO.CNTA_ID = PH.CNTA_ID "
							+ "AND CO.CNHI_DTVENCIMENTOCONTA <= PH.PGHI_DTPAGAMENTO " + "AND QFA.LOCA_ID = LCS.UNCO_ID "
							+ "AND QFA.CATG_ID = LCS.CATG_ID " + "AND QFA.QDFA_AMREFERENCIA = CO.CNHI_AMREFERENCIACONTA "
							+ "GROUP BY LCS.UNCO_ID, " + "CO.CNHI_AMREFERENCIACONTA, " + "LCS.CATG_ID),0) " + "WHERE LOCA_ID IN "
							+ "(SELECT DISTINCT LCS.UNCO_ID " + "FROM LANCAMENTO_CONTABIL_SINTETICO LCS, "
							+ "LANCAMENTO_CONTABIL_ANALITICO LCA, " + "CONTA_HISTORICO CO, "
							+ "PAGAMENTO_HISTORICO PH "
							+ "WHERE LCS.LACS_ID = LCA.LACS_ID "
							+ "AND LCS.EVCO_ID  IN (23,24,25,26,27,31,32,33,34,35) "
							+ "AND LCS.LACS_DTCONTABIL BETWEEN :dateInicioMes AND :dateFimMes "
							+ "AND LCA.LACA_IDOBJETO = CO.CNTA_ID " + "AND PH.CNTA_ID IS NOT NULL " + "AND CO.CNTA_ID = PH.CNTA_ID "
							+ "AND CO.CNHI_DTVENCIMENTOCONTA <= PH.PGHI_DTPAGAMENTO " + "AND QFA.LOCA_ID = LCS.UNCO_ID "
							+ "AND QFA.CATG_ID = LCS.CATG_ID " + "AND QFA.QDFA_AMREFERENCIA = CO.CNHI_AMREFERENCIACONTA)";

			session.createSQLQuery(query8).setString("dateInicioMes", dateInicioMes).setString("dateFimMes", dateFimMes).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}catch(SQLException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Retorna dados da cobrança administrativa
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @throws ErroRepositorioException
	 * @author Felipe Rosacruz
	 * @date 28/12/2013
	 */
	public Collection<Object[]> gerarDadosRemuneracaoCobrancaAdministrativaModelo1() throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select c.empr_id idEmpresa ,b.cacm_id idLote,sum(icai_vlarrecadadolote) somaValorArrecadadoLote,sum(icai_vlbaseremuneracao) somaValorRemuneracao");
			consulta.append(" from IMOVEL_COBRANCA_ADMINISTR_ITEM a ");
			consulta.append(" join IMOVEL_COBRANCA_SITUACAO b on b.iscb_id=a.iscb_id ");
			consulta.append(" join COBRANCA_ACAO_ATIVIDADE_COMAND c on c.cacm_id=b.cacm_id ");
			consulta.append(" where icai_amreferenciaarrecadacao=(SELECT parm_amreferenciaarrecadacao FROM sistema_parametros) ");
			consulta.append(" group by c.empr_id,b.cacm_id ");
			consulta.append(" order by c.empr_id,b.cacm_id ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("idEmpresa", Hibernate.INTEGER);
			query.addScalar("idLote", Hibernate.INTEGER);
			query.addScalar("somaValorArrecadadoLote", Hibernate.DOUBLE);
			query.addScalar("somaValorRemuneracao", Hibernate.DOUBLE);

			retorno = query.list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @throws ErroRepositorioException
	 * @author Felipe Rosacruz
	 * @date 28/12/2013
	 */
	public double retornaPercentualRemuneracaoPorEmpresa(Integer idEmpresa, double percentualDesempenho) throws ErroRepositorioException{

		Double retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select ccrs_pcremuneracao percentualRemuneracao");
			consulta.append(" from COBRANCA_CONTRATO_REMUN_SUCESS a ");
			consulta.append(" join COBRANCA_CONTRATO b on b.cbco_id=a.cbco_id ");
			consulta.append(" and ");
			consulta.append(" ( ");
			consulta.append(" (current_date>=cbco_dtcontratoinicio ");
			consulta.append(" and current_date<=cbco_dtcontratofim ");
			consulta.append(" and empr_id= :idEmpresa ");
			consulta.append(" and cbco_dtcontratofim is not null) ");
			consulta.append(" or ");
			consulta.append(" (current_date>=cbco_dtcontratoinicio ");
			consulta.append(" and empr_id= :idEmpresa ");
			consulta.append(" and cbco_dtcontratofim is null) ");
			consulta.append(" ) ");
			consulta.append(" where ");
			consulta.append(" ccrs_pcdesempenho < :percentualDesempenho ");
			consulta.append(" order by ccrs_pcdesempenho desc ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("percentualRemuneracao", Hibernate.BIG_DECIMAL);

			query.setInteger("idEmpresa", idEmpresa);
			query.setDouble("percentualDesempenho", percentualDesempenho);

			retorno = ((Number) query.setMaxResults(1).uniqueResult()).doubleValue();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}




	/**
	 * Rotina de ajuste - CAERD
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection<Integer> obterContasParaCancelamento(Integer idClienteResponsavel,
					Collection<IntervaloReferenciaHelper> colecaoReferencias) throws ErroRepositorioException{

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select a.cnta_id as idConta ");
			consulta.append(" from conta a ");
			consulta.append(" inner join cliente_conta b on b.cnta_id=a.cnta_id ");
			consulta.append("   and b.clie_id=:idClienteResponsavel ");
			consulta.append("   and b.crtp_id=:idClienteRelacaoTipo ");
			consulta.append(" where ");
			consulta.append(this.montarConsultaReferencias(colecaoReferencias));

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("idConta", Hibernate.INTEGER);
			query.setDouble("idClienteResponsavel", idClienteResponsavel);
			query.setDouble("idClienteRelacaoTipo", ClienteRelacaoTipo.RESPONSAVEL);

			retorno = (Collection<Integer>) query.list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterValorTotalContasParaCancelamento(Integer idClienteRelacaoTipo, Integer idClienteResponsavel,
					Collection<IntervaloReferenciaHelper> colecaoReferencias) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();


		try{

			consulta.append(" select sum(cnta_vlagua+cnta_vlesgoto+cnta_vldebitos) as valorTotalContas ");
			consulta.append(" from conta a ");
			consulta.append(" inner join cliente_conta b on b.cnta_id=a.cnta_id ");
			consulta.append("  and b.clie_id=:idClienteResponsavel ");
			consulta.append("  and b.crtp_id=:idClienteRelacaoTipo ");
			consulta.append(" where ");
			consulta.append(this.montarConsultaReferencias(colecaoReferencias));

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.addScalar("valorTotalContas", Hibernate.BIG_DECIMAL);
			query.setDouble("idClienteResponsavel", idClienteResponsavel);
			query.setDouble("idClienteRelacaoTipo", idClienteRelacaoTipo);

			retorno = (BigDecimal) query.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

}
