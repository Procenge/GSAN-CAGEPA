/*
 * Copyright (C) 2007-2007 the GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 *
 * This file is part of GSAN, an integrated service management system for Sanitation
 *
 * GSAN is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * GSAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place – Suite 330, Boston, MA 02111-1307, USA
 */

/*
 * GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 * Copyright (C) <2007> 
 * Adriano Britto Siqueira
 * Alexandre Santos Cabral
 * Ana Carolina Alves Breda
 * Ana Maria Andrade Cavalcante
 * Aryed Lins de Araújo
 * Bruno Leonardo Rodrigues Barros
 * Carlos Elmano Rodrigues Ferreira
 * Cláudio de Andrade Lira
 * Denys Guimarães Guenes Tavares
 * Eduardo Breckenfeld da Rosa Borges
 * Fabíola Gomes de Araújo
 * Flávio Leonardo Cavalcanti Cordeiro
 * Francisco do Nascimento Júnior
 * Homero Sampaio Cavalcanti
 * Ivan Sérgio da Silva Júnior
 * José Edmar de Siqueira
 * José Thiago Tenório Lopes
 * Kássia Regina Silvestre de Albuquerque
 * Leonardo Luiz Vieira da Silva
 * Márcio Roberto Batista da Silva
 * Maria de Fátima Sampaio Leite
 * Micaela Maria Coelho de Araújo
 * Nelson Mendonça de Carvalho
 * Newton Morais e Silva
 * Pedro Alexandre Santos da Silva Filho
 * Rafael Corrêa Lima e Silva
 * Rafael Francisco Pinto
 * Rafael Koury Monteiro
 * Rafael Palermo de Araújo
 * Raphael Veras Rossiter
 * Roberto Sobreira Barbalho
 * Rodrigo Avellar Silveira
 * Rosana Carvalho Barbosa
 * Sávio Luiz de Andrade Cavalcante
 * Tai Mu Shih
 * Thiago Augusto Souza do Nascimento
 * Tiago Moreno Rodrigues
 * Vivianne Barbosa Sousa
 *
 * Este programa é software livre; você pode redistribuí-lo e/ou
 * modificá-lo sob os termos de Licença Pública Geral GNU, conforme
 * publicada pela Free Software Foundation; versão 2 da
 * Licença.
 * Este programa é distribuído na expectativa de ser útil, mas SEM
 * QUALQUER GARANTIA; sem mesmo a garantia implícita de
 * COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM
 * PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais
 * detalhes.
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU
 * junto com este programa; se não, escreva para Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307, USA.
 * 
 * GSANPCG
 * Eduardo Henrique
 * Saulo Vasconcelos de Lima
 * Virginia Santos de Melo
 */

package gcom.arrecadacao;

import gcom.FiltroArrecadadorAgenteCaixa;
import gcom.arrecadacao.aviso.AvisoAcerto;
import gcom.arrecadacao.aviso.AvisoBancario;
import gcom.arrecadacao.aviso.AvisoDeducoes;
import gcom.arrecadacao.aviso.AvisoDeducoesPK;
import gcom.arrecadacao.aviso.bean.*;
import gcom.arrecadacao.banco.*;
import gcom.arrecadacao.banco.FiltroContaBancaria;
import gcom.arrecadacao.bean.*;
import gcom.arrecadacao.debitoautomatico.*;
import gcom.arrecadacao.pagamento.*;
import gcom.arrecadacao.pagamento.bean.ClassificarLotePagamentosNaoClassificadosHelper;
import gcom.arrecadacao.pagamento.bean.ClassificarPagamentosNaoClassificadosHelper;
import gcom.atendimentopublico.ligacaoagua.CorteTipo;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoagua.SupressaoTipo;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.atendimentopublico.ordemservico.FiltroOrdemServico;
import gcom.atendimentopublico.ordemservico.FiltroServicoTipo;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.atendimentopublico.ordemservico.ServicoTipo;
import gcom.atendimentopublico.registroatendimento.*;
import gcom.batch.*;
import gcom.cadastro.ControladorCadastroLocal;
import gcom.cadastro.ControladorCadastroLocalHome;
import gcom.cadastro.EnvioEmail;
import gcom.cadastro.aguaparatodos.FiltroImovelAguaParaTodos;
import gcom.cadastro.aguaparatodos.ImovelAguaParaTodos;
import gcom.cadastro.cliente.*;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.empresa.FiltroEmpresa;
import gcom.cadastro.endereco.*;
import gcom.cadastro.geografico.Municipio;
import gcom.cadastro.imovel.*;
import gcom.cadastro.imovel.bean.ImovelMicromedicao;
import gcom.cadastro.localidade.*;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cobranca.*;
import gcom.cobranca.bean.CalcularAcrescimoPorImpontualidadeHelper;
import gcom.cobranca.bean.ContaValoresHelper;
import gcom.cobranca.bean.GuiaPagamentoValoresHelper;
import gcom.cobranca.bean.ObterDebitoImovelOuClienteHelper;
import gcom.cobranca.contrato.CobrancaContrato;
import gcom.cobranca.contrato.FiltroCobrancaContrato;
import gcom.cobranca.contrato.FiltroCobrancaContratoRemuneracao;
import gcom.cobranca.opcaoparcelamento.PreParcelamento;
import gcom.cobranca.opcaoparcelamento.PreParcelamentoOpcao;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.contabil.ControladorContabilLocal;
import gcom.contabil.ControladorContabilLocalHome;
import gcom.contabil.OperacaoContabil;
import gcom.contabil.ProvisaoDevedoresDuvidososMotivoBaixa;
import gcom.fachada.Fachada;
import gcom.faturamento.*;
import gcom.faturamento.bean.CalcularValoresAguaEsgotoHelper;
import gcom.faturamento.consumotarifa.ConsumoTarifa;
import gcom.faturamento.conta.*;
import gcom.faturamento.credito.*;
import gcom.faturamento.debito.*;
import gcom.faturamento.debito.DebitoTipo.DebitoTipoEnum;
import gcom.financeiro.FinanciamentoTipo;
import gcom.financeiro.lancamento.LancamentoItemContabil;
import gcom.financeiro.lancamento.bean.LancamentoItemContabilParcelamentoHelper;
import gcom.gui.ActionServletException;
import gcom.gui.arrecadacao.pagamento.RelatorioClassificarLotePagamentosNaoClassificados;
import gcom.gui.faturamento.bean.GuiaPagamentoPrestacaoHelper;
import gcom.interceptor.RegistradorOperacao;
import gcom.micromedicao.*;
import gcom.micromedicao.medicao.MedicaoHistorico;
import gcom.relatorio.GerenciadorExecucaoTarefaRelatorio;
import gcom.relatorio.RelatorioAcompanhamentoMovimentoArrecadadores;
import gcom.relatorio.arrecadacao.*;
import gcom.relatorio.arrecadacao.pagamento.GuiaPagamentoRelatorioHelper;
import gcom.relatorio.cobranca.parcelamento.ExtratoDebitoRelatorioHelper;
import gcom.seguranca.ControladorPermissaoEspecialLocal;
import gcom.seguranca.ControladorPermissaoEspecialLocalHome;
import gcom.seguranca.acesso.*;
import gcom.seguranca.acesso.usuario.FiltroUsuario;
import gcom.seguranca.acesso.usuario.Usuario;
import gcom.seguranca.acesso.usuario.UsuarioAcao;
import gcom.seguranca.acesso.usuario.UsuarioAcaoUsuarioHelper;
import gcom.seguranca.transacao.ControladorTransacaoLocal;
import gcom.seguranca.transacao.ControladorTransacaoLocalHome;
import gcom.spcserasa.ControladorSpcSerasaLocal;
import gcom.spcserasa.ControladorSpcSerasaLocalHome;
import gcom.tarefa.TarefaRelatorio;
import gcom.util.*;
import gcom.util.email.ErroEmailException;
import gcom.util.email.ServicosEmail;
import gcom.util.filtro.*;
import gcom.util.parametrizacao.ExecutorParametro;
import gcom.util.parametrizacao.Parametrizacao;
import gcom.util.parametrizacao.ParametroContabil;
import gcom.util.parametrizacao.ParametroGeral;
import gcom.util.parametrizacao.arrecadacao.ExecutorParametrosArrecadacao;
import gcom.util.parametrizacao.arrecadacao.ParametroArrecadacao;
import gcom.util.parametrizacao.cadastro.ParametroCadastro;
import gcom.util.parametrizacao.cobranca.ParametroCobranca;
import gcom.util.parametrizacao.cobranca.parcelamento.ParametroParcelamento;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.util.*;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;
import javax.mail.SendFailedException;

import org.apache.commons.beanutils.BeanComparator;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.collections.comparators.ComparatorChain;
import org.apache.log4j.Logger;

import br.com.procenge.parametrosistema.api.ControladorParametroSistema;
import br.com.procenge.util.SpringBeanLocator;


/**
 * Controlador Arrecadacao PADRÃO
 * 
 * @author Raphael Rossiter
 * @date 30/04/2007
 */
public class ControladorArrecadacao
				implements SessionBean, Parametrizacao, IControladorArrecadacao {

	private static final long serialVersionUID = 1L;

	protected IRepositorioCliente repositorioCliente = null;

	protected IRepositorioImovel repositorioImovel = null;

	protected IRepositorioLocalidade repositorioLocalidade = null;

	protected IRepositorioFaturamento repositorioFaturamento = null;

	protected IRepositorioUtil repositorioUtil = null;

	protected IRepositorioArrecadacao repositorioArrecadacao = null;

	protected IRepositorioCobranca repositorioCobranca = null;

	protected static boolean registroLegadoADA = false;

	private static Logger log = Logger.getLogger(ControladorArrecadacao.class);

	SessionContext sessionContext;

	/**
	 * < <Descrição do método>>
	 * 
	 * @exception CreateException
	 *                Descrição da exceção
	 */
	public void ejbCreate() throws CreateException{

		repositorioCliente = RepositorioClienteHBM.getInstancia();
		repositorioLocalidade = RepositorioLocalidadeHBM.getInstancia();
		repositorioImovel = RepositorioImovelHBM.getInstancia();
		repositorioUtil = RepositorioUtilHBM.getInstancia();
		repositorioFaturamento = RepositorioFaturamentoHBM.getInstancia();
		repositorioArrecadacao = RepositorioArrecadacaoHBM.getInstancia();
		repositorioCobranca = RepositorioCobrancaHBM.getInstancia();

	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbRemove(){

	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbActivate(){

	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbPassivate(){

	}

	/**
	 * Seta o valor de sessionContext
	 * 
	 * @param sessionContext
	 *            O novo valor de sessionContext
	 */
	public void setSessionContext(SessionContext sessionContext){

		this.sessionContext = sessionContext;
	}

	/**
	 * Retorna o valor de controladorAcesso
	 * 
	 * @return O valor de controladorAcesso
	 */
	protected ControladorAcessoLocal getControladorAcesso(){

		ControladorAcessoLocalHome localHome = null;
		ControladorAcessoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorAcessoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_ACESSO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o controladorCadastro
	 * 
	 * @author Thiago Tenório
	 * @date 18/08/2006
	 */
	protected ControladorCadastroLocal getControladorCadastro(){

		ControladorCadastroLocalHome localHome = null;
		ControladorCadastroLocal local = null;

		ServiceLocator locator = null;
		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorCadastroLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_CADASTRO_SEJB);

			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna a interface remota de ControladorParametro
	 * 
	 * @return A interface remota do controlador de parâmetro
	 */
	protected ControladorLocalidadeLocal getControladorLocalidade(){

		ControladorLocalidadeLocalHome localHome = null;
		ControladorLocalidadeLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorLocalidadeLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_LOCALIDADE_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Author: Sávio Luiz Data: 04/01/2006
	 * Retorna o valor do Controlador de Cobranca
	 * 
	 * @return O valor de controladorCobrancaLocal
	 */
	private ControladorCobrancaLocal controladorCobranca;

	protected ControladorCobrancaLocal getControladorCobranca(){

		if(controladorCobranca == null){
			ControladorCobrancaLocalHome localHome = null;

			// pega a instância do ServiceLocator.

			ServiceLocator locator = null;

			try{
				locator = ServiceLocator.getInstancia();

				localHome = (ControladorCobrancaLocalHome) locator.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_COBRANCA_SEJB);
				// guarda a referencia de um objeto capaz de fazer chamadas à
				// objetos remotamente
				controladorCobranca = localHome.create();

				return controladorCobranca;
			}catch(CreateException e){
				throw new SistemaException(e);
			}catch(ServiceLocatorException e){
				throw new SistemaException(e);
			}
		}else{
			return controladorCobranca;
		}

	}

	/**
	 * Author: Vivianne Sousa Data: 1804/03/2006
	 * Retorna o valor do Controlador Util
	 * 
	 * @return O valor de controladorUtil
	 */
	protected ControladorUtilLocal getControladorUtil(){

		ControladorUtilLocalHome localHome = null;
		ControladorUtilLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorUtilLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_UTIL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Cria uma instância do controlador de imóvel
	 * 
	 * @author Pedro Alexandre
	 * @date 19/04/2006
	 * @return
	 */
	protected ControladorImovelLocal getControladorImovel(){

		ControladorImovelLocalHome localHome = null;
		ControladorImovelLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorImovelLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_IMOVEL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorLocalidade
	 * 
	 * @return O valor de controladorLocalidade
	 */
	protected ControladorFaturamentoLocal getControladorFaturamento(){

		ControladorFaturamentoLocalHome localHome = null;
		ControladorFaturamentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorFaturamentoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_FATURAMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}


	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0003] – Distribuir Pagamento de Documento de Cobrança
	 * DOCUMENTO COBRANÇA TIPO 05
	 * 
	 * @author Virgínia Melo
	 * @date 20/04/2009
	 *       Ajuste de posições ao recuperar dados do 'pesquisarCobrancaDocumentoItem'.
	 * @author Saulo Lima
	 * @date 02/12/2009
	 *       Alteração para colocar o Indicador de Aceitação 2 caso não seja localizado o Documento
	 *       de Cobrança
	 * @author Raphael Rossiter
	 * @date 02/05/2007
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasDocumentoCobrancaTipo5(
					RegistroHelperCodigoBarras registroHelperCodigoBarras, SistemaParametro sistemaParametro, Date dataPagamento,
					Integer anoMesPagamento, BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();

		Collection colecaoDevolucoes = new ArrayList();

		boolean matriculaImovelInvalida = false;

		Integer idImovelNaBase = null;
		Integer matriculaImovel = null;

		// valida a matricula do imóvel
		matriculaImovelInvalida = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		if(matriculaImovelInvalida){
			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";
		}else{

			// verifica se existe a matricula do imóvel na base
			matriculaImovel = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
			idImovelNaBase = null;
			try{
				idImovelNaBase = repositorioImovel.recuperarMatriculaImovel(Integer.valueOf(matriculaImovel));
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			if(idImovelNaBase == null){
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}

		// valida o numero sequencial do documento
		boolean numeroSequencialDocumentoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

		if(numeroSequencialDocumentoInvalido){
			descricaoOcorrencia = "SEQUENCIAL DO DOCUMENTO NÃO NUMÉRICO";
		}
		if(descricaoOcorrencia.equals("OK")){
			// inicializa o id da localidade
			Integer idLocalidadeImovel = null;

			// inicializa a coleção de cobranca documento item
			Collection cobrancaDocumentoItens = null;

			// inicializa a coleção de cobranca documento item
			Object[] parmsDocumentoCobranca = null;

			int numeroSequencialDocumento = Integer.parseInt(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento3());

			try{

				idLocalidadeImovel = repositorioLocalidade.pesquisarIdLocalidade(idImovelNaBase);
				cobrancaDocumentoItens = repositorioCobranca.pesquisarCobrancaDocumentoItem(idImovelNaBase, numeroSequencialDocumento);
				parmsDocumentoCobranca = repositorioCobranca.pesquisarParmsCobrancaDocumento(idImovelNaBase, numeroSequencialDocumento);

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			// caso exista documento de cobrança
			if(parmsDocumentoCobranca != null){
				Integer idCobrancaDocumento = null;
				BigDecimal valorAcrescimo = BigDecimal.ZERO;
				BigDecimal valorAcrescimoOriginalDocCob = BigDecimal.ZERO;
				BigDecimal valorDesconto = BigDecimal.ZERO;
				BigDecimal valorTaxa = BigDecimal.ZERO;

				Integer anoMesReferenciaArrecadacao = null;

				// caso o ano mes da data de dedito seja maior que o ano mes de arrecadação da
				// tabela sistema parametro então seta o ano mes da data de debito
				if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
					anoMesReferenciaArrecadacao = anoMesPagamento;
				}else{
					// caso contrario seta o o ano mes arrecadação da tabela sistema parametro
					anoMesReferenciaArrecadacao = sistemaParametro.getAnoMesArrecadacao();
				}

				Date dataEmissao = null;

				if(parmsDocumentoCobranca[2] != null){
					dataEmissao = ((Date) parmsDocumentoCobranca[2]);
				}

				// Parâmetro que identifica se a empresa emite o documento com acrescimos
				String parametroTratarAcrescimosEmissaoDocumento = ParametroArrecadacao.P_TRATAR_ACRESCIMOS_EMISSAO_DOCUMENTO.executar()
								.toString();

				// Parâmetro que identifica se a empresa emite o documento com acrescimos
				String parametroPermitirSelecaoAcrescimosExtrato = ParametroArrecadacao.P_PERMITIR_SELECAO_ACRESCIMOS_EXTRATO.executar()
								.toString();

				ResolucaoDiretoriaParametrosPagamentoAVista resolucaoDiretoriaParametrosPagamentoAVista = null;

				Integer idResolucaoDiretoria = null;

				if(parmsDocumentoCobranca[6] != null){
					idResolucaoDiretoria = ((Integer) parmsDocumentoCobranca[6]);

					resolucaoDiretoriaParametrosPagamentoAVista = this.getControladorCobranca()
									.pesquisarResolucaoDiretoriaParametrosPagamentoAVista(idResolucaoDiretoria, dataPagamento);
				}

				if(resolucaoDiretoriaParametrosPagamentoAVista != null){
					Imovel imovel = this.getControladorImovel().pesquisarImovel(idImovelNaBase);

					// [SB0023 – Tratar Desconto Extrato Parcelamento]

					BigDecimal percentualDescontoMulta = resolucaoDiretoriaParametrosPagamentoAVista.getPercentualDescontoMulta();
					BigDecimal percentualDescontoJurosMora = resolucaoDiretoriaParametrosPagamentoAVista.getPercentualDescontoJurosMora();
					BigDecimal percentualDescontoCorrecaoMonetaria = resolucaoDiretoriaParametrosPagamentoAVista
									.getPercentualDescontoCorrecaoMonetaria();

					BigDecimal cem = new BigDecimal("100").setScale(2);

					BigDecimal saldoValorPago = valorPagamento;

					Collection<Conta> contas = this.getControladorCobranca().pesquisarContasCobrancaDocumento(numeroSequencialDocumento);

					if(!Util.isVazioOrNulo(contas)){
						Conta conta = null;

						BigDecimal valorTotalContaSemImposto = BigDecimal.ZERO;

						Integer referencia = null;
						Date dataVencimentoConta = null;
						Short indicadorCobrancaMulta = null;
						Integer idConta = null;

						FiltroDebitoCobrado filtroDebitoCobrado = null;
						Collection<DebitoCobrado> debitosCobrados = null;
						BigDecimal valorDebitosConta = BigDecimal.ZERO;

						CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidadeHelper = null;

						BigDecimal valorMulta = BigDecimal.ZERO;
						BigDecimal valorJurosMora = BigDecimal.ZERO;
						BigDecimal valorAtualizacaoMonetaria = BigDecimal.ZERO;

						Integer idDebitoTipo = null;
						DebitoTipo debitoTipo = null;

						Collection<Integer> colecaoIdsContasAtualizarIndicadorMulta = new ArrayList<Integer>();
						Collection<Conta> colecaoContasAtualizarVencimento = new ArrayList<Conta>();

						Iterator contasIterator = contas.iterator();

						while(contasIterator.hasNext() && saldoValorPago.compareTo(BigDecimal.ZERO) > 0){
							conta = (Conta) contasIterator.next();


							resolucaoDiretoriaParametrosPagamentoAVista = this.getControladorCobranca()
											.obterResolucaoDiretoriaParametrosPagamentoAVista(conta.getAnoMesReferenciaConta(),
															conta.getDataVencimentoConta(), idResolucaoDiretoria, dataPagamento);

							if(resolucaoDiretoriaParametrosPagamentoAVista != null){
								percentualDescontoMulta = resolucaoDiretoriaParametrosPagamentoAVista.getPercentualDescontoMulta();
								percentualDescontoJurosMora = resolucaoDiretoriaParametrosPagamentoAVista.getPercentualDescontoJurosMora();
								percentualDescontoCorrecaoMonetaria = resolucaoDiretoriaParametrosPagamentoAVista
												.getPercentualDescontoCorrecaoMonetaria();

							}else{
								continue;
							}


							valorTotalContaSemImposto = conta.getValorTotalContaSemImposto();

							if(saldoValorPago.compareTo(valorTotalContaSemImposto) < 0){
								break;
							}

							saldoValorPago = saldoValorPago.subtract(valorTotalContaSemImposto);

							dataVencimentoConta = conta.getDataVencimentoConta();

							if((percentualDescontoMulta != null && percentualDescontoMulta.compareTo(cem) != 0)
											|| (percentualDescontoJurosMora != null && percentualDescontoJurosMora.compareTo(cem) != 0)
											|| (percentualDescontoCorrecaoMonetaria != null && percentualDescontoCorrecaoMonetaria
															.compareTo(cem) != 0)){

								// [UC0216 – Calcular Acréscimos por Impontualidade]
								referencia = conta.getReferencia();
								indicadorCobrancaMulta = conta.getIndicadorCobrancaMulta();
								idConta = conta.getId();

								filtroDebitoCobrado = new FiltroDebitoCobrado();
								filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.CONTA_ID, idConta));
								filtroDebitoCobrado.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoCobrado.DEBITO_TIPO);

								debitosCobrados = this.getControladorUtil().pesquisar(filtroDebitoCobrado, DebitoCobrado.class.getName());

								valorDebitosConta = this.getControladorFaturamento().calcularValorTotalMultasCobradasConta(debitosCobrados);

								calcularAcrescimoPorImpontualidadeHelper = this.getControladorCobranca()
												.calcularAcrescimoPorImpontualidadeBancoDeDados(referencia, dataVencimentoConta,
																dataEmissao, valorTotalContaSemImposto, valorDebitosConta,
																indicadorCobrancaMulta, Integer.toString(anoMesReferenciaArrecadacao),
																idConta, null, null, ConstantesSistema.SIM, ConstantesSistema.SIM,
																ConstantesSistema.SIM);

								if(calcularAcrescimoPorImpontualidadeHelper != null){
									BigDecimal valorAuxiliar = BigDecimal.ZERO;

									valorMulta = calcularAcrescimoPorImpontualidadeHelper.getValorMulta();

									if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
										valorAuxiliar = cem.subtract(percentualDescontoMulta);
										valorAuxiliar = valorAuxiliar.divide(cem);

										valorMulta = valorMulta.multiply(valorAuxiliar);
									}

									valorJurosMora = calcularAcrescimoPorImpontualidadeHelper.getValorJurosMora();

									if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
										valorAuxiliar = cem.subtract(percentualDescontoJurosMora);
										valorAuxiliar = valorAuxiliar.divide(cem);

										valorJurosMora = valorJurosMora.multiply(valorAuxiliar);
									}

									valorAtualizacaoMonetaria = calcularAcrescimoPorImpontualidadeHelper.getValorAtualizacaoMonetaria();

									if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
										valorAuxiliar = cem.subtract(percentualDescontoCorrecaoMonetaria);
										valorAuxiliar = valorAuxiliar.divide(cem);

										valorAtualizacaoMonetaria = valorAtualizacaoMonetaria.multiply(valorAuxiliar);
									}

									if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
										idDebitoTipo = DebitoTipo.MULTA_IMPONTUALIDADE;

										debitoTipo = new DebitoTipo();
										debitoTipo.setId(idDebitoTipo);

										this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametro, debitoTipo,
														valorMulta, referencia);

										colecaoIdsContasAtualizarIndicadorMulta.add(idConta);
									}

									if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
										idDebitoTipo = DebitoTipo.JUROS_MORA;

										debitoTipo = new DebitoTipo();
										debitoTipo.setId(idDebitoTipo);

										this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametro, debitoTipo,
														valorJurosMora, referencia);
									}

									if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
										idDebitoTipo = DebitoTipo.ATUALIZACAO_MONETARIA;

										debitoTipo = new DebitoTipo();
										debitoTipo.setId(idDebitoTipo);

										this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametro, debitoTipo,
														valorAtualizacaoMonetaria, referencia);
									}

								}
							}

							if(Util.compararData(dataVencimentoConta, dataPagamento) == -1){
								colecaoContasAtualizarVencimento.add(conta);
							}
						}

						if(!Util.isVazioOrNulo(colecaoIdsContasAtualizarIndicadorMulta)){
							try{
								repositorioFaturamento.atualizarIndicadorMultaDeConta(colecaoIdsContasAtualizarIndicadorMulta);
							}catch(ErroRepositorioException e){
								throw new ControladorException(e.getMessage());
							}
						}

						// [UC0151] Alterar Vencimento de Conta
						if(!Util.isVazioOrNulo(colecaoContasAtualizarVencimento)){
							this.getControladorFaturamento().alterarVencimentoConta(colecaoContasAtualizarVencimento, null, dataPagamento,
											null);
						}
					}

					Collection<GuiaPagamentoPrestacao> guiasPagamentoPrestacao = this.getControladorCobranca()
									.pesquisarGuiasPagamentoPrestacaoCobrancaDocumento(numeroSequencialDocumento);

					if(!Util.isVazioOrNulo(guiasPagamentoPrestacao)){
						GuiaPagamentoPrestacao guiaPagamentoPrestacao = null;

						GuiaPagamentoPrestacaoPK guiaPagamentoPrestacaoPK = null;

						BigDecimal valorPrestacao = BigDecimal.ZERO;

						Integer anoMesReferenciaFaturamento = null;
						Date dataVencimento = null;
						Short indicadorCobrancaMulta = null;

						CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidadeHelper = null;

						BigDecimal valorMulta = BigDecimal.ZERO;
						BigDecimal valorJurosMora = BigDecimal.ZERO;
						BigDecimal valorAtualizacaoMonetaria = BigDecimal.ZERO;

						Integer idDebitoTipo = null;
						DebitoTipo debitoTipo = null;

						Collection<GuiaPagamentoPrestacaoPK> colecaoIdsGuiasPagamentosAtualizarIndicadorMulta = new ArrayList<GuiaPagamentoPrestacaoPK>();
						Collection<Object[]> colecaoGuiasPagamentoPrestacaoAtualizarVencimento = new ArrayList<Object[]>();

						Iterator<GuiaPagamentoPrestacao> guiasPagamentoPrestacaoIterator = guiasPagamentoPrestacao.iterator();

						while(guiasPagamentoPrestacaoIterator.hasNext() && saldoValorPago.compareTo(BigDecimal.ZERO) > 0){
							guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) guiasPagamentoPrestacaoIterator.next();

							resolucaoDiretoriaParametrosPagamentoAVista = this
											.getControladorCobranca()
											.obterResolucaoDiretoriaParametrosPagamentoAVista(
															guiaPagamentoPrestacao.getAnoMesReferenciaFaturamento(),
															guiaPagamentoPrestacao.getDataVencimento(), idResolucaoDiretoria, dataPagamento);

							if(resolucaoDiretoriaParametrosPagamentoAVista != null){
								percentualDescontoMulta = resolucaoDiretoriaParametrosPagamentoAVista.getPercentualDescontoMulta();
								percentualDescontoJurosMora = resolucaoDiretoriaParametrosPagamentoAVista.getPercentualDescontoJurosMora();
								percentualDescontoCorrecaoMonetaria = resolucaoDiretoriaParametrosPagamentoAVista
												.getPercentualDescontoCorrecaoMonetaria();

							}else{
								continue;
							}

							guiaPagamentoPrestacaoPK = guiaPagamentoPrestacao.getComp_id();

							valorPrestacao = guiaPagamentoPrestacao.getValorPrestacao();

							if(saldoValorPago.compareTo(valorPrestacao) < 0){
								break;
							}

							saldoValorPago = saldoValorPago.subtract(valorPrestacao);

							dataVencimento = guiaPagamentoPrestacao.getDataVencimento();

							if((percentualDescontoMulta != null && percentualDescontoMulta.compareTo(cem) != 0)
											|| (percentualDescontoJurosMora != null && percentualDescontoJurosMora.compareTo(cem) != 0)
											|| (percentualDescontoCorrecaoMonetaria != null && percentualDescontoCorrecaoMonetaria
															.compareTo(cem) != 0)){

								// [UC0216 – Calcular Acréscimos por Impontualidade]
								anoMesReferenciaFaturamento = guiaPagamentoPrestacao.getAnoMesReferenciaFaturamento();
								indicadorCobrancaMulta = guiaPagamentoPrestacao.getIndicadorCobrancaMulta();

								calcularAcrescimoPorImpontualidadeHelper = this.getControladorCobranca()
												.calcularAcrescimoPorImpontualidadeBancoDeDados(anoMesReferenciaFaturamento,
																dataVencimento, dataEmissao, valorPrestacao, BigDecimal.ZERO,
																indicadorCobrancaMulta, Integer.toString(anoMesReferenciaArrecadacao),
																null, null, null, ConstantesSistema.SIM, ConstantesSistema.SIM,
																ConstantesSistema.SIM);

								if(calcularAcrescimoPorImpontualidadeHelper != null){
									BigDecimal valorAuxiliar = BigDecimal.ZERO;

									valorMulta = calcularAcrescimoPorImpontualidadeHelper.getValorMulta();

									if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
										valorAuxiliar = cem.subtract(percentualDescontoMulta);
										valorAuxiliar = valorAuxiliar.divide(cem);

										valorMulta = valorMulta.multiply(valorAuxiliar);
									}

									valorJurosMora = calcularAcrescimoPorImpontualidadeHelper.getValorJurosMora();

									if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
										valorAuxiliar = cem.subtract(percentualDescontoJurosMora);
										valorAuxiliar = valorAuxiliar.divide(cem);

										valorJurosMora = valorJurosMora.multiply(valorAuxiliar);
									}

									valorAtualizacaoMonetaria = calcularAcrescimoPorImpontualidadeHelper.getValorAtualizacaoMonetaria();

									if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
										valorAuxiliar = cem.subtract(percentualDescontoCorrecaoMonetaria);
										valorAuxiliar = valorAuxiliar.divide(cem);

										valorAtualizacaoMonetaria = valorAtualizacaoMonetaria.multiply(valorAuxiliar);
									}

									if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
										idDebitoTipo = DebitoTipo.MULTA_IMPONTUALIDADE;

										debitoTipo = new DebitoTipo();
										debitoTipo.setId(idDebitoTipo);

										this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametro, debitoTipo,
														valorMulta, anoMesReferenciaFaturamento);

										colecaoIdsGuiasPagamentosAtualizarIndicadorMulta.add(guiaPagamentoPrestacaoPK);
									}

									if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
										idDebitoTipo = DebitoTipo.JUROS_MORA;

										debitoTipo = new DebitoTipo();
										debitoTipo.setId(idDebitoTipo);

										this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametro, debitoTipo,
														valorJurosMora, anoMesReferenciaFaturamento);
									}

									if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
										idDebitoTipo = DebitoTipo.ATUALIZACAO_MONETARIA;

										debitoTipo = new DebitoTipo();
										debitoTipo.setId(idDebitoTipo);

										this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametro, debitoTipo,
														valorAtualizacaoMonetaria, anoMesReferenciaFaturamento);
									}
								}
							}

							if(Util.compararData(dataVencimento, dataPagamento) == -1){
								colecaoGuiasPagamentoPrestacaoAtualizarVencimento.add(new Object[] {guiaPagamentoPrestacaoPK
												.getGuiaPagamentoId(), guiaPagamentoPrestacaoPK.getNumeroPrestacao()});
							}
						}

						if(!Util.isVazioOrNulo(colecaoIdsGuiasPagamentosAtualizarIndicadorMulta)){
							try{
								repositorioFaturamento
												.atualizarIndicadorMultaDeGuiaPagamentoPrestacao(colecaoIdsGuiasPagamentosAtualizarIndicadorMulta);
							}catch(ErroRepositorioException e){
								throw new ControladorException("erro.sistema", e);
							}
						}

						if(!Util.isVazioOrNulo(colecaoGuiasPagamentoPrestacaoAtualizarVencimento)){
							try{
								repositorioCobranca.atualizarGuiaPagamentoPrestacao(colecaoGuiasPagamentoPrestacaoAtualizarVencimento,
												dataPagamento);
							}catch(ErroRepositorioException e){
								throw new ControladorException("erro.sistema", e);
							}
						}
					}
				}else{
					if(parmsDocumentoCobranca[0] != null){
						valorAcrescimo = ((BigDecimal) parmsDocumentoCobranca[0]);
						valorAcrescimoOriginalDocCob = ((BigDecimal) parmsDocumentoCobranca[0]);
					}

					if(parmsDocumentoCobranca[1] != null){
						valorDesconto = ((BigDecimal) parmsDocumentoCobranca[1]);
					}

					if(parmsDocumentoCobranca[3] != null){
						idCobrancaDocumento = ((Integer) parmsDocumentoCobranca[3]);
					}

					if(parmsDocumentoCobranca[4] != null){
						valorTaxa = ((BigDecimal) parmsDocumentoCobranca[4]);
					}

					// caso o valor de acrescimo for maior que zero e a empresa não utilize a regra
					// de emitir o documento com os acrescimos
					if((parametroTratarAcrescimosEmissaoDocumento.equals(Short.toString(ConstantesSistema.NAO)) && parametroPermitirSelecaoAcrescimosExtrato
									.equals(Short.toString(ConstantesSistema.NAO))) && valorAcrescimo.compareTo(BigDecimal.ZERO) == 1){

						// [SB0008 - Alterar vencimento dos itens do documento de cobrança]
						alterarVencimentoItensDocumentoCobranca(idCobrancaDocumento, dataEmissao);
					}

					// caso o valor de acrescimos seja maior que o valor dedescontos
					if(valorAcrescimo.compareTo(valorDesconto) == 1){
						valorAcrescimo = valorAcrescimo.subtract(valorDesconto);
						valorDesconto = BigDecimal.ZERO;
					}else{
						valorDesconto = valorDesconto.subtract(valorAcrescimo);
						valorAcrescimo = BigDecimal.ZERO;
					}

					// caso o valor de acrescimo for maior que zero e a empresa não utilize a regra
					// de emitir o documento com os acrescimos
					if((parametroTratarAcrescimosEmissaoDocumento.equals(Short.toString(ConstantesSistema.NAO)) && parametroPermitirSelecaoAcrescimosExtrato
									.equals(Short.toString(ConstantesSistema.NAO))) && valorAcrescimo.compareTo(BigDecimal.ZERO) == 1){

						// [SB0005 - Processar Recebimento de Acrescimos por Impontualidade]
						Pagamento pagamento = this.processarRecebimentoAcrescimosImpontualidade(idCobrancaDocumento, dataEmissao,
										valorAcrescimo, idImovelNaBase, idLocalidadeImovel, sistemaParametro, idFormaPagamento);

						colecaoPagamentos.add(pagamento);

					}

					// Atenção!!!
					// Este subfluxo foi comentado, visto que a solução de devolução precisa ser
					// revista e a aplicação hoje não estar preparada para tratar essa situação.

					// // caso o valor de desconto for maior que zero
					// if(valorDesconto.compareTo(BigDecimal.ZERO) == 1){
					//
					// // [SB0006 - Processar Desconto concedido no documento de cobrança]
					// Devolucao devolucao =
					// this.processarDescontoConcedidoDocumentoCobranca(idCobrancaDocumento,
					// dataEmissao,
					// valorDesconto, idImovelNaBase, idLocalidadeImovel, sistemaParametro,
					// idFormaPagamento);
					//
					// colecaoDevolucoes.add(devolucao);
					//
					// }


					// caso o valor da taxa referente ao documento de cobrança for maior que zero
					if(valorTaxa.compareTo(BigDecimal.ZERO) == 1){

						// [SB0007 – Processar Taxa do Documento de Cobrança]
						Pagamento pagamento = this.processarTaxaDocumentoCobranca(idCobrancaDocumento, dataEmissao, valorTaxa,
										idImovelNaBase, idLocalidadeImovel, sistemaParametro, idFormaPagamento);

						colecaoPagamentos.add(pagamento);

					}
				}

				BigDecimal valorDescontoItensCredito = BigDecimal.ZERO;
				if(cobrancaDocumentoItens != null && !cobrancaDocumentoItens.isEmpty()){
					Iterator cobrancaDocumentoItensIterator = cobrancaDocumentoItens.iterator();
					while(cobrancaDocumentoItensIterator.hasNext()){
						Object[] cobrancaDocumentoItem = (Object[]) cobrancaDocumentoItensIterator.next();

						// Se for crédito a realizar, soma o valor do item
						if(cobrancaDocumentoItem[11] != null){
							if(cobrancaDocumentoItem[3] != null){
								valorDescontoItensCredito = valorDescontoItensCredito.add((BigDecimal) cobrancaDocumentoItem[3]);
							}
						}
						// valorDescontoMulta
						if(cobrancaDocumentoItem[15] != null){
							valorDescontoItensCredito = valorDescontoItensCredito.add((BigDecimal) cobrancaDocumentoItem[15]);
						}
						// valorDescontoValor
						if(cobrancaDocumentoItem[16] != null){
							valorDescontoItensCredito = valorDescontoItensCredito.add((BigDecimal) cobrancaDocumentoItem[16]);
						}
						// valorDescontoMora
						if(cobrancaDocumentoItem[17] != null){
							valorDescontoItensCredito = valorDescontoItensCredito.add((BigDecimal) cobrancaDocumentoItem[17]);
						}
						// valorDescontoCorrecaoMonetaria
						if(cobrancaDocumentoItem[18] != null){
							valorDescontoItensCredito = valorDescontoItensCredito.add((BigDecimal) cobrancaDocumentoItem[18]);
						}
						// valorDescontoDocumento
						if(cobrancaDocumentoItem[19] != null){
							valorDescontoItensCredito = valorDescontoItensCredito.add((BigDecimal) cobrancaDocumentoItem[19]);
						}
					}
				}

				// verifica se a coleção é diferente de nula
				if(cobrancaDocumentoItens != null && !cobrancaDocumentoItens.isEmpty()){
					BigDecimal valorPagamentoAux = valorPagamento.add(valorDescontoItensCredito);

					Iterator cobrancaDocumentoItensIterator = cobrancaDocumentoItens.iterator();

					while(cobrancaDocumentoItensIterator.hasNext() && valorPagamentoAux.compareTo(BigDecimal.ZERO) > 0){

						Object[] cobrancaDocumentoItem = (Object[]) cobrancaDocumentoItensIterator.next();

						/*
						 * Colocado por Raphael Rossiter em 31/10/2007 OBJ: Apenas gerar os
						 * pagamentos referentes aos itens que NAO tenham
						 * CreditoARealizar
						 */
						BigDecimal valorItemCobrado = null;

						if(cobrancaDocumentoItem[11] == null){

							// verifica o valor do item cobrado da cobranca documento item
							if(cobrancaDocumentoItem[3] != null){
								valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[3];
							}

							BigDecimal valorAcrescimoItem = BigDecimal.ZERO;

							if(cobrancaDocumentoItem[31] != null){
								valorAcrescimoItem = (BigDecimal) cobrancaDocumentoItem[31];
							}

							// inicializa as variaveis que veio da pesquisa
							Integer idContaPesquisa = null;
							Integer idContaGeralPesquisa = null;
							Integer idGuiaPagamento = null;
							Integer idDebitoACobrar = null;
							int contaReferencia = 0;
							Integer idDebitoTipo = null;
							Integer idGuiaPagamentoGeralPesquisa = null;
							Integer idDebitoACobrarGeralPesquisa = null;
							Integer idLocalidade = null;

							// verifica o id da conta
							if(cobrancaDocumentoItem[0] != null){
								idContaPesquisa = (Integer) cobrancaDocumentoItem[0];
								idContaGeralPesquisa = (Integer) cobrancaDocumentoItem[0];

								// referencia conta
								if(cobrancaDocumentoItem[4] != null){
									contaReferencia = (Integer) cobrancaDocumentoItem[4];
								}

							}else{

								// caso não exista na conta então pesquisa na conta histórico
								if(cobrancaDocumentoItem[8] != null){
									idContaGeralPesquisa = (Integer) cobrancaDocumentoItem[8];
								}

								// referencia conta histórico
								if(cobrancaDocumentoItem[5] != null){
									contaReferencia = (Integer) cobrancaDocumentoItem[5];
								}
							}

							// verifica o id da guia pagamento
							if(cobrancaDocumentoItem[1] != null){
								idGuiaPagamento = (Integer) cobrancaDocumentoItem[1];
								idGuiaPagamentoGeralPesquisa = (Integer) cobrancaDocumentoItem[1];
							}else{

								// caso não exista no guia pagamento então pesquisa no guia
								// pagamento histórico
								if(cobrancaDocumentoItem[9] != null){
									idGuiaPagamentoGeralPesquisa = (Integer) cobrancaDocumentoItem[9];
								}
							}

							// verifica numeroPrestacao da Guia de Pagamento
							Short numeroPrestacao = null;
							if(idGuiaPagamentoGeralPesquisa != null){
								if(cobrancaDocumentoItem[14] != null){
									numeroPrestacao = (Short) cobrancaDocumentoItem[14];
								}
							}

							// verifica o id do debito a cobrar
							if(cobrancaDocumentoItem[2] != null){
								idDebitoACobrar = (Integer) cobrancaDocumentoItem[2];
								idDebitoACobrarGeralPesquisa = (Integer) cobrancaDocumentoItem[2];

								// se foi de antecipacao seta o numero da prestacao
								if(cobrancaDocumentoItem[23] != null){
									numeroPrestacao = Short.valueOf(cobrancaDocumentoItem[23] + "");
								}

								DebitoACobrar debitoACobrar = null;
								try{
									debitoACobrar = this.repositorioFaturamento.pesquisarDebitoACobrar(idDebitoACobrar);
								}catch(ErroRepositorioException e){
									throw new ControladorException("erro.sistema", e);
								}

								if(debitoACobrar == null){
									throw new ControladorException("atencao.atualizacao.removido");
								}

								// se nao tem antecipacao
								if(cobrancaDocumentoItem[23] == null
												|| (cobrancaDocumentoItem[23] != null && numeroPrestacao.intValue() == 0)){

									// [SB0012]- Verifica Pagamento de Débito a Cobrar de
									// Parcelamento
									if(debitoACobrar.getParcelamento() != null){
										this.verificaPagamentoDebitoACobrarParcelamento(idDebitoACobrar, debitoACobrar.getParcelamento()
														.getId());
									}

									// se tem antecipacao
								}else{

									// se for juros e tiver valor
									if(cobrancaDocumentoItem[6] != null
													&& DebitoTipo.JUROS_SOBRE_PARCELAMENTO.equals(cobrancaDocumentoItem[6])){

										FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
										filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
														FiltroDebitoACobrarHistorico.ID_ORIGINAL, debitoACobrar.getId()));
										filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
														FiltroDebitoACobrarHistorico.NUMERO_PARCELA, cobrancaDocumentoItem[23]));

										Collection<DebitoACobrarHistorico> colecaoDebitoACobrarHistorico = this.getControladorUtil()
														.pesquisar(filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());

										if(colecaoDebitoACobrarHistorico == null || colecaoDebitoACobrarHistorico.isEmpty()){

											// atualizando o valor do debito a cobrar quando for
											// dado desconto no juros
											debitoACobrar.setNumeroPrestacaoCobradas((short) (debitoACobrar.getNumeroPrestacaoCobradas() + 1));
											if(debitoACobrar.getNumeroPrestacaoCobradas() == debitoACobrar.getNumeroPrestacaoDebito()){
												DebitoCreditoSituacao dcs = new DebitoCreditoSituacao();
												dcs.setId(DebitoCreditoSituacao.NORMAL);
												debitoACobrar.setDebitoCreditoSituacaoAtual(dcs);
											}
											debitoACobrar.setUltimaAlteracao(new Date());
											this.getControladorUtil().atualizar(debitoACobrar);

											// calcula a diferenca entre o valor real
											// (cobrancaDocumentoItem[3]) e o valor cobrado
											// (cobrancaDocumentoItem[24])
											if(cobrancaDocumentoItem[3] != null && cobrancaDocumentoItem[24] != null){

												// verificando a diferenca entre o valor original e
												// o novo valor cobrado.
												BigDecimal diferenca = ((BigDecimal) cobrancaDocumentoItem[3])
																.subtract((BigDecimal) cobrancaDocumentoItem[24]);

												// se for menor que zero entao passa para o proximo
												if(diferenca.doubleValue() > BigDecimal.ZERO.doubleValue()){

													// // seta os dados do histórico de débito a
													// cobrar
													DebitoACobrarHistorico debitoACobrarHistoricoTemp = this.getControladorFaturamento()
																	.gerarDebitoACobrarHistoricoDoDebitoACobrar(debitoACobrar);
													debitoACobrarHistoricoTemp.setValorDebito(diferenca);
													debitoACobrarHistoricoTemp.setId(null);
													debitoACobrarHistoricoTemp.setPrestacaoCobradas((short) 1);
													debitoACobrarHistoricoTemp.setPrestacaoDebito((short) 1);
													DebitoCreditoSituacao dcs = new DebitoCreditoSituacao();
													dcs.setId(DebitoCreditoSituacao.CANCELADA);
													debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAtual(dcs);

													DebitoACobrarGeral dag = new DebitoACobrarGeral();
													dag.setIndicadorHistorico(DebitoACobrarGeral.INDICADOR_POSSUI_HISTORICO);
													dag.setUltimaAlteracao(new Date());
													Integer id = (Integer) this.getControladorUtil().inserir(dag);

													debitoACobrarHistoricoTemp.setId(id);
													debitoACobrarHistoricoTemp.setNumeroParcela(Integer.parseInt(cobrancaDocumentoItem[23]
																	+ ""));
													debitoACobrarHistoricoTemp.setIdOriginal(idDebitoACobrar);
													this.getControladorUtil().inserir(debitoACobrarHistoricoTemp);

												}
											}

											// se tem valor de juros
											if(cobrancaDocumentoItem[24] != null){
												valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[24];
												// se o juros for zero pule pra o proximo item
												if(valorItemCobrado.equals(BigDecimal.ZERO)){
													continue;
												}
											}
										}else{
											continue;
										}
									}
								}

								// é debito a cobrar no historico
							}else{

								// caso não exista no debito a cobrar então pesquisa no debito a
								// cobrar histórico
								if(cobrancaDocumentoItem[10] != null){
									idDebitoACobrarGeralPesquisa = (Integer) cobrancaDocumentoItem[10];
									if(cobrancaDocumentoItem[23] != null){
										numeroPrestacao = Short.valueOf(cobrancaDocumentoItem[23] + "");
									}
								}

								// se for juros
								if(cobrancaDocumentoItem[7] != null
												&& DebitoTipo.JUROS_SOBRE_PARCELAMENTO.equals(Integer
																.valueOf(cobrancaDocumentoItem[7] + ""))){

									// if (cobrancaDocumentoItem[3] != null &&
									// cobrancaDocumentoItem[24] != null ) {
									// // verificando a diferenca entre o valor original e o novo
									// valor cobrado.
									// BigDecimal diferenca = ((BigDecimal)
									// cobrancaDocumentoItem[3]).subtract((BigDecimal)
									// cobrancaDocumentoItem[24]);
									// //se for menor que zero entao passa para o proximo
									// if (diferenca.compareTo(BigDecimal.ZERO) > 0) {
									// // subtranindo a diferenca.....
									// FiltroDebitoACobrarHistorico fdach = new
									// FiltroDebitoACobrarHistorico();
									// fdach.adicionarParametro(new
									// ParametroSimples(FiltroDebitoACobrarHistorico.ID,
									// idDebitoACobrarGeralPesquisa));
									// DebitoACobrarHistorico debitoACobrarHistorico =
									// (DebitoACobrarHistorico)getControladorUtil().pesquisar(fdach,
									// DebitoACobrarHistorico.class.getSimpleName()).iterator().next();
									// debitoACobrarHistorico.setValorDebito(
									// debitoACobrarHistorico.getValorDebito().subtract(diferenca));
									// debitoACobrarHistorico.setUltimaAlteracao(new Date());
									// getControladorUtil().atualizar(debitoACobrarHistorico);
									//
									// // seta os dados do histórico de débito a cobrar
									// DebitoACobrarHistorico debitoACobrarHistoricoTemp =
									// duplicarDebitoACobrarHistorico(debitoACobrarHistorico);
									// debitoACobrarHistoricoTemp.setId(null);
									// debitoACobrarHistoricoTemp.setValorDebito(diferenca);
									// DebitoCreditoSituacao dcs = new DebitoCreditoSituacao();
									// dcs.setId(DebitoCreditoSituacao.CANCELADA);
									// debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAtual(dcs);
									// getControladorUtil().inserir(debitoACobrarHistoricoTemp);
									// throw new
									// IllegalArgumentException("Falta os parametros novos do d a cobrar");
									// }
									// }
									// se tem valor de juros
									if(cobrancaDocumentoItem[24] != null){
										valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[24];
										// se o juros for zero pule pra o proximo item
										if(valorItemCobrado.equals(BigDecimal.ZERO)){
											continue;
										}
									}

								}
							}

							if(idContaGeralPesquisa == null){

								// caso exista guia de pagamento
								if(idGuiaPagamentoGeralPesquisa != null){
									/*
									 * verifica o id do debito tipo se é // da // guia if
									 * (cobrancaDocumentoItem[6] != null) { idDebitoTipo =
									 * (Integer) cobrancaDocumentoItem[6]; } else { // caso não
									 * exista no guia // pagamento // então // pesquisa no
									 * guia pagamento // histórico if (cobrancaDocumentoItem[7] !=
									 * null) { idDebitoTipo = (Integer)
									 * cobrancaDocumentoItem[7]; } }
									 */
								}

								// caso exista debito a cobrar
								if(idDebitoACobrarGeralPesquisa != null){

									// verifica o id do debito tipo no debito a cobrar
									if(cobrancaDocumentoItem[6] != null){
										idDebitoTipo = (Integer) cobrancaDocumentoItem[6];

									}else{

										// caso não exista no debito a cobrar então pesquisa no
										// debito a cobrar histórico
										if(cobrancaDocumentoItem[7] != null){
											idDebitoTipo = (Integer) cobrancaDocumentoItem[7];
										}
									}
								}
							}

							if(idContaGeralPesquisa != null){
								if(cobrancaDocumentoItem[25] != null){
									idLocalidade = (Integer) cobrancaDocumentoItem[25];
								}else if(cobrancaDocumentoItem[26] != null){
									idLocalidade = (Integer) cobrancaDocumentoItem[26];
								}
							}else{
								if(idDebitoACobrarGeralPesquisa != null){
									if(cobrancaDocumentoItem[27] != null){
										idLocalidade = (Integer) cobrancaDocumentoItem[27];
									}else if(cobrancaDocumentoItem[28] != null){
										idLocalidade = (Integer) cobrancaDocumentoItem[28];
									}
								}else if(idGuiaPagamentoGeralPesquisa != null){
									if(cobrancaDocumentoItem[29] != null){
										idLocalidade = (Integer) cobrancaDocumentoItem[29];
									}else if(cobrancaDocumentoItem[30] != null){
										idLocalidade = (Integer) cobrancaDocumentoItem[30];
									}
								}else{
									idLocalidade = idLocalidadeImovel;
								}
							}

							// cria o objeto pagamento para setar os dados
							Pagamento pagamento = new Pagamento();
							if(contaReferencia != 0){
								pagamento.setAnoMesReferenciaPagamento(contaReferencia);
							}else{
								pagamento.setAnoMesReferenciaPagamento(null);
							}

							pagamento.setAnoMesReferenciaArrecadacao(anoMesReferenciaArrecadacao);

							// Ajuste necessário para tratar a Arrecadação de CASAL. O acrescimo do
							// item só deve ser considerado quando o documento foi gerado com
							// acrescimo. Essa verificação é necessária porque o emitir extrato de
							// débitos gera os ítens com acrescimo mesmo que o documento não seja
							// emitido com acrescimo
							if((parametroTratarAcrescimosEmissaoDocumento.equals(Short.toString(ConstantesSistema.SIM)) || parametroPermitirSelecaoAcrescimosExtrato
											.equals(Short.toString(ConstantesSistema.SIM)))
											&& valorAcrescimoItem.compareTo(BigDecimal.ZERO) == 1
											&& valorAcrescimoOriginalDocCob.compareTo(BigDecimal.ZERO) == 1){
								valorItemCobrado = valorItemCobrado.add(valorAcrescimoItem);
							}

							if(valorPagamentoAux.compareTo(valorItemCobrado) < 0){
								valorItemCobrado = valorPagamentoAux;
							}

							// O valor passado no código de barras vai sendo subtraído pelo valor do
							// ítem do documento. Isso é necessário para fazer com que o GSAN so
							// realize a baixa dos documentos que deram pra ser pagos com o valor do
							// código de barras
							valorPagamentoAux = valorPagamentoAux.subtract(valorItemCobrado);

							pagamento.setValorPagamento(valorItemCobrado);
							pagamento.setDataPagamento(dataPagamento);

							pagamento.setPagamentoSituacaoAtual(null);
							pagamento.setPagamentoSituacaoAnterior(null);
							if(idDebitoTipo != null){
								DebitoTipo debitoTipo = new DebitoTipo();
								debitoTipo.setId(idDebitoTipo);
								pagamento.setDebitoTipo(debitoTipo);
							}else{
								pagamento.setDebitoTipo(null);
							}

							// verifica se o id da conta é diferente de nulo
							if(idContaGeralPesquisa != null){

								Conta conta = new Conta();

								if(idContaPesquisa != null){
									conta.setId(idContaPesquisa);
									pagamento.setConta(conta);

								}else{
									conta.setId(idContaGeralPesquisa);
									pagamento.setConta(conta);
								}

								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.CONTA);
								pagamento.setDocumentoTipo(documentoTipo);
							}else{
								pagamento.setConta(null);
							}

							// verifica se o id da guia de pagamento é diferente de nulo
							if(idGuiaPagamentoGeralPesquisa != null){
								if(idGuiaPagamento != null){
									GuiaPagamento guiaPagamento = new GuiaPagamento();
									guiaPagamento.setId(idGuiaPagamento);

									guiaPagamento.setGuiaPagamentoGeral(new GuiaPagamentoGeral());
									guiaPagamento.getGuiaPagamentoGeral().setId(idGuiaPagamento);

									pagamento.setGuiaPagamentoGeral(guiaPagamento.getGuiaPagamentoGeral());
									pagamento.getGuiaPagamentoGeral().setGuiaPagamento(guiaPagamento);

									if(numeroPrestacao != null){
										pagamento.setNumeroPrestacao(Integer.valueOf(numeroPrestacao.intValue()));
									}

								}else{
									pagamento.setGuiaPagamentoGeral(null);
									pagamento.setNumeroPrestacao(null);
								}
								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
								pagamento.setDocumentoTipo(documentoTipo);

							}else{
								pagamento.setGuiaPagamentoGeral(null);
								pagamento.setNumeroPrestacao(null);
							}

							// verifica se o id do debito a cobrar é diferente de nulo
							if(idDebitoACobrarGeralPesquisa != null){
								if(idDebitoACobrar != null){
									DebitoACobrar debitoACobrar = new DebitoACobrar();
									debitoACobrar.setId(idDebitoACobrar);
									pagamento.setDebitoACobrar(debitoACobrar);
									if(numeroPrestacao != null && numeroPrestacao.intValue() != 0){
										pagamento.setNumeroPrestacao(Integer.valueOf(numeroPrestacao.intValue()));
									}else{
										pagamento.setNumeroPrestacao(null);
										try{
											// atualiza a situação atual para paga
											repositorioFaturamento.atualizarSituacaoAtualDebitoACobrar(idDebitoACobrar);
										}catch(ErroRepositorioException e){
											throw new ControladorException("erro.sistema", e);
										}
									}

								}else{
									pagamento.setDebitoACobrar(null);

									if(numeroPrestacao != null && numeroPrestacao.intValue() != 0){
										pagamento.setNumeroPrestacao(Integer.valueOf(numeroPrestacao.intValue()));
									}
								}
								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
								pagamento.setDocumentoTipo(documentoTipo);

							}else{
								pagamento.setDebitoACobrar(null);
							}

							// verifica se o id da conta é diferente de nulo
							if(idLocalidade != null){
								Localidade localidade = new Localidade();
								localidade.setId(idLocalidade);
								pagamento.setLocalidade(localidade);
							}else{
								pagamento.setLocalidade(null);

							}

							// seta o id do aviso bancario
							pagamento.setAvisoBancario(null);

							// seta o imovel
							if(idImovelNaBase != null){
								Imovel imovel = new Imovel();
								imovel.setId(idImovelNaBase);
								pagamento.setImovel(imovel);
							}else{
								pagamento.setImovel(null);
							}

							// ArrecadadorMovimentoItem arrecadadorMovimentoItem = new
							// ArrecadadorMovimentoItem();

							pagamento.setArrecadadorMovimentoItem(null);

							ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
							arrecadacaoForma.setId(idFormaPagamento);
							pagamento.setArrecadacaoForma(arrecadacaoForma);
							pagamento.setCliente(null);
							pagamento.setUltimaAlteracao(new Date());
							if(pagamento.getDocumentoTipo() != null){
								colecaoPagamentos.add(pagamento);
							}
						}else{

							// Para os itens que tenham CreditoARealizar gerar suas respectivas
							// devoluções

							Devolucao devolucao = new Devolucao();

							// DataDevolucao = DataPagamento
							devolucao.setDataDevolucao(dataPagamento);

							/*
							 * AnoMesReferenciaDevolucao Caso o anoMes da data de devolução seja
							 * MAIOR que a PARM_AMREFERENCIAARRECADACAO da tabela
							 * SISTEMA_PARAMETROS atribuir o anoMes da data da devolução, caso
							 * contrário atribuir o PARM_AMREFERENCIAARRECADACAO.
							 */
							Integer anoMesDataDevolucao = Util.getAnoMesComoInteger(devolucao.getDataDevolucao());

							if(anoMesDataDevolucao > sistemaParametro.getAnoMesArrecadacao()){
								devolucao.setAnoMesReferenciaArrecadacao(anoMesDataDevolucao);
							}else{
								devolucao.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
							}

							// ValorDevolucao = ValorItemCobrado
							if(cobrancaDocumentoItem[3] != null){
								valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[3];
								devolucao.setValorDevolucao(valorItemCobrado);
							}

							// Localidade = Localidade da tabela COBRANCA_DOCUMENTO
							if(cobrancaDocumentoItem[12] != null){
								Localidade localidade = new Localidade();
								localidade.setId((Integer) cobrancaDocumentoItem[12]);
								devolucao.setLocalidade(localidade);
							}

							// Imovel = Imovel da tabela COBRANCA_DOCUMENTO
							if(cobrancaDocumentoItem[13] != null){
								Imovel imovel = new Imovel();
								imovel.setId((Integer) cobrancaDocumentoItem[13]);
								devolucao.setImovel(imovel);
							}

							// DebitoTipo = DebitoTipo com o valor
							// correspondente a outros
							DebitoTipo debitoTipo = new DebitoTipo();
							debitoTipo.setId(DebitoTipo.OUTROS);
							devolucao.setDebitoTipo(debitoTipo);

							// CreditoARealizarGeral = CreditoARealizarGeral da tabela
							// COBRANCA_DOCUMENTO_ITEM
							CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
							creditoARealizarGeral.setId((Integer) cobrancaDocumentoItem[11]);
							devolucao.setCreditoARealizarGeral(creditoARealizarGeral);

							// Ultima Alteração
							devolucao.setUltimaAlteracao(new Date());

							// ADICIONANDO A DEVOLUCAO GERADA NA COLECAO DE RETORNO
							colecaoDevolucoes.add(devolucao);
						}
					}
				}

				// Caso possua antecipação. Atualizar o número de prestações
				// cobradas do débito de JUROS_SOBRE_PARCELAMENTO.
				// ...........................................
				if(valorDesconto.compareTo(BigDecimal.ZERO) == 1){

					Collection collDebitoACobrarAux = null;
					try{
						collDebitoACobrarAux = this.repositorioFaturamento.pesquisarDebitoACobrarPorDebitoTipo(idImovelNaBase,
										DebitoTipo.JUROS_SOBRE_PARCELAMENTO);

						BigDecimal parte1 = BigDecimal.ZERO;

						if(collDebitoACobrarAux != null){

							Iterator it = collDebitoACobrarAux.iterator();

							while(it.hasNext()){
								DebitoACobrar dbac = (DebitoACobrar) it.next();

								/*
								 * Calcular o valor que falta ser cobrado (DBAC_VLDEBITO -
								 * ((DBAC_VLDEBITO /
								 * DBAC_NNPRESTACAODEBITO) * DBAC_NNPRESTACAOCOBRADAS))
								 */
								/* Atribui o valor que falta a ser cobrado ao valor do documento */
								BigDecimal valorParcela = dbac.getValorDebito().divide(
												new BigDecimal(String.valueOf(dbac.getNumeroPrestacaoDebito())), 2, BigDecimal.ROUND_DOWN);

								BigDecimal numeroParcelasAntecipadas = BigDecimal.ZERO;
								if(dbac.getQuantidadeParcelasAntecipadas() != null){
									numeroParcelasAntecipadas = Util.formatarMoedaRealparaBigDecimal(dbac
													.getQuantidadeParcelasAntecipadas().toString());

								}



								if(dbac.getQuantidadeParcelasAntecipadas() != null
												&& dbac.getQuantidadeParcelasAntecipadas() == dbac.getNumeroPrestacaoDebito()){
									// Ultima parcela
									// Obtém o número de prestação débito
									BigDecimal numeroPrestacaoDebito = new BigDecimal(dbac.getNumeroPrestacaoDebito());

									// Mutiplica o valor da prestação * número da prestação debito
									BigDecimal multiplicacao = valorParcela.multiply(numeroPrestacaoDebito).setScale(2);

									// Subtrai o valor do débito pelo resultado da multiplicação
									parte1 = dbac.getValorDebito().subtract(multiplicacao).setScale(2);

								}

								BigDecimal numeroParcelasCobradas = Util.formatarMoedaRealparaBigDecimal(dbac.getNumeroPrestacaoCobradas()
												+ "");
								BigDecimal valorParcelasCobradas = valorParcela.multiply(numeroParcelasCobradas);
								BigDecimal valorAntecipado = valorParcela.multiply(numeroParcelasAntecipadas);


								if(parte1.compareTo(BigDecimal.ZERO) > 0){
									valorAntecipado = valorAntecipado.add(parte1);
								}

								valorAntecipado = valorAntecipado.subtract(valorParcelasCobradas);

								// Integer numeroPrestacaoAntecipadaAux =
								// numeroParcelasAntecipadas.intValue()
								// + dbac.getNumeroPrestacaoCobradas();

								if(valorAntecipado.compareTo(valorDesconto) == 0){

									dbac.setNumeroPrestacaoCobradas(numeroParcelasAntecipadas.shortValue());

									if(dbac.getNumeroPrestacaoCobradas() == dbac.getNumeroPrestacaoDebito()){
										// Tem a última parcela
										// // seta os dados do histórico de
										// débito a
										// cobrar

										Collection collDebitoACobrarTransf = new ArrayList();
										collDebitoACobrarTransf.add(dbac);

										this.getControladorFaturamento().transferirDebitosACobrarParaHistorico(collDebitoACobrarTransf,
														true);

									}else{
										dbac.setUltimaAlteracao(new Date());
										this.getControladorUtil().atualizar(dbac);
									}

								}

							}

						}

					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}

				}
				// ..............................................................

				// [SB0003] – Processar Pagamento de Documento de Cobrança
				// 2.4.11 verificar encerramento de RA
				this.encerrarRANegociacao(dataPagamento, idCobrancaDocumento);

				this.tratarBoletosBancariosDasContasEmCobrancaBancaria(idCobrancaDocumento, dataEmissao);
			}else{
				descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}

		}else{
			// atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setColecaoDevolucao(colecaoDevolucoes);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Processa os pagamentos de débito a cobrar
	 * [SF0006] Processar Pagamento de Débito a Cobrar
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 27/04/2006, 11/12/2006
	 * @author Saulo Lima
	 * @date 11/08/2009
	 *       Não gerar acréscimos por impontualidade para pagamentos de débito a cobrar.
	 * @param debitoACobrar
	 * @param colecaoPagamentos
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	protected Collection<Pagamento> processarPagamentoDebitoACobrar(DebitoACobrar debitoACobrar, Collection<Pagamento> colecaoPagamentos)
					throws ControladorException{

		/* Declaração de variáveis. */
		Collection<Pagamento> retorno = new ArrayList<Pagamento>();
		Map mapPagamentosProcessados = new HashMap<Integer, Collection<Pagamento>>();
		Object[] arrayColecoesPagamentosAtualizar = null;

		Date maiorDataPagamento = null;
		Date dataPagamentoAux = null;

		Integer numeroPrestacao = null;
		for(Pagamento pagamento : colecaoPagamentos){
			pagamento.setDebitoACobrar(debitoACobrar);
			numeroPrestacao = pagamento.getNumeroPrestacao();

			dataPagamentoAux = pagamento.getDataPagamento();

			if(maiorDataPagamento == null
							|| (dataPagamentoAux != null && maiorDataPagamento != null && dataPagamentoAux.compareTo(maiorDataPagamento) > 0)){
				maiorDataPagamento = dataPagamentoAux;
			}
		}



		/*
		 * Calcular o valor que falta ser cobrado (DBAC_VLDEBITO - ((DBAC_VLDEBITO /
		 * DBAC_NNPRESTACAODEBITO) * DBAC_NNPRESTACAOCOBRADAS))
		 */
		/* Atribui o valor que falta a ser cobrado ao valor do documento */
		BigDecimal valorParcela = debitoACobrar.getValorDebito().divide(
						new BigDecimal(String.valueOf(debitoACobrar.getNumeroPrestacaoDebito())), 2, BigDecimal.ROUND_DOWN);
		BigDecimal valorPago = valorParcela.multiply(new BigDecimal(String.valueOf(debitoACobrar.getNumeroPrestacaoCobradas())));
		BigDecimal valorDocumento = debitoACobrar.getValorDebito().subtract(valorPago);

		/* [SF0007] Calcular Valor Total dos Pagamentos */
		BigDecimal valorTotalPagamentosDebitoACobrar = this.calcularValorTotalPagamentos(colecaoPagamentos);

		DebitoACobrar debitoACobrarNaBase = null;
		short numeroPrestacaoDebito = -1;
		short numeroPrestacaoCobradas = -1;

		if(numeroPrestacao != null && numeroPrestacao.intValue() != 0){

			FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
			filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, debitoACobrar.getId()));

			Collection colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());

			if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){

				debitoACobrarNaBase = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);

				numeroPrestacaoDebito = debitoACobrarNaBase.getNumeroPrestacaoDebito();
				numeroPrestacaoCobradas = debitoACobrarNaBase.getNumeroPrestacaoCobradas();

				if(numeroPrestacao != (numeroPrestacaoDebito)){
					// Caso não seja a última parcela
					valorDocumento = valorParcela;
				}else{
					// Caso seja a última parcela
					BigDecimal numeroPrestacaoDeb = new BigDecimal(numeroPrestacaoDebito);

					// Mutiplica o valor da prestação * número da prestação debito
					BigDecimal multiplicacao = valorParcela.multiply(numeroPrestacaoDeb).setScale(2);

					// Subtrai o valor do débito pelo resultado da multiplicação
					BigDecimal parte1 = debitoACobrar.getValorDebito().subtract(multiplicacao).setScale(2);

					// Calcula o valor da prestação
					valorParcela = valorParcela.add(parte1).setScale(2);

					valorDocumento = valorParcela;

				}

			}
		}


		/*
		 * Caso valor total dos pagamentos para o débito a cobrar seja igual ao valor do documento
		 * atualizar a situação atual dos pagamentos
		 * (PGST_IDATUAL) com valor correspondente a pagamento classificado (tabela
		 * PAGAMENTO_SITUACAO) e atualizar o id do débito a cobrar nos
		 * pagamentos (seta DBAC_ID da tabela PAGAMENTO para DBAC_ID da tabela DEBITO_A_COBRAR);
		 */
		if((valorTotalPagamentosDebitoACobrar.compareTo(valorDocumento) == 0 && (numeroPrestacao == null || numeroPrestacao.intValue() == 0))
						|| (numeroPrestacao != null && numeroPrestacao.intValue() != 0 && valorTotalPagamentosDebitoACobrar
										.compareTo(valorDocumento) == 0)){

			mapPagamentosProcessados.put(debitoACobrar.getId(), colecaoPagamentos);
			retorno = colecaoPagamentos;
		}else{

			/* [SF0008] Processar Pagamento a Maior ou a Menor */
			arrayColecoesPagamentosAtualizar = this.processarPagamentoAMenorOUAMaior(valorTotalPagamentosDebitoACobrar, valorDocumento,
							colecaoPagamentos, debitoACobrar.getId());

			Collection colecaoPagamentosClassificados = (Collection) arrayColecoesPagamentosAtualizar[1];

			if(colecaoPagamentosClassificados != null && !colecaoPagamentosClassificados.isEmpty()){
				mapPagamentosProcessados.put(debitoACobrar.getId(), colecaoPagamentosClassificados);
				retorno = colecaoPagamentosClassificados;
			}
		}

		try{
			if(mapPagamentosProcessados != null && !mapPagamentosProcessados.isEmpty()){

				boolean pagamentoNaoClassificado = true;
				Collection colecaoIdsDebitosACobrar = mapPagamentosProcessados.keySet();

				for(Object idDebito : colecaoIdsDebitosACobrar){
					Collection<Pagamento> colecaoPagamentoValorNaoConfere = (Collection<Pagamento>) mapPagamentosProcessados.get(idDebito);
					if(colecaoPagamentoValorNaoConfere != null && !colecaoPagamentoValorNaoConfere.isEmpty()){
						for(Pagamento pagamentoObject : colecaoPagamentoValorNaoConfere){

							Pagamento pagamentoBase = repositorioArrecadacao.pesquisarPagamento(pagamentoObject.getId());
							if(pagamentoBase == null){
								pagamentoNaoClassificado = false;
							}

						}
					}
				}

				if(pagamentoNaoClassificado){
					this.repositorioArrecadacao.processarPagamentoDebitoACobrar(mapPagamentosProcessados);

					// Não gerar acréscimos por impontualidade para DébitoACobrar - Saulo Lima
					// 11/08/2009
					// // [UC0302] Calculo de Acrescimos -- Para cada conta do Map, itera nos
					// pagamentos encontrados
					// Collection<Integer> colecaoIdsDebitosACobrar =
					// mapPagamentosProcessados.keySet();
					// for (Integer idDebito : colecaoIdsDebitosACobrar) {
					// Collection<Pagamento> pagamentosDebito = (Collection<Pagamento>)
					// mapPagamentosProcessados.get(idDebito);
					// if (pagamentosDebito != null) {
					// for (Pagamento pagamento : pagamentosDebito) {
					// getControladorFaturamento().gerarDebitosACobrarDeAcrescimosPorImpontualidade(pagamento.getId(),
					// ConstantesSistema.SIM,
					// ConstantesSistema.SIM, ConstantesSistema.NAO);
					// }
					// }
					// }

					// 4.4. O sistema transfere para o histórico de pagamentos
					// (PAGAMENTO_HISTORICO), os pagamentos classificados
					// (PGST_IDATUAL com o valor correspondente a pagamento classificado);
					/* PARTE 1 */
					Collection<Pagamento> colecaoTemp = (Collection<Pagamento>) mapPagamentosProcessados.get(debitoACobrar.getId());
					Collection colecaoPagamentosPreenchida = this.carregarAtributosPagamento(colecaoTemp);

					Collection colecaoPagamentoHistorico = this.criarPagamentoHistoricoDoPagamento(colecaoPagamentosPreenchida,
									PagamentoSituacao.PAGAMENTO_CLASSIFICADO);
					getControladorBatch().removerColecaoObjetoParaBatch(colecaoPagamentosPreenchida);

					if(numeroPrestacao == null || numeroPrestacao.intValue() == 0){
						// 4.2. O sistema transfere para o histórico os débitos a cobrar
						// correspondentes
						// aos pagamentos classificados de débito a cobrar
						getControladorFaturamento().transferirDebitosACobrarParaHistorico(Collections.singletonList(debitoACobrar),
										Boolean.FALSE);

						// 4.3. Para cada débito a cobrar transferido para o histórico, atualiza o
						// indicador de que o débito a cobrar está no histórico
						getControladorFaturamento().atualizarIndicadorDebitoACobrarNoHistorico(Collections.singletonList(debitoACobrar));
					}else{
						if(debitoACobrarNaBase != null){
							if(numeroPrestacaoCobradas == (numeroPrestacaoDebito - 1)){
								// Última parcela

								this.getControladorFaturamento().transferirDebitosACobrarParaHistorico(
												Collections.singletonList(debitoACobrar), Boolean.FALSE);

								this.getControladorFaturamento().atualizarIndicadorDebitoACobrarNoHistorico(
												Collections.singletonList(debitoACobrar));
							}else{
								debitoACobrarNaBase.setNumeroPrestacaoCobradas(Integer.valueOf(numeroPrestacaoCobradas + 1).shortValue());

								this.getControladorUtil().atualizar(debitoACobrarNaBase);
							}
						}
					}

					if(debitoACobrar != null){
						Integer idDebitoACobrar = debitoACobrar.getId();

						// Verifica se há relação entre o débito a cobrar pago e algum item de
						// documento de
						// cobrança - [UC3082] Atualizar Item Documento Cobrança
						this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrar,
										CobrancaDebitoSituacao.PAGO, maiorDataPagamento, CobrancaDebitoSituacao.PENDENTE);
					}

					/* 4.4 PARTE 2 */
					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoPagamentoHistorico);

					/*
					 * TODO
					 * Pendência na versão 0.07 - Falta Customizar o [UC1015]
					 * Saulo Lima - 20/11/2008
					 */
					// 4.5. Efetuar os lançamentos (contabilização) relativos à baixa da conta
					// <<Inclui>> [UC1015 – Gerar/Atualizar Resumo da Arrecadação]
					// System.out.println("# Chamar o UC1015. #");

				}
			}

			if(arrayColecoesPagamentosAtualizar != null){

				Collection<Pagamento> colecaoPagamentoDuplicidade = null;

				/**
				 * Array contendo:
				 * 0 - Coleção de pagamentos para atualizar situação igual a valor não confere.
				 * 1 - Coleção de pagamentos para atualizar situação igual a pagamento classificado.
				 * 2 - Coleção de pagamentos para atualizar situação igual a pagamento em
				 * duplicidade.
				 * 3 - Coleção de pagamentos para atualizar valor excedente.
				 * 4 - Coleção de pagamentos para atualizar situação igual a valor não confere e
				 * remover referência.
				 */
				if(arrayColecoesPagamentosAtualizar[0] != null && !((Map) arrayColecoesPagamentosAtualizar[0]).isEmpty()){
					colecaoPagamentoDuplicidade = this
									.processarPagamentoValorNaoConfereDebitoACobrar((Map) arrayColecoesPagamentosAtualizar[0]);
				}
				// arrayColecoesPagamentosAtualizar[1] -> Já atualizado anteriormente
				if((arrayColecoesPagamentosAtualizar[2] != null && !((Collection) arrayColecoesPagamentosAtualizar[2]).isEmpty())
								|| (colecaoPagamentoDuplicidade != null && !colecaoPagamentoDuplicidade.isEmpty())){

					if(colecaoPagamentoDuplicidade == null){
						colecaoPagamentoDuplicidade = new ArrayList<Pagamento>();
					}
					colecaoPagamentoDuplicidade.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);

					this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_DUPLICADO,
									colecaoPagamentoDuplicidade);
				}
				if(arrayColecoesPagamentosAtualizar[3] != null && !((Collection) arrayColecoesPagamentosAtualizar[3]).isEmpty()){
					this.repositorioArrecadacao.atualizarValorExcedentePagamento((Collection) arrayColecoesPagamentosAtualizar[3]);

				}
				if(arrayColecoesPagamentosAtualizar[4] != null && !((Collection) arrayColecoesPagamentosAtualizar[4]).isEmpty()){
					this.repositorioArrecadacao
									.processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo((Collection) arrayColecoesPagamentosAtualizar[4]);
				}

				// ________________________________________________________________
				// Alterado por Yara Souza
				// Data : 27/07/2010
				// _________________________________________________________________

				if(arrayColecoesPagamentosAtualizar[5] != null && !((Collection) arrayColecoesPagamentosAtualizar[5]).isEmpty()){
					this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_A_MENOR,
									(Collection) arrayColecoesPagamentosAtualizar[5]);
				}

				if(arrayColecoesPagamentosAtualizar[6] != null && !((Collection) arrayColecoesPagamentosAtualizar[6]).isEmpty()){
					this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_A_MAIOR,
									(Collection) arrayColecoesPagamentosAtualizar[6]);
				}
				// ...................................................................

			}
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * Retorna o valor de controladorAcesso
	 * 
	 * @return O valor de controladorAcesso
	 */
	protected ControladorContabilLocal getControladorContabil(){

		ControladorContabilLocalHome localHome = null;
		ControladorContabilLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorContabilLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_CONTABIL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Cria uma instância do controlador de faturamento
	 * 
	 * @author Rafael Corrêa
	 * @date 02/05/2006
	 * @return
	 */
	/*
	 * private ControladorFaturamentoLocal getControladorFaturamento() {
	 * ControladorFaturamentoLocalHome localHome = null;
	 * ControladorFaturamentoLocal local = null; // pega a instância do
	 * ServiceLocator. ServiceLocator locator = null;
	 * try { locator = ServiceLocator.getInstancia();
	 * localHome = (ControladorFaturamentoLocalHome) locator
	 * .getLocalHome(ConstantesJNDI.CONTROLADOR_FATURAMENTO_SEJB); // guarda a
	 * referencia de um objeto capaz de fazer chamadas à // objetos remotamente
	 * local = localHome.create();
	 * return local; } catch (CreateException e) { throw new
	 * SistemaException(e); } catch (ServiceLocatorException e) { throw new
	 * SistemaException(e); } }
	 */

	/**
	 * Retorna a interface remota de ControladorParametro
	 * 
	 * @return A interface remota do controlador de parâmetro
	 */
	/*
	 * private ControladorLocalidadeLocal getControladorLocalidade() {
	 * ControladorLocalidadeLocalHome localHome = null;
	 * ControladorLocalidadeLocal local = null; // pega a instância do
	 * ServiceLocator.
	 * ServiceLocator locator = null;
	 * try { locator = ServiceLocator.getInstancia();
	 * localHome = (ControladorLocalidadeLocalHome) locator
	 * .getLocalHome(ConstantesJNDI.CONTROLADOR_LOCALIDADE_SEJB); // guarda a
	 * referencia de um objeto capaz de fazer chamadas à // objetos remotamente
	 * local = localHome.create();
	 * return local; } catch (CreateException e) { throw new
	 * SistemaException(e); } catch (ServiceLocatorException e) { throw new
	 * SistemaException(e); } }
	 */

	/**
	 * Retorna o valor de controladorFinanceiro
	 * 
	 * @return O valor de controladorLocalidade
	 */
	/*
	 * private ControladorFinanceiroLocal getControladorFinanceiro() {
	 * ControladorFinanceiroLocalHome localHome = null;
	 * ControladorFinanceiroLocal local = null; // pega a instância do
	 * ServiceLocator.
	 * ServiceLocator locator = null;
	 * try { locator = ServiceLocator.getInstancia();
	 * localHome = (ControladorFinanceiroLocalHome) locator
	 * .getLocalHome(ConstantesJNDI.CONTROLADOR_FINANCEIRO_SEJB); // guarda a
	 * referencia de um objeto capaz de fazer chamadas à // objetos remotamente
	 * local = localHome.create();
	 * return local; } catch (CreateException e) { throw new
	 * SistemaException(e); } catch (ServiceLocatorException e) { throw new
	 * SistemaException(e); } }
	 */

	/**
	 * Retorna o valor de controladorEndereco
	 * 
	 * @return O valor de controladorEndereco
	 */
	protected ControladorEnderecoLocal getControladorEndereco(){

		ControladorEnderecoLocalHome localHome = null;
		ControladorEnderecoLocal local = null;

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorEnderecoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_ENDERECO_SEJB);

			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Cria uma instância do controlador de imóvel
	 * 
	 * @author Vivianne Sousa
	 * @date 01/08/2007
	 * @return
	 */
	protected ControladorPermissaoEspecialLocal getControladorPermissaoEspecial(){

		ControladorPermissaoEspecialLocalHome localHome = null;
		ControladorPermissaoEspecialLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorPermissaoEspecialLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_PERMISSAO_ESPECIAL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorSpcSerasaSEJB
	 * 
	 * @return O valor de controladorSpcSerasa
	 */
	private ControladorSpcSerasaLocal getControladorSpcSerasa(){

		ControladorSpcSerasaLocalHome localHome = null;
		ControladorSpcSerasaLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorSpcSerasaLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_SPC_SERASA_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorRegistroAtendimentoSEJB
	 * 
	 * @return O valor de controladorRegistroAtendimento
	 */
	private ControladorRegistroAtendimentoLocal getControladorRegistroAtendimento(){

		ControladorRegistroAtendimentoLocalHome localHome = null;
		ControladorRegistroAtendimentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorRegistroAtendimentoLocalHome) locator
							.getLocalHome(ConstantesJNDI.CONTROLADOR_REGISTRO_ATENDIMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de ControladorTransacaoLocal
	 * 
	 * @return O valor de ControladorTransacaoLocal
	 */
	private ControladorTransacaoLocal getControladorTransacao(){

		ControladorTransacaoLocalHome localHome = null;
		ControladorTransacaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorTransacaoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_TRANSACAO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Cria uma instância do controlador de imóvel
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 15/02/2013
	 * @return
	 */
	private ControladorParametroSistema getControladorParametroSistema(){

		return (ControladorParametroSistema) SpringBeanLocator.getInstancia().getBeanPorID(
						ControladorParametroSistema.BEAN_ID_CONTROLADOR_PARAMETRO_SISTEMA);
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 30/01/2006, 23/11/2007
	 * @author Saulo Lima
	 * @date 02/12/2008
	 *       Alteração para tratar registros legados
	 * @author Saulo Lima
	 * @date 19/02/2009
	 *       Remover o retorno do método.
	 * @author Saulo Lima
	 * @date 27/02/2010
	 *       Tratamento da Ficha de Compensação a partir de novo método.
	 * @author Saulo Lima
	 * @date 21/05/2010
	 *       Alteração para evitar consulta desnecessária à base de dados
	 */
	public void registrarMovimentoArrecadadores(StringBuilder stringBuilderTxt, Arrecadador arrecadador, String idTipoMovimento,
					int quantidadeRegistros, int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;
		Collection collOperacaoContabilHelper = null;
		String numeroSequencialArquivo = "";

		try{

			// Registrar o início do processamento da unidade de processamento do batch
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.FUNCIONALIDADE, 0);
			System.out.println("**************** INÍCIO REGISTRAR MOVIMENTO ARRECADADORES ****************");

			AvisoBancario avisoBancario = null;

			// Recupera o parâmetro número de dígitos para matricula do imóvel na tabela de
			// parâmetros do sistema
			int numeroDigitosMatriculaImovel = Integer.valueOf(ParametroArrecadacao.P_NUMERO_DIGITOS_MATRICULA_IMOVEL.executar());

			if(idTipoMovimento != null && (idTipoMovimento.equals("DEBITO AUTOMATICO") || idTipoMovimento.equals("CODIGO DE BARRAS"))){

				// recupera o numeroSequencialArquivoEnvioDebitoAutomatico da tabela
				// ArrecadadorContrato
				// para ser inserido no arquivo de envio caso exista a coleção de
				// registros C
				Integer numeroSequencialArquivoEnvioDebitoAutomatico = null;

				// NSA do arquivo esperado
				Integer numeroSequencialArquivoEsperado = null;

				// [SB0001]-Validar Arquivo de Movimento de Arrecadador
				int tamanhoLinha = 150;

				boolean flagRetornoFichaCompensacao = false;
				boolean flagRetornoCodigoBarras = false;
				boolean flagRetornoDebitoAutomatico = false;
				boolean flagEnvioDebitoAutomatico = false;
				boolean indicadorAtualizaNSAParcelamentoResponsavel = false;
				boolean indicadorAtualizaNSADebitoAutomatico = false;

				// inicio da linha da string builder
				Integer inicioLinha = 0;

				// inicio da linha posterior ao registro A
				Integer inicioLinhaPosteriorRegA = 0;

				// inicio da linha anterior ao registro Z
				Integer inicioLinhaAnteriorRegZ = 0;

				// cria um boolean que verifica se é a primeira linha
				boolean primeiraLinha = true;

				// recupera o arrecadadorContrato para atualizar o numero
				// sequencial do arquivo
				ArrecadadorContrato arrecadadorContrato = null;

				Collection<ArrecadadorContrato> colecaoArrecadadorContrato = null;

				Collection<ArrecadadorContrato> colecaoArrecadadorContratoParcOrgPublico = null;

				String codigoConvenioArquivo = "";

				// verifica se existe o registro Z no arquivo
				boolean verificaRegistroZ = false;

				// inicializa um RegistroHelperCodigoA
				RegistroHelperCodigoA registroHelperCodigoA = null;

				// inicializa um RegistroHelperCodigoZ
				RegistroHelperCodigoZ registroHelperCodigoZ = null;

				short numeroSequencialAvisoBancario = 0;

				ArrecadadorMovimento arrecadadorMovimentoExistente = null;

				try{

					// recupera o sistema parametro
					SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

					for(int i = 1; i <= quantidadeRegistros; i++){

						String linha = stringBuilderTxt.substring(inicioLinha, inicioLinha + tamanhoLinha);

						// incrementa a primeira linha. O +1 é para tirar o
						inicioLinha = inicioLinha + tamanhoLinha + 1;

						// recupera o codigo do registro
						String codigoRegistro = linha.substring(0, 1);

						// verifica se é a primeira linha
						if(primeiraLinha){
							/*
							 * [SF0001] - Validar Arquivo de Movimento de
							 * Arrecadador Autor: Sávio Luiz Data: 31/01/2006
							 */

							inicioLinhaPosteriorRegA = inicioLinha;

							// verifica se o código do registro é diferente de
							// "A", caso seja encerra o caso de uso
							if(!codigoRegistro.toUpperCase().equals("A")){
								throw new ControladorException("atencao.arquivo.movimento.sem.header");
							}else{
								registroHelperCodigoA = (RegistroHelperCodigoA) distribuirdadosRegistroMovimentoArrecadador(linha, null);
							}

							String codigoConvenio = registroHelperCodigoA.getCodigoConvenio();
							if(codigoConvenio != null){
								codigoConvenioArquivo = codigoConvenio;
							}

							// verifica se o código da remessa é diferente de 2
							// caso seja encerra o caso de uso
							if(!registroHelperCodigoA.getCodigoRemessa().equals("2")){
								throw new ControladorException("atencao.codigo.remessa.invalido");
							}

							// verifica se o código do banco é diferente do
							// codigo do arrecadador caso seja encerra o caso de
							// uso
							Short codigoBancoTxt = Short.valueOf(registroHelperCodigoA.getCodigoBanco().trim());

							if(!codigoBancoTxt.equals(arrecadador.getCodigoAgente())){
								throw new ControladorException("atencao.movimento.nao.arrecadador", null, ""
												+ arrecadador.getCodigoAgente(), arrecadador.getCliente().getNome());
							}

							// verifica se o layout é diferente do layout da
							// tabela sistemaParematros
							Short versaoLayoutTxt = Short.valueOf(registroHelperCodigoA.getVersaoLayout().trim());

							if(versaoLayoutTxt > sistemaParametro.getNumeroLayoutFebraban()){
								throw new ControladorException("atencao.versao.arquivo.incalida");
							}

							// verifica se o tipo de movimento do txt é
							// diferente nulo
							if(registroHelperCodigoA.getTipoMovimento() != null && !registroHelperCodigoA.getTipoMovimento().equals("")){

								// verifica se o tipo de movimento selecionado é
								// diferente do tipo de movimento do txt
								if(!idTipoMovimento.equals("CODIGO DE BARRAS")){
									if(!registroHelperCodigoA.getTipoMovimento().trim().equals(idTipoMovimento)){
										throw new ControladorException("atencao.tipo.movimento.nao.selecionado");
									}
								}else{
									if(registroHelperCodigoA.getTipoMovimento().equals("DEBITO AUTOMATICO")){
										throw new ControladorException("atencao.tipo.movimento.nao.selecionado");
									}
								}

							}else{
								// nesse caso só pode ser CODIGO BARRAS então
								// faz a verificacao se o tipo selecionado é
								// diferente de DEBITO AUTOMATICO
								if(idTipoMovimento.equals("DEBITO AUTOMATICO")){
									throw new ControladorException("atencao.tipo.movimento.nao.selecionado");
								}
							}

							if(registroHelperCodigoA.getTipoMovimento().equals(ConstantesSistema.DEBITO_AUTOMATICO)){
								/*
								 * Caso o débito automático seja referente a parcelamento de órgão
								 * público (existe
								 * ocorrência na tabela ARRECADADOR_CONTRATO com ARRC_ID=ARRC_ID do
								 * arrecadador
								 * selecionado e ARCT_DTCONTRATOENCERRAMENTO com o valor nulo e
								 * ARCT_CDCONVENIOPARCELRESP=Campo A.03)
								 */
								colecaoArrecadadorContratoParcOrgPublico = repositorioArrecadacao
												.pesquisarNumeroSequecialArrecadadorContrato(arrecadador.getCodigoAgente(),
																codigoConvenioArquivo);

								if(!colecaoArrecadadorContratoParcOrgPublico.isEmpty()){

									/*
									 * Caso a empresa tenha um arrecadador próprio para fins de
									 * controle do recebimento dos
									 * parcelamentos de órgão público (PASI_VLPARAMETRO com o valor
									 * diferente de -1 na
									 * tabela PARAMETRO_SISTEMA com
									 * PASI_CDPARAMETRO=”P_ID_ARRECADADOR_PARCELAMENTO_RESPONSAVEL”
									 * ):
									 */
									String parametroIdArrecParcResponsavel = ParametroArrecadacao.P_ID_ARRECADADOR_PARCELAMENTO_RESPONSAVEL
													.executar().toString();

									if(!parametroIdArrecParcResponsavel.equals(ConstantesSistema.VALOR_NAO_INFORMADO)){

										// Obter dados do arrecadador adotado pela empresa para fins
										// de controle do
										// recebimento dos parcelamentos de órgão público
										FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
										Collection<Arrecadador> colArrecadadorConsultado = null;

										filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.ID,
														parametroIdArrecParcResponsavel));
										filtroArrecadador.adicionarCaminhoParaCarregamentoEntidade(FiltroArrecadador.CLIENTE);

										colArrecadadorConsultado = repositorioUtil
														.pesquisar(filtroArrecadador, Arrecadador.class.getName());

										if(!colArrecadadorConsultado.isEmpty()){

											/*
											 * Assumir o arrecadador adotado pela empresa para fins
											 * de controle do recebimento dos
											 * parcelamentos de órgão público como o arrecadador
											 * selecionado no passo 2.1. do Fluxo Principal.
											 */
											arrecadador = colArrecadadorConsultado.iterator().next();

											// Atualiza o campo Dados Complementares do Processo
											// Iniciado
											// ///////////////////////////////////////////////////////////
											Integer nsaEsperado = null;
											ArrecadadorContrato arrecadadorContratoParcelOrgPublico = colecaoArrecadadorContratoParcOrgPublico
															.iterator().next();
											if(arrecadadorContratoParcelOrgPublico.getNumeroSequencialArquivoRetornoDebitoAutomatico() != null){
												nsaEsperado = arrecadadorContratoParcelOrgPublico
																.getNumeroSequencialArquivoRetornoDebitoAutomatico() + 1;
											}

											ProcessoIniciadoDadoComplementarHelper helper = new ProcessoIniciadoDadoComplementarHelper();
											helper.adcionarDadoComplementar(DadoComplementarEnumerator.ARRECADADOR_CODIGO_AGENTE,
															arrecadador.getCodigoAgente());
											helper.adcionarDadoComplementar(DadoComplementarEnumerator.ARRECADACAO_ARRECADADOR, arrecadador
															.getCliente().getNome());
											helper.adcionarDadoComplementar(DadoComplementarEnumerator.ARRECADACAO_NSA_ESPERADO,
															Util.isVazioOuBranco(nsaEsperado) ? "NA" : nsaEsperado);
											helper.adcionarDadoComplementar(DadoComplementarEnumerator.ARRECADACAO_TIPO_MOVIMENTO,
															idTipoMovimento);
											helper.adcionarDadoComplementar(DadoComplementarEnumerator.ARRECADACAO_QUANTIDADE_REGISTROS,
															quantidadeRegistros);

											FiltroFuncionalidadeIniciada filtroFuncionalidadeIniciada = new FiltroFuncionalidadeIniciada();
											filtroFuncionalidadeIniciada.adicionarParametro(new ParametroSimples(
															FiltroFuncionalidadeIniciada.ID, idFuncionalidadeIniciada));
											filtroFuncionalidadeIniciada
															.adicionarCaminhoParaCarregamentoEntidade(FiltroFuncionalidadeIniciada.PROCESSO_INICIADO);

											Collection<FuncionalidadeIniciada> colFuncionalidadeIniciada = new ArrayList<FuncionalidadeIniciada>();

											// Consulta a funcionalidade iniciada
											colFuncionalidadeIniciada = repositorioUtil.pesquisar(filtroFuncionalidadeIniciada,
															FuncionalidadeIniciada.class.getName());

											ProcessoIniciado processoIniciado = null;
											if(!colFuncionalidadeIniciada.isEmpty()){
												processoIniciado = colFuncionalidadeIniciada.iterator().next().getProcessoIniciado();
											}

											processoIniciado.setDescricaoDadosComplementares(helper.getStringFormatoPesistencia());

											repositorioUtil.atualizar(processoIniciado);

										}
									}

								}
							}

							/*
							 * O sistema determina o número seqüencial do arquivo (NSA) esperado (a
							 * partir da tabela ARRECADADOR_CONTRATO com ARRC_ID=ARRC_ID do
							 * arrecadador selecionado e ARCT_DTCONTRATOENCERRAMENTO com o valor
							 * nulo).
							 */
							String codigoConvenioSemZero = Util.removerZerosEsquerda(codigoConvenio);

							if(arrecadadorContrato == null){
								colecaoArrecadadorContrato = repositorioArrecadacao.pesquisarNumeroSequecialArrecadadorContrato(
												arrecadador.getCodigoAgente(), null);

								if(!Util.isVazioOrNulo(colecaoArrecadadorContrato)){
									String codigoConvenioDebitoAutomatico = null;
									String codigoConvenioDebitoAutomaticoSemZero = null;

									String codigoConvenioParcelamentoResposavel = null;
									String codigoConvenioParcelamentoResposavelSemZero = null;

									String codigoConvenioContrato = null;
									String codigoConvenioContratoSemZero = null;

									for(ArrecadadorContrato arrecadadorContratoAux : colecaoArrecadadorContrato){
										if(registroHelperCodigoA.getTipoMovimento().equals(ConstantesSistema.DEBITO_AUTOMATICO)){

											codigoConvenioDebitoAutomatico = arrecadadorContratoAux.getCodigoConvenioDebitoAutomatico();
											codigoConvenioDebitoAutomaticoSemZero = Util
															.removerZerosEsquerda(codigoConvenioDebitoAutomatico);

											codigoConvenioParcelamentoResposavel = arrecadadorContratoAux
															.getCodigoConvenioParcelamentoResposavel();
											codigoConvenioParcelamentoResposavelSemZero = Util
															.removerZerosEsquerda(codigoConvenioParcelamentoResposavel);

											if(codigoConvenioDebitoAutomaticoSemZero != null && codigoConvenioSemZero != null
															&& codigoConvenioDebitoAutomaticoSemZero.equals(codigoConvenioSemZero)){

												numeroSequencialArquivoEsperado = arrecadadorContratoAux
																.getNumeroSequencialArquivoRetornoDebitoAutomatico();
												arrecadadorContrato = arrecadadorContratoAux;
												break;
											}else if(codigoConvenioParcelamentoResposavelSemZero != null && codigoConvenioSemZero != null
															&& codigoConvenioParcelamentoResposavelSemZero.equals(codigoConvenioSemZero)){

												numeroSequencialArquivoEsperado = arrecadadorContratoAux
																.getNumeroSequencialArquivoRetornoParcelamentoResposavel();
												arrecadadorContrato = arrecadadorContratoAux;
												break;
											}
										}else{
											codigoConvenioContrato = arrecadadorContratoAux.getCodigoConvenio();
											codigoConvenioContratoSemZero = Util.removerZerosEsquerda(codigoConvenioContrato);

											if(codigoConvenioContratoSemZero != null && codigoConvenioSemZero != null
															&& codigoConvenioContratoSemZero.equals(codigoConvenioSemZero)){

												numeroSequencialArquivoEsperado = arrecadadorContratoAux
																.getNumeroSequecialArquivoRetornoCodigoBarras();
												arrecadadorContrato = arrecadadorContratoAux;
												break;
											}
										}
									}
								}

								if(registroHelperCodigoA.getTipoMovimento().equals(ConstantesSistema.DEBITO_AUTOMATICO)){
									if(arrecadadorContrato != null){
										numeroSequencialArquivoEnvioDebitoAutomatico = arrecadadorContrato
														.getNumeroSequencialArquivoEnvioDebitoAutomatico();

										if(numeroSequencialArquivoEnvioDebitoAutomatico == null){
											numeroSequencialArquivoEnvioDebitoAutomatico = 0;
										}
									}else{
										log.error("codigoConvenioArquivo - DEBITO_AUTOMATICO - " + codigoConvenioArquivo);
										throw new ControladorException("atencao.movimento_debito_automatico_codigo_convenio_inexiste",
														null, codigoConvenioArquivo);

									}
								}else{
									if(arrecadadorContrato == null){
										log.error("codigoConvenioArquivo - CODIGO_BARRAS - " + codigoConvenioArquivo);
										throw new ControladorException("atencao.movimento_codigo_barras_codigo_convenio_inexiste", null,
														codigoConvenioArquivo);
									}
								}
							}

							if(numeroSequencialArquivoEsperado == null){

								numeroSequencialArquivoEsperado = Integer.valueOf(0);
							}

							/*
							 * Caso tipo de movimento (campo A.10) seja igual a “DEBITO
							 * AUTOMATICO”
							 */
							if(registroHelperCodigoA.getTipoMovimento().equals(ConstantesSistema.DEBITO_AUTOMATICO)){

								flagRetornoDebitoAutomatico = true;

								/*
								 * Caso o Código do Convênio do Movimento (Campo A.03) =
								 * ARCT_CDCONVENIODEBAUT
								 */
								if(arrecadadorContrato.getCodigoConvenioDebitoAutomatico() != null
												&& Util.removerZerosEsquerda(arrecadadorContrato.getCodigoConvenioDebitoAutomatico())
																.equals(codigoConvenioSemZero)){

									indicadorAtualizaNSADebitoAutomatico = true;

								}else if(arrecadadorContrato.getCodigoConvenioParcelamentoResposavel() != null
												&& Util.removerZerosEsquerda(arrecadadorContrato.getCodigoConvenioParcelamentoResposavel())
																.equals(codigoConvenioSemZero)){

									indicadorAtualizaNSAParcelamentoResponsavel = true;
								}

								/*
								 * Caso haja indicação de criticar o número seqüencial do
								 * arquivo
								 * (ARCT_ICCRITICARNSA com o valor 1 (sim) na tabela
								 * ARRECADADOR_CONTRATO)
								 */
								if(arrecadadorContrato.getIndicadorCriticarNumeroSequencialArquivo().equals(ConstantesSistema.SIM)){

									numeroSequencialArquivoEsperado += 1;
								}else{

									/*
									 * Caso contrário, ou seja, caso não haja indicação de
									 * criticar o número seqüencial do arquivo (ARCT_ICCRITICARNSA
									 * com o
									 * valor 2 (não) na tabela ARRECADADOR_CONTRATO)
									 */
									numeroSequencialArquivoEsperado = Util.obterInteger(registroHelperCodigoA.getNumeroSequencialArquivo());
								}

							}else{

								/*
								 * Caso contrário, o número seqüencial do arquivo (NSA) esperado =
								 * ARCT_NNNSARETORNOCDBARRAS + 1
								 */
								numeroSequencialArquivoEsperado += 1;
								flagRetornoCodigoBarras = true;

								/*
								 * Caso o Arrecadador em Questão seja do tipo ‘Criar NSA Cód.
								 * Barras’ Atribuir o NSA Atualizado do Arrecadador ao NSA do
								 * Arquivo de movimento em Questão
								 */
								if(arrecadadorContrato.getIndicadorCriarNumeroSequencialArquivoCodigoBarras().equals(ConstantesSistema.SIM)){

									registroHelperCodigoA.setNumeroSequencialArquivo(numeroSequencialArquivoEsperado.toString());
								}
							}

							/*
							 * Se consistir NSA (ARCT_ICCRITICARNSA da Tabela
							 * ARRECADADOR_CONTRATO=1)
							 */
							if(arrecadadorContrato.getIndicadorCriticarNumeroSequencialArquivo().equals(ConstantesSistema.SIM)){

								/*
								 * Caso o número seqüencial do arquivo (NSA) (campo A.08) não seja
								 * igual ao o número seqüencial do arquivo (NSA) esperado
								 */
								if(!Integer.valueOf(registroHelperCodigoA.getNumeroSequencialArquivo()).equals(
												numeroSequencialArquivoEsperado)){

									numeroSequencialArquivo = registroHelperCodigoA.getNumeroSequencialArquivo();

									throw new ControladorException("atencao.arquivo.movimento.fora.sequencia");
								}
							}else if(Util.isInteger(registroHelperCodigoA.getNumeroSequencialArquivo())){

								numeroSequencialArquivoEsperado = Util.obterInteger(registroHelperCodigoA.getNumeroSequencialArquivo());
							}

							/*
							 * Verificar a já existência do Movimento em Questão na tabela
							 * ARRECADADOR_MOVIMENTO
							 */
							arrecadadorMovimentoExistente = repositorioArrecadacao.pesquisaArrecadadorMovimentoExistente(
											arrecadador.getCodigoAgente(), codigoConvenio,
											Util.obterInteger(registroHelperCodigoA.getNumeroSequencialArquivo()));

							if(arrecadadorMovimentoExistente != null){

								throw new ControladorException("atencao.movimento_ja_processado", null,
												registroHelperCodigoA.getCodigoBanco(), registroHelperCodigoA.getTipoMovimento(),
												registroHelperCodigoA.getNumeroSequencialArquivo());
							}

							if(arrecadador != null && registroHelperCodigoA.getDataGeracaoArquivo() != null){

								Date dataGeracao = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA
												.getDataGeracaoArquivo());

								Short valorMaximoNumeroSequencia = null;
								valorMaximoNumeroSequencia = repositorioArrecadacao.pesquisarValorMaximoNumeroSequencial(dataGeracao,
												arrecadador.getId().toString());

								if(valorMaximoNumeroSequencia != null){
									numeroSequencialAvisoBancario = (short) (valorMaximoNumeroSequencia.shortValue() + 1);
								}

							}else{
								numeroSequencialAvisoBancario = 0;
							}

							// depois de ler a primeira linha atribui ela para
							// falso
							primeiraLinha = false;

						}else{

							// verifica se o código do registro é "A", caso seja
							// então não existe o codigo do registro "Z" e
							// encerra o caso de uso
							if(codigoRegistro.toUpperCase().equals("A")){
								throw new ControladorException("atencao.arquivo.movimento.nao.codigo.z");
							}
							if(registroHelperCodigoA.getTipoMovimento() != null && !registroHelperCodigoA.getTipoMovimento().equals("")){

								// caso o tipo de medição seja igual a DEBITO
								// AUTOMATICO
								if(registroHelperCodigoA.getTipoMovimento().equals("DEBITO AUTOMATICO")){

									// caso exista no arquivo codigo do registro
									// igual de "G"
									if(codigoRegistro.toUpperCase().equals("G")){
										throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
									}

								}else{
									// caso exista no arquivo codigo do registro
									// diferente de "A" , "G" , "Z"
									if(!codigoRegistro.toUpperCase().equals("A") && !codigoRegistro.toUpperCase().equals("G")
													&& !codigoRegistro.toUpperCase().equals("Z")){
										throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
									}
								}
							}else{
								// caso exista no arquivo codigo do registro
								// diferente de "A" , "G" , "Z"
								if(!codigoRegistro.toUpperCase().equals("A") && !codigoRegistro.toUpperCase().equals("G")
												&& !codigoRegistro.toUpperCase().equals("Z")){
									throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
								}
							}

							// verifica se o código do registro é diferente de
							// "Z", caso seja então adiciona
							// a linha na coleção de linhas para depois serem
							// processadas
							if(!codigoRegistro.toUpperCase().equals("Z")){

								inicioLinhaAnteriorRegZ = inicioLinha - tamanhoLinha - 1;

							}else{
								// se entrou no else então é porque tem registro
								// Z então seta o boolean para true
								verificaRegistroZ = true;

								// caso código do registro seja "Z" então
								// processa a coleção
								// de linhas e inseri o movimento de
								// arrecadadores
								registroHelperCodigoZ = (RegistroHelperCodigoZ) distribuirdadosRegistroMovimentoArrecadador(linha, null);
								// caso a quantidade de registros for diferente
								// da
								// quantidade de registros do txt então ecerra o
								// caso de uso
								if(Integer.parseInt(registroHelperCodigoZ.getTotalRegistrosArquivo().trim()) != i){
									throw new ControladorException("atencao.total.registros.invalido");
								}

								break;

							} // codigoRegistro == "Z"

						} // !primeiraLinha

					} // for (quantidadeRegistros)

					System.out.println("0 - quantidadeRegistros = " + quantidadeRegistros);

					// caso não exista o registro Z.
					if(!verificaRegistroZ){
						throw new ControladorException("atencao.arquivo.movimento.nao.codigo.z");
					}

					// Coleção dos registros C para serem mandados para o acrrecadador
					Collection<RegistroHelperCodigoC> colecaoCodigoRegistrosC = new ArrayList<RegistroHelperCodigoC>();

					// cria uma coleção de avisos bancarios
					Collection<AvisoBancario> avisosBancarios = new ArrayList<AvisoBancario>();

					// cria uma coleção de pagamentos
					Collection<Pagamento> pagamentos = new ArrayList<Pagamento>();

					// cria uma coleção de devolucoes
					Collection<Devolucao> devolucoes = new ArrayList<Devolucao>();

					BigDecimal valorArrecadacaoInformado = Util
									.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoZ
													.getValorTotalRegistrosArquivo());

					// [SF0002] - Inserir o movimento do arrecadador
					// Autor: Sávio Luiz
					// Data: 31/01/2006

					Map<String, Integer> mapFormasArrecadacao = new TreeMap<String, Integer>();
					Collection<ArrecadacaoForma> collFormasArrecadacao = this.getControladorUtil().pesquisar(new FiltroArrecadacaoForma(),
									ArrecadacaoForma.class.getName());

					if(collFormasArrecadacao != null && !collFormasArrecadacao.isEmpty()){
						for(ArrecadacaoForma arrecadacaoForma : collFormasArrecadacao){
							mapFormasArrecadacao.put(arrecadacaoForma.getCodigoArrecadacaoForma(), arrecadacaoForma.getId());
						}
						collFormasArrecadacao.clear();
					}
					collFormasArrecadacao = null;

					ArrecadadorMovimento arrecadadorMovimento = null;
					arrecadadorMovimento = inserirMovimentoArrecadador(registroHelperCodigoA, registroHelperCodigoZ, idTipoMovimento,
									arrecadador);

					Date dataGeracao = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA.getDataGeracaoArquivo());

					// cria uma variavel da descrição da ocorrencia do
					// movimento com o valor setado para OK
					String descricaoOcorrenciaMovimento = "OK";

					// cria uma variavel do indicador de aceitação do
					// registro do movimento
					int indicadorAceitacaoRegistroMovimento = 1;

					inicioLinha = inicioLinhaPosteriorRegA;

					long numlinha = 1;

					while(inicioLinha <= inicioLinhaAnteriorRegZ){

						numlinha++;

						String linha = stringBuilderTxt.substring(inicioLinha, inicioLinha + tamanhoLinha);

						// incrementa a primeira linha. O +1 é para tirar o
						// System.getProperty("line.separator")
						inicioLinha = inicioLinha + tamanhoLinha + 1;

						// cria uma variavel da descrição da
						// ocorrencia do movimento com o valor
						// setado para OK
						descricaoOcorrenciaMovimento = "OK";

						// cria uma variavel do indicador de
						// aceitação do registro do movimento
						indicadorAceitacaoRegistroMovimento = 1;

						// cria uma variavel para validar data
						boolean dataInvalida = false;

						boolean valorDebitoInvalido = false;

						Date dataDebito = null;

						String matriculaImovel = null;

						final char b = 'B';
						final char f = 'F';
						final char g = 'G';
						final char x = 'X';

						// recupera o código do registro de cada
						// linha
						char codigoRegistroChar = linha.substring(0, 1).toUpperCase().charAt(0);

						switch(codigoRegistroChar){

						// ########## B ##########
							case b:
								/*
								 * [SF0003] - Processar Registro
								 * Código B Autor: Sávio Luiz Data:
								 * 31/01/2006
								 */
								RegistroHelperCodigoB registroHelperCodigoB = (RegistroHelperCodigoB) distribuirdadosRegistroMovimentoArrecadador(
												linha, null);

								// verifica se o código de movimento
								// é diferente de null
								if(!registroHelperCodigoB.getCodigoMovimento().equals("1")
												&& !registroHelperCodigoB.getCodigoMovimento().equals("2")){
									descricaoOcorrenciaMovimento = "CÓDIGO DE MOVIMENTO INVÁLIDO";
								}

								// valida a data
								dataInvalida = Util.validarAnoMesDiaSemBarra(registroHelperCodigoB.getDataOpcaoExclusao());
								if(dataInvalida){
									descricaoOcorrenciaMovimento = "DATA DE OPÇÃO/EXCLUSÃO INVÁLIDA";
								}

								// caso a quantidade de dígitos da matricula do imovel seja
								// diferente do parâmetro ”P_NUMERO_DIGITOS_MATRICULA_IMOVEL”
								if(registroHelperCodigoB.getIdClienteEmpresa() != null
												&& registroHelperCodigoB.getIdClienteEmpresa().length() != numeroDigitosMatriculaImovel){
									descricaoOcorrenciaMovimento = "MAT DO IMÓVEL NÃO CONTÉM A QTD DE DÍGITOS ADOTADA";
								}

								// caso a descricao de movimento
								// seja igual a OK
								if(descricaoOcorrenciaMovimento.equals("OK")){

									// matricula do imóvel com os
									// ”P_NUMERO_DIGITOS_MATRICULA_IMOVEL”
									// primeiros digitos da
									// identificação do cliente na
									// empresa
									matriculaImovel = registroHelperCodigoB.getIdClienteEmpresa().trim();

									// Código do banco
									String codigoBanco = registroHelperCodigoA.getCodigoBanco();

									// Código da agencia
									String codigoAgencia = registroHelperCodigoB.getAgenciaDebito();

									// identificação do cliente no
									// banco
									String identificacaoCliente = registroHelperCodigoB.getIdClienteBanco();

									Date dataExcluso = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoB
													.getDataOpcaoExclusao());

									String descricaoOcorrenciaMovimentoAux = "";

									// caso o código do movimento
									// corresponda a exclusão(1)
									if(registroHelperCodigoB.getCodigoMovimento().equals("1")){

										// processar exclusão
										descricaoOcorrenciaMovimento = this.getControladorCobranca().removerDebitoAutomatico(
														matriculaImovel, codigoBanco, codigoAgencia, identificacaoCliente, dataExcluso,
														Usuario.USUARIO_BATCH);
									}else{

										if(registroHelperCodigoB.getCodigoMovimento().equals("2")){
											// processar inclusão
											String[] retornoInclusao = this.getControladorCobranca().inserirDebitoAutomatico(
															matriculaImovel, codigoBanco, codigoAgencia, identificacaoCliente, dataExcluso);

											descricaoOcorrenciaMovimento = retornoInclusao[0];
											descricaoOcorrenciaMovimentoAux = retornoInclusao[1];
										}
									}

									// caso a descricao de movimento
									// não seja igual a OK
									if(!descricaoOcorrenciaMovimento.equals("OK")){

										// seta o indicador de
										// aceitação do registro do
										// movimento para 2(NÃO)
										indicadorAceitacaoRegistroMovimento = 2;

										// adiciona a linha do
										// registro na colecao
										// codigoRegistrosC quando o
										// método
										// distribuirdadosRegistroMovimentoArrecadador
										// é chamado passando
										// a
										// descricaoOcorrenciaMovimento
										// então é retornado um
										// registro do tipo C
										RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) distribuirdadosRegistroMovimentoArrecadador(
														linha, descricaoOcorrenciaMovimento);

										// seta o objeto
										// registroHelperCodigoC na
										// coleção
										colecaoCodigoRegistrosC.add(registroHelperCodigoC);
									}else{
										if(!Util.isVazioOuBranco(descricaoOcorrenciaMovimentoAux)){
											descricaoOcorrenciaMovimento = descricaoOcorrenciaMovimentoAux;
										}
									}

								}else{

									// seta o indicador de aceitação
									// do registro do movimento para
									// 2(NÃO)
									indicadorAceitacaoRegistroMovimento = 2;

									// adiciona a linha do registro
									// na colecao codigoRegistrosC
									// quando o método
									// distribuirdadosRegistroMovimentoArrecadador
									// é chamado passando
									// a
									// descricaoOcorrenciaMovimento
									// então é retornado um registro
									// do tipo C
									RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) distribuirdadosRegistroMovimentoArrecadador(
													linha, descricaoOcorrenciaMovimento);

									// seta o objeto
									// registroHelperCodigoC na
									// coleção
									colecaoCodigoRegistrosC.add(registroHelperCodigoC);
								}

								// inseri o item movimento
								// arrecadador
								inserirItemMovimentoArrecadador(linha, arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
												indicadorAceitacaoRegistroMovimento, null);
								break;

							// ########## F ##########
							case f:
								/*
								 * [SF0004] - Processar Registro
								 * Código F Autor: Sávio Luiz Data:
								 * 31/01/2006
								 */

								RegistroHelperCodigoF registroHelperCodigoF = (RegistroHelperCodigoF) this
												.distribuirdadosRegistroMovimentoArrecadador(linha, null);

								this.processarRegistroCodigoF(registroHelperCodigoF, sistemaParametro, linha, arrecadadorMovimento,
												indicadorAceitacaoRegistroMovimento, registroHelperCodigoA, dataGeracao, avisosBancarios,
												numeroSequencialAvisoBancario, registroHelperCodigoZ, pagamentos, numlinha,
												arrecadadorContrato, arrecadador);
								break;

							// ########## G ##########
							case g:
								/*
								 * [SF0005] - Processar Registro
								 * Código G Autor: Sávio Luiz Data:
								 * 31/01/2006
								 */
								RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) distribuirdadosRegistroMovimentoArrecadador(
												linha, null);

								// -------------------------------------------------------------------------------
								// validação do registro G
								// -------------------------------------------------------------------------------
								boolean dataExcludentes = false;

								// valida a data
								dataInvalida = Util.validarAnoMesDiaSemBarra(registroHelperCodigoG.getDataPagamento());
								if(dataInvalida){
									dataExcludentes = true;
									descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO INVÁLIDA";
								}

								// caso a data seja inválida não
								// verifica se é maior que a data
								// atual
								if(!dataExcludentes){

									// verifica se a data de
									// bedito/pagamento é superior a
									// atual
									dataDebito = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoG.getDataPagamento());
									if(dataDebito.after(new Date())){
										descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO POSTERIOR A DATA CORRENTE";
									}
								}

								// validar data de credito
								dataInvalida = Util.validarAnoMesDiaSemBarra(registroHelperCodigoG.getDataPrevistaCredito());
								if(dataInvalida){
									descricaoOcorrenciaMovimento = "DATA DE CRÉDITO INVÁLIDA";
								}

								// valida o valor recebido
								valorDebitoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoG.getValorRecebido());
								if(valorDebitoInvalido){
									descricaoOcorrenciaMovimento = "VALOR DEBITADO/RECEBIDO NÃO NUMÉRICO";
								}
								// -------------------------------------------------------------------------------

								// -------------------------------------------------------------------------------
								// caso a descricao de movimento
								// seja igual a OK
								// -------------------------------------------------------------------------------
								if(descricaoOcorrenciaMovimento.equals("OK")){

									String codigoBarras = registroHelperCodigoG.getCodigoBarras();
									Integer idFormaPagamento = mapFormasArrecadacao.get(registroHelperCodigoG.getCodigoFormaArrecadacao());

									if(idFormaPagamento == null){
										idFormaPagamento = ArrecadacaoForma.GUICHE_CAIXA;
									}

									String subStringIdPagamento = codigoBarras.substring(19, 44);

									Integer idConcessionaria = null;

									if(arrecadadorContrato != null){
										Concessionaria concessionaria = arrecadadorContrato.getConcessionaria();

										if(concessionaria != null){
											idConcessionaria = concessionaria.getId();
										}
									}

									// [UC0259]- Processar Pagamento com Código de Barras
									PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = processarPagamentosCodigoBarras(
													registroHelperCodigoG.getRegistroHelperCodigoBarras(), dataDebito, idFormaPagamento,
													sistemaParametro, subStringIdPagamento, idConcessionaria);

									// seta a descricao da
									// occerencia do caso de uso
									// [UC0259] - Processar
									// Pagamento com Código de
									// Barras
									descricaoOcorrenciaMovimento = pagamentoHelperCodigoBarras.getDescricaoOcorrencia();

									// seta o indicador daaceitação
									// do caso de uso [UC0259] -
									// Processar Pagamento com
									// Código de Barras
									indicadorAceitacaoRegistroMovimento = Integer.parseInt(pagamentoHelperCodigoBarras
													.getIndicadorAceitacaoRegistro());

									// caso o indicador de aceitação
									// for igual a 1(SIM)
									Short numeroDiasFloat = null;
									Integer codigoBanco = Integer.valueOf(registroHelperCodigoA.getCodigoBanco());

									// verifica se a data prevista é
									// zero, se for calcula a data
									// prevista
									if(Integer.parseInt(registroHelperCodigoG.getDataPrevistaCredito()) == 0){
										if(arrecadadorContrato != null){
											Integer idArrecadadorContrato = arrecadadorContrato.getId();

											numeroDiasFloat = repositorioArrecadacao.pesquisarNumeroDiasFloat(idArrecadadorContrato,
															idFormaPagamento);
										}
									}else{
										numeroDiasFloat = 0;
									}

									// verifica se a data de
									// debito/pagamento é superior a
									// atual
									Date dataPrevistaCredito = Util.adicionarNumeroDiasDeUmaData(dataDebito, numeroDiasFloat);

									// -------------------------------------------------------------------------------
									// Tratamento do Aviso Bancário
									// -------------------------------------------------------------------------------
									// pesquisa o aviso bancario
									// passando o código do banco a
									// data de geração do
									// arquivo e a data prevista
									// calculada

									avisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(codigoBanco, dataGeracao,
													dataPrevistaCredito, arrecadadorMovimento.getId());

									// recupera o valor debitado
									// formatado como bigDecimal
									BigDecimal valorDebito = Util
													.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoG
																	.getRegistroHelperCodigoBarras().getValorPagamento());

									// 3.4.4.Parte que determina os
									// valores calculado e informado
									// do pagamento e da devolução
									BigDecimal valorCalcPagamento = BigDecimal.ZERO;
									BigDecimal valorCalcDevolucao = BigDecimal.ZERO;
									BigDecimal valorInfPagamento = valorDebito;
									BigDecimal valorInfDevolucao = BigDecimal.ZERO;

									if(indicadorAceitacaoRegistroMovimento == 1){

										Integer idImovelPagamento = null;
										if(pagamentoHelperCodigoBarras.getColecaoPagamentos() != null
														&& !pagamentoHelperCodigoBarras.getColecaoPagamentos().isEmpty()){
											Pagamento pagamento = (Pagamento) Util.retonarObjetoDeColecao(pagamentoHelperCodigoBarras
															.getColecaoPagamentos());
											if(pagamento.getImovel() != null && pagamento.getImovel().getId() != null){
												idImovelPagamento = pagamento.getImovel().getId();
											}
										}

										// inseri o item movimento
										// arrecadador
										Integer idArrecadadorMovimentoItem = inserirItemMovimentoArrecadador(linha,
														arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
														indicadorAceitacaoRegistroMovimento, idImovelPagamento);

										ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
										arrecadadorMovimentoItem.setId(idArrecadadorMovimentoItem);

										// verifica seo aviso
										// bancario é diferente de
										// nulo
										if(avisoBancario != null){

											// recupera a coleção de
											// pagamentos do caso de
											// uso
											// [UC0259] - Processar
											// Pagamento com Código
											// de Barras
											// para setar o aviso
											// bancário no objeto
											// pagamento
											Collection<Pagamento> pagamentosCodigoBarras = pagamentoHelperCodigoBarras
															.getColecaoPagamentos();
											Iterator<Pagamento> pagamentosCodigoBarraIterator = pagamentosCodigoBarras.iterator();

											while(pagamentosCodigoBarraIterator.hasNext()){
												Pagamento pagamento = pagamentosCodigoBarraIterator.next();

												// adiciona o valor
												// de pagamento
												valorCalcPagamento = valorCalcPagamento.add(pagamento.getValorPagamento());

												pagamento.setAvisoBancario(avisoBancario);

												pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

												// adiciona o
												// pagamento na
												// coleção de
												// pagamentos
												pagamentos.add(pagamento);
											}

											/*
											 * Alterado por Raphael
											 * Rossiter em
											 * 31/10/2007 -
											 * Analista: Aryed Lins
											 * Recupera uma coleção
											 * de devoluções do caso
											 * de uso [UC0259] -
											 * Processar Pagamento
											 * com Código de Barras
											 */
											Collection<Devolucao> colecaoDevolucaoCodigoBarras = pagamentoHelperCodigoBarras
															.getColecaoDevolucao();

											if(colecaoDevolucaoCodigoBarras != null && !colecaoDevolucaoCodigoBarras.isEmpty()){

												for(Devolucao devolucao : colecaoDevolucaoCodigoBarras){

													// Adiciona o
													// valor de
													// devolução
													valorCalcDevolucao = valorCalcDevolucao.add(devolucao.getValorDevolucao());

													// Adiciona o
													// AvisoBancario
													devolucao.setAvisoBancario(avisoBancario);

													// Movimento
													devolucao.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

													// Adiciona a
													// devolucao na
													// coleção final
													// de devoluções
													devolucoes.add(devolucao);
												}

											}

										}else{
											// recupera a coleção de
											// pagamentos do caso de
											// uso
											// [UC0259] - Processar
											// Pagamento com Código
											// de Barras
											// para setar o aviso
											// bancário no objeto
											// pagamento
											Collection<Pagamento> pagamentosCodigoBarras = pagamentoHelperCodigoBarras
															.getColecaoPagamentos();
											Iterator<Pagamento> pagamentosCodigoBarraIterator = pagamentosCodigoBarras.iterator();

											while(pagamentosCodigoBarraIterator.hasNext()){

												Pagamento pagamento = pagamentosCodigoBarraIterator.next();
												pagamento.setLinhaArrecadacao(numlinha);

												// seta o aviso
												// bancario para
												// null
												pagamento.setAvisoBancario(null);

												// seta o valor da
												// data prevista
												// para quando for
												// inserir o
												// pagamento saber
												// de que aviso
												// bancário o
												// pagamento está
												// relacionádo.
												pagamento.setDataPrevistaCreditoHelper(dataPrevistaCredito);

												pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

												// adiciona o
												// pagamento na
												// coleção de
												// pagamentos
												pagamentos.add(pagamento);
											}

											/*
											 * Alterado por Raphael
											 * Rossiter em
											 * 31/10/2007 -
											 * Analista: Aryed Lins
											 * Recupera uma coleção
											 * de devoluções do caso
											 * de uso [UC0259] -
											 * Processar Pagamento
											 * com Código de Barras
											 */
											Collection<Devolucao> colecaoDevolucaoCodigoBarras = pagamentoHelperCodigoBarras
															.getColecaoDevolucao();

											if(colecaoDevolucaoCodigoBarras != null && !colecaoDevolucaoCodigoBarras.isEmpty()){

												for(Devolucao devolucao : colecaoDevolucaoCodigoBarras){
													/*
													 * Seta o valor
													 * da data
													 * prevista para
													 * quando for
													 * inserir o
													 * pagamento
													 * saber de que
													 * aviso
													 * bancário o
													 * pagamento
													 * está
													 * relacionádo.
													 */
													devolucao.setDataPrevistaCreditoHelper(dataPrevistaCredito);

													// Movimento
													devolucao.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

													// Adiciona a
													// devolucao na
													// coleção final
													// de devoluções
													devolucoes.add(devolucao);
												}

											}
										}

									}else{
										// inserir o item movimento
										// arrecadador
										inserirItemMovimentoArrecadador(linha, arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
														indicadorAceitacaoRegistroMovimento, null);
									}

									boolean achou = false;
									if(avisoBancario != null){
										// se for atualiza o valor
										// da arrecadação no aviso
										// bancario
										avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);
										avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInformado);
										avisoBancario.setUltimaAlteracao(new Date());
									}else{
										Iterator avisosBancarioIterator = avisosBancarios.iterator();

										// cria um boolean para
										// saber se existe algum
										// aviso bancario da coleção
										// com a mesma data prevista
										// da data prevista
										// calculada anteriormente
										while(avisosBancarioIterator.hasNext()){
											AvisoBancario avisoBancarioDaColecao = (AvisoBancario) avisosBancarioIterator.next();
											boolean comparaDataIguais = Util.datasIguais(avisoBancarioDaColecao.getDataPrevista(),
															dataPrevistaCredito);
											if(comparaDataIguais){
												avisoBancarioDaColecao.setValorArrecadacaoInformado(valorArrecadacaoInformado);
												achou = true;
												break;
											}
										}
									}
									if(!achou){
										// chama o método para cria
										// o objeto do aviso
										// bancário
										avisoBancario = gerarOcorrenciaAvisoBancario(arrecadadorMovimento.getId(), registroHelperCodigoA,
														dataPrevistaCredito, registroHelperCodigoZ.getValorTotalRegistrosArquivo(),
														sistemaParametro.getAnoMesArrecadacao(), registroHelperCodigoA.getCodigoBanco(),
														valorCalcPagamento, valorInfPagamento, valorCalcDevolucao, valorInfDevolucao,
														numeroSequencialAvisoBancario, arrecadadorContrato, arrecadador);

										numeroSequencialAvisoBancario += 1;
										avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);
										// adiciona o aviso bancário
										// na coleção de avisos
										// bancários
										avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInformado);
										avisosBancarios.add(avisoBancario);
									}

								}else{

									// seta o indicador de aceitação
									// do registro do movimento para
									// 2(NÃO)
									indicadorAceitacaoRegistroMovimento = 2;

									// inseri o item movimento
									// arrecadador
									inserirItemMovimentoArrecadador(linha, arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
													indicadorAceitacaoRegistroMovimento, null);

								}
								break;

							// ########## X ##########
							case x:
								/*
								 * [SF0007] - Processar Registro
								 * Código X Autor: Sávio Luiz Data:
								 * 21/02/2006
								 */

								RegistroHelperCodigoX registroHelperCodigoX = (RegistroHelperCodigoX) distribuirdadosRegistroMovimentoArrecadador(
												linha, null);

								Agencia agencia = null;

								try{
									agencia = repositorioArrecadacao.pesquisarAgencia(registroHelperCodigoX.getCodigoAgencia(),
													Integer.valueOf(registroHelperCodigoA.getCodigoBanco()));
								}catch(NumberFormatException e){
									agencia = null;
								}

								// caso exista agencia então
								// atualiza a agencia
								if(agencia != null){

									// nome da agencia
									agencia.setNomeAgencia(registroHelperCodigoX.getNomeAgencia());

									// id do cep
									Cep cep = null;
									try{
										cep = getControladorEndereco().pesquisarCep(
														Integer.valueOf(registroHelperCodigoX.getCodigoCep()
																		+ registroHelperCodigoX.getSufixoCep()));
									}catch(NumberFormatException e){
										cep = null;
									}

									if(cep != null){
										agencia.setCep(cep);
									}

									// numero do imovel
									agencia.setNumeroImovel(registroHelperCodigoX.getNumero());

									// numero do imovel
									agencia.setUltimaAlteracao(new Date());

									// atualiza a agencia na base
									getControladorUtil().atualizar(agencia);

								}else{

									// caso não exista agencia então
									// cria uma agencia com os dados
									// do arquivo
									agencia = new Agencia();
									agencia.setCodigoAgencia(registroHelperCodigoX.getCodigoAgencia());
									Banco banco = new Banco();
									banco.setId(Util.converterStringParaInteger(registroHelperCodigoA.getCodigoBanco()));
									agencia.setBanco(banco);

									// nome da agencia
									agencia.setNomeAgencia(registroHelperCodigoX.getNomeAgencia());
									agencia.setNumeroTelefone("0");

									// numero do imovel
									agencia.setNumeroImovel(registroHelperCodigoX.getNumero());

									// id do cep
									Cep cep = null;
									try{
										cep = getControladorEndereco().pesquisarCep(
														Integer.valueOf(registroHelperCodigoX.getCodigoCep()
																		+ registroHelperCodigoX.getSufixoCep()));
									}catch(NumberFormatException e){
										cep = null;
									}

									if(cep != null && !cep.equals("")){
										agencia.setCep(cep);
									}

									EnderecoReferencia endenrecoReferencia = new EnderecoReferencia();
									endenrecoReferencia.setId(EnderecoReferencia.NUMERO);
									agencia.setEnderecoReferencia(endenrecoReferencia);
									agencia.setUltimaAlteracao(new Date());

									// inseri a agencia na base
									getControladorUtil().inserir(agencia);
								}

								// inseri o item movimento
								// arrecadador
								inserirItemMovimentoArrecadador(linha, arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
												indicadorAceitacaoRegistroMovimento, null);

								break;

							// caso não tenha sido nenhuma das
							// opções anteriores
							// ########## DEFAULT ##########
							default:
								descricaoOcorrenciaMovimento = "CÓDIGO DE MOVIMENTO NÃO IDENTIFICADO";

								// o indicador de aceitação é setado
								// para 2(NÃO)
								indicadorAceitacaoRegistroMovimento = 2;

								// inseri o item movimento
								// arrecadador
								inserirItemMovimentoArrecadador(linha, arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
												indicadorAceitacaoRegistroMovimento, null);
						} // switch case

					} // loop linhas detalhes

					// verifica se a coleção de registros C é
					// diferente de nulo, null
					if(colecaoCodigoRegistrosC != null && !colecaoCodigoRegistrosC.isEmpty()){

						// cria um arquivo para mandar para o banco
						// com os registros do tipo c
						gerarArquivoRegistrosTipoC(registroHelperCodigoA, registroHelperCodigoZ, colecaoCodigoRegistrosC,
										numeroSequencialArquivoEnvioDebitoAutomatico, descricaoOcorrenciaMovimento,
										indicadorAceitacaoRegistroMovimento, idTipoMovimento, arrecadador);
					}

					// verifica se a coleção de avisos bancario é
					// diferente de nulo
					if(avisosBancarios != null && !avisosBancarios.isEmpty()){
						Iterator avisosBancarioIterator = avisosBancarios.iterator();
						while(avisosBancarioIterator.hasNext()){
							AvisoBancario avisoBanc = (AvisoBancario) avisosBancarioIterator.next();

							// inserir o aviso bancário na base e
							// recupera o id
							Integer idAvisoBancario = (Integer) getControladorUtil().inserir(avisoBanc);
							avisoBanc.setId(idAvisoBancario);
						}
					}

					// verifica se a coleção de pagamentos está
					// diferente de nulo
					if(pagamentos != null && !pagamentos.isEmpty()){

						collOperacaoContabilHelper = new ArrayList();

						Iterator pagamentoIterator = pagamentos.iterator();
						while(pagamentoIterator.hasNext()){
							Pagamento pagamento = (Pagamento) pagamentoIterator.next();

							// verifica se existe o aviso bancario
							// no pagamento, se não existe então
							// seta o aviso bancario no pagamento
							if(pagamento.getAvisoBancario() == null){
								Iterator avisosBancarioIterator = avisosBancarios.iterator();
								while(avisosBancarioIterator.hasNext()){
									AvisoBancario avisoBanc = (AvisoBancario) avisosBancarioIterator.next();
									// avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
									// avisoBancario.adicionarUsuario(usuario,
									// usuarioAcao);

									// caso a data prevista seja a
									// mesma estão seta o aviso
									// bancário no pagamento
									boolean comparaDataIguais = Util.datasIguais(pagamento.getDataPrevistaCreditoHelper(),
													avisoBanc.getDataPrevista());
									if(comparaDataIguais){
										pagamento.setAvisoBancario(avisoBanc);
										break;
									}
								}
							}

						}

						getControladorBatch().inserirColecaoObjetoParaBatch((Collection) pagamentos);

						// 11. Para cada pagamento da coleção
						// inserido o sistema efetua a classificação
						// do pagamento <<Inclui>>
						// [UC0300 –
						// ClassificarPagamentosDevolucoes] - PARTE
						// 1

						Pagamento pagtoAux = null;

						try{

							if(pagamentos != null && !pagamentos.isEmpty()){

								for(Pagamento pagamento : (Collection<Pagamento>) pagamentos){

									pagtoAux = pagamento;

									// [SB0021 – Verificar correspondência do pagamento com item de
									// negativação]
									if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)
													|| pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.FATURA_CLIENTE)){
										this.getControladorSpcSerasa().atualizarItemDaNegativacao(pagamento.getAnoMesReferenciaPagamento(),
														pagamento.getImovel(), CobrancaDebitoSituacao.PAGO, pagamento.getDataPagamento(),
														pagamento.getValorPagamento(), Boolean.FALSE, ConstantesSistema.SIM);
									}

									this.classificarPagamentosRegistroMovimentoArrecadadores(pagamento);

									// --------------------------------------------------------------------
									// Preparar operação para : [Registra o Lançamento Contábil].
									// --------------------------------------------------------------------

									OperacaoContabilHelper helper = this.definirOrigemOperacaoContabilPagamento(pagamento, false);

									collOperacaoContabilHelper.add(helper);

									// --------------------------------------------------------------------

								}

								// System.out.println("Quantidade1: " + idsDebitoACobrar.size());
								// if(!Util.isVazioOrNulo(idsDebitoACobrar)){
								//
								// if(idsDebitoACobrar.size() > 1000){
								// Collection<Integer> colecaoAuxiliar = new ArrayList<Integer>();
								// Calendar tempo = Calendar.getInstance();
								// int contador = 1;
								// for(Integer id : idsDebitoACobrar){
								// colecaoAuxiliar.add(id);
								// if(colecaoAuxiliar.size() == 1000){
								// Collection<DebitoACobrar> colecao = repositorioFaturamento
								// .pesquisarDebitoACobrar(colecaoAuxiliar);
								// System.out.println("Tempo1: " +
								// Util.calcularDiferencaTempo(tempo));
								// System.out.println("Quantidade2: " + colecao.size());
								//
								// for(DebitoACobrar debitoACobrar : colecao){
								// this.getControladorContabil().registrarLancamentoContabil(debitoACobrar,
								// OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);
								// }
								// colecaoAuxiliar.clear();
								// System.out.println("Tempo2 " + contador + " -> " +
								// Util.calcularDiferencaTempo(tempo));
								// }
								// }
								// if(!colecaoAuxiliar.isEmpty()){
								// Collection<DebitoACobrar> colecao = repositorioFaturamento
								// .pesquisarDebitoACobrar(colecaoAuxiliar);
								// System.out.println("Tempo3: " +
								// Util.calcularDiferencaTempo(tempo));
								// System.out.println("Quantidade3: " + colecao.size());
								//
								// for(DebitoACobrar debitoACobrar : colecao){
								// this.getControladorContabil().registrarLancamentoContabil(debitoACobrar,
								// OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);
								// }
								//
								// System.out.println("Tempo4: " +
								// Util.calcularDiferencaTempo(tempo));
								// }
								//
								// }else{
								// Calendar tempo = Calendar.getInstance();
								//
								// Collection<DebitoACobrar> colecao =
								// repositorioFaturamento.pesquisarDebitoACobrar(idsDebitoACobrar);
								// System.out.println("Tempo5: " +
								// Util.calcularDiferencaTempo(tempo));
								// System.out.println("Quantidade4: " + colecao.size());
								//
								// for(DebitoACobrar debitoACobrar : colecao){
								// this.getControladorContabil().registrarLancamentoContabil(debitoACobrar,
								// OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);
								// }
								//
								// System.out.println("Tempo6: " +
								// Util.calcularDiferencaTempo(tempo));
								// }
								// }
							}

						}catch(ControladorException e){

							if(pagtoAux != null && pagtoAux.getImovel() != null){

								ControladorException ce = new ControladorException("erro.sistema.arrecadacao", (Exception) e.getCause(),
												"Pagamentos", Integer.toString(pagtoAux.getImovel().getId()), Long.toString(pagtoAux
																.getLinhaArrecadacao()));

								String[] params = new String[ce.getParametroMensagem().size()];
								params = ce.getParametroMensagem().toArray(params);
								System.out.println("-----------------> " + ConstantesAplicacao.get(ce.getMessage(), params));

								e.printStackTrace();

								throw ce;
							}else{
								throw e;
							}
						}
					}

					// verifica se a coleção de pagamentos está
					// diferente de nulo
					if(devolucoes != null && !devolucoes.isEmpty()){

						/*
						 * Colocado por Raphael Rossiter em
						 * 29/10/2007 - Analista: Aryed Lins OBJ:
						 * Este caso de uso ficará responsável pela
						 * inserção das guias de devolução
						 */

						Iterator devolucaoIterator = devolucoes.iterator();
						while(devolucaoIterator.hasNext()){
							Devolucao devolucao = (Devolucao) devolucaoIterator.next();

							// verifica se existe o aviso bancario
							// no pagamento,
							// se não existe então seta o aviso
							// bancario no pagamento
							if(devolucao.getAvisoBancario() == null){
								Iterator avisosBancarioIterator = avisosBancarios.iterator();
								while(avisosBancarioIterator.hasNext()){
									AvisoBancario avisoBanc = (AvisoBancario) avisosBancarioIterator.next();
									// avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
									// avisoBancario.adicionarUsuario(usuario,
									// usuarioAcao);

									// caso a data prevista seja a
									// mesma estão seta o aviso
									// bancário no pagamento
									boolean comparaDataIguais = Util.datasIguais(devolucao.getDataPrevistaCreditoHelper(),
													avisoBanc.getDataPrevista());
									if(comparaDataIguais){
										devolucao.setAvisoBancario(avisoBanc);
										break;
									}
								}
							}
							/*
							 * Colocado por Sávio Luiz em 14/11/2007 -
							 * Analista: Aryed Lins OBJ: Este caso
							 * de uso ficará responsável pela
							 * inserção das guias de devolução
							 */
							if(devolucao.getGuiaDevolucao() != null){
								Integer idGuiaDevolucao = (Integer) getControladorUtil().inserir(devolucao.getGuiaDevolucao());
								devolucao.getGuiaDevolucao().setId(idGuiaDevolucao);
							}
						}

						getControladorBatch().inserirColecaoObjetoParaBatch((Collection) devolucoes);

						// 11. Para cada pagamento da coleção
						// inserido o sistema efetua a classificação
						// do pagamento <<Inclui>>
						// [UC0300 –
						// ClassificarPagamentosDevolucoes] - PARTE
						// 2
						if(devolucoes != null && !devolucoes.isEmpty()){

							for(Devolucao devolucaoTemp : (Collection<Devolucao>) devolucoes){

								this.classificarDevolucoes(devolucaoTemp);
							}
						}
					}

					if(avisosBancarios != null && !avisosBancarios.isEmpty()){
						Iterator avisosBancarioIterator = avisosBancarios.iterator();
						while(avisosBancarioIterator.hasNext()){
							avisoBancario = (AvisoBancario) avisosBancarioIterator.next();
							this.atualizarValoresAvisoBancario(avisoBancario, true);
						}
					}else if(avisoBancario != null){
						this.atualizarValoresAvisoBancario(avisoBancario, true);
					}

					// o sistema atualiza o numero sequencial do
					// arquivo(NSA) verifica o tipo de pagamento
					if(registroHelperCodigoA.getTipoMovimento().equals(ConstantesSistema.DEBITO_AUTOMATICO)){

						numeroSequencialArquivo = numeroSequencialArquivoEsperado.toString();

						if(indicadorAtualizaNSADebitoAutomatico){

							arrecadadorContrato.setNumeroSequencialArquivoRetornoDebitoAutomatico(numeroSequencialArquivoEsperado);
						}else if(indicadorAtualizaNSAParcelamentoResponsavel){

							arrecadadorContrato.setNumeroSequencialArquivoRetornoParcelamentoResposavel(numeroSequencialArquivoEsperado);
						}
					}else{

						numeroSequencialArquivo = numeroSequencialArquivoEsperado.toString();
						arrecadadorContrato.setNumeroSequecialArquivoRetornoCodigoBarras(numeroSequencialArquivoEsperado);
					}

					// caso a coleção de registros c não está vazia
					// então adiciona mais 1 para numero do
					// sequencial do arquivo de envio.
					if(colecaoCodigoRegistrosC != null && !colecaoCodigoRegistrosC.isEmpty()){
						numeroSequencialArquivo = numeroSequencialArquivoEnvioDebitoAutomatico.toString();
						numeroSequencialArquivoEnvioDebitoAutomatico += 1;
						flagEnvioDebitoAutomatico = true;
						arrecadadorContrato.setNumeroSequencialArquivoEnvioDebitoAutomatico(numeroSequencialArquivoEnvioDebitoAutomatico);
					}

					// atualiza arrecadação contrato na base
					repositorioArrecadacao.atualizarDadosArrecadadorContrato(arrecadadorContrato, flagEnvioDebitoAutomatico,
									flagRetornoCodigoBarras, flagRetornoDebitoAutomatico, flagRetornoFichaCompensacao, false,
									indicadorAtualizaNSADebitoAutomatico, indicadorAtualizaNSAParcelamentoResponsavel);

					// --------------------------------------------------------------------------------------------
					// Registra o Lançamento Contábil.
					// --------------------------------------------------------------------------------------------
					if(collOperacaoContabilHelper != null && !collOperacaoContabilHelper.isEmpty()){
						System.out.println("***********************Início Registra o Lançamento Contábil.[REGISTRAR MOV. ARRECADADOR]*********************************");

						getControladorContabil().registrarLancamentoContabil(collOperacaoContabilHelper);

						System.out.println("***********************Fim Registra o Lançamento Contábil.[REGISTRAR MOV. ARRECADADOR]************************************");
					}

					// --------------------------------------------------------------------------------------------

					registroHelperCodigoA = null;
					colecaoCodigoRegistrosC.clear();
					colecaoCodigoRegistrosC = new ArrayList();
					primeiraLinha = true;
					arrecadadorContrato = null;
					flagEnvioDebitoAutomatico = false;
					flagRetornoCodigoBarras = false;
					flagRetornoDebitoAutomatico = false;
					flagRetornoFichaCompensacao = false;

					avisosBancarios.clear();
					avisosBancarios = new ArrayList();
					pagamentos.clear();
					pagamentos = new ArrayList();
					devolucoes = null;

				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

			}else{

				this.validarArquivoMovimentoArrecadadorFichaCompensacao(stringBuilderTxt, arrecadador, quantidadeRegistros, idTipoMovimento);

			}


			// Registrar o fim do processamento da unidade de processamento do batch
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
			System.out.println("**************************FIM REGISTRAR MOVIMENTO DOS ARRECADORES*********************************");

		}catch(Exception e){

			e.printStackTrace();

			try{

				EnvioEmail envioEmailError = getControladorCadastro().pesquisarEnvioEmail(
								EnvioEmail.REGISTRAR_MOVIMENTO_ARRECADADORES_COM_ERRO);

				String emailRemetente = envioEmailError.getEmailRemetente();
				String tituloMensagem = envioEmailError.getTituloMensagem() + " " + numeroSequencialArquivo;
				String emailReceptor = envioEmailError.getEmailReceptor();

				boolean mensagemComParametros = false;

				if(e instanceof ControladorException){

					if(!Util.isVazioOrNulo(((ControladorException) e).getParametroMensagem())){

						ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem,
										((ControladorException) e).getMensagem());

						mensagemComParametros = true;
					}
				}

				if(mensagemComParametros == false){

					String mensagem = e.getMessage();

					if(mensagem != null){

						if(!mensagem.startsWith("erro.") && !mensagem.startsWith("atencao.")){

							mensagem = "erro.sistema";
						}
					}else{

						mensagem = "erro.sistema";
					}

					ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, ConstantesAplicacao.get(mensagem));
				}

			}catch(Exception e2){

				e2.printStackTrace();
				throw new ControladorException("erro.sistema", e2);
			}finally{

				sessionContext.setRollbackOnly();
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			}
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores [SF0004] - Processar
	 * Registro Código F
	 * 
	 * @author Saulo Lima
	 * @date 31/12/2008 Método Criado para processar os arquivos do GSAN e os
	 *       arquivos de Legados (método sobrescrito)
	 * @param registroHelperCodigoF
	 * @param sistemaParametro
	 * @param linhaRegistro
	 * @param arrecadadorMovimento
	 * @param indicadorAceitacaoRegistroMovimento
	 * @param registroHelperCodigoA
	 * @param dataGeracao
	 * @param avisosBancarios
	 * @param numeroSequencialAvisoBancario
	 * @param registroHelperCodigoZ
	 * @param pagamentos
	 * @param linhaArrecadacao
	 * @throws ControladorException
	 */
	public void processarRegistroCodigoF(RegistroHelperCodigoF registroHelperCodigoF, SistemaParametro sistemaParametro,
					String linhaRegistro, ArrecadadorMovimento arrecadadorMovimento, int indicadorAceitacaoRegistroMovimento,
					RegistroHelperCodigoA registroHelperCodigoA, Date dataGeracao, Collection<AvisoBancario> avisosBancarios,
					short numeroSequencialAvisoBancario, RegistroHelperCodigoZ registroHelperCodigoZ, Collection<Pagamento> pagamentos,
					long linhaArrecadacao, ArrecadadorContrato arrecadadorContrato, Arrecadador arrecadadorSelecionado)
					throws ControladorException{

		String[] retorno = (String[]) ParametroArrecadacao.P_VALIDAR_CAMPOS_RETORNO_DEB_AUTOMATICO_CODIGO_F.executar(this, -1,
						registroHelperCodigoF, sistemaParametro, linhaRegistro);
		String descricaoOcorrenciaMovimento = retorno[0];

		// caso o código do retorno seja igual a zero ou 31
		if(Integer.valueOf(registroHelperCodigoF.getCodigoRetorno()).equals(DebitoAutomaticoRetornoCodigo.DEBITADO)
						|| Integer.valueOf(registroHelperCodigoF.getCodigoRetorno()).equals(
										DebitoAutomaticoRetornoCodigo.EFETUADO_EM_DATA_DIVERSA_FERIADO_NA_PRACA)){
			// caso a descricao de movimento seja igual a OK
			if(descricaoOcorrenciaMovimento.equals("OK")){
				String matriculaImovel = retorno[1];
				// verifica se existe a matricula do imóvel na base
				Integer idImovelNaBase;
				try{
					idImovelNaBase = repositorioImovel.recuperarMatriculaImovel(Integer.valueOf(matriculaImovel));
				}catch(NumberFormatException e){
					throw new ControladorException("erro.sistema", e);
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				Object[] retornoParametro = (Object[]) ParametroArrecadacao.P_ATUALIZAR_DEB_AUTOMATICO_REGISTRO_CODIGO_F.executar(this, -1,
								descricaoOcorrenciaMovimento, idImovelNaBase, registroHelperCodigoF, registroHelperCodigoA);
				Integer identificacaoConta = (Integer) retornoParametro[0];
				Integer identificacaoGuiaPagamento = (Integer) retornoParametro[1];
				Integer numeroPrestacao = (Integer) retornoParametro[2];
				descricaoOcorrenciaMovimento = (String) retornoParametro[3];
				Boolean indicadorPagamentoConta = (Boolean) retornoParametro[4];

				// inseri o item movimento arrecadador
				Integer idArrecadadorMovimentoItem = inserirItemMovimentoArrecadador(linhaRegistro, arrecadadorMovimento.getId(),
								descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento, idImovelNaBase);

				// inicializa o id da localidade
				Integer idLocalidade = null;

				// se o id do imovel pesquisado na base for diferente de nulo
				if(idImovelNaBase != null){

					try{
						idLocalidade = repositorioLocalidade.pesquisarIdLocalidade(idImovelNaBase);

					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}

				}
				// cria o objeto pagamento para setar os dados
				Pagamento pagamento = new Pagamento();
				pagamento.setLinhaArrecadacao(linhaArrecadacao);

				pagamento.setAnoMesReferenciaPagamento(Integer.parseInt(registroHelperCodigoF.getAnoMesReferenciaConta()));
				Date dataDebito = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoF.getDataDebito());
				Integer anoMesDebito = Util.recuperaAnoMesDaData(dataDebito);
				// caso o ano mes da data de dedito seja maior que o ano mes de
				// arrecadação da tabela sistema parametro então
				// seta o ano mes da data de debito
				if(anoMesDebito > sistemaParametro.getAnoMesArrecadacao()){
					pagamento.setAnoMesReferenciaArrecadacao(anoMesDebito);
				}else{
					// caso contrario seta o o ano mes
					// arrecadação da tabela sistema parametro
					pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
				}
				// formata o valor debitado
				BigDecimal valorDebitado = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoF
								.getValorDebito());
				pagamento.setValorPagamento(valorDebitado);
				pagamento.setDataPagamento(dataDebito);
				pagamento.setPagamentoSituacaoAtual(null);
				pagamento.setPagamentoSituacaoAnterior(null);
				pagamento.setDebitoTipo(null);

				// verifica se o id da conta é diferente de nulo
				Imovel imovel = new Imovel();
				imovel.setId(idImovelNaBase);

				if(identificacaoConta != null){
					Conta conta = new Conta();
					conta.setId(identificacaoConta);
					pagamento.setConta(conta);
				}else{
					pagamento.setConta(null);
				}

				if(identificacaoGuiaPagamento != null){
					GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
					guiaPagamentoGeral.setId(identificacaoGuiaPagamento);
					GuiaPagamento guiaPagamento = new GuiaPagamento();
					guiaPagamento.setId(identificacaoGuiaPagamento);
					guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);
					pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
				}else{
					pagamento.setGuiaPagamentoGeral(null);
				}

				// verifica se o id da Localidade é diferente de nulo
				if(idLocalidade != null){
					Localidade localidade = new Localidade();
					localidade.setId(idLocalidade);
					pagamento.setLocalidade(localidade);
				}else{
					pagamento.setLocalidade(null);
				}
				DocumentoTipo documentoTipo = new DocumentoTipo();

				if(indicadorPagamentoConta){
					documentoTipo.setId(DocumentoTipo.CONTA);
				}else{
					documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
				}

				pagamento.setDocumentoTipo(documentoTipo);

				// seta o id do aviso bancario

				// seta o imovel
				if(idImovelNaBase != null){
					imovel = new Imovel();
					imovel.setId(idImovelNaBase);
					pagamento.setImovel(imovel);
				}else{
					pagamento.setImovel(null);
				}

				ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
				arrecadadorMovimentoItem.setId(idArrecadadorMovimentoItem);

				pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

				ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				arrecadacaoForma.setId(ArrecadacaoForma.DEBITO_AUTOMATICO);
				pagamento.setArrecadacaoForma(arrecadacaoForma);
				pagamento.setCliente(null);
				pagamento.setUltimaAlteracao(new Date());
				pagamento.setNumeroPrestacao(numeroPrestacao);

				Integer idArrecadadorSelecionado = arrecadadorSelecionado.getId();

				// pesquisa a quantidade de dias de float
				Short numeroDiasFloat = null;
				Integer idFormaArrecadacao = ArrecadacaoForma.DEBITO_AUTOMATICO;
				try{
					if(arrecadadorContrato != null){
						Integer idArrecadadorContrato = arrecadadorContrato.getId();

						numeroDiasFloat = repositorioArrecadacao.pesquisarNumeroDiasFloat(idArrecadadorContrato, idFormaArrecadacao);
					}
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				Date dataPrevistaCredito = null;
				if(numeroDiasFloat != null){

					dataPrevistaCredito = Util.adicionarNumeroDiasDeUmaData(dataDebito, numeroDiasFloat);
				}else{
					dataPrevistaCredito = Util.adicionarNumeroDiasDeUmaData(dataDebito, 0);
				}

				// 2.5.3.Parte que determina os valores calculado
				// e informado do pagamento e da devolução
				BigDecimal valorCalcPagamento = valorDebitado;
				BigDecimal valorCalcDevolucao = BigDecimal.ZERO;
				BigDecimal valorInfPagamento = valorDebitado;
				BigDecimal valorInfDevolucao = BigDecimal.ZERO;

				// pesquisa o aviso bancario passando o
				// código do banco a data de geração
				// do arquivo e a data prevista calculada
				AvisoBancario avisoBancario = null;
				try{
					avisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(idArrecadadorSelecionado, dataGeracao,
									dataPrevistaCredito, null);

				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				// verifica seo aviso bancario é diferente de nulo
				// Alterado por Sávio Luiz
				// Data: 04/01/2007
				if(avisoBancario != null){
					// avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
					// avisoBancario.adicionarUsuario(usuario, usuarioAcao);

					if(avisoBancario.getValorArrecadacaoCalculado() != null && !avisoBancario.getValorArrecadacaoCalculado().equals("")){
						BigDecimal novoValorArrecadacaoCalculado = avisoBancario.getValorArrecadacaoCalculado().add(valorCalcPagamento);
						avisoBancario.setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
					}else{
						avisoBancario.setValorArrecadacaoCalculado(valorCalcPagamento);
					}

					if(avisoBancario.getValorDevolucaoCalculado() != null && !avisoBancario.getValorDevolucaoCalculado().equals("")){
						BigDecimal novoValorDevolucaoCalculado = avisoBancario.getValorDevolucaoCalculado().add(valorCalcDevolucao);
						avisoBancario.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
					}else{
						avisoBancario.setValorDevolucaoCalculado(valorCalcDevolucao);
					}

					if(avisoBancario.getValorArrecadacaoInformado() != null && !avisoBancario.getValorArrecadacaoInformado().equals("")){
						BigDecimal novoValorArrecadacaoInformado = avisoBancario.getValorArrecadacaoInformado().add(valorInfPagamento);
						avisoBancario.setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
					}else{
						avisoBancario.setValorArrecadacaoInformado(valorInfPagamento);
					}

					if(avisoBancario.getValorRealizado() != null && !avisoBancario.getValorRealizado().equals("")){
						BigDecimal novoValorArrecadacaoInformado = avisoBancario.getValorRealizado().add(valorInfPagamento);
						avisoBancario.setValorRealizado(novoValorArrecadacaoInformado);
					}else{
						avisoBancario.setValorRealizado(valorInfPagamento);
					}

					if(avisoBancario.getValorDevolucaoInformado() != null && !avisoBancario.getValorDevolucaoInformado().equals("")){
						BigDecimal novoValorDevolucaoInformado = avisoBancario.getValorDevolucaoInformado().add(valorInfDevolucao);
						avisoBancario.setValorDevolucaoInformado(novoValorDevolucaoInformado);
					}else{
						avisoBancario.setValorDevolucaoInformado(valorInfDevolucao);
					}

					avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);
					avisoBancario.setUltimaAlteracao(new Date());
					// atualiza o aviso bancário
					try{
						repositorioUtil.atualizar(avisoBancario);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}

					pagamento.setAvisoBancario(avisoBancario);

				}else{
					// seta o aviso bancario para null
					pagamento.setAvisoBancario(null);
					// seta o valor da data prevista para quando for inserir o
					// pagamento saber de que aviso bancário o pagamento está relacionádo.
					pagamento.setDataPrevistaCreditoHelper(dataPrevistaCredito);

					Iterator avisosBancarioIterator = avisosBancarios.iterator();
					// cria um boolean para saber se existe algum aviso bancario da
					// coleção com a mesma data prevista da data
					// prevista calculada anteriormente
					boolean achou = false;
					while(avisosBancarioIterator.hasNext()){
						AvisoBancario avisoBancarioDaColecao = (AvisoBancario) avisosBancarioIterator.next();
						boolean comparaDataIguais = Util.datasIguais(avisoBancarioDaColecao.getDataPrevista(), dataPrevistaCredito);
						if(comparaDataIguais){

							if(avisoBancarioDaColecao.getValorArrecadacaoCalculado() != null
											&& !avisoBancarioDaColecao.getValorArrecadacaoCalculado().equals("")){
								BigDecimal novoValorArrecadacaoCalculado = avisoBancarioDaColecao.getValorArrecadacaoCalculado().add(
												valorCalcPagamento);
								avisoBancarioDaColecao.setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
							}else{
								avisoBancarioDaColecao.setValorArrecadacaoCalculado(valorCalcPagamento);
							}

							if(avisoBancarioDaColecao.getValorDevolucaoCalculado() != null
											&& !avisoBancarioDaColecao.getValorDevolucaoCalculado().equals("")){
								BigDecimal novoValorDevolucaoCalculado = avisoBancarioDaColecao.getValorDevolucaoCalculado().add(
												valorCalcDevolucao);
								avisoBancarioDaColecao.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
							}else{
								avisoBancarioDaColecao.setValorDevolucaoCalculado(valorCalcDevolucao);
							}

							if(avisoBancarioDaColecao.getValorRealizado() != null && !avisoBancarioDaColecao.getValorRealizado().equals("")){
								BigDecimal novoValorArrecadacaoInformado = avisoBancarioDaColecao.getValorRealizado()
												.add(valorInfPagamento);
								avisoBancarioDaColecao.setValorRealizado(novoValorArrecadacaoInformado);
							}else{
								avisoBancarioDaColecao.setValorRealizado(valorInfPagamento);
							}

							if(avisoBancarioDaColecao.getValorDevolucaoInformado() != null
											&& !avisoBancarioDaColecao.getValorDevolucaoInformado().equals("")){
								BigDecimal novoValorDevolucaoInformado = avisoBancarioDaColecao.getValorDevolucaoInformado().add(
												valorInfDevolucao);
								avisoBancarioDaColecao.setValorDevolucaoInformado(novoValorDevolucaoInformado);
							}else{
								avisoBancarioDaColecao.setValorDevolucaoInformado(valorInfDevolucao);
							}

							achou = true;
							break;
						}
					}
					if(!achou){

						// chama o método para cria o objeto do aviso bancário
						avisoBancario = gerarOcorrenciaAvisoBancario(arrecadadorMovimento.getId(), registroHelperCodigoA,
										dataPrevistaCredito, registroHelperCodigoZ.getValorTotalRegistrosArquivo(),
										sistemaParametro.getAnoMesArrecadacao(), registroHelperCodigoA.getCodigoBanco(),
										valorCalcPagamento, valorInfPagamento, valorCalcDevolucao, valorInfDevolucao,
										numeroSequencialAvisoBancario, arrecadadorContrato, arrecadadorSelecionado);

						numeroSequencialAvisoBancario += 1;
						avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);
						avisoBancario.setValorRealizado(valorInfPagamento);

						// adiciona o aviso bancário na coleção de avisos bancários
						avisosBancarios.add(avisoBancario);
					}
				}

				// adiciona o pagamento na coleção de pagamentos
				pagamentos.add(pagamento);

			}else{

				// seta o indicador de aceitação do registro do movimento para 2(NÃO)
				indicadorAceitacaoRegistroMovimento = 2;

				// inseri o item movimento arrecadador
				inserirItemMovimentoArrecadador(linhaRegistro, arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
								indicadorAceitacaoRegistroMovimento, null);

			}
		}else{
			// 2.1. O sistema atribui o valor 2 (NÃO) ao Indicador de Aceitação do Registro do
			// Movimento;
			// seta o indicador de aceitação do registro do movimento para 2(NÃO)
			indicadorAceitacaoRegistroMovimento = 2;

			// caso a descricao de movimento seja igual a OK
			if(descricaoOcorrenciaMovimento.equals("OK")){
				DebitoAutomaticoMovimento debitoAutomaticoMovimento = null;
				String matriculaImovel = retorno[1];
				// verifica se existe a matricula do imóvel na base
				Integer idImovelNaBase;
				Imovel imovel = null;
				Integer idConta = null;
				Integer identificacaoConta = null;

				try{
					idImovelNaBase = repositorioImovel.recuperarMatriculaImovel(Integer.valueOf(matriculaImovel));
				}catch(NumberFormatException e){
					throw new ControladorException("erro.sistema", e);
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				if(!Util.isVazioOuBranco(idImovelNaBase)){
					try{
						imovel = new Imovel();
						imovel.setId(idImovelNaBase);
						// 2.2. Verifica a existência da conta (a partir da tabela CONTA com
						// IMOV_ID=matrícula do imóvel e CNTA_AMREFERENCIACONTA=Ano/mês
						// de referência da conta (campo F08) e situação atual (DCST_IDATUAL)
						// com o valor correspondente a normal, retificada ou incluída).
						idConta = repositorioFaturamento.pesquisarExistenciaContaComSituacaoAtual(imovel,
										Integer.valueOf(registroHelperCodigoF.getAnoMesReferenciaConta()));
						if(idConta != null){
							identificacaoConta = idConta;
							debitoAutomaticoMovimento = repositorioFaturamento.obterDebitoAutomaticoMovimento(idImovelNaBase,
											Integer.valueOf(registroHelperCodigoF.getAnoMesReferenciaConta()));
						}else{
							// 2.3. Caso a conta não exista, verifica a existência da conta no
							// histórico (a partir da tabela CONTA_HISTORICO com IMOV_ID=matrícula
							// do imóvel e CNHI_AMREFERENCIACONTA=Ano/mês de referência
							// da conta (campo F08) e situação atual (DCST_IDATUAL)
							// com o valor correspondente a normal, retificada ou incluída):
							Integer idContaHistorico = repositorioFaturamento.pesquisarExistenciaContaHistoricoComSituacaoAtual(imovel,
											Integer.valueOf(registroHelperCodigoF.getAnoMesReferenciaConta()));
							if(idContaHistorico != null){
								identificacaoConta = idContaHistorico;
								debitoAutomaticoMovimento = repositorioFaturamento.obterDebitoAutomaticoMovimento(idImovelNaBase,
												Integer.valueOf(registroHelperCodigoF.getAnoMesReferenciaConta()));
							}
						}
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}

				// 2.4. Caso a conta exista, o sistema atualiza o movimento de débito automático com
				// os seguintes dados (a partir da tabela DEBITO_AUTOMATICO_MOVIMENTO com
				// CNTA_ID=CNTA_ID da tabela CONTA ou da tabela CONTA_HISTORICO)
				// e atribui o valor de CNTA_ID da tabela
				// CONTA ou da tabela CONTA_HISTORICO à Identificação da Conta:
				if(!Util.isVazioOuBranco(identificacaoConta)){
					// DURC_ID Código de Retorno
					// DAMV_TMRETORNOBANCO Data e hora correntes
					// DAMV_NNNSARETORNO Número seqüencial do arquivo (NSA)
					// DAMV_TMULTIMAALTERACAO Data e hora correntes
					if(!Util.isVazioOuBranco(debitoAutomaticoMovimento)){

						DebitoAutomaticoRetornoCodigo debitoAutomaticoRetornoCodigo = new DebitoAutomaticoRetornoCodigo();
						debitoAutomaticoRetornoCodigo.setId(Integer.valueOf(registroHelperCodigoF.getCodigoRetorno()));
						debitoAutomaticoMovimento.setDebitoAutomaticoRetornoCodigo(debitoAutomaticoRetornoCodigo);
						debitoAutomaticoMovimento.setRetornoBanco(new Date());
						debitoAutomaticoMovimento.setNumeroSequenciaArquivoRecebido(Integer.valueOf(registroHelperCodigoA
										.getNumeroSequencialArquivo()));
						debitoAutomaticoMovimento.setUltimaAlteracao(new Date());
						getControladorUtil().atualizar(debitoAutomaticoMovimento);
					}
				}
			}

			// atualiza o aviso bancário
			try{
				descricaoOcorrenciaMovimento = repositorioArrecadacao.pesquisarDescricaoDebitoAutomatico(Integer
								.valueOf(registroHelperCodigoF.getCodigoRetorno()));
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			// inseri o item movimento arrecadador
			inserirItemMovimentoArrecadador(linhaRegistro, arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
							indicadorAceitacaoRegistroMovimento, null);
		}

	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0011] - Validar Arquivo de Movimento de Arrecadador da Ficha de Compensação
	 * 
	 * @author Saulo Lima
	 * @date 25/02/2010
	 * @param stringBuilderTxt
	 * @param arrecadador
	 * @param quantidadeRegistros
	 * @param arrecadadoresMovimento
	 * @return Collection<ArrecadadorMovimento>
	 */
	private void validarArquivoMovimentoArrecadadorFichaCompensacao(StringBuilder stringBuilderTxt, Arrecadador arrecadador,
					int quantidadeRegistros, String idTipoMovimento) throws ControladorException{

		Collection<ArrecadadorMovimento> arrecadadoresMovimentoRetorno = new ArrayList<ArrecadadorMovimento>();

		if(idTipoMovimento.equals("FICHA DE COMPENSACAO")){

			ArrecadadorMovimento arrecadadorMovimento = null;
			ArrecadadorMovimento arrecadadorMovimentoExistente = null;

			// Ficha de Compensação
			int tamanhoLinha = 240;

			boolean flagRetornoFichaCompensacao = true;
			boolean flagRetornoCodigoBarras = false;
			boolean flagRetornoDebitoAutomatico = false;
			boolean flagEnvioDebitoAutomatico = false;

			int countRegistros = 0;

			// inicio da linha da string builder
			Integer inicioLinha = 0;

			// cria um boolean que verifica se é a primeira linha
			boolean primeiraLinha = true;

			// recupera o arrecadadorContrato para atualizar o numero sequencial do arquivo
			ArrecadadorContrato arrecadadorContrato = null;

			Collection<ArrecadadorContrato> colecaoArrecadadorContrato = null;

			// verifica se existe o registro 9 no arquivo
			boolean verificaRegistro9 = false;

			// caso seja ficha de compensação
			Integer numeroSequecialArquivoRetornoFichaComp = null;

			// recupera o sistema parametro
			SistemaParametro sistemaParametro = null;
			sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// cria uma coleção com as linhas do txt
			Collection<String> linhas = new ArrayList<String>();

			// cria uma coleção de pagamentos
			Collection<Pagamento> pagamentos = new ArrayList<Pagamento>();

			// cria uma coleção de avisos bancarios
			Collection<AvisoBancario> avisosBancarios = new ArrayList<AvisoBancario>();

			// inicializa um RegistroHelperCodigo0
			RegistroHelperCodigo0 registroHelperCodigo0 = null;

			// inicializa um RegistroHelperCodigo5
			// RegistroHelperCodigo5 registroHelperCodigo5 = null;

			BigDecimal somatorioValorTITCarteira07 = BigDecimal.ZERO;

			try{

				for(int i = 1; i <= quantidadeRegistros; i++){

					countRegistros = countRegistros + 1;

					String linha = stringBuilderTxt.substring(inicioLinha, inicioLinha + tamanhoLinha);

					// incrementa a primeira linha.O +1 é para tirar o
					// System.getProperty("line.separator")
					inicioLinha = inicioLinha + tamanhoLinha + 1;

					// cria uma variavel da descrição da ocorrencia do movimento com o valor setado
					// para
					// OK
					String descricaoOcorrenciaMovimento = "OK";

					// cria uma variavel do indicador de aceitação do registro do movimento
					int indicadorAceitacaoRegistroMovimento = 1;

					// recupera o codigo do registro
					String codigoRegistro = linha.substring(7, 8);

					short numeroSequencialAvisoBancario = 0;

					// [SB0011]-Validar Arquivo de Movimento de Arrecadador da Ficha de Compensação
					// verifica se é a primeira linha
					if(primeiraLinha){
						/*
						 * [SF0011] - Validar Arquivo de Movimento de Arrecadador da Ficha de
						 * Compensação Autor: Vivianne Sousa Data: 26/11/2007
						 */

						// 1. verifica se o código do registro é diferente de "0", caso seja encerra
						// o
						// caso de uso
						if(!codigoRegistro.toUpperCase().equals("0")){
							throw new ControladorException("atencao.arquivo.movimento.sem.header");
						}else{
							registroHelperCodigo0 = (RegistroHelperCodigo0) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
											linha, null);
						}

						// 2. verifica se o código da remessa é diferente de 2,
						// caso seja encerra o caso de uso
						if(!registroHelperCodigo0.getCodigoRemessaRetorno().equals("2")){
							throw new ControladorException("atencao.codigo.remessa.invalido");
						}

						// 3. verifica se o código do banco é diferente do codigo do
						// arrecadador caso seja encerra o caso de uso
						Short codigoBancoTxt = Short.valueOf(registroHelperCodigo0.getCodigoBancoCompensacao().trim());

						if(!codigoBancoTxt.equals(arrecadador.getCodigoAgente())){
							throw new ControladorException("atencao.movimento.nao.arrecadador", null, "" + arrecadador.getCodigoAgente(),
											arrecadador.getCliente().getNome());
						}

						// 4. verifica se o lote de serviço é diferente de 0000 caso
						// seja encerra o caso de uso
						if(!registroHelperCodigo0.getLoteServico().equals("0000")){
							throw new ControladorException("atencao.lote.nao.corresponde.header");
						}

						// 5. verifica o numero sequencial do txt se está de acordo com o da base
						// verifica se o arrecadadorContrato é diferente de nulo , para
						// não ficar fazendo essa pesquisa varias vezes
						String codigoConvenioBanco = registroHelperCodigo0.getCodigoConvenioBanco();

						if(arrecadadorContrato == null || arrecadadorContrato.equals("")){
							colecaoArrecadadorContrato = repositorioArrecadacao.pesquisarNumeroSequecialArrecadadorContrato(
											arrecadador.getCodigoAgente(), null);

							if(!Util.isVazioOrNulo(colecaoArrecadadorContrato)){
								String codigoConvenioFichaCompensacao = null;
								String codigoConvenioFichaCompensacaoSemZero = null;

								String codigoConvenioBancoSemZero = Util.removerZerosEsquerda(codigoConvenioBanco);

								for(ArrecadadorContrato arrecadadorContratoAux : colecaoArrecadadorContrato){
									codigoConvenioFichaCompensacao = arrecadadorContratoAux.getCodigoConvenioFichaCompensacao();
									codigoConvenioFichaCompensacaoSemZero = Util.removerZerosEsquerda(codigoConvenioFichaCompensacao);

									if(codigoConvenioFichaCompensacaoSemZero != null && codigoConvenioBancoSemZero != null
													&& codigoConvenioFichaCompensacaoSemZero.equals(codigoConvenioBancoSemZero)){
										arrecadadorContrato = arrecadadorContratoAux;

										break;
									}
								}
							}

							if(arrecadadorContrato == null){
								throw new ControladorException("atencao.movimento_processado_codigo_convenio_inexiste", null,
												idTipoMovimento, codigoConvenioBanco);
							}
						}

						if(arrecadadorContrato != null && arrecadadorContrato.getNumeroSequencialArquivoRetornoFichaCompensacao() != null){

							numeroSequecialArquivoRetornoFichaComp = arrecadadorContrato
											.getNumeroSequencialArquivoRetornoFichaCompensacao().intValue() + 1;

							/*
							 * Se consistir NSA (ARCT_ICCRITICARNSA da Tabela
							 * ARRECADADOR_CONTRATO=1)
							 */
							if(arrecadadorContrato.getIndicadorCriticarNumeroSequencialArquivo().equals(ConstantesSistema.SIM)){

								/*
								 * Caso o número seqüencial do arquivo (NSA) (campo 0.19) não seja
								 * igual
								 * ao o
								 * número seqüencial do arquivo (NSA) esperado exibir a mensagem
								 * “Arquivo de
								 * Movimento Está Fora de Seqüência” e encerrar o caso de uso
								 */
								if(!Integer.valueOf(registroHelperCodigo0.getNumeroSequencialArquivo()).equals(
												numeroSequecialArquivoRetornoFichaComp)){

									throw new ControladorException("atencao.arquivo.movimento.fora.sequencia");
								}
							}else if(Util.isInteger(registroHelperCodigo0.getNumeroSequencialArquivo())){

								numeroSequecialArquivoRetornoFichaComp = Util.obterInteger(registroHelperCodigo0
												.getNumeroSequencialArquivo());
							}
						}

						/*
						 * Verificar a já existência do Movimento em Questão na tabela
						 * ARRECADADOR_MOVIMENTO
						 */
						arrecadadorMovimentoExistente = repositorioArrecadacao.pesquisaArrecadadorMovimentoExistente(new Short(
										registroHelperCodigo0.getCodigoBancoCompensacao()), codigoConvenioBanco, Util
										.obterInteger(registroHelperCodigo0.getNumeroSequencialArquivo()));

						if(arrecadadorMovimentoExistente != null){

							throw new ControladorException("atencao.movimento_ja_processado", null,
											registroHelperCodigo0.getCodigoBancoCompensacao(), codigoConvenioBanco,
											registroHelperCodigo0.getNumeroSequencialArquivo());
						}

						if(registroHelperCodigo0.getCodigoBancoCompensacao() != null
										&& registroHelperCodigo0.getDataGeracaoArquivo() != null){

							Date dataGeracao = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigo0.getDataGeracaoArquivo());

							Short valorMaximoNumeroSequencia = null;
							valorMaximoNumeroSequencia = repositorioArrecadacao.pesquisarValorMaximoNumeroSequencial(dataGeracao,
											registroHelperCodigo0.getCodigoBancoCompensacao());

							if(valorMaximoNumeroSequencia != null){
								numeroSequencialAvisoBancario = (short) (valorMaximoNumeroSequencia.shortValue() + 1);
							}
						}else{
							numeroSequencialAvisoBancario = 0;
						}

						// depois de ler a primeira linha atribui ela para falso
						primeiraLinha = false;

					}else{

						// [FS0015]-Verificar a existência do registro código 9
						// verifica se o código do registro é "0", caso seja então
						// não existe o codigo do registro "9" e encerra o caso de uso
						if(codigoRegistro.equals("0")){
							throw new ControladorException("atencao.arquivo.movimento.nao.codigo.9");
						}

						// [FS0016]-Verificar a existência de registros com código inválido na ficha
						// de
						// compensação
						// caso exista no arquivo codigo do registro diferente de "0" , "1" , "3" ,
						// "5"
						// e "9"
						if(!codigoRegistro.equals("0") && !codigoRegistro.equals("1") && !codigoRegistro.equals("3")
										&& !codigoRegistro.equals("5") && !codigoRegistro.equals("9")){
							throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
						}

						// verifica se o código do registro é diferente de "9", caso seja
						// diferente de "1" e de "5" então adiciona
						// a linha na coleção de linhas para depois serem processadas
						if(!codigoRegistro.equals("9")){

							if(codigoRegistro.equals("5")){
								RegistroHelperCodigo5 registroHelperCodigo5 = (RegistroHelperCodigo5) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
												linha, null);

								BigDecimal valorTITCarteira07 = Util
												.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo5
																.getValorTITCarteira07());

								somatorioValorTITCarteira07 = somatorioValorTITCarteira07.add(valorTITCarteira07);
							}else if(!codigoRegistro.equals("1")){
								linhas.add(linha);
							}

						}else{

							// se entrou no else então é porque tem registro 9 então seta o boolean
							// para
							// true
							verificaRegistro9 = true;

							// caso código do registro seja "9" então processa a coleção
							// de linhas e inseri o movimento de arrecadadores
							RegistroHelperCodigo9 registroHelperCodigo9 = (RegistroHelperCodigo9) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
											linha, null);

							// caso a quantidade de registros for diferente da
							// quantidade de registros do txt então ecerra o caso de uso
							if(Integer.parseInt(registroHelperCodigo9.getQtdeRegistrosArquivo().trim()) != countRegistros){
								throw new ControladorException("atencao.total.registros.invalido");
							}

							/*
							 * [SB0012]-Processar Movimento da Ficha de Compensação [SF0013] -
							 * Inserir o
							 * movimento do arrecadador da ficha de Compensação
							 * Autor: Vivianne Sousa Data: 27/11/2007
							 */
							arrecadadorMovimento = inserirMovimentoArrecadadorFichaCompensacao(registroHelperCodigo0,
											somatorioValorTITCarteira07, registroHelperCodigo9, idTipoMovimento, null);
							arrecadadoresMovimentoRetorno.add(arrecadadorMovimento);

							Date dataGeracao = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigo0.getDataGeracaoArquivo());

							// cria uma iterator para pegar linha a linha da coleção de linhas
							Iterator linhaIterator = linhas.iterator();
							// int aux = 1;
							while(linhaIterator.hasNext()){

								// System.out.println("LINHA:" + aux);
								// aux++;

								// cria uma variavel da descrição da ocorrencia do movimento com o
								// valor
								// setado para OK
								descricaoOcorrenciaMovimento = "OK";

								// cria uma variavel do indicador de aceitação do registro do
								// movimento
								indicadorAceitacaoRegistroMovimento = 1;

								// cria uma variavel para validar data
								boolean dataInvalida = false;
								boolean valorDebitoInvalido = false;
								Date dataDebito = null;

								// recupera a linha da coleção
								String linhaRegistro = (String) linhaIterator.next();

								// recupera o código do registro de cada linha
								Integer codigoRegistroInteger = Integer.valueOf(linhaRegistro.substring(7, 8));

								switch(codigoRegistroInteger){

									case 3:
										/*
										 * [SB0012]-Processar Movimento da Ficha de Compensação
										 * [SF0014] - Processar Registro Código 3
										 * Autor: Vivianne Sousa
										 * Data: 27/11/2007
										 */

										String linhaRegistroCodigoT = linhaRegistro;
										RegistroHelperCodigo3T registroHelperCodigo3T = (RegistroHelperCodigo3T) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
														linhaRegistroCodigoT, null);

										String linhaRegistroCodigoU = (String) linhaIterator.next();
										RegistroHelperCodigo3U registroHelperCodigo3U = (RegistroHelperCodigo3U) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
														linhaRegistroCodigoU, null);

										boolean dataExcludentes = false;

										// valida a data de pagamento
										// [FS0017]-Validar data de débito/pagamento da ficha
										dataInvalida = Util.validarDiaMesAnoSemBarra(registroHelperCodigo3U.getDataOcorrencia());
										if(dataInvalida){
											dataExcludentes = true;
											descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO INVÁLIDA";
										}
										// caso a data seja inválida não verifica se é maior que a
										// data
										// atual
										if(!dataExcludentes){

											// verifica se a data de bedito/pagamento é superior a
											// atual
											dataDebito = Util.converteStringSemBarraParaDate(registroHelperCodigo3U.getDataOcorrencia());
											if(dataDebito.after(new Date())){
												descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO POSTERIOR A DATA CORRENTE";
											}
										}

										// valida o valor recebido
										// [FS0018]-Validar valor debitado/recebido da ficha
										valorDebitoInvalido = Util.validarValorNaoNumerico(registroHelperCodigo3U.getValorPagoSacado());
										if(valorDebitoInvalido){
											descricaoOcorrenciaMovimento = "VALOR DEBITADO/RECEBIDO NÃO NUMÉRICO";
										}
										BigDecimal valorRecebido = Util
														.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3U
																		.getValorPagoSacado());

										// caso a descricao de movimento seja igual a OK
										if(descricaoOcorrenciaMovimento.equals("OK")){

											String nossoNumero = registroHelperCodigo3T.getNossoNumero();

											/*
											 * [UC0724]-Processar Pagamento com Ficha de Compensação
											 * Autor: Vivianne Sousa
											 * Data: 27/11/2007
											 */
											PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = processarPagamentosFichaCompensacao(
															sistemaParametro, dataDebito, valorRecebido, nossoNumero);

											// seta a descricao da ocorrencia do caso de uso
											// [UC0724] - Processar Pagamento com Ficha de
											// Compensaçãos
											descricaoOcorrenciaMovimento = pagamentoHelperCodigoBarras.getDescricaoOcorrencia();

											// seta o indicador daaceitação do caso de uso
											// [UC0724] - Processar Pagamento com Ficha de
											// Compensação
											indicadorAceitacaoRegistroMovimento = Integer.parseInt(pagamentoHelperCodigoBarras
															.getIndicadorAceitacaoRegistro());

											Integer codigoBanco = Integer.valueOf(registroHelperCodigo0.getCodigoBancoCompensacao());

											// determina a data prevista para p crédito
											Date dataPrevistaCredito = Util.adicionarNumeroDiasDeUmaData(dataDebito, 2);

											// pesquisa o aviso bancario passando o código do banco
											// a
											// data de geração do
											// arquivo e a data prevista calculada
											AvisoBancario avisoBancario = null;
											avisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(codigoBanco, dataGeracao,
															dataPrevistaCredito, arrecadadorMovimento.getId());
											// try {
											// } catch (ErroRepositorioException e) {
											// throw new ControladorException("erro.sistema", e);
											// }

											// 3.4.4.Parte que determina os valores calculado e
											// informado do
											// pagamento e da devolução
											BigDecimal valorCalcPagamento = BigDecimal.ZERO;
											BigDecimal valorCalcDevolucao = BigDecimal.ZERO;
											BigDecimal valorInfPagamento = valorRecebido;
											BigDecimal valorInfDevolucao = BigDecimal.ZERO;

											// caso o indicador de aceitação for igual a 1(SIM)
											if(indicadorAceitacaoRegistroMovimento == 1){

												Integer idImovelPagamento = null;
												if(pagamentoHelperCodigoBarras.getColecaoPagamentos() != null
																&& !pagamentoHelperCodigoBarras.getColecaoPagamentos().isEmpty()){

													Pagamento pagamento = (Pagamento) Util
																	.retonarObjetoDeColecao(pagamentoHelperCodigoBarras
																					.getColecaoPagamentos());

													if(pagamento.getImovel() != null){
														idImovelPagamento = pagamento.getImovel().getId();
													}
												}

												// [SB0016]-Insere o item movimento arrecadador da
												// ficha
												// de compensação
												Integer idArrecadadorMovimentoItem = inserirItemMovimentoArrecadadorFichaCompensacao(
																linhaRegistroCodigoT, linhaRegistroCodigoU, arrecadadorMovimento.getId(),
																descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento,
																idImovelPagamento);

												ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
												arrecadadorMovimentoItem.setId(idArrecadadorMovimentoItem);

												// verifica se o aviso bancario é diferente de nulo
												// Alterado por Sávio Luiz
												// Data: 04/01/2007
												if(avisoBancario != null
																&& avisoBancario.getValorArrecadacaoCalculado().compareTo(BigDecimal.ZERO) == 0){

													// recupera a coleção de pagamentos do caso de
													// uso
													// [UC0724] - Processar Pagamento com Ficha de
													// Compensação
													// para setar o aviso bancário no objeto
													// pagamento
													Collection pagamentosFichaCompensacao = pagamentoHelperCodigoBarras
																	.getColecaoPagamentos();
													Iterator pagamentosFichaCompensacaoIterator = pagamentosFichaCompensacao.iterator();

													while(pagamentosFichaCompensacaoIterator.hasNext()){
														Pagamento pagamento = (Pagamento) pagamentosFichaCompensacaoIterator.next();

														// adiciona o valor de pagamento
														valorCalcPagamento = valorCalcPagamento.add(pagamento.getValorPagamento());

														pagamento.setAvisoBancario(avisoBancario);
														pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

														// adiciona o pagamento na coleção de
														// pagamentos
														pagamentos.add(pagamento);
													}

												}else{
													// recupera a coleção de pagamentos do caso de
													// uso
													// [UC0724] - Processar Pagamento com Ficha de
													// Compensação
													// para setar o aviso bancário no objeto
													// pagamento
													Collection pagamentosFichaCompensacao = pagamentoHelperCodigoBarras
																	.getColecaoPagamentos();
													Iterator pagamentosFichaCompensacaoIterator = pagamentosFichaCompensacao.iterator();

													while(pagamentosFichaCompensacaoIterator.hasNext()){
														Pagamento pagamento = (Pagamento) pagamentosFichaCompensacaoIterator.next();

														// seta o aviso bancario para null
														pagamento.setAvisoBancario(null);

														// seta o valor da data prevista para quando
														// for
														// inserir o pagamento saber de que aviso
														// bancário o
														// pagamento está relacionádo.
														pagamento.setDataPrevistaCreditoHelper(dataPrevistaCredito);
														pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

														// adiciona o valor de pagamento
														valorCalcPagamento = valorCalcPagamento.add(pagamento.getValorPagamento());

														// adiciona o pagamento na coleção de
														// pagamentos
														pagamentos.add(pagamento);
													}
												}

											}else{
												// insere o item movimento arrecadador
												inserirItemMovimentoArrecadadorFichaCompensacao(linhaRegistroCodigoT, linhaRegistroCodigoU,
																arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
																indicadorAceitacaoRegistroMovimento, null);
											}

											if(avisoBancario != null){

												if(avisoBancario.getValorArrecadacaoCalculado() != null
																&& !avisoBancario.getValorArrecadacaoCalculado().equals("")){
													BigDecimal novoValorArrecadacaoCalculado = avisoBancario.getValorArrecadacaoCalculado()
																	.add(valorCalcPagamento);
													avisoBancario.setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
												}else{
													avisoBancario.setValorArrecadacaoCalculado(valorCalcPagamento);
												}

												if(avisoBancario.getValorDevolucaoCalculado() != null
																&& !avisoBancario.getValorDevolucaoCalculado().equals("")){
													BigDecimal novoValorDevolucaoCalculado = avisoBancario.getValorDevolucaoCalculado()
																	.add(valorCalcDevolucao);
													avisoBancario.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
												}else{
													avisoBancario.setValorDevolucaoCalculado(valorCalcDevolucao);
												}

												if(avisoBancario.getValorArrecadacaoInformado() != null
																&& !avisoBancario.getValorArrecadacaoInformado().equals("")){
													BigDecimal novoValorArrecadacaoInformado = avisoBancario.getValorArrecadacaoInformado()
																	.add(valorInfPagamento);
													avisoBancario.setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
													avisoBancario.setValorRealizado(novoValorArrecadacaoInformado);
												}else{
													avisoBancario.setValorArrecadacaoInformado(valorInfPagamento);
													avisoBancario.setValorRealizado(valorInfPagamento);
												}

												if(avisoBancario.getValorPagamentoNaoClassificado() != null){
													BigDecimal novoValorNaoClassificado = avisoBancario.getValorPagamentoNaoClassificado()
																	.add(valorInfPagamento);
													avisoBancario.setValorPagamentoNaoClassificado(novoValorNaoClassificado);
												}else{
													avisoBancario.setValorPagamentoNaoClassificado(valorInfPagamento);
												}

												// se for atualiza o valor da arrecadação no aviso
												// bancario
												avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);
												avisoBancario.setUltimaAlteracao(new Date());

												// atualiza o aviso bancário
												repositorioUtil.atualizar(avisoBancario);
												// try {
												// } catch (ErroRepositorioException e) {
												// throw new ControladorException("erro.sistema",
												// e);
												// }
											}else{
												Iterator avisosBancarioIterator = avisosBancarios.iterator();

												// cria um boolean para saber se existe algum aviso
												// bancario da
												// coleção com a mesma data prevista da data
												// prevista
												// calculada anteriormente
												boolean achou = false;
												while(avisosBancarioIterator.hasNext()){
													AvisoBancario avisoBancarioDaColecao = (AvisoBancario) avisosBancarioIterator.next();
													boolean comparaDataIguais = Util.datasIguais(avisoBancarioDaColecao.getDataPrevista(),
																	dataPrevistaCredito);
													if(comparaDataIguais){

														if(avisoBancarioDaColecao.getValorArrecadacaoCalculado() != null
																		&& !avisoBancarioDaColecao.getValorArrecadacaoCalculado()
																						.equals("")){
															BigDecimal novoValorArrecadacaoCalculado = avisoBancarioDaColecao
																			.getValorArrecadacaoCalculado().add(valorCalcPagamento);
															avisoBancarioDaColecao
																			.setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
														}else{
															avisoBancarioDaColecao.setValorArrecadacaoCalculado(valorCalcPagamento);
														}

														if(avisoBancarioDaColecao.getValorDevolucaoCalculado() != null
																		&& !avisoBancarioDaColecao.getValorDevolucaoCalculado().equals("")){
															BigDecimal novoValorDevolucaoCalculado = avisoBancarioDaColecao
																			.getValorDevolucaoCalculado().add(valorCalcDevolucao);
															avisoBancarioDaColecao.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
														}else{
															avisoBancarioDaColecao.setValorDevolucaoCalculado(valorCalcDevolucao);
														}

														if(avisoBancarioDaColecao.getValorArrecadacaoInformado() != null
																		&& !avisoBancarioDaColecao.getValorArrecadacaoInformado()
																						.equals("")){
															BigDecimal novoValorArrecadacaoInformado = avisoBancarioDaColecao
																			.getValorArrecadacaoInformado().add(valorInfPagamento);
															avisoBancarioDaColecao
																			.setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
															avisoBancarioDaColecao.setValorRealizado(novoValorArrecadacaoInformado);
														}else{
															avisoBancarioDaColecao.setValorArrecadacaoInformado(valorInfPagamento);
															avisoBancarioDaColecao.setValorRealizado(valorInfPagamento);
														}

														if(avisoBancarioDaColecao.getValorPagamentoNaoClassificado() != null){
															BigDecimal novoValorNaoClassificado = avisoBancarioDaColecao
																			.getValorPagamentoNaoClassificado().add(valorInfPagamento);
															avisoBancarioDaColecao
																			.setValorPagamentoNaoClassificado(novoValorNaoClassificado);
														}else{
															avisoBancarioDaColecao.setValorPagamentoNaoClassificado(valorInfPagamento);
														}

														achou = true;
														break;
													}
												}
												if(!achou){

													// chama o método para cria o objeto do aviso
													// bancário
													avisoBancario = gerarOcorrenciaFichaAvisoBancario(arrecadadorMovimento.getId(),
																	registroHelperCodigo0, dataPrevistaCredito,
																	sistemaParametro.getAnoMesArrecadacao(),
																	registroHelperCodigo0.getCodigoBancoCompensacao(), valorCalcPagamento,
																	valorInfPagamento, valorCalcDevolucao, valorInfDevolucao,
																	numeroSequencialAvisoBancario, arrecadadorContrato);
													numeroSequencialAvisoBancario += 1;

													// adiciona o aviso bancário na coleção de
													// avisos
													// bancários
													avisosBancarios.add(avisoBancario);
												}
											}

										}else{

											// 6.caso contrario, seta o indicador de aceitação do
											// registro do movimento para 2(NÃO)
											indicadorAceitacaoRegistroMovimento = 2;

											// inseri o item movimento arrecadador
											inserirItemMovimentoArrecadadorFichaCompensacao(linhaRegistroCodigoT, linhaRegistroCodigoU,
															arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
															indicadorAceitacaoRegistroMovimento, null);
										}
										break;

									// caso não tenha sido nenhuma das opções anteriores
									default:
										descricaoOcorrenciaMovimento = "CÓDIGO DE MOVIMENTO NÃO IDENTIFICADO";

										// o indicador de aceitação é setado para 2(NÃO)
										indicadorAceitacaoRegistroMovimento = 2;

										// inseri o item movimento arrecadador
										inserirItemMovimentoArrecadador(linhaRegistro, arrecadadorMovimento.getId(),
														descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento, null);
								}
							}

							// verifica se a coleção de avisos bancario é diferente de nulo
							if(avisosBancarios != null && !avisosBancarios.isEmpty()){
								Iterator avisosBancarioIterator = avisosBancarios.iterator();
								while(avisosBancarioIterator.hasNext()){
									AvisoBancario avisoBancario = (AvisoBancario) avisosBancarioIterator.next();

									// insere o aviso bancário na base e recupera o id
									Integer idAvisoBancario = (Integer) getControladorUtil().inserir(avisoBancario);

									avisoBancario.setId(idAvisoBancario);
								}
							}

							// verifica se a coleção de pagamentos está diferente de nulo
							if(pagamentos != null && !pagamentos.isEmpty()){

								// Collection colecaoPagamentos = new ArrayList();

								Iterator pagamentoIterator = pagamentos.iterator();
								while(pagamentoIterator.hasNext()){

									Pagamento pagamento = (Pagamento) pagamentoIterator.next();

									// verifica se existe o aviso bancario no pagamento,
									// se não existe então seta o aviso bancario no pagamento
									if(pagamento.getAvisoBancario() == null || pagamento.getAvisoBancario().equals("")){

										Iterator avisosBancarioIterator = avisosBancarios.iterator();
										while(avisosBancarioIterator.hasNext()){
											AvisoBancario avisoBancario = (AvisoBancario) avisosBancarioIterator.next();

											// caso a data prevista seja a mesma
											// estão seta o aviso bancário no pagamento
											boolean comparaDataIguais = Util.datasIguais(pagamento.getDataPrevistaCreditoHelper(),
															avisoBancario.getDataPrevista());
											if(comparaDataIguais){
												pagamento.setAvisoBancario(avisoBancario);
												break;
											}
										}
									}
									// colecaoPagamentos.add(pagamento);
								}

								getControladorBatch().inserirColecaoObjetoParaBatch((Collection) pagamentos);

								// 11. Para cada pagamento da coleção inserido o sistema efetua a
								// classificação do pagamento <<Inclui>>
								// [UC0300 – ClassificarPagamentosDevolucoes] - PARTE 2
								if(pagamentos != null && !pagamentos.isEmpty()){
									for(Pagamento pagamentoTemp : (Collection<Pagamento>) pagamentos){
										// Collection<Pagamento> pagamentosClassificados =
										// this.classificarPagamentos(pagamentoTemp);

										// ** Alteração do Classificar **
										// this.classificarPagamentos(pagamentoTemp);
										this.classificarPagamentosRegistroMovimentoArrecadadores(pagamentoTemp);
										// ** Alteração do Classificar **

										OperacaoContabilHelper helper = this.definirOrigemOperacaoContabilPagamento(pagamentoTemp, false);
										getControladorContabil().registrarLancamentoContabil(helper.getObjetoOrigem(),
														helper.getOperacaoContabil());
									}
								}
							}

							arrecadadorContrato.setNumeroSequencialArquivoRetornoFichaCompensacao(numeroSequecialArquivoRetornoFichaComp);

							// System.out.println("******************FIM SEQUENCIAL FICHA COMPENSACAO "
							// + numeroSequecialArquivoRetornoFichaComp);

							// atualiza arrecadação contrato na base
							repositorioArrecadacao.atualizarDadosArrecadadorContrato(arrecadadorContrato, flagEnvioDebitoAutomatico,
											flagRetornoCodigoBarras, flagRetornoDebitoAutomatico, flagRetornoFichaCompensacao, false,
											false, false);
							// try {
							// } catch (ErroRepositorioException e) {
							// throw new ControladorException("erro.sistema", e);
							// }

							// --PARTE QUE LIMPA OS CAMPOS PARA LER UM NOVO
							// ARQUIVO(CASO EXISTA)--
							// linhas = new ArrayList();
							// registroHelperCodigo0 = null;
							// registroHelperCodigo5 = null;
							// colecaoCodigoRegistrosC = new ArrayList();
							// primeiraLinha = true;
							// avisosBancarios = new ArrayList();
							// pagamentos = new ArrayList();
							// arrecadadorContrato = null;
							// flagEnvioDebitoAutomatico = false;
							// flagRetornoCodigoBarras = false;
							// flagRetornoDebitoAutomatico = false;
							// countRegistros = 0;
							// devolucoes = new ArrayList();
							// somatorioValorTITCarteira07 = BigDecimal.ZERO;
						}
					}
				}

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
			// caso não exista o registro 9.
			if(!verificaRegistro9){
				throw new ControladorException("atencao.arquivo.movimento.nao.codigo.z");
			}
		}else{

			// Fluxo para tratamento do tipo de movimento Boleto Bancário
			this.validarArquivoMovimentoArrecadadorBoletoBancario(stringBuilderTxt, arrecadador, quantidadeRegistros, idTipoMovimento);
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SF0009] - Inserir o item de movimento do arrecadador
	 * 
	 * @author Sávio Luiz
	 * @date 30/01/2006
	 */
	public Integer inserirItemMovimentoArrecadador(String linhaRegistro, Integer idMovimento, String descricaoOcorrencia,
					int indicadorAceitacaoRegistro, Integer idImovelPagamento) throws ControladorException{

		Integer idArrecadadorMovimentoItem = null;

		// Recupera o código do registro de cada linha
		String codigoRegistro = linhaRegistro.substring(0, 1);

		/* Recupera o id do registro da tabela REGSITRO_CÓDIGO passando o código do registro */
		Integer idRegistroCodigo = null;
		try{

			idRegistroCodigo = repositorioArrecadacao.pesquisarIdRegistroCodigo(codigoRegistro);
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		// Seta os campos para a inserção em arrecadador movimento item
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();

		RegistroCodigo registroCodigo = new RegistroCodigo();
		registroCodigo.setId(idRegistroCodigo);
		arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);

		String caracterUltimaPosicaoLinha = linhaRegistro.substring(linhaRegistro.length() - 1);

		String linhaRegistroAuxiliar = "";
		if(caracterUltimaPosicaoLinha.equals(" ")){

			linhaRegistroAuxiliar = linhaRegistro.substring(0, linhaRegistro.length() - 1) + "*";
		}else{

			linhaRegistroAuxiliar = linhaRegistro;
		}

		arrecadadorMovimentoItem.setConteudoRegistro(linhaRegistroAuxiliar);

		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);

		arrecadadorMovimentoItem.setDescricaoOcorrencia(descricaoOcorrencia);
		arrecadadorMovimentoItem.setIndicadorAceitacao(Short.valueOf(String.valueOf(indicadorAceitacaoRegistro)));
		arrecadadorMovimentoItem.setUltimaAlteracao(new Date());

		if(idImovelPagamento != null){

			Imovel imovel = new Imovel();
			imovel.setId(idImovelPagamento);
			arrecadadorMovimentoItem.setImovel(imovel);
		}

		try{

			idArrecadadorMovimentoItem = (Integer) repositorioUtil.inserir(arrecadadorMovimentoItem);
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return idArrecadadorMovimentoItem;

	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * LEGADO CONTA CAERN
	 * Autor: Raphael Rossiter Data: 30/04/2007
	 */
	private PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasLegadoContaCAERN(
					RegistroHelperCodigoBarras registroHelperCodigoBarras, SistemaParametro sistemaParametro, Date dataPagamento,
					Integer anoMesPagamento, BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();

		boolean matriculaImovelInvalida = false;

		int anoMes = 0;
		Integer idImovelNaBase = null;
		Integer matriculaImovel = null;

		boolean anoMesReferencia = false;

		// Valida matrícula imóvel
		matriculaImovelInvalida = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if(matriculaImovelInvalida){

			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";

		}else{

			// Verifica se existe a matricula do imóvel na base
			matriculaImovel = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1());

			// [FS0008] - Calcular Digito Verificador da Matricula
			Short empresa = Short.parseShort(ConstantesAplicacao.get("empresa.ada_codigo_empresa"));
			if(matriculaImovel != null){
				int digitoModulo11 = Util.obterDigitoVerificadorModulo("" + matriculaImovel, empresa);

				matriculaImovel = Integer.valueOf(matriculaImovel.toString() + digitoModulo11);
			}

			idImovelNaBase = null;

			try{

				idImovelNaBase = repositorioImovel.recuperarMatriculaImovel(matriculaImovel);

			}catch(ErroRepositorioException e){
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			// Se o id do imovel pesquisado na base for diferente de nulo
			if(idImovelNaBase == null){
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}

		// Valida mes/ano referencia
		anoMesReferencia = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		if(!anoMesReferencia){

			anoMes = this.obterMesAnoReferencia(Integer.parseInt(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento2()));

		}else{
			descricaoOcorrencia = "ANO/MÊS DE REFERÊNCIA DA CONTA INVÁLIDA";
		}

		if(descricaoOcorrencia.equals("OK")){

			Integer idLocalidade = null;
			Integer idConta = null;

			int anoMesReferenciaInt = anoMes;

			Imovel imovel = new Imovel();
			imovel.setId(idImovelNaBase);

			try{

				idLocalidade = repositorioLocalidade.pesquisarIdLocalidade(idImovelNaBase);

				idConta = repositorioFaturamento.pesquisarExistenciaContaComSituacaoAtual(imovel, anoMesReferenciaInt);

			}catch(ErroRepositorioException e){
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			if(idConta == null || idConta.equals("")){
				descricaoOcorrencia = "CONTA INEXISTENTE";
			}

			// Cria o objeto pagamento para setar os dados
			Pagamento pagamento = new Pagamento();
			pagamento.setAnoMesReferenciaPagamento(anoMes);

			/*
			 * Caso o ano mes da data de dedito seja maior que o ano mes de arrecadação da tabela
			 * sistema parametro então seta o ano mes da data de
			 * debito
			 */

			if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){

				pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
			}else{

				/*
				 * caso contrario seta o o ano mes arrecadação da tabela sistema parametro
				 */
				pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
			}

			pagamento.setValorPagamento(valorPagamento);
			pagamento.setDataPagamento(dataPagamento);
			pagamento.setPagamentoSituacaoAtual(null);
			pagamento.setPagamentoSituacaoAnterior(null);
			pagamento.setDebitoTipo(null);

			// Verifica se o id da conta é diferente de nulo
			if(idConta != null){

				Conta conta = new Conta();
				conta.setId(idConta);
				pagamento.setConta(conta);

			}else{
				pagamento.setConta(null);
			}

			pagamento.setGuiaPagamentoGeral(null);

			// Verifica se o id da conta é diferente de nulo
			if(idLocalidade != null){

				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);

			}else{
				pagamento.setLocalidade(null);
			}

			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.CONTA);
			pagamento.setDocumentoTipo(documentoTipo);

			pagamento.setAvisoBancario(null);

			if(idImovelNaBase != null){

				pagamento.setImovel(imovel);

			}else{
				pagamento.setImovel(null);
			}

			pagamento.setArrecadadorMovimentoItem(null);

			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
			arrecadacaoForma.setId(idFormaPagamento);
			pagamento.setArrecadacaoForma(arrecadacaoForma);
			pagamento.setCliente(null);
			pagamento.setUltimaAlteracao(new Date());

			colecaoPagamentos.add(pagamento);

		}else{

			// Atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0001] – Processar Pagamento de Conta
	 * CONTA
	 * 
	 * @author Raphael Rossiter
	 * @date 02/05/2007
	 * @author eduardo henrique
	 * @date 17/12/2008
	 *       Correção para adequação à descrição do UC. Não deve-se rejeitar registro caso não
	 *       encontre Conta.
	 *       Inclusão da pesquisa em Conta Histórico, caso não se encontre em Conta.
	 * @author Saulo Lima
	 * @date 12/01/2009
	 *       Colocar a referência no pagamento caso a Conta esteja em histórico
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasConta(RegistroHelperCodigoBarras registroHelperCodigoBarras,
					SistemaParametro sistemaParametro, Date dataPagamento, Integer anoMesPagamento, BigDecimal valorPagamento,
					Integer idFormaPagamento) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();

		boolean matriculaImovelInvalida = false;

		int anoMes = 0;
		Integer idImovelNaBase = null;
		Integer matriculaImovel = null;

		boolean anoMesReferencia = false;

		matriculaImovelInvalida = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if(matriculaImovelInvalida){
			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";
		}else{

			/*
			 * Verifica se existe a matricula do imóvel na base
			 */
			matriculaImovel = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1());

			idImovelNaBase = null;

			try{
				idImovelNaBase = repositorioImovel.recuperarMatriculaImovel(matriculaImovel);
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			/*
			 * Se o id do imovel pesquisado na base for diferente de nulo
			 */
			if(idImovelNaBase == null){
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}

		anoMesReferencia = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		if(anoMesReferencia){

			// valida o namo mes de referencia da conta
			descricaoOcorrencia = "ANO/MÊS DE REFERÊNCIA DA CONTA INVÁLIDA";
		}else{
			anoMes = Util.formatarMesAnoParaAnoMes(Integer.parseInt(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento2()));

		}

		if(descricaoOcorrencia.equals("OK")){

			Integer idLocalidade = null;

			Integer idConta = null;
			Collection idsContas = null;

			// Valida o amo mes de referencia da conta
			int anoMesReferenciaInt = Util.formatarMesAnoParaAnoMes(Integer.parseInt(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2()));

			Imovel imovel = new Imovel();
			imovel.setId(idImovelNaBase);

			try{

				idConta = repositorioFaturamento.pesquisarExistenciaContaComSituacaoAtual(imovel, anoMesReferenciaInt);

				if(idConta == null){

					// Tenta encontrar referência em histórico
					idsContas = repositorioFaturamento.pesquisarExistenciaContaHistoricoPorRefEImovel(imovel, anoMesReferenciaInt);

					if(idsContas == null || idsContas.isEmpty()){
						idLocalidade = repositorioLocalidade.pesquisarIdLocalidade(idImovelNaBase);

						descricaoOcorrencia = "CONTA INEXISTENTE";

						indicadorAceitacaoRegistro = "2";
					}else{

						idConta = (Integer) Util.retonarObjetoDeColecao(idsContas);

						FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
						filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, idConta));

						Collection<ContaHistorico> colecaoContaHistorico = this.getControladorUtil().pesquisar(filtroContaHistorico,
										ContaHistorico.class.getName());

						ContaHistorico contaHistorico = (ContaHistorico) Util.retonarObjetoDeColecao(colecaoContaHistorico);

						Localidade localidade = contaHistorico.getLocalidade();
						idLocalidade = localidade.getId();
					}
				}else{
					FiltroConta filtroConta = new FiltroConta();
					filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, idConta));

					Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

					Conta conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

					Localidade localidade = conta.getLocalidade();
					idLocalidade = localidade.getId();
				}

			}catch(ErroRepositorioException e){
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			// Cria o objeto pagamento para setar os dados
			Pagamento pagamento = new Pagamento();
			pagamento.setAnoMesReferenciaPagamento(anoMes);

			/*
			 * Caso o ano mes da data de dedito seja maior que o ano mes de arrecadação da tabela
			 * sistema parametro então seta o ano mes da data de
			 * debito
			 */
			if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){

				pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

			}else{

				/*
				 * caso contrario seta o o ano mes arrecadação da tabela sistema parametro
				 */
				pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
			}

			pagamento.setValorPagamento(valorPagamento);
			pagamento.setDataPagamento(dataPagamento);
			pagamento.setPagamentoSituacaoAtual(null);
			pagamento.setPagamentoSituacaoAnterior(null);
			pagamento.setDebitoTipo(null);

			// Verifica se o id da conta é diferente de nulo
			if(idConta != null){

				Conta conta = new Conta();
				conta.setId(idConta);
				pagamento.setConta(conta);

			}else{

				pagamento.setConta(null);
			}
			pagamento.setGuiaPagamentoGeral(null);

			Localidade localidade = new Localidade();
			localidade.setId(idLocalidade);
			pagamento.setLocalidade(localidade);

			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.CONTA);
			pagamento.setDocumentoTipo(documentoTipo);
			pagamento.setAvisoBancario(null);

			if(idImovelNaBase != null){
				pagamento.setImovel(imovel);
			}else{
				pagamento.setImovel(null);
			}

			pagamento.setArrecadadorMovimentoItem(null);

			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
			arrecadacaoForma.setId(idFormaPagamento);
			pagamento.setArrecadacaoForma(arrecadacaoForma);
			pagamento.setCliente(null);
			pagamento.setUltimaAlteracao(new Date());
			pagamento.setNumeroPrestacao(null);

			colecaoPagamentos.add(pagamento);

		}else{
			// atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0002] – Processar Pagamento de Guia de Pagamento Matrícula
	 * GUIA DE PAGAMENTO
	 * 
	 * @author Raphael Rossiter
	 * @date 02/05/2007
	 * @author Saulo Lima
	 * @date 09/12/2008
	 *       Customização para adequar Guia de Pagamento
	 * @author Eduardo Henrique
	 * @date 17/12/2008
	 *       Correção para não invalidar registro caso não se encontre Guia de Pagamento
	 * @author Saulo Lima
	 * @throws ErroRepositorioException
	 * @date 12/01/2009
	 *       Colocar a referência no pagamento caso a Guia Pagamento esteja em histórico
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasGuiaPagamento(
					RegistroHelperCodigoBarras registroHelperCodigoBarras, SistemaParametro sistemaParametro, Date dataPagamento,
					Integer anoMesPagamento, BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException{

		Collection<Pagamento> colecaoPagamentos = new ArrayList();

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection<Integer> colecaoDebitoCreditoSituacaoAtual = new ArrayList<Integer>();

		colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.NORMAL);
		colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.RETIFICADA);
		colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.INCLUIDA);
		colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
		colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.PRESCRITA);

		Integer idGuiaPagamentoNaBase = null;

		Short numeroPrestacaoNaBase = null;

		Localidade localidade = null;

		Integer idLocalidade = null;

		Imovel imovel = null;

		// Id Guia de Pagamento
		Integer idGuiaPagamento = null;

		String idGuiaPagamentoStr = registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2();

		boolean idGuiaPagamentoInvalida = Util.validarValorNaoNumerico(idGuiaPagamentoStr);

		if(idGuiaPagamentoInvalida){
			descricaoOcorrencia = "IDENTIFICAÇÃO DA GUIA NÃO NUMÉRICO";
		}else{
			idGuiaPagamento = Integer.valueOf(idGuiaPagamentoStr);
		}

		// Número Prestação Guia de Pagamento
		Short numeroPrestacao = null;

		String numeroPrestacaoStr = registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3();

		boolean numeroPrestacaoInvalida = Util.validarValorNaoNumerico(numeroPrestacaoStr);

		if(numeroPrestacaoInvalida){
			descricaoOcorrencia = "NÚMERO DA PARCELA NÃO NUMÉRICO";
		}else{
			numeroPrestacao = Short.valueOf(numeroPrestacaoStr);
		}

		// Imóvel
		String idImovelStr = registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1();

		idImovelStr = Util.removerZerosEsquerda(idImovelStr);

		if(!Util.isVazioOuBrancoOuZero(idImovelStr)){
			Integer idImovel = null;

			boolean matriculaImovelInvalido = Util.validarValorNaoNumerico(idImovelStr);

			if(matriculaImovelInvalido){
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL INVÁLIDA";
			}else{
				FiltroImovel filtroImovel = new FiltroImovel();
				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovelStr));

				Collection<Imovel> colecaoImovel = this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());

				if(Util.isVazioOrNulo(colecaoImovel)){
					descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
				}else{
					idImovel = Integer.valueOf(idImovelStr);
				}
			}

			if(descricaoOcorrencia.equals("OK")){
				FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
				filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));
				filtroGuiaPagamento.adicionarParametro(new ParametroSimplesColecao(FiltroGuiaPagamento.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
								colecaoDebitoCreditoSituacaoAtual));

				Collection<GuiaPagamento> colecaoGuiaPagamento = this.getControladorUtil().pesquisar(filtroGuiaPagamento,
								GuiaPagamento.class.getName());

				if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){
					GuiaPagamento guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);

					localidade = guiaPagamento.getLocalidade();
				}else{
					FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
					filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID, idGuiaPagamento));
					filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimplesColecao(
									FiltroGuiaPagamentoHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID, colecaoDebitoCreditoSituacaoAtual));

					Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = getControladorUtil().pesquisar(
									filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());

					if(!Util.isVazioOrNulo(colecaoGuiaPagamentoHistorico)){
						GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
										.retonarObjetoDeColecao(colecaoGuiaPagamentoHistorico);

						localidade = guiaPagamentoHistorico.getLocalidade();
					}else{
						descricaoOcorrencia = "PRESTACAO DA GUIA DE PAGAMENTO INEXISTENTE";
					}
				}

				if(descricaoOcorrencia.equals("OK")){
					FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
					filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
									idGuiaPagamento));
					filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
									numeroPrestacao));

					Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = this.getControladorUtil().pesquisar(
									filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

					if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){
						GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) Util
										.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);

						idGuiaPagamentoNaBase = idGuiaPagamento;

						numeroPrestacaoNaBase = numeroPrestacao;

						if(localidade != null){
							idLocalidade = localidade.getId();
						}

						try{
							this.repositorioArrecadacao.atualizarIndicadorGuiaPagamentoPrestacao(idGuiaPagamento, numeroPrestacao,
											ConstantesSistema.SIM);
						}catch(ErroRepositorioException e){
							e.printStackTrace();
							throw new ControladorException("erro.sistema", e);
						}

						// [SB0017] Gerar boletos bancários para prestações de guia de pagamento].
						this.gerarBoletoBancarioParaPrestacoesGuiaPagamento(idGuiaPagamento, numeroPrestacao);

						// [SB0020] Verificar Guia de Pagamento do Programa Água para Todos
						this.verificarGuiaPagamentoAguaParaTodos(guiaPagamentoPrestacao);

						// [SB0024] Verificar Guia de Pagamento de Boleto Bancário
						this.verificarGuiaPagamentoBoletoBancario(idGuiaPagamento, numeroPrestacao.intValue());
					}else{
						FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
						filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
										FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
						filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
										FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacao));

						Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil()
										.pesquisar(filtroGuiaPagamentoPrestacaoHistorico, GuiaPagamentoPrestacaoHistorico.class.getName());

						if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){

							idGuiaPagamentoNaBase = idGuiaPagamento;

							numeroPrestacaoNaBase = numeroPrestacao;

							if(localidade != null){
								idLocalidade = localidade.getId();
							}

							try{

								this.repositorioArrecadacao.atualizarIndicadorGuiaPagamentoPrestacaoHistorico(idGuiaPagamento,
												numeroPrestacao, ConstantesSistema.SIM);

							}catch(ErroRepositorioException e){
								e.printStackTrace();
								throw new ControladorException("erro.sistema", e);
							}

							// [SB0017] Gerar boletos bancários para prestações de guia de pagamento
							this.gerarBoletoBancarioParaPrestacoesGuiaPagamento(idGuiaPagamento, numeroPrestacao);

							// [SB0024] Verificar Guia de Pagamento de Boleto Bancário
							this.verificarGuiaPagamentoBoletoBancario(idGuiaPagamento, numeroPrestacao.intValue());

						}else{
							descricaoOcorrencia = "PRESTACAO DA GUIA DE PAGAMENTO INEXISTENTE";
						}

					}
				}

				// Cria o objeto pagamento para setar os dados
				Pagamento pagamento = new Pagamento();
				pagamento.setAnoMesReferenciaPagamento(null);

				// Caso o ano mes da data de dedito seja maior que o ano mes de arrecadação da
				// tabela
				// sistema parametro então seta o ano mes da data de debito
				if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
					pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

				}else{
					// Caso contrario seta o o ano mes arrecadação da tabela sistema parametro
					pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
				}

				pagamento.setValorPagamento(valorPagamento);
				pagamento.setDataPagamento(dataPagamento);
				pagamento.setPagamentoSituacaoAtual(null);
				pagamento.setPagamentoSituacaoAnterior(null);
				pagamento.setDebitoTipo(null);
				pagamento.setConta(null);

				// Verifica se o id da guia é diferente de nulo
				if(idGuiaPagamentoNaBase != null){
					GuiaPagamento guiaPagamento = new GuiaPagamento();
					guiaPagamento.setId(idGuiaPagamentoNaBase);

					GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
					guiaPagamentoGeral.setId(idGuiaPagamentoNaBase);
					guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);

					pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
				}else{
					pagamento.setGuiaPagamentoGeral(null);
				}

				if(idLocalidade != null){
					pagamento.setLocalidade(localidade);
				}else{
					String codigoPadraoLocalidade = ParametroCadastro.P_LOCA_ID_LOCALIDADE_PADRAO.executar();
					pagamento.setLocalidade(new Localidade(Integer.valueOf(codigoPadraoLocalidade)));
				}

				DocumentoTipo documentoTipo = new DocumentoTipo();
				documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
				pagamento.setDocumentoTipo(documentoTipo);

				pagamento.setAvisoBancario(null);

				imovel = new Imovel();
				imovel.setId(idImovel);

				pagamento.setImovel(imovel);

				pagamento.setArrecadadorMovimentoItem(null);

				ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				arrecadacaoForma.setId(idFormaPagamento);

				pagamento.setArrecadacaoForma(arrecadacaoForma);

				pagamento.setCliente(null);
				pagamento.setUltimaAlteracao(new Date());

				if(numeroPrestacaoNaBase != null){
					pagamento.setNumeroPrestacao(numeroPrestacaoNaBase.intValue());
				}else{
					pagamento.setNumeroPrestacao(null);
				}

				colecaoPagamentos.add(pagamento);
			}else{
				indicadorAceitacaoRegistro = "2";
			}
		}else{
			if(descricaoOcorrencia.equals("OK")){
				FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
				filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));
				filtroGuiaPagamento.adicionarParametro(new ParametroSimplesColecao(FiltroGuiaPagamento.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
								colecaoDebitoCreditoSituacaoAtual));

				Collection<GuiaPagamento> colecaoGuiaPagamento = this.getControladorUtil().pesquisar(filtroGuiaPagamento,
								GuiaPagamento.class.getName());

				if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){
					idGuiaPagamentoNaBase = idGuiaPagamento;

					GuiaPagamento guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);

					localidade = guiaPagamento.getLocalidade();

					imovel = guiaPagamento.getImovel();
				}else{
					FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
					filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID, idGuiaPagamento));
					filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimplesColecao(
									FiltroGuiaPagamentoHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID, colecaoDebitoCreditoSituacaoAtual));

					Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = getControladorUtil().pesquisar(
									filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());

					if(!Util.isVazioOrNulo(colecaoGuiaPagamentoHistorico)){
						idGuiaPagamentoNaBase = idGuiaPagamento;

						GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
										.retonarObjetoDeColecao(colecaoGuiaPagamentoHistorico);

						localidade = guiaPagamentoHistorico.getLocalidade();

						imovel = guiaPagamentoHistorico.getImovel();
					}else{
						descricaoOcorrencia = "PRESTACAO DA GUIA DE PAGAMENTO INEXISTENTE";
					}
				}

				if(descricaoOcorrencia.equals("OK")){
					FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
					filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
									idGuiaPagamento));
					filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
									numeroPrestacao));

					Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = this.getControladorUtil().pesquisar(
									filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

					if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){
						GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) Util
										.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);

						numeroPrestacaoNaBase = numeroPrestacao;

						try{

							this.repositorioArrecadacao.atualizarIndicadorGuiaPagamentoPrestacao(idGuiaPagamento, numeroPrestacao,
											ConstantesSistema.SIM);

						}catch(ErroRepositorioException e){
							e.printStackTrace();
							throw new ControladorException("erro.sistema", e);
						}

						// [SB0017] Gerar boletos bancários para prestações de guia de pagamento].
						this.gerarBoletoBancarioParaPrestacoesGuiaPagamento(idGuiaPagamento, numeroPrestacao);

						// [SB0020] Verificar Guia de Pagamento do Programa Água para Todos
						this.verificarGuiaPagamentoAguaParaTodos(guiaPagamentoPrestacao);

						// [SB0024] Verificar Guia de Pagamento de Boleto Bancário
						this.verificarGuiaPagamentoBoletoBancario(idGuiaPagamento, numeroPrestacao.intValue());
					}else{
						FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
						filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
										FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
						filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
										FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacao));

						Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil()
										.pesquisar(filtroGuiaPagamentoPrestacaoHistorico, GuiaPagamentoPrestacaoHistorico.class.getName());

						if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){

							numeroPrestacaoNaBase = numeroPrestacao;

							try{

								this.repositorioArrecadacao.atualizarIndicadorGuiaPagamentoPrestacaoHistorico(idGuiaPagamento,
												numeroPrestacao, ConstantesSistema.SIM);

							}catch(ErroRepositorioException e){
								e.printStackTrace();
								throw new ControladorException("erro.sistema", e);
							}

							// [SB0017] Gerar boletos bancários para prestações de guia de pagamento
							this.gerarBoletoBancarioParaPrestacoesGuiaPagamento(idGuiaPagamento, numeroPrestacao);

							// [SB0024] Verificar Guia de Pagamento de Boleto Bancário
							this.verificarGuiaPagamentoBoletoBancario(idGuiaPagamento, numeroPrestacao.intValue());
						}else{
							descricaoOcorrencia = "PRESTACAO DA GUIA DE PAGAMENTO INEXISTENTE";
						}
					}
				}

				if(descricaoOcorrencia.equals("OK")){
					// Cria o objeto pagamento para setar os dados
					Pagamento pagamento = new Pagamento();
					pagamento.setAnoMesReferenciaPagamento(null);

					// Caso o ano mes da data de dedito seja maior que o ano mes de arrecadação da
					// tabela sistema parametro então seta o ano mes da data de debito
					if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
						pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

					}else{
						// Caso contrario seta o o ano mes arrecadação da tabela sistema parametro
						pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
					}

					pagamento.setValorPagamento(valorPagamento);
					pagamento.setDataPagamento(dataPagamento);
					pagamento.setPagamentoSituacaoAtual(null);
					pagamento.setPagamentoSituacaoAnterior(null);
					pagamento.setDebitoTipo(null);
					pagamento.setConta(null);

					GuiaPagamento guiaPagamento = new GuiaPagamento();
					guiaPagamento.setId(idGuiaPagamentoNaBase);

					GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
					guiaPagamentoGeral.setId(idGuiaPagamentoNaBase);
					guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);

					pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);

					pagamento.setLocalidade(localidade);

					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
					pagamento.setDocumentoTipo(documentoTipo);

					pagamento.setAvisoBancario(null);

					pagamento.setImovel(imovel);

					pagamento.setArrecadadorMovimentoItem(null);

					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
					arrecadacaoForma.setId(idFormaPagamento);

					pagamento.setArrecadacaoForma(arrecadacaoForma);

					pagamento.setCliente(null);
					pagamento.setUltimaAlteracao(new Date());

					pagamento.setNumeroPrestacao(numeroPrestacaoNaBase.intValue());

					colecaoPagamentos.add(pagamento);
				}else{
					indicadorAceitacaoRegistro = "2";
				}
			}else{
				indicadorAceitacaoRegistro = "2";
			}
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0013] – Processar Pagamento de Guia de Pagamento Cliente
	 * GUIA DE PAGAMENTO CLIENTE(Tipo 6)
	 * 
	 * @author Ana Maria
	 * @date 06/08/2007
	 * @author Eduardo Henrique
	 * @date 17/12/2008
	 *       Correção para não invalidar registro caso não se encontre Guia de Pagamento
	 * @author Saulo Lima
	 * @date 12/01/2009
	 *       Colocar a referência no pagamento caso a Guia Pagamento esteja em histórico
	 * @author Virgínia Melo
	 * @date 17/04/2009
	 *       Correção para utilizar localidade padrão caso a mesma não seja recuperada.
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasGuiaPagamentoCliente(
					RegistroHelperCodigoBarras registroHelperCodigoBarras, SistemaParametro sistemaParametro, Date dataPagamento,
					Integer anoMesPagamento, BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();

		// Cliente
		Integer idCliente = null;

		boolean idClienteInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if(idClienteInvalido){
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		}else{
			idCliente = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1());

			try{
				Integer idClienteNaBase = repositorioCliente.verificarExistenciaCliente(Integer.valueOf(idCliente));

				if(idClienteNaBase == null){
					descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO CADASTRADO";
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
		}

		// Id Guia de Pagamento
		Integer idGuiaPagamento = null;

		boolean idGuiaPagamentoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());

		if(idGuiaPagamentoInvalido){
			descricaoOcorrencia = "IDENTIFICAÇÃO DA GUIA NÃO NUMÉRICO";
		}else{
			idGuiaPagamento = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
		}

		// Número Prestação Guia de Pagamento
		Integer numeroPrestacao = null;

		boolean numeroPrestacaoInvalida = Util.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

		if(numeroPrestacaoInvalida){
			descricaoOcorrencia = "NÚMERO DA PARCELA NÃO NUMÉRICO";
		}else{
			numeroPrestacao = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());
		}

		if(descricaoOcorrencia.equals("OK")){
			Localidade localidade = null;

			Integer idLocalidade = null;

			Integer idGuiaPagamentoNaBase = null;

			Integer numeroPrestacaoNaBase = null;

			Collection<Integer> colecaoDebitoCreditoSituacaoAtual = new ArrayList<Integer>();

			colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.NORMAL);
			colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.RETIFICADA);
			colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.INCLUIDA);
			colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
			colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.PRESCRITA);

			FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));
			filtroGuiaPagamento.adicionarParametro(new ParametroSimplesColecao(FiltroGuiaPagamento.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
							colecaoDebitoCreditoSituacaoAtual));

			Collection<GuiaPagamento> colecaoGuiaPagamento = this.getControladorUtil().pesquisar(filtroGuiaPagamento,
							GuiaPagamento.class.getName());

			if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){
				GuiaPagamento guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);

				localidade = guiaPagamento.getLocalidade();
			}else{
				FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
				filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID, idGuiaPagamento));
				filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimplesColecao(
								FiltroGuiaPagamentoHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID, colecaoDebitoCreditoSituacaoAtual));

				Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = this.getControladorUtil().pesquisar(
								filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());

				if(!Util.isVazioOrNulo(colecaoGuiaPagamentoHistorico)){
					GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
									.retonarObjetoDeColecao(colecaoGuiaPagamentoHistorico);

					localidade = guiaPagamentoHistorico.getLocalidade();
				}else{
					descricaoOcorrencia = "GUIA DE PAGAMENTO INEXISTENTE";
				}
			}

			if(descricaoOcorrencia.equals("OK")){
				FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
				filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
								idGuiaPagamento));
				filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
								numeroPrestacao));

				Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = this.getControladorUtil().pesquisar(
								filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

				if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){
					idGuiaPagamentoNaBase = idGuiaPagamento;

					numeroPrestacaoNaBase = numeroPrestacao;

					if(localidade != null){
						idLocalidade = localidade.getId();
					}

					try{

						this.repositorioArrecadacao.atualizarIndicadorGuiaPagamentoPrestacao(idGuiaPagamento, numeroPrestacao.shortValue(),
										ConstantesSistema.SIM);

					}catch(ErroRepositorioException e){
						e.printStackTrace();
						throw new ControladorException("erro.sistema", e);
					}

					// [SB0024] Verificar Guia de Pagamento de Boleto Bancário
					this.verificarGuiaPagamentoBoletoBancario(idGuiaPagamento, numeroPrestacao);

				}else{
					FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
					filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
									FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
					filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
									FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacao));

					Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil()
									.pesquisar(filtroGuiaPagamentoPrestacaoHistorico, GuiaPagamentoPrestacaoHistorico.class.getName());

					if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){
						idGuiaPagamentoNaBase = idGuiaPagamento;

						numeroPrestacaoNaBase = numeroPrestacao;

						if(localidade != null){
							idLocalidade = localidade.getId();
						}

						try{

							this.repositorioArrecadacao.atualizarIndicadorGuiaPagamentoPrestacaoHistorico(idGuiaPagamento,
											numeroPrestacao.shortValue(), ConstantesSistema.SIM);

						}catch(ErroRepositorioException e){
							e.printStackTrace();
							throw new ControladorException("erro.sistema", e);
						}

						// [SB0024] Verificar Guia de Pagamento de Boleto Bancário
						this.verificarGuiaPagamentoBoletoBancario(idGuiaPagamento, numeroPrestacao);

					}else{
						descricaoOcorrencia = "GUIA DE PAGAMENTO INEXISTENTE";
					}
				}
			}

			// Cria o objeto pagamento para setar os dados
			Pagamento pagamento = new Pagamento();
			pagamento.setAnoMesReferenciaPagamento(null);

			// Caso o ano mes da data de dedito seja maior que o ano mes de arrecadação da tabela
			// sistema parametro então seta o ano mes da data de debito
			if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
				pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

			}else{
				// Caso contrario seta o o ano mes arrecadação da tabela sistema parametro
				pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
			}

			pagamento.setValorPagamento(valorPagamento);
			pagamento.setDataPagamento(dataPagamento);
			pagamento.setPagamentoSituacaoAtual(null);
			pagamento.setPagamentoSituacaoAnterior(null);
			pagamento.setDebitoTipo(null);
			pagamento.setConta(null);

			if(idGuiaPagamentoNaBase != null){
				GuiaPagamento guiaPagamento = new GuiaPagamento();
				guiaPagamento.setId(idGuiaPagamentoNaBase);

				GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
				guiaPagamentoGeral.setId(idGuiaPagamentoNaBase);
				guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);

				pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
			}else{
				pagamento.setGuiaPagamentoGeral(null);
			}

			if(idLocalidade != null){
				pagamento.setLocalidade(localidade);
			}else{
				String codigoPadraoLocalidade = ParametroCadastro.P_LOCA_ID_LOCALIDADE_PADRAO.executar();
				pagamento.setLocalidade(new Localidade(Integer.valueOf(codigoPadraoLocalidade)));
			}

			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
			pagamento.setDocumentoTipo(documentoTipo);

			pagamento.setAvisoBancario(null);

			if(idCliente != null){
				Cliente cliente = new Cliente();
				cliente.setId(idCliente);

				pagamento.setCliente(cliente);
			}else{
				pagamento.setCliente(null);
			}

			pagamento.setArrecadadorMovimentoItem(null);

			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
			arrecadacaoForma.setId(idFormaPagamento);
			pagamento.setArrecadacaoForma(arrecadacaoForma);

			pagamento.setImovel(null);
			pagamento.setUltimaAlteracao(new Date());

			if(numeroPrestacaoNaBase != null){
				pagamento.setNumeroPrestacao(numeroPrestacaoNaBase);
			}else{
				pagamento.setNumeroPrestacao(null);
			}

			colecaoPagamentos.add(pagamento);
		}else{
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0015] – Processar Pagamento de Documento de Cobrança - Pré Parcelamento
	 * DOCUMENTO DE COBRANÇA TIPO 2
	 * 
	 * @author Bruno Ferreira dos Santos
	 * @date 16/03/2011
	 * @param registroHelperCodigoBarras
	 * @param sistemaParametro
	 * @param dataPagamento
	 * @param anoMesPagamento
	 * @param valorPagamento
	 * @param idFormaPagamento
	 * @return
	 * @throws ControladorException
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasCobrancaPreParcelamento(
					RegistroHelperCodigoBarras registroHelperCodigoBarras, SistemaParametro sistemaParametro, Date dataPagamento,
					Integer anoMesPagamento, BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
		Collection colecaoPagamentos = new ArrayList();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		boolean codPreParcelamentoOpcaoValido = true;

		Integer idPreParcelamentoOpcao = 0;

		if(Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2())){
			descricaoOcorrencia = "CÓDIGO DO PRÉ PARCELAMENTO NÃO NUMÉRICO";
			codPreParcelamentoOpcaoValido = false;
		}

		if(Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4())){
			descricaoOcorrencia = "TIPO DO DOCUMENTO NÃO NUMÉRICO";
		}

		// valida o numero sequencial do documento
		boolean numeroSequencialDocumentoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

		if(numeroSequencialDocumentoInvalido){
			descricaoOcorrencia = "SEQUENCIAL DO DOCUMENTO NÃO NUMÉRICO";
		}

		if(codPreParcelamentoOpcaoValido){
			idPreParcelamentoOpcao = new Integer(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
			PreParcelamentoOpcao preParcelamentoOpcao = getControladorCobranca().obterPreParcelamentoOpcao(
							new Integer(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2()));
			if(preParcelamentoOpcao == null){
				descricaoOcorrencia = "CÓDIGO DA OPÇÃO DE PRÉ PARCELAMENTO NÃO CADASTRADO";
			}
		}

		if(descricaoOcorrencia.equals("OK")){

			PreParcelamentoOpcao preParcelamentoOpcao = getControladorCobranca().obterCobrancaDocumentoPreParcelamento(
							new Integer(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3()),
							idPreParcelamentoOpcao);

			if(preParcelamentoOpcao != null && preParcelamentoOpcao.getPreParcelamento().getDocumentoCobranca() != null){
				Pagamento pagamento = new Pagamento();

				PreParcelamento preParcelamento = preParcelamentoOpcao.getPreParcelamento();

				CobrancaDocumento cobrancaDocumento = preParcelamento.getDocumentoCobranca();

				pagamento.setAnoMesReferenciaArrecadacao(preParcelamento.getAnoMesReferenciaFaturamento());

				if(preParcelamentoOpcao.getValorEntrada().equals(BigDecimal.ZERO)){
					pagamento.setValorPagamento(preParcelamentoOpcao.getValorPrestacao());
				}else{
					// pagamento.setValorPagamento(preParcelamentoOpcao.getValorEntrada());

					pagamento.setValorPagamento(valorPagamento);
					DebitoTipo debitoTipo = new DebitoTipo();
					debitoTipo.setId(DebitoTipo.ENTRADA_PARCELAMENTO);
					pagamento.setDebitoTipo(debitoTipo);
				}

				pagamento.setDataPagamento(dataPagamento);

				if(cobrancaDocumento.getLocalidade() != null){
					pagamento.setLocalidade(cobrancaDocumento.getLocalidade());
				}else{
					pagamento.setLocalidade(cobrancaDocumento.getImovel().getLocalidade());
				}

				pagamento.setDocumentoTipo(cobrancaDocumento.getDocumentoTipo());
				pagamento.setImovel(cobrancaDocumento.getImovel());

				ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				arrecadacaoForma.setId(idFormaPagamento);

				pagamento.setArrecadacaoForma(arrecadacaoForma);
				pagamento.setUltimaAlteracao(new Date());
				pagamento.setPreParcelamentoOpcao(preParcelamentoOpcao);

				colecaoPagamentos.add(pagamento);

				// 2.3.2. Caso o pré-parcelamento corresponda à entrada ou 1ª. parcela de negociação
				// de débitos
				FiltroCobrancaNegociacaoAtendimento filtroCobrancaNegociacaoAtendimento = new FiltroCobrancaNegociacaoAtendimento();

				filtroCobrancaNegociacaoAtendimento.adicionarParametro(new ParametroSimples(
								FiltroCobrancaNegociacaoAtendimento.PRE_PARCELAMENTO_ID, preParcelamento.getId()));
				filtroCobrancaNegociacaoAtendimento.adicionarCaminhoParaCarregamentoEntidade("registroAtendimento");

				Collection<CobrancaNegociacaoAtendimento> collCobrancaNegociacaoAtendimento = getControladorUtil().pesquisar(
								filtroCobrancaNegociacaoAtendimento, CobrancaNegociacaoAtendimento.class.getName());

				if(collCobrancaNegociacaoAtendimento != null && !collCobrancaNegociacaoAtendimento.isEmpty()){

					// Integer idDocumentoNegociacao =
					// collCobrancaNegociacaoAtendimento.iterator().next().getPreParcelamento().getId();
					Integer idDocumentoNegociacao = preParcelamento.getId();
					String tipoDocumentoNegociacao = CobrancaNegociacaoAtendimento.PRE_PARCELAMENTO;

					// [SB0018] - Verificar Encerramento do RA do Parcelamento
					verificarEncerramentoRANegociacao(collCobrancaNegociacaoAtendimento.iterator().next(), dataPagamento,
									idDocumentoNegociacao, tipoDocumentoNegociacao);

				}
			}else{
				descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}

		}else{
			indicadorAceitacaoRegistro = "2";
		}

		if(pagamentoHelperCodigoBarras.getColecaoPagamentos() != null){
			pagamentoHelperCodigoBarras.getColecaoPagamentos().addAll(colecaoPagamentos);
		}else{
			pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		}
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	// [SB0003] – Processar Pagamento de Documento de Cobrança
	// 2.4.11 verificar encerramento de RA
	private void encerrarRANegociacao(Date dataPagamento, Integer idCobrancaDocumento) throws ControladorException{

		// 2.4.11.Caso o documento de cobrança corresponde a um extrato de negociação de
		// débitos
		FiltroCobrancaNegociacaoAtendimento filtroCobrancaNegociacaoAtendimento = new FiltroCobrancaNegociacaoAtendimento();

		filtroCobrancaNegociacaoAtendimento.adicionarParametro(new ParametroSimples(
						FiltroCobrancaNegociacaoAtendimento.COBRANCA_DOCUMENTO_ID, idCobrancaDocumento));
		filtroCobrancaNegociacaoAtendimento.adicionarCaminhoParaCarregamentoEntidade("registroAtendimento");

		Collection<CobrancaNegociacaoAtendimento> collCobrancaNegociacaoAtendimento = getControladorUtil().pesquisar(
						filtroCobrancaNegociacaoAtendimento, CobrancaNegociacaoAtendimento.class.getName());

		if(collCobrancaNegociacaoAtendimento != null && !collCobrancaNegociacaoAtendimento.isEmpty()){

			// Integer idDocumentoNegociacao =
			// collCobrancaNegociacaoAtendimento.iterator().next().getCobrancaDocumento().getId();
			Integer idDocumentoNegociacao = idCobrancaDocumento;
			String tipoDocumentoNegociacao = CobrancaNegociacaoAtendimento.EXTRATO_DE_DEBITO;

			// [SB0018] - Verificar Encerramento do RA do Parcelamento
			verificarEncerramentoRANegociacao(collCobrancaNegociacaoAtendimento.iterator().next(), dataPagamento, idDocumentoNegociacao,
							tipoDocumentoNegociacao);
		}
	}

	// UC0259 [SB0018] - Verificar Encerramento do RA do Negociacao
	private void verificarEncerramentoRANegociacao(CobrancaNegociacaoAtendimento cobrancaNegociacaoAtendimento, Date dataPagamento,
					Integer idDocumentoNegociacao, String tipoDocumentoNegociacao) throws ControladorException{

		if(cobrancaNegociacaoAtendimento.getRegistroAtendimento() != null){
			RegistroAtendimento registroAtendimento = cobrancaNegociacaoAtendimento.getRegistroAtendimento();

			// 1.1. Caso o pagamento do documento da negociação tenha sido efetuado no vencimento
			// (Data do Pagamento menor ou igual à data do vencimento do documento da negociação)
			if(dataPagamento.compareTo(cobrancaNegociacaoAtendimento.getDataVencimento()) <= 0){

				// 1.1.1. Caso o registro de atendimento não esteja encerrado
				if(registroAtendimento.getCodigoSituacao() != RegistroAtendimento.SITUACAO_ENCERRADO){

					encerrarRegistroAtendimento(AtendimentoMotivoEncerramento.PAGAMENTO_PRIMEIRA_PARCELA_EFETUADO_NO_VENCIMENTO,
									registroAtendimento, tipoDocumentoNegociacao, idDocumentoNegociacao);

				}

			}else{ // Data do Pagamento maior que a data do vencimento do documento da negociação

				// 1.2.1. Caso o registro de atendimento não esteja encerrado
				if(registroAtendimento.getCodigoSituacao() != RegistroAtendimento.SITUACAO_ENCERRADO){

					encerrarRegistroAtendimento(AtendimentoMotivoEncerramento.PAGAMENTO_PRIMEIRA_PARCELA_EFETUADO_APOS_VENCIMENTO,
									registroAtendimento, tipoDocumentoNegociacao, idDocumentoNegociacao);

				}else{// o registro de atendimento esteja encerrado (RGAT_CDSITUACAO com o valor
						// correspondente a “ENCERRADO”)

					// atualizar o motivo de encerramento do registro de atendimento
					AtendimentoMotivoEncerramento atendimentoMotivoEncerramento = new AtendimentoMotivoEncerramento();
					atendimentoMotivoEncerramento.setId(AtendimentoMotivoEncerramento.PAGAMENTO_PRIMEIRA_PARCELA_EFETUADO_APOS_VENCIMENTO);

					registroAtendimento.setAtendimentoMotivoEncerramento(atendimentoMotivoEncerramento);
					registroAtendimento.setUltimaAlteracao(new Date());

					this.getControladorUtil().atualizar(registroAtendimento);
				}
			}

		}
	}

	// UC0259 [SB0018] Encerrar o registro de atendimento - <<Inclui>> [UC0435 - Encerrar Registro
	// de Atendimento]
	private void encerrarRegistroAtendimento(Integer idAtendimentoMotivoEncerramento, RegistroAtendimento registroAtendimento,
					String tipoDocumentoNegociacao, Integer idDocumentoNegociacao) throws ControladorException{

		AtendimentoMotivoEncerramento atendimentoMotivoEncerramento = new AtendimentoMotivoEncerramento();
		atendimentoMotivoEncerramento.setId(idAtendimentoMotivoEncerramento);
		registroAtendimento.setAtendimentoMotivoEncerramento(atendimentoMotivoEncerramento);

		registroAtendimento.setCodigoSituacao(RegistroAtendimento.SITUACAO_ENCERRADO);
		registroAtendimento.setDataEncerramento(new Date());

		String descricaoParecerEncerramento = "Este RA foi encerrado em razão do pagamento do " + tipoDocumentoNegociacao
						+ " de identificação " + idDocumentoNegociacao;

		registroAtendimento.setParecerEncerramento(descricaoParecerEncerramento);
		registroAtendimento.setUltimaAlteracao(new Date());

		// cria o RegistroAtendimentoUnidade que será enviado para o método
		// encerrarRegistroAtendimento
		RegistroAtendimentoUnidade registroAtendimentoUnidade = new RegistroAtendimentoUnidade();
		registroAtendimentoUnidade.setRegistroAtendimento(registroAtendimento);

		// obtem o usuário batch
		FiltroUsuario filtroUsuario = new FiltroUsuario();
		filtroUsuario.adicionarParametro(new ParametroSimples(FiltroUsuario.ID, Integer.valueOf((String) ParametroGeral.P_USUARIO_BATCH
						.executar())));
		filtroUsuario.adicionarCaminhoParaCarregamentoEntidade("unidadeOrganizacional");

		Collection<Usuario> collUsuario = getControladorUtil().pesquisar(filtroUsuario, Usuario.class.getName());

		Usuario usuarioBatch = null;
		if(collUsuario != null && !collUsuario.isEmpty()){

			usuarioBatch = collUsuario.iterator().next();
			registroAtendimentoUnidade.setUsuario(usuarioBatch);

			if(usuarioBatch.getUnidadeOrganizacional() != null && !usuarioBatch.getUnidadeOrganizacional().equals("")){
				registroAtendimentoUnidade.setUnidadeOrganizacional(usuarioBatch.getUnidadeOrganizacional());
			}

		}

		// atendimento relação tipo
		AtendimentoRelacaoTipo atendimentoRelacaoTipo = new AtendimentoRelacaoTipo();
		atendimentoRelacaoTipo.setId(AtendimentoRelacaoTipo.ENCERRAR);
		registroAtendimentoUnidade.setAtendimentoRelacaoTipo(atendimentoRelacaoTipo);
		registroAtendimentoUnidade.setUltimaAlteracao(new Date());

		// [UC0435 - Encerrar Registro de Atendimento]
		getControladorRegistroAtendimento().encerrarRegistroAtendimento(registroAtendimento, registroAtendimentoUnidade, usuarioBatch);
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0004] – Processar Pagamento Fatura do Cliente Responsável
	 * CLIENTE RESPONSÁVEL
	 * 
	 * @author Raphael Rossiter
	 * @date 02/05/2007
	 * @author Saulo Lima
	 * @date 16/12/2008
	 *       Alteração para novo padrão do codigo de Barras
	 * @author Saulo Lima
	 * @date 12/08/2009
	 *       Alteração para setar o AnoMesReferenciaPagamento quando conta estiver em histórico.
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasClienteResponsavel(
					RegistroHelperCodigoBarras registroHelperCodigoBarras, SistemaParametro sistemaParametro, Date dataPagamento,
					Integer anoMesPagamento, BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();

		// valida a matricula do imóvel
		boolean idClienteInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());
		Integer idClienteNaBase = null;

		if(idClienteInvalido){
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		}else{
			// verifica se existe o id do cliente na base
			Integer idCliente = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1());

			try{
				idClienteNaBase = repositorioCliente.verificarExistenciaCliente(Integer.valueOf(idCliente));
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			if(idClienteNaBase == null){
				descricaoOcorrencia = "CLIENTE RESPONSÁVEL NÃO CADASTRADO";
			}
		}

		boolean numeroSequencialFaturaInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

		if(numeroSequencialFaturaInvalido){
			descricaoOcorrencia = "SEQÜENCIAL DA FATURA DO CLIENTE RESPONSÁVEL NÃO NUMÉRICO";
		}

		if(descricaoOcorrencia.equals("OK")){

			// inicializa a coleção de fatura item
			Collection<Object> faturaItens = null;

			Integer numeroSequencial = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento3());

			FiltroFatura filtroFatura = new FiltroFatura();
			filtroFatura.adicionarParametro(new ParametroSimples(FiltroFatura.CLIENTE_ID, idClienteNaBase));
			filtroFatura.adicionarParametro(new ParametroSimples(FiltroFatura.SEQUENCIAL, numeroSequencial));
			filtroFatura.adicionarParametro(new ParametroSimples(FiltroFatura.DEBITO_VALOR, valorPagamento));
			Collection<Fatura> colecaoFatura = getControladorUtil().pesquisar(filtroFatura, Fatura.class.getName());

			Fatura fatura = null;
			if(colecaoFatura != null && !colecaoFatura.isEmpty()){
				fatura = (Fatura) Util.retonarObjetoDeColecao(colecaoFatura);
			}

			if(fatura == null){
				descricaoOcorrencia = "FATURA DO CLIENTE RESPONSÁVEL INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}else{

				try{
					faturaItens = repositorioFaturamento.pesquisarFaturaItem(numeroSequencial);
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				// verifica se a coleção é diferente de nula
				if(faturaItens != null && !faturaItens.isEmpty()){
					Iterator faturaItensIterator = faturaItens.iterator();
					while(faturaItensIterator.hasNext()){
						Object[] faturaItem = (Object[]) faturaItensIterator.next();
						// inicializa as variaveis que veio da pesquisa
						Integer idContaPesquisa = null;
						Integer idImovelPesquisa = null;
						Integer idLocalidadePesquisa = null;
						BigDecimal valorConta = null;
						// verifica o valor da conta
						if(faturaItem[0] != null){
							valorConta = (BigDecimal) faturaItem[0];
						}
						// verifica o id da conta
						if(faturaItem[1] != null){
							idContaPesquisa = (Integer) faturaItem[1];
						}
						// verifica o id da localidade
						if(faturaItem[2] != null){
							idLocalidadePesquisa = (Integer) faturaItem[2];
						}
						// verifica o id do imovel
						if(faturaItem[3] != null){
							idImovelPesquisa = (Integer) faturaItem[3];
						}
						// verifica o id da localidade de Conta Histórico
						if(faturaItem[4] != null){
							idLocalidadePesquisa = (Integer) faturaItem[4];
						}
						// verifica o id do imovel de Conta Histórico
						if(faturaItem[5] != null){
							idImovelPesquisa = (Integer) faturaItem[5];
						}
						// verifica o id da Conta Histórico
						if(faturaItem[6] != null){
							idContaPesquisa = (Integer) faturaItem[6];
						}

						// cria o objeto pagamento para setar os dados
						Pagamento pagamento = new Pagamento();

						// caso o ano mes da data de debito seja maior que o ano mes de arrecadação
						// da
						// tabela sistema parametro então seta o ano mes da data de debito
						if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
							pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
						}else{
							// caso contrario seta o o ano mes arrecadação da tabela sistema
							// parametro
							pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
						}

						pagamento.setValorPagamento(valorConta);
						pagamento.setDataPagamento(dataPagamento);
						pagamento.setPagamentoSituacaoAtual(null);
						pagamento.setPagamentoSituacaoAnterior(null);
						pagamento.setDebitoTipo(null);

						// verifica se o id da conta é diferente de nulo
						if(idContaPesquisa != null){

							Conta conta = null;
							try{
								conta = repositorioArrecadacao.pesquisarConta(idContaPesquisa);
							}catch(ErroRepositorioException e){
								throw new ControladorException("atencao.conta.nao.localizada", e);
							}

							if(conta != null){
								pagamento.setConta(conta);
								pagamento.setAnoMesReferenciaPagamento(Integer.valueOf(conta.getReferencia()));

							}else{

								ContaHistorico contaHistorico = null;
								try{
									contaHistorico = repositorioArrecadacao.pesquisarContaHistorico(idContaPesquisa);
								}catch(ErroRepositorioException e){
									throw new ControladorException("atencao.conta.nao.localizada", e);
								}
								if(contaHistorico != null){
									pagamento.setAnoMesReferenciaPagamento(Integer.valueOf(contaHistorico.getAnoMesReferenciaConta()));
								}
							}

						}else{
							pagamento.setConta(null);
						}
						pagamento.setGuiaPagamentoGeral(null);

						pagamento.setDebitoACobrar(null);

						// verifica se o id da conta é diferente de nulo
						if(idLocalidadePesquisa != null){
							Localidade localidade = new Localidade();
							localidade.setId(idLocalidadePesquisa);
							pagamento.setLocalidade(localidade);
						}else{
							pagamento.setLocalidade(null);
						}
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.FATURA_CLIENTE);
						pagamento.setDocumentoTipo(documentoTipo);

						// seta o id do aviso bancario
						pagamento.setAvisoBancario(null);

						// seta o imovel
						if(idImovelPesquisa != null){
							Imovel imovel = new Imovel();
							imovel.setId(idImovelPesquisa);
							pagamento.setImovel(imovel);
						}else{
							pagamento.setImovel(null);
						}

						pagamento.setArrecadadorMovimentoItem(null);

						ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
						arrecadacaoForma.setId(idFormaPagamento);
						pagamento.setArrecadacaoForma(arrecadacaoForma);
						pagamento.setCliente(null);
						pagamento.setUltimaAlteracao(new Date());

						colecaoPagamentos.add(pagamento);
					}
				}
			}
		}else{
			// atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras [SB0003] – Distribuir Pagamento de
	 * Documento de Cobrança
	 * DOCUMENTO COBRANÇA TIPO 08
	 * 
	 * @author Raphael Rossiter
	 * @date 02/05/2007
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasDocumentoCobrancaTipo8(
					RegistroHelperCodigoBarras registroHelperCodigoBarras, SistemaParametro sistemaParametro, Date dataPagamento,
					Integer anoMesPagamento, BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
		String descricaoOcorrencia = "OK";
		String indicadorAceitacaoRegistro = "1";
		Collection colecaoPagamentos = new ArrayList();

		// valida o cliente
		boolean idClienteInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		Integer idClienteNaBase = null;

		if(idClienteInvalido){
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		}else{

			// verifica se existe o id do cliente na base
			Integer idCliente = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());

			try{
				idClienteNaBase = repositorioCliente.verificarExistenciaCliente(Integer.valueOf(idCliente));
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			if(idClienteNaBase == null){
				descricaoOcorrencia = "CLIENTE RESPONSÁVEL NÂO CADASTRADO";
			}
		}

		// valida o numero sequencial do documento
		boolean numeroSequencialDocumentoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

		if(numeroSequencialDocumentoInvalido){
			descricaoOcorrencia = "SEQUENCIAL DO DOCUMENTO NÃO NUMÉRICO";
		}

		if(descricaoOcorrencia.equals("OK")){

			// inicializa a coleção de cobranca documento item
			Collection cobrancaDocumentoItens = null;

			int numeroSequencialDocumento = Integer.parseInt(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento3());

			try{

				cobrancaDocumentoItens = repositorioCobranca.pesquisarCobrancaDocumentoItemCliente(idClienteNaBase,
								numeroSequencialDocumento);
				// parmsDocumentoCobranca =
				// repositorioCobranca.pesquisarParmsCobrancaDocumentoCliente(idClienteNaBase,
				// numeroSequencialDocumento);

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			// caso exista documento de cobrança verifica se a coleção é diferente de nula
			if(cobrancaDocumentoItens != null && !cobrancaDocumentoItens.isEmpty()){

				// Parâmetro que identifica se a empresa emite o documento com acrescimos
				String parametroTratarAcrescimosEmissaoDocumento = ParametroArrecadacao.P_TRATAR_ACRESCIMOS_EMISSAO_DOCUMENTO.executar()
								.toString();

				// Parâmetro que identifica se a empresa emite o documento com acrescimos
				String parametroPermitirSelecaoAcrescimosExtrato = ParametroArrecadacao.P_PERMITIR_SELECAO_ACRESCIMOS_EXTRATO.executar()
								.toString();

				BigDecimal valorPagamentoAux = valorPagamento;

				Integer idCobrancaDocumento = null;

				Date dataEmissao = null;

				Iterator cobrancaDocumentoItensIterator = cobrancaDocumentoItens.iterator();
				while(cobrancaDocumentoItensIterator.hasNext() && valorPagamentoAux.compareTo(BigDecimal.ZERO) > 0){

					Object[] cobrancaDocumentoItem = (Object[]) cobrancaDocumentoItensIterator.next();

					// inicializa as variaveis que vieram da pesquisa
					Integer idContaPesquisa = null;
					Integer idContaGeralPesquisa = null;
					Integer idGuiaPagamento = null;
					Integer idDebitoACobrar = null;
					BigDecimal valorItemCobrado = null;
					int contaReferencia = 0;
					Integer idDebitoTipo = null;
					Integer idGuiaPagamentoGeralPesquisa = null;
					Integer idDebitoACobrarGeralPesquisa = null;
					Integer idLocalidade = null;
					BigDecimal valorAcrescimoOriginalDocCob = BigDecimal.ZERO;
					BigDecimal valorAcrescimoItem = BigDecimal.ZERO;

					if(cobrancaDocumentoItem[29] != null){
						valorAcrescimoOriginalDocCob = ((BigDecimal) cobrancaDocumentoItem[29]);
					}

					if(cobrancaDocumentoItem[30] != null){
						valorAcrescimoItem = (BigDecimal) cobrancaDocumentoItem[30];
					}

					if(cobrancaDocumentoItem[31] != null){
						dataEmissao = ((Date) cobrancaDocumentoItem[31]);
					}

					// id Cobranca Documento
					if(cobrancaDocumentoItem[22] != null){
						idCobrancaDocumento = (Integer) cobrancaDocumentoItem[22];
					}

					// verifica o id da conta
					if(cobrancaDocumentoItem[0] != null){
						idContaPesquisa = (Integer) cobrancaDocumentoItem[0];
						idContaGeralPesquisa = (Integer) cobrancaDocumentoItem[0];

						// referencia conta
						if(cobrancaDocumentoItem[4] != null){
							contaReferencia = (Integer) cobrancaDocumentoItem[4];
						}
					}else{

						// caso não exista na conta então pesquisa na conta histórico
						if(cobrancaDocumentoItem[10] != null){
							idContaGeralPesquisa = (Integer) cobrancaDocumentoItem[10];
						}

						// referencia conta histórico
						if(cobrancaDocumentoItem[5] != null){
							contaReferencia = (Integer) cobrancaDocumentoItem[5];
						}
					}

					// verifica o id da guia pagamento
					if(cobrancaDocumentoItem[1] != null){
						idGuiaPagamento = (Integer) cobrancaDocumentoItem[1];
						idGuiaPagamentoGeralPesquisa = (Integer) cobrancaDocumentoItem[1];
					}else{

						// caso não exista no guia pagamento então pesquisa no guia pagamento
						// histórico
						if(cobrancaDocumentoItem[11] != null){
							idGuiaPagamentoGeralPesquisa = (Integer) cobrancaDocumentoItem[11];
						}
					}

					// verifica numeroPrestacao da Guia de Pagamento
					Short numeroPrestacao = null;
					if(idGuiaPagamentoGeralPesquisa != null){
						if(cobrancaDocumentoItem[19] != null){
							numeroPrestacao = (Short) cobrancaDocumentoItem[19];
						}
					}

					Integer numeroParcelaAntecipada = null;

					// verifica o id do debito a cobrar
					if(cobrancaDocumentoItem[2] != null){

						idDebitoACobrar = (Integer) cobrancaDocumentoItem[2];
						idDebitoACobrarGeralPesquisa = (Integer) cobrancaDocumentoItem[2];

						if(cobrancaDocumentoItem[20] != null){
							numeroParcelaAntecipada = (Integer) cobrancaDocumentoItem[20];
						}

						DebitoACobrar debitoACobrar = null;
						try{
							debitoACobrar = this.repositorioFaturamento.pesquisarDebitoACobrar(idDebitoACobrar);
						}catch(ErroRepositorioException e){
							throw new ControladorException("erro.sistema", e);
						}

						if(debitoACobrar == null){
							throw new ControladorException("atencao.atualizacao.removido");
						}

						// se nao tem antecipacao
						if(numeroParcelaAntecipada == null || numeroParcelaAntecipada.intValue() == 0){

							// [SB0012]- Verifica Pagamento de Débito a Cobrar de Parcelamento
							if(debitoACobrar.getParcelamento() != null){
								this.verificaPagamentoDebitoACobrarParcelamento(idDebitoACobrar, debitoACobrar.getParcelamento().getId());
							}

							// se tem antecipacao
						}else{

							// se for juros e tiver valor
							if(cobrancaDocumentoItem[8] != null && DebitoTipo.JUROS_SOBRE_PARCELAMENTO.equals(cobrancaDocumentoItem[8])){

								// atualizando o valor do debito a cobrar quando for dado desconto
								// no juros
								debitoACobrar.setNumeroPrestacaoCobradas((short) (debitoACobrar.getNumeroPrestacaoCobradas() + 1));
								if(debitoACobrar.getNumeroPrestacaoCobradas() == debitoACobrar.getNumeroPrestacaoDebito()){
									DebitoCreditoSituacao dcs = new DebitoCreditoSituacao();
									dcs.setId(DebitoCreditoSituacao.PAGA);
									debitoACobrar.setDebitoCreditoSituacaoAtual(dcs);
								}
								debitoACobrar.setUltimaAlteracao(new Date());
								this.getControladorUtil().atualizar(debitoACobrar);

								// calcula a diferenca entre o valor real (cobrancaDocumentoItem[3])
								// e o valor cobrado (cobrancaDocumentoItem[21])
								if(cobrancaDocumentoItem[3] != null && cobrancaDocumentoItem[21] != null){

									// verificando a diferenca entre o valor original e o novo valor
									// cobrado.
									BigDecimal diferenca = ((BigDecimal) cobrancaDocumentoItem[3])
													.subtract((BigDecimal) cobrancaDocumentoItem[21]);

									// se for menor que zero entao passa para o proximo
									if(diferenca.doubleValue() > BigDecimal.ZERO.doubleValue()){

										// subtraindo a diferenca.
										debitoACobrar.setValorDebito(debitoACobrar.getValorDebito().subtract(diferenca));
										debitoACobrar.setUltimaAlteracao(new Date());
										this.getControladorUtil().atualizar(debitoACobrar);

										// seta os dados do histórico de débito a cobrar
										DebitoACobrarHistorico debitoACobrarHistoricoTemp = this.getControladorFaturamento()
														.gerarDebitoACobrarHistoricoDoDebitoACobrar(debitoACobrar);
										debitoACobrarHistoricoTemp.setValorDebito(diferenca);
										debitoACobrarHistoricoTemp.setId(null);
										DebitoCreditoSituacao dcs = new DebitoCreditoSituacao();
										dcs.setId(DebitoCreditoSituacao.CANCELADA);
										debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAtual(dcs);

										DebitoACobrarGeral dag = new DebitoACobrarGeral();
										dag.setIndicadorHistorico(DebitoACobrarGeral.INDICADOR_POSSUI_HISTORICO);
										dag.setUltimaAlteracao(new Date());
										Integer id = (Integer) this.getControladorUtil().inserir(dag);

										debitoACobrarHistoricoTemp.setId(id);
										debitoACobrarHistoricoTemp.setNumeroParcela(Integer.parseInt(cobrancaDocumentoItem[20] + ""));
										debitoACobrarHistoricoTemp.setIdOriginal(idDebitoACobrar);
										this.getControladorUtil().inserir(debitoACobrarHistoricoTemp);

										// throw new
										// IllegalArgumentException("Falta os parametros novos do d a cobrar");
									}
								}

								// se tem valor de juros
								if(cobrancaDocumentoItem[21] != null){
									valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[21];
									// se o juros for zero pule pra o proximo item
									if(valorItemCobrado.equals(BigDecimal.ZERO)){
										continue;
									}
								}
							}
						}

						// é debito a cobrar no historico
					}else{

						// caso não exista no debito a cobrar então pesquisa no guia pagamento
						// histórico
						if(cobrancaDocumentoItem[12] != null){

							idDebitoACobrarGeralPesquisa = (Integer) cobrancaDocumentoItem[12];

							if(cobrancaDocumentoItem[20] != null){
								numeroParcelaAntecipada = (Integer) cobrancaDocumentoItem[20];
							}
						}

						// se for juros
						if(cobrancaDocumentoItem[9] != null && DebitoTipo.JUROS_SOBRE_PARCELAMENTO.equals(cobrancaDocumentoItem[9])){

							// se tem valor de juros
							if(cobrancaDocumentoItem[20] != null){
								valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[20];
								// se o juros for zero pule pra o proximo item
								if(valorItemCobrado.equals(BigDecimal.ZERO)){
									continue;
								}
							}
						}
					}

					// verifica o valor do item cobrado da cobranca documento item
					if(cobrancaDocumentoItem[3] != null){
						valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[3];
					}

					// se o id da conta for igual a null
					if(idContaGeralPesquisa == null){

						// caso exista guia de pagamento
						if(idGuiaPagamentoGeralPesquisa != null){

							// // verifica o id do debito tipo se é da guia
							// if(cobrancaDocumentoItem[6] != null){
							// idDebitoTipo = (Integer) cobrancaDocumentoItem[6];
							// }else{
							//
							// // caso não exista no guia pagamento então pesquisa no guia
							// // pagamento histórico
							// if(cobrancaDocumentoItem[7] != null){
							// idDebitoTipo = (Integer) cobrancaDocumentoItem[7];
							// }
							// }
						}

						// caso exista debito a cobrar
						if(idDebitoACobrarGeralPesquisa != null){

							// verifica o id do debito tipo no debito a cobrar
							if(cobrancaDocumentoItem[8] != null){
								idDebitoTipo = (Integer) cobrancaDocumentoItem[8];
							}else{

								// caso não exista no debito a cobrar então pesquisa no debito a
								// cobrar histórico
								if(cobrancaDocumentoItem[9] != null){
									idDebitoTipo = (Integer) cobrancaDocumentoItem[9];
								}
							}
						}
					}

					if(idContaGeralPesquisa != null){
						if(cobrancaDocumentoItem[23] != null){
							idLocalidade = (Integer) cobrancaDocumentoItem[23];
						}else if(cobrancaDocumentoItem[24] != null){
							idLocalidade = (Integer) cobrancaDocumentoItem[24];
						}
					}else{
						if(idDebitoACobrarGeralPesquisa != null){
							if(cobrancaDocumentoItem[25] != null){
								idLocalidade = (Integer) cobrancaDocumentoItem[25];
							}else if(cobrancaDocumentoItem[26] != null){
								idLocalidade = (Integer) cobrancaDocumentoItem[26];
							}
						}else if(idGuiaPagamentoGeralPesquisa != null){
							if(cobrancaDocumentoItem[27] != null){
								idLocalidade = (Integer) cobrancaDocumentoItem[27];
							}else if(cobrancaDocumentoItem[28] != null){
								idLocalidade = (Integer) cobrancaDocumentoItem[28];
							}
						}else{
							if(cobrancaDocumentoItem[16] != null){
								idLocalidade = (Integer) cobrancaDocumentoItem[16];
							}
						}
					}

					// cria o objeto pagamento para setar os dados
					Pagamento pagamento = new Pagamento();
					if(contaReferencia != 0){
						pagamento.setAnoMesReferenciaPagamento(contaReferencia);
					}else{
						pagamento.setAnoMesReferenciaPagamento(null);
					}

					/*
					 * caso o ano mes da data de dedito seja maior que o ano mes de arrecadação da
					 * tabela sistema parametro então seta o ano mes da
					 * data de debito
					 */
					if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
						pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
					}else{

						// caso contrario seta o o ano mes arrecadação da tabela sistema parametro
						pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
					}

					// Ajuste necessário para tratar a Arrecadação de CASAL. O acrescimo do item só
					// deve ser considerado quando o documento foi gerado com acrescimo. Essa
					// verificação é necessária porque o emitir extrato de débitos gera os ítens com
					// acrescimo mesmo que o documento não seja emitido com acrescimo
					if((parametroTratarAcrescimosEmissaoDocumento.equals(Short.toString(ConstantesSistema.SIM)) || parametroPermitirSelecaoAcrescimosExtrato
									.equals(Short.toString(ConstantesSistema.SIM)))
									&& valorAcrescimoItem.compareTo(BigDecimal.ZERO) == 1
									&& valorAcrescimoOriginalDocCob.compareTo(BigDecimal.ZERO) == 1){
						valorItemCobrado = valorItemCobrado.add(valorAcrescimoItem);
					}

					if(valorPagamentoAux.compareTo(valorItemCobrado) < 0){
						valorItemCobrado = valorPagamentoAux;
					}

					// O valor passado no código de barras vai sendo subtraído pelo valor do ítem do
					// documento. Isso é necessário para fazer com que o GSAN so realize a baixa dos
					// documentos que deram pra ser pagos com o valor do código de barras
					valorPagamentoAux = valorPagamentoAux.subtract(valorItemCobrado);

					pagamento.setValorPagamento(valorItemCobrado);
					pagamento.setDataPagamento(dataPagamento);
					pagamento.setPagamentoSituacaoAtual(null);
					pagamento.setPagamentoSituacaoAnterior(null);
					if(idDebitoTipo != null){
						DebitoTipo debitoTipo = new DebitoTipo();
						debitoTipo.setId(idDebitoTipo);
						pagamento.setDebitoTipo(debitoTipo);
					}else{
						pagamento.setDebitoTipo(null);
					}

					if(idLocalidade != null){
						Localidade localidade = new Localidade();
						localidade.setId(idLocalidade);
						pagamento.setLocalidade(localidade);
					}else{
						pagamento.setLocalidade(null);
					}

					// verifica se o id da conta é diferente de nulo
					if(idContaGeralPesquisa != null){

						Conta conta = new Conta();
						
						if(idContaPesquisa != null){
							conta.setId(idContaPesquisa);
							pagamento.setConta(conta);
						}else{
							conta.setId(idContaGeralPesquisa);
							pagamento.setConta(conta);
						}

						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.CONTA);
						pagamento.setDocumentoTipo(documentoTipo);
					}else{
						pagamento.setConta(null);
					}

					// verifica se o id da guia de pagamento é diferente de nulo
					if(idGuiaPagamentoGeralPesquisa != null){
						if(idGuiaPagamento != null){

							GuiaPagamento guiaPagamento = new GuiaPagamento();
							guiaPagamento.setId(idGuiaPagamento);

							guiaPagamento.setGuiaPagamentoGeral(new GuiaPagamentoGeral());
							guiaPagamento.getGuiaPagamentoGeral().setId(idGuiaPagamento);

							pagamento.setGuiaPagamentoGeral(guiaPagamento.getGuiaPagamentoGeral());
							pagamento.getGuiaPagamentoGeral().setGuiaPagamento(guiaPagamento);

							if(numeroPrestacao != null){
								pagamento.setNumeroPrestacao(Integer.valueOf(numeroPrestacao.intValue()));
							}

						}else{
							pagamento.setGuiaPagamentoGeral(null);
							pagamento.setNumeroPrestacao(null);
						}
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
						pagamento.setDocumentoTipo(documentoTipo);

					}else{
						pagamento.setGuiaPagamentoGeral(null);
						pagamento.setNumeroPrestacao(null);
					}

					// verifica se o id do debito a cobrar é diferente de nulo
					if(idDebitoACobrarGeralPesquisa != null){

						if(idDebitoACobrar != null){

							DebitoACobrar debitoACobrar = new DebitoACobrar();
							debitoACobrar.setId(idDebitoACobrar);
							pagamento.setDebitoACobrar(debitoACobrar);

							if(numeroParcelaAntecipada != null && numeroParcelaAntecipada.intValue() != 0){
								pagamento.setNumeroPrestacao(Integer.valueOf(numeroParcelaAntecipada.intValue()));
							}else{
								pagamento.setNumeroPrestacao(null);
								try{
									// atualiza a situação atual para paga
									repositorioFaturamento.atualizarSituacaoAtualDebitoACobrar(idDebitoACobrar);
								}catch(ErroRepositorioException e){
									throw new ControladorException("erro.sistema", e);
								}
							}
						}else{
							pagamento.setDebitoACobrar(null);
							if(numeroParcelaAntecipada != null && numeroParcelaAntecipada.intValue() != 0){
								pagamento.setNumeroPrestacao(Integer.valueOf(numeroParcelaAntecipada.intValue()));
							}
						}

						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
						pagamento.setDocumentoTipo(documentoTipo);

					}else{
						pagamento.setGuiaPagamentoGeral(null);
						pagamento.setNumeroPrestacao(null);
					}

					// seta o id do aviso bancario
					pagamento.setAvisoBancario(null);

					// seta o imovel
					if(idContaGeralPesquisa != null && idContaPesquisa != null){

						Imovel imovel = new Imovel();
						imovel.setId((Integer) cobrancaDocumentoItem[13]);
						pagamento.setImovel(imovel);

					}else if(idGuiaPagamentoGeralPesquisa != null && idGuiaPagamento != null){

						Imovel imovel = new Imovel();
						imovel.setId((Integer) cobrancaDocumentoItem[14]);
						pagamento.setImovel(imovel);

					}else if(idDebitoACobrarGeralPesquisa != null && idDebitoACobrar != null){

						Imovel imovel = new Imovel();
						imovel.setId((Integer) cobrancaDocumentoItem[15]);
						pagamento.setImovel(imovel);
					}

					/*
					 * if (idImovelNaBase != null) {
					 * Imovel imovel = new Imovel();
					 * imovel.setId(idImovelNaBase);
					 * pagamento.setImovel(imovel);
					 * } else {
					 * pagamento.setImovel(null);
					 * }
					 */

					// ArrecadadorMovimentoItem arrecadadorMovimentoItem = new
					// ArrecadadorMovimentoItem();
					pagamento.setArrecadadorMovimentoItem(null);

					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
					arrecadacaoForma.setId(idFormaPagamento);
					pagamento.setArrecadacaoForma(arrecadacaoForma);
					pagamento.setCliente(null);
					pagamento.setUltimaAlteracao(new Date());

					colecaoPagamentos.add(pagamento);
				}

				// [SB0003] – Processar Pagamento de Documento de Cobrança
				// 2.4.11 verificar encerramento de RA
				this.encerrarRANegociacao(dataPagamento, idCobrancaDocumento);

				this.tratarBoletosBancariosDasContasEmCobrancaBancaria(idCobrancaDocumento, dataEmissao);

			}else{
				descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}

		}else{

			// atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * @author Sávio Luiz
	 * @date 01/02/2006
	 * @author Saulo Lima
	 * @date 21/05/2010
	 *       Alteraçao para já receber o 'RegistroHelperCodigoBarras'
	 */
	public PagamentoHelperCodigoBarras processarPagamentosCodigoBarras(RegistroHelperCodigoBarras registroHelperCodigoBarras,
					Date dataPagamento, Integer idFormaPagamento, SistemaParametro sistemaParametro, String subStringIdPagamento,
					Integer idConcessionaria) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		int tipoPagamento = ConstantesSistema.NUMERO_NAO_INFORMADO;

		String tipoPagamentoStr = registroHelperCodigoBarras.getTipoPagamento();

		if(!Util.isVazioOuBranco(tipoPagamentoStr)){
			tipoPagamento = Integer.valueOf(tipoPagamentoStr);
		}

		try{

			String descricaoOcorrencia = registroHelperCodigoBarras.getDescricaoOcorrencia();
			String indicadorAceitacaoRegistro = "1";
			Collection colecaoPagamentos = new ArrayList();

			if(descricaoOcorrencia.equals("OK")){
				String codigoEmpresaCodigoBarrasStr = registroHelperCodigoBarras.getIdEmpresa();

				Integer codigoEmpresaCodigoBarras = null;

				if(!Util.isVazioOuBranco(codigoEmpresaCodigoBarrasStr)){
					codigoEmpresaCodigoBarras = Integer.valueOf(codigoEmpresaCodigoBarrasStr);
				}

				if(idConcessionaria == null){
					// Ocorre quando é chamado pelo Inserir Pagamento

					FiltroConcessionaria filtroConcessionaria = new FiltroConcessionaria();
					filtroConcessionaria.adicionarParametro(new ParametroSimples(FiltroConcessionaria.CODIGO_EMPRESA_FEBRABAN,
									codigoEmpresaCodigoBarras));

					Collection<Concessionaria> colecaoConcessionaria = this.getControladorUtil().pesquisar(filtroConcessionaria,
									Concessionaria.class.getName());

					if(Util.isVazioOrNulo(colecaoConcessionaria)){
						// Atribui o valor 2(NÃO) ao indicador aceitação registro
						indicadorAceitacaoRegistro = "2";

						descricaoOcorrencia = "EMPRESA " + codigoEmpresaCodigoBarrasStr + " NÃO IDENTIFICADA";

						// Seta os parametros que serão retornados
						pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
						pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
						pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
					}
				}else{
					// Ocorre quando é chamado pelo Registrar Movimento Arrecadadores

					FiltroConcessionaria filtroConcessionaria = new FiltroConcessionaria();
					filtroConcessionaria.adicionarParametro(new ParametroSimples(FiltroConcessionaria.ID, idConcessionaria));

					Collection<Concessionaria> colecaoConcessionaria = this.getControladorUtil().pesquisar(filtroConcessionaria,
									Concessionaria.class.getName());

					if(!Util.isVazioOrNulo(colecaoConcessionaria)){
						Concessionaria concessionaria = (Concessionaria) Util.retonarObjetoDeColecao(colecaoConcessionaria);

						Integer codigoEmpresaFebraban = concessionaria.getCodigoEmpresaFebraban();

						if(codigoEmpresaCodigoBarras != null && codigoEmpresaFebraban != null
										&& codigoEmpresaCodigoBarras.intValue() != codigoEmpresaFebraban.intValue()){
							// Atribui o valor 2(NÃO) ao indicador aceitação registro
							indicadorAceitacaoRegistro = "2";

							descricaoOcorrencia = "CÓDIGO DE BARRAS NÃO PERTENCE A " + codigoEmpresaFebraban;

							// Seta os parametros que serão retornados
							pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
							pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
							pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
						}
					}
				}

				if(descricaoOcorrencia.equals("OK")){
					BigDecimal valorPagamento = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoBarras
									.getValorPagamento());

					// Recupera o ano e o mes da data de pagamento
					Integer anoMesPagamento = Util.recuperaAnoMesDaData(dataPagamento);

					switch(tipoPagamento){

					// CONTA
						case PagamentoTipo.PAGAMENTO_TIPO_CONTA:

							pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasConta(registroHelperCodigoBarras,
											sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento, idFormaPagamento);
							break;

						// GUIA DE PAGAMENTO (com matrícula do imóvel)
						case PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_MATRICULA_IMOVEL:

							pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasGuiaPagamento(registroHelperCodigoBarras,
											sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento, idFormaPagamento);
							break;

						// DOCUMENTO DE COBRANÇA (com matrícula do imóvel)
						case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_MATRICULA_IMOVEL:

							pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasDocumentoCobrancaTipo5(
											registroHelperCodigoBarras, sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento,
											idFormaPagamento);
							break;

						// GUIA DE PAGAMENTO (com código do cliente)
						case PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_CODIGO_CLIENTE:

							pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasGuiaPagamentoCliente(
											registroHelperCodigoBarras, sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento,
											idFormaPagamento);
							break;

						// FATURA DO CLIENTE RESPONSÁVEL
						case PagamentoTipo.PAGAMENTO_TIPO_CLIENTE_RESPONSAVEL:

							pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasClienteResponsavel(
											registroHelperCodigoBarras, sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento,
											idFormaPagamento);
							break;

						// DOCUMENTO DE COBRANÇA (com código do cliente)
						case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_CODIGO_CLIENTE:

							pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasDocumentoCobrancaTipo8(
											registroHelperCodigoBarras, sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento,
											idFormaPagamento);
							break;

						// DOCUMENTO DE COBRANÇA (pré parcelamento)
						case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_PRE_PARCELAMENTO:

							pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasCobrancaPreParcelamento(
											registroHelperCodigoBarras, sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento,
											idFormaPagamento);

							break;

						// NOTA DE RECEBIMENTO
						case PagamentoTipo.PAGAMENTO_TIPO_NOTA_RECEBIMENTO:

							pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasNotaRecebimento(registroHelperCodigoBarras,
											sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento, idFormaPagamento);

							break;

						// CASO NÃO SEJA NENHUM DESSES TIPOS DE PAGAMENTO
						default:

							// atribui o valor 2(NÃO) ao indicador aceitacao registro
							indicadorAceitacaoRegistro = "2";
							descricaoOcorrencia = "CÓDIGO DE BARRAS COM TIPO DE PAGAMENTO INVÁLIDO";

							// Seta os parametros que serão retornados
							pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
							pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
							pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
					}
				}
			}else{
				// atribui o valor 2(NÃO) ao indicador aceitacao registro
				indicadorAceitacaoRegistro = "2";

				// Seta os parametros que serão retornados
				pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
				pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
				pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
			}

		}catch(ControladorException e){
			sessionContext.setRollbackOnly();
			throw e;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * @author Rafael Pinto
	 * @date 19/04/2007
	 */
	protected Pagamento processarPagamentosCodigoBarrasTipoFatura(Object[] faturaItem, int anoMes, Integer anoMesPagamento,
					SistemaParametro sistemaParametro, Date dataPagamento, Integer idFormaPagamento) throws ControladorException{

		// inicializa as variaveis que veio da pesquisa
		Integer idContaPesquisa = null;
		Integer idImovelPesquisa = null;
		Integer idLocalidadePesquisa = null;
		BigDecimal valorConta = null;
		// verifica o valor da conta
		if(faturaItem[0] != null){
			valorConta = (BigDecimal) faturaItem[0];
		}
		// verifica o id da conta
		if(faturaItem[1] != null){
			idContaPesquisa = (Integer) faturaItem[1];
		}
		// verifica o id da localidade
		if(faturaItem[2] != null){
			idLocalidadePesquisa = (Integer) faturaItem[2];
		}
		// verifica o id do imovel
		if(faturaItem[3] != null){
			idImovelPesquisa = (Integer) faturaItem[3];
		}
		// verifica o id da localidade
		if(faturaItem[2] != null){
			idLocalidadePesquisa = (Integer) faturaItem[2];
		}
		// verifica o id do imovel
		if(faturaItem[3] != null){
			idImovelPesquisa = (Integer) faturaItem[3];
		}
		// verifica o id da localidade de Conta Histórico
		if(faturaItem[4] != null){
			idLocalidadePesquisa = (Integer) faturaItem[4];
		}
		// verifica o id do imovel de Conta Histórico
		if(faturaItem[5] != null){
			idImovelPesquisa = (Integer) faturaItem[5];
		}

		// cria o objeto pagamento para setar os dados
		Pagamento pagamento = new Pagamento();
		pagamento.setAnoMesReferenciaPagamento(anoMes);
		// caso o ano mes da data de dedito seja
		// maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano
		// mes da data de debito
		if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
			pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		}else{
			// caso contrario seta o o ano mes
			// arrecadação da tabela sistema
			// parametro
			pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
		}
		pagamento.setValorPagamento(valorConta);
		pagamento.setDataPagamento(dataPagamento);
		pagamento.setPagamentoSituacaoAtual(null);
		pagamento.setPagamentoSituacaoAnterior(null);
		pagamento.setDebitoTipo(null);
		// verifica se o id da conta é diferente de
		// nulo
		if(idContaPesquisa != null){
			Conta conta = new Conta();
			conta.setId(idContaPesquisa);
			pagamento.setConta(conta);
		}else{
			pagamento.setConta(null);
		}
		pagamento.setGuiaPagamentoGeral(null);

		pagamento.setDebitoACobrar(null);

		// verifica se o id da conta é diferente de
		// nulo
		if(idLocalidadePesquisa != null){
			Localidade localidade = new Localidade();
			localidade.setId(idLocalidadePesquisa);
			pagamento.setLocalidade(localidade);
		}else{
			pagamento.setLocalidade(null);
		}
		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.FATURA_CLIENTE);
		pagamento.setDocumentoTipo(documentoTipo);

		// seta o id do aviso bancario
		pagamento.setAvisoBancario(null);

		// seta o imovel
		if(idImovelPesquisa != null){
			Imovel imovel = new Imovel();
			imovel.setId(idImovelPesquisa);
			pagamento.setImovel(imovel);
		}else{
			pagamento.setImovel(null);
		}

		pagamento.setArrecadadorMovimentoItem(null);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaPagamento);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		pagamento.setCliente(null);
		pagamento.setUltimaAlteracao(new Date());

		return pagamento;
	}

	/**
	 * [UC0259] - Processar Pagamneto com Código de Barras
	 * Autor: Rafael Pinto
	 * Data: 19/04/2007
	 */
	protected Pagamento processarPagamentosCodigoBarrasTipoPagamento(int anoMes, Integer anoMesPagamento,
					SistemaParametro sistemaParametro, BigDecimal valorPagamento, Date dataPagamento, Integer idConta,
					Integer idLocalidade, Integer idFormaPagamento, Integer idImovelNaBase, Imovel imovel) throws ControladorException{

		Pagamento pagamento = new Pagamento();
		pagamento.setAnoMesReferenciaPagamento(anoMes);

		// caso o ano mes da data de dedito seja
		// maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano
		// mes da data de debito
		if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
			pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		}else{
			// caso contrario seta o o ano mes
			// arrecadação da tabela sistema
			// parametro
			pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
		}

		pagamento.setValorPagamento(valorPagamento);
		pagamento.setDataPagamento(dataPagamento);
		pagamento.setPagamentoSituacaoAtual(null);
		pagamento.setPagamentoSituacaoAnterior(null);
		pagamento.setDebitoTipo(null);
		// verifica se o id da conta é diferente de
		// nulo
		if(idConta != null){
			Conta conta = new Conta();
			conta.setId(idConta);
			pagamento.setConta(conta);
		}else{
			pagamento.setConta(null);
		}
		pagamento.setGuiaPagamentoGeral(null);

		// verifica se o id da conta é diferente de
		// nulo
		if(idLocalidade != null){
			Localidade localidade = new Localidade();
			localidade.setId(idLocalidade);
			pagamento.setLocalidade(localidade);
		}else{
			pagamento.setLocalidade(null);
		}
		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.CONTA);
		pagamento.setDocumentoTipo(documentoTipo);

		// seta o id do aviso bancario
		pagamento.setAvisoBancario(null);

		// seta o imovel
		if(idImovelNaBase != null){
			pagamento.setImovel(imovel);
		}else{
			pagamento.setImovel(null);
		}

		pagamento.setArrecadadorMovimentoItem(null);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaPagamento);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		pagamento.setCliente(null);
		pagamento.setUltimaAlteracao(new Date());

		return pagamento;
	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * [SB0005] - Processar Recebimento de Acréscimos por Inpontualidade
	 * 
	 * @autor Sávio Luiz
	 * @date 15/02/2006
	 * @author Saulo Lima
	 * @date 02/04/2009
	 *       Adicionar o número da prestação no pagamento
	 */
	public Pagamento processarRecebimentoAcrescimosImpontualidade(Integer idCobrancaDocumento, Date dataPagamento, BigDecimal valorDebito,
					Integer idImovel, Integer idLocalidade, SistemaParametro sistemaParametro, Integer idFormaPagamento)
					throws ControladorException{

		GuiaPagamento guiaPagamento = new GuiaPagamento();
		guiaPagamento.setValorDebito(valorDebito);
		Imovel imovel = null;
		if(idImovel != null){
			imovel = new Imovel();
			imovel.setId(idImovel);
		}
		guiaPagamento.setImovel(imovel);

		Integer idGuiaPagamento = this.getControladorFaturamento().inserirGuiaPagamentoCodigoBarras(guiaPagamento,
						DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE, dataPagamento);
		guiaPagamento.setId(idGuiaPagamento);

		// cria o objeto pagamento para setar os dados
		Pagamento pagamento = new Pagamento();
		pagamento.setAnoMesReferenciaPagamento(null);

		Integer anoMesPagamento = Util.formataAnoMes(dataPagamento);

		// caso o ano mes da data de dedito seja maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano mes da data de debito
		if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
			pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		}else{
			// caso contrario seta o o ano mes arrecadação da tabela sistema parametro
			pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
		}

		pagamento.setValorPagamento(valorDebito);
		pagamento.setDataPagamento(dataPagamento);
		pagamento.setPagamentoSituacaoAtual(null);
		pagamento.setPagamentoSituacaoAnterior(null);
		DebitoTipo debitoTipo = new DebitoTipo();
		debitoTipo.setId(DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE);
		pagamento.setDebitoTipo(debitoTipo);
		pagamento.setConta(null);

		guiaPagamento.setGuiaPagamentoGeral(new GuiaPagamentoGeral());
		guiaPagamento.getGuiaPagamentoGeral().setId(guiaPagamento.getId());

		pagamento.setGuiaPagamentoGeral(guiaPagamento.getGuiaPagamentoGeral());
		pagamento.getGuiaPagamentoGeral().setGuiaPagamento(guiaPagamento);
		pagamento.setNumeroPrestacao(Integer.valueOf(1));

		pagamento.setDebitoACobrar(null);

		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
		pagamento.setDocumentoTipo(documentoTipo);

		// seta o id do aviso bancario
		pagamento.setAvisoBancario(null);

		// seta o imovel
		if(imovel != null && !imovel.equals("")){
			pagamento.setImovel(imovel);
			if(idLocalidade != null){
				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);
			}else{
				pagamento.setLocalidade(null);
			}
		}else{
			pagamento.setImovel(null);
		}

		pagamento.setArrecadadorMovimentoItem(null);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaPagamento);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		pagamento.setCliente(null);
		pagamento.setUltimaAlteracao(new Date());

		return pagamento;
	}

	protected int obterMesAnoReferencia(int anoMes){

		int retorno = 0;
		int calculo = 0;

		final int CONSTANTE_REFERENCIA = 457;
		final int CONSTANTE_ANO_MES = 200001;

		calculo = anoMes - CONSTANTE_REFERENCIA;

		Date data = Util.adcionarOuSubtrairMesesAData(null, calculo, CONSTANTE_ANO_MES);

		Integer resultadoAnoMes = Util.recuperaAnoMesDaData(data);

		retorno = resultadoAnoMes.intValue();

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * [SB0006] - Processar Desconto Concedido no Documento de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @date 15/02/2006
	 */

	public Devolucao processarDescontoConcedidoDocumentoCobranca(Integer idCobrancaDocumento, Date dataPagamento, BigDecimal valorDebito,
					Integer idImovel, Integer idLocalidade, SistemaParametro sistemaParametro, Integer idFormaPagamento)
					throws ControladorException{

		GuiaDevolucao guiaDevolucao = new GuiaDevolucao();
		if(idLocalidade != null){
			Localidade localidade = new Localidade();
			localidade.setId(idLocalidade);
			guiaDevolucao.setLocalidade(localidade);
		}else{
			guiaDevolucao.setLocalidade(null);
		}
		Imovel imovel = null;
		if(idImovel != null){
			imovel = new Imovel();
			imovel.setId(idImovel);
		}
		guiaDevolucao.setImovel(imovel);
		guiaDevolucao.setCliente(null);
		guiaDevolucao.setAnoMesReferenciaContabil(sistemaParametro.getAnoMesArrecadacao());
		guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(null);
		guiaDevolucao.setDataEmissao(new Date());
		guiaDevolucao.setDataValidade(new Date());
		guiaDevolucao.setValorDevolucao(valorDebito);
		guiaDevolucao.setRegistroAtendimento(null);
		guiaDevolucao.setOrdemServico(null);
		Integer idLancamentoItemContabil = null;
		try{

			idLancamentoItemContabil = repositorioArrecadacao.pesquisarIdLancamentoItemContabil(CreditoTipo.DESCONTOS_CONCEDIDOS);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		if(idLancamentoItemContabil != null && !idLancamentoItemContabil.equals("")){
			LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
			lancamentoItemContabil.setId(idLancamentoItemContabil);
			guiaDevolucao.setLancamentoItemContabil(lancamentoItemContabil);
		}
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
		guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
		guiaDevolucao.setDebitoCreditoSituacaoAnterior(null);

		CreditoTipo creditoTipo = new CreditoTipo();
		creditoTipo.setId(CreditoTipo.DESCONTOS_CONCEDIDOS);
		guiaDevolucao.setCreditoTipo(creditoTipo);

		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.DEVOLUCAO_VALOR);
		guiaDevolucao.setDocumentoTipo(documentoTipo);
		guiaDevolucao.getContaGeral().setConta(null);
		guiaDevolucao.setGuiaPagamentoGeral(null);
		guiaDevolucao.setDebitoACobrarGeral(null);
		DebitoTipo debitoTipo = new DebitoTipo();
		debitoTipo.setId(DebitoTipo.OUTROS);
		guiaDevolucao.setDebitoTipo(debitoTipo);

		guiaDevolucao.setUltimaAlteracao(new Date());

		/*
		 * Cometado por Raphael Rossiter em 29/10/2007 - Analista: Aryed Lins
		 * OBJ: O caso de uso que inicia o processo será o responsável pela
		 * inserção tanto da guia de devolução quanto da propria devolução.
		 */
		/*
		 * Integer idGuiaDevolucao = (Integer)
		 * getControladorUtil().inserir(guiaDevolucao);
		 * guiaDevolucao.setId(idGuiaDevolucao);
		 */

		// cria o objeto pagamento para setar os
		// dados
		Devolucao devolucao = new Devolucao();
		devolucao.setAnoMesReferenciaDevolucao(null);

		Integer anoMesPagamento = Util.formataAnoMes(dataPagamento);

		// caso o ano mes da data de dedito seja
		// maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano
		// mes da data de debito
		if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
			devolucao.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		}else{
			// caso contrario seta o o ano mes
			// arrecadação da tabela sistema
			// parametro
			devolucao.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
		}

		devolucao.setValorDevolucao(valorDebito);
		devolucao.setDataDevolucao(dataPagamento);
		devolucao.setDevolucaoSituacaoAtual(null);
		devolucao.setDevolucaoSituacaoAnterior(null);
		// seta o id do aviso bancario
		devolucao.setAvisoBancario(null);
		devolucao.setDebitoTipo(null);

		devolucao.setGuiaDevolucao(guiaDevolucao);

		if(idLocalidade != null){
			Localidade localidade = new Localidade();
			localidade.setId(idLocalidade);
			devolucao.setLocalidade(localidade);
		}else{
			devolucao.setLocalidade(null);
		}

		if(idImovel != null){
			imovel = new Imovel();
			imovel.setId(idImovel);
			devolucao.setImovel(imovel);
		}else{
			devolucao.setImovel(null);
		}
		devolucao.setCliente(null);

		devolucao.setDebitoTipo(debitoTipo);

		devolucao.setUltimaAlteracao(new Date());

		return devolucao;

	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * [SB0007] - Processar Taxa do Documento de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @data 15/02/2006
	 */

	public Pagamento processarTaxaDocumentoCobranca(Integer idCobrancaDocumento, Date dataPagamento, BigDecimal valorTaxa,
					Integer idImovel, Integer idLocalidade, SistemaParametro sistemaParametro, Integer idFormaPagamento)
					throws ControladorException{

		GuiaPagamento guiaPagamento = new GuiaPagamento();
		guiaPagamento.setValorDebito(valorTaxa);
		Imovel imovel = null;
		if(idImovel != null){
			imovel = new Imovel();
			imovel.setId(idImovel);
		}
		guiaPagamento.setImovel(imovel);
		// guiaPagamento.setDataVencimento(dataPagamento);

		Integer idGuiaPagamento = getControladorFaturamento().inserirGuiaPagamentoCodigoBarras(guiaPagamento, DebitoTipo.TAXA_COBRANCA,
						dataPagamento);
		guiaPagamento.setId(idGuiaPagamento);

		// cria o objeto pagamento para setar os
		// dados
		Pagamento pagamento = new Pagamento();
		pagamento.setAnoMesReferenciaPagamento(null);

		Integer anoMesPagamento = Util.formataAnoMes(dataPagamento);

		// caso o ano mes da data de dedito seja
		// maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano
		// mes da data de debito
		if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
			pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		}else{
			// caso contrario seta o o ano mes
			// arrecadação da tabela sistema
			// parametro
			pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
		}

		pagamento.setValorPagamento(valorTaxa);
		pagamento.setDataPagamento(dataPagamento);
		pagamento.setPagamentoSituacaoAtual(null);
		pagamento.setPagamentoSituacaoAnterior(null);
		DebitoTipo debitoTipo = new DebitoTipo();
		debitoTipo.setId(DebitoTipo.TAXA_COBRANCA);
		pagamento.setDebitoTipo(debitoTipo);
		pagamento.setConta(null);

		guiaPagamento.setGuiaPagamentoGeral(new GuiaPagamentoGeral());
		guiaPagamento.getGuiaPagamentoGeral().setId(guiaPagamento.getId());

		pagamento.setGuiaPagamentoGeral(guiaPagamento.getGuiaPagamentoGeral());
		pagamento.getGuiaPagamentoGeral().setGuiaPagamento(guiaPagamento);

		pagamento.setDebitoACobrar(null);

		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
		pagamento.setDocumentoTipo(documentoTipo);

		// seta o id do aviso bancario
		pagamento.setAvisoBancario(null);

		// seta o imovel
		if(imovel != null && !imovel.equals("")){
			pagamento.setImovel(imovel);
			if(idLocalidade != null){
				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);
			}else{
				pagamento.setLocalidade(null);
			}
		}else{
			pagamento.setImovel(null);

		}

		pagamento.setArrecadadorMovimentoItem(null);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaPagamento);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		pagamento.setCliente(null);
		pagamento.setUltimaAlteracao(new Date());

		return pagamento;

	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * [SB0008] - Alterar Vencimento dos Itens do documento de cobrança
	 * 
	 * @author Sávio Luiz
	 * @date 15/02/2006
	 * @author Virgínia Melo
	 * @date 02/03/2009
	 *       Correção para considerar nova estrutura da guia de pagamento.
	 *       Será alterada a data de vencimento das prestações e não da guia.
	 */

	public void alterarVencimentoItensDocumentoCobranca(Integer idCobrancaDocumento, Date dataEmissao) throws ControladorException{

		Collection colecaoContas = null;
		Collection colecaoGuiaPagamentoPrestacoes = null;

		try{
			colecaoContas = repositorioCobranca.pesquisarCobrancaDocumentoItemComConta(idCobrancaDocumento);

			// 1.1 - [UC151] - Alterar Vencimento de Conta
			getControladorFaturamento().alterarVencimentoConta(colecaoContas, null, dataEmissao, null);

			// 1.2 - alterar a data de vencimento das guias de pagamento
			colecaoGuiaPagamentoPrestacoes = repositorioCobranca.pesquisarGuiaPagamentoPrestacao(idCobrancaDocumento);

			if(colecaoGuiaPagamentoPrestacoes != null && !colecaoGuiaPagamentoPrestacoes.isEmpty()){
				repositorioCobranca.atualizarGuiaPagamentoPrestacao(colecaoGuiaPagamentoPrestacoes, dataEmissao);
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @date 15/02/2006
	 */
	public RegistroHelperCodigoBarras distribuirDadosCodigoBarras(String codigoBarras) throws ControladorException{

		if(!Util.isNumero(codigoBarras, false, 0)){
			log.error("codigoBarras " + codigoBarras);
			throw new ControladorException("atencao.codigo.barras.invalido");
		}

		// instancia o objeto de código de barras
		RegistroHelperCodigoBarras registroHelperCodigoBarras = new RegistroHelperCodigoBarras();

		// seta as subStrings nos respectivos campos do objeto registroHelperCodigoBarras
		registroHelperCodigoBarras.setIdProduto(codigoBarras.substring(0, 1).trim());
		registroHelperCodigoBarras.setIdSegmento(codigoBarras.substring(1, 2).trim());
		registroHelperCodigoBarras.setIdValorReal(codigoBarras.substring(2, 3).trim());
		registroHelperCodigoBarras.setDigitoVerificadorGeral(codigoBarras.substring(3, 4).trim());
		registroHelperCodigoBarras.setValorPagamento(codigoBarras.substring(4, 15).trim());
		registroHelperCodigoBarras.setIdEmpresa(codigoBarras.substring(15, 19).trim());

		// recupera o tipo pagamento e passa para int
		int tipoPagamentoOuLegado = Integer.parseInt(codigoBarras.substring(43, 44).trim());

		// chama o método distribuirDadosCodigoBarrasPorTipoPagamento para distribuir os dados de
		// acordo com o tipo de pagamento
		Object[] pagamentoCodigoBarras = (Object[]) ParametroArrecadacao.P_DISTRIBUIR_PAGAMENTO_CODIGO_BARRAS_LEGADO.executar(this, -1,
						codigoBarras, registroHelperCodigoBarras, tipoPagamentoOuLegado);

		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = (RegistroHelperCodigoBarrasTipoPagamento) pagamentoCodigoBarras[0];
		Integer tipoPagamento = (Integer) pagamentoCodigoBarras[1];
		String descricaoOcorrenciaMovimento = (String) pagamentoCodigoBarras[2];

		registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);

		if(tipoPagamento != null){
			String tipoPagamentoStr = tipoPagamento.toString();
			registroHelperCodigoBarras.setTipoPagamento(tipoPagamentoStr);
		}else{
			registroHelperCodigoBarras.setTipoPagamento(null);
		}

		registroHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrenciaMovimento);

		return registroHelperCodigoBarras;
	}

	/**
	 * Retorna o objeto distribuido de acordo com o tipo de pagamento
	 * [UC0264] - Distribuir Dados do Código de Barras
	 * [SF0001] - Distribuir Pagamento de Conta
	 * [SF0002] - Distribuir Pagamento de Guia de Pagamento
	 * [SF0003] - Distribuir Pagamento de Documento de Cobrança
	 * [SF0004] - Distribuir Pagamento de Fatura do Cliente Responsável
	 * 
	 * @author Sávio Luiz
	 * @throws ControladorException
	 * @date 15/02/2006
	 */
	public Object[] distribuirDadosCodigoBarrasPorTipoPagamento(String idPagamento, int tipoPagamento, String idEmpresa)
					throws ControladorException{

		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();

		// seta as subStrings nos respectivos campos do objeto
		// registroHelperCodigoBarrasTipoPagamento dependendo do tipo de pagamento

		switch(tipoPagamento){

			case PagamentoTipo.PAGAMENTO_TIPO_CONTA:

				// seta a matrícula do imóvel
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 8).trim());
				// seta o mês e ano de referência(MMAAAA)
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(8, 14).trim());
				// não está sendo utilizado
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(14, 23).trim());


				break;

			case PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_MATRICULA_IMOVEL:

				String[] valoresGuiaImovel = this.distribuirDadosCodigoBarrasGuiaPagamento(idPagamento);

				// seta a Matrícula do Imóvel
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(valoresGuiaImovel[0]);
				// seta o Id da Guia de Pagamento
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(valoresGuiaImovel[1]);
				// Número da prestação
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(valoresGuiaImovel[2]);
				// não está sendo utilizado
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(valoresGuiaImovel[3]);
				break;

			case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_PRE_PARCELAMENTO: // substituir pela constante
				// Código da localidade
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 3));
				// Código da opção de preparcelamento
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 11));
				// Seguencial do documento de cobranca
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(11, 20));
				// Código do tipo de documento
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(20, 22));
				// Não utilizado
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento.substring(22, 24));
				break;

			case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_MATRICULA_IMOVEL:
				// seta o código da localidade
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 3).trim());
				// seta a matrícula do imóvel
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 11).trim());
				// seta o sequencial do documento de cobrança
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(11, 20).trim());
				// seta o código do tipo de documento
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(20, 22).trim());
				// não está sendo utilizado
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento.substring(22, 24).trim());
				break;

			case PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_CODIGO_CLIENTE:

				String[] valoresGuiaCliente = this.distribuirDadosCodigoBarrasGuiaPagamento(idPagamento);

				// seta o Código do Cliente
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(valoresGuiaCliente[0]);
				// seta o Id da Guia de Pagamento
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(valoresGuiaCliente[1]);
				// Número da prestação
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(valoresGuiaCliente[2]);
				// não está sendo utilizado
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(valoresGuiaCliente[3]);
				break;

			case PagamentoTipo.PAGAMENTO_TIPO_CLIENTE_RESPONSAVEL:
				// seta o código do cliente responsável
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 9).trim());
				// não está sendo utilizado
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(9, 14).trim());
				// sequencial de fatura do cliente responsável
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(14, 23).trim());
				break;

			case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_CODIGO_CLIENTE:
				// não está sendo utilizado
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 3).trim());
				// seta o código do cliente
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 11).trim());
				// seta o sequencial do documento de cobrança
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(11, 20).trim());
				// seta o código do tipo de documento
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(20, 22).trim());
				// não está sendo utilizado
				registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento.substring(22, 24).trim());
				break;

		}

		Object[] retorno = new Object[3];

		retorno[0] = registroHelperCodigoBarrasTipoPagamento;
		retorno[1] = tipoPagamento;
		retorno[2] = "OK";

		return retorno;
	}

	/**
	 * Formata a distribuição de acordo com o tamanho do ID da Guia de Pagmento no Código de Barras.
	 * [UC0264] – Distribuir Dados do Código de Barras
	 * 
	 * @author Saulo Lima
	 * @date 14/04/2012
	 * @param idPagamento
	 * @return String[]
	 * @throws ControladorException
	 */
	private String[] distribuirDadosCodigoBarrasGuiaPagamento(String idPagamento) throws ControladorException{

		String tamanho = ParametroArrecadacao.P_TAMANHO_CAMPO_GUIA_PAGAMENTO_CODIGO_BARRAS.executar();
		String[] retorno = new String[4];

		if(tamanho.equals("8")){

			// seta a Matrícula do Imóvel ou Cliente (8 dígitos)
			retorno[0] = idPagamento.substring(0, 8).trim();
			// seta o Id da Guia de Pagamento (8 dígitos)
			retorno[1] = idPagamento.substring(8, 16).trim();
			// Número da prestação (3 dígitos)
			retorno[2] = idPagamento.substring(16, 19).trim();
			// não está sendo utilizado (4 dígitos)
			retorno[3] = idPagamento.substring(19, 24).trim();

		}else if(tamanho.equals("9")){

			// seta a Matrícula do Imóvel ou Cliente (8 dígitos)
			retorno[0] = idPagamento.substring(0, 8).trim();
			// seta o Id da Guia de Pagamento (9 dígitos)
			retorno[1] = idPagamento.substring(8, 17).trim();
			// Número da prestação (3 dígitos)
			retorno[2] = idPagamento.substring(17, 20).trim();
			// não está sendo utilizado (3 dígitos)
			retorno[3] = idPagamento.substring(20, 24).trim();

		}else{
			throw new ControladorException("Valor do Parâmetro Inválido");
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SF0008] - Gerar Ocorrência na coleção de Avisos Bancários
	 * 
	 * @author Sávio Luiz
	 * @data 15/02/2006
	 * @author Saulo Lima
	 * @date 12/12/2008
	 *       Correção - Procurar o Id do Arrecadador pelo código do Agente.
	 */
	public AvisoBancario gerarOcorrenciaAvisoBancario(Integer idMovimento, RegistroHelperCodigoA registroHelperCodigoA,
					Date dataPrevistaCredito, String valorTotalRegistrosArquivo, Integer spAnoMesArrecadacao, String codigoBanco,
					BigDecimal valorArrecadacaoInf, BigDecimal valorArrecadacaoCalc, BigDecimal valorDevolucaoCalc,
					BigDecimal valorDevolucaoInf, Short numeroSequencialAvisoBancario, ArrecadadorContrato arrecadadorContrato,
					Arrecadador arrecadadorSelecionado)
					throws ControladorException{

		// instância o aviso bancário
		AvisoBancario avisoBancario = new AvisoBancario();
		// avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
		// avisoBancario.adicionarUsuario(usuario, usuarioAcao);

		// seta os campos no aviso bancário
		Arrecadador arrecadador = new Arrecadador();

		if(arrecadadorSelecionado != null){
			arrecadador.setId(arrecadadorSelecionado.getId());
		}else{
			arrecadador.setId(Integer.valueOf(registroHelperCodigoA.getCodigoBanco()));
		}
		avisoBancario.setArrecadador(arrecadador);

		Date dataLancamento = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA.getDataGeracaoArquivo());
		avisoBancario.setDataLancamento(dataLancamento);
		avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);
		avisoBancario.setDataPrevista(dataPrevistaCredito);
		avisoBancario.setDataRealizada(dataPrevistaCredito);

		avisoBancario.setValorRealizado(valorArrecadacaoInf);

		avisoBancario.setValorArrecadacaoCalculado(valorArrecadacaoCalc);
		avisoBancario.setValorArrecadacaoInformado(Util
						.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(valorTotalRegistrosArquivo));
		avisoBancario.setValorDevolucaoCalculado(valorDevolucaoCalc);
		avisoBancario.setValorDevolucaoInformado(valorDevolucaoInf);
		avisoBancario.setValorContabilizado(BigDecimal.ZERO);
		Integer anoMesDataLancamento = Util.recuperaAnoMesDaData(dataLancamento);
		if(anoMesDataLancamento > anoMesDataLancamento){
			avisoBancario.setAnoMesReferenciaArrecadacao(anoMesDataLancamento);
		}else{
			avisoBancario.setAnoMesReferenciaArrecadacao(spAnoMesArrecadacao);
		}
		avisoBancario.setIndicadorCreditoDebito(AvisoBancario.INDICADOR_CREDITO);
		avisoBancario.setNumeroDocumento(0);
		avisoBancario.setUltimaAlteracao(new Date());

		ContaBancaria contaBancaria = null;

		if(arrecadadorContrato != null){
			ContaBancaria contaBancariaDepositoArrecadacao = arrecadadorContrato.getContaBancariaDepositoArrecadacao();

			if(contaBancariaDepositoArrecadacao != null){
				Integer idContaBancaria = contaBancariaDepositoArrecadacao.getId();

				contaBancaria = new ContaBancaria();
				contaBancaria.setId(idContaBancaria);
			}
		}

		avisoBancario.setContaBancaria(contaBancaria);
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);

		return avisoBancario;
	}

	/**
	 * [UC0235] - Inserir Aviso Bancario
	 * 
	 * @author Rhawi Dantas
	 * @date 16/02/2006
	 */
	public Double pesquisarDeducoesAvisoBancario(String codigoAgente, Date dataLancamento, String numeroSequencial)
					throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarDeducoesAvisoBancario(codigoAgente, dataLancamento, numeroSequencial);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0235] - Inserir Aviso Bancario
	 * 
	 * @author Rafael Corrêa
	 * @date 24/03/2006
	 *       [FS0003] Verificar existência de avisos bancários não realizados
	 *       [FS0004] Verificar seleção de aviso Retorna o valor do maior número sequencial do
	 *       arrecadador selecionado
	 */
	public Short pesquisarValorMaximoNumeroSequencial(Date dataLancamento, String idArrecadador) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarValorMaximoNumeroSequencial(dataLancamento, idArrecadador);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores [SF0010] - Gerar o
	 * arquivo de envio para o arrecadador com registros do Movimento Autor:
	 * Sávio Luiz Data: 15/02/2006
	 */
	public void gerarArquivoRegistrosTipoC(RegistroHelperCodigoA registroHelperCodigoA, RegistroHelperCodigoZ registroHelperCodigoZ,
					Collection colecaoRegistrosC, Integer numeroSequencialArquivoEnvioDebitoAutomatico, String descricaoOcorrencia,
					Integer indicadorAceitacaoRegistro, String idTipoMovimento, Arrecadador arrecadador) throws ControladorException{

		StringBuilder registrosC = new StringBuilder();
		// cria o header do código C para inserir o movimento arrecadador
		RegistroHelperCodigoA registroHelperHeaderC = new RegistroHelperCodigoA();
		// cria o trailler do código C para inserir o móvimento arrecadador
		RegistroHelperCodigoZ registroHelperTreillerC = new RegistroHelperCodigoZ();

		// inicializa com 1, pois já está contando com a linha do registro A
		int quantidadeRegistros = 1;

		registrosC.append("A");
		registroHelperHeaderC.setCodigoRegistro("A");
		registrosC.append("1");
		registroHelperHeaderC.setCodigoRemessa("1");
		// seta o código do convênio
		registrosC.append(Util.completaString(registroHelperCodigoA.getCodigoConvenio(), 20));
		registroHelperHeaderC.setCodigoConvenio(registroHelperCodigoA.getCodigoConvenio());
		// seta o nome da empresa
		registrosC.append(Util.completaString(registroHelperCodigoA.getNomeEmpresa(), 20));
		registroHelperHeaderC.setNomeEmpresa(registroHelperCodigoA.getNomeEmpresa());
		// seta o código do banco
		registrosC.append(Util.adicionarZerosEsquedaNumero(3, registroHelperCodigoA.getCodigoBanco()));
		registroHelperHeaderC.setCodigoBanco(registroHelperCodigoA.getCodigoBanco());
		// seta o nome do banco
		registrosC.append(Util.completaString(registroHelperCodigoA.getNomeBanco(), 20));
		registroHelperHeaderC.setNomeBanco(registroHelperCodigoA.getNomeBanco());
		// seta a data corrente
		String dataAtualString = Util.recuperaDataInvertida(new Date());
		registrosC.append(Util.completaString(dataAtualString, 8));
		registroHelperHeaderC.setDataGeracaoArquivo(dataAtualString);

		// seta numero sequencial da tabela Arrecadador_Contrato o campo
		// ARCT_NNNSAENVIODEBAUT + 1
		numeroSequencialArquivoEnvioDebitoAutomatico += 1;
		registrosC.append(Util.adicionarZerosEsquedaNumero(6, "" + numeroSequencialArquivoEnvioDebitoAutomatico));
		registroHelperHeaderC.setNumeroSequencialArquivo("" + numeroSequencialArquivoEnvioDebitoAutomatico);
		// seta a versão de layout
		registrosC.append(Util.adicionarZerosEsquedaNumero(2, "" + registroHelperCodigoA.getVersaoLayout()));
		registroHelperHeaderC.setVersaoLayout(registroHelperCodigoA.getVersaoLayout());
		// tipo do movimento
		registrosC.append(Util.completaString(registroHelperCodigoA.getTipoMovimento(), 17));
		registroHelperHeaderC.setTipoMovimento(registroHelperCodigoA.getTipoMovimento());

		// reservado para o futuro
		registrosC.append(Util.completaString("", 51));
		// reservado para o futuro

		String pFinalizarComAsterisco = (String) ParametroArrecadacao.P_FINALIZAR_HEADER_TRAILLER_REGISTRO_TIPO_C_COM_ASTERISCO
						.executar(this);

		if(pFinalizarComAsterisco.equals(ConstantesSistema.SIM.toString())){
			registrosC.append(Util.completaString("*", 1));
		}else{
			registrosC.append(Util.completaString(" ", 1));
		}

		registroHelperHeaderC.setReservadoFuturo(registroHelperCodigoA.getReservadoFuturo());

		// parte do treiller criada para inserir no movimento arrecadador
		registroHelperTreillerC.setCodigoRegistro("Z");
		// o total de registros é a quantidade da coleção mais a header e o
		// treiller (1+1)
		registroHelperTreillerC.setTotalRegistrosArquivo("" + (colecaoRegistrosC.size() + 2));

		registroHelperTreillerC.setValorTotalRegistrosArquivo("000");

		ArrecadadorMovimento arrecadadorMovimento = inserirMovimentoArrecadador(registroHelperHeaderC, registroHelperTreillerC,
						idTipoMovimento, arrecadador);

		// pula uma linha
		registrosC.append(System.getProperty("line.separator"));

		Iterator colecaoRegistrosCIterator = colecaoRegistrosC.iterator();
		while(colecaoRegistrosCIterator.hasNext()){
			// cria uma string builder para pegar linha a linha da coleção
			// inserir o movimento arrecadador e depois inserir na string
			// builder do registrosC
			// para ser mandado para o banco.
			StringBuilder linhaRegistroC = new StringBuilder();
			// incrementa a quantidade de registros para cada registro da
			// coleção
			quantidadeRegistros = quantidadeRegistros + 1;
			// começa a criar a string com o registro do tipo c
			RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) colecaoRegistrosCIterator.next();
			linhaRegistroC.append("C");
			// Identificação do cliente na empresa
			linhaRegistroC.append(Util.completaString(registroHelperCodigoC.getIdClienteEmpresa(), 25));
			// agencia para debito
			linhaRegistroC.append(Util.completaString(registroHelperCodigoC.getAgenciaDebito(), 4));
			// Identificacao cliente banco
			linhaRegistroC.append(Util.completaString(registroHelperCodigoC.getIdClienteBanco(), 14));
			// descricao ocorrencia movimento
			linhaRegistroC.append(Util.completaString(registroHelperCodigoC.getDescricaoOcorrenciaMovimento(), 40));
			// brancos
			linhaRegistroC.append(Util.completaString("", 40));
			// reservado para o futuro
			linhaRegistroC.append(Util.completaString("", 25));
			// agencia para debito
			linhaRegistroC.append(Util.adicionarZerosEsquedaNumero(1, registroHelperCodigoC.getCodigoMovimento()));

			// inseri o item do movimento arrecadador
			inserirItemMovimentoArrecadador(linhaRegistroC.toString(), arrecadadorMovimento.getId(),
							registroHelperCodigoC.getDescricaoOcorrenciaMovimento(), indicadorAceitacaoRegistro, null);
			registrosC.append(linhaRegistroC);
			registrosC.append(System.getProperty("line.separator"));
		}

		// incrementa a quantidade de registros para registro Z
		quantidadeRegistros = quantidadeRegistros + 1;

		registrosC.append("Z");
		// total de registros do arquivo
		registrosC.append(Util.adicionarZerosEsquedaNumero(6, "" + quantidadeRegistros));
		// valor zero
		registrosC.append(Util.adicionarZerosEsquedaNumero(17, ""));
		// reservado para o futuro
		registrosC.append(Util.completaString("", 125));
		// reservado para o futuro

		if(pFinalizarComAsterisco.equals(ConstantesSistema.SIM.toString())){
			registrosC.append(Util.completaString("*", 1));
		}else{
			registrosC.append(Util.completaString(" ", 1));
		}

		registrosC.append(System.getProperty("line.separator"));

		EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.REGISTRAR_MOVIMENTO_ARRECADADORES);

		String emailRemetente = envioEmail.getEmailRemetente();
		String tituloMensagem = envioEmail.getTituloMensagem();
		String corpoMensagem = envioEmail.getCorpoMensagem();
		String emailReceptor = envioEmail.getEmailReceptor();

		mandaArquivoLeituraEmail(registrosC, emailReceptor, emailRemetente, tituloMensagem, corpoMensagem);

	}

	protected void mandaArquivoLeituraEmail(StringBuilder arquivo, String emailReceptor, String emailRemetente, String tituloMensagem,
					String corpoMensagem) throws ControladorException{

		try{
			File leitura = File.createTempFile("gcom", ".txt");
			BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leitura.getAbsolutePath())));
			out.write(arquivo.toString());
			out.close();

			ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

			leitura.delete();
		}catch(IOException e){
			throw new ControladorException("erro.sistema", e);
		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores [SF0002] - Inserir o
	 * movimento do arrecadador Autor: Sávio Luiz Data: 31/01/2006
	 */

	public ArrecadadorMovimento inserirMovimentoArrecadador(RegistroHelperCodigoA registroHelperCodigoA,
					RegistroHelperCodigoZ registroHelperCodigoZ, String idTipoMovimento, Arrecadador arrecadador)
					throws ControladorException{

		Integer idMovimento = null;
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		// cria o objeto de arrecadador movimento para a inserção
		arrecadadorMovimento.setCodigoRemessa(Short.valueOf(registroHelperCodigoA.getCodigoRemessa()));
		arrecadadorMovimento.setCodigoConvenio(registroHelperCodigoA.getCodigoConvenio().trim());
		arrecadadorMovimento.setNomeEmpresa(registroHelperCodigoA.getNomeEmpresa().trim());
		arrecadadorMovimento.setCodigoBanco(arrecadador.getCodigoAgente());
		arrecadadorMovimento.setNomeBanco(Util.truncarString(arrecadador.getCliente().getNome(), 40));
		Date dataGeracao = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA.getDataGeracaoArquivo().trim());
		arrecadadorMovimento.setDataGeracao(dataGeracao);
		arrecadadorMovimento.setNumeroSequencialArquivo(Integer.valueOf(registroHelperCodigoA.getNumeroSequencialArquivo().trim()));
		arrecadadorMovimento.setNumeroVersaoLayout(Integer.valueOf(registroHelperCodigoA.getVersaoLayout().trim()));
		arrecadadorMovimento.setDescricaoIdentificacaoServico(idTipoMovimento.trim());
		arrecadadorMovimento.setNumeroRegistrosMovimento(Integer.valueOf(registroHelperCodigoZ.getTotalRegistrosArquivo().trim()));
		BigDecimal valorTotalRegistros = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoZ
						.getValorTotalRegistrosArquivo().trim());
		arrecadadorMovimento.setValorTotalMovimento(valorTotalRegistros);
		arrecadadorMovimento.setUltimaAlteracao(new Date());

		try{
			idMovimento = (Integer) repositorioUtil.inserir(arrecadadorMovimento);
			arrecadadorMovimento.setId(idMovimento);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema");
		}
		return arrecadadorMovimento;
	}

	/**
	 * Este caso de uso cria um filtro do movimento dos arrecadadores
	 * [UC0263] - Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Raphael Rossiter
	 * @date 23/02/2006
	 * @param filtroArrecadadorMovimento
	 * @param movimentoOcorrencia
	 * @param movimentoAceito
	 * @param movimentoAbertoFechado
	 * @return Uma coleçao com os movimentos selecionados
	 * @throws ControladorException
	 */
	public FiltroArrecadadorMovimento filtrarMovimentoArrecadadores(FiltroArrecadadorMovimento filtroArrecadadorMovimento,
					String movimentoOcorrencia, String movimentoAceito, String movimentoAbertoFechado) throws ControladorException{

		Collection<ArrecadadorMovimento> retorno = new ArrayList();
		Collection<ArrecadadorMovimento> colecaoMovimentoArrecadadoresTotal = null;

		/*
		 * Movimento com/sem ítens em ocorrência
		 * Caso seja selecionado "COM ÍTENS EM OCORRÊNCIA" selecionar os
		 * movimentos que tenham algum ítem em ocorrência (a partir da tabela
		 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_DSOCORRENCIA diferente de "OK"),
		 * caso seja selecionado "SEM ITENS EM OCORÊNCIA" selecionar os
		 * movimentos que não tenham itens em ocorrência (a partir da tabela
		 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_DSOCORRENCIA igual a "OK")
		 */
		if(movimentoOcorrencia != null && !movimentoOcorrencia.equalsIgnoreCase("")
						&& !movimentoOcorrencia.equalsIgnoreCase("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){

			if(movimentoOcorrencia.equalsIgnoreCase("" + ConstantesSistema.COM_ITENS)){

				filtroArrecadadorMovimento.adicionarParametro(new ParametroSimplesColecaoDiferenteDe(
								FiltroArrecadadorMovimento.ARRECADADOR_MOVIMENTO_ITEM_DESCRICAO_OCORRENCIA, "OK"));
			}else{

				filtroArrecadadorMovimento.adicionarParametro(new ParametroSimplesColecao(
								FiltroArrecadadorMovimento.ARRECADADOR_MOVIMENTO_ITEM_DESCRICAO_OCORRENCIA, "OK"));
			}
		}

		/*
		 * Movimento com/sem ítens que não foram aceitos
		 * Caso seja selecionado "COM ITENS NÃO ACEITOS" selecionar os
		 * movimentos que tenham algum item não aceito (a partir da tabela
		 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_ICACEITACAO igual de 2 (NÃO)),
		 * caso seja selecionado os movimentos em que todos os itens tenha sido
		 * aceitos (a partir da tabela ARRECADADOR_MOVIMENTO_ITEM com
		 * AMIT_ICACEITACAO igual de 1 (SIM))
		 */
		if(movimentoAceito != null && !movimentoAceito.equalsIgnoreCase("")
						&& !movimentoAceito.equalsIgnoreCase("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){

			if(movimentoAceito.equalsIgnoreCase("" + ConstantesSistema.COM_ITENS)){

				filtroArrecadadorMovimento.adicionarParametro(new ParametroSimplesColecao(
								FiltroArrecadadorMovimento.ARRECADADOR_MOVIMENTO_ITEM_INDICADOR_ACEITACAO, ConstantesSistema.COM_ITENS));
			}else{

				filtroArrecadadorMovimento.adicionarParametro(new ParametroSimplesColecao(
								FiltroArrecadadorMovimento.ARRECADADOR_MOVIMENTO_ITEM_INDICADOR_ACEITACAO, ConstantesSistema.SEM_ITENS));
			}
		}

		/*
		 * Coleção com os movimentos abertos e fechados
		 */
		try{

			colecaoMovimentoArrecadadoresTotal = repositorioArrecadacao.filtrarMovimentoArrecadadores(filtroArrecadadorMovimento);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		retorno.addAll(colecaoMovimentoArrecadadoresTotal);

		// [FS0005] - Nenhum registro encontrado
		if(retorno == null || retorno.isEmpty()){
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return filtroArrecadadorMovimento;
	}

	/**
	 * Obtém o número de registros em ocorrência de um determinado movimento
	 * (número de linhas da tabela ARRECADADOR_MOVIMENTO_ITEM com ARMV_ID =
	 * ARMV_ID da tabela ARRECADADOR_MOVIMENTO e AMIT_DSOCORRENCIA diferente de
	 * "OK")
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * @param arrecadadorMovimento
	 * @return Um integer que representa a quantidade de registros selecionados
	 * @throws ControladorException
	 */
	public Integer obterNumeroRegistrosEmOcorrenciaPorMovimentoArrecadadores(ArrecadadorMovimento arrecadadorMovimento,
					String descricaoOcorrencia) throws ControladorException{

		Integer retorno = Integer.valueOf(0);

		try{

			retorno = repositorioArrecadacao.obterNumeroRegistrosEmOcorrenciaPorMovimentoArrecadadores(arrecadadorMovimento,
							descricaoOcorrencia);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Obtém o número de registros que não foram aceitos de um determinado
	 * movimento (número de linhas da tabela ARRECADADOR_MOVIMENTO_ITEM com
	 * ARMV_ID = ARMV_ID da tabela ARRECADADOR_MOVIMENTO e AMIT_ICACEITACAO
	 * igual a 2 (NÃO))
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * @param arrecadadorMovimento
	 * @return Um integer que representa a quantidade de registros selecionados
	 * @throws ControladorException
	 */
	public Integer obterNumeroRegistrosNaoAceitosPorMovimentoArrecadadores(ArrecadadorMovimento arrecadadorMovimento,
					Short indicadorAceitacao) throws ControladorException{

		Integer retorno = Integer.valueOf(0);

		try{

			retorno = repositorioArrecadacao.obterNumeroRegistrosNaoAceitosPorMovimentoArrecadadores(arrecadadorMovimento,
							indicadorAceitacao);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Lista os avisos bancários associados ao movimento com os seguintes dados:
	 * Data do Lançamento Sequencial do Aviso Tipo do Aviso Data do Crédito
	 * Valor do Crédito Valor da Arrecadação Valor Total dos pagamentos
	 * associados ao aviso Situação do Aviso
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * @param arrecadadorMovimento
	 * @return Uma Collection<AvisoBancarioHelper> que representa a os avisos
	 *         bancários selecionados
	 * @throws ControladorException
	 */
	public Collection<AvisoBancarioHelper> obterColecaoAvisosBancariosPorArrecadadorMovimento(ArrecadadorMovimento arrecadadorMovimento)
					throws ControladorException{

		Collection<AvisoBancarioHelper> retorno = new ArrayList();
		Collection<AvisoBancario> colecaoAvisosBancarios = null;
		AvisoBancario avisoBancario = null;
		AvisoBancarioHelper avisoBancarioHelper = null;
		BigDecimal valorInformado = null;
		BigDecimal valorCalculado = null;
		BigDecimal valorAcertos = null;

		/*
		 * Seleciona os avisos bancários de um determinado movimento
		 */
		try{

			colecaoAvisosBancarios = repositorioArrecadacao.obterAvisosBancariosPorArrecadadorMovimento(arrecadadorMovimento);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoAvisosBancarios != null && !colecaoAvisosBancarios.isEmpty()){

			Iterator iteratorColecaoAvisosBancarios = colecaoAvisosBancarios.iterator();

			while(iteratorColecaoAvisosBancarios.hasNext()){

				avisoBancario = (AvisoBancario) iteratorColecaoAvisosBancarios.next();
				avisoBancarioHelper = new AvisoBancarioHelper();
				valorInformado = BigDecimal.ZERO;
				valorCalculado = BigDecimal.ZERO;

				// Id do Aviso
				avisoBancarioHelper.setIdAvisoBancario(avisoBancario.getId());

				// Data do Lançamento
				if(avisoBancario.getDataLancamento() != null){

					avisoBancarioHelper.setDataLancamento(avisoBancario.getDataLancamento());
				}

				// Número Seqüencial Aviso
				if(avisoBancario.getNumeroSequencial() != null){

					avisoBancarioHelper.setNumeroSequencial(avisoBancario.getNumeroSequencial());
				}

				// Data de Crédito
				if(avisoBancario.getDataRealizada() != null){

					avisoBancarioHelper.setDataRealizada(avisoBancario.getDataRealizada());
				}

				// Obtém o valor dos acertos do aviso
				Object[] objetoValorAcertosAvisoBancario = null;
				try{

					objetoValorAcertosAvisoBancario = repositorioArrecadacao.pesquisarValorAcertosAvisoBancario(avisoBancario.getId());
				}catch(ErroRepositorioException e){

					throw new ControladorException("erro.sistema");
				}

				BigDecimal valorSomatorioAcertoCreditoArrecadacao = BigDecimal.ZERO;
				BigDecimal valorSomatorioAcertoDebitoArrecadacao = BigDecimal.ZERO;
				BigDecimal valorSomatorioAcertoCreditoDevolucao = BigDecimal.ZERO;
				BigDecimal valorSomatorioAcertoDebitoDevolucao = BigDecimal.ZERO;

				/*
				 * Somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO = 1 e
				 * AVAC_ICARRECADACAODEVOLUCAO = 1 com AVBC_ID = AVBC da tabela AVISO_BANCARIO
				 */
				if(objetoValorAcertosAvisoBancario[0] != null){

					valorSomatorioAcertoCreditoArrecadacao = (BigDecimal) objetoValorAcertosAvisoBancario[0];
				}

				/*
				 * Somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO = 2 e
				 * AVAC_ICARRECADACAODEVOLUCAO = 1 com AVBC_ID = AVBC da tabela AVISO_BANCARIO
				 */
				if(objetoValorAcertosAvisoBancario[1] != null){

					valorSomatorioAcertoDebitoArrecadacao = (BigDecimal) objetoValorAcertosAvisoBancario[1];
				}

				/*
				 * Somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO = 1 e
				 * AVAC_ICARRECADACAODEVOLUCAO = 2 com AVBC_ID = AVBC da tabela AVISO_BANCARIO
				 */
				if(objetoValorAcertosAvisoBancario[2] != null){

					valorSomatorioAcertoCreditoDevolucao = (BigDecimal) objetoValorAcertosAvisoBancario[2];
				}

				/*
				 * Somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO = 2 e
				 * AVAC_ICARRECADACAODEVOLUCAO = 2 com AVBC_ID = AVBC da tabela AVISO_BANCARIO
				 */
				if(objetoValorAcertosAvisoBancario[3] != null){

					valorSomatorioAcertoDebitoDevolucao = (BigDecimal) objetoValorAcertosAvisoBancario[3];
				}

				// Verifica se o Aviso é de Crédito "1" ou Débito "2"
				if(avisoBancario.getIndicadorCreditoDebito() != null){

					if(avisoBancario.getIndicadorCreditoDebito().equals(AvisoBancario.INDICADOR_CREDITO)){

						// Tipo do Aviso
						avisoBancarioHelper.setDescricaoIndicadorCreditoDebito(AvisoBancario.SIGLA_CREDITO);

						// Valor Arrecadação Informado
						if(avisoBancario.getValorArrecadacaoInformado() != null){

							avisoBancarioHelper.setValorInformado(avisoBancario.getValorArrecadacaoInformado());
							valorInformado = avisoBancario.getValorArrecadacaoInformado();
						}

						// Valor dos Acertos de Aviso de Crédito
						avisoBancarioHelper.setValorAcertos(valorSomatorioAcertoCreditoArrecadacao
										.subtract(valorSomatorioAcertoDebitoArrecadacao));
						valorAcertos = valorSomatorioAcertoCreditoArrecadacao.subtract(valorSomatorioAcertoDebitoArrecadacao);

						// Valor Arrecadação Calculado
						if(avisoBancario.getValorArrecadacaoCalculado() != null){

							avisoBancarioHelper.setValorCalculado(avisoBancario.getValorArrecadacaoCalculado());
							valorCalculado = avisoBancario.getValorArrecadacaoCalculado();
						}

					}else{

						// Tipo do Aviso
						avisoBancarioHelper.setDescricaoIndicadorCreditoDebito(AvisoBancario.SIGLA_DEBITO);

						// Valor Devolução Informado
						if(avisoBancario.getValorDevolucaoInformado() != null){

							avisoBancarioHelper.setValorInformado(avisoBancario.getValorDevolucaoInformado());
							valorInformado = avisoBancario.getValorDevolucaoInformado();
						}

						// Valor dos Acertos de Aviso de Devolução
						avisoBancarioHelper.setValorAcertos(valorSomatorioAcertoCreditoDevolucao
										.subtract(valorSomatorioAcertoDebitoDevolucao));
						valorAcertos = valorSomatorioAcertoCreditoDevolucao.subtract(valorSomatorioAcertoDebitoDevolucao);

						// Valor Devolução Calculado
						if(avisoBancario.getValorDevolucaoCalculado() != null){

							avisoBancarioHelper.setValorCalculado(avisoBancario.getValorDevolucaoCalculado());
							valorCalculado = avisoBancario.getValorDevolucaoCalculado();
						}
					}
				}

				// Diferença
				avisoBancarioHelper.setValorDiferenca(valorCalculado.subtract(valorInformado.add(valorAcertos)));

				// Situação do Aviso
				if(avisoBancarioHelper.getValorDiferenca().compareTo(BigDecimal.ZERO) == 0){

					avisoBancarioHelper.setSituacao(ConstantesSistema.FECHADO);
				}else{

					avisoBancarioHelper.setSituacao(ConstantesSistema.ABERTO);
				}

				retorno.add(avisoBancarioHelper);
			}
		}

		return retorno;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * O sistema seleciona os itens do movimento do arrecadador com os seguintes
	 * dados: 1 - Código do Registro 2 - Identificação do Imóvel/Cliente 3 -
	 * Ocorrência 4 - Indicador de Aceitação 5 - Descrição do Indicador de
	 * Aceitação
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author Raphael Rossiter
	 * @data 20/03/2006
	 * @param arrecadadorMovimento
	 * @return Collection<ArrecadadorMovimentoItemHelper>
	 */
	public Collection<ArrecadadorMovimentoItemHelper> consultarItensMovimentoArrecadador(ArrecadadorMovimento arrecadadorMovimento,
					Integer idImovel, Short indicadorAceitacao, String descricaoOcorrencia) throws ControladorException{

		Collection<ArrecadadorMovimentoItemHelper> retorno = new ArrayList();
		Collection<ArrecadadorMovimentoItem> colecaoArrecadadorMovimentoItens = null;
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = null;

		/*
		 * Seleciona os itens de um determinado movimento
		 */
		try{

			colecaoArrecadadorMovimentoItens = repositorioArrecadacao.consultarItensMovimentoArrecadador(arrecadadorMovimento, idImovel,
							indicadorAceitacao, descricaoOcorrencia);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoArrecadadorMovimentoItens != null && !colecaoArrecadadorMovimentoItens.isEmpty()){

			Iterator iteratorColecaoArrecadadorMovimentoItens = colecaoArrecadadorMovimentoItens.iterator();

			while(iteratorColecaoArrecadadorMovimentoItens.hasNext()){

				arrecadadorMovimentoItem = (ArrecadadorMovimentoItem) iteratorColecaoArrecadadorMovimentoItens.next();

				String descricaoAjuste = null;
				if(indicadorAceitacao == null || indicadorAceitacao != 1){
					try{
						Collection colecaoDescricaoAjuste = repositorioArrecadacao
										.filtrarItemMovimentoArrecadadorAjustado(arrecadadorMovimentoItem.getId());
						if(colecaoDescricaoAjuste != null && !colecaoDescricaoAjuste.isEmpty()){
							descricaoAjuste = (String) Util.retonarObjetoDeColecao(colecaoDescricaoAjuste);
						}else{
							descricaoAjuste = "";
						}
					}catch(ErroRepositorioException ex){
						ex.printStackTrace();
						throw new ControladorException("erro.sistema", ex);
					}
				}
				retorno.add(this.montarHelperArrecadadorMovimentoItem(arrecadadorMovimentoItem, descricaoAjuste));
			}
		}

		return retorno;
	}

	/**
	 * [UC0262] - Distribuir dados do Registro de Movimento do Arrecadador
	 * 
	 * @auhtor Sávio Luiz
	 * @date 30/01/2006
	 * @author Saulo Lima
	 * @date 30/12/2008
	 *       Customização pra identificar/distribuir arquivos legados
	 *       Caso a descrição de Ocorrencia venha nula então recupera o código
	 *       registro da linha senão então seta o valor de código registro para 'C'
	 */

	public Object distribuirdadosRegistroMovimentoArrecadador(String linha, String descricaoOcorrencia) throws ControladorException{

		Object registroHelperCodigo = null;

		// inicializa a variavel como 0
		char codigoRegistro = '0';
		// se a descrição da ocorrencia for diferente de null
		// então é para setar o objeto registroHelperCodigoC
		if(descricaoOcorrencia != null){
			codigoRegistro = 'C';
		}else{
			codigoRegistro = linha.substring(0, 1).toUpperCase().charAt(0);
		}

		switch(codigoRegistro){

			case 'A':
				RegistroHelperCodigoA registroHelperCodigoA = new RegistroHelperCodigoA();
				// recupera o codigo do registro
				registroHelperCodigoA.setCodigoRegistro("" + codigoRegistro);
				// recupera o codigo da remessa
				registroHelperCodigoA.setCodigoRemessa(linha.substring(1, 2).trim());
				// recupera o código do convênio
				registroHelperCodigoA.setCodigoConvenio(linha.substring(2, 22).trim());
				// recupera o nome da empresa
				registroHelperCodigoA.setNomeEmpresa(linha.substring(22, 42).trim());
				// recupera o codigo do banco
				registroHelperCodigoA.setCodigoBanco(linha.substring(42, 45).trim());
				// recupera o nome do banco
				registroHelperCodigoA.setNomeBanco(linha.substring(45, 65).trim());
				// recupera a data de geração do arquivo
				registroHelperCodigoA.setDataGeracaoArquivo(linha.substring(65, 73).trim());
				// recupera o numero sequencial do arquivo(NSA)
				registroHelperCodigoA.setNumeroSequencialArquivo(linha.substring(73, 79).trim());
				// recupera a versão do layout
				registroHelperCodigoA.setVersaoLayout(linha.substring(79, 81).trim());
				// recupera o tipo de movimento
				registroHelperCodigoA.setTipoMovimento(linha.substring(81, 98).trim());

				if(linha.substring(149, 150).trim().equals("*")){
					// recupera o reservado para o futuro
					registroHelperCodigoA.setReservadoFuturo(linha.substring(98, 149).trim());
				}else{
					// recupera o reservado para o futuro
					registroHelperCodigoA.setReservadoFuturo(linha.substring(98, 150).trim());
				}

				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigoA;
				break;

			case 'B':
				RegistroHelperCodigoB registroHelperCodigoB = new RegistroHelperCodigoB();
				// recupera o codigo do registro
				registroHelperCodigoB.setCodigoRegistro("" + codigoRegistro);
				// recupera a identificação do cliente na empresa
				registroHelperCodigoB.setIdClienteEmpresa(linha.substring(1, 26).trim());
				// recupera a agencia para debito
				registroHelperCodigoB.setAgenciaDebito(linha.substring(26, 30).trim());
				// recupera o identificação do cliente no banco
				registroHelperCodigoB.setIdClienteBanco(linha.substring(30, 44).trim());
				// recupera a data de Opção/Exclusão
				registroHelperCodigoB.setDataOpcaoExclusao(linha.substring(44, 52).trim());
				// recupera o reservado para o futuro
				registroHelperCodigoB.setReservadoFuturo(linha.substring(52, 149).trim());
				// recupera a codigo movimento
				if(!linha.substring(149, 150).trim().equals("*")){
					registroHelperCodigoB.setCodigoMovimento(linha.substring(149, 150).trim());
				}
				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigoB;
				break;

			case 'C':
				RegistroHelperCodigoC registroHelperCodigoC = new RegistroHelperCodigoC();
				// recupera o codigo do registro
				registroHelperCodigoC.setCodigoRegistro("" + codigoRegistro);
				// recupera a identificação do cliente na empresa
				registroHelperCodigoC.setIdClienteEmpresa(linha.substring(1, 26).trim());
				// recupera a agencia para debito
				registroHelperCodigoC.setAgenciaDebito(linha.substring(26, 30).trim());
				// recupera o identificação do cliente no banco
				registroHelperCodigoC.setIdClienteBanco(linha.substring(30, 44).trim());
				// recupera a descrição da ocorrencia do movimento
				registroHelperCodigoC.setDescricaoOcorrenciaMovimento(descricaoOcorrencia);
				// recupera os brancos
				registroHelperCodigoC.setBrancos(linha.substring(84, 124).trim());
				// recupera o reservado para o futuro
				registroHelperCodigoC.setReservadoFuturo(linha.substring(124, 149).trim());
				if(!linha.substring(149, 150).trim().equals("*")){
					// recupera a codigo movimento
					registroHelperCodigoC.setCodigoMovimento(linha.substring(149, 150).trim());
				}
				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigoC;
				break;

			case 'E':
				RegistroHelperCodigoE registroHelperCodigoE = new RegistroHelperCodigoE();
				// recupera o codigo do registro
				registroHelperCodigoE.setCodigoRegistro("" + codigoRegistro);
				// recupera a identificação do cliente na empresa
				registroHelperCodigoE.setIdClienteEmpresa(linha.substring(1, 26).trim());
				// recupera a agencia para debito
				registroHelperCodigoE.setAgenciaDebito(linha.substring(26, 30).trim());
				// recupera o identificação do cliente no banco
				registroHelperCodigoE.setIdClienteBanco(linha.substring(30, 44).trim());
				// recupera a data do debito
				registroHelperCodigoE.setDataDebito(linha.substring(44, 52).trim());
				// recupera o valor debitado
				registroHelperCodigoE.setValorDebito(linha.substring(52, 67).trim());
				// recupera o codigo da moeda
				registroHelperCodigoE.setCodigoMoeda(linha.substring(67, 69).trim());
				// recupera o código de movimento
				registroHelperCodigoE.setAnoMesReferenciaConta(linha.substring(69, 75).trim());
				// recupera o digito verificado no modulo dez(10) do ano e mes da contadebitada
				registroHelperCodigoE.setDigitoVerificadoAnoMesConta(linha.substring(75, 76).trim());
				// grupo de faturamento
				registroHelperCodigoE.setGruposFaturamento(linha.substring(76, 129).trim());
				// recupera o reservado para o futuro
				registroHelperCodigoE.setReservadoFuturo(linha.substring(129, 149).trim());
				if(!linha.substring(149, 150).trim().equals("*")){
					// recupera o codigo do movimento enviado no registro de código E
					registroHelperCodigoE.setCodigoMovimento(linha.substring(149, 150).trim());
				}
				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigoE;
				break;

			case 'F':
				// [SB0005] – Distribuir Registro Código F
				registroHelperCodigo = this.distribuirDadosRegistroCodigoF(codigoRegistro, linha);
				break;

			case 'G':
				RegistroHelperCodigoG registroHelperCodigoG = new RegistroHelperCodigoG();
				// recupera o codigo do registro
				registroHelperCodigoG.setCodigoRegistro("" + codigoRegistro);
				// recupera a identificação da agencia /conta/digito creditada
				registroHelperCodigoG.setIdAgenciaContaDigito(linha.substring(1, 21).trim());
				// recupera a data de pagamento(AAAAMMDD)
				registroHelperCodigoG.setDataPagamento(linha.substring(21, 29).trim());
				// recupera a data prevista para o credito(AAAAMMDD)
				registroHelperCodigoG.setDataPrevistaCredito(linha.substring(29, 37).trim());
				// recupera O CÓDIGO DE BARRAS
				String codigoBarras = linha.substring(37, 81).trim();
				RegistroHelperCodigoBarras registroHelperCodigoBarras = this.distribuirDadosCodigoBarras(codigoBarras);
				// seta também o código de barra como string
				registroHelperCodigoG.setCodigoBarras(codigoBarras);
				registroHelperCodigoG.setRegistroHelperCodigoBarras(registroHelperCodigoBarras);
				// recupera o valor recebido
				registroHelperCodigoG.setValorRecebido(linha.substring(81, 93).trim());
				// recupera o valor da tarifa
				registroHelperCodigoG.setValorTarifa(linha.substring(93, 100).trim());
				// recupera o numero sequencial do registro(NRS)
				registroHelperCodigoG.setNumeroSeqRegistro(linha.substring(100, 108).trim());
				// recupera o codigo da agencia arrecadadora
				registroHelperCodigoG.setCodigoAgenciaArrecadadora(linha.substring(108, 116).trim());
				// recupera a foma de arrecadação/captura
				String codigoArrecadacaoForma = linha.substring(116, 117).trim();
				registroHelperCodigoG.setCodigoFormaArrecadacao(codigoArrecadacaoForma);

				String descricaoArrecadacaoForma = "";
				try{
					descricaoArrecadacaoForma = this.repositorioArrecadacao.recuperaDescricaoArrecadacaoForma(codigoArrecadacaoForma);
				}catch(ErroRepositorioException e){
					e.printStackTrace();
				}

				registroHelperCodigoG.setFormaArrecadacao(descricaoArrecadacaoForma);
				// recupera o numero de autenticação caixa ou código de transação
				registroHelperCodigoG.setNumeroAutenticacao(linha.substring(117, 140).trim());

				if(!linha.substring(140, 141).trim().equals("")){
					// recupera a forma de pagamento
					registroHelperCodigoG.setFormaPagamento(linha.substring(140, 141).trim());
				}else{
					// recupera a forma de pagamento
					registroHelperCodigoG.setFormaPagamento("1");
				}

				if(linha.substring(149, 150).trim().equals("*")){
					// recupera o reservado para o futuro
					registroHelperCodigoG.setReservadoFuturo(linha.substring(141, 149).trim());
				}else{
					// recupera o reservado para o futuro
					registroHelperCodigoG.setReservadoFuturo(linha.substring(141, 150).trim());
				}

				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigoG;
				break;

			case 'X':
				RegistroHelperCodigoX registroHelperCodigoX = new RegistroHelperCodigoX();
				// recupera o codigo do registro
				registroHelperCodigoX.setCodigoRegistro("" + codigoRegistro);
				// recupera o código agencia
				registroHelperCodigoX.setCodigoAgencia(linha.substring(1, 5));
				// recupera o nome da agencia
				registroHelperCodigoX.setNomeAgencia(linha.substring(5, 35));
				// recupera o nome do logradouro
				registroHelperCodigoX.setNomelogradouro(linha.substring(35, 65));
				// recupera o numero
				registroHelperCodigoX.setNumero(linha.substring(65, 70));
				// recupera o código do cep
				registroHelperCodigoX.setCodigoCep(linha.substring(70, 75));
				// recupera o sufixo do cep
				registroHelperCodigoX.setSufixoCep(linha.substring(75, 78));
				// recupera o nome da cidade
				registroHelperCodigoX.setNomeCidade(linha.substring(78, 98));
				// recupera a sigla da unidade federação
				registroHelperCodigoX.setSiglaUnidadeFederacao(linha.substring(98, 100));
				// recupera a situação da agencia
				registroHelperCodigoX.setSituacaoAgencia(linha.substring(100, 101));
				if(linha.substring(149, 150).trim().equals("*")){
					// recupera o reservado para o futuro
					registroHelperCodigoX.setReservadoFuturo(linha.substring(101, 149));
				}else{
					// recupera o reservado para o futuro
					registroHelperCodigoX.setReservadoFuturo(linha.substring(101, 150));
				}
				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigoX;
				break;

			case 'Z':
				RegistroHelperCodigoZ registroHelperCodigoZ = new RegistroHelperCodigoZ();
				// recupera o codigo do registro
				registroHelperCodigoZ.setCodigoRegistro("" + codigoRegistro);
				// recupera o total de registros do arquivo
				registroHelperCodigoZ.setTotalRegistrosArquivo(linha.substring(1, 7));
				// recupera o valor total recebido dos registrosdo arquivo
				registroHelperCodigoZ.setValorTotalRegistrosArquivo(linha.substring(7, 24));
				if(linha.substring(149, 150).trim().equals("*")){
					// recupera o reservado para o futuro
					registroHelperCodigoZ.setReservadoFuturo(linha.substring(24, 149));
				}else{
					// recupera o reservado para o futuro
					registroHelperCodigoZ.setReservadoFuturo(linha.substring(24, 150));
				}
				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigoZ;
				break;

		}
		return registroHelperCodigo;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * O sistema captura os dados referentes ao conteúdo do registro de
	 * Movimento do arrecadador
	 * [SF0002] Apresentar Dados do Conteúdo do Registro de Movimento do
	 * Arrecadador
	 * 
	 * @author Raphael Rossiter
	 * @data 21/03/2006
	 * @param arrecadadorMovimentoItem
	 * @return DadosConteudoRegistroMovimentoArrecadador
	 */
	public DadosConteudoRegistroMovimentoArrecadadorHelper apresentarDadosConteudoRegistroMovimentoArrecadador(
					ArrecadadorMovimentoItem arrecadadorMovimentoItem) throws ControladorException{

		DadosConteudoRegistroMovimentoArrecadadorHelper retorno = new DadosConteudoRegistroMovimentoArrecadadorHelper();

		FiltroArrecadadorMovimentoItem filtroArrecadadorMovimentoItem = new FiltroArrecadadorMovimentoItem();

		filtroArrecadadorMovimentoItem.adicionarCaminhoParaCarregamentoEntidade("registroCodigo");

		filtroArrecadadorMovimentoItem.adicionarCaminhoParaCarregamentoEntidade("arrecadadorMovimento");

		filtroArrecadadorMovimentoItem.adicionarParametro(new ParametroSimples(FiltroArrecadadorMovimentoItem.ID, arrecadadorMovimentoItem
						.getId()));

		Collection colecaoArrecadadorMovimentoItem = getControladorUtil().pesquisar(filtroArrecadadorMovimentoItem,
						ArrecadadorMovimentoItem.class.getName());

		ArrecadadorMovimentoItem arrecadadorMovimentoItemCompleto = (ArrecadadorMovimentoItem) Util
						.retonarObjetoDeColecao(colecaoArrecadadorMovimentoItem);

		/*
		 * Caso o código do registro corresponda a: "B" ou "C", apresentar os
		 * seguintes campos:
		 * Código do registro Identificação do cliente na empresa Agência para
		 * débito Identificação do cliente no banco Data de opção/exclusão
		 * Código do movimento (1 - EXCLUSÃO, 2 - INCLUSÃO) Ocorrência Indicador
		 * de Aceitação
		 */
		if(arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
						&& arrecadadorMovimentoItemCompleto.getRegistroCodigo().getCodigo().equals(RegistroCodigo.CODIGO_B)){

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoB registroHelperCodigoB = (RegistroHelperCodigoB) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto.getConteudoRegistro(), null);

			retorno.setCodigoRegistro(registroHelperCodigoB.getCodigoRegistro());
			retorno.setIdentificacaoClienteEmpresa(registroHelperCodigoB.getIdClienteEmpresa());
			retorno.setAgenciaDebito(registroHelperCodigoB.getAgenciaDebito());
			retorno.setIdentificacaoClienteBanco(registroHelperCodigoB.getIdClienteBanco());
			retorno.setDataOpcaoExclusao(Util.formatarData(registroHelperCodigoB.getDataOpcaoExclusao()));

			if(registroHelperCodigoB.getCodigoMovimento().equals(ConstantesSistema.CODIGO_MOVIMENTO_EXCLUSAO.toString())){

				retorno.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_EXCLUSAO);
			}else{
				retorno.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_INCLUSAO);
			}

			if(arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia() != null){
				retorno.setOcorrencia(arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia());
			}

			if(arrecadadorMovimentoItemCompleto.getIndicadorAceitacao() != null
							&& arrecadadorMovimentoItemCompleto.getIndicadorAceitacao().equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)){

				retorno.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
			}else{
				retorno.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
			}

		}else if(arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
						&& arrecadadorMovimentoItemCompleto.getRegistroCodigo().getCodigo().equals(RegistroCodigo.CODIGO_C)){

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto.getConteudoRegistro(), null);

			retorno.setCodigoRegistro(registroHelperCodigoC.getCodigoRegistro());
			retorno.setIdentificacaoClienteEmpresa(registroHelperCodigoC.getIdClienteEmpresa());
			retorno.setAgenciaDebito(registroHelperCodigoC.getAgenciaDebito());
			retorno.setIdentificacaoClienteBanco(registroHelperCodigoC.getIdClienteBanco());

			if(registroHelperCodigoC.getCodigoMovimento().equals(ConstantesSistema.CODIGO_MOVIMENTO_EXCLUSAO.toString())){

				retorno.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_EXCLUSAO);
			}else{
				retorno.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_INCLUSAO);
			}

			if(arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia() != null){
				retorno.setOcorrencia(arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia());
			}

			retorno.setIndicadorAceitacao("");

			// Comentado a pedido de Rosana em 08/04/2006
			/*
			 * if (arrecadadorMovimentoItemCompleto.getIndicadorAceitacao() !=
			 * null && arrecadadorMovimentoItemCompleto.getIndicadorAceitacao()
			 * .equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)) {
			 * retorno
			 * .setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO); }
			 * else { retorno
			 * .setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO); }
			 */
		}
		/*
		 * Caso o código do registro corresponda a: "E" ou "F", apresentar os
		 * seguintes campos:
		 * Código do registro Identificação do cliente na empresa Agência para
		 * débito Identificação do cliente no banco Data do vencimento/débito
		 * Valor do débito Código da moeda ou código do retorno Mês e ano de
		 * rferencia da conta Dígito verificador da conta Código do movimento (0 -
		 * DÉBITO NORMAL, 1 - CANCELAMENTO) Ocorrência Indicador de Aceitação
		 */
		else if(arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
						&& arrecadadorMovimentoItemCompleto.getRegistroCodigo().getCodigo().equals(RegistroCodigo.CODIGO_E)){

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoE registroHelperCodigoE = (RegistroHelperCodigoE) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto.getConteudoRegistro(), null);

			retorno.setCodigoRegistro(registroHelperCodigoE.getCodigoRegistro());
			retorno.setIdentificacaoClienteEmpresa(registroHelperCodigoE.getIdClienteEmpresa());
			retorno.setAgenciaDebito(registroHelperCodigoE.getAgenciaDebito());
			retorno.setIdentificacaoClienteBanco(registroHelperCodigoE.getIdClienteBanco());

			retorno.setDataVencimentoDebito(Util.formatarData(registroHelperCodigoE.getDataDebito()));

			try{
				retorno.setValorDebito(Util.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoE.getValorDebito())));
			}catch(NumberFormatException ex){
				retorno.setValorDebito(registroHelperCodigoE.getValorDebito());
			}

			retorno.setCodigoMoeda(registroHelperCodigoE.getCodigoMoeda());
			retorno.setMesAnoReferenciaConta(Util.formatarAnoMesParaMesAno(Integer
							.valueOf(registroHelperCodigoE.getAnoMesReferenciaConta()).intValue()));
			retorno.setDigitoVerificadorConta(registroHelperCodigoE.getDigitoVerificadoAnoMesConta());

			if(registroHelperCodigoE.getCodigoMovimento().equals(ConstantesSistema.CODIGO_MOVIMENTO_DEBITO_NORMAL.toString())){

				retorno.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_DEBITO_NORMAL);
			}else{
				retorno.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_CANCELAMENTO);
			}

			if(arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia() != null){
				retorno.setOcorrencia(arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia());
			}

			if(arrecadadorMovimentoItemCompleto.getIndicadorAceitacao() != null
							&& arrecadadorMovimentoItemCompleto.getIndicadorAceitacao().equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)){

				retorno.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
			}else{
				retorno.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
			}

			FiltroDebitoAutomaticoMovimento filtroDebitoAutomaticoMovimento = new FiltroDebitoAutomaticoMovimento();

			filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoMovimento.BANCO,
							arrecadadorMovimentoItemCompleto.getArrecadadorMovimento().getCodigoBanco()));
			filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoMovimento.NUMERO_SEQ_ARQ_ENVIADO,
							arrecadadorMovimentoItemCompleto.getArrecadadorMovimento().getNumeroSequencialArquivo()));

			DebitoAutomaticoMovimento debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) Util
							.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroDebitoAutomaticoMovimento,
											DebitoAutomaticoMovimento.class.getName()));
			if(debitoAutomaticoMovimento != null){
				retorno.setDataEnvio(Util.formatarData(debitoAutomaticoMovimento.getEnvioBanco()));
			}

			filtroDebitoAutomaticoMovimento.limparListaParametros();

			filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoMovimento.BANCO,
							arrecadadorMovimentoItemCompleto.getArrecadadorMovimento().getCodigoBanco()));
			filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoMovimento.NUMERO_SEQ_ARQ_RETORNO,
							arrecadadorMovimentoItemCompleto.getArrecadadorMovimento().getNumeroSequencialArquivo()));

			debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(
							filtroDebitoAutomaticoMovimento, DebitoAutomaticoMovimento.class.getName()));

			if(debitoAutomaticoMovimento != null){
				retorno.setDataRetorno(Util.formatarData(debitoAutomaticoMovimento.getRetornoBanco()));
			}

		}else if(arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
						&& arrecadadorMovimentoItemCompleto.getRegistroCodigo().getCodigo().equals(RegistroCodigo.CODIGO_F)){

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoF registroHelperCodigoF = (RegistroHelperCodigoF) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto.getConteudoRegistro(), null);

			retorno.setCodigoRegistro(registroHelperCodigoF.getCodigoRegistro());
			retorno.setIdentificacaoClienteEmpresa(registroHelperCodigoF.getIdClienteEmpresa());
			retorno.setAgenciaDebito(registroHelperCodigoF.getAgenciaDebito());
			retorno.setIdentificacaoClienteBanco(registroHelperCodigoF.getIdClienteBanco());
			retorno.setDataVencimentoDebito(Util.formatarData(registroHelperCodigoF.getDataDebito()));

			try{
				retorno.setValorDebito(Util.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoF.getValorDebito())));
			}catch(NumberFormatException ex){
				retorno.setValorDebito(registroHelperCodigoF.getValorDebito());
			}

			if(registroHelperCodigoF.getAnoMesReferenciaConta() == null || registroHelperCodigoF.getAnoMesReferenciaConta().equals("")){
				retorno.setMesAnoReferenciaConta("--/----");
			}else{
				retorno.setMesAnoReferenciaConta(Util.formatarAnoMesParaMesAno(Integer.valueOf(
								registroHelperCodigoF.getAnoMesReferenciaConta()).intValue()));
			}
			retorno.setDigitoVerificadorConta(registroHelperCodigoF.getDigitoVerificadoAnoMesConta());

			if(registroHelperCodigoF.getCodigoMovimento() != null
							&& registroHelperCodigoF.getCodigoMovimento().equals(
											ConstantesSistema.CODIGO_MOVIMENTO_DEBITO_NORMAL.toString())){

				retorno.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_DEBITO_NORMAL);

			}else{
				retorno.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_CANCELAMENTO);
			}

			if(arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia() != null){
				retorno.setOcorrencia(arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia());
			}

			if(arrecadadorMovimentoItemCompleto.getIndicadorAceitacao() != null
							&& arrecadadorMovimentoItemCompleto.getIndicadorAceitacao().equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)){

				retorno.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
			}else{
				retorno.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
			}

			FiltroDebitoAutomaticoMovimento filtroDebitoAutomaticoMovimento = new FiltroDebitoAutomaticoMovimento();

			filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoMovimento.BANCO,
							arrecadadorMovimentoItemCompleto.getArrecadadorMovimento().getCodigoBanco()));
			filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoMovimento.NUMERO_SEQ_ARQ_ENVIADO,
							arrecadadorMovimentoItemCompleto.getArrecadadorMovimento().getNumeroSequencialArquivo()));

			DebitoAutomaticoMovimento debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) Util
							.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroDebitoAutomaticoMovimento,
											DebitoAutomaticoMovimento.class.getName()));
			if(debitoAutomaticoMovimento != null){
				retorno.setDataEnvio(Util.formatarData(debitoAutomaticoMovimento.getEnvioBanco()));
			}

			filtroDebitoAutomaticoMovimento.limparListaParametros();

			filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoMovimento.BANCO,
							arrecadadorMovimentoItemCompleto.getArrecadadorMovimento().getCodigoBanco()));
			filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoMovimento.NUMERO_SEQ_ARQ_RETORNO,
							arrecadadorMovimentoItemCompleto.getArrecadadorMovimento().getNumeroSequencialArquivo()));

			debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(
							filtroDebitoAutomaticoMovimento, DebitoAutomaticoMovimento.class.getName()));

			if(debitoAutomaticoMovimento != null){
				retorno.setDataRetorno(Util.formatarData(debitoAutomaticoMovimento.getRetornoBanco()));
			}

			/*
			 * Caso o código do registro corresponda a "F" apresentar a
			 * descrição do código de retorno
			 * (DURC_DSDEBITOAUTOMATICORETORNOCODIGO da tabela
			 * DEBITO_AUTOMATICO_RETORNO_COD com DURC_ID = código de retorno)
			 */
			FiltroDebitoAutomaticoRetornoCodigo filtroDebitoAutomaticoRetornoCodigo = new FiltroDebitoAutomaticoRetornoCodigo();

			filtroDebitoAutomaticoRetornoCodigo.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoRetornoCodigo.ID, Integer
							.valueOf(registroHelperCodigoF.getCodigoRetorno())));

			Collection colecaoDebitoAutomaticoRetornoCodigo = getControladorUtil().pesquisar(filtroDebitoAutomaticoRetornoCodigo,
							DebitoAutomaticoRetornoCodigo.class.getName());

			DebitoAutomaticoRetornoCodigo debitoAutomaticoRetornoCodigo = (DebitoAutomaticoRetornoCodigo) Util
							.retonarObjetoDeColecao(colecaoDebitoAutomaticoRetornoCodigo);

			if(debitoAutomaticoRetornoCodigo != null){
				retorno.setCodigoRetorno(debitoAutomaticoRetornoCodigo.getDescricaoDebitoAutomaticoRetornoCodigo());
			}

			/*
			 * Lista de pagamentos relacionados ao ítem do movimento
			 */
			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.setConsultaSemLimites(true);

			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.DOCUMENTO_TIPO);

			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.DEBITO_TIPO);

			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.PAGAMENTO_SITUACAO_ATUAL);

			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ARRECADADOR_MOVIMENTO_ITEM_ID,
							arrecadadorMovimentoItemCompleto.getId()));

			Collection colecaoPagamentos = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

			retorno.setPossuiPagamentos("true");

			if(Util.isVazioOrNulo(colecaoPagamentos)){

				FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
				filtroPagamentoHistorico.setConsultaSemLimites(true);

				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.DOCUMENTO_TIPO);

				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.DEBITO_TIPO);

				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.PAGAMENTO_SITUACAO_ATUAL);

				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.ARRECADADOR_MOVIMENTO_ITEM_ID,
								arrecadadorMovimentoItemCompleto.getId()));

				Collection colecaoPagamentoHistorico = getControladorUtil().pesquisar(filtroPagamentoHistorico,
								PagamentoHistorico.class.getName());

				retorno.setColecaoPagamentoHistorico(colecaoPagamentoHistorico);

				if(Util.isVazioOrNulo(colecaoPagamentoHistorico)){

					retorno.setPossuiPagamentos(null);
				}
			}else{

				retorno.setColecaoPagamentos(colecaoPagamentos);
			}
		}
		/*
		 * Caso o código do registro corresponda a: "G", apresentar os seguintes
		 * campos:
		 * Código do registro Identificação da agência/conta/dígito creditada
		 * Data pagamento Data prevista para o crédito Código de Barras [SB003 -
		 * Apresentar Dados do Conteúdo do Código de Barras] com os dados
		 * retornados pelo [UC0264] Valor recebido Valor da tarifa NSR - Número
		 * sequencial de registro Código da agência arrecadadora Forma de
		 * arrecadação/captura Número de autenticação caixa ou código de
		 * transação Forma de pagamento
		 */
		else if(arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
						&& arrecadadorMovimentoItemCompleto.getRegistroCodigo().getCodigo().equals(RegistroCodigo.CODIGO_G)){

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto.getConteudoRegistro(), null);

			retorno.setCodigoRegistro(registroHelperCodigoG.getCodigoRegistro());
			retorno.setIdentificacaoAgenciaContaDigitoCreditada(registroHelperCodigoG.getIdAgenciaContaDigito());
			retorno.setDataPagamento(Util.formatarData(registroHelperCodigoG.getDataPagamento()));
			retorno.setDataPrevistaCredito(Util.formatarData(registroHelperCodigoG.getDataPrevistaCredito()));

			// [SB0003] - Apresentar Dados do Conteúdo do Código de Barras
			DadosConteudoCodigoBarrasHelper dadosConteudoCodigoBarrasHelper = this.apresentarDadosConteudoCodigoBarras(
							registroHelperCodigoG, arrecadadorMovimentoItemCompleto.getConteudoRegistro());

			retorno.setDadosConteudoCodigoBarrasHelper(dadosConteudoCodigoBarrasHelper);

			try{
				retorno.setValorRecebido(Util.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoG.getValorRecebido())));
			}catch(NumberFormatException ex){
				retorno.setValorRecebido(registroHelperCodigoG.getValorRecebido());
			}

			try{
				retorno.setValorTarifa(Util.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoG.getValorTarifa())));
			}catch(NumberFormatException ex){
				retorno.setValorTarifa(registroHelperCodigoG.getValorTarifa());
			}

			retorno.setNsr(registroHelperCodigoG.getNumeroSeqRegistro());
			retorno.setCodigoAgenciaArrecadadora(registroHelperCodigoG.getCodigoAgenciaArrecadadora());
			retorno.setFormaArrecadacaoCaptura(registroHelperCodigoG.getFormaArrecadacao());
			retorno.setNumeroAutenticacaoCaixaOUCodigoTransacao(registroHelperCodigoG.getNumeroAutenticacao());
			retorno.setFormaPagamento(registroHelperCodigoG.getFormaPagamento());

			/*
			 * Lista de pagamentos relacionados ao ítem do movimento
			 */
			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.setConsultaSemLimites(true);

			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("documentoTipo");
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAtual");

			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ARRECADADOR_MOVIMENTO_ITEM_ID,
							arrecadadorMovimentoItemCompleto.getId()));

			Collection colecaoPagamentos = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

			retorno.setPossuiPagamentos("true");

			if(Util.isVazioOrNulo(colecaoPagamentos)){

				FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
				filtroPagamentoHistorico.setConsultaSemLimites(true);

				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.DOCUMENTO_TIPO);

				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.DEBITO_TIPO);

				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.PAGAMENTO_SITUACAO_ATUAL);

				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.ARRECADADOR_MOVIMENTO_ITEM_ID,
								arrecadadorMovimentoItemCompleto.getId()));

				Collection colecaoPagamentoHistorico = getControladorUtil().pesquisar(filtroPagamentoHistorico,
								PagamentoHistorico.class.getName());

				retorno.setColecaoPagamentoHistorico(colecaoPagamentoHistorico);

				if(Util.isVazioOrNulo(colecaoPagamentoHistorico)){

					retorno.setPossuiPagamentos(null);
				}

			}else{

				retorno.setColecaoPagamentos(colecaoPagamentos);
			}
		}
		/*
		 * Caso o código do registro corresponda a: "X", apresentar os seguintes
		 * campos:
		 * Código do registro Código da agência Nome da agência Nome do
		 * logradouro Número Código do CEP Sufixo do CEP Nome da cidade Sigla da
		 * unidade da federação Situação da agência ("A" = Ativa, "B" = em
		 * regime de encerramento)
		 */
		else if(arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
						&& arrecadadorMovimentoItemCompleto.getRegistroCodigo().getCodigo().equals(RegistroCodigo.CODIGO_X)){

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoX registroHelperCodigoX = (RegistroHelperCodigoX) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto.getConteudoRegistro(), null);

			retorno.setCodigoRegistro(registroHelperCodigoX.getCodigoRegistro());
			retorno.setCodigoAgencia(registroHelperCodigoX.getCodigoAgencia());
			retorno.setNomeAgencia(registroHelperCodigoX.getNomeAgencia());
			retorno.setNomeLogradouro(registroHelperCodigoX.getNomelogradouro());
			retorno.setNumero(registroHelperCodigoX.getNumero());
			retorno.setCodigoCep(registroHelperCodigoX.getCodigoCep());
			retorno.setSufixoCep(registroHelperCodigoX.getSufixoCep());
			retorno.setNomeCidade(registroHelperCodigoX.getNomeCidade());
			retorno.setSiglaUnidadeFederacao(registroHelperCodigoX.getSiglaUnidadeFederacao());

			if(registroHelperCodigoX.getSituacaoAgencia().equals(ConstantesSistema.CODIGO_SITUACAO_AGENCIA_ATIVO)){

				retorno.setSituacaoAgencia(ConstantesSistema.DESCRICAO_SITUACAO_AGENCIA_ATIVO);
			}else{

				retorno.setSituacaoAgencia(ConstantesSistema.DESCRICAO_SITUACAO_AGENCIA_EM_REGIME_ENCERRAMENTO);
			}
		}
		/*
		 * 1.5. "3", correspondente aos segmentos "T" e "U" (T.05 com o valor "T"), apresentar os
		 * seguintes campos:
		 */
		else if(arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
						&& arrecadadorMovimentoItemCompleto.getRegistroCodigo().getCodigo().equals(RegistroCodigo.CODIGO_3)){
			try{
				String codSegmento = arrecadadorMovimentoItemCompleto.getConteudoRegistro().substring(13, 14).trim();
				if(codSegmento.equals("T")){

					// [UC0262] - Distribuir Dados do Registro de Movimento do Arrecadador
					RegistroHelperCodigo3T registroHelperCodigo3T = (RegistroHelperCodigo3T) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
									arrecadadorMovimentoItemCompleto.getConteudoRegistro().substring(0, 240), null);
					RegistroHelperCodigo3U registroHelperCodigo3U = (RegistroHelperCodigo3U) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
									arrecadadorMovimentoItemCompleto.getConteudoRegistro().substring(240, 480), null);
					retorno.setCodigoRegistro(registroHelperCodigo3U.getCodigoRegistro());

					retorno.setCodigoMovimentoRetorno(repositorioArrecadacao.pesquisarBoletoBancarioLancamentoRetorno(
									Util.obterInteger(registroHelperCodigo3U.getCodigoMovimento())).getDescricaoLancamentoRetorno());
					BoletoBancarioMovimentacao boletoBancarioMovimentacao = repositorioArrecadacao
									.pesquisarBoletoBancarioMovimentacao(arrecadadorMovimentoItemCompleto.getId());
					if(boletoBancarioMovimentacao != null){
						List<BoletoBancarioMotivoOcorrencia> ocorrencias = repositorioArrecadacao
										.pesquisarBoletoBancarioMotivoOcorrencia(arrecadadorMovimentoItemCompleto.getId());
						if(!Util.isVazioOrNulo(ocorrencias)){
							ArrayList<String> ocorrenciasString = new ArrayList<String>();
							for(BoletoBancarioMotivoOcorrencia boletoBancarioMotivoOcorrencia : ocorrencias){
								ocorrenciasString.add(boletoBancarioMotivoOcorrencia.getCodigoMotivoOcorrencia().toString() + " - "
												+ boletoBancarioMotivoOcorrencia.getDescricaoMotivoOcorrencia());
							}
							retorno.setOcorrencias(ocorrenciasString);
						}
					}else{
						// [SB0004] - Apresentar Dados do Conteúdo do Código de Barras
						DadosConteudoCodigoBarrasHelper dadosConteudoCodigoBarrasHelper = apresentarDadosConteudoCodigoBarrasFichaCompensacao(
										registroHelperCodigo3T, registroHelperCodigo3U);

						retorno.setDadosConteudoCodigoBarrasHelper(dadosConteudoCodigoBarrasHelper);
					}
					retorno.setIdentificacaoAgenciaContaDigitoCreditada(registroHelperCodigo3T.getAgenciaMantedoraConta() + ""
									+ registroHelperCodigo3T.getDigitoVerificadorAgencia() + ""
									+ registroHelperCodigo3T.getNumeroContaCorrente() + ""
									+ registroHelperCodigo3T.getDigitoVerificadorConta() + ""
									+ registroHelperCodigo3T.getDigitoVerificadorAgConta());
					retorno.setDataPagamento(Util.formatarDataDDMMYYYY(registroHelperCodigo3U.getDataOcorrencia()));
					retorno.setDataPrevistaCredito(Util.formatarDataDDMMYYYY(registroHelperCodigo3U.getDataEfetivacaoCredito()));
					retorno.setValorRecebido(Util.formatarMoedaReal(Util
									.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3U.getValorPagoSacado())));
					retorno.setNsr(registroHelperCodigo3U.getNumeroSequencialRegLote());
					retorno.setFormaArrecadacaoCaptura(arrecadadorMovimentoItemCompleto.getArrecadadorMovimento()
									.getDescricaoIdentificacaoServico());

				}else if(codSegmento.equals("P")){
					RegistroHelperCodigo3P registroHelperCodigo3P = (RegistroHelperCodigo3P) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
									arrecadadorMovimentoItem.getConteudoRegistro().substring(0, 240), null);
					RegistroHelperCodigo3Q registroHelperCodigo3Q = (RegistroHelperCodigo3Q) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
									arrecadadorMovimentoItem.getConteudoRegistro().substring(240, 420), null);
					RegistroHelperCodigo3R registroHelperCodigo3R = (RegistroHelperCodigo3R) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
									arrecadadorMovimentoItem.getConteudoRegistro().substring(420, 660), null);

					retorno.setCodigoRegistro(registroHelperCodigo3P.getCodigoRegistro());
					Integer[] lista = new Integer[3];
					if(registroHelperCodigo3P.getCodigoMovimento() != null){
						lista[0] = Util.obterInteger(registroHelperCodigo3P.getCodigoMovimento());
					}
					if(registroHelperCodigo3Q.getCodigoMovimento() != null){
						lista[1] = Util.obterInteger(registroHelperCodigo3Q.getCodigoMovimento());
					}
					if(registroHelperCodigo3R.getCodigoMovimento() != null){
						lista[2] = Util.obterInteger(registroHelperCodigo3R.getCodigoMovimento());
					}
					retorno.setCodigoMovimentoRemessa(repositorioArrecadacao.pesquisarBoletoBancarioLancamentoEnvio(lista)
									.getDescricaoLancamentoEnvio());
					retorno.setIdentificacaoAgenciaContaDigitoCreditada(registroHelperCodigo3P.getAgenciaMantedoraConta() + ""
									+ registroHelperCodigo3P.getDigitoVerificadorAgenciaMantenedoraConta() + ""
									+ registroHelperCodigo3P.getNumeroContaCorrente() + ""
									+ registroHelperCodigo3P.getDigitoVerificadorConta() + ""
									+ registroHelperCodigo3P.getDigitoVerificadorAgenciaConta());
					retorno.setDataVencimentoDebito(Util.formatarDataDDMMYYYY(registroHelperCodigo3P.getDataVencimentoTitulo()));
					retorno.setValorNominalTitulo(Util.formatarMoedaReal(Util
									.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3P
													.getValorNominalTitulo())));

					retorno.setDataDesconto1(Util.formatarDataDDMMYYYY(registroHelperCodigo3P.getDataDesconto1()));

					retorno.setValorPercentualDesconto1(Util.formatarMoedaReal(Util
									.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3P
													.getValorPercentualConcedidoDesconto1())));

					retorno.setNomeSacado(registroHelperCodigo3Q.getNome());

					retorno.setEnderecoSacado(registroHelperCodigo3Q.getEndereco());

					retorno.setBairro(registroHelperCodigo3Q.getBairro());

					retorno.setCEP(registroHelperCodigo3Q.getCep());

					retorno.setDataDesconto2(Util.formatarDataDDMMYYYY(registroHelperCodigo3R.getDataDesconto2()));

					retorno.setValorPercentualDesconto2(Util.formatarMoedaReal(Util
									.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3R
													.getValorPercentualConcedidoDesconto2())));

					retorno.setDataDesconto3(Util.formatarDataDDMMYYYY(registroHelperCodigo3R.getDataDesconto3()));

					retorno.setValorPercentualDesconto3(Util.formatarMoedaReal(Util
									.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3R
													.getValorPercentualConcedidoDesconto3())));
				}
			}catch(ErroRepositorioException e){
				e.printStackTrace();
			}

		}

		return retorno;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * O sistema captura os dados referentes ao conteúdo do do código de barras
	 * [SF0003] Apresentar Dados do Conteúdo do Código de Barras
	 * 
	 * @author Raphael Rossiter
	 * @data 22/03/2006
	 * @author eduardo henrique
	 * @date 17/12/2008
	 *       Alteração no método para adequação da montagem dos dados da conta e Guia de Pagamento
	 *       com a alteração do UC0264.
	 * @param registroHelperCodigoG
	 * @return DadosConteudoCodigoBarrasHelper
	 */
	public DadosConteudoCodigoBarrasHelper apresentarDadosConteudoCodigoBarras(RegistroHelperCodigoG registroHelperCodigoG, String linha)
					throws ControladorException{

		DadosConteudoCodigoBarrasHelper retorno = new DadosConteudoCodigoBarrasHelper();

		retorno.setIdentificacaoProduto(registroHelperCodigoG.getRegistroHelperCodigoBarras().getIdProduto());
		retorno.setIdentificacaoSegmento(registroHelperCodigoG.getRegistroHelperCodigoBarras().getIdSegmento());
		retorno.setIdentificacaoValorRealOUReferencia(registroHelperCodigoG.getRegistroHelperCodigoBarras().getIdValorReal());
		retorno.setDigitoVerificadorGeral(registroHelperCodigoG.getRegistroHelperCodigoBarras().getDigitoVerificadorGeral());
		retorno.setValorPagamento(Util.formatarMoedaReal(Util
						.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoG.getRegistroHelperCodigoBarras()
										.getValorPagamento())));

		String tipoPagamento = registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento();

		if(tipoPagamento != null && tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA_LEGADO_CAERN.toString())){

			retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);

			// Verifica se existe a matricula do imóvel na base
			Integer matriculaImovel = Integer.valueOf(registroHelperCodigoG.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1());

			// Calcular Digito Verificador da Matricula
			if(matriculaImovel != null){
				Short empresa = Short.parseShort(ConstantesAplicacao.get("empresa.ada_codigo_empresa"));
				int digitoModulo11 = Util.obterDigitoVerificadorModulo("" + matriculaImovel, empresa);

				matriculaImovel = Integer.valueOf(matriculaImovel.toString() + digitoModulo11);

				retorno.setMatriculaImovel(matriculaImovel.toString());

				Collection colecaoClienteImovel = this.getControladorImovel().pesquisarImovel(matriculaImovel.toString(), null, null, null,
								null, null, null, null, null, null, null, null, false, false, 0);

				ClienteImovel clienteImovel = (ClienteImovel) Util.retonarObjetoDeColecao(colecaoClienteImovel);

				if(clienteImovel != null && clienteImovel.getImovel() != null && !clienteImovel.getImovel().equals("")){

					retorno.setCodigoLocalidade(clienteImovel.getImovel().getLocalidade().getId().toString());
				}

			}

			int anoMesReferenciaConta = this.obterMesAnoReferencia(Integer.parseInt(registroHelperCodigoG.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2()));

			retorno.setMesAnoReferenciaConta(Util.formatarAnoMesParaMesAno(anoMesReferenciaConta));

			retorno.setDigitoVerificadorContaModulo10(Long.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento5()).toString());

		}else if(tipoPagamento != null && tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA.toString())){

			retorno.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_CONTA);

			retorno.setMatriculaImovel(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento1()).toString());

			retorno.setMesAnoReferenciaConta(Util.formatarMesAnoSemBarraParaMesAnoComBarra(registroHelperCodigoG
							.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2()));

		}else if(tipoPagamento != null && tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_IMOVEL.toString())){

			retorno.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_GUIA_PAGAMENTO);

			retorno.setMatriculaImovel(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento1()).toString());

			retorno.setNumeroGuiaPagamento(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento2()).toString());

			retorno.setNumeroPrestacaoGuiaPagamento(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento3()).toString());
		}else if(tipoPagamento != null && tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_CLIENTE.toString())){

			retorno.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_GUIA_PAGAMENTO);

			retorno.setCodigoCliente(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento1()).toString());

			retorno.setNumeroGuiaPagamento(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento2()).toString());

			retorno.setNumeroPrestacaoGuiaPagamento(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento3()).toString());

		}else if(tipoPagamento != null && tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA.toString())){

			retorno.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);

			retorno.setMatriculaImovel(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento2()).toString());

			retorno.setSequencialDocumentoCobranca(registroHelperCodigoG.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

		}else if(tipoPagamento != null
						&& tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_CLIENTE.toString())){

			retorno.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);

			retorno.setCodigoCliente(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento1()).toString());

			retorno.setSequencialDocumentoCobranca(registroHelperCodigoG.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

		}else if(tipoPagamento != null
						&& tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL.toString())){

			retorno.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL);

			retorno.setCodigoCliente(Integer.valueOf(
							registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento2()).toString());
			retorno.setSequencialFaturaClienteResponsavel(registroHelperCodigoG.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento6());

		}else if(tipoPagamento != null && tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_NOTA_RECEBIMENTO.toString())){

			retorno.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_NOTA_RECEBIMENTO);

			retorno.setMatriculaImovel(registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento1());
			retorno.setCodigoLocalidade(registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento2());
			retorno.setCodigoTipoDebito(registroHelperCodigoG.getRegistroHelperCodigoBarras().getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento4());
		}

		return retorno;

	}

	// Método que verifica (no InserirAvisoBancario) se a conta bancária
	// selecionada existe para depósito da arrecadação
	public void verificarExistenciaContaParaAvisoBancario(String idArrecadador, String idConta) throws ControladorException{

		Collection arrecadadorContratoEncontrado = null;

		if(idConta != null && !idConta.equals("")){
			FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
			filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ID_DEPOSITO_ARRECADACAO, idConta));
			filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID, idArrecadador));
			filtroArrecadadorContrato.adicionarParametro(new ParametroNulo(FiltroArrecadadorContrato.DATA_CONTRATO_ENCERRAMENTO));

			try{

				arrecadadorContratoEncontrado = repositorioUtil.pesquisar(filtroArrecadadorContrato, ArrecadadorContrato.class.getName());

			}catch(ErroRepositorioException ex){
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}

			if(arrecadadorContratoEncontrado == null || arrecadadorContratoEncontrado.isEmpty()){
				throw new ControladorException("atencao.arrecadador.conta.inexistente");
			}

		}

	}

	/**
	 * Método que atualiza o aviso bancario, adiciona as deducoes e acertos
	 * novas e remove as deducoes e os acertos que forma para remover
	 * 
	 * @author thiago
	 * @date 14/03/2006
	 * @param avisoBancario
	 * @param duducoes
	 * @param deducoesParaRemover
	 * @param acertos
	 * @param acertosParaRemover
	 */
	public void atualizarAvisoBancario(AvisoBancario avisoBancario, Collection deducoes, Collection deducoesParaRemover,
					Collection acertos, Collection acertosParaRemover, Usuario usuario) throws ControladorException{

		try{

			BigDecimal arrecadacao = BigDecimal.ZERO;
			BigDecimal devolucao = BigDecimal.ZERO;
			BigDecimal deducao = BigDecimal.ZERO;

			if(avisoBancario.getValorArrecadacaoInformado() != null){
				arrecadacao = avisoBancario.getValorArrecadacaoInformado();
			}

			if(avisoBancario.getValorDevolucaoInformado() != null){
				devolucao = avisoBancario.getValorDevolucaoInformado();
			}

			if(deducoes != null){
				Iterator it = deducoes.iterator();
				while(it.hasNext()){
					AvisoDeducoes avisoDeducoes = (AvisoDeducoes) it.next();
					if(avisoDeducoes.getValorDeducao() != null){
						deducao = deducao.add(avisoDeducoes.getValorDeducao());
					}
				}
			}
			BigDecimal valorAviso = arrecadacao.subtract(devolucao);
			BigDecimal valorTela = valorAviso.subtract(deducao);

			if(avisoBancario.getIndicadorCreditoDebito() == 1 && (valorTela.compareTo(BigDecimal.ZERO) == -1)){
				throw new ControladorException("atencao.avisoBancario.credito.menor.que.zero", null, Util.formatarMoedaReal(valorTela));
			}else if(avisoBancario.getIndicadorCreditoDebito() == 2 && (valorTela.compareTo(BigDecimal.ZERO) == 1)){
				throw new ControladorException("atencao.avisoBancario.debito.maior.que.zero", null, Util.formatarMoedaReal(valorTela));
			}

			/*
			 * FiltroAvisoBancario filtroAvisoBancario = new
			 * FiltroAvisoBancario(); filtroAvisoBancario.adicionarParametro(new
			 * ParametroSimples( FiltroAvisoBancario.ID,
			 * avisoBancario.getId())); Collection coll =
			 * repositorioUtil.pesquisar(filtroAvisoBancario,
			 * AvisoBancario.class.getSimpleName()); if (coll != null &&
			 * !coll.isEmpty()) { AvisoBancario aviso = (AvisoBancario)
			 * coll.iterator().next(); if (aviso != null &&
			 * aviso.getUltimaAlteracao() != null) { if
			 * (aviso.getUltimaAlteracao().getTime() != avisoBancario
			 * .getUltimaAlteracao().getTime()) { throw new
			 * ControladorException( "atencao.avisoBancario.ja.atualizado"); }
			 * else { avisoBancario.setValorArrecadacaoInformado(aviso
			 * .getValorArrecadacaoInformado());
			 * avisoBancario.setValorDevolucaoInformado(aviso
			 * .getValorDevolucaoInformado()); } } }
			 */

			Boolean isAgente = this.isAgenteCaixaDeEmpresaAutorizado(avisoBancario.getArrecadador().getId(), usuario.getId());

			if(!isAgente){

				throw new ControladorException("atencao.arrecadacao.agente_nao_autorizado_a_atualizar_avisos_bancarios");

			}

			avisoBancario.setUltimaAlteracao(new Date(System.currentTimeMillis()));
			getControladorUtil().atualizar(avisoBancario);

			// removendo as
			if(deducoesParaRemover != null){
				Iterator it = deducoesParaRemover.iterator();
				while(it.hasNext()){
					AvisoDeducoes aviso = (AvisoDeducoes) it.next();
					if(aviso.getComp_id() != null){
						getControladorUtil().remover(aviso);
					}
				}
			}

			// adicionando as deducoes novas
			if(deducoes != null){
				Iterator it = deducoes.iterator();
				while(it.hasNext()){
					AvisoDeducoes aviso = (AvisoDeducoes) it.next();
					if(aviso.getComp_id() == null){
						AvisoDeducoesPK pk = new AvisoDeducoesPK();
						pk.setAvisoBancarioId(avisoBancario.getId());
						pk.setDeducaoTipoId(aviso.getDeducaoTipo().getId());

						aviso.setComp_id(pk);
						aviso.setAvisoBancario(avisoBancario);
						aviso.setUltimaAlteracao(new Date(System.currentTimeMillis()));

						getControladorUtil().inserir(aviso);
					}else{
						getControladorUtil().atualizar(aviso);
					}
				}
			}

			// removendo os acertos
			if(acertosParaRemover != null){
				Iterator it = acertosParaRemover.iterator();
				while(it.hasNext()){
					AvisoAcerto aviso = (AvisoAcerto) it.next();
					if(aviso.getId() != null){
						getControladorUtil().remover(aviso);
					}
				}
			}

			// adicionando as deducoes novas
			if(acertos != null){
				Iterator it = acertos.iterator();
				while(it.hasNext()){
					AvisoAcerto aviso = (AvisoAcerto) it.next();
					if(aviso.getId() == null){

						aviso.setAvisoBancario(avisoBancario);
						aviso.setUltimaAlteracao(new Date(System.currentTimeMillis()));

						getControladorUtil().inserir(aviso);
					}else{
						getControladorUtil().atualizar(aviso);
					}
				}
			}

		}catch(ControladorException ex){
			ex.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException(ex.getMessage(), ex);
		}

	}

	/**
	 * Faz a pesquisa de devolução fazendo os carregamentos de clienteContas,
	 * clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * @param FiltroDevolucao
	 * @return Collection<Devolucao>
	 * @throws ControladorException
	 */
	public Collection<Devolucao> pesquisarDevolucao(FiltroDevolucao filtroDevolucao) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarDevolucao(filtroDevolucao);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamentoImovel
	 * 
	 * @author Tiago Moreno, Roberta Costa,Rafael Santos
	 * @date 12/06/06,06/10/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoImovel(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoImovel(idImovel, idCliente, idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal, periodoPagamentoInicio,
							periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial, codigoSetorComercialFinal,
							indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0235] - Inserir Aviso Bancario Autor: Rhawi Dantas Data: 16/02/2006
	 */

	/**
	 * [UC0239] Filtrar Aviso Bancário
	 * Validar Filtrar Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 18/03/2006
	 * @param dataLancamentoInicio
	 * @param dataLancamentoFim
	 * @param periodoArrecadacaoInicio
	 * @param periodoArrecadacaoFim
	 * @param dataPrevisaoCreditoDebitoInicio
	 * @param dataPrevisaoCreditoDebitoFim
	 * @param intervaloValorPrevistoInicio
	 * @param intervaloValorPrevistoFim
	 * @param dataRealizacaoCreditoDebitoInicio
	 * @param dataRealizacaoCreditoDebitoFim
	 * @param intervaloValorRealizadoInicio
	 * @param intervaloValorRealizadoFim
	 *            return void
	 * @throws ControladorException
	 */
	public void validacaoFinal(Date dataLancamentoInicio, Date dataLancamentoFim, Integer periodoArrecadacaoInicio,
					Integer periodoArrecadacaoFim, Date dataPrevisaoCreditoDebitoInicio, Date dataPrevisaoCreditoDebitoFim,
					BigDecimal intervaloValorPrevistoInicio, BigDecimal intervaloValorPrevistoFim, Date dataRealizacaoCreditoDebitoInicio,
					Date dataRealizacaoCreditoDebitoFim, BigDecimal intervaloValorRealizadoInicio, BigDecimal intervaloValorRealizadoFim)
					throws ControladorException{

		getControladorUtil().validarDataMenorDataAtual(dataLancamentoInicio, "atencao.data.lancamento.posterior");
		getControladorUtil().validarDataMenorDataAtual(dataLancamentoFim, "atencao.data.lancamento.posterior");
		if((periodoArrecadacaoInicio != null)
						&& (periodoArrecadacaoInicio.toString().length() < 6 || Util.validarAnoMes(Util
										.formatarMesAnoReferencia(periodoArrecadacaoInicio)))){
			throw new ControladorException("atencao.arrecadacao_referencia_invalido", null);
		}
		if((periodoArrecadacaoFim != null)
						&& (periodoArrecadacaoFim.toString().length() < 6 || Util.validarAnoMes(Util
										.formatarMesAnoReferencia(periodoArrecadacaoFim)))){
			throw new ControladorException("atencao.arrecadacao_referencia_invalido", null);
		}
		getControladorUtil().validarAnoMesMenorAnoMesAtual(periodoArrecadacaoInicio, "atencao.referencia.posterior");
		getControladorUtil().validarAnoMesMenorAnoMesAtual(periodoArrecadacaoFim, "atencao.referencia.posterior");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(dataLancamentoInicio, dataLancamentoFim,
						"atencao.data_fim_menor_inicio");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(periodoArrecadacaoInicio, periodoArrecadacaoFim,
						"atencao.referenciafinal.menorque");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(dataPrevisaoCreditoDebitoInicio, dataPrevisaoCreditoDebitoFim,
						"atencao.data_fim_menor_inicio");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(intervaloValorPrevistoInicio, intervaloValorPrevistoFim,
						"atencao.valorprevistofinal.menorque");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(dataRealizacaoCreditoDebitoInicio, dataRealizacaoCreditoDebitoFim,
						"atencao.data_fim_menor_inicio");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(intervaloValorRealizadoInicio, intervaloValorRealizadoFim,
						"atencao.valorrealizadofinal.menorque");

	}

	/**
	 * Método que recebe um array de Integer e remove os Avisos Bancarios dos
	 * ids passado, caso exista um Aviso Bancario que tenha um relacionamento
	 * com outra tabela entao nao remove nenhum. Outra tabela fora aviso_deducao
	 * e aviso_acerto
	 * 
	 * @author Thiago Toscano
	 * @date 20/03/2006
	 * @param ids
	 * @throws ControladorException
	 */
	public void removerAvisosBancarios(Integer[] ids, OperacaoEfetuada operacaoEfetuada,
					Collection<UsuarioAcaoUsuarioHelper> acaoUsuarioHelper) throws ControladorException{

		if(ids != null && ids.length > 0){
			for(int i = 0; i < ids.length; i++){
				Integer id = ids[i];

				try{
					//
					// // consulta todos os aviso deducoes para serem removidos
					// FiltroAvisoDeducoes filtroAvisoDeducoes = new
					// FiltroAvisoDeducoes();
					// filtroAvisoDeducoes
					// .adicionarParametro(new ParametroSimples(
					// FiltroAvisoDeducoes.AVISO_BANCARIO_ID, id));
					// Collection collAvisoDeducoes = getControladorUtil()
					// .pesquisar(filtroAvisoDeducoes,
					// AvisoDeducoes.class.getSimpleName());
					// if (collAvisoDeducoes != null
					// && !collAvisoDeducoes.isEmpty()) {
					// Iterator it = collAvisoDeducoes.iterator();
					// while (it.hasNext()) {
					// AvisoDeducoes avisoDeducoes = (AvisoDeducoes) it.next();
					// avisoDeducoes.setOperacaoEfetuada(operacaoEfetuada);
					// avisoDeducoes.setUsuario(usuario);
					// getControladorUtil().remover(avisoDeducoes);
					// }
					// }
					//
					// // consultando todo os aviso acerto para serem removidos
					// FiltroAvisoAcerto filtroAvisoAcerto = new
					// FiltroAvisoAcerto();
					// filtroAvisoAcerto.adicionarParametro(new
					// ParametroSimples(
					// FiltroAvisoAcerto.AVISO_BANCARIO_ID, id));
					// Collection collAvisoAcerto = getControladorUtil()
					// .pesquisar(filtroAvisoAcerto,
					// AvisoAcerto.class.getSimpleName());
					// if (collAvisoAcerto != null &&
					// !collAvisoAcerto.isEmpty()) {
					// Iterator it = collAvisoAcerto.iterator();
					// while (it.hasNext()) {
					// AvisoAcerto avisoAcerto = (AvisoAcerto) it.next();
					// avisoAcerto.setOperacaoEfetuada(operacaoEfetuada);
					// avisoAcerto.setUsuario(usuario);
					// getControladorUtil().remover(avisoAcerto);
					// }
					// }

					// alterado por Vivianne Sousa dia 18/01/2007
					// pesquisa os pagamentos associados ao aviso bancario
					Collection colecaoPagamentoAvisoBancario = null;
					try{
						colecaoPagamentoAvisoBancario = repositorioArrecadacao.pesquisarPagamentoPorAvisoBancario(id);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema");
					}

					if(colecaoPagamentoAvisoBancario != null && !colecaoPagamentoAvisoBancario.isEmpty()){

						Iterator iteratorPagamentoAvisoBancario = colecaoPagamentoAvisoBancario.iterator();

						while(iteratorPagamentoAvisoBancario.hasNext()){
							Pagamento pagamento = (Pagamento) iteratorPagamentoAvisoBancario.next();

							// remover pagamento
							getControladorUtil().removerUm(pagamento.getId().intValue(), Pagamento.class.getName(), operacaoEfetuada,
											acaoUsuarioHelper);
						}
					}

					// remover aviso bancario
					getControladorUtil().removerUm(id.intValue(), AvisoBancario.class.getName(), operacaoEfetuada, acaoUsuarioHelper);

					// } catch (CallbackException e) {
					// sessionContext.setRollbackOnly();
					// throw new ControladorException(e.getMessage());
				}catch(ControladorException e){
					sessionContext.setRollbackOnly();
					/* Throwable troable = */e.getCause();
					if(e != null && e.getMessage() != null && "atencao.dependencias.existentes".equalsIgnoreCase(e.getMessage())){
						throw new ControladorException("atencao.avisoBancario.com.vinculo");
					}

					throw e;
				}
			}
		}
	}

	public void removerPagamentosAjusteDESO(String idMovimentoCorreto, String idMovimentoDuplicado) throws ControladorException{

		Usuario usur = new Usuario();
		usur.setId(Integer.valueOf(9999));

		String[] idsPagamentos = null;

		try{

			idsPagamentos = this.repositorioArrecadacao.pesquisarIdsPagamentoAjsuteDESO(idMovimentoCorreto, idMovimentoDuplicado);
			this.removerPagamentosDESO(idsPagamentos, usur);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema");
		}

	}
	
	public void removerPagamentosDESO(String[] idsPagamentos, Usuario usuarioLogado) throws ControladorException{

		// // ------------ REGISTRAR TRANSAÇÃO ----------------
		// RegistradorOperacao registradorOperacao = new
		// RegistradorOperacao(Operacao.OPERACAO_PAGAMENTO_REMOVER,
		// new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		// Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_PAGAMENTO_REMOVER);

		// OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		// operacaoEfetuada.setOperacao(operacao);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		if(idsPagamentos != null && idsPagamentos.length > 0){
			for(int i = 0; i < idsPagamentos.length; i++){
				String idPagamento = idsPagamentos[i];

				// System.out.println(" ### removerPagamentos(...) :: " + idPagamento + " :: " + (i
				// + 1) + "/" + idsPagamentos.length);

				FiltroPagamento filtroPagamento = new FiltroPagamento();
				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, idPagamento));
				filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAtual");
				filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAnterior");
				filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("avisoBancario");

				Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

				Pagamento pagamento;

				if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
					pagamento = (Pagamento) Util.retonarObjetoDeColecao(colecaoPagamento);

					// Esta validação foi removida do caso de uso UC0266 - ManterPagamentos
					// [FS0001]
					// if(pagamento.getPagamentoSituacaoAtual() != null &&
					// pagamento.getPagamentoSituacaoAnterior() != null){
					// throw new ControladorException("atencao.pagamento.situacoes.preenchidas",
					// null, pagamento
					// .getPagamentoSituacaoAnterior().getDescricao(),
					// pagamento.getPagamentoSituacaoAtual()
					// .getDescricao());
					// }

					// Alterado por Sávio Luiz data:16/03/2007
					AvisoBancario avisoBancario = pagamento.getAvisoBancario();

					// ------------ REGISTRAR TRANSAÇÃO ----------------
					// pagamento.setOperacaoEfetuada(operacaoEfetuada);
					// pagamento.adicionarUsuario(usuarioLogado,
					// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					// registradorOperacao.registrarOperacao(pagamento);
					// ------------ REGISTRAR TRANSAÇÃO ----------------

					getControladorContabil().registrarLancamentoContabil(pagamento, OperacaoContabil.ESTORNAR_PAGAMENTO_NAO_IDENTIFICADO);

					// atualizar itens de negativação
					// if(pagamento.getConta() != null){
					// getControladorSpcSerasa().atualizarItemDaNegativacao(pagamento.getConta().getReferencia(),
					// pagamento.getImovel(),
					// CobrancaDebitoSituacao.PENDENTE, new Date(), null, Boolean.TRUE,
					// ConstantesSistema.NAO);
					// }

					getControladorUtil().remover(pagamento);

					if(avisoBancario == null){
						throw new ControladorException("atencao.aviso.nao_localizado.pagamento");
					}

					// [SB0005] – Verifica Associação do Pagamento com Itens de Negativação.
					this.verificarAssociacaoPagamentoItensNegativacao(pagamento);

					this.atualizarValoresAvisoBancario(avisoBancario, false);

					// [SB0019] – Verifica Associação do Pagamento com Itens de Documento de
					// Cobrança
					this.verificarAssociacaoDoPagamentoComItensDeDocumentoDeCobranca(pagamento);
				}else{
					throw new ControladorException("atencao.registro_remocao_nao_existente");
				}

			}
		}

		System.out.println(" FIM  ### removerPagamentos(...) ");

	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * <Breve descrição sobre o subfluxo>
	 * <Identificador e nome do subfluxo>
	 * <Breve descrição sobre o fluxo secundário>
	 * <Identificador e nome do fluxo secundário>
	 * 
	 * @author Pedro Alexandre
	 * @date 22/03/2006
	 * @param idsPagamentos
	 * @throws ControladorException
	 */
	public void removerPagamentos(String[] idsPagamentos, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_PAGAMENTO_REMOVER,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_PAGAMENTO_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		if(idsPagamentos != null && idsPagamentos.length > 0){
			for(int i = 0; i < idsPagamentos.length; i++){
				String idPagamento = idsPagamentos[i];

				FiltroPagamento filtroPagamento = new FiltroPagamento();

				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, idPagamento));

				filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAtual");

				filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAnterior");

				filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("avisoBancario");

				Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

				Pagamento pagamento;

				if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
					pagamento = (Pagamento) Util.retonarObjetoDeColecao(colecaoPagamento);

					// Esta validação foi removida do caso de uso UC0266 - ManterPagamentos
					// [FS0001]
					// if(pagamento.getPagamentoSituacaoAtual() != null &&
					// pagamento.getPagamentoSituacaoAnterior() != null){
					// throw new ControladorException("atencao.pagamento.situacoes.preenchidas",
					// null, pagamento
					// .getPagamentoSituacaoAnterior().getDescricao(),
					// pagamento.getPagamentoSituacaoAtual()
					// .getDescricao());
					// }

					// Alterado por Sávio Luiz data:16/03/2007
					AvisoBancario avisoBancario = pagamento.getAvisoBancario();

					// ------------ REGISTRAR TRANSAÇÃO ----------------
					pagamento.setOperacaoEfetuada(operacaoEfetuada);
					pagamento.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					registradorOperacao.registrarOperacao(pagamento);
					// ------------ REGISTRAR TRANSAÇÃO ----------------

					getControladorContabil().registrarLancamentoContabil(pagamento, OperacaoContabil.ESTORNAR_PAGAMENTO_NAO_IDENTIFICADO);

					// atualizar itens de negativação
					if(pagamento.getConta() != null){
						getControladorSpcSerasa().atualizarItemDaNegativacao(pagamento.getConta().getReferencia(), pagamento.getImovel(),
										CobrancaDebitoSituacao.PENDENTE, new Date(), null, Boolean.TRUE, ConstantesSistema.NAO);
					}

					getControladorUtil().remover(pagamento);

					if(avisoBancario == null){
						throw new ControladorException("atencao.aviso.nao_localizado.pagamento");
					}

					// [SB0005] – Verifica Associação do Pagamento com Itens de Negativação.
					this.verificarAssociacaoPagamentoItensNegativacao(pagamento);

					this.atualizarValoresAvisoBancario(avisoBancario, false);

					// [SB0019] – Verifica Associação do Pagamento com Itens de Documento de
					// Cobrança
					this.verificarAssociacaoDoPagamentoComItensDeDocumentoDeCobranca(pagamento);
				}else{
					throw new ControladorException("atencao.registro_remocao_nao_existente");
				}

			}
		}
	}

	/**
	 * Fechado : avisos bancarios com o valor da arrecadação calculado - o valor
	 * da arrecadação informado + (Somatório dos acertos de credito para
	 * arrecadação)- (Somatório dos acertos de debitos para arrecadação) =
	 * avisos bancarios com o valor da devolução calculado - o valor da
	 * devolução informado + (Somatório dos acertos de credito para devolução)-
	 * (Somatório dos acertos de debitos para devolução)
	 * 
	 * @author Viviane Sousa, Raphael Rossiter
	 * @date 23/03/2006
	 * @param avisoBancario
	 * @return Uma String que representa a situação do aviso
	 * @throws ControladorException
	 */
	public String obterSituacaoAvisoBancario(AvisoBancario avisoBancario) throws ControladorException{

		String retorno = ConstantesSistema.ABERTO;
		BigDecimal vlArrecadacaoCalculado = BigDecimal.ZERO;
		BigDecimal vlArrecadacaoInformado = BigDecimal.ZERO;
		BigDecimal vlRealizado = BigDecimal.ZERO;

		// BigDecimal vlAcertosArrecadacao1 = BigDecimal.ZERO;
		// BigDecimal vlAcertosArrecadacao2 = BigDecimal.ZERO;
		// BigDecimal vlArrecadacaoFinal = BigDecimal.ZERO;
		//
		// BigDecimal vlDevolucaoCalculado = BigDecimal.ZERO;
		// BigDecimal vlDevolucaoInformado = BigDecimal.ZERO;
		// BigDecimal vlAcertosDevolucao1 = BigDecimal.ZERO;
		// BigDecimal vlAcertosDevolucao2 = BigDecimal.ZERO;
		// BigDecimal vlDevolucaoFinal = BigDecimal.ZERO;

		Object[] objeto = null;
		try{
			objeto = repositorioArrecadacao.pesquisarAvisoBancarioAvisoAcertos(avisoBancario.getId());

			if(objeto != null){

				if(objeto[0] != null){
					vlArrecadacaoCalculado = (BigDecimal) objeto[0];
				}

				if(objeto[1] != null){
					vlArrecadacaoInformado = (BigDecimal) objeto[1];
				}

				if(objeto[2] != null){
					vlRealizado = (BigDecimal) objeto[2];
				}

				if(vlRealizado.compareTo(vlArrecadacaoCalculado) == 0){
					retorno = ConstantesSistema.FECHADO;
				}

			}

		}catch(ErroRepositorioException e){
			e.printStackTrace();
		}

		// if (objeto[2] != null) {
		// vlAcertosArrecadacao1 = (BigDecimal) objeto[2];
		// }
		//
		// if (objeto[3] != null) {
		// vlAcertosArrecadacao2 = (BigDecimal) objeto[3];
		// }
		//
		// if (objeto[4] != null) {
		// vlDevolucaoCalculado = (BigDecimal) objeto[4];
		// }
		//
		// if (objeto[5] != null) {
		// vlDevolucaoInformado = (BigDecimal) objeto[5];
		// }
		//
		// if (objeto[6] != null) {
		// vlAcertosDevolucao1 = (BigDecimal) objeto[6];
		// }
		//
		// if (objeto[7] != null) {
		// vlAcertosDevolucao2 = (BigDecimal) objeto[7];
		// }
		//
		// vlArrecadacaoFinal = vlArrecadacaoCalculado
		// .subtract(vlArrecadacaoInformado);
		// vlArrecadacaoFinal = vlArrecadacaoFinal.add(vlAcertosArrecadacao1);
		// vlArrecadacaoFinal = vlArrecadacaoFinal.subtractarrecadadoresMovimento =
		// this.registrarMovimentoFichaCompensacao(stringBuilderTxt, codigoArrecadador,
		// nomeArrecadador, quantidadeRegistros);(vlAcertosArrecadacao2);
		//
		// vlDevolucaoFinal = vlDevolucaoCalculado.subtract(vlDevolucaoInformado);
		// vlDevolucaoFinal = vlDevolucaoFinal.add(vlAcertosDevolucao1);
		// vlDevolucaoFinal = vlDevolucaoFinal.subtract(vlAcertosDevolucao2);

		return retorno;

	}

	/**
	 * Este caso de uso apresenta a análise do aviso bancário e os pagamentos/devoluções associados.
	 * [UC0267] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Raphael Rossiter
	 * @date 23/03/2006
	 * @param avisoBancario
	 * @return AvisoBancarioHelper
	 */
	public AvisoBancarioHelper apresentarAnaliseAvisoBancario(AvisoBancario avisoBancario) throws ControladorException{

		AvisoBancarioHelper retorno = new AvisoBancarioHelper();

		Integer idAvisoBancario = avisoBancario.getId();

		// Obtém dados do Aviso Bancário
		Object[] dadosAvisoBancario = null;
		try{

			dadosAvisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(idAvisoBancario);
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema");
		}

		AvisoBancario avisoBancarioCompleto = (AvisoBancario) dadosAvisoBancario[0];

		Short codigoAgenteArrecadador = null;
		String nomeCliente = "";
		Integer idMovimentoArrecadador = null;
		Integer idBancoContaBancaria = (Integer) dadosAvisoBancario[4];
		String codigoAgenciaContaBancaria = (String) dadosAvisoBancario[5];
		String numeroContaBancaria = (String) dadosAvisoBancario[6];

		if(dadosAvisoBancario[1] != null){

			codigoAgenteArrecadador = (Short) dadosAvisoBancario[1];
		}

		if(dadosAvisoBancario[2] != null){

			nomeCliente = (String) dadosAvisoBancario[2];
		}

		if(dadosAvisoBancario[3] != null){

			idMovimentoArrecadador = (Integer) dadosAvisoBancario[3];
		}

		// Arrecadador
		retorno.setCodigoAgenteArrecadador(codigoAgenteArrecadador);
		retorno.setNomeCliente(nomeCliente);

		// Id do Arrecadador Movimento (armv_id)
		retorno.setIdMovimentoArrecadador(idMovimentoArrecadador);

		// Conta Bancária onde foi efetuado o depósito (banco, Agência e Conta)
		retorno.setIdBancoContaBancaria(idBancoContaBancaria);
		retorno.setCodigoAgenciaContaBancaria(codigoAgenciaContaBancaria);
		retorno.setNumeroContaBancaria(numeroContaBancaria);

		// Obtém o valor dos acertos do aviso
		Object[] objetoValorAcertosAvisoBancario = null;
		try{

			objetoValorAcertosAvisoBancario = repositorioArrecadacao.pesquisarValorAcertosAvisoBancario(avisoBancario.getId());
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema");
		}

		BigDecimal valorSomatorioAcertoCreditoArrecadacao = BigDecimal.ZERO;
		BigDecimal valorSomatorioAcertoDebitoArrecadacao = BigDecimal.ZERO;
		BigDecimal valorSomatorioAcertoCreditoDevolucao = BigDecimal.ZERO;
		BigDecimal valorSomatorioAcertoDebitoDevolucao = BigDecimal.ZERO;

		/*
		 * Somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO = 1 e
		 * AVAC_ICARRECADACAODEVOLUCAO = 1 com AVBC_ID = AVBC da tabela AVISO_BANCARIO
		 */
		if(objetoValorAcertosAvisoBancario[0] != null){

			valorSomatorioAcertoCreditoArrecadacao = (BigDecimal) objetoValorAcertosAvisoBancario[0];
		}

		/*
		 * Somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO = 2 e
		 * AVAC_ICARRECADACAODEVOLUCAO = 1 com AVBC_ID = AVBC da tabela AVISO_BANCARIO
		 */
		if(objetoValorAcertosAvisoBancario[1] != null){

			valorSomatorioAcertoDebitoArrecadacao = (BigDecimal) objetoValorAcertosAvisoBancario[1];
		}

		/*
		 * Somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO = 1 e
		 * AVAC_ICARRECADACAODEVOLUCAO = 2 com AVBC_ID = AVBC da tabela AVISO_BANCARIO
		 */
		if(objetoValorAcertosAvisoBancario[2] != null){

			valorSomatorioAcertoCreditoDevolucao = (BigDecimal) objetoValorAcertosAvisoBancario[2];
		}

		/*
		 * Somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO = 2 e
		 * AVAC_ICARRECADACAODEVOLUCAO = 2 com AVBC_ID = AVBC da tabela AVISO_BANCARIO
		 */
		if(objetoValorAcertosAvisoBancario[3] != null){

			valorSomatorioAcertoDebitoDevolucao = (BigDecimal) objetoValorAcertosAvisoBancario[3];
		}

		BigDecimal valorInformado = BigDecimal.ZERO;
		BigDecimal valorCalculado = BigDecimal.ZERO;
		BigDecimal valorAcertos = BigDecimal.ZERO;

		// Verifica se o Aviso é de Crédito "1" ou Débito "2"
		if(avisoBancarioCompleto.getIndicadorCreditoDebito() != null){

			if(avisoBancarioCompleto.getIndicadorCreditoDebito().equals(AvisoBancario.INDICADOR_CREDITO)){

				// Tipo do Aviso
				retorno.setTipoAviso(AvisoBancario.CREDITO);

				// Valor Arrecadação Informado
				if(avisoBancarioCompleto.getValorArrecadacaoInformado() != null){

					retorno.setValorInformado(avisoBancarioCompleto.getValorArrecadacaoInformado());
					valorInformado = avisoBancarioCompleto.getValorArrecadacaoInformado();
				}

				// Valor dos Acertos de Aviso de Crédito
				retorno.setValorAcertos(valorSomatorioAcertoCreditoArrecadacao.subtract(valorSomatorioAcertoDebitoArrecadacao));
				valorAcertos = valorSomatorioAcertoCreditoArrecadacao.subtract(valorSomatorioAcertoDebitoArrecadacao);

				// Valor Arrecadação Calculado
				if(avisoBancarioCompleto.getValorArrecadacaoCalculado() != null){

					retorno.setValorCalculado(avisoBancarioCompleto.getValorArrecadacaoCalculado());
					valorCalculado = avisoBancarioCompleto.getValorArrecadacaoCalculado();
				}

			}else{

				// Tipo do Aviso
				retorno.setTipoAviso(AvisoBancario.DEBITO);

				// Valor Devolução Informado
				if(avisoBancarioCompleto.getValorDevolucaoInformado() != null){

					retorno.setValorInformado(avisoBancarioCompleto.getValorDevolucaoInformado());
					valorInformado = avisoBancario.getValorDevolucaoInformado();
				}

				// Valor dos Acertos de Aviso de Devolução
				retorno.setValorAcertos(valorSomatorioAcertoCreditoDevolucao.subtract(valorSomatorioAcertoDebitoDevolucao));
				valorAcertos = valorSomatorioAcertoCreditoDevolucao.subtract(valorSomatorioAcertoDebitoDevolucao);

				// Valor Devolução Calculado
				if(avisoBancarioCompleto.getValorDevolucaoCalculado() != null){

					retorno.setValorCalculado(avisoBancarioCompleto.getValorDevolucaoCalculado());
					valorCalculado = avisoBancarioCompleto.getValorDevolucaoCalculado();
				}
			}
		}

		// Diferença
		retorno.setValorDiferenca(valorCalculado.subtract(valorInformado.add(valorAcertos)));

		try{

			// Valor das Deduções
			retorno.setValorSomatorioDeducoes(repositorioArrecadacao.pesquisarSomatorioDeducoesAvisoBancario(avisoBancarioCompleto.getId()));

			// Valor dos Pagamentos Classificados
			retorno.setValorPagamentosClassificados(repositorioArrecadacao
							.obterValorTotalPagamentosClassificadosPorAviso(avisoBancarioCompleto));

			// Valor dos Pagamento Não Classificados
			retorno.setValorPagamentosNaoClassificados(repositorioArrecadacao
							.obterValorTotalPagamentosNaoClassificadosPorAviso(avisoBancarioCompleto));
		}catch(ErroRepositorioException e1){
			e1.printStackTrace();
		}

		// Situação do Aviso
		if(retorno.getValorDiferenca().compareTo(BigDecimal.ZERO) == 0){

			retorno.setSituacao(ConstantesSistema.FECHADO);
		}else{

			retorno.setSituacao(ConstantesSistema.ABERTO);
		}

		// Aviso Bancário
		retorno.setAvisoBancario(avisoBancarioCompleto);

		/*
		 * Lista de pagamentos relacionados ao aviso bancário
		 */
		Collection colecaoPagamentos = this.pesquisarPagamentoAvisoBancario(idAvisoBancario);

		if(colecaoPagamentos != null){

			retorno.setColecaoPagamentos(colecaoPagamentos);
		}

		/*
		 * Lista das devoluções relacionados ao aviso bancário
		 */
		Collection colecaoDadosDevolucoes = null;
		try{

			colecaoDadosDevolucoes = repositorioArrecadacao.pesquisarDevolucaoAvisoBancario(idAvisoBancario);
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema");
		}

		if(colecaoDadosDevolucoes != null){

			Collection<Devolucao> colecaoDevolucoes = new ArrayList<Devolucao>();

			Iterator iter = colecaoDadosDevolucoes.iterator();

			while(iter.hasNext()){

				Object[] dadosDevolucoes = (Object[]) iter.next();
				Devolucao devolucao = new Devolucao();

				GuiaDevolucao guiaDevolucao = new GuiaDevolucao();
				DocumentoTipo documentoTipo = new DocumentoTipo();
				Localidade localidade = new Localidade();
				Imovel imovel = new Imovel();
				Cliente cliente = new Cliente();
				DebitoTipo debitoTipo = new DebitoTipo();
				DevolucaoSituacao devolucaoSituacaoAtual = new DevolucaoSituacao();

				documentoTipo.setDescricaoAbreviado((String) dadosDevolucoes[0]);
				guiaDevolucao.setDocumentoTipo(documentoTipo);
				devolucao.setGuiaDevolucao(guiaDevolucao);

				devolucao.setDataDevolucao((Date) dadosDevolucoes[1]);

				localidade.setId((Integer) dadosDevolucoes[2]);
				devolucao.setLocalidade(localidade);

				imovel.setId((Integer) dadosDevolucoes[3]);
				devolucao.setImovel(imovel);

				cliente.setId((Integer) dadosDevolucoes[4]);
				devolucao.setCliente(cliente);

				devolucao.setAnoMesReferenciaDevolucao((Integer) dadosDevolucoes[5]);

				debitoTipo.setId((Integer) dadosDevolucoes[6]);
				devolucao.setDebitoTipo(debitoTipo);

				devolucao.setValorDevolucao((BigDecimal) dadosDevolucoes[7]);

				devolucaoSituacaoAtual.setDescricaoAbreviada((String) dadosDevolucoes[8]);
				devolucao.setDevolucaoSituacaoAtual(devolucaoSituacaoAtual);

				colecaoDevolucoes.add(devolucao);
			}

			retorno.setColecaoDevolucoes(colecaoDevolucoes);
		}

		return retorno;
	}

	/**
	 * Seleciona os pagamentos histórios de um aviso
	 * 
	 * @author Rafael Corrêa
	 * @date 23/04/2007
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarPagamentoHistoricoAvisoBancario(Integer idAvisoBancario) throws ControladorException{

		Calendar tempo = Calendar.getInstance();

		Collection colecaoPagamentosHistoricos = new ArrayList();
		Collection colecaoDadosPagamentos = null;
		try{
			colecaoDadosPagamentos = repositorioArrecadacao.pesquisarPagamentoHistoricoAvisoBancario(idAvisoBancario);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema");
		}

		if(colecaoDadosPagamentos != null){

			Iterator iter = colecaoDadosPagamentos.iterator();

			while(iter.hasNext()){

				Object[] dadosPagamentos = (Object[]) iter.next();
				PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();

				DocumentoTipo documentoTipo = new DocumentoTipo();
				Localidade localidade = new Localidade();
				Imovel imovel = new Imovel();
				Cliente cliente = new Cliente();
				DebitoTipo debitoTipo = new DebitoTipo();
				PagamentoSituacao pagamentoSituacaoAtual = new PagamentoSituacao();
				ContaHistorico conta = new ContaHistorico();
				DebitoACobrar debitoACobrar = new DebitoACobrar();
				GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();

				documentoTipo.setDescricaoAbreviado((String) dadosPagamentos[0]);
				pagamentoHistorico.setDocumentoTipo(documentoTipo);

				pagamentoHistorico.setDataPagamento((Date) dadosPagamentos[1]);

				localidade.setId((Integer) dadosPagamentos[2]);
				pagamentoHistorico.setLocalidade(localidade);

				imovel.setId((Integer) dadosPagamentos[3]);
				pagamentoHistorico.setImovel(imovel);

				cliente.setId((Integer) dadosPagamentos[4]);
				pagamentoHistorico.setCliente(cliente);

				pagamentoHistorico.setAnoMesReferenciaPagamento((Integer) dadosPagamentos[5]);

				debitoTipo.setId((Integer) dadosPagamentos[6]);
				pagamentoHistorico.setDebitoTipo(debitoTipo);

				pagamentoHistorico.setValorPagamento((BigDecimal) dadosPagamentos[7]);

				pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamentos[8]);
				pagamentoHistorico.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

				pagamentoHistorico.setNumeroPrestacao((Integer) dadosPagamentos[9]);

				debitoACobrar.setId((Integer) dadosPagamentos[10]);
				pagamentoHistorico.setDebitoACobrar(debitoACobrar);

				conta.setId((Integer) dadosPagamentos[11]);
				pagamentoHistorico.setConta(conta);

				guiaPagamentoGeral.setId((Integer) dadosPagamentos[12]);
				pagamentoHistorico.setGuiaPagamentoGeral(guiaPagamentoGeral);

				colecaoPagamentosHistoricos.add(pagamentoHistorico);
			}
		}

		// System.out.println(" Tempo retorno Pagamento Historico AvisoBancario =" +
		// Util.calcularDiferencaTempo(tempo));

		return colecaoPagamentosHistoricos;

	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Pesquisa o débito a cobrar do imóvel informado pelo usuário
	 * [FS0024] - Verificar existência do débito a cobrar
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param idImovel
	 * @param idDebitoACobrar
	 * @return
	 * @throws ControladorException
	 */
	public DebitoACobrar pesquisarDebitoACobrarDigitado(String idImovel, String idDebitoACobrar) throws ControladorException{

		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrar debitoACobrarDigitado = null;

		// Cria o filtro de débito a cobrar e seta todos os parâmetros para
		// pesquisar o débito a cobrar do imóvel
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("imovel");
		Collection colecaoDebitoACobrar = getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());

		// Caso exista o débito a cobrar para o imóvel informado cadastrado no
		// sistema
		// Retorna para o usuário o débito a cobrar retornado pela pesquisa
		// Caso contrário retorna um objeto nulo
		if(colecaoDebitoACobrar == null || colecaoDebitoACobrar.isEmpty()){
			throw new ControladorException("atencao.pesquisa_inexistente", null, "Débito a Cobrar");
		}else{
			debitoACobrarDigitado = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
		}

		// Retorna o débito a cobrar encontrado ou nulo se não existir o débito
		// a cobrar
		return debitoACobrarDigitado;
	}

	public DebitoACobrar pesquisarDebitoACobrarDigitado2(String idImovel, String idDebitoACobrar) throws ControladorException{

		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrar debitoACobrarDigitado = null;

		// Cria o filtro de débito a cobrar e seta todos os parâmetros para
		// pesquisar o débito a cobrar do imóvel
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("imovel");
		//
		Collection colecaoDebitoACobrar = getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());
		// Collection colecaoDebitoACobrarHistorico = getControladorUtil().pesquisar(
		// filtroDebitoACobrar, DebitoACobrarHistorico.class.getName());
		//
		// colecaoDebitoACobrar.addAll(colecaoDebitoACobrarHistorico);

		// Caso exista o débito a cobrar para o imóvel informado cadastrado no
		// sistema
		// Retorna para o usuário o débito a cobrar retornado pela pesquisa
		// Caso contrário retorna um objeto nulo
		if(colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()){
			debitoACobrarDigitado = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
		}

		// Retorna o débito a cobrar encontrado ou nulo se não existir o débito
		// a cobrar
		return debitoACobrarDigitado;
	}

	/**
	 * Pesquisa o débito a cobrar do imóvel informado pelo usuário
	 * 
	 * @param idImovel
	 * @param idDebitoACobrar
	 * @return DebitoACobrarHistorico
	 * @throws ControladorException
	 */
	public DebitoACobrarHistorico pesquisarDebitoACobrarHistoricoDigitado(String idImovel, String idDebitoACobrar)
					throws ControladorException{

		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrarHistorico debitoACobrarHistoricoDigitado = null;

		// Cria o filtro de débito a cobrar e seta todos os parâmetros para
		// pesquisar o débito a cobrar do imóvel
		FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));
		filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
		Collection colecaoDebitoACobrarHistorico = getControladorUtil().pesquisar(filtroDebitoACobrarHistorico,
						DebitoACobrarHistorico.class.getName());
		if(colecaoDebitoACobrarHistorico == null || colecaoDebitoACobrarHistorico.isEmpty()){
			throw new ControladorException("atencao.pesquisa_inexistente", null, "Débito a Cobrar Histórico");
		}else{
			debitoACobrarHistoricoDigitado = (DebitoACobrarHistorico) Util.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico);
		}

		return debitoACobrarHistoricoDigitado;
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Pesquisa a guia de pagamento do imóvel informado pelo usuário
	 * [FS0022] - Verificar existência da guia de pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param idImovel
	 * @param idCliente
	 * @param idGuiaPagamento
	 * @return
	 * @throws ControladorException
	 */
	public GuiaPagamento pesquisarGuiaPagamentoDigitada(String idImovel, String idCliente, String idGuiaPagamento)
					throws ControladorException{

		// Cria a variável que vai armazenar a guia de pagamento pequisada
		GuiaPagamento guiaPagamentoDigitada = null;

		// Cria o filtro de guia de pagamento
		FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();

		// Caso o usuário tenha informado o imóvel, seta o código do imóvel no
		// filtro
		// Caso contrário, o usuário tenha informado o cliente seta o código do
		// cliente no filtro
		// Caso o usuário não tenha informado nem o imóvel nem o cliente levanta
		// uma exceção
		// para o usuário informando que tem de informar o cliente ou o imóvel
		if(idImovel != null && !idImovel.trim().equalsIgnoreCase("")){
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.IMOVEL_ID, idImovel));
		}else if(idCliente != null && !idCliente.trim().equalsIgnoreCase("")){
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.CLIENTE_ID, idCliente));
		}else{
			throw new ControladorException("atencao.naoinformado", null, "Imóvel ou Cliente");
		}

		// Pesquisa a guia de pagamento de acordo com os parâmetros no filtro
		filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));

		// filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("imovel");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("cliente");

		Collection colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamento, GuiaPagamento.class.getName());

		// Caso exista a guia de pagamento para o imóvel ou o cliente informado
		// cadastrado no sistema
		// Retorna para o usuário a guia de pagamento retornada pela pesquisa
		// Caso contrário retorna um objeto nulo
		if(colecaoGuiaPagamento == null || colecaoGuiaPagamento.isEmpty()){

			GuiaPagamentoHistorico guiaPagamentoHistorico = null;
			// Caso a guia de pagamento tenha ido para histórico
			guiaPagamentoHistorico = this.pesquisarGuiaPagamentoHistoricoDigitada(idImovel, idCliente, idGuiaPagamento);

			if(!Util.isVazioOuBranco(guiaPagamentoHistorico)){
				guiaPagamentoDigitada = new GuiaPagamento();

				guiaPagamentoDigitada.setId(guiaPagamentoHistorico.getId());

				if(!Util.isVazioOuBranco(guiaPagamentoHistorico.getLocalidade())){
					guiaPagamentoDigitada.setLocalidade(guiaPagamentoHistorico.getLocalidade());
				}

				if(!Util.isVazioOuBranco(guiaPagamentoHistorico.getImovel())){
					guiaPagamentoDigitada.setImovel(guiaPagamentoHistorico.getImovel());
				}

				if(!Util.isVazioOuBranco(guiaPagamentoHistorico.getCliente())){
					guiaPagamentoDigitada.setCliente(guiaPagamentoHistorico.getCliente());
				}
			}else{
				throw new ControladorException("atencao.pesquisa_inexistente", null, "Guia de Pagamento");
			}
		}else{
			guiaPagamentoDigitada = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);
		}

		// Retorna a guia de pagamento encontrada ou nulo se não existir aa guia
		// de pagamento
		return guiaPagamentoDigitada;
	}

	/**
	 * Atualizar uma coleção de pagamentos no sistema
	 * [UC0265] Atualizar Pagamentos
	 * Pesquisa a guia de pagamento histórico do imóvel informado pelo usuário
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 18/06/2013
	 * @param idImovel
	 * @param idCliente
	 * @param idGuiaPagamento
	 * @return
	 * @throws ControladorException
	 */
	public GuiaPagamentoHistorico pesquisarGuiaPagamentoHistoricoDigitada(String idImovel, String idCliente, String idGuiaPagamento)
					throws ControladorException{

		// Cria a variável que vai armazenar a guia de pagamento historico pequisada
		GuiaPagamentoHistorico guiaPagamentoHistoricoDigitada = null;

		// Cria o filtro de guia de pagamento historico
		FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();

		// Caso o usuário tenha informado o imóvel, seta o código do imóvel no
		// filtro
		// Caso contrário, o usuário tenha informado o cliente seta o código do
		// cliente no filtro
		// Caso o usuário não tenha informado nem o imóvel nem o cliente levanta
		// uma exceção
		// para o usuário informando que tem de informar o cliente ou o imóvel
		if(idImovel != null && !idImovel.trim().equalsIgnoreCase("")){
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.IMOVEL_ID, idImovel));
		}else if(idCliente != null && !idCliente.trim().equalsIgnoreCase("")){
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.CLIENTE_ID, idCliente));
		}else{
			throw new ControladorException("atencao.naoinformado", null, "Imóvel ou Cliente");
		}

		// Pesquisa a guia de pagamento de acordo com os parâmetros no filtro
		filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID, idGuiaPagamento));

		filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
		filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("cliente");

		Collection colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamentoHistorico,
						GuiaPagamentoHistorico.class.getName());

		// Caso exista a guia de pagamento para o imóvel ou o cliente informado
		// cadastrado no sistema
		// Retorna para o usuário a guia de pagamento histórico retornada pela pesquisa
		// Caso contrário retorna um objeto nulo
		if(colecaoGuiaPagamento == null || colecaoGuiaPagamento.isEmpty()){
			throw new ControladorException("atencao.pesquisa_inexistente", null, "Guia de Pagamento");
		}else{
			guiaPagamentoHistoricoDigitada = (GuiaPagamentoHistorico) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);
		}

		// Retorna a guia de pagamento histórico encontrada ou nulo se não existir a guia
		// de pagamento
		return guiaPagamentoHistoricoDigitada;
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Verifica se o usuário informou o código da guia de pagamento e o tipo de
	 * débito, só pode ser informado um dos dois
	 * [FS0021] Verificar preenchimento da guia de pagamento e do tipo de débito
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param idGuiaPagamento
	 * @param idTipoDebito
	 * @throws ControladorException
	 */
	public void verificarPreeenchimentoGuiaPagamentoETipoDebito(String idGuiaPagamento, String idTipoDebito) throws ControladorException{

		// Caso o usuário não informou a guia de pagamento
		if(idGuiaPagamento == null || idGuiaPagamento.trim().equalsIgnoreCase("")){
			// Caso o usuário não informou o tipo de débito, levanta uma exceção
			// para o usário
			// indicando que o usuário precisa informar ou a guia ou o tipo de
			// débito
			if(idTipoDebito == null || idTipoDebito.trim().equalsIgnoreCase("")){
				throw new ControladorException("atencao.naoinformado", null, "Guia Pagamento ou Tipo de Débito");
			}
		}else{
			// Caso o usuário informou a guia de pagamento e o tipo de débito,
			// levanta uma exceção para o usário indicando que o usuário
			// informou a guia e o tipo de débito
			if(idTipoDebito != null && !idTipoDebito.trim().equalsIgnoreCase("")){
				throw new ControladorException("atencao.guia_pagamento_tipo_debito_informado");
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Verifica se o usuário informou o código do débito a cobrar e o tipo de
	 * débito, só pode ser informado um dos dois
	 * [FS0023] Verificar preenchimento do débito a cobrar e do tipo de débito
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param idDebitoACobrar
	 * @param idTipoDebito
	 * @throws ControladorException
	 */
	public void verificarPreeenchimentoDebitoACobrarETipoDebito(String idDebitoACobrar, String idTipoDebito) throws ControladorException{

		// Caso o usuário não informou o débito a cobrar
		if(idDebitoACobrar == null || idDebitoACobrar.trim().equalsIgnoreCase("")){
			// Caso o usuário não informou o tipo de débito, levanta uma exceção
			// para o usário
			// indicando que o usuário precisa informar ou o débito a cobrar ou
			// o tipo de débito
			if(idTipoDebito == null || idTipoDebito.trim().equalsIgnoreCase("")){
				throw new ControladorException("atencao.naoinformado", null, "Débito a Cobrar ou Tipo de Débito");
			}
		}else{
			// Caso o usuário informou o débito a cobrar e o tipo de débito,
			// levanta uma exceção
			// para o usário indicando que o usuário informou o débito a cobrar
			// e o tipo de débito
			if(idTipoDebito != null && !idTipoDebito.trim().equalsIgnoreCase("")){
				throw new ControladorException("atencao.debto_a_cobrar_tipo_debito_informado");
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Verifica se a localidade informada é a mesma da guia de pagamento
	 * [FS0014] Verificar localidade da guia de pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param guiaPagamento
	 * @param idLocalidade
	 * @throws ControladorException
	 */
	public void verificarLocalidadeGuiaPagamento(GuiaPagamento guiaPagamento, String idLocalidade) throws ControladorException{

		// Caso o usuário tenha informado a localidade
		if(idLocalidade != null && !idLocalidade.trim().equalsIgnoreCase("")){
			// Caso a localidade da guia de pagamento seja diferente da
			// localidade informada
			if(!guiaPagamento.getLocalidade().getId().equals(Integer.valueOf(idLocalidade))){

				// Cria a mensagem que vai ser exibida ao usuário
				// e levanta a exceção
				String mensagem = "A Localidade da Guia de Pagamento " + guiaPagamento.getLocalidade().getId()
								+ " é diferente da Localidade informada " + idLocalidade;
				throw new ControladorException("atencao.localidade_guia_pagamento_diferente", null, mensagem);
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Verifica se a localidade informada é a mesma do débito a cobrar
	 * [FS0017] Verificar localidade do débito a cobrar
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param debitoACobrar
	 * @param idLocalidade
	 * @throws ControladorException
	 */
	public void verificarLocalidadeDebitoACobrar(DebitoACobrar debitoACobrar, String idLocalidade) throws ControladorException{

		// Caso o usuário tenha informado a localidade
		if(idLocalidade != null && !idLocalidade.trim().equalsIgnoreCase("")){

			// Caso a localidade do débito a cobrar seja diferente da localidade
			// informada
			if(!debitoACobrar.getLocalidade().getId().equals(Integer.valueOf(idLocalidade))){

				// Cria a mensagem que vai ser exibida ao usuário
				// e levanta a exceção
				String mensagem = "A Localidade do Débito a Cobrar " + debitoACobrar.getLocalidade().getId()
								+ " é diferente da Localidade informada " + idLocalidade;
				throw new ControladorException("atencao.localidade_debito_a_cobrar_diferente", null, mensagem);
			}
		}
	}

	/**
	 * Verifica se a localidade informada é a mesma do débito a cobrar Historico
	 * 
	 * @param debitoACobrar
	 * @param idLocalidade
	 * @throws ControladorException
	 */
	public void verificarLocalidadeDebitoACobrarHistorico(DebitoACobrarHistorico debitoACobrarHistorico, String idLocalidade)
					throws ControladorException{

		// Caso o usuário tenha informado a localidade
		if(idLocalidade != null && !idLocalidade.trim().equalsIgnoreCase("")){

			// Caso a localidade do débito a cobrar seja diferente da localidade
			// informada
			if(!debitoACobrarHistorico.getLocalidade().getId().equals(Integer.valueOf(idLocalidade))){

				// Cria a mensagem que vai ser exibida ao usuário
				// e levanta a exceção
				String mensagem = "A Localidade do Débito a Cobrar Histórico " + debitoACobrarHistorico.getLocalidade().getId()
								+ " é diferente da Localidade informada " + idLocalidade;
				throw new ControladorException("atencao.localidade_debito_a_cobrar_diferente", null, mensagem);
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Verifica a existência de débito a cobrar com o tipo de débito e o imóvel
	 * informados
	 * [FS0016] Verificar existência de débito a cobrar com tipo de débito
	 * informado
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param tipoDebito
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public DebitoACobrar verificarExistenciaDebitoACobrarComTipoDebito(DebitoTipo tipoDebito, String idImovel) throws ControladorException{

		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrar debitoACobrar = null;

		// Cria o filtro de débito a cobrar, e seta os parâmetros para pesquisar
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.DEBITO_TIPO_ID, tipoDebito.getId()));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
						DebitoCreditoSituacao.NORMAL));

		// Pesquisa o débito a cobrar no sistema
		Collection colecaoDebitoACobrar = getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());

		// Caso exista débito a cobrar cadastrado com o tipo de débito informado
		if(colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()){

			// Caso exista mais que um débito a cobrar cadastrado para o tipo de
			// débito
			// Monta a mensagem para o usuário e levanta a exceção
			if(colecaoDebitoACobrar.size() > 1){
				String mensagem = "Há mais de um Débito a Cobrar com o tipo de débito " + tipoDebito.getDescricao() + " para o Imóvel "
								+ idImovel;
				throw new ControladorException("atencao.descricao_concatenada", null, mensagem);
			}else{
				// Caso só exista apenas um débito a cobrar cadastrado para o
				// tipo de débito
				debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
			}
		}

		// Retorna o débito a cobrar encontrado ou nulo se não existir o débito
		// a cobrar
		return debitoACobrar;
	}

	/**
	 * Verifica a existência de débito a cobrar com o tipo de débito e o imóvel
	 * informados
	 * 
	 * @param tipoDebito
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public DebitoACobrarHistorico verificarExistenciaDebitoACobrarHistoricoComTipoDebito(DebitoTipo tipoDebito, String idImovel)
					throws ControladorException{

		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrarHistorico debitoACobrarHistorico = null;

		// Cria o filtro de débito a cobrar, e seta os parâmetros para pesquisar
		FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.DEBITO_TIPO_ID, tipoDebito.getId()));
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
						DebitoCreditoSituacao.NORMAL));

		// Pesquisa o débito a cobrar no sistema
		Collection colecaoDebitoACobrarHistorico = getControladorUtil().pesquisar(filtroDebitoACobrarHistorico,
						DebitoACobrarHistorico.class.getName());

		// Caso exista débito a cobrar cadastrado com o tipo de débito informado
		if(colecaoDebitoACobrarHistorico != null && !colecaoDebitoACobrarHistorico.isEmpty()){

			// Caso exista mais que um débito a cobrar cadastrado para o tipo de
			// débito
			// Monta a mensagem para o usuário e levanta a exceção
			if(colecaoDebitoACobrarHistorico.size() > 1){
				String mensagem = "Há mais de um Débito a Cobrar no Histórico com o tipo de débito " + tipoDebito.getDescricao()
								+ " para o Imóvel " + idImovel;
				throw new ControladorException("atencao.descricao_concatenada", null, mensagem);
			}else{
				// Caso só exista apenas um débito a cobrar cadastrado para o
				// tipo de débito
				debitoACobrarHistorico = (DebitoACobrarHistorico) Util.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico);
			}
		}

		// Retorna o débito a cobrar historico encontrado ou nulo se não existir o débito
		// a cobrar
		return debitoACobrarHistorico;
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Verifica a existência de guia de pagamento com o tipo de débito e o
	 * imóvel informados
	 * [FS0013] Verificar existência de guia de pagamento com tipo de débito
	 * informado
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param tipoDebito
	 * @param idImovel
	 * @param idCliente
	 * @return
	 * @throws ControladorException
	 */
	public GuiaPagamento verificarExistenciaGuiaPagamentoComTipoDebito(DebitoTipo tipoDebito, String idImovel, String idCliente)
					throws ControladorException{

		// Cria a variável que vai armazenar a guia de pagamento pesquisada
		GuiaPagamento guiaPagamento = null;

		// Cria o filtro de guia de pagamento, e seta os parâmetros para
		// pesquisar
		FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();

		filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
						DebitoCreditoSituacao.NORMAL));

		// Caso o usuário tenha informado a matrícula do imóvel,
		// seta a metrículo do imóvel no filtro
		// Caso contrário seta o códigodo cliente no filtro
		if(idImovel != null && !idImovel.trim().equalsIgnoreCase("")){
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.IMOVEL_ID, idImovel));
		}else if(idCliente != null && !idCliente.trim().equalsIgnoreCase("")){
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.CLIENTE_ID, idCliente));
		}else{
			throw new ControladorException("atencao.naoinformado", null, "Imóvel ou Cliente");
		}

		// Pesquisa as guias de pagamento no sistema
		Collection colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamento, GuiaPagamento.class.getName());

		// Caso exista guia de pagamento cadastrada no sistema com os parâmetros
		// informados no filtro
		if(colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()){

			// Caso exista mais que uma guia de pagamento cadastrada
			if(colecaoGuiaPagamento.size() > 1){

				// Cria a variável que vai armazenar a mensagem que vai ser
				// exibida ao usuário
				String mensagem = null;

				// Caso a pequisa foi para imóvel
				// Cria a mensagem para imóvel
				// Caso contrário cria a mensagem para cliente
				if(idImovel != null && !idImovel.trim().equalsIgnoreCase("")){
					mensagem = "Há mais de uma Guia de Pagamento com o tipo de débito " + tipoDebito.getDescricao() + " para o Imóvel "
									+ idImovel + ". Efetue uma pesquisa para selecionar a Guia";
				}else{
					mensagem = "Há mais de uma Guia de Pagamento com o tipo de débito " + tipoDebito.getDescricao() + " para o Cliente "
									+ idCliente + ". Efetue uma pesquisa para selecionar a Guia";
				}

				// levanta a exceção para o usuário com a mensagem criada
				throw new ControladorException("atencao.descricao_concatenada", null, mensagem);

			}else{
				// Caso só exista apenas uma guia de pagamento cadastrada para o
				// tipo de débito
				guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);
			}
		}

		// Retorna a guia de pagamento encontrada ou nulo se não existir a guia
		// de pagamento
		return guiaPagamento;
	}

	/**
	 * Atualizar uma coleção de pagamentos no sistema
	 * [UC0265] Atualizar Pagamentos
	 * Pesquisa a guia de pagamento histórico do imóvel informado pelo usuário
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 19/06/2013
	 * @param idImovel
	 * @param idCliente
	 * @param tipoDebito
	 * @return
	 * @throws ControladorException
	 */
	public GuiaPagamentoHistorico verificarExistenciaGuiaPagamentoHistoricoComTipoDebito(DebitoTipo tipoDebito, String idImovel,
					String idCliente) throws ControladorException{

		// Cria a variável que vai armazenar a guia de pagamento historico pesquisada
		GuiaPagamentoHistorico guiaPagamentoHistorico = null;

		// Cria o filtro de guia de pagamento historico, e seta os parâmetros para
		// pesquisar
		FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();

		filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
						DebitoCreditoSituacao.NORMAL, ConectorOr.CONECTOR_OR, 2));
		filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
						DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO));

		// Caso o usuário tenha informado a matrícula do imóvel,
		// seta a metrículo do imóvel no filtro
		// Caso contrário seta o códigodo cliente no filtro
		if(idImovel != null && !idImovel.trim().equalsIgnoreCase("")){
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.IMOVEL_ID, idImovel));
		}else if(idCliente != null && !idCliente.trim().equalsIgnoreCase("")){
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.CLIENTE_ID, idCliente));
		}else{
			throw new ControladorException("atencao.naoinformado", null, "Imóvel ou Cliente");
		}

		// Pesquisa as guias de pagamento no sistema
		Collection colecaoGuiaPagamentoHistorico = getControladorUtil().pesquisar(filtroGuiaPagamentoHistorico,
						GuiaPagamentoHistorico.class.getName());

		// Caso exista guia de pagamento historico cadastrada no sistema com os parâmetros
		// informados no filtro
		if(colecaoGuiaPagamentoHistorico != null && !colecaoGuiaPagamentoHistorico.isEmpty()){

			// Caso exista mais que uma guia de pagamento historico cadastrada
			if(colecaoGuiaPagamentoHistorico.size() > 1){

				// Cria a variável que vai armazenar a mensagem que vai ser
				// exibida ao usuário
				String mensagem = null;

				// Caso a pequisa foi para imóvel
				// Cria a mensagem para imóvel
				// Caso contrário cria a mensagem para cliente
				if(idImovel != null && !idImovel.trim().equalsIgnoreCase("")){
					mensagem = "Há mais de uma Guia de Pagamento com o tipo de débito " + tipoDebito.getDescricao() + " para o Imóvel "
									+ idImovel + ". Efetue uma pesquisa para selecionar a Guia";
				}else{
					mensagem = "Há mais de uma Guia de Pagamento com o tipo de débito " + tipoDebito.getDescricao() + " para o Cliente "
									+ idCliente + ". Efetue uma pesquisa para selecionar a Guia";
				}

				// levanta a exceção para o usuário com a mensagem criada
				throw new ControladorException("atencao.descricao_concatenada", null, mensagem);

			}else{
				// Caso só exista apenas uma guia de pagamento historico cadastrada para o
				// tipo de débito
				guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util.retonarObjetoDeColecao(colecaoGuiaPagamentoHistorico);
			}
		}

		// Retorna a guia de pagamento historico encontrada ou nulo se não existir a guia
		// de pagamento
		return guiaPagamentoHistorico;
	}


	/**
	 * Encapsula a chamada ao método atualizarPagamento, sem a passagem do parâmetro
	 * colecaoClassificarPagamentosNaoClassificadosHelper, utilizado apenas pela funcionalidade de
	 * Classificar Lote de Pagamentos Não Classificados
	 * [UC0266] Manter Pagamentos
	 * [SB0001] Atualizar Pagamento
	 * 
	 * @author Luciano Galvão
	 * @date 16/09/2013
	 */
	public void atualizarPagamento(Pagamento pagamento, Usuario usuario, String gerarDevolucaoValores, Integer idCreditoTipo,
					PagamentoSituacao situacaoPagamentoOriginal) throws ControladorException{

		atualizarPagamento(pagamento, usuario, gerarDevolucaoValores, idCreditoTipo, situacaoPagamentoOriginal, null);
	}

	/**
	 * Responsável pela manutenção das informações de pagamento
	 * [UC0266] Manter Pagamentos
	 * Atualiza um pagamento no sistema, verificando se a atualização já foi
	 * executada por outro usuário
	 * [SB0001] Atualizar Pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 25/03/2006
	 * @author Saulo Lima
	 * @date 14/01/2009
	 *       Incluir chamada ao Classificar Pagamentos
	 * @param pagamento
	 * @throws ControladorException
	 */
	private void atualizarPagamento(Pagamento pagamento, Usuario usuario, String gerarDevolucaoValores, Integer idCreditoTipo,
					PagamentoSituacao situacaoPagamentoOriginal,
					Collection<ClassificarPagamentosNaoClassificadosHelper> colecaoClassificarPagamentosNaoClassificadosHelper)
					throws ControladorException{

		try{

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_PAGAMENTO_ATUALIZAR, pagamento.getId(),
							pagamento.getId(), new UsuarioAcaoUsuarioHelper(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_PAGAMENTO_ATUALIZAR);
			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			// Cria o filtro de pagamento para pesquisar o pagamento na base
			FiltroPagamento filtroPagamento = new FiltroPagamento();

			// Parte de Validação com Timestamp

			// Seta no filtro o códigodo pagamento que está sendo atualizado
			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, pagamento.getId()));
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.CONTA);
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.GUIA_PAGAMENTO_GERAL);
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.GUIA_PAGAMENTO);
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.DEBITO_A_COBRAR);

			// Procura o pagamento na base
			Collection<Pagamento> colecaoPagamento = this.getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

			Pagamento pagamentoNaBase = (Pagamento) Util.retonarObjetoDeColecao(colecaoPagamento);

			Integer idContaGeral = repositorioArrecadacao.pesquisarIdDaContaGeralNoPagamento(pagamento.getId());

			// [FS0017] Atualização realizada por outro usuário
			// Caso o usuário esteja tentando atualizar um pagamento e o mesmo já tenha
			// sido atualizado durante a manutençaõ corrente
			if(pagamentoNaBase.getUltimaAlteracao().after(pagamento.getUltimaAlteracao())){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			pagamento.setOperacaoEfetuada(operacaoEfetuada);
			pagamento.adicionarUsuario(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(pagamento);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			pagamento.setUltimaAlteracao(new Date());

			// Caso o pagamento não tenha sido atualizado por outro usuário durante a manutenção
			// corrente atualiza pagamento no sistema
			this.getControladorUtil().atualizar(pagamento);

			// [UC0300] Classificar Pagamentos e Devoluções
			this.classificarPagamentosRegistroMovimentoArrecadadores(pagamento, colecaoClassificarPagamentosNaoClassificadosHelper);

			DocumentoTipo documentoTipo = pagamento.getDocumentoTipo();

			if(documentoTipo != null){
				Integer idDocumentoTipo = documentoTipo.getId();

				if(idDocumentoTipo.intValue() == DocumentoTipo.CONTA.intValue()){
					Conta contaNova = pagamento.getConta();
					Conta contaAntiga = pagamentoNaBase.getConta();

					if(contaAntiga == null && idContaGeral != null){
						// Essa verificação é necessária porque o objeto Pagamento está associado a
						// Conta e não a ContaGeral, mas a tabela PAGAMENTO está associada a
						// CONTA_GERAL. Nesse caso quando um pagameno que tinha uma conta em
						// histórico e era realizado a baixa forçada, o sistema estava transferindo
						// o pagamento sem o Id da Conta.

						contaAntiga = new Conta();
						contaAntiga.setId(idContaGeral);
					}

					// Atualizar Itens da negaticação
					// [SB0005 - Verifica Associação Pagamento da Conta com Itens de Negativação]
					if(contaNova != null){
						this.verificaAssociacaoPagamentoContaItensNegativacao(pagamento, contaNova, contaAntiga);
					}

					// [SB0010 - Verifica Associação Novo Tipo Documento do Pagamento com Itens de
					// Negativação]
					this.verificarAssociacaoNovoTipoDocPagamentoItensNegativacao(contaAntiga, contaNova);

					// [SB0015] – Verifica Associação Pagamento da Conta com Itens de Documento de
					// Cobrança
					this.verificarAssociacaoDoPagamentoDaContaComItensDeDocumentoDeCobranca(pagamento, pagamentoNaBase);

				}else if(idDocumentoTipo.intValue() == DocumentoTipo.GUIA_PAGAMENTO.intValue()){
					// [SB0016] – Verifica Associação Pagamento da Guia com Itens de Documento de
					// Cobrança
					this.verificarAssociacaoDoPagamentoDaGuiaComItensDeDocumentoDeCobranca(pagamento, pagamentoNaBase);

				}else if(idDocumentoTipo.intValue() == DocumentoTipo.DEBITO_A_COBRAR.intValue()){
					// [SB0017] – Verifica Associação Pagamento do Débito A Cobrar com Itens de
					// Documento de Cobrança
					this.verificarAssociacaoDoPagamentoDoDebitoComItensDeDocumentoDeCobranca(pagamento, pagamentoNaBase);

				}else{
					// [SB0018] – Verifica Associação Novo Tipo Documento do Pagamento com Itens de
					// Documento de Cobrança]
					this.verificarAssociacaoNovoTipoDocumentoDoPagamentoComItensDeDocumentoDeCobranca(pagamento, pagamentoNaBase);

				}
			}

			// [SB0020] – Gerar devolução de valores
			this.gerarDevolucoesValores(pagamento, situacaoPagamentoOriginal, usuario, gerarDevolucaoValores, idCreditoTipo);

			AvisoBancario avisoBancario = pagamento.getAvisoBancario();

			if(avisoBancario != null){
				this.atualizarValoresAvisoBancario(avisoBancario, false);
			}

		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	private void verificaAssociacaoPagamentoContaItensNegativacao(Pagamento pagamento, Conta contaNova, Conta contaAntiga)
					throws ControladorException{

		// Situação 1: Pagamento alterado para determinada conta
		if(contaAntiga == null && pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)){
			getControladorSpcSerasa().atualizarItemDaNegativacao(pagamento.getConta().getReferencia(), pagamento.getImovel(),
							CobrancaDebitoSituacao.PAGO, pagamento.getDataPagamento(), pagamento.getValorPagamento(), Boolean.FALSE,
							ConstantesSistema.SIM);

			// Situação 2: Pagamento alterado para outra conta
		}else if(contaAntiga != null && contaNova != null && contaAntiga.getId() != contaNova.getId()){
			// atualizando itens da negativação da conta antiga
			getControladorSpcSerasa().atualizarItemDaNegativacao(contaAntiga.getReferencia(), contaAntiga.getImovel(),
							CobrancaDebitoSituacao.PENDENTE, new Date(), null, Boolean.TRUE, ConstantesSistema.NAO);
			// atualizando itens da negativação da conta nova
			getControladorSpcSerasa().atualizarItemDaNegativacao(contaNova.getReferencia(), pagamento.getImovel(),
							CobrancaDebitoSituacao.PAGO, pagamento.getDataPagamento(), pagamento.getValorPagamento(), Boolean.FALSE,
							ConstantesSistema.SIM);

			// Situação 3: Valor e/ou Data do Pagamento alterados, sem mudança da conta do pagamento
		}else if(contaAntiga != null && contaNova != null && contaAntiga.getId() == contaNova.getId()){
			getControladorSpcSerasa().atualizarItemDaNegativacao(pagamento.getConta().getReferencia(), pagamento.getImovel(),
							CobrancaDebitoSituacao.PAGO, pagamento.getDataPagamento(), pagamento.getValorPagamento(), Boolean.TRUE,
							ConstantesSistema.SIM);
		}
	}

	protected ControladorBatchLocal getControladorBatch(){

		ControladorBatchLocalHome localHome = null;
		ControladorBatchLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorBatchLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_BATCH_SEJB);
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Gera os dados diários da arrecadação acumulando a quantidade e o valor
	 * dos pagamentos
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 11/04/2006, 08/12/2006
	 * @author Saulo Lima
	 * @date 19/01/2009
	 *       Acumular dados de Pagamento e PagamentoHistorico
	 * @throws ControladorException
	 */
	public void gerarDadosDiariosArrecadacao(int idFuncionalidadeIniciada, Collection<Integer> colecaoIdsLocalidades)
					throws ControladorException{

		int idUnidadeIniciada = 0;

		// ------------------------------------------------------------------------
		// Registrar o início do processamento da Unidade de Processamento do Batch
		// ------------------------------------------------------------------------
		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.LOCALIDADE, (Integer) Util.retonarObjetoDeColecao(colecaoIdsLocalidades));

		Collection colecaoDadosDiariosArrecadacaoInserir = null;

		SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

		// recupera o ano/mês de referência da arrecadação int
		int anoMesArrecadacaoSistemaParametro = sistemaParametros.getAnoMesArrecadacao();

		ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = null;

		// Cria as variáveis referentes a imóvel
		Imovel imovel = null;
		Localidade localidade = null;
		SetorComercial setorComercial = null;
		Rota rota = null;
		Quadra quadra = null;
		int codigoSetorComercial = 0;
		int numeroQuadra = 0;
		ImovelPerfil perfilImovel = null;
		LigacaoAguaSituacao situacaoLigacaoAgua = null;
		LigacaoEsgotoSituacao situacaoLigacaoEsgoto = null;
		Categoria principalCategoria = null;
		EsferaPoder esferaPoder = null;
		Short indicadorHidrometro = null;
		BigDecimal somaValorPagamento = null;
		Long quantidadePagamento = null;
		AvisoBancario avisoBancario = null;
		Arrecadador arrecadador = null;
		UnidadeNegocio unidadeNegocio = null;
		GerenciaRegional gerenciaRegional = null;
		DocumentoTipo documentoTipo = null;
		ArrecadacaoForma arrecadacaoForma = null;
		Date dataPagamento = null;

		Collection<Object> colecaoDadosPagamentos = null;
		boolean concluiuComSucesso = false;

		try{

			if(colecaoIdsLocalidades != null && !colecaoIdsLocalidades.isEmpty()){
				for(Integer idLocalidade : colecaoIdsLocalidades){

					Collection<Integer> colecaoAnoMesReferenciaPagamentos = repositorioArrecadacao
									.pesquisarAnoMesArrecadacaoPagamentoMaiorIgualAnoMesArrecadacaoAtual(anoMesArrecadacaoSistemaParametro,
													idLocalidade);

					Collection<Integer> colecaoAnoMesReferenciaPagamentosHistorico = repositorioArrecadacao
									.pesquisarAnoMesArrecadacaoPagamentoMaiorIgualAnoMesArrecadacaoAtualHistorico(
													anoMesArrecadacaoSistemaParametro, idLocalidade);

					// Union de ano/mes ref pagamento com seu historico
					if(colecaoAnoMesReferenciaPagamentosHistorico != null && !colecaoAnoMesReferenciaPagamentosHistorico.isEmpty()){
						if(colecaoAnoMesReferenciaPagamentos != null){
							// Transforma as listas em conjuntos para impedir repetição
							Set<Integer> conjuntoAnoMesReferenciaPagamentos = new HashSet<Integer>(colecaoAnoMesReferenciaPagamentos);
							Set<Integer> conjuntoAnoMesReferenciaPagamentosHistorico = new HashSet<Integer>(
											colecaoAnoMesReferenciaPagamentosHistorico);

							conjuntoAnoMesReferenciaPagamentos.addAll(colecaoAnoMesReferenciaPagamentosHistorico);

							colecaoAnoMesReferenciaPagamentos = new ArrayList<Integer>(conjuntoAnoMesReferenciaPagamentos);
						}else{
							colecaoAnoMesReferenciaPagamentos = colecaoAnoMesReferenciaPagamentosHistorico;
						}
					}

					if(colecaoAnoMesReferenciaPagamentos != null && !colecaoAnoMesReferenciaPagamentos.isEmpty()){

						colecaoDadosDiariosArrecadacaoInserir = new ArrayList();

						for(Integer anoMesArrecadacaoAtual : colecaoAnoMesReferenciaPagamentos){

							// Exclui os dados diários da arrecadação do ano/mês da arrecadação
							// corrente
							repositorioArrecadacao.excluirDadosDiariosArrecadacaoPorAnoMesArrecadacaoPorLocalidade(anoMesArrecadacaoAtual,
											idLocalidade);

							localidade = new Localidade();
							localidade.setId(idLocalidade);

							// Acumula a quantidade e o valor de pagamentos
							colecaoDadosPagamentos = repositorioArrecadacao.acumularQuantidadeEValorPagamentoPorAnoMesArrecadacao(
											anoMesArrecadacaoAtual, localidade.getId());

							// Acumula a quantidade e o valor de pagamentos vindos do histórico
							// Saulo Lima - 19/01/2008
							Collection colecaoDadosPagamentosHistorico = repositorioArrecadacao
											.acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoDoHistorico(anoMesArrecadacaoAtual,
															localidade.getId());
							if(colecaoDadosPagamentosHistorico != null && !colecaoDadosPagamentosHistorico.isEmpty()){
								if(colecaoDadosPagamentos != null){
									colecaoDadosPagamentos.addAll(colecaoDadosPagamentosHistorico);
								}else{
									colecaoDadosPagamentos = colecaoDadosPagamentosHistorico;
								}
							}

							// Caso a coleção de pagamentosnão esteja vazia
							if(colecaoDadosPagamentos != null){

								// Laço para incluir todos os dados diários da arrecadação
								for(Object dadosPagamento : colecaoDadosPagamentos){

									Object[] arrayDadosPagamento = (Object[]) dadosPagamento;

									// ID IMOVEL
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[0] != null){
											imovel = new Imovel();
											imovel.setId((Integer) arrayDadosPagamento[0]);
										}else{
											imovel = null;
										}
									}

									// SOMA DO VALOR
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[1] != null){

											somaValorPagamento = (BigDecimal) arrayDadosPagamento[1];
										}else{
											somaValorPagamento = null;
										}
									}

									// QUANTIDADE PAGAMENTOS
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[2] != null){
											quantidadePagamento = (Long) arrayDadosPagamento[2];
										}else{
											quantidadePagamento = null;
										}
									}

									// ID SETOR COMERCIAL
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[3] != null){
											setorComercial = new SetorComercial();
											setorComercial.setId((Integer) arrayDadosPagamento[3]);
										}else{
											setorComercial = null;
										}
									}

									// CODIGO SETOR COMERCIAL
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[4] != null){
											codigoSetorComercial = (Integer) arrayDadosPagamento[4];
										}else{
											codigoSetorComercial = 0;
										}
									}

									// ID DA ROTA
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[5] != null){
											rota = new Rota();
											rota.setId((Integer) arrayDadosPagamento[5]);
										}else{
											rota = null;
										}
									}

									// ID QUADRA
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[6] != null){
											quadra = new Quadra();
											quadra.setId((Integer) arrayDadosPagamento[6]);
										}else{
											quadra = null;
										}
									}

									// NUMERO QUADRA
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[7] != null){
											numeroQuadra = (Integer) arrayDadosPagamento[7];
										}else{
											numeroQuadra = 0;
										}
									}

									// ID IMOVEL PERFIL
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[8] != null){
											perfilImovel = new ImovelPerfil();
											perfilImovel.setId((Integer) arrayDadosPagamento[8]);
										}else{
											perfilImovel = null;
										}
									}

									// ID LIGACAO AGUA SITUACAO
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[9] != null){
											situacaoLigacaoAgua = new LigacaoAguaSituacao();
											situacaoLigacaoAgua.setId((Integer) arrayDadosPagamento[9]);
										}else{
											situacaoLigacaoAgua = null;
										}
									}

									// ID LIGACAO ESGOTO SITUACAO
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[10] != null){
											situacaoLigacaoEsgoto = new LigacaoEsgotoSituacao();
											situacaoLigacaoEsgoto.setId((Integer) arrayDadosPagamento[10]);
										}else{
											situacaoLigacaoEsgoto = null;
										}
									}

									// ID GERENCIA REGIONAL
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[11] != null){
											gerenciaRegional = new GerenciaRegional();
											gerenciaRegional.setId((Integer) arrayDadosPagamento[11]);
										}else{
											gerenciaRegional = null;
										}
									}

									// ID AVISO BANCARIO
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[12] != null){
											avisoBancario = new AvisoBancario();
											avisoBancario.setId((Integer) arrayDadosPagamento[12]);
										}else{
											avisoBancario = null;
										}
									}

									// ID ARRECADADOR
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[13] != null){
											arrecadador = new Arrecadador();
											arrecadador.setId((Integer) arrayDadosPagamento[13]);
										}else{
											arrecadador = null;
										}
									}

									// ID DOCUMENTO TIPO
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[14] != null){
											documentoTipo = new DocumentoTipo();
											documentoTipo.setId((Integer) arrayDadosPagamento[14]);
										}else{
											documentoTipo = null;
										}
									}

									// ID ARRECADACAO FORMA
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[15] != null){
											arrecadacaoForma = new ArrecadacaoForma();
											arrecadacaoForma.setId((Integer) arrayDadosPagamento[15]);
										}else{
											arrecadacaoForma = null;
										}
									}

									// DATA DO PAGAMENTO
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[16] != null){
											dataPagamento = (Date) arrayDadosPagamento[16];
										}else{
											dataPagamento = null;
										}
									}

									// ID UNIDADE DE NEGOCIO
									if(arrayDadosPagamento != null){
										if(arrayDadosPagamento[17] != null){
											unidadeNegocio = new UnidadeNegocio();
											unidadeNegocio.setId((Integer) arrayDadosPagamento[17]);
										}else{
											unidadeNegocio = null;
										}
									}

									// Caso o imóvel esteja preenchido no pagamento
									if(imovel != null){

										// [UC0306] Obter principal categoria do imóvel
										principalCategoria = getControladorImovel().obterPrincipalCategoriaImovel(imovel.getId());

										Integer idEsferaPoder = repositorioArrecadacao
														.pesquisarEsferaPoderClienteResponsavelPeloImovel(imovel.getId());

										if(idEsferaPoder != null){
											esferaPoder = new EsferaPoder();
											esferaPoder.setId(idEsferaPoder);
										}else{
											esferaPoder = null;
										}

										// [UC0307] - Obter Indicador de Existência de Hidrômetro
										String indicadorHidrometroString = Integer.valueOf(
														getControladorImovel().obterIndicadorExistenciaHidrometroImovel(imovel.getId()))
														.toString();
										indicadorHidrometro = Short.valueOf(indicadorHidrometroString);
									}

									// Caso indicador de hidrômetro esteja nulo
									// Seta 2(dois) = NÃO no indicador de hidrômetro
									if(indicadorHidrometro == null){
										indicadorHidrometro = Short.valueOf("2");
									}

									// Cria o objeto ArrecadacaoDadosDiarios e seta os dados
									// necessários para inclusão
									arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();
									arrecadacaoDadosDiarios.setAnoMesReferenciaArrecadacao(anoMesArrecadacaoAtual);
									arrecadacaoDadosDiarios.setArrecadador(arrecadador);
									arrecadacaoDadosDiarios.setUnidadeNegocio(unidadeNegocio);
									arrecadacaoDadosDiarios.setGerenciaRegional(gerenciaRegional);
									arrecadacaoDadosDiarios.setLocalidade(localidade);
									arrecadacaoDadosDiarios.setSetorComercial(setorComercial);
									arrecadacaoDadosDiarios.setRota(rota);
									arrecadacaoDadosDiarios.setQuadra(quadra);
									arrecadacaoDadosDiarios.setCodigoSetorComercial(codigoSetorComercial);
									arrecadacaoDadosDiarios.setNumeroQuadra(numeroQuadra);
									arrecadacaoDadosDiarios.setImovelPerfil(perfilImovel);
									arrecadacaoDadosDiarios.setLigacaoAguaSituacao(situacaoLigacaoAgua);
									arrecadacaoDadosDiarios.setLigacaoEsgotoSituacao(situacaoLigacaoEsgoto);
									arrecadacaoDadosDiarios.setCategoria(principalCategoria);
									arrecadacaoDadosDiarios.setEsferaPoder(esferaPoder);
									arrecadacaoDadosDiarios.setIndicadorHidrometro(indicadorHidrometro);
									arrecadacaoDadosDiarios.setDocumentoTipo(documentoTipo);
									arrecadacaoDadosDiarios.setArrecadacaoForma(arrecadacaoForma);
									arrecadacaoDadosDiarios.setDataPagamento(dataPagamento);
									arrecadacaoDadosDiarios.setQuantidadePagamentos(quantidadePagamento.intValue());
									arrecadacaoDadosDiarios.setValorPagamentos(somaValorPagamento);

									colecaoDadosDiariosArrecadacaoInserir.add(arrecadacaoDadosDiarios);
								}
							}
						}
					}
					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDadosDiariosArrecadacaoInserir);
					colecaoDadosDiariosArrecadacaoInserir = null;
				}
			}

			// --------------------------------------------------------
			// Registrar o fim da execução da Unidade de Processamento
			// --------------------------------------------------------

			concluiuComSucesso = true;

			// Erro no repositório
		}catch(Exception e){

			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			sessionContext.setRollbackOnly();
			throw new EJBException(e);

		}finally{
			if(concluiuComSucesso){
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
			}
		}
	}

	/**
	 * Este caso de uso permite classificar os pagamentos e as devoluções
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Vitor Hora
	 * @date 18/04/2006, 06/12/2006, 08/10/2008
	 * @author Saulo Lima
	 * @date 08/11/2008
	 *       Funcionamento on-line
	 * @author Saulo Lima
	 * @date 04/08/2009
	 *       Novos parâmetros ao pesquisar DébitosACobrar e GuiasPagamento
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Melhorando o desempenho do Classificar
	 * @param Pagamento
	 * @return Collection<Pagamento>
	 * @deprecated
	 */
	public Collection<Pagamento> classificarPagamentos(Pagamento pagamento) throws ControladorException{

		Collection<Pagamento> retorno = new ArrayList<Pagamento>();
		try{
			// Cria as variáveis para classificar os pagamentos
			Integer idLocalidade = pagamento.getLocalidade().getId();

			// Object[] arrayDadosProcessarGuiasPagamento = null;

			// 2. Para o pagamento com matrícula do imóvel (IMOV_ID) e ano/mês de referência do
			// pagamento (PGMT_AMREFERENCIAPAGAMENTO) diferentes de nulo:
			// Solicitado pelo analista Alessandro pra verificar se DocumentoTipo é 'conta' ou
			// 'fatura de cliente responsável'.
			// Saulo Lima - 07/04/2009
			if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)
							|| pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.FATURA_CLIENTE)){
				if(pagamento.getImovel().getId() != null && pagamento.getAnoMesReferenciaPagamento() != null){

					Imovel imovel = pagamento.getImovel();

					/*
					 * O sistema seleciona os pagamentos com ano/mês de referência da arrecadação
					 * igual o ano/mês de referência da arrecadação
					 * corrente (seleciona a partir da tabela PAGAMENTO para
					 * PGMT_AMREFERENCIAARRECADACAO igual ou menor ao
					 * PARM_AMREFERENCIAARRECADACAO)
					 */
					Collection<Object[]> colecaoPagamentosConta = repositorioArrecadacao.pesquisarPagamentosPorConta(imovel.getId(),
									pagamento.getAnoMesReferenciaPagamento());

					Collection<Integer> idsDebitoACobrar = new ArrayList<Integer>();

					/*
					 * Caso a pesquisa de pagamentos para conta do imóvel informado e com o ano/mês
					 * de arrecadação do pagamento não esteja nula
					 * Classifica os pagamentos selecionados.
					 */
					if(colecaoPagamentosConta != null && !colecaoPagamentosConta.isEmpty()){

						retorno.addAll(this.classificarPagamentosConta(colecaoPagamentosConta, imovel));
					}

					if(!Util.isVazioOrNulo(idsDebitoACobrar)){
						Collection<DebitoACobrar> colecao = repositorioFaturamento.pesquisarDebitoACobrar(idsDebitoACobrar);
						for(DebitoACobrar debitoACobrar : colecao){
							this.getControladorContabil().registrarLancamentoContabil(debitoACobrar,
											OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);
						}
					}
				}

			}else if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.GUIA_PAGAMENTO)){

				Collection colecaoPagamentosGuiaPagamentoPreenchida = null;
				Collection colecaoPagamentosGuiaPagamentoNaoPreenchida = null;

				GuiaPagamento guiaPagamento = null;
				GuiaPagamentoHistorico guiaPagamentoHistorico = null;

				if(pagamento.getGuiaPagamentoGeral() != null){

					Object retornoPesquisa = this.selecionarGuiaPagamento(pagamento.getGuiaPagamentoGeral().getId());

					if(retornoPesquisa instanceof GuiaPagamento){
						guiaPagamento = (GuiaPagamento) retornoPesquisa;
					}else if(retornoPesquisa instanceof GuiaPagamentoHistorico){
						guiaPagamentoHistorico = (GuiaPagamentoHistorico) retornoPesquisa;
					}
					if(guiaPagamento != null){
						// Pesquisa as coleções de pagamentos para guia de pagamento e para
						// pagamentos de débito a cobrar para classificar.
						if(pagamento.getGuiaPagamentoGeral().getGuiaPagamento() != null && pagamento.getNumeroPrestacao() != null){

							colecaoPagamentosGuiaPagamentoPreenchida = repositorioArrecadacao
											.pesquisarPagamentosPorGuiaPagamentoComGuiaInformada(idLocalidade, pagamento
															.getGuiaPagamentoGeral().getGuiaPagamento().getId(),
															pagamento.getNumeroPrestacao());
						}

						if(pagamento.getImovel() != null && pagamento.getImovel().getId() != null){
							colecaoPagamentosGuiaPagamentoNaoPreenchida = repositorioArrecadacao
											.pesquisarPagamentosPorGuiaPagamentoSemGuiaInformada(idLocalidade, pagamento.getImovel()
															.getId(), null);
						}else if(pagamento.getCliente() != null && pagamento.getCliente().getId() != null){
							colecaoPagamentosGuiaPagamentoNaoPreenchida = repositorioArrecadacao
											.pesquisarPagamentosPorGuiaPagamentoSemGuiaInformada(idLocalidade, null, pagamento.getCliente()
															.getId());
						}
					}else if(guiaPagamentoHistorico != null){

						colecaoPagamentosGuiaPagamentoPreenchida = repositorioArrecadacao.pesquisarPagamentosPorGuiaPagamentoHistorico(
										idLocalidade, pagamento.getGuiaPagamentoGeral().getGuiaPagamentoHistorico().getId(),
										pagamento.getNumeroPrestacao(), pagamento.getAvisoBancario().getId());

					}

				}

				if((colecaoPagamentosGuiaPagamentoPreenchida != null && !colecaoPagamentosGuiaPagamentoPreenchida.isEmpty())
								|| (colecaoPagamentosGuiaPagamentoNaoPreenchida != null && !colecaoPagamentosGuiaPagamentoNaoPreenchida
												.isEmpty())){

					Collection<Integer> idsDebitoACobrar = new ArrayList<Integer>();

					// Para os pagamentos com tipo de documento (DOPT_ID) com o valor correspondente
					// a GUIA DE PAGAMENTO:
					retorno.addAll(this.classificarPagamentosGuiaPagamento(colecaoPagamentosGuiaPagamentoPreenchida,
									colecaoPagamentosGuiaPagamentoNaoPreenchida, pagamento));

					if(!Util.isVazioOrNulo(idsDebitoACobrar)){
						Collection<DebitoACobrar> colecao = repositorioFaturamento.pesquisarDebitoACobrar(idsDebitoACobrar);
						for(DebitoACobrar debitoACobrar : colecao){
							this.getControladorContabil().registrarLancamentoContabil(debitoACobrar,
											OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);
						}
					}
				}

			}else if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.DEBITO_A_COBRAR)){

				DebitoACobrar debitoACobrar = null;
				DebitoACobrarHistorico debitoACobrarHistorico = null;
				Collection colecaoPagamentosDebitoACobrarPreenchido = null;
				Collection colecaoPagamentosDebitoACobrarNaoPreenchido = null;

				if(pagamento.getImovel() != null && pagamento.getDebitoTipo() != null){

					Object retornoPesquisa = this.selecionarDebitoACobrar(pagamento.getImovel().getId(), pagamento.getDebitoTipo().getId());

					if(retornoPesquisa instanceof DebitoACobrar){
						debitoACobrar = (DebitoACobrar) retornoPesquisa;
					}else if(retornoPesquisa instanceof DebitoACobrarHistorico){
						debitoACobrarHistorico = (DebitoACobrarHistorico) retornoPesquisa;
					}
				}
				if(debitoACobrar != null){

					// Para os pagamentos com tipo de documento (DOPT_ID) com o valor correspondente
					// a DÉBITO A COBRAR:
					colecaoPagamentosDebitoACobrarPreenchido = repositorioArrecadacao
									.pesquisarPagamentosPorDebitoACobrarComDebitoInformado(idLocalidade, pagamento.getImovel().getId(),
													pagamento.getNumeroPrestacao());

					// colecaoPagamentosDebitoACobrarNaoPreenchido =
					// repositorioArrecadacao.pesquisarPagamentosPorDebitoACobrarSemDebitoInformada(
					// idLocalidade, pagamento.getImovel().getId());

				}else if(debitoACobrarHistorico != null){

					colecaoPagamentosDebitoACobrarNaoPreenchido = repositorioArrecadacao
									.pesquisarPagamentosPorDebitoACobrarSemDebitoInformada(idLocalidade, pagamento.getImovel().getId());

				}

				if((colecaoPagamentosDebitoACobrarPreenchido != null && !colecaoPagamentosDebitoACobrarPreenchido.isEmpty())
								|| (colecaoPagamentosDebitoACobrarNaoPreenchido != null && !colecaoPagamentosDebitoACobrarNaoPreenchido
												.isEmpty())){

					retorno.addAll(this.classificarPagamentosDebitoACobrar(colecaoPagamentosDebitoACobrarPreenchido,
									colecaoPagamentosDebitoACobrarNaoPreenchido, pagamento));
				}
			}

			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, pagamento.getId()));
			Collection<Pagamento> colecaoPagamentoTemp = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

			if(colecaoPagamentoTemp != null && !colecaoPagamentoTemp.isEmpty()){

				// Caso o situação do pagamento seja "valor a baixa", mandar pagamento pra histórico
				if(pagamento.getPagamentoSituacaoAtual() != null
								&& pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR)){

					Collection colecaoPagamentoBaixar = new ArrayList<Pagamento>();
					colecaoPagamentoBaixar.add(pagamento);

					Collection colecaoPagamentoHistorico = this.criarPagamentoHistoricoDoPagamento(colecaoPagamentoBaixar,
									PagamentoSituacao.VALOR_A_BAIXAR);

					// remover os Pagamentos
					this.getControladorBatch().removerColecaoObjetoParaBatch(colecaoPagamentoBaixar);

					// inserir os PagamentosHistorico
					this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoPagamentoHistorico);

					retorno.addAll(colecaoPagamentoBaixar);

				}
			}

		}catch(ErroRepositorioException e){
			// Este catch serve para interceptar qualquer exceção que o processo venha a lançar
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * @author Bruno Ferreira dos Santos
	 * @param pagamento
	 * @return
	 * @throws ControladorException
	 */
	private Pagamento classificarPagamentosPreParcelamento(Pagamento pagamento) throws ControladorException{

		PreParcelamentoOpcao preParcelamentoOpcao = getControladorCobranca().obterPreParcelamentoOpcao(
						pagamento.getPreParcelamentoOpcao().getId());
		if(preParcelamentoOpcao != null){

			SistemaParametro sistemaParametros = null;
			sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();
			String anoMesArrecadacao = sistemaParametros.getAnoMesArrecadacao() + "";

			Collection<CobrancaDocumentoItem> colCobDocItem = getControladorCobranca().obterCobrancaDocumentoItemPrePacelamento(
							preParcelamentoOpcao.getPreParcelamento().getDocumentoCobranca());

			Iterator<CobrancaDocumentoItem> itCobDocItem = colCobDocItem.iterator();

			BigDecimal valorRestanteACobrar = BigDecimal.ZERO;
			BigDecimal valorTotalRestanteServicosACobrarCurtoPrazo = BigDecimal.ZERO;
			BigDecimal valorTotalRestanteServicosACobrarLongoPrazo = BigDecimal.ZERO;
			BigDecimal valorTotalRestanteParcelamentosACobrarCurtoPrazo = BigDecimal.ZERO;
			BigDecimal valorTotalRestanteParcelamentosACobrarLongoPrazo = BigDecimal.ZERO;
			final int indiceCurtoPrazo = 0;
			final int indiceLongoPrazo = 1;

			// ******* Campanha Parcelamento date 23/08/2011 ******************
			BigDecimal valorAtualizacaoMonetaria = BigDecimal.ZERO;
			BigDecimal valorJurosMora = BigDecimal.ZERO;
			// *********** date 23/08/2011 ************************************

			PagamentoSituacao pagamentoSituacao = new PagamentoSituacao();
			pagamentoSituacao.setId(PagamentoSituacao.VALOR_NAO_CONFERE);

			Collection<DebitoACobrar> debitosACobrar = new ArrayList<DebitoACobrar>();
			Collection<CreditoARealizar> creditosARealizar = new ArrayList<CreditoARealizar>();
			Collection<ContaValoresHelper> contasValoresHelper = new ArrayList<ContaValoresHelper>();
			Collection<GuiaPagamentoValoresHelper> guiasPagamentosValoresHelper = new ArrayList<GuiaPagamentoValoresHelper>();
			BigDecimal valorJurosParcelamento = BigDecimal.ZERO;

			while(itCobDocItem.hasNext()){
				CobrancaDocumentoItem cobrancaDocumentoItem = itCobDocItem.next();

				if(cobrancaDocumentoItem.getContaGeral() != null){

					Conta conta = cobrancaDocumentoItem.getContaGeral().getConta();
					if(conta != null){
						if(conta.getValorTotal().equals(cobrancaDocumentoItem.getValorItemCobrado().setScale(2))){

							// ******* Campanha Parcelamento date 23/08/2011 ******************
							// Calcula o valor das multas cobradas para a conta
							BigDecimal valorMultasCobradas = null;
							valorMultasCobradas = getControladorFaturamento().pesquisarValorMultasCobradas(conta.getId());

							CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidade = null;

							calcularAcrescimoPorImpontualidade = this.getControladorCobranca()
											.calcularAcrescimoPorImpontualidadeBancoDeDados(conta.getReferencia(),
															conta.getDataVencimentoConta(), pagamento.getDataPagamento(),
															conta.getValorTotal(), valorMultasCobradas, conta.getIndicadorCobrancaMulta(),
															anoMesArrecadacao, conta.getId(), null, null, ConstantesSistema.SIM,
															ConstantesSistema.SIM, ConstantesSistema.SIM);

							// set os Valores
							if(calcularAcrescimoPorImpontualidade != null){

								// seta valor de atualizacao monetaria
								if(calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria() != null
												&& !calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria().equals("")){
									valorAtualizacaoMonetaria.setScale(Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO);
									valorAtualizacaoMonetaria = valorAtualizacaoMonetaria.add(calcularAcrescimoPorImpontualidade
													.getValorAtualizacaoMonetaria().setScale(Parcelamento.CASAS_DECIMAIS,
																	Parcelamento.TIPO_ARREDONDAMENTO));
								}

								// seta valor de juros mora
								if(calcularAcrescimoPorImpontualidade.getValorJurosMora() != null
												&& !calcularAcrescimoPorImpontualidade.getValorJurosMora().equals("")){
									valorJurosMora.setScale(Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO);
									valorJurosMora = valorJurosMora.add(calcularAcrescimoPorImpontualidade.getValorJurosMora().setScale(
													Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO));
								}

							}
							// *********** date 23/08/2011 ************************************

							ContaValoresHelper contaValoresHelper = new ContaValoresHelper();
							contaValoresHelper.setConta(conta);
							contaValoresHelper.setValorPago(pagamento.getValorPagamento());
							contaValoresHelper.setValorAtualizacaoMonetaria(preParcelamentoOpcao.getValorAtualizacaoMonetaria());
							contaValoresHelper.setValorJurosMora(preParcelamentoOpcao.getValorJurosMora());
							contaValoresHelper.setValorMulta(preParcelamentoOpcao.getValorMulta());

							contasValoresHelper.add(contaValoresHelper);

						}else{
							pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
							return pagamento;
						}
					}else{
						pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
						return pagamento;
					}

				}else if(cobrancaDocumentoItem.getGuiaPagamentoGeral() != null){

					GuiaPagamento guia = cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento();
					if(guia != null){
						BigDecimal valTotPrestacoes = BigDecimal.ZERO;

						if(guia.getGuiasPagamentoPrestacao() != null){
							Iterator it = guia.getGuiasPagamentoPrestacao().iterator();

							while(it.hasNext()){
								GuiaPagamentoPrestacao guiaPrestacao = (GuiaPagamentoPrestacao) it.next();
								if(guiaPrestacao.getComp_id().getGuiaPagamentoId()
												.equals(cobrancaDocumentoItem.getGuiaPagamentoGeral().getId())
												&& guiaPrestacao.getComp_id().getNumeroPrestacao().shortValue() == cobrancaDocumentoItem
																.getNumeroDaPrestacao()){
									valTotPrestacoes = valTotPrestacoes.add(guiaPrestacao.getValorPrestacao());
								}
							}
						}

						if(valTotPrestacoes.equals(cobrancaDocumentoItem.getValorItemCobrado())){
							GuiaPagamentoValoresHelper guiaPagamentoValoresHelper = new GuiaPagamentoValoresHelper();
							guiaPagamentoValoresHelper.setDataEmissao(new Date());
							guiaPagamentoValoresHelper.setDataVencimento(new Date());
							guiaPagamentoValoresHelper.setGuiaPagamentoPrestacoes(guia.getGuiasPagamentoPrestacao());
							guiaPagamentoValoresHelper.setIdGuiaPagamento(guia.getId());
							guiaPagamentoValoresHelper.setNumeroPrestacao(guia.getNumeroPrestacaoTotal());
							guiaPagamentoValoresHelper.setValorAtualizacaoMonetaria(preParcelamentoOpcao.getValorAtualizacaoMonetaria());
							guiaPagamentoValoresHelper.setValorJurosMora(preParcelamentoOpcao.getValorJurosMora());
							guiaPagamentoValoresHelper.setValorMulta(preParcelamentoOpcao.getValorMulta());
							guiaPagamentoValoresHelper.setValorPago(pagamento.getValorPagamento());

							guiasPagamentosValoresHelper.add(guiaPagamentoValoresHelper);

							// *********** date 23/08/2011 ************************************
							if(guia.getGuiasPagamentoPrestacao() != null){
								Iterator it = guia.getGuiasPagamentoPrestacao().iterator();

								while(it.hasNext()){
									GuiaPagamentoPrestacao guiaPrestacao = (GuiaPagamentoPrestacao) it.next();

									CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidade = this
													.getControladorCobranca().calcularAcrescimoPorImpontualidadeBancoDeDados(
																	guiaPrestacao.getAnoMesReferenciaFaturamento(),
																	guiaPrestacao.getDataVencimento(), pagamento.getDataPagamento(),
																	valTotPrestacoes, BigDecimal.ZERO,
																	guiaPrestacao.getIndicadorCobrancaMulta().shortValue(),
																	anoMesArrecadacao, null, null, null, ConstantesSistema.SIM,
																	ConstantesSistema.SIM, ConstantesSistema.SIM);

									// set os Valores
									if(calcularAcrescimoPorImpontualidade != null){

										// seta valor de juros mora
										valorJurosMora.setScale(Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO);
										valorJurosMora = valorJurosMora.add(calcularAcrescimoPorImpontualidade.getValorJurosMora());

										// seta valor de atualizacao monetaria
										valorAtualizacaoMonetaria.setScale(Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO);
										valorAtualizacaoMonetaria = valorAtualizacaoMonetaria.add(calcularAcrescimoPorImpontualidade
														.getValorAtualizacaoMonetaria());
									}
								}
							}
							// *********** date 23/08/2011 ************************************

						}else{
							pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
							return pagamento;
						}
					}else{
						pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
						return pagamento;
					}
				}else if(cobrancaDocumentoItem.getDebitoACobrarGeral() != null){

					DebitoACobrar debitoACobrar = cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar();

					if(debitoACobrar != null){

						BigDecimal valorDebitoTotal = debitoACobrar.getValorDebito().setScale(Parcelamento.CASAS_DECIMAIS);
						BigDecimal valorDebitoPrestacao = valorDebitoTotal.divide(new BigDecimal(debitoACobrar.getNumeroPrestacaoDebito()),
										Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO);
						BigDecimal valorDebitoRestante = valorDebitoPrestacao.multiply(new BigDecimal(debitoACobrar
										.getNumeroPrestacaoDebito()).subtract(new BigDecimal(debitoACobrar.getNumeroPrestacaoCobradas())));

						if((valorDebitoTotal.compareTo(cobrancaDocumentoItem.getValorItemCobrado()) == 0)
										|| (valorDebitoPrestacao.compareTo(cobrancaDocumentoItem.getValorItemCobrado()) == 0)
										|| (valorDebitoRestante.compareTo(cobrancaDocumentoItem.getValorItemCobrado()) == 0)){

							if(!debitosACobrar.contains(debitoACobrar)){
								debitosACobrar.add(debitoACobrar);
							}

							if(debitoACobrar.getDebitoTipo().getId() != null
											&& !debitoACobrar.getDebitoTipo().getId().equals(DebitoTipo.JUROS_SOBRE_PARCELAMENTO)){

								if(valorRestanteACobrar.compareTo(debitoACobrar.getValorTotal()) != 0){
									// Debitos A Cobrar - Serviço
									if(debitoACobrar.getFinanciamentoTipo().getId().equals(FinanciamentoTipo.SERVICO_NORMAL)){
										// [SB0001] Obter Valores de Curto e Longo Prazo
										valorRestanteACobrar = debitoACobrar.getValorTotal();

										BigDecimal[] valoresDeCurtoELongoPrazo = getControladorFaturamento()
														.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
																		debitoACobrar.getNumeroPrestacaoCobradas(), valorRestanteACobrar);
										valorTotalRestanteServicosACobrarCurtoPrazo.setScale(Parcelamento.CASAS_DECIMAIS,
														Parcelamento.TIPO_ARREDONDAMENTO);
										valorTotalRestanteServicosACobrarCurtoPrazo = valorTotalRestanteServicosACobrarCurtoPrazo
														.add(valoresDeCurtoELongoPrazo[indiceCurtoPrazo]);
										valorTotalRestanteServicosACobrarLongoPrazo.setScale(Parcelamento.CASAS_DECIMAIS,
														Parcelamento.TIPO_ARREDONDAMENTO);
										valorTotalRestanteServicosACobrarLongoPrazo = valorTotalRestanteServicosACobrarLongoPrazo
														.add(valoresDeCurtoELongoPrazo[indiceLongoPrazo]);
									}

									// Debitos A Cobrar - Parcelamento

									Collection<Integer> tiposParcelamento = Util
													.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO
																	.executar());

									if(tiposParcelamento != null
													&& tiposParcelamento.contains(debitoACobrar.getFinanciamentoTipo().getId())){

										// [SB0001] Obter Valores de Curto e Longo Prazo
										valorRestanteACobrar = debitoACobrar.getValorTotal();

										BigDecimal[] valoresDeCurtoELongoPrazo = getControladorFaturamento()
														.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
																		debitoACobrar.getNumeroPrestacaoCobradas(), valorRestanteACobrar);
										valorTotalRestanteParcelamentosACobrarCurtoPrazo.setScale(Parcelamento.CASAS_DECIMAIS,
														Parcelamento.TIPO_ARREDONDAMENTO);
										valorTotalRestanteParcelamentosACobrarCurtoPrazo = valorTotalRestanteParcelamentosACobrarCurtoPrazo
														.add(valoresDeCurtoELongoPrazo[indiceCurtoPrazo]);
										valorTotalRestanteParcelamentosACobrarLongoPrazo.setScale(Parcelamento.CASAS_DECIMAIS,
														Parcelamento.TIPO_ARREDONDAMENTO);
										valorTotalRestanteParcelamentosACobrarLongoPrazo = valorTotalRestanteParcelamentosACobrarLongoPrazo
														.add(valoresDeCurtoELongoPrazo[indiceLongoPrazo]);
									}
								}
							}else if(debitoACobrar.getDebitoTipo().getId() != null
											&& debitoACobrar.getDebitoTipo().getId().equals(DebitoTipo.JUROS_SOBRE_PARCELAMENTO)){
								valorJurosParcelamento = debitoACobrar.getValorTotal();
							}

						}else{
							pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
							return pagamento;
						}
					}else{
						pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
						return pagamento;
					}

				}else if(cobrancaDocumentoItem.getCreditoARealizarGeral() != null){

					CreditoARealizar creditoARealizar = cobrancaDocumentoItem.getCreditoARealizarGeral().getCreditoARealizar();

					if(creditoARealizar != null){

						BigDecimal valorCredito = creditoARealizar.getValorCredito();

						if(valorCredito.equals(cobrancaDocumentoItem.getValorItemCobrado())){
							if(!creditosARealizar.contains(creditoARealizar)){
								creditosARealizar.add(creditoARealizar);
							}
						}else{
							pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
							return pagamento;
						}
					}else{
						pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
						return pagamento;
					}

				}

			}

			if((contasValoresHelper != null && !contasValoresHelper.isEmpty())
							|| (guiasPagamentosValoresHelper != null && !guiasPagamentosValoresHelper.isEmpty())
							|| (debitosACobrar != null && !debitosACobrar.isEmpty())
							|| (creditosARealizar != null && !creditosARealizar.isEmpty())){

				BigDecimal valorASerNegociado = preParcelamentoOpcao
								.getPreParcelamento()
								.getValorDebitoAtualizado()
								.subtract(preParcelamentoOpcao.getValorDescontosAcrescimosImpontualidade()
												.add(preParcelamentoOpcao.getValorDescontosAcrescimosAntiguidade())
												.add(preParcelamentoOpcao.getValorDescontosAcrescimosInatividade())
												.add(valorJurosParcelamento));

				BigDecimal valorASerParcelado = preParcelamentoOpcao.getValorPrestacao()
								.multiply(new BigDecimal(preParcelamentoOpcao.getNumeroPrestacoes()))
								.add(preParcelamentoOpcao.getValorEntrada());

				Imovel imovel = getControladorImovel().pesquisarImovel(pagamento.getImovel().getId());

				BigDecimal valorTotalRestanteParcelamentosACobrar = BigDecimal.ZERO;
				BigDecimal valorTotalRestanteServicosACobrar = BigDecimal.ZERO;

				valorTotalRestanteServicosACobrar.setScale(Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO);
				valorTotalRestanteServicosACobrar = valorTotalRestanteServicosACobrarCurtoPrazo
								.add(valorTotalRestanteServicosACobrarLongoPrazo);

				valorTotalRestanteParcelamentosACobrar.setScale(Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO);
				valorTotalRestanteParcelamentosACobrar = valorTotalRestanteParcelamentosACobrarCurtoPrazo
								.add(valorTotalRestanteParcelamentosACobrarLongoPrazo);

				// Caso tenha feito o pacelamento
				Integer parcelamentoId = null;

				if(preParcelamentoOpcao.getValorPrestacao().compareTo(BigDecimal.ZERO) == 0){
					// se a parcela for igual a zero entao pague a vista.

					Collection<Categoria> colecaoCategoria = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

					Usuario usuario = new Usuario();
					usuario.setId(Usuario.ID_USUARIO_ADM_SISTEMA);

					getControladorCobranca().classificarContasParaHistorico(contasValoresHelper, usuario, "2");

					getControladorCobranca().classificarGuiaPagamentoParaHistorico(guiasPagamentosValoresHelper,
									preParcelamentoOpcao.getPreParcelamento().getIndicadorGuiasPagamento().toString());

					// Debito a cobrar help para atualização do novo débito referente ao
					// parcelamento.
					Collection<DebitoACobrar> colecaoDebitoACobrarHelp = new ArrayList<DebitoACobrar>();

					Collection<DebitoACobrar> colecaoDebitoACobrarTemp = new ArrayList<DebitoACobrar>();
					Map debitoACobrarValorDivida = new HashMap();

					getControladorCobranca().classificarDebitoACobrarParaHistorico(debitosACobrar,
									preParcelamentoOpcao.getPreParcelamento().getIndicadorDebitoACobrar().toString(), sistemaParametros,
									colecaoDebitoACobrarHelp, colecaoDebitoACobrarTemp, debitoACobrarValorDivida);

					Collection<CreditoARealizar> colecaoCreditoARealizarParaAtualizacao = getControladorCobranca()
									.classificarCreditoARealizarParaHistorico(creditosARealizar,
													preParcelamentoOpcao.getPreParcelamento().getIndicadorCreditoARealizar().toString(),
													sistemaParametros);

					// 6.1.5.4. O sistema transfere para o histórico de créditos
					// a realizar, os créditos a realizar que foram parcelados
					getControladorFaturamento().transferirCreditoARealizarParaHistorico(colecaoCreditoARealizarParaAtualizacao);

					// 6.1.5.5. Para cada crédito a realizar transferido,
					// atualiza o indicador de que o crédito a realizar está no
					// histórico
					getControladorFaturamento().atualizarIndicadorCreditosARealizarNoHistorico(colecaoCreditoARealizarParaAtualizacao);

					getControladorCobranca().classificarDebitoACobrarTempParaHistorico(colecaoDebitoACobrarTemp, debitoACobrarValorDivida,
									null);

					// ****************************************************
					// desconto
					BigDecimal valorDescontos = (preParcelamentoOpcao.getValorDescontosAcrescimosAntiguidade() != null ? preParcelamentoOpcao
									.getValorDescontosAcrescimosAntiguidade() : BigDecimal.ZERO)
									.add(preParcelamentoOpcao.getValorDescontosAcrescimosImpontualidade() != null ? preParcelamentoOpcao
													.getValorDescontosAcrescimosImpontualidade() : BigDecimal.ZERO)
									.add(preParcelamentoOpcao.getValorDescontosAcrescimosInatividade() != null ? preParcelamentoOpcao
													.getValorDescontosAcrescimosInatividade() : BigDecimal.ZERO)
									.add(preParcelamentoOpcao.getValorDescontoSancoesRDEspecial() != null ? preParcelamentoOpcao
													.getValorDescontoSancoesRDEspecial() : BigDecimal.ZERO);

					// divida total
					BigDecimal dividaTotal = preParcelamentoOpcao.getPreParcelamento().getValorDebitoAtualizado();

					// valor total a pagar se o cliente escolher essa opção de
					// parcelamento
					BigDecimal valorTotalOpcaoParcelamentoAPagar = BigDecimal.ZERO;

					valorTotalOpcaoParcelamentoAPagar = dividaTotal.subtract(valorDescontos);
					// ****************************************************

					Map<Integer, Map<LancamentoItemContabilParcelamentoHelper, Map<Categoria, BigDecimal>>> mapaValorEntradaPorTipoDebito = getValorEntradaPorTipoDebito(
									colecaoCategoria, valorTotalOpcaoParcelamentoAPagar);

					if(mapaValorEntradaPorTipoDebito != null && !mapaValorEntradaPorTipoDebito.isEmpty()){

						getControladorCobranca().gerarEntradaParcelamento(imovel, mapaValorEntradaPorTipoDebito, null, null, usuario,
										pagamento, "2", "1", null, preParcelamentoOpcao.getNumeroDiasVencimentoDaEntrada(), new Date(),
										ConstantesSistema.NAO);
					}

					// getControladorCobranca().gerarEntradaParcelamento(imovel,
					// preParcelamentoOpcao.getValorEntrada(),
					// preParcelamentoOpcao.getValorJurosMora(), null, colecaoCategoria, null,
					// usuario, new Date(), pagamento);

					pagamentoSituacao.setId(PagamentoSituacao.VALOR_A_BAIXAR);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);

					inserirDebitoACobrarDiferencaValores(pagamento, preParcelamentoOpcao, valorAtualizacaoMonetaria, valorJurosMora,
									guiasPagamentosValoresHelper, parcelamentoId);

					return pagamento;
				}else{

					parcelamentoId = getControladorCobranca().concluirParcelamentoDebitos(
									contasValoresHelper,
									guiasPagamentosValoresHelper,
									debitosACobrar,
									creditosARealizar,
									preParcelamentoOpcao.getPreParcelamento().getIndicadorRestabelecimento().toString(),
									preParcelamentoOpcao.getPreParcelamento().getIndicadorContasRevisao().toString(),
									preParcelamentoOpcao.getPreParcelamento().getIndicadorGuiasPagamento().toString(),
									preParcelamentoOpcao.getPreParcelamento().getIndicadorAcrescimosImpontualdade().toString(),
									preParcelamentoOpcao.getPreParcelamento().getIndicadorDebitoACobrar().toString(),
									preParcelamentoOpcao.getPreParcelamento().getIndicadorCreditoARealizar().toString(),
									imovel,
									BigDecimal.ZERO,// preParcelamentoOpcao.getValorEntrada(),
									valorASerNegociado, valorASerParcelado, new Date(),
									preParcelamentoOpcao.getPreParcelamento().getValorConta(),
									preParcelamentoOpcao.getPreParcelamento().getValorGuiaPapagamento(), valorTotalRestanteServicosACobrar,
									valorTotalRestanteParcelamentosACobrar,
									preParcelamentoOpcao.getPreParcelamento().getValorCreditoARealizar(),
									preParcelamentoOpcao.getValorAtualizacaoMonetaria(),
									preParcelamentoOpcao.getPreParcelamento().getValorJurosMora(),
									preParcelamentoOpcao.getPreParcelamento().getValorMulta(),
									preParcelamentoOpcao.getPreParcelamento().getValorDebitoAtualizado(),
									preParcelamentoOpcao.getValorDescontosAcrescimosImpontualidade(),
									preParcelamentoOpcao.getValorDescontosAcrescimosAntiguidade(),
									preParcelamentoOpcao.getValorDescontosAcrescimosInatividade(),
									preParcelamentoOpcao.getPercentualDescontoAcrescimoImpontualidade(),
									preParcelamentoOpcao.getPercentualDescontoAntiguidade(),
									preParcelamentoOpcao.getPercentualDescontoInatividade(),
									preParcelamentoOpcao.getParcelamentoPerfil().getId(),
									preParcelamentoOpcao.getPreParcelamento().getValorDescontoAcrescimos(),
									valorTotalRestanteServicosACobrarLongoPrazo, valorTotalRestanteServicosACobrarCurtoPrazo,
									valorTotalRestanteParcelamentosACobrarLongoPrazo, valorTotalRestanteParcelamentosACobrarCurtoPrazo,
									preParcelamentoOpcao.getNumeroPrestacoes().shortValue(), preParcelamentoOpcao.getValorPrestacao(),
									preParcelamentoOpcao.getValorEntrada(), preParcelamentoOpcao.getValorJurosMora(), "1",
									preParcelamentoOpcao.getPreParcelamento().getDocumentoCobranca().getCliente(), Usuario.USUARIO_BATCH,
									"", preParcelamentoOpcao.getValorDescontoSancoesRDEspecial(),
									preParcelamentoOpcao.getValorDescontoTarifaSocialRDEspecial(), new Date(), pagamento,
									preParcelamentoOpcao.getNumeroMesesEntreParcelas(), preParcelamentoOpcao.getNumeroParcelasALancar(),
									preParcelamentoOpcao.getNumeroMesesInicioCobranca(), null, "1", "N",
									preParcelamentoOpcao.getNumeroDiasVencimentoDaEntrada(), "", null, null, null, null, null, null,
									valorASerParcelado, null);
					pagamentoSituacao.setId(PagamentoSituacao.VALOR_A_BAIXAR);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);

					inserirDebitoACobrarDiferencaValores(pagamento, preParcelamentoOpcao, valorAtualizacaoMonetaria, valorJurosMora,
									guiasPagamentosValoresHelper, parcelamentoId);

					return pagamento;
				}
			}else{
				pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);
			}

		}
		return pagamento;
	}

	/**
	 * Distribui o valor de entrada por TipoDebito, ItemContabil e Categoria
	 * 
	 * @author Luciano Galvao
	 * @date 31/10/2012
	 */
	private Map<Integer, Map<LancamentoItemContabilParcelamentoHelper, Map<Categoria, BigDecimal>>> getValorEntradaPorTipoDebito(
					Collection<Categoria> colecaoCategoria,
					BigDecimal valorEntrada) throws ControladorException{

		Map<Integer, Map<LancamentoItemContabilParcelamentoHelper, Map<Categoria, BigDecimal>>> mapaValorEntradaPorTipoDebito = new HashMap<Integer, Map<LancamentoItemContabilParcelamentoHelper, Map<Categoria, BigDecimal>>>();

		DebitoTipo debitoTipo = getControladorCobranca().filtrarDebitoTipo(DebitoTipo.ENTRADA_PARCELAMENTO);
		Integer idDebitoTipo = debitoTipo.getId();

		LancamentoItemContabil lancamentoItemContabil = debitoTipo.getLancamentoItemContabil();
		Integer idLancamentoItemContabil = lancamentoItemContabil.getId();

		// [UC0185] Obter Valor po Categoria
		Collection<BigDecimal> colecaoValorCategoria = this.getControladorImovel().obterValorPorCategoria(colecaoCategoria, valorEntrada);

		Iterator<BigDecimal> iteratorValorCategoria = colecaoValorCategoria.iterator();

		BigDecimal valorPorCategoria = BigDecimal.ZERO;
		Map<Categoria, BigDecimal> mapaValorPorCategoria = new HashMap<Categoria, BigDecimal>();

		for(Categoria categoria : colecaoCategoria){
			if(iteratorValorCategoria.hasNext()){
				valorPorCategoria = iteratorValorCategoria.next();
				mapaValorPorCategoria.put(categoria, valorPorCategoria);
			}
		}

		Map<LancamentoItemContabilParcelamentoHelper, Map<Categoria, BigDecimal>> mapaValorEntradaPorItemContabil = new HashMap<LancamentoItemContabilParcelamentoHelper, Map<Categoria, BigDecimal>>();

		if(!mapaValorPorCategoria.isEmpty()){

			LancamentoItemContabilParcelamentoHelper itemContabilHelper = new LancamentoItemContabilParcelamentoHelper(
							idLancamentoItemContabil, ConstantesSistema.NAO);
			mapaValorEntradaPorItemContabil.put(itemContabilHelper, mapaValorPorCategoria);
		}

		if(!mapaValorEntradaPorItemContabil.isEmpty()){
			mapaValorEntradaPorTipoDebito.put(idDebitoTipo, mapaValorEntradaPorItemContabil);
		}

		return mapaValorEntradaPorTipoDebito;
	}

	/**
	 * @author Isaac Silva
	 * @date 31/08/2011
	 * @param pagamento
	 * @param preParcelamentoOpcao
	 * @param valorAtualizacaoMonetaria
	 * @param valorJurosMora
	 * @param guiasPagamentosValoresHelper
	 * @param parcelamentoId
	 * @throws ControladorException
	 * @throws ControladorException
	 */
	private void inserirDebitoACobrarDiferencaValores(Pagamento pagamento, PreParcelamentoOpcao preParcelamentoOpcao,
					BigDecimal valorAtualizacaoMonetaria, BigDecimal valorJurosMora,
					Collection<GuiaPagamentoValoresHelper> guiasPagamentosValoresHelper, Integer parcelamentoId)
					throws ControladorException{

		if(guiasPagamentosValoresHelper != null){
			Collection<GuiaPagamentoValoresHelper> colecaoGuiaPagamentoValoresSelecionadas = guiasPagamentosValoresHelper;

			valorAtualizacaoMonetaria = valorAtualizacaoMonetaria.add(this.getControladorCobranca().calcularValoresGuia(
							colecaoGuiaPagamentoValoresSelecionadas, ConstantesSistema.PARCELAMENTO_VALOR_GUIA_ATUALIZACAO_MONETARIA));

			valorJurosMora = valorJurosMora.add(this.getControladorCobranca().calcularValoresGuia(colecaoGuiaPagamentoValoresSelecionadas,
							ConstantesSistema.PARCELAMENTO_VALOR_GUIA_JUROS_MORA));

		}

		BigDecimal valorAtualizacaoMonetariaAux = null;
		if(valorAtualizacaoMonetaria.compareTo(preParcelamentoOpcao.getPreParcelamento().getValorAtualizacaoMonetaria()) > 0){
			valorAtualizacaoMonetariaAux = valorAtualizacaoMonetaria.subtract(preParcelamentoOpcao.getPreParcelamento()
							.getValorAtualizacaoMonetaria());
		}

		BigDecimal valorJurosMoraAux = null;
		if(valorJurosMora.compareTo(preParcelamentoOpcao.getPreParcelamento().getValorJurosMora()) > 0){
			valorJurosMoraAux = valorJurosMora.subtract(preParcelamentoOpcao.getPreParcelamento().getValorJurosMora());
		}

		if(valorAtualizacaoMonetariaAux != null || valorJurosMoraAux != null){
			Collection<Categoria> colecaoCategoria = this.getControladorImovel().obterQuantidadeEconomiasCategoria(pagamento.getImovel());
			this.getControladorCobranca().gerarDebitosACobrarDiferencaEntreDebitos(pagamento.getImovel(), valorAtualizacaoMonetariaAux,
							valorJurosMoraAux, null, preParcelamentoOpcao.getValorJurosMora(), parcelamentoId, colecaoCategoria, true, 1,
							1, 1);
		}
	}

	/**
	 * Rotina para ajuste de caso errados na base OC1205061
	 * 
	 * @author Saulo Lima
	 * @since 11/12/2013
	 * @throws ControladorException
	 */
	public void classificarPagamentosAjuste() throws ControladorException{

		// Integer[] pagamentos1 = {...};
		// Integer[] pagamentos2 = {...};
		// Integer[] pagamentos3 = {...};
		// Integer[] pagamentos4 = {...};
		// Integer[] pagamentos5 = {...};
		// Integer[] pagamentos6 = {...};
		// Integer[] pagamentos7 = {...};
		// Integer[] pagamentos8 = {...};
		// Integer[] pagamentos9 = {...};
		// Integer[] pagamentos10 = {...};
		// Integer[] pagamentos11 = {...};
		// Integer[] pagamentos12 = {...};
		// Integer[] pagamentos13 = {...};
		// Integer[] pagamentos14 = {...};

		Collection<Integer[]> colecaoPag = new ArrayList<Integer[]>();
		// colecaoPag.add(pagamentos1);
		// colecaoPag.add(pagamentos2);
		// colecaoPag.add(pagamentos3);
		// colecaoPag.add(pagamentos4);
		// colecaoPag.add(pagamentos5);
		// colecaoPag.add(pagamentos6);
		// colecaoPag.add(pagamentos7);
		// colecaoPag.add(pagamentos8);
		// colecaoPag.add(pagamentos9);
		// colecaoPag.add(pagamentos10);
		// colecaoPag.add(pagamentos11);
		// colecaoPag.add(pagamentos12);
		// colecaoPag.add(pagamentos13);
		// colecaoPag.add(pagamentos14);

		Collection<Integer> idsPagamentos = null;
		try{
			idsPagamentos = this.repositorioArrecadacao.pesquisarClassificarPagamentosAjuste();
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

		int contadorColecao = 1;
		for(Integer idPagamento : idsPagamentos){

			System.out.println("### contagem = " + contadorColecao + "/" + idsPagamentos.size() + " :: idPagamento = " + idPagamento);

			FiltroPagamento filtro = new FiltroPagamento();
			filtro.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, idPagamento));
			Collection<Pagamento> colecaoPagamento = this.getControladorUtil().pesquisar(filtro, Pagamento.class.getName());

			Pagamento pagamento = (Pagamento) Util.retonarObjetoDeColecao(colecaoPagamento);

			if(pagamento != null){
				this.classificarPagamentosRegistroMovimentoArrecadadores(pagamento, null);
			}
			contadorColecao++;
		}

		int contadorExterno = 1;
		for(Integer[] pagamentos : colecaoPag){

			int contadorInterno = 1;
			for(Integer idPagamento : pagamentos){

				System.out.println("### contagem = " + contadorExterno + "/" + colecaoPag.size() + " " + contadorInterno + "/"
								+ pagamentos.length + " :: idPagamento = " + idPagamento);
				contadorInterno++;

				FiltroPagamento filtro = new FiltroPagamento();
				filtro.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, idPagamento));
				Collection<Pagamento> colecaoPagamento = this.getControladorUtil().pesquisar(filtro, Pagamento.class.getName());

				Pagamento pagamento = (Pagamento) Util.retonarObjetoDeColecao(colecaoPagamento);

				if(pagamento != null){
					this.classificarPagamentosRegistroMovimentoArrecadadores(pagamento, null);
				}
			}
			contadorExterno++;
		}
	}

	/**
	 * Encapsula a chamada ao método que classifica os pagamentos
	 * (classificarPagamentosRegistroMovimentoArrecadadores) sem a passagem do parâmetro
	 * colecaoClassificarPagamentosNaoClassificadosHelper, que é utilizado apenas pela
	 * funcionalidade de Classificar Lote de Pagamentos Não Classificados
	 * 
	 * @author Luciano Galvão
	 * @date 16/09/2013
	 */
	public void classificarPagamentosRegistroMovimentoArrecadadores(Pagamento pagamento) throws ControladorException{

		classificarPagamentosRegistroMovimentoArrecadadores(pagamento, null);
	}

	/**
	 * Classifica um pagamento
	 * 
	 * @date 06/10/2010
	 * @author jns
	 * @param pagamento
	 * @throws ControladorException
	 */
	private void classificarPagamentosRegistroMovimentoArrecadadores(Pagamento pagamento,
					Collection<ClassificarPagamentosNaoClassificadosHelper> colecaoClassificarPagamentosNaoClassificadosHelper)
					throws ControladorException{

		try{

			boolean pagamentoHistorico = true;

			// Cria as variáveis para classificar os pagamentos
			Integer idLocalidade = pagamento.getLocalidade().getId();
			Integer idGuiaPagamento = null;
			Integer idConta = null;
			Integer idDebitoACobrarGeral = null;
			
			Imovel imovel = pagamento.getImovel();

			Object contaAntesClassificacao = null;
			// Se o parâmetro
			if(colecaoClassificarPagamentosNaoClassificadosHelper != null){
				// [SB0001] Selecionar Conta pelo Imóvel e Ano/Mês de Referência
				contaAntesClassificacao = this.selecionarContaPorImovelAnoMesReferencia(imovel, pagamento.getAnoMesReferenciaPagamento());
			}

			// 2. Para o pagamento com matrícula do imóvel (IMOV_ID) e ano/mês
			// de referência do pagamento (PGMT_AMREFERENCIAPAGAMENTO)
			// diferentes de nulo:
			// Solicitado pelo analista Alessandro pra verificar se
			// DocumentoTipo é 'conta' ou 'fatura de cliente responsável'.
			// Saulo Lima - 07/04/2009
			if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)
							|| pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.FATURA_CLIENTE)){

				if(pagamento.getImovel() != null && pagamento.getImovel().getId() != null
								&& pagamento.getAnoMesReferenciaPagamento() != null){

					/*
					 * O sistema seleciona os pagamentos com ano/mês de
					 * referência da arrecadação igual o ano/mês de referência
					 * da arrecadação corrente (seleciona a partir da tabela
					 * PAGAMENTO para PGMT_AMREFERENCIAARRECADACAO igual ou
					 * menor ao PARM_AMREFERENCIAARRECADACAO)
					 */
					Collection<Pagamento> colecaoPagamentosConta = new ArrayList<Pagamento>();

					Collection<Object[]> resultado = repositorioArrecadacao.pesquisarPagamentosPorContaJDBC(imovel.getId(),
									pagamento.getAnoMesReferenciaPagamento());

					for(Object[] item : resultado){

						Pagamento pgto = new Pagamento();
						pgto.setId((Integer) item[0]);

						pgto.setImovel(imovel);

						pgto.setValorPagamento((BigDecimal) item[1]);

						PagamentoSituacao pgtoSit = null;
						if(item[2] != null){
							pgtoSit = new PagamentoSituacao();
							pgtoSit.setId((Integer) item[2]);
						}

						AvisoBancario avBnco = new AvisoBancario();
						avBnco.setId((Integer) item[3]);

						Conta cnta = null;
						if(item[4] != null){
							cnta = new Conta();
							cnta.setId((Integer) item[4]);
							idConta = (Integer) item[4];
						}

						DocumentoTipo docTipo = new DocumentoTipo();
						docTipo.setId((Integer) item[5]);

						pgto.setDataPagamento((Date) item[6]);
						pgto.setPagamentoSituacaoAtual(pgtoSit);
						pgto.setAvisoBancario(avBnco);
						pgto.setConta(cnta);
						pgto.setDocumentoTipo(docTipo);
						pgto.setAnoMesReferenciaArrecadacao((Integer) item[7]);

						colecaoPagamentosConta.add(pgto);
					}

					this.repositorioArrecadacao.atualizarIndicadorPagamentoConta(pagamento.getImovel().getId(),
									pagamento.getAnoMesReferenciaPagamento());

					/*
					 * Caso a pesquisa de pagamentos para conta do imóvel
					 * informado e com o ano/mês de arrecadação do pagamento não
					 * esteja nula Classifica os pagamentos selecionados.
					 */
					if(colecaoPagamentosConta != null && !colecaoPagamentosConta.isEmpty()){

						this.classificarPagamentosContaMovimentoArrecadadores(colecaoPagamentosConta, imovel,
										pagamento.getAnoMesReferenciaPagamento(), pagamento);

						colecaoPagamentosConta.clear();
						colecaoPagamentosConta = null;

					}
				}

			}else if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.CARTA_OPCAO_PARCELAMENTO)){
				// TODO Bruno Ferreira dos Santos
				// [UC0300] [5] - Carta com opções de pagamento.
				this.classificarPagamentosPreParcelamento(pagamento);

				pagamentoHistorico = false;
			}else if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.GUIA_PAGAMENTO)){

				Collection colecaoPagamentosGuiaPagamentoPreenchida = null;
				Collection colecaoPagamentosGuiaPagamentoNaoPreenchida = null;

				GuiaPagamento guiaPagamento = null;
				GuiaPagamentoHistorico guiaPagamentoHistorico = null;

				if(pagamento.getGuiaPagamentoGeral() != null){

					Object retornoPesquisa = this.selecionarGuiaPagamento(pagamento.getGuiaPagamentoGeral().getId());
					idGuiaPagamento = pagamento.getGuiaPagamentoGeral().getId();

					if(retornoPesquisa instanceof GuiaPagamento){
						guiaPagamento = (GuiaPagamento) retornoPesquisa;
					}else if(retornoPesquisa instanceof GuiaPagamentoHistorico){
						guiaPagamentoHistorico = (GuiaPagamentoHistorico) retornoPesquisa;
					}
					if(guiaPagamento != null){
						// Pesquisa as coleções de pagamentos para guia de
						// pagamento e para pagamentos de débito a cobrar para
						// classificar.
						if(pagamento.getGuiaPagamentoGeral().getGuiaPagamento() != null && pagamento.getNumeroPrestacao() != null){

							colecaoPagamentosGuiaPagamentoPreenchida = repositorioArrecadacao
											.pesquisarPagamentosPorGuiaPagamentoComGuiaInformada(idLocalidade, pagamento
															.getGuiaPagamentoGeral().getGuiaPagamento().getId(),
															pagamento.getNumeroPrestacao());

						}

						if(pagamento.getImovel() != null && pagamento.getImovel().getId() != null){
							colecaoPagamentosGuiaPagamentoNaoPreenchida = repositorioArrecadacao
											.pesquisarPagamentosPorGuiaPagamentoSemGuiaInformada(idLocalidade, pagamento.getImovel()
															.getId(), null);
						}else if(pagamento.getCliente() != null && pagamento.getCliente().getId() != null){
							colecaoPagamentosGuiaPagamentoNaoPreenchida = repositorioArrecadacao
											.pesquisarPagamentosPorGuiaPagamentoSemGuiaInformada(idLocalidade, null, pagamento.getCliente()
															.getId());
						}

					}else if(guiaPagamentoHistorico != null){

						colecaoPagamentosGuiaPagamentoPreenchida = repositorioArrecadacao.pesquisarPagamentosPorGuiaPagamentoHistorico(
										idLocalidade, guiaPagamentoHistorico.getId(), pagamento.getNumeroPrestacao(), pagamento
														.getAvisoBancario().getId());

					}

				}

				if((colecaoPagamentosGuiaPagamentoPreenchida != null && !colecaoPagamentosGuiaPagamentoPreenchida.isEmpty())
								|| (colecaoPagamentosGuiaPagamentoNaoPreenchida != null && !colecaoPagamentosGuiaPagamentoNaoPreenchida
												.isEmpty())){

					// Para os pagamentos com tipo de documento (DOPT_ID) com o
					// valor correspondente a GUIA DE PAGAMENTO:
					this.classificarPagamentosGuiaPagamento(colecaoPagamentosGuiaPagamentoPreenchida,
									colecaoPagamentosGuiaPagamentoNaoPreenchida, pagamento);

				}

			}else if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.DEBITO_A_COBRAR)){

				DebitoACobrar debitoACobrar = null;
				DebitoACobrarHistorico debitoACobrarHistorico = null;
				Collection colecaoPagamentosDebitoACobrarPreenchido = null;
				Collection colecaoPagamentosDebitoACobrarNaoPreenchido = null;

				if(pagamento.getImovel() != null && pagamento.getDebitoTipo() != null){

					Object retornoPesquisa = this.selecionarDebitoACobrar(pagamento.getImovel().getId(), pagamento.getDebitoTipo().getId());

					if(retornoPesquisa instanceof DebitoACobrar){
						debitoACobrar = (DebitoACobrar) retornoPesquisa;
						idDebitoACobrarGeral = debitoACobrar.getId();
					}else if(retornoPesquisa instanceof DebitoACobrarHistorico){
						debitoACobrarHistorico = (DebitoACobrarHistorico) retornoPesquisa;
						idDebitoACobrarGeral = debitoACobrarHistorico.getId();
					}
				}

				colecaoPagamentosDebitoACobrarPreenchido = repositorioArrecadacao.pesquisarPagamentosPorDebitoACobrarComDebitoInformado(
								idLocalidade, pagamento.getImovel().getId(), pagamento.getNumeroPrestacao());

				colecaoPagamentosDebitoACobrarNaoPreenchido = repositorioArrecadacao.pesquisarPagamentosPorDebitoACobrarSemDebitoInformada(
								idLocalidade, pagamento.getImovel().getId());

				if((colecaoPagamentosDebitoACobrarPreenchido != null && !colecaoPagamentosDebitoACobrarPreenchido.isEmpty())
								|| (colecaoPagamentosDebitoACobrarNaoPreenchido != null && !colecaoPagamentosDebitoACobrarNaoPreenchido
												.isEmpty())){

					this.classificarPagamentosDebitoACobrar(colecaoPagamentosDebitoACobrarPreenchido,
									colecaoPagamentosDebitoACobrarNaoPreenchido, pagamento);

				}

			}

			// Caso o situação do pagamento seja "valor a baixar", mandar
			// pagamento pra histórico
			if(pagamentoHistorico && pagamento.getPagamentoSituacaoAtual() != null
							&& pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR)){

				Collection colecaoPagamentoBaixar = new ArrayList<Pagamento>();
				colecaoPagamentoBaixar.add(pagamento);

				if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA) && pagamento.getConta() != null){
					Conta contaAtiva = this.getControladorFaturamento().pesquisarContaPeloID(pagamento.getConta().getId());

					if(contaAtiva != null){
						Integer idContaAtiva = contaAtiva.getId();
						this.getControladorFaturamento().transferirContasParaHistorico(idContaAtiva);
					}
				}

				PagamentoHistorico pagamentoHistoricoExistente = (PagamentoHistorico) getControladorUtil().pesquisar(pagamento.getId(),
								PagamentoHistorico.class, false);

				// Caso o pagamento ainda não tenha sido trasnferifo pra histórico
				if(pagamentoHistoricoExistente == null){

					Collection colecaoPagamentoHistorico = this.criarPagamentoHistoricoDoPagamento(colecaoPagamentoBaixar,
									PagamentoSituacao.VALOR_A_BAIXAR);

					// remover os Pagamentos
					this.getControladorBatch().removerColecaoObjetoParaBatch(colecaoPagamentoBaixar);

					// inserir os PagamentosHistorico
					this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoPagamentoHistorico);
				}else{

					// Caso contrário atualiza a situação do pagamento
					pagamentoHistoricoExistente.setPagamentoSituacaoAnterior(pagamentoHistoricoExistente.getPagamentoSituacaoAtual());
					PagamentoSituacao pagamentoSituacao = new PagamentoSituacao();
					pagamentoSituacao.setId(PagamentoSituacao.VALOR_A_BAIXAR);
					pagamentoHistoricoExistente.setPagamentoSituacaoAtual(pagamentoSituacao);
					getControladorUtil().atualizar(pagamentoHistoricoExistente);
				}

			}else if(pagamentoHistorico && pagamento.getPagamentoSituacaoAtual() != null
							&& pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR_MENOR)){
				// Caso o situação do pagamento seja "BAIXA PAGAMENTO A MENOR"

				Conta conta = pagamento.getConta();
				BigDecimal valorTotalPago = BigDecimal.ZERO;
				

				if(conta != null){

					Pagamento primeiroPagamentoAposVencimento = null;

					// =============================================================
					// Selecionar todos os pagamentos para a conta
					// =============================================================
					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.CONTA_ID, conta.getId()));
					Collection<Pagamento> colecaoPagamentosConta = getControladorUtil().pesquisar(filtroPagamento,
									Pagamento.class.getName());

					if(!Util.isVazioOrNulo(colecaoPagamentosConta)){
						for(Pagamento pagamentoConta : colecaoPagamentosConta){
							if(primeiroPagamentoAposVencimento == null && pagamentoConta.getDataPagamento() != null
											&& conta.getDataVencimentoConta() != null
											&& pagamentoConta.getDataPagamento().compareTo(conta.getDataVencimentoConta()) > 0){

								// Capturando o primeiro pagamento realizado após o vencimento da
								// conta
								primeiroPagamentoAposVencimento = pagamentoConta;
							}

							// Somando o valor total dos pagamentos da conta
							valorTotalPago = valorTotalPago.add(pagamentoConta.getValorPagamento());
						}

						// =============================================================
						// Caso um dos pagamentos tenha sido efetuado após a data de vencimento da
						// conta
						// =============================================================
						if(primeiroPagamentoAposVencimento != null){

							// =============================================================
							// Gerar os acréscimos por impontualidade referentes ao período entre a
							// data de vencimento da conta e a menor data de pagamento pós
							// vencimento da conta
							// =============================================================

							// Calcula o valor das multas cobradas para a conta
							SistemaParametro sistemaParametros = null;
							sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();
							String anoMesArrecadacao = sistemaParametros.getAnoMesArrecadacao() + "";

							BigDecimal valorMultasCobradas = null;
							valorMultasCobradas = getControladorFaturamento().pesquisarValorMultasCobradas(conta.getId());

							CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidade = null;

							calcularAcrescimoPorImpontualidade = this.getControladorCobranca()
											.calcularAcrescimoPorImpontualidadeBancoDeDados(conta.getReferencia(),
															conta.getDataVencimentoConta(),
															primeiroPagamentoAposVencimento.getDataPagamento(), conta.getValorTotal(),
															valorMultasCobradas, conta.getIndicadorCobrancaMulta(), anoMesArrecadacao,
															conta.getId(), null, null, ConstantesSistema.SIM, ConstantesSistema.SIM,
															ConstantesSistema.SIM);

							BigDecimal valorMulta = BigDecimal.ZERO;
							if(calcularAcrescimoPorImpontualidade != null && calcularAcrescimoPorImpontualidade.getValorMulta() != null){
								valorMulta = calcularAcrescimoPorImpontualidade.getValorMulta();
							}

							BigDecimal valorJurosMora = BigDecimal.ZERO;
							if(calcularAcrescimoPorImpontualidade != null && calcularAcrescimoPorImpontualidade.getValorJurosMora() != null){
								valorJurosMora = calcularAcrescimoPorImpontualidade.getValorJurosMora();
							}

							BigDecimal valorAtualizacaoMonetaria = BigDecimal.ZERO;
							if(calcularAcrescimoPorImpontualidade != null
											&& calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria() != null){
								valorAtualizacaoMonetaria = calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria();
							}

							Integer idDebitoTipo = null;
							DebitoTipo debitoTipo = null;

							if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
								idDebitoTipo = DebitoTipo.MULTA_IMPONTUALIDADE;

								debitoTipo = new DebitoTipo();
								debitoTipo.setId(idDebitoTipo);

								this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametros, debitoTipo,
												valorMulta, conta.getReferencia());
							}

							if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
								idDebitoTipo = DebitoTipo.JUROS_MORA;

								debitoTipo = new DebitoTipo();
								debitoTipo.setId(idDebitoTipo);

								this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametros, debitoTipo,
												valorJurosMora, conta.getReferencia());
							}

							if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
								idDebitoTipo = DebitoTipo.ATUALIZACAO_MONETARIA;

								debitoTipo = new DebitoTipo();
								debitoTipo.setId(idDebitoTipo);

								this.getControladorFaturamento().criarDebitoACobrar(imovel, null, sistemaParametros, debitoTipo,
												valorAtualizacaoMonetaria, conta.getReferencia());
							}
						}

						// =============================================================
						// Retificar a conta para o valor correspondente ao valor total pago,
						// zerando os valores de água e esgoto
						// =============================================================
						Collection colecaoCreditoRealizado = getControladorFaturamento().obterCreditosRealizadosConta(conta);
						Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasContaCategoria(conta);

						String consumoAgua = null;
						if(conta.getConsumoAgua() != null){
							consumoAgua = conta.getConsumoAgua().toString();
						}

						String consumoEsgoto = null;
						if(conta.getConsumoEsgoto() != null){
							consumoEsgoto = conta.getConsumoEsgoto().toString();
						}

						String percentualEsgoto = null;
						if(conta.getPercentualEsgoto() != null){
							percentualEsgoto = conta.getPercentualEsgoto().toString();
						}

						Usuario usuario = null;
						UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = null;

						if(!Util.isVazioOrNulo(pagamento.getUsuarioAcaoUsuarioHelp())){
							usuarioAcaoUsuarioHelper = (UsuarioAcaoUsuarioHelper) pagamento.getUsuarioAcaoUsuarioHelp().iterator().next();
							if(usuarioAcaoUsuarioHelper != null){
								usuario = usuarioAcaoUsuarioHelper.getUsuario();
							}
						}

						ContaMotivoRetificacao contaMotivoRetificacao = new ContaMotivoRetificacao();
						contaMotivoRetificacao.setId(ContaMotivoRetificacao.BAIXA_FORCADA);

						conta.setValorAgua(BigDecimal.ZERO);
						conta.setValorEsgoto(BigDecimal.ZERO);


						// =============================================================
						// Remover débitos cobrados da conta
						// =============================================================
						// =============================================================
						// Adicionar novo débito cobrado com o valor correspondente ao valor total
						// pago e com tipo de débito correspondente a
						// "39 - Diferença pagamento a menor"
						// =============================================================
						// Criação de uma coleção apenas com o novo débito cobrado do tipo 39. Os
						// demais débitos cobrados da conta serão removidos no procedimento de
						// Retificação da Conta

						if(DebitoTipo.DIF_PAGTO_MENOR < 0){
							throw new ControladorException("erro.cdconstante.inexistente", null, "Tipo de Débito",
											DebitoTipoEnum.DIF_PAGTO_MENOR.name());
						}

						FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, DebitoTipo.DIF_PAGTO_MENOR));
						filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.FINANCIAMENTO_TIPO);
						filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);
						DebitoTipo debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroDebitoTipo,
										DebitoTipo.class.getName()));

						DebitoCobrado debitoCobrado = new DebitoCobrado();
						debitoCobrado.setUltimaAlteracao(new Date());
						debitoCobrado.setAnoMesReferenciaDebito(conta.getReferencia());
						debitoCobrado.setAnoMesCobrancaDebito(conta.getReferencia());
						debitoCobrado.setValorPrestacao(valorTotalPago);
						debitoCobrado.setDebitoTipo(debitoTipo);
						debitoCobrado.setNumeroPrestacao(new Short("1").shortValue());
						debitoCobrado.setNumeroPrestacaoDebito(new Short("1").shortValue());

						Collection<DebitoCobrado> colecaoDebitoCobrado = new ArrayList<DebitoCobrado>();
						colecaoDebitoCobrado.add(debitoCobrado);

						System.out.println(conta.getValorTotalConta());
						
						// Retificar conta
						this.getControladorFaturamento().retificarConta(conta.getReferencia(), conta, imovel,
										colecaoDebitoCobrado, colecaoCreditoRealizado, conta.getLigacaoAguaSituacao(),
										conta.getLigacaoEsgotoSituacao(), colecaoCategoria, consumoAgua, consumoEsgoto, percentualEsgoto,
 conta.getDataVencimentoConta(),
										null, contaMotivoRetificacao, null, usuario, null, conta.getConsumoTarifa(), null);

						// =============================================================
						// Gerar novo débito a cobrar para o imóvel com a diferença do valor total
						// pago e o valor original da conta (tipo de débito "66 Dif Pagto Menor")
						// =============================================================

						BigDecimal valorDiferencaPagamento = BigDecimal.ZERO;

						if(conta.getValorTotal() != null && conta.getValorTotal().compareTo(valorTotalPago) > 0){
							valorDiferencaPagamento = conta.getValorTotal().subtract(valorTotalPago);
						}

						if(valorDiferencaPagamento.compareTo(BigDecimal.ZERO) > 0){

							if(DebitoTipo.DIF_PGTO_MENOR < 0){
								throw new ControladorException("erro.cdconstante.inexistente", null, "Tipo de Débito",
												DebitoTipoEnum.DIF_PGTO_MENOR.name());
							}

							this.getControladorFaturamento().gerarDebitoACobrar(imovel.getId(), conta.getReferencia(),
											DebitoTipo.DIF_PGTO_MENOR, valorDiferencaPagamento);
						}

						// =============================================================
						// Baixar todos os pagamentos da conta
						// =============================================================
						transferirPagamentoParaHistorico(colecaoPagamentosConta);

						// ==============================================================
						// Baixar Contas
						// ==============================================================


						FiltroConta filtroConta = new FiltroConta();
						filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, conta.getReferencia()));
						filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, imovel.getId()));

						ArrayList<Conta> colecaoContaBaixa = (ArrayList<Conta>) this.getControladorUtil().pesquisar(filtroConta,
										Conta.class.getName());

						for(Conta contaBaixa : colecaoContaBaixa){

							Date maiorDataPagamento = null;
							Date dataPagamentoAux = null;

							if(!Util.isVazioOrNulo(colecaoPagamentosConta)){
								for(Pagamento pagamentoConta : colecaoPagamentosConta){
									dataPagamentoAux = pagamentoConta.getDataPagamento();

									if(maiorDataPagamento == null
													|| (dataPagamentoAux != null && maiorDataPagamento != null && dataPagamentoAux
																	.compareTo(maiorDataPagamento) > 0)){
										maiorDataPagamento = dataPagamentoAux;
									}
								}
							}

							this.getControladorFaturamento().transferirContasParaHistorico(contaBaixa.getId());
							
							this.getControladorCobranca().atualizarItemDocumentoCobranca(contaBaixa.getId(), null, null, null,
											CobrancaDebitoSituacao.PAGO, maiorDataPagamento, CobrancaDebitoSituacao.PENDENTE);

							OperacaoContabilHelper helper = this.definirOrigemOperacaoContabilPagamento(pagamento, false);
							getControladorContabil().registrarLancamentoContabil(helper.getObjetoOrigem(), helper.getOperacaoContabil());


						}
					}
				}
			}

			// =============================================================
			// Guardar registro Helper para construção do relatório de pagamentos não
			// classificados, caso a coleção de Helpers esteja diferente de Null, o que
			// significa que este método foi chamado pela funcionalidade de Classificar
			// Lote de Pagamentos Não Classificados - Aqui serão guardados os pagamentos
			// A MENOR. Os pagamentos A MAIOR são guardados em outro momento, quando são
			// gerados os seus acréscimos
			// =============================================================
			if(colecaoClassificarPagamentosNaoClassificadosHelper != null){

				Integer referenciaDebito = null;
				BigDecimal valorDocumento = BigDecimal.ZERO;
				BigDecimal valorReajuste = BigDecimal.ZERO;

				// Constroi o Helper que será utilizado na geração do Relatório de
				// Pagamentos Baixados, gerado na funcionalidade de Classificar Lote de
				// Pagamentos Não Classificados
				ClassificarPagamentosNaoClassificadosHelper helper = new ClassificarPagamentosNaoClassificadosHelper();
				helper.setPagamento(pagamento);


				// Captura o valor do documento antes de ser realizada a classifica do pagamento e,
				// possivelmente, reajuste do valor da conta com acréscimos de impontualidade
				if(contaAntesClassificacao != null){
					if(contaAntesClassificacao instanceof Conta){
						valorDocumento = ((Conta) contaAntesClassificacao).getValorTotal();
						referenciaDebito = ((Conta) contaAntesClassificacao).getReferencia();
						helper.setConta((Conta) contaAntesClassificacao);

					}else if(contaAntesClassificacao instanceof ContaHistorico){
						valorDocumento = ((ContaHistorico) contaAntesClassificacao).getValorTotal();
						referenciaDebito = ((ContaHistorico) contaAntesClassificacao).getAnoMesReferenciaConta();
						helper.setContaHistorico((ContaHistorico) contaAntesClassificacao);
					}
				}

				// Recupera o valor de reajuste: Soma dos acréscimos de impontualidade gerados
				valorReajuste = recuperarValorAcrescimosImpontualidade(imovel.getId(), referenciaDebito);

				if(valorReajuste != null && valorReajuste.compareTo(BigDecimal.ZERO) > 0){
					helper.setValorReajuste(valorReajuste);
					helper.setValorDocumentoReajustado(valorDocumento.add(valorReajuste));
				}else{
					helper.setValorReajuste(BigDecimal.ZERO);
					helper.setValorDocumentoReajustado(valorDocumento);
				}

				colecaoClassificarPagamentosNaoClassificadosHelper.add(helper);
			}

			if(idConta != null || idGuiaPagamento != null || idDebitoACobrarGeral != null){

				// Gerar Remuneração Cobrança Administrativa
				ParametroArrecadacao.P_GERACAO_ITENS_REMUNERACAO_COBRANCA_ADMINISTRATIVA.executar(this, -1, null, pagamento.getId());
			}

		}catch(ErroRepositorioException e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// venha a lançar
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Retorna a soma dos valores de acréscimo gerados para o imóvel em determinada referência
	 * 
	 * @author Luciano Galvao
	 * @date 19/09/2013
	 */
	private BigDecimal recuperarValorAcrescimosImpontualidade(Integer imovelId, Integer referenciaDebito) throws ControladorException{

		BigDecimal valorReajuste = BigDecimal.ZERO;

		Collection<Integer> colecaoDebitosAcrescimoImpontualidade = new ArrayList<Integer>();
		colecaoDebitosAcrescimoImpontualidade.add(DebitoTipo.ATUALIZACAO_MONETARIA);
		colecaoDebitosAcrescimoImpontualidade.add(DebitoTipo.JUROS_MORA);
		colecaoDebitosAcrescimoImpontualidade.add(DebitoTipo.MULTA_IMPONTUALIDADE);

		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, imovelId));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.REFERENCIA_DEBITO, referenciaDebito));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimplesColecao(FiltroDebitoACobrar.DEBITO_TIPO_ID,
						colecaoDebitosAcrescimoImpontualidade));

		Collection<DebitoACobrar> colecaoDebitosACobrar = getControladorUtil()
						.pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());

		if(!Util.isVazioOrNulo(colecaoDebitosACobrar)){
			for(DebitoACobrar debitoACobrar : colecaoDebitosACobrar){
				valorReajuste = valorReajuste.add(debitoACobrar.getValorDebito());
			}
		}
		return valorReajuste;
	}

	/**
	 * Este caso de uso permite classificar os pagamentos e as devoluções
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Saulo Lima
	 * @since 02/12/2008
	 * @param Devolucao
	 * @return void
	 */
	public void classificarDevolucoes(Devolucao devolucao) throws ControladorException{

		long dif = 0L, ini = 0L;

		try{

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			if(sistemaParametro != null){

				// Recupera o ano/mês de arrecadação atual.
				Integer anoMesArrecadacao = sistemaParametro.getAnoMesArrecadacao();

				// Recupera o ano/mês de faturamento atual.
				// Integer anoMesFaturamento = sistemaParametro.getAnoMesFaturamento();

				Integer idLocalidade = devolucao.getLocalidade().getId();

				/*
				 * O sistema seleciona as devoluções com ano/mês de referência da arrecadação igual
				 * ou menor que o
				 * ano/mês de referência da arrecadação corrente (seleciona a partir da tabela
				 * DEVOLUCAO para
				 * DEVL_AMREFERENCIAARRECADACAO igual ou menor ao PARM_AMREFERENCIAARRECADACAO)
				 */
				Collection<Object[]> colecaoDevolucoesDuplicidadeExcesso = null;
				Collection<Object[]> colecaoDevolucoesCobradasIndevidamente = null;

				// System.out.println("********************** DEVOLUCOES ******************* devolucao_Id = "+
				// devolucao.getId());

				colecaoDevolucoesDuplicidadeExcesso = repositorioArrecadacao.pesquisarDevolucoesEmDuplicidadeOUExcesso(devolucao);

				dif = System.currentTimeMillis() - ini;
				System.out.println("6.1 - ############################## -> " + dif);
				ini = System.currentTimeMillis();

				colecaoDevolucoesCobradasIndevidamente = repositorioArrecadacao.pesquisarDevolucoesCobradasIndevidamente(anoMesArrecadacao,
								idLocalidade);

				dif = System.currentTimeMillis() - ini;
				System.out.println("6.2 - ############################## -> " + dif);
				ini = System.currentTimeMillis();

				/*
				 * Para as devoluções de contas pagas em duplicidade ou em excesso, ou seja, aquelas
				 * com ano/mês de
				 * referência preenchidos (DEVL_AMREFERENCIADEVOLUCAO com valor diferente de nulo)
				 */
				if(colecaoDevolucoesDuplicidadeExcesso != null && !colecaoDevolucoesDuplicidadeExcesso.isEmpty()){

					ini = System.currentTimeMillis();

					this.classificarDevolucoesDuplicidadeExcesso(colecaoDevolucoesDuplicidadeExcesso);

					dif = System.currentTimeMillis() - ini;
					System.out.println("6.3 - ############################## -> " + dif);
					ini = System.currentTimeMillis();

				}
				if(colecaoDevolucoesCobradasIndevidamente != null && !colecaoDevolucoesCobradasIndevidamente.isEmpty()){

					ini = System.currentTimeMillis();

					this.classificarDevolucoesCobradasIndevidamente(colecaoDevolucoesCobradasIndevidamente);

					dif = System.currentTimeMillis() - ini;
					System.out.println("6.4 - ############################## -> " + dif);
					ini = System.currentTimeMillis();
				}

				ini = System.currentTimeMillis();

				// -----------------------------------------------------
				// ATUALIZANDO AVISO BANCARIO.
				// -----------------------------------------------------
				this.atualizarAvisoBancarioDevolucao(devolucao);

				dif = System.currentTimeMillis() - ini;
				System.out.println("6.5 - ############################## -> " + dif);
				ini = System.currentTimeMillis();
			}

		}catch(ErroRepositorioException e){
			// Este catch serve para interceptar qualquer exceção que o processo venha a lançar
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * O sistema seleciona a conta correspondente ao pagamento através do imóvel
	 * e ano/mês de referência do pagamento (a partir da tabela CONTA com
	 * IMOV_ID = IMOV_ID da tabela PAGAMENTO, PGMT_AMREFERENCIAPAGAMENTO da
	 * tabela PAGAMENTO e DCST_IDATUAL com o valor correspondente a normal,
	 * retificada, incluída ou entrada de parcelamento ou prefaturada, da tabela
	 * DEBTIO_CREDITO_SITUACAO)
	 * [SB0001] Selecionar Conta pelo Imóvel e Ano/Mês de Referência
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2006, 28/11/2006, 05/06/2007, 02/10/2007, 15/01/2008
	 * @param imovel
	 * @param anoMesReferenciaPagamento
	 * @return Object
	 */
	private Object selecionarContaPorImovelAnoMesReferencia(Imovel imovel, Integer anoMesReferenciaPagamento) throws ControladorException{

		Conta conta = null;
		ContaHistorico contaHistorico = null;

		if(imovel != null && anoMesReferenciaPagamento != null){

			try{
				Object[] dadosConta = repositorioArrecadacao.selecionarContaPorImovelAnoMesReferencia(imovel, anoMesReferenciaPagamento);

				/*
				 * Caso o array dos dados da conta esteja preenchido
				 * 00 - id da conta
				 * 01 - valor da água
				 * 02 - valor do esgoto
				 * 03 - valor dos débitos
				 * 04 - valor dos créditos
				 * 05 - valor dos impostos
				 * 06 - ano/mês referência contábil
				 * 07 - débito crédito situação atual
				 * 08 - data de vencimento da conta
				 * 09 - referência
				 * 10 - indicador de cobrança de multa
				 * 11 - data de emissão
				 */
				if(dadosConta != null){
					conta = new Conta();
					conta.setId((Integer) dadosConta[0]);
					conta.setValorAgua((BigDecimal) dadosConta[1]);
					conta.setValorEsgoto((BigDecimal) dadosConta[2]);
					conta.setDebitos((BigDecimal) dadosConta[3]);
					conta.setValorCreditos((BigDecimal) dadosConta[4]);
					conta.setValorImposto((BigDecimal) dadosConta[5]);
					conta.setReferenciaContabil((Integer) dadosConta[6]);

					DebitoCreditoSituacao dcstAtual = new DebitoCreditoSituacao();
					dcstAtual.setId((Integer) dadosConta[7]);
					conta.setDebitoCreditoSituacaoAtual(dcstAtual);

					conta.setDataVencimentoConta((Date) dadosConta[8]);
					conta.setReferencia((Integer) dadosConta[9]);
					conta.setIndicadorCobrancaMulta((Short) dadosConta[10]);
					conta.setDataEmissao((Date) dadosConta[11]);
				}

				// caso não encontre a conta, procurar no histórico
				if(conta == null){

					Object[] dadosContaHistorico = repositorioArrecadacao.selecionarContaHistoricoPorImovelAnoMesReferencia(imovel,
									anoMesReferenciaPagamento);

					/*
					 * Caso o array dos dados da conta histórico esteja preenchido
					 * 0 - id da conta
					 * 1 - valor da água
					 * 2 - valor do esgoto
					 * 3 - valor dos débitos
					 * 4 - valor dos créditos
					 * 5 - valor dos impostos
					 * 6 - ano/mês referência contábil
					 * 7 - debito credito situação atual
					 */
					if(dadosContaHistorico != null){
						contaHistorico = new ContaHistorico();
						contaHistorico.setId((Integer) dadosContaHistorico[0]);
						contaHistorico.setValorAgua((BigDecimal) dadosContaHistorico[1]);
						contaHistorico.setValorEsgoto((BigDecimal) dadosContaHistorico[2]);
						contaHistorico.setValorDebitos((BigDecimal) dadosContaHistorico[3]);
						contaHistorico.setValorCreditos((BigDecimal) dadosContaHistorico[4]);
						contaHistorico.setValorImposto((BigDecimal) dadosContaHistorico[5]);
						contaHistorico.setAnoMesReferenciaContabil((Integer) dadosContaHistorico[6]);

						DebitoCreditoSituacao dcstAtual = new DebitoCreditoSituacao();
						dcstAtual.setId((Integer) dadosContaHistorico[7]);
						contaHistorico.setDebitoCreditoSituacaoAtual(dcstAtual);
					}
				}
			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		if(conta != null){
			return conta;
		}else if(contaHistorico != null){
			return contaHistorico;
		}else{
			return null;
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Processa os pagamentos da conta
	 * [SB0002] - Processar Pagamento de Conta
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre Santos
	 * @date 19/04/2006, 06/12/2006
	 * @author Saulo Lima
	 * @date 17/11/2008
	 *       Funcionamento on-line
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Melhorando o desempenho do Classificar
	 * @param conta
	 * @param colecaoPagamentos
	 * @throws ControladorException
	 */
	// FIXME TODO AHGL Método Chamado por método onde é DEPRECATED
	@Deprecated
	protected Collection<Pagamento> processarPagamentoConta(Conta conta, Collection<Pagamento> colecaoPagamentos)
					throws ControladorException{

		// Declaração das variáveis
		Collection<Pagamento> retorno = new ArrayList<Pagamento>();
		Collection<Pagamento> colecaoPagamentosProcessados = new ArrayList<Pagamento>();
		Collection<Integer> idsDebitosACobrar = new ArrayList<Integer>();
		Object[] arrayColecoesPagamentosAtualizar = null;

		try{

			for(Pagamento pagamento : colecaoPagamentos){
				pagamento.setConta(conta);
			}

			// Atribuir o valor da conta ao valor do documento
			BigDecimal valorDocumento = conta.getValorTotal();

			// [SF0007] Calcular Valor Total dos Pagamentos
			BigDecimal valorTotalPagamentosConta = this.calcularValorTotalPagamentos(colecaoPagamentos);

			/*
			 * Caso valor total dos pagamentos da conta seja igual ao valor do documento atualizar a
			 * situação atual dos pagamentos (PGST_IDATUAL) com
			 * valor correspondente a pagamento classificado (tabela PAGAMENTO_SITUACAO) e atualizar
			 * o id da conta nos pagamentos (seta CNTA_ID da
			 * tabela PAGAMENTO para CNTA_ID da tabela CONTA);
			 */
			// recurepa o valor absoluto da diferença entre o total dos pagamentos e o valor
			// documento
			BigDecimal diferenca = (valorTotalPagamentosConta.subtract(valorDocumento)).abs();

			// caso a diferença seja igual a zero
			if(diferenca.compareTo(BigDecimal.ZERO) == 0){

				colecaoPagamentosProcessados.addAll(colecaoPagamentos);
				retorno = colecaoPagamentos;

				// Caso contrário, verifica pagamento a maior ou a menor [SB0008 - Processar
				// Pagamento a Maior ou a Menor]
			}else{

				// [SB0008] Processar Pagamento a Maior ou a Menor
				arrayColecoesPagamentosAtualizar = this.processarPagamentoAMenorOUAMaior(valorTotalPagamentosConta, valorDocumento,
								colecaoPagamentos, conta.getId());

				if(arrayColecoesPagamentosAtualizar[1] != null && !((Collection) arrayColecoesPagamentosAtualizar[1]).isEmpty()){

					Collection colecaoPagamentosClassificados = (Collection) arrayColecoesPagamentosAtualizar[1];
					colecaoPagamentosProcessados.addAll(colecaoPagamentosClassificados);
					retorno = colecaoPagamentosClassificados;
				}
			}

			if(colecaoPagamentosProcessados != null && !colecaoPagamentosProcessados.isEmpty()){

				repositorioArrecadacao.processarPagamentoConta(colecaoPagamentosProcessados, conta.getId());

				// [UC0302] Calculo de Acrescimos -- itera nos pagamentos encontrados

				Collection<Integer> idsDebitosACobrarAux = new ArrayList<Integer>();
				Collection<Integer> idsDebitosACobrarAtualizarIndicador = new ArrayList<Integer>();

				Object retornoExecutor = null;
				boolean atualizarRemuneraCobrancaAdministrativa = false;

				for(Pagamento pagamento : colecaoPagamentosProcessados){
					idsDebitosACobrarAux = this.getControladorFaturamento().gerarDebitosACobrarDeAcrescimosPorImpontualidadeBancoDeDados(
							pagamento, null);

					if(!Util.isVazioOrNulo(idsDebitosACobrarAux)){
						retornoExecutor = ParametroArrecadacao.P_GERACAO_ACRESCIMOS_COBRANCA_ADMINISTRATIVA.executar(this, -1, pagamento);

						if(retornoExecutor != null){
							atualizarRemuneraCobrancaAdministrativa = (Boolean) retornoExecutor;
						}

						if(atualizarRemuneraCobrancaAdministrativa){
							idsDebitosACobrarAtualizarIndicador.addAll(idsDebitosACobrarAux);
						}

						idsDebitosACobrar.addAll(idsDebitosACobrarAux);
					}
				}
		
				if(!Util.isVazioOrNulo(idsDebitosACobrarAtualizarIndicador)){
					Collection colecaoDebitoACobrarAtualizar = new ArrayList();
		
					FiltroDebitoACobrar filtroDebitoACobrar = null;
					Collection<DebitoACobrar> colecaoDebitoACobrar = null;
		
					for(Integer idDebitoACobrar : idsDebitosACobrarAtualizarIndicador){
						filtroDebitoACobrar = new FiltroDebitoACobrar();
						filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));
		
						colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());
		
						if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){
							for(DebitoACobrar debitoACobrar : colecaoDebitoACobrar){
								debitoACobrar.setIndicadorRemuneraCobrancaAdministrativa(ConstantesSistema.SIM);
		
								colecaoDebitoACobrarAtualizar.add(debitoACobrar);
							}
						}
					}

					if(!Util.isVazioOrNulo(colecaoDebitoACobrarAtualizar)){
						this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoDebitoACobrarAtualizar);
					}
				}

				// 4.4. O sistema transfere para o histórico de pagamentos (PAGAMENTO_HISTORICO), os
				// pagamentos classificados
				// (PGST_IDATUAL com o valor correspondente a pagamento classificado);
				/* PARTE 1 */

				Collection colecaoPagamentosPreenchida = this.carregarAtributosPagamento(colecaoPagamentosProcessados);

				Collection colecaoPagamentoHistorico = this.criarPagamentoHistoricoDoPagamento(colecaoPagamentosPreenchida,
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO);

				getControladorBatch().removerColecaoObjetoParaBatch(colecaoPagamentosPreenchida);

				// 4.2. O sistema transfere para o histórico, as contas correspondentes aos
				// pagamentos classificados de conta
				SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
				if(sistemaParametro != null){
					Integer anoMesFaturamentoSistemaParametro = sistemaParametro.getAnoMesFaturamento();
					if(anoMesFaturamentoSistemaParametro != null){
						FiltroConta filtroConta = new FiltroConta();
						filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, conta.getId()));
						Collection<Conta> colecaoConta = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());
						if(colecaoConta != null && !colecaoConta.isEmpty()){
							this.getControladorFaturamento().transferirContasParaHistorico(colecaoConta,
											anoMesFaturamentoSistemaParametro.intValue());
						}
					}else{
						throw new ControladorException("atencao.pesquisa.sistemaparametro_inexistente");
					}
				}else{
					throw new ControladorException("atencao.pesquisa.sistemaparametro_inexistente");
				}

				/* 4.4 PARTE 2 */
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoPagamentoHistorico);

				// 4.3. Para cada conta transferida para o histórico, atualiza o indicador de que a
				// conta está no histórico
				this.getControladorFaturamento().atualizarIndicadorContaNoHistorico(Collections.singletonList(conta));

				/*
				 * TODO
				 * Pendência na versão 0.07 - Falta Customizar o [UC1015]
				 * Saulo Lima - 20/11/2008
				 */
				// 4.5. Efetuar os lançamentos (contabilização) relativos à baixa da conta
				// <<Inclui>> [UC1015 – Gerar/Atualizar Resumo da Arrecadação]
				// System.out.println("# Chamar o UC1015. #");

				// # Inicio da remuneração de agentes de cobrança #"
				ContaHistorico contaHistorico = this.repositorioArrecadacao.consultarContaHistorico(conta.getId());
				CobrancaDocumento documentoCobranca = null;

				/**
				 * 4.6. Caso a conta classificada corresponda a uma entrada de parcelamento (PARC_ID
				 * da
				 * tabela CONTA diferente de nulo), verificar se há documento de cobrança vinculado
				 * (CBDO_ID da tabela PARCELAMENTO com PARC_ID = PARC_ID da tabela CONTA diferente
				 * de
				 * nulo)
				 */
				if(contaHistorico.getParcelamento() != null && contaHistorico.getParcelamento().getCobrancaDocumento() != null){

					/**
					 * 4.6.1. Caso exista documento de cobrança associado ao parcelamento (CBDO_ID
					 * da tabela
					 * PARCELAMENTO diferente de nulo), obter documento de cobrança
					 * (COBRANCA_DOCUMENTO com CBDO_ID =
					 * CBDO_ID da tabela PARCELAMENTO)
					 */

					documentoCobranca = contaHistorico.getParcelamento().getCobrancaDocumento();
					this.remunerarAgentes(documentoCobranca, contaHistorico, colecaoPagamentoHistorico);

					/**
					 * 4.7. Caso não seja entrada(PARC_ID=Nulo da tabela CONTA), verificar se a
					 * conta está em processo
					 * de cobrança (existe CNTA_ID da tabela CONTA = CNTA_ID da tabela
					 * COBRANCA_DOCUMENTO_ITEM)
					 */

					// Se o parâmetro da Contra-Ação do parcelamento for no ato do
					// "Pagamento da entrada do Parcelamento", verificar Contra-Ação
					String contraAcaoParcelamentoIndicador = ConstantesAplicacao.get("aplicacao.contra_acao.parcelamento");
					if(contraAcaoParcelamentoIndicador != null && Util.isInteger(contraAcaoParcelamentoIndicador)){

						int contraAcaoIndicador = Util.converterStringParaInteger(contraAcaoParcelamentoIndicador);
						if(contraAcaoIndicador == ContraAcao.CONTRA_ACAO_PAGAMENTO_ENTRADA_PARCELAMENTO){

							if(contaHistorico.getContaMotivoRevisao() != null
											&& contaHistorico.getContaMotivoRevisao().getId().intValue() == ContaMotivoRevisao.REVISAO_ENTRADA_DE_PARCELAMENTO
															.intValue()){
								/**
								 * Chamar metodo para realizar Contra-ação
								 * Andre Nishimura 26/04/2010
								 */
								this.getControladorCobranca().validaDocumentoCobrancaPagamentoParaContraAcao(contaHistorico.getId());
							}
						}
					}

				}else if(contaHistorico.getParcelamento() == null){
					/**
					 * 4.7.1. Caso esteja, obter documento de cobrança (COBRANCA_DOCUMENTO com
					 * CBDO_ID = CBDO_ID da
					 * tabela COBRANCA_DOCUMENTO_ITEM)
					 */

					documentoCobranca = this.repositorioArrecadacao.consultarUltimoCobrancaDocumento(contaHistorico.getId());
					if(documentoCobranca != null
									&& (documentoCobranca.getCobrancaAcaoAtividadeComando() != null || documentoCobranca
													.getCobrancaAcaoAtividadeCronograma() != null)){

						this.remunerarAgentes(documentoCobranca, contaHistorico, colecaoPagamentoHistorico);
					}else{
						/**
						 * 4.8. Caso contrário, verificar se há parcela cobrada, a ser remunerada,
						 * na conta em
						 * questão(CBDO_ID da tabela PARCELAMENTO diferente de nulo para PARC_ID =
						 * PARC_ID da tabela
						 * DEBITO_COBRADO com CNTA_ID = CNTA_ID da tabela CONTA)
						 */

						/**
						 * 4.8.1. Obter documento de cobrança (COBRANCA_DOCUMENTO com CBDO_ID =
						 * CBDO_ID da tabela PARCELAMENTO)
						 */

						Set<DebitoCobradoHistorico> debitosCobrados = contaHistorico.getDebitoCobradoHistoricos();

						if(debitosCobrados != null && !debitosCobrados.isEmpty()){

							for(DebitoCobradoHistorico debitoCobrado : debitosCobrados){
								Parcelamento parcelamento = debitoCobrado.getParcelamento();

								if(parcelamento != null){

									documentoCobranca = parcelamento.getCobrancaDocumento();
									this.remunerarAgentes(documentoCobranca, contaHistorico, colecaoPagamentoHistorico);

								}
							}
						}

					}

					/**
					 * Chamar metodo para realizar Contra-ação
					 * Andre Nishimura 26/04/2010
					 */
					this.getControladorCobranca().validaDocumentoCobrancaPagamentoParaContraAcao(contaHistorico.getId());
				}

				// # Fim da remuneração de agentes de cobrança #"
			}

			if(arrayColecoesPagamentosAtualizar != null){
				/**
				 * 0 - Coleção de pagamentos com situação igual a valor não confere.
				 * 1 - Coleção de pagamentos com situação igual pagamentos classificados.
				 * 2 - Coleção de pagamentos com situação igual pagamentos em duplicidade.
				 * 3 - Coleção de pagamentos para atualizar valor excedente.
				 * 4 - Coleção de pagamentos para atualizar situação igual a valor não confere e
				 * remover referência.
				 */
				if(arrayColecoesPagamentosAtualizar[0] != null && !((Map) arrayColecoesPagamentosAtualizar[0]).isEmpty()){
					this.repositorioArrecadacao.processarPagamentoValorNaoConfereConta((Map) arrayColecoesPagamentosAtualizar[0]);
				}
				// arrayColecoesPagamentosAtualizar[1] -> Já processado anteriormente
				if(arrayColecoesPagamentosAtualizar[2] != null && !((Collection) arrayColecoesPagamentosAtualizar[2]).isEmpty()){
					this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_DUPLICADO,
									(Collection) arrayColecoesPagamentosAtualizar[2]);
				}
				if(arrayColecoesPagamentosAtualizar[3] != null && !((Collection) arrayColecoesPagamentosAtualizar[3]).isEmpty()){
					this.repositorioArrecadacao.atualizarValorExcedentePagamento((Collection) arrayColecoesPagamentosAtualizar[3]);

				}
				if(arrayColecoesPagamentosAtualizar[4] != null && !((Collection) arrayColecoesPagamentosAtualizar[4]).isEmpty()){
					this.repositorioArrecadacao
									.processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo((Collection) arrayColecoesPagamentosAtualizar[4]);

				}

				// _________________________________________________________________
				// Alterado por Yara Souza
				// Data : 27/07/2010
				// _________________________________________________________________

				if(arrayColecoesPagamentosAtualizar[5] != null && !((Collection) arrayColecoesPagamentosAtualizar[5]).isEmpty()){
					this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_A_MENOR,
									(Collection) arrayColecoesPagamentosAtualizar[5]);
				}

				if(arrayColecoesPagamentosAtualizar[6] != null && !((Collection) arrayColecoesPagamentosAtualizar[6]).isEmpty()){
					this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_A_MAIOR,
									(Collection) arrayColecoesPagamentosAtualizar[6]);

				}
				// ...................................................................
			}

			this.getControladorFaturamento().registrarLancamentoContabilDebitoACobrar(idsDebitosACobrar);

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * Contempla os seguintes itens: 4.6.1.1, 4.7.2, 4.8.2
	 * Caso o agente de cobrança vinculado ao documento (EMPR_ID da tabela
	 * DOCUMENTO_COBRANCA diferente de nulo) tenha contrato de remuneração por sucesso ativo
	 * (COBRANCA_CONTRATO_REMUNER com CBRT_ID com valor correspondente a “Sucesso” para
	 * COBRANCA_CONTRATO_REMUNER com CBCO_ID = CBCO_ID da tabela COBRANCA_CONTRATO com
	 * CBCO_DTCONTRATOENCERRAMENTO = Nulo e EMPR_ID = EMPR_ID da tabela DOCUMENTO_COBRANCA), efetuar
	 * a atualização da remuneração(acumular valores caso já exista ou inserir)
	 */
	private void remunerarAgentes(CobrancaDocumento documentoCobranca, ContaHistorico contaHistorico, Collection colecaoPagamentoHistorico)
					throws ControladorException{

		if(documentoCobranca != null){

			Empresa agCobranca = documentoCobranca.getEmpresa();
			// entidade CobrancaContratoRemuneracao dropada
			// CobrancaContratoRemuneracao cobrancaContratoRemuneracaoSucessoSelecionado = null;
			// CobrancaContratoRemuneracao cobrancaContratoRemuneracaoProdutividadeSelecionado =
			// null;

			if(agCobranca != null){
				Set<CobrancaContrato> contratosCobranca = agCobranca.getCobrancaContratos();

				if(contratosCobranca != null && !contratosCobranca.isEmpty()){

					for(CobrancaContrato contratoCobranca : contratosCobranca){
						// entidade CobrancaContratoRemuneracao dropada
						if(contratoCobranca.getDataEncerramento() == null){
							// Set<CobrancaContratoRemuneracao> cobrancaContratosRemuneracao =
							// contratoCobranca
							// .getCobrancaContratoRemuneracoes();
							// for(CobrancaContratoRemuneracao cobrancaContratoRemuneracao :
							// cobrancaContratosRemuneracao){
							// if(cobrancaContratoRemuneracao.getContratoTipo().getId().intValue()
							// == ContratoTipoRemuneracao.TIPO_SUCESSO){
							// cobrancaContratoRemuneracaoSucessoSelecionado =
							// cobrancaContratoRemuneracao;
							// }
							// }
							// break;
						}
					}
				}
				// entidade CobrancaContratoRemuneracao dropada
				// if(cobrancaContratoRemuneracaoSucessoSelecionado != null){
				//
				// BigDecimal valorParcelasCobradas = BigDecimal.ZERO;
				//
				// if(contaHistorico.getDebitoCobradoHistoricos() != null &&
				// !contaHistorico.getDebitoCobradoHistoricos().isEmpty()){
				// for(DebitoCobradoHistorico debitoCobrado :
				// contaHistorico.getDebitoCobradoHistoricos()){
				// if(debitoCobrado.getParcelamento() != null){
				//
				// CobrancaDocumento documentoCobrancaParcelamento = null;
				// try{
				// documentoCobrancaParcelamento = repositorioArrecadacao
				// .consultarCobrancaDocumentoParcelamento(debitoCobrado.getParcelamento().getId());
				// }catch(ErroRepositorioException e){
				// e.printStackTrace();
				// }
				//
				// // CobrancaDocumento documentoCobrancaParcelamento =
				// // debitoCobrado.getParcelamento().getCobrancaDocumento();
				//
				// if((documentoCobrancaParcelamento != null)
				// && (documentoCobrancaParcelamento.getId().equals(documentoCobranca.getId()))){
				// valorParcelasCobradas.add(debitoCobrado.getValorPrestacao());
				// }
				// }
				// }
				// }
				// this.insereOuAtualizaCobrancaSucesso(documentoCobranca,
				// colecaoPagamentoHistorico, contaHistorico
				// .getDataVencimentoConta(), contaHistorico.getValorTotal(), valorParcelasCobradas,
				// contaHistorico
				// .getParcelamento());
				// }
			}
		}
	}

	private void insereOuAtualizaCobrancaSucesso(CobrancaDocumento documentoCobranca, Collection colecaoPagamentoHistorico,
					Date dataVencimentoOuGuia, BigDecimal valorTotalContaOuGuia, BigDecimal valorParcelasCobradas, Parcelamento parcelamento)
					throws ControladorException{

		// utilizado para insercao/atualizacao da cobranca sucesso
		Date menorDataPagamento = null;
		Iterator iter = colecaoPagamentoHistorico.iterator();

		while(iter.hasNext()){
			PagamentoHistorico pghist = (PagamentoHistorico) iter.next();
			Date dataPg = pghist.getDataPagamento();
			if(menorDataPagamento == null || dataPg.before(menorDataPagamento)){
				menorDataPagamento = dataPg;
			}
		}

		FiltroCobrancaSucesso filtroCobrancaSucesso = new FiltroCobrancaSucesso();
		filtroCobrancaSucesso.adicionarParametro(new ParametroNulo(FiltroCobrancaSucesso.ANO_MES_REFERENCIA));

		filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.DATA_VENCIMENTO_CONTA, menorDataPagamento));

		if(documentoCobranca.getCobrancaAcaoAtividadeComando() != null){
			filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.COMANDO_ACAO_COMANDO_ID, documentoCobranca
							.getCobrancaAcaoAtividadeComando().getId()));
		}else if(documentoCobranca.getCobrancaAcaoAtividadeCronograma() != null){
			filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.COMANDO_ACAO_CRONOGRAMA_ID,
							documentoCobranca.getCobrancaAcaoAtividadeCronograma().getId()));
		}

		filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.COBRANCA_ACAO_ID, documentoCobranca
						.getCobrancaAcao().getId()));
		filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.EMPRESA_ID, documentoCobranca.getEmpresa()
						.getId()));
		filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.DOCUMENTO_TIPO_ID, documentoCobranca
						.getDocumentoTipo().getId()));

		Integer servicoTipoId = null;
		Integer supressaoTipoId = null;
		Integer corteTipoId = null;

		FiltroOrdemServico filtro = new FiltroOrdemServico();
		filtro.adicionarParametro(new ParametroSimples(FiltroOrdemServico.COBRANCA_DOCUMENTO_ID, documentoCobranca.getId()));

		Collection<OrdemServico> ordensServico = getControladorUtil().pesquisar(filtro, OrdemServico.class.getName());

		if(ordensServico != null && ordensServico.size() == 1){
			OrdemServico os = ordensServico.iterator().next();
			ServicoTipo servicoTipo = os.getServicoTipo();
			SupressaoTipo supressaoTipo = os.getSupressaoTipo();
			CorteTipo corteTipo = os.getCorteTipo();

			if(servicoTipo != null){
				servicoTipoId = servicoTipo.getId();
			}

			if(supressaoTipoId != null){
				supressaoTipoId = supressaoTipo.getId();
			}

			if(corteTipoId != null){
				corteTipoId = corteTipo.getId();
			}
		}

		if(servicoTipoId != null){
			filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.SERVICO_TIPO_ID, servicoTipoId));
		}else{
			filtroCobrancaSucesso.adicionarParametro(new ParametroNulo(FiltroCobrancaSucesso.SERVICO_TIPO));
		}

		if(supressaoTipoId != null){
			filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.SUPRESSAO_TIPO_ID, supressaoTipoId));
		}else{
			filtroCobrancaSucesso.adicionarParametro(new ParametroNulo(FiltroCobrancaSucesso.SUPRESSAO_TIPO));
		}

		if(corteTipoId != null){
			filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.CORTE_TIPO_ID, corteTipoId));
		}else{
			filtroCobrancaSucesso.adicionarParametro(new ParametroNulo(FiltroCobrancaSucesso.CORTE_TIPO));
		}

		/**
		 * CCRV_DIASVENCIDOS da tabela COBRANCA_CONTRATO_REMUNER_VENC para o número dias mínimo
		 * maior que o número
		 * de dias vencido(PGHI_DTPAGAMENTO -(menos) CNTA_DTVENCIMENTOCONTA) do contrato de sucesso
		 * em questão
		 */
		Integer diasVencido = null;
		int diasDeAtraso = Util.obterQuantidadeDiasEntreDuasDatas(dataVencimentoOuGuia, menorDataPagamento);
		List<Integer> diasVencidosContratoRemuneracaoVencimento = new ArrayList<Integer>();
		CobrancaContrato cobrancaContratoAtivo = null;

		for(CobrancaContrato cobrancaContrato : documentoCobranca.getEmpresa().getCobrancaContratos()){
			if(cobrancaContrato.getDataEncerramento() == null){
				cobrancaContratoAtivo = cobrancaContrato;
				break;
			}
		}
		FiltroCobrancaContratoRemuneracao filtro2 = new FiltroCobrancaContratoRemuneracao();
		filtro2.adicionarParametro(new ParametroSimples(FiltroCobrancaContratoRemuneracao.COBRANCA_CONTRATO_ID, cobrancaContratoAtivo
						.getId()));
		filtro2.adicionarCaminhoParaCarregamentoEntidade("cobrancaContratoRemuneracaoVencimentos");
		// entidade CobrancaContratoRemuneracao dropada
		// Collection<CobrancaContratoRemuneracao> cobrancaContratoRemuneracoes =
		// getControladorUtil().pesquisar(filtro2,
		// CobrancaContratoRemuneracao.class.getName());

		// entidade CobrancaContratoRemuneracao dropada
		// for(CobrancaContratoRemuneracao cobrancaContratoRemuneracao :
		// cobrancaContratoRemuneracoes){
		// if(cobrancaContratoRemuneracao.getContratoTipo().getId().intValue() ==
		// ContratoTipoRemuneracao.TIPO_SUCESSO){
		// Set<CobrancaContratoRemuneracaoPorSucesso> contratoRemuneracaoVencimentos =
		// cobrancaContratoRemuneracao
		// .getCobrancaContratoRemuneracaoVencimentos();
		// for(CobrancaContratoRemuneracaoPorSucesso contratoRemuneracaoVencimento :
		// contratoRemuneracaoVencimentos){
		// diasVencidosContratoRemuneracaoVencimento.add(contratoRemuneracaoVencimento.getDiasVencidos());
		// }
		// }
		// }

		if(!diasVencidosContratoRemuneracaoVencimento.isEmpty()){
			Collections.sort(diasVencidosContratoRemuneracaoVencimento, new Comparator() {

				public int compare(Object o1, Object o2){

					Integer a = (Integer) o1;
					Integer b = (Integer) o2;

					return a.compareTo(b);
				}
			});

			for(Integer diaVencimentoContratoRemuneracaoVencimento : diasVencidosContratoRemuneracaoVencimento){
				if(diasDeAtraso <= diaVencimentoContratoRemuneracaoVencimento){
					diasVencido = diaVencimentoContratoRemuneracaoVencimento;
					break;
				}
			}

			if(diasVencido == null){
				diasVencido = diasDeAtraso;
			}

		}else{
			diasVencido = diasDeAtraso;
		}

		filtroCobrancaSucesso.adicionarParametro(new ParametroSimples(FiltroCobrancaSucesso.DIAS_VENCIDOS, diasVencido));

		Collection<CobrancaSucesso> colecaoCobrancaSucesso = getControladorUtil().pesquisar(filtroCobrancaSucesso,
						CobrancaSucesso.class.getName());

		if(colecaoCobrancaSucesso != null && !colecaoCobrancaSucesso.isEmpty()){

			for(CobrancaSucesso cobrancaSucesso : colecaoCobrancaSucesso){

				if(parcelamento != null){
					if(cobrancaSucesso.getQuantidadeParcelas() == null){
						cobrancaSucesso.setQuantidadeParcelas(Integer.valueOf(parcelamento.getNumeroPrestacoes()));
					}else{
						cobrancaSucesso.setQuantidadeParcelas(cobrancaSucesso.getQuantidadeParcelas()
										+ Integer.valueOf(parcelamento.getNumeroPrestacoes()));
					}
					if(cobrancaSucesso.getValorParcelas() == null){
						cobrancaSucesso.setValorParcelas(valorTotalContaOuGuia);
					}else{
						cobrancaSucesso.setValorParcelas(cobrancaSucesso.getValorParcelas().add(valorParcelasCobradas));
					}
				}else{
					if(cobrancaSucesso.getValorContas() == null){
						cobrancaSucesso.setValorContas(valorTotalContaOuGuia);
					}else{
						cobrancaSucesso.setValorContas(cobrancaSucesso.getValorContas().add(valorTotalContaOuGuia));
					}
				}
				if(colecaoPagamentoHistorico != null){
					if(cobrancaSucesso.getQuantidadeContas() == null){
						cobrancaSucesso.setQuantidadeContas(colecaoPagamentoHistorico.size());
					}else{
						cobrancaSucesso.setQuantidadeContas(cobrancaSucesso.getQuantidadeContas() + colecaoPagamentoHistorico.size());
					}
				}
				cobrancaSucesso.setUltimaAlteracao(new Date());
				getControladorUtil().atualizar(cobrancaSucesso);
			}
		}else{

			if(documentoCobranca.getEmpresa() != null){

				CobrancaSucesso cobrancaSucesso = new CobrancaSucesso();
				cobrancaSucesso.setAnoMesReferencia(null);
				cobrancaSucesso.setDataVencimentoConta(menorDataPagamento);
				cobrancaSucesso.setComandoAcaoCronograma(documentoCobranca.getCobrancaAcaoAtividadeCronograma());
				cobrancaSucesso.setComandoAcaoEventual(documentoCobranca.getCobrancaAcaoAtividadeComando());
				cobrancaSucesso.setCobrancaAcao(documentoCobranca.getCobrancaAcao());
				cobrancaSucesso.setEmpresa(documentoCobranca.getEmpresa());
				cobrancaSucesso.setDocumentoTipo(documentoCobranca.getDocumentoTipo());

				if(parcelamento != null){
					cobrancaSucesso.setQuantidadeParcelas(Integer.valueOf(parcelamento.getNumeroPrestacoes()));
					cobrancaSucesso.setValorParcelas(valorTotalContaOuGuia);
				}else{
					cobrancaSucesso.setValorContas(valorTotalContaOuGuia);
				}

				cobrancaSucesso.setUltimaAlteracao(new Date());

				ServicoTipo servicoTipo = null;
				SupressaoTipo supressaoTipo = null;
				CorteTipo corteTipo = null;
				ordensServico = documentoCobranca.getOrdensServico();

				if(ordensServico != null && ordensServico.size() == 1){
					OrdemServico os = ordensServico.iterator().next();
					servicoTipo = os.getServicoTipo();
					supressaoTipo = os.getSupressaoTipo();
					corteTipo = os.getCorteTipo();
				}

				cobrancaSucesso.setServicoTipo(servicoTipo);
				cobrancaSucesso.setCorteTipo(corteTipo);
				cobrancaSucesso.setSupressaoTipo(supressaoTipo);
				cobrancaSucesso.setDiasVencidos(diasVencido);

				if(colecaoPagamentoHistorico != null){
					cobrancaSucesso.setQuantidadeContas(colecaoPagamentoHistorico.size());
				}

				getControladorUtil().inserir(cobrancaSucesso);

			}
		}
	}

	/**
	 * verificar se há parcela cobrada, a ser remunerada, na conta em questão(CBDO_ID da tabela
	 * PARCELAMENTO diferente
	 * de nulo para PARC_ID = PARC_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da tabela
	 * CONTA)
	 * 
	 * @author eduardo henrique
	 * @date 19/12/2008
	 *       Alteração no método para adequação ao ProcessarPagamentoConta
	 * @param contaHistorico
	 * @return
	 */
	private Parcelamento obterParcelaCobradaASerRemunerada(ContaHistorico contaHistorico){

		Set<DebitoCobradoHistorico> debitosCobrados = contaHistorico.getDebitoCobradoHistoricos();
		for(DebitoCobradoHistorico debitoCobrado : debitosCobrados){
			Parcelamento parcelamento = debitoCobrado.getParcelamento();
			if(parcelamento != null){

				return parcelamento;
			}
		}
		return null;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Calcula o valor total dos pagamentos para a conta
	 * [SF0007] Calcular Valor Total dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 19/04/2006
	 * @param conta
	 *            ,
	 *            colecaoPagamentos
	 * @return BigDecimal
	 */
	public BigDecimal calcularValorTotalPagamentos(Collection<Pagamento> colecaoPagamentos) throws ControladorException{

		BigDecimal valorTotalPagamentos = BigDecimal.ZERO;
		BigDecimal valorPagamentos = BigDecimal.ZERO;
		BigDecimal valorExcedente = BigDecimal.ZERO;

		Iterator iteratorColecaoPagamentos = colecaoPagamentos.iterator();

		while(iteratorColecaoPagamentos.hasNext()){

			Pagamento pagamento = (Pagamento) iteratorColecaoPagamentos.next();

			// Acumula o valor dos pagamentos (PGMT_VLPAGAMENTO) do conjunto que
			// está sendo processado
			if(pagamento.getValorPagamento() != null){
				valorPagamentos = valorPagamentos.add(pagamento.getValorPagamento());
			}

			/*
			 * Acumula o valor excedente dos pagamentos (PGMT_VLEXCEDENTE) do
			 * conjunto que está sendo processado que tenha situação atual
			 * (PGST_IDATUAL) com valor correspondente a baixar valor excedente
			 * (tabela PAGAMENTO_SITUACAO)
			 */
			if(pagamento.getPagamentoSituacaoAtual() != null
							&& pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR)
							&& pagamento.getValorExcedente() != null){
				valorExcedente = valorExcedente.add(pagamento.getValorExcedente());
			}
		}

		// Retorna o valor total dos pagamentos = valor dos pagamentos - valor
		// excedente dos pagamentos
		valorTotalPagamentos = valorPagamentos.subtract(valorExcedente);
		valorTotalPagamentos = valorTotalPagamentos.setScale(2);

		return valorTotalPagamentos;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Processar Pagamento a Maior ou a Menor
	 * [SB0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 19/04/2006, 12/12/2006
	 * @param valorTotalPagamentos
	 * @param valorDocumento
	 * @param colecaoPagamentos
	 * @return
	 * @throws ControladorException
	 */
	protected Object[] processarPagamentoAMenorOUAMaior(BigDecimal valorTotalPagamentos, BigDecimal valorDocumento,
					Collection<Pagamento> colecaoPagamentos, Integer identificadorDocumento) throws ControladorException{

		/* Declaração de variáveis */
		Object[] arrayColecoesPagamentosAtualizar = new Object[7];

		Collection colecaoPagamentoValorAMenor = new ArrayList();
		Collection colecaoPagamentoValorAMaior = new ArrayList();
		// .................................................................

		Collection colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo = new ArrayList();
		Collection colecaoPagamentoClassificado = new ArrayList();
		Collection colecaoPagamentoEmDuplicidade = new ArrayList();
		Collection colecaoPagamentoAtualizarValorExcedente = new ArrayList();
		boolean flagIndicadorExistePagamentoValorDocumento = false;

		/*
		 * Caso o valor total dos pagamentos seja menor que o valor do
		 * documento, atualizar a situacao atual dos pagamentos (PGST_IDATUAL)
		 * com valor correspondente a valor não confere (tabela
		 * PAGAMENTO_SITUACAO) e atualizar o identificador do documento no
		 * pagamento com o identificador do documento (CNTA_ID,GPAG_ID ou
		 * DBAC_ID conforme seja conta, guia de pagamento ou débito a cobrar
		 * respectivamente,no pagamento)
		 */
		if(valorTotalPagamentos.compareTo(valorDocumento) == -1){
			colecaoPagamentoValorAMenor.addAll(colecaoPagamentos);
		}else{

			BigDecimal saldoDevido = valorDocumento;
			Collection colecaoPagamentosValorIgual = new ArrayList();
			Collection colecaoPagamentosValorDiferente = new ArrayList();

			Iterator iteratorColecaoPagamentos = colecaoPagamentos.iterator();
			while(iteratorColecaoPagamentos.hasNext()){
				Pagamento pagamento = (Pagamento) iteratorColecaoPagamentos.next();

				if(pagamento.getValorPagamento().compareTo(valorDocumento) == 0){

					if(DocumentoTipo.DEBITO_A_COBRAR.equals(pagamento.getDocumentoTipo().getId())
									&& (pagamento.getNumeroPrestacao() != null && pagamento.getNumeroPrestacao().intValue() != 0)){
						colecaoPagamentosValorDiferente.add(pagamento);
					}else{
						colecaoPagamentosValorIgual.add(pagamento);
					}

				}else{
					colecaoPagamentoValorAMaior.add(pagamento);
				}
			}

			// Para os pagamentos cujo valor (PGMT_VLPAGAMENTO) seja igual ao valor do documento:
			if(colecaoPagamentosValorIgual != null && !colecaoPagamentosValorIgual.isEmpty()){

				flagIndicadorExistePagamentoValorDocumento = true;
				saldoDevido = BigDecimal.ZERO;

				/*
				 * Atualizar a situação atual do pagamento (PGST_IDATUAL), que tenha a data de
				 * pagamento mais antiga (PGMT_DTPAGAMENTO), com o valor
				 * correspondente a pagamento classificado (tabela PAGAMENTO_SITUACAO);
				 */
				Iterator iteratorColecaoPagamentosValorIgual = colecaoPagamentosValorIgual.iterator();
				Pagamento pagamentoDataPgMaisAntiga = null;

				while(iteratorColecaoPagamentosValorIgual.hasNext()){

					Pagamento pagamento = (Pagamento) iteratorColecaoPagamentosValorIgual.next();

					if(pagamentoDataPgMaisAntiga == null && pagamento.getDataPagamento() != null){
						pagamentoDataPgMaisAntiga = pagamento;
					}else if(pagamento.getDataPagamento() != null){

						if(pagamentoDataPgMaisAntiga.getDataPagamento().after(pagamento.getDataPagamento())){
							pagamentoDataPgMaisAntiga = pagamento;
						}
					}
				}

				if(pagamentoDataPgMaisAntiga != null){
					colecaoPagamentoClassificado.add(pagamentoDataPgMaisAntiga);
				}

				colecaoPagamentosValorIgual.remove(pagamentoDataPgMaisAntiga);

				/* Item 2.2.3 Para os outros pagamentos */
				iteratorColecaoPagamentosValorIgual = colecaoPagamentosValorIgual.iterator();

				while(iteratorColecaoPagamentosValorIgual.hasNext()){

					Pagamento pagamento = (Pagamento) iteratorColecaoPagamentosValorIgual.next();

					/*
					 * Caso a situação atual (PGST_IDATUAL) esteja com valor diferente de baixar
					 * valor excedente (tabela PAGAMENTO_SITUACAO),
					 * atualizar a situação atual (PGST_IDATUAL) com o valor correspondente a
					 * pagamento em duplicidade/excesso (tabela
					 * PAGAMENTO_SITUACAO);
					 */
					if(pagamento.getPagamentoSituacaoAtual() == null
									|| !pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR)){
						colecaoPagamentoEmDuplicidade.add(pagamento);
					}

					/* [SF0009] Atualizar Valor Excedente do Pagamento */
					Object[] dadosPagamento = this.atualizarValorExcedentePagamento(pagamento, saldoDevido);

					if(dadosPagamento != null){
						saldoDevido = (BigDecimal) dadosPagamento[0];
						colecaoPagamentoAtualizarValorExcedente.add(dadosPagamento[1]);
					}
				}
			}

			// Para os pagamentos cujo valor (PGMT_VLPAGAMENTO) seja diferente do valor do
			// documento:
			if(colecaoPagamentosValorDiferente != null && !colecaoPagamentosValorDiferente.isEmpty()){

				Iterator iteratorColecaoPagamentosValorDiferente = colecaoPagamentosValorDiferente.iterator();

				while(iteratorColecaoPagamentosValorDiferente.hasNext()){

					Pagamento pagamento = (Pagamento) iteratorColecaoPagamentosValorDiferente.next();

					if(flagIndicadorExistePagamentoValorDocumento){
						colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo.add(pagamento);
					}

					/* [SF0009] Atualizar Valor Excedente do Pagamento */
					Object[] dadosPagamento = this.atualizarValorExcedentePagamento(pagamento, saldoDevido);

					if(dadosPagamento != null){
						saldoDevido = (BigDecimal) dadosPagamento[0];
						colecaoPagamentoAtualizarValorExcedente.add(dadosPagamento[1]);
					}
				}
			}
		}

		/**
		 * Retorna um array contendo :
		 * 0 - Coleção de pagamentos para atualizar situação igual a valor não confere.
		 * 1 - Coleção de pagamentos para atualizar situação igual a pagamento classificado.
		 * 2 - Coleção de pagamentos para atualizar situação igual a pagamento em duplicidade.
		 * 3 - Coleção de pagamentos para atualizar valor excedente.
		 * 4 - Coleção de pagamentos para atualizar situação igual a valor não confere e remover
		 * referência.
		 */
		arrayColecoesPagamentosAtualizar[1] = colecaoPagamentoClassificado;
		arrayColecoesPagamentosAtualizar[2] = colecaoPagamentoEmDuplicidade;
		arrayColecoesPagamentosAtualizar[3] = colecaoPagamentoAtualizarValorExcedente;
		arrayColecoesPagamentosAtualizar[4] = colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo;

		arrayColecoesPagamentosAtualizar[5] = colecaoPagamentoValorAMenor;
		arrayColecoesPagamentosAtualizar[6] = colecaoPagamentoValorAMaior;

		return arrayColecoesPagamentosAtualizar;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Atualizar Valor Excedente do Pagamento
	 * [SF0009] Atualizar Valor Excedente do Pagamento
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 25/04/2006
	 * @param pagamento
	 * @param saldoDevido
	 * @return
	 * @throws ControladorException
	 */
	protected Object[] atualizarValorExcedentePagamento(Pagamento pagamento, BigDecimal saldoDevido) throws ControladorException{

		Object[] retorno = null;
		BigDecimal novoSaldoDevido = saldoDevido;

		if(pagamento.getValorPagamento() != null && saldoDevido != null){

			retorno = new Object[2];
			/*
			 * Caso o valor do pagamento (PGMT_VLPAGAMENTO) seja menor que o
			 * saldo devido, atualizar o valor excedente do pagamento
			 * (PGMT_VLEXCEDENTE) com o valor zero e subtrair o valor do
			 * pagamento do saldo devido (saldo devido = saldo devido - valor do
			 * pagamento);
			 */
			if(pagamento.getValorPagamento().compareTo(saldoDevido) == -1){
				pagamento.setValorExcedente(BigDecimal.ZERO);
				novoSaldoDevido = novoSaldoDevido.subtract(pagamento.getValorPagamento());
			}
			/*
			 * Caso contrário, atualizar o valor excedente do pagamento
			 * (PGMT_VLEXCEDENTE) com o valor do pagamento menos o saldo devido
			 * (valor excedente do pagamento = valor do pagamento - saldo
			 * devido) e atribuir o valor zero ao saldo devido Para os
			 * pagamentos cujo valor (PGMT_VLPAGAMENTO) seja igual ao valor do
			 * documento: - Atualizar a situação atual do pagamento
			 * (PGST_IDATUAL), que tenha a data de pagamento mais antiga
			 * (PGMT_DTPAGAMENTO), com o valor correspondente a pagamento
			 * classificado (tabela PAGAMENTO_SITUACAO); - Atribuir o valor zero
			 * ao saldo devido; - Para os outros pagamentos: - Caso a situação
			 * atual (PGST_IDATUAL) esteja com valor diferente de baixar valor
			 * excedente (tabela PAGAMENTO_SITUACAO), atualizar a situação atual
			 * (PGST_IDATUAL) com o valor correspondente a pagamento em
			 * duplicidade/excesso (tabela PAGAMENTO_SITUACAO); - Atualizar o
			 * valor excedente [SB0009 - Atualizar Valor Excedente do
			 * Pagamento].
			 */
			else{
				BigDecimal vlExcedente = pagamento.getValorPagamento().subtract(saldoDevido);
				pagamento.setValorExcedente(vlExcedente);
				novoSaldoDevido = BigDecimal.ZERO;
			}

			/**
			 * Retorna o array contendo: 0 - novo saldo devido. 1 - pagamento a
			 * ser atualizado.
			 */
			retorno[0] = novoSaldoDevido;
			retorno[1] = pagamento;
		}
		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Processar Pagamento de Guia de Pagamento
	 * [SB0004] Processar Pagamento de Guia de Pagamento
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 26/04/2006, 08/12/2006
	 * @author eduardo henrique
	 * @date 20/12/2008
	 *       Alteração no método para a busca da guia pagamento em Histórico, após transferência
	 *       para histórico da mesma.
	 * @param guiaPagamento
	 * @param colecaoPagamentos
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	protected Collection<Pagamento> processarPagamentoGuiaPagamento(GuiaPagamento guiaPagamento, Collection<Pagamento> colecaoPagamentos)
					throws ControladorException{

		Collection<Pagamento> retorno = new ArrayList<Pagamento>();
		Collection<Integer> idsDebitosACobrar = new ArrayList<Integer>();
		Integer numeroPrestacao = null;
		Imovel imovel = null;

		Date maiorDataPagamento = null;
		Date dataPagamentoAux = null;

		if(!Util.isVazioOrNulo(colecaoPagamentos)){
			for(Pagamento pagamento : colecaoPagamentos){
				numeroPrestacao = pagamento.getNumeroPrestacao();
				imovel = pagamento.getImovel();

				dataPagamentoAux = pagamento.getDataPagamento();

				if(maiorDataPagamento == null
								|| (dataPagamentoAux != null && maiorDataPagamento != null && dataPagamentoAux
												.compareTo(maiorDataPagamento) > 0)){
					maiorDataPagamento = dataPagamentoAux;
				}
			}
		}

		if(numeroPrestacao == null){
			if(guiaPagamento.getNumeroPrestacaoTotal().equals(Short.valueOf("1"))){
				numeroPrestacao = Integer.valueOf(1);
			}
		}

		if(numeroPrestacao != null){

			// Atribuir o valor da guia de pagamento (GPAG_VLDEBITO) ao valor do documento
			BigDecimal valorDocumento = BigDecimal.ZERO;

			FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
							guiaPagamento.getId()));
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
							numeroPrestacao));

			Collection colecaoGuiaPagamentoPrestacao = getControladorUtil().pesquisar(filtroGuiaPagamentoPrestacao,
							GuiaPagamentoPrestacao.class.getName());
			if(colecaoGuiaPagamentoPrestacao == null || colecaoGuiaPagamentoPrestacao.isEmpty()){

				// consultar no histórico
				FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
				filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
								FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, guiaPagamento.getId()));
				filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
								FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacao));

				Collection colecaoGuiaPagamentoPrestacaoHistorico = getControladorUtil().pesquisar(filtroGuiaPagamentoPrestacaoHistorico,
								GuiaPagamentoPrestacaoHistorico.class.getName());

				if(colecaoGuiaPagamentoPrestacaoHistorico == null || colecaoGuiaPagamentoPrestacaoHistorico.isEmpty()){
					System.out.println("Indentificação do objeto não localizado 'GuiaPagamentoPrestacao': Guia e Prestação "
									+ guiaPagamento.getId() + " " + numeroPrestacao);
					throw new ControladorException("atencao.atualizacao.removido");
				}

			}else{
				for(Iterator iteratorGuiaPrestacao = colecaoGuiaPagamentoPrestacao.iterator(); iteratorGuiaPrestacao.hasNext();){
					GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) iteratorGuiaPrestacao.next();
					valorDocumento = valorDocumento.add(guiaPagamentoPrestacao.getValorPrestacao());
				}
			}

			/* Declaração de variáveis */
			Map mapPagamentosProcessados = new HashMap<Integer, Collection<Pagamento>>();
			Object[] arrayColecoesPagamentosAtualizar = null;

			/* [SF0007] Calcular Valor Total dos Pagamentos */
			BigDecimal valorTotalPagamentosGuiaPagamento = this.calcularValorTotalPagamentos(colecaoPagamentos);

			BigDecimal diferenca = valorTotalPagamentosGuiaPagamento.subtract(valorDocumento);

			Date dataEmissao = null;

			// Parâmetro que identifica se a empresa emite o documento com acrescimos
			String parametroTratarAcrescimosEmissaoDocumento = ParametroArrecadacao.P_TRATAR_ACRESCIMOS_EMISSAO_DOCUMENTO.executar()
							.toString();

			// Parâmetro que identifica se a empresa emite o documento com acrescimos
			String parametroPermitirSelecaoAcrescimosExtrato = ParametroArrecadacao.P_PERMITIR_SELECAO_ACRESCIMOS_EXTRATO.executar()
							.toString();

			if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)
							&& ((!Util.isVazioOuBranco(parametroTratarAcrescimosEmissaoDocumento) && parametroTratarAcrescimosEmissaoDocumento
											.equals(Short.toString(ConstantesSistema.SIM))) || parametroPermitirSelecaoAcrescimosExtrato
											.equals(Short.toString(ConstantesSistema.SIM))) && diferenca.compareTo(BigDecimal.ZERO) > 0
							&& imovel != null){

				// Quando a diferença entre o valor pago e o valor da guia for maior que zero e a
				// empresa realize a emissão de documentos com acréscimos, o sistema deve calcular
				// os acréscimos que deveriam ser cobrados e realizar uma retificação

				Object[] retornoTratamento = this.tratarAcrescimosPagamentoGuia(guiaPagamento, colecaoGuiaPagamentoPrestacao,
								colecaoPagamentos, diferenca, valorDocumento);

				diferenca = (BigDecimal) retornoTratamento[0];

				dataEmissao = (Date) retornoTratamento[1];
			}

			/*
			 * Caso valor total dos pagamentos para a guia de pagamento seja igual
			 * ao valor do documento atualizar a situação atual dos pagamentos
			 * (PGST_IDATUAL) com valor correspondente a pagamento classificado
			 * (tabela PAGAMENTO_SITUACAO) e atualizar o id da guia de pagamento nos
			 * pagamentos (seta GPAG_ID da tabela PAGAMENTO para GPAG_ID da tabela
			 * GUIA_PAGAMENTO);
			 */
			if(diferenca.compareTo(BigDecimal.ZERO) == 0){
				retorno.addAll(colecaoPagamentos);
				mapPagamentosProcessados.put(guiaPagamento.getId(), colecaoPagamentos);

			}else{

				/* [SF0008] Processar Pagamento a Maior ou a Menor */
				arrayColecoesPagamentosAtualizar = this.processarPagamentoAMenorOUAMaior(valorTotalPagamentosGuiaPagamento, valorDocumento,
								colecaoPagamentos, guiaPagamento.getId());

				Collection<Pagamento> colecaoPagamentosClassificados = (Collection) arrayColecoesPagamentosAtualizar[1];

				if(colecaoPagamentosClassificados != null && !colecaoPagamentosClassificados.isEmpty()){
					mapPagamentosProcessados.put(guiaPagamento.getId(), colecaoPagamentosClassificados);
					retorno.addAll(colecaoPagamentosClassificados);
				}
			}

			try{

				if(mapPagamentosProcessados != null && !mapPagamentosProcessados.isEmpty()){
					this.repositorioArrecadacao.processarPagamentoGuiaPagamento(mapPagamentosProcessados, numeroPrestacao);

					// [UC 0302] -- Calculo de Acrescimos; Para cada guia do Map, itera nos
					// pagamentos encontrados
					Collection<Integer> idsDebitosACobrarAux = new ArrayList<Integer>();
					Collection<Integer> idsDebitosACobrarAtualizarIndicador = new ArrayList<Integer>();

					Object retornoExecutor = null;
					boolean atualizarRemuneraCobrancaAdministrativa = false;

					Collection<Integer> colecaoIdsGuiaPagamento = mapPagamentosProcessados.keySet();

					for(Integer idGuia : colecaoIdsGuiaPagamento){
						Collection<Pagamento> pagamentosGuia = (Collection<Pagamento>) mapPagamentosProcessados.get(idGuia);

						if(pagamentosGuia != null){
							for(Pagamento pagamento : pagamentosGuia){
								idsDebitosACobrarAux = this.getControladorFaturamento()
												.gerarDebitosACobrarDeAcrescimosPorImpontualidadeBancoDeDados(pagamento, dataEmissao);

								if(!Util.isVazioOrNulo(idsDebitosACobrarAux)){
									retornoExecutor = ParametroArrecadacao.P_GERACAO_ACRESCIMOS_COBRANCA_ADMINISTRATIVA.executar(this, -1,
													pagamento);

									if(retornoExecutor != null){
										atualizarRemuneraCobrancaAdministrativa = (Boolean) retornoExecutor;
									}

									if(atualizarRemuneraCobrancaAdministrativa){
										idsDebitosACobrarAtualizarIndicador.addAll(idsDebitosACobrarAux);
									}

									idsDebitosACobrar.addAll(idsDebitosACobrarAux);
								}
							}
						}
					}

					if(!Util.isVazioOrNulo(idsDebitosACobrarAtualizarIndicador)){
						Collection colecaoDebitoACobrarAtualizar = new ArrayList();

						FiltroDebitoACobrar filtroDebitoACobrar = null;
						Collection<DebitoACobrar> colecaoDebitoACobrar = null;

						for(Integer idDebitoACobrar : idsDebitosACobrarAtualizarIndicador){
							filtroDebitoACobrar = new FiltroDebitoACobrar();
							filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));

							colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());

							if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){
								for(DebitoACobrar debitoACobrar : colecaoDebitoACobrar){
									debitoACobrar.setIndicadorRemuneraCobrancaAdministrativa(ConstantesSistema.SIM);

									colecaoDebitoACobrarAtualizar.add(debitoACobrar);
								}
							}
						}

						if(!Util.isVazioOrNulo(colecaoDebitoACobrarAtualizar)){
							this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoDebitoACobrarAtualizar);
						}
					}

					// 3.4. O sistema transfere para o histórico de pagamentos
					// (PAGAMENTO_HISTORICO), os pagamentos classificados
					// (PGST_IDATUAL com o valor correspondente a pagamento classificado);
					/* PARTE 1 */
					Collection<Pagamento> colecaoTemp = (Collection<Pagamento>) mapPagamentosProcessados.get(guiaPagamento.getId());
					Collection colecaoPagamentosPreenchida = this.carregarAtributosPagamento(colecaoTemp);

					Collection colecaoPagamentoHistorico = this.criarPagamentoHistoricoDoPagamento(colecaoPagamentosPreenchida,
									PagamentoSituacao.PAGAMENTO_CLASSIFICADO);
					getControladorBatch().removerColecaoObjetoParaBatch(colecaoPagamentosPreenchida);

					FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
					filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, guiaPagamento.getId()));
					filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("guiasPagamentoPrestacao");
					filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("guiasPagamentoCategoria");
					Collection<GuiaPagamento> colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamento,
									GuiaPagamento.class.getName());
					GuiaPagamento guiaPreenchida = null;
					if(colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()){
						guiaPreenchida = colecaoGuiaPagamento.iterator().next();
					}

					if(guiaPreenchida != null){
						this.transferirGuiaPagamentoParaHistorico(guiaPreenchida, numeroPrestacao);

						Integer idGuiaPagamento = guiaPreenchida.getId();

						// Verifica se há relação entre a prestação da guia de pagamento paga e
						// algum item de documento de cobrança - [UC3082] Atualizar Item Documento
						// Cobrança]
						this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamento, numeroPrestacao.shortValue(),
										null, CobrancaDebitoSituacao.PAGO, maiorDataPagamento, CobrancaDebitoSituacao.PENDENTE);
					}

					/* 4.4 PARTE 2 */
					this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoPagamentoHistorico);

					/*
					 * TODO
					 * Pendência na versão 0.07 - Falta Customizar o [UC1015]
					 * Saulo Lima - 20/11/2008
					 */
					// 3.5. Efetuar os lançamentos (contabilização) relativos à baixa da conta
					// <<Inclui>> [UC1015 – Gerar/Atualizar Resumo da Arrecadação]
					// System.out.println("# Chamar o UC1015. #");

					/*
					 * 3.6. Caso a guia classificada corresponda a uma entrada de parcelamento
					 * (PARC_ID da
					 * tabela GUIA_PAGAMENTO diferente de nulo), verificar se há documento de
					 * cobrança
					 * vinculado (CBDO_ID da tabela PARCELAMENTO com PARC_ID = PARC_ID da tabela
					 * GUIA_PAGAMENTO diferente de nulo)
					 */
					FiltroGuiaPagamentoHistorico filtroGuiaPagHistorico = new FiltroGuiaPagamentoHistorico();
					filtroGuiaPagHistorico.setInitializeLazy(false);
					filtroGuiaPagHistorico.adicionarCaminhoParaCarregamentoEntidade("guiasPagamentoPrestacaoHistorico");
					filtroGuiaPagHistorico.adicionarCaminhoParaCarregamentoEntidade("parcelamento.cobrancaDocumento");
					filtroGuiaPagHistorico.adicionarCaminhoParaCarregamentoEntidade("parcelamento.cobrancaDocumento.empresa");
					filtroGuiaPagHistorico
									.adicionarCaminhoParaCarregamentoEntidade("parcelamento.cobrancaDocumento.empresa.cobrancaContratos");
					filtroGuiaPagHistorico.adicionarCaminhoParaCarregamentoEntidade("parcelamento.cobrancaDocumento.ordensServico");
					filtroGuiaPagHistorico
									.adicionarCaminhoParaCarregamentoEntidade("parcelamento.cobrancaDocumento.cobrancaDocumentoItems");
					filtroGuiaPagHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, guiaPagamento.getId()));
					Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = this.getControladorUtil().pesquisar(
									filtroGuiaPagHistorico, GuiaPagamentoHistorico.class.getName());

					if(colecaoGuiaPagamentoHistorico != null && !colecaoGuiaPagamentoHistorico.isEmpty()){

						GuiaPagamentoHistorico guiaPagamentoHistorico = colecaoGuiaPagamentoHistorico.iterator().next();
						if(guiaPagamentoHistorico.getParcelamento() != null
										&& guiaPagamentoHistorico.getParcelamento().getCobrancaDocumento() != null){

							/*
							 * 3.6. Caso a guia classificada corresponda a uma entrada de
							 * parcelamento (PARC_ID da tabela GUIA_PAGAMENTO
							 * diferente de nulo), verificar se há documento de cobrança vinculado
							 * (CBDO_ID da tabela PARCELAMENTO com PARC_ID =
							 * PARC_ID da tabela GUIA_PAGAMENTO diferente de nulo)
							 */
							CobrancaDocumento documentoCobranca = guiaPagamentoHistorico.getParcelamento().getCobrancaDocumento();

							/*
							 * 3.6.2. Caso o agente de cobrança vinculado ao documento (EMPR_ID da
							 * tabela DOCUMENTO_COBRANCA diferente de
							 * nulo) tenha contrato de remuneração por sucesso ativo
							 * (COBRANCA_CONTRATO_REMUNER com CBRT_ID com valor
							 * correspondente a “Sucesso” para COBRANCA_CONTRATO_REMUNER com CBCO_ID
							 * = CBCO_ID da tabela COBRANCA_CONTRATO com
							 * CBCO_DTCONTRATOENCERRAMENTO = Nulo e EMPR_ID = EMPR_ID da tabela
							 * DOCUMENTO_COBRANCA), efetuar a atualização da
							 * remuneração(acumular valores caso já exista ou inserir)
							 */
							Empresa agCobranca = documentoCobranca.getEmpresa();
							// entidade CobrancaContratoRemuneracao dropada
							// CobrancaContratoRemuneracao cobrancaContratoRemuneracaoSelecionado =
							// null;
							if(agCobranca != null){
								boolean flagAtualizarRemuneracao = false;
								Set<CobrancaContrato> contratosCobranca = agCobranca.getCobrancaContratos();
								for(CobrancaContrato contratoCobranca : contratosCobranca){
									if(flagAtualizarRemuneracao){
										break;
									}else if(contratoCobranca.getDataEncerramento() == null){
										FiltroCobrancaContratoRemuneracao filtro = new FiltroCobrancaContratoRemuneracao();
										filtro.adicionarParametro(new ParametroSimples(
														FiltroCobrancaContratoRemuneracao.COBRANCA_CONTRATO_ID, contratoCobranca.getId()));
										// entidade CobrancaContratoRemuneracao dropada
										// Collection<CobrancaContratoRemuneracao>
										// cobrancaContratosRemuneracao = getControladorUtil()
										// .pesquisar(filtro,
										// CobrancaContratoRemuneracao.class.getName());
										//
										// for(CobrancaContratoRemuneracao
										// cobrancaContratoRemuneracao :
										// cobrancaContratosRemuneracao){
										// if(cobrancaContratoRemuneracao.getContratoTipo().getId().intValue()
										// == ContratoTipoRemuneracao.TIPO_SUCESSO){
										// cobrancaContratoRemuneracaoSelecionado =
										// cobrancaContratoRemuneracao;
										// flagAtualizarRemuneracao = true;
										// }
										// }
									}
								}
								if(flagAtualizarRemuneracao){
									Date menorDataVencimento = null;
									Iterator iter = guiaPagamentoHistorico.getGuiasPagamentoPrestacaoHistorico().iterator();
									while(iter.hasNext()){
										GuiaPagamentoPrestacaoHistorico gpp = (GuiaPagamentoPrestacaoHistorico) iter.next();
										Date dataPg = gpp.getDataVencimento();
										if(menorDataVencimento == null || dataPg.before(menorDataVencimento)){
											menorDataVencimento = dataPg;
										}
									}
									insereOuAtualizaCobrancaSucesso(documentoCobranca, colecaoPagamentoHistorico, menorDataVencimento,
													guiaPagamentoHistorico.getValorDebito(), guiaPagamentoHistorico.getValorDebito(),
													guiaPagamentoHistorico.getParcelamento());
								}
							}

							// // Se o parâmetro da Contra-Ação do parcelamento for no ato do
							// // "Pagamento da entrada do Parcelamento", verificar Contra-Ação
							// String contraAcaoParcelamentoIndicador =
							// ConstantesAplicacao.get("aplicacao.contra_acao.parcelamento");
							// if(contraAcaoParcelamentoIndicador != null &&
							// Util.isInteger(contraAcaoParcelamentoIndicador)){
							//
							// int contraAcaoIndicador =
							// Util.converterStringParaInteger(contraAcaoParcelamentoIndicador);
							// if(contraAcaoIndicador ==
							// ContraAcao.CONTRA_ACAO_PAGAMENTO_ENTRADA_PARCELAMENTO){
							//
							// Collection<CobrancaDocumentoItem> cobrancaDocumentoItens =
							// documentoCobranca
							// .getCobrancaDocumentoItems();
							//
							// CobrancaDocumentoItem cobrancaDocumentoItem =
							// cobrancaDocumentoItens.iterator().next();
							//
							// ContaGeral conta = cobrancaDocumentoItem.getContaGeral();
							//
							// /**
							// * Chamar metodo para realizar Contra-ação
							// * Andre Nishimura 26/04/2010
							// */
							// this.getControladorCobranca().validaDocumentoCobrancaPagamentoParaContraAcao(conta.getId());
							// }
							// }

						}
					}
				}

				if(arrayColecoesPagamentosAtualizar != null){
					/**
					 * Rebebe o retorno de array contendo :
					 * 0 - Coleção de pagamentos para atualizar situação igual a valor não confere.
					 * 1 - Coleção de pagamentos para atualizar situação igual a pagamento
					 * classificado.
					 * 2 - Coleção de pagamentos para atualizar situação igual a pagamento em
					 * duplicidade.
					 * 3 - Coleção de pagamentos para atualizar valor excedente.
					 * 4 - Coleção de pagamentos para atualizar situação igual a valor não confere e
					 * remover referência.
					 */
					if(arrayColecoesPagamentosAtualizar[0] != null && !((Map) arrayColecoesPagamentosAtualizar[0]).isEmpty()){
						this.repositorioArrecadacao.processarPagamentoValorNaoConfereGuiaPagamento(
										(Map) arrayColecoesPagamentosAtualizar[0], numeroPrestacao);
					}
					// arrayColecoesPagamentosAtualizar[1] -> Já processado anteriormente
					if(arrayColecoesPagamentosAtualizar[2] != null && !((Collection) arrayColecoesPagamentosAtualizar[2]).isEmpty()){
						this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_DUPLICADO,
										(Collection) arrayColecoesPagamentosAtualizar[2]);
					}
					if(arrayColecoesPagamentosAtualizar[3] != null && !((Collection) arrayColecoesPagamentosAtualizar[3]).isEmpty()){
						this.repositorioArrecadacao.atualizarValorExcedentePagamento((Collection) arrayColecoesPagamentosAtualizar[3]);
					}
					if(arrayColecoesPagamentosAtualizar[4] != null && !((Collection) arrayColecoesPagamentosAtualizar[4]).isEmpty()){
						this.repositorioArrecadacao
										.processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo((Collection) arrayColecoesPagamentosAtualizar[4]);
					}

					// ________________________________________________________________
					// Alterado por Yara Souza
					// Data : 27/07/2010
					// _________________________________________________________________

					if(arrayColecoesPagamentosAtualizar[5] != null && !((Collection) arrayColecoesPagamentosAtualizar[5]).isEmpty()){
						this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_A_MENOR,
										(Collection) arrayColecoesPagamentosAtualizar[5]);
					}

					if(arrayColecoesPagamentosAtualizar[6] != null && !((Collection) arrayColecoesPagamentosAtualizar[6]).isEmpty()){
						this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_A_MAIOR,
										(Collection) arrayColecoesPagamentosAtualizar[6]);
					}
					// ...................................................................

				}

				this.getControladorFaturamento().registrarLancamentoContabilDebitoACobrar(idsDebitosACobrar);

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
		}
		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Processar Devoluções de Pagamento
	 * [SF0011] Processar Devoluções de Pagamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/04/2006
	 * @param Collection
	 *            <Devolucao>, Collection<Pagamento>
	 * @return void
	 */
	public void processarDevolucaoPagamento(Collection<Devolucao> colecaoDevolucao, Collection<Pagamento> colecaoPagamento)
					throws ControladorException{

		Devolucao devolucaoColecao = null;
		Pagamento pagamentoColecao = null;
		BigDecimal valorTotalDevolucoes = BigDecimal.ZERO;
		BigDecimal valorTotalExcedente = BigDecimal.ZERO;

		Iterator iteratorColecaoPagamento = null;
		Iterator iteratorColecaoDevolucao = null;
		String[] idPagamento = new String[1];
		String[] idDevolucao = new String[1];

		if(colecaoDevolucao != null && !colecaoDevolucao.isEmpty()){

			iteratorColecaoDevolucao = colecaoDevolucao.iterator();

			while(iteratorColecaoDevolucao.hasNext()){
				devolucaoColecao = (Devolucao) iteratorColecaoDevolucao.next();

				if(devolucaoColecao.getValorDevolucao() != null){
					valorTotalDevolucoes = valorTotalDevolucoes.add(devolucaoColecao.getValorDevolucao());
				}
			}

		}

		if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){

			iteratorColecaoPagamento = colecaoPagamento.iterator();

			while(iteratorColecaoPagamento.hasNext()){
				pagamentoColecao = (Pagamento) iteratorColecaoPagamento.next();

				if(pagamentoColecao.getValorExcedente() != null){
					valorTotalExcedente = valorTotalExcedente.add(pagamentoColecao.getValorExcedente());
				}
			}

		}

		// Caso o valor total das devoluções seja igual ao valor total excedente
		// dos pagamentos
		if(valorTotalDevolucoes.equals(valorTotalExcedente)){

			SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

			if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){

				iteratorColecaoPagamento = colecaoPagamento.iterator();

				while(iteratorColecaoPagamento.hasNext()){
					pagamentoColecao = (Pagamento) iteratorColecaoPagamento.next();

					idPagamento[0] = String.valueOf(pagamentoColecao.getId());

					try{

						repositorioArrecadacao.atualizarSituacaoPagamento(idPagamento, PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO);

					}catch(ErroRepositorioException ex){
						ex.printStackTrace();
						throw new ControladorException("erro.sistema", ex);
					}

					if(pagamentoColecao.getAnoMesReferenciaArrecadacao() == sistemaParametro.getAnoMesArrecadacao().intValue()){

						try{

							repositorioArrecadacao.atualizarSituacaoAnteriorPagamento(idPagamento,
											PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);

						}catch(ErroRepositorioException ex){
							ex.printStackTrace();
							throw new ControladorException("erro.sistema", ex);
						}
					}
				}
			}

			// Para todas a devoluções do conjunto que está sendo processado
			if(colecaoDevolucao != null && !colecaoDevolucao.isEmpty()){

				iteratorColecaoDevolucao = colecaoDevolucao.iterator();

				while(iteratorColecaoDevolucao.hasNext()){

					devolucaoColecao = (Devolucao) iteratorColecaoDevolucao.next();

					idDevolucao[0] = String.valueOf(devolucaoColecao.getId());

					if(devolucaoColecao.getGuiaDevolucao() != null){

						try{

							repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao, DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA);

						}catch(ErroRepositorioException ex){
							ex.printStackTrace();
							throw new ControladorException("erro.sistema", ex);
						}

					}else{

						try{

							repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao, DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);

						}catch(ErroRepositorioException ex){
							ex.printStackTrace();
							throw new ControladorException("erro.sistema", ex);
						}
					}

				}
			}
		}else{

			// [SB0013 - Processar Devolução a Maior ou a Menor]
			this.processarDevolucaoAMaiorOUAMenor(colecaoDevolucao, valorTotalDevolucoes, colecaoPagamento, valorTotalExcedente);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Processar Devolução a Maior ou a Menor
	 * [SF0013] Processar Devolução a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter,Pedro Alexandre
	 * @date 15/06/2006, 10/07/2007
	 * @param colecaoDevolucao
	 * @param valorTotalDevolucoes
	 * @param colecaoPagamento
	 * @param valorTotalExcedente
	 * @throws ControladorException
	 */
	public void processarDevolucaoAMaiorOUAMenor(Collection<Devolucao> colecaoDevolucao, BigDecimal valorTotalDevolucoes,
					Collection<Pagamento> colecaoPagamento, BigDecimal valorTotalExcedente) throws ControladorException{

		// declaração de variáveis
		Iterator iteratorColecaoDevolucao = null;
		Iterator iteratorColecaoPagamento = null;
		Pagamento pagamentoColecao = null;
		Devolucao devolucao = null;
		Devolucao devolucaoSelecionada = null;
		String[] idPagamento = new String[1];
		String[] idDevolucao = new String[1];
		BigDecimal valorTotalDevolucaoInformado = BigDecimal.ZERO;

		try{
			// verifica se existe alguma devolução com o valor igual ao valor
			// excedente
			if(colecaoDevolucao != null && !colecaoDevolucao.isEmpty()){

				iteratorColecaoDevolucao = colecaoDevolucao.iterator();

				while(iteratorColecaoDevolucao.hasNext()){

					devolucao = (Devolucao) iteratorColecaoDevolucao.next();

					if((devolucao.getValorDevolucao() != null && devolucao.getValorDevolucao().equals(valorTotalExcedente))
									&& devolucaoSelecionada == null){

						devolucaoSelecionada = devolucao;

					}else if((devolucao.getValorDevolucao() != null && devolucao.getValorDevolucao().equals(valorTotalExcedente))
									&& (devolucaoSelecionada != null)){
						// [FS0004 - Verificar seleção de mais de uma devolução]
						if(devolucao.getDataDevolucao() != null && devolucaoSelecionada.getDataDevolucao() != null
										&& devolucao.getDataDevolucao().after(devolucaoSelecionada.getDataDevolucao())){
							devolucaoSelecionada = devolucao;
						}
					}
				}
			}

			if(devolucaoSelecionada != null){

				SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

				if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){

					iteratorColecaoPagamento = colecaoPagamento.iterator();

					/*
					 * Para todos os pagamentos da lista, tualiza a situação
					 * atual do pagamento (PGST_IDATUAL) com o valor
					 * correspondente a duplicidade/excesso devolvido
					 */
					while(iteratorColecaoPagamento.hasNext()){
						pagamentoColecao = (Pagamento) iteratorColecaoPagamento.next();

						idPagamento[0] = String.valueOf(pagamentoColecao.getId());

						repositorioArrecadacao.atualizarSituacaoPagamento(idPagamento, PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO);

						/*
						 * Para os pagamentos da lista com ano/mês de
						 * arrecadação igual ao ano/mês de arrecadação corrente
						 * (PGMT_AMREFERENCIAARRECADACAO igual a
						 * PARM_AMREFERENCIAARRECADACAO), atualiza a situação
						 * anterior do pagamento (PGST_IDANTERIOR) com o valor
						 * correspondente a pagamento em duplicidade/excesso.
						 */
						if(pagamentoColecao.getAnoMesReferenciaArrecadacao() == sistemaParametro.getAnoMesArrecadacao().intValue()){
							repositorioArrecadacao.atualizarSituacaoAnteriorPagamento(idPagamento,
											PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);
						}
					}
				}

				/*
				 * Caso a guia de devolução esteja preenchida (GDEV_ID com o
				 * valor diferente de nulo), atualiza a situação atual da
				 * devolução (DVST_IDATUAL) com o valor correspondente a
				 * devolução classificada. Caso contrário, atualiza a situação
				 * da devolução (DVST_IDATUAL) com o valor correspndente a guia
				 * de devolução não informada.
				 */
				if(devolucaoSelecionada.getGuiaDevolucao() != null){
					idDevolucao[0] = String.valueOf(devolucaoSelecionada.getId());

					Collection<Devolucao> colecaoDevolucoes = new ArrayList<Devolucao>();
					DevolucaoSituacao devolucaoSituacao = new DevolucaoSituacao();
					devolucaoSituacao.setId(DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA);
					devolucaoSelecionada.setDevolucaoSituacaoAtual(devolucaoSituacao);

					colecaoDevolucoes.add(devolucaoSelecionada);
					this.transferirDevolucaoParaHistorico(colecaoDevolucoes);

				}else{
					idDevolucao[0] = String.valueOf(devolucaoSelecionada.getId());
					Collection<Devolucao> colecaoDevolucoes = new ArrayList<Devolucao>();
					DevolucaoSituacao devolucaoSituacao = new DevolucaoSituacao();
					devolucaoSituacao.setId(DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);
					devolucaoSelecionada.setDevolucaoSituacaoAtual(devolucaoSituacao);

					colecaoDevolucoes.add(devolucaoSelecionada);
					this.transferirDevolucaoParaHistorico(colecaoDevolucoes);

				}

			}else{
				/*
				 * Caso não exista nenhuma devolução com o valor igual ao valor
				 * excedente atualiza a situação atual das devoluções
				 * (DVST_IDATUAL) com o valor correspondente a valor não
				 * confere.
				 */
				if(colecaoDevolucao != null && !colecaoDevolucao.isEmpty()){

					iteratorColecaoDevolucao = colecaoDevolucao.iterator();

					while(iteratorColecaoDevolucao.hasNext()){
						devolucao = (Devolucao) iteratorColecaoDevolucao.next();

						Collection<Devolucao> colecaoDevolucoes = new ArrayList<Devolucao>();
						DevolucaoSituacao devolucaoSituacao = new DevolucaoSituacao();
						devolucaoSituacao.setId(DevolucaoSituacao.VALOR_NAO_CONFERE);
						devolucao.setDevolucaoSituacaoAtual(devolucaoSituacao);

						colecaoDevolucoes.add(devolucao);
						this.transferirDevolucaoParaHistorico(colecaoDevolucoes);

					}
				}
			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	private void atualizarAvisoBancarioDevolucao(Devolucao devolucao){

		BigDecimal valorTotalDevolucoesCalculado = BigDecimal.ZERO;
		BigDecimal valorTotalDevolucaoInformado = BigDecimal.ZERO;
		BigDecimal valorTotalArrecadadorMovimentoItem = BigDecimal.ZERO;

		try{
			// consultar devolucao
			BigDecimal somatorioDevolucao = repositorioArrecadacao.pesquisarValorDevolucao(devolucao.getAvisoBancario().getId());

			// consultar devolucao_historico
			BigDecimal somatorioDevolucaoHistorico = repositorioArrecadacao.pesquisarValorDevolucaoHistorico(devolucao.getAvisoBancario()
							.getId());

			// chamar método arrecadador_movimento_item
			valorTotalArrecadadorMovimentoItem = this.retornarSomatorioArrecadadorMovimentoItem(devolucao.getAvisoBancario()
							.getArrecadadorMovimento().getId(), ConstantesSistema.NAO);

			AvisoBancario avisoBancario = devolucao.getAvisoBancario();

			valorTotalDevolucoesCalculado = somatorioDevolucao.add(somatorioDevolucaoHistorico);
			avisoBancario.setValorDevolucaoCalculado(valorTotalDevolucoesCalculado);

			valorTotalDevolucaoInformado = somatorioDevolucao.add(somatorioDevolucaoHistorico).add(valorTotalArrecadadorMovimentoItem);
			avisoBancario.setValorDevolucaoInformado(valorTotalDevolucaoInformado);
			avisoBancario.setUltimaAlteracao(new Date());

			getControladorUtil().atualizar(avisoBancario);

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(ControladorException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Selecionar Guia de Pagamento pela Localidade, Imóvel, Cliente e Débito
	 * Tipo
	 * [SF0003] Selecionar Guia de Pagamento pela Localidade, Imóvel, Cliente e
	 * Débito Tipo
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre, Pedro
	 *         Alexandre
	 * @date 26/04/2006, 14/03/2007, 05/06/2007, 02/10/2007
	 * @param imovel
	 * @param cliente
	 * @param debitoTipo
	 * @return GuiaPagamento
	 */
	public GuiaPagamento selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(Imovel imovel, Cliente cliente, DebitoTipo debitoTipo)
					throws ControladorException{

		GuiaPagamento guiaPagamento = null;
		Collection<GuiaPagamento> colecaoGuiaPagamento = null;

		try{

			colecaoGuiaPagamento = repositorioArrecadacao.selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(imovel, cliente,
							debitoTipo);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		/*
		 * Caso a guia de pagamento seja encontrada o sistema retorna a guia de
		 * pagamento [FS0002 - Verificar seleção de mais de uma guia de
		 * pagamento]
		 */
		if(colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()){

			if(colecaoGuiaPagamento.size() == 1){
				guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);
			}else{
				Iterator iteratorColecaoGuiaPagamento = colecaoGuiaPagamento.iterator();

				while(iteratorColecaoGuiaPagamento.hasNext()){

					guiaPagamento = (GuiaPagamento) iteratorColecaoGuiaPagamento.next();

					// if (guiaPagamento.getDataVencimento() != null) {
					// break;
					// }
				}
			}
		}

		return guiaPagamento;

	}


	/**
	 * Validaçao de pagamentos com valor diferente em caso de adiantamento de parcelas
	 * 
	 * @author Andre Nishimura
	 * @date 21/09/2009
	 */
	private Collection<Pagamento> processarPagamentoValorNaoConfereDebitoACobrar(Map<Integer, Collection> mapPagamentosValorNaoConfere)
					throws ControladorException{

		Collection<Pagamento> colecaoPagamentoDuplicidade = new ArrayList<Pagamento>();

		try{
			if(mapPagamentosValorNaoConfere != null && !mapPagamentosValorNaoConfere.isEmpty()){

				// Map que será utilizado para atualizar a situação caso não seja valor da parcela
				Map<Integer, Collection> mapPagamentosValorNaoConfereAtualizar = new HashMap<Integer, Collection>();

				Collection<Integer> colecaoIdsDebitosACobrar = mapPagamentosValorNaoConfere.keySet();
				for(Integer idDebito : colecaoIdsDebitosACobrar){

					System.out.println("idDebito da colecao = " + idDebito);

					Collection<Pagamento> colecaoPagamentoValorNaoConfere = mapPagamentosValorNaoConfere.get(idDebito);
					if(colecaoPagamentoValorNaoConfere != null && !colecaoPagamentoValorNaoConfere.isEmpty()){

						for(Pagamento pagamento : colecaoPagamentoValorNaoConfere){

							DebitoACobrar debitoACobrar = pagamento.getDebitoACobrar();

							try{

								// verifica se trata-se de um adiantamento de parcelas
								if(debitoACobrar.getNumeroPrestacaoDebito() != 0){
									BigDecimal valorDebito = debitoACobrar.getValorDebito();
									BigDecimal valorParcela = valorDebito.divide(
													new BigDecimal(String.valueOf(debitoACobrar.getNumeroPrestacaoDebito())),
													Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO);

									// O valor pago corresponde a 1 parcela
									if(valorParcela.compareTo(pagamento.getValorPagamento()) == 0){

										FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
										filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
														FiltroPagamentoHistorico.DEBITO_A_COBRAR_ID, debitoACobrar.getId()));
										if(pagamento.getNumeroPrestacao() != null){
											filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
															FiltroPagamentoHistorico.NUMERO_PRESTACAO, pagamento.getNumeroPrestacao()));
										}
										Collection<PagamentoHistorico> colecaoPagamentoHistoricoConsulta = this.getControladorUtil()
														.pesquisar(filtroPagamentoHistorico, PagamentoHistorico.class.getName());

										// Caso já exista um pagamento no histórico para a mesma
										// parcela do Débito a Cobrar, colocar como duplicidade.
										if(colecaoPagamentoHistoricoConsulta != null && !colecaoPagamentoHistoricoConsulta.isEmpty()){
											colecaoPagamentoDuplicidade.add(pagamento);
										}else{

											debitoACobrar.setNumeroPrestacaoCobradas(Short.valueOf(String.valueOf(debitoACobrar
															.getNumeroPrestacaoCobradas() + 1)));

											debitoACobrar.setUltimaAlteracao(new Date());

											if(debitoACobrar != null){
												System.out.println("DEBITO A COBRAR = " + debitoACobrar.getId());
											}else if(pagamento != null && pagamento.getImovel() != null){
												System.out.println("DEBITO A COBRAR NULL e IMOVEL = " + pagamento.getImovel().getId());
											}else{
												System.out.println("DEBITO A COBRAR NULL e VALOR DEBITO = " + valorDebito);
											}

											this.getControladorUtil().atualizar(debitoACobrar);

											// Caso esteja adiantando a ultima parcela
											if(debitoACobrar.getNumeroPrestacaoCobradas() == debitoACobrar.getNumeroPrestacaoDebito()){
												this.getControladorFaturamento().transferirDebitosACobrarParaHistorico(
																Collections.singletonList(debitoACobrar), Boolean.FALSE);
												this.getControladorFaturamento().atualizarIndicadorDebitoACobrarNoHistorico(
																Collections.singletonList(debitoACobrar));
											}

											// Atualizar pagamento do débito a cobrar como
											// CLASSIFICADO
											Map<Integer, Collection> mapPagamentosProcessados = new HashMap<Integer, Collection>();
											mapPagamentosProcessados.put(debitoACobrar.getId(), Collections.singletonList(pagamento));
											this.repositorioArrecadacao.processarPagamentoDebitoACobrar(mapPagamentosProcessados);

											// Enviar pagamento para historico
											Collection colecaoPagamentosPreenchida = this.carregarAtributosPagamento(Collections
															.singletonList(pagamento));

											this.transferirPagamentoParaHistorico(colecaoPagamentosPreenchida);

											mapPagamentosProcessados.clear();
										}
									}else{
										if(mapPagamentosValorNaoConfereAtualizar.containsKey(debitoACobrar.getId())){
											Collection<Pagamento> colecaoPagamentoAtualizar = mapPagamentosValorNaoConfere
															.get(debitoACobrar.getId());

											if(!colecaoPagamentoAtualizar.contains(pagamento)){
												colecaoPagamentoAtualizar.add(pagamento);
												mapPagamentosValorNaoConfere.put(debitoACobrar.getId(), colecaoPagamentoAtualizar);
											}

										}else{
											mapPagamentosValorNaoConfereAtualizar.put(debitoACobrar.getId(),
															Collections.singletonList(pagamento));
										}
									}
								}else{
									if(mapPagamentosValorNaoConfereAtualizar.containsKey(debitoACobrar.getId())){
										Collection<Pagamento> colecaoPagamentoAtualizar = mapPagamentosValorNaoConfere.get(debitoACobrar
														.getId());
										colecaoPagamentoAtualizar.add(pagamento);
									}else{
										mapPagamentosValorNaoConfereAtualizar.put(debitoACobrar.getId(),
														Collections.singletonList(pagamento));
									}
								}

							}catch(ControladorException ex){
								ex.getMessage();
								throw new ControladorException("erro.sistema", ex);
							}catch(ErroRepositorioException ex){
								ex.getMessage();
								throw new ControladorException("erro.sistema", ex);
							}

						}
					}
				}
				if(mapPagamentosValorNaoConfereAtualizar != null && !mapPagamentosValorNaoConfereAtualizar.isEmpty()){
					this.repositorioArrecadacao.processarPagamentoValorNaoConfereDebitoACobrar(mapPagamentosValorNaoConfereAtualizar);
				}
			}
		}catch(Exception ex){
			ex.getMessage();
			throw new ControladorException("erro.sistema", ex);
		}

		return colecaoPagamentoDuplicidade;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Selecionar Débito a Cobrar pela Localidade, Imóvel e Débito Tipo
	 * [SF0005] Selecionar Débito a Cobrar pela Localidade, Imóvel e Débito Tipo
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 26/04/2006, 05/06/2007, 02/10/2007
	 * @param imovel
	 * @param debitoTipo
	 * @param anoMesFaturamento
	 * @return DebitoACobrar
	 */
	private DebitoACobrar selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(Imovel imovel, DebitoTipo debitoTipo)
					throws ControladorException{

		DebitoACobrar debitoACobrar = null;
		Collection<DebitoACobrar> colecaoDebitoACobrar = null;

		try{

			colecaoDebitoACobrar = repositorioArrecadacao.selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(imovel, debitoTipo);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		/*
		 * Caso o débito a cobrar seja encontrado o sistema retorna o débito a
		 * cobrar [FS0003 - Verificar seleção de mais de um débito a cobrar]
		 */
		if(colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()){

			if(colecaoDebitoACobrar.size() == 1){
				debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
			}else{
				Iterator iteratorColecaoDebitoACobrar = colecaoDebitoACobrar.iterator();

				while(iteratorColecaoDebitoACobrar.hasNext()){

					debitoACobrar = (DebitoACobrar) iteratorColecaoDebitoACobrar.next();

					if(debitoACobrar.getGeracaoDebito() != null){
						break;
					}
				}
			}
		}

		return debitoACobrar;

	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Selecionar Pagamentos não Classificados de Conta
	 * [SF0010] Selecionar Pagamentos não Classificados de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 15/06/2006
	 * @param imovel
	 *            ,
	 *            anoMesReferenciaDevolucao
	 * @return Collection<Pagamento>
	 */
	public Collection<Pagamento> selecionarPagamentosNaoClassificadosConta(Imovel imovel, Integer anoMesReferenciaDevolucao)
					throws ControladorException{

		Collection<Pagamento> colecaoPagamento = null;

		try{

			colecaoPagamento = repositorioArrecadacao.selecionarPagamentosNaoClassificadosConta(imovel, anoMesReferenciaDevolucao);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return colecaoPagamento;

	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SF0012] Selecionar Pagamentos não classificados de guia de pagamento ou
	 * débito a cobrar
	 * 
	 * @author Raphael Rossiter
	 * @date 15/06/2006
	 * @param imovel
	 *            ,
	 *            anoMesReferenciaDevolucao
	 * @return Collection<Pagamento>
	 */
	public Collection<Pagamento> selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(Imovel imovel, Cliente cliente,
					DebitoTipo debitoTipo) throws ControladorException{

		Collection<Pagamento> colecaoPagamento = null;

		if(imovel != null && cliente != null && debitoTipo != null){

			try{

				colecaoPagamento = repositorioArrecadacao.selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(imovel, cliente,
								debitoTipo);

			}catch(ErroRepositorioException ex){
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}

		}

		return colecaoPagamento;

	}

	/**
	 * Insere os aviso deduções no aviso bancário
	 * [UC0000] Inserir Aviso Bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 18/04/2006
	 * @throws ControladorException
	 */
	public void inserirAvisosDeducoes(AvisoDeducoes avisoDeducoes, AvisoBancario avisoBancario) throws ControladorException{

		FiltroAvisoDeducoes filtroAvisoDeducoes = new FiltroAvisoDeducoes();
		filtroAvisoDeducoes.adicionarParametro(new ParametroSimples(FiltroAvisoDeducoes.AVISO_BANCARIO_ID, avisoBancario.getId()));
		filtroAvisoDeducoes.adicionarParametro(new ParametroSimples(FiltroAvisoDeducoes.DEDUCAO_TIPO_ID, avisoDeducoes.getDeducaoTipo()
						.getId()));
		filtroAvisoDeducoes.adicionarCaminhoParaCarregamentoEntidade("avisoBancario");
		filtroAvisoDeducoes.adicionarCaminhoParaCarregamentoEntidade("deducaoTipo");

		Collection colecaoAvisoDeducaoBase = getControladorUtil().pesquisar(filtroAvisoDeducoes, AvisoDeducoes.class.getName());

		if(colecaoAvisoDeducaoBase != null && !colecaoAvisoDeducaoBase.isEmpty()){
			Iterator colecaoAvisoDeducaoBaseIterator = colecaoAvisoDeducaoBase.iterator();

			// Remove os avisos deduçoes já existentes na base para fazer a
			// inserção dos novos avisos deduções
			while(colecaoAvisoDeducaoBaseIterator.hasNext()){
				AvisoDeducoes avisoDeducoesBase = (AvisoDeducoes) colecaoAvisoDeducaoBaseIterator.next();

				getControladorUtil().remover(avisoDeducoesBase);
			}
		}

		getControladorUtil().inserir(avisoDeducoes);
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * pesquisa todos os bancos que tenham contrato vigente para arrecadador
	 * contas com forma de arrecadação correspondente a debito automático
	 * [SB0002] - Carregar Lista de Bancos
	 * 
	 * @author Sávio Luiz
	 * @date 18/04/2006
	 * @return Coleção de Bancos
	 * @throws ControladorException
	 */

	/*
	 * public Collection<Banco> pesquisaBancosDebitoAutomatico() throws
	 * ControladorException { try { return
	 * repositorioArrecadacao.pesquisaBancosDebitoAutomatico(); } catch
	 * (ErroRepositorioException e) { throw new
	 * ControladorException("erro.sistema", e); } }
	 */

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * pesquisa os movimentos de débito automático para o banco,referentes ao
	 * grupo e ano/mês de faturamento informados
	 * [SB0002] - Carregar Lista de Bancos
	 * 
	 * @author Sávio Luiz
	 * @date 18/04/2006
	 * @param idFaturamentoGrupo
	 *            ,anoMesReferenciaFaturamento,idBanco
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ControladorException
	 */

	public Map<Banco, Collection<DebitoAutomaticoMovimento>> pesquisaDebitoAutomaticoMovimento(Collection colecaoIdsFaturamentoGrupo,
					Integer anoMesReferenciaFaturamento, String opcaoDebitoAutomatico) throws ControladorException{

		TreeMap<Banco, Collection<DebitoAutomaticoMovimento>> debitosAutomaticoBancosMap = null;
		try{

			Collection colecaoidsBancos = repositorioArrecadacao.pesquisaBancosDebitoAutomatico();

			if(colecaoidsBancos != null && !colecaoidsBancos.isEmpty()){

				Collection colecaoBancoDebitoAutomaticoMovimento = repositorioArrecadacao.pesquisaDebitoAutomaticoMovimento(
								colecaoIdsFaturamentoGrupo, anoMesReferenciaFaturamento, colecaoidsBancos, opcaoDebitoAutomatico);

				if(colecaoBancoDebitoAutomaticoMovimento != null && !colecaoBancoDebitoAutomaticoMovimento.isEmpty()){

					debitosAutomaticoBancosMap = new TreeMap(new Comparator() {

						public int compare(Object bnco1, Object bnco2){

							int resultado = 0;
							Banco banco1 = (Banco) bnco1;
							Banco banco2 = (Banco) bnco2;

							if(banco1.getId() < banco2.getId()){
								return -1;
							}
							if(banco1.getId() > banco2.getId()){
								return 1;
							}
							return resultado;
						}

					});

					Iterator iteCollBancoDebitoAutomaticoMovimento = colecaoBancoDebitoAutomaticoMovimento.iterator();

					boolean primeiraVez = true;
					boolean primeiroValor = true;
					Integer idBancoUltimo = null;
					Banco bancoInserir = null;
					Collection colecaoDebitoAutomaticoMovimento = new ArrayList();

					while(iteCollBancoDebitoAutomaticoMovimento.hasNext()){
						Object[] bancoDebitoAutomaticoMovimento = (Object[]) iteCollBancoDebitoAutomaticoMovimento.next();
						if(bancoDebitoAutomaticoMovimento != null){

							Banco banco = null;
							DebitoAutomaticoMovimento debitoAutomaticoMovimento = null;
							// banco
							if(bancoDebitoAutomaticoMovimento[0] != null){
								banco = (Banco) bancoDebitoAutomaticoMovimento[0];
								if(primeiroValor){
									idBancoUltimo = banco.getId();
									primeiroValor = false;
								}
							}
							// Debito Automatico Movimento
							if(bancoDebitoAutomaticoMovimento[1] != null){
								debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) bancoDebitoAutomaticoMovimento[1];
							}

							if(primeiraVez && idBancoUltimo.equals(banco.getId())){
								idBancoUltimo = banco.getId();
								bancoInserir = banco;
								primeiraVez = false;
							}else if(primeiraVez && !idBancoUltimo.equals(banco.getId())){
								primeiraVez = false;
							}

							if(idBancoUltimo.equals(banco.getId())){
								colecaoDebitoAutomaticoMovimento.add(debitoAutomaticoMovimento);
							}else{
								debitosAutomaticoBancosMap.put(bancoInserir, colecaoDebitoAutomaticoMovimento);
								colecaoDebitoAutomaticoMovimento = new ArrayList();
								idBancoUltimo = banco.getId();
								bancoInserir = banco;
								colecaoDebitoAutomaticoMovimento.add(debitoAutomaticoMovimento);
								primeiraVez = true;

							}

						}
					}
					debitosAutomaticoBancosMap.put(bancoInserir, colecaoDebitoAutomaticoMovimento);

				}
			}
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		return debitosAutomaticoBancosMap;
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * @author Vivianne Sousa
	 * @date 20/04/2006
	 * @param avisoBancarioHelper
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarAvisoBancarioAbertoFechado(AvisoBancarioHelper avisoBancarioHelper) throws ControladorException{

		try{
			Collection colecaoAvisosBancario = this.repositorioArrecadacao.filtrarAvisoBancarioAbertoFechado(avisoBancarioHelper);

			AvisoBancarioHelper avisoBancarioHelperNovo = null;
			Iterator iterator = colecaoAvisosBancario.iterator();

			Collection colecaoAvisosBancarioHelperFinal = new ArrayList();

			while(iterator.hasNext()){

				Object[] dadosAvisoBancario = (Object[]) iterator.next();
				AvisoBancario avisoBancario = new AvisoBancario();

				avisoBancarioHelperNovo = new AvisoBancarioHelper();

				avisoBancarioHelperNovo.setTipoAviso(avisoBancarioHelper.getTipoAviso());

				Arrecadador arrecadador = new Arrecadador();
				arrecadador.setId((Integer) dadosAvisoBancario[0]);
				avisoBancario.setArrecadador(arrecadador);

				avisoBancario.setDataLancamento((Date) dadosAvisoBancario[1]);

				avisoBancario.setNumeroSequencial((Short) dadosAvisoBancario[2]);

				avisoBancario.setIndicadorCreditoDebito((Short) dadosAvisoBancario[3]);

				avisoBancario.setDataPrevista((Date) dadosAvisoBancario[4]);

				avisoBancario.setDataRealizada((Date) dadosAvisoBancario[5]);

				avisoBancario.setValorRealizado((BigDecimal) dadosAvisoBancario[6]);

				avisoBancario.setId((Integer) dadosAvisoBancario[15]);

				avisoBancario.setNumeroDocumento((Integer) dadosAvisoBancario[16]);

				ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
				arrecadadorMovimento.setNumeroSequencialArquivo((Integer) dadosAvisoBancario[17]);
				avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);

				avisoBancarioHelperNovo.setAvisoBancario(avisoBancario);

				BigDecimal valorAcertos = BigDecimal.ZERO;
				BigDecimal valorCalculado = BigDecimal.ZERO;
				BigDecimal valorInformado = BigDecimal.ZERO;
				BigDecimal valorDiferenca = BigDecimal.ZERO;

				if(avisoBancario.getIndicadorCreditoDebito().equals(AvisoBancario.INDICADOR_CREDITO)){

					if(dadosAvisoBancario[7] != null){

						// Valor da Arrecadacao Calculado
						valorCalculado = (BigDecimal) dadosAvisoBancario[7];
						avisoBancarioHelperNovo.setValorCalculado(valorCalculado);
					}

					if(dadosAvisoBancario[8] != null){

						// Valor da Arrecadacao Informado
						valorInformado = (BigDecimal) dadosAvisoBancario[8];
					}

					if(dadosAvisoBancario[9] != null){

						// Valor dos Acertos Crédito da Arrecadacao
						valorAcertos = valorAcertos.add((BigDecimal) dadosAvisoBancario[9]);
					}

					if(dadosAvisoBancario[10] != null){

						// Valor dos Acertos Débito da Arrecadacao
						valorAcertos = valorAcertos.subtract((BigDecimal) dadosAvisoBancario[10]);
						avisoBancarioHelperNovo.setValorAcertos(valorAcertos);
					}

					// Valor Diferença
					valorDiferenca = valorInformado.subtract(valorCalculado.add(valorAcertos));
				}else{

					if(dadosAvisoBancario[11] != null){

						// Valor da Devolucao Calculado
						valorCalculado = (BigDecimal) dadosAvisoBancario[11];
						avisoBancarioHelperNovo.setValorCalculado(valorCalculado);
					}

					if(dadosAvisoBancario[12] != null){

						// Valor da Devolucao Informado
						valorInformado = (BigDecimal) dadosAvisoBancario[12];
					}

					if(dadosAvisoBancario[13] != null){

						// Valor dos Acertos Crédito da Devolucao
						valorAcertos = valorAcertos.add((BigDecimal) dadosAvisoBancario[13]);
					}

					if(dadosAvisoBancario[14] != null){

						// Valor dos Acertos Crédito da Devolucao
						valorAcertos = valorAcertos.subtract((BigDecimal) dadosAvisoBancario[14]);
						avisoBancarioHelperNovo.setValorAcertos(valorAcertos);
					}
				}

				// Situação do Aviso
				if(valorDiferenca.compareTo(BigDecimal.ZERO) != 0){

					avisoBancarioHelperNovo.setSituacao(ConstantesSistema.ABERTO);

				}else{

					avisoBancarioHelperNovo.setSituacao(ConstantesSistema.FECHADO);
				}

				if(avisoBancarioHelper.getIndicadorAbertoFechado() == null
								|| avisoBancarioHelper.getIndicadorAbertoFechado().equals(ConstantesSistema.AVISO_ABERTO_FECHADO)){

					avisoBancarioHelperNovo.setIndicadorAbertoFechado(ConstantesSistema.AVISO_ABERTO_FECHADO);
					colecaoAvisosBancarioHelperFinal.add(avisoBancarioHelperNovo);
				}else{

					if(avisoBancarioHelper.getIndicadorAbertoFechado().equals(ConstantesSistema.AVISO_ABERTO)
									&& avisoBancarioHelperNovo.getSituacao().equals(ConstantesSistema.ABERTO)){

						avisoBancarioHelperNovo.setIndicadorAbertoFechado(ConstantesSistema.AVISO_ABERTO);
						colecaoAvisosBancarioHelperFinal.add(avisoBancarioHelperNovo);
					}else if(avisoBancarioHelper.getIndicadorAbertoFechado().equals(ConstantesSistema.AVISO_FECHADO)
									&& avisoBancarioHelperNovo.getSituacao().equals(ConstantesSistema.FECHADO)){

						avisoBancarioHelperNovo.setIndicadorAbertoFechado(ConstantesSistema.AVISO_FECHADO);
						colecaoAvisosBancarioHelperFinal.add(avisoBancarioHelperNovo);
					}
				}
			}
			return colecaoAvisosBancarioHelperFinal;
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * Movimento de débito automático em arquivo TXT gerado e enviado ao banco.
	 * [SB0001] - Gerar Movimento para Debito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * @author Saulo Lima
	 * @date 20/02/2009
	 *       Identação pra poder visualizar bem o código
	 * @throws ControladorException
	 */
	public void gerarMovimentoDebitoAutomaticoBanco(Map<Banco, Collection<DebitoAutomaticoMovimento>> debitosAutomaticoBancosMap,
					Usuario usuario, Integer anoMesReferencia, String opcaoDebitoAutomatico) throws ControladorException{

		Collection colecaoGerarMovimentoDebitoAutomatico = new ArrayList();

		// cria uma coleção com a a chave(Banco) do Map
		Iterator debitosAutomaticoBancosIterator = debitosAutomaticoBancosMap.keySet().iterator();

		ArrecadadorMovimento arrecadadorMovimento = null;
		try{

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.GERAR_MOVIMENTO_AUTOMATICO_BANCO);

			Integer idGrupoFaturamento = null;
			// Integer anoMesReferencia = null;
			boolean primeiraVez = true;

			while(debitosAutomaticoBancosIterator.hasNext()){
				Banco banco = (Banco) debitosAutomaticoBancosIterator.next();

				// recupera a coleção de valores(DebitoAutomaticoMovimento) pelo valor, no map
				Collection<DebitoAutomaticoMovimento> colecaoDebitoAutomaticoMovimento = debitosAutomaticoBancosMap.get(banco);

				// Ordenando pela data de vencimento
				BeanComparator comparador = new BeanComparator("dataVencimento");
				Collections.sort((List) colecaoDebitoAutomaticoMovimento, comparador);

				Iterator debitoAutomaticoMovimentoIterator = colecaoDebitoAutomaticoMovimento.iterator();
				GerarMovimentoDebitoAutomaticoBancoHelper gerarMovimentoDebitoAutomaticoBancoHelper = new GerarMovimentoDebitoAutomaticoBancoHelper();

				StringBuilder registrosTipoE = new StringBuilder();
				Integer idArrecadadorContrato = null;
				String codigoConvenio = null;
				String codigoConvenioResp = null;
				Integer numeroSequencialArquivoEnvio = null;
				Integer numeroSequencialArquivoEnvioResp = null;
				String descricaoEmail = null;

				Object[] arrecadadorContrato = null;

				try{
					arrecadadorContrato = repositorioArrecadacao.pesquisaCamposArrecadadorContrato(banco.getId());
					if(arrecadadorContrato[0] != null){
						idArrecadadorContrato = (Integer) arrecadadorContrato[0];
					}
					if(arrecadadorContrato[1] != null){
						codigoConvenio = (String) arrecadadorContrato[1];
					}
					if(arrecadadorContrato[2] != null){
						numeroSequencialArquivoEnvio = (Integer) arrecadadorContrato[2];
					}
					if(arrecadadorContrato[3] != null){
						descricaoEmail = (String) arrecadadorContrato[3];
					}
					if(arrecadadorContrato[4] != null){
						codigoConvenioResp = (String) arrecadadorContrato[4];
					}
					if(arrecadadorContrato[5] != null){
						numeroSequencialArquivoEnvioResp = (Integer) arrecadadorContrato[5];
					}
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}
				// instancia um objeto arrecadador movimento
				arrecadadorMovimento = new ArrecadadorMovimento();
				// +2 referentes a A e Z
				Integer quantidadeRegistrosMap = colecaoDebitoAutomaticoMovimento.size() + 2;
				arrecadadorMovimento.setCodigoRemessa(Short.valueOf("1"));
				// Código do convênio do arrecadador contrato

				// Alteração Silvio Barros 13/06/2012
				if(DebitoAutomaticoMovimento.GERAR_MOVIMENTO_DE_DEBITO_AUTOMATICO.equals(opcaoDebitoAutomatico)){ // CNTA

					arrecadadorMovimento.setCodigoConvenio(codigoConvenio); // ARCT_CDCONVENIODEBAUT

					arrecadadorMovimento.setNumeroSequencialArquivo(numeroSequencialArquivoEnvio + 1);
				}else if(DebitoAutomaticoMovimento.GERAR_MOVIMENTO_DE_DEBITO_AUTOMATICO_PREFEITURA.equals(opcaoDebitoAutomatico)){ // GPAG
					arrecadadorMovimento.setCodigoConvenio(codigoConvenioResp);
					// ARCT_CDCONVENIOPARCELRESP); Da tabela ARRECADADOR_CONTRATO.

					arrecadadorMovimento.setNumeroSequencialArquivo(numeroSequencialArquivoEnvioResp + 1);
					// (ARCT_NNNSAENVIOPARCELRESP+1); Da tabela ARRECADADOR_CONTRATO.
				}

				arrecadadorMovimento.setNomeEmpresa(sistemaParametro.getNomeAbreviadoEmpresa());
				arrecadadorMovimento.setCodigoBanco(Short.valueOf(banco.getId().toString()));
				arrecadadorMovimento.setNomeBanco(banco.getDescricao());
				arrecadadorMovimento.setDataGeracao(new Date());

				arrecadadorMovimento.setNumeroVersaoLayout(Integer.valueOf("" + sistemaParametro.getNumeroLayoutFebraban()));
				arrecadadorMovimento.setDescricaoIdentificacaoServico(ConstantesSistema.DEBITO_AUTOMATICO);
				arrecadadorMovimento.setNumeroRegistrosMovimento(quantidadeRegistrosMap);
				Collection colecaoArrecadadorMovimentoItem = new ArrayList();

				BigDecimal valorTotalDebitado = BigDecimal.ZERO;

				while(debitoAutomaticoMovimentoIterator.hasNext()){

					DebitoAutomaticoMovimento debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) debitoAutomaticoMovimentoIterator
									.next();

					if(primeiraVez){
						idGrupoFaturamento = debitoAutomaticoMovimento.getFaturamentoGrupo().getId();
					}

					try{
						BigDecimal valorDebito = BigDecimal.ZERO;

						valorDebito = debitoAutomaticoMovimento.getValorDebito();

						valorTotalDebitado = valorTotalDebitado.add(valorDebito);

						// atualiza o objeto debito automatico movimento
						debitoAutomaticoMovimento.setNumeroSequenciaArquivoEnviado(arrecadadorMovimento.getNumeroSequencialArquivo());
						debitoAutomaticoMovimento.setEnvioBanco(new Date());
						debitoAutomaticoMovimento.setUltimaAlteracao(new Date());

						repositorioUtil.atualizar(debitoAutomaticoMovimento);

						StringBuilder linhaTipoE = criarRegistroTipoE(banco, debitoAutomaticoMovimento,
										arrecadadorMovimento.getNumeroSequencialArquivo());

						// inseri o item do movimento arrecadador
						ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
						Integer idRegistroCodigo = repositorioArrecadacao.pesquisarIdRegistroCodigo(RegistroCodigo.CODIGO_E);
						RegistroCodigo registroCodigo = new RegistroCodigo();
						registroCodigo.setId(idRegistroCodigo);
						arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);
						arrecadadorMovimentoItem.setConteudoRegistro(linhaTipoE.toString());
						arrecadadorMovimentoItem.setDescricaoOcorrencia("OK");
						arrecadadorMovimentoItem.setIndicadorAceitacao(Short.valueOf("1"));
						arrecadadorMovimentoItem.setUltimaAlteracao(new Date());
						arrecadadorMovimentoItem.setImovel(debitoAutomaticoMovimento.getDebitoAutomatico().getImovel());
						colecaoArrecadadorMovimentoItem.add(arrecadadorMovimentoItem);

						registrosTipoE.append(linhaTipoE);
						registrosTipoE.append(System.getProperty("line.separator"));

					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}
				arrecadadorMovimento.setValorTotalMovimento(valorTotalDebitado);
				arrecadadorMovimento.setUltimaAlteracao(new Date());
				Integer idArrecadadorMovimento = null;

				try{
					idArrecadadorMovimento = (Integer) repositorioUtil.inserir(arrecadadorMovimento);
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				arrecadadorMovimento.setId(idArrecadadorMovimento);
				gerarMovimentoDebitoAutomaticoBancoHelper.setArrecadadorMovimento(arrecadadorMovimento);
				Iterator iteratorArrecadadorMovimentoItem = colecaoArrecadadorMovimentoItem.iterator();

				while(iteratorArrecadadorMovimentoItem.hasNext()){
					ArrecadadorMovimentoItem arrecadadorMovimentoItem = (ArrecadadorMovimentoItem) iteratorArrecadadorMovimentoItem.next();
					arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);

					try{
						repositorioUtil.inserir(arrecadadorMovimentoItem);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}

				// chama o gerar arquivo TXT para envio do banco
				StringBuilder arquivoTXTEnvio = this.gerarArquivoTxt(arrecadadorMovimento, registrosTipoE);

				// atualiza o numero sequencial do arquivo no arrecadador contrato
				try{
					repositorioArrecadacao.atualizarNumeroSequencialArrecadadorContrato(idArrecadadorContrato, arrecadadorMovimento
									.getNumeroSequencialArquivo(), opcaoDebitoAutomatico);
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				String emailRemetente = envioEmail.getEmailRemetente();

				String situacaoEmail = null;

				String tituloMensagem = envioEmail.getTituloMensagem()
								+ " "
								+ (arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento
												.getNumeroSequencialArquivo() : "");

				// String mesAnoReferenciaFormatada =
				// Util.formatarAnoMesParaMesAnoCom2Digitos(anoMesReferencia);

				String nomeZip = banco.getDescricaoAbreviada() + "_" + idGrupoFaturamento + "_" + anoMesReferencia;
				// String nomeZip = banco.getDescricaoAbreviada() + "" +
				// Util.recuperaDiaMesAnoCom2DigitosDaData(new Date());

				// String emailReceptor = "apaula@compesa.com.br,edmilson@compesa.com.br";

				String emailReceptor = envioEmail.getEmailReceptor();
				boolean mandouEmailBanco = false;

				// pegar o arquivo, zipar pasta e arquivo e escrever no stream
				try{

					/*
					 * // criar o arquivo zip
					 * File compactado = File.createTempFile(nomeZip, ".zip");
					 * ZipOutputStream zos = new ZipOutputStream( new FileOutputStream(compactado));
					 */

					File leitura = File.createTempFile(nomeZip, ".rem");
					// File leitura = new File(nomeZip + ".rem");
					BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leitura.getAbsolutePath())));

					out.write(arquivoTXTEnvio.toString());
					out.flush();
					out.close();
					/*
					 * ZipUtil.adicionarArquivo(zos, leitura);
					 * // close the stream zos.close();
					 */
					// se o email do arrecadador movimento for preenchido
					if(descricaoEmail != null){

						ServicosEmail.enviarMensagemArquivoAnexado(descricaoEmail, emailRemetente, tituloMensagem, "", leitura);
						mandouEmailBanco = true;
						ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, "", leitura);
						situacaoEmail = "Enviado";
					}else{
						ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, "", leitura);
						situacaoEmail = "Não Enviado";
					}
					// compactado.delete();
					// leitura.delete();

				}catch(SendFailedException e){
					if(mandouEmailBanco){
						situacaoEmail = "Enviado.";
					}else{
						situacaoEmail = "Não Enviado.";
					}

				}catch(IOException e){
					throw new ControladorException("erro.sistema", e);
				}catch(Exception e){
					throw new ControladorException("erro.sistema", e);
				}

				gerarMovimentoDebitoAutomaticoBancoHelper.setBanco(banco);
				gerarMovimentoDebitoAutomaticoBancoHelper.setArrecadadorMovimento(arrecadadorMovimento);
				gerarMovimentoDebitoAutomaticoBancoHelper.setDescricaoEmail(descricaoEmail);
				gerarMovimentoDebitoAutomaticoBancoHelper.setSituacaoEnvioEmail(situacaoEmail);
				colecaoGerarMovimentoDebitoAutomatico.add(gerarMovimentoDebitoAutomaticoBancoHelper);
			}

			// Parte que gera o relatório e envia por email
			// cria uma instância da classe do relatório
			// cria uma instância da classe do relatório
			RelatorioMovimentoDebitoAutomaticoBanco relatorioMovimentoDebitoAutomaticoBanco = new RelatorioMovimentoDebitoAutomaticoBanco(
							usuario);

			relatorioMovimentoDebitoAutomaticoBanco.addParametro("colecaoGerarMovimentoDebitoAutomatico",
							colecaoGerarMovimentoDebitoAutomatico);

			relatorioMovimentoDebitoAutomaticoBanco.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
			byte[] relatorioGerado = (byte[]) relatorioMovimentoDebitoAutomaticoBanco.executar();

			String emailRemetente = envioEmail.getEmailRemetente();

			String tituloMensagem = envioEmail.getTituloMensagem()
							+ " "
							+ (arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento
											.getNumeroSequencialArquivo() : "");

			String corpoMensagem = envioEmail.getCorpoMensagem();
			String emailReceptor = envioEmail.getEmailReceptor();

			try{
				File leitura = new File("gcom.PDF");
				FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
				out.write(relatorioGerado);
				out.flush();
				out.close();

				ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

				leitura.delete();
			}catch(IOException e){
				throw new ControladorException("erro.sistema", e);
			}

		}catch(Exception e){

			e.printStackTrace();

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.GERAR_MOVIMENTO_AUTOMATICO_BANCO_COM_ERRO);

			String mensagem = e.getMessage();
			String[] inicioMensagem = null;

			if(mensagem != null){
				inicioMensagem = mensagem.split("\\.");
			}else{
				mensagem = e.getStackTrace().toString();
				inicioMensagem = mensagem.split("\\.");
			}

			if(inicioMensagem != null && (!inicioMensagem[0].equals("erro") && !inicioMensagem[0].equals("atencao"))){
				mensagem = "erro.sistema";
			}

			String emailRemetente = envioEmail.getEmailRemetente();

			String tituloMensagem = envioEmail.getTituloMensagem()
							+ " "
							+ (arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento
											.getNumeroSequencialArquivo() : "");
			String emailReceptor = envioEmail.getEmailReceptor();

			try{
				if(ConstantesAplicacao.get(mensagem) != null && !ConstantesAplicacao.get(mensagem).equals("")){
					ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, ConstantesAplicacao.get(mensagem));
				}else{
					ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, mensagem);
				}
			}catch(ErroEmailException e1){

			}
			sessionContext.setRollbackOnly();
		}
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * Cria uma linha de 150 posições com o registro tipo E.
	 * [SB0001] - Gerar Movimento para Debito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * @param banco
	 *            ,debitoAutomaticoMovimento
	 * @return StringBuilder
	 * @throws ControladorException
	 */
	protected StringBuilder criarRegistroTipoE(Banco banco, DebitoAutomaticoMovimento debitoAutomaticoMovimento,
					Integer numeroSequencialArquivo) throws ControladorException{

		StringBuilder registroTipoE = new StringBuilder();
		ContaGeral contaGeral = debitoAutomaticoMovimento.getContaGeral();
		GuiaPagamento guiaPagamento = null;
		registroTipoE.append("E");
		// identificação do cliente na empresa
		String identificacaoCliente = "";
		if(contaGeral != null){
			Short numeroDigitosMatriculaImovel = Short.valueOf((String) ParametroArrecadacao.P_NUMERO_DIGITOS_MATRICULA_IMOVEL
							.executar(this));

			Short indicadorHistorico = contaGeral.getIndicadorHistorico();
			Imovel imovel = null;
			Integer idImovel = null;
			String idImovelStr = null;

			if(ConstantesSistema.NAO.equals(indicadorHistorico)){
				Conta conta = contaGeral.getConta();

				if(conta != null){
					imovel = conta.getImovel();

					if(imovel != null){
						idImovel = imovel.getId();
						idImovelStr = Integer.toString(idImovel);
					}
				}
			}else{
				ContaHistorico contaHistorico = contaGeral.getContaHistorico();

				if(contaHistorico != null){
					imovel = contaHistorico.getImovel();

					if(imovel != null){
						idImovel = imovel.getId();
						idImovelStr = Integer.toString(idImovel);
					}
				}
			}

			identificacaoCliente = Util.adicionarZerosEsquedaNumero(numeroDigitosMatriculaImovel, idImovelStr);
		}else{
			guiaPagamento = debitoAutomaticoMovimento.getGuiaPagamento();
			if(guiaPagamento != null){
				identificacaoCliente = Util.adicionarZerosEsquedaNumero(14, guiaPagamento.getImovel().getLocalidade().getMunicipio()
								.getNumeroCnpjPrefeitura());
			}

		}

		registroTipoE.append(Util.completaString(identificacaoCliente, 25));

		String codigoAgencia = debitoAutomaticoMovimento.getDebitoAutomatico().getAgencia().getCodigoAgencia();
		// agencia para débito
		registroTipoE.append(Util.adicionarZerosEsquedaNumero(4, codigoAgencia));

		// Identificação do cliente no Banco
		registroTipoE.append(Util.completaString(debitoAutomaticoMovimento.getDebitoAutomatico().getIdentificacaoClienteBanco(), 14));

		// data de vencimento(AAAAMMDD)
		String dataVencimento = null;

		dataVencimento = Util.recuperaAnoMesDiaDaData(debitoAutomaticoMovimento.getDataVencimento());

		registroTipoE.append(dataVencimento);

		// Valor do débito
		BigDecimal valorDebito = BigDecimal.ZERO;

		valorDebito = debitoAutomaticoMovimento.getValorDebito();

		String valorDebitoString = (Util.formataBigDecimal(valorDebito, 2, true)).replace(",", "");
		valorDebitoString = valorDebitoString.replace(".", "");
		registroTipoE.append(Util.adicionarZerosEsquedaNumero(15, valorDebitoString));

		// Código da moeda
		registroTipoE.append("03");
		registroTipoE = (StringBuilder) ParametroArrecadacao.P_FORMATAR_CAMPO_ENVIO_DEB_AUTOMATICO_CODIGO_E.executar(this,
						ConstantesSistema.NUMERO_NAO_INFORMADO, registroTipoE, debitoAutomaticoMovimento, numeroSequencialArquivo);

		// reservado para o futuro
		registroTipoE.append(Util.completaString("", 20));
		// Tipo do Movimento
		registroTipoE.append(debitoAutomaticoMovimento.getIndicadorExclusao() != null
						&& debitoAutomaticoMovimento.getIndicadorExclusao().equals(Util.obterShort("1")) ? "1" : "0");

		return registroTipoE;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * Gera o arquivo TXT para envio.
	 * [SB0004] - Gerar Arquivo TXT para Envio do Banco
	 * 
	 * @author Sávio Luiz, eduardo henrique
	 * @date 17/07/2009
	 *       Alteracao para obter finalizadores de linha e fim de arquivo do for configurado no
	 *       .properties
	 * @param arrecadadorMovimento
	 *            ,registrosTipoE
	 * @return StringBuilder
	 * @throws ControladorException
	 */
	protected StringBuilder gerarArquivoTxt(ArrecadadorMovimento arrecadadorMovimento, StringBuilder registrosTipoE)
					throws ControladorException{

		StringBuilder arquivoTXTEnvio = new StringBuilder();
		// gera o header do arquivo(registroCódigoA)
		arquivoTXTEnvio.append("A");
		arquivoTXTEnvio.append(Util.completaString("" + arrecadadorMovimento.getCodigoRemessa(), 1));
		arquivoTXTEnvio.append(Util.completaString(arrecadadorMovimento.getCodigoConvenio(), 20));
		arquivoTXTEnvio.append(Util.completaString(arrecadadorMovimento.getNomeEmpresa(), 20));
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(3, "" + arrecadadorMovimento.getCodigoBanco()));
		arquivoTXTEnvio.append(Util.completaString(arrecadadorMovimento.getNomeBanco(), 20));
		String dataGeracaoArquivo = Util.recuperaAnoMesDiaDaData(arrecadadorMovimento.getDataGeracao());
		arquivoTXTEnvio.append(dataGeracaoArquivo);
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(6, "" + arrecadadorMovimento.getNumeroSequencialArquivo()));
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(2, "" + arrecadadorMovimento.getNumeroVersaoLayout()));
		arquivoTXTEnvio.append(Util.completaString(arrecadadorMovimento.getDescricaoIdentificacaoServico(), 17));

		// Formata Header de acordo com a Empresa.
		arquivoTXTEnvio = (StringBuilder) ParametroArrecadacao.P_FORMATAR_HEADER_DEB_AUTOMATICO.executar(this, -1, arquivoTXTEnvio);
		// arquivoTXTEnvio.append(Util.completaString("", 51));

		if(ConstantesAplicacao.get("aplicacao.separador_linha_arquivo_debito_automatico") != null){
			arquivoTXTEnvio.append(ConstantesAplicacao.get("aplicacao.separador_linha_arquivo_debito_automatico"));
		}
		arquivoTXTEnvio.append(System.getProperty("line.separator"));
		// recupera todos os registros do tipo E
		arquivoTXTEnvio.append(registrosTipoE);
		// gera o trailler(registro código "Z") do arquivo de envio
		arquivoTXTEnvio.append("Z");
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(6, "" + arrecadadorMovimento.getNumeroRegistrosMovimento()));
		String valorSemVirgula = ("" + arrecadadorMovimento.getValorTotalMovimento().setScale(2)).replace(".", "");
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(17, valorSemVirgula));

		// Formata Header de acordo com a Empresa.
		arquivoTXTEnvio = (StringBuilder) ParametroArrecadacao.P_FORMATAR_TRAILLER_DEB_AUTOMATICO.executar(this, -1, arquivoTXTEnvio);

		// arquivoTXTEnvio.append(Util.completaString("", 125));

		if(ConstantesAplicacao.get("aplicacao.separador_linha_arquivo_debito_automatico") != null){
			arquivoTXTEnvio.append(ConstantesAplicacao.get("aplicacao.separador_linha_arquivo_debito_automatico"));
		}
		arquivoTXTEnvio.append(System.getProperty("line.separator"));
		// fim de arquivo
		if(ConstantesAplicacao.get("aplicacao.finalizador_arquivo_debito_automatico") != null){
			arquivoTXTEnvio.append(ConstantesAplicacao.get("aplicacao.finalizador_arquivo_debito_automatico"));
		}

		return arquivoTXTEnvio;

	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * Cria uma linha de 150 posições com o registro tipo E.
	 * [SB0003] - Regerar arquivo TXT para um movimento de débito automático
	 * gerado anteriormente
	 * 
	 * @author Sávio Luiz
	 * @date 25/04/2006
	 * @param arrecadadorMovimento
	 * @return Object[]
	 * @throws ControladorException
	 */
	public void regerarArquivoTxtMovimentoDebitoAutomatico(ArrecadadorMovimento arrecadadorMovimento, String envioBanco, Usuario usuario)
					throws ControladorException{

		try{
			StringBuilder linhasParaGerarTxt = new StringBuilder();
			Collection colecaoArrecadadorMovimentoItem = null;
			String descricaoEmail = null;

			String estadoEmail = null;
			try{
				colecaoArrecadadorMovimentoItem = repositorioArrecadacao.consultarItensMovimentoArrecadador(arrecadadorMovimento, null,
								null, null);

				descricaoEmail = repositorioArrecadacao.pesquisarEmailArrecadadorContrato(arrecadadorMovimento.getCodigoBanco());

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
			Iterator iteratorArrecadadorMovimentoItem = colecaoArrecadadorMovimentoItem.iterator();
			while(iteratorArrecadadorMovimentoItem.hasNext()){
				ArrecadadorMovimentoItem arrecadadorMovimentoItem = (ArrecadadorMovimentoItem) iteratorArrecadadorMovimentoItem.next();
				linhasParaGerarTxt.append(arrecadadorMovimentoItem.getConteudoRegistro());
				linhasParaGerarTxt.append(System.getProperty("line.separator"));
			}
			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.REGERAR_MOVIMENTO_AUTOMATICO_BANCO);
			// cria o arquivo txt para o envio
			StringBuilder arquivoTxtGerado = gerarArquivoTxt(arrecadadorMovimento, linhasParaGerarTxt);

			String emailRemetente = envioEmail.getEmailRemetente();

			String tituloMensagem = envioEmail.getTituloMensagem()
							+ " "
							+ (arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento
											.getNumeroSequencialArquivo() : "");
			String corpoMensagem = envioEmail.getCorpoMensagem();
			String emailReceptor = envioEmail.getEmailReceptor();
			boolean mandouEmailBanco = false;
			try{

				File leitura = File.createTempFile("gcom", ".txt");
				BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leitura.getAbsolutePath())));
				out.write(arquivoTxtGerado.toString());
				out.flush();
				out.close();
				// caso o envio do banco seja igual a 1, então envia para o
				// banco
				if(envioBanco.equals("1")){
					// se o email do arrecadador movimento for preenchido
					if(descricaoEmail != null){

						ServicosEmail.enviarMensagemArquivoAnexado(descricaoEmail, emailRemetente, tituloMensagem, "", leitura);
						mandouEmailBanco = true;
						ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, "Registros Regerados",
										leitura);

						estadoEmail = "Enviado";
					}else{
						ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, "Registros Regerados",
										leitura);

						estadoEmail = "Não Enviado";
					}

				}else{
					ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, "Registros Gerados", leitura);

					estadoEmail = "Não Enviado";
				}
				leitura.delete();
			}catch(SendFailedException e){
				if(mandouEmailBanco){
					estadoEmail = "Enviado";
				}else{
					estadoEmail = "Não Enviado";
				}

			}catch(IOException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}catch(Exception e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			// Parte que gera o relatório e envia por email
			// cria uma instância da classe do relatório
			// cria uma instância da classe do relatório
			RelatorioMovimentoDebitoAutomaticoBanco relatorioMovimentoDebitoAutomaticoBanco = new RelatorioMovimentoDebitoAutomaticoBanco(
							usuario);
			GerarMovimentoDebitoAutomaticoBancoHelper gerarMovimentoDebitoAutomaticoBancoHelper = new GerarMovimentoDebitoAutomaticoBancoHelper();
			FiltroBanco filtroBanco = new FiltroBanco();
			filtroBanco.adicionarParametro(new ParametroSimples(FiltroBanco.ID, Integer.valueOf(arrecadadorMovimento.getCodigoBanco())));
			Collection colecaoBanco = getControladorUtil().pesquisar(filtroBanco, Banco.class.getName());
			Banco banco = null;
			if(colecaoBanco != null && !colecaoBanco.isEmpty()){
				banco = (Banco) Util.retonarObjetoDeColecao(colecaoBanco);
			}
			gerarMovimentoDebitoAutomaticoBancoHelper.setBanco(banco);

			gerarMovimentoDebitoAutomaticoBancoHelper.setArrecadadorMovimento(arrecadadorMovimento);
			gerarMovimentoDebitoAutomaticoBancoHelper.setDescricaoEmail(descricaoEmail);
			gerarMovimentoDebitoAutomaticoBancoHelper.setSituacaoEnvioEmail(estadoEmail);
			Collection colecaogerarMovimentoDebitoAutomatico = new ArrayList();
			colecaogerarMovimentoDebitoAutomatico.add(gerarMovimentoDebitoAutomaticoBancoHelper);

			relatorioMovimentoDebitoAutomaticoBanco.addParametro("colecaoGerarMovimentoDebitoAutomatico",
							colecaogerarMovimentoDebitoAutomatico);

			relatorioMovimentoDebitoAutomaticoBanco.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
			byte[] relatorioGerado = (byte[]) relatorioMovimentoDebitoAutomaticoBanco.executar();

			try{
				File leitura = File.createTempFile("gcom", ".PDF");
				FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
				out.write(relatorioGerado);
				out.flush();
				out.close();

				ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

				leitura.delete();
			}catch(IOException e){
				throw new ControladorException("erro.sistema", e);
			}

		}catch(Exception e){

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.REGERAR_MOVIMENTO_AUTOMATICO_BANCO_COM_ERRO);

			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");
			if(inicioMensagem != null && (!inicioMensagem[0].equals("erro") && !inicioMensagem[0].equals("atencao"))){
				mensagem = "erro.sistema";
			}

			String emailRemetente = envioEmail.getEmailRemetente();
			String tituloMensagem = envioEmail.getTituloMensagem()
							+ " "
							+ (arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento
											.getNumeroSequencialArquivo() : "");
			String emailReceptor = envioEmail.getEmailReceptor();

			/*
			 * try { ServicosEmail.enviarMensagem(emailRemetente, emailReceptor,
			 * tituloMensagem, ConstantesAplicacao.get(mensagem)); } catch
			 * (ErroEmailException e1) { }
			 */
			sessionContext.setRollbackOnly();
			e.printStackTrace();

		}
	}

	/**
	 * [UC0322] - Inserir Guia de Devolução
	 * Insere uma Guia de Devolução
	 * 
	 * @author Rafael Corrêa, Pedro Alexandre
	 * @date 29/04/2006, 21/11/2006
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer inserirGuiaDevolucao(GuiaDevolucao guiaDevolucao, Usuario usuarioLogado) throws ControladorException{

		String idRegistroAtendimento = guiaDevolucao.getRegistroAtendimento().getId().toString();

		Integer id = null;
		RegistroAtendimento registroAtendimento = null;
		OrdemServico ordemServico = null;
		Localidade localidade = null;

		/** ************************************************************************************ */
		/** Verificar as permissão especial para inserir uma devolução quando o * */
		/** valor da devolucao é maior que o valor da guia da devolucao * */
		/** Vivianne Sousa - 01/08/2007 * */
		boolean temPermissaoIcluirDevolucaoMaiorValorMaximo = getControladorPermissaoEspecial()
						.verificarPermissaoIcluirDevolucaoMaiorValorMaximo(usuarioLogado);
		/** ************************************************************************************ */

		// Pesquisar nos parâmetros do sistema AnoMesFaturamento
		SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

		// recupera o ano/mês de referência da arrecadação
		int anoMesArrecadacaoSistemaParametro = sistemaParametros.getAnoMesArrecadacao();

		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

		Date dataAtual = new Date();
		Date dataValidade = Util.adicionarNumeroDiasDeUmaData(dataAtual, 30);

		FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();
		filtroRegistroAtendimento.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimento.ID, idRegistroAtendimento));
		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.localidade");
		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.setorComercial");
		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.quadra");

		// filtroRegistroAtendimento
		// .adicionarCaminhoParaCarregamentoEntidade("cliente");
		Collection colecaoRegistrosAtendimentos = getControladorUtil().pesquisar(filtroRegistroAtendimento,
						RegistroAtendimento.class.getName());

		if(colecaoRegistrosAtendimentos != null && !colecaoRegistrosAtendimentos.isEmpty()){
			registroAtendimento = (RegistroAtendimento) colecaoRegistrosAtendimentos.iterator().next();
			if(registroAtendimento.getImovel() != null){
				if(guiaDevolucao.getDocumentoTipo().getId().equals("" + DocumentoTipo.CONTA)
								|| guiaDevolucao.getDocumentoTipo().getId().equals("" + DocumentoTipo.DEBITO_A_COBRAR)){
					throw new ControladorException("atencao.registro.atendimento.sem.imovel", null, idRegistroAtendimento);
				}
			}
		}else{
			throw new ControladorException("atencao.pesquisa_inexistente", null, "RA - Registro de Atendimento");
		}

		/*--<merge>--
		 if (guiaDevolucao.getOrdemServico() != null) {
		 	String idOrdemServico = guiaDevolucao.getOrdemServico().getId().toString();
		 	FiltroOrdemServico filtroOrdemServico = new FiltroOrdemServico();
		 	filtroOrdemServico.adicionarParametro(new ParametroSimples(
		 	FiltroOrdemServico.ID, idOrdemServico));
		 	filtroOrdemServico.adicionarCaminhoParaCarregamentoEntidade("servicoTipo.debitoTipo");

		 	Collection colecaoOrdemServico = getControladorUtil().pesquisar(
		 	filtroOrdemServico, OrdemServico.class.getName());

		 if (colecaoOrdemServico != null && !colecaoOrdemServico.isEmpty()) {
		 	ordemServico = (OrdemServico) colecaoOrdemServico.iterator().next();
		 } else {
		 	throw new ControladorException("atencao.pesquisa_inexistente", null, "Ordem de Serviço");
		 }

		 }
		 */

		if(ordemServico != null && registroAtendimento != null){
			if(ordemServico.getRegistroAtendimento() != null
							&& !ordemServico.getRegistroAtendimento().getId().equals(registroAtendimento.getId())){
				throw new ControladorException("atencao.ordem.servico.diferente.registro.atendimento", null, idRegistroAtendimento);
			}
		}

		if(guiaDevolucao.getLocalidade() != null){

			FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
			filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, guiaDevolucao.getLocalidade().getId().toString()));
			Collection colecaoLocalidade = getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

			if(colecaoLocalidade != null && !colecaoLocalidade.isEmpty()){
				localidade = (Localidade) colecaoLocalidade.iterator().next();
			}else{
				throw new ControladorException("atencao.pesquisa_inexistente", null, "Localidade");
			}
		}

		if(guiaDevolucao.getDocumentoTipo() != null){

			// [FS0008] - Verificar existência da conta
			if(guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)){

				if(guiaDevolucao.getContaGeral() == null || guiaDevolucao.getContaGeral().getConta() == null){
					throw new ControladorException("atencao.Informe_entidade", null, "Conta");
				}

				// Cria o filtro de conta e seta todos os parâmetros para pesquisar a conta do
				// imóvel
				FiltroConta filtroConta = new FiltroConta();
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, registroAtendimento.getImovel().getId()
								.toString()));
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, ""
								+ guiaDevolucao.getContaGeral().getConta().getReferencia()));
				filtroConta.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroConta.adicionarCaminhoParaCarregamentoEntidade("imovel");
				Collection colecaoConta = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

				if(colecaoConta != null && !colecaoConta.isEmpty()){

					// Recupera a conta do imóvel com a referência informada
					Conta conta = (Conta) colecaoConta.iterator().next();

					// [FS0009] - Verificar localidade da conta
					if(!localidade.getId().equals(conta.getLocalidade().getId())){

						throw new ControladorException("atencao.imovel.localidade.diferente.conta.localidade", null, conta.getLocalidade()
										.getId().toString(), registroAtendimento.getImovel().getLocalidade().getId().toString(),
										registroAtendimento.getImovel().getId().toString());
					}

					BigDecimal valorLimite = BigDecimal.ZERO;

					// Faz uma pesquisa em pagamento para somar o valor de
					// todos os pagamentos associados ao débito a cobrar,
					// depois subtraí-lo do valor total do débito e
					// verificar se o valor digitado é maior do que esse
					// valor
					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.CONTA_ID, conta.getId()));
					Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

					if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){

						Iterator colecaoPagamentoIterator = colecaoPagamento.iterator();

						while(colecaoPagamentoIterator.hasNext()){
							Pagamento pagamento = (Pagamento) colecaoPagamentoIterator.next();
							valorLimite = valorLimite.add(pagamento.getValorPagamento());
						}

						valorLimite = valorLimite.subtract(conta.getValorTotal());

						FiltroGuiaDevolucao filtroGuiaDevolucao = new FiltroGuiaDevolucao();
						filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(FiltroGuiaDevolucao.CONTA_ID, conta.getId()));
						filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(FiltroGuiaDevolucao.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
										DebitoCreditoSituacao.NORMAL));
						Collection colecaoGuiaDevolucao = getControladorUtil()
										.pesquisar(filtroGuiaDevolucao, GuiaDevolucao.class.getName());

						if(colecaoGuiaDevolucao != null && !colecaoGuiaDevolucao.isEmpty()){

							Iterator itera = colecaoGuiaDevolucao.iterator();

							while(itera.hasNext()){
								GuiaDevolucao guia = (GuiaDevolucao) itera.next();
								valorLimite = valorLimite.subtract(guia.getValorDevolucao());
							}
						}

						/*
						 * FiltroDevolucao filtroDevolucao = new FiltroDevolucao(); filtroDevolucao
						 * .adicionarParametro(new ParametroSimples(
						 * FiltroDevolucao.GUIA_DEVOLUCAO_CONTA_ID, conta.getId()));
						 * Collection colecaoDevolucaoContas = getControladorUtil()
						 * .pesquisar(filtroDevolucao, Devolucao.class.getName());
						 * if (colecaoDevolucaoContas != null && !colecaoDevolucaoContas.isEmpty())
						 * {
						 * Iterator colecaoDevolucaoContasIterator = colecaoDevolucaoContas
						 * .iterator();
						 * while (colecaoDevolucaoContasIterator.hasNext()) { Devolucao devolucao =
						 * (Devolucao) colecaoDevolucaoContasIterator
						 * .next(); valorLimite = valorLimite.subtract(devolucao
						 * .getValorDevolucao()); } }
						 */

					}else{
						throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados", null, "Conta "
										+ Util.formatarAnoMesParaMesAno(conta.getReferencia()) + " ");
					}

					if(guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0){

						if(valorLimite.compareTo(BigDecimal.ZERO) > 0 && !temPermissaoIcluirDevolucaoMaiorValorMaximo){
							throw new ControladorException("atencao.valor. devolucao.superior.valor.pagamento", null, Util
											.formatarMoedaReal(valorLimite), "Conta");
						}else{
							throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");
						}
						// } else if
						// (guiaDevolucao.getValorDevolucao().compareTo(
						// valorLimite) == 0) {
						// throw new ControladorException(
						// "atencao.valor.devolucao.igual.valor.pagamento",
						// null);
					}else{

						FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
						filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID,
										CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
						filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
						CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
										.pesquisar(filtroCreditoTipo, CreditoTipo.class.getName()).iterator().next();

						// [FS00018] - Verificar valor da devolução
						if(guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0
										&& !temPermissaoIcluirDevolucaoMaiorValorMaximo){
							throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade", null);
						}

						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.CONTA);

						int anoMesConta = guiaDevolucao.getContaGeral().getConta().getReferencia();

						guiaDevolucao.setContaGeral(new ContaGeral(conta.getId()));
						guiaDevolucao.setImovel(registroAtendimento.getImovel());
						guiaDevolucao.setLocalidade(registroAtendimento.getImovel().getLocalidade());
						guiaDevolucao.setAnoMesReferenciaContabil(Integer.valueOf(anoMesArrecadacaoSistemaParametro));
						guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(Integer.valueOf(anoMesConta));
						guiaDevolucao.setDataEmissao(dataAtual);
						guiaDevolucao.setDataValidade(dataValidade);
						guiaDevolucao.setCreditoTipo(creditoTipo);
						guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
						guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
						guiaDevolucao.setDocumentoTipo(documentoTipo);
						guiaDevolucao.setUltimaAlteracao(new Date());

						/**
						 * alterado por pedro alexandre dia 21/11/2006 alteração
						 * feita para acoplar o controle de abrangência de
						 * usuário
						 */
						// ------------ CONTROLE DE ABRANGENCIA ----------------
						Abrangencia abrangencia = new Abrangencia(usuarioLogado, guiaDevolucao.getLocalidade());

						if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
							sessionContext.setRollbackOnly();
							throw new ControladorException("atencao.acesso.negado.abrangencia");
						}else{
							id = (Integer) getControladorUtil().inserir(guiaDevolucao);
						}
						// ------------ FIM CONTROLE DE ABRANGENCIA
						// ----------------
					}

				}else{
					throw new ControladorException("atencao.pesquisa_inexistente", null, "Conta");
				}
			}else if(guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.GUIA_PAGAMENTO)){

				// [FS0010] - Verificar existência da guia de pagamento
				if(guiaDevolucao.getGuiaPagamentoGeral() != null){
					Cliente cliente = new Cliente();
					String idCliente = null;
					if(registroAtendimento.getImovel() == null){
						RegistroAtendimentoSolicitante registroAtendimentoSolicitante = null;

						FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();
						filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
										registroAtendimento.getId()));
						filtro.adicionarParametro(new ParametroSimples(
										FiltroRegistroAtendimentoSolicitante.INDICADOR_SOLICITANTE_PRINCIPAL, ConstantesSistema.SIM));
						filtro.adicionarCaminhoParaCarregamentoEntidade("cliente");
						Collection colecao = this.getControladorUtil().pesquisar(filtro, RegistroAtendimentoSolicitante.class.getName());

						if(colecao != null && !colecao.isEmpty()){
							registroAtendimentoSolicitante = (RegistroAtendimentoSolicitante) Util.retonarObjetoDeColecao(colecao);
							idCliente = "" + registroAtendimentoSolicitante.getCliente().getId();
							cliente.setId(Integer.valueOf(idCliente));
						}
					}else{
						guiaDevolucao.setImovel(registroAtendimento.getImovel());
					}
					// Pesquisa a guia de pagamento para o imóvel ou o cliente informado
					GuiaPagamento guiaPagamento = this.pesquisarGuiaPagamentoDigitada(registroAtendimento.getImovel() == null ? null
									: registroAtendimento.getImovel().getId().toString(), idCliente, guiaDevolucao.getGuiaPagamentoGeral()
									.getId().toString());

					// Caso a guia de pagamento esteja cadastrada no sistema, seta os dados da guai
					// de pagamento no form.
					// Caso contrário seta os dados da guia para nulo e informa ao usuário que não
					// existe guia de pagamento cadastrada no
					// sistema
					if(guiaPagamento != null){

						// [FS0011] - Verificar imóvel ou cliente da guia de pagamento
						if(registroAtendimento.getImovel() != null){
							if(guiaPagamento.getImovel() == null){
								throw new ControladorException("atencao.guia.pagamento.imovel.inexistente", null);
							}else{
								// Verifica se o id do imóvel do Registro de Atendimento
								// é diferente do id do imovel da Guia de Pagamento
								if(!(registroAtendimento.getImovel().getId().equals(guiaPagamento.getImovel().getId()))){
									throw new ControladorException("atencao.imovel.guia.pagamento.diferente.registro.atendimento.imovel",
													null, guiaPagamento.getImovel().getId().toString(), registroAtendimento.getImovel()
																	.getId().toString());
								}else{

									// Verifica se o id do localidade do imóvel do Registro de
									// Atendimento
									// é diferente do id da localidade da Guia de Pagamento
									if(!(localidade.getId().equals(guiaPagamento.getLocalidade().getId()))){
										throw new ControladorException("atencao.imovel.localidade.diferente.guia.pagamento.localidade",
														null, guiaPagamento.getLocalidade().getId().toString(), localidade.getId()
																		.toString(), registroAtendimento.getImovel().getId().toString());
									}
								}
							}
						} /*--<merge>--
											 else if (registroAtendimento.getCliente() != null) {
											 if (guiaPagamento.getCliente() == null) {
											 throw new ControladorException(
											 "atencao.guia.pagamento.cliente.inexistente",
											 null);
											 } else {
											 // Verifica se o id do cliente do Registro de
											 // Atendimento
											 // é diferente do id do cliente da Guia de
											 // Pagamento
											 if (!(registroAtendimento.getCliente().getId()
											 .equals(guiaPagamento.getCliente()
											 .getId()))) {
											 throw new ControladorException(
											 "atencao.cliente.guia.pagamento.diferente.registro.atendimento.cliente",
											 null, guiaPagamento.getCliente()
											 .getId().toString(),
											 registroAtendimento.getCliente()
											 .getId().toString());
											 }
											 }
											 }*/

						if(ordemServico != null){
							if(ordemServico.getServicoTipo().getDebitoTipo() != null){
								/*
								 * if (!(guiaPagamento.getDebitoTipo().getId()
								 * .equals(ordemServico.getServicoTipo() .getDebitoTipo().getId())))
								 * {
								 * throw new ControladorException(
								 * "atencao.debito.tipo.guia.pagamento.diferente.ordem.servico.debito.tipo"
								 * , null,
								 * guiaPagamento.getDebitoTipo() .getDescricao(),
								 * ordemServico.getServicoTipo() .getDebitoTipo() .getDescricao());
								 * }
								 */
							}
						}

						BigDecimal valorLimite = BigDecimal.ZERO;

						// Faz uma pesquisa em pagamento para somar o valor de
						// todos os pagamentos associados ao débito a cobrar,
						// depois subtraí-lo do valor total do débito e
						// verificar se o valor digitado é maior do que esse
						// valor
						FiltroPagamento filtroPagamento = new FiltroPagamento();
						filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.GUIA_PAGAMENTO_ID, guiaPagamento.getId()));
						Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

						if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
							Iterator colecaoPagamentoIterator = colecaoPagamento.iterator();
							while(colecaoPagamentoIterator.hasNext()){
								Pagamento pagamento = (Pagamento) colecaoPagamentoIterator.next();
								valorLimite = valorLimite.add(pagamento.getValorPagamento());
							}

							valorLimite = valorLimite.subtract(guiaPagamento.getValorDebito());

							FiltroGuiaDevolucao filtroGuiaDevolucao = new FiltroGuiaDevolucao();
							filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(FiltroGuiaDevolucao.GUIA_PAGAMENTO_ID,
											guiaPagamento.getId()));
							filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
											FiltroGuiaDevolucao.DEBITO_CREDITO_SITUACAO_ATUAL_ID, DebitoCreditoSituacao.NORMAL));
							Collection colecaoGuiaDevolucao = getControladorUtil().pesquisar(filtroGuiaDevolucao,
											GuiaDevolucao.class.getName());

							if(colecaoGuiaDevolucao != null && !colecaoGuiaDevolucao.isEmpty()){
								Iterator itera = colecaoGuiaDevolucao.iterator();
								while(itera.hasNext()){
									GuiaDevolucao guia = (GuiaDevolucao) itera.next();
									valorLimite = valorLimite.subtract(guia.getValorDevolucao());
								}
							}

							/*
							 * FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
							 * filtroDevolucao .adicionarParametro(new ParametroSimples(
							 * FiltroDevolucao.GUIA_DEVOLUCAO_GUIA_PAGAMENTO_ID,
							 * guiaDevolucao.getGuiaPagamento() .getId()));
							 * Collection colecaoDevolucaoGuiasPagamentos = getControladorUtil()
							 * .pesquisar(filtroDevolucao,
							 * Devolucao.class.getName());
							 * if (colecaoDevolucaoGuiasPagamentos != null &&
							 * !colecaoDevolucaoGuiasPagamentos .isEmpty()) {
							 * Iterator colecaoDevolucaoGuiasPagamentosIterator =
							 * colecaoDevolucaoGuiasPagamentos .iterator();
							 * while (colecaoDevolucaoGuiasPagamentosIterator .hasNext()) {
							 * Devolucao devolucao = (Devolucao)
							 * colecaoDevolucaoGuiasPagamentosIterator .next();
							 * valorLimite = valorLimite .subtract(devolucao .getValorDevolucao());
							 * } }
							 */

						}else{
							throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados", null, "Guia Pagamento "
											+ guiaPagamento.getId().toString() + " ");
						}

						if(guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0){

							if(valorLimite.compareTo(BigDecimal.ZERO) > 0 && !temPermissaoIcluirDevolucaoMaiorValorMaximo){
								throw new ControladorException("atencao.valor.devolucao.superior.valor.pagamento", null,
												Util.formatarMoedaReal(valorLimite), "Guia de Pagamento");
							}else{
								throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");
							}

							// } else if
							// (guiaDevolucao.getValorDevolucao().compareTo(
							// valorLimite) == 0) {
							// throw new ControladorException(
							// "atencao.valor.devolucao.igual.valor.pagamento",
							// null);
						}else{

							FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
							filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID,
											CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
							filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");

							CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
											.pesquisar(filtroCreditoTipo, CreditoTipo.class.getName()).iterator().next();

							// [FS00018] - Verificar valor da devolução
							if(guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0
											&& !temPermissaoIcluirDevolucaoMaiorValorMaximo){
								throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade", null);
							}

							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);

							guiaDevolucao.setImovel(registroAtendimento.getImovel());

							/*--<merge>--
							 guiaDevolucao.setCliente(registroAtendimento
							 .getCliente());*/
							guiaDevolucao.setLocalidade(guiaPagamento.getLocalidade());
							guiaDevolucao.setAnoMesReferenciaContabil(Integer.valueOf(anoMesArrecadacaoSistemaParametro));
							guiaDevolucao.setDataEmissao(dataAtual);
							guiaDevolucao.setDataValidade(dataValidade);
							guiaDevolucao.setCreditoTipo(creditoTipo);
							guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
							guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
							guiaDevolucao.setDocumentoTipo(documentoTipo);
							// guiaDevolucao.setDebitoTipo(guiaPagamento
							// .getDebitoTipo());

							// guiaDevolucao.setGuiaPagamento(guiaPagamento);
							guiaDevolucao.setUltimaAlteracao(new Date());
							guiaDevolucao.setCliente(cliente);
							guiaDevolucao.setImovel(registroAtendimento.getImovel());
							/**
							 * alterado por pedro alexandre dia 21/11/2006 alteração feita para
							 * acoplar o controle de abrangência de usuário
							 */
							// ------------ CONTROLE DE ABRANGENCIA
							// ----------------
							Abrangencia abrangencia = new Abrangencia(usuarioLogado, guiaDevolucao.getLocalidade());

							if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
								sessionContext.setRollbackOnly();
								throw new ControladorException("atencao.acesso.negado.abrangencia");
							}else{
								id = (Integer) getControladorUtil().inserir(guiaDevolucao);
							}
							// ------------ FIM CONTROLE DE ABRANGENCIA
							// ----------------
						}

					}else{
						throw new ControladorException("atencao.pesquisa_inexistente", null, "Guia de Pagamento");
					}

				}else{
					throw new ControladorException("atencao.Informe_entidade", null, "Guia de Pagamento");
				}

			}else if(guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.DEBITO_A_COBRAR)){

				// [FS0013] - Verificar existência do débito a cobrar

				// Caso o usuário tenha informado o código do débito a cobrar
				if(guiaDevolucao.getDebitoACobrarGeral() != null){

					// Pesquisa o débito a cobrar para o imóvel informado
					DebitoACobrar debitoACobrar = this.pesquisarDebitoACobrarDigitado(registroAtendimento.getImovel().getId().toString(),
									guiaDevolucao.getDebitoACobrarGeral().getId().toString());

					if(debitoACobrar != null){
						if(!(registroAtendimento.getImovel().getId().equals(debitoACobrar.getImovel().getId()))){
							throw new ControladorException("atencao.imovel.debito.a.cobrar.diferente.registro.atendimento.imovel", null,
											debitoACobrar.getImovel().getId().toString(), registroAtendimento.getImovel().getId()
															.toString());
						}else{
							// [FS0015] - Verificar localidade do débito a
							// cobrar
							if(!registroAtendimento.getImovel().getLocalidade().getId().equals(debitoACobrar.getLocalidade().getId())){
								throw new ControladorException("atencao.imovel.localidade.diferente.debito.a.cobrar.localidade", null,
												debitoACobrar.getLocalidade().getId().toString(), registroAtendimento.getImovel()
																.getLocalidade().getId().toString(), registroAtendimento.getImovel()
																.getId().toString());
							}
						}

						if(ordemServico != null){
							if(ordemServico.getServicoTipo().getDebitoTipo() != null){
								if(!(debitoACobrar.getDebitoTipo().getId().equals(ordemServico.getServicoTipo().getDebitoTipo().getId()))){
									throw new ControladorException(
													"atencao.debito.tipo.debito.a.cobrar.diferente.ordem.servico.debito.tipo", null,
													debitoACobrar.getDebitoTipo().getDescricao(), ordemServico.getServicoTipo()
																	.getDebitoTipo().getDescricao());
								}
							}
						}

						BigDecimal valorLimite = BigDecimal.ZERO;

						// Faz uma pesquisa em pagamento para somar o valor de
						// todos os pagamentos associados ao débito a cobrar,
						// depois subtraí-lo do valor total do débito e
						// verificar se o valor digitado é maior do que esse
						// valor
						FiltroPagamento filtroPagamento = new FiltroPagamento();
						filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.DEBITO_A_COBRAR_ID, debitoACobrar.getId()));

						Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

						if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
							Iterator colecaoPagamentoIterator = colecaoPagamento.iterator();

							while(colecaoPagamentoIterator.hasNext()){
								Pagamento pagamento = (Pagamento) colecaoPagamentoIterator.next();
								valorLimite = valorLimite.add(pagamento.getValorPagamento());
							}

							valorLimite = valorLimite.subtract(debitoACobrar.getValorTotal());

							FiltroGuiaDevolucao filtroGuiaDevolucao = new FiltroGuiaDevolucao();

							filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(FiltroGuiaDevolucao.DEBITO_A_COBRAR_ID,
											debitoACobrar.getId()));

							filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
											FiltroGuiaDevolucao.DEBITO_CREDITO_SITUACAO_ATUAL_ID, DebitoCreditoSituacao.NORMAL));

							Collection colecaoGuiaDevolucao = getControladorUtil().pesquisar(filtroGuiaDevolucao,
											GuiaDevolucao.class.getName());

							if(colecaoGuiaDevolucao != null && !colecaoGuiaDevolucao.isEmpty()){

								Iterator itera = colecaoGuiaDevolucao.iterator();

								while(itera.hasNext()){
									GuiaDevolucao guia = (GuiaDevolucao) itera.next();
									valorLimite = valorLimite.subtract(guia.getValorDevolucao());
								}
							}

							/*
							 * FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
							 * filtroDevolucao .adicionarParametro(new ParametroSimples(
							 * FiltroDevolucao.GUIA_DEVOLUCAO_DEBITO_A_COBRAR_ID,
							 * guiaDevolucao.getDebitoACobrar() .getId()));
							 * Collection colecaoDevolucaoDebitosACobrar = getControladorUtil()
							 * .pesquisar(filtroDevolucao,
							 * Devolucao.class.getName());
							 * if (colecaoDevolucaoDebitosACobrar != null &&
							 * !colecaoDevolucaoDebitosACobrar .isEmpty()) {
							 * Iterator colecaoDevolucaoDebitosACobrarIterator =
							 * colecaoDevolucaoDebitosACobrar .iterator();
							 * while (colecaoDevolucaoDebitosACobrarIterator .hasNext()) { Devolucao
							 * devolucao = (Devolucao)
							 * colecaoDevolucaoDebitosACobrarIterator .next(); valorLimite =
							 * valorLimite .subtract(devolucao .getValorDevolucao()); } }
							 */

						}else{
							throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados", null, "Débito a Cobrar "
											+ debitoACobrar.getId().toString() + " ");
						}

						if(guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0){

							if(valorLimite.compareTo(BigDecimal.ZERO) > 0 && !temPermissaoIcluirDevolucaoMaiorValorMaximo){
								throw new ControladorException("atencao.valor.devolucao.superior.valor.pagamento", null,
												Util.formatarMoedaReal(valorLimite), "Débito a Cobrar");
							}else{
								throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");
							}
							// } else if ( guiaDevolucao.getValorDevolucao().compareTo(valorLimite)
							// == 0) {
							// throw new
							// ControladorException("atencao.valor.devolucao.igual.valor.pagamento",null);
						}else{

							FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
							filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID,
											CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
							filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
							CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
											.pesquisar(filtroCreditoTipo, CreditoTipo.class.getName()).iterator().next();

							// [FS00018] - Verificar valor da devolução
							if(guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0
											&& !temPermissaoIcluirDevolucaoMaiorValorMaximo){
								throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade", null);
							}

							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);

							guiaDevolucao.setImovel(registroAtendimento.getImovel());
							guiaDevolucao.setLocalidade(debitoACobrar.getLocalidade());
							guiaDevolucao.setAnoMesReferenciaContabil(Integer.valueOf(anoMesArrecadacaoSistemaParametro));
							guiaDevolucao.setDataEmissao(dataAtual);
							guiaDevolucao.setDataValidade(dataValidade);
							guiaDevolucao.setCreditoTipo(creditoTipo);
							guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
							guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
							guiaDevolucao.setDocumentoTipo(documentoTipo);
							guiaDevolucao.setDebitoTipo(debitoACobrar.getDebitoTipo());
							// guiaDevolucao.setDebitoACobrar(debitoACobrar);
							guiaDevolucao.setUltimaAlteracao(new Date());

							/**
							 * alterado por pedro alexandre dia 21/11/2006 alteração feita para
							 * acoplar o controle de abrangência de usuário
							 */
							// ------------ CONTROLE DE ABRANGENCIA
							// ----------------
							Abrangencia abrangencia = new Abrangencia(usuarioLogado, guiaDevolucao.getLocalidade());

							if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
								sessionContext.setRollbackOnly();
								throw new ControladorException("atencao.acesso.negado.abrangencia");
							}else{
								id = (Integer) getControladorUtil().inserir(guiaDevolucao);
							}
							// ------------ FIM CONTROLE DE ABRANGENCIA
							// -------------
						}
					}else{
						throw new ControladorException("atencao.pesquisa_inexistente", null, "Débito a Cobrar");
					}
				}else{
					throw new ControladorException("atencao.Informe_entidade", null, "Débito a Cobrar");
				}
			}else if(guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.DEVOLUCAO_VALOR)){
				if(registroAtendimento.getImovel() == null){
					RegistroAtendimentoSolicitante registroAtendimentoSolicitante = null;

					FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();
					filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
									registroAtendimento.getId()));
					filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.INDICADOR_SOLICITANTE_PRINCIPAL,
									ConstantesSistema.SIM));
					filtro.adicionarCaminhoParaCarregamentoEntidade("cliente");
					Collection colecao = this.getControladorUtil().pesquisar(filtro, RegistroAtendimentoSolicitante.class.getName());

					if(colecao != null && !colecao.isEmpty()){
						registroAtendimentoSolicitante = (RegistroAtendimentoSolicitante) Util.retonarObjetoDeColecao(colecao);
						Cliente cliente = new Cliente();
						cliente.setId(registroAtendimentoSolicitante.getCliente().getId());
						guiaDevolucao.setCliente(cliente);
					}

					// LOCALIDADE
					if(guiaDevolucao.getLocalidade() == null){
						throw new ControladorException("atencao.Informe_entidade", null, "Localidade");
					}else{
						FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
						filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, guiaDevolucao.getLocalidade().getId()
										.toString()));
						Collection colecaoLocalidade = getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

						if(colecaoLocalidade == null || colecaoLocalidade.isEmpty()){
							throw new ControladorException("atencao.pesquisa_inexistente", null, "Localidade");
						}
					}
				}else{
					guiaDevolucao.setImovel(registroAtendimento.getImovel());
					guiaDevolucao.setLocalidade(registroAtendimento.getImovel().getLocalidade());
				}

				if(ordemServico == null || ordemServico.getServicoTipo().getDebitoTipo() == null){
					if(guiaDevolucao.getDebitoTipo() != null){
						FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, guiaDevolucao.getDebitoTipo().getId()
										.toString()));
						Collection colecaoDebitoTipo = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

						if(colecaoDebitoTipo == null || colecaoDebitoTipo.isEmpty()){
							throw new ControladorException("atencao.pesquisa_inexistente", null, "Tipo de Débito");
						}
					}
				}

				FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
				filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, CreditoTipo.DEVOLUCAO_OUTROS_VALORES));
				filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
				CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil().pesquisar(filtroCreditoTipo, CreditoTipo.class.getName())
								.iterator().next();

				// [FS00018] - Verificar valor da devolução
				if(guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0
								&& !temPermissaoIcluirDevolucaoMaiorValorMaximo){
					throw new ControladorException("atencao.valor.devolucao.superior.valor.limite", null);
				}

				DocumentoTipo documentoTipo = new DocumentoTipo();
				documentoTipo.setId(DocumentoTipo.DEVOLUCAO_VALOR);

				guiaDevolucao.setImovel(registroAtendimento.getImovel());

				/*--<merge>--guiaDevolucao.setCliente(registroAtendimento.getCliente());*/

				guiaDevolucao.setLocalidade(guiaDevolucao.getLocalidade());
				guiaDevolucao.setAnoMesReferenciaContabil(Integer.valueOf(anoMesArrecadacaoSistemaParametro));
				guiaDevolucao.setDataEmissao(dataAtual);
				guiaDevolucao.setDataValidade(dataValidade);
				guiaDevolucao.setCreditoTipo(creditoTipo);
				guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
				guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
				guiaDevolucao.setDocumentoTipo(documentoTipo);
				guiaDevolucao.setDebitoTipo(guiaDevolucao.getDebitoTipo());
				guiaDevolucao.setUltimaAlteracao(new Date());

				/**
				 * alterado por pedro alexandre dia 21/11/2006 alteração feita para acoplar o
				 * controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, guiaDevolucao.getLocalidade());

				if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				}else{
					id = (Integer) getControladorUtil().inserir(guiaDevolucao);
				}
				// ------------ CONTROLE DE ABRANGENCIA ----------------
			}
		}

		return id;

	}

	/**
	 * Faz a pesquisa de guia de devolução para o relatório fazendo os
	 * carregamentos de clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 11/09/2006
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ControladorException
	 */
	public Collection<GuiaDevolucao> pesquisarGuiaDevolucaoRelatorio(FiltroGuiaDevolucao filtroGuiaDevolucao) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarGuiaDevolucaoRelatorio(filtroGuiaDevolucao);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0324] - Filtrar Guia de Devolucao
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * Faz a pesquisa de guia de devolução fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ControladorException
	 */
	public Collection<GuiaDevolucao> pesquisarGuiaDevolucao(FiltroGuiaDevolucao filtroGuiaDevolucao, Integer numeroPagina)
					throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarGuiaDevolucao(filtroGuiaDevolucao, numeroPagina);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0324] - Filtrar Guia de Devolucao
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * Faz a pesquisa de guia de devolução fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ControladorException
	 */
	public Integer pesquisarGuiaDevolucaoCount(FiltroGuiaDevolucao filtroGuiaDevolucao) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarGuiaDevolucaoCount(filtroGuiaDevolucao);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0266] - Manter Guia de Devolução
	 * [SB0001] - Atualizar Guia de Devolução
	 * Atualiza uma Guia de Devolução e as Devoluções associadas a ela
	 * 
	 * @author Rafael Corrêa
	 * @date 09/05/2006
	 * @throws ControladorException
	 */
	public void atualizarGuiaDevolucao(GuiaDevolucao guiaDevolucao, Usuario usuarioLogado) throws ControladorException{

		/*--<merge>--String idRegistroAtendimento = guiaDevolucao.getRegistroAtendimento()
		 .getId().toString();*/
		String idRegistroAtendimento = null;

		RegistroAtendimento registroAtendimento = null;
		OrdemServico ordemServico = null;
		Localidade localidade = null;

		Date dataAtual = new Date();
		Date dataValidade = guiaDevolucao.getDataValidade();
		Date dataLimite = Util.adicionarNumeroDiasDeUmaData(dataAtual, 30);

		/** ************************************************************************************ */
		/** Verificar as permissão especial para inserir uma devolução quando o * */
		/** valor da devolucao é maior que o valor da guia da devolucao * */
		/** Vivianne Sousa - 01/08/2007 * */
		boolean temPermissaoIcluirDevolucaoMaiorValorMaximo = getControladorPermissaoEspecial()
						.verificarPermissaoIcluirDevolucaoMaiorValorMaximo(usuarioLogado);
		/** ************************************************************************************ */

		if(dataValidade.after(dataLimite)){
			throw new ControladorException("atencao.data.validade.superior.data.corrente.adicionado.trinta.dias", null,
							Util.formatarData(dataLimite));
		}

		FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();
		filtroRegistroAtendimento.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimento.ID, idRegistroAtendimento));

		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.localidade");
		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.setorComercial");
		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.quadra");
		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("cliente");

		Collection colecaoRegistrosAtendimentos = getControladorUtil().pesquisar(filtroRegistroAtendimento,
						RegistroAtendimento.class.getName());

		if(colecaoRegistrosAtendimentos != null && !colecaoRegistrosAtendimentos.isEmpty()){
			registroAtendimento = (RegistroAtendimento) colecaoRegistrosAtendimentos.iterator().next();

			/*--<merge>--
			 if (registroAtendimento.getCliente() != null) {

			 if (guiaDevolucao.getDocumentoTipo().getId().equals(
			 DocumentoTipo.CONTA)
			 || guiaDevolucao.getDocumentoTipo().getId().equals(
			 DocumentoTipo.DEBITO_A_COBRAR)) {
			 throw new ControladorException(
			 "atencao.registro.atendimento.sem.imovel", null,
			 idRegistroAtendimento);
			 }

			 } else {
			 guiaDevolucao.setCliente(null);
			 }*/

		}else{
			throw new ControladorException("atencao.pesquisa_inexistente", null, "RA - Registro de Atendimento");
		}

		/*--<merge>--
		 if (guiaDevolucao.getOrdemServico() != null) {
		 String idOrdemServico = guiaDevolucao.getOrdemServico().getId()
		 .toString();
		 FiltroOrdemServico filtroOrdemServico = new FiltroOrdemServico();
		 filtroOrdemServico.adicionarParametro(new ParametroSimples(
		 FiltroOrdemServico.ID, idOrdemServico));
		 filtroOrdemServico
		 .adicionarCaminhoParaCarregamentoEntidade("servicoTipo.debitoTipo");

		 Collection colecaoOrdemServico = getControladorUtil().pesquisar(
		 filtroOrdemServico, OrdemServico.class.getName());

		 if (colecaoOrdemServico != null && !colecaoOrdemServico.isEmpty()) {
		 ordemServico = (OrdemServico) colecaoOrdemServico.iterator()
		 .next();

		 } else {
		 throw new ControladorException("atencao.pesquisa_inexistente",
		 null, "Ordem de Serviço");
		 }

		 }*/

		if(ordemServico != null && registroAtendimento != null){
			if(ordemServico.getRegistroAtendimento() != null
							&& !ordemServico.getRegistroAtendimento().getId().equals(registroAtendimento.getId())){
				throw new ControladorException("atencao.ordem.servico.diferente.registro.atendimento", null, idRegistroAtendimento);
			}
		}

		if(guiaDevolucao.getLocalidade() != null){
			FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
			filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, guiaDevolucao.getLocalidade().getId().toString()));

			Collection colecaoLocalidade = getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

			if(colecaoLocalidade != null && !colecaoLocalidade.isEmpty()){
				localidade = (Localidade) colecaoLocalidade.iterator().next();

			}else{
				throw new ControladorException("atencao.pesquisa_inexistente", null, "Localidade");
			}
		}

		if(guiaDevolucao.getDocumentoTipo() != null){

			// [FS0008] - Verificar existência da conta
			if(guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)){
				if(guiaDevolucao.getContaGeral() != null && guiaDevolucao.getContaGeral().getConta() == null){
					throw new ControladorException("atencao.Informe_entidade", null, "Conta");
				}

				// Cria o filtro de conta e seta todos os parâmetros para
				// pesquisar a
				// conta do imóvel
				FiltroConta filtroConta = new FiltroConta();
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, registroAtendimento.getImovel().getId()
								.toString()));
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, ""
								+ guiaDevolucao.getContaGeral().getConta().getReferencia()));
				filtroConta.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroConta.adicionarCaminhoParaCarregamentoEntidade("imovel");

				Collection colecaoConta = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

				if(colecaoConta != null && !colecaoConta.isEmpty()){

					// Recupera a conta do imóvel com a referência informada
					Conta conta = (Conta) colecaoConta.iterator().next();

					// [FS0009] - Verificar localidade da conta
					if(!localidade.getId().equals(conta.getLocalidade().getId())){
						throw new ControladorException("atencao.imovel.localidade.diferente.conta.localidade", null, conta.getLocalidade()
										.getId().toString(), registroAtendimento.getImovel().getLocalidade().getId().toString(),
										registroAtendimento.getImovel().getId().toString());
					}

					BigDecimal valorLimite = BigDecimal.ZERO;

					// Faz uma pesquisa em pagamento para somar o valor de
					// todos os pagamentos associados ao débito a cobrar,
					// depois subtraí-lo do valor total do débito e
					// verificar se o valor digitado é maior do que esse
					// valor
					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.CONTA_ID, conta.getId()));

					Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

					if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
						Iterator colecaoPagamentoIterator = colecaoPagamento.iterator();

						while(colecaoPagamentoIterator.hasNext()){
							Pagamento pagamento = (Pagamento) colecaoPagamentoIterator.next();
							valorLimite = valorLimite.add(pagamento.getValorPagamento());
						}

						valorLimite = valorLimite.subtract(conta.getValorTotal());

						FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
						filtroDevolucao.adicionarParametro(new ParametroSimples(FiltroDevolucao.GUIA_DEVOLUCAO_CONTA_ID, conta.getId()));

						Collection colecaoDevolucaoContas = getControladorUtil().pesquisar(filtroDevolucao, Devolucao.class.getName());

						if(colecaoDevolucaoContas != null && !colecaoDevolucaoContas.isEmpty()){
							Iterator colecaoDevolucaoContasIterator = colecaoDevolucaoContas.iterator();
							while(colecaoDevolucaoContasIterator.hasNext()){
								Devolucao devolucao = (Devolucao) colecaoDevolucaoContasIterator.next();
								valorLimite = valorLimite.subtract(devolucao.getValorDevolucao());
							}
						}

					}else{
						throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados", null, "Conta "
										+ Util.formatarAnoMesParaMesAno(conta.getReferencia()) + " ");
					}

					if(guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0){

						if(valorLimite.compareTo(BigDecimal.ZERO) > 0 && !temPermissaoIcluirDevolucaoMaiorValorMaximo){

							throw new ControladorException("atencao.valor.devolucao.superior.valor.pagamento", null,
											Util.formatarMoedaReal(valorLimite), "Conta");

						}else{
							throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");
						}
						// } else if
						// (guiaDevolucao.getValorDevolucao().compareTo(
						// valorLimite) == 0) {
						// throw new ControladorException(
						// "atencao.valor.devolucao.igual.valor.pagamento",
						// null);
					}else{

						FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
						filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID,
										CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
						filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
						CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
										.pesquisar(filtroCreditoTipo, CreditoTipo.class.getName()).iterator().next();

						// [FS00018] - Verificar valor da devolução
						if(guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0
										&& !temPermissaoIcluirDevolucaoMaiorValorMaximo){
							throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade", null);
						}

						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.CONTA);

						int anoMesConta = guiaDevolucao.getContaGeral().getConta().getReferencia();

						guiaDevolucao.setDebitoTipo(null);

						guiaDevolucao.getContaGeral().setConta(conta);
						guiaDevolucao.setImovel(registroAtendimento.getImovel());
						guiaDevolucao.setLocalidade(registroAtendimento.getImovel().getLocalidade());
						guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(Integer.valueOf(anoMesConta));
						guiaDevolucao.setDataEmissao(dataAtual);
						guiaDevolucao.setDataValidade(dataValidade);
						guiaDevolucao.setCreditoTipo(creditoTipo);
						guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
						guiaDevolucao.setDocumentoTipo(documentoTipo);

					}

				}else{
					throw new ControladorException("atencao.pesquisa_inexistente", null, "Conta");
				}
			}else if(guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.GUIA_PAGAMENTO)){
				// [FS0010] - Verificar existência da guia de pagamento
				if(guiaDevolucao.getGuiaPagamentoGeral() != null){
					// Pesquisa a guia de pagamento para o imóvel ou o cliente
					// informado verificando se o cliente ou o imóvel é nulo

					/*--<merge>--GuiaPagamento guiaPagamento = this
					 .pesquisarGuiaPagamentoDigitada(registroAtendimento
					 .getImovel() == null ? null
					 : registroAtendimento.getImovel().getId()
					 .toString(), registroAtendimento
					 .getCliente() == null ? null
					 : registroAtendimento.getCliente().getId()
					 .toString(), guiaDevolucao
					 .getGuiaPagamento().getId().toString());*/
					GuiaPagamento guiaPagamento = null;

					// Caso a guia de pagamento esteja cadastrada no sistema
					// Seta os dados da guai de pagamento no form
					// Caso contrário seta os dados da guia para nulo e informa
					// ao
					// usuário que não existe guia de pagamento cadastrada no
					// sistema
					if(guiaPagamento != null){

						// [FS0011] - Verificar imóvel ou cliente da guia de
						// pagamento
						if(registroAtendimento.getImovel() != null){
							if(guiaPagamento.getImovel() == null){
								throw new ControladorException("atencao.guia.pagamento.imovel.inexistente", null);
							}else{
								// Verifica se o id do imóvel do Registro de
								// Atendimento
								// é diferente do id do imovel da Guia de
								// Pagamento
								if(!(registroAtendimento.getImovel().getId().equals(guiaPagamento.getImovel().getId()))){
									throw new ControladorException("atencao.imovel.guia.pagamento.diferente.registro.atendimento.imovel",
													null, guiaPagamento.getImovel().getId().toString(), registroAtendimento.getImovel()
																	.getId().toString());
								}else{
									// Verifica se o id do localidade do imóvel
									// do
									// Registro de Atendimento
									// é diferente do id da localidade da Guia
									// de
									// Pagamento
									if(!(localidade.getId().equals(guiaPagamento.getLocalidade().getId()))){
										throw new ControladorException("atencao.imovel.localidade.diferente.guia.pagamento.localidade",
														null, guiaPagamento.getLocalidade().getId().toString(), localidade.getId()
																		.toString(), registroAtendimento.getImovel().getId().toString());
									}
								}
							}
						} /*--<merge>--
							else if (registroAtendimento.getCliente() != null) {
							if (guiaPagamento.getCliente() == null) {
							throw new ControladorException(
							"atencao.guia.pagamento.cliente.inexistente",
							null);
							} else {
							// Verifica se o id do cliente do Registro de
							// Atendimento
							// é diferente do id do cliente da Guia de
							// Pagamento
							if (!(registroAtendimento.getCliente().getId()
							.equals(guiaPagamento.getCliente()
							.getId()))) {
							throw new ControladorException(
							"atencao.cliente.guia.pagamento.diferente.registro.atendimento.cliente",
							null, guiaPagamento.getCliente()
							.getId().toString(),
							registroAtendimento.getCliente()
							.getId().toString());
							}
							}
							} */

						if(ordemServico != null){
							if(ordemServico.getServicoTipo().getDebitoTipo() != null){
								/*
								 * if (!(guiaPagamento.getDebitoTipo().getId()
								 * .equals(ordemServico.getServicoTipo()
								 * .getDebitoTipo().getId()))) {
								 * throw new ControladorException(
								 * "atencao.debito.tipo.guia.pagamento.diferente.ordem.servico.debito.tipo"
								 * ,
								 * null, guiaPagamento.getDebitoTipo()
								 * .getDescricao(),
								 * ordemServico.getServicoTipo()
								 * .getDebitoTipo()
								 * .getDescricao());
								 * }
								 */
							}
						}

						BigDecimal valorLimite = BigDecimal.ZERO;

						// Faz uma pesquisa em pagamento para somar o valor de
						// todos os pagamentos associados ao débito a cobrar,
						// depois subtraí-lo do valor total do débito e
						// verificar se o valor digitado é maior do que esse
						// valor
						FiltroPagamento filtroPagamento = new FiltroPagamento();
						filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.GUIA_PAGAMENTO_ID, guiaPagamento.getId()));

						Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

						if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
							Iterator colecaoPagamentoIterator = colecaoPagamento.iterator();

							while(colecaoPagamentoIterator.hasNext()){
								Pagamento pagamento = (Pagamento) colecaoPagamentoIterator.next();
								valorLimite = valorLimite.add(pagamento.getValorPagamento());
							}

							valorLimite = valorLimite.subtract(guiaPagamento.getValorDebito());

							FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
							filtroDevolucao.adicionarParametro(new ParametroSimples(FiltroDevolucao.GUIA_DEVOLUCAO_GUIA_PAGAMENTO_ID,
											guiaDevolucao.getGuiaPagamentoGeral().getId()));

							Collection colecaoDevolucaoGuiasPagamentos = getControladorUtil().pesquisar(filtroDevolucao,
											Devolucao.class.getName());

							if(colecaoDevolucaoGuiasPagamentos != null && !colecaoDevolucaoGuiasPagamentos.isEmpty()){
								Iterator colecaoDevolucaoGuiasPagamentosIterator = colecaoDevolucaoGuiasPagamentos.iterator();
								while(colecaoDevolucaoGuiasPagamentosIterator.hasNext()){
									Devolucao devolucao = (Devolucao) colecaoDevolucaoGuiasPagamentosIterator.next();
									valorLimite = valorLimite.subtract(devolucao.getValorDevolucao());
								}
							}

						}else{
							throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados", null, "Guia Pagamento "
											+ guiaPagamento.getId().toString() + " ");
						}

						if(guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0){

							if(valorLimite.compareTo(BigDecimal.ZERO) > 0 && !temPermissaoIcluirDevolucaoMaiorValorMaximo){

								throw new ControladorException("atencao.valor.devolucao.superior.valor.pagamento", null,
												Util.formatarMoedaReal(valorLimite), "Guia de Pagamento");

							}else{
								throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");
							}
							// } else if
							// (guiaDevolucao.getValorDevolucao().compareTo(
							// valorLimite) == 0) {
							// throw new ControladorException(
							// "atencao.valor.devolucao.igual.valor.pagamento",
							// null);
						}else{

							FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
							filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID,
											CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
							filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
							CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
											.pesquisar(filtroCreditoTipo, CreditoTipo.class.getName()).iterator().next();

							// [FS00018] - Verificar valor da devolução
							if(guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0
											&& !temPermissaoIcluirDevolucaoMaiorValorMaximo){
								throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade", null);
							}

							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);

							guiaDevolucao.setImovel(registroAtendimento.getImovel());
							/*--<merge>--guiaDevolucao.setCliente(registroAtendimento
							 .getCliente());*/
							guiaDevolucao.setLocalidade(guiaPagamento.getLocalidade());
							guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(null);
							guiaDevolucao.setDataValidade(dataValidade);
							guiaDevolucao.setCreditoTipo(creditoTipo);
							guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
							guiaDevolucao.setDocumentoTipo(documentoTipo);
							// guiaDevolucao.setDebitoTipo(guiaPagamento
							// .getDebitoTipo());

							// guiaDevolucao.setGuiaPagamento(guiaPagamento);

						}

					}else{
						throw new ControladorException("atencao.pesquisa_inexistente", null, "Guia de Pagamento");
					}

				}else{
					throw new ControladorException("atencao.Informe_entidade", null, "Guia de Pagamento");
				}

			}else if(guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.DEBITO_A_COBRAR)){
				// [FS0013] - Verificar existência do débito a cobrar

				// Caso o usuário tenha informado o código do débito a cobrar
				if(guiaDevolucao.getDebitoACobrarGeral() != null){
					// Pesquisa o débito a cobrar para o imóvel informado
					DebitoACobrar debitoACobrar = this.pesquisarDebitoACobrarDigitado(registroAtendimento.getImovel().getId().toString(),
									guiaDevolucao.getDebitoACobrarGeral().getId().toString());

					if(debitoACobrar != null){
						if(!(registroAtendimento.getImovel().getId().equals(debitoACobrar.getImovel().getId()))){
							throw new ControladorException("atencao.imovel.debito.a.cobrar.diferente.registro.atendimento.imovel", null,
											debitoACobrar.getImovel().getId().toString(), registroAtendimento.getImovel().getId()
															.toString());
						}else{
							// [FS0015] - Verificar localidade do débito a
							// cobrar
							if(!registroAtendimento.getImovel().getLocalidade().getId().equals(debitoACobrar.getLocalidade().getId())){
								throw new ControladorException("atencao.imovel.localidade.diferente.debito.a.cobrar.localidade", null,
												debitoACobrar.getLocalidade().getId().toString(), registroAtendimento.getImovel()
																.getLocalidade().getId().toString(), registroAtendimento.getImovel()
																.getId().toString());
							}
						}

						if(ordemServico != null){
							if(ordemServico.getServicoTipo().getDebitoTipo() != null){
								if(!(debitoACobrar.getDebitoTipo().getId().equals(ordemServico.getServicoTipo().getDebitoTipo().getId()))){
									throw new ControladorException(
													"atencao.debito.tipo.debito.a.cobrar.diferente.ordem.servico.debito.tipo", null,
													debitoACobrar.getDebitoTipo().getDescricao(), ordemServico.getServicoTipo()
																	.getDebitoTipo().getDescricao());
								}
							}
						}

						BigDecimal valorLimite = BigDecimal.ZERO;

						// Faz uma pesquisa em pagamento para somar o valor de
						// todos os pagamentos associados ao débito a cobrar,
						// depois subtraí-lo do valor total do débito e
						// verificar se o valor digitado é maior do que esse
						// valor
						FiltroPagamento filtroPagamento = new FiltroPagamento();
						filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.DEBITO_A_COBRAR_ID, debitoACobrar.getId()));

						Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

						if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
							Iterator colecaoPagamentoIterator = colecaoPagamento.iterator();

							while(colecaoPagamentoIterator.hasNext()){
								Pagamento pagamento = (Pagamento) colecaoPagamentoIterator.next();
								valorLimite = valorLimite.add(pagamento.getValorPagamento());
							}

							valorLimite = valorLimite.subtract(debitoACobrar.getValorTotal());

							FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
							filtroDevolucao.adicionarParametro(new ParametroSimples(FiltroDevolucao.GUIA_DEVOLUCAO_DEBITO_A_COBRAR_ID,
											guiaDevolucao.getDebitoACobrarGeral().getId()));

							Collection colecaoDevolucaoDebitosACobrar = getControladorUtil().pesquisar(filtroDevolucao,
											Devolucao.class.getName());

							if(colecaoDevolucaoDebitosACobrar != null && !colecaoDevolucaoDebitosACobrar.isEmpty()){
								Iterator colecaoDevolucaoDebitosACobrarIterator = colecaoDevolucaoDebitosACobrar.iterator();
								while(colecaoDevolucaoDebitosACobrarIterator.hasNext()){
									Devolucao devolucao = (Devolucao) colecaoDevolucaoDebitosACobrarIterator.next();
									valorLimite = valorLimite.subtract(devolucao.getValorDevolucao());
								}
							}

						}else{
							throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados", null, "Débito a Cobrar "
											+ debitoACobrar.getId().toString() + " ");
						}

						if(guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0){

							if(valorLimite.compareTo(BigDecimal.ZERO) > 0 && !temPermissaoIcluirDevolucaoMaiorValorMaximo){

								throw new ControladorException("atencao.valor.devolucao.superior.valor.pagamento", null,
												Util.formatarMoedaReal(valorLimite), "Débito a Cobrar");

							}else{
								throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");
							}
							// } else if
							// (guiaDevolucao.getValorDevolucao().compareTo(
							// valorLimite) == 0) {
							// throw new ControladorException(
							// "atencao.valor.devolucao.igual.valor.pagamento",
							// null);
						}else{

							FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
							filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID,
											CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
							filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
							CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
											.pesquisar(filtroCreditoTipo, CreditoTipo.class.getName()).iterator().next();

							// [FS00018] - Verificar valor da devolução
							if(guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0
											&& !temPermissaoIcluirDevolucaoMaiorValorMaximo){
								throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade", null);
							}

							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);

							guiaDevolucao.setImovel(registroAtendimento.getImovel());
							guiaDevolucao.setLocalidade(debitoACobrar.getLocalidade());
							guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(null);
							guiaDevolucao.setDataValidade(dataValidade);
							guiaDevolucao.setCreditoTipo(creditoTipo);
							guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
							guiaDevolucao.setDocumentoTipo(documentoTipo);
							guiaDevolucao.setDebitoTipo(debitoACobrar.getDebitoTipo());
							// guiaDevolucao.setDebitoACobrar(debitoACobrar);

						}
					}else{
						throw new ControladorException("atencao.pesquisa_inexistente", null, "Débito a Cobrar");
					}
				}else{
					throw new ControladorException("atencao.Informe_entidade", null, "Débito a Cobrar");
				}
			}else if(guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.DEVOLUCAO_VALOR)){

				if(registroAtendimento.getImovel() == null){
					if(guiaDevolucao.getLocalidade() == null){
						throw new ControladorException("atencao.Informe_entidade", null, "Localidade");
					}else{
						FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
						filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, guiaDevolucao.getLocalidade().getId()
										.toString()));

						Collection colecaoLocalidade = getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

						if(colecaoLocalidade == null || colecaoLocalidade.isEmpty()){
							throw new ControladorException("atencao.pesquisa_inexistente", null, "Localidade");
						}
					}
				}else{
					guiaDevolucao.setLocalidade(registroAtendimento.getImovel().getLocalidade());
				}
				if(ordemServico == null || ordemServico.getServicoTipo().getDebitoTipo() == null){
					if(guiaDevolucao.getDebitoTipo() == null){
						throw new ControladorException("atencao.Informe_entidade", null, "Tipo de Débito");
					}else{
						FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, guiaDevolucao.getDebitoTipo().getId()
										.toString()));

						Collection colecaoDebitoTipo = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

						if(colecaoDebitoTipo == null || colecaoDebitoTipo.isEmpty()){
							throw new ControladorException("atencao.pesquisa_inexistente", null, "Tipo de Débito");
						}
					}
				}

				FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
				filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, CreditoTipo.DEVOLUCAO_OUTROS_VALORES));
				filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
				CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil().pesquisar(filtroCreditoTipo, CreditoTipo.class.getName())
								.iterator().next();

				// [FS00018] - Verificar valor da devolução
				if(guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0
								&& !temPermissaoIcluirDevolucaoMaiorValorMaximo){
					throw new ControladorException("atencao.valor.devolucao.superior.valor.limite", null);
				}

				DocumentoTipo documentoTipo = new DocumentoTipo();
				documentoTipo.setId(DocumentoTipo.DEVOLUCAO_VALOR);

				guiaDevolucao.setImovel(registroAtendimento.getImovel());
				/*--<merge>--guiaDevolucao.setCliente(registroAtendimento.getCliente());*/
				guiaDevolucao.setLocalidade(guiaDevolucao.getLocalidade());
				guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(null);
				guiaDevolucao.setDataValidade(dataValidade);
				guiaDevolucao.setCreditoTipo(creditoTipo);
				guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
				guiaDevolucao.setDocumentoTipo(documentoTipo);
				guiaDevolucao.setDebitoTipo(guiaDevolucao.getDebitoTipo());
			}
		}

		FiltroGuiaDevolucao filtroGuiaDevolucao = new FiltroGuiaDevolucao();
		filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(FiltroGuiaDevolucao.ID, guiaDevolucao.getId()));

		Collection colecaoGuiaDevolucao = getControladorUtil().pesquisar(filtroGuiaDevolucao, GuiaDevolucao.class.getName());
		GuiaDevolucao guiaDevolucaoBase = null;

		if(colecaoGuiaDevolucao != null && !colecaoGuiaDevolucao.isEmpty()){
			guiaDevolucaoBase = (GuiaDevolucao) colecaoGuiaDevolucao.iterator().next();
		}else{
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		if(guiaDevolucaoBase != null && guiaDevolucaoBase.getUltimaAlteracao().after(guiaDevolucao.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		guiaDevolucao.setUltimaAlteracao(new Date());
		getControladorUtil().atualizar(guiaDevolucao);

		// Faz um filtro das Devoluções associadas à guia de devolução
		// atualizada para atualizá-las também
		FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
		filtroDevolucao.adicionarParametro(new ParametroSimples(FiltroDevolucao.GUIA_DEVOLUCAO_ID, guiaDevolucao.getId()));

		Collection colecaoDevolucao = getControladorUtil().pesquisar(filtroDevolucao, Devolucao.class.getName());

		if(colecaoDevolucao != null && !colecaoDevolucao.isEmpty()){
			Iterator colecaoDevolucaoIterator = colecaoDevolucao.iterator();

			while(colecaoDevolucaoIterator.hasNext()){
				Devolucao devolucao = (Devolucao) colecaoDevolucaoIterator.next();

				// Seta os valores para atualizar as devoluções
				devolucao.setAnoMesReferenciaDevolucao(guiaDevolucao.getAnoMesReferenciaGuiaDevolucao());
				devolucao.setLocalidade(guiaDevolucao.getLocalidade());
				devolucao.setImovel(guiaDevolucao.getImovel());
				devolucao.setCliente(guiaDevolucao.getCliente());
				devolucao.setDebitoTipo(guiaDevolucao.getDebitoTipo());
				devolucao.setUltimaAlteracao(new Date());

				getControladorUtil().atualizar(devolucao);

			}
		}
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo do Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 24/05/2006
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorio(String opcaoTotalizacao, int mesAnoReferencia, Integer gerenciaRegional,
					Integer localidade, Integer unidadeNegocio, Integer idSetorComercial) throws ControladorException{

		Collection retorno = new ArrayList();
		Collection colecaoResumoArrecadacaoRelatorio = null;

		// Converter de mesAno para anoMes para que funcione nas consultas
		int anoMesReferencia = Util.formatarMesAnoParaAnoMes(mesAnoReferencia);
		boolean consultarResumoArrecadacaoRelatorio = true;

		try{

			if(opcaoTotalizacao.equals("estado")){
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao.consultarResumoArrecadacaoRelatorioPorEstado(anoMesReferencia);

			}else if(opcaoTotalizacao.equals("estadoGerencia")){
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
								.consultarResumoArrecadacaoRelatorioPorEstadoPorGerenciaRegional(anoMesReferencia);

			}else if(opcaoTotalizacao.equals("estadoLocalidade")){
				retorno = consultarResumoArrecadacaoRelatorioPorEstadoPorLocalidade(anoMesReferencia);

				consultarResumoArrecadacaoRelatorio = false;

			}else if(opcaoTotalizacao.equals("gerenciaRegional")){
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao.consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
								anoMesReferencia, gerenciaRegional);

			}else if(opcaoTotalizacao.equals("gerenciaRegionalLocalidade")){
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
								.consultarResumoArrecadacaoRelatorioPorGerenciaRegionalPorLocalidade(anoMesReferencia, gerenciaRegional);

			}else if(opcaoTotalizacao.equals("localidade")){

				if(idSetorComercial != null){
					colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
									.consultarResumoArrecadacaoRelatorioPorLocalidadePorSetorComercial(anoMesReferencia, localidade,
													idSetorComercial);
				}else{
					colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao.consultarResumoArrecadacaoRelatorioPorLocalidade(
									anoMesReferencia, localidade);
				}

			}else if(opcaoTotalizacao.equals("estadoUnidadeNegocio")){
				retorno = consultarResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio(anoMesReferencia);

				consultarResumoArrecadacaoRelatorio = false;

			}else if(opcaoTotalizacao.equals("unidadeNegocio")){
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao.consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(
								anoMesReferencia, unidadeNegocio);

			}

			if(consultarResumoArrecadacaoRelatorio){

				Iterator iterator = colecaoResumoArrecadacaoRelatorio.iterator();

				// Prepara cada linha do relatório

				String recebimentoTipo = null;
				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String idLocalidadeAnterior = null;
				String descLancamentoTipoSuperior = "";
				Integer codigoSetorComercial = null;
				String descricaoSetorComercial = null;

				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				Boolean agrupaPorGerencia = false;
				if(opcaoTotalizacao.equalsIgnoreCase("estadoGerencia") || opcaoTotalizacao.equalsIgnoreCase("gerenciaRegional")){
					agrupaPorGerencia = true;
				}

				Boolean agrupaPorLocalidade = false;
				if(opcaoTotalizacao.equalsIgnoreCase("estadoLocalidade") || opcaoTotalizacao.equalsIgnoreCase("gerenciaRegionalLocalidade")
								|| opcaoTotalizacao.equalsIgnoreCase("localidade")){
					agrupaPorLocalidade = true;
				}

				Boolean agrupaPorUnidadeNegocio = false;
				if(opcaoTotalizacao.equalsIgnoreCase("unidadeNegocio") || opcaoTotalizacao.equalsIgnoreCase("estadoUnidadeNegocio")){
					agrupaPorUnidadeNegocio = true;
				}

				while(iterator.hasNext()){
					Object[] element = null;
					String tempRecebimentoTipo = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;

					element = (Object[]) iterator.next();

					if(recebimentoTipo == null){
						recebimentoTipo = (String) element[1];
						tipoLancamento = (String) element[2];
						itemLancamento = (String) element[3];
						itemContabel = (String) element[4];
					}

					tempRecebimentoTipo = (String) element[1];
					tempTipoLancamento = (String) element[2];
					tempItemLancamento = (String) element[3];
					tempItemContabel = (String) element[4];

					if(idSetorComercial != null){
						codigoSetorComercial = (Integer) element[16];
						descricaoSetorComercial = (String) element[17];
					}

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if(recebimentoTipo.equals(tempRecebimentoTipo) && tipoLancamento.equals(tempTipoLancamento)
									&& itemLancamento.equals(tempItemLancamento)){

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if(itemContabel == null && tempItemContabel == null
										|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

							// se for agrupado por gerencia
							// compara se o registro atual eh da
							// mesma gerencia regional do registro anterior
							if(!agrupaPorGerencia || descGerenciaRegionalAnterior == null
											|| (agrupaPorGerencia && descGerenciaRegionalAnterior.equalsIgnoreCase((String) element[10]))){

								switch(((Integer) element[9]).intValue()){
									case 1:
										arrayValores[0] = (BigDecimal) element[0];
										break;
									case 2:
										arrayValores[1] = (BigDecimal) element[0];
										break;
									case 3:
										arrayValores[2] = (BigDecimal) element[0];
										break;
									case 4:
										arrayValores[4] = (BigDecimal) element[0];
										break;
								}
							}else{
								condicaoIgual = false;
							}

						}else{

							condicaoIgual = false;
						}

					}else{

						condicaoIgual = false;

					}

					if(!condicaoIgual){

						// adiciona uma linha no relátorio
						ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
										arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
										(String) elementAnterior[3], (String) elementAnterior[4], (Short) elementAnterior[5],
										(Short) elementAnterior[6], (Integer) elementAnterior[7], (Integer) elementAnterior[8], false,
										descGerenciaRegionalAnterior, idGerenciaRegionalAnterior, descLocalidadeAnterior,
										idLocalidadeAnterior, descLancamentoTipoSuperior, descUnidadeNegocioAnterior,
										idUnidadeNegocioAnterior, codigoSetorComercial, descricaoSetorComercial);

						retorno.add(resumoArrecadacaoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch(((Integer) element[9]).intValue()){
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
						}

					}

					elementAnterior[1] = element[1]; // descricaoTipoRecebimento
					elementAnterior[2] = element[2]; // descricaoTipoLancamento
					elementAnterior[3] = element[3]; // descricaoItemLancamento
					elementAnterior[4] = element[4]; // descricaoItemContabil
					elementAnterior[5] = element[5]; // indicadorImpressao
					elementAnterior[6] = element[6]; // indicadorTotal
					elementAnterior[7] = element[7]; // lancamentoTipo
					elementAnterior[8] = element[8]; // lancamentoTipoSuperior

					// identifica pelo que vai ser "quebrado" o relátorio
					if(agrupaPorGerencia){
						// quebra página por Gerência Regional e não mostra a
						// Localidade
						descGerenciaRegionalAnterior = "" + element[10];
						idGerenciaRegionalAnterior = "" + element[11];
					}
					if(agrupaPorLocalidade){
						if(opcaoTotalizacao.equalsIgnoreCase("estadoLocalidade")
										|| opcaoTotalizacao.equalsIgnoreCase("gerenciaRegionalLocalidade")){
							// quebra a página por Localidade e mostra a
							// Gerência
							// Regional
							descGerenciaRegionalAnterior = "" + element[10];
							idGerenciaRegionalAnterior = "" + element[11];
							descLocalidadeAnterior = "" + element[12];
							idLocalidadeAnterior = "" + element[13];
						}else{
							// quebra a página por Localidade e não mostra a
							// Gerência
							// Regional
							descLocalidadeAnterior = "" + element[10];
							idLocalidadeAnterior = "" + element[11];
						}
					}

					if(agrupaPorUnidadeNegocio){
						descUnidadeNegocioAnterior = "" + element[10];
						idUnidadeNegocioAnterior = "" + element[11];

					}

					recebimentoTipo = tempRecebimentoTipo;
					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;

				}

				if(colecaoResumoArrecadacaoRelatorio != null && !colecaoResumoArrecadacaoRelatorio.isEmpty()){
					// adiciona a ultima linha
					ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
									(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
									(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
									(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
									idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
									descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, codigoSetorComercial, descricaoSetorComercial);

					retorno.add(resumoArrecadacaoRelatorioHelper);
				}

			}

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0339] - Consultar Dados Diarios da Arrecadacao
	 * [SB0006] - Apresentar Dados Diarios da Arrecadacao por Perfil
	 * Acumula os dados por Perfil de uma Colecao de Dados Diarios da
	 * Arrecadação
	 * 
	 * @author Fernanda Paiva
	 * @date 24/05/2006
	 * @throws ControladorException
	 */

	public void acumularDadosArrecadacao(Collection colecaoArrecadacaoDadosDiarios, ArrecadacaoDadosDiarios arrecadacaoDadosDiarios,
					int indicador, String idElo, String idGerencia, String idLocalidade){

		if(colecaoArrecadacaoDadosDiarios.isEmpty()){
			colecaoArrecadacaoDadosDiarios.add(arrecadacaoDadosDiarios);
		}else{

			Iterator iteratorColecaoArrecadacaoDadosDiarios = colecaoArrecadacaoDadosDiarios.iterator();

			// int indice = 0;
			// int indiceAAcumular = 0;
			boolean acumular = false;
			ArrecadacaoDadosDiarios arrecadacaoDadosDiariosSubstituir = null;

			// ArrecadacaoDadosDiarios arrecadacaoDadosDiarios2 = null;
			boolean achou = true;
			while(iteratorColecaoArrecadacaoDadosDiarios.hasNext() && achou){
				acumular = false;

				arrecadacaoDadosDiariosSubstituir = (ArrecadacaoDadosDiarios) iteratorColecaoArrecadacaoDadosDiarios.next();

				if(indicador == 1){
					// se a gerencia for igual
					if(arrecadacaoDadosDiarios.getGerenciaRegional().getId()
									.equals(arrecadacaoDadosDiariosSubstituir.getGerenciaRegional().getId())){
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if(indicador == 2){
					// se a arrecadador for igual
					if(arrecadacaoDadosDiarios.getArrecadador().getId().equals(arrecadacaoDadosDiariosSubstituir.getArrecadador().getId())){
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if(indicador == 3 && arrecadacaoDadosDiarios.getCategoria() != null
								&& arrecadacaoDadosDiariosSubstituir.getCategoria() != null){
					// se a categoria for igual
					if(arrecadacaoDadosDiarios.getCategoria().getId().equals(arrecadacaoDadosDiariosSubstituir.getCategoria().getId())){
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if(indicador == 4 && arrecadacaoDadosDiarios.getImovelPerfil() != null
								&& arrecadacaoDadosDiariosSubstituir.getImovelPerfil() != null){
					// se o Imovel Perfil for igual
					if(arrecadacaoDadosDiarios.getImovelPerfil().getId()
									.equals(arrecadacaoDadosDiariosSubstituir.getImovelPerfil().getId())){
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if(indicador == 5){
					// se o Documento for igual
					if(arrecadacaoDadosDiarios.getDocumentoTipo().getId()
									.equals(arrecadacaoDadosDiariosSubstituir.getDocumentoTipo().getId())){
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if(indicador == 6){
					// se o Elo for igual
					if(arrecadacaoDadosDiarios.getLocalidade().getId().equals(arrecadacaoDadosDiariosSubstituir.getLocalidade().getId())){
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}

				if(indicador == 7){
					// se a Concessionária for igual
					if(arrecadacaoDadosDiarios.getConcessionaria().getId()
									.equals(arrecadacaoDadosDiariosSubstituir.getConcessionaria().getId())){
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				// indice++;
			}// fim while

			// verfica se é para acumular
			if(acumular){

				arrecadacaoDadosDiariosSubstituir.setValorPagamentos(arrecadacaoDadosDiariosSubstituir.getValorPagamentos().add(
								arrecadacaoDadosDiarios.getValorPagamentos()));

				if(indicador == 5){
					arrecadacaoDadosDiariosSubstituir.setQuantidadePagamentos(arrecadacaoDadosDiariosSubstituir.getQuantidadePagamentos()
									+ arrecadacaoDadosDiarios.getQuantidadePagamentos());
				}

				// ((ArrayList) colecaoArrecadacaoDadosDiarios).set(
				// indiceAAcumular, arrecadacaoDadosDiariosSubstituir);

			}else{
				// se for diferente
				colecaoArrecadacaoDadosDiarios.add(arrecadacaoDadosDiarios);
			}
		}
	}

	/**
	 * Consulta a qtde de registros ResumoArrecadacao para a geração do
	 * relatório '[UC0345] Gerar Relatório de Resumo do Arrecadacao' de acordo
	 * com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 02/06/2006
	 * @param opcaoTotalizacao
	 * @param mesAnoReferencia
	 * @param gerenciaRegional
	 * @param localidade
	 * @return
	 * @throws ControladorException
	 */
	public Integer consultarQtdeRegistrosResumoArrecadacaoRelatorio(String opcaoTotalizacao, int mesAnoReferencia,
					Integer gerenciaRegional, Integer localidade, Integer idSetorComercial) throws ControladorException{

		Integer retorno = null;

		// Converter de mesAno para anoMes para que funcione na consulta
		int anoMesReferencia = Util.formatarMesAnoParaAnoMes(mesAnoReferencia);

		try{

			retorno = repositorioArrecadacao.consultarQtdeRegistrosResumoArrecadacaoRelatorio(anoMesReferencia, localidade,
							gerenciaRegional, opcaoTotalizacao, idSetorComercial);

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		if(retorno == null || retorno.intValue() == 0){

			throw new ControladorException("atencao.relatorio.vazio");
		}

		return retorno;
	}

	/**
	 * Metódo responsável por encerrar a arrecadação do mês.
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @author Pedro Alexandre
	 * @date 15/12/2006
	 * @param colecaoIdsLocalidades
	 * @throws ControladorException
	 */
	@Deprecated
	public void encerrarArrecadacaoMes(Collection<Integer> colecaoIdsLocalidades, int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.LOCALIDADE, ((Integer) Util.retonarObjetoDeColecao(colecaoIdsLocalidades)));

		try{



			// Pesquisa os lançamento de item contábil cadastrados no sistema
			// Collection colecaoDadosLancamentosItemContabil =
			// this.repositorioArrecadacao.pesquisarDadosLancamentosItemContabil();

			// Pesquisa a coleção de categorias no sistema
			// Collection<Integer> colecaoIdsCategorias =
			// this.repositorioArrecadacao.pesquisarIdsCategorias();

			// Cria a coleção que vai armazenar todos os resumos de arrecadação
			// gerados
			// Collection<ResumoArrecadacao> colecaoResumoArrecadacao = new ArrayList();

			// Cria as variaveis temporárias que serão utilizadas para gerar os
			// resumos da arrecadação
			// ResumoArrecadacao resumoArrecadacaoTemp = new ResumoArrecadacao();
			// RecebimentoTipo recebimentoTipoTemp = new RecebimentoTipo();
			// LancamentoTipo lancamentoTipoTemp = new LancamentoTipo();
			// LancamentoItem lancamentoItemTemp = new LancamentoItem();
			// Imovel imovel = null;
			// Object[] arrayDadosContaImpostosDeduzidos = null;
			// Object[] arrayDadosPagamento = null;
			// Object[] arrayDadosDevolucao = null;
			// BigDecimal valorDevolucao = null;
			// BigDecimal valorImposto = null;
			// BigDecimal valorPagamento = null;
			// BigDecimal valorExcedente = null;
			// Integer idImovel = null;

			// Cria as variáveis para acumular os valores para gerar o resumo da
			// arrecadação
			// Seqüêncial de Tipo de Lançamento 1100
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 1600
			// BigDecimal
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 2000
			// BigDecimal
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 2400
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 2500
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 2800
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 3200
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 3300
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 3400
			// BigDecimal diferencaEntreSequencialTipoIgual2500e3300 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 4500
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 5000
			// BigDecimal
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 5400
			// BigDecimal
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 5700
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 6100
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 6200
			// BigDecimal valorAcumuladoContasContabilizadasComoPerdas = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 6600
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = BigDecimal.ZERO;
			// // Seqüêncial de Tipo de Lançamento 7000
			// BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 = BigDecimal.ZERO;
			//
			// // Cria os maps que armazenaram para acada categoria o seu valor
			// // correspondente
			// // Seqüêncial de Tipo de Lançamento 1200
			// Map<Integer, BigDecimal> mapValorIRPagamentosClassificadosConta = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 1300
			// Map<Integer, BigDecimal> mapValorCSLLPagamentosClassificadosConta = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 1400
			// Map<Integer, BigDecimal> mapValorCOFINSPagamentosClassificadosConta = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 1500
			// Map<Integer, BigDecimal> mapValorPISPASEPPagamentosClassificadosConta = new
			// HashMap();
			// // Seqüêncial de Tipo de Lançamento 2100
			// Map<Integer, BigDecimal>
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 2200
			// Map<Integer, BigDecimal>
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 2300
			// Map<Integer, BigDecimal>
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere =
			// new HashMap();
			// // Seqüêncial de Tipo de Lançamento 2600
			// Map<Integer, BigDecimal> mapValorDevolucaoSituacaoAtualDevolucaoClassificada = new
			// HashMap();
			// // Seqüêncial de Tipo de Lançamento 2900
			// Map<Integer, BigDecimal>
			// mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado =
			// new HashMap();
			// // Seqüêncial de Tipo de Lançamento 3000
			// Map<Integer, BigDecimal>
			// mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada = new
			// HashMap();
			// // Seqüêncial de Tipo de Lançamento 3100
			// Map<Integer, BigDecimal> mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 4600
			// Map<Integer, BigDecimal>
			// mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 4700
			// Map<Integer, BigDecimal>
			// mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 4800
			// Map<Integer, BigDecimal>
			// mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes = new
			// HashMap();
			// // Seqüêncial de Tipo de Lançamento 4900
			// Map<Integer, BigDecimal>
			// mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes = new
			// HashMap();
			// // Seqüêncial de Tipo de Lançamento 5500
			// Map<Integer, BigDecimal>
			// mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 5800
			// Map<Integer, BigDecimal>
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 5900
			// Map<Integer, BigDecimal>
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 6000
			// Map<Integer, BigDecimal>
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 6200
			// Map<Integer, BigDecimal>
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores = new
			// HashMap();
			// // Seqüêncial de Tipo de Lançamento 6300
			// Map<Integer, BigDecimal>
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 6400
			// Map<Integer, BigDecimal>
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 6500
			// Map<Integer, BigDecimal>
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere =
			// new HashMap();
			// // Seqüêncial de Tipo de Lançamento 6700
			// Map<Integer, BigDecimal>
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 6800
			// Map<Integer, BigDecimal>
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// = new HashMap();
			// // Seqüêncial de Tipo de Lançamento 6900
			// Map<Integer, BigDecimal>
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere = new
			// HashMap();

			// Recupera os parâmetros do sistema
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// [FS0001] - Verificar existência de dados
			// Caso não exista dados no sistema de parâmetros levantauma exceção
			if(sistemaParametro == null){
				throw new ControladorException("atencao.entidade_sem_dados_para_selecao", null, "Sistema Parâmetro");
			}

			// Recupera o ano/mês da data atual
			Integer anoMesCorrente = Util.recuperaAnoMesDaData(new Date());

			// Recupera o ano/mês de referência da arrecadação dos parâmetros de
			// sistema
			Integer anoMesReferenciaArrecadacao = sistemaParametro.getAnoMesArrecadacao();

			// [FS0002 - Verificar ano/mês da data corrente maior que o ano/mês
			// de
			// arrecadação

			if(anoMesCorrente.intValue() <= anoMesReferenciaArrecadacao.intValue()){
				throw new ControladorException("atencao.arrecadacao.nao.pode.ser.fechada");
			}

			// Atualiza os pagamentos não classificados do mês.
			this.atualizaPagamentosNaoClassificadosMes(sistemaParametro);

			// fim

			// if(colecaoIdsLocalidades != null && !colecaoIdsLocalidades.isEmpty()){
			//
			// // Laço para gerar os resumos da arrecadação por localidade
			// for(Integer idLocalidade : colecaoIdsLocalidades){
			//
			// System.out.println("******* LOCALIDADE = " + idLocalidade + " ******");
			// // [FS0003] - Verificar a existência do resumo da
			// // arrecadação
			// Collection colecaoResumoArrecadacaoNaBase =
			// repositorioArrecadacao.pesquisarResumoArrecadacaoPorAnoMesArrecadacao(
			// anoMesReferenciaArrecadacao, idLocalidade);
			//
			// // Caso já exista dados do resumo da arrecadação para o
			// // ano/mês de
			// // referência da arrecadação
			// if(colecaoResumoArrecadacaoNaBase != null &&
			// !colecaoResumoArrecadacaoNaBase.isEmpty()){
			// throw new ControladorException("atencao.resumo.arrecadacao.ja.existe.dados");
			// }
			//
			// Localidade localidade = new Localidade();
			// localidade.setId(idLocalidade);
			//
			// Integer idGerenciaRegional =
			// this.getControladorLocalidade().pesquisarIdGerenciaParaLocalidade(idLocalidade);
			// GerenciaRegional gerenciaRegional = new GerenciaRegional();
			// gerenciaRegional.setId(idGerenciaRegional);
			//
			// // Seqüêncial de Tipo de Lançamento 2700
			// // Este map vai armazenar para cada item lançamento contábil
			// // um map
			// // para cada categoria um valor de devolução correspondente
			// Map<Integer, Map>
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil = new
			// HashMap();
			//
			// // Seqüêncial de Tipo de Lançamento 5600
			// // Este map vai armazenar para cada item lançamento contábil
			// // um map
			// // para cada categoria um valor de devolução correspondente
			// Map<Integer, Map>
			// mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil
			// = new HashMap();
			//
			// /*
			// * Essa parte vem antes do laço de categorias porque os
			// * items aqui não estão relacionados diretamente com a
			// * categoria. Os valores serão armazenados no map
			// * correspondente do item com a chave com o id de categoria
			// * e o valor correspondente, Depois esses valores serão
			// * recuperados para gerar o resumo da arrecadação
			// */
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1200 Para cada grupo de
			// * pagamentos classificados acumula o valor do imposto de
			// * renda pesquisando as contas impostos de duzidos e obtém
			// * as categorias do imóvel da conta relacionada e para cada
			// * categoria retornada obtém o valor por categoria.
			// */
			// Collection colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoIR =
			// repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosClassificadosContaPorTipoImposto(idLocalidade,
			// anoMesReferenciaArrecadacao, ImpostoTipo.IR);
			// if(colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoIR != null
			// && colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoIR.size() >
			// 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoIR){
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			//
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// System.out.println("SEQUENCIAL 1200");
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorIRPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorIRPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorIR = (BigDecimal) iteratorColecaoValorIRPorCategoria.next();
			//
			// if(!mapValorIRPagamentosClassificadosConta.containsKey(categoria.getId())){
			// mapValorIRPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorIRPagamentosClassificadosConta.put(categoria.getId(),
			// mapValorIRPagamentosClassificadosConta
			// .get(categoria.getId()).add(valorIR));
			// }
			// }else{
			// if(!mapValorIRPagamentosClassificadosConta.containsKey(Categoria.RESIDENCIAL)){
			// mapValorIRPagamentosClassificadosConta.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorIRPagamentosClassificadosConta.put(Categoria.RESIDENCIAL,
			// mapValorIRPagamentosClassificadosConta
			// .get(Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1300 Para cada grupo de
			// * pagamentos classificados acumula o valor da CSLL
			// * pesquisando as contas impostos de duzidos e obtém as
			// * categorias do imóvel da conta relacionada e para cada
			// * categoria retornada obtém o valor por categoria.
			// */
			// Collection colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoCSLL
			// = repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosClassificadosContaPorTipoImposto(idLocalidade,
			// anoMesReferenciaArrecadacao, ImpostoTipo.CSLL);
			//
			// if(colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoCSLL != null
			// && colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoCSLL.size() >
			// 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoCSLL){
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			//
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// System.out.println("SEQUENCIAL 1300");
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorCSLLPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorCSLLPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorCSLL = (BigDecimal) iteratorColecaoValorCSLLPorCategoria.next();
			//
			// if(!mapValorCSLLPagamentosClassificadosConta.containsKey(categoria.getId())){
			// mapValorCSLLPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorCSLLPagamentosClassificadosConta.put(categoria.getId(),
			// mapValorCSLLPagamentosClassificadosConta.get(categoria.getId()).add(valorCSLL));
			// }
			// }else{
			// if(!mapValorCSLLPagamentosClassificadosConta.containsKey(Categoria.RESIDENCIAL)){
			// mapValorCSLLPagamentosClassificadosConta.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorCSLLPagamentosClassificadosConta.put(Categoria.RESIDENCIAL,
			// mapValorCSLLPagamentosClassificadosConta.get(Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1400 Para cada grupo de
			// * pagamentos classificados acumula o valor da COFINS
			// * pesquisando as contas impostos de duzidos e obtém as
			// * categorias do imóvel da conta relacionada e para cada
			// * categoria retornada obtém o valor por categoria.
			// */
			// Collection
			// colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoCOFINS =
			// repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosClassificadosContaPorTipoImposto(idLocalidade,
			// anoMesReferenciaArrecadacao, ImpostoTipo.COFINS);
			// if(colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoCOFINS !=
			// null
			// && colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoCOFINS.size()
			// > 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoCOFINS){
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			//
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// System.out.println("SEQUENCIAL 1400");
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorCOFINSPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorCOFINSPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorCOFINS = (BigDecimal) iteratorColecaoValorCOFINSPorCategoria.next();
			//
			// if(!mapValorCOFINSPagamentosClassificadosConta.containsKey(categoria.getId())){
			// mapValorCOFINSPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorCOFINSPagamentosClassificadosConta.put(categoria.getId(),
			// mapValorCOFINSPagamentosClassificadosConta.get(categoria.getId()).add(valorCOFINS));
			// }
			// }else{
			// if(!mapValorCOFINSPagamentosClassificadosConta.containsKey(Categoria.RESIDENCIAL)){
			// mapValorCOFINSPagamentosClassificadosConta.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorCOFINSPagamentosClassificadosConta.put(Categoria.RESIDENCIAL,
			// mapValorCOFINSPagamentosClassificadosConta.get(Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1500 Para cada grupo de
			// * pagamentos classificados acumula o valor da PIS/PASEP
			// * pesquisando as contas impostos de duzidos e obtém as
			// * categorias do imóvel da conta relacionada e para cada
			// * categoria retornada obtém o valor por categoria.
			// */
			// Collection
			// colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoPIS_PASEP =
			// repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosClassificadosContaPorTipoImposto(idLocalidade,
			// anoMesReferenciaArrecadacao, ImpostoTipo.PIS_PASEP);
			// if(colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoPIS_PASEP !=
			// null
			// &&
			// colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoPIS_PASEP.size()
			// > 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosClassificadosContaImpostoTipoPIS_PASEP){
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			//
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// System.out.println("SEQUENCIAL 1500");
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorPISPASEPPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorPISPASEPPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorPISPASEP = (BigDecimal)
			// iteratorColecaoValorPISPASEPPorCategoria.next();
			//
			// if(!mapValorPISPASEPPagamentosClassificadosConta.containsKey(categoria.getId())){
			// mapValorPISPASEPPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPISPASEPPagamentosClassificadosConta.put(categoria.getId(),
			// mapValorPISPASEPPagamentosClassificadosConta.get(categoria.getId()).add(valorPISPASEP));
			// }
			// }else{
			// if(!mapValorPISPASEPPagamentosClassificadosConta.containsKey(Categoria.RESIDENCIAL)){
			// mapValorPISPASEPPagamentosClassificadosConta.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorPISPASEPPagamentosClassificadosConta.put(Categoria.RESIDENCIAL,
			// mapValorPISPASEPPagamentosClassificadosConta.get(Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2100 Para os pagamentos
			// * não classificados do mês com situação atual igual a
			// * pagamento em duplicidade acumula o valor do pagamento por
			// * categoria,e para os pagamentos não classificados com
			// * situação anterior igual a pagamento em duplicidade
			// * acumula o valor excedente do pagamento obtém as
			// * categorias do imóvel do pagamento relacionado e para cada
			// * categoria retornada obtém o valor por categoria.
			// */
			// Collection colecaoPagamentosNaoClassificadosSituacaoAtualPagmentoEmDuplicidade =
			// repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);
			// if(colecaoPagamentosNaoClassificadosSituacaoAtualPagmentoEmDuplicidade != null
			// && colecaoPagamentosNaoClassificadosSituacaoAtualPagmentoEmDuplicidade.size() > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosSituacaoAtualPagmentoEmDuplicidade){
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			//
			// valorPagamento = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// System.out.println("SEQUENCIAL 2100");
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualPagamentoEmDuplicidade
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorPagamento)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualPagamentoEmDuplicidade.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorPagamento = (BigDecimal)
			// iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualPagamentoEmDuplicidade
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(categoria
			// .getId(),
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .get(categoria.getId()).add(valorPagamento));
			// }
			//
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .get(Categoria.RESIDENCIAL).add(valorPagamento));
			// }
			// }
			// }
			//
			// Collection colecaoPagamentosNaoClassificadosSituacaoAnteriorPagmentoEmDuplicidade =
			// repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);
			//
			// if(colecaoPagamentosNaoClassificadosSituacaoAnteriorPagmentoEmDuplicidade != null
			// && colecaoPagamentosNaoClassificadosSituacaoAnteriorPagmentoEmDuplicidade.size() >
			// 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosSituacaoAnteriorPagmentoEmDuplicidade){
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			//
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// System.out.println("SEQUENCIAL 2100");
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorPagamentoEmDuplicidade =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// && iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorPagamentoEmDuplicidade
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorExcedente = (BigDecimal)
			// iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorPagamentoEmDuplicidade
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(categoria
			// .getId(),
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .get(categoria.getId()).add(valorExcedente));
			// }
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .get(Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2200 Para os pagamentos
			// * não classificados do mês com situação atual igual a
			// * documento inexistente acumula o valor do pagamento por
			// * categoria,e para os pagamentos não classificados com
			// * situação anterior igual a documento inexistente acumula o
			// * valor excedente do pagamento obtém as categorias do
			// * imóvel do pagamento relacionado e para cada categoria
			// * retornada obtém o valor por categoria.
			// */
			// Collection colecaoPagamentosNaoClassificadosSituacaoAtualDocumentoInexistente =
			// repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// PagamentoSituacao.DOCUMENTO_INEXISTENTE);
			//
			// if(colecaoPagamentosNaoClassificadosSituacaoAtualDocumentoInexistente != null
			// && colecaoPagamentosNaoClassificadosSituacaoAtualDocumentoInexistente.size() > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosSituacaoAtualDocumentoInexistente){
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			//
			// valorPagamento = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// System.out.println("SEQUENCIAL 2200");
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualDocumentoInexistente =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorPagamento)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualDocumentoInexistente.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorPagamento = (BigDecimal)
			// iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualDocumentoInexistente
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(categoria
			// .getId(),
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .get(categoria.getId()).add(valorPagamento));
			// }
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .get(Categoria.RESIDENCIAL).add(valorPagamento));
			// }
			// }
			// }
			//
			// Collection colecaoPagamentosNaoClassificadosSituacaoAnteriorDocumentoInexistente =
			// repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// PagamentoSituacao.DOCUMENTO_INEXISTENTE);
			//
			// if(colecaoPagamentosNaoClassificadosSituacaoAnteriorDocumentoInexistente != null
			// && colecaoPagamentosNaoClassificadosSituacaoAnteriorDocumentoInexistente.size() > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosSituacaoAnteriorDocumentoInexistente){
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			//
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// System.out.println("SEQUENCIAL 2200");
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorDocumentoInexistente =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorDocumentoInexistente.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorExcedente = (BigDecimal)
			// iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorDocumentoInexistente
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(categoria
			// .getId(),
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .get(categoria.getId()).add(valorExcedente));
			// }
			//
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .get(Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2300 Para os pagamentos
			// * não classificados do mês com situação atual igual a valor
			// * não confere acumula o valor do pagamento por categoria,e
			// * para os pagamentos não classificados com situação
			// * anterior igual a valor não confere acumula o valor
			// * excedente do pagamento obtém as categorias do imóvel do
			// * pagamento relacionado e para cada categoria retornada
			// * obtém o valor por categoria.
			// */
			// Collection colecaoPagamentosNaoClassificadosSituacaoAtualValorNaoConfere =
			// repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// PagamentoSituacao.VALOR_NAO_CONFERE);
			//
			// if(colecaoPagamentosNaoClassificadosSituacaoAtualValorNaoConfere != null
			// && colecaoPagamentosNaoClassificadosSituacaoAtualValorNaoConfere.size() > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosSituacaoAtualValorNaoConfere){
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			//
			// valorPagamento = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// System.out.println("SEQUENCIAL 2300");
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualValorNaoConfere =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorPagamento)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// && iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualValorNaoConfere.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorPagamento = (BigDecimal)
			// iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualValorNaoConfere
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(categoria
			// .getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(categoria
			// .getId(),
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.get(
			// categoria.getId()).add(valorPagamento));
			// }
			//
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.get(
			// Categoria.RESIDENCIAL).add(valorPagamento));
			// }
			// }
			// }
			//
			// Collection colecaoPagamentosNaoClassificadosSituacaoAnteriorValorNaoConfere =
			// repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// PagamentoSituacao.VALOR_NAO_CONFERE);
			//
			// if(colecaoPagamentosNaoClassificadosSituacaoAnteriorValorNaoConfere != null
			// && colecaoPagamentosNaoClassificadosSituacaoAnteriorValorNaoConfere.size() > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosSituacaoAnteriorValorNaoConfere){
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			//
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// System.out.println("SEQUENCIAL 2300");
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorValorNaoConfere =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorValorNaoConfere.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorExcedente = (BigDecimal)
			// iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorValorNaoConfere
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(categoria
			// .getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(categoria
			// .getId(),
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.get(
			// categoria.getId()).add(valorExcedente));
			// }
			//
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.get(
			// Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2600 Para asdevoluções
			// * classificadas com situação atual igual a devolução
			// * classificada acumula o valor da devolução por categoria,
			// * obtém as categorias do imóvel da devolução relacionada e
			// * para cada categoria retornada obtém o valor por
			// * categoria.
			// */
			// Collection colecaoDevolucoesClassificadasSituacaoAtualDevolucaoClassificada =
			// repositorioArrecadacao
			// .pesquisarDevolucoesClassificadasSituacaoAtualDevolucaoClassificada(anoMesReferenciaArrecadacao,
			// idLocalidade);
			//
			// if(colecaoDevolucoesClassificadasSituacaoAtualDevolucaoClassificada != null
			// && colecaoDevolucoesClassificadasSituacaoAtualDevolucaoClassificada.size() > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesClassificadasSituacaoAtualDevolucaoClassificada){
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			//
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// System.out.println("SEQUENCIAL 2600");
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoClassificada =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// && iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoClassificada.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoClassificada.next();
			//
			// if(!mapValorDevolucaoSituacaoAtualDevolucaoClassificada.containsKey(categoria.getId())){
			// mapValorDevolucaoSituacaoAtualDevolucaoClassificada.put(categoria.getId(),
			// BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoSituacaoAtualDevolucaoClassificada.put(categoria.getId(),
			// mapValorDevolucaoSituacaoAtualDevolucaoClassificada.get(categoria.getId()).add(
			// valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoSituacaoAtualDevolucaoClassificada.containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoSituacaoAtualDevolucaoClassificada.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorDevolucaoSituacaoAtualDevolucaoClassificada.put(Categoria.RESIDENCIAL,
			// mapValorDevolucaoSituacaoAtualDevolucaoClassificada.get(Categoria.RESIDENCIAL).add(
			// valorDevolucao));
			// }
			// }
			// }
			//
			// // Laço de lançamento de item contábil para armazenar num
			// // map os
			// // maps de categoria e valor
			// // para cada item contábil
			// for(Object dadosLancamentoItemContabil : colecaoDadosLancamentosItemContabil){
			// Object[] arrayDadosLancamentoItemContabil = (Object[]) dadosLancamentoItemContabil;
			// Integer idLancamentoItemContabil = (Integer) arrayDadosLancamentoItemContabil[0];
			//
			// System.out.println("LANCAMENTO ITEM CONTABIL " + idLancamentoItemContabil);
			//
			// // Cria o map que vai armazenar o valor da devolução por
			// // categria
			// Map<Integer, BigDecimal> mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores = new
			// HashMap();
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2700 Para as
			// * devoluções classificadas com situação atual igual a
			// * devolução de outros valores acumula o valor da
			// * devolução por categoria, obtém as categorias do
			// * imóvel da devolução relacionada e para cada categoria
			// * retornada obtém o valor por categoria.
			// */
			// Collection colecaoDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores =
			// repositorioArrecadacao
			// .pesquisarDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores(anoMesReferenciaArrecadacao,
			// idLocalidade, idLancamentoItemContabil);
			//
			// if(colecaoDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores != null
			// && colecaoDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores.size() > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores){
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			//
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// System.out.println("SEQUENCIAL 2700");
			// // [UC0108 - Obter Quantidade de Economias
			// // por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoOutrosValores =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// && iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoOutrosValores.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoOutrosValores
			// .next();
			//
			// if(!mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.containsKey(categoria.getId())){
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.put(categoria.getId(),
			// BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.put(categoria.getId(),
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.get(categoria.getId()).add(
			// valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.put(Categoria.RESIDENCIAL,
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.get(Categoria.RESIDENCIAL).add(
			// valorDevolucao));
			// }
			// }
			//
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil.put(idLancamentoItemContabil,
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5600 Para as
			// * devoluções efetuadas em meses anteriores
			// * classificadas no mês com situação atual igual a
			// * devolução de outros valores acumula o valor da
			// * devolução por categoria, obtém as categorias do
			// * imóvel da devolução relacionada e para cada categoria
			// * retornada obtém o valor por categoria.
			// */
			// // Cria o map para armazenar o valor por categoria da
			// // devolução
			// Map<Integer, BigDecimal>
			// mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores
			// = new HashMap();
			//
			// Collection
			// colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores
			// = repositorioArrecadacao
			// .pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores(
			// anoMesReferenciaArrecadacao, idLocalidade, idLancamentoItemContabil);
			//
			// if(colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores
			// != null
			// &&
			// colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores
			// .size() > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores){
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			//
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// System.out.println("SEQUENCIAL 5600");
			// // [UC0108 - Obter Quantidade de Economias
			// // por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoOutrosValores =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// && iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoOutrosValores.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoSituacaoAtualDevolucaoOutrosValores
			// .next();
			//
			// if(!mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores
			// .containsKey(categoria.getId())){
			// mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores
			// .put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores.put(
			// categoria.getId(),
			// mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores
			// .get(categoria.getId()).add(valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores.put(
			// Categoria.RESIDENCIAL,
			// mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores
			// .get(Categoria.RESIDENCIAL).add(valorDevolucao));
			// }
			// }
			//
			// mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil.put(
			// idLancamentoItemContabil,
			// mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2900 Para as devoluções
			// * não classificadas no mês com situação atual igual a
			// * pagamento em duplicidade não encontrado acumula o valor
			// * da devolução por categoria, obtém as categorias do imóvel
			// * da devolução relacionada e para cada categoria retornada
			// * obtém o valor por categoria.
			// */
			// Collection
			// colecaoDevolucoesNaoClassificadasMesSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// = repositorioArrecadacao
			// .pesquisarDevolucoesNaoClassificadasMesPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// DevolucaoSituacao.PAGAMENTO_DUPLICIDADE_NAO_ENCONTRADO);
			//
			// if(colecaoDevolucoesNaoClassificadasMesSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// != null
			// &&
			// colecaoDevolucoesNaoClassificadasMesSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.size()
			// > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesNaoClassificadasMesSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado){
			// System.out.println("SEQUENCIAL 2900");
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			//
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .next();
			//
			// if(!mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .containsKey(categoria.getId())){
			// mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(categoria
			// .getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(categoria.getId(),
			// mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(
			// categoria.getId()).add(valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(Categoria.RESIDENCIAL,
			// mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(
			// Categoria.RESIDENCIAL).add(valorDevolucao));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3000 Para as devoluções
			// * não classificadas no mês com situação atual igual a guia
			// * de devolução não informada acumula o valor da devolução
			// * por categoria, obtém as categorias do imóvel da devolução
			// * relacionada e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection colecaoDevolucoesNaoClassificadasMesSituacaoAtualGuiaDevolucaoNaoInformada
			// = repositorioArrecadacao
			// .pesquisarDevolucoesNaoClassificadasMesPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);
			//
			// if(colecaoDevolucoesNaoClassificadasMesSituacaoAtualGuiaDevolucaoNaoInformada != null
			// && colecaoDevolucoesNaoClassificadasMesSituacaoAtualGuiaDevolucaoNaoInformada.size()
			// > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesNaoClassificadasMesSituacaoAtualGuiaDevolucaoNaoInformada){
			// System.out.println("SEQUENCIAL 3000");
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			//
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// && iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada
			// .next();
			//
			// if(!mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.containsKey(categoria
			// .getId())){
			// mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria.getId(),
			// BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria.getId(),
			// mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.get(
			// categoria.getId()).add(valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.put(Categoria.RESIDENCIAL,
			// mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.get(
			// Categoria.RESIDENCIAL).add(valorDevolucao));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3100 Para as devoluções
			// * não classificadas no mês com situação atual igual a valor
			// * não confere acumula o valor da devolução por categoria,
			// * obtém as categorias do imóvel da devolução relacionada e
			// * para cada categoria retornada obtém o valor por
			// * categoria.
			// */
			// Collection colecaoDevolucoesNaoClassificadasMesSituacaoAtualValorNaoConfere =
			// repositorioArrecadacao
			// .pesquisarDevolucoesNaoClassificadasMesPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade,
			// DevolucaoSituacao.VALOR_NAO_CONFERE);
			//
			// if(colecaoDevolucoesNaoClassificadasMesSituacaoAtualValorNaoConfere != null
			// && colecaoDevolucoesNaoClassificadasMesSituacaoAtualValorNaoConfere.size() > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesNaoClassificadasMesSituacaoAtualValorNaoConfere){
			// System.out.println("SEQUENCIAL 3100");
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			//
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere =
			// (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere
			// .next();
			//
			// if(!mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.containsKey(categoria.getId())){
			// mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere
			// .put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.put(categoria.getId(),
			// mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.get(categoria.getId())
			// .add(valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere
			// .put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.put(Categoria.RESIDENCIAL,
			// mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.get(Categoria.RESIDENCIAL)
			// .add(valorDevolucao));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4600 Para cada grupo de
			// * pagamento de contas efetuadas em meses anteriores
			// * classificados no mês com tipo de impostoigual a IR
			// * acumula o valor do imposto por categoria, obtém as
			// * categorias do imóvel da conta imposto deduzido
			// * relacionada e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoIR
			// = repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(
			// idLocalidade, anoMesReferenciaArrecadacao, ImpostoTipo.IR);
			//
			// if(colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoIR
			// != null
			// &&
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoIR
			// .size() > 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoIR){
			// System.out.println("SEQUENCIAL 4600");
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorIRPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorIRPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorIR = (BigDecimal) iteratorColecaoValorIRPorCategoria.next();
			//
			// if(!mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(categoria.getId())){
			// mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// BigDecimal.ZERO);
			// }
			//
			// mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(categoria.getId()).add(valorIR));
			// }
			// }else{
			// if(!mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(Categoria.RESIDENCIAL)){
			// mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
			// mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4700 Para cada grupo de
			// * pagamento de contas efetuadas em meses anteriores
			// * classificados no mês com tipo de impostoigual a CSLL
			// * acumula o valor do imposto por categoria, obtém as
			// * categorias do imóvel da conta imposto deduzido
			// * relacionada e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCSLL
			// = repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(
			// idLocalidade, anoMesReferenciaArrecadacao, ImpostoTipo.CSLL);
			//
			// if(colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCSLL
			// != null
			// &&
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCSLL
			// .size() > 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCSLL){
			// System.out.println("SEQUENCIAL 4700");
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorCSLLPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorCSLLPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorCSLL = (BigDecimal) iteratorColecaoValorCSLLPorCategoria.next();
			//
			// if(!mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(categoria.getId())){
			// mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// BigDecimal.ZERO);
			// }
			//
			// mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(
			// categoria.getId()).add(valorCSLL));
			// }
			// }else{
			// if(!mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(Categoria.RESIDENCIAL)){
			// mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
			// mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(
			// Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4800 Para cada grupo de
			// * pagamento de contas efetuadas em meses anteriores
			// * classificados no mês com tipo de impostoigual a COFINS
			// * acumula o valor do imposto por categoria, obtém as
			// * categorias do imóvel da conta imposto deduzido
			// * relacionada e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCOFINS
			// = repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(
			// idLocalidade, anoMesReferenciaArrecadacao, ImpostoTipo.COFINS);
			//
			// if(colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCOFINS
			// != null
			// &&
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCOFINS
			// .size() > 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCOFINS){
			// System.out.println("SEQUENCIAL 4800");
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorCOFINSPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorCOFINSPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorCOFINS = (BigDecimal) iteratorColecaoValorCOFINSPorCategoria.next();
			//
			// if(!mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .containsKey(categoria.getId())){
			// mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// BigDecimal.ZERO);
			// }
			//
			// mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(
			// categoria.getId()).add(valorCOFINS));
			// }
			// }else{
			// if(!mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
			// mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(
			// Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4900 Para cada grupo de
			// * pagamento de contas efetuadas em meses anteriores
			// * classificados no mês com tipo de impostoigual a PIS/PASEP
			// * acumula o valor do imposto por categoria, obtém as
			// * categorias do imóvel da conta imposto deduzido
			// * relacionada e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoPIS_PASEP
			// = repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(
			// idLocalidade, anoMesReferenciaArrecadacao, ImpostoTipo.PIS_PASEP);
			//
			// if(colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoPIS_PASEP
			// != null
			// &&
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoPIS_PASEP
			// .size() > 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoPIS_PASEP){
			// System.out.println("SEQUENCIAL 4900");
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorPISPASEPPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorPISPASEPPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorPISPASEP = (BigDecimal)
			// iteratorColecaoValorPISPASEPPorCategoria.next();
			//
			// if(!mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(categoria
			// .getId())){
			// mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// BigDecimal.ZERO);
			// }
			//
			// mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(
			// categoria.getId()).add(valorPISPASEP));
			// }
			// }else{
			// if(!mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
			// mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(
			// Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5500 Para as devoluções
			// * efetuadas em meses anteriores classificados no mês com
			// * situação da devolução atual igual a devolução
			// * classificada acumula o valor da devolução por categoria,
			// * obtém as categorias do imóvel da devolução relacionada e
			// * para cada categoria retornada obtém o valor por
			// * categoria.
			// */
			// Collection
			// colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// = repositorioArrecadacao
			// .pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada(
			// anoMesReferenciaArrecadacao, idLocalidade);
			//
			// if(colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// != null
			// &&
			// colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .size() > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada){
			// System.out.println("SEQUENCIAL 5500");
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			//
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// System.out.println("IMOVEL -> " + idImovel);
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorDevolucaoEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorDevolucaoEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .next();
			//
			// if(!mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .containsKey(categoria.getId())){
			// mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.put(
			// categoria.getId(),
			// mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .get(categoria.getId()).add(valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.put(
			// Categoria.RESIDENCIAL,
			// mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .get(Categoria.RESIDENCIAL).add(valorDevolucao));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5800 Para os pagamentos
			// * não classificados com baixa comandada com situação
			// * anterior igual a pagamento em duplicidade acumula o valor
			// * excedente do pagamento por categoria, obtém as categorias
			// * do imóvel do pagamento relacionado e para cada categoria
			// * retornada obtém o valor por categoria.
			// */
			// Collection
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// = repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade,
			// anoMesReferenciaArrecadacao, PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);
			//
			// if(colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// != null
			// &&
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.size()
			// > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade){
			// System.out.println("SEQUENCIAL 5800");
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorExcedentePorCategoria = (BigDecimal)
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .next();
			//
			// if(!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .containsKey(categoria.getId())){
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(
			// categoria.getId(),
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .get(categoria.getId()).add(valorExcedentePorCategoria));
			// }
			//
			// }else{
			// if(!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(
			// Categoria.RESIDENCIAL,
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .get(Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5900 Para os pagamentos
			// * não classificados com baixa comandada com situação
			// * anterior igual a documento inexistente acumula o valor
			// * excedente do pagamento por categoria, obtém as categorias
			// * do imóvel do pagamento relacionado e para cada categoria
			// * retornada obtém o valor por categoria.
			// */
			// Collection
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// = repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade,
			// anoMesReferenciaArrecadacao, PagamentoSituacao.DOCUMENTO_INEXISTENTE);
			//
			// if(colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// != null
			// &&
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.size()
			// > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente){
			// System.out.println("SEQUENCIAL 5900");
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorExcedentePorCategoria = (BigDecimal)
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .next();
			//
			// if(!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .containsKey(categoria.getId())){
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.put(
			// categoria.getId(),
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .get(categoria.getId()).add(valorExcedentePorCategoria));
			// }
			//
			// }else{
			// if(!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.put(
			// Categoria.RESIDENCIAL,
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .get(Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6000 Para os pagamentos
			// * não classificados com baixa comandada com situação
			// * anterior igual a valor não confere acumula o valor
			// * excedente do pagamento por categoria, obtém as categorias
			// * do imóvel do pagamento relacionado e para cada categoria
			// * retornada obtém o valor por categoria.
			// */
			// Collection
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere =
			// repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade,
			// anoMesReferenciaArrecadacao, PagamentoSituacao.VALOR_NAO_CONFERE);
			//
			// if(colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// != null
			// &&
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.size()
			// > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere){
			// System.out.println("SEQUENCIAL 6000");
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorExcedentePorCategoria = (BigDecimal)
			// iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .next();
			//
			// if(!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .containsKey(categoria.getId())){
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(
			// categoria.getId(),
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .get(categoria.getId()).add(valorExcedentePorCategoria));
			// }
			//
			// }else{
			// if(!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(
			// Categoria.RESIDENCIAL,
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .get(Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6200 Para cada grupo de
			// * pagamentos classificados no mês e meses anterioeres
			// * acumula o valor dos impostos para as contas já
			// * contabilizadas como perdas pesquisando as contas impostos
			// * duzidos, e obtém as categorias do imóvel da conta
			// * relacionada e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP
			// = repositorioArrecadacao
			// .pesquisarContasImpostosDeduzidosPagamentosClassificadosNoMesMesesAnterioresContaContabilizadasComoPerdasImpostoTipoIRCSLLCOFINSPISPASEP(
			// idLocalidade, anoMesReferenciaArrecadacao);
			//
			// if(colecaoContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP
			// != null
			// &&
			// colecaoContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP
			// .size() > 0){
			// for(Object dadosContaImpostosDeduzidos :
			// colecaoContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP){
			// System.out.println("SEQUENCIAL 6200");
			//
			// arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
			// valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
			// idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator iteratorColecaoValorImpostoPorCategoria =
			// (getControladorImovel().obterValorPorCategoria(
			// colecaoCategoriasImovel, valorImposto)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext() &&
			// iteratorColecaoValorImpostoPorCategoria.hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorImposto = (BigDecimal) iteratorColecaoValorImpostoPorCategoria.next();
			//
			// if(!mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.containsKey(categoria
			// .getId())){
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(categoria.getId(),
			// BigDecimal.ZERO);
			// }
			//
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(categoria.getId(),
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.get(
			// categoria.getId()).add(valorImposto));
			// }
			// }else{
			// if(!mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(Categoria.RESIDENCIAL,
			// BigDecimal.ZERO);
			// }
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(Categoria.RESIDENCIAL,
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.get(
			// Categoria.RESIDENCIAL).add(valorImposto));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6300 Para os pagamentos
			// * não classificados com situação atual igual a pagamento em
			// * duplicidade acumula o valor excedente do pagamento por
			// * categoria, obtém as categorias do imóvel do pagamento
			// * relacionado e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// = repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade, PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);
			//
			// if(colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// != null
			// &&
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.size()
			// > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade){
			// System.out.println("SEQUENCIAL 6300");
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualPagamentoEmDuplicidade
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualPagamentoEmDuplicidade
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorExcedentePagamento = (BigDecimal)
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualPagamentoEmDuplicidade
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(categoria
			// .getId(),
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// .get(categoria.getId()).add(valorExcedentePagamento));
			// }
			//
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// .get(Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6400 Para os pagamentos
			// * não classificados com situação atual igual a documento
			// * inexistente acumula o valor excedente do pagamento por
			// * categoria, obtém as categorias do imóvel do pagamento
			// * relacionado e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistente
			// = repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE);
			//
			// if(colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistente
			// != null
			// &&
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistente.size()
			// > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistente){
			//
			// System.out.println("SEQUENCIAL 6400");
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// System.out.println("IMOVEL -> " + idImovel);
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorExcedentePagamento = (BigDecimal)
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.put(categoria
			// .getId(),
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente
			// .get(categoria.getId()).add(valorExcedentePagamento));
			// }
			//
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.get(
			// Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6500 Para os pagamentos
			// * não classificados com situação atual igual a valor não
			// * confere acumula o valor excedente do pagamento por
			// * categoria, obtém as categorias do imóvel do pagamento
			// * relacionado e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualValorNaoConfere =
			// repositorioArrecadacao
			// .pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade, PagamentoSituacao.VALOR_NAO_CONFERE);
			//
			// if(colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// != null
			// &&
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualValorNaoConfere.size()
			// > 0){
			// for(Object dadosPagamento :
			// colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualValorNaoConfere){
			// System.out.println("SEQUENCIAL 6500");
			//
			// arrayDadosPagamento = (Object[]) dadosPagamento;
			// valorExcedente = (BigDecimal) arrayDadosPagamento[0];
			// idImovel = (Integer) arrayDadosPagamento[1];
			// valorPagamento = (BigDecimal) arrayDadosPagamento[2];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// /**
			// * Caso o valor excedente esteja nulo o valor
			// * excedente vai ser o valor do pagamento
			// */
			// if(valorExcedente == null){
			// valorExcedente = valorPagamento;
			// }
			//
			// if(idImovel != null){
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// BigDecimal valorExcedentePagamento = (BigDecimal)
			// iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente
			// .next();
			//
			// if(!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// .containsKey(categoria.getId())){
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria
			// .getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(
			// categoria.getId(),
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(
			// categoria.getId()).add(valorExcedentePagamento));
			// }
			//
			// }else{
			// if(!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			//
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(
			// Categoria.RESIDENCIAL,
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(
			// Categoria.RESIDENCIAL).add(valorExcedente));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6700 Para as devoluções
			// * não classificadas com situação atual igual a pagamento em
			// * duplicidade não confere acumula o valor da devolução por
			// * categoria, obtém as categorias do imóvel da devolução
			// * relacionada e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// = repositorioArrecadacao
			// .pesquisarDevolucoesNaoClassificadasMesEAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade, DevolucaoSituacao.PAGAMENTO_DUPLICIDADE_NAO_ENCONTRADO);
			//
			// if(colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// != null
			// &&
			// colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .size() > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado){
			// System.out.println("SEQUENCIAL 6700");
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .next();
			//
			// if(!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .containsKey(categoria.getId())){
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .put(categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .put(categoria.getId(),
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .get(categoria.getId()).add(valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(
			// Categoria.RESIDENCIAL,
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .get(Categoria.RESIDENCIAL).add(valorDevolucao));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6800 Para as devoluções
			// * não classificadas com situação atual igual a guia de
			// * devolução não informada acumula o valor da devolução por
			// * categoria, obtém as categorias do imóvel da devolução
			// * relacionada e para cada categoria retornada obtém o valor
			// * por categoria.
			// */
			// Collection
			// colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// = repositorioArrecadacao
			// .pesquisarDevolucoesNaoClassificadasMesEAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade, DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);
			//
			// if(colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// != null
			// &&
			// colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.size()
			// > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada){
			//
			// System.out.println("SEQUENCIAL 6800");
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			//
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .next();
			//
			// if(!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .containsKey(categoria.getId())){
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(
			// categoria.getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria
			// .getId(),
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .get(categoria.getId()).add(valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(
			// Categoria.RESIDENCIAL,
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .get(Categoria.RESIDENCIAL).add(valorDevolucao));
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6900 Para as devoluções
			// * não classificadas com situação atual igual a valor não
			// * confere acumula o valor da devolução por categoria, obtém
			// * as categorias do imóvel da devolução relacionada e para
			// * cada categoria retornada obtém o valor por categoria.
			// */
			// Collection
			// colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualValorNaoConfere =
			// repositorioArrecadacao
			// .pesquisarDevolucoesNaoClassificadasMesEAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao,
			// idLocalidade, DevolucaoSituacao.VALOR_NAO_CONFERE);
			//
			// if(colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualValorNaoConfere !=
			// null
			// && colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualValorNaoConfere.size()
			// > 0){
			// for(Object dadosDevolucao :
			// colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualValorNaoConfere){
			//
			// System.out.println("SEQUENCIAL 6900");
			//
			// arrayDadosDevolucao = (Object[]) dadosDevolucao;
			// valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
			// idImovel = (Integer) arrayDadosDevolucao[1];
			// imovel = new Imovel();
			// imovel.setId(idImovel);
			//
			// if(idImovel != null){
			// // [UC0108 - Obter Quantidade de Economias por
			// // Categoria]
			// Collection colecaoCategoriasImovel =
			// getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			// Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
			//
			// // [UC0185 - Obter Valor por Categoria]
			// Iterator
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualValorNaoConfere
			// = (getControladorImovel()
			// .obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();
			//
			// while(iteratorColecaoCategoriasImovel.hasNext()
			// &&
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualValorNaoConfere
			// .hasNext()){
			// Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
			//
			// valorDevolucao = (BigDecimal)
			// iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualValorNaoConfere
			// .next();
			//
			// if(!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// .containsKey(categoria.getId())){
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria
			// .getId(), BigDecimal.ZERO);
			// }
			//
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria.getId(),
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(
			// categoria.getId()).add(valorDevolucao));
			// }
			//
			// }else{
			// if(!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// .containsKey(Categoria.RESIDENCIAL)){
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(
			// Categoria.RESIDENCIAL, BigDecimal.ZERO);
			// }
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(Categoria.RESIDENCIAL,
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(
			// Categoria.RESIDENCIAL).add(valorDevolucao));
			// }
			// }
			// }
			//
			// // Laço para gerar os resumos da arrecadação por categoria
			// for(Integer idCategoria : colecaoIdsCategorias){
			//
			// Categoria categoria = new Categoria();
			// categoria.setId(idCategoria);
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 100 Para os
			// * pagamento classificados de conta acumula o valor de
			// * água por categoria e gera o resumo da arrecadação
			// * caso o valor acumulado seja maior que 0(zero)
			// */
			// BigDecimal somaValorAguaPagamentosClassificadosContas = repositorioArrecadacao
			// .acumularValorAguaPagamentosClassificadosConta(idLocalidade,
			// anoMesReferenciaArrecadacao,
			// idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorAguaPagamentosClassificadosContas != null
			// && somaValorAguaPagamentosClassificadosContas.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 100");
			// // Acumula o sequêncial do tipo de lançamento igual
			// // a 100
			// // para io item 16
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .add(somaValorAguaPagamentosClassificadosContas);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			//
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.AGUA);
			//
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("100"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorAguaPagamentosClassificadosContas);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			//
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 200 Para os
			// * pagamento classificados de conta acumula o valor de
			// * esgoto por categoria e gera o resumo da arrecadação
			// * caso o valor acumulado seja maior que 0(zero)
			// */
			// BigDecimal somaValorEsgotoPagamentosClassificadosContas = repositorioArrecadacao
			// .acumularValorEsgotoPagamentosClassificadosConta(idLocalidade,
			// anoMesReferenciaArrecadacao,
			// idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorEsgotoPagamentosClassificadosContas != null
			// && somaValorEsgotoPagamentosClassificadosContas.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 200");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .add(somaValorEsgotoPagamentosClassificadosContas);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.ESGOTO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("200"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorEsgotoPagamentosClassificadosContas);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 400 Para os
			// * pagamento classificados de conta acumula o valor dos
			// * débitos cobrados por categoria para o tipo de
			// * financiamneto igual a parcelamento água e gera o
			// * resumo da arrecadação caso o valor acumulado seja
			// * maior que 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua =
			// repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria, FinanciamentoTipo.PARCELAMENTO_AGUA);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 400");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.AGUA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("400"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 500 Para os
			// * pagamento classificados de conta acumula o valor dos
			// * débitos cobrados por categoria para o tipo de
			// * financiamneto igual a parcelamento esgoto e gera o
			// * resumo da arrecadação caso o valor acumulado seja
			// * maior que 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria, FinanciamentoTipo.PARCELAMENTO_ESGOTO);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 500");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.ESGOTO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("500"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 700 Para os
			// * pagamento classificados de conta acumula o valor dos
			// * débitos cobrados por categoria para o tipo de
			// * financiamneto igual a parcelamento de serviço e grupo
			// * de parcelamento igual a juros cobrados e gera o
			// * resumo da arrecadação caso o valor acumulado seja
			// * maior que 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 700");
			// // Seqüêncial de Tipo de Lançamento 16
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.JUROS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("700"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 800 Para os
			// * pagamento classificados de conta acumula o valor dos
			// * créditos realizados por categoria para a origem do
			// * crédito igual a contas pagas em duplicidade/excesso e
			// * gera o resumo da arrecadação caso o valor acumulado
			// * seja maior que 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria,
			// CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 800");
			// // Seqüêncial de Tipo de Lançamento 1100
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099
			// .add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("800"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1000 Para os
			// * pagamento classificados de conta acumula o valor dos
			// * créditos realizados por categoria para a origem do
			// * crédito igual a descontos concedidos e gera o resumo
			// * da arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria,
			// CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento
			// .doubleValue() > 0.00){
			//
			// System.out.println("SEQUENCIAL 1000");
			//
			// // Seqüêncial de Tipo de Lançamento 1100
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099
			// .add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CONCEDIDOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1000"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1010 Para os
			// * pagamento classificados de conta acumula o valor dos
			// * créditos realizados por categoria para a origem do
			// * crédito igual a descontos condicionais e gera o
			// * resumo da arrecadação caso o valor acumulado seja
			// * maior que 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.DESCONTOS_CONDICIONAIS);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais
			// .doubleValue() > 0.00){
			//
			// System.out.println("SEQUENCIAL 1010");
			//
			// // Seqüêncial de Tipo de Lançamento 1100
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099
			// .add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1010"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1020 Para os
			// * pagamento classificados de conta acumula o valor dos
			// * créditos realizados por categoria para a origem do
			// * crédito igual a descontos incondicionais e gera o
			// * resumo da arrecadação caso o valor acumulado seja
			// * maior que 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.DESCONTOS_INCONDICIONAIS);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais
			// .doubleValue() > 0.00){
			//
			// System.out.println("SEQUENCIAL 1020");
			//
			// // Seqüêncial de Tipo de Lançamento 1100
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099
			// .add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1020"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1030 Para os
			// * pagamento classificados de conta acumula o valor dos
			// * créditos realizados por categoria para a origem do
			// * crédito igual a ajustes para zerar conta e gera o
			// * resumo da arrecadação caso o valor acumulado seja
			// * maior que 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta
			// .doubleValue() > 0.00){
			//
			// System.out.println("SEQUENCIAL 1030");
			//
			// // Seqüêncial de Tipo de Lançamento 1100
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099
			// .add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1030"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1700 Para os
			// * pagamento classificados de guias de pagamento acumula
			// * o valor das entradas do parcelamento por categoria
			// * para tipo de financiamento igual a entrada de
			// * parcelamento e gera o resumo da arrecadação caso o
			// * valor acumulado seja maior que 0(zero)
			// */
			// BigDecimal somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento =
			// repositorioArrecadacao
			// .acumularValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoEntradaParcelamento(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento != null
			// && somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento.doubleValue() >
			// 0.00){
			// System.out.println("SEQUENCIAL 1700");
			// // Seqüêncial de Tipo de Lançamento 2000
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// .add(somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
			// lancamentoItemTemp.setId(LancamentoItem.ENTRADAS_PARCELAMENTO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1700"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3500 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor de água por
			// * categoria e gera o resumo da arrecadação caso o valor
			// * acumulado seja maior que 0(zero)
			// */
			// BigDecimal somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes
			// = repositorioArrecadacao
			// .acumularValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes != null
			// &&
			// somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes.doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 3500");
			//
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .add(somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.AGUA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3500"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3600 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor de esgoto por
			// * categoria e gera o resumo da arrecadação caso o valor
			// * acumulado seja maior que 0(zero)
			// */
			// BigDecimal
			// somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes =
			// repositorioArrecadacao
			// .acumularValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes !=
			// null
			// &&
			// somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes.doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 3600");
			//
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .add(somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.ESGOTO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3600"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3800 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor dos débitos
			// * cobrados por categoria para tipo de financiamento
			// * igual a parcelamento de água e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// FinanciamentoTipo.PARCELAMENTO_AGUA);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 3800");
			//
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.AGUA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3800"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3900 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor dos débitos
			// * cobrados por categoria para tipo de financiamento
			// * igual a parcelamento de esgoto e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// FinanciamentoTipo.PARCELAMENTO_ESGOTO);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 3900");
			//
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.ESGOTO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3900"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4100 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor dos débitos
			// * cobrados por categoria para tipo de financiamento
			// * igual a parcelamento de serviços e grupo de
			// * parcelamento igual a juros cobrados e gera o resumo
			// * da arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4100");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.JUROS_COBRADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4100"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4200 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor dos créditos
			// * realizados por categoria para origem do crédito igual
			// * a documentos pagos em duplicidade/excesso e gera o
			// * resumo da arrecadação caso o valor acumulado seja
			// * maior que 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4200");
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 =
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
			// .add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4200"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4400 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor dos créditos
			// * realizados por categoria para origem do crédito igual
			// * a descontos concedidos e gera o resumo da arrecadação
			// * caso o valor acumulado seja maior que 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4400");
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 =
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
			// .add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CONCEDIDOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4400"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4410 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor dos créditos
			// * realizados por categoria para origem do crédito igual
			// * a descontos condicionais e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// CreditoOrigem.DESCONTOS_CONDICIONAIS);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4410");
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 =
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
			// .add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4410"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4420 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor dos créditos
			// * realizados por categoria para origem do crédito igual
			// * a descontos incondicionais e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// CreditoOrigem.DESCONTOS_INCONDICIONAIS);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4420");
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 =
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
			// .add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4420"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4430 Para os
			// * pagamentos de contas efetuados em meses anteriores
			// * classificados no mês acumula o valor dos créditos
			// * realizados por categoria para origem do crédito igual
			// * a ajustes para zerar conta e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4430");
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 =
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
			// .add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4430"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5100 Para os
			// * pagamentos de guias de pagamento efetuadas em meses
			// * anteriores classificados no mês acumula o valor das
			// * entradas dos parcelamento por categoria com tipo de
			// * financiamento igual a entrada de parcelamento e gera
			// * o resumo da arrecadação caso o valor acumulado seja
			// * maior que 0(zero)
			// */
			// BigDecimal
			// somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento
			// = repositorioArrecadacao
			// .acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento
			// != null
			// &&
			// somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 5100");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
			// lancamentoItemTemp.setId(LancamentoItem.ENTRADAS_PARCELAMENTO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5100"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// // Laço para gerar os resumos por lançamento de item
			// // contábil
			// for(Object dadosLancamentoItemContabil : colecaoDadosLancamentosItemContabil){
			//
			// Object[] arrayDadosLancamentoItemContabil = (Object[]) dadosLancamentoItemContabil;
			// Integer idLancamentoItemContabil = (Integer) arrayDadosLancamentoItemContabil[0];
			// Short sequencialImpressao = (Short) arrayDadosLancamentoItemContabil[1];
			//
			// System.out.println("LANCAMENTO ITEM CONTABIL " + idLancamentoItemContabil);
			// LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
			// lancamentoItemContabil.setId(idLancamentoItemContabil);
			// lancamentoItemContabil.setSequenciaImpressao(sequencialImpressao);
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 300 Para os
			// * pagamento classificados de conta acumula o valor
			// * dos débitos cobrados por categoria para tipo de
			// * financiamento igual a serviço e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			//
			// Collection<Integer> colecaoIdsTipoFinanciamentoSequencial300E3700 = new ArrayList();
			// colecaoIdsTipoFinanciamentoSequencial300E3700.add(FinanciamentoTipo.SERVICO_NORMAL);
			// colecaoIdsTipoFinanciamentoSequencial300E3700.add(FinanciamentoTipo.ARRASTO_AGUA);
			// colecaoIdsTipoFinanciamentoSequencial300E3700.add(FinanciamentoTipo.ARRASTO_ESGOTO);
			// colecaoIdsTipoFinanciamentoSequencial300E3700.add(FinanciamentoTipo.ARRASTO_SERVICO);
			//
			// BigDecimal somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade,
			// anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria,
			// colecaoIdsTipoFinanciamentoSequencial300E3700);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico != null
			// &&
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico.doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 300");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.FINANCIAMENTOS_COBRADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("300"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 600 Para os
			// * pagamento classificados de conta acumula o valor
			// * dos débitos cobrados por categoria para tipo de
			// * financiamento igual a parcelamento de serviço e
			// * grupo de parrcelamento igual a juros cobrados e
			// * gera o resumo da arrecadação caso o valor
			// * acumulado seja maior que 0(zero)
			// */
			//
			// Collection<Integer> colecaoIdsTipoFinanciamentoSequencial600E4000 = new ArrayList();
			// colecaoIdsTipoFinanciamentoSequencial600E4000.add(FinanciamentoTipo.PARCELAMENTO_SERVICO);
			//
			// BigDecimal
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade,
			// anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria,
			// colecaoIdsTipoFinanciamentoSequencial600E4000);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 600");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.FINANCIAMENTOS_COBRADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("600"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 900 Para os
			// * pagamento classificados de conta acumula o valor
			// * dos créditos realizados por categoria para origem
			// * de crédito igual a valores cobrados indevidamente
			// * e gera o resumo da arrecadação caso o valor
			// * acumulado seja maior que 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// idLancamentoItemContabil);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 900");
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099
			// .add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.VALORES_COBRADOS_INDEVIDAMENTE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("900"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1550 Para os
			// * pagamento classificados de conta acumula o valor
			// * dos débitos cobrados por categoria para tipo de
			// * financiamento igual a doações gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes(idLocalidade,
			// anoMesReferenciaArrecadacao, idCategoria, idLancamentoItemContabil);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes != null
			// &&
			// somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes.doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 1550");
			// // Seqüêncial de Tipo de Lançamento 1600
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.DOACOES_RECEBIDAS_EM_CONTA);
			// lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1550"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1800 Para os
			// * pagamento classificados de guias de pagamento
			// * acumula o valor das guias de pagamento por
			// * categoria com tipo de financiamento igual a
			// * serviço e gera o resumo da arrecadação caso o
			// * valor acumulado seja maior que 0(zero)
			// */
			// BigDecimal
			// somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico
			// = repositorioArrecadacao
			// .acumularValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico(
			// idLocalidade, anoMesReferenciaArrecadacao, idLancamentoItemContabil,
			// idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico
			// != null
			// &&
			// somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 1800");
			// // Seqüêncial de Tipo de Lançamento 2000
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// .add(somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
			// lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1800"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1900 Para os
			// * pagamento classificados de débitos a cobrar
			// * acumula o valor que falta ser cobrado por
			// * categoria dodébito a cobrar e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero) Esta pesquisa já retorna o valor que
			// * falta ser cobrado
			// */
			// BigDecimal somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar =
			// repositorioArrecadacao
			// .acumularValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar(idLocalidade,
			// anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar != null
			// && somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar.doubleValue() >
			// 0.00){
			// System.out.println("SEQUENCIAL 1900");
			// // Seqüêncial de Tipo de Lançamento 2000
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// .add(somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.DEBITOS_A_COBRAR);
			// lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1900"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2700 Para as
			// * devoluções classificadas acumula o valor da
			// * devolução por categoria com situação atual igual
			// * a devolução de outros valores e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			//
			// if(mapValorDevolucaoSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil
			// .containsKey(idLancamentoItemContabil)){
			// System.out.println("SEQUENCIAL 2700");
			// Map<Integer, BigDecimal> mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores =
			// mapValorDevolucaoSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil
			// .get(idLancamentoItemContabil);
			//
			// if(mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.get(idCategoria).doubleValue()
			// > 0.00){
			//
			// // Seqüêncial de Tipo de Lançamento 2800
			// valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 =
			// valorAcumuladoSequenciaTipoLancamentoEntre2600e2799
			// .add(mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE);
			// lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2700"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5600 Para as
			// * devoluções efetuadas em meses anteriores
			// * classificadas no mês acumula o valor da devolução
			// * por categoria com situação atual igual a
			// * devolução de outros valores e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// if(mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil
			// .containsKey(idLancamentoItemContabil)){
			// System.out.println("SEQUENCIAL 5600");
			// Map<Integer, BigDecimal>
			// mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores =
			// mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil
			// .get(idLancamentoItemContabil);
			//
			// if(mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores.containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores.get(idCategoria)
			// .doubleValue() > 0.00){
			//
			// // Seqüêncial de Tipo de Lançamento 5700
			// valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 =
			// valorAcumuladoSequenciaTipoLancamentoEntre5500e5699
			// .add(mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp
			// .setId(RecebimentoTipo.DEVOLUCOES_RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE);
			// lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5600"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3700 Para os
			// * pagamentos em conta efetuados em meses anteriores
			// * classificados no mês acumula o valor dos débitos
			// * cobrados por categoria para tipo de financiamento
			// * igual a serviço e gera o resumo da arrecadação
			// * caso o valor acumulado seja maior que 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(
			// idLocalidade, anoMesReferenciaArrecadacao, idLancamentoItemContabil,
			// idCategoria, colecaoIdsTipoFinanciamentoSequencial300E3700);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 3700");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.FINANCIAMENTOS_COBRADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3700"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4000 Para os
			// * pagamentos de contas efetuados em meses
			// * anteriores classificados no mês acumula o valor
			// * dos débitos cobrados por categoria e item
			// * contábil para tipo de financiamento igual a
			// * parcelamento de serviços e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(
			// idLocalidade, anoMesReferenciaArrecadacao, idLancamentoItemContabil,
			// idCategoria, colecaoIdsTipoFinanciamentoSequencial600E4000);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4000");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.FINANCIAMENTOS_COBRADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4000"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4950 Para os
			// * pagamentos de contas efetuados em meses
			// * anteriores classificados no mês acumula o valor
			// * dos débitos cobrados por categoria e item
			// * contábil para tipo de financiamento igual doações
			// * e gera o resumo da arrecadação caso o valor
			// * acumulado seja maior que 0(zero)
			// */
			// BigDecimal
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes
			// = repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// idLancamentoItemContabil);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes
			// != null
			// &&
			// somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4950");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.DOACOES_RECEBIDAS_EM_CONTA);
			// lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4950"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4300 Para os
			// * pagamentos de contas efetuados em meses
			// * anteriores classificados no mês acumula o valor
			// * dos créditos realizados por categoria e item
			// * contábil para origem do crédito igual a valores
			// * cobrados indevidamente e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente
			// = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
			// idLancamentoItemContabil);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente
			// != null
			// &&
			// somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4300");
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 =
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
			// .add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
			// lancamentoItemTemp.setId(LancamentoItem.VALORES_COBRADOS_INDEVIDAMENTE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4300"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5200 Para os
			// * pagamentos de guias de pagamento efetuados em
			// * meses anteriores classificados no mês acumula o
			// * valor das guias de pagamento por categoria e item
			// * contábil para tipo de financiamento serviço e
			// * gera o resumo da arrecadação caso o valor
			// * acumulado seja maior que 0(zero)
			// */
			// BigDecimal
			// somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico
			// = repositorioArrecadacao
			// .acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico(
			// idLocalidade, anoMesReferenciaArrecadacao, idLancamentoItemContabil,
			// idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico
			// != null
			// &&
			// somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 5200");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
			// lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5200"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5300 Para os
			// * pagamentos de débitos a cobrar efetuados em meses
			// * anteriores classificados no mês acumula o valor
			// * que falta ser cobrado dos débitos a cobrar por
			// * categoria e item contábil e para tipo de
			// * financiamento igual a serviço e gera o resumo da
			// * arrecadação caso o valor acumulado seja maior que
			// * 0(zero)
			// */
			// BigDecimal
			// somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores =
			// repositorioArrecadacao
			// .acumularValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores(idLocalidade,
			// anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria);
			//
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores !=
			// null
			// &&
			// somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores.doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 5300");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .add(somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.DEBITOS_A_COBRAR);
			// lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5300"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			//
			// }// fim do laço para gerar os resumo por LANÇAMENTO
			// // ITEM CONTÁBIL
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1200 Caso o map onde
			// * foi armazenado o valor do imposto de renda (IR) por
			// * categoria não estiver vazio, gera o resumo da
			// * arrecadação para cada categoria retornada pelo imóvel
			// * com seu respectivo valor.
			// */
			// if(mapValorIRPagamentosClassificadosConta.containsKey(idCategoria)){
			// if(mapValorIRPagamentosClassificadosConta.get(idCategoria).doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 1200");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .subtract(mapValorIRPagamentosClassificadosConta.get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_RECEBIDAS);
			// lancamentoItemTemp.setId(LancamentoItem.IMPOSTO_RENDA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1200"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorIRPagamentosClassificadosConta.get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1300 Caso o map onde
			// * foi armazenado o valor do CSLL por categoria não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorCSLLPagamentosClassificadosConta.containsKey(idCategoria)){
			// if(mapValorCSLLPagamentosClassificadosConta.get(idCategoria).doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 1300");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .subtract(mapValorCSLLPagamentosClassificadosConta.get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_RECEBIDAS);
			// lancamentoItemTemp.setId(LancamentoItem.CSLL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1300"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorCSLLPagamentosClassificadosConta.get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1400 Caso o map onde
			// * foi armazenado o valor do COFINS por categoria não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorCOFINSPagamentosClassificadosConta.containsKey(idCategoria)){
			// if(mapValorCOFINSPagamentosClassificadosConta.get(idCategoria).doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 1400");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .subtract(mapValorCOFINSPagamentosClassificadosConta.get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_RECEBIDAS);
			// lancamentoItemTemp.setId(LancamentoItem.COFINS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1400"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorCOFINSPagamentosClassificadosConta.get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 1500 Caso o map onde
			// * foi armazenado o valor do PIS/PASEP por categoria não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorPISPASEPPagamentosClassificadosConta.containsKey(idCategoria)){
			// if(mapValorPISPASEPPagamentosClassificadosConta.get(idCategoria).doubleValue() >
			// 0.00){
			// System.out.println("SEQUENCIAL 1500");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .subtract(mapValorPISPASEPPagamentosClassificadosConta.get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_RECEBIDAS);
			// lancamentoItemTemp.setId(LancamentoItem.PIS_PASEP);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1500"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorPISPASEPPagamentosClassificadosConta.get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2100 Caso o map onde
			// * foi armazenado o valor do pagamento por categoria do
			// * grupo de pagamentos classificados do mês, com
			// * situação atual igual a pagamento em duplicidade não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .containsKey(idCategoria)){
			// if(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 2100");
			// // Seqüêncial de Tipo de Lançamento 2400
			// valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 =
			// valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
			// .add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE);
			// lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2100"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2200 Caso o map onde
			// * foi armazenado o valor do pagamento por categoria do
			// * grupo de pagamentos classificados do mês, com
			// * situação atual igual a pagamento em duplicidade não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.containsKey(idCategoria)){
			// if(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 2200");
			// // Seqüêncial de Tipo de Lançamento 2400
			// valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 =
			// valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
			// .add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.DOCUMENTO_INEXISTENTE);
			// lancamentoItemTemp.setId(LancamentoItem.DOCUMENTO_INEXISTENTE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2200"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2300 Caso o map onde
			// * foi armazenado o valor do pagamento por categoria do
			// * grupo de pagamentos classificados do mês, com
			// * situação atual igual a valor não confere e e para os
			// * pagamentos não classificados do mês com situação
			// * anterior igual a valor não confere, acumulou neste
			// * caso o valor do pagamento excedente, não estiver
			// * vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.containsKey(idCategoria)){
			// if(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 2300");
			// // Seqüêncial de Tipo de Lançamento 2400
			// valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 =
			// valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
			// .add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
			// lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2300"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2600 Caso o map onde
			// * foi armazenado o valor das devoluções por categoria
			// * com situação atual igual a devolução classificada não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorDevolucaoSituacaoAtualDevolucaoClassificada.containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoSituacaoAtualDevolucaoClassificada.get(idCategoria).doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 2600");
			// // Seqüêncial de Tipo de Lançamento 2800
			// valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 =
			// valorAcumuladoSequenciaTipoLancamentoEntre2600e2799
			// .add(mapValorDevolucaoSituacaoAtualDevolucaoClassificada.get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
			// lancamentoItemTemp.setId(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2600"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoSituacaoAtualDevolucaoClassificada
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 2900 Caso o map onde
			// * foi armazenado os maps com o valor das devoluções por
			// * categoria com situação atual igual a pagamento em
			// * duplicidade não encontrado não estiver vazio, gera
			// * para cada map armazenado o resumo da arrecadação para
			// * cada categoria retornada pelo imóvel com seu
			// * respectivo valor.
			// */
			// if(mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 2900");
			// // Seqüêncial de Tipo de Lançamento 3200
			// valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 =
			// valorAcumuladoSequenciaTipoLancamentoEntre2900e3199
			// .add(mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_NAO_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE_EXCESSO_NAO_ENCONTRADO);
			// lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE_EXCESSO_NAO_ENCONTRADO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2900"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3000 Caso o map onde
			// * foi armazenado o valor das devoluções não
			// * classificadas do mês por categoria com situação atual
			// * igual a guia de devolução não informada não estiver
			// * vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.get(idCategoria).doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 3000");
			// // Seqüêncial de Tipo de Lançamento 3200
			// valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 =
			// valorAcumuladoSequenciaTipoLancamentoEntre2900e3199
			// .add(mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_NAO_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.GUIA_DEVOLUCAO_NAO_INFORMADA);
			// lancamentoItemTemp.setId(LancamentoItem.GUIA_DEVOLUCAO_NAO_INFORMADA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3000"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 3100 Caso o map onde
			// * foi armazenado o valor das devoluções não
			// * classificadas do mês por categoria com situação atual
			// * igual a valor não confere não estiver vazio, gera o
			// * resumo da arrecadação para cada categoria retornada
			// * pelo imóvel com seu respectivo valor.
			// */
			// if(mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.get(idCategoria).doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 3100");
			// // Seqüêncial de Tipo de Lançamento 3200
			// valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 =
			// valorAcumuladoSequenciaTipoLancamentoEntre2900e3199
			// .add(mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_NAO_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
			// lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3100"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4600 Caso o map onde
			// * foi armazenado o valor do IR(imposto de renda) por
			// * categoria do grupo de pagamentos de contas efetuados
			// * em meses anteriores classificados no mês, não estiver
			// * vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(idCategoria)){
			// if(mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria).doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 4600");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .subtract(mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .subtract(mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp
			// .setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
			// lancamentoItemTemp.setId(LancamentoItem.IMPOSTO_RENDA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4600"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4700 Caso o map onde
			// * foi armazenado o valor do CSLL por categoria do grupo
			// * de pagamentos de contas efetuados em meses anteriores
			// * classificados no mês, não estiver vazio, gera o
			// * resumo da arrecadação para cada categoria retornada
			// * pelo imóvel com seu respectivo valor.
			// */
			// if(mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(idCategoria)){
			// if(mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria).doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 4700");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .subtract(mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .subtract(mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp
			// .setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
			// lancamentoItemTemp.setId(LancamentoItem.CSLL);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4700"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4800 Caso o map onde
			// * foi armazenado o valor do COFINS por categoria do
			// * grupo de pagamentos de contas efetuados em meses
			// * anteriores classificados no mês, não estiver vazio,
			// * gera o resumo da arrecadação para cada categoria
			// * retornada pelo imóvel com seu respectivo valor.
			// */
			// if(mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(idCategoria)){
			// if(mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria).doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 4800");
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .subtract(mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .subtract(mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp
			// .setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
			// lancamentoItemTemp.setId(LancamentoItem.COFINS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4800"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 4900 Caso o map onde
			// * foi armazenado o valor do PIS/PASEP por categoria do
			// * grupo de pagamentos de contas efetuados em meses
			// * anteriores classificados no mês, não estiver vazio,
			// * gera o resumo da arrecadação para cada categoria
			// * retornada pelo imóvel com seu respectivo valor.
			// */
			// if(mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(idCategoria)){
			// if(mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria).doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 4900");
			//
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .subtract(mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .subtract(mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp
			// .setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
			// lancamentoItemTemp.setId(LancamentoItem.PIS_PASEP);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4900"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5500 Caso o map onde
			// * foi armazenado o valor das devoluções por categoria
			// * do grupo de devoluções efetuadas em meses anteriores
			// * classificadas no mês, com situação atual igual a
			// * devolução classificada não estiver vazio, gera o
			// * resumo da arrecadação para cada categoria retornada
			// * pelo imóvel com seu respectivo valor.
			// */
			// if(mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.get(
			// idCategoria).doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 5500");
			// // Seqüêncial de Tipo de Lançamento 5700
			// valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 =
			// valorAcumuladoSequenciaTipoLancamentoEntre5500e5699
			// .add(mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
			// lancamentoItemTemp.setId(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5500"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5800 Caso o map onde
			// * foi armazenado o valor excedente dos pagamentos por
			// * categoria do grupo de pagamentos não classificados
			// * com baixa comandada, com situação anterior igual a
			// * pagamento em duplicidade não estiver vazio, gera o
			// * resumo da arrecadação para cada categoria retornada
			// * pelo imóvel com seu respectivo valor.
			// */
			// if(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .containsKey(idCategoria)){
			// if(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.get(
			// idCategoria).doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 5800");
			// // Seqüêncial de Tipo de Lançamento 6100
			// valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
			// .add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE);
			// lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5800"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 5900 Caso o map onde
			// * foi armazenado o valor excedente dos pagamentos por
			// * categoria do grupo de pagamentos não classificados
			// * com baixa comandada, com situação anterior igual a
			// * documento inexistente não estiver vazio, gera o
			// * resumo da arrecadação para cada categoria retornada
			// * pelo imóvel com seu respectivo valor.
			// */
			// if(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .containsKey(idCategoria)){
			// if(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.get(
			// idCategoria).doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 5900");
			// // Seqüêncial de Tipo de Lançamento 6100
			// valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
			// .add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.DOCUMENTO_INEXISTENTE);
			// lancamentoItemTemp.setId(LancamentoItem.DOCUMENTO_INEXISTENTE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5900"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6000 Caso o map onde
			// * foi armazenado o valor excedente dos pagamentos por
			// * categoria do grupo de pagamentos não classificados
			// * com baixa comandada, com situação anterior igual a
			// * valor não confere não estiver vazio, gera o resumo da
			// * arrecadação para cada categoria retornada pelo imóvel
			// * com seu respectivo valor.
			// */
			// if(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .containsKey(idCategoria)){
			// if(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6000");
			// // Seqüêncial de Tipo de Lançamento 6100
			// valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 =
			// valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
			// .add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
			// lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6000"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 6200
			// // O sequência 6200 acumula os valores dos sequências
			// // 100 à 700
			// // de 3500 à 4100
			// // e acumula negativamente os valores dos sequências de
			// // 8000 à
			// // 1000, de 1200 à 1500,
			// // de 4200 à 4400 e de 4600 à 4900.
			// BigDecimal valorSequencial_100_200_3500_3600 = repositorioArrecadacao
			// .acumularValorAguaEsgotoPagamentosClassificadosNoMesEfetuadosEmMesesAnterioresContaContabilizadasComoPerdas(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria);
			// BigDecimal valorSequencial_300_400_500_600_700_3700_3800_3900_4000_4100 =
			// repositorioArrecadacao
			// .acumularValorDebitoCobradoPagamentosClassificadosNoMesEfetuadosEmMesesAnterioresContaContabilizadaComoPerdasFinanciamentoTipoServicoParcelamentoAguaParcelamentoEsgotoParcelamentoServico(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria);
			// BigDecimal valorSequencial_800_900_1000_4200_4300_4400 = repositorioArrecadacao
			// .acumularValorCreditoRealizadoPagamentosClassificadosNoMesEfetuadosMesesAnterioresContaContabilizadaComoPerdasOrigemCreditoContasPagasEmDuplicidadeExcessoValoresCobradosIndevidamenteDescontosConcedidos(
			// idLocalidade, anoMesReferenciaArrecadacao, idCategoria);
			// BigDecimal valorSequencial_1200_1300_1400_1500_4600_4700_4800_4900 = null;
			//
			// if(mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.containsKey(idCategoria)){
			// valorSequencial_1200_1300_1400_1500_4600_4700_4800_4900 =
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores
			// .get(idCategoria);
			// }
			//
			// if(valorSequencial_100_200_3500_3600 != null){
			// valorAcumuladoContasContabilizadasComoPerdas =
			// valorAcumuladoContasContabilizadasComoPerdas
			// .add(valorSequencial_100_200_3500_3600);
			// }
			//
			// if(valorSequencial_300_400_500_600_700_3700_3800_3900_4000_4100 != null){
			// valorAcumuladoContasContabilizadasComoPerdas =
			// valorAcumuladoContasContabilizadasComoPerdas
			// .add(valorSequencial_300_400_500_600_700_3700_3800_3900_4000_4100);
			// }
			//
			// if(valorSequencial_800_900_1000_4200_4300_4400 != null){
			// valorAcumuladoContasContabilizadasComoPerdas =
			// valorAcumuladoContasContabilizadasComoPerdas
			// .subtract(valorSequencial_800_900_1000_4200_4300_4400);
			// }
			// if(valorSequencial_1200_1300_1400_1500_4600_4700_4800_4900 != null){
			// valorAcumuladoContasContabilizadasComoPerdas =
			// valorAcumuladoContasContabilizadasComoPerdas
			// .subtract(valorSequencial_1200_1300_1400_1500_4600_4700_4800_4900);
			// }
			// // fim do acumulador do sequêncial 6200
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6300 Caso o map onde
			// * foi armazenado o valor excedente dos pagamentos por
			// * categoria do grupo de pagamentos não classificados ,
			// * com situação atual igual a pagamento em duplicidade
			// * não estiver vazio, gera o resumo da arrecadação para
			// * cada categoria retornada pelo imóvel com seu
			// * respectivo valor.
			// */
			// if(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// .containsKey(idCategoria)){
			// if(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6300");
			// // Seqüêncial de Tipo de Lançamento 6600
			// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
			// .add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE);
			// lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6300"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6400 Caso o map onde
			// * foi armazenado o valor excedente dos pagamentos por
			// * categoria do grupo de pagamentos não classificados ,
			// * com situação atual igual a documento inexistente não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.containsKey(idCategoria)){
			// if(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6400");
			// // Seqüêncial de Tipo de Lançamento 6600
			// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
			// .add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.DOCUMENTO_INEXISTENTE);
			// lancamentoItemTemp.setId(LancamentoItem.DOCUMENTO_INEXISTENTE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6400"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6500 Caso o map onde
			// * foi armazenado o valor excedente dos pagamentos por
			// * categoria do grupo de pagamentos não classificados ,
			// * com situação atual igual a valor não confere não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.containsKey(idCategoria)){
			// if(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6500");
			// // Seqüêncial de Tipo de Lançamento 6600
			// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
			// .add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
			// lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6500"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6700 Caso o map onde
			// * foi armazenado o valor da devolução por categoria do
			// * grupo de devoluções não classificadas , com situação
			// * atual igual a pagamento em duplicidade não encontrado
			// * não estiver vazio, gera o resumo da arrecadação para
			// * cada categoria retornada pelo imóvel com seu
			// * respectivo valor.
			// */
			// if(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(
			// idCategoria).doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6700");
			// // Seqüêncial de Tipo de Lançamento 7000
			// valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre6700e6999
			// .add(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_DEVOLUCOES_NAO_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE_EXCESSO_NAO_ENCONTRADO);
			// lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE_EXCESSO_NAO_ENCONTRADO);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6700"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6800 Caso o map onde
			// * foi armazenado o valor da devolução por categoria do
			// * grupo de devoluções não classificadas , com situação
			// * atual igual a guia de devolução não informada não
			// * estiver vazio, gera o resumo da arrecadação para cada
			// * categoria retornada pelo imóvel com seu respectivo
			// * valor.
			// */
			// if(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6800");
			// // Seqüêncial de Tipo de Lançamento 7000
			// valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre6700e6999
			// .add(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_DEVOLUCOES_NAO_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.GUIA_DEVOLUCAO_NAO_INFORMADA);
			// lancamentoItemTemp.setId(LancamentoItem.GUIA_DEVOLUCAO_NAO_INFORMADA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6800"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// /*
			// * Seqüêncial de Tipo de Lançamento 6900 Caso o map onde
			// * foi armazenado o valor da devolução por categoria do
			// * grupo de devoluções não classificadas , com situação
			// * atual igual a valor não confere não estiver vazio,
			// * gera o resumo da arrecadação para cada categoria
			// * retornada pelo imóvel com seu respectivo valor.
			// */
			// if(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.containsKey(idCategoria)){
			//
			// if(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(idCategoria)
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6900");
			// // Seqüêncial de Tipo de Lançamento 7000
			// valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre6700e6999
			// .add(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// .get(idCategoria));
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_DEVOLUCOES_NAO_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
			// lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6900"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere
			// .get(idCategoria));
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			// }
			// }
			//
			// // Sequências que são somatórios de outros sequências
			// // anteriores
			// /*
			// * Seqüêncial de Tipo de Lançamento 1100 Caso o acumulo
			// * dos valores dos seqüênciais entre 800 e 1099 for
			// * maior que zero ,gera o resumo para o valor acumulado.
			// */
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre800e1099 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre800e1099.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 1100");
			// // Seqüêncial de Tipo de Lançamento 1600
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
			// .subtract(valorAcumuladoSequenciaTipoLancamentoEntre800e1099);
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_CREDITOS_REALIZADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_CREDITOS_REALIZADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1100"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre800e1099);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 2000 (Seqüêncial de
			// // Tipo de
			// // Lançamento 1600 + 1700 a 1999)
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// .add(valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599);
			//
			// // Seqüêncial de Tipo de Lançamento 2500 (Seqüêncial de
			// // Tipo de
			// // Lançamento 2000 e 2400)
			// valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 =
			// valorAcumuladoSequenciaTipoLancamentoIgual2000e2400
			// .add(valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999);
			//
			// // Seqüêncial de Tipo de Lançamento 2000
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// != null
			// &&
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 2000");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_CLASSIFICADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2000"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
			// = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 1600 (Seqüêncial de
			// // Tipo de
			// // Lançamento (100 e 700) - (1100) - (1200 e 1500))
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 !=
			// null
			// &&
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599.doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 1600");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("1600"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 =
			// BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 2500 (Seqüêncial de
			// // Tipo de
			// // Lançamento 2000 e 2400)
			// valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 =
			// valorAcumuladoSequenciaTipoLancamentoIgual2000e2400
			// .add(valorAcumuladoSequenciaTipoLancamentoEntre2100e2399);
			//
			// // Seqüêncial de Tipo de Lançamento 2400
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre2100e2399.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 2400");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2400"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre2100e2399);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 3400 (Seqüêncial de
			// // Tipo de
			// // Lançamento 2500 e 3300)
			// diferencaEntreSequencialTipoIgual2500e3300 =
			// diferencaEntreSequencialTipoIgual2500e3300
			// .add(valorAcumuladoSequenciaTipoLancamentoIgual2000e2400);
			//
			// // Seqüêncial de Tipo de Lançamento 2500
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 != null
			// && valorAcumuladoSequenciaTipoLancamentoIgual2000e2400.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 2500");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_RECEBIMENTOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2500"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoIgual2000e2400);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 3300 = (Seqüêncial
			// // de Tipo
			// // de Lançamento 2800 + Seqüêncial de Tipo de Lançamento
			// // 3200)
			// valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 =
			// valorAcumuladoSequenciaTipoLancamentoIgual2800e3200
			// .add(valorAcumuladoSequenciaTipoLancamentoEntre2600e2799);
			//
			// // Seqüêncial de Tipo de Lançamento 2800
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre2600e2799.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 2800");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES_CLASSIFICADAS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES_CLASSIFICADAS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("2800"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre2600e2799);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 3300 = (Seqüêncial
			// // de Tipo
			// // de Lançamento 2800 + Seqüêncial de Tipo de Lançamento
			// // 3200)
			// valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 =
			// valorAcumuladoSequenciaTipoLancamentoIgual2800e3200
			// .add(valorAcumuladoSequenciaTipoLancamentoEntre2900e3199);
			//
			// // Seqüêncial de Tipo de Lançamento 3200
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre2900e3199.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 3200");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_NAO_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES_NAO_CLASSIFICADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES_NAO_CLASSIFICADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3200"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre2900e3199);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 3400
			// diferencaEntreSequencialTipoIgual2500e3300 =
			// diferencaEntreSequencialTipoIgual2500e3300
			// .subtract(valorAcumuladoSequenciaTipoLancamentoIgual2800e3200);
			//
			// // Seqüêncial de Tipo de Lançamento 3300
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 != null
			// && valorAcumuladoSequenciaTipoLancamentoIgual2800e3200.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 3300");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_DEVOLUCOES);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3300"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoIgual2800e3200);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 3400
			// // Neste caso não tem verificação do valor menor ou
			// // igula a zero
			// // porque , a diferença
			// // pode ser negativa ou zero.
			// if(diferencaEntreSequencialTipoIgual2500e3300 != null){
			// System.out.println("SEQUENCIAL 3400");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.ARRECADACAO_LIQUIDA);
			// lancamentoTipoTemp.setId(LancamentoTipo.ARRECADACAO_LIQUIDA);
			// lancamentoItemTemp.setId(LancamentoItem.ARRECADACAO_LIQUIDA);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("3400"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(diferencaEntreSequencialTipoIgual2500e3300);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// diferencaEntreSequencialTipoIgual2500e3300 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 4500
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre4200e4499.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 4500");
			//
			// // Seqüêncial de Tipo de Lançamento 5400
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .subtract(valorAcumuladoSequenciaTipoLancamentoEntre4200e4499);
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// .subtract(valorAcumuladoSequenciaTipoLancamentoEntre4200e4499);
			//
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_CREDITOS_REALIZADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_CREDITOS_REALIZADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("4500"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre4200e4499);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 5000
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
			// != null
			// &&
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999.doubleValue()
			// > 0.00){
			// System.out.println("SEQUENCIAL 5000");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5000"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 =
			// BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 5400
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// != null
			// &&
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// .doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 5400");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5400"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp
			// .setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
			// = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 5700
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre5500e5699.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 5700");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES_DE_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES_DE_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("5700"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre5500e5699);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 6100
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre5800e6099.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6100");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS_BAIXADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS_BAIXADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6100"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre5800e6099);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 6200
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoContasContabilizadasComoPerdas != null
			// && valorAcumuladoContasContabilizadasComoPerdas.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6200");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_VALORES_CONTABILIZADOS_COMO_PERDAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.VALORES_CONTABILIZADOS_COMO_PERDAS);
			// lancamentoItemTemp.setId(LancamentoItem.VALORES_CONTABILIZADOS_COMO_PERDAS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6200"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoContasContabilizadasComoPerdas);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoContasContabilizadasComoPerdas = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 6600
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre6300e6599.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 6600");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("6600"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre6300e6599);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = BigDecimal.ZERO;
			// }
			//
			// // Seqüêncial de Tipo de Lançamento 7000
			// // [FS0005] - Verificar valor acumulado igual a zero
			// if(valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 != null
			// && valorAcumuladoSequenciaTipoLancamentoEntre6700e6999.doubleValue() > 0.00){
			// System.out.println("SEQUENCIAL 7000");
			// recebimentoTipoTemp = new RecebimentoTipo();
			// lancamentoTipoTemp = new LancamentoTipo();
			// lancamentoItemTemp = new LancamentoItem();
			//
			// resumoArrecadacaoTemp = new ResumoArrecadacao();
			// recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_DEVOLUCOES_NAO_CLASSIFICADAS);
			// lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES_NAO_CLASSIFICADOS);
			// lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES_NAO_CLASSIFICADOS);
			// resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
			// resumoArrecadacaoTemp.setLocalidade(localidade);
			// resumoArrecadacaoTemp.setCategoria(categoria);
			// resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
			// resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
			// resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
			// resumoArrecadacaoTemp.setLancamentoItemContabil(null);
			// resumoArrecadacaoTemp.setSequenciaTipoLancamento(Short.valueOf("7000"));
			// resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(Short.valueOf("0"));
			// resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
			// resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre6700e6999);
			// colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
			//
			// valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 = BigDecimal.ZERO;
			// }
			//
			// // Reseta os valores dentro dos maps
			// // Seqüêncial de Tipo de Lançamento 1200
			// mapValorIRPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 1300
			// mapValorCSLLPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 1400
			// mapValorCOFINSPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 1500
			// mapValorPISPASEPPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 2100
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 2200
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 2300
			// mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 2600
			// mapValorDevolucaoSituacaoAtualDevolucaoClassificada.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 2900
			// mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 3000
			// mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 3100
			// mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 4600
			// mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 4700
			// mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 4800
			// mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 4900
			// mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 5800
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(categoria
			// .getId(), BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 5900
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.put(categoria
			// .getId(), BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 6000
			// mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 6200
			// mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores
			// .put(categoria.getId(), BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 6300
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 6400
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 6500
			// mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 6700
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(categoria
			// .getId(), BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 6800
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria.getId(),
			// BigDecimal.ZERO);
			// // Seqüêncial de Tipo de Lançamento 6900
			// mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria.getId(),
			// BigDecimal.ZERO);
			//
			// }// CATEGORIA
			//
			// repositorioArrecadacao.inserirResumoArrecadacao(colecaoResumoArrecadacao);
			// colecaoResumoArrecadacao = new ArrayList();
			//
			// System.out.println("FIM DA LOCALIDADE" + idLocalidade);
			// }// LOCALIDADE

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------

			// }
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	/**
	 * 
	 * @throws ErroRepositorioException
	 * @author Felipe Rosacruz
	 * @date 28/12/2013
	 */
	private void gerarDadosRemuneracaoCobrancaAdministrativaModelo1() throws ErroRepositorioException{

		Collection<ImovelCobrancaAdministrivaItem> colecaoImovelCobrancaAdministrivaItens;


		Collection<Object[]> colecaoRetorno = repositorioArrecadacao.gerarDadosRemuneracaoCobrancaAdministrativaModelo1();

		double valorArrecadadoLoteAcumulado;
		double valorNominalLote;
		double percentualDesempenho;
		double percentualRemuneracao;
		double valorRemuneracao;
		
		FiltroCobrancaAdministrativaRemuneracaoMensal filtroCobrancaAdministrativaRemuneracaoMensal;
		SistemaParametro sistemaParametro = Fachada.getInstancia().pesquisarParametrosDoSistema();
		for(Object[] objects : colecaoRetorno){
			
			valorArrecadadoLoteAcumulado = ((Double) objects[2]);
			filtroCobrancaAdministrativaRemuneracaoMensal = new FiltroCobrancaAdministrativaRemuneracaoMensal();
			filtroCobrancaAdministrativaRemuneracaoMensal.adicionarParametro(new ParametroSimples("empresa.id", objects[0]));
			filtroCobrancaAdministrativaRemuneracaoMensal.adicionarParametro(new ParametroSimples("cobrancaAcaoAtividadeComando.id",
							objects[1]));
			Collection<CobrancaAdministrativaRemuneracaoMensal> colecaoCobrancaAdministrativaRemuneracaoMensal = Fachada.getInstancia()
							.pesquisar(filtroCobrancaAdministrativaRemuneracaoMensal,
											CobrancaAdministrativaRemuneracaoMensal.class.getName());
			for(CobrancaAdministrativaRemuneracaoMensal cobrancaAdministrativaRemuneracaoMensal : colecaoCobrancaAdministrativaRemuneracaoMensal){
				valorArrecadadoLoteAcumulado += cobrancaAdministrativaRemuneracaoMensal.getValorArrecadadoLote().doubleValue();
			}
			
			valorNominalLote = 0;
			FiltroCobrancaDocumento filtroCobrancaDocumento = new FiltroCobrancaDocumento();
			filtroCobrancaDocumento.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.ID_COBRANCA_ACAO_ATIVIDADE_COMANDO, objects[1]));
			Collection<CobrancaDocumento> colecaoCobrancaDocumentos = Fachada.getInstancia().pesquisar(filtroCobrancaDocumento, CobrancaDocumento.class.getName());
			for(CobrancaDocumento cobrancaDocumento : colecaoCobrancaDocumentos){
				valorNominalLote += cobrancaDocumento.getValorDocumento().doubleValue()
								- cobrancaDocumento.getValorAcrescimos().doubleValue() + cobrancaDocumento.getValorDesconto().doubleValue();
			}
			
			percentualDesempenho = valorArrecadadoLoteAcumulado * 100 / valorNominalLote;
			
			percentualRemuneracao = repositorioArrecadacao.retornaPercentualRemuneracaoPorEmpresa((Integer) objects[0],
							percentualDesempenho);
			
			valorRemuneracao = ((Double) objects[3]) * percentualRemuneracao / 100;
			
			
			
			CobrancaAdministrativaRemuneracaoMensal cobrancaAdministrativaRemuneracaoMensal = new CobrancaAdministrativaRemuneracaoMensal();
			cobrancaAdministrativaRemuneracaoMensal.setReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
			cobrancaAdministrativaRemuneracaoMensal.setPercentualDesempenho(BigDecimal.valueOf(percentualDesempenho));
			cobrancaAdministrativaRemuneracaoMensal.setPercentualRemuneracao(BigDecimal.valueOf(percentualRemuneracao));
			cobrancaAdministrativaRemuneracaoMensal.setValorArrecadadoLote(BigDecimal.valueOf((Double) objects[2]));
			cobrancaAdministrativaRemuneracaoMensal.setValorArrecadadoLoteAcumulado(BigDecimal.valueOf(valorArrecadadoLoteAcumulado));
			cobrancaAdministrativaRemuneracaoMensal.setValorArrecadado(BigDecimal.valueOf((Double) objects[3]));
			cobrancaAdministrativaRemuneracaoMensal.setValorRemuneracao(BigDecimal.valueOf(valorRemuneracao));
			cobrancaAdministrativaRemuneracaoMensal.setIndicadorRemuneracaoPaga((short) 2);
			FiltroCobrancaAcaoAtividadeComando filtroCACM = new FiltroCobrancaAcaoAtividadeComando();
			filtroCACM.adicionarParametro(new ParametroSimples("id", objects[1]));
			CobrancaAcaoAtividadeComando cacm = (CobrancaAcaoAtividadeComando) Util.retonarObjetoDeColecao(Fachada.getInstancia()
							.pesquisar(filtroCACM, CobrancaAcaoAtividadeComando.class.getName()));
			cobrancaAdministrativaRemuneracaoMensal.setCobrancaAcaoAtividadeComando(cacm);
			FiltroEmpresa filtroEmpresa = new FiltroEmpresa();
			filtroEmpresa.adicionarParametro(new ParametroSimples(FiltroEmpresa.ID, objects[0]));
			Empresa empresa = (Empresa) Util.retonarObjetoDeColecao(Fachada.getInstancia()
							.pesquisar(filtroEmpresa, Empresa.class.getName()));
			cobrancaAdministrativaRemuneracaoMensal.setEmpresa(empresa);
			cobrancaAdministrativaRemuneracaoMensal.setUltimaAlteracao(new Date());

			Fachada.getInstancia().inserir(cobrancaAdministrativaRemuneracaoMensal);

			FiltroImovelCobrancaAdministrivaItem filtroImovelCobrancaAdministrivaItem = new FiltroImovelCobrancaAdministrivaItem();
			filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples("anoMesReferenciaArrecadacao", sistemaParametro
							.getAnoMesArrecadacao()));
			
			FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
			filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples("cobrancaAcaoAtividadeComando.id", objects[1]));
			Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = Fachada.getInstancia().pesquisar(filtroImovelCobrancaSituacao, ImovelCobrancaSituacao.class.getName());
			Collection<Integer> colecaoIdsImovelCobrancaSituacao = new ArrayList<Integer>();
			for(ImovelCobrancaSituacao imovelCobrancaSituacao : colecaoImovelCobrancaSituacao){
				colecaoIdsImovelCobrancaSituacao.add(imovelCobrancaSituacao.getId());
			}
			
			filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimplesColecao("imovelCobrancaSituacao.id",
							colecaoIdsImovelCobrancaSituacao));
			Collection<ImovelCobrancaAdministrivaItem> colecaoImovelCobrancaAdministrivaItem = (Collection<ImovelCobrancaAdministrivaItem>) Fachada
							.getInstancia().pesquisar(
							filtroImovelCobrancaAdministrivaItem, ImovelCobrancaAdministrivaItem.class.getName());
			for(ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem : colecaoImovelCobrancaAdministrivaItem){
				imovelCobrancaAdministrivaItem.setCobrancaAdministrativaRemuneracaoMensal(cobrancaAdministrativaRemuneracaoMensal);
				imovelCobrancaAdministrivaItem.setUltimaAlteracao(new Date());
				Fachada.getInstancia().atualizar(imovelCobrancaAdministrivaItem);
			}

		}


	}

	/**
	 * @param sistemaParametro
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	private void atualizaPagamentosNaoClassificadosMes(SistemaParametro sistemaParametro) throws ControladorException{

		Collection<Pagamento> colecaoPagamentosNaoClassificados;

		try{
			colecaoPagamentosNaoClassificados = repositorioArrecadacao.pesquisarPagamentoNaoClassificado(sistemaParametro
							.getAnoMesArrecadacao());

			for(Pagamento pagamento : colecaoPagamentosNaoClassificados){

				pagamento.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAtual());
				pagamento.setUltimaAlteracao(new Date());
			}

			if(colecaoPagamentosNaoClassificados != null && !colecaoPagamentosNaoClassificados.isEmpty()){
				this.getControladorUtil().atualizarColecaoObjetos(colecaoPagamentosNaoClassificados);
			}

			sistemaParametro.setAnoMesArrecadacao(Util.somaMesAnoMesReferencia(sistemaParametro.getAnoMesArrecadacao(), 1));

			this.getControladorUtil().atualizarSistemaParametro(sistemaParametro);

		}catch(ErroRepositorioException e1){
			throw new ControladorException("erro.sistema", e1);
		}catch(ControladorException e){
			throw new ControladorException("atencao.registro_nao_atualizado");
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Metodo responsável pela transferência das contas, guias de pagamento,
	 * pagamentos e devoluções para o histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 06/02/2007
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ControladorException
	 */
	public void gerarHistoricoParaEncerrarArrecadacaoMes(Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
					int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.LOCALIDADE, idLocalidade);

		try{
			/** GUIA PAGAMENTO */
			gerarHistoricoParaEncerrarArrecadacaoGuiaPagamento(anoMesReferenciaArrecadacao, idLocalidade);

			/** DEBITO A COBRAR */
			gerarHistoricoParaEncerrarArrecadacaoDebitoACobrar(anoMesReferenciaArrecadacao, idLocalidade);

			/** PAGAMENTO */
			gerarHistoricoParaEncerrarArrecadacaoPagamento(anoMesReferenciaArrecadacao, idLocalidade);

			/** DEVOLUCAO */
			gerarHistoricoEncerrarArrecadacaoDevolucao(anoMesReferenciaArrecadacao, idLocalidade);

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	public void gerarHistoricoConta(Integer anoMesReferenciaArrecadacao, Integer idSetorComercial, int idFuncionalidadeIniciada)
					throws ControladorException{

		int idUnidadeIniciada = 0;

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.SETOR_COMERCIAL, idSetorComercial);

		try{
			Integer idLocalidade = repositorioArrecadacao.pesquisarIdLocalidadePorSetorComercial(idSetorComercial);

			/** CONTA */
			gerarHistoricoEncerrarArrecadacaoConta(anoMesReferenciaArrecadacao, idLocalidade, idSetorComercial);

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	protected void gerarHistoricoEncerrarArrecadacaoDevolucao(Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
					throws ErroRepositorioException, ControladorException{

		/** Devoluções Classificadas */
		List colecaoDevolucoesClassificadas = (List) repositorioArrecadacao.pesquisarDevolucoesClassificadasPorLocalidade(
						anoMesReferenciaArrecadacao, idLocalidade);

		if(colecaoDevolucoesClassificadas != null && !colecaoDevolucoesClassificadas.isEmpty()){
			int limiteSuperiorDevolucao;
			int limiteInferiorDevolucao;
			int limiteMaximoDevolucao = colecaoDevolucoesClassificadas.size();
			int quantidadeMaximaPorColecaoDevolucao = 50;

			for(int i = 0; i < limiteMaximoDevolucao; i = i + quantidadeMaximaPorColecaoDevolucao){

				if(limiteMaximoDevolucao < quantidadeMaximaPorColecaoDevolucao){
					limiteInferiorDevolucao = 0;
					limiteSuperiorDevolucao = limiteMaximoDevolucao;
				}else{
					limiteInferiorDevolucao = i;
					limiteSuperiorDevolucao = i + quantidadeMaximaPorColecaoDevolucao;

					if(limiteSuperiorDevolucao > limiteMaximoDevolucao){
						limiteSuperiorDevolucao = limiteMaximoDevolucao;
					}
				}

				List colecaoDevolucoesTemporaria = new ArrayList();
				colecaoDevolucoesTemporaria
								.addAll(colecaoDevolucoesClassificadas.subList(limiteInferiorDevolucao, limiteSuperiorDevolucao));

				if(colecaoDevolucoesTemporaria != null && !colecaoDevolucoesTemporaria.isEmpty()){
					transferirDevolucaoParaHistorico(colecaoDevolucoesTemporaria);
				}

				colecaoDevolucoesTemporaria = null;
			}

			colecaoDevolucoesClassificadas = null;
		}
		/** Fim Devoluções Classificadas */
	}

	protected void gerarHistoricoParaEncerrarArrecadacaoPagamento(Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
					throws ErroRepositorioException, ControladorException{

		/** Pagamentos Classificados */
		boolean flagTerminou = false;
		final int quantidadeRegistros = 500;
		int numeroIndice = 0;

		while(!flagTerminou){
			Collection<Integer> colecaoPagamentosClassificados = repositorioArrecadacao
							.pesquisarPagamentosClassificadosOuValorExcedenteBaixado(anoMesReferenciaArrecadacao, idLocalidade,
											numeroIndice, quantidadeRegistros);

			if(colecaoPagamentosClassificados == null || colecaoPagamentosClassificados.size() < quantidadeRegistros){

				flagTerminou = true;
			}

			Iterator<Integer> iteratorPagamentos = colecaoPagamentosClassificados.iterator();
			while(iteratorPagamentos.hasNext()){

				Integer idPagamento = iteratorPagamentos.next();

				Pagamento pagamento = this.repositorioArrecadacao.pesquisarPagamento(idPagamento);

				if(pagamento != null){
					transferirPagamentoParaHistorico(Collections.singletonList(pagamento));
					iteratorPagamentos.remove();
					pagamento = null;
				}

			}
		}

		/** Fim Pagamentos Classificados */
	}

	protected void gerarHistoricoEncerrarArrecadacaoConta(Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
					Integer idSetorComercial) throws ErroRepositorioException, ControladorException{

		/** Contas */
		// Variáveis para a paginação
		boolean flagTerminou = false;
		final int quantidadeRegistros = 100;
		int numeroIndice = 0;

		while(!flagTerminou){
			Collection<Integer> colecaoContas = repositorioArrecadacao
							.pesquisarContasDePagamentosClassificadosContaEPagamentosAnterioresContaClassificadosNoMes(
											anoMesReferenciaArrecadacao, idLocalidade, numeroIndice, quantidadeRegistros, idSetorComercial);

			if(colecaoContas == null || colecaoContas.size() < quantidadeRegistros){
				flagTerminou = true;
			}

			Iterator<Integer> iteratorContas = colecaoContas.iterator();
			while(iteratorContas.hasNext()){

				Integer idConta = iteratorContas.next();

				Conta conta = this.repositorioArrecadacao.pesquisarConta(idConta);

				if(conta != null){

					getControladorFaturamento()
									.transferirContasParaHistorico(Collections.singletonList(conta), anoMesReferenciaArrecadacao);

					getControladorFaturamento().atualizarIndicadorContaNoHistorico(Collections.singletonList(conta));

					iteratorContas.remove();
					conta = null;
				}

			}
		}
	}

	protected void gerarHistoricoParaEncerrarArrecadacaoGuiaPagamento(Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
					throws ErroRepositorioException, ControladorException{

		/** Guias de Pagamento */
		List colecaoGuiasPagamento = (List) repositorioArrecadacao
						.pesquisarGuiasPagamentoDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
										anoMesReferenciaArrecadacao, idLocalidade);

		if(colecaoGuiasPagamento != null && !colecaoGuiasPagamento.isEmpty()){
			int limiteSuperiorGuia;
			int limiteInferiorGuia;
			int limiteMaximoGuia = colecaoGuiasPagamento.size();
			int quantidadeMaximaPorColecaoGuia = 50;

			for(int i = 0; i < limiteMaximoGuia; i = i + quantidadeMaximaPorColecaoGuia){

				if(limiteMaximoGuia < quantidadeMaximaPorColecaoGuia){
					limiteInferiorGuia = 0;
					limiteSuperiorGuia = limiteMaximoGuia;
				}else{
					limiteInferiorGuia = i;
					limiteSuperiorGuia = i + quantidadeMaximaPorColecaoGuia;

					if(limiteSuperiorGuia > limiteMaximoGuia){
						limiteSuperiorGuia = limiteMaximoGuia;
					}
				}

				List colecaoGuiasTemporaria = new ArrayList();
				colecaoGuiasTemporaria.addAll(colecaoGuiasPagamento.subList(limiteInferiorGuia, limiteSuperiorGuia));

				if(colecaoGuiasTemporaria != null && !colecaoGuiasTemporaria.isEmpty()){
					transferirGuiaPagamentoParaHistorico(colecaoGuiasTemporaria);

					atualizarIndicadorGuiaPagamentoNoHistorico(colecaoGuiasTemporaria);
				}

				colecaoGuiasTemporaria = null;
			}

			colecaoGuiasPagamento = null;

		}
		/** Fim Guias de Pagamento */
	}

	protected void gerarHistoricoParaEncerrarArrecadacaoDebitoACobrar(Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
					throws ErroRepositorioException, ControladorException{

		// criar os histórico dos débitos a cobrar cancelados
		List debitosACobrar = (List) repositorioArrecadacao
						.pesquisarDebitosACobrarDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
										anoMesReferenciaArrecadacao, idLocalidade);

		if(debitosACobrar != null && !debitosACobrar.isEmpty()){
			int limiteSuperiorDebito;
			int limiteInferiorDebito;
			int limiteMaximoDebito = debitosACobrar.size();
			int quantidadeMaximaPorColecaoDebito = 50;

			for(int i = 0; i < limiteMaximoDebito; i = i + quantidadeMaximaPorColecaoDebito){

				if(limiteMaximoDebito < quantidadeMaximaPorColecaoDebito){
					limiteInferiorDebito = 0;
					limiteSuperiorDebito = limiteMaximoDebito;
				}else{
					limiteInferiorDebito = i;
					limiteSuperiorDebito = i + quantidadeMaximaPorColecaoDebito;

					if(limiteSuperiorDebito > limiteMaximoDebito){
						limiteSuperiorDebito = limiteMaximoDebito;
					}
				}

				List colecaoDebitosTemporaria = new ArrayList();
				colecaoDebitosTemporaria.addAll(debitosACobrar.subList(limiteInferiorDebito, limiteSuperiorDebito));

				if(colecaoDebitosTemporaria != null && !colecaoDebitosTemporaria.isEmpty()){
					getControladorFaturamento().transferirDebitosACobrarParaHistorico(colecaoDebitosTemporaria, Boolean.FALSE);
					getControladorFaturamento().atualizarIndicadorDebitoACobrarNoHistorico(colecaoDebitosTemporaria);
				}

				colecaoDebitosTemporaria = null;
			}
			debitosACobrar = null;
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection pesquisarPagamentoClienteConta(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria)
					throws ControladorException{

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoClienteConta(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					Pagamento pagamento = new Pagamento();

					// Id do Pagamento
					if(dadosPagamento[0] != null){
						pagamento.setId((Integer) dadosPagamento[0]);
					}

					Conta conta = null;

					// Id da Conta
					if(dadosPagamento[1] != null){
						conta = new Conta();
						conta.setId((Integer) dadosPagamento[1]);
					}

					// Ano Mês Referência da Conta
					if(dadosPagamento[2] != null){
						conta.setReferencia((Integer) dadosPagamento[2]);
					}

					// Valor da Água da Conta
					if(dadosPagamento[3] != null){
						conta.setValorAgua((BigDecimal) dadosPagamento[3]);
					}

					// Valor de Esgoto da Conta
					if(dadosPagamento[4] != null){
						conta.setValorEsgoto((BigDecimal) dadosPagamento[4]);
					}

					// Valor de Débitos
					if(dadosPagamento[5] != null){
						conta.setDebitos((BigDecimal) dadosPagamento[5]);
					}

					// Valor dos Créditos
					if(dadosPagamento[6] != null){
						conta.setValorCreditos((BigDecimal) dadosPagamento[6]);
					}

					pagamento.setConta(conta);

					// Data do Pagamento
					if(dadosPagamento[7] != null){
						pagamento.setDataPagamento((Date) dadosPagamento[7]);
					}

					// Ano Mês do Pagamento
					if(dadosPagamento[8] != null){
						pagamento.setAnoMesReferenciaPagamento((Integer) dadosPagamento[8]);
					}

					// Valor do Pagamento
					if(dadosPagamento[9] != null){
						pagamento.setValorPagamento((BigDecimal) dadosPagamento[9]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[10] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) dadosPagamento[10]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[11] != null){
						pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamento[11]);
					}

					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if(dadosPagamento[12] != null){
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior.setId((Integer) dadosPagamento[12]);
					}

					// Descrição da Situação Anterior do Pagamento
					if(dadosPagamento[13] != null){
						pagamentoSituacaoAnterior.setDescricaoAbreviada((String) dadosPagamento[13]);
					}

					pagamento.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if(dadosPagamento[14] != null){
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[14]);
						pagamento.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel
					if(dadosPagamento[15] != null){
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[15]);
						pagamento.setImovel(imovel);
					}

					// Aviso Bancario
					if(dadosPagamento[16] != null){
						setarAvisoBancarioDaConsulta((Integer) dadosPagamento[16], pagamento);
					}

					retorno.add(pagamento);

				}

			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	private void setarAvisoBancarioDaConsulta(Integer idAvisoBancarioBanco, Pagamento pagamento) throws ControladorException{

		FiltroAvisoBancario filtroAvisoBancario = new FiltroAvisoBancario();
		filtroAvisoBancario.adicionarParametro(new ParametroSimples(FiltroAvisoBancario.ID, idAvisoBancarioBanco));
		filtroAvisoBancario.adicionarCaminhoParaCarregamentoEntidade(FiltroAvisoBancario.ARRECADADOR);
		Collection<AvisoBancario> collAvisoBancario = this.getControladorUtil().pesquisar(filtroAvisoBancario,
						AvisoBancario.class.getName());
		if(collAvisoBancario != null && !collAvisoBancario.isEmpty()){
			pagamento.setAvisoBancario(collAvisoBancario.iterator().next());
		}
	}

	private void setarAvisoBancarioDaConsulta(Integer idAvisoBancarioBanco, PagamentoHistorico pagamento) throws ControladorException{

		FiltroAvisoBancario filtroAvisoBancario = new FiltroAvisoBancario();
		filtroAvisoBancario.adicionarParametro(new ParametroSimples(FiltroAvisoBancario.ID, idAvisoBancarioBanco));
		filtroAvisoBancario.adicionarCaminhoParaCarregamentoEntidade(FiltroAvisoBancario.ARRECADADOR);
		Collection<AvisoBancario> collAvisoBancario = this.getControladorUtil().pesquisar(filtroAvisoBancario,
						AvisoBancario.class.getName());
		if(collAvisoBancario != null && !collAvisoBancario.isEmpty()){
			pagamento.setAvisoBancario(collAvisoBancario.iterator().next());
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoClienteGuiaPagamento(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoClienteGuiaPagamento(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					Pagamento pagamento = new Pagamento();

					// Id do Pagamento
					if(dadosPagamento[0] != null){
						pagamento.setId((Integer) dadosPagamento[0]);
					}

					// Id do Cliente
					if(dadosPagamento[2] != null){
						Cliente cliente = new Cliente();
						cliente.setId((Integer) dadosPagamento[2]);
						pagamento.setCliente(cliente);
					}

					// Data do Pagamento
					if(dadosPagamento[3] != null){
						pagamento.setDataPagamento((Date) dadosPagamento[3]);
					}

					// Ano Mês do Pagamento
					if(dadosPagamento[4] != null){
						pagamento.setAnoMesReferenciaPagamento((Integer) dadosPagamento[4]);
					}

					DebitoTipo debitoTipoPagamento = null;

					// Id do Tipo de Débito do Pagamento
					if(dadosPagamento[5] != null){
						debitoTipoPagamento = new DebitoTipo();
						debitoTipoPagamento.setId((Integer) dadosPagamento[5]);
					}

					// Descrição do Tipo de Débito do Pagamento
					if(dadosPagamento[6] != null){
						debitoTipoPagamento.setDescricao((String) dadosPagamento[6]);
					}
					pagamento.setDebitoTipo(debitoTipoPagamento);

					// Valor do Pagamento
					if(dadosPagamento[7] != null){
						pagamento.setValorPagamento((BigDecimal) dadosPagamento[7]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[8] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) dadosPagamento[8]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[9] != null){
						pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamento[9]);
					}

					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if(dadosPagamento[10] != null){
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior.setId((Integer) dadosPagamento[10]);
					}

					// Descrição da Situação Anterior do Pagamento
					if(dadosPagamento[11] != null){
						pagamentoSituacaoAnterior.setDescricaoAbreviada((String) dadosPagamento[11]);
					}

					pagamento.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if(dadosPagamento[12] != null){
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[12]);
						pagamento.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel
					if(dadosPagamento[13] != null){
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[13]);
						pagamento.setImovel(imovel);
					}

					// Prestacao do Pagamento
					if(dadosPagamento[15] != null){
						pagamento.setNumeroPrestacao((Integer) dadosPagamento[15]);
					}

					// verifica se o Pagamento referencia uma Prestação de Guia em Histórico ou Não
					if(dadosPagamento[1] != null && dadosPagamento[15] != null){
						// Id da Guia de Pagamento

						FiltroGuiaPagamentoGeral filtroGuiaGeral = new FiltroGuiaPagamentoGeral();
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.GUIA_PAGAMENTO);
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.PRESTACOES_GUIA_PAGAMENTO);
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.PRESTACOES_HISTORICO_GUIA_PAGAMENTO);
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.GUIA_PAGAMENTO_HISTORICO);
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.PRESTACOES_HISTORICO_GUIA_PAGAMENTO_HISTORICO);
						filtroGuiaGeral.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoGeral.ID, ((Integer) dadosPagamento[1])));

						Collection<GuiaPagamentoGeral> colecaoGuiaPagamentoGeral = getControladorUtil().pesquisar(filtroGuiaGeral,
										GuiaPagamentoGeral.class.getName());
						for(GuiaPagamentoGeral guiaPagamentoGeral : colecaoGuiaPagamentoGeral){
							pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
						}
					}

					// Aviso Bancario
					if(dadosPagamento[16] != null){
						setarAvisoBancarioDaConsulta((Integer) dadosPagamento[16], pagamento);
					}

					retorno.add(pagamento);

				}

			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoClienteDebitoACobrar(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoClienteDebitoACobrar(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					Pagamento pagamento = new Pagamento();

					// Id do Pagamento
					if(dadosPagamento[0] != null){
						pagamento.setId((Integer) dadosPagamento[0]);
					}

					DebitoACobrar debitoACobrar = null;

					// Id do Imóvel do Pagamento
					if(dadosPagamento[1] != null){
						Imovel imovelPagamento = new Imovel();
						imovelPagamento.setId((Integer) dadosPagamento[1]);
						pagamento.setImovel(imovelPagamento);
					}

					// Id do Débito a Cobrar
					if(dadosPagamento[2] != null){
						debitoACobrar = new DebitoACobrar();
						debitoACobrar.setId((Integer) dadosPagamento[2]);
					}

					// Valor do Débito
					if(dadosPagamento[3] != null){
						debitoACobrar.setValorDebito((BigDecimal) dadosPagamento[3]);
					}

					// Número de Prestações Cobradas
					if(dadosPagamento[4] != null){
						debitoACobrar.setNumeroPrestacaoCobradas((Short) dadosPagamento[4]);
					}

					// Número de Prestações Débito
					if(dadosPagamento[5] != null){
						debitoACobrar.setNumeroPrestacaoDebito((Short) dadosPagamento[5]);
					}

					// Data do Pagamento
					if(dadosPagamento[6] != null){
						pagamento.setDataPagamento((Date) dadosPagamento[6]);
					}

					// Ano Mês do Pagamento
					if(dadosPagamento[7] != null){
						pagamento.setAnoMesReferenciaPagamento((Integer) dadosPagamento[7]);
					}

					DebitoTipo debitoTipoDebito = null;

					// Id do Tipo de Débito do Débito a Cobrar
					if(dadosPagamento[8] != null){
						debitoTipoDebito = new DebitoTipo();
						debitoTipoDebito.setId((Integer) dadosPagamento[8]);
					}

					// Descrição do Tipo de Débito do Débito a Cobrar
					if(dadosPagamento[9] != null){
						debitoTipoDebito.setDescricao((String) dadosPagamento[9]);
					}

					debitoACobrar.setDebitoTipo(debitoTipoDebito);

					DebitoTipo debitoTipoPagamento = null;

					// Id do Tipo de Débito do Pagamento
					if(dadosPagamento[10] != null){
						debitoTipoPagamento = new DebitoTipo();
						debitoTipoPagamento.setId((Integer) dadosPagamento[10]);
					}

					// Descrição do Tipo de Débito do Pagamento
					if(dadosPagamento[11] != null){
						debitoTipoPagamento.setDescricao((String) dadosPagamento[11]);
					}

					pagamento.setDebitoTipo(debitoTipoPagamento);

					// Valor do Pagamento
					if(dadosPagamento[12] != null){
						pagamento.setValorPagamento((BigDecimal) dadosPagamento[12]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[13] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[14] != null){
						pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamento[14]);
					}

					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if(dadosPagamento[15] != null){
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior.setId((Integer) dadosPagamento[15]);
					}

					// Descrição da Situação Anterior do Pagamento
					if(dadosPagamento[16] != null){
						pagamentoSituacaoAnterior.setDescricaoAbreviada((String) dadosPagamento[16]);
					}

					pagamento.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if(dadosPagamento[17] != null){
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[17]);
						pagamento.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel do Débito a Cobrar
					if(dadosPagamento[18] != null){
						Imovel imovelDebito = new Imovel();
						imovelDebito.setId((Integer) dadosPagamento[18]);
						debitoACobrar.setImovel(imovelDebito);
					}

					pagamento.setDebitoACobrar(debitoACobrar);

					// Aviso Bancario
					if(dadosPagamento[19] != null){
						setarAvisoBancarioDaConsulta((Integer) dadosPagamento[19], pagamento);
					}

					retorno.add(pagamento);

				}

			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoLocalidade(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoLocalidade(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancario(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoAvisoBancario(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadador(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoMovimentoArrecadador(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * obtem colecao com dados diarios da arrecadacao
	 * 
	 * @author Fernanda Paiva
	 * @date 09/06/2006
	 * @param anoMesReferencia
	 *            ,
	 *            id
	 * @return Uma Colecao
	 * @throws ControladorException
	 */
	public Collection consultarDadosDiarios(int anoMesReferencia, int id, String descricao, int idElo) throws ControladorException{

		try{
			Collection colecaoDadosDiarios = this.repositorioArrecadacao.consultarDadosDiarios(anoMesReferencia, id, descricao, idElo);

			Collection dadosDiarios = new ArrayList();
			Iterator iteratorColecaoArrecadacaoDadosDiarios = colecaoDadosDiarios.iterator();
			while(iteratorColecaoArrecadacaoDadosDiarios.hasNext()){

				// Obtém os dados do crédito realizado
				Object[] guiaArray = (Object[]) iteratorColecaoArrecadacaoDadosDiarios.next();

				ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();
				if(descricao == "VALORESELO" || descricao == "VALORESLOCALIDADE" || descricao == "VALORESGERENCIA"
								|| descricao == "VALORES" || descricao == "VALORESARRECADADOR" || descricao == "VALORESPERFIL"
								|| descricao == "VALORESCATEGORIA" || descricao == "VALORESDOCUMENTO"){
					if((Date) guiaArray[0] != null){
						// Data Pagamento
						arrecadacaoDadosDiarios.setDataPagamento((Date) guiaArray[0]);
					}
					if((BigDecimal) guiaArray[1] != null){
						// Valor Pagamento
						arrecadacaoDadosDiarios.setValorPagamentos((BigDecimal) guiaArray[1]);
					}

					if((Integer) guiaArray[2] != null){
						// Ano Mês referencia
						arrecadacaoDadosDiarios.setAnoMesReferenciaArrecadacao((Integer) guiaArray[2]);
					}
				}else if(descricao == "ARRECADADOR"){
					if((String) guiaArray[0] != null){

						// Nome do Cliente Arrecadador
						Arrecadador arrecadador = new Arrecadador();
						arrecadador.setId((Integer) guiaArray[3]);
						Cliente cliente = new Cliente();
						cliente.setNome((String) guiaArray[0]);
						arrecadador.setCliente(cliente);
						arrecadacaoDadosDiarios.setArrecadador(arrecadador);
						arrecadacaoDadosDiarios.setArrecadador(arrecadador);
					}
					if((BigDecimal) guiaArray[1] != null){
						// Valor Total
						arrecadacaoDadosDiarios.setValorPagamentos((BigDecimal) guiaArray[1]);
					}
					if((Integer) guiaArray[2] != null){
						// Ano Mês referencia
						arrecadacaoDadosDiarios.setAnoMesReferenciaArrecadacao((Integer) guiaArray[2]);
					}
				}else if(descricao == "VALORESPORDIA"){
					if((Date) guiaArray[0] != null){
						// Data Pagamento
						arrecadacaoDadosDiarios.setDataPagamento((Date) guiaArray[0]);
					}
					if((BigDecimal) guiaArray[1] != null){
						// Valor Pagamento
						arrecadacaoDadosDiarios.setValorPagamentos((BigDecimal) guiaArray[1]);
					}

					if((Integer) guiaArray[2] != null){
						// Ano Mês referencia
						arrecadacaoDadosDiarios.setAnoMesReferenciaArrecadacao((Integer) guiaArray[2]);
					}

				}else{
					if((Integer) guiaArray[0] != null){
						// ID da localidade
						Localidade localidade = new Localidade();
						localidade.setId((Integer) guiaArray[0]);
						Localidade localidadeElo = new Localidade();
						localidadeElo.setDescricao((String) guiaArray[3]);
						localidadeElo.setId((Integer) guiaArray[4]);
						localidade.setLocalidade(localidadeElo);
						arrecadacaoDadosDiarios.setLocalidade(localidade);
					}
					if((BigDecimal) guiaArray[1] != null){
						// Ano Mês referencia
						arrecadacaoDadosDiarios.setValorPagamentos((BigDecimal) guiaArray[1]);
					}
					if((Integer) guiaArray[2] != null){
						// ID da localidade
						GerenciaRegional gerenciaRegional = new GerenciaRegional();
						gerenciaRegional.setId((Integer) guiaArray[2]);
						arrecadacaoDadosDiarios.setGerenciaRegional(gerenciaRegional);
					}
					if((Integer) guiaArray[5] != null){
						// Ano Mês referencia
						arrecadacaoDadosDiarios.setAnoMesReferenciaArrecadacao((Integer) guiaArray[5]);
					}
				}
				dadosDiarios.add(arrecadacaoDadosDiarios);
			}
			return dadosDiarios;

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * @param avisoBancarioHelper
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarAvisoBancarioAbertoFechadoParaPaginacao(AvisoBancarioHelper avisoBancarioHelper, Integer numeroPagina)
					throws ControladorException{

		try{
			Collection colecaoAvisosBancario = this.repositorioArrecadacao.filtrarAvisoBancarioAbertoFechado(avisoBancarioHelper);

			AvisoBancarioHelper avisoBancarioHelperNovo = null;
			Iterator iterator = colecaoAvisosBancario.iterator();

			Collection colecaoAvisosBancarioHelperFinal = new ArrayList();

			while(iterator.hasNext()){

				Object[] dadosAvisoBancario = (Object[]) iterator.next();
				AvisoBancario avisoBancario = new AvisoBancario();

				avisoBancarioHelperNovo = new AvisoBancarioHelper();

				avisoBancarioHelperNovo.setTipoAviso(avisoBancarioHelper.getTipoAviso());

				Arrecadador arrecadador = new Arrecadador();
				arrecadador.setId((Integer) dadosAvisoBancario[0]);
				avisoBancario.setArrecadador(arrecadador);

				avisoBancario.setDataLancamento((Date) dadosAvisoBancario[1]);

				avisoBancario.setNumeroSequencial((Short) dadosAvisoBancario[2]);

				avisoBancario.setIndicadorCreditoDebito((Short) dadosAvisoBancario[3]);

				avisoBancario.setDataPrevista((Date) dadosAvisoBancario[4]);

				avisoBancario.setDataRealizada((Date) dadosAvisoBancario[5]);

				avisoBancario.setValorRealizado((BigDecimal) dadosAvisoBancario[6]);

				avisoBancario.setValorArrecadacaoCalculado((BigDecimal) dadosAvisoBancario[7]);

				avisoBancario.setId((Integer) dadosAvisoBancario[15]);

				avisoBancario.setNumeroDocumento((Integer) dadosAvisoBancario[16]);

				ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
				arrecadadorMovimento.setNumeroSequencialArquivo((Integer) dadosAvisoBancario[17]);
				avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);

				avisoBancarioHelperNovo.setAvisoBancario(avisoBancario);

				BigDecimal valorAcertos = BigDecimal.ZERO;
				BigDecimal valorCalculado = BigDecimal.ZERO;
				BigDecimal valorInformado = BigDecimal.ZERO;
				BigDecimal valorDiferenca = BigDecimal.ZERO;

				if(avisoBancario.getIndicadorCreditoDebito().equals(AvisoBancario.INDICADOR_CREDITO)){

					if(dadosAvisoBancario[7] != null){

						// Valor da Arrecadacao Calculado
						valorCalculado = (BigDecimal) dadosAvisoBancario[7];
					}

					if(dadosAvisoBancario[8] != null){

						// Valor da Arrecadacao Informado
						valorInformado = (BigDecimal) dadosAvisoBancario[8];
					}

					if(dadosAvisoBancario[9] != null){

						// Valor dos Acertos Crédito da Arrecadacao
						valorAcertos = valorAcertos.add((BigDecimal) dadosAvisoBancario[9]);
					}

					if(dadosAvisoBancario[10] != null){

						// Valor dos Acertos Débito da Arrecadacao
						valorAcertos = valorAcertos.subtract((BigDecimal) dadosAvisoBancario[10]);
					}

					// Valor Diferença
					valorDiferenca = valorInformado.subtract(valorCalculado.add(valorAcertos));
				}else{

					if(dadosAvisoBancario[11] != null){

						// Valor da Devolucao Calculado
						valorCalculado = (BigDecimal) dadosAvisoBancario[11];
					}

					if(dadosAvisoBancario[12] != null){

						// Valor da Devolucao Informado
						valorInformado = (BigDecimal) dadosAvisoBancario[12];
					}

					if(dadosAvisoBancario[13] != null){

						// Valor dos Acertos Crédito da Devolucao
						valorAcertos = valorAcertos.add((BigDecimal) dadosAvisoBancario[13]);
					}

					if(dadosAvisoBancario[14] != null){

						// Valor dos Acertos Crédito da Devolucao
						valorAcertos = valorAcertos.subtract((BigDecimal) dadosAvisoBancario[14]);
					}
				}

				// Situação do Aviso
				if(valorDiferenca.compareTo(BigDecimal.ZERO) != 0){

					avisoBancarioHelperNovo.setSituacao(ConstantesSistema.ABERTO);

				}else{

					avisoBancarioHelperNovo.setSituacao(ConstantesSistema.FECHADO);
				}

				if(avisoBancarioHelper.getIndicadorAbertoFechado() == null
								|| avisoBancarioHelper.getIndicadorAbertoFechado().equals(ConstantesSistema.AVISO_ABERTO_FECHADO)){

					avisoBancarioHelperNovo.setIndicadorAbertoFechado(ConstantesSistema.AVISO_ABERTO_FECHADO);
					colecaoAvisosBancarioHelperFinal.add(avisoBancarioHelperNovo);
				}else{

					if(avisoBancarioHelper.getIndicadorAbertoFechado().equals(ConstantesSistema.AVISO_ABERTO)
									&& avisoBancarioHelperNovo.getSituacao().equals(ConstantesSistema.ABERTO)){

						avisoBancarioHelperNovo.setIndicadorAbertoFechado(ConstantesSistema.AVISO_ABERTO);
						colecaoAvisosBancarioHelperFinal.add(avisoBancarioHelperNovo);
					}else if(avisoBancarioHelper.getIndicadorAbertoFechado().equals(ConstantesSistema.AVISO_FECHADO)
									&& avisoBancarioHelperNovo.getSituacao().equals(ConstantesSistema.FECHADO)){

						avisoBancarioHelperNovo.setIndicadorAbertoFechado(ConstantesSistema.AVISO_FECHADO);
						colecaoAvisosBancarioHelperFinal.add(avisoBancarioHelperNovo);
					}
				}
			}

			Collection colecao = null;
			if(numeroPagina > 0){

				if(colecaoAvisosBancarioHelperFinal != null && !colecaoAvisosBancarioHelperFinal.isEmpty()){

					int posicao = 0;

					colecao = new ArrayList();

					Iterator iteratorColecaoAvisosBancarioHelperFinal = colecaoAvisosBancarioHelperFinal.iterator();
					AvisoBancarioHelper avisoBancarioHelper2 = null;
					while(iteratorColecaoAvisosBancarioHelperFinal.hasNext()){
						avisoBancarioHelper2 = (AvisoBancarioHelper) iteratorColecaoAvisosBancarioHelperFinal.next();

						if(posicao >= (numeroPagina * 10)){
							colecao.add(avisoBancarioHelper2);
						}
						posicao++;
					}
				}
			}else{
				colecao = colecaoAvisosBancarioHelperFinal;
			}

			return colecao;

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 21/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoCliente(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					Pagamento pagamento = new Pagamento();

					// Id do Pagamento
					if(dadosPagamento[0] != null){
						pagamento.setId((Integer) dadosPagamento[0]);
					}

					// Id do Imóvel
					if(dadosPagamento[1] != null){
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[1]);
						pagamento.setImovel(imovel);
					}

					// Id do Cliente
					if(dadosPagamento[2] != null){
						Cliente cliente = new Cliente();
						cliente.setId((Integer) dadosPagamento[2]);
						pagamento.setCliente(cliente);
					}

					Arrecadador arrecadador = null;

					// Código Agente do Arrecadador
					if(dadosPagamento[3] != null){
						arrecadador = new Arrecadador();
						arrecadador.setCodigoAgente((Short) dadosPagamento[3]);
					}

					AvisoBancario avisoBancario = new AvisoBancario();

					// Data do Lançamento do Aviso Bancário
					if(dadosPagamento[4] != null){
						avisoBancario.setDataLancamento((Date) dadosPagamento[4]);
					}

					// Número Sequencial do Aviso Bancário
					if(dadosPagamento[5] != null){
						avisoBancario.setNumeroSequencial((Short) dadosPagamento[5]);
					}

					avisoBancario.setArrecadador(arrecadador);
					pagamento.setAvisoBancario(avisoBancario);

					DocumentoTipo documentoTipo = null;

					// Id do Tipo de Documento
					if(dadosPagamento[6] != null){
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[6]);
					}

					// Descrição do Tipo de Documento
					if(dadosPagamento[7] != null){
						documentoTipo.setDescricaoDocumentoTipo((String) dadosPagamento[7]);
					}

					pagamento.setDocumentoTipo(documentoTipo);

					// Valor do Pagamento
					if(dadosPagamento[8] != null){
						pagamento.setValorPagamento((BigDecimal) dadosPagamento[8]);
					}

					// Data do Pagamento
					if(dadosPagamento[9] != null){
						pagamento.setDataPagamento((Date) dadosPagamento[9]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[10] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) dadosPagamento[10]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[11] != null){
						pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamento[11]);
					}

					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if(dadosPagamento[12] != null){
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior.setId((Integer) dadosPagamento[12]);
					}

					// Descrição da Situação Anterior do Pagamento
					if(dadosPagamento[13] != null){
						pagamentoSituacaoAnterior.setDescricaoAbreviada((String) dadosPagamento[13]);
					}

					// Numero Prestação
					if(dadosPagamento[14] != null){
						pagamento.setNumeroPrestacao((Integer) dadosPagamento[14]);
					}

					pagamento.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Aviso Bancario
					if(dadosPagamento[15] != null){
						setarAvisoBancarioDaConsulta((Integer) dadosPagamento[15], pagamento);
					}

					retorno.add(pagamento);

				}

			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 21/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoClienteCount(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection qtdes = null;
		int retorno = 0;

		try{
			qtdes = repositorioArrecadacao.pesquisarPagamentoClienteCount(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);

			if(qtdes != null && !qtdes.isEmpty()){

				Iterator qtdesIterator = qtdes.iterator();

				while(qtdesIterator.hasNext()){
					Integer qtde = (Integer) qtdesIterator.next();
					retorno = retorno + qtde;
				}

			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Vivianne Sousa
	 * @date 21/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancarioParaPaginacao(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoAvisoBancarioParaPaginacao(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina,
							codigoSetorComercialInicial, codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores,
							idsCategoria);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Vivianne Sousa
	 * @date 21/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoAvisoBancarioCount(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoAvisoBancarioCount(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Vivianne Sousa
	 * @date 22/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoImovelCount(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoImovelCount(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Vivianne Sousa
	 * @date 22/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoImovelParaPaginacao(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoImovelParaPaginacao(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/2006
	 * @param FiltroPagamento
	 * @return Collection
	 * @throws ControladorException
	 */

	public Collection pesquisarPagamentoImovelRelatorio(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria)
					throws ControladorException{

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoImovelRelatorio(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if(dadosPagamento[1] != null){ // 1,2
						pagamentoRelatorioHelper.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if(dadosPagamento[3] != null){ // 3,4
						pagamentoRelatorioHelper.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if(dadosPagamento[5] != null){ // 5
						pagamentoRelatorioHelper.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if(dadosPagamento[6] != null){ // 6,7
						pagamentoRelatorioHelper.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if(dadosPagamento[8] != null){ // 8
						pagamentoRelatorioHelper.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if(dadosPagamento[9] != null){ // 9
						pagamentoRelatorioHelper.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if(dadosPagamento[10] != null){ // 10
						pagamentoRelatorioHelper.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if(dadosPagamento[11] != null){ // 11
						pagamentoRelatorioHelper.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if(dadosPagamento[12] != null){ // 12
						pagamentoRelatorioHelper.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if(dadosPagamento[13] != null){ // 13
						pagamentoRelatorioHelper.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if(dadosPagamento[14] != null){ // 14
						pagamentoRelatorioHelper.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if(dadosPagamento[15] != null){ // 15
						pagamentoRelatorioHelper.setDebitos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if(dadosPagamento[16] != null){ // 16
						pagamentoRelatorioHelper.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if(dadosPagamento[17] != null){ // 17
						pagamentoRelatorioHelper.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if(dadosPagamento[18] != null){ // 18
						pagamentoRelatorioHelper.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if(dadosPagamento[19] != null){ // 19
						pagamentoRelatorioHelper.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if(dadosPagamento[20] != null){ // 20
						pagamentoRelatorioHelper.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[21] != null){ // 21
						pagamentoRelatorioHelper.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[22] != null){ // 22
						pagamentoRelatorioHelper.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if(dadosPagamento[23] != null){ // 23
						pagamentoRelatorioHelper.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					// Data vencimento
					if(dadosPagamento[24] != null){
						pagamentoRelatorioHelper.setDataVencimento((Date) dadosPagamento[24]);
					}

					// id da guia
					if(dadosPagamento[25] != null){
						pagamentoRelatorioHelper.setIdGuiaPagamento((Integer) dadosPagamento[25]);
					}

					// numero da prestacao
					if(dadosPagamento[26] != null){
						pagamentoRelatorioHelper.setNumeroPrestacao((Integer) dadosPagamento[26]);
					}

					// id debito a cobrar
					if(dadosPagamento[27] != null){
						pagamentoRelatorioHelper.setIdDebitoACobrar((Integer) dadosPagamento[27]);
					}

					if(dadosPagamento[28] != null){
						pagamentoRelatorioHelper.setCodigoSetorComercial((Integer) dadosPagamento[28]);
					}

					if(dadosPagamento[29] != null){
						pagamentoRelatorioHelper.setIdConta((Integer) dadosPagamento[29]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/2006
	 * @param FiltroPagamento
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarPagamentoImovelAmbosRelatorio(String idImovel) throws ControladorException{

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoImovelAmbosRelatorio(idImovel);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if(dadosPagamento[1] != null){ // 1,2
						pagamentoRelatorioHelper.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if(dadosPagamento[3] != null){ // 3,4
						pagamentoRelatorioHelper.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if(dadosPagamento[5] != null){ // 5
						pagamentoRelatorioHelper.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if(dadosPagamento[6] != null){ // 6,7
						pagamentoRelatorioHelper.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if(dadosPagamento[8] != null){ // 8
						pagamentoRelatorioHelper.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if(dadosPagamento[9] != null){ // 9
						pagamentoRelatorioHelper.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if(dadosPagamento[10] != null){ // 10
						pagamentoRelatorioHelper.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if(dadosPagamento[11] != null){ // 11
						pagamentoRelatorioHelper.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if(dadosPagamento[12] != null){ // 12
						pagamentoRelatorioHelper.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if(dadosPagamento[13] != null){ // 13
						pagamentoRelatorioHelper.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if(dadosPagamento[14] != null){ // 14
						pagamentoRelatorioHelper.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if(dadosPagamento[15] != null){ // 15
						pagamentoRelatorioHelper.setValorCreditos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if(dadosPagamento[16] != null){ // 16
						pagamentoRelatorioHelper.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if(dadosPagamento[17] != null){ // 17
						pagamentoRelatorioHelper.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if(dadosPagamento[18] != null){ // 18
						pagamentoRelatorioHelper.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if(dadosPagamento[19] != null){ // 19
						pagamentoRelatorioHelper.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if(dadosPagamento[20] != null){ // 20
						pagamentoRelatorioHelper.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[21] != null){ // 21
						pagamentoRelatorioHelper.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[22] != null){ // 22
						pagamentoRelatorioHelper.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if(dadosPagamento[23] != null){ // 23
						pagamentoRelatorioHelper.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					// Descrição do Tipo de Documento
					if(dadosPagamento[24] != null){ // 24
						pagamentoRelatorioHelper.setDescricaoDocumentoTipo((String) dadosPagamento[24]);
					}

					// Descrição da Situação Anterior do Pagamento
					if(dadosPagamento[25] != null){ // 25
						pagamentoRelatorioHelper.setDescricaoSituacaoPagamentoAnterior((String) dadosPagamento[25]);
					}

					// Data vencimento conta historico ou nao
					if(dadosPagamento[26] != null){
						pagamentoRelatorioHelper.setDataVencimento((Date) dadosPagamento[26]);
					}

					// id da guia
					if(dadosPagamento[27] != null){
						pagamentoRelatorioHelper.setIdGuiaPagamento((Integer) dadosPagamento[27]);
					}

					// numero da prestacao
					if(dadosPagamento[28] != null){
						pagamentoRelatorioHelper.setNumeroPrestacao((Integer) dadosPagamento[28]);
					}

					// dataVencimentoGuia historico ou nao
					if(dadosPagamento[29] != null){
						pagamentoRelatorioHelper.setDataVencimento((Date) dadosPagamento[29]);
					}

					// id do debitoACobrar historico ou nao
					if(dadosPagamento[30] != null){
						pagamentoRelatorioHelper.setIdDebitoACobrar((Integer) dadosPagamento[30]);
					}else{
						if(dadosPagamento[31] != null){
							pagamentoRelatorioHelper.setIdDebitoACobrar((Integer) dadosPagamento[31]);
						}
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);
				}

			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * Este caso de uso cria um sql que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/2006
	 * @param FiltroPagamento
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarPagamentoClienteRelatorio(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String indicadorTotalizarPorDataPagamento, Collection<Integer> idsArrecadadores, String[] idsCategoria)
					throws ControladorException{

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoClienteRelatorio(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if(dadosPagamento[1] != null){ // 1,2
						pagamentoRelatorioHelper.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if(dadosPagamento[3] != null){ // 3,4
						pagamentoRelatorioHelper.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if(dadosPagamento[5] != null){ // 5
						pagamentoRelatorioHelper.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if(dadosPagamento[6] != null){ // 6,7
						pagamentoRelatorioHelper.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if(dadosPagamento[8] != null){ // 8
						pagamentoRelatorioHelper.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if(dadosPagamento[9] != null){ // 9
						pagamentoRelatorioHelper.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if(dadosPagamento[10] != null){ // 10
						pagamentoRelatorioHelper.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if(dadosPagamento[11] != null){ // 11
						pagamentoRelatorioHelper.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor do Documento
					if(dadosPagamento[12] != null){ // 12
						pagamentoRelatorioHelper.setValorDocumento((BigDecimal) dadosPagamento[12]);
					}

					// Valor do Pagamento
					if(dadosPagamento[13] != null){ // 13
						pagamentoRelatorioHelper.setValorPagamento((BigDecimal) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[14] != null){ // 14
						pagamentoRelatorioHelper.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[14]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[15] != null){ // 15
						pagamentoRelatorioHelper.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[15]);
					}

					// Id do Tipo de Documento
					if(dadosPagamento[16] != null){ // 16
						pagamentoRelatorioHelper.setIdDocumentoTipo((Integer) dadosPagamento[16]);
					}

					if(dadosPagamento[17] != null){
						pagamentoRelatorioHelper.setCodigoSetorComercial((Integer) dadosPagamento[17]);
					}

					if(dadosPagamento[18] != null){
						pagamentoRelatorioHelper.setIdConta((Integer) dadosPagamento[18]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */

	public Collection pesquisarPagamentoAvisoBancarioRelatorio(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoAvisoBancarioRelatorio(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if(dadosPagamento[1] != null){ // 1,2
						pagamentoRelatorioHelper.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if(dadosPagamento[3] != null){ // 3,4
						pagamentoRelatorioHelper.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if(dadosPagamento[5] != null){ // 5
						pagamentoRelatorioHelper.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if(dadosPagamento[6] != null){ // 6,7
						pagamentoRelatorioHelper.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if(dadosPagamento[8] != null){ // 8
						pagamentoRelatorioHelper.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if(dadosPagamento[9] != null){ // 9
						pagamentoRelatorioHelper.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if(dadosPagamento[10] != null){ // 10
						pagamentoRelatorioHelper.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if(dadosPagamento[11] != null){ // 11
						pagamentoRelatorioHelper.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if(dadosPagamento[12] != null){ // 12
						pagamentoRelatorioHelper.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if(dadosPagamento[13] != null){ // 13
						pagamentoRelatorioHelper.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if(dadosPagamento[14] != null){ // 14
						pagamentoRelatorioHelper.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if(dadosPagamento[15] != null){ // 15
						pagamentoRelatorioHelper.setValorCreditos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if(dadosPagamento[16] != null){ // 16
						pagamentoRelatorioHelper.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if(dadosPagamento[17] != null){ // 17
						pagamentoRelatorioHelper.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if(dadosPagamento[18] != null){ // 18
						pagamentoRelatorioHelper.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if(dadosPagamento[19] != null){ // 19
						pagamentoRelatorioHelper.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if(dadosPagamento[20] != null){ // 20
						pagamentoRelatorioHelper.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[21] != null){ // 21
						pagamentoRelatorioHelper.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[22] != null){ // 22
						pagamentoRelatorioHelper.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if(dadosPagamento[23] != null){ // 23
						pagamentoRelatorioHelper.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					if(dadosPagamento[24] != null){
						pagamentoRelatorioHelper.setCodigoSetorComercial((Integer) dadosPagamento[24]);
					}

					if(dadosPagamento[25] != null){
						pagamentoRelatorioHelper.setIdConta((Integer) dadosPagamento[25]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadadorRelatorio(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoMovimentoArrecadadorRelatorio(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if(dadosPagamento[1] != null){ // 1,2
						pagamentoRelatorioHelper.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if(dadosPagamento[3] != null){ // 3,4
						pagamentoRelatorioHelper.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if(dadosPagamento[5] != null){ // 5
						pagamentoRelatorioHelper.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if(dadosPagamento[6] != null){ // 6,7
						pagamentoRelatorioHelper.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if(dadosPagamento[8] != null){ // 8
						pagamentoRelatorioHelper.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if(dadosPagamento[9] != null){ // 9
						pagamentoRelatorioHelper.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if(dadosPagamento[10] != null){ // 10
						pagamentoRelatorioHelper.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if(dadosPagamento[11] != null){ // 11
						pagamentoRelatorioHelper.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if(dadosPagamento[12] != null){ // 12
						pagamentoRelatorioHelper.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if(dadosPagamento[13] != null){ // 13
						pagamentoRelatorioHelper.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if(dadosPagamento[14] != null){ // 14
						pagamentoRelatorioHelper.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if(dadosPagamento[15] != null){ // 15
						pagamentoRelatorioHelper.setDebitos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if(dadosPagamento[16] != null){ // 16
						pagamentoRelatorioHelper.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if(dadosPagamento[17] != null){ // 17
						pagamentoRelatorioHelper.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if(dadosPagamento[18] != null){ // 18
						pagamentoRelatorioHelper.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if(dadosPagamento[19] != null){ // 19
						pagamentoRelatorioHelper.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if(dadosPagamento[20] != null){ // 20
						pagamentoRelatorioHelper.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[21] != null){ // 21
						pagamentoRelatorioHelper.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[22] != null){ // 22
						pagamentoRelatorioHelper.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if(dadosPagamento[23] != null){ // 23
						pagamentoRelatorioHelper.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					if(dadosPagamento[24] != null){
						pagamentoRelatorioHelper.setCodigoSetorComercial((Integer) dadosPagamento[24]);
					}

					if(dadosPagamento[25] != null){
						pagamentoRelatorioHelper.setIdConta((Integer) dadosPagamento[25]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/2006
	 * @author Saulo Lima
	 * @date 08/01/2009
	 *       Nova forma de preencher o PagamentoRelatorioHelper e acréscimo do Generics nas coleções
	 * @return Collection<PagamentoRelatorioHelper>
	 * @throws ControladorException
	 */
	public Collection<PagamentoRelatorioHelper> pesquisarPagamentoLocalidadeRelatorio(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection<Object> colecaoDadosPagamento = null;
		Collection<PagamentoRelatorioHelper> colecaoPagamentoHelper = new ArrayList();

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoLocalidadeRelatorio(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Iterator<Object> colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if(dadosPagamento[1] != null){ // 1,2
						pagamentoRelatorioHelper.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if(dadosPagamento[3] != null){ // 3,4
						pagamentoRelatorioHelper.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if(dadosPagamento[5] != null){ // 5
						pagamentoRelatorioHelper.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if(dadosPagamento[6] != null){ // 6,7
						pagamentoRelatorioHelper.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if(dadosPagamento[8] != null){ // 8
						pagamentoRelatorioHelper.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if(dadosPagamento[9] != null){ // 9
						pagamentoRelatorioHelper.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if(dadosPagamento[10] != null){ // 10
						pagamentoRelatorioHelper.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if(dadosPagamento[11] != null){ // 11
						pagamentoRelatorioHelper.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor do Pagamento
					if(dadosPagamento[12] != null){ // 12
						pagamentoRelatorioHelper.setValorPagamento((BigDecimal) dadosPagamento[12]);
					}

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[13] != null){ // 13
						pagamentoRelatorioHelper.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[14] != null){ // 14
						pagamentoRelatorioHelper.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[14]);
					}

					// Id do Tipo de Documento
					if(dadosPagamento[15] != null){ // 15
						pagamentoRelatorioHelper.setIdDocumentoTipo((Integer) dadosPagamento[15]);
					}

					// Id do Debito A Cobrar
					if(dadosPagamento[16] != null){ // 16
						pagamentoRelatorioHelper.setIdDebitoACobrar((Integer) dadosPagamento[16]);
					}

					// Id da Guia de Pagamento
					if(dadosPagamento[17] != null){ // 17
						pagamentoRelatorioHelper.setIdGuiaPagamento((Integer) dadosPagamento[17]);
					}

					// Número da Prestação da Guia de Pagamento
					if(dadosPagamento[18] != null){ // 18
						pagamentoRelatorioHelper.setNumeroPrestacaoGuia((Integer) dadosPagamento[18]);
					}

					if(dadosPagamento[19] != null){
						pagamentoRelatorioHelper.setCodigoSetorComercial((Integer) dadosPagamento[19]);
					}

					if(dadosPagamento[20] != null){
						pagamentoRelatorioHelper.setIdConta((Integer) dadosPagamento[20]);
					}

					Integer idDocumentoTipo = pagamentoRelatorioHelper.getIdDocumentoTipo();
					if(idDocumentoTipo != null){

						// Pagamentos de Conta
						if(idDocumentoTipo.intValue() == DocumentoTipo.CONTA){

							FiltroConta filtroConta = new FiltroConta();
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, pagamentoRelatorioHelper
											.getIdImovel()));
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, pagamentoRelatorioHelper
											.getAnoMesReferenciaPagamento()));
							Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

							Conta conta = null;
							if(colecaoConta != null && !colecaoConta.isEmpty()){
								conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

								pagamentoRelatorioHelper.setValorAgua(conta.getValorAgua());
								pagamentoRelatorioHelper.setValorEsgoto(conta.getValorEsgoto());
								pagamentoRelatorioHelper.setDebitos(conta.getDebitos());
								pagamentoRelatorioHelper.setValorCreditos(conta.getValorCreditos());
								pagamentoRelatorioHelper.setValorImpostos(conta.getValorImposto());
							}

							if(conta == null){
								FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
								filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.IMOVEL_ID,
												pagamentoRelatorioHelper.getIdImovel()));
								filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ANO_MES_REFERENCIA,
												pagamentoRelatorioHelper.getAnoMesReferenciaPagamento()));
								Collection<ContaHistorico> colecaoContaHistorico = this.getControladorUtil().pesquisar(
												filtroContaHistorico, ContaHistorico.class.getName());

								ContaHistorico contaHistorico = null;
								if(colecaoContaHistorico != null && !colecaoContaHistorico.isEmpty()){
									contaHistorico = (ContaHistorico) Util.retonarObjetoDeColecao(colecaoContaHistorico);

									pagamentoRelatorioHelper.setValorAgua(contaHistorico.getValorAgua());
									pagamentoRelatorioHelper.setValorEsgoto(contaHistorico.getValorEsgoto());
									pagamentoRelatorioHelper.setDebitos(contaHistorico.getValorDebitos());
									pagamentoRelatorioHelper.setValorCreditos(contaHistorico.getValorCreditos());
									pagamentoRelatorioHelper.setValorImpostos(contaHistorico.getValorImposto());
								}
							}

							// Pagamentos de Debito A Cobrar
						}else if(idDocumentoTipo.intValue() == DocumentoTipo.DEBITO_A_COBRAR){
							Integer idDebitoACobrarHelper = pagamentoRelatorioHelper.getIdDebitoACobrar();
							Integer idImovelHelper = pagamentoRelatorioHelper.getIdImovel();
							Integer anoMesReferenciaPagamentoHelper = pagamentoRelatorioHelper.getAnoMesReferenciaPagamento();

							// Caso o registro não tenha o idDebitoACobrar, deve-se pesquisar pela
							// matricula do imovel e referencia
							if(idDebitoACobrarHelper != null || (idImovelHelper != null && anoMesReferenciaPagamentoHelper != null)){
								FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();

								if(idDebitoACobrarHelper != null){
									filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID,
													idDebitoACobrarHelper));
								}else{
									filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID,
													idImovelHelper));
									filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.REFERENCIA_DEBITO,
													anoMesReferenciaPagamentoHelper));
								}

								Collection<DebitoACobrar> colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar,
												DebitoACobrar.class.getName());

								DebitoACobrar debitoACobrar = null;
								if(colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()){
									debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
									pagamentoRelatorioHelper.setNumeroPrestacaoDebito(debitoACobrar.getNumeroPrestacaoDebito());
									pagamentoRelatorioHelper.setNumeroPrestacaoCobradas(debitoACobrar.getNumeroPrestacaoCobradas());
									pagamentoRelatorioHelper.setValorDebito(debitoACobrar.getValorDebito());
								}

								if(debitoACobrar == null){
									FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();

									if(idDebitoACobrarHelper != null){
										filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
														FiltroDebitoACobrarHistorico.ID, idDebitoACobrarHelper));
									}else{
										filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
														FiltroDebitoACobrarHistorico.IMOVEL_ID, idImovelHelper));
										filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
														FiltroDebitoACobrarHistorico.REFERENCIA_DEBITO, anoMesReferenciaPagamentoHelper));
									}

									Collection<DebitoACobrarHistorico> colecaoDebitoACobrarHistorico = this.getControladorUtil().pesquisar(
													filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());

									DebitoACobrarHistorico debitoACobrarHistorico = null;
									if(colecaoDebitoACobrarHistorico != null && !colecaoDebitoACobrarHistorico.isEmpty()){
										debitoACobrarHistorico = (DebitoACobrarHistorico) Util
														.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico);
										pagamentoRelatorioHelper.setNumeroPrestacaoDebito(debitoACobrarHistorico.getPrestacaoDebito());
										pagamentoRelatorioHelper.setNumeroPrestacaoCobradas(debitoACobrarHistorico.getPrestacaoCobradas());
										pagamentoRelatorioHelper.setValorDebito(debitoACobrarHistorico.getValorDebito());
									}
								}
							}

							// Pagamentos de Guia de Pagamento
						}else if(idDocumentoTipo.intValue() == DocumentoTipo.GUIA_PAGAMENTO){

							FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
							filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, pagamentoRelatorioHelper
											.getIdGuiaPagamento()));
							filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
											FiltroGuiaPagamento.DEBITO_CREDITO_SITUACAO_ATUAL_ID, DebitoCreditoSituacao.NORMAL));

							Collection<GuiaPagamento> colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamento,
											GuiaPagamento.class.getName());

							if(colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()){

								FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
								filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(
												FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID, pagamentoRelatorioHelper
																.getIdGuiaPagamento()));
								filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(
												FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO, pagamentoRelatorioHelper
																.getNumeroPrestacaoGuia()));

								Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = getControladorUtil().pesquisar(
												filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

								if(colecaoGuiaPagamentoPrestacao != null && !colecaoGuiaPagamentoPrestacao.isEmpty()){
									GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) Util
													.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);
									pagamentoRelatorioHelper.setValorDebito(guiaPagamentoPrestacao.getValorPrestacao());
								}else{
									FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
									filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, pagamentoRelatorioHelper
																	.getIdGuiaPagamento()));
									filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, pagamentoRelatorioHelper
																	.getNumeroPrestacaoGuia()));

									Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = getControladorUtil()
													.pesquisar(filtroGuiaPagamentoPrestacaoHistorico,
																	GuiaPagamentoPrestacaoHistorico.class.getName());

									if(colecaoGuiaPagamentoPrestacaoHistorico != null && !colecaoGuiaPagamentoPrestacaoHistorico.isEmpty()){
										GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) Util
														.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHistorico);
										pagamentoRelatorioHelper.setValorDebito(guiaPagamentoPrestacaoHistorico.getValorPrestacao());
									}
								}

							}else{
								// tenta buscar em Histórico
								FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
								filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID,
												pagamentoRelatorioHelper.getIdGuiaPagamento()));
								filtroGuiaPagamentoHistorico
												.adicionarParametro(new ParametroSimples(
																FiltroGuiaPagamentoHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
																DebitoCreditoSituacao.NORMAL));

								Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = getControladorUtil().pesquisar(
												filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());
								if(colecaoGuiaPagamentoHistorico != null && !colecaoGuiaPagamentoHistorico.isEmpty()){
									FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
									filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, pagamentoRelatorioHelper
																	.getIdGuiaPagamento()));
									filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, pagamentoRelatorioHelper
																	.getNumeroPrestacaoGuia()));

									Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = getControladorUtil()
													.pesquisar(filtroGuiaPagamentoPrestacaoHistorico,
																	GuiaPagamentoPrestacaoHistorico.class.getName());

									if(colecaoGuiaPagamentoPrestacaoHistorico != null && !colecaoGuiaPagamentoPrestacaoHistorico.isEmpty()){
										GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) Util
														.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHistorico);
										pagamentoRelatorioHelper.setValorDebito(guiaPagamentoPrestacaoHistorico.getValorPrestacao());
									}
								}
							}
						}
					}
					colecaoPagamentoHelper.add(pagamentoRelatorioHelper);
				}
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamentoHelper;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoMovimentoArrecadadorCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoMovimentoArrecadadorCount(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Saulo Lima
	 * @date 25/08/2009
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarPagamentoHistoricoMovimentoArrecadadorCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoMovimentoArrecadadorCount(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoLocalidadeCount(String idImovel, String idCliente, String idTipoRelacao, String localidadeInicial,
					String localidadeFinal, String idAvisoBancario, String idArrecadador, String periodoArrecadacaoInicial,
					String periodoArrecadacaoFinal, String periodoPagamentoInicio, String periodoPagamentoFim, Date dataPagamentoInicial,
					Date dataPagamentoFinal, String[] idsPagamentosSituacoes, String[] idsDebitosTipos, String[] idsArrecadacaoForma,
					String[] idsDocumentosTipos, String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoLocalidadeCount(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	public Integer verificarExistenciaGuiaDevolucao(Integer idGuiaDevolucao) throws ControladorException{

		// Retorna o cliente encontrado ou vazio se não existir
		try{
			return repositorioArrecadacao.verificarExistenciaGuiaDevolucao(idGuiaDevolucao);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Pesquisa os avisos bancários para o relatório através das opções
	 * selecionadas no Filtrar Aviso Bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 04/09/06
	 * @return Collection<AvisoBancarioRelatorioHelper>
	 * @throws ControladorException
	 */
	public Collection pesquisarAvisoBancarioRelatorio(AvisoBancarioHelper avisoBancarioHelper) throws ControladorException{

		try{
			// Collection colecaoAvisosBancario =
			// this.repositorioArrecadacao.filtrarAvisoBancarioAbertoFechado(avisoBancarioHelper);

			Collection colecaoAvisosBancario = this.filtrarAvisoBancarioAbertoFechado(avisoBancarioHelper);

			AvisoBancario objetoAvisoBancario = null;
			AvisoBancarioHelper avisoBancarioHelperNovo = null;
			Iterator iterator = colecaoAvisosBancario.iterator();

			Collection colecaoAvisosBancarioFinal = new ArrayList();
			colecaoAvisosBancarioFinal.removeAll(colecaoAvisosBancarioFinal);

			Collection colecaoAvisoBancarioRelatorioHelper = new ArrayList();

			while(iterator.hasNext()){
				objetoAvisoBancario = ((AvisoBancarioHelper) iterator.next()).getAvisoBancario();
				avisoBancarioHelperNovo = new AvisoBancarioHelper();

				avisoBancarioHelperNovo.setIdAvisoBancario(avisoBancarioHelper.getIdAvisoBancario());
				avisoBancarioHelperNovo.setAvisoBancario(objetoAvisoBancario);
				avisoBancarioHelperNovo.setTipoAviso(avisoBancarioHelper.getTipoAviso());

				avisoBancarioHelperNovo.setCodigoAgenteArrecadador(avisoBancarioHelper.getCodigoAgenteArrecadador());
				avisoBancarioHelperNovo.setDataLancamentoInicial(avisoBancarioHelper.getDataLancamentoInicial());
				avisoBancarioHelperNovo.setDataLancamentoFinal(avisoBancarioHelper.getDataLancamentoFinal());
				avisoBancarioHelperNovo.setIndicadorCreditoDebito(avisoBancarioHelper.getIndicadorCreditoDebito());
				avisoBancarioHelperNovo.setIdContaBancaria(avisoBancarioHelper.getIdContaBancaria());
				avisoBancarioHelperNovo.setDataPrevistaInicial(avisoBancarioHelper.getDataPrevistaInicial());
				avisoBancarioHelperNovo.setDataPrevistaFinal(avisoBancarioHelper.getDataPrevistaFinal());
				avisoBancarioHelperNovo.setAnoMesReferenciaArrecadacaoInicial(avisoBancarioHelper.getAnoMesReferenciaArrecadacaoInicial());
				avisoBancarioHelperNovo.setAnoMesReferenciaArrecadacaoFinal(avisoBancarioHelper.getAnoMesReferenciaArrecadacaoFinal());
				avisoBancarioHelperNovo.setDataRealizadaInicial(avisoBancarioHelper.getDataRealizadaInicial());
				avisoBancarioHelperNovo.setDataRealizadaFinal(avisoBancarioHelper.getDataRealizadaFinal());
				avisoBancarioHelperNovo.setValorRealizadoInicial(avisoBancarioHelper.getValorRealizadoInicial());
				avisoBancarioHelperNovo.setValorRealizadoFinal(avisoBancarioHelper.getValorRealizadoFinal());
				avisoBancarioHelperNovo.setValorPrevistoInicial(avisoBancarioHelper.getValorPrevistoInicial());
				avisoBancarioHelperNovo.setValorPrevistoFinal(avisoBancarioHelper.getValorPrevistoFinal());
				avisoBancarioHelperNovo.setIdMovimentoArrecadador(avisoBancarioHelper.getIdMovimentoArrecadador());
				if(avisoBancarioHelperNovo != null && !avisoBancarioHelperNovo.equals("")){
					Collection colecaoDadosAvisosBancarios = this.repositorioArrecadacao
									.pesquisarAvisoBancarioRelatorio(avisoBancarioHelperNovo);

					Iterator colecaoDadosAvisosBancariosIterator = colecaoDadosAvisosBancarios.iterator();
					while(colecaoDadosAvisosBancariosIterator.hasNext()){

						AvisoBancarioRelatorioHelper avisoBancarioRelatorioHelper = new AvisoBancarioRelatorioHelper();

						// Obtém os dados do crédito realizado
						Object[] dadosArray = (Object[]) colecaoDadosAvisosBancariosIterator.next();

						// Id do Aviso Bancário
						if(dadosArray[0] != null){
							avisoBancarioRelatorioHelper.setIdAvisoBancario((Integer) dadosArray[0]);

							// Consulta a data de pagamento do aviso
							Date dataPagamentoAvisoBancario = this.repositorioArrecadacao
											.pesquisarDataPagamentoAvisoBancario(avisoBancarioRelatorioHelper.getIdAvisoBancario());

							avisoBancarioRelatorioHelper.setDataPagamentoAvisoBancario(dataPagamentoAvisoBancario);

						}

						// Nome Arrecadador
						if(dadosArray[1] != null){
							avisoBancarioRelatorioHelper.setNomeArrecadador((String) dadosArray[1]);
						}

						// Data Lançamento
						if(dadosArray[2] != null){
							avisoBancarioRelatorioHelper.setDataLancamento((Date) dadosArray[2]);
						}

						// Sequencial
						if(dadosArray[3] != null){
							avisoBancarioRelatorioHelper.setSequencial((Short) dadosArray[3]);
						}

						// Indicador Crédito/Débito
						if(dadosArray[4] != null){
							avisoBancarioRelatorioHelper.setTipo((Short) dadosArray[4]);
						}

						// Número Documento
						if(dadosArray[5] != null){
							avisoBancarioRelatorioHelper.setNumeroDocumento((Integer) dadosArray[5]);
						}

						// Banco
						if(dadosArray[6] != null){
							avisoBancarioRelatorioHelper.setBanco((String) dadosArray[6]);
						}

						// Agência
						if(dadosArray[7] != null){
							avisoBancarioRelatorioHelper.setAgencia((String) dadosArray[7]);
						}

						// Número Conta
						if(dadosArray[8] != null){
							avisoBancarioRelatorioHelper.setNumeroConta((String) dadosArray[8]);
						}

						// Data Realização
						if(dadosArray[9] != null){
							avisoBancarioRelatorioHelper.setDataRealizacao((Date) dadosArray[9]);
						}

						// Total Arrecadação
						if(dadosArray[10] != null){
							avisoBancarioRelatorioHelper.setTotalArrecadacao((BigDecimal) dadosArray[10]);
						}

						// Total Devolução
						if(dadosArray[11] != null){
							avisoBancarioRelatorioHelper.setTotalDevolucao((BigDecimal) dadosArray[11]);
						}

						// Valor Aviso
						if(dadosArray[12] != null){
							avisoBancarioRelatorioHelper.setValorAviso((BigDecimal) dadosArray[12]);
						}

						// Valor Arrecadacao Calculado
						if(dadosArray[13] != null){
							avisoBancarioRelatorioHelper.setValorArrecadacaoCalculado((BigDecimal) dadosArray[13]);
						}

						// Valor devolucao Calculado
						if(dadosArray[14] != null){
							avisoBancarioRelatorioHelper.setValorDevolucaoCalculado((BigDecimal) dadosArray[14]);
						}

						colecaoAvisoBancarioRelatorioHelper.add(avisoBancarioRelatorioHelper);
					}
				}
			}
			return colecaoAvisoBancarioRelatorioHelper;
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa os avisos deduções de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 05/09/06
	 * @return Collection<DeducoesRelatorioHelper>
	 * @throws ControladorException
	 */

	public Collection pesquisarAvisoDeducoesAvisoBancarioRelatorio(Integer idAvisoBancario) throws ControladorException{

		try{
			Collection colecaoDadosDeducoes = this.repositorioArrecadacao.pesquisarAvisoDeducoesAvisoBancarioRelatorio(idAvisoBancario);

			Collection colecaoDeducoesRelatorioHelper = new ArrayList();
			Iterator colecaoDadosDeducoesIterator = colecaoDadosDeducoes.iterator();
			while(colecaoDadosDeducoesIterator.hasNext()){

				DeducoesRelatorioHelper deducoesRelatorioHelper = new DeducoesRelatorioHelper();

				// Obtém os dados do crédito realizado
				Object[] dadosArray = (Object[]) colecaoDadosDeducoesIterator.next();

				// Tipo
				if(dadosArray[0] != null){
					deducoesRelatorioHelper.setTipo((String) dadosArray[0]);
				}

				// Valor Dedução
				if(dadosArray[1] != null){
					deducoesRelatorioHelper.setValorDeducao((BigDecimal) dadosArray[1]);
				}

				colecaoDeducoesRelatorioHelper.add(deducoesRelatorioHelper);
			}

			return colecaoDeducoesRelatorioHelper;

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa os avisos acertos de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 05/09/06
	 * @return Collection<AcertosRelatorioHelper>
	 * @throws ControladorException
	 */

	public Collection pesquisarAvisoAcertosAvisoBancarioRelatorio(Integer idAvisoBancario) throws ControladorException{

		try{
			Collection colecaoDadosAcertos = this.repositorioArrecadacao.pesquisarAvisoAcertosAvisoBancarioRelatorio(idAvisoBancario);

			Collection colecaoAcertosRelatorioHelper = new ArrayList();
			Iterator colecaoDadosAcertosIterator = colecaoDadosAcertos.iterator();
			while(colecaoDadosAcertosIterator.hasNext()){

				AcertosRelatorioHelper acertosRelatorioHelper = new AcertosRelatorioHelper();

				// Obtém os dados do crédito realizado
				Object[] dadosArray = (Object[]) colecaoDadosAcertosIterator.next();

				// Banco
				if(dadosArray[0] != null){
					acertosRelatorioHelper.setBanco((String) dadosArray[0]);
				}

				// Agência
				if(dadosArray[1] != null){
					acertosRelatorioHelper.setAgencia((Integer) dadosArray[1]);
				}

				// Número Conta
				if(dadosArray[2] != null){
					acertosRelatorioHelper.setNumeroConta((String) dadosArray[2]);
				}

				// Indicador Crédito/Débito
				if(dadosArray[3] != null){
					acertosRelatorioHelper.setTipo(((Integer) dadosArray[3]).shortValue());
				}

				// Data Acerto
				if(dadosArray[4] != null){
					acertosRelatorioHelper.setDataAcerto((Date) dadosArray[4]);
				}

				// Valor Acerto
				if(dadosArray[5] != null){
					acertosRelatorioHelper.setValorAcerto((BigDecimal) dadosArray[5]);
				}

				colecaoAcertosRelatorioHelper.add(acertosRelatorioHelper);
			}

			return colecaoAcertosRelatorioHelper;

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa dos dados diários da arrecadação
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Rafael Santos
	 * @date 05/09/2006
	 * @return
	 */
	public Collection filtrarDadosDiariosArrecadacao(String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String idLocalidade,
					String idGerenciaRegional, String unidadeNegocioId, String idArrecadador, String idElo, String[] idsImovelPerfil,
					String[] idsLigacaoAgua, String[] idsLigacaoEsgoto, String[] idsDocumentosTipos, String[] idsCategoria,
					String[] idsEsferaPoder, String setorComercial, String idConcessionaria) throws ControladorException{

		Collection colecaoDadosDiarios = null;
		Collection colecaoDadosDiariosArrecadacao = null;

		try{
			colecaoDadosDiarios = repositorioArrecadacao.filtrarDadosDiariosArrecadacao(periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							idLocalidade, idGerenciaRegional, unidadeNegocioId, idArrecadador, idElo, idsImovelPerfil, idsLigacaoAgua,
							idsLigacaoEsgoto, idsDocumentosTipos, idsCategoria, idsEsferaPoder, setorComercial, idConcessionaria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		System.out.println("inicio-cont-=" + new Date().toString());
		if(colecaoDadosDiarios != null && !colecaoDadosDiarios.isEmpty()){

			colecaoDadosDiariosArrecadacao = new ArrayList();

			Iterator colecaoDadosDiariosIterator = colecaoDadosDiarios.iterator();

			ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = null;

			while(colecaoDadosDiariosIterator.hasNext()){

				arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();

				// Obtém os dados
				Object[] dadosArray = (Object[]) colecaoDadosDiariosIterator.next();

				// Ano Mês
				if(dadosArray[0] != null){
					arrecadacaoDadosDiarios.setAnoMesReferenciaArrecadacao(((Number) dadosArray[0]).intValue());
				}

				// Data Pagamento
				if(dadosArray[1] != null){
					arrecadacaoDadosDiarios.setDataPagamento((java.util.Date) dadosArray[1]);
				}

				// Quantidade Pagmento
				if(dadosArray[2] != null){
					arrecadacaoDadosDiarios.setQuantidadePagamentos(((Number) dadosArray[2]).intValue());
				}

				// Valor Pagamento
				if(dadosArray[3] != null){
					arrecadacaoDadosDiarios.setValorPagamentos((BigDecimal) dadosArray[3]);
				}

				// Arrecadador
				if(dadosArray[4] != null){
					Arrecadador arrecadador = new Arrecadador();
					arrecadador.setId(((Number) dadosArray[4]).intValue());

					// if(dadosArray[15] != null){
					// Cliente cliente = new Cliente();
					// cliente.setNome((String)dadosArray[15]);
					// arrecadador.setCliente(cliente);
					// }

					arrecadacaoDadosDiarios.setArrecadador(arrecadador);
				}

				// Arrecadador Forma
				/*
				 * if (dadosArray[5] != null) { ArrecadacaoForma
				 * arrecadacaoForma = new ArrecadacaoForma();
				 * arrecadacaoForma.setId((Integer)dadosArray[5]);
				 * arrecadacaoDadosDiarios.setArrecadacaoForma(arrecadacaoForma); }
				 */
				// Documento Tipo
				if(dadosArray[5] != null){
					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId(((Number) dadosArray[5]).intValue());

					// / if(dadosArray[13] != null){
					// documentoTipo.setDescricaoDocumentoTipo((String)dadosArray[13]);
					// }

					arrecadacaoDadosDiarios.setDocumentoTipo(documentoTipo);
				}

				// ImovelPerfil
				if(dadosArray[6] != null){
					ImovelPerfil imovelPerfil = new ImovelPerfil();
					imovelPerfil.setId(((Number) dadosArray[6]).intValue());

					// if (dadosArray[16] != null) {
					// imovelPerfil.setDescricao((String)dadosArray[16]);
					// }

					arrecadacaoDadosDiarios.setImovelPerfil(imovelPerfil);
				}

				// Gerencia Regional
				if(dadosArray[7] != null){
					GerenciaRegional gerenciaRegional = new GerenciaRegional();
					gerenciaRegional.setId(((Number) dadosArray[7]).intValue());
					// if (dadosArray[11] != null) {
					// / gerenciaRegional.setNome((String) dadosArray[11]);
					// }
					// if (dadosArray[12] != null) {
					// gerenciaRegional.setNomeAbreviado((String)
					// dadosArray[12]);
					// }

					arrecadacaoDadosDiarios.setGerenciaRegional(gerenciaRegional);
				}

				// Localidade
				if(dadosArray[8] != null){
					Localidade localidade = new Localidade();
					localidade.setId(((Number) dadosArray[8]).intValue());

					// if (dadosArray[10] != null) {
					// localidade.setDescricao((String)dadosArray[10]);
					// }

					Localidade elo = null;
					// if (dadosArray[11] != null) {
					// elo = new Localidade();
					// elo.setDescricao((String)dadosArray[11]);
					// }
					if(dadosArray[10] != null){
						if(elo == null){
							elo = new Localidade();
						}
						elo.setId(((Number) dadosArray[10]).intValue());
					}

					localidade.setLocalidade(elo);

					arrecadacaoDadosDiarios.setLocalidade(localidade);
				}

				// Categoria
				if(dadosArray[9] != null){
					Categoria categoria = new Categoria();
					categoria.setId(((Number) dadosArray[9]).intValue());

					// if (dadosArray[14] != null) {
					// categoria.setDescricao((String)dadosArray[14]);
					// }

					arrecadacaoDadosDiarios.setCategoria(categoria);
				}

				// Unidade Negocio
				if(dadosArray[11] != null){
					UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(((Number) dadosArray[11]).intValue());

					// if (dadosArray[14] != null) {
					// categoria.setDescricao((String)dadosArray[14]);
					// }

					arrecadacaoDadosDiarios.setUnidadeNegocio(unidadeNegocio);
				}

				// Setor Comercial
				if(dadosArray[12] != null){
					SetorComercial setorComercial1 = new SetorComercial();
					setorComercial1.setId(((Number) dadosArray[12]).intValue());
					if(dadosArray[13] != null){
						setorComercial1.setDescricao((String) dadosArray[13]);
					}
					if(dadosArray[14] != null){
						Localidade loc = new Localidade();
						loc.setId(((Number) dadosArray[14]).intValue());
						setorComercial1.setLocalidade(loc);
					}

					arrecadacaoDadosDiarios.setSetorComercial(setorComercial1);
				}

				// Concessionária
				if(idConcessionaria != null && dadosArray[15] != null){
					Concessionaria concessionaria = new Concessionaria();
					concessionaria.setId(((Number) dadosArray[15]).intValue());
					if(dadosArray[16] != null){
						concessionaria.setNome((String) dadosArray[16]);
					}
					if(dadosArray[17] != null){
						concessionaria.setNomeAbreviado((String) dadosArray[17]);
					}

					arrecadacaoDadosDiarios.setConcessionaria(concessionaria);
				}

				colecaoDadosDiariosArrecadacao.add(arrecadacaoDadosDiarios);
			}
		}

		System.out.println("fim-cont=" + new Date().toString());
		return colecaoDadosDiariosArrecadacao;

	}

	/**
	 * Pesquisa dos dados diários da arrecadação pela Gerencia
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Rafael Santos
	 * @date 05/09/2006
	 * @return
	 */
	public Collection filtrarDadosDiariosArrecadacaoValoresDiarios(String idGerenciaRegional) throws ControladorException{

		Collection colecaoValoresDiarios = null;
		try{

			Collection colecaoArrecadacao = repositorioArrecadacao.filtrarDadosDiariosArrecadacaoValoresDiarios(idGerenciaRegional);

			ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = null;
			if(colecaoArrecadacao != null && !colecaoArrecadacao.isEmpty()){

				Iterator icolecaoColecaoArrecadacao = colecaoArrecadacao.iterator();
				colecaoValoresDiarios = new ArrayList();

				// dados diarios
				while(icolecaoColecaoArrecadacao.hasNext()){

					arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();
					Object[] arrecadacaoArray = (Object[]) icolecaoColecaoArrecadacao.next();

					if(arrecadacaoArray[0] != null){// 0
						// nome gerencia regional
						GerenciaRegional gerenciaRegional = new GerenciaRegional();
						gerenciaRegional.setNome(arrecadacaoArray[0].toString());

						arrecadacaoDadosDiarios.setGerenciaRegional(gerenciaRegional);
					}
					if(arrecadacaoArray[1] != null){// 1
						// descricao localidade
						Localidade localidade = new Localidade();

						localidade.setDescricao(arrecadacaoArray[1].toString());
						arrecadacaoDadosDiarios.setLocalidade(localidade);
					}
					// descricao elo
					if(arrecadacaoArray[2] != null){// 2
						// descricao localidade
						Localidade localidade = new Localidade();
						if(arrecadacaoArray[1] != null){// 1
							localidade.setDescricao(arrecadacaoArray[1].toString());
						}

						Localidade localidadeElo = new Localidade();
						localidadeElo.setDescricao(arrecadacaoArray[2].toString());

						localidade.setLocalidade(localidadeElo);

						arrecadacaoDadosDiarios.setLocalidade(localidade);
					}
					colecaoValoresDiarios.add(arrecadacaoDadosDiarios);
				}
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return colecaoValoresDiarios;
	}

	/**
	 * Pesquisa os dados da Guia de Pagamento necessários para o relatório
	 * através do id da Guia de Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 03/10/06
	 * @author eduardo henrique
	 * @date 20/08/2008
	 *       Alteração para Impressão de Guia de Pagamento por Prestação. O Método sempre gerará uma
	 *       folha de Impressão por Id de GuiaPagamento + Nr. Prestação
	 * @param prestacoesGuiaPagamento
	 *            Coleção de GuiaPagamentoPrestação que poderá(ão) será(ão) impressa(s)
	 * @param registrosImpressao
	 *            Id's selecionados na Apresentação ou de 'Outra Origem'.
	 *            Pré-Requisito : elementos GuiaPagamentoPrestacaoHelper devem vir com : Id,
	 *            IdGuiaPagamento e NumeroPrestacao preenchidos.
	 * @return Collection<GuiaPagamentoRelatorioHelper>
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public Collection<GuiaPagamentoRelatorioHelper> pesquisarGuiaPagamentoRelatorio(
					Collection<GuiaPagamentoPrestacaoHelper> prestacoesGuiaPagamento, String[] registrosImpressao)
					throws ControladorException{

		Collection<GuiaPagamentoRelatorioHelper> colecaoGuiaPagamentoRelatorioHelper = new ArrayList();

		// Novo Funcionamento
		if(prestacoesGuiaPagamento == null || prestacoesGuiaPagamento.isEmpty() || registrosImpressao == null
						|| (registrosImpressao.length == 0)){
			throw new ControladorException("atencao.nenhuma.guia.selecionada");
		}

		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
		String anoMesArrecadacao = sistemaParametro.getAnoMesArrecadacao().toString();

		Map<String, BigDecimal> mapValorPorTipoDebito = null;
		BigDecimal valorTipoDebitoAux = null;

		for(int i = 0; i < registrosImpressao.length; i++){

			for(GuiaPagamentoPrestacaoHelper beanGuiaPagamentoHelper : prestacoesGuiaPagamento){

				if(registrosImpressao[i].equals(beanGuiaPagamentoHelper.getId().toString())){
					// Realiza a Geração por Guia e Nr. Prestação

					Collection colecaoGuiaPrestacoes = null;
					List prestacaoImpressao = new ArrayList();
					prestacaoImpressao.add(beanGuiaPagamentoHelper.getNumeroPrestacao());

					if(beanGuiaPagamentoHelper.getIdGuiaPagamento() == null){
						throw new ControladorException("erro.problema_na_identificacao_guia_pagamento");
					}

					try{
						colecaoGuiaPrestacoes = repositorioArrecadacao.pesquisarGuiaPagamentoRelatorio(
										beanGuiaPagamentoHelper.getIdGuiaPagamento(), prestacaoImpressao);
					}catch(ErroRepositorioException ex){
						throw new ControladorException("erro.sistema", ex);
					}

					Integer idCliente = null;
					Integer idImovel = null;
					String matricula = "";
					String nomeCliente = "";
					String inscricao = "";
					BigDecimal valorTotalPrestacao = BigDecimal.ZERO.setScale(2);

					FiltroDebitoAutomaticoMovimento filtroDebitoAutomaticoMovimento = null;
					Collection<DebitoAutomaticoMovimento> colecaoDebitoAutomaticoMovimento = null;

					GuiaPagamentoRelatorioHelper guiaPagamentoRelatorioHelper = new GuiaPagamentoRelatorioHelper();

					for(Iterator iterator = colecaoGuiaPrestacoes.iterator(); iterator.hasNext();){
						Object[] dadosParcelaTipoDebito = (Object[]) iterator.next();

						String descricaoDebitoTipo = (String) dadosParcelaTipoDebito[7];

						if(descricaoDebitoTipo != null){
							descricaoDebitoTipo = descricaoDebitoTipo.trim();
						}

						BigDecimal valorTipoDebito = (BigDecimal) dadosParcelaTipoDebito[4];

						// Realiza o acúmulo do valor por Tipo de Débito para a Prestação
						mapValorPorTipoDebito = guiaPagamentoRelatorioHelper.getMapValorPorTipoDebito();

						if(!mapValorPorTipoDebito.containsKey(descricaoDebitoTipo)){
							mapValorPorTipoDebito.put(descricaoDebitoTipo, valorTipoDebito);
						}else{
							valorTipoDebitoAux = mapValorPorTipoDebito.get(descricaoDebitoTipo);
							valorTipoDebitoAux = valorTipoDebitoAux.add(valorTipoDebito);

							mapValorPorTipoDebito.put(descricaoDebitoTipo, valorTipoDebitoAux);
						}

						valorTotalPrestacao = valorTotalPrestacao.add(valorTipoDebito);

						// O preenchimento dos dados 'gerais' só é realizado uma vez por bean
						if(guiaPagamentoRelatorioHelper.getIdGuiaPagamento() == null
										&& guiaPagamentoRelatorioHelper.getNumeroPrestacaoGuiaPagamento() == null){

							// Pesquisar Cliente -- recupera cliente atraves de ClienteGuiaPagamento
							// se vir null, recupera atraves de Imovel.imovelCliente
							Object[] dadosCliente = null;

							try{
								dadosCliente = repositorioArrecadacao.pesquisarClienteDeGuiaPagamento(beanGuiaPagamentoHelper
												.getIdGuiaPagamento());
							}catch(ErroRepositorioException e){
								throw new ControladorException("erro.sistema", e);
							}

							if(dadosCliente == null){
								try{
									dadosCliente = repositorioArrecadacao.pesquisarImovelDeClienteGuiaPagamento(beanGuiaPagamentoHelper
													.getIdGuiaPagamento());
								}catch(ErroRepositorioException e){
									throw new ControladorException("erro.sistema", e);
								}

							}

							if(dadosCliente == null){
								try{
									dadosCliente = repositorioArrecadacao.pesquisarClienteDeClienteImovel(beanGuiaPagamentoHelper
													.getIdGuiaPagamento());
								}catch(ErroRepositorioException e){
									throw new ControladorException("erro.sistema", e);
								}

							}

							if(dadosCliente != null){
								if(dadosCliente[0] != null){
									idCliente = (Integer) dadosCliente[0];
								}
								if(dadosCliente[1] != null){
									nomeCliente = (String) dadosCliente[1];
								}
							}

							if(dadosParcelaTipoDebito[0] == null){
								// código do cliente
								matricula = "" + idCliente;

								// Inscrição do imóvel
								// caso imov_id = null, imprimir código da localidade
								// (loca_id)
								inscricao = "" + dadosParcelaTipoDebito[2];

								// recupera endereço de correspondencia do cliente
								// [UC0085]Obter Endereco
								String enderecoClienteResponsavel = "";
								enderecoClienteResponsavel = this.getControladorEndereco().pesquisarEnderecoClienteAbreviado(idCliente);
								guiaPagamentoRelatorioHelper.setEnderecoClienteResponsavel(enderecoClienteResponsavel);

							}else{
								idImovel = (Integer) dadosParcelaTipoDebito[0];
								// matrícula do imóvel
								matricula = "" + idImovel;
								// try {
								// nomeCliente = repositorioArrecadacao
								// .pesquisarNomeClienteGuiaPagamentoRelatorio(idGuiaPagamento);
								// } catch (ErroRepositorioException e) {
								// e.printStackTrace();
								// }

								// Inscrição do imóvel
								inscricao = getControladorImovel().pesquisarInscricaoImovel(idImovel, true);

								// recupera endereco do imóvel
								String enderecoImovel = "";
								try{
									enderecoImovel = this.getControladorEndereco().pesquisarEnderecoFormatado(idImovel);
								}catch(ControladorException e1){
									e1.printStackTrace();
								}
								guiaPagamentoRelatorioHelper.setEnderecoImovel(enderecoImovel);
							}

							guiaPagamentoRelatorioHelper.setIdCliente(idCliente);
							guiaPagamentoRelatorioHelper.setIdImovel(idImovel);
							guiaPagamentoRelatorioHelper.setMatricula(matricula);
							guiaPagamentoRelatorioHelper.setNomeCliente(nomeCliente);
							guiaPagamentoRelatorioHelper.setInscricao(inscricao);
							guiaPagamentoRelatorioHelper.setIdGuiaPagamento("" + beanGuiaPagamentoHelper.getIdGuiaPagamento());
							guiaPagamentoRelatorioHelper.setNumeroPrestacaoGuiaPagamento(beanGuiaPagamentoHelper.getNumeroPrestacao());

							Date dataEmissaoPrestacao = (Date) dadosParcelaTipoDebito[5];
							Date dataVencimentoPrestacao = (Date) dadosParcelaTipoDebito[1];
							Short numeroTotalPrestacoes = (Short) dadosParcelaTipoDebito[9];
							Integer idTipoDocumento = (Integer) dadosParcelaTipoDebito[10];
							String descricaoTipoDocumento = (String) dadosParcelaTipoDebito[11];
							String indicadorPrestacaoNoHistorico = (String) dadosParcelaTipoDebito[12];
							Integer anoMesReferenciaFaturamento = (Integer) dadosParcelaTipoDebito[13];
							Short indicadorCobrancaMulta = (Short) dadosParcelaTipoDebito[14];
							Short indicadorEmissaoObservacaoRA = (Short) dadosParcelaTipoDebito[15];
							String descricaoObservacao = "";
							if(dadosParcelaTipoDebito[16] != null && !((String) dadosParcelaTipoDebito[16]).equals("")){
								descricaoObservacao = (String) dadosParcelaTipoDebito[16];
							}

							// String anoEmissaoGuia = "" + Util.getAno(dataEmissaoPrestacao);
							guiaPagamentoRelatorioHelper.setDataEmissao(dataEmissaoPrestacao);
							guiaPagamentoRelatorioHelper.setDataVencimento(dataVencimentoPrestacao);
							guiaPagamentoRelatorioHelper.setIdTipoDocumento(idTipoDocumento);
							guiaPagamentoRelatorioHelper.setDescricaoTipoDocumento(descricaoTipoDocumento);
							guiaPagamentoRelatorioHelper.setNumeroPrestacaoTotal(numeroTotalPrestacoes);
							guiaPagamentoRelatorioHelper.setIndicadorPrestacaoNoHistorico(indicadorPrestacaoNoHistorico);
							guiaPagamentoRelatorioHelper.setAnoMesReferenciaFaturamento(anoMesReferenciaFaturamento);
							guiaPagamentoRelatorioHelper.setIndicadorCobrancaMulta(indicadorCobrancaMulta);
							guiaPagamentoRelatorioHelper.setIndicadorEmissaoObservacaoRA(indicadorEmissaoObservacaoRA);
							guiaPagamentoRelatorioHelper.setDescricaoObservacao(descricaoObservacao);

							// Número do Contrato Parcelamento Órgão Público
							if(dadosParcelaTipoDebito[17] != null){
								guiaPagamentoRelatorioHelper.setNumeroContratoParcelOrgaoPublico((Integer) dadosParcelaTipoDebito[17]);
							}

							if(!Util.isVazioOuBranco(indicadorPrestacaoNoHistorico)){
								filtroDebitoAutomaticoMovimento = new FiltroDebitoAutomaticoMovimento();
								filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(
												FiltroDebitoAutomaticoMovimento.GUIA_PAGAMENTO_PRESTACAO_ID, beanGuiaPagamentoHelper
																.getIdGuiaPagamento()));
								filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(
												FiltroDebitoAutomaticoMovimento.NUMERO_PRESTACAO, beanGuiaPagamentoHelper
																.getNumeroPrestacao()));

								colecaoDebitoAutomaticoMovimento = this.getControladorUtil().pesquisar(filtroDebitoAutomaticoMovimento,
												DebitoAutomaticoMovimento.class.getName());

								if(!Util.isVazioOrNulo(colecaoDebitoAutomaticoMovimento)){
									guiaPagamentoRelatorioHelper.setIndicadorPrestacaoDebitoAutomatico("S");
								}
							}
						}

						if(!iterator.hasNext()){
							// Parâmetro que identifica se a empresa emite o documento com
							// acrescimos
							String parametroTratarAcrescimosEmissaoDocumento = ParametroArrecadacao.P_TRATAR_ACRESCIMOS_EMISSAO_DOCUMENTO
											.executar().toString();

							String indicadorPrestacaoNoHistorico = guiaPagamentoRelatorioHelper.getIndicadorPrestacaoNoHistorico();

							if(parametroTratarAcrescimosEmissaoDocumento.equals(Short.toString(ConstantesSistema.SIM))
											&& Util.isVazioOuBranco(indicadorPrestacaoNoHistorico)){
								Date menorDataPagamento = null;

								Collection<Object[]> dadosPagamento = null;

								try{
									dadosPagamento = repositorioCobranca.pesquisarValorTotalGuiaPagamentoMenorDataGuiaPagamento(
													beanGuiaPagamentoHelper.getIdGuiaPagamento(), beanGuiaPagamentoHelper
																	.getNumeroPrestacao().intValue());
								}catch(ErroRepositorioException e){
									throw new ControladorException("erro.sistema", e);
								}

								if(dadosPagamento != null && !dadosPagamento.isEmpty()){
									Object[] dadosPagamentoArray = dadosPagamento.iterator().next();

									if(dadosPagamentoArray[1] != null){
										menorDataPagamento = (Date) dadosPagamentoArray[1];
									}
								}

								CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidade = this.getControladorCobranca()
												.calcularAcrescimoPorImpontualidadeBancoDeDados(
																guiaPagamentoRelatorioHelper.getAnoMesReferenciaFaturamento(),
																guiaPagamentoRelatorioHelper.getDataVencimento(), menorDataPagamento,
																valorTotalPrestacao, BigDecimal.ZERO,
																guiaPagamentoRelatorioHelper.getIndicadorCobrancaMulta().shortValue(),
																anoMesArrecadacao, null, new Date(), ConstantesSistema.SIM,
																ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM);

								if(calcularAcrescimoPorImpontualidade != null){
									mapValorPorTipoDebito = guiaPagamentoRelatorioHelper.getMapValorPorTipoDebito();

									FiltroDebitoTipo filtroDebitoTipo = null;
									Collection<DebitoTipo> colecaoDebitoTipo = null;
									DebitoTipo debitoTipo = null;

									BigDecimal valorMulta = calcularAcrescimoPorImpontualidade.getValorMulta();

									if(valorMulta != null && valorMulta.compareTo(BigDecimal.ZERO) > 0){
										valorTotalPrestacao = valorTotalPrestacao.add(valorMulta);

										filtroDebitoTipo = new FiltroDebitoTipo();
										filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID,
														DebitoTipo.MULTA_IMPONTUALIDADE));
										filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
														ConstantesSistema.INDICADOR_USO_ATIVO));

										colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo,
														DebitoTipo.class.getName());

										descricaoDebitoTipo = "";

										if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
											debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
											descricaoDebitoTipo = debitoTipo.getDescricao();
										}

										if(!mapValorPorTipoDebito.containsKey(descricaoDebitoTipo)){
											mapValorPorTipoDebito.put(descricaoDebitoTipo, valorMulta);
										}else{
											valorTipoDebitoAux = mapValorPorTipoDebito.get(descricaoDebitoTipo);
											valorTipoDebitoAux = valorTipoDebitoAux.add(valorMulta);

											mapValorPorTipoDebito.put(descricaoDebitoTipo, valorTipoDebitoAux);
										}
									}

									BigDecimal valorJurosMora = calcularAcrescimoPorImpontualidade.getValorJurosMora();

									if(valorJurosMora != null && valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
										valorTotalPrestacao = valorTotalPrestacao.add(valorJurosMora);

										filtroDebitoTipo = new FiltroDebitoTipo();
										filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, DebitoTipo.JUROS_MORA));
										filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
														ConstantesSistema.INDICADOR_USO_ATIVO));

										colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo,
														DebitoTipo.class.getName());

										descricaoDebitoTipo = "";

										if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
											debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
											descricaoDebitoTipo = debitoTipo.getDescricao();
										}

										if(!mapValorPorTipoDebito.containsKey(descricaoDebitoTipo)){
											mapValorPorTipoDebito.put(descricaoDebitoTipo, valorJurosMora);
										}else{
											valorTipoDebitoAux = mapValorPorTipoDebito.get(descricaoDebitoTipo);
											valorTipoDebitoAux = valorTipoDebitoAux.add(valorJurosMora);

											mapValorPorTipoDebito.put(descricaoDebitoTipo, valorTipoDebitoAux);
										}
									}

									BigDecimal valorAtualizacaoMonetaria = calcularAcrescimoPorImpontualidade
													.getValorAtualizacaoMonetaria();

									if(valorAtualizacaoMonetaria != null && valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
										valorTotalPrestacao = valorTotalPrestacao.add(valorAtualizacaoMonetaria);

										filtroDebitoTipo = new FiltroDebitoTipo();
										filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID,
														DebitoTipo.ATUALIZACAO_MONETARIA));
										filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
														ConstantesSistema.INDICADOR_USO_ATIVO));

										colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo,
														DebitoTipo.class.getName());

										descricaoDebitoTipo = "";

										if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
											debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
											descricaoDebitoTipo = debitoTipo.getDescricao();
										}

										if(!mapValorPorTipoDebito.containsKey(descricaoDebitoTipo)){
											mapValorPorTipoDebito.put(descricaoDebitoTipo, valorAtualizacaoMonetaria);
										}else{
											valorTipoDebitoAux = mapValorPorTipoDebito.get(descricaoDebitoTipo);
											valorTipoDebitoAux = valorTipoDebitoAux.add(valorAtualizacaoMonetaria);

											mapValorPorTipoDebito.put(descricaoDebitoTipo, valorTipoDebitoAux);
										}
									}

									guiaPagamentoRelatorioHelper.setIndicadorExibirAcrescimos(ConstantesSistema.SIM.toString());
								}
							}

							// Atribui os dados Acumulados da Guia/Prestação a ser impressa
							guiaPagamentoRelatorioHelper.setValorDebito(valorTotalPrestacao);

							// caso imov_id da guia de pagamento esteja preenchido,
							// atribuir o valor 4 , caso contrário atribuir o valor 6
							Integer tipoPagamento = 4;
							if(guiaPagamentoRelatorioHelper.getIdImovel() == null){
								tipoPagamento = 6;
							}

							// [UC0229] - Obter Representação Numérica do Código de Barras
							String representacaoNumericaCodBarra = obterRepresentacaoNumericaCodigoBarra(
											tipoPagamento,
											guiaPagamentoRelatorioHelper.getValorDebito(),
											guiaPagamentoRelatorioHelper.getIdLocalidade(),
											guiaPagamentoRelatorioHelper.getIdImovel() == null ? null : guiaPagamentoRelatorioHelper
															.getIdImovel(),
											null,
											null,
											guiaPagamentoRelatorioHelper.getIdTipoDocumento(),
											String.valueOf((Util.getAno(guiaPagamentoRelatorioHelper.getDataEmissao()))),
											null,
											DocumentoTipo.GUIA_PAGAMENTO,
											null,
											null,
											guiaPagamentoRelatorioHelper.getNumeroPrestacaoGuiaPagamento(),
											null,
											Integer.valueOf(guiaPagamentoRelatorioHelper.getIdGuiaPagamento()),
											guiaPagamentoRelatorioHelper.getIdCliente() == null ? null : guiaPagamentoRelatorioHelper
															.getIdCliente());

							// Formata a representação númerica do código de barras
							String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11) + "-"
											+ representacaoNumericaCodBarra.substring(11, 12) + " "
											+ representacaoNumericaCodBarra.substring(12, 23) + "-"
											+ representacaoNumericaCodBarra.substring(23, 24) + " "
											+ representacaoNumericaCodBarra.substring(24, 35) + "-"
											+ representacaoNumericaCodBarra.substring(35, 36) + " "
											+ representacaoNumericaCodBarra.substring(36, 47) + "-"
											+ representacaoNumericaCodBarra.substring(47, 48);

							guiaPagamentoRelatorioHelper.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

							String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra.substring(0, 11)
											+ representacaoNumericaCodBarra.substring(12, 23)
											+ representacaoNumericaCodBarra.substring(24, 35)
											+ representacaoNumericaCodBarra.substring(36, 47);

							guiaPagamentoRelatorioHelper.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);

							colecaoGuiaPagamentoRelatorioHelper.add(guiaPagamentoRelatorioHelper);
						}
					}
				}
			}
		}

		return colecaoGuiaPagamentoRelatorioHelper;
	}

	/**
	 * Pesquisa os dados da Guia de Devolução necessários para o relatório
	 * através do id da Guia de Devolução
	 * 
	 * @author Ana Maria
	 * @date 05/10/06
	 * @author Eduardo Henrique
	 * @date 22/05/2008
	 *       Correção no cast do código da Agência retornado, que é String.
	 * @return Collection<GuiaDevolucaoRelatorioHelper>
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */

	public Collection<GuiaDevolucaoRelatorioHelper> pesquisarGuiaDevolucaoRelatorio(String[] ids) throws ControladorException{

		Collection<GuiaDevolucaoRelatorioHelper> colecaoGuiaDevolucaoRelatorioHelper = new ArrayList();

		if(ids != null && ids.length != 0){
			for(int i = 0; i < ids.length; i++){

				int idGuiaDevolucao = Integer.parseInt(ids[i]);
				GuiaDevolucaoRelatorioHelper guiaDevolucaoRelatorioHelper = new GuiaDevolucaoRelatorioHelper();

				try{
					guiaDevolucaoRelatorioHelper = repositorioArrecadacao.pesquisarGuiaDevolucaoRelatorio(idGuiaDevolucao);
				}catch(ErroRepositorioException ex){
					ex.printStackTrace();
					throw new ControladorException("erro.sistema", ex);
				}

				String valorExtenco = Util.valorExtenso(guiaDevolucaoRelatorioHelper.getValorDevolucao());
				if(valorExtenco != null && !valorExtenco.equals("")){
					guiaDevolucaoRelatorioHelper.setValorExtenso(valorExtenco);
				}

				if(guiaDevolucaoRelatorioHelper.getIdMatriculaImovel() != null){
					// Imóvel

					// recupera endereco do imóvel
					String enderecoImovel = "";
					try{
						enderecoImovel = this.getControladorEndereco().pesquisarEnderecoFormatado(
										guiaDevolucaoRelatorioHelper.getIdMatriculaImovel());
					}catch(ControladorException e1){
						e1.printStackTrace();
					}
					guiaDevolucaoRelatorioHelper.setEndereco(enderecoImovel);

					// Pesquisa para recuperar o cpf/cnpj e o rg do Cliente
					Object[] dadosClienteImovel = null;

					try{

						dadosClienteImovel = repositorioArrecadacao.pesquisarClienteImovel(guiaDevolucaoRelatorioHelper
										.getIdMatriculaImovel());

					}catch(ErroRepositorioException ex){
						ex.printStackTrace();
						throw new ControladorException("erro.sistema", ex);
					}
					if(dadosClienteImovel != null){
						if(dadosClienteImovel[0] != null){
							guiaDevolucaoRelatorioHelper.setNomeCliente("" + dadosClienteImovel[0]);
						}
						if(dadosClienteImovel[1] != null){
							guiaDevolucaoRelatorioHelper.setCpfCliente("" + dadosClienteImovel[1]);
						}
						if(dadosClienteImovel[2] != null){
							guiaDevolucaoRelatorioHelper.setCnpjCliente("" + dadosClienteImovel[2]);
						}
						if(dadosClienteImovel[3] != null){
							guiaDevolucaoRelatorioHelper.setIdentidadeCliente("" + dadosClienteImovel[3]);
						}
						if(dadosClienteImovel[4] != null){
							guiaDevolucaoRelatorioHelper.setOrgaoExpedidor("" + dadosClienteImovel[4]);
						}
						if(dadosClienteImovel[5] != null){
							guiaDevolucaoRelatorioHelper.setUnidadeFederacao("" + dadosClienteImovel[5]);
						}
					}
				}else{
					// Cliente

					String enderecoClienteResponsavel = this.getControladorEndereco().pesquisarEnderecoClienteAbreviado(
									guiaDevolucaoRelatorioHelper.getIdCliente());
					guiaDevolucaoRelatorioHelper.setEndereco(enderecoClienteResponsavel);
				}

				try{

					Object[] dadosContaAgencia = null;
					dadosContaAgencia = repositorioArrecadacao.pesquisarContaAgenciaSistemaParametro();

					// Número da conta corrente para débito
					if(dadosContaAgencia[0] != null){
						guiaDevolucaoRelatorioHelper.setConta((String) dadosContaAgencia[0]);
					}
					// Código da agência para débito
					if(dadosContaAgencia[1] != null){
						String agenciaStr = (String) dadosContaAgencia[1];
						guiaDevolucaoRelatorioHelper.setAgencia(Integer.valueOf(agenciaStr.trim()));
					}

				}catch(ErroRepositorioException ex){
					ex.printStackTrace();
					throw new ControladorException("erro.sistema", ex);
				}

				colecaoGuiaDevolucaoRelatorioHelper.add(guiaDevolucaoRelatorioHelper);
			}
		}

		return colecaoGuiaDevolucaoRelatorioHelper;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para pesquisar os pagamento historicos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos historicos do Imóvel
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoImovel(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoImovel(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método que pesquisa os pagamentos histórico para tela de consulta de Imóvel
	 * 
	 * @author Saulo Lima
	 * @date 09/02/2009
	 * @param idImovel
	 * @return Collection<PagamentoHistorico>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoConsultaImovel(Integer idImovel) throws ControladorException{

		Collection<PagamentoHistorico> colecaoPagamentosHistorico = new ArrayList<PagamentoHistorico>();
		Collection<PagamentoHistorico> colecaoPagamentosHistoricoImovel = null;

		try{
			colecaoPagamentosHistoricoImovel = repositorioArrecadacao.pesquisarPagamentoHistoricoConsultaImovel(idImovel);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		try{
			if(colecaoPagamentosHistoricoImovel != null && !colecaoPagamentosHistoricoImovel.isEmpty()){

				Iterator<PagamentoHistorico> iteratorPagamentoHist = colecaoPagamentosHistoricoImovel.iterator();
				while(iteratorPagamentoHist.hasNext()){
					PagamentoHistorico pagamentoHistorico = iteratorPagamentoHist.next();

					if(pagamentoHistorico.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)){

						// Pesquisar ContaHistorico na base.
						if(pagamentoHistorico.getConta() != null){

							FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
							filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, pagamentoHistorico
											.getConta().getId()));

							Collection<ContaHistorico> colecaoContaHistorico = getControladorUtil().pesquisar(filtroContaHistorico,
											ContaHistorico.class.getName());

							if(colecaoContaHistorico != null && !colecaoContaHistorico.isEmpty()){
								ContaHistorico contaHistorico = (ContaHistorico) Util.retonarObjetoDeColecao(colecaoContaHistorico);
								pagamentoHistorico.setConta(contaHistorico);
							}
						}
						colecaoPagamentosHistorico.add(pagamentoHistorico);

					}else if(pagamentoHistorico.getDocumentoTipo().getId().equals(DocumentoTipo.GUIA_PAGAMENTO)){

						// Pesquisar guiaPagamentoHistorico na base.
						if(pagamentoHistorico.getGuiaPagamentoGeral() != null){

							Integer idGuiaPagamento = pagamentoHistorico.getGuiaPagamentoGeral().getId();

							FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
							filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID,
											idGuiaPagamento));
							Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = this.getControladorUtil().pesquisar(
											filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());

							if(colecaoGuiaPagamentoHistorico != null && !colecaoGuiaPagamentoHistorico.isEmpty()){
								GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
												.retonarObjetoDeColecao(colecaoGuiaPagamentoHistorico);

								pagamentoHistorico.getGuiaPagamentoGeral().setGuiaPagamentoHistorico(guiaPagamentoHistorico);
							}
						}
						colecaoPagamentosHistorico.add(pagamentoHistorico);

					}else if(pagamentoHistorico.getDocumentoTipo().getId().equals(DocumentoTipo.DEBITO_A_COBRAR)){

						// Pesquisar DebitoACobrarHistorico na base.
						if(pagamentoHistorico.getDebitoACobrar() != null){
							Integer idDebitoACobrar = pagamentoHistorico.getDebitoACobrar().getId();

							FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
							filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.ID,
											idDebitoACobrar));
							filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrarHistorico.IMOVEL);
							filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrarHistorico.DEBITO_TIPO);
							Collection<DebitoACobrarHistorico> colecaoDebitoACobrarHistorico = this.getControladorUtil().pesquisar(
											filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());

							if(colecaoDebitoACobrarHistorico != null && !colecaoDebitoACobrarHistorico.isEmpty()){
								DebitoACobrarHistorico debitoACobrarHistorico = (DebitoACobrarHistorico) Util
												.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico);
								DebitoACobrar debitoACobrar = new DebitoACobrar();
								debitoACobrar.setId(debitoACobrarHistorico.getId());
								debitoACobrar.setImovel(debitoACobrarHistorico.getImovel());
								debitoACobrar.setDebitoTipo(debitoACobrarHistorico.getDebitoTipo());
								pagamentoHistorico.setDebitoACobrar(debitoACobrar);
							}
						}
						colecaoPagamentosHistorico.add(pagamentoHistorico);
					}
				}
			}
		}catch(Exception ex){
			ex.printStackTrace();
			throw new ControladorException(ex.getMessage(), ex);
		}

		return colecaoPagamentosHistorico;
	}

	/**
	 * Filtar a quantiade de pagamento historicos do imovel [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoImovelCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoImovelCount(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Filtra os pagamento historicos do Imovel para paginação
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoImovelParaPaginacao(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoImovelParaPaginacao(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina,
							codigoSetorComercialInicial, codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores,
							idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Filtra os Pagamento Historicos do Cliente Conta
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoClienteConta(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoHistoricoClienteConta(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();

					// Id do Pagamento
					if(dadosPagamento[0] != null){
						pagamentoHistorico.setId((Integer) dadosPagamento[0]);
					}

					ContaHistorico conta = null;

					// Id da Conta
					if(dadosPagamento[1] != null){
						conta = new ContaHistorico();
						conta.setId((Integer) dadosPagamento[1]);
					}

					// Ano Mês Referência da Conta
					if(dadosPagamento[2] != null){
						conta.setAnoMesReferenciaConta((Integer) dadosPagamento[2]);
					}

					// Valor da Água da Conta
					if(dadosPagamento[3] != null){
						conta.setValorAgua((BigDecimal) dadosPagamento[3]);
					}

					// Valor de Esgoto da Conta
					if(dadosPagamento[4] != null){
						conta.setValorEsgoto((BigDecimal) dadosPagamento[4]);
					}

					// Valor de Débitos
					if(dadosPagamento[5] != null){
						conta.setValorDebitos((BigDecimal) dadosPagamento[5]);
					}

					// Valor dos Créditos
					if(dadosPagamento[6] != null){
						conta.setValorCreditos((BigDecimal) dadosPagamento[6]);
					}

					pagamentoHistorico.setConta(conta);

					// Data do Pagamento
					if(dadosPagamento[7] != null){
						pagamentoHistorico.setDataPagamento((Date) dadosPagamento[7]);
					}

					// Ano Mês do Pagamento
					if(dadosPagamento[8] != null){
						pagamentoHistorico.setAnoMesReferenciaPagamento((Integer) dadosPagamento[8]);
					}

					// Valor do Pagamento
					if(dadosPagamento[9] != null){
						pagamentoHistorico.setValorPagamento((BigDecimal) dadosPagamento[9]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[10] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) dadosPagamento[10]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[11] != null){
						pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamento[11]);
					}

					pagamentoHistorico.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if(dadosPagamento[12] != null){
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior.setId((Integer) dadosPagamento[12]);
					}

					// Descrição da Situação Anterior do Pagamento
					if(dadosPagamento[13] != null){
						pagamentoSituacaoAnterior.setDescricaoAbreviada((String) dadosPagamento[13]);
					}

					pagamentoHistorico.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if(dadosPagamento[14] != null){
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[14]);
						pagamentoHistorico.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel
					if(dadosPagamento[15] != null){
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[15]);
						pagamentoHistorico.setImovel(imovel);
					}

					// Aviso Bancario
					if(dadosPagamento[16] != null){
						setarAvisoBancarioDaConsulta((Integer) dadosPagamento[16], pagamentoHistorico);
					}


					retorno.add(pagamentoHistorico);

				}

			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Filtrar os pagamentos historicos do Cliente Guia Pagamento
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 06/10/06
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoClienteGuiaPagamento(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection<PagamentoHistorico> retorno = new ArrayList();
		Collection<Object[]> colecaoDadosPagamento = null;

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoHistoricoClienteGuiaPagamento(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();

					// Id do Pagamento
					if(dadosPagamento[0] != null){
						pagamentoHistorico.setId((Integer) dadosPagamento[0]);
					}

					// Id do Cliente
					if(dadosPagamento[2] != null){
						Cliente cliente = new Cliente();
						cliente.setId((Integer) dadosPagamento[2]);
						pagamentoHistorico.setCliente(cliente);
					}

					// Data do Pagamento
					if(dadosPagamento[3] != null){
						pagamentoHistorico.setDataPagamento((Date) dadosPagamento[3]);
					}

					// Ano Mês do Pagamento
					if(dadosPagamento[4] != null){
						pagamentoHistorico.setAnoMesReferenciaPagamento((Integer) dadosPagamento[4]);
					}

					DebitoTipo debitoTipoPagamento = null;

					// Id do Tipo de Débito do Pagamento
					if(dadosPagamento[5] != null){
						debitoTipoPagamento = new DebitoTipo();
						debitoTipoPagamento.setId((Integer) dadosPagamento[5]);
					}

					// Descrição do Tipo de Débito do Pagamento
					if(dadosPagamento[6] != null){
						debitoTipoPagamento.setDescricao((String) dadosPagamento[6]);
					}

					pagamentoHistorico.setDebitoTipo(debitoTipoPagamento);

					// Valor do Pagamento
					if(dadosPagamento[7] != null){
						pagamentoHistorico.setValorPagamento((BigDecimal) dadosPagamento[7]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[8] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) dadosPagamento[8]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[9] != null){
						pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamento[9]);
					}

					pagamentoHistorico.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if(dadosPagamento[10] != null){
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior.setId((Integer) dadosPagamento[10]);
					}

					// Descrição da Situação Anterior do Pagamento
					if(dadosPagamento[11] != null){
						pagamentoSituacaoAnterior.setDescricaoAbreviada((String) dadosPagamento[11]);
					}

					pagamentoHistorico.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if(dadosPagamento[12] != null){
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[12]);
						pagamentoHistorico.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel
					if(dadosPagamento[13] != null){
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[13]);
						pagamentoHistorico.setImovel(imovel);
					}

					// Prestacao do Pagamento
					if(dadosPagamento[15] != null){
						pagamentoHistorico.setNumeroPrestacao((Integer) dadosPagamento[15]);
					}

					// verifica se o PagamentoHistorico referencia uma Prestação de Guia em
					// Histórico ou Não
					if(dadosPagamento[1] != null && dadosPagamento[15] != null){
						// Id da Guia de Pagamento

						FiltroGuiaPagamentoGeral filtroGuiaGeral = new FiltroGuiaPagamentoGeral();
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.GUIA_PAGAMENTO);
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.PRESTACOES_GUIA_PAGAMENTO);
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.PRESTACOES_HISTORICO_GUIA_PAGAMENTO);
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.GUIA_PAGAMENTO_HISTORICO);
						filtroGuiaGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.PRESTACOES_HISTORICO_GUIA_PAGAMENTO_HISTORICO);
						filtroGuiaGeral.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoGeral.ID, ((Integer) dadosPagamento[1])));

						Collection<GuiaPagamentoGeral> colecaoGuiaPagamentoGeral = getControladorUtil().pesquisar(filtroGuiaGeral,
										GuiaPagamentoGeral.class.getName());
						for(GuiaPagamentoGeral guiaPagamentoGeral : colecaoGuiaPagamentoGeral){
							pagamentoHistorico.setGuiaPagamentoGeral(guiaPagamentoGeral);
						}
					}

					// Aviso Bancario
					if(dadosPagamento[16] != null){
						setarAvisoBancarioDaConsulta((Integer) dadosPagamento[16], pagamentoHistorico);
					}

					retorno.add(pagamentoHistorico);

				}

			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Filtra os pagamentos historicos do debito a cobrar
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 12/06/06,06/10/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoClienteDebitoACobrar(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoHistoricoClienteDebitoACobrar(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();

					// Id do Pagamento
					if(dadosPagamento[0] != null){
						pagamentoHistorico.setId((Integer) dadosPagamento[0]);
					}

					DebitoACobrar debitoACobrar = null;

					// Id do Imóvel do Pagamento
					if(dadosPagamento[1] != null){
						Imovel imovelPagamento = new Imovel();
						imovelPagamento.setId((Integer) dadosPagamento[1]);
						pagamentoHistorico.setImovel(imovelPagamento);
					}

					// Id do Débito a Cobrar
					if(dadosPagamento[2] != null){
						debitoACobrar = new DebitoACobrar();
						debitoACobrar.setId((Integer) dadosPagamento[2]);
					}

					// Valor do Débito
					if(dadosPagamento[3] != null){
						debitoACobrar.setValorDebito((BigDecimal) dadosPagamento[3]);
					}

					// Número de Prestações Cobradas
					if(dadosPagamento[4] != null){
						debitoACobrar.setNumeroPrestacaoCobradas((Short) dadosPagamento[4]);
					}

					// Número de Prestações Débito
					if(dadosPagamento[5] != null){
						debitoACobrar.setNumeroPrestacaoDebito((Short) dadosPagamento[5]);
					}

					// Data do Pagamento
					if(dadosPagamento[6] != null){
						pagamentoHistorico.setDataPagamento((Date) dadosPagamento[6]);
					}

					// Ano Mês do Pagamento
					if(dadosPagamento[7] != null){
						pagamentoHistorico.setAnoMesReferenciaPagamento((Integer) dadosPagamento[7]);
					}

					DebitoTipo debitoTipoDebito = null;

					// Id do Tipo de Débito do Débito a Cobrar
					if(dadosPagamento[8] != null){
						debitoTipoDebito = new DebitoTipo();
						debitoTipoDebito.setId((Integer) dadosPagamento[8]);
					}

					// Descrição do Tipo de Débito do Débito a Cobrar
					if(dadosPagamento[9] != null){
						debitoTipoDebito.setDescricao((String) dadosPagamento[9]);
					}

					debitoACobrar.setDebitoTipo(debitoTipoDebito);

					DebitoTipo debitoTipoPagamento = null;

					// Id do Tipo de Débito do Pagamento
					if(dadosPagamento[10] != null){
						debitoTipoPagamento = new DebitoTipo();
						debitoTipoPagamento.setId((Integer) dadosPagamento[10]);
					}

					// Descrição do Tipo de Débito do Pagamento
					if(dadosPagamento[11] != null){
						debitoTipoPagamento.setDescricao((String) dadosPagamento[11]);
					}

					pagamentoHistorico.setDebitoTipo(debitoTipoPagamento);

					// Valor do Pagamento
					if(dadosPagamento[12] != null){
						pagamentoHistorico.setValorPagamento((BigDecimal) dadosPagamento[12]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[13] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[14] != null){
						pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamento[14]);
					}

					pagamentoHistorico.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if(dadosPagamento[15] != null){
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior.setId((Integer) dadosPagamento[15]);
					}

					// Descrição da Situação Anterior do Pagamento
					if(dadosPagamento[16] != null){
						pagamentoSituacaoAnterior.setDescricaoAbreviada((String) dadosPagamento[16]);
					}

					pagamentoHistorico.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if(dadosPagamento[17] != null){
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[17]);
						pagamentoHistorico.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel do Débito a Cobrar
					if(dadosPagamento[18] != null){
						Imovel imovelDebito = new Imovel();
						imovelDebito.setId((Integer) dadosPagamento[18]);
						debitoACobrar.setImovel(imovelDebito);
					}

					pagamentoHistorico.setDebitoACobrar(debitoACobrar);

					// Aviso Bancario
					if(dadosPagamento[19] != null){
						setarAvisoBancarioDaConsulta((Integer) dadosPagamento[19], pagamentoHistorico);
					}

					
					retorno.add(pagamentoHistorico);

				}

			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Filtrar a quantidade de pagamento historicos do cliente
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Santos
	 * @date 06/10/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoClienteCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoClienteCount(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Filtra os pagamento historicos do cliente
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 21/08/06,06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoCliente(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoCliente(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Filtra a quantiadade dos Pagamento Historicos da Localidade
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoLocalidadeCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoLocalidadeCount(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Filtra os Pagamento Historicos da Localidade
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoLocalidade(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoLocalidade(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Filtra oas pagamento historicos do Aviso Bancario
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoAvisoBancario(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoAvisoBancario(idImovel, idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal, idsPagamentosSituacoes,
							idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Filtra a quantidade de pagamento historicos do avio bancario
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoAvisoBancarioCount(String idImovel, String idCliente, String idTipoRelacao,
					String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, Collection<Integer> idsArrecadadores,
					String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoAvisoBancarioCount(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Filtra os pagamento historicos do aviso bancario para paginação
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoAvisoBancarioParaPaginacao(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoAvisoBancarioParaPaginacao(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina,
							codigoSetorComercialInicial, codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores,
							idsCategoria);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Filtrar pagamentos historicos do movimento arrecador
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoMovimentoArrecadador(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoMovimentoArrecadador(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Faz a pesquisa de devoluçãoHistorico fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 09/10/2006
	 * @param FiltroDevolucaoHistorico
	 * @return Collection<DevolucaoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<DevolucaoHistorico> pesquisarDevolucaoHistorico(FiltroDevolucaoHistorico filtroDevolucaoHistorico)
					throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarDevolucaoHistorico(filtroDevolucaoHistorico);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * histórico para o Relatório
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos histórico do tipo Debito a Cobrar do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 17/12/06
	 * @author Saulo Lima
	 * @date 08/01/2009
	 *       Nova forma de preencher o PagamentoRelatorioHelper e acréscimo do Generics nas coleções
	 * @return Collection<PagamentoRelatorioHelper>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoRelatorioHelper> pesquisarPagamentoHistoricoLocalidadeRelatorio(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		Collection<Object> colecaoDadosPagamento = null;
		Collection<PagamentoRelatorioHelper> colecaoPagamento = new ArrayList();

		try{

			colecaoDadosPagamento = repositorioArrecadacao.pesquisarPagamentoHistoricoLocalidadeRelatorio(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, codigoSetorComercialInicial,
							codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores, idsCategoria);

			if(colecaoDadosPagamento != null && !colecaoDadosPagamento.isEmpty()){

				Iterator<Object> colecaoDadosPagamentoIterator = colecaoDadosPagamento.iterator();

				while(colecaoDadosPagamentoIterator.hasNext()){

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if(dadosPagamento[1] != null){ // 1,2
						pagamentoRelatorioHelper.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if(dadosPagamento[3] != null){ // 3,4
						pagamentoRelatorioHelper.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if(dadosPagamento[5] != null){ // 5
						pagamentoRelatorioHelper.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if(dadosPagamento[6] != null){ // 6,7
						pagamentoRelatorioHelper.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if(dadosPagamento[8] != null){ // 8
						pagamentoRelatorioHelper.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if(dadosPagamento[9] != null){ // 9
						pagamentoRelatorioHelper.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if(dadosPagamento[10] != null){ // 10
						pagamentoRelatorioHelper.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if(dadosPagamento[11] != null){ // 11
						pagamentoRelatorioHelper.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor do Pagamento
					if(dadosPagamento[12] != null){ // 12
						pagamentoRelatorioHelper.setValorPagamento((BigDecimal) dadosPagamento[12]);
					}

					// Id da Situação Atual do Pagamento
					if(dadosPagamento[13] != null){ // 13
						pagamentoRelatorioHelper.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if(dadosPagamento[14] != null){ // 14
						pagamentoRelatorioHelper.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[14]);
					}

					// Id do Tipo de Documento
					if(dadosPagamento[15] != null){ // 15
						pagamentoRelatorioHelper.setIdDocumentoTipo((Integer) dadosPagamento[15]);
					}

					// Id do Debito A Cobrar
					if(dadosPagamento[16] != null){ // 16
						pagamentoRelatorioHelper.setIdDebitoACobrar((Integer) dadosPagamento[16]);
					}

					// Id da Guia de Pagamento
					if(dadosPagamento[17] != null){ // 17
						pagamentoRelatorioHelper.setIdGuiaPagamento((Integer) dadosPagamento[17]);
					}

					// Número da Prestação da Guia de Pagamento
					if(dadosPagamento[18] != null){ // 18
						pagamentoRelatorioHelper.setNumeroPrestacaoGuia((Integer) dadosPagamento[18]);
					}

					if(dadosPagamento[19] != null){
						pagamentoRelatorioHelper.setCodigoSetorComercial((Integer) dadosPagamento[19]);
					}

					if(dadosPagamento[20] != null){
						pagamentoRelatorioHelper.setIdConta((Integer) dadosPagamento[20]);
					}

					// Verifica o Tipo do Documento do pagamento e consulta os dados restantes
					// (normal ou histórico)
					Integer idDocumentoTipo = pagamentoRelatorioHelper.getIdDocumentoTipo();
					if(idDocumentoTipo != null){

						// Pagamentos de Conta
						if(idDocumentoTipo.intValue() == DocumentoTipo.CONTA){

							FiltroConta filtroConta = new FiltroConta();
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, pagamentoRelatorioHelper
											.getIdImovel()));
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, pagamentoRelatorioHelper
											.getAnoMesReferenciaPagamento()));
							Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

							Conta conta = null;
							if(colecaoConta != null && !colecaoConta.isEmpty()){
								conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

								pagamentoRelatorioHelper.setValorAgua(conta.getValorAgua());
								pagamentoRelatorioHelper.setValorEsgoto(conta.getValorEsgoto());
								pagamentoRelatorioHelper.setDebitos(conta.getDebitos());
								pagamentoRelatorioHelper.setValorCreditos(conta.getValorCreditos());
								pagamentoRelatorioHelper.setValorImpostos(conta.getValorImposto());

							}

							if(conta == null){
								FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
								filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.IMOVEL_ID,
												pagamentoRelatorioHelper.getIdImovel()));
								filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ANO_MES_REFERENCIA,
												pagamentoRelatorioHelper.getAnoMesReferenciaPagamento()));
								Collection<ContaHistorico> colecaoContaHistorico = this.getControladorUtil().pesquisar(
												filtroContaHistorico, ContaHistorico.class.getName());

								ContaHistorico contaHistorico = null;
								if(colecaoContaHistorico != null && !colecaoContaHistorico.isEmpty()){
									contaHistorico = (ContaHistorico) Util.retonarObjetoDeColecao(colecaoContaHistorico);

									pagamentoRelatorioHelper.setValorAgua(contaHistorico.getValorAgua());
									pagamentoRelatorioHelper.setValorEsgoto(contaHistorico.getValorEsgoto());
									pagamentoRelatorioHelper.setDebitos(contaHistorico.getValorDebitos());
									pagamentoRelatorioHelper.setValorCreditos(contaHistorico.getValorCreditos());
									pagamentoRelatorioHelper.setValorImpostos(contaHistorico.getValorImposto());
								}
							}

							// Pagamentos de Debito A Cobrar
						}else if(idDocumentoTipo.intValue() == DocumentoTipo.DEBITO_A_COBRAR){
							FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
							filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, pagamentoRelatorioHelper
											.getIdDebitoACobrar()));
							Collection<DebitoACobrar> colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar,
											DebitoACobrar.class.getName());

							DebitoACobrar debitoACobrar = null;
							if(colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()){

								debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
								pagamentoRelatorioHelper.setNumeroPrestacaoDebito(debitoACobrar.getNumeroPrestacaoDebito());
								pagamentoRelatorioHelper.setNumeroPrestacaoCobradas(debitoACobrar.getNumeroPrestacaoCobradas());
								pagamentoRelatorioHelper.setValorDebito(debitoACobrar.getValorDebito());
							}

							if(debitoACobrar == null){
								FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
								filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.ID,
												pagamentoRelatorioHelper.getIdDebitoACobrar()));
								Collection<DebitoACobrarHistorico> colecaoDebitoACobrarHistorico = this.getControladorUtil().pesquisar(
												filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());

								DebitoACobrarHistorico debitoACobrarHistorico = null;
								if(colecaoDebitoACobrarHistorico != null && !colecaoDebitoACobrarHistorico.isEmpty()){

									debitoACobrarHistorico = (DebitoACobrarHistorico) Util
													.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico);
									pagamentoRelatorioHelper.setNumeroPrestacaoDebito(debitoACobrarHistorico.getPrestacaoDebito());
									pagamentoRelatorioHelper.setNumeroPrestacaoCobradas(debitoACobrarHistorico.getPrestacaoCobradas());
									pagamentoRelatorioHelper.setValorDebito(debitoACobrarHistorico.getValorDebito());

								}
							}

							// Pagamentos de Guia de Pagamento
						}else if(idDocumentoTipo.intValue() == DocumentoTipo.GUIA_PAGAMENTO){

							FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
							filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, pagamentoRelatorioHelper
											.getIdGuiaPagamento()));
							filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
											FiltroGuiaPagamento.DEBITO_CREDITO_SITUACAO_ATUAL_ID, DebitoCreditoSituacao.NORMAL));

							Collection<GuiaPagamento> colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamento,
											GuiaPagamento.class.getName());

							if(colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()){

								FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
								filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(
												FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID, pagamentoRelatorioHelper
																.getIdGuiaPagamento()));
								filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(
												FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO, pagamentoRelatorioHelper
																.getNumeroPrestacaoGuia()));

								Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = getControladorUtil().pesquisar(
												filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

								if(colecaoGuiaPagamentoPrestacao != null && !colecaoGuiaPagamentoPrestacao.isEmpty()){
									GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) Util
													.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);
									pagamentoRelatorioHelper.setValorDebito(guiaPagamentoPrestacao.getValorPrestacao());
								}else{
									FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
									filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, pagamentoRelatorioHelper
																	.getIdGuiaPagamento()));
									filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, pagamentoRelatorioHelper
																	.getNumeroPrestacaoGuia()));

									Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = getControladorUtil()
													.pesquisar(filtroGuiaPagamentoPrestacaoHistorico,
																	GuiaPagamentoPrestacaoHistorico.class.getName());

									if(colecaoGuiaPagamentoPrestacaoHistorico != null && !colecaoGuiaPagamentoPrestacaoHistorico.isEmpty()){
										GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) Util
														.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHistorico);
										pagamentoRelatorioHelper.setValorDebito(guiaPagamentoPrestacaoHistorico.getValorPrestacao());
									}
								}

							}else{
								// tenta buscar em Histórico
								FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
								filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID,
												pagamentoRelatorioHelper.getIdGuiaPagamento()));
								filtroGuiaPagamentoHistorico
												.adicionarParametro(new ParametroSimples(
																FiltroGuiaPagamentoHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
																DebitoCreditoSituacao.NORMAL));

								Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = getControladorUtil().pesquisar(
												filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());
								if(colecaoGuiaPagamentoHistorico != null && !colecaoGuiaPagamentoHistorico.isEmpty()){
									FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
									filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, pagamentoRelatorioHelper
																	.getIdGuiaPagamento()));
									filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, pagamentoRelatorioHelper
																	.getNumeroPrestacaoGuia()));

									Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = getControladorUtil()
													.pesquisar(filtroGuiaPagamentoPrestacaoHistorico,
																	GuiaPagamentoPrestacaoHistorico.class.getName());

									if(colecaoGuiaPagamentoPrestacaoHistorico != null && !colecaoGuiaPagamentoPrestacaoHistorico.isEmpty()){
										GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) Util
														.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHistorico);
										pagamentoRelatorioHelper.setValorDebito(guiaPagamentoPrestacaoHistorico.getValorPrestacao());
									}
								}
							}
						}
					}
					colecaoPagamento.add(pagamentoRelatorioHelper);
				}
			}
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * Consulta dados da tabela dados diarios arrecadacao
	 * 
	 * @author Rafael Santos
	 * @created 21/10/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ArrecadacaoDadosDiarios consultarDadosDiarios(int idGerenciaRegional, int idLocalidade, int idElo) throws ControladorException{

		Collection colecaoDadosDiarios = null;

		ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = null;

		try{
			colecaoDadosDiarios = repositorioArrecadacao.consultarDadosDiarios(idGerenciaRegional, idLocalidade, idElo);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDadosDiarios != null && !colecaoDadosDiarios.isEmpty()){

			Object[] dados = (Object[]) colecaoDadosDiarios.iterator().next();

			arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();

			// gerencia regional
			if(dados[0] != null){
				GerenciaRegional gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setNome((String) dados[0]);
				arrecadacaoDadosDiarios.setGerenciaRegional(gerenciaRegional);
			}

			// localidade
			Localidade localidade = null;

			if(dados[1] != null){
				localidade = new Localidade();
				localidade.setDescricao((String) dados[1]);
				arrecadacaoDadosDiarios.setLocalidade(localidade);
			}

			// elo
			if(dados[2] != null){
				if(localidade == null){
					localidade = new Localidade();
				}
				Localidade elo = new Localidade();
				elo.setDescricao((String) dados[2]);
				localidade.setLocalidade(elo);
				arrecadacaoDadosDiarios.setLocalidade(localidade);
			}

		}

		return arrecadacaoDadosDiarios;
	}

	/**
	 * Este método se destina a validar todas as situações e particularidades da
	 * inserir guia de devolução no momento da exibição.
	 * [FS0002] Validar registro de atendimento [FS0004] Validar ordem de
	 * servico.
	 * 
	 * @author Rafael Pinto
	 * @date 06/11/2006
	 * @param RegistroAtendimento
	 *            ,OrdemServico
	 */
	public void validarExibirInserirGuiaDevolucao(RegistroAtendimento ra, OrdemServico ordemServico) throws ControladorException{

		// [FS0002] Validar registro de atendimento
		if(ra != null){

			Imovel imovel = ra.getImovel();

			// Caso o Registro Atendimento não esteja associado a um imóvel e não esteja associado
			// um cliente
			FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();
			filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID, ra.getId()));
			filtro.adicionarCaminhoParaCarregamentoEntidade("cliente");
			Collection colecaoRegistros = getControladorUtil().pesquisar(filtro, RegistroAtendimentoSolicitante.class.getName());

			if(colecaoRegistros != null && !colecaoRegistros.isEmpty()){

				Iterator itera = colecaoRegistros.iterator();
				while(itera.hasNext()){
					RegistroAtendimentoSolicitante raSoli = (RegistroAtendimentoSolicitante) itera.next();

					if(raSoli.getIndicadorSolicitantePrincipal() == ConstantesSistema.SIM.shortValue()){
						if(raSoli.getCliente() == null && imovel == null){
							throw new ControladorException("atencao.registro.atendimento.sem.imovel.cliente", null, "" + ra.getId());
						}

					}
				}

			}else if(imovel == null){
				throw new ControladorException("atencao.registro.atendimento.sem.imovel.cliente", null, "" + ra.getId());
			}

			// Caso a situação do Registro de Atendimento não seja encerrada
			if(ra.getAtendimentoMotivoEncerramento() != null){
				throw new ControladorException("atencao.registro_atendimento.esta.encerrado");
			}

			// Caso o tipo de solicitação do registro atendimento
			// não permita a geração de guia de devolução
			if(ra.getSolicitacaoTipoEspecificacao().getIndicadorGeracaoCredito().intValue() == ConstantesSistema.NAO.intValue()){
				throw new ControladorException("atencao.registro_atendimento.nao.permite.guia.devolucao");
			}

			// [FS0007] Validar ordem de servico.
		}else if(ordemServico != null){

			// Caso a Ordem de Serviço não esteja associada a um Registro de
			// Atendimento
			if(ordemServico.getRegistroAtendimento() == null){
				throw new ControladorException("atencao.ordem_servico.nao.esta.associado.registro_atendimento");
			}

			RegistroAtendimento registroAtendimento = ordemServico.getRegistroAtendimento();

			Imovel imovel = registroAtendimento.getImovel();

			// Caso a Ordem de Serviço esteja associada a um Registro Atendimento,
			// porém o Registro Atendimento não esteja associado a um imóvel e não esteja associado
			// um cliente
			FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();
			filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
							registroAtendimento.getId()));
			filtro.adicionarCaminhoParaCarregamentoEntidade("cliente");
			Collection colecaoRegistros = getControladorUtil().pesquisar(filtro, RegistroAtendimentoSolicitante.class.getName());

			if(colecaoRegistros != null && !colecaoRegistros.isEmpty()){

				Iterator itera = colecaoRegistros.iterator();
				while(itera.hasNext()){
					RegistroAtendimentoSolicitante raSoli = (RegistroAtendimentoSolicitante) itera.next();

					if(raSoli.getIndicadorSolicitantePrincipal() == ConstantesSistema.SIM.shortValue()){
						if(raSoli.getCliente() == null && imovel == null){
							throw new ControladorException("atencao.registro.atendimento.sem.imovel.cliente", null, ""
											+ registroAtendimento.getId());
						}

					}
				}

			}else if(imovel == null){
				throw new ControladorException("atencao.registro.atendimento.sem.imovel.cliente", null, "" + registroAtendimento.getId());
			}

		}
	}

	/**
	 * Metodo responsável pela remoção das guias de devolução
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 24/11/2006
	 * @param idImovel
	 * @param usuarioLogado
	 * @param ids
	 * @param pacoteNomeObjeto
	 * @param operacaoEfetuada
	 * @param acaoUsuarioHelper
	 * @throws ControladorException
	 */
	public void removerGuiaDevolucao(String idImovel, Usuario usuarioLogado, String[] ids, String pacoteNomeObjeto,
					OperacaoEfetuada operacaoEfetuada, Collection<UsuarioAcaoUsuarioHelper> acaoUsuarioHelper) throws ControladorException{

		Imovel imovel = new Imovel();
		imovel.setId(Integer.valueOf(idImovel));

		/**
		 * alterado por pedro alexandre dia 24/11/2006 alteração feita para
		 * acoplar o controle de abrangência de usuário
		 */
		// ------------ CONTROLE DE ABRANGENCIA ----------------
		Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

		if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.acesso.negado.abrangencia");
		}else{
			this.getControladorUtil().remover(ids, pacoteNomeObjeto, operacaoEfetuada, acaoUsuarioHelper);
		}
		// ------------ FIM CONTROLE DE ABRANGENCIA ------------
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @throws ControladorException
	 */
	public Integer filtrarMovimentoArrecadadoresCount(String codigoBanco, String codigoRemessa, String descricaoIdentificacaoServico,
					String idImovel, String numeroSequencialArquivo, Date dataGeracaoInicio, Date dataGeracaoFim,
					Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia, String indicadorAceitacao,
					String idConcessionaria)
					throws ControladorException{

		try{
			return repositorioArrecadacao.filtrarMovimentoArrecadadoresCount(codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
							idImovel, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim, ultimaAlteracaoInicio,
							ultimaAlteracaoFim, descricaoOcorrencia, indicadorAceitacao, idConcessionaria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param numeroPagina
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<FiltrarMovimentoArrecadadoresHelper> filtrarMovimentoArrecadadorParaPaginacao(String codigoBanco, String codigoRemessa,
					String descricaoIdentificacaoServico, String idImovel, String numeroSequencialArquivo, Date dataGeracaoInicio,
					Date dataGeracaoFim, Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia,
					String indicadorAceitacao, Integer numeroPagina, String idConcessionaria) throws ControladorException{

		Collection<FiltrarMovimentoArrecadadoresHelper> retorno = new LinkedList<FiltrarMovimentoArrecadadoresHelper>();
		Collection colecaoMovimentoArrecadadores = null;

		try{

			colecaoMovimentoArrecadadores = repositorioArrecadacao.filtrarMovimentoArrecadadorParaPaginacao(codigoBanco, codigoRemessa,
							descricaoIdentificacaoServico, idImovel, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
							ultimaAlteracaoInicio, ultimaAlteracaoFim, descricaoOcorrencia, indicadorAceitacao, numeroPagina,
							idConcessionaria);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		Iterator iteratorMovimentoArrecadadoresTotal = colecaoMovimentoArrecadadores.iterator();

		while(iteratorMovimentoArrecadadoresTotal.hasNext()){

			FiltrarMovimentoArrecadadoresHelper filtrarMovimentoArrecadadoresHelper = new FiltrarMovimentoArrecadadoresHelper();
			ArrecadadorMovimento arrecadadorMovimentoRetorno = new ArrecadadorMovimento();
			Object[] arrecadadorMovimento = (Object[]) iteratorMovimentoArrecadadoresTotal.next();

			if(arrecadadorMovimento[0] != null){// 0
				// codigo do banco
				arrecadadorMovimentoRetorno.setCodigoBanco(Short.valueOf(arrecadadorMovimento[0].toString()));
			}

			if(arrecadadorMovimento[1] != null){// 1
				// codigo remessa
				arrecadadorMovimentoRetorno.setCodigoRemessa(Short.valueOf(arrecadadorMovimento[1].toString()));
			}

			if(arrecadadorMovimento[2] != null){// 2
				// descrição indentificação do serviço
				arrecadadorMovimentoRetorno.setDescricaoIdentificacaoServico(arrecadadorMovimento[2].toString());
			}

			if(arrecadadorMovimento[3] != null){// 3
				// nsa
				arrecadadorMovimentoRetorno.setNumeroSequencialArquivo(Integer.valueOf(arrecadadorMovimento[3].toString()));
			}

			if(arrecadadorMovimento[4] != null){// 4
				// id de arrecadadorMovimento
				arrecadadorMovimentoRetorno.setId(Integer.valueOf(arrecadadorMovimento[4].toString()));
			}

			if(arrecadadorMovimento[5] != null){// 5
				// data de geração
				arrecadadorMovimentoRetorno.setDataGeracao((Date) arrecadadorMovimento[5]);
			}

			if(arrecadadorMovimento[6] != null){// 6
				// numero Registros Movimento
				arrecadadorMovimentoRetorno.setNumeroRegistrosMovimento(Integer.valueOf(arrecadadorMovimento[6].toString()));
			}

			if(arrecadadorMovimento[7] != null){// 7
				// valor Total do Movimento
				arrecadadorMovimentoRetorno.setValorTotalMovimento(new BigDecimal(arrecadadorMovimento[7].toString()));
			}

			if(arrecadadorMovimento[8] != null){// 8
				// ultima alteração
				arrecadadorMovimentoRetorno.setUltimaAlteracao((Date) arrecadadorMovimento[8]);
			}

			if(arrecadadorMovimento[9] != null){// 9
				// nome banco
				arrecadadorMovimentoRetorno.setNomeBanco((String) arrecadadorMovimento[9]);
			}

			filtrarMovimentoArrecadadoresHelper.setArrecadadorMovimento(arrecadadorMovimentoRetorno);
			
			if(idConcessionaria != null){

				Integer idConc = null;
				String nomeConcessionaria = null;

				if(arrecadadorMovimento[10] != null){
					idConc = (Integer) arrecadadorMovimento[10];
					nomeConcessionaria = (String) arrecadadorMovimento[11];
				}
				filtrarMovimentoArrecadadoresHelper.setIdConcessionaria(idConc);
				filtrarMovimentoArrecadadoresHelper.setNomeConcessionaria(nomeConcessionaria);
			}
			
			retorno.add(filtrarMovimentoArrecadadoresHelper);
		}

		if(retorno == null || retorno.isEmpty()){
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return retorno;

	}

	/**
	 * Pesquisar os ids das localidades que possuem pagamentos
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 04/12/2006
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Integer> pesquisarIdsLocalidadeComPagamentosOuDevolucoes() throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarIdsLocalidadeComPagamentosOuDevolucoes();
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Classifica os pagamentos para tipo de documento igual a débito a cobrar.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre, Saulo Lima
	 * @date 29/11/2006, 05/06/2007, 22/11/2008
	 * @param colecaoPagamentosDebitoACobrarPreenchido
	 * @param colecaoPagamentosDebitoACobrarNaoPreenchido
	 * @throws ControladorException
	 */
	protected Collection<Pagamento> classificarPagamentosDebitoACobrar(Collection colecaoPagamentosDebitoACobrarPreenchido,
					Collection colecaoPagamentosDebitoACobrarNaoPreenchido, Pagamento pagamentoAClassificar) throws ControladorException{

		/* Declaração de variáveis. */
		Collection<Pagamento> retorno = new ArrayList<Pagamento>();
		Collection colecaoPagamentosAtualizar = new ArrayList();
		Collection colecaoConjuntoPagamentos = new ArrayList();
		Iterator iteratorColecaoConjuntoPagamentos = null;
		boolean conjuntoFechado = false;
		boolean primeiraEntrada = true;
		Localidade localidadeAnterior = null;
		Imovel imovelAnterior = null;
		DebitoTipo debitoTipoAnterior = null;
		Object[] pagamentoArray = null;
		Collection colecaoPagamentosDuplicados = new ArrayList();
		Collection colecaoPagamentosPagos = new ArrayList();
		Collection colecaoPagamentosCancelados = new ArrayList();
		Collection colecaoPagamentosParcelados = new ArrayList();

		/*
		 * ==========================================================================================
		 * ======
		 * Para os pagamentos com tipo de documento (DOPT_ID) com o valor correspondente a DÉBITO A
		 * COBRAR:
		 * ==========================================================================================
		 * ======
		 */

		// Para os pagamentos com débito a cobrar preenchido (DBAC_ID diferente de nulo)
		if(colecaoPagamentosDebitoACobrarPreenchido != null && !colecaoPagamentosDebitoACobrarPreenchido.isEmpty()){

			// Para cada conjunto de pagamentos com mesmo débito a cobrar (DBAC_ID):
			Iterator iteratorcolecaoPagamentosDebitoACobrarPreenchido = colecaoPagamentosDebitoACobrarPreenchido.iterator();
			Pagamento pagamento = null;
			primeiraEntrada = true;
			conjuntoFechado = false;
			DebitoACobrar debitoACobrarAnterior = null;
			DebitoACobrar debitoACobrar = null;
			colecaoConjuntoPagamentos.clear();

			/* Laço para criar os conjuntos de pagamentos para o mesmo débito a cobrar. */
			while(iteratorcolecaoPagamentosDebitoACobrarPreenchido.hasNext()){

				pagamentoArray = (Object[]) iteratorcolecaoPagamentosDebitoACobrarPreenchido.next();

				DocumentoTipo documentoTipo = null;
				if(pagamentoArray[1] != null){
					documentoTipo = new DocumentoTipo();
					documentoTipo.setId((Integer) pagamentoArray[1]);
				}

				Localidade localidade = null;
				if(pagamentoArray[2] != null){
					localidade = new Localidade();
					localidade.setId((Integer) pagamentoArray[2]);
				}

				Imovel imovel = null;
				if(pagamentoArray[3] != null){
					imovel = new Imovel();
					imovel.setId((Integer) pagamentoArray[3]);
				}

				PagamentoSituacao pagamentoSituacaoAtual = null;
				if(pagamentoArray[4] != null){
					pagamentoSituacaoAtual = new PagamentoSituacao();
					pagamentoSituacaoAtual.setId((Integer) pagamentoArray[4]);
				}

				if(pagamentoArray[5] != null){
					debitoACobrar = (DebitoACobrar) pagamentoArray[5];
				}else{
					debitoACobrar = null;
				}

				pagamento = (Pagamento) pagamentoArray[0];
				pagamento.setDocumentoTipo(documentoTipo);
				pagamento.setLocalidade(localidade);
				pagamento.setImovel(imovel);
				pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);
				pagamento.setDebitoACobrar(debitoACobrar);

				if(!primeiraEntrada){

					if(pagamento.getDebitoACobrar().getId().equals(debitoACobrarAnterior.getId())){
						colecaoConjuntoPagamentos.add(pagamento);
					}else{
						conjuntoFechado = true;
					}

				}else{
					primeiraEntrada = false;
					colecaoConjuntoPagamentos.add(pagamento);
				}

				if(conjuntoFechado){

					// [SF0006] Processar Pagamento de Débito a Cobrar
					retorno.addAll(this.processarPagamentoDebitoACobrar(debitoACobrarAnterior, colecaoConjuntoPagamentos));

					colecaoConjuntoPagamentos = new ArrayList();
					colecaoConjuntoPagamentos.add(pagamento);
				}

				debitoACobrarAnterior = pagamento.getDebitoACobrar();
			}

			/* Último registro */
			if(!colecaoConjuntoPagamentos.isEmpty()){

				// [SF0006] Processar Pagamento de Débito a Cobrar
				retorno.addAll(this.processarPagamentoDebitoACobrar(debitoACobrarAnterior, colecaoConjuntoPagamentos));

				colecaoConjuntoPagamentos = new ArrayList();
			}

		}

		// Para os pagamentos sem débito a cobrar preenchido (DBAC_ID igual a nulo)
		if(colecaoPagamentosDebitoACobrarNaoPreenchido != null && !colecaoPagamentosDebitoACobrarNaoPreenchido.isEmpty()){

			/*
			 * Para cada conjunto de pagamentos com mesma localidade, mesma matrícula do imóvel, e
			 * mesmo tipo de débito:
			 */
			Iterator iteratorColecaoPagamentosDebitoACobrarNaoPreenchido = colecaoPagamentosDebitoACobrarNaoPreenchido.iterator();
			Pagamento pagamento = null;
			primeiraEntrada = true;
			conjuntoFechado = false;
			DebitoACobrar debitoACobrarConjunto = null;

			colecaoConjuntoPagamentos.clear();

			while(iteratorColecaoPagamentosDebitoACobrarNaoPreenchido.hasNext()){

				pagamentoArray = (Object[]) iteratorColecaoPagamentosDebitoACobrarNaoPreenchido.next();

				DocumentoTipo documentoTipo = null;
				if(pagamentoArray[1] != null){
					documentoTipo = new DocumentoTipo();
					documentoTipo.setId((Integer) pagamentoArray[1]);
				}

				Localidade localidade = null;
				if(pagamentoArray[2] != null){
					localidade = new Localidade();
					localidade.setId((Integer) pagamentoArray[2]);
				}

				Imovel imovel = null;
				if(pagamentoArray[3] != null){
					imovel = new Imovel();
					imovel.setId((Integer) pagamentoArray[3]);
				}

				PagamentoSituacao pagamentoSituacaoAtual = null;
				if(pagamentoArray[4] != null){
					pagamentoSituacaoAtual = new PagamentoSituacao();
					pagamentoSituacaoAtual.setId((Integer) pagamentoArray[4]);
				}

				pagamento = (Pagamento) pagamentoArray[0];
				pagamento.setDocumentoTipo(documentoTipo);
				pagamento.setLocalidade(localidade);
				pagamento.setImovel(imovel);
				pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

				if(!primeiraEntrada){

					if((localidadeAnterior == null && pagamento.getLocalidade() == null)
									|| (localidadeAnterior != null && pagamento.getLocalidade() != null && localidadeAnterior.getId()
													.equals(pagamento.getLocalidade().getId()))){

						if((imovelAnterior == null && pagamento.getImovel() == null)
										|| (imovelAnterior != null && pagamento.getImovel() != null && imovelAnterior.getId().equals(
														pagamento.getImovel().getId()))){

							if((debitoTipoAnterior == null && pagamento.getDebitoTipo() == null)
											|| (debitoTipoAnterior != null && pagamento.getDebitoTipo() != null && debitoTipoAnterior
															.getId().equals(pagamento.getDebitoTipo().getId()))){

								colecaoConjuntoPagamentos.add(pagamento);

							}else{
								conjuntoFechado = true;
							}
						}else{
							conjuntoFechado = true;
						}
					}else{
						conjuntoFechado = true;
					}

				}else{
					primeiraEntrada = false;
					colecaoConjuntoPagamentos.add(pagamento);
				}

				if(conjuntoFechado){

					/* [SF0005] Selecionar Débito a Cobrar pela Localidade, Imóvel e Tipo de Débito */
					debitoACobrarConjunto = this.selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(imovelAnterior, debitoTipoAnterior);

					/*
					 * Caso o débito a cobrar não seja encontrado (retorno nulo do [SB0005]) e a
					 * situação atual (PGST_IDATUAL) não corresponda a
					 * baixar valor excedente (tabela PAGAMENTO_SITUACAO), atualizar a situação
					 * atual dos pagamentos (PGST_IDATUAL) com valor
					 * correspondente a documento inexistente (tabela PAGAMENTO_SITUACAO) e o valor
					 * excedente (PGMT_VLEXCEDENTE) com o valor do
					 * pagamento
					 */
					if(debitoACobrarConjunto == null){

						iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos.iterator();

						while(iteratorColecaoConjuntoPagamentos.hasNext()){

							Pagamento pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos.next();

							if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
											|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
															.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR))){

								pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());

								colecaoPagamentosAtualizar.add(pagamentoConjunto);
							}
						}
					}else{
						iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos.iterator();


						// [SF0006] Processar Pagamento de Débito a Cobrar
						retorno.addAll(this.processarPagamentoDebitoACobrar(debitoACobrarConjunto, colecaoConjuntoPagamentos));


					}

					colecaoConjuntoPagamentos = new ArrayList();
					colecaoConjuntoPagamentos.add(pagamento);
				}

				localidadeAnterior = pagamento.getLocalidade();
				imovelAnterior = pagamento.getImovel();
				debitoTipoAnterior = pagamento.getDebitoTipo();
			}

			/* Último registro */
			if(!colecaoConjuntoPagamentos.isEmpty()){

				/* [SF0005] Selecionar Débito a Cobrar pela Localidade, Imóvel e Tipo de Débito */
				debitoACobrarConjunto = this.selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(imovelAnterior, debitoTipoAnterior);

				/*
				 * Caso o débito a cobrar não seja encontrado (retorno nulo do [SB0005]) e a
				 * situação atual (PGST_IDATUAL) não corresponda a
				 * baixar valor excedente (tabela PAGAMENTO_SITUACAO), atualizar a situação atual
				 * dos pagamentos (PGST_IDATUAL) com valor
				 * correspondente a documento inexistente (tabela PAGAMENTO_SITUACAO) e o valor
				 * excedente (PGMT_VLEXCEDENTE) com o valor do
				 * pagamento
				 */
				if(debitoACobrarConjunto == null){

					iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos.iterator();

					while(iteratorColecaoConjuntoPagamentos.hasNext()){

						Pagamento pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos.next();

						if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
										|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
														.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR))){

							// Pegar o imovel e consultar em debito a cobrar historico com a ref do
							// pagamento
							Collection collDebitoACobrarHistorico = new ArrayList();

							try{
								collDebitoACobrarHistorico = repositorioArrecadacao.pesquisarDebitoACobrarHistorico(pagamentoConjunto
												.getImovel().getId(), pagamentoConjunto.getDebitoTipo().getId());
							}catch(ErroRepositorioException e){
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							DebitoACobrarHistorico debitoACobrarHistorico = (DebitoACobrarHistorico) Util
											.retonarObjetoDeColecao(collDebitoACobrarHistorico);

							if(debitoACobrarHistorico != null){
								if(debitoACobrarHistorico.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.NORMAL)
												|| debitoACobrarHistorico.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.RETIFICADA)){

									pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());

									if(debitoACobrarHistorico.getValorDebito().compareTo(pagamentoConjunto.getValorPagamento()) == 0){
										colecaoPagamentosDuplicados.add(pagamentoConjunto);
									}else{
										colecaoPagamentosPagos.add(pagamentoConjunto);
									}

								}else if(debitoACobrarHistorico.getDebitoCreditoSituacaoAtual().getId()
												.equals(DebitoCreditoSituacao.CANCELADA)){
									colecaoPagamentosCancelados.add(pagamentoConjunto);
								}else if(debitoACobrarHistorico.getDebitoCreditoSituacaoAtual().getId()
												.equals(DebitoCreditoSituacao.PARCELADA)){
									colecaoPagamentosParcelados.add(pagamentoConjunto);
								}

							}
						}

					}
				}else{

					iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos.iterator();

					// [SF0006] Processar Pagamento de Débito a Cobrar
					retorno.addAll(this.processarPagamentoDebitoACobrar(debitoACobrarConjunto, colecaoConjuntoPagamentos));


				}
				colecaoConjuntoPagamentos = new ArrayList();
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosDuplicados != null && !colecaoPagamentosDuplicados.isEmpty()){

			try{
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosDuplicados,
								PagamentoSituacao.PAGAMENTO_DUPLICADO);

			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosPagos != null && !colecaoPagamentosPagos.isEmpty()){

			try{
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosPagos,
								PagamentoSituacao.PAGAMENTO_DOC_PAGO);

			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosCancelados != null && !colecaoPagamentosCancelados.isEmpty()){

			try{
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosCancelados,
								PagamentoSituacao.PAGAMENTO_DOC_CANCELADO);

			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosParcelados != null && !colecaoPagamentosParcelados.isEmpty()){

			try{
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosParcelados,
								PagamentoSituacao.PAGAMENTO_DOC_PARCELADO);

			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja vazia atualizar a situação e o
		 * valor excedente do pagamento.
		 */
		if(colecaoPagamentosAtualizar != null && !colecaoPagamentosAtualizar.isEmpty()){
			try{
				System.out.println("ATUALIZANDO PAGAMENTO DEBITO A COBRAR");
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosAtualizar,
								PagamentoSituacao.FATURA_INEXISTENTE);
			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * ==========================================================================================
		 * FIM pagamentos com tipo de documento (DOPT_ID) com valor correspondente a DÉBITO A
		 * COBRAR:
		 * ==========================================================================================
		 */
		return retorno;
	}

	/**
	 * [UC0721] - Distribuir dados do Registro de Movimento do Arrecadador da Ficha de Compensação
	 * Autor: Vivianne Sousa
	 * Data: 23/11/2007
	 */
	public Object distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(String linha, String descricaoOcorrencia)
					throws ControladorException{

		Object registroHelperCodigo = null;

		char codigoRegistro = linha.substring(7, 8).charAt(0);

		switch(codigoRegistro){

			case '0':
				RegistroHelperCodigo0 registroHelperCodigo0 = new RegistroHelperCodigo0();

				registroHelperCodigo0.setCodigoBancoCompensacao(linha.substring(0, 3).trim());

				registroHelperCodigo0.setLoteServico(linha.substring(3, 7).trim());

				registroHelperCodigo0.setCodigoRegistro(linha.substring(7, 8).trim());

				registroHelperCodigo0.setUsoExclusivo04(linha.substring(8, 17).trim());

				registroHelperCodigo0.setTipoInscricaoEmpresa(linha.substring(17, 18).trim());

				registroHelperCodigo0.setNumeroInscricaoEmpresa(linha.substring(18, 32).trim());

				registroHelperCodigo0.setCodigoConvenioBanco(linha.substring(32, 52).trim());

				registroHelperCodigo0.setAgenciaMantedoraConta(linha.substring(52, 57).trim());

				registroHelperCodigo0.setDigitoVerificadorAgencia(linha.substring(57, 58).trim());

				registroHelperCodigo0.setNumeroContaCorrente(linha.substring(58, 70).trim());

				registroHelperCodigo0.setDigitoVerificadorConta(linha.substring(70, 71).trim());

				registroHelperCodigo0.setDigitoVerificadorAgConta(linha.substring(71, 72).trim());

				registroHelperCodigo0.setNomeEmpresa(linha.substring(72, 92).trim());

				registroHelperCodigo0.setNomeBanco(linha.substring(102, 132).trim());

				registroHelperCodigo0.setUsoExclusivo15(linha.substring(132, 142).trim());

				registroHelperCodigo0.setCodigoRemessaRetorno(linha.substring(142, 143).trim());

				registroHelperCodigo0.setDataGeracaoArquivo(linha.substring(143, 151).trim());

				registroHelperCodigo0.setHoraGeracaoArquivo(linha.substring(151, 157).trim());

				registroHelperCodigo0.setNumeroSequencialArquivo(linha.substring(157, 163).trim());

				registroHelperCodigo0.setNumeroVersaoLayoutArquivo(linha.substring(163, 166).trim());

				registroHelperCodigo0.setDensidadeGravacaoArquivo(linha.substring(166, 171).trim());

				registroHelperCodigo0.setReservadoBanco(linha.substring(171, 191).trim());

				registroHelperCodigo0.setReservadoEmpresa(linha.substring(191, 211).trim());

				registroHelperCodigo0.setUsoExclusivo24(linha.substring(211, 222).trim());

				registroHelperCodigo0.setCobrancaSemPapel(linha.substring(222, 225).trim());

				registroHelperCodigo0.setUsoExclusivoVans(linha.substring(225, 228).trim());

				registroHelperCodigo0.setTipoServico(linha.substring(228, 230).trim());

				registroHelperCodigo0.setCodigoOcorrencias(linha.substring(230, 240).trim());

				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigo0;
				break;

			case '1':
				RegistroHelperCodigo1 registroHelperCodigo1 = new RegistroHelperCodigo1();

				registroHelperCodigo1.setCodigoBancoCompensacao(linha.substring(0, 3).trim());

				registroHelperCodigo1.setLoteServico(linha.substring(3, 7).trim());

				registroHelperCodigo1.setCodigoRegistro(linha.substring(7, 8).trim());

				registroHelperCodigo1.setTipoOperacao(linha.substring(8, 9).trim());

				registroHelperCodigo1.setTipoServico(linha.substring(9, 11).trim());

				registroHelperCodigo1.setFormaLancamento(linha.substring(11, 13).trim());

				registroHelperCodigo1.setNumeroVersaoLayoutArquivo(linha.substring(13, 16).trim());

				registroHelperCodigo1.setUsoExclusivo08(linha.substring(16, 17).trim());

				registroHelperCodigo1.setTipoInscricaoEmpresa(linha.substring(17, 18).trim());

				registroHelperCodigo1.setNumeroInscricaoEmpresa(linha.substring(18, 33).trim());

				registroHelperCodigo1.setCodigoConvenioBanco(linha.substring(33, 53).trim());

				registroHelperCodigo1.setAgenciaMantedoraConta(linha.substring(53, 58).trim());

				registroHelperCodigo1.setDigitoVerificadorAgencia(linha.substring(58, 59).trim());

				registroHelperCodigo1.setNumeroContaCorrente(linha.substring(59, 71).trim());

				registroHelperCodigo1.setDigitoVerificadorConta(linha.substring(71, 72).trim());

				registroHelperCodigo1.setDigitoVerificadorAgConta(linha.substring(72, 73).trim());

				registroHelperCodigo1.setNomeEmpresa(linha.substring(73, 103).trim());

				registroHelperCodigo1.setMensagem1(linha.substring(103, 143).trim());

				registroHelperCodigo1.setMensagem2(linha.substring(143, 183).trim());

				registroHelperCodigo1.setNumeroRemessaRetorno(linha.substring(183, 191).trim());

				registroHelperCodigo1.setDataGravacaoRemessaRetorno(linha.substring(191, 199).trim());

				registroHelperCodigo1.setDataCredito(linha.substring(199, 207).trim());

				registroHelperCodigo1.setUsoExclusivo23(linha.substring(207, 240).trim());

				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigo1;
				break;

			case '3':

				String codSegmento = linha.substring(13, 14).trim();

				registroHelperCodigo = this.distribuirRegistroCodigoTresFichaCompensacao(linha, codSegmento);

				break;

			case '5':
				RegistroHelperCodigo5 registroHelperCodigo5 = new RegistroHelperCodigo5();

				registroHelperCodigo5.setCodigoBancoCompensacao(linha.substring(0, 3).trim());

				registroHelperCodigo5.setLoteServico(linha.substring(3, 7).trim());

				registroHelperCodigo5.setCodigoRegistro(linha.substring(7, 8).trim());

				registroHelperCodigo5.setUsoExclusivo04(linha.substring(8, 17).trim());

				registroHelperCodigo5.setQtdeRegistrosLote(linha.substring(17, 23).trim());

				registroHelperCodigo5.setQtdeTITCobranca06(linha.substring(23, 29).trim());

				registroHelperCodigo5.setValorTITCarteira07(linha.substring(29, 46).trim());

				registroHelperCodigo5.setQtdeTITCobranca08(linha.substring(46, 52).trim());

				registroHelperCodigo5.setValorTITCarteira09(linha.substring(52, 69).trim());

				registroHelperCodigo5.setQtdeTITCobranca10(linha.substring(69, 75).trim());

				registroHelperCodigo5.setValorTITCarteira11(linha.substring(75, 92).trim());

				registroHelperCodigo5.setQtdeTITCobranca12(linha.substring(92, 98).trim());

				registroHelperCodigo5.setValorTITCarteira13(linha.substring(98, 115).trim());

				registroHelperCodigo5.setNumeroAvisoLancamento(linha.substring(115, 123).trim());

				registroHelperCodigo5.setUsoExclusivo15(linha.substring(123, 240).trim());

				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigo5;
				break;

			case '9':
				RegistroHelperCodigo9 registroHelperCodigo9 = new RegistroHelperCodigo9();

				registroHelperCodigo9.setCodigoBancoCompensacao(linha.substring(0, 3).trim());

				registroHelperCodigo9.setLoteServico(linha.substring(3, 7).trim());

				registroHelperCodigo9.setCodigoRegistro(linha.substring(7, 8).trim());

				registroHelperCodigo9.setUsoExclusivo04(linha.substring(8, 17).trim());

				registroHelperCodigo9.setQtdeLoteArquivo(linha.substring(17, 23).trim());

				registroHelperCodigo9.setQtdeRegistrosArquivo(linha.substring(23, 29).trim());

				registroHelperCodigo9.setQtdeContas(linha.substring(29, 35).trim());

				registroHelperCodigo9.setUsoExclusivo08(linha.substring(35, 240).trim());

				// faz um cast para o object
				registroHelperCodigo = registroHelperCodigo9;
				break;

		}
		return registroHelperCodigo;
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SF0015] - Gerar Ocorrência da ficha na coleção de Avisos Bancários
	 * Autor: Vivianne Sousa
	 * Data: 27/11/2007
	 */
	public AvisoBancario gerarOcorrenciaFichaAvisoBancario(Integer idMovimento, RegistroHelperCodigo0 registroHelperCodigo0,
					Date dataPrevistaCredito, Integer spAnoMesArrecadacao, String codigoBanco, BigDecimal valorArrecadacaoInf,
					BigDecimal valorArrecadacaoCalc, BigDecimal valorDevolucaoCalc, BigDecimal valorDevolucaoInf,
					Short numeroSequencialAvisoBancario, ArrecadadorContrato arrecadadorContrato) throws ControladorException{

		// instância o aviso bancário
		AvisoBancario avisoBancario = new AvisoBancario();

		// seta os campos no aviso bancário
		Arrecadador arrecadador = new Arrecadador();
		arrecadador.setId(Integer.valueOf(registroHelperCodigo0.getCodigoBancoCompensacao()));
		avisoBancario.setArrecadador(arrecadador);
		Date dataLancamento = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigo0.getDataGeracaoArquivo());
		avisoBancario.setDataLancamento(dataLancamento);
		avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);
		avisoBancario.setDataPrevista(dataPrevistaCredito);
		avisoBancario.setDataRealizada(dataPrevistaCredito);

		avisoBancario.setValorRealizado(valorArrecadacaoInf);
		avisoBancario.setValorArrecadacaoCalculado(valorArrecadacaoCalc);
		avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInf);
		avisoBancario.setValorDevolucaoCalculado(BigDecimal.ZERO);
		avisoBancario.setValorDevolucaoInformado(BigDecimal.ZERO);
		avisoBancario.setValorContabilizado(BigDecimal.ZERO);
		Integer anoMesDataLancamento = Util.recuperaAnoMesDaData(dataLancamento);
		if(anoMesDataLancamento > spAnoMesArrecadacao){
			avisoBancario.setAnoMesReferenciaArrecadacao(anoMesDataLancamento);
		}else{
			avisoBancario.setAnoMesReferenciaArrecadacao(spAnoMesArrecadacao);
		}
		avisoBancario.setIndicadorCreditoDebito(AvisoBancario.INDICADOR_CREDITO);
		avisoBancario.setNumeroDocumento(0);
		avisoBancario.setUltimaAlteracao(new Date());

		ContaBancaria contaBancaria = null;

		if(arrecadadorContrato != null){
			ContaBancaria contaBancariaDepositoArrecadacao = arrecadadorContrato.getContaBancariaDepositoArrecadacao();

			if(contaBancariaDepositoArrecadacao != null){
				Integer idContaBancaria = contaBancariaDepositoArrecadacao.getId();

				contaBancaria = new ContaBancaria();
				contaBancaria.setId(idContaBancaria);
			}
		}

		avisoBancario.setContaBancaria(contaBancaria);
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);

		return avisoBancario;
	}

	/**
	 * [UC0276] - Gerar Resumo do Faturamento
	 * [UC0188] - Manter Guia de Pagamento
	 * Transfere para o histórico as guias de pagamentos e os relacionamentos
	 * ligados a ela.
	 * 
	 * @author Felipe Rosacruz
	 * @date 31/05/2013
	 *       Alteração para a Geração de Históricos por Prestação de Guia de Pagamento.
	 *       Pré-Requisito : Set de Prestações de Cada Guia que Será(ão) Cancelada(s) deve estar
	 *       populado com as prestações que serão canceladas.
	 *       Tipo de Situação do Debito/Credito da Prestação também já deve estar definido com o
	 *       valor desejado. Ex. CANCELADO, PARCELADO, ETC.
	 * @param colecaoGuiasPagamento
	 * @throws ControladorException
	 */
	public void transferirGuiaPagamentoParaHistorico(Collection<GuiaPagamento> colecaoGuiasPagamento) throws ControladorException{

		transferirGuiaPagamentoParaHistoricoRegistrarOperacao(colecaoGuiasPagamento, null, null);
	}

	/**
	 * [UC0276] - Gerar Resumo do Faturamento
	 * [UC0188] - Manter Guia de Pagamento
	 * Transfere para o histórico as guias de pagamentos e os relacionamentos
	 * ligados a ela.
	 * 
	 * @author Felipe Rosacruz
	 * @date 31/05/2013
	 *       Alteração para a Geração de Históricos por Prestação de Guia de Pagamento.
	 *       Pré-Requisito : Set de Prestações de Cada Guia que Será(ão) Cancelada(s) deve estar
	 *       populado com as prestações que serão canceladas.
	 *       Tipo de Situação do Debito/Credito da Prestação também já deve estar definido com o
	 *       valor desejado. Ex. CANCELADO, PARCELADO, ETC.
	 *       Chamar este método para registrar a operação.
	 * @param colecaoGuiasPagamento
	 * @throws ControladorException
	 */
	public void transferirGuiaPagamentoParaHistorico(Collection<GuiaPagamento> colecaoGuiasPagamento, Usuario usuario, Integer idOperacao)
					throws ControladorException{

		transferirGuiaPagamentoParaHistoricoRegistrarOperacao(colecaoGuiasPagamento, usuario, idOperacao);
	}

	/**
	 * [UC0276] - Gerar Resumo do Faturamento
	 * [UC0188] - Manter Guia de Pagamento
	 * Transfere para o histórico as guias de pagamentos e os relacionamentos
	 * ligados a ela.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @author eduardo henrique
	 * @date 18/08/2008
	 *       Alteração para a Geração de Históricos por Prestação de Guia de Pagamento.
	 *       Pré-Requisito : Set de Prestações de Cada Guia que Será(ão) Cancelada(s) deve estar
	 *       populado com as prestações que serão canceladas.
	 *       Tipo de Situação do Debito/Credito da Prestação também já deve estar definido com o
	 *       valor desejado. Ex. CANCELADO, PARCELADO, ETC.
	 * @author eduardo henrique
	 * @date 15/07/2009
	 *       Retirada da desvinculação de Guia de Pagamento ao possível Pagamento associado.
	 * @param colecaoGuiasPagamento
	 * @param usuario
	 * @param idOperacao
	 * @throws ControladorException
	 */
	private void transferirGuiaPagamentoParaHistoricoRegistrarOperacao(Collection<GuiaPagamento> colecaoGuiasPagamento, Usuario usuario,
					Integer idOperacao) throws ControladorException{

		try{

			if(colecaoGuiasPagamento != null && !colecaoGuiasPagamento.isEmpty()){

				SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
				if(sistemaParametro == null){
					throw new ControladorException("erro.sistema"); // Cadastrar Mensagem
				}

				for(Iterator iterator = colecaoGuiasPagamento.iterator(); iterator.hasNext();){
					GuiaPagamento guiaPagamento = (GuiaPagamento) iterator.next();

					Collection colecaoGuiasPagamentoCategoriaRemover = new ArrayList();
					/*
					 * Início do novo método
					 */

					// Transfere as informações das Prestações para o histórico (Prestação e
					// Categoria)
					this.enviarGuiaPagamentoPrestacaoParaHistorico(guiaPagamento.getGuiasPagamentoPrestacao(), usuario, idOperacao);

					// Busca as Categorias Correspondentes às Prestações
					Map mapGuiaPagamentoNumeroPrestacao = new HashMap<String, GuiaPagamentoPrestacao>();
					// Map que servirá de suporte para saber se já foi adicionado a Guia
					// + Nr.Prestação + Id do LancamentoItemContabil (Suficiente para realizar a Lo

					for(Iterator iteratorPrestacao = guiaPagamento.getGuiasPagamentoPrestacao().iterator(); iteratorPrestacao.hasNext();){
						GuiaPagamentoPrestacao guiaPrestacao = (GuiaPagamentoPrestacao) iteratorPrestacao.next();

						String idMap = guiaPrestacao.getComp_id().getGuiaPagamentoId().toString()
										+ guiaPrestacao.getComp_id().getItemLancamentoContabilId().toString()
										+ guiaPrestacao.getComp_id().getNumeroPrestacao().toString();

						if(!mapGuiaPagamentoNumeroPrestacao.containsKey(idMap)){
							mapGuiaPagamentoNumeroPrestacao.put(idMap, guiaPrestacao);
						}
					}

					// Itera no resultado do Map para Montar a Coleção de Categorias correspondentes
					// às Prestações
					for(Iterator iteratorCategoria = mapGuiaPagamentoNumeroPrestacao.values().iterator(); iteratorCategoria.hasNext();){
						GuiaPagamentoPrestacao guiaPrestacao = (GuiaPagamentoPrestacao) iteratorCategoria.next();

						// Consulta as Categorias da Prestação para Cancelamento também
						FiltroGuiaPagamentoCategoria filtroGuiaPagamentoCategoria = new FiltroGuiaPagamentoCategoria();
						filtroGuiaPagamentoCategoria.adicionarParametro(new ParametroSimples(
										FiltroGuiaPagamentoCategoria.GUIA_PAGAMENTO_ID, guiaPrestacao.getComp_id().getGuiaPagamentoId()));
						filtroGuiaPagamentoCategoria.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoCategoria.NUMERO_PRESTACAO,
										guiaPrestacao.getComp_id().getNumeroPrestacao()));
						filtroGuiaPagamentoCategoria.adicionarParametro(new ParametroSimples(
										FiltroGuiaPagamentoCategoria.LANCAMENTO_ITEM_CONTABIL_ID, guiaPrestacao.getComp_id()
														.getItemLancamentoContabilId()));

						Collection guiasPagamentoCategorias = getControladorUtil().pesquisar(filtroGuiaPagamentoCategoria,
										GuiaPagamentoCategoria.class.getName());

						if(guiasPagamentoCategorias != null && !guiasPagamentoCategorias.isEmpty()){
							colecaoGuiasPagamentoCategoriaRemover.addAll(guiasPagamentoCategorias);
						}
					}

					this.enviarGuiaPagamentoCategoriaParaHistorico(colecaoGuiasPagamentoCategoriaRemover);

					// Verifica se todas as prestações de cada Guia Foram Canceladas.
					// Se sim, move a Guia e Cliente_Guia para Histórico (utiliza a coleção de
					// Prestações q foram canceladas)

					Map mapGuiaPagamentoCancelar = new HashMap();
					List arrayNumeroPrestacoesGuia = null;

					for(Iterator iteratorPrestacoes = guiaPagamento.getGuiasPagamentoPrestacao().iterator(); iteratorPrestacoes.hasNext();){
						GuiaPagamentoPrestacao guiaPrestacao = (GuiaPagamentoPrestacao) iteratorPrestacoes.next();

						if(!mapGuiaPagamentoCancelar.containsKey(guiaPrestacao.getGuiaPagamento().getId())){
							arrayNumeroPrestacoesGuia = new ArrayList();
							arrayNumeroPrestacoesGuia.add(guiaPrestacao.getComp_id().getNumeroPrestacao());

							mapGuiaPagamentoCancelar.put(guiaPagamento.getId(), arrayNumeroPrestacoesGuia);

						}else{
							List arrayMapNumeroPrestacoes = (ArrayList) mapGuiaPagamentoCancelar.get(guiaPagamento.getId());
							arrayMapNumeroPrestacoes.add(guiaPrestacao.getComp_id().getNumeroPrestacao());
						}
					}

					if(mapGuiaPagamentoCancelar.size() > 0){

						for(Iterator iteratorGuiaPagamento = mapGuiaPagamentoCancelar.keySet().iterator(); iteratorGuiaPagamento.hasNext();){
							Integer idGuiaPagamento = (Integer) iteratorGuiaPagamento.next();

							Collection colecaoGuiaPagamentoCancelar = new ArrayList();
							Collection colecaoGuiaPagamentoHistorico = new ArrayList();
							Collection colecaoGuiaPagamentoGeral = new ArrayList();

							List arrayNumeroPrestacoesDesconsideradas = (ArrayList) mapGuiaPagamentoCancelar.get(idGuiaPagamento);

							Integer idGuiaFinalizada = repositorioArrecadacao.verificarExistenciaPrestacaoGuiaPagamento(idGuiaPagamento,
											arrayNumeroPrestacoesDesconsideradas);
							if(idGuiaFinalizada == null){// encontrou Guia(s) que não tem mais
								// nenhuma prestação
								// Histórico da Guia Pagamento e Cliente_Guia Pagamento
								FiltroGuiaPagamento filtroGuiaPagamentoBase = new FiltroGuiaPagamento();
								filtroGuiaPagamentoBase.adicionarCaminhoParaCarregamentoEntidade("localidade");
								filtroGuiaPagamentoBase.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
								filtroGuiaPagamentoBase.adicionarCaminhoParaCarregamentoEntidade("guiasPagamentoCategoria");
								filtroGuiaPagamentoBase.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));

								Collection guiasPagamentosBase = getControladorUtil().pesquisar(filtroGuiaPagamentoBase,
												GuiaPagamento.class.getName());

								GuiaPagamento guiaPagamentoBase = (GuiaPagamento) Util.retonarObjetoDeColecao(guiasPagamentosBase);
								if(guiaPagamentoBase == null){
									System.out.println("Indentificação do objeto não localizado 'GuiaPagamento': id = " + idGuiaPagamento);
									sessionContext.setRollbackOnly();
									throw new ControladorException("atencao.atualizacao.removido");
								}

								colecaoGuiaPagamentoCancelar.add(guiaPagamentoBase);

								GuiaPagamentoHistorico guiaPagamentoHistorico = new GuiaPagamentoHistorico();
								try{
									PropertyUtils.copyProperties(guiaPagamentoHistorico, guiaPagamentoBase);
								}catch(IllegalAccessException iaex){
									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema");
								}catch(InvocationTargetException itex){
									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema");
								}

								guiaPagamentoHistorico.setUltimaAlteracao(new Date());
								if(usuario != null && idOperacao != null){

									Integer valorArgumento = null;
									Argumento argumento = new Argumento();
									if(guiaPagamentoBase.getImovel() != null){
										valorArgumento = guiaPagamentoBase.getImovel().getId();
										argumento.setId(Argumento.IMOVEL);
									}else{
										argumento.setId(Argumento.CLIENTE);
										valorArgumento = guiaPagamentoBase.getCliente().getId();
									}
									// ------------ REGISTRAR TRANSAÇÃO ----------------
									RegistradorOperacao registradorOperacao = new RegistradorOperacao(idOperacao, valorArgumento,
													argumento,
													guiaPagamentoBase.getId(), new UsuarioAcaoUsuarioHelper(usuario,
																	UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

									registradorOperacao.registrarOperacao(guiaPagamentoBase);
									// ------------ REGISTRAR TRANSAÇÃO ----------------

								}
								colecaoGuiaPagamentoHistorico.add(guiaPagamentoHistorico);

								getControladorUtil().inserirColecaoObjetos(colecaoGuiaPagamentoHistorico);

								this.enviarClienteGuiaPagamentoParaHistorico(guiaPagamentoHistorico, guiaPagamentoBase.getId());

								for(Iterator iterator2 = colecaoGuiaPagamentoCancelar.iterator(); iterator2.hasNext();){
									GuiaPagamento item = (GuiaPagamento) iterator2.next();
									getControladorUtil().removerColecaoObjetos(item.getGuiasPagamentoPrestacao());
									getControladorUtil().removerColecaoObjetos(item.getGuiasPagamentoCategoria());

								}

								getControladorUtil().removerColecaoObjetos(colecaoGuiaPagamentoCancelar);

								// Obtém o Guia_Pagamento_Geral para Atualização
								FiltroGuiaPagamentoGeral filtroGuiaPagamentoGeral = new FiltroGuiaPagamentoGeral();
								filtroGuiaPagamentoGeral.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoGeral.ID,
												guiaPagamentoBase.getId()));

								Collection guiaPagamentoGeral = getControladorUtil().pesquisar(filtroGuiaPagamentoGeral,
												GuiaPagamentoGeral.class.getName());
								if(guiaPagamentoGeral == null || guiaPagamentoGeral.isEmpty()){
									System.out.println("Indentificação do objeto não localizado 'GuiaPagamentoGeral': id = "
													+ guiaPagamentoBase.getId());
									sessionContext.setRollbackOnly();
									throw new ControladorException("atencao.atualizacao.removido");
								}

								GuiaPagamentoGeral guiaPagamentoGeralAtualizar = (GuiaPagamentoGeral) Util
												.retonarObjetoDeColecao(guiaPagamentoGeral);
								guiaPagamentoGeralAtualizar.setIndicadorHistorico(Short.valueOf("1"));
								guiaPagamentoGeralAtualizar.setUltimaAlteracao(new Date());

								colecaoGuiaPagamentoGeral.add(guiaPagamentoGeralAtualizar);

								getControladorUtil().atualizarColecaoObjetos(colecaoGuiaPagamentoGeral);
							}
						}

					}

					/*
					 * Fim do Novo Método
					 */
				}
			}
		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @author eduardo henrique
	 * @date 18/08/2008
	 *       Método para Geração de Históricos para Guia_Pagamento_Prestação
	 *       Caso seja necessário registrar a operação, passar o usuario e o id da operação.
	 * @param colecaoGuiaPagamentoPrestacoes
	 * @throws ControladorException
	 */
	protected void enviarGuiaPagamentoPrestacaoParaHistorico(Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacoes,
					Usuario usuario, Integer idOperacao)
					throws ControladorException{

		try{
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			if(sistemaParametro == null){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema");
			}

			Collection colecaoGuiasPagamentoPrestacaoHistoricoInserir = new ArrayList();
			Collection colecaoGuiasPagamentoPrestacaoRemover = new ArrayList();
			for(Iterator iterator = colecaoGuiaPagamentoPrestacoes.iterator(); iterator.hasNext();){
				GuiaPagamentoPrestacao guiaPrestacao = (GuiaPagamentoPrestacao) iterator.next();

				if(usuario != null && idOperacao != null){
					// ------------ REGISTRAR TRANSAÇÃO ----------------
				Integer valorArgumento = null;
				Argumento argumento = new Argumento();
				if(guiaPrestacao.getGuiaPagamento().getImovel() != null){
					valorArgumento = guiaPrestacao.getGuiaPagamento().getImovel().getId();
					argumento.setId(Argumento.IMOVEL);
				}else{
					valorArgumento = guiaPrestacao.getGuiaPagamento().getCliente().getId();
					argumento.setId(Argumento.CLIENTE);
				}

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(idOperacao, valorArgumento, argumento, valorArgumento,
								new UsuarioAcaoUsuarioHelper(usuario,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
				Operacao operacao = new Operacao();
				operacao.setId(idOperacao);

				OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
				operacaoEfetuada.setOperacao(operacao);

				operacaoEfetuada.setArgumentoValor(valorArgumento);
				guiaPrestacao.setOperacaoEfetuada(operacaoEfetuada);
				guiaPrestacao.adicionarUsuario(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(guiaPrestacao);

					// ------------ REGISTRAR TRANSAÇÃO ----------------
				}


				// Cria uma Guia Prestacao Histórico
				GuiaPagamentoPrestacaoHistoricoPK guiaPrestacaoHistoricoPK = new GuiaPagamentoPrestacaoHistoricoPK(guiaPrestacao
								.getComp_id().getGuiaPagamentoId(), guiaPrestacao.getComp_id().getNumeroPrestacao(), guiaPrestacao
								.getComp_id().getDebitoTipoId(), guiaPrestacao.getComp_id().getItemLancamentoContabilId());
				GuiaPagamentoPrestacaoHistorico guiaPrestacaoHistorico = new GuiaPagamentoPrestacaoHistorico();
				guiaPrestacaoHistorico.setComp_id(guiaPrestacaoHistoricoPK);

				guiaPrestacaoHistorico.setAnoMesReferenciaFaturamento(guiaPrestacao.getAnoMesReferenciaFaturamento());
				guiaPrestacaoHistorico.setDataEmissao(guiaPrestacao.getDataEmissao());
				guiaPrestacaoHistorico.setDataVencimento(guiaPrestacao.getDataVencimento());
				guiaPrestacaoHistorico.setDebitoTipo(guiaPrestacao.getDebitoTipo());
				guiaPrestacaoHistorico.setFinanciamentoTipo(guiaPrestacao.getFinanciamentoTipo());
				guiaPrestacaoHistorico.setIndicadorCobrancaMulta(guiaPrestacao.getIndicadorCobrancaMulta());
				guiaPrestacaoHistorico.setIndicadorPagamentoPendente(guiaPrestacao.getIndicadorPagamentoPendente());
				guiaPrestacaoHistorico.setValorPrestacao(guiaPrestacao.getValorPrestacao());
				guiaPrestacaoHistorico.setDebitoCreditoSituacao(guiaPrestacao.getDebitoCreditoSituacao());
				guiaPrestacaoHistorico.setUltimaAlteracao(new Date());
				guiaPrestacaoHistorico.setIndicadorCobrancaAdministrativa(guiaPrestacao.getIndicadorCobrancaAdministrativa());
				guiaPrestacaoHistorico.setIndicadorRemuneraCobrancaAdministrativa(guiaPrestacao.getIndicadorRemuneraCobrancaAdministrativa());

				// verifica a maior data entre dataFaturamento e o anoMesReferenciaArrecadacao , e a
				// Utiliza
				if(guiaPrestacaoHistorico.getAnoMesReferenciaFaturamento() != null
								&& !guiaPrestacaoHistorico.getAnoMesReferenciaFaturamento().equals(0)
								&& Util.compararAnoMesReferencia(guiaPrestacaoHistorico.getAnoMesReferenciaFaturamento(),
												sistemaParametro.getAnoMesArrecadacao(), ">")){
					guiaPrestacaoHistorico.setAnoMesReferenciaArrecadacao(guiaPrestacaoHistorico.getAnoMesReferenciaFaturamento());
				}else{
					guiaPrestacaoHistorico.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
				}

				colecaoGuiasPagamentoPrestacaoHistoricoInserir.add(guiaPrestacaoHistorico);
				colecaoGuiasPagamentoPrestacaoRemover.add(guiaPrestacao);

			}
			if(usuario == null && idOperacao == null){
				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoGuiasPagamentoPrestacaoHistoricoInserir);

				getControladorBatch().removerColecaoObjetoParaBatch(colecaoGuiasPagamentoPrestacaoRemover);
			}else{
				for(Object guiaPagamentoPrestacao : colecaoGuiasPagamentoPrestacaoRemover.toArray()){
					getControladorUtil().remover((GuiaPagamentoPrestacao) guiaPagamentoPrestacao);
				}
				for(Object guiaPagamentoPrestacaoHistorico : colecaoGuiasPagamentoPrestacaoHistoricoInserir.toArray()){
					GuiaPagamentoPrestacaoHistorico prestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) guiaPagamentoPrestacaoHistorico;
					getControladorUtil().inserir(prestacaoHistorico);
				}

			}
			colecaoGuiasPagamentoPrestacaoHistoricoInserir = null;
			colecaoGuiasPagamentoPrestacaoRemover = null;

		}catch(ControladorException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0276] - Gerar Resumo de Faturamento
	 * Alteração do Método para geração de Históricos de Guia_Pagamento_Categoria
	 * 
	 * @author Pedro Alexandre
	 * @date 05/04/2007
	 * @author eduardo henrique
	 * @date 18/08/2008
	 * @param colecaoCategoriasGuiaPagamento
	 * @throws ErroRepositorioException
	 */
	protected void enviarGuiaPagamentoCategoriaParaHistorico(Collection<GuiaPagamentoCategoria> colecaoCategoriasGuiaPagamento)
					throws ControladorException{

		try{
			Collection colecaoGuiasPagamentoCategoriaHistoricoInserir = new ArrayList();
			Collection colecaoGuiasPagamentoCategoriaRemover = new ArrayList();
			for(Iterator iterator = colecaoCategoriasGuiaPagamento.iterator(); iterator.hasNext();){
				GuiaPagamentoCategoria guiaCategoria = (GuiaPagamentoCategoria) iterator.next();

				// Cria uma Guia Categoria Histórico
				GuiaPagamentoCategoriaHistoricoPK guiaCategoriaHistoricoPK = new GuiaPagamentoCategoriaHistoricoPK(guiaCategoria
								.getComp_id().getCategoriaId(), guiaCategoria.getComp_id().getGuiaPagamentoId(), guiaCategoria.getComp_id()
								.getLancamentoItemContabilId(), guiaCategoria.getComp_id().getNumeroPrestacao());
				GuiaPagamentoCategoriaHistorico guiaCategoriaHistorico = new GuiaPagamentoCategoriaHistorico();
				guiaCategoriaHistorico.setComp_id(guiaCategoriaHistoricoPK);

				guiaCategoriaHistorico.setQuantidadeEconomia(guiaCategoria.getQuantidadeEconomia());
				guiaCategoriaHistorico.setValorCategoria(guiaCategoria.getValorCategoria());
				guiaCategoriaHistorico.setUltimaAlteracao(new Date());

				colecaoGuiasPagamentoCategoriaHistoricoInserir.add(guiaCategoriaHistorico);
				colecaoGuiasPagamentoCategoriaRemover.add(guiaCategoria);
			}

			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoGuiasPagamentoCategoriaHistoricoInserir);

			getControladorBatch().removerColecaoObjetoParaBatch(colecaoGuiasPagamentoCategoriaRemover);

			colecaoGuiasPagamentoCategoriaHistoricoInserir = null;
			colecaoGuiasPagamentoCategoriaRemover = null;

			/*
			 * Collection<GuiaPagamentoCategoria> colecaoGuiaPagamentoCategoria =
			 * repositorioArrecadacao
			 * .pesquisarGuiaPagamentoCategoria(idGuiaPagamento);
			 * GuiaPagamentoCategoriaHistorico guiaPagamentoCategoriaHistoricoTemp = null;
			 * if (colecaoGuiaPagamentoCategoria != null
			 * && !colecaoGuiaPagamentoCategoria.isEmpty()) {
			 * colecaoGuiaPagamentoCategoriaRemover
			 * .addAll(colecaoGuiaPagamentoCategoria);
			 * for (GuiaPagamentoCategoria guiaPagamentoCategoria : colecaoGuiaPagamentoCategoria) {
			 * GuiaPagamentoCategoriaHistoricoPK guiaPagamentoCategoriaHistoricoTempPK = new
			 * GuiaPagamentoCategoriaHistoricoPK(
			 * guiaPagamentoCategoria.getCategoria().getId(),
			 * colecaoCategoriasGuiaPagamento.getId());
			 * guiaPagamentoCategoriaHistoricoTemp = new GuiaPagamentoCategoriaHistorico();
			 * guiaPagamentoCategoriaHistoricoTemp
			 * .setComp_id(guiaPagamentoCategoriaHistoricoTempPK);
			 * guiaPagamentoCategoriaHistoricoTemp
			 * .setCategoria(guiaPagamentoCategoria.getCategoria());
			 * guiaPagamentoCategoriaHistoricoTemp
			 * .setGuiaPagamentoHistorico(colecaoCategoriasGuiaPagamento);
			 * guiaPagamentoCategoriaHistoricoTemp
			 * .setQuantidadeEconomia(guiaPagamentoCategoria
			 * .getQuantidadeEconomia());
			 * guiaPagamentoCategoriaHistoricoTemp
			 * .setUltimaAlteracao(new Date());
			 * guiaPagamentoCategoriaHistoricoTemp
			 * .setValorCategoria(guiaPagamentoCategoria
			 * .getValorCategoria());
			 * colecaoGuiaPagamentoCategoriaHistoricoInserir
			 * .add(guiaPagamentoCategoriaHistoricoTemp);
			 * }
			 */

		}catch(ControladorException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Para cada guia de pagamento transferida para o histórico atualiza o indicador de que a guia
	 * de pagamento está no histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param colecaoGuiasPagamento
	 * @throws ControladorException
	 */
	public void atualizarIndicadorGuiaPagamentoNoHistorico(Collection colecaoGuiasPagamento) throws ControladorException{

		List colecaoTotalGuiasPagamento = (List) colecaoGuiasPagamento;
		int limiteSuperior;
		int limiteInferior;
		int limiteMaximo = colecaoTotalGuiasPagamento.size();
		int quantidadeMaximaPorColecao = 100;

		try{

			for(int i = 0; i < limiteMaximo; i = i + 100){

				// System.out.println("ATUALIZANDO INDICADOR GUIA PAGAMENTO:" + i);

				if(limiteMaximo < quantidadeMaximaPorColecao){
					limiteInferior = 0;
					limiteSuperior = limiteMaximo;
				}else{
					limiteInferior = i;
					limiteSuperior = i + 100;

					if(limiteSuperior > limiteMaximo){
						limiteSuperior = limiteMaximo;
					}
				}

				List colecaoGuiasPagamentoTemporaria = new ArrayList();
				colecaoGuiasPagamentoTemporaria.addAll(colecaoTotalGuiasPagamento.subList(limiteInferior, limiteSuperior));

				this.repositorioArrecadacao.atualizarIndicadorGuiaPagamentoNoHistorico(colecaoGuiasPagamentoTemporaria);

			}

		}catch(Exception ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 05/04/2007
	 * @param guiaPagamentoHistoricoTemp
	 * @param idGuiaPagamento
	 * @throws ErroRepositorioException
	 */
	protected void enviarClienteGuiaPagamentoParaHistorico(GuiaPagamentoHistorico guiaPagamentoHistoricoTemp, Integer idGuiaPagamento)
					throws ControladorException{

		Collection colecaoClienteGuiaPagamentoHistoricoInserir = new ArrayList();
		Collection colecaoClienteGuiaPagamentoRemover = new ArrayList();
		try{
			Collection<ClienteGuiaPagamento> colecaoClienteGuiaPagamento = repositorioArrecadacao
							.pesquisarClienteGuiaPagamento(idGuiaPagamento);

			ClienteGuiaPagamentoHistorico clienteGuiaPagamentoHistoricoTemp = null;

			if(colecaoClienteGuiaPagamento != null && !colecaoClienteGuiaPagamento.isEmpty()){

				colecaoClienteGuiaPagamentoRemover.addAll(colecaoClienteGuiaPagamento);

				for(ClienteGuiaPagamento clienteGuiaPagamento : colecaoClienteGuiaPagamento){
					clienteGuiaPagamentoHistoricoTemp = new ClienteGuiaPagamentoHistorico();
					clienteGuiaPagamentoHistoricoTemp.setId(clienteGuiaPagamento.getId());
					clienteGuiaPagamentoHistoricoTemp.setCliente(clienteGuiaPagamento.getCliente());
					clienteGuiaPagamentoHistoricoTemp.setClienteRelacaoTipo(clienteGuiaPagamento.getClienteRelacaoTipo());
					clienteGuiaPagamentoHistoricoTemp.setGuiaPagamentoHistorico(guiaPagamentoHistoricoTemp);
					clienteGuiaPagamentoHistoricoTemp.setUltimaAlteracao(new Date());

					colecaoClienteGuiaPagamentoHistoricoInserir.add(clienteGuiaPagamentoHistoricoTemp);
				}

				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoClienteGuiaPagamentoHistoricoInserir);

				getControladorBatch().removerColecaoObjetoParaBatch(colecaoClienteGuiaPagamentoRemover);

				colecaoClienteGuiaPagamentoHistoricoInserir = null;
				colecaoClienteGuiaPagamentoRemover = null;

			}

		}catch(Exception ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método que recebe uma coleção de Pagamentos com os Ids preenchidos e retorna uma coleção com
	 * os objetos preenchidos
	 * [UC0300] - Classificar Pagamentos e Devoluções
	 * 
	 * @author Saulo Lima
	 * @date 24/11/2008
	 * @param colecaoPagamentos
	 *            <Pagamento>
	 * @return colecaoRetorno<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> carregarAtributosPagamento(Collection<Pagamento> colecaoPagamentos) throws ControladorException{

		Collection<Pagamento> colecaoRetorno = new ArrayList<Pagamento>();
		Collection<Integer> colecaoIdsPagamentos = new ArrayList<Integer>();

		if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){

			Iterator<Pagamento> pagamentosIterator = colecaoPagamentos.iterator();

			while(pagamentosIterator.hasNext()){
				Pagamento pagamento = pagamentosIterator.next();
				colecaoIdsPagamentos.add(pagamento.getId());
			}

			FiltroPagamento filtroPagamento = new FiltroPagamento();
			colecaoRetorno = getControladorUtil().pesquisar(colecaoIdsPagamentos, filtroPagamento, Pagamento.class.getName());
		}

		return colecaoRetorno;
	}

	/**
	 * Método que recebe uma coleção de Pagamentos e retorna uma Coleção de PagamentosHistorico a
	 * partir dos Pagamentos
	 * [UC0300] - Classificar Pagamentos e Devoluções
	 * 
	 * @author Saulo Lima
	 * @date 25/11/2008
	 * @author Saulo Lima
	 * @date 26/01/2009
	 *       Inclusão do parâmetro pagamentoSituacaoId
	 * @param colecaoPagamentos
	 *            <Pagamento>
	 *            colecaoPagamentos
	 * @param Integer
	 *            Id da situacao do pagamento
	 * @return colecaoHistoricoRetorno<PagamentoHistorico>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> criarPagamentoHistoricoDoPagamento(Collection<Pagamento> colecaoPagamentos,
					Integer pagamentoSituacaoId) throws ControladorException{

		Collection<PagamentoHistorico> colecaoHistoricoRetorno = new ArrayList<PagamentoHistorico>();
		PagamentoHistorico pagamentoHistoricoTemp = null;

		if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){
			Iterator<Pagamento> pagamentosIterator = colecaoPagamentos.iterator();

			while(pagamentosIterator.hasNext()){
				Pagamento pagamento = pagamentosIterator.next();

				pagamentoHistoricoTemp = new PagamentoHistorico();
				pagamentoHistoricoTemp.setId(pagamento.getId());
				pagamentoHistoricoTemp.setAnoMesReferenciaArrecadacao(pagamento.getAnoMesReferenciaArrecadacao());
				pagamentoHistoricoTemp.setAnoMesReferenciaPagamento(pagamento.getAnoMesReferenciaPagamento());
				pagamentoHistoricoTemp.setArrecadacaoForma(pagamento.getArrecadacaoForma());
				pagamentoHistoricoTemp.setArrecadadorMovimentoItem(pagamento.getArrecadadorMovimentoItem());
				pagamentoHistoricoTemp.setAvisoBancario(pagamento.getAvisoBancario());
				pagamentoHistoricoTemp.setCliente(pagamento.getCliente());
				pagamentoHistoricoTemp.setNumeroPrestacao(pagamento.getNumeroPrestacao());
				pagamentoHistoricoTemp.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAtual());

				PagamentoSituacao pagamentoSituacao = (PagamentoSituacao) getControladorUtil().pesquisar(pagamentoSituacaoId,
								PagamentoSituacao.class, true);

				pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);

				if(pagamento.getConta() != null && pagamento.getConta().getId() != null){
					ContaHistorico contaHistorico = new ContaHistorico();
					contaHistorico.setId(pagamento.getConta().getId());
					pagamentoHistoricoTemp.setConta(contaHistorico);
				}

				pagamentoHistoricoTemp.setDataPagamento(pagamento.getDataPagamento());
				pagamentoHistoricoTemp.setDebitoACobrar(pagamento.getDebitoACobrar());
				pagamentoHistoricoTemp.setDebitoTipo(pagamento.getDebitoTipo());
				pagamentoHistoricoTemp.setDocumentoTipo(pagamento.getDocumentoTipo());
				pagamentoHistoricoTemp.setGuiaPagamentoGeral(pagamento.getGuiaPagamentoGeral());
				pagamentoHistoricoTemp.setImovel(pagamento.getImovel());
				pagamentoHistoricoTemp.setLocalidade(pagamento.getLocalidade());
				pagamentoHistoricoTemp.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAnterior());
				pagamentoHistoricoTemp.setPagamentoSituacaoAtual(pagamento.getPagamentoSituacaoAtual());
				pagamentoHistoricoTemp.setUltimaAlteracao(new Date());
				pagamentoHistoricoTemp.setValorPagamento(pagamento.getValorPagamento());
				pagamentoHistoricoTemp.setValorExcedente(pagamento.getValorExcedente());

				colecaoHistoricoRetorno.add(pagamentoHistoricoTemp);
			}
		}

		return colecaoHistoricoRetorno;
	}

	/**
	 * Obtém a representação númerica do código de barras de um pagamento de
	 * acordo com os parâmetros informados
	 * [UC0229] Obter Representação Numérica do Código de Barras
	 * 
	 * @author Pedro Alexandre
	 * @date 20/04/2006
	 * @author eduardo henrique
	 * @date 14/08/2008
	 *       Alterado para Guia de Pagamento utilizar novo método de Linha de Código de Barras. Na
	 *       versão final, todos devem usar o novo método.
	 *       Adicionado Parâmetro de Numero da Prestação
	 * @author eduardo henrique
	 * @date 24/12/2008
	 *       Atribui a Precisão do BigDecimal de Valor para evitar problemas de formatação de valor
	 *       para o código de barras.
	 *       Ajuste da montagem do valor do código de barras.
	 * @param tipoPagamento
	 * @param valorCodigoBarra
	 * @param idLocalidade
	 * @param matriculaImovel
	 * @param digitoVerificadorRefContaModulo10
	 * @param idTipoDebito
	 * @param anoEmissaoGuiaPagamento
	 * @param sequencialDocumentoCobranca
	 * @param idTipoDocumento
	 * @param idCliente
	 * @param seqFaturaClienteResponsavel
	 * @param anoMesReferenciaConta
	 * @param numeroPrestacaoDocumento
	 *            (Caso exista)
	 * @return
	 * @throws ParametroNaoInformadoException
	 */
	private String obterRepresentacaoNumericaCodigoBarraSemParametrizacao(Integer tipoPagamento, BigDecimal valorCodigoBarra,
					Integer idLocalidade, Integer matriculaImovel, String mesAnoReferenciaConta, Integer digitoVerificadorRefContaModulo10,
					Integer idTipoDebito, String anoEmissaoGuiaPagamento, String sequencialDocumentoCobranca, Integer idTipoDocumento,
					Integer idCliente, Integer seqFaturaClienteResponsavel, Short numeroPrestacaoDocumento, Integer idOpcao)
					throws ControladorException{

		// [FS0001] Verificar compatibilidade dos campos informados com o tipo
		// de pagamento
		if(tipoPagamento == null){
			throw new ControladorException("atencao.parametros.incompletos.codigobarra");
		}else{
			// Caso o tipo de pagamento seja referente a conta
			if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_CONTA){

				// Caso a matrícula do imóvel ou o mês/ano da referência da conta
				// ou o valor do código de barras não forem informados levanta uma
				// exceção para o usuário indicando que os parâmetros para geração
				// do código de barras está incompleto.
				if(matriculaImovel == null || mesAnoReferenciaConta == null || valorCodigoBarra == null){
					throw new ControladorException("atencao.parametros.incompletos.codigobarra");
				}

				// Caso o tipo de pagamento seja referente a guia de pagamento
			}else if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_MATRICULA_IMOVEL){

				// Caso o código da localidade ou a matrícula do imóvel ou o
				// tipo de débito ou o ano da emissão da guia de pagamento
				// não forem informados levanta uma exceção para o usuário
				// indicando que os parâmetros para geração do código de barras
				// está incompleto.
				if(matriculaImovel == null || idTipoDocumento == null // nr. da Guia
								|| numeroPrestacaoDocumento == null){// nr. Prestacao
					throw new ControladorException("atencao.parametros.incompletos.codigobarra");
				}

				// Caso a tipo de pagamento seja referente a documento de
				// cobrança
			}else if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_COBANCA_MATRICULA_IMOVEL){

				// Caso o código da localidade ou a matrícula do imóvel ou o
				// sequencial do documento de cobrança ou o tipo de documento
				// não forem informados levanta uma exceção para o usuário
				// indicando que os parâmetros para geração do código de barras
				// está incompleto.
				if(idLocalidade == null || matriculaImovel == null || sequencialDocumentoCobranca == null || idTipoDocumento == null){
					throw new ControladorException("atencao.parametros.incompletos.codigobarra");
				}

				// Caso o tipo de pagamento seja referente a fatura do cliente
				// responsável
			}else if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_CLIENTE_RESPONSAVEL){
				// Caso o código do cliente ou o valor do Codigo Barras
				// ou o sequencial da fatura do cliente responsável
				// não forem informados levanta uma exceção para o usuário
				// indicando que os parâmetros para geração do código de barras
				// está incompleto.
				if(idCliente == null || valorCodigoBarra == null || seqFaturaClienteResponsavel == null){
					throw new ControladorException("atencao.parametros.incompletos.codigobarra");
				}

				// Caso a tipo de pagamento seja referente a guia de pagamento
			}else if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_CODIGO_CLIENTE){
				// Caso o código da localidade ou id do cliente ou o
				// tipo de débito ou o ano da emissão da guia de pagamento
				// não forem informados levanta uma exceção para o usuário
				// indicando que os parâmetros para geração do código de barras
				// está incompleto.
				if(idCliente == null || idTipoDocumento == null // nr. da Guia
								|| numeroPrestacaoDocumento == null){ // nr. da Prestacao
					throw new ControladorException("atencao.parametros.incompletos.codigobarra");
				}
			}else if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_COBANCA_CODIGO_CLIENTE){

				// Caso o código do cliente ou o
				// sequencial do documento de cobrança ou o tipo de documento
				// não forem informados levanta uma exceção para o usuário
				// indicando que os parâmetros para geração do código de barras
				// está incompleto.
				if(idCliente == null || sequencialDocumentoCobranca == null || idTipoDocumento == null){
					throw new ControladorException("atencao.parametros.incompletos.codigobarra");
				}
			}
		}

		// Atribui precisão do Valor
		valorCodigoBarra = valorCodigoBarra.setScale(2);

		String representacaoNumericaCodigoBarra = "";

		// G.05.1 - Identificação do produto
		String identificacaoProduto = "8";
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoProduto;

		// G.05.2 - Identificação do segmento
		String identificacaoSegmento = "2";
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoSegmento;

		// G.05.3 - Identificação dovalor real ou referência
		String identificacaoValorRealOuReferencia = "6";
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoValorRealOuReferencia;

		// G.05.4 - Dígito verificador geral
		// Calculado posteriormente

		// G.05.5 - Valor do código de barras
		String valorCodigoBarraFormatado = Util.adicionarZerosEsquedaNumero(11, valorCodigoBarra.toString().replace(".", ""));
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + valorCodigoBarraFormatado;

		// G.05.6 - Identificação da empresa
		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
		String identificacaoEmpresa = sistemaParametro.getCodigoEmpresaFebraban().toString();
		identificacaoEmpresa = Util.adicionarZerosEsquedaNumero(4, identificacaoEmpresa);
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoEmpresa;

		// G.05.7 Identificação do pagamento
		// [SB0001] Obter Identificação do Pagamento
		String identificacaoPagamento = "";

		if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_CONTA
						|| tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_MATRICULA_IMOVEL
						|| tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_CODIGO_CLIENTE
						|| tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_CLIENTE_RESPONSAVEL){

			Integer numeroPrestacaoDoc = null;
			if(numeroPrestacaoDocumento != null){
				numeroPrestacaoDoc = Integer.valueOf(numeroPrestacaoDocumento.intValue());
			}

			identificacaoPagamento = obterIdentificacaoPagamento(tipoPagamento, matriculaImovel, idTipoDocumento, numeroPrestacaoDoc,
							idCliente, seqFaturaClienteResponsavel, mesAnoReferenciaConta);

			representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoPagamento;

			// G.05.4 - Dígito verificador geral
			// [SB0002] Obter Dígito verificador geral
			String digitoVerificadorGeral = (Util.obterDigitoVerificadorGeral(representacaoNumericaCodigoBarra)).toString();

			representacaoNumericaCodigoBarra = identificacaoProduto + identificacaoSegmento + identificacaoValorRealOuReferencia
							+ digitoVerificadorGeral + valorCodigoBarraFormatado + identificacaoEmpresa + identificacaoPagamento;

		}else{
			identificacaoPagamento = obterIdentificacaoPagamento(tipoPagamento, idLocalidade, matriculaImovel, mesAnoReferenciaConta,
							digitoVerificadorRefContaModulo10, idTipoDebito, anoEmissaoGuiaPagamento, sequencialDocumentoCobranca,
							idTipoDocumento, idCliente, seqFaturaClienteResponsavel, idOpcao);

			representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoPagamento + tipoPagamento.toString();

			// G.05.4 - Dígito verificador geral
			// [SB0002] Obter Dígito verificador geral
			String digitoVerificadorGeral = (Util.obterDigitoVerificadorGeral(representacaoNumericaCodigoBarra)).toString();

			representacaoNumericaCodigoBarra = identificacaoProduto + identificacaoSegmento + identificacaoValorRealOuReferencia
							+ digitoVerificadorGeral + valorCodigoBarraFormatado + identificacaoEmpresa + identificacaoPagamento
							+ tipoPagamento.toString();
		}

		representacaoNumericaCodigoBarra = this.finalizarRepresentacaoNumericaCodigoBarra(representacaoNumericaCodigoBarra);

		// Retorna a representação númerica do código de barras
		return representacaoNumericaCodigoBarra;
	}

	/**
	 * Obtém a representação númerica do código de barras de um pagamento de
	 * acordo com os parâmetros informados.
	 * [UC0229] Obter Representação Numérica do Código de Barras
	 * Formata a identificação do pagamento de acordo com o tipo de pagamento
	 * informado.
	 * (Método foi sobrescrito pois será utilizado atendendo às mudanças do GSANPCG)
	 * [SB0001] Obter Identificação do Pagamento
	 * 
	 * @author eduardo henrique
	 * @date 14/08/2008
	 * @since v0.04
	 * @param tipoPagamento
	 *            - Tipo do Documento
	 *            3: Conta
	 *            4 ou 6: Guia Pagamento
	 *            7: Fatura
	 * @param idIdentificacaoImovel
	 *            - Pode ser a Matrícula do Imóvel ou o Código do Cliente
	 * @param idDocumento
	 *            - Numero do Documento
	 * @param idPrestacaoDocumento
	 *            - Numero da Prestação do Documento (se existir)
	 * @param idCliente
	 *            - Código do Cliente
	 * @param seqFaturaClienteResponsavel
	 *            - Numero da Fatura
	 * @return
	 * @throws ControladorException
	 */
	public String obterIdentificacaoPagamento(Integer tipoPagamento, Integer idIdentificacaoImovel, Integer idDocumento,
					Integer idPrestacaoDocumento, Integer idCliente, Integer seqFaturaClienteResponsavel, String mesAnoReferenciaConta)
					throws ControladorException{

		String identificacaoPagamento = "";

		if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_CONTA){

			// Conta
			identificacaoPagamento += Util.adicionarZerosEsquedaNumero(8, "" + idIdentificacaoImovel);
			identificacaoPagamento += Util.adicionarZerosEsquedaNumero(6, mesAnoReferenciaConta);
			identificacaoPagamento += "000000000";
			identificacaoPagamento += Util.adicionarZerosEsquedaNumero(2, "" + tipoPagamento);

		}else if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_MATRICULA_IMOVEL){

			// Guia Pagamento com Mat. Imóvel
			identificacaoPagamento = this.obterIdentificacaoPagamentoGuiaPagamento(tipoPagamento, idIdentificacaoImovel, idDocumento,
							idPrestacaoDocumento);

		}else if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_CODIGO_CLIENTE){

			// Guia Pagamento com Cód. do Cliente
			identificacaoPagamento = this.obterIdentificacaoPagamentoGuiaPagamento(tipoPagamento, idCliente, idDocumento,
							idPrestacaoDocumento);

		}else if(tipoPagamento.intValue() == PagamentoTipo.PAGAMENTO_TIPO_CLIENTE_RESPONSAVEL){

			// Fatura
			identificacaoPagamento += Util.adicionarZerosEsquedaNumero(9, idCliente.toString());
			identificacaoPagamento += "00000";
			identificacaoPagamento += Util.adicionarZerosEsquedaNumero(9, seqFaturaClienteResponsavel.toString());
			identificacaoPagamento += Util.adicionarZerosEsquedaNumero(2, "" + tipoPagamento);

		}

		return identificacaoPagamento;
	}

	/**
	 * Obtém a representação númerica do código de barras de um pagamento de acordo com os
	 * parâmetros informados.
	 * [UC0229] Obter Representação Numérica do Código de Barras
	 * 
	 * @author Saulo Lima
	 * @date 14/04/2012
	 * @param tipoPagamento
	 * @param idIdentificacaoImovelOuCliente
	 * @param idDocumento
	 * @param idPrestacaoDocumento
	 * @return String
	 * @throws ControladorException
	 */
	private String obterIdentificacaoPagamentoGuiaPagamento(Integer tipoPagamento, Integer idIdentificacaoImovelOuCliente,
					Integer idDocumento, Integer idPrestacaoDocumento) throws ControladorException{

		String tamanho = ParametroArrecadacao.P_TAMANHO_CAMPO_GUIA_PAGAMENTO_CODIGO_BARRAS.executar();
		String retorno = "";

		if(tamanho.equals("8")){

			retorno += Util.adicionarZerosEsquedaNumero(8, "" + idIdentificacaoImovelOuCliente);
			retorno += Util.adicionarZerosEsquedaNumero(8, "" + idDocumento);
			retorno += Util.adicionarZerosEsquedaNumero(3, "" + idPrestacaoDocumento);
			retorno += "0000";
			retorno += Util.adicionarZerosEsquedaNumero(2, "" + tipoPagamento);

		}else if(tamanho.equals("9")){

			retorno += Util.adicionarZerosEsquedaNumero(8, "" + idIdentificacaoImovelOuCliente);
			retorno += Util.adicionarZerosEsquedaNumero(9, "" + idDocumento);
			retorno += Util.adicionarZerosEsquedaNumero(3, "" + idPrestacaoDocumento);
			retorno += "000";
			retorno += Util.adicionarZerosEsquedaNumero(2, "" + tipoPagamento);

		}else{
			throw new ControladorException("Valor do Parâmetro Inválido");
		}

		return retorno;
	}

	/**
	 * Obtém a representação númerica do código de barras de um pagamento de
	 * acordo com os parâmetros informados
	 * [UC0229] Obter Representação Numérica do Código de Barras
	 * Formata a identificação do pagamento de acordo com o tipo de pagamento
	 * informado
	 * [SB0001] Obter Identificação do Pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 20/04/2006
	 * @deprecated
	 *             NÂO UTILIZAR PARA O GSANPCG, método será removido na versão final.
	 * @param tipoPagamento
	 * @param idLocalidade
	 * @param matriculaImovel
	 * @param anoMesReferenciaConta
	 * @param digitoVerificadorRefContaModulo10
	 * @param idTipoDebito
	 * @param anoEmissaoGuiaPagamento
	 * @param sequencialDocumentoCobranca
	 * @param idTipoDocumento
	 * @param idCliente
	 * @param seqFaturaClienteResponsavel
	 * @return
	 */
	public String obterIdentificacaoPagamento(Integer tipoPagamento, Integer idLocalidade, Integer matriculaImovel,
					String mesAnoReferenciaConta, Integer digitoVerificadorRefContaModulo10, Integer idTipoDebito,
					String anoEmissaoGuiaPagamento, String sequencialDocumentoCobranca, Integer idTipoDocumento, Integer idCliente,
					Integer seqFaturaClienteResponsavel, Integer idOpcao) throws ControladorException{

		// Cria a variável que vai armazenar o identificador do pagamento
		// formatado
		String identificacaoPagamento = "";

		// Caso o tipo de pagamento seja referente a conta
		if(tipoPagamento.intValue() == 3){
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(8, "" + matriculaImovel);
			identificacaoPagamento = identificacaoPagamento + "000";
			identificacaoPagamento = identificacaoPagamento + mesAnoReferenciaConta;
			identificacaoPagamento = identificacaoPagamento + digitoVerificadorRefContaModulo10;
			identificacaoPagamento = identificacaoPagamento + "000";

			// Caso o tipo de pagamento seja referente a guia de pagamento
			// (Imóvel)

		}else if(tipoPagamento.intValue() == 2){
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(8, "" + idOpcao);
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(9, sequencialDocumentoCobranca));
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(2, idTipoDocumento.toString()));
			identificacaoPagamento = identificacaoPagamento + "00";

		}else if(tipoPagamento.intValue() == 4){
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(8, "" + matriculaImovel);
			identificacaoPagamento = identificacaoPagamento + "000";
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(3, idTipoDebito.toString()));
			identificacaoPagamento = identificacaoPagamento + anoEmissaoGuiaPagamento;
			identificacaoPagamento = identificacaoPagamento + "000";

			// Caso a tipo de pagamento seja referente a documento de cobrança
		}else if(tipoPagamento.intValue() == 5){
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(8, "" + matriculaImovel);
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(9, sequencialDocumentoCobranca));
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(2, idTipoDocumento.toString()));
			identificacaoPagamento = identificacaoPagamento + "00";

			// Caso o tipo de pagamento seja referente a guia de pagamento
			// (Cliente)
		}else if(tipoPagamento.intValue() == 6){
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(8, "" + idCliente);
			identificacaoPagamento = identificacaoPagamento + "000";
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(3, idTipoDebito.toString()));
			identificacaoPagamento = identificacaoPagamento + anoEmissaoGuiaPagamento;
			identificacaoPagamento = identificacaoPagamento + "000";

			// Caso o tipo de pagamento seja referente a fatura do cliente
			// responsável
		}else if(tipoPagamento.intValue() == 7){
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(9, idCliente.toString()));
			identificacaoPagamento = identificacaoPagamento + "00";
			identificacaoPagamento = identificacaoPagamento + mesAnoReferenciaConta;
			identificacaoPagamento = identificacaoPagamento + digitoVerificadorRefContaModulo10;
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(6, seqFaturaClienteResponsavel.toString()));
			// Caso a tipo de pagamento seja referente a documento de cobrança
			// cliente
		}else if(tipoPagamento.intValue() == 8){
			identificacaoPagamento = identificacaoPagamento + "000";
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(8, idCliente.toString()));
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(9, sequencialDocumentoCobranca));
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(2, idTipoDocumento.toString()));
			identificacaoPagamento = identificacaoPagamento + "00";
		}

		// Retorna o identificador do pagamento formatado
		return identificacaoPagamento;
	}

	/**
	 * Clasifica as devoluções cobradas indevidamente.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 29/11/2006
	 * @param colecaoDevolucoesCobradasIndevidamente
	 * @throws ControladorException
	 */
	protected void classificarDevolucoesCobradasIndevidamente(Collection colecaoDevolucoesCobradasIndevidamente)
					throws ControladorException{

		Devolucao devolucao = null;
		Collection colecaoConjuntoDevolucoes = new ArrayList();
		Iterator iteratorColecaoConjuntoDevolucoes = null;
		boolean conjuntoFechado = false;
		boolean primeiraEntrada = true;
		Devolucao devolucaoConjunto = null;

		Localidade localidadeAnterior = null;
		Imovel imovelAnterior = null;
		DebitoTipo debitoTipoAnterior = null;
		DebitoTipo debitoTipo = null;
		Cliente cliente = null;
		Cliente clienteAnterior = null;
		Collection<Pagamento> colecaoPagamentoNaoClassificados = null;

		String[] idDevolucao = null;

		Object[] devolucaoArray = null;
		Localidade localidade = null;
		Imovel imovel = null;
		GuiaDevolucao guiaDevolucao = null;

		if(!colecaoDevolucoesCobradasIndevidamente.isEmpty()){

			Iterator iteratorColecaoDevolucoesCobradasIndevidamente = colecaoDevolucoesCobradasIndevidamente.iterator();

			devolucao = null;
			primeiraEntrada = true;
			conjuntoFechado = false;

			colecaoConjuntoDevolucoes.clear();

			while(iteratorColecaoDevolucoesCobradasIndevidamente.hasNext()){

				devolucaoArray = (Object[]) iteratorColecaoDevolucoesCobradasIndevidamente.next();

				if(devolucaoArray[1] != null){
					localidade = new Localidade();
					localidade.setId((Integer) devolucaoArray[1]);
				}else{
					localidade = null;
				}

				if(devolucaoArray[2] != null){
					imovel = new Imovel();
					imovel.setId((Integer) devolucaoArray[2]);
				}else{
					imovel = null;
				}

				if(devolucaoArray[3] != null){
					guiaDevolucao = new GuiaDevolucao();
					guiaDevolucao.setId((Integer) devolucaoArray[3]);
				}else{
					guiaDevolucao = null;
				}

				if(devolucaoArray[4] != null){
					cliente = new Cliente();
					cliente.setId((Integer) devolucaoArray[4]);
				}else{
					cliente = null;
				}

				if(devolucaoArray[5] != null){
					debitoTipo = new DebitoTipo();
					debitoTipo.setId((Integer) devolucaoArray[5]);
				}else{
					debitoTipo = null;
				}

				devolucao = (Devolucao) devolucaoArray[0];
				devolucao.setLocalidade(localidade);
				devolucao.setImovel(imovel);
				devolucao.setCliente(cliente);
				devolucao.setDebitoTipo(debitoTipo);
				devolucao.setGuiaDevolucao(guiaDevolucao);

				if(!primeiraEntrada){

					if((localidadeAnterior == null && devolucao.getLocalidade() == null)
									|| (localidadeAnterior != null && devolucao.getLocalidade() != null && localidadeAnterior.getId()
													.equals(devolucao.getLocalidade().getId()))){

						if((imovelAnterior == null && devolucao.getImovel() == null)
										|| (imovelAnterior != null && devolucao.getImovel() != null && imovelAnterior.getId().equals(
														devolucao.getImovel().getId()))){

							if((clienteAnterior == null && devolucao.getCliente() == null)
											|| (clienteAnterior != null && devolucao.getCliente() != null && clienteAnterior.getId()
															.equals(devolucao.getCliente().getId()))){

								if((debitoTipoAnterior == null && devolucao.getDebitoTipo() == null)
												|| (debitoTipoAnterior != null && devolucao.getDebitoTipo() != null && debitoTipoAnterior
																.getId().equals(devolucao.getDebitoTipo().getId()))){

									colecaoConjuntoDevolucoes.add(devolucao);
									conjuntoFechado = false;
								}else{
									conjuntoFechado = true;
								}
							}else{
								conjuntoFechado = true;
							}
						}else{
							conjuntoFechado = true;
						}
					}else{
						conjuntoFechado = true;
					}

				}else{
					primeiraEntrada = false;
					colecaoConjuntoDevolucoes.add(devolucao);
				}

				if(conjuntoFechado){

					/*
					 * [SF0012] Selecionar Pagamentos não classificados de guia
					 * de pagamento ou débito a cobrar
					 */
					colecaoPagamentoNaoClassificados = this.selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(imovelAnterior,
									clienteAnterior, debitoTipoAnterior);

					if(colecaoPagamentoNaoClassificados == null || colecaoPagamentoNaoClassificados.isEmpty()){

						iteratorColecaoConjuntoDevolucoes = colecaoConjuntoDevolucoes.iterator();

						idDevolucao = new String[1];

						while(iteratorColecaoConjuntoDevolucoes.hasNext()){

							devolucaoConjunto = (Devolucao) iteratorColecaoConjuntoDevolucoes.next();

							idDevolucao[0] = String.valueOf(devolucaoConjunto.getId());

							if(devolucaoConjunto.getGuiaDevolucao() != null){

								try{
									System.out.println("ATUALIZANDO DEVOLUCAO GUIA DEVOLUCAO, idDevolucao: " + idDevolucao);
									repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao,
													DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES);

								}catch(ErroRepositorioException ex){
									ex.printStackTrace();
									throw new ControladorException("erro.sistema", ex);
								}

							}else{

								try{
									System.out.println("ATUALIZANDO DEVOLUCAO GUIA DEVOLUCAO, idDevolucao: " + idDevolucao);
									repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao,
													DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);

								}catch(ErroRepositorioException ex){
									ex.printStackTrace();
									throw new ControladorException("erro.sistema", ex);
								}
							}
						}
					}else{

						// [SF0011] Processar Devoluções de
						// Pagamentos
						this.processarDevolucaoPagamento(colecaoConjuntoDevolucoes, colecaoPagamentoNaoClassificados);

					}

					colecaoConjuntoDevolucoes.clear();
					colecaoConjuntoDevolucoes.add(devolucao);
				}

				localidadeAnterior = devolucao.getLocalidade();
				imovelAnterior = devolucao.getImovel();
				clienteAnterior = devolucao.getCliente();
				debitoTipoAnterior = devolucao.getDebitoTipo();
			}

			/*
			 * Último registro
			 */
			if(!colecaoConjuntoDevolucoes.isEmpty()){

				/*
				 * [SF0012] Selecionar Pagamentos não classificados de guia de
				 * pagamento ou débito a cobrar
				 */
				colecaoPagamentoNaoClassificados = this.selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(imovelAnterior,
								clienteAnterior, debitoTipoAnterior);

				if(colecaoPagamentoNaoClassificados == null || colecaoPagamentoNaoClassificados.isEmpty()){

					iteratorColecaoConjuntoDevolucoes = colecaoConjuntoDevolucoes.iterator();

					idDevolucao = new String[1];

					while(iteratorColecaoConjuntoDevolucoes.hasNext()){

						devolucaoConjunto = (Devolucao) iteratorColecaoConjuntoDevolucoes.next();

						idDevolucao[0] = String.valueOf(devolucaoConjunto.getId());

						if(devolucaoConjunto.getGuiaDevolucao() != null){

							try{
								System.out.println("ATUALIZANDO DEVOLUCAO GUIA DEVOLUCAO_1");
								repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao, DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES);

							}catch(ErroRepositorioException ex){
								ex.printStackTrace();
								throw new ControladorException("erro.sistema", ex);
							}

						}else{

							try{
								System.out.println("ATUALIZANDO DEVOLUCAO GUIA DEVOLUCAO_2");
								repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao,
												DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);

							}catch(ErroRepositorioException ex){
								ex.printStackTrace();
								throw new ControladorException("erro.sistema", ex);
							}
						}
					}
				}else{

					// [SF0011] Processar Devoluções de
					// Pagamentos
					this.processarDevolucaoPagamento(colecaoConjuntoDevolucoes, colecaoPagamentoNaoClassificados);

				}
			}
		}
	}

	/**
	 * Classifica as devoluções em duplicidade ou excesso.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 29/11/2006
	 * @param colecaoDevolucoesDuplicidadeExcesso
	 * @throws ControladorException
	 */
	protected void classificarDevolucoesDuplicidadeExcesso(Collection colecaoDevolucoesDuplicidadeExcesso) throws ControladorException{

		/**
		 * Declaração de variáveis.
		 */
		Devolucao devolucao = null;
		Collection colecaoConjuntoDevolucoes = new ArrayList();
		Iterator iteratorColecaoConjuntoDevolucoes = null;
		boolean conjuntoFechado = false;
		boolean primeiraEntrada = true;
		Devolucao devolucaoConjunto = null;
		Localidade localidadeAnterior = null;
		Imovel imovelAnterior = null;
		Integer anoMesReferenciaDevolucaoAnterior = null;
		Collection<Pagamento> colecaoPagamentoNaoClassificados = null;
		String[] idDevolucao = null;
		Object[] devolucaoArray = null;
		Localidade localidade = null;
		Imovel imovel = null;
		GuiaDevolucao guiaDevolucao = null;

		/*
		 * Para as devoluções de contas pagas em duplicidade ou em excesso, ou
		 * seja, aquelas com ano/mês de referência preenchidos
		 * (DEVL_AMREFERENCIADEVOLUCAO com valor diferente de nulo)
		 */
		if(!colecaoDevolucoesDuplicidadeExcesso.isEmpty()){

			/*
			 * Para cada conjunto de devoluções com mesma localidade, mesma
			 * matrícula do imóvel, e mesmo ano/mês de referência da devolução
			 */
			Iterator iteratorColecaoDevolucoesDuplicidadeExcesso = colecaoDevolucoesDuplicidadeExcesso.iterator();

			devolucao = null;
			primeiraEntrada = true;
			conjuntoFechado = false;

			colecaoConjuntoDevolucoes.clear();

			while(iteratorColecaoDevolucoesDuplicidadeExcesso.hasNext()){

				devolucaoArray = (Object[]) iteratorColecaoDevolucoesDuplicidadeExcesso.next();

				if(devolucaoArray[1] != null){
					localidade = new Localidade();
					localidade.setId((Integer) devolucaoArray[1]);
				}else{
					localidade = null;
				}

				if(devolucaoArray[2] != null){
					imovel = new Imovel();
					imovel.setId((Integer) devolucaoArray[2]);
				}else{
					imovel = null;
				}

				if(devolucaoArray[3] != null){
					guiaDevolucao = new GuiaDevolucao();
					guiaDevolucao.setId((Integer) devolucaoArray[3]);
				}else{
					guiaDevolucao = null;
				}

				devolucao = (Devolucao) devolucaoArray[0];
				devolucao.setLocalidade(localidade);
				devolucao.setImovel(imovel);
				devolucao.setGuiaDevolucao(guiaDevolucao);

				if(!primeiraEntrada){

					if((localidadeAnterior == null && devolucao.getLocalidade() == null)
									|| (localidadeAnterior != null && devolucao.getLocalidade() != null && localidadeAnterior.getId()
													.equals(devolucao.getLocalidade().getId()))){

						if((imovelAnterior == null && devolucao.getImovel() == null)
										|| (imovelAnterior != null && devolucao.getImovel() != null && imovelAnterior.getId().equals(
														devolucao.getImovel().getId()))){

							if((anoMesReferenciaDevolucaoAnterior == null && devolucao.getAnoMesReferenciaDevolucao() == null)
											|| (anoMesReferenciaDevolucaoAnterior != null
															&& devolucao.getAnoMesReferenciaDevolucao() != null && anoMesReferenciaDevolucaoAnterior
																.equals(devolucao.getAnoMesReferenciaDevolucao()))){

								colecaoConjuntoDevolucoes.add(devolucao);
								conjuntoFechado = false;

							}else{
								conjuntoFechado = true;
							}
						}else{
							conjuntoFechado = true;
						}
					}else{
						conjuntoFechado = true;
					}

				}else{
					primeiraEntrada = false;
					colecaoConjuntoDevolucoes.add(devolucao);
				}

				if(conjuntoFechado){

					/*
					 * [SF0010] Selecionar Pagamentos não classificados de conta
					 */
					colecaoPagamentoNaoClassificados = this.selecionarPagamentosNaoClassificadosConta(imovelAnterior,
									anoMesReferenciaDevolucaoAnterior);

					if(colecaoPagamentoNaoClassificados == null || colecaoPagamentoNaoClassificados.isEmpty()){

						iteratorColecaoConjuntoDevolucoes = colecaoConjuntoDevolucoes.iterator();

						idDevolucao = new String[1];

						while(iteratorColecaoConjuntoDevolucoes.hasNext()){

							devolucaoConjunto = (Devolucao) iteratorColecaoConjuntoDevolucoes.next();

							idDevolucao[0] = String.valueOf(devolucaoConjunto.getId());

							try{
								System.out.println("ATUALIZANDO DEVOLUCAO CONTA");
								repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao,
												DevolucaoSituacao.PAGAMENTO_DUPLICIDADE_NAO_ENCONTRADO);

							}catch(ErroRepositorioException ex){
								ex.printStackTrace();
								throw new ControladorException("erro.sistema", ex);
							}
						}
					}else{
						System.out.println("PROCESSANDO DEVOLUCAO CONTA");
						// [SF0011] Processar Devoluções de Pagamentos
						this.processarDevolucaoPagamento(colecaoConjuntoDevolucoes, colecaoPagamentoNaoClassificados);

					}

					colecaoConjuntoDevolucoes.clear();
					colecaoConjuntoDevolucoes.add(devolucao);
				}

				localidadeAnterior = devolucao.getLocalidade();
				imovelAnterior = devolucao.getImovel();
				anoMesReferenciaDevolucaoAnterior = devolucao.getAnoMesReferenciaDevolucao();
			}

			/*
			 * Último registro
			 */
			if(!colecaoConjuntoDevolucoes.isEmpty()){

				/*
				 * [SF0010] Selecionar Pagamentos não classificados de conta
				 */
				colecaoPagamentoNaoClassificados = this.selecionarPagamentosNaoClassificadosConta(imovelAnterior,
								anoMesReferenciaDevolucaoAnterior);

				if(colecaoPagamentoNaoClassificados == null || colecaoPagamentoNaoClassificados.isEmpty()){

					iteratorColecaoConjuntoDevolucoes = colecaoConjuntoDevolucoes.iterator();

					idDevolucao = new String[1];

					while(iteratorColecaoConjuntoDevolucoes.hasNext()){

						devolucaoConjunto = (Devolucao) iteratorColecaoConjuntoDevolucoes.next();

						idDevolucao[0] = String.valueOf(devolucaoConjunto.getId());

						try{
							System.out.println("ATUALIZANDO DEVOLUCAO CONTA - PAGAMENTO_DUPLICIDADE_NAO_ENCONTRADO");

							Collection<Devolucao> colecaoDevolucoes = new ArrayList<Devolucao>();
							Devolucao devolucaoTMP = new Devolucao();
							devolucaoTMP.setId(Integer.valueOf(idDevolucao[0]));
							devolucaoTMP = repositorioArrecadacao.obterDevolucao(devolucaoTMP);

							DevolucaoSituacao devolucaoSituacao = new DevolucaoSituacao();
							devolucaoSituacao.setId(DevolucaoSituacao.PAGAMENTO_DUPLICIDADE_NAO_ENCONTRADO);
							devolucaoTMP.setDevolucaoSituacaoAtual(devolucaoSituacao);

							colecaoDevolucoes.add(devolucaoTMP);
							this.transferirDevolucaoParaHistorico(colecaoDevolucoes);

						}catch(ErroRepositorioException ex){
							ex.printStackTrace();
							throw new ControladorException("erro.sistema", ex);
						}
					}
				}else{
					System.out.println("PROCESSANDO DEVOLUCAO CONTA");
					// [SF0011] Processar Devoluções de Pagamentos
					this.processarDevolucaoPagamento(colecaoConjuntoDevolucoes, colecaoPagamentoNaoClassificados);

				}
			}

		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Transfere para o histórico as devoluções informadas.
	 * 
	 * @author Administrador
	 * @date 09/01/2007
	 * @param colecaoDevolucoes
	 * @throws ControladorException
	 */
	public void transferirDevolucaoParaHistorico(Collection<Devolucao> colecaoDevolucoes) throws ControladorException{

		DevolucaoHistorico devolucaoHistoricoTemp = null;

		Collection colecaoDevolucaoHistoricoInserir = new ArrayList();
		Collection colecaoDevolucaoHistoricoRemover = new ArrayList();

		try{

			if(colecaoDevolucoes != null && !colecaoDevolucoes.isEmpty()){

				colecaoDevolucaoHistoricoRemover.addAll(colecaoDevolucoes);

				int cont = 0;
				for(Devolucao devolucao : colecaoDevolucoes){
					cont++;
					// System.out.println("GERANDO HISTORICO DAS DEVOLUÇOES:" + cont);

					devolucaoHistoricoTemp = new DevolucaoHistorico();
					devolucaoHistoricoTemp.setId(devolucao.getId());
					devolucaoHistoricoTemp.setAnoMesReferenciaArrecadacao(devolucao.getAnoMesReferenciaArrecadacao());
					devolucaoHistoricoTemp.setAnoMesReferenciaDevolucao(devolucao.getAnoMesReferenciaDevolucao());
					devolucaoHistoricoTemp.setAvisoBancario(devolucao.getAvisoBancario());
					devolucaoHistoricoTemp.setCliente(devolucao.getCliente());
					devolucaoHistoricoTemp.setDataDevolucao(devolucao.getDataDevolucao());
					devolucaoHistoricoTemp.setDebitoTipo(devolucao.getDebitoTipo());
					devolucaoHistoricoTemp.setDevolucaoSituacaoAnterior(devolucao.getDevolucaoSituacaoAnterior());
					devolucaoHistoricoTemp.setDevolucaoSituacaoAtual(devolucao.getDevolucaoSituacaoAtual());
					devolucaoHistoricoTemp.setGuiaDevolucao(devolucao.getGuiaDevolucao());
					devolucaoHistoricoTemp.setImovel(devolucao.getImovel());
					devolucaoHistoricoTemp.setLocalidade(devolucao.getLocalidade());
					devolucaoHistoricoTemp.setUltimaAlteracao(new Date());
					devolucaoHistoricoTemp.setValorDevolucao(devolucao.getValorDevolucao());

					colecaoDevolucaoHistoricoInserir.add(devolucaoHistoricoTemp);
				}
			}

			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDevolucaoHistoricoInserir);

			getControladorBatch().removerColecaoObjetoParaBatch(colecaoDevolucaoHistoricoRemover);

			colecaoDevolucaoHistoricoInserir = null;
			colecaoDevolucaoHistoricoRemover = null;

		}catch(Exception ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método reponsável por remover a coleção de GuiaPagamentoCategoriaHistorico e inserir as
	 * GuiaPagamentoCategoria referentes
	 * [UC0213] Desfazer Parcelamento de Débitos
	 * 
	 * @author Saulo Lima
	 * @date 13/07/2009
	 * @param colecaoGuiasPagamentoCategoriaHistorico
	 * @throws ControladorException
	 */
	public void enviarGuiaPagamentoCategoriaHistoricoParaGuiaPagamentoCategoria(
					Collection<GuiaPagamentoCategoriaHistorico> colecaoGuiasPagamentoCategoriaHistorico) throws ControladorException{

		try{
			Collection colecaoGuiasPagamentoCategoriaInserir = new ArrayList<GuiaPagamentoCategoria>();
			Collection colecaoGuiasPagamentoCategoriaHistoricoRemover = new ArrayList<GuiaPagamentoCategoriaHistorico>();

			for(Iterator iterator = colecaoGuiasPagamentoCategoriaHistorico.iterator(); iterator.hasNext();){
				GuiaPagamentoCategoriaHistorico guiaCategoriaHistorico = (GuiaPagamentoCategoriaHistorico) iterator.next();

				// Cria uma Guia Categoria
				GuiaPagamentoCategoriaPK guiaCategoriaPK = new GuiaPagamentoCategoriaPK(guiaCategoriaHistorico.getComp_id()
								.getCategoriaId(), guiaCategoriaHistorico.getComp_id().getGuiaPagamentoId(), guiaCategoriaHistorico
								.getComp_id().getLancamentoItemContabilId(), guiaCategoriaHistorico.getComp_id().getNumeroPrestacao());

				GuiaPagamentoCategoria guiaCategoriaInserir = new GuiaPagamentoCategoria();
				guiaCategoriaInserir.setComp_id(guiaCategoriaPK);

				guiaCategoriaInserir.setQuantidadeEconomia(guiaCategoriaHistorico.getQuantidadeEconomia());
				guiaCategoriaInserir.setValorCategoria(guiaCategoriaHistorico.getValorCategoria());
				guiaCategoriaInserir.setUltimaAlteracao(new Date());

				colecaoGuiasPagamentoCategoriaInserir.add(guiaCategoriaInserir);
				colecaoGuiasPagamentoCategoriaHistoricoRemover.add(guiaCategoriaHistorico);
			}

			this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoGuiasPagamentoCategoriaInserir);
			this.getControladorBatch().removerColecaoObjetoParaBatch(colecaoGuiasPagamentoCategoriaHistoricoRemover);

			colecaoGuiasPagamentoCategoriaInserir = null;
			colecaoGuiasPagamentoCategoriaHistoricoRemover = null;

		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Transfere para o histórico os pagamentos informados.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param colecaoGuiasPagamento
	 * @param anoMesFaturamentoSistemaParametro
	 * @throws ControladorException
	 */
	public void transferirPagamentoParaHistorico(Collection<Pagamento> colecaoPagamentos) throws ControladorException{

		PagamentoHistorico pagamentoHistoricoTemp = null;

		Collection colecaoPagamentoHistoricoInserir = new ArrayList();
		Collection colecaoPagamentoHistoricoRemover = new ArrayList();

		try{
			if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){

				colecaoPagamentoHistoricoRemover.addAll(colecaoPagamentos);
				int cont = 0;
				for(Pagamento pagamento : colecaoPagamentos){
					cont++;
					// System.out.println("GERANDO HISTORICO DOS PAGAMENTOS:" + cont);

					pagamentoHistoricoTemp = new PagamentoHistorico();
					pagamentoHistoricoTemp.setId(pagamento.getId());
					pagamentoHistoricoTemp.setAnoMesReferenciaArrecadacao(pagamento.getAnoMesReferenciaArrecadacao());
					pagamentoHistoricoTemp.setAnoMesReferenciaPagamento(pagamento.getAnoMesReferenciaPagamento());
					pagamentoHistoricoTemp.setArrecadacaoForma(pagamento.getArrecadacaoForma());
					pagamentoHistoricoTemp.setArrecadadorMovimentoItem(pagamento.getArrecadadorMovimentoItem());
					pagamentoHistoricoTemp.setAvisoBancario(pagamento.getAvisoBancario());
					pagamentoHistoricoTemp.setCliente(pagamento.getCliente());
					pagamentoHistoricoTemp.setNumeroPrestacao(pagamento.getNumeroPrestacao());

					PagamentoSituacao pagamentoSituacao = new PagamentoSituacao();
					pagamentoSituacao.setId(PagamentoSituacao.PAGAMENTO_CLASSIFICADO);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacao);

					pagamentoHistoricoTemp.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAtual());

					if(pagamento.getConta() != null && pagamento.getConta().getId() != null){
						ContaHistorico contaHistorico = new ContaHistorico();
						contaHistorico.setId(pagamento.getConta().getId());
						pagamentoHistoricoTemp.setConta(contaHistorico);
					}

					pagamentoHistoricoTemp.setDataPagamento(pagamento.getDataPagamento());
					pagamentoHistoricoTemp.setDebitoACobrar(pagamento.getDebitoACobrar());
					pagamentoHistoricoTemp.setDebitoTipo(pagamento.getDebitoTipo());
					pagamentoHistoricoTemp.setDocumentoTipo(pagamento.getDocumentoTipo());
					pagamentoHistoricoTemp.setGuiaPagamentoGeral(pagamento.getGuiaPagamentoGeral());
					pagamentoHistoricoTemp.setImovel(pagamento.getImovel());
					pagamentoHistoricoTemp.setLocalidade(pagamento.getLocalidade());
					pagamentoHistoricoTemp.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAnterior());
					pagamentoHistoricoTemp.setPagamentoSituacaoAtual(pagamento.getPagamentoSituacaoAtual());
					pagamentoHistoricoTemp.setUltimaAlteracao(new Date());
					pagamentoHistoricoTemp.setValorPagamento(pagamento.getValorPagamento());
					pagamentoHistoricoTemp.setValorExcedente(pagamento.getValorExcedente());

					colecaoPagamentoHistoricoInserir.add(pagamentoHistoricoTemp);

				}
			}

			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoPagamentoHistoricoInserir);

			getControladorBatch().removerColecaoObjetoParaBatch(colecaoPagamentoHistoricoRemover);

			colecaoPagamentoHistoricoInserir = null;
			colecaoPagamentoHistoricoRemover = null;

		}catch(Exception ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorLocalidade(int anoMesReferencia) throws ControladorException{

		Collection colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade = new ArrayList();
		Collection retorno = new ArrayList();

		try{
			colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade = repositorioArrecadacao
							.consultarResumoArrecadacaoRelatorioPorEstadoPorLocalidade(anoMesReferencia);

			if(colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade != null
							&& !colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade.isEmpty()){

				Iterator iterator = colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade.iterator();

				// Prepara cada linha do relatório
				String recebimentoTipo = null;
				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String idLocalidadeAnterior = null;
				String descLancamentoTipoSuperior = "";

				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				while(iterator.hasNext()){
					Object[] element = null;
					String tempRecebimentoTipo = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;

					element = (Object[]) iterator.next();

					if(recebimentoTipo == null){
						recebimentoTipo = (String) element[1];
						tipoLancamento = (String) element[2];
						itemLancamento = (String) element[3];
						itemContabel = (String) element[4];
					}

					tempRecebimentoTipo = (String) element[1];
					tempTipoLancamento = (String) element[2];
					tempItemLancamento = (String) element[3];
					tempItemContabel = (String) element[4];

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if(recebimentoTipo.equals(tempRecebimentoTipo) && tipoLancamento.equals(tempTipoLancamento)
									&& itemLancamento.equals(tempItemLancamento)){

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if(itemContabel == null && tempItemContabel == null
										|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

							switch(((Integer) element[9]).intValue()){
								case 1:
									arrayValores[0] = (BigDecimal) element[0];
									break;
								case 2:
									arrayValores[1] = (BigDecimal) element[0];
									break;
								case 3:
									arrayValores[2] = (BigDecimal) element[0];
									break;
								case 4:
									arrayValores[4] = (BigDecimal) element[0];
									break;
							}

						}else{

							condicaoIgual = false;
						}

					}else{

						condicaoIgual = false;

					}

					if(!condicaoIgual){

						// adiciona uma linha no relátorio
						ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
										arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
										(String) elementAnterior[3], (String) elementAnterior[4], (Short) elementAnterior[5],
										(Short) elementAnterior[6], (Integer) elementAnterior[7], (Integer) elementAnterior[8], false,
										descGerenciaRegionalAnterior, idGerenciaRegionalAnterior, descLocalidadeAnterior,
										idLocalidadeAnterior, descLancamentoTipoSuperior, descUnidadeNegocioAnterior,
										idUnidadeNegocioAnterior, null, null);

						retorno.add(resumoArrecadacaoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch(((Integer) element[9]).intValue()){
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
						}

					}

					if(idUnidadeNegocioAnterior != null && !idUnidadeNegocioAnterior.equals("" + element[18])){
						// quebra por Unidade Negocio
						retorno = consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(anoMesReferencia,
										Integer.valueOf(idUnidadeNegocioAnterior), retorno);

						System.out.println("---------------------------------------");
						System.out.println("localidade1: " + descLocalidadeAnterior);
						System.out.println("unidade1: " + descUnidadeNegocioAnterior);
						System.out.println("gerencia1: " + descGerenciaRegionalAnterior);
						System.out.println("---------------------------------------");

					}

					if(idGerenciaRegionalAnterior != null && !idGerenciaRegionalAnterior.equals("" + element[11])){
						// quebra por gerencia
						retorno = consultarResumoArrecadacaoRelatorioPorGerenciaRegional(anoMesReferencia,
										Integer.valueOf(idGerenciaRegionalAnterior), retorno);

						System.out.println("---------------------------------------");
						System.out.println("localidade2: " + descLocalidadeAnterior);
						System.out.println("unidade2: " + descUnidadeNegocioAnterior);
						System.out.println("gerencia2: " + descGerenciaRegionalAnterior);
						System.out.println("---------------------------------------");

					}

					elementAnterior[1] = element[1]; // descricaoTipoRecebimento
					elementAnterior[2] = element[2]; // descricaoTipoLancamento
					elementAnterior[3] = element[3]; // descricaoItemLancamento
					elementAnterior[4] = element[4]; // descricaoItemContabil
					elementAnterior[5] = element[5]; // indicadorImpressao
					elementAnterior[6] = element[6]; // indicadorTotal
					elementAnterior[7] = element[7]; // lancamentoTipo
					elementAnterior[8] = element[8]; // lancamentoTipoSuperior

					descGerenciaRegionalAnterior = "" + element[10];
					idGerenciaRegionalAnterior = "" + element[11];
					descLocalidadeAnterior = "" + element[12];
					idLocalidadeAnterior = "" + element[13];
					descUnidadeNegocioAnterior = "" + element[17];
					idUnidadeNegocioAnterior = "" + element[18];

					recebimentoTipo = tempRecebimentoTipo;
					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;

				}

				if(colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade != null
								&& !colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade.isEmpty()){
					// adiciona a ultima linha
					ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
									(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
									(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
									(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
									idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
									descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

					retorno.add(resumoArrecadacaoRelatorioHelper);

					retorno = consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(anoMesReferencia,
									Integer.valueOf(idUnidadeNegocioAnterior), retorno);

					retorno = consultarResumoArrecadacaoRelatorioPorGerenciaRegional(anoMesReferencia,
									Integer.valueOf(idGerenciaRegionalAnterior), retorno);

					retorno = consultarResumoArrecadacaoRelatorioPorEstado(anoMesReferencia, retorno);

				}
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstado(int anoMesReferencia, Collection colecaoResumoArrecadacaoRelatorio)
					throws ControladorException{

		Collection colecaoResumoArrecadacaoRelatorioPorEstado = new ArrayList();

		try{
			colecaoResumoArrecadacaoRelatorioPorEstado = repositorioArrecadacao
							.consultarResumoArrecadacaoRelatorioPorEstado(anoMesReferencia);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoArrecadacaoRelatorioPorEstado.iterator();

		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while(iterator.hasNext()){
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if(recebimentoTipo == null){
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if(recebimentoTipo.equals(tempRecebimentoTipo) && tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)){

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if(itemContabel == null && tempItemContabel == null
								|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

					switch(((Integer) element[9]).intValue()){
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
					}

				}else{

					condicaoIgual = false;
				}

			}else{

				condicaoIgual = false;

			}

			if(!condicaoIgual){

				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
								(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
								(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
								(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

				colecaoResumoArrecadacaoRelatorio.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch(((Integer) element[9]).intValue()){
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if(colecaoResumoArrecadacaoRelatorio != null && !colecaoResumoArrecadacaoRelatorio.isEmpty()){
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
							(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
							(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
							(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

			colecaoResumoArrecadacaoRelatorio.add(resumoArrecadacaoRelatorioHelper);
		}

		return colecaoResumoArrecadacaoRelatorio;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 19/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio(int anoMesReferencia) throws ControladorException{

		Collection colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio = new ArrayList();
		Collection retorno = new ArrayList();

		try{
			colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio = repositorioArrecadacao
							.consultarResumoArrecadacaoRelatorioPorEstadoPorUnidadeNegocio(anoMesReferencia);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio.iterator();

		// Prepara cada linha do relatório
		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while(iterator.hasNext()){
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if(recebimentoTipo == null){
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if(recebimentoTipo.equals(tempRecebimentoTipo) && tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)){

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if(itemContabel == null && tempItemContabel == null
								|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

					switch(((Integer) element[9]).intValue()){
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
					}

				}else{

					condicaoIgual = false;
				}

			}else{

				condicaoIgual = false;

			}

			if(!condicaoIgual){

				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
								(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
								(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
								(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

				retorno.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch(((Integer) element[9]).intValue()){
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
				}

			}

			if(idGerenciaRegionalAnterior != null && !idGerenciaRegionalAnterior.equals("" + element[16])){
				// quebra por gerencia
				retorno = consultarResumoArrecadacaoRelatorioPorGerenciaRegional(anoMesReferencia,
								Integer.valueOf(idGerenciaRegionalAnterior), retorno);
			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			descGerenciaRegionalAnterior = "" + element[15];
			idGerenciaRegionalAnterior = "" + element[16];

			descUnidadeNegocioAnterior = "" + element[10];
			idUnidadeNegocioAnterior = "" + element[11];

			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if(colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio != null
						&& !colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio.isEmpty()){
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
							(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
							(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
							(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

			retorno.add(resumoArrecadacaoRelatorioHelper);

			retorno = consultarResumoArrecadacaoRelatorioPorGerenciaRegional(anoMesReferencia, Integer.valueOf(idGerenciaRegionalAnterior),
							retorno);
		}

		return retorno;

	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 19/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorGerenciaRegional(int anoMesReferencia, Integer idGerenciaRegional,
					Collection colecaoResumoArrecadacaoRelatorio) throws ControladorException{

		Collection colecaoResumoArrecadacaoRelatorioPorGerenciaRegional = new ArrayList();

		try{
			colecaoResumoArrecadacaoRelatorioPorGerenciaRegional = repositorioArrecadacao
							.consultarResumoArrecadacaoRelatorioPorGerenciaRegional(anoMesReferencia, idGerenciaRegional);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iteratorResumoArrecadacaoRelatorioPorGerenciaRegional = colecaoResumoArrecadacaoRelatorioPorGerenciaRegional.iterator();

		// Prepara cada linha do relatório
		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		Boolean agrupaPorGerencia = true;

		while(iteratorResumoArrecadacaoRelatorioPorGerenciaRegional.hasNext()){
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iteratorResumoArrecadacaoRelatorioPorGerenciaRegional.next();

			if(recebimentoTipo == null){
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if(recebimentoTipo.equals(tempRecebimentoTipo) && tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)){

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if(itemContabel == null && tempItemContabel == null
								|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

					// se for agrupado por gerencia
					// compara se o registro atual eh da
					// mesma gerencia regional do registro anterior
					if(!agrupaPorGerencia || descGerenciaRegionalAnterior == null
									|| (agrupaPorGerencia && descGerenciaRegionalAnterior.equalsIgnoreCase((String) element[10]))){

						switch(((Integer) element[9]).intValue()){
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
						}
					}else{
						condicaoIgual = false;
					}

				}else{

					condicaoIgual = false;
				}

			}else{

				condicaoIgual = false;

			}

			if(!condicaoIgual){

				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
								(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
								(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
								(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

				colecaoResumoArrecadacaoRelatorio.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch(((Integer) element[9]).intValue()){
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			descGerenciaRegionalAnterior = "" + element[10];
			idGerenciaRegionalAnterior = "" + element[11];

			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if(colecaoResumoArrecadacaoRelatorio != null && !colecaoResumoArrecadacaoRelatorio.isEmpty()){
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
							(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
							(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
							(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

			colecaoResumoArrecadacaoRelatorio.add(resumoArrecadacaoRelatorioHelper);
		}

		return colecaoResumoArrecadacaoRelatorio;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(int anoMesReferencia, Integer idUnidadeNegocio,
					Collection colecaoResumoArrecadacaoRelatorio) throws ControladorException{

		Collection colecaoResumoArrecadacaoRelatorioPorUnidadeNegocio = new ArrayList();

		try{
			colecaoResumoArrecadacaoRelatorioPorUnidadeNegocio = repositorioArrecadacao
							.consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(anoMesReferencia, idUnidadeNegocio);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoArrecadacaoRelatorioPorUnidadeNegocio.iterator();

		// Prepara cada linha do relatório

		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while(iterator.hasNext()){
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if(recebimentoTipo == null){
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if(recebimentoTipo.equals(tempRecebimentoTipo) && tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)){

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if(itemContabel == null && tempItemContabel == null
								|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

					switch(((Integer) element[9]).intValue()){
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
					}

				}else{

					condicaoIgual = false;
				}

			}else{

				condicaoIgual = false;

			}

			if(!condicaoIgual){

				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
								(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
								(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
								(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

				colecaoResumoArrecadacaoRelatorio.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch(((Integer) element[9]).intValue()){
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			descUnidadeNegocioAnterior = "" + element[10];
			idUnidadeNegocioAnterior = "" + element[11];
			descGerenciaRegionalAnterior = "" + element[15];
			idGerenciaRegionalAnterior = "" + element[16];

			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if(colecaoResumoArrecadacaoRelatorio != null && !colecaoResumoArrecadacaoRelatorio.isEmpty()){
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(arrayValores,
							(String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
							(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
							(Integer) elementAnterior[7], (Integer) elementAnterior[8], false, descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior, idUnidadeNegocioAnterior, null, null);

			colecaoResumoArrecadacaoRelatorio.add(resumoArrecadacaoRelatorioHelper);
		}

		return colecaoResumoArrecadacaoRelatorio;
	}

	private BigDecimal retornarSomatorioArrecadadorMovimentoItem(Integer idArrecadadorMovimento, Short indicadorAceitacao)
					throws ControladorException{

		BigDecimal somatorioArrecadadorMovimentoItem = BigDecimal.ZERO;

		try{
			Collection collArrecadadorMovimentoItem = repositorioArrecadacao.pesquisarArrecadadorMovimentoItem(idArrecadadorMovimento,
							indicadorAceitacao);
			Iterator it = collArrecadadorMovimentoItem.iterator();

			String conteudoRegistro = "";
			String valorRegistro = "";

			while(it.hasNext()){
				ArrecadadorMovimentoItem arrecadadorMovimentoItem = (ArrecadadorMovimentoItem) it.next();
				conteudoRegistro = arrecadadorMovimentoItem.getConteudoRegistro();

				char[] registro = new char[150];
				if(conteudoRegistro != null){
					for(int i = 0; i < conteudoRegistro.length(); i++){
						if(i <= registro.length){
							registro[i] = conteudoRegistro.toCharArray()[i];
						}
					}
				}

				// int posicaoInicial, int tamanho, char[] registro
				String tipo = Util.getConteudo(1, 1, registro);
				if(tipo.equals("G")){

					// precisa saber qual o tipo de pagamento.
					// String codigoBarras = Util.getConteudo(37,46,registro);
					// String tipoPagamento = Util.getConteudo(45,1,codigoBarras.toCharArray());

					// if(Util.converterStringParaInteger(tipoPagamento).equals(PagamentoTipo.PAGAMENTO_TIPO_CONTA)||
					// Util.converterStringParaInteger(tipoPagamento).equals(PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_MATRICULA_IMOVEL)||
					// Util.converterStringParaInteger(tipoPagamento).equals(PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_CODIGO_CLIENTE)||
					// Util.converterStringParaInteger(tipoPagamento).equals(PagamentoTipo.PAGAMENTO_TIPO_COBANCA_MATRICULA_IMOVEL)||
					// Util.converterStringParaInteger(tipoPagamento).equals(PagamentoTipo.PAGAMENTO_TIPO_COBANCA_CODIGO_CLIENTE)
					// ||
					// Util.converterStringParaInteger(tipoPagamento).equals(PagamentoTipo.PAGAMENTO_TIPO_CLIENTE_RESPONSAVEL)){
					// valorRegistro = Util.getConteudo(42,11,registro);
					// }else{
					valorRegistro = Util.getConteudo(42, 11, registro);
					// }

				}else if(tipo.equals("F")){
					valorRegistro = Util.getConteudo(53, 15, registro);
				}

				if(!valorRegistro.equals("")){
					somatorioArrecadadorMovimentoItem = somatorioArrecadadorMovimentoItem.add(Util
									.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(valorRegistro));
				}

			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return somatorioArrecadadorMovimentoItem;

	}

	/**
	 * Este caso de uso pesquisa pagamentos do aviso bancário
	 * [UC0255] Pesquisar Pagamentos Aviso Bancario
	 * Pesquisa os pagamentos do aviso bancário
	 * 
	 * @author Yara Souza
	 * @date 22/07/2010
	 */
	private Collection<Pagamento> pesquisarPagamentoAvisoBancario(Integer idAvisoBancario) throws ControladorException{

		Calendar tempo = Calendar.getInstance();
		Collection<Pagamento> colecaoPagamentos = new ArrayList<Pagamento>();

		Collection colecaoDadosPagamentos;
		try{
			colecaoDadosPagamentos = repositorioArrecadacao.pesquisarPagamentoAvisoBancario(idAvisoBancario);
			if(colecaoDadosPagamentos != null){
				Iterator iter = colecaoDadosPagamentos.iterator();
				while(iter.hasNext()){
					Object[] dadosPagamentos = (Object[]) iter.next();
					Pagamento pagamento = new Pagamento();

					DocumentoTipo documentoTipo = new DocumentoTipo();
					Localidade localidade = new Localidade();
					Imovel imovel = new Imovel();
					Cliente cliente = new Cliente();
					DebitoTipo debitoTipo = new DebitoTipo();
					PagamentoSituacao pagamentoSituacaoAtual = new PagamentoSituacao();

					documentoTipo.setDescricaoAbreviado((String) dadosPagamentos[0]);
					pagamento.setDocumentoTipo(documentoTipo);

					pagamento.setDataPagamento((Date) dadosPagamentos[1]);

					localidade.setId((Integer) dadosPagamentos[2]);
					pagamento.setLocalidade(localidade);

					imovel.setId((Integer) dadosPagamentos[3]);
					pagamento.setImovel(imovel);

					cliente.setId((Integer) dadosPagamentos[4]);
					pagamento.setCliente(cliente);

					pagamento.setAnoMesReferenciaPagamento((Integer) dadosPagamentos[5]);

					debitoTipo.setId((Integer) dadosPagamentos[6]);
					pagamento.setDebitoTipo(debitoTipo);

					pagamento.setValorPagamento((BigDecimal) dadosPagamentos[7]);

					pagamentoSituacaoAtual.setDescricaoAbreviada((String) dadosPagamentos[8]);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					pagamento.setId((Integer) dadosPagamentos[9]);

					pagamento.setNumeroPrestacao((Integer) dadosPagamentos[10]);

					Conta conta = null;
					if((Integer) dadosPagamentos[11] != null){
						conta = new Conta();
						conta.setId((Integer) dadosPagamentos[11]);
					}
					pagamento.setConta(conta);

					GuiaPagamentoGeral guiaPagamentoGeral = null;
					if((Integer) dadosPagamentos[12] != null){
						guiaPagamentoGeral = new GuiaPagamentoGeral();
						GuiaPagamento guiaPagamento = new GuiaPagamento();
						guiaPagamento.setId((Integer) dadosPagamentos[12]);
						guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);
					}
					pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);

					DebitoACobrar debitoACobrar = null;
					if((Integer) dadosPagamentos[13] != null){
						debitoACobrar = new DebitoACobrar();
						debitoACobrar.setId((Integer) dadosPagamentos[13]);
					}
					pagamento.setDebitoACobrar(debitoACobrar);

					PreParcelamentoOpcao preParcelamentoOpcao = null;
					if((Integer) dadosPagamentos[14] != null){
						preParcelamentoOpcao = new PreParcelamentoOpcao();
						preParcelamentoOpcao.setId((Integer) dadosPagamentos[14]);
					}
					pagamento.setPreParcelamentoOpcao(preParcelamentoOpcao);

					colecaoPagamentos.add(pagamento);
				}
			}
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		// System.out.println(" Tempo retorno pesquisar Pagamento AvisoBancario =" +
		// Util.calcularDiferencaTempo(tempo));
		return colecaoPagamentos;
	}

	/**
	 * [UC0300] - Classificar Pagamentos e Devoluções
	 * Transfere para o histórico as prestações da guia de pagamento segundo o parâmetro
	 * numeroPrestação.
	 * Caso seja a única prestação em aberto, guiaPagamento também será enviada para histórico.
	 * 
	 * @author Saulo Lima
	 * @date 26/11/2008
	 * @author Saulo Lima
	 * @date 19/02/2009
	 *       Correção para processar guia com várias parcelas/categorias corretamente
	 * @author Eduardo Henrique
	 * @date 28/02/2009
	 *       Alteração para tratamento de obter somente categorias por nr. guia, prestacao e
	 *       lancamento_item_contabil, evitando duplicidades.
	 * @param guiaPagamento
	 * @param numeroPrestacao
	 * @throws ControladorException
	 */
	private void transferirGuiaPagamentoParaHistorico(GuiaPagamento guiaPagamento, Integer numeroPrestacao) throws ControladorException{

		try{

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			if(sistemaParametro == null){
				throw new ControladorException("atencao.pesquisa.sistemaparametro_inexistente");
			}

			FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
							guiaPagamento.getId()));
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
							numeroPrestacao));

			Collection colecaoGuiaPagamentoPrestacao = getControladorUtil().pesquisar(filtroGuiaPagamentoPrestacao,
							GuiaPagamentoPrestacao.class.getName());
			if(colecaoGuiaPagamentoPrestacao == null || colecaoGuiaPagamentoPrestacao.isEmpty()){
				System.out.println("Indentificação do objeto não localizado 'GuiaPagamentoPrestacao': Guia e Prestação "
								+ guiaPagamento.getId() + " " + numeroPrestacao);
				throw new ControladorException("atencao.atualizacao.removido");
			}

			// Transfere as informações das Prestações para o histórico (Prestação e Categoria)
			this.enviarGuiaPagamentoPrestacaoParaHistorico(colecaoGuiaPagamentoPrestacao, null, null);

			// O Set garante que somente 1 categoria por Prestação e Lancamento_item_Contabil será
			// obtido, mesmo qdo variar somente o tipo de débito
			Collection colecaoGuiasPagamentoCategoriaRemover = new HashSet();
			// Itera no resultado do Map para Montar a Coleção de Categorias correspondentes às
			// Prestações
			for(Iterator iteratorCategoria = colecaoGuiaPagamentoPrestacao.iterator(); iteratorCategoria.hasNext();){
				GuiaPagamentoPrestacao guiaPrestacao = (GuiaPagamentoPrestacao) iteratorCategoria.next();

				// Consulta as Categorias da Prestação para Cancelamento também
				FiltroGuiaPagamentoCategoria filtroGuiaPagamentoCategoria = new FiltroGuiaPagamentoCategoria();
				filtroGuiaPagamentoCategoria.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoCategoria.GUIA_PAGAMENTO_ID,
								guiaPrestacao.getComp_id().getGuiaPagamentoId()));
				filtroGuiaPagamentoCategoria.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoCategoria.NUMERO_PRESTACAO,
								guiaPrestacao.getComp_id().getNumeroPrestacao()));

				Collection guiasPagamentoCategorias = getControladorUtil().pesquisar(filtroGuiaPagamentoCategoria,
								GuiaPagamentoCategoria.class.getName());

				if(guiasPagamentoCategorias != null && !guiasPagamentoCategorias.isEmpty()){
					colecaoGuiasPagamentoCategoriaRemover.addAll(guiasPagamentoCategorias);
				}
			}

			this.enviarGuiaPagamentoCategoriaParaHistorico(colecaoGuiasPagamentoCategoriaRemover);

			Collection colecaoGuiaPagamentoCancelar = new ArrayList();
			Collection colecaoGuiaPagamentoHistorico = new ArrayList();
			Collection colecaoGuiaPagamentoGeral = new ArrayList();

			// Verifica se todas as prestações de cada Guia Foram Canceladas.
			// Se sim, move a Guia e Cliente_Guia para Histórico (utiliza a coleção de Prestações q
			// foram canceladas)
			List prestacoesDesconsideradas = new ArrayList();
			prestacoesDesconsideradas.add(Short.valueOf(numeroPrestacao.toString()));

			Integer idGuiaFinalizada = repositorioArrecadacao.verificarExistenciaPrestacaoGuiaPagamento(guiaPagamento.getId(),
							prestacoesDesconsideradas);
			if(idGuiaFinalizada == null){
				// Guia que não tem mais nenhuma prestação

				colecaoGuiaPagamentoCancelar.add(guiaPagamento);

				GuiaPagamentoHistorico guiaPagamentoHistorico = new GuiaPagamentoHistorico();
				PropertyUtils.copyProperties(guiaPagamentoHistorico, guiaPagamento);

				// try {
				// } catch (IllegalAccessException iaex) {
				// sessionContext.setRollbackOnly();
				// throw new ControladorException("erro.sistema");
				// } catch (InvocationTargetException itex) {
				// sessionContext.setRollbackOnly();
				// throw new ControladorException("erro.sistema");
				// }

				BigDecimal valorTotalPrestacao = repositorioArrecadacao
								.obterValorTotalDasPrestacoesDaGuiaEmHistorico(guiaPagamento.getId());

				if(valorTotalPrestacao != null){
					guiaPagamentoHistorico.setValorDebito(valorTotalPrestacao);
				}

				guiaPagamentoHistorico.setUltimaAlteracao(new Date());

				colecaoGuiaPagamentoHistorico.add(guiaPagamentoHistorico);

				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoGuiaPagamentoHistorico);

				this.enviarClienteGuiaPagamentoParaHistorico(guiaPagamentoHistorico, guiaPagamento.getId());

				getControladorBatch().removerColecaoObjetoParaBatch(colecaoGuiaPagamentoCancelar);

				// Obtém o Guia_Pagamento_Geral para Atualização
				FiltroGuiaPagamentoGeral filtroGuiaPagamentoGeral = new FiltroGuiaPagamentoGeral();
				filtroGuiaPagamentoGeral.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoGeral.ID, guiaPagamento.getId()));

				Collection guiaPagamentoGeral = getControladorUtil()
								.pesquisar(filtroGuiaPagamentoGeral, GuiaPagamentoGeral.class.getName());
				if(guiaPagamentoGeral == null || guiaPagamentoGeral.isEmpty()){
					System.out.println("Indentificação do objeto não localizado 'GuiaPagamentoGeral': id = " + guiaPagamento.getId());
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.removido");
				}

				GuiaPagamentoGeral guiaPagamentoGeralAtualizar = (GuiaPagamentoGeral) Util.retonarObjetoDeColecao(guiaPagamentoGeral);
				guiaPagamentoGeralAtualizar.setIndicadorHistorico(Short.valueOf("1"));
				guiaPagamentoGeralAtualizar.setUltimaAlteracao(new Date());

				colecaoGuiaPagamentoGeral.add(guiaPagamentoGeralAtualizar);

				getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoGuiaPagamentoGeral);
			}

		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Classifica os pagamentos para tipo de documento igual a guia de pagamento
	 * para guia preenchida ou não preenchida.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 29/11/2006, 02/10/2007
	 * @param colecaoPagamentosGuiaPagamentoPreenchida
	 * @param colecaoPagamentosGuiaPagamentoNaoPreenchida
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	protected Collection<Pagamento> classificarPagamentosGuiaPagamento(Collection colecaoPagamentosGuiaPagamentoPreenchida,
					Collection colecaoPagamentosGuiaPagamentoNaoPreenchida, Pagamento pagamentoAClassificar) throws ControladorException{

		/* Declaração de variáveis */
		Collection<Pagamento> retorno = new ArrayList<Pagamento>();
		Collection colecaoPagamentosAtualizar = new ArrayList();
		Pagamento pagamento = null;
		Collection colecaoConjuntoPagamentos = new ArrayList();
		Iterator iteratorColecaoConjuntoPagamentos = null;
		boolean conjuntoFechado = false;
		boolean primeiraEntrada = true;
		Pagamento pagamentoConjunto = null;
		Localidade localidadeAnterior = null;
		Imovel imovelAnterior = null;
		DebitoTipo debitoTipoAnterior = null;
		DebitoTipo debitoTipo = null;
		Cliente cliente = null;
		Cliente clienteAnterior = null;
		Object[] pagamentoArray = null;
		DocumentoTipo documentoTipo = null;
		Localidade localidade = null;
		Imovel imovel = null;
		PagamentoSituacao pagamentoSituacaoAtual = null;
		Integer idGuiaPagamento = null;
		BigDecimal valorPagamento = null;
		Date dataPagamento = null;
		Integer anoMesReferenciaPagamento = null;
		BigDecimal valorDebitoGuiaPagamento = null;
		Integer numeroPrestacao = null;
		Integer idAvisoBancario = null;
		AvisoBancario avisoBancario = null;
		Short indicadorHistorico = null;

		Collection colecaoPagamentosDuplicados = new ArrayList();
		Collection colecaoPagamentosPagos = new ArrayList();
		Collection colecaoPagamentosCancelados = new ArrayList();
		Collection colecaoPagamentosParcelados = new ArrayList();

		GuiaPagamento guiaPagamentoConjunto = null;
		/*
		 * ==========================================================================================
		 * ========
		 * Para os pagamentos com tipo de documento (DOPT_ID) com o valor correspondente a GUIA DE
		 * PAGAMENTO:
		 * ==========================================================================================
		 * ========
		 */
		if((colecaoPagamentosGuiaPagamentoPreenchida != null && !colecaoPagamentosGuiaPagamentoPreenchida.isEmpty())
						|| (colecaoPagamentosGuiaPagamentoNaoPreenchida != null && !colecaoPagamentosGuiaPagamentoNaoPreenchida.isEmpty())){

			// Para os pagamentos com guia de pagamento preenchida
			// 3.1. Para os pagamentos com guia de pagamento preenchida (GPAG_ID diferente de nulo e
			// PGMT_NNPRESTACAO diferente de nulo):
			if(colecaoPagamentosGuiaPagamentoPreenchida != null && !colecaoPagamentosGuiaPagamentoPreenchida.isEmpty()){

				// Para cada conjunto de pagamentos com mesma guia de pagamento (GPAG_ID):
				Iterator iteratorColecaoPagamentosGuiaPagamentoPreenchida = colecaoPagamentosGuiaPagamentoPreenchida.iterator();
				pagamento = null;
				primeiraEntrada = true;
				conjuntoFechado = false;
				debitoTipoAnterior = null;
				GuiaPagamento guiaPagamentoAnterior = null;
				GuiaPagamento guiaPagamento = null;
				colecaoConjuntoPagamentos = new ArrayList();

				/* Laço para criar os pagamentos e classificar por conjuntos. */
				while(iteratorColecaoPagamentosGuiaPagamentoPreenchida.hasNext()){

					// System.out.println("GUIA PREENCHIDA");
					pagamentoArray = (Object[]) iteratorColecaoPagamentosGuiaPagamentoPreenchida.next();

					if(pagamentoArray[1] != null){
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) pagamentoArray[1]);
					}else{
						documentoTipo = null;
					}

					if(pagamentoArray[2] != null){
						localidade = new Localidade();
						localidade.setId((Integer) pagamentoArray[2]);
					}else{
						localidade = null;
					}

					if(pagamentoArray[3] != null){
						imovel = new Imovel();
						imovel.setId((Integer) pagamentoArray[3]);
					}else{
						imovel = null;
					}

					if(pagamentoArray[4] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) pagamentoArray[4]);
					}else{
						pagamentoSituacaoAtual = null;
					}

					if(pagamentoArray[5] != null){
						idGuiaPagamento = (Integer) pagamentoArray[5];
						guiaPagamento = new GuiaPagamento();
						guiaPagamento.setId(idGuiaPagamento);
					}else{
						idGuiaPagamento = null;
					}

					if(pagamentoArray[6] != null){
						valorPagamento = (BigDecimal) pagamentoArray[6];
					}else{
						valorPagamento = null;
					}

					if(pagamentoArray[7] != null){
						dataPagamento = (Date) pagamentoArray[7];
					}else{
						dataPagamento = null;
					}

					if(pagamentoArray[8] != null){
						anoMesReferenciaPagamento = (Integer) pagamentoArray[8];
					}else{
						anoMesReferenciaPagamento = null;
					}

					if(pagamentoArray[9] != null){
						valorDebitoGuiaPagamento = (BigDecimal) pagamentoArray[9];
					}else{
						valorDebitoGuiaPagamento = null;
					}

					if(pagamentoArray[10] != null){
						numeroPrestacao = (Integer) pagamentoArray[10];
					}else{
						numeroPrestacao = null;
					}

					if(pagamentoArray[11] != null){
						idAvisoBancario = (Integer) pagamentoArray[11];
						avisoBancario = new AvisoBancario();
						avisoBancario.setId(idAvisoBancario);
					}else{
						avisoBancario = null;
					}

					if(pagamentoArray[12] != null){
						indicadorHistorico = (Short) pagamentoArray[12];
					}else{
						indicadorHistorico = 0;
					}

					pagamento = new Pagamento();
					pagamento.setId((Integer) pagamentoArray[0]);
					pagamento.setDocumentoTipo(documentoTipo);
					pagamento.setLocalidade(localidade);
					pagamento.setImovel(imovel);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);
					pagamento.setAvisoBancario(avisoBancario);
					guiaPagamento.setValorDebito(valorDebitoGuiaPagamento);

					if(guiaPagamento != null){
						guiaPagamento.setGuiaPagamentoGeral(new GuiaPagamentoGeral());
						guiaPagamento.getGuiaPagamentoGeral().setId(guiaPagamento.getId());
						guiaPagamento.getGuiaPagamentoGeral().setIndicadorHistorico(indicadorHistorico);
						pagamento.setGuiaPagamentoGeral(guiaPagamento.getGuiaPagamentoGeral());
						pagamento.getGuiaPagamentoGeral().setGuiaPagamento(guiaPagamento);
					}

					pagamento.setValorPagamento(valorPagamento);
					pagamento.setDataPagamento(dataPagamento);
					pagamento.setAnoMesReferenciaPagamento(anoMesReferenciaPagamento);
					pagamento.setNumeroPrestacao(numeroPrestacao);

					if(!primeiraEntrada){

						if((guiaPagamentoAnterior == null && pagamento.getGuiaPagamentoGeral() == null)
										|| (guiaPagamentoAnterior != null && pagamento.getGuiaPagamentoGeral() != null
														&& pagamento.getGuiaPagamentoGeral().getGuiaPagamento() != null && guiaPagamentoAnterior
														.getId().equals(pagamento.getGuiaPagamentoGeral().getGuiaPagamento().getId()))){

							if((localidadeAnterior == null && pagamento.getLocalidade() == null)
											|| (localidadeAnterior != null && pagamento.getLocalidade() != null && localidadeAnterior
															.getId().equals(pagamento.getLocalidade().getId()))){

								if((imovelAnterior == null && pagamento.getImovel() == null)
												|| (imovelAnterior != null && pagamento.getImovel() != null && imovelAnterior.getId()
																.equals(pagamento.getImovel().getId()))){

									if((clienteAnterior == null && pagamento.getCliente() == null)
													|| (clienteAnterior != null && pagamento.getCliente() != null && clienteAnterior
																	.getId().equals(pagamento.getCliente().getId()))){

										if((debitoTipoAnterior == null && pagamento.getDebitoTipo() == null)
														|| (debitoTipoAnterior != null && pagamento.getDebitoTipo() != null && debitoTipoAnterior
																		.getId().equals(pagamento.getDebitoTipo().getId()))){

											colecaoConjuntoPagamentos.add(pagamento);
											conjuntoFechado = false;
										}else{
											conjuntoFechado = true;
										}
									}else{
										conjuntoFechado = true;
									}
								}else{
									conjuntoFechado = true;
								}
							}else{
								conjuntoFechado = true;
							}
						}else{
							conjuntoFechado = true;
						}

					}else{
						primeiraEntrada = false;
						colecaoConjuntoPagamentos.add(pagamento);
					}

					// verificar onde está a guia.
					if(pagamento.getGuiaPagamentoGeral() != null
									&& guiaPagamento.getGuiaPagamentoGeral().getIndicadorHistorico() == ConstantesSistema.NAO){

						/* Caso o conjunto de pagamentos para um mesmo imóvel esteja fechado. */
						if(conjuntoFechado){

							// [SB0004] Processar Pagamento de Guia de Pagamento
							retorno.addAll(this.processarPagamentoGuiaPagamento(guiaPagamentoAnterior, colecaoConjuntoPagamentos));

							colecaoConjuntoPagamentos = new ArrayList();
							colecaoConjuntoPagamentos.add(pagamento);
						}

						// if (pagamento.getGuiaPagamentoGeral() != null){
						guiaPagamentoAnterior = pagamento.getGuiaPagamentoGeral().getGuiaPagamento();
						// }

						localidadeAnterior = pagamento.getLocalidade();
						imovelAnterior = pagamento.getImovel();
						clienteAnterior = pagamento.getCliente();
						debitoTipoAnterior = pagamento.getDebitoTipo();

					}

				}

				/* Último registro */
				if(!colecaoConjuntoPagamentos.isEmpty() && guiaPagamentoAnterior != null){

					// [SB0004] Processar Pagamento de Guia de Pagamento
					retorno.addAll(this.processarPagamentoGuiaPagamento(guiaPagamentoAnterior, colecaoConjuntoPagamentos));

				}

				// **********************************************
				/*
				 * Caso a guia de pagamento não seja encontrada (retorno nulo do [SB0003]) e a
				 * situação atual (PGST_IDATUAL) não
				 * corresponda a baixar valor excedente (tabela PAGAMENTO_SITUACAO), atualizar a
				 * situação atual dos
				 * pagamentos (PGST_IDATUAL) com valor correspondente a documento inexistente
				 * (tabela PAGAMENTO_SITUACAO) e o
				 * valor excedente (PGMT_VLEXCEDENTE) com o valor do pagamento
				 */
				iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos.iterator();

				if(guiaPagamentoConjunto == null){

					while(iteratorColecaoConjuntoPagamentos.hasNext()){
						pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos.next();

						if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
										|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
														.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR))){

							if(pagamentoConjunto.getGuiaPagamentoGeral() != null
											&& pagamentoConjunto.getGuiaPagamentoGeral().getIndicadorHistorico() == ConstantesSistema.SIM){

								Collection collGuiaPagamentoHistorico;
								try{
									collGuiaPagamentoHistorico = repositorioArrecadacao.pesquisarGuiaPagamentoHistorico(pagamentoConjunto
													.getGuiaPagamentoGeral().getGuiaPagamento().getId());
									GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
													.retonarObjetoDeColecao(collGuiaPagamentoHistorico);

									if(guiaPagamentoHistorico != null){
										Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = repositorioArrecadacao
														.pesquisarGuiaPagamentoPrestacaoHistorico(guiaPagamentoHistorico.getId(),
																		pagamentoConjunto.getNumeroPrestacao());
										GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) Util
														.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHistorico);

										if(guiaPagamentoPrestacaoHistorico.getDebitoCreditoSituacao().getId()
														.equals(DebitoCreditoSituacao.NORMAL)
														|| guiaPagamentoPrestacaoHistorico.getDebitoCreditoSituacao().getId()
																		.equals(DebitoCreditoSituacao.RETIFICADA)
														|| guiaPagamentoPrestacaoHistorico.getDebitoCreditoSituacao().getId()
																		.equals(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO)){

											boolean guiaDeParcelamentoSemPagamento = false;

											if(guiaPagamentoHistorico.getParcelamento() != null){
												// Verifica se a Guia do Parcelamento foi para
												// histórico por estar sendo paga novamente ou se
												// foi parcelada em um novo parcelamento

												FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
												filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
																FiltroPagamentoHistorico.GUIA_PAGAMENTO_GERAL_ID, guiaPagamentoHistorico
																				.getId()));
												filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
																FiltroPagamentoHistorico.NUMERO_PRESTACAO, pagamentoConjunto
																				.getNumeroPrestacao()));

												Collection<PagamentoHistorico> colecaoPagamentoHistoricoConsulta = this
																.getControladorUtil().pesquisar(filtroPagamentoHistorico,
																				PagamentoHistorico.class.getName());

												if(Util.isVazioOrNulo(colecaoPagamentoHistoricoConsulta)){
													guiaDeParcelamentoSemPagamento = true;
												}
											}

											if(guiaDeParcelamentoSemPagamento){
												colecaoPagamentosParcelados.add(pagamentoConjunto);
											}else{
												BigDecimal valorTotalPrestacao = BigDecimal.ZERO;
												BigDecimal valorPrestacao = BigDecimal.ZERO;

												for(GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistoricoAux : colecaoGuiaPagamentoPrestacaoHistorico){
													valorPrestacao = guiaPagamentoPrestacaoHistoricoAux.getValorPrestacao();
													valorTotalPrestacao = valorTotalPrestacao.add(valorPrestacao);
												}

												if(valorTotalPrestacao.compareTo(pagamentoConjunto.getValorPagamento()) == 0){
													colecaoPagamentosDuplicados.add(pagamentoConjunto);
												}else{
													colecaoPagamentosPagos.add(pagamentoConjunto);
												}
											}

										}else if(guiaPagamentoPrestacaoHistorico.getDebitoCreditoSituacao().getId()
														.equals(DebitoCreditoSituacao.CANCELADA)){
											colecaoPagamentosCancelados.add(pagamentoConjunto);
										}else if(guiaPagamentoPrestacaoHistorico.getDebitoCreditoSituacao().getId()
														.equals(DebitoCreditoSituacao.PARCELADA)){
											colecaoPagamentosParcelados.add(pagamentoConjunto);
										}
									}

								}catch(ErroRepositorioException e){
									throw new ControladorException("erro.sistema", e);
								}

							}

						}

					}

					// ********************************************************

				}

				// Para os pagamentos sem guia de pagamento preenchida (GPAG_ID igual a nulo)
				if(colecaoPagamentosGuiaPagamentoNaoPreenchida != null && !colecaoPagamentosGuiaPagamentoNaoPreenchida.isEmpty()){

					/*
					 * Para cada conjunto de pagamentos com mesma localidade, mesma matrícula do
					 * imóvel,
					 * mesmo código de cliente e mesmo tipo de débito:
					 */
					Iterator iteratorColecaoPagamentosGuiaPagamentoNaoPreenchida = colecaoPagamentosGuiaPagamentoNaoPreenchida.iterator();
					pagamento = null;
					primeiraEntrada = true;
					conjuntoFechado = false;
					clienteAnterior = null;
					localidadeAnterior = null;
					debitoTipoAnterior = null;
					imovelAnterior = null;

					// GuiaPagamento guiaPagamentoConjunto = null;
					cliente = null;
					debitoTipo = null;
					colecaoConjuntoPagamentos = new ArrayList();

					while(iteratorColecaoPagamentosGuiaPagamentoNaoPreenchida.hasNext()){

						// System.out.println("GUIA NÃO PREENCHIDA");

						pagamentoArray = (Object[]) iteratorColecaoPagamentosGuiaPagamentoNaoPreenchida.next();

						if(pagamentoArray[1] != null){
							documentoTipo = new DocumentoTipo();
							documentoTipo.setId((Integer) pagamentoArray[1]);
						}else{
							documentoTipo = null;
						}

						if(pagamentoArray[2] != null){
							localidade = new Localidade();
							localidade.setId((Integer) pagamentoArray[2]);
						}else{
							localidade = null;
						}

						if(pagamentoArray[3] != null){
							imovel = new Imovel();
							imovel.setId((Integer) pagamentoArray[3]);
						}else{
							imovel = null;
						}

						if(pagamentoArray[4] != null){
							pagamentoSituacaoAtual = new PagamentoSituacao();
							pagamentoSituacaoAtual.setId((Integer) pagamentoArray[4]);
						}else{
							pagamentoSituacaoAtual = null;
						}

						if(pagamentoArray[5] != null){
							cliente = new Cliente();
							cliente.setId((Integer) pagamentoArray[5]);
						}else{
							cliente = null;
						}

						if(pagamentoArray[6] != null){
							debitoTipo = new DebitoTipo();
							debitoTipo.setId((Integer) pagamentoArray[6]);
						}else{
							debitoTipo = null;
						}

						if(pagamentoArray[7] != null){
							valorPagamento = (BigDecimal) pagamentoArray[7];
						}else{
							valorPagamento = null;
						}

						if(pagamentoArray[8] != null){
							dataPagamento = (Date) pagamentoArray[8];
						}else{
							dataPagamento = null;
						}

						if(pagamentoArray[9] != null){
							anoMesReferenciaPagamento = (Integer) pagamentoArray[9];
						}else{
							anoMesReferenciaPagamento = null;
						}

						if(pagamentoArray[10] != null){
							idAvisoBancario = (Integer) pagamentoArray[10];
							avisoBancario = new AvisoBancario();
							avisoBancario.setId(idAvisoBancario);
						}else{
							avisoBancario = null;
						}

						pagamento = new Pagamento();
						pagamento.setId((Integer) pagamentoArray[0]);
						pagamento.setDocumentoTipo(documentoTipo);
						pagamento.setLocalidade(localidade);
						pagamento.setImovel(imovel);
						pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);
						pagamento.setCliente(cliente);
						pagamento.setDebitoTipo(debitoTipo);
						pagamento.setValorPagamento(valorPagamento);
						pagamento.setDataPagamento(dataPagamento);
						pagamento.setAnoMesReferenciaPagamento(anoMesReferenciaPagamento);
						pagamento.setAvisoBancario(avisoBancario);

						if(!primeiraEntrada){

							if((localidadeAnterior == null && pagamento.getLocalidade() == null)
											|| (localidadeAnterior != null && pagamento.getLocalidade() != null && localidadeAnterior
															.getId().equals(pagamento.getLocalidade().getId()))){

								if((imovelAnterior == null && pagamento.getImovel() == null)
												|| (imovelAnterior != null && pagamento.getImovel() != null && imovelAnterior.getId()
																.equals(pagamento.getImovel().getId()))){

									if((clienteAnterior == null && pagamento.getCliente() == null)
													|| (clienteAnterior != null && pagamento.getCliente() != null && clienteAnterior
																	.getId().equals(pagamento.getCliente().getId()))){

										if((debitoTipoAnterior == null && pagamento.getDebitoTipo() == null)
														|| (debitoTipoAnterior != null && pagamento.getDebitoTipo() != null && debitoTipoAnterior
																		.getId().equals(pagamento.getDebitoTipo().getId()))){

											colecaoConjuntoPagamentos.add(pagamento);
											conjuntoFechado = false;
										}else{
											conjuntoFechado = true;
										}
									}else{
										conjuntoFechado = true;
									}
								}else{
									conjuntoFechado = true;
								}
							}else{
								conjuntoFechado = true;
							}

						}else{
							primeiraEntrada = false;
							colecaoConjuntoPagamentos.add(pagamento);
						}

						if(conjuntoFechado){

							/*
							 * [SF0003] Selecionar Guia de Pagamento pela Localidade, Imóvel,
							 * Cliente, Tipo de Débito
							 */
							guiaPagamentoConjunto = this.selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(imovelAnterior,
											clienteAnterior, debitoTipoAnterior);

							/*
							 * Caso a guia de pagamento não seja encontrada (retorno nulo do
							 * [SB0003]) e a situação atual (PGST_IDATUAL) não corresponda a
							 * baixar valor excedente (tabela PAGAMENTO_SITUACAO), atualizar a
							 * situação atual dos pagamentos (PGST_IDATUAL) com valor
							 * correspondente a documento inexistente (tabela PAGAMENTO_SITUACAO) e
							 * o valor excedente (PGMT_VLEXCEDENTE) com o valor do
							 * pagamento
							 */

							iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos.iterator();

							if(guiaPagamentoConjunto == null){

								while(iteratorColecaoConjuntoPagamentos.hasNext()){
									pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos.next();
									if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
													|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
																	.getPagamentoSituacaoAtual().getId()
																	.equals(PagamentoSituacao.VALOR_A_BAIXAR))){

										pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());
										colecaoPagamentosAtualizar.add(pagamentoConjunto);
									}
								}
							}else{

								/*
								 * Caso o ano/mês de referência contábil da guia de pagamento seja
								 * maior ou igual ao ano/mês de referência do faturamento
								 * atualizar a situação atual dos pagamentos com o valor
								 * correspondente a documento inexistente, o valor excedente com o
								 * valor do pagamento e a identificação da guia de pagamento no
								 * pagamento.
								 */
								/*
								 * if (!(guiaPagamentoConjunto
								 * .getAnoMesReferenciaContabil().compareTo(
								 * anoMesFaturamento) == -1)) {
								 * while (iteratorColecaoConjuntoPagamentos
								 * .hasNext()) {
								 * pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos
								 * .next();
								 * pagamentoConjunto
								 * .setGuiaPagamento(guiaPagamentoConjunto);
								 * pagamentoConjunto
								 * .setValorExcedente(pagamentoConjunto
								 * .getValorPagamento());
								 * colecaoPagamentosAtualizar
								 * .add(pagamentoConjunto);
								 * }
								 * } else {
								 */
								// [SF0004] Processar Pagamento de Guia de Pagamento
								retorno.addAll(this.processarPagamentoGuiaPagamento(guiaPagamentoConjunto, colecaoConjuntoPagamentos));

							}

							colecaoConjuntoPagamentos = new ArrayList();
							colecaoConjuntoPagamentos.add(pagamento);
						}

						localidadeAnterior = pagamento.getLocalidade();
						imovelAnterior = pagamento.getImovel();
						clienteAnterior = pagamento.getCliente();
						debitoTipoAnterior = pagamento.getDebitoTipo();
					}

					/* Último registro */
					if(!colecaoConjuntoPagamentos.isEmpty()){

						/*
						 * [SF0003] Selecionar Guia de Pagamento pela Localidade, Imóvel, Cliente,
						 * Tipo de Débito
						 */
						guiaPagamentoConjunto = this.selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(imovelAnterior,
										clienteAnterior, debitoTipoAnterior);

						/*
						 * Caso a guia de pagamento não seja encontrada (retorno nulo do [SB0003]) e
						 * a situação atual (PGST_IDATUAL) não
						 * corresponda a baixar valor excedente (tabela PAGAMENTO_SITUACAO),
						 * atualizar a situação atual dos
						 * pagamentos (PGST_IDATUAL) com valor correspondente a documento
						 * inexistente (tabela PAGAMENTO_SITUACAO) e o
						 * valor excedente (PGMT_VLEXCEDENTE) com o valor do pagamento
						 */
						iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos.iterator();

						if(guiaPagamentoConjunto == null){

							while(iteratorColecaoConjuntoPagamentos.hasNext()){
								pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos.next();

								if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
												|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
																.getPagamentoSituacaoAtual().getId()
																.equals(PagamentoSituacao.VALOR_A_BAIXAR))){

									pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());
									colecaoPagamentosAtualizar.add(pagamentoConjunto);

								}

							}
						}
					}else{

						/*
						 * Caso o ano/mês de referência contábil da guia de pagamento seja maior ou
						 * igual ao ano/mês de referência do faturamento
						 * atualizar a situação atual dos pagamentos com o valor correspondente a
						 * documento inexistente, o valor excedente com o valor
						 * do pagamento e a identificação da guia de pagamento no pagamento.
						 */
						/*
						 * if (!(guiaPagamentoConjunto
						 * .getAnoMesReferenciaContabil().compareTo(
						 * anoMesFaturamento) == -1)) {
						 * while (iteratorColecaoConjuntoPagamentos.hasNext()) {
						 * pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos
						 * .next();
						 * pagamentoConjunto
						 * .setGuiaPagamento(guiaPagamentoConjunto);
						 * pagamentoConjunto
						 * .setValorExcedente(pagamentoConjunto
						 * .getValorPagamento());
						 * colecaoPagamentosAtualizar
						 * .add(pagamentoConjunto);
						 * }
						 * } else {
						 */
						// [SB0004] Processar Pagamento de Guia de Pagamento
						retorno.addAll(this.processarPagamentoGuiaPagamento(guiaPagamentoConjunto, colecaoConjuntoPagamentos));

					}
					colecaoConjuntoPagamentos = new ArrayList();
				}
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosPagos != null && !colecaoPagamentosPagos.isEmpty()){

			try{
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosPagos,
								PagamentoSituacao.PAGAMENTO_DOC_PAGO);
			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosDuplicados != null && !colecaoPagamentosDuplicados.isEmpty()){

			try{
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosDuplicados,
								PagamentoSituacao.PAGAMENTO_DUPLICADO);

			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosCancelados != null && !colecaoPagamentosCancelados.isEmpty()){

			try{
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosCancelados,
								PagamentoSituacao.PAGAMENTO_DOC_CANCELADO);

			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosParcelados != null && !colecaoPagamentosParcelados.isEmpty()){

			try{
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosParcelados,
								PagamentoSituacao.PAGAMENTO_DOC_PARCELADO);

			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem esteja vazia Atualiza a
		 * situação e o valor excedente do pagamento.
		 */
		if(colecaoPagamentosAtualizar != null && !colecaoPagamentosAtualizar.isEmpty()){

			try{

				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosAtualizar,
								PagamentoSituacao.FATURA_INEXISTENTE);

			}catch(ErroRepositorioException ex){
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * ==========================================================================================
		 * ====
		 * FIM pagamentos com tipo de documento (DOPT_ID) com valor correspondente a GUIA DE
		 * PAGAMENTO:
		 * ==========================================================================================
		 * ====
		 */
		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @return Object
	 */
	private Object selecionarDebitoACobrar(Integer idImovel, Integer idDebitoTipo) throws ControladorException{

		DebitoACobrar debitoACobrar = null;
		DebitoACobrarHistorico debitoACobrarHistorico = null;

		if(idImovel != null && idDebitoTipo != null){

			try{
				Collection collDebitoACobrar = repositorioArrecadacao.pesquisarDebitoACobrar(idImovel, idDebitoTipo);
				if(collDebitoACobrar == null || collDebitoACobrar.isEmpty()){
					// caso não encontre a guia, procurar no histórico
					Collection collDebitoACobrarHistorico = repositorioArrecadacao.pesquisarDebitoACobrarHistorico(idImovel, idDebitoTipo);
					if(collDebitoACobrarHistorico != null && !collDebitoACobrarHistorico.isEmpty()){
						debitoACobrarHistorico = (DebitoACobrarHistorico) Util.retonarObjetoDeColecao(collDebitoACobrarHistorico);
					}
				}else{
					debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(collDebitoACobrar);
				}

			}catch(ErroRepositorioException e){
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

		if(debitoACobrar != null){
			return debitoACobrar;
		}else if(debitoACobrarHistorico != null){
			return debitoACobrarHistorico;
		}else{
			return null;
		}

	}

	/**
	 * @author jns
	 * @param colecaoPagamentosConta
	 * @param imovel
	 * @param anoMesReferenciaPagamento
	 * @throws ControladorException
	 */
	protected void classificarPagamentosContaMovimentoArrecadadores(Collection<Pagamento> colecaoPagamentosConta, Imovel imovel,
					Integer anoMesReferenciaPagamento, Pagamento pagamentoAClassificar)
					throws ControladorException{

		// long ini = 0L, dif = 0L;

		Collection<Pagamento> colecaoPagamentosAtualizacao = new ArrayList();

		try{
			if(!colecaoPagamentosConta.isEmpty()){

				// Para cada conjunto de pagamentos com mesma localidade, mesma matrícula do imóvel
				// e mesmo ano/mês de referência do pagamento
				Conta conta = null;
				ContaHistorico contaHistorico = null;

				// [SB0001] Selecionar Conta pelo Imóvel e Ano/Mês de Referência
				Object retornoPesquisa = this.selecionarContaPorImovelAnoMesReferencia(imovel, anoMesReferenciaPagamento);

				/*
				 * Caso a conta não seja encontrada na tabela conta e nem no histórico
				 * e nem no histórico (retorno nulo do [SB0001]) e a
				 * situação atual (PGST_IDATUAL) não corresponda a baixar valor
				 * excedente (tabela PAGAMENTO_SITUACAO), atualizar a situação atual
				 * dos pagamentos (PGST_IDATUAL) com valor correspondente a
				 * documento inexistente (tabela PAGAMENTO_SITUACAO) e o valor
				 * excedente (PGMT_VLEXCEDENTE) com o valor do pagamento
				 * (PGMT_VLPAGAMENTO).
				 */

				Iterator<Pagamento> iteratorColecaoConjuntoPagamentos = colecaoPagamentosConta.iterator();

				if(retornoPesquisa == null){

					while(iteratorColecaoConjuntoPagamentos.hasNext()){
						Pagamento pagamentoConjunto = iteratorColecaoConjuntoPagamentos.next();

						if(pagamentoConjunto.getConta() != null){

							// ----------------------------------
							repositorioArrecadacao.atualizarIndPagamentoContaNaoClassif(pagamentoConjunto.getConta().getId());
							// ----------------------------------------------

						}

						if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
										|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
														.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR))){
							pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());
							colecaoPagamentosAtualizacao.add(pagamentoConjunto);
						}

					}

				}else{

					/*
					 * Caso tenha encontrado a Conta, recupera conta por um cast
					 * caso contrário recupera a ContaHistorico
					 */
					if(retornoPesquisa instanceof Conta){
						conta = (Conta) retornoPesquisa;

					}else if(retornoPesquisa instanceof ContaHistorico){
						contaHistorico = (ContaHistorico) retornoPesquisa;
					}

					if(contaHistorico != null){

						// ................................................................................................
						// VERSÃO NOVA 26/07/2010 - Yara Souza
						// ................................................................................................
						// caso pagamento para conta em histórico
						Collection<Pagamento> colecaoPagamentosDuplicidade = new ArrayList();
						Collection<Pagamento> colecaoPagamentosContaCancelada = new ArrayList();
						Collection<Pagamento> colecaoPagamentosContaParcelada = new ArrayList();
						Collection<Pagamento> colecaoPagamentosContaPaga = new ArrayList();

						while(iteratorColecaoConjuntoPagamentos.hasNext()){

							Pagamento pagamentoConjunto = iteratorColecaoConjuntoPagamentos.next();

							if(pagamentoConjunto.getConta() != null){

								// ----------------------------------
								repositorioArrecadacao.atualizarIndPagamentoContaNaoClassif(pagamentoConjunto.getConta().getId());
								// ----------------------------------------------
							}

							// ---------------------------------------------------------
							Conta contaConjunto = new Conta();
							contaConjunto.setId(contaHistorico.getId());
							pagamentoConjunto.setConta(contaConjunto);
							// ---------------------------------------------------------

							if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
											|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
															.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR))){

								pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());

								if(contaHistorico.getDebitoCreditoSituacaoAtual() != null
												&& (contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.NORMAL)
																|| contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																				.equals(DebitoCreditoSituacao.RETIFICADA)
																|| contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																				.equals(DebitoCreditoSituacao.INCLUIDA) || contaHistorico
																.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO))){
									if(contaHistorico.getValorTotal().compareTo(pagamentoConjunto.getValorPagamento()) == 0){
										colecaoPagamentosDuplicidade.add(pagamentoConjunto);
									}else{
										colecaoPagamentosContaPaga.add(pagamentoConjunto);
									}
								}else if(contaHistorico.getDebitoCreditoSituacaoAtual() != null
												&& contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.CANCELADA)){

									colecaoPagamentosContaCancelada.add(pagamentoConjunto);

								}else if(contaHistorico.getDebitoCreditoSituacaoAtual() != null
												&& contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.PARCELADA)){

									colecaoPagamentosContaParcelada.add(pagamentoConjunto);
								}else{
									colecaoPagamentosAtualizacao.add(pagamentoConjunto);
								}

							}

						}

						/* Atualiza a situação e o valor excedente dos pagamentos em duplicidade. */
						if(colecaoPagamentosDuplicidade != null && !colecaoPagamentosDuplicidade.isEmpty()){

							repositorioArrecadacao.atualizarSituacaoValorExcedentePagamento(colecaoPagamentosDuplicidade,
											PagamentoSituacao.PAGAMENTO_DUPLICADO);

						}

						/* Atualiza a situação e o valor excedente dos pagamentos em cancelados. */
						if(colecaoPagamentosContaCancelada != null && !colecaoPagamentosContaCancelada.isEmpty()){

							repositorioArrecadacao.atualizarSituacaoValorExcedentePagamento(colecaoPagamentosContaCancelada,
											PagamentoSituacao.PAGAMENTO_DOC_CANCELADO);

						}

						/* Atualiza a situação e o valor excedente dos pagamentos parcelados. */
						if(colecaoPagamentosContaParcelada != null && !colecaoPagamentosContaParcelada.isEmpty()){

							repositorioArrecadacao.atualizarSituacaoValorExcedentePagamento(colecaoPagamentosContaParcelada,
											PagamentoSituacao.PAGAMENTO_DOC_PARCELADO);

						}

						/* Atualiza a situação e o valor excedente dos pagamentos já pagos. */
						if(colecaoPagamentosContaPaga != null && !colecaoPagamentosContaPaga.isEmpty()){

							repositorioArrecadacao.atualizarSituacaoValorExcedentePagamento(colecaoPagamentosContaPaga,
											PagamentoSituacao.PAGAMENTO_DOC_PAGO);

						}
					}
					// ................................................................................................

					// Caso a conta tenha sido encontrada na tabela conta
					if(conta != null){

						// [SF0002] Processar Pagamento de Conta
						this.processarPagamentoContaMovimentoArrecadadores(conta, colecaoPagamentosConta);

					}
				}
			}

			// Atualiza a situação e o valor excedente dos pagamentos.
			if(colecaoPagamentosAtualizacao != null && !colecaoPagamentosAtualizacao.isEmpty()){

				repositorioArrecadacao.atualizarSituacaoValorExcedentePagamento(colecaoPagamentosAtualizacao,
								PagamentoSituacao.FATURA_INEXISTENTE);

			}

		}catch(Exception e){
			e.printStackTrace();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB0002] - Processar Pagamento de Conta
	 * 
	 * @author jns
	 * @param conta
	 * @param colecaoPagamentos
	 * @throws ControladorException
	 */
	protected Collection<Pagamento> processarPagamentoContaMovimentoArrecadadores(Conta conta, Collection<Pagamento> colecaoPagamentos)
					throws ControladorException{

		// Declaração das variáveis
		Collection<Pagamento> colecaoPagamentosProcessados = new ArrayList<Pagamento>();
		Object[] arrayColecoesPagamentosAtualizar = null;
		Collection<Integer> idsDebitosACobrar = new ArrayList<Integer>();

		try{

			/*
			 * Caso a conta seja pré-faturada (DCST_IDATUAL com o valor correspondente à
			 * “PREFATURADA”), atualizar a situação atual dos pagamentos (PGST_IDATUAL) com o valor
			 * correspondente a “CONTA EM FATURAMENTO” (tabela PAGAMENTO_SITUACAO) e atualizar o id
			 * da conta nos pagamentos (seta CNTA_ID da tabela PAGAMENTO para o CNTA_ID da tabela
			 * CONTA).
			 */
			String idsPagamentoAtualizar = "";
			Integer idConta = conta.getId();
			if(conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.PRE_FATURADA)){

				for(Pagamento pagamento : colecaoPagamentos){

					idsPagamentoAtualizar += "," + pagamento.getId().toString();
				}

				idsPagamentoAtualizar = idsPagamentoAtualizar.substring(1);

				repositorioArrecadacao.atualizarContaESituacaoPagamento(idsPagamentoAtualizar, idConta,
								PagamentoSituacao.CONTA_EM_FATURAMENTO);
			}else{

				// Caso contrário, ou seja, a conta não seja pré-faturada
				// Atribuir o valor da conta ao valor do documento
				BigDecimal valorDocumento = conta.getValorTotal();

				// [SF0007] Calcular Valor Total dos Pagamentos
				BigDecimal valorTotalPagamentosConta = this.calcularValorTotalPagamentos(colecaoPagamentos);

				BigDecimal diferenca = valorTotalPagamentosConta.subtract(valorDocumento);

				Integer idContaGerada = null;
				Short indicadorTratamentoMulta = ConstantesSistema.NAO;
				Date dataEmissao = null;

				// Parâmetro que identifica se a empresa emite o documento com acrescimos
				String parametroTratarAcrescimosEmissaoDocumento = ParametroArrecadacao.P_TRATAR_ACRESCIMOS_EMISSAO_DOCUMENTO.executar()
								.toString();

				// Parâmetro que identifica se a empresa emite o documento com acrescimos
				String parametroPermitirSelecaoAcrescimosExtrato = ParametroArrecadacao.P_PERMITIR_SELECAO_ACRESCIMOS_EXTRATO.executar()
								.toString();

				if(((!Util.isVazioOuBranco(parametroTratarAcrescimosEmissaoDocumento) && parametroTratarAcrescimosEmissaoDocumento
								.equals(Short.toString(ConstantesSistema.SIM))) || parametroPermitirSelecaoAcrescimosExtrato.equals(Short
								.toString(ConstantesSistema.SIM)))
								&& diferenca.compareTo(BigDecimal.ZERO) > 0){

					// System.out.println("** ");
					// System.out.println("** colecaoPagamentos.size " + colecaoPagamentos.size());
					// System.out.println("** conta.id " + idConta);
					// System.out.println("** valorTotalPagamentosConta " +
					// valorTotalPagamentosConta);
					// System.out.println("** valorDocumento " + valorDocumento);
					// System.out.println("** diferenca Antes " + diferenca);

					// Quando a diferença entre o valor pago e o valor da conta for maior que zero e
					// a empresa realize a emissão de documentos com acréscimos, o sistema deve
					// calcular os acréscimos que deveriam ser cobrados e realizar uma retificação

					Object[] retornoTratamento = this.tratarAcrescimosPagamentoConta(conta, colecaoPagamentos, diferenca);

					diferenca = (BigDecimal) retornoTratamento[0];

					// System.out.println("** diferenca Depois " + diferenca);

					idContaGerada = (Integer) retornoTratamento[1];
					dataEmissao = (Date) retornoTratamento[2];
					indicadorTratamentoMulta = (Short) retornoTratamento[3];
				}

				/*
				 * Caso valor total dos pagamentos da conta seja igual ao valor do documento
				 * atualizar a
				 * situação atual dos pagamentos (PGST_IDATUAL) com
				 * valor correspondente a pagamento classificado (tabela PAGAMENTO_SITUACAO) e
				 * atualizar
				 * o id da conta nos pagamentos (seta CNTA_ID da
				 * tabela PAGAMENTO para CNTA_ID da tabela CONTA);
				 */
				// recurepa o valor absoluto da diferença entre o total dos pagamentos e o valor
				// documento
				BigDecimal diferencaAbs = diferenca.abs();

				// caso a diferença seja igual a zero
				if(diferencaAbs.compareTo(BigDecimal.ZERO) == 0){
					// 2.4. Caso valor total dos pagamentos para a conta seja igual ao valor do
					// documento

					colecaoPagamentosProcessados.addAll(colecaoPagamentos);

				}else{
					// ........................................................................................................
					// 2.5. Caso o valor total dos pagamentos para a conta seja maior que o valor do
					// documento, e exista Valor de Imposto Deduzido na conta (CNTA_VLIMPOSTOS >
					// 0,00).
					String pPermitePagamentoSemDeducaoImposto = (String) ParametroArrecadacao.P_PERMITE_PAGAMENTO_SEM_DEDUCAO_IMPOSTO
									.executar(this);

					if(conta.getValorImposto().compareTo(BigDecimal.ZERO) > 0
									&& pPermitePagamentoSemDeducaoImposto.equals(ConstantesSistema.SIM.toString())
									&& conta.getValorTotalContaSemImposto().compareTo(valorTotalPagamentosConta) == 0){

						conta.setValorImposto(BigDecimal.ZERO);

						// 1. O sistema atualiza o valor de Imposto Deduzido da conta com o valor
						// 0 (CNTA_VLIMPOSTOS = 0);
						this.repositorioArrecadacao.atualizarValorImpostoConta(idConta, conta.getValorImposto());

						// 2. O sistema exclui os dados referentes a cada imposto deduzido (Deletar
						// da tabela CONTA_IMPOSTOS_DEDUZIDOS os dados do imposto deduzido com
						// CNTA_ID = CNTA_ID relativo a conta.
						this.repositorioArrecadacao.removerContaImpostosDeduzidos(idConta);

						colecaoPagamentosProcessados.addAll(colecaoPagamentos);
						// ........................................................................................................

					}else{
						// [SB0008] Processar Pagamento a Maior ou a Menor
						arrayColecoesPagamentosAtualizar = this.processarPagamentoAMenorOUAMaior(valorTotalPagamentosConta, valorDocumento,
										colecaoPagamentos, idConta);

						if(arrayColecoesPagamentosAtualizar[1] != null && !((Collection) arrayColecoesPagamentosAtualizar[1]).isEmpty()){

							Collection colecaoPagamentosClassificados = (Collection) arrayColecoesPagamentosAtualizar[1];
							colecaoPagamentosProcessados.addAll(colecaoPagamentosClassificados);
						}
					}

				}

				if(colecaoPagamentosProcessados != null && !colecaoPagamentosProcessados.isEmpty()){

					// Consulta o parcelamento antes de transferir para histórico por questão de
					// performance
					Parcelamento parcelamentoParaRemuneracao = repositorioArrecadacao.consultarParcelamentoConta(idConta);

					if(idContaGerada != null){
						// Seta o Id da conta nova (conta gerada pela retificação), pois a conta
						// original já foi enviada para histórico
						Conta contaAux = null;

						for(Pagamento pagamentoProcessado : colecaoPagamentosProcessados){
							contaAux = pagamentoProcessado.getConta();
							contaAux.setId(idContaGerada);
						}

						idConta = idContaGerada;
					}

					repositorioArrecadacao.processarPagamentoConta(colecaoPagamentosProcessados, idConta);

					String idMunicipio = ConstantesAplicacao.get("empresa.municipio");
					Municipio municipio = new Municipio();
					municipio.setId(Util.converterStringParaInteger(idMunicipio));

					// [UC0302] Calculo de Acrescimos -- itera nos pagamentos encontrados
					Collection<Integer> idsDebitosACobrarAux = new ArrayList<Integer>();
					Collection<Integer> idsDebitosACobrarAtualizarIndicador = new ArrayList<Integer>();

					Object retornoExecutor = null;
					boolean atualizarRemuneraCobrancaAdministrativa = false;

					// Consulta aqui na procedure os ACRESC_IMPONTUALIDADE_DESCONTO e ver se o pgto pertence ao periodo. 
					for(Pagamento pagamento : colecaoPagamentosProcessados){
						Date dataUtil = getControladorCobranca().verificarDataUtilVencimento(conta.getDataVencimentoConta(), municipio);

						if(pagamento.getDataPagamento().after(dataUtil)){
							
							if(indicadorTratamentoMulta.equals(ConstantesSistema.NAO)){
								idsDebitosACobrarAux = this.getControladorFaturamento()
												.gerarDebitosACobrarDeAcrescimosPorImpontualidadeBancoDeDados(pagamento, dataEmissao);
							}

							if(!Util.isVazioOrNulo(idsDebitosACobrarAux)){
								retornoExecutor = ParametroArrecadacao.P_GERACAO_ACRESCIMOS_COBRANCA_ADMINISTRATIVA.executar(this, -1,
												pagamento);

								if(retornoExecutor != null){
									atualizarRemuneraCobrancaAdministrativa = (Boolean) retornoExecutor;
								}

								if(atualizarRemuneraCobrancaAdministrativa){
									idsDebitosACobrarAtualizarIndicador.addAll(idsDebitosACobrarAux);
								}

								idsDebitosACobrar.addAll(idsDebitosACobrarAux);

								/*
								 * for(Integer idDebitoACobrar : idsDebitosACobrarAux){
								 * FiltroDebitoACobrar filtroDebitoACobrar = new
								 * FiltroDebitoACobrar();
								 * filtroDebitoACobrar.adicionarParametro(new
								 * ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));
								 * Collection<DebitoACobrar> colecaoDebitoACobrar =
								 * this.getControladorUtil().pesquisar(
								 * filtroDebitoACobrar, DebitoACobrar.class.getName());
								 * if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){
								 * for(DebitoACobrar debitoACobrar : colecaoDebitoACobrar){
								 * System.out.println("Valor do débito: " +
								 * debitoACobrar.getValorDebito());
								 * }
								 * }
								 * }
								 */
							}
						}
					}

					if(!Util.isVazioOrNulo(idsDebitosACobrarAtualizarIndicador)){
						Collection colecaoDebitoACobrarAtualizar = new ArrayList();

						FiltroDebitoACobrar filtroDebitoACobrar = null;
						Collection<DebitoACobrar> colecaoDebitoACobrar = null;

						for(Integer idDebitoACobrar : idsDebitosACobrarAtualizarIndicador){
							filtroDebitoACobrar = new FiltroDebitoACobrar();
							filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));

							colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());

							if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){
								for(DebitoACobrar debitoACobrar : colecaoDebitoACobrar){
									debitoACobrar.setIndicadorRemuneraCobrancaAdministrativa(ConstantesSistema.SIM);

									colecaoDebitoACobrarAtualizar.add(debitoACobrar);
								}
							}
						}

						if(!Util.isVazioOrNulo(colecaoDebitoACobrarAtualizar)){
							this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoDebitoACobrarAtualizar);
						}
					}

					/**
					 * NÃO NECESSÁRIO!
					 */
					Collection colecaoPagamentosPreenchida = this.carregarAtributosPagamento(colecaoPagamentosProcessados);

					Collection colecaoPagamentoHistorico = this.criarPagamentoHistoricoDoPagamento(colecaoPagamentosPreenchida,
									PagamentoSituacao.PAGAMENTO_CLASSIFICADO);

					getControladorBatch().removerColecaoObjetoParaBatch(colecaoPagamentosPreenchida);

					this.getControladorFaturamento().transferirContasParaHistorico(idConta);

					// Verifica se há relação entre a conta paga e algum item de documento de
					// cobrança - [UC3082] Atualizar Item Documento Cobrança
					Date maiorDataPagamento = null;
					Date dataPagamentoAux = null;

					if(!Util.isVazioOrNulo(colecaoPagamentos)){
						for(Pagamento pagamento : colecaoPagamentos){
							dataPagamentoAux = pagamento.getDataPagamento();

							if(maiorDataPagamento == null
											|| (dataPagamentoAux != null && maiorDataPagamento != null && dataPagamentoAux
															.compareTo(maiorDataPagamento) > 0)){
								maiorDataPagamento = dataPagamentoAux;
							}
						}
					}

					this.getControladorCobranca().atualizarItemDocumentoCobranca(idConta, null, null, null, CobrancaDebitoSituacao.PAGO,
									maiorDataPagamento, CobrancaDebitoSituacao.PENDENTE);

					/* 4.4 PARTE 2 */
					this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoPagamentoHistorico);

					/**
					 * 4.6. Caso a conta classificada corresponda a uma entrada de parcelamento
					 * (PARC_ID
					 * da
					 * tabela CONTA diferente de nulo), verificar se há documento de cobrança
					 * vinculado
					 * (CBDO_ID da tabela PARCELAMENTO com PARC_ID = PARC_ID da tabela CONTA
					 * diferente
					 * de
					 * nulo)
					 */
					if(parcelamentoParaRemuneracao != null && parcelamentoParaRemuneracao.getCobrancaDocumento() != null){

						/**
						 * 4.6.1. Caso exista documento de cobrança associado ao parcelamento
						 * (CBDO_ID
						 * da tabela
						 * PARCELAMENTO diferente de nulo), obter documento de cobrança
						 * (COBRANCA_DOCUMENTO com CBDO_ID =
						 * CBDO_ID da tabela PARCELAMENTO)
						 */

						ContaHistorico contaHistorico = repositorioArrecadacao.pesquisarContaHistorico(idConta);

						CobrancaDocumento documentoCobranca = contaHistorico.getParcelamento().getCobrancaDocumento();
						this.remunerarAgentes(documentoCobranca, contaHistorico, colecaoPagamentoHistorico);

						/**
						 * 4.7. Caso não seja entrada(PARC_ID=Nulo da tabela CONTA), verificar se a
						 * conta está em processo
						 * de cobrança (existe CNTA_ID da tabela CONTA = CNTA_ID da tabela
						 * COBRANCA_DOCUMENTO_ITEM)
						 */

						// Se o parâmetro da Contra-Ação do parcelamento for no ato do
						// "Pagamento da entrada do Parcelamento", verificar Contra-Ação
						String contraAcaoParcelamentoIndicador = ConstantesAplicacao.get("aplicacao.contra_acao.parcelamento");
						if(contraAcaoParcelamentoIndicador != null && Util.isInteger(contraAcaoParcelamentoIndicador)){

							int contraAcaoIndicador = Util.converterStringParaInteger(contraAcaoParcelamentoIndicador);
							if(contraAcaoIndicador == ContraAcao.CONTRA_ACAO_PAGAMENTO_ENTRADA_PARCELAMENTO){

								if(contaHistorico.getContaMotivoRevisao() != null
												&& contaHistorico.getContaMotivoRevisao().getId().intValue() == ContaMotivoRevisao.REVISAO_ENTRADA_DE_PARCELAMENTO
																.intValue()){
									this.getControladorCobranca().validaDocumentoCobrancaPagamentoParaContraAcao(contaHistorico.getId());
								}

							}
						}

					}else if(parcelamentoParaRemuneracao == null){
						/**
						 * 4.7.1. Caso esteja, obter documento de cobrança (COBRANCA_DOCUMENTO com
						 * CBDO_ID = CBDO_ID da
						 * tabela COBRANCA_DOCUMENTO_ITEM)
						 */

						// CobrancaDocumento documentoCobranca =
						// this.repositorioArrecadacao.consultarUltimoCobrancaDocumentoRemuneracao(conta
						// .getId());
						//
						// ContaHistorico contaHistorico =
						// repositorioArrecadacao.consultarContaHistoricoRemuneracoes(conta.getId());
						//
						// if(documentoCobranca != null
						// && (documentoCobranca.getCobrancaAcaoAtividadeComando() != null ||
						// documentoCobranca
						// .getCobrancaAcaoAtividadeCronograma() != null)){
						//
						// this.remunerarAgentes(documentoCobranca, contaHistorico,
						// colecaoPagamentoHistorico);

						// }else{
						// /**
						// * 4.8. Caso contrário, verificar se há parcela cobrada, a ser
						// * remunerada,
						// * na conta em
						// * questão(CBDO_ID da tabela PARCELAMENTO diferente de nulo para PARC_ID
						// * =
						// * PARC_ID da tabela
						// * DEBITO_COBRADO com CNTA_ID = CNTA_ID da tabela CONTA)
						// */
						//
						// /**
						// * 4.8.1. Obter documento de cobrança (COBRANCA_DOCUMENTO com CBDO_ID =
						// * CBDO_ID da tabela PARCELAMENTO)
						// */
						//
						// Collection<DebitoCobradoHistorico> debitosCobrados =
						// repositorioArrecadacao
						// .consultarHistoricoDebitoCobrado(contaHistorico.getId());//
						// getDebitoCobradoHistoricos();
						//
						// if(debitosCobrados != null && !debitosCobrados.isEmpty()){
						//
						// for(DebitoCobradoHistorico debitoCobrado : debitosCobrados){
						// Parcelamento parcelamento = debitoCobrado.getParcelamento();
						//
						// if(parcelamento != null){
						// documentoCobranca = parcelamento.getCobrancaDocumento();
						//
						// this.remunerarAgentes(documentoCobranca, contaHistorico,
						// colecaoPagamentoHistorico);
						//
						// }
						// }
						// }
						// }

						/**
						 * Chamar metodo para realizar Contra-ação
						 * Andre Nishimura 26/04/2010
						 */

						this.getControladorCobranca().validaDocumentoCobrancaPagamentoParaContraAcao(idConta);

					}

					// # Fim da remuneração de agentes de cobrança #"
				}

				if(arrayColecoesPagamentosAtualizar != null){
					/**
					 * 0 - Coleção de pagamentos com situação igual a valor não confere.
					 * 1 - Coleção de pagamentos com situação igual pagamentos classificados.
					 * 2 - Coleção de pagamentos com situação igual pagamentos em duplicidade.
					 * 3 - Coleção de pagamentos para atualizar valor excedente.
					 * 4 - Coleção de pagamentos para atualizar situação igual a valor não confere e
					 * remover referência.
					 */
					if(arrayColecoesPagamentosAtualizar[0] != null && !((Map) arrayColecoesPagamentosAtualizar[0]).isEmpty()){
						this.repositorioArrecadacao.processarPagamentoValorNaoConfereConta((Map) arrayColecoesPagamentosAtualizar[0]);
					}

					if(arrayColecoesPagamentosAtualizar[2] != null && !((Collection) arrayColecoesPagamentosAtualizar[2]).isEmpty()){

						this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_DUPLICADO,
										(Collection) arrayColecoesPagamentosAtualizar[2]);
					}
					if(arrayColecoesPagamentosAtualizar[3] != null && !((Collection) arrayColecoesPagamentosAtualizar[3]).isEmpty()){
						this.repositorioArrecadacao.atualizarValorExcedentePagamento((Collection) arrayColecoesPagamentosAtualizar[3]);
					}

					if(arrayColecoesPagamentosAtualizar[4] != null && !((Collection) arrayColecoesPagamentosAtualizar[4]).isEmpty()){
						this.repositorioArrecadacao
										.processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo((Collection) arrayColecoesPagamentosAtualizar[4]);
					}

					if(arrayColecoesPagamentosAtualizar[5] != null && !((Collection) arrayColecoesPagamentosAtualizar[5]).isEmpty()){
						this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_A_MENOR,
										(Collection) arrayColecoesPagamentosAtualizar[5]);
					}

					if(arrayColecoesPagamentosAtualizar[6] != null && !((Collection) arrayColecoesPagamentosAtualizar[6]).isEmpty()){
						this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_A_MAIOR,
										(Collection) arrayColecoesPagamentosAtualizar[6]);
					}
					// ...................................................................
				}
			}

			this.getControladorFaturamento().registrarLancamentoContabilDebitoACobrar(idsDebitosACobrar);

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
		return null;
	}

	/**
	 * Classifica a coleção de pagamentos para contas.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 18/04/2006, 06/12/2006
	 * @author Saulo Lima
	 * @date 17/11/2008
	 *       Fazer a classificação ser on-line
	 * @author Saulo Lima
	 * @date 07/06/2010
	 *       Melhorando o desempenho do Classificar
	 * @param colecaoPagamentosConta
	 * @param imovel
	 * @throws ControladorException
	 */
	// FIXME AHGL - Validando Método - Chamado por um método DEPRECATED
	@Deprecated
	protected Collection<Pagamento> classificarPagamentosConta(Collection<Object[]> colecaoPagamentosConta, Imovel imovel)
					throws ControladorException{

		Collection<Pagamento> retorno = new ArrayList<Pagamento>();
		Collection<Pagamento> colecaoPagamentosAtualizacao = new ArrayList();
		Collection<Pagamento> colecaoConjuntoPagamentos = new ArrayList();
		Integer anoMesReferenciaPagamento = null;
		AvisoBancario avisoBancario = null;

		try{
			/*
			 * ======================================================================================
			 * ========
			 * Para os pagamentos com tipo de documento(DOPT_ID) com valor correspondente a CONTA:
			 * ======================================================================================
			 * ========
			 */
			if(!colecaoPagamentosConta.isEmpty()){

				// Para cada conjunto de pagamentos com mesma localidade, mesma matrícula do imóvel
				// e mesmo ano/mês de referência do pagamento
				Iterator<Object[]> iteratorColecaoPagamentosConta = colecaoPagamentosConta.iterator();
				Conta conta = null;
				ContaHistorico contaHistorico = null;

				// Laço para montar os pagamentos e acumular.
				while(iteratorColecaoPagamentosConta.hasNext()){

					Object[] pagamentoArray = iteratorColecaoPagamentosConta.next();

					DocumentoTipo documentoTipo = null;
					if(pagamentoArray[1] != null){
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) pagamentoArray[1]);
					}

					Localidade localidade = null;
					if(pagamentoArray[2] != null){
						localidade = new Localidade();
						localidade.setId((Integer) pagamentoArray[2]);
					}

					BigDecimal valorPagamento = null;
					if(pagamentoArray[3] != null){
						valorPagamento = (BigDecimal) pagamentoArray[3];
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;
					if(pagamentoArray[4] != null){
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual.setId((Integer) pagamentoArray[4]);
					}

					Date dataPagamento = null;
					if(pagamentoArray[5] != null){
						dataPagamento = (Date) pagamentoArray[5];
					}

					if(pagamentoArray[6] != null){
						anoMesReferenciaPagamento = (Integer) pagamentoArray[6];
					}else{
						anoMesReferenciaPagamento = null;
					}
					if(pagamentoArray[7] != null){
						avisoBancario = new AvisoBancario();
						avisoBancario = (AvisoBancario) pagamentoArray[7];
					}

					Pagamento pagamento = new Pagamento();
					pagamento.setId((Integer) pagamentoArray[0]);
					pagamento.setDocumentoTipo(documentoTipo);
					pagamento.setLocalidade(localidade);
					pagamento.setImovel(imovel);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);
					pagamento.setValorPagamento(valorPagamento);
					pagamento.setDataPagamento(dataPagamento);
					pagamento.setAvisoBancario(avisoBancario);
					colecaoConjuntoPagamentos.add(pagamento);
				}

				// [SB0001] Selecionar Conta pelo Imóvel e Ano/Mês de Referência
				Object retornoPesquisa = this.selecionarContaPorImovelAnoMesReferencia(imovel, anoMesReferenciaPagamento);

				/*
				 * Caso a conta não seja encontrada na tabela conta e nem no histórico
				 * e nem no histórico (retorno nulo do [SB0001]) e a
				 * situação atual (PGST_IDATUAL) não corresponda a baixar valor
				 * excedente (tabela PAGAMENTO_SITUACAO), atualizar a situação atual
				 * dos pagamentos (PGST_IDATUAL) com valor correspondente a
				 * documento inexistente (tabela PAGAMENTO_SITUACAO) e o valor
				 * excedente (PGMT_VLEXCEDENTE) com o valor do pagamento
				 * (PGMT_VLPAGAMENTO).
				 */

				Iterator<Pagamento> iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos.iterator();

				if(retornoPesquisa == null){

					while(iteratorColecaoConjuntoPagamentos.hasNext()){

						Pagamento pagamentoConjunto = iteratorColecaoConjuntoPagamentos.next();

						if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
										|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
														.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR))){

							pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());

							colecaoPagamentosAtualizacao.add(pagamentoConjunto);
						}
					}
				}else{

					/*
					 * Caso tenha encontrado a Conta, recupera conta por um cast
					 * caso contrário recupera a ContaHistorico
					 */
					if(retornoPesquisa instanceof Conta){
						conta = (Conta) retornoPesquisa;
					}else if(retornoPesquisa instanceof ContaHistorico){
						contaHistorico = (ContaHistorico) retornoPesquisa;
					}

					// ................................................................................................
					// VERSÃO NOVA 26/07/2010 - Yara Souza
					// ................................................................................................
					// caso pagamento para conta em histórico
					Collection<Pagamento> colecaoPagamentosDuplicidade = new ArrayList();
					Collection<Pagamento> colecaoPagamentosContaCancelada = new ArrayList();
					Collection<Pagamento> colecaoPagamentosContaParcelada = new ArrayList();
					Collection<Pagamento> colecaoPagamentosContaPaga = new ArrayList();

					if(contaHistorico != null){
						while(iteratorColecaoConjuntoPagamentos.hasNext()){

							Pagamento pagamentoConjunto = iteratorColecaoConjuntoPagamentos.next();

							// ---------------------------------------------------------
							Conta contaConjunto = new Conta();
							contaConjunto.setId(contaHistorico.getId());
							pagamentoConjunto.setConta(contaConjunto);
							// ---------------------------------------------------------

							if(pagamentoConjunto.getPagamentoSituacaoAtual() == null
											|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null && !pagamentoConjunto
															.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR))){

								pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());

								if(contaHistorico.getDebitoCreditoSituacaoAtual() != null
												&& (contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.NORMAL)
																|| contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																				.equals(DebitoCreditoSituacao.RETIFICADA)
																|| contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																				.equals(DebitoCreditoSituacao.INCLUIDA) || contaHistorico
																.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO))){

									if(contaHistorico.getValorTotal().compareTo(pagamentoConjunto.getValorPagamento()) == 0){

										colecaoPagamentosDuplicidade.add(pagamentoConjunto);
									}else{

										colecaoPagamentosContaPaga.add(pagamentoConjunto);
									}
								}else if(contaHistorico.getDebitoCreditoSituacaoAtual() != null
												&& contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.CANCELADA)){

									colecaoPagamentosContaCancelada.add(pagamentoConjunto);
								}else if(contaHistorico.getDebitoCreditoSituacaoAtual() != null
												&& contaHistorico.getDebitoCreditoSituacaoAtual().getId()
																.equals(DebitoCreditoSituacao.PARCELADA)){

									colecaoPagamentosContaParcelada.add(pagamentoConjunto);
								}

							}

						}

						/* Atualiza a situação e o valor excedente dos pagamentos em duplicidade. */
						if(colecaoPagamentosDuplicidade != null && !colecaoPagamentosDuplicidade.isEmpty()){
							repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosDuplicidade,
											PagamentoSituacao.PAGAMENTO_DUPLICADO);
						}

						/* Atualiza a situação e o valor excedente dos pagamentos em cancelados. */
						if(colecaoPagamentosContaCancelada != null && !colecaoPagamentosContaCancelada.isEmpty()){
							repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosContaCancelada,
											PagamentoSituacao.PAGAMENTO_DOC_CANCELADO);
						}

						/* Atualiza a situação e o valor excedente dos pagamentos parcelados. */
						if(colecaoPagamentosContaParcelada != null && !colecaoPagamentosContaParcelada.isEmpty()){
							repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosContaParcelada,
											PagamentoSituacao.PAGAMENTO_DOC_PARCELADO);
						}

						/* Atualiza a situação e o valor excedente dos pagamentos já pagos. */
						if(colecaoPagamentosContaPaga != null && !colecaoPagamentosContaPaga.isEmpty()){
							repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosContaPaga,
											PagamentoSituacao.PAGAMENTO_DOC_PAGO);
						}

					}

					// ................................................................................................

					// Caso a conta tenha sido encontrada na tabela conta
					if(conta != null){

						// [SF0002] Processar Pagamento de Conta
						retorno = this.processarPagamentoConta(conta, colecaoConjuntoPagamentos);
					}
				}
			}

			// Atualiza a situação e o valor excedente dos pagamentos.
			if(colecaoPagamentosAtualizacao != null && !colecaoPagamentosAtualizacao.isEmpty()){
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosAtualizacao,
								PagamentoSituacao.FATURA_INEXISTENTE);
			}

		}catch(Exception e){
			e.printStackTrace();
			throw new EJBException(e);
		}
		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @return Object
	 */
	private Object selecionarGuiaPagamento(Integer idGuiaPagamento) throws ControladorException{

		GuiaPagamento guiaPagamento = null;
		GuiaPagamentoHistorico guiaPagamentoHistorico = null;

		if(idGuiaPagamento != null){

			try{
				Collection collGuiaPagamento = repositorioArrecadacao.pesquisarGuiaPagamento(idGuiaPagamento);
				if(collGuiaPagamento == null || collGuiaPagamento.isEmpty()){
					// caso não encontre a guia, procurar no histórico
					Collection collGuiaPagamentoHistorico = repositorioArrecadacao.pesquisarGuiaPagamentoHistorico(idGuiaPagamento);
					if(collGuiaPagamentoHistorico != null && !collGuiaPagamentoHistorico.isEmpty()){
						guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util.retonarObjetoDeColecao(collGuiaPagamentoHistorico);
					}
				}else{
					guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(collGuiaPagamento);
				}

			}catch(ErroRepositorioException e){
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

		if(guiaPagamento != null){
			return guiaPagamento;
		}else if(guiaPagamentoHistorico != null){
			return guiaPagamentoHistorico;
		}else{
			return null;
		}

	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * [SB0012] – Verifica Pagamento de Debito a Cobrar de Parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @date 19/07/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void verificaPagamentoDebitoACobrarParcelamento(Integer idDebitoACobrar, Integer idParcelamento) throws ControladorException{

		FiltroDebitoACobrar fdac = new FiltroDebitoACobrar();
		fdac.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.PARCELAMENTO_ID, idParcelamento));
		fdac.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.DEBITO_TIPO_ID, DebitoTipo.JUROS_SOBRE_PARCELAMENTO));
		Collection coll = getControladorUtil().pesquisar(fdac, DebitoACobrar.class.getName());
		if(coll != null && !coll.isEmpty()){
			Iterator it = coll.iterator();
			while(it.hasNext()){
				DebitoACobrar dbac = (DebitoACobrar) it.next();

				DebitoCreditoSituacao dcs = new DebitoCreditoSituacao();
				dcs.setId(DebitoCreditoSituacao.CANCELADA);
				dbac.setDebitoCreditoSituacaoAtual(dcs);

				Collection<DebitoACobrar> collDJuros = new ArrayList<DebitoACobrar>();
				collDJuros.add(dbac);

				this.getControladorFaturamento().transferirDebitosACobrarParaHistorico(collDJuros, Boolean.FALSE);
			}
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0016] - Inserir o item de movimento do arrecadador da Ficha de Compensação
	 * Autor: Vivianne Sousa
	 * Data: 27/11/2007
	 */
	public Integer inserirItemMovimentoArrecadadorFichaCompensacao(String linhaRegistroCodigoT, String linhaRegistroCodigoU,
					Integer idMovimento, String descricaoOcorrencia, int indicadorAceitacaoRegistro, Integer idImovelPagamento)
					throws ControladorException{

		Integer idArrecadadorMovimentoItem = null;

		Integer idRegistroCodigo = RegistroCodigo.FICHA_COMPENSACAO_ID;

		// seta os campos para a inserção em arrecadador movimento item
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();

		RegistroCodigo registroCodigo = new RegistroCodigo();
		registroCodigo.setId(idRegistroCodigo);

		StringBuilder conteudoMovimento = new StringBuilder();
		conteudoMovimento.append(linhaRegistroCodigoT.substring(0, 13));
		conteudoMovimento.append(linhaRegistroCodigoT.substring(15, 57));
		conteudoMovimento.append(linhaRegistroCodigoT.substring(58, 96));
		conteudoMovimento.append(linhaRegistroCodigoU.substring(92, 107));
		conteudoMovimento.append(linhaRegistroCodigoU.substring(137, 153));

		arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);

		String linhaRegistro = conteudoMovimento.toString();
		String caracterUltimaPosicaoLinha = linhaRegistro.substring(linhaRegistro.length() - 1);

		String linhaRegistroAuxiliar = "";
		if(caracterUltimaPosicaoLinha.equals(" ")){

			linhaRegistroAuxiliar = linhaRegistro.substring(0, linhaRegistro.length() - 1) + "*";
		}else{

			linhaRegistroAuxiliar = linhaRegistro;
		}

		arrecadadorMovimentoItem.setConteudoRegistro(linhaRegistroAuxiliar);
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);
		arrecadadorMovimentoItem.setDescricaoOcorrencia(descricaoOcorrencia);
		arrecadadorMovimentoItem.setIndicadorAceitacao(Short.valueOf("" + indicadorAceitacaoRegistro));
		arrecadadorMovimentoItem.setUltimaAlteracao(new Date());
		if(idImovelPagamento != null){
			Imovel imovel = new Imovel();
			imovel.setId(idImovelPagamento);
			arrecadadorMovimentoItem.setImovel(imovel);
		}

		try{
			idArrecadadorMovimentoItem = (Integer) repositorioUtil.inserir(arrecadadorMovimentoItem);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return idArrecadadorMovimentoItem;

	}

	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação
	 * Autor: Vivianne Sousa
	 * Data: 26/11/2007
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosFichaCompensacao(SistemaParametro sistemaParametro, Date dataPagamento,
					BigDecimal valorPagamento, String nossoNumero) throws ControladorException{

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";
		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();

		Integer tipoDocumento = Integer.valueOf(nossoNumero.substring(7, 9));
		Integer idDocumentoEmitido = Integer.valueOf(nossoNumero.substring(9, 17));

		// 5.
		FiltroDocumentoTipo filtroDocumentoTipo = new FiltroDocumentoTipo();
		filtroDocumentoTipo.adicionarParametro(new ParametroSimples(FiltroDocumentoTipo.ID, tipoDocumento));
		Collection colecaoDocumentoTipo = getControladorUtil().pesquisar(filtroDocumentoTipo, DocumentoTipo.class.getName());

		// Caso o tipo de documento não esteja na tabela COBRANCA.DOCUMENTO_TIPO
		if(colecaoDocumentoTipo == null || colecaoDocumentoTipo.isEmpty()){
			indicadorAceitacaoRegistro = "2";
			descricaoOcorrencia = "TIPO DE DOCUMENTO INVÁLIDO";
		}else{

			if(tipoDocumento.equals(DocumentoTipo.CONTA)){
				// 6.1
				// [SB0001]-Processar Pagamento de Conta

				Conta conta = null;
				try{
					conta = repositorioFaturamento.pesquisarExistenciaContaComSituacaoAtual(idDocumentoEmitido);
				}catch(ErroRepositorioException e){
					// Auto-generated catch block
					e.printStackTrace();
				}

				// [FS0001]-Validar Conta
				if(conta == null){
					descricaoOcorrencia = "CONTA INEXISTENTE";
				}

				if(descricaoOcorrencia.equalsIgnoreCase("OK")){
					// Cria o objeto pagamento para setar os dados
					Pagamento pagamento = new Pagamento();
					Integer anoMesPagamento = Util.recuperaAnoMesDaData(dataPagamento);
					pagamento.setAnoMesReferenciaPagamento(conta.getReferencia());

					/*
					 * Caso o ano mes da data de dedito seja maior que o ano mes de
					 * arrecadação da tabela sistema parametro então seta o ano mes da
					 * data de debito
					 */
					if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){

						pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

					}else{

						/*
						 * caso contrario seta o o ano mes arrecadação da tabela sistema
						 * parametro
						 */
						pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
					}

					pagamento.setValorPagamento(valorPagamento);
					pagamento.setDataPagamento(dataPagamento);
					pagamento.setPagamentoSituacaoAtual(null);
					pagamento.setPagamentoSituacaoAnterior(null);
					pagamento.setDebitoTipo(null);

					pagamento.setConta(conta);
					pagamento.setGuiaPagamentoGeral(null);
					pagamento.setLocalidade(conta.getImovel().getLocalidade());

					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.CONTA);
					pagamento.setDocumentoTipo(documentoTipo);
					pagamento.setAvisoBancario(null);

					pagamento.setImovel(conta.getImovel());
					pagamento.setArrecadadorMovimentoItem(null);

					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
					arrecadacaoForma.setId(16);
					pagamento.setArrecadacaoForma(arrecadacaoForma);
					pagamento.setCliente(null);
					pagamento.setUltimaAlteracao(new Date());

					colecaoPagamentos.add(pagamento);

				}else{
					indicadorAceitacaoRegistro = "2";
				}

			}else{
				// 6.2
				indicadorAceitacaoRegistro = "2";
				descricaoOcorrencia = "FICHA DE COMPENS. COM TIPO DE PAGAMENTO INVÁLIDO";
			}
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SF0013] - Inserir o movimento do arrecadador da Ficha de Compensação
	 * Autor: Vivianne Sousa
	 * Data: 27/11/2007
	 */
	public ArrecadadorMovimento inserirMovimentoArrecadadorFichaCompensacao(RegistroHelperCodigo0 registroHelperCodigo0,
					BigDecimal somatorioValorTITCarteira07, RegistroHelperCodigo9 registroHelperCodigo9, String idTipoMovimento,
					Integer quantidadeItens) throws ControladorException{

		Integer idMovimento = null;

		// Cria o objeto de arrecadador movimento para a inserção
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setCodigoRemessa(Short.valueOf(registroHelperCodigo0.getCodigoRemessaRetorno()));
		arrecadadorMovimento.setCodigoConvenio(registroHelperCodigo0.getCodigoConvenioBanco().trim());
		arrecadadorMovimento.setNomeEmpresa(registroHelperCodigo0.getNomeEmpresa().trim());
		arrecadadorMovimento.setCodigoBanco(Short.valueOf(registroHelperCodigo0.getCodigoBancoCompensacao().trim()));
		arrecadadorMovimento.setNomeBanco(registroHelperCodigo0.getNomeBanco().trim());

		Date dataGeracao = null;
		if(idTipoMovimento.equals("FICHA DE COMPENSACAO")){

			dataGeracao = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigo0.getDataGeracaoArquivo().trim());
		}else{
			dataGeracao = Util.converteStringSemBarraParaDate(registroHelperCodigo0.getDataGeracaoArquivo().trim());
		}

		arrecadadorMovimento.setDataGeracao(dataGeracao);
		arrecadadorMovimento.setNumeroSequencialArquivo(Integer.valueOf(registroHelperCodigo0.getNumeroSequencialArquivo().trim()));
		arrecadadorMovimento.setNumeroVersaoLayout(Integer.valueOf(registroHelperCodigo0.getNumeroVersaoLayoutArquivo().trim()));

		if(idTipoMovimento.equals("FICHA DE COMPENSACAO")){

			arrecadadorMovimento.setDescricaoIdentificacaoServico("FICHA DE COMPENSACAO");
		}else{

			arrecadadorMovimento.setDescricaoIdentificacaoServico("COBRANCA BANCARIA");
		}

		// Caso o tipo do movimento seja FICHA DE COMPENSAÇÃO, atribuir Campo 9.06
		if(quantidadeItens == null){

			arrecadadorMovimento.setNumeroRegistrosMovimento(Integer.valueOf(registroHelperCodigo9.getQtdeRegistrosArquivo().trim()));
		}else{

			/*
			 * Caso contrário, atribuir quantidade de itens para este movimento (registros tipo 0,
			 * 1, 3, 5, 9)
			 */
			arrecadadorMovimento.setNumeroRegistrosMovimento(quantidadeItens);
		}

		arrecadadorMovimento.setValorTotalMovimento(somatorioValorTITCarteira07);
		arrecadadorMovimento.setUltimaAlteracao(new Date());

		try{

			idMovimento = (Integer) repositorioUtil.inserir(arrecadadorMovimento);
			arrecadadorMovimento.setId(idMovimento);
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema");
		}
		return arrecadadorMovimento;
	}

	/**
	 * [UC0298] Manter Agência bancária [] Atualizar Agência Bancária Metodo que
	 * atualiza a Agência Bancária
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * @throws ControladorException
	 */

	public void atualizarAgenciaBancaria(Agencia agencia) throws ControladorException{

		// Verifica se todos os campos obrigatorios foram preenchidos

		if((agencia.getId() == null || agencia.getId().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (agencia.getCodigoAgencia() == null || agencia.getCodigoAgencia().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (agencia.getNomeAgencia() == null || agencia.getNomeAgencia()
										.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (agencia.getBanco() == null || agencia.getBanco().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (agencia.getNumeroTelefone() == null || agencia.getNumeroTelefone().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Código da Agência foi preenchido

		if(agencia.getCodigoAgencia() == null || agencia.getCodigoAgencia().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Código da Agência");
		}
		// Verifica se o campo Nome da Agência foi preenchido

		if(agencia.getNomeAgencia() == null || agencia.getNomeAgencia().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Nome da Agência");
		}

		// Verifica se o campo Banco foi preenchido
		if(agencia.getBanco() == null || agencia.getBanco().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Banco");
		}

		// Verifica se o campo Telefone foi preenchido
		if(agencia.getNumeroTelefone() == null || agencia.getNumeroTelefone().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Telefone");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroAgencia filtroAgencia = new FiltroAgencia();
		filtroAgencia.adicionarParametro(new ParametroSimples(FiltroAgencia.ID, agencia.getId()));

		Collection colecaoAgenciaBase = getControladorUtil().pesquisar(filtroAgencia, Agencia.class.getName());

		if(colecaoAgenciaBase == null || colecaoAgenciaBase.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		Agencia agenciaBase = (Agencia) colecaoAgenciaBase.iterator().next();

		if(agenciaBase.getUltimaAlteracao().after(agencia.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		agencia.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(agencia);

	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Atualiza o ano/mês de referência da arrecadação.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * @param anoMesArrecadacaoSistemaParametro
	 * @throws ControladorException
	 */
	public void atualizarAnoMesArrecadacao(Integer anoMesArrecadacaoSistemaParametro) throws ControladorException{

		try{
			repositorioArrecadacao.atualizarAnoMesArrecadacao(anoMesArrecadacaoSistemaParametro,
							Util.somarData(anoMesArrecadacaoSistemaParametro));
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC507] Manter Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 08/02/2007
	 * @pparam
	 * @throws ControladorException
	 */
	public void atualizarArrecadador(Arrecadador arrecadador, Usuario usuarioLogado) throws ControladorException{

		arrecadador.setUltimaAlteracao(new Date());

		// [UC0107] - Registrar Transação
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ARRECADADOR_ATUALIZAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ARRECADADOR_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		arrecadador.setOperacaoEfetuada(operacaoEfetuada);

		arrecadador.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(arrecadador);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		// [FS0002] - Atualização realizada por outro usuário
		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
		// Seta o filtro para buscar o arrecadador na base
		filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.ID, arrecadador.getId()));

		// Procura arrecadador na base
		Collection arrecadadorAtualizadas = getControladorUtil().pesquisar(filtroArrecadador, Arrecadador.class.getName());

		Arrecadador arrecadadorNaBase = (Arrecadador) Util.retonarObjetoDeColecao(arrecadadorAtualizadas);

		if(arrecadadorNaBase == null){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.registro_remocao_nao_existente");
		}

		// Verificar se o arrecadador já foi atualizado por outro usuário
		// durante esta atualização

		if(arrecadadorNaBase.getUltimaAlteracao().after(arrecadador.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		arrecadador.setUltimaAlteracao(new Date());

		// Atualiza o objeto na base
		getControladorUtil().atualizar(arrecadador);
	}

	/**
	 * Atualizar Devoluções e Aviso Bancário
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public void atualizarAvisoBancarioDevolucoes(Collection<Integer> idsDevolucoes, Collection<Integer> idsDevolucoesHistorico,
					String devolucaoInformadoDepoisOrigem, String devolucaoCalculadoDepoisOrigem, String devolucaoInformadoDepoisDestino,
					String devolucaoCalculadoDepoisDestino, Integer idAvisoBancarioO, Integer idAvisoBancarioD, Usuario usuarioLogado)
					throws ControladorException{

		try{
			if((idsDevolucoes != null && !idsDevolucoes.isEmpty()) || (idsDevolucoesHistorico != null && !idsDevolucoesHistorico.isEmpty())){
				repositorioArrecadacao.atualizarAvisoBancarioDevolucoes(idsDevolucoes, idsDevolucoesHistorico, idAvisoBancarioD);

				repositorioArrecadacao.atualizarValorDevolucaoAvisoBancario(devolucaoInformadoDepoisOrigem, devolucaoCalculadoDepoisOrigem,
								idAvisoBancarioO);

				repositorioArrecadacao.atualizarValorDevolucaoAvisoBancario(devolucaoInformadoDepoisDestino,
								devolucaoCalculadoDepoisDestino, idAvisoBancarioD);

				FiltroAvisoBancario filtroAvisoBancario = new FiltroAvisoBancario();
				filtroAvisoBancario.adicionarParametro(new ParametroSimples(FiltroAvisoBancario.ID, idAvisoBancarioO));

				AvisoBancario avisoBancario = new AvisoBancario();

				avisoBancario = (AvisoBancario) getControladorUtil().pesquisar(filtroAvisoBancario, AvisoBancario.class.getName())
								.iterator().next();
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
								Operacao.OPERACAO_AVISO_BANCARIO_MOVIMENTAR_PAGAMENTOS_DEVOLUCOES,

								new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				Operacao operacao = new Operacao();
				operacao.setId(Operacao.OPERACAO_AVISO_BANCARIO_MOVIMENTAR_PAGAMENTOS_DEVOLUCOES);

				OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
				operacaoEfetuada.setOperacao(operacao);
				avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
				avisoBancario.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

				registradorOperacao.registrarOperacao(avisoBancario);

				this.getControladorUtil().inserir(avisoBancario);

				// ------------ REGISTRAR TRANSAÇÃO ----------------

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Atualizar Pagamentos e Aviso Bancário
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public void atualizarAvisoBancarioPagamentos(Collection<Integer> idsPagamentos, Collection<Integer> idsPagamentosHistorico,
					String arrecadacaoCalculadoDepoisOrigem, String arrecadacaoCalculadoDepoisDestino, Integer idAvisoBancarioO,
					Integer idAvisoBancarioD, Usuario usuarioLogado) throws ControladorException{

		try{
			if((idsPagamentos != null && !idsPagamentos.isEmpty()) || (idsPagamentosHistorico != null && !idsPagamentosHistorico.isEmpty())){
				if(!Util.isVazioOuBranco(idAvisoBancarioD)){
					repositorioArrecadacao.atualizarAvisoBancarioPagamentos(idsPagamentos, idsPagamentosHistorico, idAvisoBancarioD);
				}

				if(!Util.isVazioOuBranco(arrecadacaoCalculadoDepoisOrigem) && !Util.isVazioOuBranco(idAvisoBancarioO)){
					repositorioArrecadacao.atualizarValorArrecadacaoAvisoBancario(arrecadacaoCalculadoDepoisOrigem, idAvisoBancarioO);
				}

				if(!Util.isVazioOuBranco(arrecadacaoCalculadoDepoisDestino) && !Util.isVazioOuBranco(idAvisoBancarioD)){
					repositorioArrecadacao.atualizarValorArrecadacaoAvisoBancario(arrecadacaoCalculadoDepoisDestino, idAvisoBancarioD);
				}

				FiltroAvisoBancario filtroAvisoBancario = new FiltroAvisoBancario();
				filtroAvisoBancario.adicionarParametro(new ParametroSimples(FiltroAvisoBancario.ID, idAvisoBancarioO));

				AvisoBancario avisoBancario = new AvisoBancario();

				avisoBancario = (AvisoBancario) getControladorUtil().pesquisar(filtroAvisoBancario, AvisoBancario.class.getName())
								.iterator().next();
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
								Operacao.OPERACAO_AVISO_BANCARIO_MOVIMENTAR_PAGAMENTOS_DEVOLUCOES,

								new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				Operacao operacao = new Operacao();
				operacao.setId(Operacao.OPERACAO_AVISO_BANCARIO_MOVIMENTAR_PAGAMENTOS_DEVOLUCOES);

				OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
				operacaoEfetuada.setOperacao(operacao);
				avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
				avisoBancario.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

				registradorOperacao.registrarOperacao(avisoBancario);

				this.getControladorUtil().inserir(avisoBancario);

				// ------------ REGISTRAR TRANSAÇÃO ----------------

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0298] Manter Agência bancária [] Atualizar Agência Bancária Metodo que
	 * atualiza a Agência Bancária
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * @throws ControladorException
	 */

	public void atualizarContaBancaria(ContaBancaria contaBancaria) throws ControladorException{

		// Verifica se todos os campos obrigatorios foram preenchidos

		if((contaBancaria.getId() == null || contaBancaria.getId().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (contaBancaria.getAgencia().getBanco() == null || contaBancaria.getAgencia().getBanco()
										.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (contaBancaria.getAgencia() == null || contaBancaria.getAgencia().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (contaBancaria.getNumeroConta() == null || contaBancaria.getNumeroConta().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Banco foi preenchido

		if(contaBancaria.getAgencia().getBanco() == null
						|| contaBancaria.getAgencia().getBanco().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Banco");
		}
		// Verifica se o campo Agencia foi preenchido

		if(contaBancaria.getAgencia() == null || contaBancaria.getAgencia().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Agência");
		}

		// Verifica se o campo Banco foi preenchido
		if(contaBancaria.getNumeroConta() == null || contaBancaria.getNumeroConta().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Numero da Conta");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroContaBancaria filtroContaBancaria = new FiltroContaBancaria();
		filtroContaBancaria.adicionarParametro(new ParametroSimples(FiltroContaBancaria.ID, contaBancaria.getId()));

		Collection colecaoContaBancariaBase = getControladorUtil().pesquisar(filtroContaBancaria, ContaBancaria.class.getName());

		if(colecaoContaBancariaBase == null || colecaoContaBancariaBase.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		ContaBancaria contaBancariaBase = (ContaBancaria) colecaoContaBancariaBase.iterator().next();

		if(contaBancariaBase.getUltimaAlteracao().after(contaBancaria.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		contaBancaria.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(contaBancaria);

	}

	/**
	 * [UC510] Atualiza Contrato Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 12/04/2007
	 * @pparam
	 * @throws ControladorException
	 */
	public void atualizarContratoArrecadador(ArrecadadorContrato arrecadadorContrato,
					Collection<ArrecadadorContratoTarifa> colecaoArrecadadorContratoTarifa, Usuario usuarioLogado)
					throws ControladorException{

		arrecadadorContrato.setUltimaAlteracao(new Date());

		// [UC0107] - Registrar Transação
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ARRECADADOR_CONTRATO_ATUALIZAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ARRECADADOR_CONTRATO_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		// arrecadadorContrato.setOperacaoEfetuada(operacaoEfetuada);

		// arrecadador.adicionarUsuario(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		// registradorOperacao.registrarOperacao(arrecadador);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		// [FS0002] - Atualização realizada por outro usuário
		FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
		// Seta o filtro para buscar o arrecadador na base
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ID, arrecadadorContrato.getId()));

		// Procura arrecadador na base
		Collection<ArrecadadorContrato> contratoArrecadadorAtualizados = getControladorUtil().pesquisar(filtroArrecadadorContrato,
						ArrecadadorContrato.class.getName());

		ArrecadadorContrato arrecadadorContratoNaBase = (ArrecadadorContrato) Util.retonarObjetoDeColecao(contratoArrecadadorAtualizados);

		if(arrecadadorContratoNaBase == null){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.registro_remocao_nao_existente");
		}

		// Verificar se o arrecadador já foi atualizado por outro usuário
		// durante esta atualização

		if(arrecadadorContratoNaBase.getUltimaAlteracao().after(arrecadadorContrato.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// [FS0008] - Verificar existência do contrato de arrecadador
		if(!arrecadadorContratoNaBase.getNumeroContrato().equals(arrecadadorContrato.getNumeroContrato())){

			filtroArrecadadorContrato.limparListaParametros();

			filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID, arrecadadorContrato
							.getArrecadador().getId()));
			filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.NUMEROCONTRATO, arrecadadorContrato
							.getNumeroContrato()));
			filtroArrecadadorContrato.adicionarCaminhoParaCarregamentoEntidade(FiltroArrecadadorContrato.ARRECADADOR_CLIENTE);

			contratoArrecadadorAtualizados = getControladorUtil().pesquisar(filtroArrecadadorContrato, ArrecadadorContrato.class.getName());

			arrecadadorContratoNaBase = (ArrecadadorContrato) Util.retonarObjetoDeColecao(contratoArrecadadorAtualizados);

			if(arrecadadorContratoNaBase != null){
				throw new ControladorException("atencao.existe_contrato_arrecadador", null, arrecadadorContratoNaBase.getArrecadador()
								.getCliente().getNome());
			}
		}

		// [FS0018] - Verificar existência convênio código de barras
		verificarExistenciaConvenioCodigoBarras(arrecadadorContrato, true);

		// [FS0019] - Verificar existência convênio débito automático
		verificarExistenciaConvenioDebitoAutomatico(arrecadadorContrato, true);

		// [FS0020] - Verificar existência convênio ficha de compensação
		verificarExistenciaConvenioFichaDeCompensacao(arrecadadorContrato, true);

		// [FS0021] - Verificar existência convênio boleto bancário
		verificarExistenciaConvenioBoletoBancario(arrecadadorContrato, true);

		// [FS0022] - Verificar existência convênio parcelamento por responsável
		verificarExistenciaParcelamentoResponsavel(arrecadadorContrato, true);

		arrecadadorContrato.setUltimaAlteracao(new Date());

		// Atualiza o objeto na base
		getControladorUtil().atualizar(arrecadadorContrato);

		FiltroArrecadadorContratoTarifa filtroArrecadadorContratoTarifa = new FiltroArrecadadorContratoTarifa();
		filtroArrecadadorContratoTarifa.adicionarParametro(new ParametroSimples(FiltroArrecadadorContratoTarifa.ID_ARRECADADOR_CONTRATO,
						arrecadadorContrato.getId()));

		Collection colecaoRemocao = getControladorUtil().pesquisar(filtroArrecadadorContratoTarifa,
						ArrecadadorContratoTarifa.class.getName());

		getControladorUtil().removerColecaoObjetos(colecaoRemocao);

		Iterator<ArrecadadorContratoTarifa> it = colecaoArrecadadorContratoTarifa.iterator();

		while(it.hasNext()){
			ArrecadadorContratoTarifa arrecadadorContratoTarifa = it.next();
			getControladorUtil().inserir(arrecadadorContratoTarifa);
		}
	}

	/**
	 * Atualiza logradouroBairro de um ou mais imóveis
	 * [UC0] Atualizar Logradouro
	 * 
	 * @author Raphael Rossiter
	 * @date 22/02/2007
	 * @param
	 * @return void
	 */
	public void atualizarLogradouroBairro(LogradouroBairro logradouroBairroAntigo, LogradouroBairro logradouroBairroNovo)
					throws ControladorException{

		try{

			this.repositorioArrecadacao.atualizarLogradouroBairro(logradouroBairroAntigo, logradouroBairroNovo);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Atualiza logradouroCep de um ou mais imóveis
	 * [UC0] Atualizar Logradouro
	 * 
	 * @author Raphael Rossiter
	 * @date 22/02/2007
	 * @param
	 * @return void
	 */
	public void atualizarLogradouroCep(LogradouroCep logradouroCepAntigo, LogradouroCep logradouroCepNovo) throws ControladorException{

		try{

			this.repositorioArrecadacao.atualizarLogradouroCep(logradouroCepAntigo, logradouroCepNovo);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0739] - Informar Situação de Expurgo do Pagamento
	 * 
	 * @autor Sávio Luiz
	 * @date 02/01/2008
	 */
	public void atualizarSituacaoExpurgoPagamento(Collection colecaoPagamento) throws ControladorException{

		try{
			repositorioArrecadacao.atualizarSituacaoExpurgado(colecaoPagamento);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * O sistema seleciona os itens do movimento do arrecadador com os seguintes
	 * dados: 1 - Código do Registro 2 - Identificação do Imóvel/Cliente 3 -
	 * Ocorrência 4 - Indicador de Aceitação 5 - Descrição do Indicador de
	 * Aceitação
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author Raphael Rossiter
	 * @data 20/03/2006
	 * @param arrecadadorMovimento
	 * @return Collection<ArrecadadorMovimentoItemHelper>
	 */
	public Collection<ArrecadadorMovimentoItemHelper> consultarItensMovimentoArrecadador(ArrecadadorMovimento arrecadadorMovimento,
					Integer idImovel, Short indicadorAceitacao, String descricaoOcorrencia, String codigoArrecadacaoForma)
					throws ControladorException{

		Collection<ArrecadadorMovimentoItemHelper> retorno = new ArrayList();
		Collection<ArrecadadorMovimentoItem> colecaoArrecadadorMovimentoItens = null;
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = null;
		ArrecadadorMovimentoItemHelper arrecadadorMovimentoItemHelper = null;

		/*
		 * Seleciona os itens de um determinado movimento
		 */
		try{

			colecaoArrecadadorMovimentoItens = repositorioArrecadacao.consultarItensMovimentoArrecadador(arrecadadorMovimento, idImovel,
							indicadorAceitacao, descricaoOcorrencia, codigoArrecadacaoForma);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoArrecadadorMovimentoItens != null && !colecaoArrecadadorMovimentoItens.isEmpty()){

			Iterator iteratorColecaoArrecadadorMovimentoItens = colecaoArrecadadorMovimentoItens.iterator();

			BoletoBancarioMovimentacao boletoBancarioMovimentacao = null;

			while(iteratorColecaoArrecadadorMovimentoItens.hasNext()){

				arrecadadorMovimentoItem = (ArrecadadorMovimentoItem) iteratorColecaoArrecadadorMovimentoItens.next();

				arrecadadorMovimentoItemHelper = new ArrecadadorMovimentoItemHelper();

				arrecadadorMovimentoItemHelper.setId(arrecadadorMovimentoItem.getId());

				/*
				 * (RGCD_CDREGISTROCODIGO da tabela REGISTRO_CODIGO com RGCD_ID =
				 * RGCD_ID da tabela ARRECADADOR_MOVIMENTO_ITEM)
				 */
				if(arrecadadorMovimentoItem.getRegistroCodigo() != null){
					arrecadadorMovimentoItemHelper.setCodigoRegistro(arrecadadorMovimentoItem.getRegistroCodigo().getCodigo());
				}

				/*
				 * Caso o código do registro corresponda a "B", "C", "E" ou "F",
				 * exibir a identificação do cliente na empresa retornada pelo
				 * [UC0262]
				 */
				if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
								&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_B)){

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoB registroHelperCodigoB = (RegistroHelperCodigoB) this.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoB.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper.setRegistroHelperCodigoB(registroHelperCodigoB);
				}else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
								&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_C)){

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) this.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoC.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper.setRegistroHelperCodigoC(registroHelperCodigoC);

				}else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
								&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_E)){

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoE registroHelperCodigoE = (RegistroHelperCodigoE) this.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoE.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper.setRegistroHelperCodigoE(registroHelperCodigoE);

				}else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
								&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_F)){

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoF registroHelperCodigoF = (RegistroHelperCodigoF) this.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoF.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper.setRegistroHelperCodigoF(registroHelperCodigoF);

					int tamanho = registroHelperCodigoF.getValorDebito().length();

					String valorDebito = registroHelperCodigoF.getValorDebito().substring(0, (tamanho - 2)) + "."
									+ registroHelperCodigoF.getValorDebito().substring((tamanho - 2), tamanho);

					arrecadadorMovimentoItemHelper.setVlMovimento(Util.formatarMoedaReal(new BigDecimal(valorDebito)));
				}

				/*
				 * Caso o código do registro corresponda a "G"
				 * Distribui os dados do código de barras [UC0264] - Distribuir
				 * Dados co Código de Barras passando o código de barras
				 * retornado pelo [UC0262]- Distribuir Dados do Registro de
				 * Movimento do Arrecadador.
				 * Exibir o tipo de pagamento retornado pelo [UC0262] -
				 * Distribuir Dados co Código de Barras
				 */
				else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
								&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_G)){

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) this.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper.setRegistroHelperCodigoG(registroHelperCodigoG);

					int tamanho = registroHelperCodigoG.getValorRecebido().length();

					String valorRecebido = registroHelperCodigoG.getValorRecebido().substring(0, (tamanho - 2)) + "."
									+ registroHelperCodigoG.getValorRecebido().substring((tamanho - 2), tamanho);

					arrecadadorMovimentoItemHelper.setVlMovimento(Util.formatarMoedaReal(new BigDecimal(valorRecebido)));

					/*
					 * Caso o tipo de pagamento corresponda a: Conta (valor =
					 * 3), Guia de Pagamento (valor = 4) ou Documento de
					 * Cobrança (valor = 5), exibir a matrícula do imóvel
					 * retornada pelo [UC0264]
					 */
					if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
									.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA_LEGADO_CAERN))){

						Integer matriculaImovel = Integer.valueOf(registroHelperCodigoG.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1());

						// Calcular Digito Verificador da Matricula
						if(matriculaImovel != null){
							Short empresa = Short.parseShort(ConstantesAplicacao.get("empresa.ada_codigo_empresa"));
							int digitoModulo11 = Util.obterDigitoVerificadorModulo("" + matriculaImovel, empresa);

							matriculaImovel = Integer.valueOf(matriculaImovel.toString() + digitoModulo11);

						}

						arrecadadorMovimentoItemHelper.setIdentificacao(matriculaImovel.toString());

						arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);

					}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
									.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA))){

						arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoG.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());

						arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);

					}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
									.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO))){

						arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoG.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
						arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_GUIA_PAGAMENTO);
					}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
									.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA))){

						arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoG.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
						arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
					}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
									.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL))){

						arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoG.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
						arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL);
					}

				}else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
								&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_3)){

					String codSegmento = arrecadadorMovimentoItem.getConteudoRegistro().substring(13, 14).trim();
					if(codSegmento.equals("U")){
						RegistroHelperCodigo3U registroHelperCodigo3U = (RegistroHelperCodigo3U) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
										arrecadadorMovimentoItem.getConteudoRegistro().substring(240, 480), null);

						int tamanho = registroHelperCodigo3U.getValorPagoSacado().length();

						String valorRecebido = registroHelperCodigo3U.getValorPagoSacado().substring(0, (tamanho - 2)) + "."
										+ registroHelperCodigo3U.getValorPagoSacado().substring((tamanho - 2), tamanho);

						arrecadadorMovimentoItemHelper.setVlMovimento(Util.formatarMoedaReal(new BigDecimal(valorRecebido)));
					}

					arrecadadorMovimentoItemHelper.setIdentificacao(arrecadadorMovimentoItem.getConteudoRegistro().substring(37, 57));
				}

				// (AMIT_DSOCORRENCIA)
				if(arrecadadorMovimentoItem.getDescricaoOcorrencia() != null){
					arrecadadorMovimentoItemHelper.setOcorrencia(arrecadadorMovimentoItem.getDescricaoOcorrencia());
				}

				if(arrecadadorMovimentoItem.getIndicadorAceitacao() != null
								&& arrecadadorMovimentoItem.getIndicadorAceitacao().equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)){

					arrecadadorMovimentoItemHelper.setIndicadorAceitacao(arrecadadorMovimentoItem.getIndicadorAceitacao());

					// Colocado a pedido de Rosana em 08/04/2006
					if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
									&& !arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_C)){

						arrecadadorMovimentoItemHelper.setDescricaoIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
					}

				}else{

					arrecadadorMovimentoItemHelper.setIndicadorAceitacao(arrecadadorMovimentoItem.getIndicadorAceitacao());

					// Colocado a pedido de Rosana em 08/04/2006
					if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
									&& !arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_C)){

						arrecadadorMovimentoItemHelper
										.setDescricaoIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
					}

				}

				BigDecimal valorPagamento = null;
				try{
					valorPagamento = repositorioArrecadacao
									.recuperaValorPagamentoArrecadadorMovimentoItem(arrecadadorMovimentoItem.getId());
				}catch(ErroRepositorioException e){
					e.printStackTrace();
				}

				arrecadadorMovimentoItemHelper.setVlPagamento(Util.formatarMoedaReal(valorPagamento));

				retorno.add(arrecadadorMovimentoItemHelper);
			}
		}

		if(retorno == null || retorno.isEmpty()){
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return retorno;
	}

	/**
	 * Método responsável por consultar o ultimo cobranca documento
	 * 
	 * @date 02/06/2010
	 * @author isilva
	 * @param idContaHistorico
	 * @return
	 * @throws ControladorException
	 */
	public CobrancaDocumento consultarUltimoCobrancaDocumento(Integer idContaHistorico) throws ControladorException{

		try{
			return this.repositorioArrecadacao.consultarUltimoCobrancaDocumento(idContaHistorico);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema");
		}
	}

	// /**
	// * Método responsável por consultar conta historico
	// * @date 02/06/20010
	// * @author isilva
	// * @param idContaHistorico
	// * @return
	// * @throws ControladorException
	// */
	// public ContaHistorico consultarContaHistorico(Integer idContaHistorico) throws
	// ControladorException {
	// try {
	// return this.repositorioArrecadacao.consultarContaHistorico(idContaHistorico);
	// } catch (ErroRepositorioException e) {
	// throw new ControladorException("erro.sistema");
	// }
	// }

	/**
	 * [UC1016] Estornar Pagamentos
	 * 
	 * @author Saulo Lima
	 * @date 19/08/2009
	 * @param pagamentoHistorico
	 * @param usuarioLogado
	 * @throws ControladorException
	 * @author Andre Nishimura
	 * @date 05/10/2009
	 *       Alteraçao para estornar pagamento de parcelas adiantadas.
	 */
	public void estornarPagamento(PagamentoHistorico pagamentoHistorico, Usuario usuarioLogado) throws ControladorException{

		if(pagamentoHistorico == null){
			throw new ControladorException("atencao.estorno.nao_selecionado");
		}

		try{

			// 3.1.1. [SB0004 – Cancelar crédito associado ao pagamento]
			this.cancelarCreditoAssociadoAoPagamento(pagamentoHistorico, usuarioLogado);

			AvisoBancario avisoBancario = pagamentoHistorico.getAvisoBancario();

			// Cria um objeto Pagamento a partir do Pagamento Histórico
			Pagamento pagamentoInserir = this.criarPagamentoDoPagamentoHistorico(pagamentoHistorico, PagamentoSituacao.VALOR_EM_EXCESSO);

			// Coleção de PagamentosHitorico para remover
			Collection<Object> colecaoPagamentoHistoricoRemover = new ArrayList<Object>();
			colecaoPagamentoHistoricoRemover.add(pagamentoHistorico);

			// Coleção de Pagamentos para inserir
			Collection<Object> colecaoPagamentoInserir = new ArrayList<Object>();
			colecaoPagamentoInserir.add(pagamentoInserir);
			Collection<PagamentoHistorico> colecaoPagamentoHistoricoConsulta = null;

			/*
			 * Registrar Lancamento Contabil
			 * ---------------------------------------
			 */

			if(pagamentoInserir.getConta() != null){
				getControladorContabil().registrarLancamentoContabil(pagamentoHistorico, OperacaoContabil.ESTORNAR_PAGAMENTO);
			}else{
				getControladorContabil().registrarLancamentoContabil(pagamentoHistorico,
								OperacaoContabil.ESTORNAR_PAGAMENTO_NAO_IDENTIFICADO);
			}

			/*
			 * ---------------------------------------
			 */

			// Pagamento de Conta
			if(pagamentoHistorico.getConta() != null){

				Integer idContaGeral = pagamentoHistorico.getConta().getId();

				SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
				if(sistemaParametro == null){
					throw new ControladorException("atencao.pesquisa.sistemaparametro_inexistente");
				}

				Integer anoMesFaturamentoSistemaParametro = sistemaParametro.getAnoMesFaturamento();

				FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
				filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, idContaGeral));
				filtroContaHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
				Collection<ContaHistorico> colecaoContaHistorico = this.getControladorUtil().pesquisar(filtroContaHistorico,
								ContaHistorico.class.getName());

				if(colecaoContaHistorico == null || colecaoContaHistorico.isEmpty()){
					throw new ControladorException("atencao.estorno.conta_historico.nao_localizada");
				}

				FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.CONTA_ID, idContaGeral));
				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("avisoBancario");
				colecaoPagamentoHistoricoConsulta = this.getControladorUtil().pesquisar(filtroPagamentoHistorico,
								PagamentoHistorico.class.getName());

				if(colecaoPagamentoHistoricoConsulta != null && !colecaoPagamentoHistoricoConsulta.isEmpty()){

					// Caso mais de um pagamento tenha sido utilizado pra para o documento, remover
					// do histórico
					for(PagamentoHistorico pagamentoHistoricoTemporario : colecaoPagamentoHistoricoConsulta){
						if(!pagamentoHistoricoTemporario.getId().equals(pagamentoHistorico.getId())){
							Pagamento pagamentoTemporario = this.criarPagamentoDoPagamentoHistorico(pagamentoHistoricoTemporario,
											PagamentoSituacao.VALOR_EM_EXCESSO);
							colecaoPagamentoInserir.add(pagamentoTemporario);
							colecaoPagamentoHistoricoRemover.add(pagamentoHistoricoTemporario);
						}
					}
				}

				// Remove os Pagamentos do Histórico e transfere os documentos referentes
				this.getControladorUtil().removerColecaoObjetos(colecaoPagamentoHistoricoRemover);
				this.getControladorFaturamento().transferirContasHistoricoParaConta(colecaoContaHistorico,
								anoMesFaturamentoSistemaParametro, DebitoCreditoSituacao.NORMAL);

				this.removerImovelCobrancaAdministrivaConta(idContaGeral);

				// Foi removido do caso de uso UC1016 - EstornarPagamentos
				// FiltroConta filtroConta = new FiltroConta();
				// filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID,
				// idContaGeral));
				// Conta conta = (Conta)
				// Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtroConta,
				// Conta.class.getName()));
				// this.getControladorSpcSerasa().verificarHaRelacaoCancelamentoComItensNegativacaoEstornarPagementos(conta);

				// Pagamento de Guia
			}else if(pagamentoHistorico.getGuiaPagamentoGeral() != null){

				Integer idGuiaPagamentoGeral = pagamentoHistorico.getGuiaPagamentoGeral().getId();
				Short numeroPrestacao = null;

				if(pagamentoHistorico.getNumeroPrestacao() == null){
					throw new ControladorException("atencao.estorno.pagamento_sem_numero_prestacao");
				}else{
					numeroPrestacao = Short.valueOf(pagamentoHistorico.getNumeroPrestacao().toString());
				}

				FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.GUIA_PAGAMENTO_GERAL_ID,
								idGuiaPagamentoGeral));
				filtroPagamentoHistorico
								.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.NUMERO_PRESTACAO, numeroPrestacao));
				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("avisoBancario");
				colecaoPagamentoHistoricoConsulta = this.getControladorUtil().pesquisar(filtroPagamentoHistorico,
								PagamentoHistorico.class.getName());

				if(colecaoPagamentoHistoricoConsulta != null && !colecaoPagamentoHistoricoConsulta.isEmpty()){

					// Caso mais de um pagamento tenha sido utilizado pra para o documento, remover
					// do histórico
					for(PagamentoHistorico pagamentoHistoricoTemporario : colecaoPagamentoHistoricoConsulta){
						if(!pagamentoHistoricoTemporario.getId().equals(pagamentoHistorico.getId())){
							Pagamento pagamentoTemporario = this.criarPagamentoDoPagamentoHistorico(pagamentoHistoricoTemporario,
											PagamentoSituacao.VALOR_EM_EXCESSO);
							colecaoPagamentoInserir.add(pagamentoTemporario);
							colecaoPagamentoHistoricoRemover.add(pagamentoHistoricoTemporario);
						}
					}
				}

				// Remove os Pagamentos do Histórico e transfere os documentos referentes
				this.getControladorUtil().removerColecaoObjetos(colecaoPagamentoHistoricoRemover);
				this.transferirGuiaPagamentoPrestacaoHistoricoParaGuiaPagamentoPrestacao(idGuiaPagamentoGeral, numeroPrestacao);

				this.removerImovelCobrancaAdministrivaGuia(idGuiaPagamentoGeral, numeroPrestacao);

				// Pagamento de Débido a Cobrar
			}else if(pagamentoHistorico.getDebitoACobrar() != null){
				/*
				 * Andre Nishimura 05/10/2009 Alteração para estornar pagamento de parcelas
				 * adiantadas
				 * Quando for um adiantamento de parcelas, retorna os pagamentos para o adiantamento
				 * da(s) parcela(s) paga(s)
				 */
				Integer idDebitoACobrarGeral = pagamentoHistorico.getDebitoACobrar().getId();

				FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.DEBITO_A_COBRAR_ID,
								idDebitoACobrarGeral));
				if(pagamentoHistorico.getNumeroPrestacao() != null && pagamentoHistorico.getNumeroPrestacao().intValue() != 0){
					filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.NUMERO_PRESTACAO,
									pagamentoHistorico.getNumeroPrestacao()));
				}else{
					filtroPagamentoHistorico.adicionarParametro(new ParametroNulo(FiltroPagamentoHistorico.NUMERO_PRESTACAO,
									ParametroSimples.CONECTOR_OR));
					filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.NUMERO_PRESTACAO, 0));
				}
				filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("avisoBancario");
				colecaoPagamentoHistoricoConsulta = repositorioArrecadacao.pesquisarPagamentoHistoricoCriteria(filtroPagamentoHistorico);

				if(colecaoPagamentoHistoricoConsulta != null && !colecaoPagamentoHistoricoConsulta.isEmpty()){

					// Caso mais de um pagamento tenha sido utilizado pra para o documento, remover
					// do histórico
					for(PagamentoHistorico pagamentoHistoricoTemporario : colecaoPagamentoHistoricoConsulta){
						if(!pagamentoHistoricoTemporario.getId().equals(pagamentoHistorico.getId())){
							Pagamento pagamentoTemporario = this.criarPagamentoDoPagamentoHistorico(pagamentoHistoricoTemporario,
											PagamentoSituacao.VALOR_EM_EXCESSO);
							colecaoPagamentoInserir.add(pagamentoTemporario);
							colecaoPagamentoHistoricoRemover.add(pagamentoHistoricoTemporario);
						}
					}
				}

				FiltroDebitoACobrarGeral filtroDebitoACobrarGeral = new FiltroDebitoACobrarGeral();
				filtroDebitoACobrarGeral.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarGeral.ID, idDebitoACobrarGeral));
				Collection colecaoDebitoACobrarGeral = this.getControladorUtil().pesquisar(filtroDebitoACobrarGeral,
								DebitoACobrarGeral.class.getName());

				DebitoACobrarGeral debitoACobrarGeral = (DebitoACobrarGeral) Util.retonarObjetoDeColecao(colecaoDebitoACobrarGeral);

				// Remove os Pagamentos do Histórico
				this.getControladorUtil().removerColecaoObjetos(colecaoPagamentoHistoricoRemover);

				boolean estaHistorico = false;
				if(debitoACobrarGeral != null
								&& debitoACobrarGeral.getIndicadorHistorico() == DebitoACobrarGeral.INDICADOR_POSSUI_HISTORICO){
					DebitoACobrarHistorico debitoACobrarHistorico = new DebitoACobrarHistorico();
					debitoACobrarHistorico.setId(idDebitoACobrarGeral);

					estaHistorico = true;

					// Indicador de Parcelamento - indica se deve ser recuperado ou não o id do
					// parcelamento.
					// No caso do estornar Pagamento esse id deve ser restaurado na tabela de débito
					// a cobrar, caso exista
					boolean indicadorParcelamento = true;

					// transfere os documentos referentes
					this.getControladorCobranca().transferirDebitoACobrarHistoricoParaDebitoACobrar(debitoACobrarHistorico,
									indicadorParcelamento);

				}

				if(pagamentoHistorico.getNumeroPrestacao() != null){
					FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
					filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrarGeral));
					Collection colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar,
									DebitoACobrar.class.getName());

					DebitoACobrar debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);

					if(debitoACobrar != null){
						// decrementa as parcelas cobradas
						if(estaHistorico){
							debitoACobrar.setNumeroPrestacaoCobradas(Short.valueOf(String.valueOf(debitoACobrar.getNumeroPrestacaoDebito() - 1)));
						}else{
							debitoACobrar.setNumeroPrestacaoCobradas(Short.valueOf(String.valueOf(debitoACobrar
											.getNumeroPrestacaoCobradas() - 1)));
						}
						debitoACobrar.setUltimaAlteracao(new Date());
						this.getControladorUtil().atualizar(debitoACobrar);
					}
					// remove os todo os registros do debito a cobrar historico do tipo Juros do
					// Parcelamento referente ao debito a cobrar da parcela
					// paga
					FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
					filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.DEBITO_TIPO_ID,
									DebitoTipo.JUROS_SOBRE_PARCELAMENTO));
					filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.ID_ORIGINAL,
									idDebitoACobrarGeral));
					filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.NUMERO_PARCELA,
									pagamentoHistorico.getNumeroPrestacao()));
					Collection colecaoDebitoACobrarhistoricoRemover = this.getControladorUtil().pesquisar(filtroDebitoACobrarHistorico,
									DebitoACobrarHistorico.class.getName());

					if(colecaoDebitoACobrarhistoricoRemover != null && !colecaoDebitoACobrarhistoricoRemover.isEmpty()){
						this.getControladorUtil().removerColecaoObjetos(colecaoDebitoACobrarhistoricoRemover);
					}
				}else{

					FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
					filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrarGeral));
					Collection colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar,
									DebitoACobrar.class.getName());

					DebitoACobrar debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
					// fazer uma consulta no repositório que conte quantidade de pagamentos
					// históricos que tenham dbac-id = idDebitoACobrarGeral
					// e numero de prestacoes diferene de null e diferente de zero retorne para
					// quantidadeParcelasAntecipadas

					Integer quantidadeParcelasAntecipadas = repositorioArrecadacao
									.consultarQtdePagamentoHistoricoParaDebitoACobrarParcelamentoComPrestacaoNula(debitoACobrarGeral
													.getId());

					if(debitoACobrar != null){

						debitoACobrar.setNumeroPrestacaoCobradas(Short.valueOf(String.valueOf(quantidadeParcelasAntecipadas)));

						debitoACobrar.setUltimaAlteracao(new Date());
						this.getControladorUtil().atualizar(debitoACobrar);
					}

				}
			}else{

				if(colecaoPagamentoHistoricoRemover != null && !colecaoPagamentoHistoricoRemover.isEmpty()){
					this.getControladorUtil().removerColecaoObjetos(colecaoPagamentoHistoricoRemover);
				}

			}

			// ------------ REGISTRAR TRANSAÇÃO ------------
			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_ESTORNAR_PAGAMENTO);

			RegistradorOperacao registradorOperacao = new RegistradorOperacao(operacao.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			for(Object pagamentoObject : colecaoPagamentoInserir){
				Pagamento pagamento = (Pagamento) pagamentoObject;
				pagamento.setOperacaoEfetuada(operacaoEfetuada);
				pagamento.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(pagamento);
			}
			// ------------ REGISTRAR TRANSAÇÃO ------------

			this.getControladorUtil().inserirColecaoObjetos(colecaoPagamentoInserir);

			// Atualiza os valores do aviso bancário
			avisoBancario = (AvisoBancario) getControladorUtil().pesquisar(avisoBancario.getId(), AvisoBancario.class, false);
			this.atualizarValoresAvisoBancario(avisoBancario, false);

		}catch(ControladorException e1){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e1);
		}catch(Exception e2){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e2);
		}
	}

	/**
	 * [UC1016] Estornar Pagamentos
	 * 
	 * @author Saulo Lima
	 * @date 20/08/2009
	 * @param pagamentoHistorico
	 * @return Pagamento
	 * @throws ControladorException
	 */
	public Pagamento criarPagamentoDoPagamentoHistorico(PagamentoHistorico pagamentoHistorico, Integer pagamentoSituacaoId)
					throws ControladorException{

		Pagamento pagamentoTemp = null;

		try{

			pagamentoTemp = new Pagamento();
			pagamentoTemp.setAnoMesReferenciaArrecadacao(pagamentoHistorico.getAnoMesReferenciaArrecadacao());
			pagamentoTemp.setAnoMesReferenciaPagamento(pagamentoHistorico.getAnoMesReferenciaPagamento());
			pagamentoTemp.setArrecadacaoForma(pagamentoHistorico.getArrecadacaoForma());
			pagamentoTemp.setArrecadadorMovimentoItem(pagamentoHistorico.getArrecadadorMovimentoItem());
			pagamentoTemp.setAvisoBancario(pagamentoHistorico.getAvisoBancario());
			pagamentoTemp.setCliente(pagamentoHistorico.getCliente());
			pagamentoTemp.setNumeroPrestacao(pagamentoHistorico.getNumeroPrestacao());
			pagamentoTemp.setPagamentoSituacaoAnterior(pagamentoHistorico.getPagamentoSituacaoAtual());
			pagamentoTemp.setIndicadorExpurgado(pagamentoHistorico.getIndicadorExpurgado());

			PagamentoSituacao pagamentoSituacao = new PagamentoSituacao();
			pagamentoSituacao.setId(pagamentoSituacaoId);
			pagamentoTemp.setPagamentoSituacaoAtual(pagamentoSituacao);
			pagamentoTemp.setPagamentoSituacaoAnterior(pagamentoHistorico.getPagamentoSituacaoAtual());

			if(pagamentoHistorico.getConta() != null && pagamentoHistorico.getConta().getId() != null){
				Conta conta = new Conta();
				conta.setId(pagamentoHistorico.getConta().getId());
				pagamentoTemp.setConta(conta);
			}

			pagamentoTemp.setDataPagamento(pagamentoHistorico.getDataPagamento());
			pagamentoTemp.setDebitoACobrar(pagamentoHistorico.getDebitoACobrar());
			pagamentoTemp.setDebitoTipo(pagamentoHistorico.getDebitoTipo());
			pagamentoTemp.setDocumentoTipo(pagamentoHistorico.getDocumentoTipo());
			pagamentoTemp.setGuiaPagamentoGeral(pagamentoHistorico.getGuiaPagamentoGeral());
			pagamentoTemp.setImovel(pagamentoHistorico.getImovel());
			pagamentoTemp.setLocalidade(pagamentoHistorico.getLocalidade());
			pagamentoTemp.setUltimaAlteracao(new Date());
			pagamentoTemp.setValorPagamento(pagamentoHistorico.getValorPagamento());
			pagamentoTemp.setValorExcedente(pagamentoHistorico.getValorExcedente());

		}catch(Exception ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return pagamentoTemp;
	}

	/**
	 * Pesquisar devoluções pelo aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 11/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public PagamentosDevolucoesHelper filtrarDevolucoes(FiltroDevolucao filtroDevolucao, FiltroDevolucaoHistorico filtroDevolucaoHistorico)
					throws ControladorException{

		PagamentosDevolucoesHelper devolucoes = null;

		try{

			devolucoes = repositorioArrecadacao.filtrarDevolucoes(filtroDevolucao, filtroDevolucaoHistorico);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		return devolucoes;
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores - Relatório
	 * 
	 * @author Ana Maria
	 * @date 13/07/07
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> filtrarIdsMovimentoArrecadador(String codigoBanco, String codigoRemessa,
					String descricaoIdentificacaoServico, String idImovel, String numeroSequencialArquivo, Date dataGeracaoInicio,
					Date dataGeracaoFim, Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia,
					String indicadorAceitacao, String idConcessionaria) throws ControladorException{

		Collection<Integer> retorno = new ArrayList<Integer>();

		try{

			retorno = repositorioArrecadacao.filtrarIdsMovimentoArrecadador(codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
							idImovel, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim, ultimaAlteracaoInicio,
							ultimaAlteracaoFim, descricaoOcorrencia, indicadorAceitacao, idConcessionaria);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarMovimentoArrecadadorParaRelatorio(String codigoBanco, String codigoRemessa,
					String descricaoIdentificacaoServico, String numeroSequencialArquivo, Date dataGeracaoInicio, Date dataGeracaoFim,
					Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia, String indicadorAceitacao,
					String indicadorAbertoFechado, String idConcessionaria) throws ControladorException{

		Collection<ArrecadadorMovimento> retorno = new ArrayList<ArrecadadorMovimento>();
		Collection colecaoMovimentoArrecadadores = null;

		try{

			colecaoMovimentoArrecadadores = repositorioArrecadacao.filtrarMovimentoArrecadadorParaRelatorio(codigoBanco, codigoRemessa,
							descricaoIdentificacaoServico, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
							ultimaAlteracaoInicio, ultimaAlteracaoFim, descricaoOcorrencia, indicadorAceitacao, indicadorAbertoFechado,
							idConcessionaria);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		Iterator iteratorMovimentoArrecadadoresTotal = colecaoMovimentoArrecadadores.iterator();

		while(iteratorMovimentoArrecadadoresTotal.hasNext()){

			ArrecadadorMovimento arrecadadorMovimentoRetorno = new ArrecadadorMovimento();
			Object[] arrecadadorMovimento = (Object[]) iteratorMovimentoArrecadadoresTotal.next();

			if(arrecadadorMovimento[0] != null){// 0
				// codigo do banco
				arrecadadorMovimentoRetorno.setCodigoBanco(Short.valueOf(arrecadadorMovimento[0].toString()));
			}

			if(arrecadadorMovimento[1] != null){// 1
				// codigo remessa
				arrecadadorMovimentoRetorno.setCodigoRemessa(Short.valueOf(arrecadadorMovimento[1].toString()));
			}

			if(arrecadadorMovimento[2] != null){// 2
				// descrição indentificação do serviço
				arrecadadorMovimentoRetorno.setDescricaoIdentificacaoServico(arrecadadorMovimento[2].toString());
			}

			if(arrecadadorMovimento[3] != null){// 3
				// nsa
				arrecadadorMovimentoRetorno.setNumeroSequencialArquivo(Integer.valueOf(arrecadadorMovimento[3].toString()));
			}

			if(arrecadadorMovimento[4] != null){// 4
				// id de arrecadadorMovimento
				arrecadadorMovimentoRetorno.setId(Integer.valueOf(arrecadadorMovimento[4].toString()));
			}

			if(arrecadadorMovimento[5] != null){// 5
				// data de geração
				arrecadadorMovimentoRetorno.setDataGeracao((Date) arrecadadorMovimento[5]);
			}

			if(arrecadadorMovimento[6] != null){// 6
				// numero Registros Movimento
				arrecadadorMovimentoRetorno.setNumeroRegistrosMovimento(Integer.valueOf(arrecadadorMovimento[6].toString()));
			}

			if(arrecadadorMovimento[7] != null){// 7
				// valor Total do Movimento
				arrecadadorMovimentoRetorno.setValorTotalMovimento(new BigDecimal(arrecadadorMovimento[7].toString()));
			}

			if(arrecadadorMovimento[8] != null){// 8
				// ultima alteração
				arrecadadorMovimentoRetorno.setUltimaAlteracao((Date) arrecadadorMovimento[8]);
			}

			if(arrecadadorMovimento[9] != null){// 9
				// nome do Banco
				arrecadadorMovimentoRetorno.setNomeBanco(arrecadadorMovimento[9].toString());
			}

			retorno.add(arrecadadorMovimentoRetorno);
		}

		if(retorno == null || retorno.isEmpty()){
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return retorno;

	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 04/01/07
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @throws ControladorException
	 */
	public Integer filtrarMovimentoArrecadadoresRelatorioCount(String codigoBanco, String codigoRemessa,
					String descricaoIdentificacaoServico, String numeroSequencialArquivo, Date dataGeracaoInicio, Date dataGeracaoFim,
					Date ultimaAlteracaoInicio, Date ultimaAlteracaoFim, String descricaoOcorrencia, String indicadorAceitacao,
					String indicadorAbertoFechado, String idConcessionaria) throws ControladorException{

		try{
			return repositorioArrecadacao.filtrarMovimentoArrecadadoresRelatorioCount(codigoBanco, codigoRemessa,
							descricaoIdentificacaoServico, numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
							ultimaAlteracaoInicio, ultimaAlteracaoFim, descricaoOcorrencia, indicadorAceitacao, indicadorAbertoFechado,
							idConcessionaria);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Pesquisar pagamentos pelo aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 11/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public PagamentosDevolucoesHelper filtrarPagamentos(FiltroPagamento filtroPagamento, FiltroPagamentoHistorico filtroPagamentoHistorico)
					throws ControladorException{

		PagamentosDevolucoesHelper pagamentos = null;

		try{

			pagamentos = repositorioArrecadacao.filtrarPagamentos(filtroPagamento, filtroPagamentoHistorico);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		return pagamentos;
	}

	/**
	 * [UC0739] - Informar Situação de Expurgo do Pagamento
	 * Autor: Sávio Luiz
	 * Data: 02/01/2008
	 */
	public Object[] gerarColecaoDadosPagamentoPelaData(String dataPagamento, Integer idCliente) throws ControladorException{

		Collection dadosPagamento = null;

		// cria um object com 2 coleções, uma com o indicador de expurgado com 1
		// e outra com o indicador de expurgado 2
		Object[] colecaoDadosPagamento = new Object[2];

		try{
			dadosPagamento = repositorioArrecadacao.pesquisarDadosPagamentoExpurgado(dataPagamento, idCliente);

			Collection dadosPagamentoHistorico = repositorioArrecadacao.pesquisarDadosPagamentoHistoricoExpurgado(dataPagamento, idCliente);

			if(dadosPagamentoHistorico != null && !dadosPagamentoHistorico.isEmpty()){
				dadosPagamento.addAll(dadosPagamentoHistorico);
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		Collection colecaoExpurgado = new ArrayList();

		Collection colecaoNaoExpurgado = new ArrayList();

		if(dadosPagamento != null && !dadosPagamento.isEmpty()){
			Iterator ite = dadosPagamento.iterator();
			while(ite.hasNext()){
				Object[] dadoPagamento = (Object[]) ite.next();

				Pagamento pagamento = new Pagamento();
				pagamento.setId((Integer) dadoPagamento[0]);

				if(dadoPagamento[1] != null){
					pagamento.setValorPagamento((BigDecimal) dadoPagamento[1]);
				}

				if(dadoPagamento[2] != null){
					pagamento.setIndicadorExpurgado((Short) dadoPagamento[2]);
					if(((Short) dadoPagamento[2]).equals(Pagamento.INDICADOR_EXPURGADO_SIM)){
						colecaoExpurgado.add(pagamento);
					}else{
						colecaoNaoExpurgado.add(pagamento);
					}
				}

			}
		}else{
			throw new ControladorException("atencao.existencia.pagamento.data_cliente");
		}

		colecaoDadosPagamento[0] = colecaoExpurgado;
		colecaoDadosPagamento[1] = colecaoNaoExpurgado;

		return colecaoDadosPagamento;
	}

	/**
	 * [UC0619] Gerar Relação de Acompanhamento dos Movimentos Arrecadadores por
	 * NSA
	 * 
	 * @author Ana Maria
	 * @date 12/07/2007
	 * @param idMovimentoArrecadador
	 * @return
	 */
	public Collection<MovimentoArrecadadoresPorNSAHelper> gerarMovimentoArrecadadoresNSA(Collection<Integer> idsArrecadadorMovimento,
					Integer codigoFormaArrecadacao, String idConcessionaria) throws ControladorException{

		Collection<MovimentoArrecadadoresPorNSAHelper> colecaoMovimentoArrecadadoresPorNSAHelper = null;

		try{
			colecaoMovimentoArrecadadoresPorNSAHelper = repositorioArrecadacao.gerarMovimentoArrecadadoresNSA(idsArrecadadorMovimento,
							codigoFormaArrecadacao, idConcessionaria);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return colecaoMovimentoArrecadadoresPorNSAHelper;
	}

	/**
	 * Relatório para acompanhar o movimento dos arrecadadores
	 * 
	 * @author Sávio Luiz
	 * @date 02/04/2007
	 * @param idDebitoACobrar
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public void gerarResumoAcompanhamentoMovimentoArrecadadores(Usuario usuario, String mesAnoReferencia, Arrecadador arrecadador,
					ArrecadacaoForma arrecadacaoForma, Concessionaria concessionaria) throws ControladorException{

		EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(
						EnvioEmail.GERAR_RELATORIO_ACOMPANHAMENTO_MOVIMENTO_ARRECADADORES);
		// Parte que gera o relatório e envia por email
		// cria uma instância da classe do relatório
		RelatorioAcompanhamentoMovimentoArrecadadores relatorioAcompanhamentoMovimentoArrecadadores = new RelatorioAcompanhamentoMovimentoArrecadadores(
						usuario);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro("mesAnoReferencia", mesAnoReferencia);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro("arrecadador", arrecadador);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro("arrecadacaoForma", arrecadacaoForma);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro("concessionaria", concessionaria);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
		byte[] relatorioGerado = (byte[]) relatorioAcompanhamentoMovimentoArrecadadores.executar();

		String emailRemetente = envioEmail.getEmailRemetente();

		String tituloMensagem = envioEmail.getTituloMensagem();

		String corpoMensagem = envioEmail.getCorpoMensagem();
		String emailReceptor = envioEmail.getEmailReceptor();

		try{
			File leitura = new File("gcom.PDF");
			FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
			out.write(relatorioGerado);
			out.flush();
			out.close();

			ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

			// leitura.delete();
		}catch(IOException e){
			throw new ControladorException("erro.sistema", e);
		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Permite inserir uma Agência Bancaria
	 * [UC0217] Inserir Agência Bancaria
	 * 
	 * @author Thiago Tenório
	 * @date 30/03/2006
	 */
	public Integer inserirAgenciaBancaria(Agencia agencia) throws ControladorException{

		FiltroAgencia filtroAgencia = new FiltroAgencia();

		filtroAgencia.adicionarParametro(new ParametroSimples(FiltroAgencia.BANCO_ID, agencia.getBanco().getId()));

		filtroAgencia.adicionarParametro(new ParametroSimples(FiltroAgencia.CODIGO_AGENCIA, agencia.getCodigoAgencia()));

		filtroAgencia.adicionarParametro(new ParametroSimples(FiltroAgencia.NOME_AGENCIA, agencia.getNomeAgencia()));

		Collection colecaoEnderecos = getControladorUtil().pesquisar(filtroAgencia, Agencia.class.getName());

		if(colecaoEnderecos != null && !colecaoEnderecos.isEmpty()){
			throw new ControladorException("atencao.endereco_localidade_nao_informado");
		}

		Integer id = (Integer) getControladorUtil().inserir(agencia);

		return id;

	}

	/**
	 * [UC0506] Inserir Arrecadador
	 * Inclusão de um novo arrecadador.
	 * 
	 * @author Marcio Roberto
	 * @date 29/01/2007
	 * @param String
	 *            idAgente, String idCliente, String inscricaoEstadual, String
	 *            idImovel, Usuario usuarioLogado
	 * @throws ControladorException
	 */
	public Integer inserirArrecadador(String idAgente, String idCliente, String inscricaoEstadual, String idImovel, Usuario usuarioLogado,
					Short indicadorCaixaEmpresa) throws ControladorException{

		Arrecadador arrecadador = new Arrecadador();

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ARRECADADOR_INSERIR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ARRECADADOR_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		arrecadador.setOperacaoEfetuada(operacaoEfetuada);
		arrecadador.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(arrecadador);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		// preenche objeto arrecadador
		// seta o atributo de Agente no objeto arrecadador
		arrecadador.setCodigoAgente(Short.valueOf(idAgente));

		// seta o atributo de Cliente no objeto arrecadador
		Cliente cliente = new Cliente();
		cliente.setId(Integer.valueOf(idCliente));
		arrecadador.setCliente(cliente);

		// Crio um objeto imovel para setar o id e preencher o atributo imovel
		// de arrecadador.
		if(idImovel != null && !idImovel.equals("")){
			Imovel imovel = new Imovel();
			imovel.setId(Integer.valueOf(idImovel));
			arrecadador.setImovel(imovel);
		}

		// seta o atributo de Inscrição Estadual no objeto arrecadador
		arrecadador.setNumeroInscricaoEstadual(inscricaoEstadual);

		arrecadador.setIndicadorUso((short) 1);

		arrecadador.setIndicadorCaixaEmpresa(indicadorCaixaEmpresa);

		arrecadador.setUltimaAlteracao(new Date());

		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
		filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.CODIGO_AGENTE, idAgente));

		Collection colecaoArrecadador = getControladorUtil().pesquisar(filtroArrecadador, Arrecadador.class.getName());

		Integer idArrecadador = null;
		if(colecaoArrecadador.isEmpty()){
			// Inserir na base de dados Arrecadador
			idArrecadador = (Integer) getControladorUtil().inserir(arrecadador);
		}else{
			throw new ControladorException("atencao.arrecadador_existente");
		}
		return idArrecadador;
	}

	/**
	 * Permite inserir uma Conta Bancaria
	 * [UC0217] Inserir Conta Bancaria
	 * 
	 * @author Thiago Tenório
	 * @date 30/03/2006
	 */
	public Integer inserirContaBancaria(ContaBancaria contaBancaria) throws ControladorException{

		FiltroContaBancaria filtroContaBancaria = new FiltroContaBancaria();

		filtroContaBancaria.adicionarParametro(new ParametroSimples(FiltroContaBancaria.AGENCIA_BANCO_ID, contaBancaria.getAgencia()
						.getBanco().getId()));

		filtroContaBancaria.adicionarParametro(new ParametroSimples(FiltroContaBancaria.AGENCIA_ID, contaBancaria.getAgencia().getId()));

		filtroContaBancaria.adicionarParametro(new ParametroSimples(FiltroContaBancaria.NUMERO_CONTA, contaBancaria.getNumeroConta()));

		filtroContaBancaria.adicionarCaminhoParaCarregamentoEntidade("agencia.banco");
		// filtroContaBancaria
		// .adicionarCaminhoParaCarregamentoEntidade("agencia");
		//
		Collection colecaoContaBancaria = getControladorUtil().pesquisar(filtroContaBancaria, ContaBancaria.class.getName());

		if(colecaoContaBancaria != null && !colecaoContaBancaria.isEmpty()){
			throw new ControladorException("atencao.conta_bancaria.existente");
		}

		Integer id = (Integer) getControladorUtil().inserir(contaBancaria);

		return id;

	}

	/**
	 * [UC0509] Inserir Contrato Arrecadador
	 * Inclusão de um novo Contrato de arrecadador.
	 * 
	 * @author Marcio Roberto
	 * @date 22/03/2007
	 * @param
	 * @throws ControladorException
	 */
	public Integer inserirContratoArrecadador(ArrecadadorContrato contrato,
					Collection<ArrecadadorContratoTarifa> colecaoArrecadadorContratoTarifa, Usuario usuarioLogado)
					throws ControladorException{

		// // ------------ REGISTRAR TRANSAÇÃO ----------------------------
		// RegistradorOperacao registradorOperacao = new RegistradorOperacao(
		// Operacao.OPERACAO_ARRECADADOR_CONTRATO_INSERIR,
		// new UsuarioAcaoUsuarioHelper(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		//
		// Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_ARRECADADOR_CONTRATO_INSERIR);
		//
		// OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		// operacaoEfetuada.setOperacao(operacao);

		// arrecadador.setOperacaoEfetuada(operacaoEfetuada);
		// arrecadador.adicionarUsuario(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		// registradorOperacao.registrarOperacao(arrecadador);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		contrato.setUltimaAlteracao(new Date());

		FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
		filtroArrecadadorContrato.adicionarCaminhoParaCarregamentoEntidade(FiltroArrecadadorContrato.ARRECADADOR_CLIENTE);
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID, contrato
						.getArrecadador().getId()));
		filtroArrecadadorContrato.adicionarParametro(new ParametroNulo(FiltroArrecadadorContrato.DATA_CONTRATO_ENCERRAMENTO));
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ID_CONCESSIONARIA, contrato
						.getConcessionaria().getId()));
		Collection colecaoArrecadadorContrato = getControladorUtil().pesquisar(filtroArrecadadorContrato,
						ArrecadadorContrato.class.getName());

		Integer idContrato = null;

		if(Util.isNaoNuloBrancoZero(colecaoArrecadadorContrato)){
			ArrecadadorContrato ac = (ArrecadadorContrato) colecaoArrecadadorContrato.iterator().next();
			throw new ControladorException("atencao.contrato_arrecadador_existencia_contrato_vigente", null, ac.getArrecadador()
							.getCliente().getNome());
		}

		filtroArrecadadorContrato = new FiltroArrecadadorContrato();
		filtroArrecadadorContrato.adicionarCaminhoParaCarregamentoEntidade(FiltroArrecadadorContrato.ARRECADADOR_CLIENTE);
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID, contrato
						.getArrecadador().getId()));
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.NUMEROCONTRATO, contrato
						.getNumeroContrato()));

		colecaoArrecadadorContrato = getControladorUtil().pesquisar(filtroArrecadadorContrato, ArrecadadorContrato.class.getName());

		if(Util.isNaoNuloBrancoZero(colecaoArrecadadorContrato)){
			ArrecadadorContrato ac = (ArrecadadorContrato) colecaoArrecadadorContrato.iterator().next();
			throw new ControladorException("atencao.contrato_arrecadador_existencia_contrato_numero", null, ac.getArrecadador()
							.getCliente().getNome());
		}

		// [FS0013] - Verificar existência convênio código de barras
		verificarExistenciaConvenioCodigoBarras(contrato, false);

		// [FS0014] - Verificar existência convênio débito automático
		verificarExistenciaConvenioDebitoAutomatico(contrato, false);

		// [FS0015] - Verificar existência convênio ficha de compensação
		verificarExistenciaConvenioFichaDeCompensacao(contrato, false);

		// [FS0016] - Verificar existência convênio boleto bancário
		verificarExistenciaConvenioBoletoBancario(contrato, false);

		// [FS0017] - Verificar existência convênio parcelamento por responsável
		verificarExistenciaParcelamentoResponsavel(contrato, false);

		if(Util.isVazioOrNulo(colecaoArrecadadorContrato)){
			// Inserir na base de dados Arrecadador
			idContrato = (Integer) getControladorUtil().inserir(contrato);
		}

		contrato.setId(idContrato);

		Iterator<ArrecadadorContratoTarifa> it = colecaoArrecadadorContratoTarifa.iterator();

		while(it.hasNext()){
			ArrecadadorContratoTarifa arrecadadorContratoTarifa = it.next();
			arrecadadorContratoTarifa.setArrecadadorContrato(contrato);
			arrecadadorContratoTarifa.getComp_id().setArrecadadorContratoId(contrato.getId());
			getControladorUtil().inserir(arrecadadorContratoTarifa);
		}

		return idContrato;
	}

	/**
	 * [FS0013] - Verificar existência convênio código de barras
	 * [FS0018] - Verificar existência convênio código de barras
	 * 
	 * @param contrato
	 * @throws ControladorException
	 */
	private void verificarExistenciaConvenioCodigoBarras(ArrecadadorContrato contrato, boolean isAlteracao) throws ControladorException{

		verificarExistenciaUnicoArrecadadorContrato(contrato, FiltroArrecadadorContrato.CODIGO_CONVENIO, contrato.getCodigoConvenio(),
						"atencao.contrato_arrecadador_convenio_codigo_de_barras", isAlteracao);

	}

	/**
	 * [FS0014] - Verificar existência convênio débito automático
	 * [FS0019] - Verificar existência convênio débito automático
	 * 
	 * @param contrato
	 * @throws ControladorException
	 */
	private void verificarExistenciaConvenioDebitoAutomatico(ArrecadadorContrato contrato, boolean isAlteracao) throws ControladorException{

		verificarExistenciaUnicoArrecadadorContrato(contrato, FiltroArrecadadorContrato.CODIGO_CONVENIO_DEBITO_AUTOMATICO,
						contrato.getCodigoConvenioDebitoAutomatico(), "atencao.contrato_arrecadador_convenio_debito_automatico",
						isAlteracao);
	}

	/**
	 * [FS0015] - Verificar existência convênio ficha de compensação
	 * [FS0020] - Verificar existência convênio ficha de compensação
	 * 
	 * @param contrato
	 * @throws ControladorException
	 */
	private void verificarExistenciaConvenioFichaDeCompensacao(ArrecadadorContrato contrato, boolean isAlteracao)
					throws ControladorException{

		verificarExistenciaUnicoArrecadadorContrato(contrato, FiltroArrecadadorContrato.CODIGO_CONVENIO_FICHA_COMPENSACAO,
						contrato.getCodigoConvenioFichaCompensacao(), "atencao.contrato_arrecadador_convenio_ficha_compensacao",
						isAlteracao);
	}

	/**
	 * [FS0016] - Verificar existência convênio boleto bancário
	 * [FS0021] - Verificar existência convênio boleto bancário
	 * 
	 * @param contrato
	 * @throws ControladorException
	 */
	private void verificarExistenciaConvenioBoletoBancario(ArrecadadorContrato contrato, boolean isAlteracao) throws ControladorException{

		verificarExistenciaUnicoArrecadadorContrato(contrato, FiltroArrecadadorContrato.CODIGO_CONVENIO_BOLETO_BANCARIO,
						contrato.getCodigoConvenioBoletoBancario(), "atencao.contrato_arrecadador_convenio_boleto_bancario", isAlteracao);
	}

	/**
	 * [FS0017] - Verificar existência convênio parcelamento por responsável
	 * [FS0022] - Verificar existência convênio parcelamento por responsável
	 * 
	 * @param contrato
	 * @throws ControladorException
	 */
	private void verificarExistenciaParcelamentoResponsavel(ArrecadadorContrato contrato, boolean isAlteracao) throws ControladorException{

		verificarExistenciaUnicoArrecadadorContrato(contrato, FiltroArrecadadorContrato.CODIGO_CONVENIO_PARCELAMENTO_RESP,
						contrato.getCodigoConvenioParcelamentoResposavel(), "atencao.contrato_arrecadador_convenio_parcelamento_resp",
						isAlteracao);
	}

	private void verificarExistenciaUnicoArrecadadorContrato(ArrecadadorContrato contrato, String parametroConsulta, String valorConsulta,
					String mensagemErro, boolean isAlteracao) throws ControladorException{

		Collection<ArrecadadorContrato> colecaoArrecadadorContrato = null;
		try{
			if(Util.isNaoNuloBrancoZero(valorConsulta)){
				colecaoArrecadadorContrato = repositorioArrecadacao.consultarArrecadadorContratoGenerico(contrato, parametroConsulta,
								valorConsulta, isAlteracao);
			}
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		if(Util.isNaoNuloBrancoZero(colecaoArrecadadorContrato)){
			throw new ControladorException(mensagemErro);
		}
	}

	/**
	 * Inserir devoluções para os pagamentos efetuados a partir do código de
	 * barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/10/2007
	 * @return
	 * @throws ControladorException
	 */
	public void inserirDevolucoes(Collection<Devolucao> colecaoDevolucoes, Usuario usuarioLogado, AvisoBancario avisoBancario)
					throws ControladorException{

		try{
			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_DEVOLUCOES_INSERIR,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_DEVOLUCOES_INSERIR);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			// Cria a variável que vai acumular os valores de devoluções informadas
			BigDecimal valorDevolucaoAcumulado = BigDecimal.ZERO;

			if(colecaoDevolucoes != null && !colecaoDevolucoes.isEmpty()){
				for(Devolucao devolucao : colecaoDevolucoes){
					// Acumula o valor da devolução
					valorDevolucaoAcumulado = valorDevolucaoAcumulado.add(devolucao.getValorDevolucao());

					devolucao.setAvisoBancario(avisoBancario);
					devolucao.setUltimaAlteracao(new Date());

					// ------------ REGISTRAR TRANSAÇÃO ----------------
					devolucao.setOperacaoEfetuada(operacaoEfetuada);
					devolucao.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					registradorOperacao.registrarOperacao(devolucao);
					// ------------ REGISTRAR TRANSAÇÃO ----------------

					// INSERINDO DEVOLUCAO
					this.getControladorUtil().inserir(devolucao);
				}
			}

			// Atualiza o valor de devolução do aviso bancário
			avisoBancario.setValorDevolucaoCalculado(avisoBancario.getValorDevolucaoCalculado().add(valorDevolucaoAcumulado));
			avisoBancario.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
			avisoBancario.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(avisoBancario);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			this.getControladorUtil().atualizar(avisoBancario);
		}catch(ControladorException e1){
			sessionContext.setRollbackOnly();
			throw e1;
		}catch(Exception e2){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e2);
		}

	}

	/**
	 * Inserir uma coleção de pagamentos informados manualmente
	 * 
	 * @author Raphael Rossiter
	 * @date 26/09/2007
	 * @author Vitor Hora, Saulo Lima
	 * @date 08/10/2008, 26/11/2008
	 *       Chamada ao classificarPagamentos
	 * @param Collection
	 *            <Pagamento>
	 * @param Usuario
	 * @param AvisoBancario
	 * @return Integer
	 *         Id do último pagamento inserido
	 * @throws ControladorException
	 */
	public Integer inserirPagamentos(Collection<Pagamento> colecaoPagamento, Usuario usuarioLogado, AvisoBancario avisoBancario,
					Integer idTipoOperacao, boolean usuarioConfirmou) throws ControladorException, InserirPagamentoException{

		Integer retorno = null;

		// Collection<Integer> colecaoIdsLocalidades = new ArrayList<Integer>();

		try{

			if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){

				// ------------ REGISTRAR TRANSAÇÃO ----------------
				RegistradorOperacao registradorOperacao = new RegistradorOperacao(idTipoOperacao, new UsuarioAcaoUsuarioHelper(
								usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				RegistradorOperacao.set(registradorOperacao);

				// ------------ REGISTRAR TRANSAÇÃO ----------------

				// Cria a variável que vai acumular os valores de pagamentos informados
				BigDecimal valorPagamentoAcumulado = BigDecimal.ZERO;
				// Collection colecaoPagamentosClassificados = new ArrayList();
				// Collection retornoClassificacao;

				// atualiza aviso bancario
				for(Pagamento pagamento : colecaoPagamento){
					// Acumula o valor do pagamento
					valorPagamentoAcumulado = valorPagamentoAcumulado.add(pagamento.getValorPagamento());
				}
				avisoBancario.setValorArrecadacaoCalculado(avisoBancario.getValorArrecadacaoCalculado().add(valorPagamentoAcumulado));
				BigDecimal valorNaoClassificado = avisoBancario.getValorPagamentoNaoClassificado();
				valorNaoClassificado = (valorNaoClassificado == null) ? BigDecimal.ZERO : valorNaoClassificado;
				avisoBancario.setValorPagamentoNaoClassificado(valorNaoClassificado.add(valorPagamentoAcumulado));

				avisoBancario.setUltimaAlteracao(new Date());
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				avisoBancario.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(avisoBancario);
				// ------------ REGISTRAR TRANSAÇÃO ----------------

				this.getControladorUtil().atualizar(avisoBancario);

				Pagamento pagamentoNaoClassificado = null;
				Short parametroExibirConfirmacaoInclusaoPagamentoNaoClassificado = Util
								.obterShort(ParametroArrecadacao.P_EXIBIR_CONFIRM_INCLUSAO_PAG_NAO_CLASSIFICADO.executar());

				// Laço para incluir todos os pagamentos informados
				for(Pagamento pagamento : colecaoPagamento){

					// Adiciona os as localidades na lista para classificação.
					// colecaoIdsLocalidades.add(pagamento.getLocalidade().getId());

					pagamento.setAvisoBancario(avisoBancario);
					pagamento.setUltimaAlteracao(new Date());

					// ------------ REGISTRAR TRANSAÇÃO ----------------
					pagamento.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					registradorOperacao.registrarOperacao(pagamento);
					// ------------ REGISTRAR TRANSAÇÃO ----------------

					// Chama o metódo de inserir
					retorno = (Integer) this.getControladorUtil().inserir(pagamento);

					// [UC0300] Classificar a medida que for inserindo o pagamento.

					// ** Alteração do Classificar **
					// retornoClassificacao = this.classificarPagamentos(pagamento);
					// colecaoPagamentosClassificados.addAll(retornoClassificacao);

					this.classificarPagamentosRegistroMovimentoArrecadadores(pagamento);

					// Atualizar intes negativação
					// [UC0937 - Obter Itens de Negativação Associados à Conta]
					// [SB0006 - Atualizar Item da Negativação]
					if(pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)
									|| pagamento.getDocumentoTipo().getId().equals(DocumentoTipo.FATURA_CLIENTE)){
						getControladorSpcSerasa().atualizarItemDaNegativacao(pagamento.getAnoMesReferenciaPagamento(),
										pagamento.getImovel(), CobrancaDebitoSituacao.PAGO, pagamento.getDataPagamento(),
										pagamento.getValorPagamento(), Boolean.FALSE, ConstantesSistema.SIM);
					}

					AvisoBancario avisoBancarioAux = pagamento.getAvisoBancario();

					if(avisoBancarioAux != null){
						this.atualizarValoresAvisoBancario(avisoBancarioAux, false);
					}

					pagamentoNaoClassificado = repositorioArrecadacao.pesquisarPagamentoComSituacaoAtual(retorno);

					if(!usuarioConfirmou && pagamentoNaoClassificado != null
									&& parametroExibirConfirmacaoInclusaoPagamentoNaoClassificado.equals(ConstantesSistema.SIM)){

						String descricaoSituacaoAtualPagamento = pagamentoNaoClassificado.getPagamentoSituacaoAtual().getId().toString()
										+ "-" + pagamentoNaoClassificado.getPagamentoSituacaoAtual().getDescricao();
						String valorPagamentoInserido = Util.formatarMoedaReal(pagamentoNaoClassificado.getValorPagamento(), 2);
						throw new InserirPagamentoException("atencao.pagamento_nao_classificado", null,
										new String[] {descricaoSituacaoAtualPagamento}, descricaoSituacaoAtualPagamento,
										valorPagamentoInserido);
					}

					OperacaoContabilHelper helper = this.definirOrigemOperacaoContabilPagamento(pagamento, false);
					getControladorContabil().registrarLancamentoContabil(helper.getObjetoOrigem(), helper.getOperacaoContabil());
					// ** Alteração do Classificar **
				}

				// ** Alteração no Classificar **
				// for(Object pagamento : colecaoPagamentosClassificados){
				// if(((Pagamento)
				// pagamento).getAvisoBancario().getId().equals(avisoBancario.getId())){
				// ((Pagamento) pagamento).setAvisoBancario(avisoBancario);
				// }
				// }
				// this.atualizarPagamentosClassificadosNoAvisoBancario(colecaoPagamentosClassificados);
				//
				// this.atualizarValorRealizadoNoAvisoBancario(avisoBancario);
				//
				// for(Object objeto : colecaoPagamentosClassificados){
				// Pagamento pagamento = (Pagamento) objeto;
				// OrigemPagamentoOperacaoContabilHelper helper =
				// this.definirOrigemOperacaoContabilPagamento(pagamento, false);
				// getControladorContabil().registrarLancamentoContabil(helper.getObjetoOrigem(),
				// helper.getOperacaoContabil());
				// }
				// ** Alteração no Classificar **
			}else{
				throw new ControladorException("atencao.documento_naoinformado");
			}

		}catch(ControladorException e1){
			sessionContext.setRollbackOnly();
			throw e1;
		}catch(Exception e2){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e2);
		}

		return retorno;
	}

	public OperacaoContabilHelper definirOrigemOperacaoContabilPagamento(Pagamento pagamento, Boolean ehClassificadoAnterior)
					throws ControladorException{

		OperacaoContabilHelper retorno = new OperacaoContabilHelper();

		try{

			Collection<Pagamento> pagamentoBanco = new ArrayList<Pagamento>();
			Collection<PagamentoHistorico> pagamentoHistoricoBanco = new ArrayList<PagamentoHistorico>();

			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, pagamento.getId()));
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.PAGAMENTO_SITUACAO_ATUAL);
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.PAGAMENTO_SITUACAO_ANTERIOR);
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.LOCALIDADE);
			pagamentoBanco = repositorioUtil.pesquisar(filtroPagamento, Pagamento.class.getName());

			FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
			filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.ID, pagamento.getId()));
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.PAGAMENTO_SITUACAO_ATUAL);
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.PAGAMENTO_SITUACAO_ANTERIOR);
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.LOCALIDADE);
			pagamentoHistoricoBanco = repositorioUtil.pesquisar(filtroPagamentoHistorico, PagamentoHistorico.class.getName());

			if(!pagamentoBanco.isEmpty()){

				Pagamento pgtBanco = pagamentoBanco.iterator().next();

				retorno.setObjetoOrigem(pgtBanco);

				// TODO Rever: pgtBanco.getPagamentoSituacaoAtual() != null
				if(pgtBanco.getPagamentoSituacaoAtual() != null
								&& pgtBanco.getPagamentoSituacaoAtual().getId().intValue() == PagamentoSituacao.PAGAMENTO_CLASSIFICADO
								&& !ehClassificadoAnterior){

					retorno.setOperacaoContabil(OperacaoContabil.INCLUIR_PAGAMENTO);

				}else if(pgtBanco.getPagamentoSituacaoAtual() != null
								&& pgtBanco.getPagamentoSituacaoAtual().getId().intValue() == PagamentoSituacao.PAGAMENTO_CLASSIFICADO
								&& ehClassificadoAnterior){

					retorno.setOperacaoContabil(OperacaoContabil.INCLUIR_PAGAMENTO_POSTERIOR);

					// }else if(!ehClassificadoAnterior
					// && (pgtBanco.getPagamentoSituacaoAtual().getId().intValue() ==
					// PagamentoSituacao.PAGAMENTO_A_MAIOR
					// || pgtBanco.getPagamentoSituacaoAtual().getId().intValue() ==
					// PagamentoSituacao.PAGAMENTO_A_MENOR || pgtBanco
					// .getPagamentoSituacaoAtual().getId().intValue() ==
					// PagamentoSituacao.PAGAMENTO_DUPLICADO)){
					//
					// retorno.setOperacaoContabil(OperacaoContabil.INCLUIR_PAGAMENTO_NAO_IDENTIFICADO);
				}else{
					retorno.setOperacaoContabil(OperacaoContabil.INCLUIR_PAGAMENTO_NAO_IDENTIFICADO);
				}

			}

			if(!pagamentoHistoricoBanco.isEmpty()){

				PagamentoHistorico pgtBanco = pagamentoHistoricoBanco.iterator().next();

				retorno.setObjetoOrigem(pgtBanco);

				if(pgtBanco.getPagamentoSituacaoAtual().getId().intValue() == PagamentoSituacao.PAGAMENTO_CLASSIFICADO
								&& !ehClassificadoAnterior){

					retorno.setOperacaoContabil(OperacaoContabil.INCLUIR_PAGAMENTO);

				}else if(pgtBanco.getPagamentoSituacaoAtual().getId().intValue() == PagamentoSituacao.PAGAMENTO_CLASSIFICADO
								&& ehClassificadoAnterior){

					retorno.setOperacaoContabil(OperacaoContabil.INCLUIR_PAGAMENTO_POSTERIOR);

					// }else if(!ehClassificadoAnterior
					// && (pgtBanco.getPagamentoSituacaoAtual().getId().intValue() ==
					// PagamentoSituacao.PAGAMENTO_A_MAIOR
					// || pgtBanco.getPagamentoSituacaoAtual().getId().intValue() ==
					// PagamentoSituacao.PAGAMENTO_A_MENOR || pgtBanco
					// .getPagamentoSituacaoAtual().getId().intValue() ==
					// PagamentoSituacao.PAGAMENTO_DUPLICADO)){
					//
					// retorno.setOperacaoContabil(OperacaoContabil.INCLUIR_PAGAMENTO_NAO_IDENTIFICADO);
				}else{
					retorno.setOperacaoContabil(OperacaoContabil.INCLUIR_PAGAMENTO_NAO_IDENTIFICADO);
				}

			}

		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * Inserir Pagamentos por código de barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/10/2007
	 * @return
	 * @throws ControladorException
	 */
	public Integer inserirPagamentosCodigoBarras(Collection<Pagamento> colecaoPagamentos, Collection<Devolucao> colecaoDevolucoes,
					Usuario usuarioLogado, AvisoBancario avisoBancario, boolean usuarioConfirmou) throws ControladorException,
					InserirPagamentoException{

		// INSERINDO PAGAMENTOS
		Integer retorno = this.inserirPagamentos(colecaoPagamentos, usuarioLogado, avisoBancario,
						Operacao.OPERACAO_PAGAMENTO_INSERIR_CODIGOBARRAS, usuarioConfirmou);

		// INSERINDO DEVOLUCOES
		this.inserirDevolucoes(colecaoDevolucoes, usuarioLogado, avisoBancario);

		
		
		return retorno;
	}

	/**
	 * Obtém a representação númerica do código de barras da Ficha de Compensação
	 * [UC0716] Obter Representação Numérica do Código de Barras da Ficha de Compensação
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2007
	 * @param codigoBanco
	 * @param codigoMoeda
	 * @param valorCodigoBarra
	 * @param nossoNumero
	 * @param carteira
	 * @param fatorVencimento
	 * @return
	 * @throws ParametroNaoInformadoException
	 */
	public String obterEspecificacaoCodigoBarraFichaCompensacao(String codigoBanco, String codigoMoeda, BigDecimal valorCodigoBarra,
					String nossoNumeroSemDV, String carteira, String fatorVencimento) throws ControladorException{

		// Cria a variável que vai armazenar a representação númerica do código de barras
		String representacaoNumericaCodigoBarra = "";

		// G.05.1 - Código do Banco
		codigoBanco = Util.adicionarZerosEsquedaNumero(3, codigoBanco);
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + codigoBanco;

		// G.05.2 - Código da Moeda
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + codigoMoeda;

		// G.05.4 - Fator de Vencimento
		fatorVencimento = Util.adicionarZerosEsquedaNumero(4, fatorVencimento);
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + fatorVencimento;

		// G.05.5 - Valor do código de barras
		String valorCodigoBarraFormatado = Util.adicionarZerosEsquedaNumero(10, valorCodigoBarra.toString().replace(".", ""));
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + valorCodigoBarraFormatado;

		// G.05.6 - Zeros
		String zeros = "";
		zeros = Util.adicionarZerosEsquedaNumero(6, zeros);
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + zeros;

		// G.05.7 Nosso número sem o DV
		nossoNumeroSemDV = Util.adicionarZerosEsquedaNumero(17, nossoNumeroSemDV);
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + nossoNumeroSemDV;

		// G.05.8 Tipo de Carteira
		carteira = Util.adicionarZerosEsquedaNumero(2, carteira);
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + carteira;

		// G.05.3 - Dígito verificador geral
		// [SB0001] Obter Dígito verificador geral
		String digitoVerificadorGeral = (Util.obterDigitoVerificadorModulo11(representacaoNumericaCodigoBarra)).toString();
		// (Util.obterDigitoVerificadorGeral(representacaoNumericaCodigoBarra)).toString();

		if(digitoVerificadorGeral.equalsIgnoreCase("0") || digitoVerificadorGeral.equalsIgnoreCase("10")
						|| digitoVerificadorGeral.equalsIgnoreCase("11")){
			digitoVerificadorGeral = "1";
		}
		System.out.println("----- DIGITO VERIFICADOR : " + digitoVerificadorGeral);

		// Monta a representaçaõ númerica com todos os campos informados
		representacaoNumericaCodigoBarra = codigoBanco + codigoMoeda + digitoVerificadorGeral + fatorVencimento + valorCodigoBarraFormatado
						+ zeros + nossoNumeroSemDV + carteira;

		// Retorna a representação númerica do código de barras
		return representacaoNumericaCodigoBarra;
	}

	/**
	 * Obtém a representação númerica do código de barras da Ficha de Compensação
	 * [UC0716] Obter Representação Numérica do Código de Barras da Ficha de Compensação
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2007
	 * @param codigoBanco
	 * @param codigoMoeda
	 * @param valorCodigoBarra
	 * @param nossoNumero
	 * @param carteira
	 * @param fatorVencimento
	 * @return
	 * @throws ParametroNaoInformadoException
	 */
	public String obterRepresentacaoNumericaCodigoBarraFichaCompensacao(String especificacaoCodigoBarra) throws ControladorException{

		String representacaoNumericaCodigoBarra = especificacaoCodigoBarra;
		System.out.println("especificacaoCodigoBarra " + especificacaoCodigoBarra);
		// Cria as variáveis que vão armazenar o código de barra separado por
		// campos e seus respectivos dígitos verificadores se existirem
		String codigoBarraCampo1 = null;
		String codigoBarraDigitoVerificadorCampo1 = null;
		String codigoBarraCampo2 = null;
		String codigoBarraDigitoVerificadorCampo2 = null;
		String codigoBarraCampo3 = null;
		String codigoBarraDigitoVerificadorCampo3 = null;
		String codigoBarraDigitoVerificadorCampo4 = null;
		String codigoBarraCampo5 = null;

		// Separa as 44 posições do código de barras em 5 partes,
		// sendo 3 primeiros constituidos por DV(módulo 10) e, entre cada campo,
		// espaço equivalente a uma posição.No quarto campo é indicado, isoladamente,
		// o DV(módulo 11) do código de barras.
		codigoBarraCampo1 = representacaoNumericaCodigoBarra.substring(0, 4) + representacaoNumericaCodigoBarra.substring(20, 21);
		codigoBarraCampo1 = codigoBarraCampo1 + "." + representacaoNumericaCodigoBarra.substring(21, 25);
		codigoBarraDigitoVerificadorCampo1 = (Util.obterDigitoVerificadorModulo10(Long.valueOf(codigoBarraCampo1.replace(".", ""))))
						.toString();
		codigoBarraDigitoVerificadorCampo1 = codigoBarraDigitoVerificadorCampo1 + " ";

		codigoBarraCampo2 = representacaoNumericaCodigoBarra.substring(24, 29);
		codigoBarraCampo2 = codigoBarraCampo2 + "." + representacaoNumericaCodigoBarra.substring(29, 34);
		codigoBarraDigitoVerificadorCampo2 = codigoBarraDigitoVerificadorCampo2 + " ";

		codigoBarraCampo3 = representacaoNumericaCodigoBarra.substring(34, 39);
		codigoBarraCampo3 = codigoBarraCampo3 + "." + representacaoNumericaCodigoBarra.substring(39, 44);
		codigoBarraDigitoVerificadorCampo3 = (Util.obterDigitoVerificadorModulo10(Long.valueOf(codigoBarraCampo3.replace(".", ""))))
						.toString();
		codigoBarraDigitoVerificadorCampo3 = codigoBarraDigitoVerificadorCampo3 + " ";

		codigoBarraDigitoVerificadorCampo4 = representacaoNumericaCodigoBarra.substring(4, 5) + " ";

		codigoBarraCampo5 = representacaoNumericaCodigoBarra.substring(5, 19);

		// Monta a representação númerica do código de barras com os dígitos verificadores
		representacaoNumericaCodigoBarra = codigoBarraCampo1 + codigoBarraDigitoVerificadorCampo1 + codigoBarraCampo2
						+ codigoBarraDigitoVerificadorCampo2 + codigoBarraCampo3 + codigoBarraDigitoVerificadorCampo3
						+ codigoBarraDigitoVerificadorCampo4 + codigoBarraCampo5;

		// Retorna a representação númerica do código de barras
		return representacaoNumericaCodigoBarra;
	}

	/**
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * @return Collection<AcertosAvisoBancarioHelper>
	 * @throws ControladorException
	 */
	public Collection<AcertosAvisoBancarioHelper> pesquisarAcertosAvisoBancario(Integer idAvisoBancario,
					Integer indicadorArrecadacaoDevolucao) throws ControladorException{

		try{
			Collection colecaoDadosAcertosAvisoBancario = this.repositorioArrecadacao.pesquisarAcertosAvisoBancario(idAvisoBancario,
							indicadorArrecadacaoDevolucao);

			Collection<AcertosAvisoBancarioHelper> colecaoAcertosAvisoBancarioHelper = new ArrayList();
			Iterator colecaoDadosAcertosAvisoBancarioIterator = colecaoDadosAcertosAvisoBancario.iterator();
			while(colecaoDadosAcertosAvisoBancarioIterator.hasNext()){

				AcertosAvisoBancarioHelper AcertosAvisoBancarioHelper = new AcertosAvisoBancarioHelper();

				Object[] dadosArray = (Object[]) colecaoDadosAcertosAvisoBancarioIterator.next();

				// id do Banco
				if(dadosArray[0] != null){
					AcertosAvisoBancarioHelper.setIdbanco("" + dadosArray[0]);
				}
				// código da Agência
				if(dadosArray[1] != null){
					AcertosAvisoBancarioHelper.setCodigoAgencia("" + dadosArray[1]);
				}
				// numero da Conta
				if(dadosArray[2] != null){
					AcertosAvisoBancarioHelper.setNumeroConta((String) dadosArray[2]);
				}
				// indicadorCreditoDebito
				if(dadosArray[3] != null){
					Integer indicadorCreditoDebito = (Integer) dadosArray[3];

					if(indicadorCreditoDebito.equals(AvisoBancario.INDICADOR_CREDITO.intValue())){
						AcertosAvisoBancarioHelper.setIndicadorCreditoDebito(AvisoBancario.CREDITO);
					}else{
						AcertosAvisoBancarioHelper.setIndicadorCreditoDebito(AvisoBancario.DEBITO);
					}
				}
				// data do Acerto
				if(dadosArray[4] != null){
					AcertosAvisoBancarioHelper.setDataAcerto(Util.formatarData((Date) dadosArray[4]));
				}
				// valor do Acerto
				if(dadosArray[5] != null){
					AcertosAvisoBancarioHelper.setValorAcerto(Util.formatarMoedaReal((BigDecimal) dadosArray[5]));
				}

				colecaoAcertosAvisoBancarioHelper.add(AcertosAvisoBancarioHelper);
			}

			return colecaoAcertosAvisoBancarioHelper;

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa o endereço de correspondência do cliente pelo seu id fazendo os
	 * carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return ClienteEndereco
	 * @throws ControladorException
	 */
	public ClienteEndereco pesquisarClienteEnderecoPagamento(Integer idCliente) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarClienteEnderecoPagamento(idCliente);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa o telefone padrão do cliente pelo seu id fazendo os
	 * carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return ClienteFone
	 * @throws ControladorException
	 */
	public ClienteFone pesquisarClienteFonePagamento(Integer idCliente) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarClienteFonePagamento(idCliente);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa o cliente pelo id fazendo os carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return Cliente
	 * @throws ErroRepositorioException
	 */
	public Cliente pesquisarClientePagamento(Integer idCliente) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarClientePagamento(idCliente);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa os clientes do imóvel pelo seu id do imóvel fazendo os
	 * carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return Collection<ClienteImovel>
	 * @throws ControladorException
	 */
	public Collection<ClienteImovel> pesquisarClientesImoveisPagamento(Integer idImovel) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarClientesImoveisPagamento(idImovel);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Processamento Rápido
	 * 
	 * @author Raphael Rossiter
	 * @date 17/08/2007
	 * @return Collection<Conta>
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContaComPagamentoHistorico() throws ControladorException{

		try{

			return repositorioArrecadacao.pesquisarContaComPagamentoHistorico();

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * @return Collection<DeducoesHelper>
	 * @throws ControladorException
	 */
	public Collection<DeducoesHelper> pesquisarDeducoesAvisoBancario(Integer idAvisoBancario) throws ControladorException{

		try{
			Collection colecaoDadosDeducoes = this.repositorioArrecadacao.pesquisarDeducoesAvisoBancario(idAvisoBancario);

			Collection<DeducoesHelper> colecaoDeducoesHelper = new ArrayList();
			Iterator colecaoDadosDeducoesIterator = colecaoDadosDeducoes.iterator();
			while(colecaoDadosDeducoesIterator.hasNext()){

				DeducoesHelper deducoesHelper = new DeducoesHelper();

				// Obtém os dados do crédito realizado
				Object[] dadosArray = (Object[]) colecaoDadosDeducoesIterator.next();

				// Tipo
				if(dadosArray[0] != null){
					deducoesHelper.setTipo((String) dadosArray[0]);
				}

				// Valor Dedução
				if(dadosArray[1] != null){
					deducoesHelper.setValorDeducao(Util.formatarMoedaReal((BigDecimal) dadosArray[1]));
				}

				colecaoDeducoesHelper.add(deducoesHelper);
			}

			return colecaoDeducoesHelper;

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @author Ana Maria
	 * @date 29/01/2007
	 * @param idGuiaPagamento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarGuiaPagemento(Integer idGuiaPagamento) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarGuiaPagamento(idGuiaPagamento);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Recupera o ID da ContaGeral do pagamento especificado
	 * 
	 * @author Saulo Lima
	 * @date 23/01/2009
	 * @param idPagamento
	 * @return idContaGeral
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdDaContaGeralNoPagamento(Integer idPagamento) throws ControladorException{

		Integer idContaGeral = null;

		try{
			idContaGeral = repositorioArrecadacao.pesquisarIdDaContaGeralNoPagamento(idPagamento);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
		}

		return idContaGeral;
	}

	/**
	 * @author Sávio Luiz
	 * @data 28/04/2007
	 * @param idConta
	 * @return idParcelamento
	 */
	public Integer pesquisarIdPagamentoDaGuia(Integer idGuiaPagamento) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarIdPagamentoDaGuia(idGuiaPagamento);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @author Sávio Luiz
	 * @data 28/04/2007
	 * @param idConta
	 * @return idParcelamento
	 */
	public Integer pesquisarIdPagamentoDoDebitoACobrar(Integer idDebitoACobrar) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarIdPagamentoDoDebitoACobrar(idDebitoACobrar);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Retorna uma coleção de ids de categoria
	 * 
	 * @author Pedro Alexandre
	 * @date 13/06/2007
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Integer> pesquisarIdsCategoria() throws ControladorException{

		try{
			return this.repositorioArrecadacao.pesquisarIdsCategorias();

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método reponsável por remover a coleção de ClienteGuiaPagamentoHistorico e inserir os
	 * ClienteGuiaPagamento referentes
	 * [UC0213] Desfazer Parcelamento de Débitos
	 * 
	 * @author Saulo Lima
	 * @date 13/07/2009
	 * @param guiaPagamentoHistoricoId
	 * @throws ControladorException
	 */
	protected void enviarClienteGuiaPagamentoHistoricoParaClienteGuiaPagamento(Integer guiaPagamentoHistoricoId)
					throws ControladorException{

		Collection colecaoClienteGuiaPagamentoInserir = new ArrayList<ClienteGuiaPagamento>();
		Collection colecaoClienteGuiaPagamentoHistoricoRemover = new ArrayList<ClienteGuiaPagamentoHistorico>();

		try{
			Collection<ClienteGuiaPagamentoHistorico> colecaoClienteGuiaPagamentoHistorico = repositorioArrecadacao
							.pesquisarClienteGuiaPagamentoHistorico(guiaPagamentoHistoricoId);

			ClienteGuiaPagamento clienteGuiaPagamentoTemp = null;

			if(colecaoClienteGuiaPagamentoHistorico != null && !colecaoClienteGuiaPagamentoHistorico.isEmpty()){

				colecaoClienteGuiaPagamentoHistoricoRemover.addAll(colecaoClienteGuiaPagamentoHistorico);

				for(ClienteGuiaPagamentoHistorico clienteGuiaPagamentoHistorico : colecaoClienteGuiaPagamentoHistorico){
					clienteGuiaPagamentoTemp = new ClienteGuiaPagamento();
					clienteGuiaPagamentoTemp.setId(clienteGuiaPagamentoHistorico.getId());
					clienteGuiaPagamentoTemp.setCliente(clienteGuiaPagamentoHistorico.getCliente());
					clienteGuiaPagamentoTemp.setClienteRelacaoTipo(clienteGuiaPagamentoHistorico.getClienteRelacaoTipo());
					GuiaPagamento guiaPagamento = new GuiaPagamento();
					guiaPagamento.setId(guiaPagamentoHistoricoId);
					clienteGuiaPagamentoTemp.setGuiaPagamento(guiaPagamento);
					clienteGuiaPagamentoTemp.setUltimaAlteracao(new Date());

					colecaoClienteGuiaPagamentoInserir.add(clienteGuiaPagamentoTemp);
				}

				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoClienteGuiaPagamentoInserir);
				this.getControladorBatch().removerColecaoObjetoParaBatch(colecaoClienteGuiaPagamentoHistoricoRemover);

				colecaoClienteGuiaPagamentoInserir = null;
				colecaoClienteGuiaPagamentoHistoricoRemover = null;
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public Collection<Integer> pesquisarIdsSetoresComPagamentosOuDevolucoes() throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarIdsSetoresComPagamentosOuDevolucoes();
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Pesquisa o imóvel pelo id fazendo os carregamentos necessários
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * @return Imovel
	 * @throws ControladorException
	 */
	public Imovel pesquisarImovelPagamento(Integer idImovel) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarImovelPagamento(idImovel);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa os movimentos dos arrecadores para a geração do relatório
	 * [UCXXXX] Acompanhar Movimento dos Arrecadadores
	 * 
	 * @author Rafael Corrêa
	 * @date 02/04/2007
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarMovimentoArrecadadoresRelatorio(Integer mesAnoReferencia, Integer idArrecadador, Integer idFormaArrecadacao,
					Date dataPagamentoInicial, Date dataPagamentoFinal, Integer idConcessionaria) throws ControladorException{

		Collection colecaoMovimentoArrecadadoresHelper = new ArrayList();
		Collection colecaoDadosMovimentoArrecadador = null;

		try{
			colecaoDadosMovimentoArrecadador = repositorioArrecadacao.pesquisarMovimentoArrecadadoresRelatorio(mesAnoReferencia,
							idArrecadador, idFormaArrecadacao, dataPagamentoInicial, dataPagamentoFinal, idConcessionaria);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
		}

		if(colecaoDadosMovimentoArrecadador != null && !colecaoDadosMovimentoArrecadador.isEmpty()){

			Iterator colecaoDadosMovimentoArrecadadorIterator = colecaoDadosMovimentoArrecadador.iterator();

			while(colecaoDadosMovimentoArrecadadorIterator.hasNext()){

				Object[] dadosMoviemntoArrecador = (Object[]) colecaoDadosMovimentoArrecadadorIterator.next();

				MovimentoArrecadadoresRelatorioHelper movimentoArrecadadoresRelatorioHelper = new MovimentoArrecadadoresRelatorioHelper();

				if(dadosMoviemntoArrecador[0] != null){
					movimentoArrecadadoresRelatorioHelper.setAnoMesReferencia((Integer) dadosMoviemntoArrecador[0]);
				}

				if(dadosMoviemntoArrecador[1] != null){
					movimentoArrecadadoresRelatorioHelper.setArrecadador((String) dadosMoviemntoArrecador[1]);
				}

				if(dadosMoviemntoArrecador[2] != null){
					movimentoArrecadadoresRelatorioHelper.setDescricaoArrecadacaoForma((String) dadosMoviemntoArrecador[2]);
				}

				if(dadosMoviemntoArrecador[3] != null){
					movimentoArrecadadoresRelatorioHelper.setDataPagamento((Date) dadosMoviemntoArrecador[3]);
				}

				if(dadosMoviemntoArrecador[4] != null){
					movimentoArrecadadoresRelatorioHelper.setValorPagamento((BigDecimal) dadosMoviemntoArrecador[4]);
				}

				if(dadosMoviemntoArrecador[5] != null){
					movimentoArrecadadoresRelatorioHelper.setQtdeDocumentos((Integer) dadosMoviemntoArrecador[5]);
				}

				if(dadosMoviemntoArrecador[6] != null){
					movimentoArrecadadoresRelatorioHelper.setQtdePagamentos((Integer) dadosMoviemntoArrecador[6]);
				}
				
				if(idConcessionaria != null){
					if(dadosMoviemntoArrecador[7] != null){
						movimentoArrecadadoresRelatorioHelper.setConcessionaria((String) dadosMoviemntoArrecador[7]);
					}
				}

				colecaoMovimentoArrecadadoresHelper.add(movimentoArrecadadoresRelatorioHelper);

			}

		}

		return colecaoMovimentoArrecadadoresHelper;

	}

	/**
	 * [UC0150] Retificar Conta
	 * 
	 * @author Vivianne Sousa
	 * @data 23/04/2006
	 * @param idConta
	 * @return idParcelamento
	 */
	public Pagamento pesquisarPagamentoDeConta(Integer idConta) throws ControladorException{

		Pagamento pagamento = null;
		Object[] pagamentoDaConta = null;

		try{

			pagamentoDaConta = repositorioArrecadacao.pesquisarPagamentoDeConta(idConta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(pagamentoDaConta != null && !(pagamentoDaConta.length < 0)){

			pagamento = new Pagamento();

			// Seta o id do pagamento
			if(pagamentoDaConta[0] != null){
				pagamento.setId((Integer) pagamentoDaConta[0]);
			}
			// Seta o valor do pagamento
			if(pagamentoDaConta[1] != null){
				pagamento.setValorPagamento((BigDecimal) pagamentoDaConta[1]);
			}
		}

		return pagamento;
	}

	/**
	 * [UC0626] Gerar Resumo de Metas Acumulado no Mês (CAERN)
	 * 
	 * @author Sávio Luiz
	 * @data 28/11/2007
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarPagamentoDeContas(Collection colecaoConta) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoDeContas(colecaoConta);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Saulo Lima
	 * @date 25/08/2009
	 * @return Collection<PagamentoHistorico>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoMovimentoArrecadadorParaPaginacao(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoHistoricoMovimentoArrecadadorParaPaginacao(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina,
							codigoSetorComercialInicial, codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores,
							idsCategoria);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * [UC0255] Filtrar Pagamentos
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 21/12/06
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadadorParaPaginacao(String idImovel, String idCliente,
					String idTipoRelacao, String localidadeInicial, String localidadeFinal, String idAvisoBancario, String idArrecadador,
					String periodoArrecadacaoInicial, String periodoArrecadacaoFinal, String periodoPagamentoInicio,
					String periodoPagamentoFim, Date dataPagamentoInicial, Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
					String[] idsDebitosTipos, String[] idsArrecadacaoForma, String[] idsDocumentosTipos, Integer numeroPagina,
					String codigoSetorComercialInicial, String codigoSetorComercialFinal, String indicadorTotalizarPorDataPagamento,
					Collection<Integer> idsArrecadadores, String[] idsCategoria) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoMovimentoArrecadadorParaPaginacao(idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal, idAvisoBancario, idArrecadador, periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, periodoPagamentoInicio, periodoPagamentoFim, dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos, idsArrecadacaoForma, idsDocumentosTipos, numeroPagina,
							codigoSetorComercialInicial, codigoSetorComercialFinal, indicadorTotalizarPorDataPagamento, idsArrecadadores,
							idsCategoria);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 20/03/2007
	 * @param idDebitoACobrar
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadePagamentosPorDebitoACobrar(Integer idDebitoACobrar) throws ControladorException{

		try{

			return this.repositorioArrecadacao.pesquisarQuantidadePagamentosPorDebitoACobrar(idDebitoACobrar);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisar valores de arrecadação e devolução do aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 14/06/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public ValoresArrecadacaoDevolucaoAvisoBancarioHelper pesquisarValoresAvisoBancario(Integer idAvisoBancario)
					throws ControladorException{

		ValoresArrecadacaoDevolucaoAvisoBancarioHelper helper = null;

		try{

			helper = repositorioArrecadacao.pesquisarValoresAvisoBancario(idAvisoBancario);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		return helper;
	}

	/**
	 * [UC0507] Manter Arrecadador
	 * Remover Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 08/02/2007
	 * @pparam id, usuarioLogado
	 * @throws ControladorException
	 */
	public void removerArrecadador(String[] ids, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_ARRECADADOR_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// [SB0002]
		this.getControladorUtil().remover(ids, Arrecadador.class.getName(), null, null);
	}

	/**
	 * [UC0510] Remover Contrato Arrecadador
	 * Remover Contrato de Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 12/04/2007
	 * @pparam id, usuarioLogado
	 * @throws ControladorException
	 */
	public void removerContratoArrecadador(String[] ids, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_ARRECADADOR_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		for(int i = 0; i < ids.length; i++){
			FiltroArrecadadorContratoTarifa filtroArrecadadorContratoTarifa = new FiltroArrecadadorContratoTarifa();
			filtroArrecadadorContratoTarifa.adicionarParametro(new ParametroSimples(
							FiltroArrecadadorContratoTarifa.ID_ARRECADADOR_CONTRATO, Util.obterInteger(ids[i])));

			Collection colecaoRemocao = getControladorUtil().pesquisar(filtroArrecadadorContratoTarifa,
							ArrecadadorContratoTarifa.class.getName());

			getControladorUtil().removerColecaoObjetos(colecaoRemocao);
		}

		// [SB0002]
		this.getControladorUtil().remover(ids, ArrecadadorContrato.class.getName(), null, null);
	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito - remover guia pagamento referente
	 * ao parcelamento
	 * remove a guia de pagamento do Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * @param
	 * @return void
	 */
	public void removerGuiaPagamentoPagamento(Integer idPagamento) throws ControladorException{

		try{

			this.repositorioArrecadacao.removerGuiaPagamentoPagamento(idPagamento);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito - remover guia pagamento referente
	 * ao parcelamento
	 * remove a guia de pagamento do Pagamento historico
	 * 
	 * @author Vitor
	 * @date 21/08/2008
	 * @param
	 * @return void
	 */
	public void removerGuiaPagamentoPagamentoHistorico(Integer idPagamento) throws ControladorException{

		try{

			this.repositorioArrecadacao.removerGuiaPagamentoPagamentoHistorico(idPagamento);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Transfere as 'Guias de Pagamento Prestação Histórico' para 'Guia de Pagamento Prestação'
	 * segundo o parâmetro numeroPrestação.
	 * Caso 'Guia de Pagamento' esteja no histórico, ela também será recuperada.
	 * [UC0213] Desfazer Parcelamento de Débitos
	 * 
	 * @author Saulo Lima
	 * @date 10/07/2009
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @throws ControladorException
	 */
	public void transferirGuiaPagamentoPrestacaoHistoricoParaGuiaPagamentoPrestacao(Integer idGuiaPagamento, Short numeroPrestacao)
					throws ControladorException{

		try{

			FiltroGuiaPagamentoGeral filtroGuiaPagamentoGeral = new FiltroGuiaPagamentoGeral();
			filtroGuiaPagamentoGeral.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoGeral.ID, idGuiaPagamento));
			filtroGuiaPagamentoGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.GUIA_PAGAMENTO);
			filtroGuiaPagamentoGeral.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoGeral.GUIA_PAGAMENTO_HISTORICO);

			Collection<GuiaPagamentoGeral> colecaoGuiaPagamentoGeral = this.getControladorUtil().pesquisar(filtroGuiaPagamentoGeral,
							GuiaPagamentoGeral.class.getName());

			if(colecaoGuiaPagamentoGeral == null || colecaoGuiaPagamentoGeral.isEmpty()){
				throw new ControladorException("erro.sistema");
			}

			GuiaPagamentoGeral guiaPagamentoGeral = colecaoGuiaPagamentoGeral.iterator().next();

			// Se a Guia estiver em histórico, voltar GuiaPagamento para status anterior
			if(guiaPagamentoGeral.getIndicadorHistorico() == ConstantesSistema.SIM.shortValue()){

				// Criar e insere objeto GuiaPagamento
				GuiaPagamento guiaPagamento = new GuiaPagamento();
				try{
					PropertyUtils.copyProperties(guiaPagamento, guiaPagamentoGeral.getGuiaPagamentoHistorico());
				}catch(IllegalAccessException iaex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema");
				}catch(InvocationTargetException itex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema");
				}
				guiaPagamento.setUltimaAlteracao(new Date());
				guiaPagamento.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));
				Collection colecaoGuiaPagamentoInserir = new ArrayList<GuiaPagamento>();
				colecaoGuiaPagamentoInserir.add(guiaPagamento);
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoGuiaPagamentoInserir);

				// Recuperar Cliente Guia Pagamento
				this.enviarClienteGuiaPagamentoHistoricoParaClienteGuiaPagamento(idGuiaPagamento);

				// Remover Guia Pagamento Histórico
				GuiaPagamentoHistorico guiaPagamentoHistorico = guiaPagamentoGeral.getGuiaPagamentoHistorico();
				Collection colecaoGuiaPagamentoHistoricoRemover = new ArrayList<GuiaPagamentoHistorico>();
				colecaoGuiaPagamentoHistoricoRemover.add(guiaPagamentoHistorico);
				this.getControladorBatch().removerColecaoObjetoParaBatch(colecaoGuiaPagamentoHistoricoRemover);

				// Atualizar indicador de Guia Pagamento Geral
				guiaPagamentoGeral.setIndicadorHistorico(Short.valueOf("2"));
				guiaPagamentoGeral.setUltimaAlteracao(new Date());
				Collection colecaoGuiaPagamentoGeralAtualizar = new ArrayList();
				colecaoGuiaPagamentoGeralAtualizar.add(guiaPagamentoGeral);
				this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoGuiaPagamentoGeralAtualizar);
			}

			FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
			filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
							FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
			filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
							FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacao));

			Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil().pesquisar(
							filtroGuiaPagamentoPrestacaoHistorico, GuiaPagamentoPrestacaoHistorico.class.getName());

			if(colecaoGuiaPagamentoPrestacaoHistorico == null || colecaoGuiaPagamentoPrestacaoHistorico.isEmpty()){
				throw new ControladorException("erro.sistema");
			}

			this.enviarGuiaPagamentoPrestacaoHistoricoParaGuiaPagamentoPrestacao(colecaoGuiaPagamentoPrestacaoHistorico);

			// O Set garante que somente 1 categoria por Prestação e Lancamento_item_Contabil será
			// obtido, mesmo qdo variar somente o tipo de débito
			Set<GuiaPagamentoCategoriaHistorico> colecaoGuiasPagamentoCategoriaHistoricoRemover = new HashSet<GuiaPagamentoCategoriaHistorico>();

			// Itera no resultado do Map para Montar a Coleção de Categorias correspondentes às
			// Prestações
			for(Iterator iteratorCategoria = colecaoGuiaPagamentoPrestacaoHistorico.iterator(); iteratorCategoria.hasNext();){
				GuiaPagamentoPrestacaoHistorico guiaPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) iteratorCategoria.next();

				// Consulta as Categorias da Prestação para Cancelamento também
				FiltroGuiaPagamentoCategoriaHistorico filtroGuiaPagamentoCategoriaHistorico = new FiltroGuiaPagamentoCategoriaHistorico();
				filtroGuiaPagamentoCategoriaHistorico.adicionarParametro(new ParametroSimples(
								FiltroGuiaPagamentoCategoriaHistorico.GUIA_PAGAMENTO_GERAL_ID, guiaPrestacaoHistorico.getComp_id()
												.getGuiaPagamentoId()));
				filtroGuiaPagamentoCategoriaHistorico.adicionarParametro(new ParametroSimples(
								FiltroGuiaPagamentoCategoriaHistorico.NUMERO_PRESTACAO, guiaPrestacaoHistorico.getComp_id()
												.getNumeroPrestacao()));
				filtroGuiaPagamentoCategoriaHistorico.adicionarParametro(new ParametroSimples(
								FiltroGuiaPagamentoCategoriaHistorico.LANCAMENTO_ITEM_CONTABIL_ID, guiaPrestacaoHistorico.getComp_id()
												.getItemLancamentoContabilId()));

				Collection<GuiaPagamentoCategoriaHistorico> guiasPagamentoCategoriasHistorico = this.getControladorUtil().pesquisar(
								filtroGuiaPagamentoCategoriaHistorico, GuiaPagamentoCategoriaHistorico.class.getName());

				if(guiasPagamentoCategoriasHistorico != null && !guiasPagamentoCategoriasHistorico.isEmpty()){
					colecaoGuiasPagamentoCategoriaHistoricoRemover.addAll(guiasPagamentoCategoriasHistorico);
				}
			}

			this.enviarGuiaPagamentoCategoriaHistoricoParaGuiaPagamentoCategoria(colecaoGuiasPagamentoCategoriaHistoricoRemover);

		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método reponsável por copiar os dados da Prestação Histórico, inserir a Prestação e Remover
	 * do Histórico
	 * [UC0213] Desfazer Parcelamento de Débitos
	 * 
	 * @author Saulo Lima
	 * @date 10/07/2009
	 * @param colecaoGuiaPagamentoPrestacaoHistorico
	 * @throws ControladorException
	 */
	protected void enviarGuiaPagamentoPrestacaoHistoricoParaGuiaPagamentoPrestacao(
					Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico) throws ControladorException{

		try{

			Collection colecaoGuiasPagamentoPrestacaoInserir = new ArrayList<GuiaPagamentoPrestacao>();
			Collection colecaoGuiasPagamentoPrestacaoHistoricoRemover = new ArrayList<GuiaPagamentoPrestacaoHistorico>();
			for(Iterator<GuiaPagamentoPrestacaoHistorico> iterator = colecaoGuiaPagamentoPrestacaoHistorico.iterator(); iterator.hasNext();){
				GuiaPagamentoPrestacaoHistorico guiaPrestacaoHistorico = iterator.next();

				// Cria uma Guia Prestacao
				GuiaPagamentoPrestacaoPK guiaPrestacaoPK = new GuiaPagamentoPrestacaoPK(guiaPrestacaoHistorico.getComp_id()
								.getGuiaPagamentoId(), guiaPrestacaoHistorico.getComp_id().getNumeroPrestacao(), guiaPrestacaoHistorico
								.getComp_id().getDebitoTipoId(), guiaPrestacaoHistorico.getComp_id().getItemLancamentoContabilId());

				GuiaPagamentoPrestacao guiaPrestacaoNova = new GuiaPagamentoPrestacao();
				guiaPrestacaoNova.setComp_id(guiaPrestacaoPK);

				guiaPrestacaoNova.setAnoMesReferenciaFaturamento(guiaPrestacaoHistorico.getAnoMesReferenciaFaturamento());
				guiaPrestacaoNova.setDataEmissao(guiaPrestacaoHistorico.getDataEmissao());
				guiaPrestacaoNova.setDataVencimento(guiaPrestacaoHistorico.getDataVencimento());
				guiaPrestacaoNova.setDebitoTipo(guiaPrestacaoHistorico.getDebitoTipo());
				guiaPrestacaoNova.setFinanciamentoTipo(guiaPrestacaoHistorico.getFinanciamentoTipo());
				guiaPrestacaoNova.setIndicadorCobrancaMulta(guiaPrestacaoHistorico.getIndicadorCobrancaMulta());
				guiaPrestacaoNova.setIndicadorPagamentoPendente(guiaPrestacaoHistorico.getIndicadorPagamentoPendente());
				guiaPrestacaoNova.setValorPrestacao(guiaPrestacaoHistorico.getValorPrestacao());
				guiaPrestacaoNova.setDebitoCreditoSituacao(guiaPrestacaoHistorico.getDebitoCreditoSituacao());
				guiaPrestacaoNova.setUltimaAlteracao(new Date());
				guiaPrestacaoNova.setIndicadorCobrancaAdministrativa(guiaPrestacaoHistorico.getIndicadorCobrancaAdministrativa());
				guiaPrestacaoNova.setIndicadorRemuneraCobrancaAdministrativa(guiaPrestacaoHistorico.getIndicadorRemuneraCobrancaAdministrativa());

				colecaoGuiasPagamentoPrestacaoInserir.add(guiaPrestacaoNova);
				colecaoGuiasPagamentoPrestacaoHistoricoRemover.add(guiaPrestacaoHistorico);
			}

			this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoGuiasPagamentoPrestacaoInserir);
			this.getControladorBatch().removerColecaoObjetoParaBatch(colecaoGuiasPagamentoPrestacaoHistoricoRemover);

			colecaoGuiasPagamentoPrestacaoInserir = null;
			colecaoGuiasPagamentoPrestacaoHistoricoRemover = null;

		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0508] Filtrar Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 07/02/2007
	 * @param Integer
	 * @return boolean
	 */
	public boolean verificarExistenciaAgente(Integer codigoAgente) throws ControladorException{

		// [FS0003] - Verificando a existência do Agente
		boolean retorno = true;

		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();

		filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.CODIGO_AGENTE, codigoAgente));

		Collection colecaoAgente = getControladorUtil().pesquisar(filtroArrecadador, Arrecadador.class.getName());

		if(colecaoAgente == null || colecaoAgente.isEmpty()){
			throw new ControladorException("atencao.agente_inexistente");
		}
		return retorno;

	}

	/**
	 * [UC0511] Filtrar Contrato Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 09/04/2007
	 * @param Integer
	 * @return boolean
	 */
	public boolean verificarExistenciaArrecadador(Integer codigoArrecadador) throws ControladorException{

		// [FS0003] - Verificando a existência do Agente
		boolean retorno = true;

		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();

		filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.CODIGO_AGENTE, codigoArrecadador));

		Collection colecaoArrecadador = getControladorUtil().pesquisar(filtroArrecadador, Arrecadador.class.getName());

		if(colecaoArrecadador == null || colecaoArrecadador.isEmpty()){
			throw new ControladorException("atencao.arrecadador_inexistente");
		}
		return retorno;

	}

	/**
	 * [UC0511] Filtrar Contrato Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 09/04/2007
	 * @param Integer
	 * @return boolean
	 */
	public boolean verificarExistenciaContrato(Integer numeroContrato) throws ControladorException{

		// [FS0003] - Verificando a existência do Agente
		boolean retorno = true;

		FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();

		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.NUMEROCONTRATO, numeroContrato
						.toString()));

		Collection colecaoContratoArrecadador = getControladorUtil().pesquisar(filtroArrecadadorContrato,
						ArrecadadorContrato.class.getName());

		if(colecaoContratoArrecadador == null || colecaoContratoArrecadador.isEmpty()){
			throw new ControladorException("atencao.contratoArrecadador_inexistente");
		}
		return retorno;

	}

	/**
	 * obtem colecao com dados diarios da arrecadacao
	 * 
	 * @author Genival Barbosa
	 * @date 25/07/2011
	 * @param anoMesReferencia
	 *            ,
	 *            idArrecadador, isArrecadacaoForma
	 * @return Uma Colecao
	 * @throws ControladorException
	 */
	public Collection consultarDadosRelatorioControleDocumentosArrecadacaoAnalitico(int anoMesReferencia, Integer idArrecadador,
					Integer idArrecadacaoForma) throws ControladorException{

		try{

			return this.repositorioArrecadacao.consultarDadosRelatorioControleDocumentosArrecadacaoAnalitico(anoMesReferencia,
							idArrecadador, idArrecadacaoForma);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public ExecutorParametro getExecutorParametro(){

		return ExecutorParametrosArrecadacao.getInstancia();
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0005] Verifica Associação do Pagamento com Itens de Negativação
	 * 
	 * @author Hebert Falcão
	 * @date 11/08/2011
	 */
	private void verificarAssociacaoPagamentoItensNegativacao(Pagamento pagamento) throws ControladorException{

		Conta conta = pagamento.getConta();

		if(conta != null && conta.getId() != null){
			Integer contaId = conta.getId();

			// 1.1. O sistema obtém dados da conta do pagamento
			Collection colecaoConta = getControladorFaturamento().obterConta(contaId);
			Conta contaPesquisada = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

			// 1.2. O sistema verifica se existem itens de negativação associados à conta do
			// pagamento
			Imovel imovel = contaPesquisada.getImovel();
			Integer imovelId = imovel.getId();

			Integer referenciaConta = contaPesquisada.getReferencia();

			// [UC0937 – Obter Itens de Negativação Associados à Conta]
			Collection<Integer> itensNegativacaoAssociadosAConta = getControladorSpcSerasa().obterItensNegativacaoAssociadosAConta(
							imovelId, referenciaConta);

			if(!Util.isVazioOrNulo(itensNegativacaoAssociadosAConta)){
				// [SB0006 – Atualizar Item da Negativação – Desfazer Pagamento]
				this.atualizarItensNegativacaoDesfazerPagamento(itensNegativacaoAssociadosAConta);
			}
		}
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0006] Atualizar Itens da Negativação – Desfazer Pagamento
	 * 
	 * @author Hebert Falcão
	 * @date 11/08/2011
	 */
	private void atualizarItensNegativacaoDesfazerPagamento(Collection<Integer> itensNegativacaoAssociadosAConta)
					throws ControladorException{

		Collection<NegativadorMovimentoRegItem> negativadorMovimentoRegItens = getControladorSpcSerasa()
						.pesquisarNegativadorMovimentoRegItensPorIds((List<Integer>) itensNegativacaoAssociadosAConta);

		if(!Util.isVazioOrNulo(negativadorMovimentoRegItens)){
			Date dataCorrente = new Date();

			CobrancaDebitoSituacao cobrancaDebitoSituacao = new CobrancaDebitoSituacao();
			cobrancaDebitoSituacao.setId(CobrancaDebitoSituacao.PENDENTE);

			for(NegativadorMovimentoRegItem negativadorMovimentoRegItem : negativadorMovimentoRegItens){
				NegativadorMovimentoReg negativadorMovimentoReg = negativadorMovimentoRegItem.getNegativadorMovimentoReg();

				if(negativadorMovimentoReg.getCodigoExclusaoTipo() == null){
					// Negativação não foi excluida

					negativadorMovimentoRegItem.setCobrancaDebitoSituacao(cobrancaDebitoSituacao);
					negativadorMovimentoRegItem.setDataSituacaoDebito(dataCorrente);
				}else{
					// Negativação foi excluida

					negativadorMovimentoRegItem.setCobrancaDebitoSituacaoAposExclusao(cobrancaDebitoSituacao);
					negativadorMovimentoRegItem.setDataSituacaoDebitoAposExclusao(dataCorrente);
				}

				negativadorMovimentoRegItem.setValorPago(null);
				negativadorMovimentoRegItem.setUltimaAlteracao(dataCorrente);
				negativadorMovimentoRegItem.setIndicadorSituacaoDefinitiva(ConstantesSistema.NAO);

				// Atualiza o registro de negativação associado ao item
				negativadorMovimentoReg.setIndicadorItemAtualizado(ConstantesSistema.SIM);
				negativadorMovimentoReg.setUltimaAlteracao(dataCorrente);

				getControladorUtil().atualizar(negativadorMovimentoReg);

				// Atualiza o item da negativação
				getControladorUtil().atualizar(negativadorMovimentoRegItem);
			}
		}

	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB00010] Verifica Associação Novo Tipo Documento do Pagamento com Itens de Negativação
	 * 
	 * @author Hebert Falcão, Genival Barbosa
	 * @date 11/08/2011, 08/11/2011
	 */
	private void verificarAssociacaoNovoTipoDocPagamentoItensNegativacao(Conta contaAntiga, Conta contaNova) throws ControladorException{

		// Pagamento desvinculado da conta
		if(contaAntiga != null && contaAntiga.getId() != null && contaNova == null){

			// atualizando itens da negativação da conta antiga
			getControladorSpcSerasa().atualizarItemDaNegativacao(contaAntiga.getReferencia(), contaAntiga.getImovel(),
							CobrancaDebitoSituacao.PENDENTE, new Date(), null, Boolean.TRUE, ConstantesSistema.NAO);
		}
	}

	/**
	 * Retorna o objeto distribuido de acordo com o tipo de pagamento
	 * [UC0264] - Distribuir Dados do Código de Barras
	 * [SB0007] - Distribuir Pagamento de Conta
	 * [SF0002] - Distribuir Pagamento de Guia de Pagamento
	 * [SF0003] - Distribuir Pagamento de Documento de Cobrança
	 * [SF0004] - Distribuir Pagamento de Fatura do Cliente Responsável
	 * 
	 * @author Vitor Hora, Saulo Lima
	 * @date 06/08/2008, 04/12/2008
	 * @author eduardo henrique
	 * @date 18/12/2008
	 *       Alteração no método para tratamento de questão de Docs. Agregadores de Legado ADA
	 */
	public Object[] distribuirDadosCodigoBarrasPorTipoPagamentoLegadoADA(String idPagamento, int tipoPagamento, String idEmpresa)
					throws ControladorException{

		String contaSegundaVia = ConstantesAplicacao.get("empresa.ada_conta_segunda_via");
		String parcela = ConstantesAplicacao.get("empresa.ada_parcela");
		String notaAvulsa = ConstantesAplicacao.get("empresa.ada_nota_avulsa");
		String guiaPagamentoADA = ConstantesAplicacao.get("empresa.ada_guia_pagamento");

		// Identificação - G.05.7.1
		String identificacao = idPagamento.substring(0, 20);

		// Tipo documento - G.05.7.2
		String tipoDocumento = idPagamento.substring(20, 23);

		// Verão código barras - G.05.7.3
		String versaoCodigoBarras = idPagamento.substring(23, 25);

		// Ano corrente - G05.7.1.2
		String anoDocumentoADA = identificacao.substring(5, 9);

		// Número identificação do documento pagável - G.05.7.1.3
		String documentoPagavelADA = identificacao.substring(9, 18);

		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
		Integer tipoPagamentoAux = null;
		String descricaoOcorrenciaMovimento = "OK";

		Object[] retorno = new Object[3];

		retorno[0] = registroHelperCodigoBarrasTipoPagamento;
		retorno[1] = tipoPagamentoAux;
		retorno[2] = descricaoOcorrenciaMovimento;

		// [SB0007] - Distribuir Pagamento Legado ADA

		// Conta e Segunda Via
		if(tipoDocumento.equals(contaSegundaVia)){

			// [SB0014] – Determinar Valores da Conta

			// Verifica se o número da identificação do documento pagável contem caracteres não
			// numéricos
			if(Util.validarValorNaoNumerico(documentoPagavelADA)){
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO INVÁLIDA";

				return retorno;
			}

			FiltroAvisoInteligest filtroAvisoInteligest = new FiltroAvisoInteligest();
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.NUMERO_AVISO, documentoPagavelADA));
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.ANO, anoDocumentoADA));
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.CODIGO_TRIBUTO, tipoDocumento));

			Collection<AvisoInteligest> colecaoAvisoInteligest = this.getControladorUtil().pesquisar(filtroAvisoInteligest,
							AvisoInteligest.class.getName());

			Integer numeroSequencialInteligest = null;

			if(!Util.isVazioOrNulo(colecaoAvisoInteligest)){
				AvisoInteligest avisoInteligest = (AvisoInteligest) Util.retonarObjetoDeColecao(colecaoAvisoInteligest);
				numeroSequencialInteligest = avisoInteligest.getNumeroSequencial();
			}

			String idImovelStr = null;
			String mesAnoReferenciaConta = null;

			if(numeroSequencialInteligest == null){
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";

				return retorno;
			}else{
				FiltroConta filtroConta = new FiltroConta();
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, numeroSequencialInteligest));

				Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

				if(Util.isVazioOrNulo(colecaoConta)){
					// Tenta obter a referência do legado em Histórico
					FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
					filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, numeroSequencialInteligest));

					Collection<ContaHistorico> colecaoContaHistorico = getControladorUtil().pesquisar(filtroContaHistorico,
									ContaHistorico.class.getName());

					if(Util.isVazioOrNulo(colecaoContaHistorico)){
						descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";

						return retorno;
					}else{
						ContaHistorico contaHistorico = (ContaHistorico) Util.retonarObjetoDeColecao(colecaoContaHistorico);

						Imovel imovel = contaHistorico.getImovel();
						Integer idImovel = imovel.getId();

						idImovelStr = idImovel.toString();

						int anoMesReferenciaConta = contaHistorico.getAnoMesReferenciaConta();
						mesAnoReferenciaConta = Util.formatarAnoMesParaMesAnoSemBarra(anoMesReferenciaConta);
					}
				}else{
					Conta conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

					Imovel imovel = conta.getImovel();
					Integer idImovel = imovel.getId();

					idImovelStr = idImovel.toString();

					int anoMesReferenciaConta = conta.getReferencia();
					mesAnoReferenciaConta = Util.formatarAnoMesParaMesAnoSemBarra(anoMesReferenciaConta);
				}
			}

			registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idImovelStr);
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mesAnoReferenciaConta);

			// Tipo de Pagamento
			tipoPagamentoAux = PagamentoTipo.PAGAMENTO_TIPO_CONTA;

			// Parcela ou Nota Avulsa ou Guia de pagamento
		}else if(tipoDocumento.equals(parcela) || tipoDocumento.equals(notaAvulsa)){

			// [SB0015] – Determinar Valores da Guia de Pagamento ou do Documento de Cobrança

			// Verifica se o número da identificação do documento pagável contem caracteres não
			// numéricos
			if(Util.validarValorNaoNumerico(documentoPagavelADA)){
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO INVÁLIDA";

				return retorno;
			}

			FiltroAvisoInteligest filtroAvisoInteligest = new FiltroAvisoInteligest();
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.NUMERO_AVISO, documentoPagavelADA));
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.ANO, anoDocumentoADA));
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.CODIGO_TRIBUTO, tipoDocumento));

			Collection<AvisoInteligest> colecaoAvisoInteligest = this.getControladorUtil().pesquisar(filtroAvisoInteligest,
							AvisoInteligest.class.getName());

			Integer numeroSequencialInteligest = null;

			if(!Util.isVazioOrNulo(colecaoAvisoInteligest)){
				AvisoInteligest avisoInteligest = (AvisoInteligest) Util.retonarObjetoDeColecao(colecaoAvisoInteligest);
				numeroSequencialInteligest = avisoInteligest.getNumeroSequencial();
			}

			String idImovelStr = null;
			String idGuiaPagamentoStr = null;

			if(numeroSequencialInteligest == null){
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";

				return retorno;
			}else{
				FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
				filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, numeroSequencialInteligest));

				Collection<GuiaPagamento> colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamento,
								GuiaPagamento.class.getName());

				if(Util.isVazioOrNulo(colecaoGuiaPagamento)){
					// Tenta obter a referência do Legado no histórico
					FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
					filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID,
									numeroSequencialInteligest));

					Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = getControladorUtil().pesquisar(
									filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());

					if(Util.isVazioOrNulo(colecaoGuiaPagamentoHistorico)){
						descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";

						return retorno;
					}else{
						GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
										.retonarObjetoDeColecao(colecaoGuiaPagamentoHistorico);

						Imovel imovel = guiaPagamentoHistorico.getImovel();
						Integer idImovel = imovel.getId();

						idImovelStr = idImovel.toString();

						Integer idGuiaPagamento = guiaPagamentoHistorico.getId();
						idGuiaPagamentoStr = idGuiaPagamento.toString();
					}
				}else{
					GuiaPagamento guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);

					Imovel imovel = guiaPagamento.getImovel();
					Integer idImovel = imovel.getId();

					idImovelStr = idImovel.toString();

					Integer idGuiaPagamento = guiaPagamento.getId();
					idGuiaPagamentoStr = idGuiaPagamento.toString();
				}
			}

			registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idImovelStr);
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idGuiaPagamentoStr);
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3("1");

			// Tipo de Pagamento
			tipoPagamentoAux = PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_MATRICULA_IMOVEL;

		}else if(tipoDocumento.equals(guiaPagamentoADA)){ // novo tratamento para agregadores
			// [SB0015] – Determinar Valores da Guia de Pagamento ou do Documento de Cobrança

			// Verifica se o número da identificação do documento pagável contem caracteres não
			// numéricos
			if(Util.validarValorNaoNumerico(documentoPagavelADA)){
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO INVÁLIDA";

				return retorno;
			}

			if(versaoCodigoBarras.equalsIgnoreCase("03")){
				// Ano corrente - G05.7.1.2
				anoDocumentoADA = identificacao.substring(7, 11);

				// Número identificação do documento pagável - G.05.7.1.3
				documentoPagavelADA = identificacao.substring(11, 20);
			}

			FiltroAvisoInteligest filtroAvisoInteligest = new FiltroAvisoInteligest();
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.NUMERO_AVISO, documentoPagavelADA));
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.ANO, anoDocumentoADA));
			filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.CODIGO_TRIBUTO, tipoDocumento));

			Collection<AvisoInteligest> colecaoAvisoInteligest = this.getControladorUtil().pesquisar(filtroAvisoInteligest,
							AvisoInteligest.class.getName());

			Integer numeroSequencialInteligest = null;

			if(!Util.isVazioOrNulo(colecaoAvisoInteligest)){
				AvisoInteligest avisoInteligest = (AvisoInteligest) Util.retonarObjetoDeColecao(colecaoAvisoInteligest);
				numeroSequencialInteligest = avisoInteligest.getNumeroSequencial();
			}

			String idImovelStr = null;
			String numeroSequenciaDocumentoStr = null;

			if(numeroSequencialInteligest == null){
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";

				return retorno;
			}else{
				FiltroDocumentoCobranca filtroDocumentoCobranca = new FiltroDocumentoCobranca();
				filtroDocumentoCobranca.adicionarParametro(new ParametroSimples(FiltroDocumentoCobranca.ID, numeroSequencialInteligest));

				Collection<CobrancaDocumento> colecaoCobrancaDocumento = getControladorUtil().pesquisar(filtroDocumentoCobranca,
								CobrancaDocumento.class.getName());

				if(Util.isVazioOrNulo(colecaoCobrancaDocumento)){
					descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";

					return retorno;
				}else{
					CobrancaDocumento cobrancaDocumento = (CobrancaDocumento) Util.retonarObjetoDeColecao(colecaoCobrancaDocumento);

					Imovel imovel = cobrancaDocumento.getImovel();
					Integer idImovel = imovel.getId();

					idImovelStr = idImovel.toString();

					int numeroSequenciaDocumento = cobrancaDocumento.getNumeroSequenciaDocumento();
					numeroSequenciaDocumentoStr = Integer.toString(numeroSequenciaDocumento);
				}
			}

			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idImovelStr);
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(numeroSequenciaDocumentoStr);

			// Tipo de Pagamento
			tipoPagamentoAux = PagamentoTipo.PAGAMENTO_TIPO_COBANCA_MATRICULA_IMOVEL;
		}

		retorno[0] = registroHelperCodigoBarrasTipoPagamento;
		retorno[1] = tipoPagamentoAux;
		retorno[2] = descricaoOcorrenciaMovimento;

		return retorno;
	}

	/**
	 * Identificação da Empresa for ADA (G.05.6 = 0477) e posição 20 a 24(G.05.7 = 00000 e posição
	 * 43 a 44(G.05.7 = 04 ou 03),
	 * 
	 * @author Vitor Hora
	 * @author Saulo Lima
	 * @date 10/06/2009
	 *       Adicionar mais uma identificação: adaTipoDocumento <> "000"
	 */
	public boolean validarRegistroLegadoADA(Short codigoEmpresaFebraban, String adaGrupoFaturamentoConstanteLegado,
					String adaAnoMesReferenciaContaLegado, String adaTipoDocumento){

		boolean retorno = false;

		if(Short.parseShort(ConstantesAplicacao.get("empresa.ada_codigo_empresa")) == codigoEmpresaFebraban.shortValue()){

			if((ConstantesAplicacao.get("empresa.ada_grupo_faturamento_constante_legado1").equals(adaGrupoFaturamentoConstanteLegado) || ConstantesAplicacao
							.get("empresa.ada_grupo_faturamento_constante_legado2").equals(adaGrupoFaturamentoConstanteLegado))
							&& ConstantesAplicacao.get("empresa.ada_ano_mes_referencia_conta_legado")
											.equals(adaAnoMesReferenciaContaLegado)){

				if(!ConstantesAplicacao.get("empresa.ada_tipo_documento_diferente").equals(adaTipoDocumento)){
					retorno = true;
				}else{
					retorno = false;
				}
			}else{
				retorno = false;
			}
		}else{
			retorno = false;
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0014 – Processar Pagamento Legado ADA]
	 * LEGADO CONTA ADA
	 * 
	 * @author Saulo Lima
	 * @throws ErroRepositorioException
	 * @date 05/12/2008
	 */
	private PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasLegadoADA(RegistroHelperCodigoBarras registroHelperCodigoBarras,
					String subStringIdPagamento, SistemaParametro sistemaParametro, Date dataPagamento, Integer anoMesPagamento,
					BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException, ErroRepositorioException{

		// variável de retorno
		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = null;

		// recupera o id pagamento da string
		// String idPagamento = codigoBarras.substring(19, 44);

		// Tipo documento - G.05.7.2
		String tipoDocumento = subStringIdPagamento.substring(20, 23);

		// G.05.7.1.3 - Identificação do Documento Pagável
		String documentoPagavelADA = registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3();

		// G.05.7.1.2 - Ano do Documento Pagável
		Integer anoDocumentoADA = null;
		if(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2() != null){
			anoDocumentoADA = Integer.valueOf(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
		}

		// Tipo do Documento (G.05.7.2) transformado em codidoTributo
		Integer codigoTributoADA = null;
		if(!Util.validarValorNaoNumerico(tipoDocumento)){
			codigoTributoADA = Integer.valueOf(tipoDocumento);
		}

		String contaSegundaVia = ConstantesAplicacao.get("empresa.ada_conta_segunda_via");
		String parcela = ConstantesAplicacao.get("empresa.ada_parcela");
		String notaAvulsa = ConstantesAplicacao.get("empresa.ada_nota_avulsa");
		String guiaPagamentoADA = ConstantesAplicacao.get("empresa.ada_guia_pagamento");
		String descricaoOcorrenciaMovimento = "OK";

		// Conta e Segunda Via ADA (Conta GSAN)
		if(tipoDocumento.equals(contaSegundaVia)){

			// [FS0011 – Validar Identificação]
			Integer numeroDocumentoPagavelADA = null;
			if(!Util.validarValorNaoNumerico(documentoPagavelADA)){
				numeroDocumentoPagavelADA = Integer.valueOf(documentoPagavelADA);
			}else{
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO INVÁLIDA";
			}

			if(descricaoOcorrenciaMovimento.equals("OK") && anoDocumentoADA != null && codigoTributoADA != null){

				FiltroAvisoInteligest filtroAvisoInteligest = new FiltroAvisoInteligest();
				filtroAvisoInteligest
								.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.NUMERO_AVISO, numeroDocumentoPagavelADA));
				filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.ANO, anoDocumentoADA));
				filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.CODIGO_TRIBUTO, codigoTributoADA));

				Collection<AvisoInteligest> colecaoAvisoInteligest = getControladorUtil().pesquisar(filtroAvisoInteligest,
								AvisoInteligest.class.getName());

				AvisoInteligest avisoInteligest = null;
				if(colecaoAvisoInteligest != null && !colecaoAvisoInteligest.isEmpty()){
					avisoInteligest = colecaoAvisoInteligest.iterator().next();
				}

				if(avisoInteligest == null){
					descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO LEGADO NÃO LOCALIZADO";
				}else{
					Integer idContaInteligest = avisoInteligest.getNumeroSequencial();

					FiltroConta filtroConta = new FiltroConta();
					filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, idContaInteligest));
					Collection<Conta> colecaoConta = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

					Conta conta = null;
					if(colecaoConta != null && !colecaoConta.isEmpty()){
						conta = colecaoConta.iterator().next();
					}

					if(conta == null){
						// Tenta obter a referência do legado em Histórico
						FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
						filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, idContaInteligest));
						Collection<ContaHistorico> colecaoContaHistorico = getControladorUtil().pesquisar(filtroContaHistorico,
										ContaHistorico.class.getName());
						if(colecaoContaHistorico != null && !colecaoContaHistorico.isEmpty()){
							ContaHistorico contaHistorico = colecaoContaHistorico.iterator().next();
							// atribui a ref. e o imóvel da conta encontrada ao Helper
							registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento1(
											contaHistorico.getImovel().getId().toString());
							registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento2(
											Util.formatarAnoMesParaMesAnoSemBarra(contaHistorico.getAnoMesReferenciaConta()));
						}else{
							descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";
						}
					}else{
						// atribui a ref. e o imóvel da conta encontrada ao Helper
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento1(
										conta.getImovel().getId().toString());
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento2(
										Util.formatarAnoMesParaMesAnoSemBarra(conta.getReferencia()));

					}
					if(descricaoOcorrenciaMovimento.equalsIgnoreCase("OK")){
						pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasConta(registroHelperCodigoBarras,
										sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento, idFormaPagamento);
					}
				}
			}

			// Parcela ou Nota Avulsa ADA (GuiaPagamento GSAN)
		}else if(tipoDocumento.equals(parcela) || tipoDocumento.equals(notaAvulsa)){

			// [FS0011 – Validar Identificação]
			Integer numeroDocumentoPagavelADA = null;
			if(!Util.validarValorNaoNumerico(documentoPagavelADA)){
				numeroDocumentoPagavelADA = Integer.valueOf(documentoPagavelADA);
			}else{
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO INVÁLIDA";
			}

			if(descricaoOcorrenciaMovimento.equals("OK") && anoDocumentoADA != null && codigoTributoADA != null){

				FiltroAvisoInteligest filtroAvisoInteligest = new FiltroAvisoInteligest();
				filtroAvisoInteligest
								.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.NUMERO_AVISO, numeroDocumentoPagavelADA));
				filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.ANO, anoDocumentoADA));
				filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.CODIGO_TRIBUTO, codigoTributoADA));

				Collection<AvisoInteligest> colecaoAvisoInteligest = getControladorUtil().pesquisar(filtroAvisoInteligest,
								AvisoInteligest.class.getName());

				AvisoInteligest avisoInteligest = null;
				if(colecaoAvisoInteligest != null && !colecaoAvisoInteligest.isEmpty()){
					avisoInteligest = colecaoAvisoInteligest.iterator().next();
				}

				if(avisoInteligest == null || avisoInteligest.getNumeroSequencial() == null){
					descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO LEGADO NÃO LOCALIZADO";
				}else{

					FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
					filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, avisoInteligest
									.getNumeroSequencial()));
					Collection<GuiaPagamento> colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamento,
									GuiaPagamento.class.getName());

					GuiaPagamento guiaPagamento = null;
					if(colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()){
						guiaPagamento = colecaoGuiaPagamento.iterator().next();
					}

					if(guiaPagamento == null){
						// Tenta obter a referência do Legado no histórico
						FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
						filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID,
										avisoInteligest.getNumeroSequencial()));

						Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = getControladorUtil().pesquisar(
										filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());
						if(colecaoGuiaPagamentoHistorico != null && !colecaoGuiaPagamentoHistorico.isEmpty()){
							GuiaPagamentoHistorico guiaPagamentoHistorico = colecaoGuiaPagamentoHistorico.iterator().next();
							// atribui o imóvel, o nr da guia e a parcela da guia encontrada ao
							// Helper -- legados só tem 1 parcela
							registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento1(
											guiaPagamentoHistorico.getImovel().getId().toString());
							registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento2(
											guiaPagamentoHistorico.getId().toString());
							registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento3("01");

						}else{
							descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";
						}
					}else{
						// atribui o imóvel, o nr da guia e a parcela da guia encontrada ao Helper
						// -- legados só tem 1 parcela
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento1(
										guiaPagamento.getImovel().getId().toString());
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento2(
										guiaPagamento.getId().toString());
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento3("01");

					}

					if(descricaoOcorrenciaMovimento.equalsIgnoreCase("OK")){
						pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasGuiaPagamento(registroHelperCodigoBarras,
										sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento, idFormaPagamento);
					}
				}
			}

			// Guia de pagamento ADA (DocumentoCobranca GSAN)
		}else if(tipoDocumento.equals(guiaPagamentoADA)){

			// [FS0011 – Validar Identificação]
			Integer numeroDocumentoPagavelADA = null;
			if(!Util.validarValorNaoNumerico(documentoPagavelADA)){
				numeroDocumentoPagavelADA = Integer.valueOf(documentoPagavelADA);
			}else{
				descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO INVÁLIDA";
			}

			if(descricaoOcorrenciaMovimento.equals("OK") && anoDocumentoADA != null && codigoTributoADA != null){

				FiltroAvisoInteligest filtroAvisoInteligest = new FiltroAvisoInteligest();
				filtroAvisoInteligest
								.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.NUMERO_AVISO, numeroDocumentoPagavelADA));
				filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.ANO, anoDocumentoADA));
				filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.CODIGO_TRIBUTO, codigoTributoADA));

				Collection<AvisoInteligest> colecaoAvisoInteligest = getControladorUtil().pesquisar(filtroAvisoInteligest,
								AvisoInteligest.class.getName());

				AvisoInteligest avisoInteligest = null;
				if(colecaoAvisoInteligest != null && !colecaoAvisoInteligest.isEmpty()){
					avisoInteligest = colecaoAvisoInteligest.iterator().next();
				}

				if(avisoInteligest == null){
					descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO LEGADO NÃO LOCALIZADO";
				}else{

					FiltroDocumentoCobranca filtroDocumentoCobranca = new FiltroDocumentoCobranca();
					filtroDocumentoCobranca.adicionarParametro(new ParametroSimples(FiltroDocumentoCobranca.ID, avisoInteligest
									.getNumeroSequencial()));
					Collection<CobrancaDocumento> colecaoCobrancaDocumento = getControladorUtil().pesquisar(filtroDocumentoCobranca,
									CobrancaDocumento.class.getName());

					CobrancaDocumento cobrancaDocumento = null;
					if(colecaoCobrancaDocumento != null && !colecaoCobrancaDocumento.isEmpty()){
						cobrancaDocumento = colecaoCobrancaDocumento.iterator().next();
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento1(
										cobrancaDocumento.getLocalidade().getId().toString());
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento2(
										cobrancaDocumento.getImovel().getId().toString());
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento3(
										"" + cobrancaDocumento.getNumeroSequenciaDocumento());
						registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().setIdPagamento4(
										cobrancaDocumento.getDocumentoTipo().getId().toString());
					}

					if(cobrancaDocumento == null){
						descricaoOcorrenciaMovimento = "IDENTIFICAÇÃO DO DOCUMENTO NÃO LOCALIZADO";
					}else{
						pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasDocumentoCobrancaTipo5(
										registroHelperCodigoBarras, sistemaParametro, dataPagamento, anoMesPagamento, valorPagamento,
										idFormaPagamento);
					}
				}
			}
		}else{
			descricaoOcorrenciaMovimento = "CÓDIGO DE BARRAS COM TIPO DE PAGAMENTO INVÁLIDO";
		}

		if(pagamentoHelperCodigoBarras == null){
			pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
			pagamentoHelperCodigoBarras.setColecaoPagamentos(null);
			pagamentoHelperCodigoBarras.setColecaoDevolucao(null);
			pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrenciaMovimento);
			pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro("" + ConstantesSistema.NAO);
		}

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0016] – Processar Pagamento Legado de Deso
	 * 
	 * @author Péricles Tavares
	 * @date 16/10/2011
	 * @param registroHelperCodigoBarras
	 * @param sistemaParametro
	 * @param dataPagamento
	 * @param anoMesPagamento
	 * @param valorPagamento
	 * @param idFormaPagamento
	 * @return
	 * @throws ControladorException
	 * @deprecated Método não utilizado
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasLegadoDESO(RegistroHelperCodigoBarras registroHelperCodigoBarras,
					SistemaParametro sistemaParametro, Date dataPagamento, Integer anoMesPagamento, BigDecimal valorPagamento,
					Integer idFormaPagamento) throws ControladorException{

		String descricaoOcorrencia = "OK";
		Collection colecaoPagamentos = new ArrayList();
		String indicadorAceitacaoRegistro = "1";
		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
		try{

			int tipoPagamento = Util.obterInteger(registroHelperCodigoBarras.getTipoPagamento());

			if(tipoPagamento == PagamentoTipo.PAGAMENTO_TIPO_LEGADO_NOTA_RECEBIMENTO_DESO){

				descricaoOcorrencia = this.validarMatriculaImovel(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
								.getIdPagamento1());
				descricaoOcorrencia = this.validarLocalidade(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
								.getIdPagamento3(), descricaoOcorrencia);
				descricaoOcorrencia = this.validarCodigoServico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
								.getIdPagamento4(), descricaoOcorrencia);
				if(descricaoOcorrencia.equals("OK")){
					GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
					guiaPagamentoGeral.setIndicadorHistorico(ConstantesSistema.NAO);
					guiaPagamentoGeral.setUltimaAlteracao(new Date());
					getControladorUtil().inserir(guiaPagamentoGeral);

					GuiaPagamento guiaPagamento = new GuiaPagamento();
					guiaPagamento.setId(guiaPagamentoGeral.getId());
					guiaPagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
					DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL);
					guiaPagamento.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

					Imovel imovel = repositorioArrecadacao
									.pesquisarImovelCodigoBarrasLegadoDESO(Util.obterInteger(registroHelperCodigoBarras
													.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1()));
					guiaPagamento.setLocalidade(imovel.getLocalidade());
					guiaPagamento.setSetorComercial(imovel.getSetorComercial());
					guiaPagamento.setImovel(imovel);
					guiaPagamento.setCliente(null);
					guiaPagamento.setRegistroAtendimento(null);
					guiaPagamento.setOrdemServico(null);
					guiaPagamento.setParcelamento(null);
					DocumentoTipo documentoTipoGuiaPagamento = new DocumentoTipo();
					documentoTipoGuiaPagamento.setId(DocumentoTipo.GUIA_PAGAMENTO);
					guiaPagamento.setDocumentoTipo(documentoTipoGuiaPagamento);
					guiaPagamento.setOrigem(null);
					guiaPagamento.setValorDebito(valorPagamento);
					guiaPagamento.setNumeroPrestacaoTotal(Util.obterShort("1"));
					guiaPagamento.setUltimaAlteracao(new Date());
					ServicoTipo servicoTipo = new ServicoTipo();
					servicoTipo.setId(Util.obterInteger(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
									.getIdPagamento4()));
					DebitoTipo debitoTipo = repositorioArrecadacao
									.pesquisarDebitoTipoPorServicoTipo(Util.obterInteger(registroHelperCodigoBarras
													.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4()));
					guiaPagamento.setDataInclusao(new Date());
					getControladorUtil().inserir(guiaPagamento);

					guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);

					if(debitoTipo != null && debitoTipo.getLancamentoItemContabil() != null){
						GuiaPagamentoPrestacaoPK comp_id = new GuiaPagamentoPrestacaoPK(guiaPagamento.getId(), (short) 1,
										debitoTipo.getId(), debitoTipo.getLancamentoItemContabil().getId());
						GuiaPagamentoPrestacao guiaPagamentoPrestacao = new GuiaPagamentoPrestacao();
						guiaPagamentoPrestacao.setComp_id(comp_id);
						guiaPagamentoPrestacao.setDebitoCreditoSituacao(debitoCreditoSituacao);
						guiaPagamentoPrestacao.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
						guiaPagamentoPrestacao.setValorPrestacao(valorPagamento);
						guiaPagamentoPrestacao.setDataVencimento(dataPagamento);
						guiaPagamentoPrestacao.setIndicadorPagamentoPendente(ConstantesSistema.SIM);
						guiaPagamentoPrestacao.setIndicadorCobrancaMulta(ConstantesSistema.NAO);
						guiaPagamentoPrestacao.setAnoMesReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
						guiaPagamentoPrestacao.setUltimaAlteracao(new Date());
						guiaPagamentoPrestacao.setDataEmissao(new Date());
						getControladorUtil().inserir(guiaPagamentoPrestacao);
					}else{
						System.out.println("SVTP_ID S/ DBTP_ID E FNTP_ID: "
										+ registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4());
						throw new ControladorException("erro.sistema");
					}

					// [UC0108 - Obter Quantidade de Economias por Categoria]
					Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
					if(Util.isVazioOrNulo(colecaoCategoriasImovel)){
						colecaoCategoriasImovel = new ArrayList();
						Categoria categoria = new Categoria(Categoria.RESIDENCIAL);
						categoria.setQuantidadeEconomiasCategoria(1);
						colecaoCategoriasImovel.add(categoria);
					}
					Collection valoresCategoriasImovel = getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
									valorPagamento);
					Iterator<Categoria> iteratorCategoriasImovel = colecaoCategoriasImovel.iterator();
					Iterator<BigDecimal> iteratorValoresCategoriasImovell = valoresCategoriasImovel.iterator();
					GuiaPagamentoCategoriaPK guiaPagamentoCategoriaPK = null;
					GuiaPagamentoCategoria guiaPagamentoCategoria = null;
					Categoria categoria = null;
					while(iteratorCategoriasImovel.hasNext()){
						categoria = iteratorCategoriasImovel.next();
						guiaPagamentoCategoriaPK = new GuiaPagamentoCategoriaPK(categoria.getId(), guiaPagamento.getId(), debitoTipo
										.getLancamentoItemContabil().getId(), (short) 1);
						guiaPagamentoCategoria = new GuiaPagamentoCategoria(guiaPagamentoCategoriaPK);
						guiaPagamentoCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
						guiaPagamentoCategoria.setValorCategoria(iteratorValoresCategoriasImovell.next());
						guiaPagamentoCategoria.setUltimaAlteracao(new Date());
						getControladorUtil().inserir(guiaPagamentoCategoria);
					}
					Collection<ClienteImovel> colecaoClientesImovel = getControladorImovel().pesquisarClientesImovel(imovel.getId());
					ClienteGuiaPagamento clienteGuiaPagamento = null;
					if(!Util.isVazioOrNulo(colecaoClientesImovel)){
						for(ClienteImovel clienteImovel : colecaoClientesImovel){
							clienteGuiaPagamento = new ClienteGuiaPagamento(clienteImovel.getCliente(),
											clienteImovel.getClienteRelacaoTipo(), guiaPagamento);
							clienteGuiaPagamento.setUltimaAlteracao(new Date());
							getControladorUtil().inserir(clienteGuiaPagamento);
						}
					}
					Pagamento pagamento = new Pagamento();
					if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
						pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
					}else{
						pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
					}
					pagamento.setValorPagamento(valorPagamento);
					pagamento.setDataPagamento(dataPagamento);
					pagamento.setDebitoTipo(debitoTipo);
					pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
					pagamento.setLocalidade(imovel.getLocalidade());
					pagamento.setDocumentoTipo(documentoTipoGuiaPagamento);
					pagamento.setImovel(imovel);
					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
					arrecadacaoForma.setId(idFormaPagamento);
					pagamento.setArrecadacaoForma(arrecadacaoForma);
					pagamento.setUltimaAlteracao(new Date());
					pagamento.setNumeroPrestacao(1);
					colecaoPagamentos.add(pagamento);

					/**
					 * Início - Alteração solicitada na CR111262
					 * Luciano Galvão - 21/03/2012
					 */

					// [UC0259]:[SB0019] - Verificar Nota de Recebimento do Programa Água para Todos
					verificarNotaRecebimentoAguaParaTodos(registroHelperCodigoBarras, imovel);
					/**
					 * Fim - Alteração solicitada na CR111262
					 * Luciano Galvão - 21/03/2012
					 */
				}else{
					indicadorAceitacaoRegistro = "2";
				}
			}else if(tipoPagamento == PagamentoTipo.PAGAMENTO_TIPO_LEGADO_CONTA_SEGUNDA_VIA_DESO){

				descricaoOcorrencia = this.validarMatriculaImovel(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
								.getIdPagamento1());
				boolean anoMesReferencia = Util.validarValorNaoNumerico(registroHelperCodigoBarras
								.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());

				if(anoMesReferencia){

					// valida o namo mes de referencia da conta
					descricaoOcorrencia = "ANO/MÊS DE REFERÊNCIA DA CONTA INVÁLIDA";
				}

				if(descricaoOcorrencia.equals("OK")){
					Integer idConta = null;

					// Valida o ano mes de referencia da conta
					int anoMesReferenciaInt = Util.formatarMesAnoParaAnoMes(Util.obterInteger(registroHelperCodigoBarras
									.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2()));

					Imovel imovel = repositorioArrecadacao
									.pesquisarImovelCodigoBarrasLegadoDESO(Util.obterInteger(registroHelperCodigoBarras
													.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1()));

					try{

						// Verifica a existência de conta para o ano/mês referência
						idConta = repositorioFaturamento.pesquisarExistenciaContaComSituacaoAtualLegadoDESO(imovel, anoMesReferenciaInt);

						if(idConta == null){

							// Tenta encontrar referência em histórico
							idConta = repositorioFaturamento.pesquisarExistenciaContaHistoricoComSituacaoAtualLegadoDESO(imovel,
											anoMesReferenciaInt);

							if(idConta == null){

								descricaoOcorrencia = "CONTA INEXISTENTE";
							}
						}

					}catch(ErroRepositorioException e){

						e.printStackTrace();
						throw new ControladorException("erro.sistema", e);
					}

					Pagamento pagamento = new Pagamento();
					pagamento.setAnoMesReferenciaPagamento(anoMesReferenciaInt);
					if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
						pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
					}else{
						pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
					}
					pagamento.setValorPagamento(valorPagamento);
					pagamento.setDataPagamento(dataPagamento);
					if(idConta != null){
						Conta conta = new Conta();
						conta.setId(idConta);
						pagamento.setConta(conta);
					}else{
						pagamento.setConta(null);
					}
					if(idConta != null){

						// Mudança na forma de consulta para melhorar performance
						Integer idLocalidade = repositorioFaturamento.obterIdLocalidadePorConta(idConta);
						if(idLocalidade != null){
							Localidade loc = new Localidade();
							loc.setId(idLocalidade);
							pagamento.setLocalidade(loc);
						}else{
							idLocalidade = repositorioFaturamento.obterIdLocalidadePorContaHistorico(idConta);
							if(idLocalidade != null){
								Localidade loc = new Localidade();
								loc.setId(idLocalidade);
								pagamento.setLocalidade(loc);
							}
						}

					}else{
						pagamento.setLocalidade(imovel.getLocalidade());
					}

					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.CONTA);
					pagamento.setDocumentoTipo(documentoTipo);
					pagamento.setImovel(imovel);
					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
					arrecadacaoForma.setId(idFormaPagamento);
					pagamento.setArrecadacaoForma(arrecadacaoForma);
					pagamento.setUltimaAlteracao(new Date());
					colecaoPagamentos.add(pagamento);
				}else{
					indicadorAceitacaoRegistro = "2";
				}
			}else if(tipoPagamento == PagamentoTipo.PAGAMENTO_TIPO_LEGADO_AVISO_CORTE_DEBITO_DESO
							|| tipoPagamento == PagamentoTipo.PAGAMENTO_TIPO_LEGADO_CONTA_AGRUPADAS_DESO){

				descricaoOcorrencia = this.validarMatriculaImovel(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
								.getIdPagamento1());

				if(descricaoOcorrencia.equals("OK")){
					Integer idImovel = Util.obterInteger(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
									.getIdPagamento1());
					Integer numeroSequencialDocumento = Util.obterInteger(registroHelperCodigoBarras
									.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
					CobrancaDocumento cobrancaDocumento = repositorioArrecadacao.pesquisarDocumentoCobrancaPorImovelSequencial(idImovel,
									numeroSequencialDocumento);
					if(cobrancaDocumento != null){
						Imovel imovel = repositorioArrecadacao.pesquisarImovelCodigoBarrasLegadoDESO(Util
										.obterInteger(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
														.getIdPagamento1()));
						BigDecimal valorAcrescimo = BigDecimal.ZERO;
						if(cobrancaDocumento.getValorAcrescimos() != null){
							valorAcrescimo = cobrancaDocumento.getValorAcrescimos();
						}
						if(valorAcrescimo.compareTo(BigDecimal.ZERO) == 1){
							this.alterarVencimentoItensDocumentoCobranca(cobrancaDocumento.getId(), dataPagamento);
						}
						BigDecimal valorDesconto = BigDecimal.ZERO;
						if(cobrancaDocumento.getValorDesconto() != null){
							valorDesconto = cobrancaDocumento.getValorDesconto();
						}
						if(valorAcrescimo.compareTo(valorDesconto) == 1){
							valorAcrescimo = valorAcrescimo.subtract(valorDesconto);
							valorDesconto = BigDecimal.ZERO;
						}else{
							valorDesconto = valorDesconto.subtract(valorAcrescimo);
							valorAcrescimo = BigDecimal.ZERO;
						}
						if(valorAcrescimo.compareTo(BigDecimal.ZERO) == 1){
							this.processarRecebimentoAcrescimosImpontualidade(cobrancaDocumento.getId(), dataPagamento, valorPagamento,
											idImovel, imovel.getLocalidade().getId(), sistemaParametro, idFormaPagamento);
						}
						if(valorDesconto.compareTo(BigDecimal.ZERO) == 1){
							this.processarDescontoConcedidoDocumentoCobranca(cobrancaDocumento.getId(), dataPagamento, valorPagamento,
											idImovel, imovel.getLocalidade().getId(), sistemaParametro, idFormaPagamento);
						}
						if(cobrancaDocumento.getValorTaxa().compareTo(BigDecimal.ZERO) == 1){
							this.processarTaxaDocumentoCobranca(cobrancaDocumento.getId(), dataPagamento, cobrancaDocumento.getValorTaxa(),
											idImovel, imovel.getLocalidade().getId(), sistemaParametro, idFormaPagamento);
						}
						Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItem = repositorioArrecadacao
										.pesquisarCobrancaDocumentoItem(cobrancaDocumento.getId());
						GuiaPagamentoPrestacao guiaPagamentoPrestacao = null;
						GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = null;
						if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){
							Pagamento pagamento = null;
							for(CobrancaDocumentoItem cobrancaDocumentoItem : colecaoCobrancaDocumentoItem){
								pagamento = new Pagamento();
								if(cobrancaDocumentoItem.getContaGeral() != null){
									if(ConstantesSistema.NAO.equals(cobrancaDocumentoItem.getContaGeral().getIndicadorHistorico())){
										pagamento.setAnoMesReferenciaPagamento(cobrancaDocumentoItem.getContaGeral().getConta()
														.getReferencia());
									}else{
										pagamento.setAnoMesReferenciaPagamento(cobrancaDocumentoItem.getContaGeral().getContaHistorico()
														.getAnoMesReferenciaConta());
									}
								}
								if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
									pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
								}else{
									pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
								}
								pagamento.setValorPagamento(cobrancaDocumentoItem.getValorItemCobrado());
								pagamento.setDataPagamento(dataPagamento);
								if(cobrancaDocumentoItem.getContaGeral() == null){
									if(cobrancaDocumentoItem.getGuiaPagamentoGeral() != null){
										if(ConstantesSistema.NAO.equals(cobrancaDocumentoItem.getGuiaPagamentoGeral()
														.getIndicadorHistorico())){
											guiaPagamentoPrestacao = repositorioArrecadacao.pesquisarGuiaPagamentoPrestacao(
															cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento().getId(),
															cobrancaDocumentoItem.getNumeroDaPrestacao().intValue());
											pagamento.setDebitoTipo(guiaPagamentoPrestacao.getDebitoTipo());
										}else{
											guiaPagamentoPrestacaoHistorico = repositorioArrecadacao
															.pesquisarGuiaPagamentoHistoricoPrestacao(cobrancaDocumentoItem
																			.getGuiaPagamentoGeral().getGuiaPagamentoHistorico().getId(),
																			cobrancaDocumentoItem.getNumeroDaPrestacao().intValue());
											pagamento.setDebitoTipo(guiaPagamentoPrestacaoHistorico.getDebitoTipo());
										}
									}
								}
								if(cobrancaDocumentoItem.getContaGeral() != null
												&& ConstantesSistema.NAO.equals(cobrancaDocumentoItem.getContaGeral()
																.getIndicadorHistorico())){
									pagamento.setConta(cobrancaDocumentoItem.getContaGeral().getConta());
								}

								if(cobrancaDocumentoItem.getGuiaPagamentoGeral() != null
												&& ConstantesSistema.NAO.equals(cobrancaDocumentoItem.getGuiaPagamentoGeral()
																.getIndicadorHistorico())){
									pagamento.setGuiaPagamentoGeral(cobrancaDocumentoItem.getGuiaPagamentoGeral());
								}
								if(cobrancaDocumentoItem.getDebitoACobrarGeral() != null
												&& ConstantesSistema.NAO.equals(cobrancaDocumentoItem.getDebitoACobrarGeral()
																.getIndicadorHistorico())){
									DebitoACobrar debitoACobrar = cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar();
									debitoACobrar.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.PAGA));
									getControladorUtil().atualizar(debitoACobrar);
									pagamento.setDebitoACobrar(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar());
								}
								DocumentoTipo documentoTipo = new DocumentoTipo();
								if(cobrancaDocumentoItem.getContaGeral() != null){
									if(ConstantesSistema.NAO.equals(cobrancaDocumentoItem.getContaGeral().getIndicadorHistorico())){
										pagamento.setLocalidade(cobrancaDocumentoItem.getContaGeral().getConta().getLocalidade());
										pagamento.setImovel(cobrancaDocumentoItem.getContaGeral().getConta().getImovel());
									}else{
										pagamento.setLocalidade(cobrancaDocumentoItem.getContaGeral().getContaHistorico().getLocalidade());
										pagamento.setImovel(cobrancaDocumentoItem.getContaGeral().getContaHistorico().getImovel());
									}
									documentoTipo.setId(DocumentoTipo.CONTA);
									pagamento.setDocumentoTipo(documentoTipo);
								}else if(cobrancaDocumentoItem.getDebitoACobrarGeral() != null
												&& cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar() != null){
									if(ConstantesSistema.NAO.equals(cobrancaDocumentoItem.getDebitoACobrarGeral().getIndicadorHistorico())){
										pagamento.setLocalidade(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar()
														.getLocalidade());
										pagamento.setImovel(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getImovel());
									}else{
										pagamento.setLocalidade(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrarHistorico()
														.getLocalidade());
										pagamento.setImovel(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrarHistorico()
														.getImovel());
									}
									documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
									pagamento.setDocumentoTipo(documentoTipo);
								}else if(cobrancaDocumentoItem.getGuiaPagamentoGeral() != null){
									if(ConstantesSistema.NAO.equals(cobrancaDocumentoItem.getGuiaPagamentoGeral().getIndicadorHistorico())){
										pagamento.setLocalidade(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento()
														.getLocalidade());
										pagamento.setImovel(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento().getImovel());
									}else{
										pagamento.setLocalidade(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamentoHistorico()
														.getLocalidade());
										pagamento.setImovel(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamentoHistorico()
														.getImovel());
									}
									documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
									pagamento.setDocumentoTipo(documentoTipo);
								}else{
									pagamento.setLocalidade(imovel.getLocalidade());
								}

								ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
								arrecadacaoForma.setId(idFormaPagamento);
								pagamento.setArrecadacaoForma(arrecadacaoForma);
								pagamento.setUltimaAlteracao(new Date());

								if(cobrancaDocumentoItem.getGuiaPagamentoGeral() != null){
									pagamento.setNumeroPrestacao(cobrancaDocumentoItem.getNumeroDaPrestacao().intValue());
								}

								colecaoPagamentos.add(pagamento);
							}
						}
					}else{
						descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
						indicadorAceitacaoRegistro = "2";
					}
				}else{
					indicadorAceitacaoRegistro = "2";
				}
			}else if(tipoPagamento == PagamentoTipo.PAGAMENTO_TIPO_LEGADO_CARNE_DESO){

				if(!Util.isInteger(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1())){
					descricaoOcorrencia = "NÚMERO DO CARNÊ NÃO NUMÉRICO";
				}
				if(!Util.isInteger(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2())){
					descricaoOcorrencia = "NÚMERO DA PARCELA NÃO NUMÉRICO";
				}
				if(descricaoOcorrencia.equals("OK")){
					GuiaPagamento guiaPagamento = repositorioArrecadacao.pesquisarGuiaPagamentoNormalRetificadaIncluidaEntradaParcelamento(
									Util.obterInteger(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
													.getIdPagamento1()), Util.obterInteger(registroHelperCodigoBarras
													.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2()));
					if(guiaPagamento == null){
						descricaoOcorrencia = "GUIA DE PAGAMENTO INEXISTENTE";
						indicadorAceitacaoRegistro = "2";
					}else{
						Pagamento pagamento = new Pagamento();
						if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
							pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
						}else{
							pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
						}
						pagamento.setValorPagamento(valorPagamento);
						pagamento.setDataPagamento(dataPagamento);
						GuiaPagamentoPrestacao guiaPagamentoPrestacao = repositorioArrecadacao.pesquisarGuiaPagamentoPrestacao(
										guiaPagamento.getId(), Util.obterInteger(registroHelperCodigoBarras
														.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2()));

						if(guiaPagamentoPrestacao != null){
							// [SB0017 – Gerar boletos bancários para prestações de guia de
							// pagamento].
							this.gerarBoletoBancarioParaPrestacoesGuiaPagamento(guiaPagamentoPrestacao.getComp_id().getGuiaPagamentoId(),
											guiaPagamentoPrestacao.getComp_id().getNumeroPrestacao());
						}

						pagamento.setDebitoTipo(guiaPagamentoPrestacao.getDebitoTipo());
						pagamento.setNumeroPrestacao(guiaPagamentoPrestacao.getComp_id().getNumeroPrestacao().intValue());
						pagamento.setImovel(guiaPagamento.getImovel());
						pagamento.setLocalidade(guiaPagamento.getLocalidade());
						GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
						guiaPagamentoGeral.setId(guiaPagamento.getId());
						guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);
						pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
						DocumentoTipo documentoTipoGuiaPagamento = new DocumentoTipo();
						documentoTipoGuiaPagamento.setId(DocumentoTipo.GUIA_PAGAMENTO);
						pagamento.setDocumentoTipo(documentoTipoGuiaPagamento);

						ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
						arrecadacaoForma.setId(idFormaPagamento);
						pagamento.setArrecadacaoForma(arrecadacaoForma);
						pagamento.setUltimaAlteracao(new Date());

						colecaoPagamentos.add(pagamento);
					}
				}else{
					indicadorAceitacaoRegistro = "2";
				}
			}
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259]:[SB0019] - Verificar Nota de Recebimento do Programa Água para Todos
	 * 
	 * @param registroHelperCodigoBarras
	 * @param imovel
	 * @throws ControladorException
	 */
	private void verificarNotaRecebimentoAguaParaTodos(RegistroHelperCodigoBarras registroHelperCodigoBarras, Imovel imovel)
					throws ControladorException{

		String codigoServico = registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4();

		String paramCodigoServico = ParametroArrecadacao.P_IDENTIFICACAO_DEBITO_TIPO_PROGRAMA_AGUA_PARA_TODOS.executar();

		// Recupera usuário batch
		String paramUsuarioBatch = ParametroGeral.P_USUARIO_BATCH.executar();

		FiltroUsuario filtroUsuario = new FiltroUsuario();
		filtroUsuario.adicionarParametro(new ParametroSimples(FiltroUsuario.ID, Util.obterInteger(paramUsuarioBatch)));

		Collection colUsuarios = getControladorUtil().pesquisar(filtroUsuario, Usuario.class.getName());
		Usuario usuario = null;

		if((colUsuarios != null) && (!colUsuarios.isEmpty())){
			usuario = (Usuario) colUsuarios.iterator().next();
		}

		if((codigoServico != null) && (paramCodigoServico != null) && (!paramCodigoServico.equals("-1"))
						&& (codigoServico.equals(paramCodigoServico))){

			// [UC0259]:[SB0021] - Habilitar Programa Água para Todos
			// Luciano Galvão - 21/03/2012
			habilitarProgramaAguaParaTodos(imovel, usuario);

		}
	}

	/**
	 * [UC0259]:[SB0019] - Verificar Nota de Recebimento do Programa Água para Todos
	 * 
	 * @param registroHelperCodigoBarras
	 * @param imovel
	 * @throws ControladorException
	 */
	private void verificarGuiaPagamentoAguaParaTodos(GuiaPagamentoPrestacao guiaPagamentoPrestacao) throws ControladorException{

		String paramTipoDebitoProgramaAguaParaTodos = ParametroArrecadacao.P_IDENTIFICACAO_DEBITO_TIPO_PROGRAMA_AGUA_PARA_TODOS.executar();

		if((guiaPagamentoPrestacao.getDebitoTipo() != null)
						&& (guiaPagamentoPrestacao.getDebitoTipo().getId().equals(Util.obterInteger(paramTipoDebitoProgramaAguaParaTodos)))
						&& (!paramTipoDebitoProgramaAguaParaTodos.equals("-1"))){

			if(guiaPagamentoPrestacao.getGuiaPagamento() != null){

				FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
				filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, guiaPagamentoPrestacao
								.getGuiaPagamento().getId()));

				GuiaPagamento guiaPagamento = null;

				Collection<GuiaPagamento> colecaoGuias = getControladorUtil().pesquisar(filtroGuiaPagamento, GuiaPagamento.class.getName());

				if((colecaoGuias != null) && (!colecaoGuias.isEmpty())){
					guiaPagamento = colecaoGuias.iterator().next();
				}

				Imovel imovel = guiaPagamento.getImovel();

				if(imovel != null){
					// Recupera o imóvel
					FiltroImovel filtroImovel = new FiltroImovel();
					filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
					imovel = (Imovel) getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()).iterator().next();

					// Recupera usuário batch
					String paramUsuarioBatch = ParametroGeral.P_USUARIO_BATCH.executar();

					FiltroUsuario filtroUsuario = new FiltroUsuario();
					filtroUsuario.adicionarParametro(new ParametroSimples(FiltroUsuario.ID, Util.obterInteger(paramUsuarioBatch)));

					Collection colUsuarios = getControladorUtil().pesquisar(filtroUsuario, Usuario.class.getName());
					Usuario usuario = null;

					if((colUsuarios != null) && (!colUsuarios.isEmpty())){
						usuario = (Usuario) colUsuarios.iterator().next();
					}

					// [UC0259]:[SB0021] - Habilitar Programa Água para Todos
					// Luciano Galvão - 21/03/2012
					habilitarProgramaAguaParaTodos(imovel, usuario);
				}
			}
		}
	}

	/**
	 * [UC0259]:[SB0021] - Habilitar Programa Água para Todos
	 * 
	 * @param imovel
	 * @param usuario
	 * @throws ControladorException
	 */
	private void habilitarProgramaAguaParaTodos(Imovel imovel, Usuario usuario) throws ControladorException{

		// Recupera as contas do imóvel com motivo de revisão relacionado ao
		// programa água para todos
		Integer paramMotivoRevisao = Util.obterInteger(ParametroArrecadacao.P_MOTIVO_REVISAO_PROGRAMA_AGUA_PARA_TODOS.executar());

		FiltroConta filtroConta = new FiltroConta();
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.CONTA_MOTIVO_REVISAO_ID, paramMotivoRevisao));
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, imovel.getId()));

		Collection<Conta> contas = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

		if((contas != null) && (!contas.isEmpty())){

			// Cria uma String com os identificadores no formato
			// "<idConta>-,<idConta>-,<idConta>-". Esta String será passada como
			// parâmetro para o método que cancela uma conta
			String identificadores = "";

			for(Conta conta : contas){
				identificadores += conta.getId() + "-,";
			}

			// Retira a "," do final da String
			identificadores = identificadores.substring(0, identificadores.length() - 1);

			// Realiza o cancelamento da Conta
			Integer paramMotivoCancelamento = Util.obterInteger(ParametroArrecadacao.P_MOTIVO_CANCELAMENTO_PROGRAMA_AGUA_PARA_TODOS
							.executar());

			// Recupera o motivo de cancelamento
			FiltroContaMotivoCancelamento filtroMotivoCancelamento = new FiltroContaMotivoCancelamento();
			filtroMotivoCancelamento
							.adicionarParametro(new ParametroSimples(FiltroContaMotivoCancelamento.CODIGO, paramMotivoCancelamento));

			ContaMotivoCancelamento motivoCancelamento = (ContaMotivoCancelamento) getControladorUtil()
							.pesquisar(filtroMotivoCancelamento, ContaMotivoCancelamento.class.getName()).iterator().next();

			// Inclui o [UC0147]: Cancelar Conta
			getControladorFaturamento().cancelarConta(contas, identificadores, motivoCancelamento, usuario, null);
		}

		// Verifica se o imóvel está hapto a ser habilitado no programa água para
		// todos
		FiltroImovelAguaParaTodos filtroImovelAguaParaTodos = new FiltroImovelAguaParaTodos();
		filtroImovelAguaParaTodos.adicionarParametro(new ParametroSimples(FiltroImovelAguaParaTodos.ID_IMOVEL, imovel.getId()));
		filtroImovelAguaParaTodos.adicionarParametro(new ParametroSimples(FiltroImovelAguaParaTodos.CODIGO_SITUACAO,
						ImovelAguaParaTodos.CADASTRADO));

		Collection<ImovelAguaParaTodos> imoveisAguaParaTodos = getControladorUtil().pesquisar(filtroImovelAguaParaTodos,
						ImovelAguaParaTodos.class.getName());

		if((imoveisAguaParaTodos != null) && (!imoveisAguaParaTodos.isEmpty())){
			ImovelAguaParaTodos imovelAguaParaTodos = imoveisAguaParaTodos.iterator().next();

			Long idContribuinte = imovelAguaParaTodos.getIdContribuinte();
			Date dataExclusao = imovelAguaParaTodos.getDataExclusao();

			if((idContribuinte != null) && (idContribuinte.longValue() != 0) && (dataExclusao == null)){

				// Habilita o imóvel no programa Água para Todos
				getControladorCadastro().habilitarImovelAguaParaTodos(imovelAguaParaTodos, imovel, usuario);

			}
		}
	}

	private String validarMatriculaImovel(String matriculaImovel) throws ControladorException{

		String descricaoOcorrencia = "OK";
		boolean matriculaImovelInvalida = Util.validarValorNaoNumerico(matriculaImovel);

		if(matriculaImovelInvalida){
			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";
		}else{

			/*
			 * Verifica se existe a matricula do imóvel na base
			 */
			Integer idImovelNaBase = null;

			try{
				idImovelNaBase = repositorioImovel.recuperarMatriculaImovel(Util.obterInteger(matriculaImovel));
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			/*
			 * Se o id do imovel pesquisado na base for diferente de nulo
			 */
			if(idImovelNaBase == null){
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}
		return descricaoOcorrencia;
	}

	private String validarLocalidade(String codigoLocalidade, String descricaoOcorrencia){

		if(!Util.isInteger(codigoLocalidade)){
			descricaoOcorrencia = "CÓDIGO DA LOCALIDADE NÃO NUMÉRICA";
		}
		return descricaoOcorrencia;

	}

	private String validarCodigoServico(String codigoServico, String descricaoOcorrencia) throws ControladorException{

		if(!Util.isInteger(codigoServico)){
			descricaoOcorrencia = "CÓDIGO DO SERVIÇO NÃO NUMÉRICO";
		}else{
			if(getControladorUtil().pesquisar(Util.obterInteger(codigoServico), ServicoTipo.class, false) == null){
				descricaoOcorrencia = "CÓDIGO DO SERVIÇO INEXISTENTE";
			}
		}
		return descricaoOcorrencia;

	}

	// ----------

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * Método responsável por montar os helpers utilizado na Consulta dos Itens do Movimento
	 * Arrecadador
	 * Método foi reescrito para adequar situação de tratamento dos Tipos de Pagamentos originais de
	 * Sistema
	 * Legado. Tratamento realizado apenas no Tipo 'G'
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author eduardo henrique
	 * @data 20/12/2008
	 * @param arrecadadorMovimentoItem
	 * @return arrecadadorMovimentoItemHelper
	 * @throws ControladorException
	 */
	protected ArrecadadorMovimentoItemHelper montarHelperArrecadadorMovimentoItem(ArrecadadorMovimentoItem arrecadadorMovimentoItem,
					String descricaoAjuste)
					throws ControladorException{

		String SEPARADOR_IDENTIFICACAO = "-";

		if(arrecadadorMovimentoItem == null){
			return null;
		}

		ArrecadadorMovimentoItemHelper arrecadadorMovimentoItemHelper = new ArrecadadorMovimentoItemHelper();

		// AJUSTE
		if(descricaoAjuste != null){
			if(descricaoAjuste.equals("")){
				arrecadadorMovimentoItemHelper.setAjustado("NÃO");
			}else{
				arrecadadorMovimentoItemHelper.setAjustado("SIM");
			}
			arrecadadorMovimentoItemHelper.setNvDescricaoOcorrencia(descricaoAjuste);
		}

		arrecadadorMovimentoItemHelper.setId(arrecadadorMovimentoItem.getId());

		/*
		 * (RGCD_CDREGISTROCODIGO da tabela REGISTRO_CODIGO com RGCD_ID =
		 * RGCD_ID da tabela ARRECADADOR_MOVIMENTO_ITEM)
		 */
		if(arrecadadorMovimentoItem.getRegistroCodigo() != null){
			arrecadadorMovimentoItemHelper.setCodigoRegistro(arrecadadorMovimentoItem.getRegistroCodigo().getCodigo());
		}

		/*
		 * Caso o código do registro corresponda a "B", "C", "E" ou "F",
		 * exibir a identificação do cliente na empresa retornada pelo
		 * [UC0262]
		 */
		if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_B)){

			arrecadadorMovimentoItemHelper.setTipoMovimento(ArrecadadorMovimentoItemHelper.TIPO_MOVIMENTO_DEBITO_AUTOMATICO);

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoB registroHelperCodigoB = (RegistroHelperCodigoB) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItem.getConteudoRegistro(), null);

			arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoB.getIdClienteEmpresa());
			arrecadadorMovimentoItemHelper.setRegistroHelperCodigoB(registroHelperCodigoB);
		}else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_C)){

			arrecadadorMovimentoItemHelper.setTipoMovimento(ArrecadadorMovimentoItemHelper.TIPO_MOVIMENTO_DEBITO_AUTOMATICO);

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItem.getConteudoRegistro(), null);

			arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoC.getIdClienteEmpresa());
			arrecadadorMovimentoItemHelper.setRegistroHelperCodigoC(registroHelperCodigoC);

		}else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_E)){

			arrecadadorMovimentoItemHelper.setTipoMovimento(ArrecadadorMovimentoItemHelper.TIPO_MOVIMENTO_DEBITO_AUTOMATICO);

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoE registroHelperCodigoE = (RegistroHelperCodigoE) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItem.getConteudoRegistro(), null);

			arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoE.getIdClienteEmpresa());
			arrecadadorMovimentoItemHelper.setRegistroHelperCodigoE(registroHelperCodigoE);

		}else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_F)){

			arrecadadorMovimentoItemHelper.setTipoMovimento(ArrecadadorMovimentoItemHelper.TIPO_MOVIMENTO_DEBITO_AUTOMATICO);

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoF registroHelperCodigoF = (RegistroHelperCodigoF) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItem.getConteudoRegistro(), null);

			if(!Util.isVazioOuBranco(registroHelperCodigoF.getAnoMesReferenciaConta())
							&& !registroHelperCodigoF.getAnoMesReferenciaConta().equals("000000")){
				arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_CONTA);
				arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoF.getIdClienteEmpresa() + SEPARADOR_IDENTIFICACAO
								+ Util.formatarAnoMesParaMesAno(registroHelperCodigoF.getAnoMesReferenciaConta()));
			}else{
				arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_GUIA_PAGAMENTO);
				arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigoF.getIdClienteEmpresa() + SEPARADOR_IDENTIFICACAO
								+ registroHelperCodigoF.getIdentificacaoGuia() + SEPARADOR_IDENTIFICACAO
								+ registroHelperCodigoF.getNumeroParcela());
			}

			arrecadadorMovimentoItemHelper.setRegistroHelperCodigoF(registroHelperCodigoF);

			int tamanho = registroHelperCodigoF.getValorDebito().length();

			String valorDebito = registroHelperCodigoF.getValorDebito().substring(0, (tamanho - 2)) + "."
							+ registroHelperCodigoF.getValorDebito().substring((tamanho - 2), tamanho);

			arrecadadorMovimentoItemHelper.setVlMovimento(Util.formatarMoedaReal(new BigDecimal(valorDebito)));
		}

		/*
		 * Caso o código do registro corresponda a "G"
		 * Distribui os dados do código de barras [UC0264] - Distribuir
		 * Dados co Código de Barras passando o código de barras
		 * retornado pelo [UC0262]- Distribuir Dados do Registro de
		 * Movimento do Arrecadador.
		 * Exibir o tipo de pagamento retornado pelo [UC0262] -
		 * Distribuir Dados co Código de Barras
		 */
		else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_G)){

			arrecadadorMovimentoItemHelper.setTipoMovimento(ArrecadadorMovimentoItemHelper.TIPO_MOVIMENTO_CODIGO_BARRAS);

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) this.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItem.getConteudoRegistro(), null);

			arrecadadorMovimentoItemHelper.setRegistroHelperCodigoG(registroHelperCodigoG);

			int tamanho = registroHelperCodigoG.getValorRecebido().length();

			if(Util.isNumero(registroHelperCodigoG.getValorRecebido().substring(0, (tamanho - 2)), false, 0)
							&& Util.isNumero(registroHelperCodigoG.getValorRecebido().substring((tamanho - 2), tamanho), false, 0)){

				String valorRecebido = registroHelperCodigoG.getValorRecebido().substring(0, (tamanho - 2)) + "."
								+ registroHelperCodigoG.getValorRecebido().substring((tamanho - 2), tamanho);
				arrecadadorMovimentoItemHelper.setVlMovimento(Util.formatarMoedaReal(new BigDecimal(valorRecebido)));
			}

			RegistroHelperCodigoBarrasTipoPagamento codigoBarrasTipoPagamento = registroHelperCodigoG.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento();

			// Tratamento dos tipos originais do Legado ADA e DESO
			if(registroHelperCodigoG.getRegistroHelperCodigoBarras().isLegado()){

				if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA_ADA)){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ Util.formatarAnoMesParaMesAno(codigoBarrasTipoPagamento.getIdPagamento2()));

					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_CONTA);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_PARCELA_ADA)
								|| registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
												.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_TAXAS_DIVERSAS_ADA)){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento2() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_GUIA_PAGAMENTO_IMOVEL);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_ADA)){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento2() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper
									.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_IMOVEL);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_LEGADO_CONTA_SEGUNDA_VIA_DESO)){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ Util.formatarAnoMesParaMesAno(codigoBarrasTipoPagamento.getIdPagamento2()));

					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_CONTA);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_LEGADO_AVISO_CORTE_DEBITO_DESO)){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento2() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper
									.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_IMOVEL);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_LEGADO_CONTA_AGRUPADAS_DESO)){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ Util.formatarAnoMesParaMesAno(codigoBarrasTipoPagamento.getIdPagamento2()));
					arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_LEGADO_CONTAS_AGRUPADAS_DESO);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_LEGADO_CARNE_DESO)){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ Util.formatarAnoMesParaMesAno(codigoBarrasTipoPagamento.getIdPagamento2()));
					arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_LEGADO_CARNE_DESO);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_LEGADO_NOTA_RECEBIMENTO_DESO)){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento2());
					arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_LEGADO_NOTA_RECEBIMENTO_DESO);
				}

			}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento() != null){

				/*
				 * Caso o tipo de pagamento corresponda a: Conta (valor =
				 * 3), Guia de Pagamento (valor = 4) ou Documento de
				 * Cobrança (valor = 5), exibir a matrícula do imóvel
				 * retornada pelo [UC0264]
				 */
				if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA))){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ Util.formatarMesAnoSemBarraParaMesAnoComBarra(codigoBarrasTipoPagamento.getIdPagamento2()));

					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_CONTA);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO))){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento2() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_GUIA_PAGAMENTO_IMOVEL);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_CLIENTE))){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento2() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_GUIA_PAGAMENTO_CLIENTE);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA))){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento2() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper
									.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_IMOVEL);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_CLIENTE))){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento2() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper
									.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_CLIENTE);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL))){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper
									.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_NOTA_RECEBIMENTO))){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento1() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento4());

					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_NOTA_RECEBIMENTO);

				}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento()
								.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_PRE_PARCELAMENTO))){

					arrecadadorMovimentoItemHelper.setIdentificacao(codigoBarrasTipoPagamento.getIdPagamento2() + SEPARADOR_IDENTIFICACAO
									+ codigoBarrasTipoPagamento.getIdPagamento3());

					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_PRE_PARCELAMENTO);

				}else{
					System.out.println("MovimenentoArrecadador: " + arrecadadorMovimentoItem.getArrecadadorMovimento().getId() + "Item : "
									+ arrecadadorMovimentoItemHelper.getId() + "  Tipo Pagamento : "
									+ registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento().toString());

					arrecadadorMovimentoItemHelper.setIdentificacao("");
					arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_NAO_IDENTIFICADO);

				}

			}else if(registroHelperCodigoG.getRegistroHelperCodigoBarras().getTipoPagamento() == null){
				arrecadadorMovimentoItemHelper.setIdentificacao("");
				arrecadadorMovimentoItemHelper.setTipoPagamento(ArrecadadorMovimentoItemHelper.TIPO_PAGAMENTO_NAO_IDENTIFICADO);
			}

		}else if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_3)){

			arrecadadorMovimentoItemHelper.setTipoMovimento(ArrecadadorMovimentoItemHelper.TIPO_MOVIMENTO_COBRANCA_BANCARIA);

			// Tratamento para os tipos de ficha de compensação e boleto bancário
			Object registroHelperCodigo = this.distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(arrecadadorMovimentoItem
							.getConteudoRegistro().substring(0, 240), null);

			if(registroHelperCodigo instanceof RegistroHelperCodigo3T){

				RegistroHelperCodigo3T registroHelperCodigo3T = (RegistroHelperCodigo3T) registroHelperCodigo;

				RegistroHelperCodigo3U registroHelperCodigo3U = (RegistroHelperCodigo3U) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
								arrecadadorMovimentoItem.getConteudoRegistro().substring(240, 480), null);

				arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigo3T.getNossoNumero());

				// Setando o Tipo de pagamento
				arrecadadorMovimentoItemHelper.setTipoPagamento("BOLETO");

				// Setando a Identificação
				String identificacao = registroHelperCodigo3T.getTituloMatriculaImovel() + SEPARADOR_IDENTIFICACAO
								+ registroHelperCodigo3T.getTituloNumeroDocumento();

				if(!Util.isVazioOuBranco(registroHelperCodigo3T.getTituloNumeroPrestacao())
								&& !registroHelperCodigo3T.getTituloNumeroPrestacao().equals("000")){
					identificacao = identificacao + SEPARADOR_IDENTIFICACAO + registroHelperCodigo3T.getTituloNumeroPrestacao();
				}

				arrecadadorMovimentoItemHelper.setIdentificacao(identificacao);

				int tamanho = registroHelperCodigo3U.getValorPagoSacado().length();

				if(Util.isNumero(registroHelperCodigo3U.getValorPagoSacado().substring(0, (tamanho - 2)), false, 0)
								&& Util.isNumero(registroHelperCodigo3U.getValorPagoSacado().substring((tamanho - 2), tamanho), false, 0)){

					String valorRecebido = registroHelperCodigo3U.getValorPagoSacado().substring(0, (tamanho - 2)) + "."
									+ registroHelperCodigo3U.getValorPagoSacado().substring((tamanho - 2), tamanho);
					arrecadadorMovimentoItemHelper.setVlMovimento(Util.formatarMoedaReal(new BigDecimal(valorRecebido)));
				}

			}else if(registroHelperCodigo instanceof RegistroHelperCodigo3P){

				RegistroHelperCodigo3P registroHelperCodigo3P = (RegistroHelperCodigo3P) registroHelperCodigo;
				arrecadadorMovimentoItemHelper.setIdentificacao(registroHelperCodigo3P.getIdentificacaoTituloBanco());
				arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_BOLETO_BANCARIO);
			}else if(registroHelperCodigo instanceof RegistroHelperCodigo3U){

				arrecadadorMovimentoItemHelper.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_BOLETO_BANCARIO);
			}

		}

		// (AMIT_DSOCORRENCIA)
		if(arrecadadorMovimentoItem.getDescricaoOcorrencia() != null){
			arrecadadorMovimentoItemHelper.setOcorrencia(arrecadadorMovimentoItem.getDescricaoOcorrencia());
		}

		if(arrecadadorMovimentoItem.getIndicadorAceitacao() != null
						&& arrecadadorMovimentoItem.getIndicadorAceitacao().equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)){

			arrecadadorMovimentoItemHelper.setIndicadorAceitacao(arrecadadorMovimentoItem.getIndicadorAceitacao());

			// Colocado a pedido de Rosana em 08/04/2006
			if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
							&& !arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_C)){

				arrecadadorMovimentoItemHelper.setDescricaoIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
			}

		}else{

			arrecadadorMovimentoItemHelper.setIndicadorAceitacao(arrecadadorMovimentoItem.getIndicadorAceitacao());

			// Colocado a pedido de Rosana em 08/04/2006
			if(arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
							&& !arrecadadorMovimentoItemHelper.getCodigoRegistro().equals(RegistroCodigo.CODIGO_C)){

				arrecadadorMovimentoItemHelper.setDescricaoIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
			}

		}

		BigDecimal valorPagamento = null;
		try{
			valorPagamento = repositorioArrecadacao.recuperaValorPagamentoArrecadadorMovimentoItem(arrecadadorMovimentoItem.getId());
		}catch(ErroRepositorioException e){
			e.printStackTrace();
		}

		arrecadadorMovimentoItemHelper.setVlPagamento(Util.formatarMoedaReal(valorPagamento));

		return arrecadadorMovimentoItemHelper;
	}

	/**
	 * [UC0262] - Distribuir Dados do Registro de Movimento do Arrecadador
	 * [SB0005] – Distribuir Registro Código F
	 * 
	 * @author Saulo Lima
	 * @date 30/12/2008
	 *       Método Criado para processar corretamente os arquivos do GSAN e arquivos de Legados
	 *       (método sobrescrito)
	 * @param codigoRegistro
	 *            char que identifica o tipo do registro que está sendo processado
	 * @param linha
	 *            String contendo a linha completa
	 * @return RegistroHelperCodigoF
	 *         RegistroHelperCodigoF preenchido
	 * @throws ControladorException
	 */
	public RegistroHelperCodigoF distribuirDadosRegistroCodigoF(char codigoRegistro, String linha) throws ControladorException{

		RegistroHelperCodigoF registroHelperCodigoF = new RegistroHelperCodigoF();

		// recupera o codigo do registro
		registroHelperCodigoF.setCodigoRegistro("" + codigoRegistro);

		// recupera a identificação do cliente na empresa
		registroHelperCodigoF.setIdClienteEmpresa(linha.substring(1, 26).trim());

		// recupera a agencia para debito
		registroHelperCodigoF.setAgenciaDebito(linha.substring(26, 30).trim());

		// recupera o identificação do cliente no banco
		registroHelperCodigoF.setIdClienteBanco(linha.substring(30, 44).trim());

		// recupera a data do debito
		registroHelperCodigoF.setDataDebito(linha.substring(44, 52).trim());

		// recupera o valor debitado
		registroHelperCodigoF.setValorDebito(linha.substring(52, 67).trim());

		// recupera o codigo do retorno
		registroHelperCodigoF.setCodigoRetorno(linha.substring(67, 69).trim());

		/*
		 * Caso esteja processando movimento da Empresa=ADA (PARM_CDEMPRESAFEBRABAN=0477 na tabela
		 * SISTEMA_PARAMETROS) e posição 93 a 94(campo
		 * F.10) for “04” e posição 70 a 74(campo F.08) for “00000”, verifica a conta (a partir da
		 * tabela CONTA com IMOV_ID=[posição 1 a 8 da
		 * Identificação do Cliente na Empresa (campo F02)] após inserção do dígito verificador e
		 * CNTA_ID = AINT_NNSEQUENCIAL da tabela
		 * AVISO_INTELIGEST para AINT_NNAVISO = [posição 79 a 87(campo F10)], AINT_NNANO=[posição 75
		 * a 78(campo F08/09/10)] e AINT_CDTRIBUTO=[posição
		 * 90 a 92(campo F10)] e situação atual (DCST_IDATUAL) com o valor correspondente a normal,
		 * retificada ou incluída);
		 */
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		Short codigoEmpresaFebraban = sistemaParametro.getCodigoEmpresaFebraban();
		String adaGrupoFaturamentoConstanteLegado = linha.substring(92, 94).trim();
		String adaTipoDocumento = linha.substring(66, 69);
		String adaAnoMesReferenciaContaLegado = linha.substring(69, 74).trim();
		validarRegistroLegadoADA(codigoEmpresaFebraban, adaGrupoFaturamentoConstanteLegado, adaAnoMesReferenciaContaLegado,
						adaTipoDocumento);

		if(registroLegadoADA){

			String stringAnoDocumentoADA = linha.substring(74, 78).trim();
			Integer anoDocumentoADA = null;
			if(!Util.validarValorNaoNumerico(stringAnoDocumentoADA)){
				anoDocumentoADA = Integer.valueOf(stringAnoDocumentoADA);
			}

			String stringDocumentoPagavelADA = linha.substring(78, 87).trim();
			Integer numeroDocumentoPagavelADA = null;
			if(!Util.validarValorNaoNumerico(stringDocumentoPagavelADA)){
				numeroDocumentoPagavelADA = Integer.valueOf(stringDocumentoPagavelADA);
			}

			String stringCodigoTributoADA = linha.substring(89, 92).trim();
			Integer codigoTributoADA = null;
			if(!Util.validarValorNaoNumerico(stringCodigoTributoADA)){
				codigoTributoADA = Integer.valueOf(stringCodigoTributoADA);
			}

			if(anoDocumentoADA != null && numeroDocumentoPagavelADA != null && codigoTributoADA != null){
				FiltroAvisoInteligest filtroAvisoInteligest = new FiltroAvisoInteligest();
				filtroAvisoInteligest
								.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.NUMERO_AVISO, numeroDocumentoPagavelADA));
				filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.ANO, anoDocumentoADA));
				filtroAvisoInteligest.adicionarParametro(new ParametroSimples(FiltroAvisoInteligest.CODIGO_TRIBUTO, codigoTributoADA));

				Collection<AvisoInteligest> colecaoAvisoInteligest = getControladorUtil().pesquisar(filtroAvisoInteligest,
								AvisoInteligest.class.getName());

				AvisoInteligest avisoInteligest = null;
				if(colecaoAvisoInteligest != null && !colecaoAvisoInteligest.isEmpty()){
					avisoInteligest = colecaoAvisoInteligest.iterator().next();
				}

				if(avisoInteligest != null){
					Integer idContaInteligest = avisoInteligest.getNumeroSequencial();

					FiltroConta filtroConta = new FiltroConta();
					filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, idContaInteligest));
					Collection<Conta> colecaoConta = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

					Conta conta = null;
					if(colecaoConta != null && !colecaoConta.isEmpty()){
						conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);
						registroHelperCodigoF.setAnoMesReferenciaConta("" + conta.getReferencia());
					}else{
						FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
						filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, idContaInteligest));
						Collection<ContaHistorico> colecaoContaHistorico = getControladorUtil().pesquisar(filtroContaHistorico,
										ContaHistorico.class.getName());

						ContaHistorico contaHistorico = null;
						if(colecaoContaHistorico != null && !colecaoContaHistorico.isEmpty()){
							contaHistorico = (ContaHistorico) Util.retonarObjetoDeColecao(colecaoContaHistorico);
							registroHelperCodigoF.setAnoMesReferenciaConta("" + contaHistorico.getAnoMesReferenciaConta());
						}
					}
				}
			}

		}else{

			// recupera o ano mes de referencia da conta
			registroHelperCodigoF.setAnoMesReferenciaConta(linha.substring(69, 75).trim());

			// recupera o digito verificado no modulo dez(10) do ano e mes da contadebitada
			registroHelperCodigoF.setDigitoVerificadoAnoMesConta(linha.substring(75, 76).trim());

			// grupo de faturamento
			registroHelperCodigoF.setGruposFaturamento(linha.substring(76, 129).trim());

			// recupera o reservado para o futuro
			registroHelperCodigoF.setReservadoFuturo(linha.substring(129, 149).trim());

			if(!linha.substring(149, 150).trim().equals("*")){
				// recupera o codigo do movimento enviado no registro de código F
				registroHelperCodigoF.setCodigoMovimento(linha.substring(149, 150).trim());
			}
		}

		registroHelperCodigoF.setIndicadorPagamentoGuia(linha.substring(84, 96).trim());

		registroHelperCodigoF.setIdentificacaoGuia(linha.substring(84, 93).trim());
		registroHelperCodigoF.setNumeroParcela(linha.substring(93, 96).trim());

		return registroHelperCodigoF;
	}

	/**
	 * Método responsável por consultar os dados de um PagamentoHistorico
	 * 
	 * @date 17/08/2009
	 * @author Virgínia Melo
	 * @param idPagamentoHistorico
	 * @return PagamentoHistorico
	 */
	public PagamentoHistorico consultarPagamentoHistorico(Integer idPagamentoHistorico) throws ControladorException{

		try{
			return repositorioArrecadacao.consultarPagamentoHistorico(idPagamentoHistorico);

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public void atualizaValorArrecadacaoAvisoBancario(BigDecimal valor, Integer codigoAvisoBancario) throws ControladorException{

		try{
			repositorioArrecadacao.atualizaValorArrecadacaoAvisoBancario(valor, codigoAvisoBancario);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * @author Bruno Ferreira dos Santos
	 * @date 26/09/2011
	 * @param imovelId
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarAcrescimoImpontualidade(Integer imovelId) throws ControladorException{

		try{

			Collection colecao = repositorioArrecadacao.pesquisarAcrescimoImpontualidade(imovelId);
			Collection colecaoHistorico = repositorioArrecadacao.pesquisarAcrescimoImpontualidadeHistorico(imovelId);

			colecao.addAll(colecaoHistorico);

			Collection colecaoAcrescimoImpontualidade = new Vector();

			if(!Util.isVazioOrNulo(colecao)){
				Iterator it = colecao.iterator();
				Map multa = new HashMap();
				while(it.hasNext()){
					Object[] obj = (Object[]) it.next();
					AcrescimoImpontualidadeHelper acrescimoImpontualidadeHelper = new AcrescimoImpontualidadeHelper();
					acrescimoImpontualidadeHelper.setReferencia(Util.formatarAnoMesParaMesAno((Integer) obj[0]));
					acrescimoImpontualidadeHelper.setDataVencimento(Util.formatarData((Date) obj[1]));
					acrescimoImpontualidadeHelper.setValorConta(Util.formataBigDecimal(new BigDecimal(obj[2].toString()), 2, true));
					acrescimoImpontualidadeHelper.setValorBase(acrescimoImpontualidadeHelper.getValorConta());
					BigDecimal valorMulta = (BigDecimal) multa.get((Integer) obj[6]);
					if(valorMulta != null){
						multa.remove((Integer) obj[6]);
						multa.put((Integer) obj[6], valorMulta.add(new BigDecimal(obj[3].toString())));
					}else{
						multa.put((Integer) obj[6], new BigDecimal(obj[3].toString()));
					}
					acrescimoImpontualidadeHelper.setMulta(Util.formataBigDecimal(new BigDecimal(obj[3].toString()), 2, true));
					acrescimoImpontualidadeHelper.setQtdDiasCobrado(Util.formataBigDecimal(new BigDecimal(obj[4].toString()), 0, false));
					acrescimoImpontualidadeHelper.setDataPagamento(Util.formatarData((Date) obj[5]));
					acrescimoImpontualidadeHelper.setReferenciaCobranca(Util.formatarAnoMesParaMesAno((Integer) obj[6]));
					colecaoAcrescimoImpontualidade.add(acrescimoImpontualidadeHelper);
				}
				it = colecaoAcrescimoImpontualidade.iterator();
				while(it.hasNext()){
					AcrescimoImpontualidadeHelper acrescimoImpontualidadeHelper = (AcrescimoImpontualidadeHelper) it.next();
					acrescimoImpontualidadeHelper.setValorBase(Util.formataBigDecimal(new BigDecimal(acrescimoImpontualidadeHelper
									.getValorBase().replace(".", "").replace(",", ".")).subtract((BigDecimal) multa.get(Util
									.obterInteger(Util.formatarMesAnoParaAnoMes(acrescimoImpontualidadeHelper.getReferenciaCobranca())))),
									2, true));
				}
			}

			return colecaoAcrescimoImpontualidade;

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0721] - Distribuir Dados do Registro de Movimento do Arrecadador da Ficha de Compensação
	 * [SB0003 – Distribuir Registro Código 3-T]
	 * [SB0004 – Distribuir Registro Código 3-U]
	 * [SB0007 – Distribuir Registro Código 3-P]
	 * [SB0008 – Distribuir Registro Código 3-Q]
	 * [SB0009 – Distribuir Registro Código 3-R]
	 * 
	 * @author Anderson Italo
	 * @date 03/10/2011
	 * @param codigoSegmento
	 * @throws ControladorException
	 */
	private Object distribuirRegistroCodigoTresFichaCompensacao(String linha, String codigoSegmento){

		Object retorno = null;

		if(codigoSegmento.equalsIgnoreCase("P")){

			RegistroHelperCodigo3P registroHelperCodigo3P = new RegistroHelperCodigo3P();

			registroHelperCodigo3P.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
			registroHelperCodigo3P.setLoteServico(linha.substring(3, 7).trim());
			registroHelperCodigo3P.setCodigoRegistro(linha.substring(7, 8).trim());
			registroHelperCodigo3P.setNumeroSequencialRegistroLote(linha.substring(8, 13).trim());
			registroHelperCodigo3P.setCodigoSegmentoRegistroDetalhe(codigoSegmento);
			registroHelperCodigo3P.setUsoExclusivoCampo6(linha.substring(14, 15).trim());
			registroHelperCodigo3P.setCodigoMovimento(linha.substring(15, 17).trim());
			registroHelperCodigo3P.setAgenciaMantedoraConta(linha.substring(17, 22).trim());
			registroHelperCodigo3P.setDigitoVerificadorAgenciaMantenedoraConta(linha.substring(22, 23).trim());
			registroHelperCodigo3P.setNumeroContaCorrente(linha.substring(23, 35).trim());
			registroHelperCodigo3P.setDigitoVerificadorConta(linha.substring(35, 36).trim());
			registroHelperCodigo3P.setDigitoVerificadorAgenciaConta(linha.substring(36, 37).trim());
			registroHelperCodigo3P.setIdentificacaoTituloBanco(linha.substring(37, 57).trim());
			registroHelperCodigo3P.setCodigoCarteira(linha.substring(57, 58).trim());
			registroHelperCodigo3P.setFormaCadastramentoTituloBanco(linha.substring(58, 59).trim());
			registroHelperCodigo3P.setTipoDocumento(linha.substring(59, 60).trim());
			registroHelperCodigo3P.setIdentificacaoEmissaoBloqueto(linha.substring(60, 61).trim());
			registroHelperCodigo3P.setIdentificacaoDistribuicao(linha.substring(61, 62).trim());
			registroHelperCodigo3P.setNumeroDocumentoCobranca(linha.substring(62, 77).trim());
			registroHelperCodigo3P.setDataVencimentoTitulo(linha.substring(77, 85).trim());
			registroHelperCodigo3P.setValorNominalTitulo(linha.substring(85, 100).trim());
			registroHelperCodigo3P.setAgenciaEncarregadaCobranca(linha.substring(100, 105).trim());
			registroHelperCodigo3P.setDigitoVerificadorAgenciaEncarregadaCobranca(linha.substring(105, 106).trim());
			registroHelperCodigo3P.setEspecieTitulo(linha.substring(106, 108).trim());
			registroHelperCodigo3P.setIdenticadorTituloAceitoOuNaoAceito(linha.substring(108, 109).trim());
			registroHelperCodigo3P.setDataEmissaoTitulo(linha.substring(109, 117).trim());
			registroHelperCodigo3P.setCodigoJurosMora(linha.substring(117, 118).trim());
			registroHelperCodigo3P.setDataJurosMora(linha.substring(118, 126).trim());
			registroHelperCodigo3P.setJurosMoraDiaTaxa(linha.substring(126, 141).trim());
			registroHelperCodigo3P.setCodigoDesconto1(linha.substring(141, 142).trim());
			registroHelperCodigo3P.setDataDesconto1(linha.substring(142, 150).trim());
			registroHelperCodigo3P.setValorPercentualConcedidoDesconto1(linha.substring(150, 165).trim());
			registroHelperCodigo3P.setValorIOFConcedido(linha.substring(165, 180).trim());
			registroHelperCodigo3P.setValorAbatimento(linha.substring(180, 195).trim());
			registroHelperCodigo3P.setIdenticadorTituloEmpresa(linha.substring(195, 220).trim());
			registroHelperCodigo3P.setCodigoProtesto(linha.substring(220, 221).trim());
			registroHelperCodigo3P.setNumeroDiasProtesto(linha.substring(221, 223).trim());
			registroHelperCodigo3P.setCodigoBaixaDevolucao(linha.substring(223, 224).trim());
			registroHelperCodigo3P.setNumeroDiasBaixaDevolucao(linha.substring(224, 227).trim());
			registroHelperCodigo3P.setCodigoMoeda(linha.substring(227, 229).trim());
			registroHelperCodigo3P.setNumeroContratoOperacaoCredito(linha.substring(229, 239).trim());
			registroHelperCodigo3P.setUsoExclusivoCampo42(linha.substring(239, 240).trim());

			retorno = registroHelperCodigo3P;

		}else if(codigoSegmento.equalsIgnoreCase("Q")){

			RegistroHelperCodigo3Q registroHelperCodigo3Q = new RegistroHelperCodigo3Q();

			registroHelperCodigo3Q.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
			registroHelperCodigo3Q.setLoteServico(linha.substring(3, 7).trim());
			registroHelperCodigo3Q.setCodigoRegistro(linha.substring(7, 8).trim());
			registroHelperCodigo3Q.setNumeroSequencialRegistroLote(linha.substring(8, 13).trim());
			registroHelperCodigo3Q.setCodigoSegmentoRegistroDetalhe(codigoSegmento);
			registroHelperCodigo3Q.setUsoExclusivoCampo6(linha.substring(14, 15).trim());
			registroHelperCodigo3Q.setCodigoMovimento(linha.substring(15, 17).trim());
			registroHelperCodigo3Q.setTipoInscricaoCampo8(linha.substring(17, 18).trim());
			registroHelperCodigo3Q.setNumeroInscricaoCampo9(linha.substring(18, 33).trim());
			registroHelperCodigo3Q.setNome(linha.substring(33, 73).trim());
			registroHelperCodigo3Q.setEndereco(linha.substring(73, 113).trim());
			registroHelperCodigo3Q.setBairro(linha.substring(113, 128).trim());
			registroHelperCodigo3Q.setCep(linha.substring(128, 133).trim());
			registroHelperCodigo3Q.setSufixoCep(linha.substring(133, 136).trim());
			registroHelperCodigo3Q.setCidade(linha.substring(136, 151).trim());
			registroHelperCodigo3Q.setUf(linha.substring(151, 153).trim());
			registroHelperCodigo3Q.setTipoInscricaoCampo17(linha.substring(153, 154).trim());
			registroHelperCodigo3Q.setNumeroInscricaoInscricaoCampo18(linha.substring(154, 169).trim());
			registroHelperCodigo3Q.setNomeSacadorAvalista(linha.substring(169, 209).trim());
			registroHelperCodigo3Q.setCodigoBancoCorrespondenteCompensacao(linha.substring(209, 212).trim());
			registroHelperCodigo3Q.setNossoNumeroBancoCorrespondenteCompensacao(linha.substring(212, 232).trim());
			registroHelperCodigo3Q.setUsoExclusivoCampo22(linha.substring(232, 240).trim());

			retorno = registroHelperCodigo3Q;

		}else if(codigoSegmento.equalsIgnoreCase("R")){

			RegistroHelperCodigo3R registroHelperCodigo3R = new RegistroHelperCodigo3R();

			registroHelperCodigo3R.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
			registroHelperCodigo3R.setLoteServico(linha.substring(3, 7).trim());
			registroHelperCodigo3R.setCodigoRegistro(linha.substring(7, 8).trim());
			registroHelperCodigo3R.setNumeroSequencialRegistroLote(linha.substring(8, 13).trim());
			registroHelperCodigo3R.setCodigoSegmentoRegistroDetalhe(codigoSegmento);
			registroHelperCodigo3R.setUsoExclusivoCampo6(linha.substring(14, 15).trim());
			registroHelperCodigo3R.setCodigoMovimento(linha.substring(15, 17).trim());
			registroHelperCodigo3R.setCodigoDesconto2(linha.substring(17, 18).trim());
			registroHelperCodigo3R.setDataDesconto2(linha.substring(18, 26).trim());
			registroHelperCodigo3R.setValorPercentualConcedidoDesconto2(linha.substring(26, 41).trim());
			registroHelperCodigo3R.setCodigoDesconto3(linha.substring(41, 42).trim());
			registroHelperCodigo3R.setDataDesconto3(linha.substring(42, 50).trim());
			registroHelperCodigo3R.setValorPercentualConcedidoDesconto3(linha.substring(50, 65).trim());
			registroHelperCodigo3R.setCodigoMulta(linha.substring(65, 66).trim());
			registroHelperCodigo3R.setDataMulta(linha.substring(66, 74).trim());
			registroHelperCodigo3R.setValorPercentualAplicadoMulta(linha.substring(74, 89).trim());
			registroHelperCodigo3R.setInformacaoSacado(linha.substring(89, 99).trim());
			registroHelperCodigo3R.setMensagem3(linha.substring(99, 139).trim());
			registroHelperCodigo3R.setMensagem4(linha.substring(139, 179).trim());
			registroHelperCodigo3R.setUsoExclusivoCampo20(linha.substring(179, 199).trim());
			registroHelperCodigo3R.setCodigoOcorrenciaSacado(linha.substring(199, 207).trim());
			registroHelperCodigo3R.setCodigoBancoContaDebito(linha.substring(207, 210).trim());
			registroHelperCodigo3R.setCodigoAgenciaDebito(linha.substring(210, 215).trim());
			registroHelperCodigo3R.setDigitoVerificadorAgenciaDebito(linha.substring(215, 216).trim());
			registroHelperCodigo3R.setContaCorrenteDebito(linha.substring(216, 228).trim());
			registroHelperCodigo3R.setDigitoVerificadorContaDebito(linha.substring(228, 229).trim());
			registroHelperCodigo3R.setDigitoVerificadorAgenciaContaDebito(linha.substring(229, 230).trim());
			registroHelperCodigo3R.setAvisoDebitoAutomatico(linha.substring(230, 231).trim());
			registroHelperCodigo3R.setUsoExclusivoCampo29(linha.substring(231, 240).trim());

			retorno = registroHelperCodigo3R;

		}else if(codigoSegmento.equalsIgnoreCase("T")){

			RegistroHelperCodigo3T registroHelperCodigo3T = new RegistroHelperCodigo3T();
			registroHelperCodigo3T.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
			registroHelperCodigo3T.setLoteServico(linha.substring(3, 7).trim());
			registroHelperCodigo3T.setCodigoRegistro(linha.substring(7, 8).trim());
			registroHelperCodigo3T.setNumeroSequencialRegLote(linha.substring(8, 13).trim());
			registroHelperCodigo3T.setCodSegmentoRegDetalhe(codigoSegmento);
			registroHelperCodigo3T.setUsoExclusivo06(linha.substring(14, 15).trim());
			registroHelperCodigo3T.setCodigoMovimento(linha.substring(15, 17).trim());
			registroHelperCodigo3T.setAgenciaMantedoraConta(linha.substring(17, 22).trim());
			registroHelperCodigo3T.setDigitoVerificadorAgencia(linha.substring(22, 23).trim());
			registroHelperCodigo3T.setNumeroContaCorrente(linha.substring(23, 35).trim());
			registroHelperCodigo3T.setDigitoVerificadorConta(linha.substring(35, 36).trim());
			registroHelperCodigo3T.setDigitoVerificadorAgConta(linha.substring(36, 37).trim());
			registroHelperCodigo3T.setNossoNumero(linha.substring(37, 57).trim());
			registroHelperCodigo3T.setCodigoCarteira(linha.substring(57, 58).trim());
			registroHelperCodigo3T.setNumeroDocCobranca(linha.substring(58, 73).trim());
			registroHelperCodigo3T.setDataVencimentoTitulo(linha.substring(73, 81).trim());
			registroHelperCodigo3T.setValorNominalTitulo(linha.substring(81, 96).trim());
			registroHelperCodigo3T.setNumeroBanco(linha.substring(96, 99).trim());
			registroHelperCodigo3T.setAgenciaCobradoraRecebedora(linha.substring(99, 104).trim());
			registroHelperCodigo3T.setDigitoVerificadorAgenciaT(linha.substring(104, 105).trim());
			registroHelperCodigo3T.setIdentificadorTituloEmpresa(linha.substring(105, 130).trim());

			// T21.1 a T21.6 - UC0721, SB0003 - Início
			registroHelperCodigo3T.setTituloIdentificador01(linha.substring(105, 106).trim());
			registroHelperCodigo3T.setTituloMatriculaImovel(linha.substring(106, 114).trim());
			registroHelperCodigo3T.setTituloIdentificador02(linha.substring(114, 116).trim());
			registroHelperCodigo3T.setTituloNumeroDocumento(linha.substring(116, 125).trim());
			registroHelperCodigo3T.setTituloNumeroPrestacao(linha.substring(125, 128).trim());
			// T21.1 a T21.6 - UC0721, SB0003 - Fim

			registroHelperCodigo3T.setCodigoMoeda(linha.substring(131, 132).trim());
			registroHelperCodigo3T.setTipoInscricao(linha.substring(132, 133).trim());
			registroHelperCodigo3T.setNumeroInscricao(linha.substring(133, 148).trim());
			registroHelperCodigo3T.setNome(linha.substring(148, 188).trim());
			registroHelperCodigo3T.setContratoOperacaoCred(linha.substring(188, 198).trim());
			registroHelperCodigo3T.setValorTarifaCustas(linha.substring(198, 213).trim());
			registroHelperCodigo3T.setIdentificacao(linha.substring(213, 223).trim());
			registroHelperCodigo3T.setUsoExclusivo29(linha.substring(223, 240).trim());

			retorno = registroHelperCodigo3T;
		}else{

			RegistroHelperCodigo3U registroHelperCodigo3U = new RegistroHelperCodigo3U();
			registroHelperCodigo3U.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
			registroHelperCodigo3U.setLoteServico(linha.substring(3, 7).trim());
			registroHelperCodigo3U.setCodigoRegistro(linha.substring(7, 8).trim());
			registroHelperCodigo3U.setNumeroSequencialRegLote(linha.substring(8, 13).trim());
			registroHelperCodigo3U.setCodSegmentoRegDetalhe(codigoSegmento);
			registroHelperCodigo3U.setUsoExclusivo06(linha.substring(14, 15).trim());
			registroHelperCodigo3U.setCodigoMovimento(linha.substring(15, 17).trim());
			registroHelperCodigo3U.setJurosMultaEncargos(linha.substring(17, 32).trim());
			registroHelperCodigo3U.setValorDescontoConcedido(linha.substring(32, 47).trim());
			registroHelperCodigo3U.setValorAbatConcedidoCancelado(linha.substring(47, 62).trim());
			registroHelperCodigo3U.setValorIOFRecolhido(linha.substring(62, 77).trim());
			registroHelperCodigo3U.setValorPagoSacado(linha.substring(77, 92).trim());
			registroHelperCodigo3U.setValorLiquidoASerCreditado(linha.substring(92, 107).trim());
			registroHelperCodigo3U.setValorOutrasDespesas(linha.substring(107, 122).trim());
			registroHelperCodigo3U.setValorOutrosCreditos(linha.substring(122, 137).trim());
			registroHelperCodigo3U.setDataOcorrencia(linha.substring(137, 145).trim());
			registroHelperCodigo3U.setDataEfetivacaoCredito(linha.substring(145, 153).trim());
			registroHelperCodigo3U.setCodigoOcorrenciaSacado(linha.substring(153, 157).trim());
			registroHelperCodigo3U.setDataOcorrenciaSacado(linha.substring(157, 165).trim());
			registroHelperCodigo3U.setValorOcorrenciaSacado(linha.substring(165, 180).trim());
			registroHelperCodigo3U.setComplOcorrenciaSacado(linha.substring(180, 210).trim());
			registroHelperCodigo3U.setCodigoBanco(linha.substring(210, 213).trim());
			registroHelperCodigo3U.setNossoNumero(linha.substring(213, 233).trim());
			registroHelperCodigo3U.setUsoExclusivo24(linha.substring(233, 240).trim());

			retorno = registroHelperCodigo3U;
		}

		return retorno;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * O sistema captura os dados referentes ao conteúdo do do código de barras
	 * [SB0004] Apresentar Dados do Conteúdo do Código de Barras da Ficha de Compensação
	 * 
	 * @author Vivianne Sousa
	 * @data 29/01/2008
	 * @param registroHelperCodigo3T
	 * @return DadosConteudoCodigoBarrasHelper
	 */
	public DadosConteudoCodigoBarrasHelper apresentarDadosConteudoCodigoBarrasFichaCompensacao(
					RegistroHelperCodigo3T registroHelperCodigo3T, RegistroHelperCodigo3U registroHelperCodigo3U)
					throws ControladorException{

		DadosConteudoCodigoBarrasHelper retorno = new DadosConteudoCodigoBarrasHelper();

		String idDocumentoTipoString = registroHelperCodigo3T.getNossoNumero().substring(44, 46);

		FiltroDocumentoTipo filtroDocumentoTipo = new FiltroDocumentoTipo();
		filtroDocumentoTipo.adicionarParametro(new ParametroSimples(FiltroDocumentoTipo.ID, Util.obterInteger(idDocumentoTipoString)));

		DocumentoTipo documentoTipo = (DocumentoTipo) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroDocumentoTipo,
						DocumentoTipo.class.getName()));
		if(documentoTipo.getId().equals(DocumentoTipo.CONTA)){
			BigDecimal valorPagamento = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3U
							.getValorPagoSacado());
			String nossoNumeroSemDV = registroHelperCodigo3T.getNossoNumero().substring(0, 17);
			String idDocumento = nossoNumeroSemDV.substring(9, 17);
			Conta conta = getControladorFaturamento().obterImovelLocalidadeConta(Util.obterInteger(idDocumento));

			if(conta != null){
				// id da Localidade
				retorno.setCodigoLocalidade(conta.getLocalidade().getId().toString());

				// matrícula do imóvel
				retorno.setMatriculaImovel(conta.getImovel().getId().toString());

				// mês e ano de referência da conta
				retorno.setMesAnoReferenciaConta(conta.getReferenciaFormatada());
			}else{
				ContaHistorico contaHistorico = getControladorFaturamento().obterImovelLocalidadeContaHistorico(
								Util.obterInteger(idDocumento));

				if(contaHistorico != null){
					// id da Localidade
					retorno.setCodigoLocalidade(contaHistorico.getLocalidade().getId().toString());

					// matrícula do imóvel
					retorno.setMatriculaImovel(contaHistorico.getImovel().getId().toString());

					// mês e ano de referência da conta
					retorno.setMesAnoReferenciaConta(contaHistorico.getFormatarAnoMesParaMesAno());
				}
			}

			Date dataVencimentoMais15 = Util.adicionarNumeroDiasDeUmaData(new Date(), 15);
			String fatorVencimento = getControladorFaturamento().obterFatorVencimento(dataVencimentoMais15);

			String especificacaoCodigoBarra = obterEspecificacaoCodigoBarraFichaCompensacao(
							ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO, ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO,
							valorPagamento, nossoNumeroSemDV.toString(), ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO, fatorVencimento);

			String digitoVerificador = especificacaoCodigoBarra.substring(4, 5);

			// String representacaoNumericaCodigoBarraFichaCompensacao =
			// obterRepresentacaoNumericaCodigoBarraFichaCompensacao(especificacaoCodigoBarra);

			// código do banco
			retorno.setCodigoBanco(ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO);

			// código da moeda
			retorno.setCodigoMoeda(ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO);

			// dígito verificador geral
			retorno.setDigitoVerificadorGeral(digitoVerificador);

			// fator de vencimento
			retorno.setFatorVencimento(fatorVencimento);

			// valor do código de barras
			retorno.setValorCodigoBarras(Util.formatarMoedaReal(valorPagamento));

			// nosso número
			retorno.setNossoNumero(nossoNumeroSemDV);

			// tipo de carteira
			retorno.setTipoCarteira(ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO);

			// tipo de pagamento
			retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);
		}else if(documentoTipo.getId().equals(DocumentoTipo.GUIA_PAGAMENTO)){
			retorno.setCodigoLocalidade("");
			FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
			filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.CLIENTE);
			filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.IMOVEL);
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, Util.obterInteger(registroHelperCodigo3T
							.getNossoNumero().substring(46, 54))));
			GuiaPagamento guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroGuiaPagamento,
							GuiaPagamento.class.getName()));
			if(guiaPagamento.getImovel() != null){
				retorno.setImovelCliente(guiaPagamento.getImovel().getId().toString());
			}else{
				retorno.setImovelCliente(guiaPagamento.getCliente().getId().toString());
			}
			retorno.setNumeroPrestacaoGuiaPagamento("");
			// tipo de pagamento
			retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_GUIA_PAGAMENTO);
		}else if(documentoTipo.getId().equals(DocumentoTipo.DOCUMENTO_COBRANCA)){
			retorno.setCodigoLocalidade("");
			FiltroCobrancaDocumento filtroCobrancaDocumento = new FiltroCobrancaDocumento();
			filtroCobrancaDocumento.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumento.CLIENTE);
			filtroCobrancaDocumento.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumento.IMOVEL);
			filtroCobrancaDocumento.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.ID, Util
							.obterInteger(registroHelperCodigo3T.getNossoNumero().substring(46, 54))));
			CobrancaDocumento cobrancaDocumento = (CobrancaDocumento) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(
							filtroCobrancaDocumento, CobrancaDocumento.class.getName()));
			if(cobrancaDocumento.getImovel() != null){
				retorno.setImovelCliente(cobrancaDocumento.getImovel().getId().toString());
			}else{
				retorno.setImovelCliente(cobrancaDocumento.getCliente().getId().toString());
			}
			// tipo de pagamento
			retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
		}else if(documentoTipo.getId().equals(DocumentoTipo.DEBITO_A_COBRAR)){
			// 1.4.1.4.1. Código da localidade;
			// 1.4.1.4.2. Matrícula do imóvel;
			// 1.4.1.4.3. Mês e ano de referência do débito a cobrar;
			// 1.4.1.4.4. Número da Prestação.

		}
		return retorno;

	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0011] - Validar Arquivo de Movimento de Arrecadador da Ficha de Compensação(Boleto
	 * Bancário)
	 * 
	 * @author Anderson Lima
	 * @date 04/10/2011
	 */
	private void validarArquivoMovimentoArrecadadorBoletoBancario(StringBuilder stringBuilderTxt, Arrecadador arrecadador,
					int quantidadeRegistros, String idTipoMovimento) throws ControladorException{

		int tamanhoLinha = 240;
		int countRegistros = 0;
		Integer inicioLinha = 0;
		boolean primeiraLinha = true;
		ArrecadadorContrato arrecadadorContrato = null;
		boolean verificaRegistro9 = false;
		Integer numeroSequencialArquivoRetorno = null;
		Collection<String> linhas = new ArrayList<String>();
		RegistroHelperCodigo0 registroHelperCodigo0 = null;
		RegistroHelperCodigo9 registroHelperCodigo9 = null;
		Collection<String> conteudoRegistros0159 = new ArrayList<String>();
		Integer quantidadeItens = 0;
		ArrecadadorMovimento arrecadadorMovimentoExistente = null;

		try{

			for(int i = 1; i <= quantidadeRegistros; i++){

				countRegistros = countRegistros + 1;
				String linha = stringBuilderTxt.substring(inicioLinha, inicioLinha + tamanhoLinha);
				inicioLinha = inicioLinha + tamanhoLinha + 1;

				// recupera o codigo do registro
				String codigoRegistro = linha.substring(7, 8);

				// Lê a primeira linha
				if(primeiraLinha){

					/*
					 * Verifica se o código do registro é diferente de "0", caso seja encerra o
					 * caso de uso
					 */
					if(!codigoRegistro.toUpperCase().equals("0")){

						throw new ControladorException("atencao.arquivo.movimento.sem.header");
					}else{

						registroHelperCodigo0 = (RegistroHelperCodigo0) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(linha,
										null);
						conteudoRegistros0159.add(linha);
						quantidadeItens++;
					}

					/*
					 * Verifica se o código da remessa é diferente de 2, caso seja encerra o caso de
					 * uso
					 */
					if(!registroHelperCodigo0.getCodigoRemessaRetorno().equals("2")){

						throw new ControladorException("atencao.codigo.remessa.invalido");
					}

					/*
					 * Verifica se o código do banco é diferente do codigo do arrecadador caso
					 * seja encerra o caso de uso
					 */
					Short codigoBancoTxt = Short.valueOf(registroHelperCodigo0.getCodigoBancoCompensacao().trim());

					if(!codigoBancoTxt.equals(arrecadador.getCodigoAgente())){

						throw new ControladorException("atencao.movimento.nao.arrecadador", null, arrecadador.getCodigoAgente().toString(),
										arrecadador.getCliente().getNome());
					}

					/*
					 * Verifica se o lote de serviço é diferente de 0000 caso seja encerra o caso de
					 * uso
					 */
					if(!registroHelperCodigo0.getLoteServico().equals("0000")){

						throw new ControladorException("atencao.lote.nao.corresponde.header");
					}

					String codigoConvenioBanco = registroHelperCodigo0.getCodigoConvenioBanco();

					/*
					 * O sistema determina o número seqüencial do arquivo (NSA) esperado (a partir
					 * da tabela ARRECADADOR_CONTRATO com ARRC_ID=ARRC_ID do arrecadador selecionado
					 * e ARCT_DTCONTRATOENCERRAMENTO com o valor nulo)
					 */
					FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
					filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID, arrecadador
									.getId()));
					filtroArrecadadorContrato.adicionarParametro(new ParametroNulo(FiltroArrecadadorContrato.DATA_CONTRATO_ENCERRAMENTO));
					filtroArrecadadorContrato
									.adicionarCaminhoParaCarregamentoEntidade(FiltroArrecadadorContrato.CONTA_BANCARIA_DEPOSITO_ARRECADACAO_BOLETO);

					Collection<ArrecadadorContrato> colecaoArrecadadorContrato = getControladorUtil().pesquisar(filtroArrecadadorContrato,
									ArrecadadorContrato.class.getName());

					if(!Util.isVazioOrNulo(colecaoArrecadadorContrato)){
						if(!Util.isVazioOrNulo(colecaoArrecadadorContrato)){
							String codigoConvenioBoletoBancario = null;
							String codigoConvenioBoletoBancarioSemZero = null;

							String codigoConvenioBancoAux = null;

							if(codigoConvenioBanco != null){
								codigoConvenioBancoAux = codigoConvenioBanco.substring(0, 9);
							}

							String codigoConvenioBancoSemZero = Util.removerZerosEsquerda(codigoConvenioBancoAux);

							for(ArrecadadorContrato arrecadadorContratoAux : colecaoArrecadadorContrato){
								codigoConvenioBoletoBancario = arrecadadorContratoAux.getCodigoConvenioBoletoBancario();
								codigoConvenioBoletoBancarioSemZero = Util.removerZerosEsquerda(codigoConvenioBoletoBancario);

								if(codigoConvenioBoletoBancarioSemZero != null && codigoConvenioBancoSemZero != null
												&& codigoConvenioBoletoBancarioSemZero.equals(codigoConvenioBancoSemZero)){
									arrecadadorContrato = arrecadadorContratoAux;

									break;
								}
							}
						}

						if(arrecadadorContrato == null){
							throw new ControladorException("atencao.movimento_processado_codigo_convenio_inexiste", null, idTipoMovimento,
											codigoConvenioBanco);
						}
					}

					if(arrecadadorContrato != null && arrecadadorContrato.getNumeroSequencialArquivoRetornoBoleto() != null){

						numeroSequencialArquivoRetorno = arrecadadorContrato.getNumeroSequencialArquivoRetornoBoleto().intValue() + 1;

						/* Se consistir NSA (ARCT_ICCRITICARNSA da Tabela ARRECADADOR_CONTRATO=1) */
						if(arrecadadorContrato.getIndicadorCriticarNumeroSequencialArquivo().equals(ConstantesSistema.SIM)){

							/*
							 * Caso o número seqüencial do arquivo (NSA) (campo 0.19) não seja igual
							 * ao o
							 * número seqüencial do arquivo (NSA) esperado exibir a mensagem
							 * “Arquivo de
							 * Movimento Está Fora de Seqüência” e encerrar o caso de uso
							 */
							if(!Integer.valueOf(registroHelperCodigo0.getNumeroSequencialArquivo()).equals(numeroSequencialArquivoRetorno)){

								throw new ControladorException("atencao.arquivo.movimento.fora.sequencia");
							}
						}else if(Util.isInteger(registroHelperCodigo0.getNumeroSequencialArquivo())){

							numeroSequencialArquivoRetorno = Util.obterInteger(registroHelperCodigo0.getNumeroSequencialArquivo());
						}
					}

					/*
					 * Verificar a já existência do Movimento em Questão na tabela
					 * ARRECADADOR_MOVIMENTO
					 */
					arrecadadorMovimentoExistente = repositorioArrecadacao.pesquisaArrecadadorMovimentoExistente(new Short(
									registroHelperCodigo0.getCodigoBancoCompensacao()), codigoConvenioBanco, Util
									.obterInteger(registroHelperCodigo0.getNumeroSequencialArquivo()));

					if(arrecadadorMovimentoExistente != null){

						throw new ControladorException("atencao.movimento_ja_processado", null,
										registroHelperCodigo0.getCodigoBancoCompensacao(), codigoConvenioBanco,
										registroHelperCodigo0.getNumeroSequencialArquivo());
					}

					// depois de ler a primeira linha atribui ela para falso
					primeiraLinha = false;

				}else{

					/*
					 * O sistema lê o arquivo de movimento de arrecadador seqüencialmente até
					 * encontrar o registro código 9, contando a quantidade total registros
					 * inclusive os registros códigos 0, 1, 3, 5 e 9, guardando os registros lidos
					 * em uma coleção(apenas os registros de código 3 são guardados na coleção).
					 */

					// [FS0015]-Verificar a existência do registro código 9
					if(codigoRegistro.equals("0")){

						throw new ControladorException("atencao.arquivo.movimento.nao.codigo.9");
					}

					/*
					 * [FS0016]-Verificar a existência de registros com código inválido na ficha
					 * de
					 * compensação
					 */
					if(!codigoRegistro.equals("0") && !codigoRegistro.equals("1") && !codigoRegistro.equals("3")
									&& !codigoRegistro.equals("5") && !codigoRegistro.equals("9")){

						throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
					}

					if(!codigoRegistro.equals("9")){

						if(codigoRegistro.equals("5")){

							conteudoRegistros0159.add(linha);
							quantidadeItens++;
						}else if(!codigoRegistro.equals("1")){

							/*
							 * Armazena os registros de código 3 em uma coleção para serem
							 * processados posteriormente
							 */
							linhas.add(linha);
						}else{

							// Armazena o conteúdo do código 1
							conteudoRegistros0159.add(linha);
							quantidadeItens++;
						}

					}else{

						verificaRegistro9 = true;

						/*
						 * Caso código do registro seja "9" então processa a coleção
						 * de linhas e inseri o movimento de arrecadadores
						 */
						registroHelperCodigo9 = (RegistroHelperCodigo9) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(linha,
										null);
						conteudoRegistros0159.add(linha);
						quantidadeItens++;

						/*
						 * Caso a quantidade de registros for diferente da
						 * quantidade de registros do txt então encerra o caso de uso
						 */
						if(Integer.parseInt(registroHelperCodigo9.getQtdeRegistrosArquivo().trim()) != countRegistros){

							throw new ControladorException("atencao.total.registros.invalido");
						}
					}
				}
			}

			// Totaliza os itens do tipo 3(duas linhas(T e U) para cada 1 item inserido)
			quantidadeItens += linhas.size() / 2;

			/*
			 * [FS0015]-Verificar a existência do registro código 9 verifica se o código do registro
			 * é "0", caso seja então
			 * não existe o codigo do registro "9" e encerra o caso de uso
			 */
			if(verificaRegistro9 == false){

				throw new ControladorException("atencao.arquivo.movimento.nao.codigo.9");
			}

			// [SB0017] - Processar Movimento do Boleto Bancário
			processarMovimentoBoletoBancario(linhas, arrecadadorContrato, numeroSequencialArquivoRetorno, registroHelperCodigo0,
							registroHelperCodigo9, idTipoMovimento, conteudoRegistros0159, quantidadeItens);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0017] - Processar Movimento do Boleto Bancário
	 * 
	 * @author Anderson Lima
	 * @date 04/10/2011
	 */
	private void processarMovimentoBoletoBancario(Collection<String> linhas, ArrecadadorContrato arrecadadorContrato,
					Integer numeroSequencialArquivoRetorno, RegistroHelperCodigo0 registroHelperCodigo0,
					RegistroHelperCodigo9 registroHelperCodigo9, String idTipoMovimento, Collection<String> conteudoRegistros0159,
					Integer quantidadeItens) throws ControladorException, ErroRepositorioException{

		/*
		 * O sistema inicializa uma coleção de avisos bancários e uma coleção de pagamentos(os
		 * avisos serão inicializados a partir do objeto MovimentoBoletoBancarioHelper)
		 */
		Collection<Pagamento> colecaoPagamento = new ArrayList<Pagamento>();
		Collection<MovimentoBoletoBancarioHelper> colecaoMovimentoBoletoBancarioHelper = new ArrayList<MovimentoBoletoBancarioHelper>();

		// [SF0013] - Inserir o movimento do arrecadador da ficha de Compensação
		ArrecadadorMovimento arrecadadorMovimento = inserirMovimentoArrecadadorFichaCompensacao(registroHelperCodigo0, BigDecimal.ZERO,
						registroHelperCodigo9, idTipoMovimento, quantidadeItens);

		// [SB0009] – Inserir o item de movimento do arrecadador
		for(String linhaRegistro : conteudoRegistros0159){

			this.inserirItemMovimentoArrecadador(linhaRegistro, arrecadadorMovimento.getId(), "OK", ConstantesSistema.SIM, null);
		}

		// Campo 0.17
		Date dataGeracao = Util.converteStringSemBarraParaDate(registroHelperCodigo0.getDataGeracaoArquivo());

		// Obtem o número sequencial do aviso bancário para ser utilizado posteriormente
		short numeroSequencialAvisoBancario = 0;
		if(registroHelperCodigo0.getCodigoBancoCompensacao() != null && registroHelperCodigo0.getDataGeracaoArquivo() != null){

			Short valorMaximoNumeroSequencia = null;
			valorMaximoNumeroSequencia = repositorioArrecadacao.pesquisarValorMaximoNumeroSequencial(dataGeracao, arrecadadorContrato
							.getArrecadador().getId().toString());

			if(valorMaximoNumeroSequencia != null){

				numeroSequencialAvisoBancario = (short) (valorMaximoNumeroSequencia.shortValue() + 1);
			}
		}else{

			numeroSequencialAvisoBancario = 0;
		}

		Iterator linhaIterator = linhas.iterator();
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		String descricaoOcorrenciaMovimento = null;
		int indicadorAceitacaoRegistroMovimento;

		// A partir do terceiro e para cada dois registros guardados na coleção, o sistema:
		while(linhaIterator.hasNext()){

			String linhaRegistro = (String) linhaIterator.next();

			// Atribui o valor “OK” ao campo Descrição da Ocorrência do Movimento
			descricaoOcorrenciaMovimento = "OK";

			// Atribui o valor 1 (SIM) ao Indicador de Aceitação do Registro do Movimento
			indicadorAceitacaoRegistroMovimento = 1;

			// Obtém o código do registro
			Integer codigoRegistroInteger = Integer.valueOf(linhaRegistro.substring(7, 8));

			/*
			 * Distribui os dados dos conteúdos dos registros de movimento do arrecadador,
			 * <<Inclui>> [UC0721 – Distribuir Dados do Registro de Movimento do Arrecadador da
			 * Ficha de Compensação]
			 */
			String linhaRegistroCodigoT = linhaRegistro;
			String linhaRegistroCodigoU = (String) linhaIterator.next();

			if(codigoRegistroInteger.intValue() == 3){

				colecaoMovimentoBoletoBancarioHelper.add(this.processarRegistroCodigoTresBoletoBancario(arrecadadorContrato,
								registroHelperCodigo0, colecaoMovimentoBoletoBancarioHelper, arrecadadorMovimento, sistemaParametro,
								numeroSequencialAvisoBancario, dataGeracao, descricaoOcorrenciaMovimento,
								indicadorAceitacaoRegistroMovimento, linhaRegistroCodigoT, linhaRegistroCodigoU));

			}else{

				// Atribui o valor “CÓDIGO DE MOVIMENTO NÃO IDENTIFICADO” ao campo Descrição da
				// Ocorrência do Movimento
				descricaoOcorrenciaMovimento = "CÓDIGO DE MOVIMENTO NÃO IDENTIFICADO";

				// Atribui o valor 2 (NÃO) ao Indicador de Aceitação do Registro do Movimento
				indicadorAceitacaoRegistroMovimento = 2;

				// [SB0018] – Inserir o item de movimento do arrecadador do boleto bancário
				inserirItemMovimentoArrecadadorBoletoBancario(linhaRegistroCodigoT, linhaRegistroCodigoU, arrecadadorMovimento.getId(),
								descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento, null);

			}
		}

		// Caso a coleção de avisos bancários não esteja vazia,
		if(!Util.isVazioOrNulo(colecaoMovimentoBoletoBancarioHelper)){

			AvisoBancario avisoBancario = null;
			AvisoBancario avisoBancarioAnterior = null;
			Collection<AvisoBancario> colecaoAvisoBancarioAtualizar = new ArrayList<AvisoBancario>();
			BigDecimal valorLiquidacaoMovimento = BigDecimal.ZERO;
			for(MovimentoBoletoBancarioHelper movimentoBoletoBancarioHelper : colecaoMovimentoBoletoBancarioHelper){

				ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();

				/*
				 * Caso o id do aviso bancário esteja nulo o sistema insere na tabela AVISO_BANCARIO
				 * cada ocorrência da coleção
				 */
				if(movimentoBoletoBancarioHelper.getAvisoBancario() != null
								&& movimentoBoletoBancarioHelper.getAvisoBancario().getId() == null){

					Integer idAvisoBancarioInserido = (Integer) getControladorUtil().inserir(
									movimentoBoletoBancarioHelper.getAvisoBancario());
					avisoBancario = movimentoBoletoBancarioHelper.getAvisoBancario();
					avisoBancario.setId(idAvisoBancarioInserido);
				}else if(movimentoBoletoBancarioHelper.getAvisoBancario() != null){

					// Caso contrário o aviso já existe não será necessário incluílo
					avisoBancario = movimentoBoletoBancarioHelper.getAvisoBancario();
					getControladorUtil().atualizar(avisoBancario);
				}

				arrecadadorMovimentoItem.setId(movimentoBoletoBancarioHelper.getIdArrecadadorMovimentoItem());

				/*
				 * Caso a coleção de pagamentos não esteja vazia:
				 * O sistema insere na tabela PAGAMENTO cada ocorrência da coleção, preenchendo o id
				 * do aviso bancário (AVBC_ID) e o id do item de movimento do arrecadador (AMIT_ID)
				 */
				if(!Util.isVazioOrNulo(movimentoBoletoBancarioHelper.getColecaoPagamento())){

					for(Pagamento pagamento : movimentoBoletoBancarioHelper.getColecaoPagamento()){

						pagamento.setAvisoBancario(avisoBancario);
						pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
					}
				}

				/*
				 * [SB0014] – Processar Registro Código 3
				 * Com a ocorrência do aviso bancário selecionada nos itens anteriores(itens 2.3.1.4
				 * ou 2.3.1.5), o sistema atualiza o valor de deduções [SB0020] – Atualizar o valor
				 * de
				 * deduções. Este fluxo foi chamado aqui pois apenas neste método é feita a
				 * persistencia dos avisos bancários incluídos.
				 */
				if(movimentoBoletoBancarioHelper.getAvisoBancario() != null){

					this.atualizarValorDeducoesAvisoBoletoBancario(movimentoBoletoBancarioHelper.getValorRecebidoDeducao(),
									movimentoBoletoBancarioHelper.getValorLiquidoDeducao(), avisoBancario);
				}

				if(!Util.isVazioOrNulo(movimentoBoletoBancarioHelper.getColecaoPagamento())){

					colecaoPagamento.addAll(movimentoBoletoBancarioHelper.getColecaoPagamento());
				}

				/*
				 * Caso o item seja do tipo 6 - Liquidação acumula o valor para atualizar o
				 * movimento (ArrecadadorMovimento)
				 */
				if(movimentoBoletoBancarioHelper.getValorRecebidoLiquidacao() != null){

					valorLiquidacaoMovimento = valorLiquidacaoMovimento.add(movimentoBoletoBancarioHelper.getValorRecebidoLiquidacao());
				}

				// Armazena os avisos na coleção caso exista mais de um no movimento
				if(avisoBancarioAnterior != null && avisoBancario != null && !avisoBancario.getId().equals(avisoBancarioAnterior.getId())){

					colecaoAvisoBancarioAtualizar.add(avisoBancario);
				}

				avisoBancarioAnterior = avisoBancario;
			}

			/*
			 * Atualiza o valor total do movimento com o valor acumulado dos itens do tipo 6 -
			 * Liquidação
			 */
			arrecadadorMovimento.setValorTotalMovimento(valorLiquidacaoMovimento);
			getControladorUtil().atualizar(arrecadadorMovimento);

			if(!Util.isVazioOrNulo(colecaoPagamento)){

				getControladorBatch().inserirColecaoObjetoParaBatch((Collection) colecaoPagamento);

				/*
				 * Para cada pagamento da coleção inserido, o sistema efetua a classificação do
				 * pagamento <<Inclui>> [UC0300 – Classificar Pagamentos Devolucoes]
				 */
				for(Pagamento pagamento : colecaoPagamento){

					this.classificarPagamentosRegistroMovimentoArrecadadores(pagamento);
				}
			}

			// Caso exista mais de um aviso no movimento
			if(!Util.isVazioOrNulo(colecaoAvisoBancarioAtualizar)){

				for(AvisoBancario avisoBancarioAux : colecaoAvisoBancarioAtualizar){

					/*
					 * Atualiza os valores dos pagamentos classificados e não classificados do aviso
					 * e o valor calculado
					 */
					this.atualizaValorArrecadacaoBoletoAvisoBancario(avisoBancarioAux);
				}
			}else if(avisoBancario != null){

				/*
				 * Caso contrário atualiza os valores dos pagamentos classificados e não
				 * classificados do aviso e o valor calculado
				 */
				this.atualizaValorArrecadacaoBoletoAvisoBancario(avisoBancario);
			}
		}

		// O sistema atualiza o número seqüencial do arquivo (NSA) na tabela ARRECADADOR_CONTRATO
		arrecadadorContrato.setNumeroSequencialArquivoRetornoBoleto(numeroSequencialArquivoRetorno);
		repositorioArrecadacao.atualizarDadosArrecadadorContrato(arrecadadorContrato, false, false, false, false, true, false, false);
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0014] – Processar Registro Código 3
	 * 
	 * @author Anderson Lima
	 * @date 12/10/2011
	 */
	private MovimentoBoletoBancarioHelper processarRegistroCodigoTresBoletoBancario(ArrecadadorContrato arrecadadorContrato,
					RegistroHelperCodigo0 registroHelperCodigo0,
					Collection<MovimentoBoletoBancarioHelper> colecaoMovimentoBoletoBancarioHelper,
					ArrecadadorMovimento arrecadadorMovimento, SistemaParametro sistemaParametro, short numeroSequencialAvisoBancario,
					Date dataGeracao, String descricaoOcorrenciaMovimento, int indicadorAceitacaoRegistroMovimento,
					String linhaRegistroCodigoT, String linhaRegistroCodigoU) throws ControladorException, ErroRepositorioException{

		MovimentoBoletoBancarioHelper retorno = new MovimentoBoletoBancarioHelper();
		BoletoBancarioMovimentoProcessadoHelper boletoBancarioMovimentoProcessadoHelper = null;

		boolean dataInvalida;
		boolean valorDebitoInvalido;
		Date dataDebito = null;

		RegistroHelperCodigo3T registroHelperCodigo3T = (RegistroHelperCodigo3T) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
						linhaRegistroCodigoT, null);

		RegistroHelperCodigo3U registroHelperCodigo3U = (RegistroHelperCodigo3U) distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
						linhaRegistroCodigoU, null);

		// [FS0017]-Validar data de débito/pagamento da ficha
		boolean dataExcludentes = false;
		dataInvalida = Util.validarDiaMesAnoSemBarra(registroHelperCodigo3U.getDataOcorrencia());

		if(dataInvalida){

			dataExcludentes = true;
			descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO INVÁLIDA";
		}

		// Caso a data seja inválida não verifica se é maior que a data atual
		if(!dataExcludentes){

			// Verifica se a data de bedito/pagamento é superior a atual
			dataDebito = Util.converteStringSemBarraParaDate(registroHelperCodigo3U.getDataOcorrencia());

			if(dataDebito.after(new Date())){

				descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO POSTERIOR A DATA CORRENTE";
			}
		}

		// [FS0018]-Validar valor debitado/recebido da ficha
		valorDebitoInvalido = Util.validarValorNaoNumerico(registroHelperCodigo3U.getValorPagoSacado());
		if(valorDebitoInvalido){

			descricaoOcorrenciaMovimento = "VALOR DEBITADO/RECEBIDO NÃO NUMÉRICO";
		}

		// Caso a descricao de movimento seja igual a OK
		Integer idArrecadadorMovimentoItemIncluido = null;
		if(descricaoOcorrenciaMovimento.equals("OK")){

			BigDecimal valorRecebido = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3U
							.getValorPagoSacado());

			BigDecimal valorLiquido = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3U
							.getValorLiquidoASerCreditado());

			BigDecimal valorNominalTitulo = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigo3T
							.getValorNominalTitulo());

			BigDecimal valorAcrescimos = valorRecebido.subtract(valorNominalTitulo);

			boletoBancarioMovimentoProcessadoHelper = this.processarMovimentoRetornoBoletoBancario(arrecadadorContrato.getArrecadador()
							.getId(), registroHelperCodigo3T.getCodigoMovimento(), registroHelperCodigo3T.getNossoNumero(),
							registroHelperCodigo3T.getIdentificadorTituloEmpresa(), registroHelperCodigo3T.getIdentificacao(),
							registroHelperCodigo3U.getDataOcorrencia(), valorRecebido, valorLiquido, valorAcrescimos, dataGeracao,
							sistemaParametro, descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento);

			// Caso a coleção de pagamentos retornada pelo [UC0724] ou [UC3024] não esteja vazia
			if(!Util.isVazioOrNulo(boletoBancarioMovimentoProcessadoHelper.getColecaoPagamentos())){

				// Caso o Indicador de Aceitação do Registro do Movimento corresponda a 1 (SIM)
				if(boletoBancarioMovimentoProcessadoHelper.getIndicadorAceitacaoRegistro().equals(ConstantesSistema.SIM.toString())){

					// Adiciona a coleção de pagamentos retornada pelo [UC0724] ou [UC3024]
					retorno.setColecaoPagamento(boletoBancarioMovimentoProcessadoHelper.getColecaoPagamentos());

					/*
					 * A data prevista para o crédito = data de pagamento (campo U.16) + 2 dias
					 * (float da ficha)
					 */
					Date dataPrevistaCredito = Util.adicionarNumeroDiasDeUmaData(dataDebito, 2);

					// Determina os valores calculados e informados do pagamento
					BigDecimal valorCalculadoPagamento = BigDecimal.ZERO;

					/*
					 * Soma dos valores dos pagamentos (soma do PGMT_VLPAGAMENTO da coleção de
					 * pagamentos retornada pelo [UC0724]) ou [UC3024] caso tenha sido chamado. caso
					 * contrário atribuir o valor zero
					 */
					for(Pagamento pagamento : boletoBancarioMovimentoProcessadoHelper.getColecaoPagamentos()){

						valorCalculadoPagamento = valorCalculadoPagamento.add(pagamento.getValorPagamento());
					}

					BigDecimal valorCalculadoDevolucao = BigDecimal.ZERO;
					BigDecimal valorInformadoPagamento = valorRecebido;
					BigDecimal valorInformadoDevolucao = BigDecimal.ZERO;

					/*
					 * Obtém o aviso bancário se existir, a partir da tabela AVISO_BANCÁRIO com
					 * ARRC_ID=Campo 0.01, AVBC_DTLANCAMENTO=Campo 0.17 e (AVBC_DTPREVISTA=Data
					 * Prevista para o crédito ou AVBC_DTREALIZADA=Data Prevista para o crédito) e
					 * ARMV_ID com o valor nulo
					 */
					AvisoBancario avisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(
									Util.obterInteger(registroHelperCodigo0.getCodigoBancoCompensacao()), dataGeracao, dataPrevistaCredito,
									null);
					boolean encontrouAvisoColecao = false;

					/*
					 * Caso já exista o aviso bancário, o sistema atualiza o valor da
					 * arrecadação (tabela AVISO_BANCARIO) conforme descrito abaixo (a partir da
					 * tabela AVISO_BANCÁRIO com ARRC_ID=Campo 0.01, AVBC_DTLANCAMENTO=Campo
					 * 0.17 e (AVBC_DTPREVISTA=Data Prevista para o crédito ou
					 * AVBC_DTREALIZADA=Data Prevista para o crédito) e ARMV_ID com o valor
					 * nulo). A persistência só será feita no final do método que chamou este.
					 */
					if(avisoBancario != null){

						avisoBancario.setValorArrecadacaoCalculado(avisoBancario.getValorArrecadacaoCalculado()
										.add(valorCalculadoPagamento));
						avisoBancario.setValorDevolucaoCalculado(avisoBancario.getValorDevolucaoCalculado().add(valorCalculadoDevolucao));
						avisoBancario.setValorArrecadacaoInformado(avisoBancario.getValorArrecadacaoInformado()
										.add(valorInformadoPagamento));
						avisoBancario.setValorRealizado(avisoBancario.getValorRealizado().add(valorInformadoPagamento));
						avisoBancario.setValorDevolucaoInformado(avisoBancario.getValorDevolucaoInformado().add(valorInformadoDevolucao));

						/*
						 * Armazena valores para atualizar as deduções do aviso bancário no
						 * final do
						 * método que chamou este, pois os avisos novos incluídos e os existente
						 * atualizados só serão
						 * persistidos no final
						 */
						retorno.setAvisoBancario(avisoBancario);
						retorno.setValorRecebidoDeducao(valorRecebido);
						retorno.setValorLiquidoDeducao(valorLiquido);

					}else if(!Util.isVazioOrNulo(colecaoMovimentoBoletoBancarioHelper)){

						/*
						 * caso contrário e caso já exista na coleção de avisos bancários para o
						 * movimento ocorrência com a data prevista para o crédito, o sistema
						 * atualiza o valor da arrecadação e da devolução do aviso bancário na
						 * ocorrência da coleção de avisos bancários, conforme descrito abaixo
						 */
						for(MovimentoBoletoBancarioHelper movimentoBoletoBancarioHelper : colecaoMovimentoBoletoBancarioHelper){

							AvisoBancario avisoBancarioMovimentoOcorrencia = movimentoBoletoBancarioHelper.getAvisoBancario();
							if(avisoBancarioMovimentoOcorrencia != null
											&& (avisoBancarioMovimentoOcorrencia.getDataPrevista() != null || avisoBancarioMovimentoOcorrencia
															.getDataRealizada() != null)){

								avisoBancarioMovimentoOcorrencia.setValorArrecadacaoCalculado(avisoBancarioMovimentoOcorrencia
												.getValorArrecadacaoCalculado().add(valorCalculadoPagamento));
								avisoBancarioMovimentoOcorrencia.setValorDevolucaoCalculado(avisoBancarioMovimentoOcorrencia
												.getValorDevolucaoCalculado().add(valorCalculadoDevolucao));
								avisoBancarioMovimentoOcorrencia.setValorArrecadacaoInformado(avisoBancarioMovimentoOcorrencia
												.getValorArrecadacaoInformado().add(valorInformadoPagamento));
								avisoBancarioMovimentoOcorrencia.setValorRealizado(avisoBancarioMovimentoOcorrencia.getValorRealizado()
												.add(valorInformadoPagamento));
								avisoBancarioMovimentoOcorrencia.setValorDevolucaoInformado(avisoBancarioMovimentoOcorrencia
												.getValorDevolucaoInformado().add(valorInformadoDevolucao));

								/*
								 * Armazena valores para atualizar as deduções do aviso bancário no
								 * final do
								 * método que chamou este, pois os avisos novos incluídos e os
								 * exitentes atualizados só serão
								 * persistidos no final
								 */
								movimentoBoletoBancarioHelper.setValorRecebidoDeducao(movimentoBoletoBancarioHelper
												.getValorRecebidoDeducao().add(valorRecebido));
								movimentoBoletoBancarioHelper.setValorLiquidoDeducao(movimentoBoletoBancarioHelper.getValorLiquidoDeducao()
												.add(valorLiquido));
								encontrouAvisoColecao = true;
								break;
							}
						}
					}

					if(avisoBancario == null && encontrouAvisoColecao == false){

						/*
						 * Caso contrário, o sistema gera uma nova ocorrência na coleção de
						 * avisos bancários [SB0015 – Gerar Ocorrência da ficha/boleto bancário
						 * na Coleção de Avisos Bancários]
						 */
						retorno.setAvisoBancario(gerarOcorrenciaAvisoBancarioBoleto(arrecadadorContrato, registroHelperCodigo0,
										arrecadadorMovimento, sistemaParametro, numeroSequencialAvisoBancario, dataGeracao,
										dataPrevistaCredito, valorCalculadoPagamento, valorInformadoPagamento));

						/*
						 * Armazena valores para atualizar as deduções do aviso bancário no final do
						 * método que chamou este, pois os avisos novos incluídos e os exitentes
						 * atualizados só serão
						 * persistidos no final
						 */
						retorno.setValorRecebidoDeducao(valorRecebido);
						retorno.setValorLiquidoDeducao(valorLiquido);
					}

				}else{

					/*
					 * Caso contrário, atribuir o valor 2 (NÃO) ao Indicador de Aceitação do
					 * Registro do Movimento
					 */
					boletoBancarioMovimentoProcessadoHelper.setIndicadorAceitacaoRegistro(ConstantesSistema.NAO.toString());
				}
			}

			// [SB0018] – Inserir o item de movimento do arrecadador do boleto bancário
			Integer idImovel = boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRetornoBoleto() == null ? null
							: boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRetornoBoleto().getBoletoBancario().getImovel()
											.getId();

			idArrecadadorMovimentoItemIncluido = inserirItemMovimentoArrecadadorBoletoBancario(linhaRegistroCodigoT, linhaRegistroCodigoU,
							arrecadadorMovimento.getId(), boletoBancarioMovimentoProcessadoHelper.getDescricaoOcorrencia(),
							Util.obterInteger(boletoBancarioMovimentoProcessadoHelper.getIndicadorAceitacaoRegistro()), idImovel);

		}else{

			// [SB0018] – Inserir o item de movimento do arrecadador do boleto bancário
			idArrecadadorMovimentoItemIncluido = inserirItemMovimentoArrecadadorBoletoBancario(linhaRegistroCodigoT, linhaRegistroCodigoU,
							arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento, null);
		}

		// Caso movimentação de retorno para incluir esteja diferente de nula
		if(boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRetornoBoleto() != null){

			/*
			 * O sistema atualiza o item de movimento do arrecadador na movimentação de
			 * retorno do boleto bancário (movimentação de retorno para incluir) retornada
			 * pelo [UC3024] e efetua a sua inserção.
			 */
			ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
			arrecadadorMovimentoItem.setId(idArrecadadorMovimentoItemIncluido);
			boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRetornoBoleto().setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

			Integer idMovimentoRetornoInserido = (Integer) getControladorUtil().inserir(
							boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRetornoBoleto());

			/*
			 * O sistema insere a coleção de ocorrências referente à movimentação de retorno
			 * deste boleto
			 */
			if(!Util.isVazioOrNulo(boletoBancarioMovimentoProcessadoHelper.getColecaoOcorrenciasBoleto())){

				for(BoletoBancarioOcorrencias boletoBancarioOcorrencias : boletoBancarioMovimentoProcessadoHelper
								.getColecaoOcorrenciasBoleto()){

					boletoBancarioOcorrencias.getBoletoBancarioMovimentacao().setId(idMovimentoRetornoInserido);
				}

				getControladorUtil().inserirColecaoObjetos(boletoBancarioMovimentoProcessadoHelper.getColecaoOcorrenciasBoleto());
			}

			// Caso movimentação de remessa para atualizar esteja diferente de nula
			if(boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRemessaBoleto() != null){

				/*
				 * O sistema efetua a atualização da movimentação de remessa deste boleto
				 * (movimentação de remessa para atualizar)
				 */
				BoletoBancarioMovimentacao movimentacaoRetornoInserida = new BoletoBancarioMovimentacao();
				movimentacaoRetornoInserida.setId(idMovimentoRetornoInserido);
				boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRemessaBoleto().setBoletoBancarioMovimentacaoRetorno(
								movimentacaoRetornoInserida);
				boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRemessaBoleto().setUltimaAlteracao(new Date());

				getControladorUtil().atualizar(boletoBancarioMovimentoProcessadoHelper.getMovimentacaoRemessaBoleto());
			}
		}

		/*
		 * Acumula o valor recebido se for do tipo 6 - Liquidação para no final atualizar o valor do
		 * movimento (ArrecadadorMovimento)
		 */
		if(boletoBancarioMovimentoProcessadoHelper.getValorRecebidoLiquidacao() != null){

			retorno.setValorRecebidoLiquidacao(boletoBancarioMovimentoProcessadoHelper.getValorRecebidoLiquidacao());
		}

		retorno.setIdArrecadadorMovimentoItem(idArrecadadorMovimentoItemIncluido);

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0020] – Atualizar o valor de deduções
	 * 
	 * @author Anderson Lima
	 * @date 12/10/2011
	 */
	private void atualizarValorDeducoesAvisoBoletoBancario(BigDecimal valorRecebido, BigDecimal valorLiquido, AvisoBancario avisoBancario)
					throws ControladorException{

		FiltroAvisoDeducoes filtroAvisoDeducoes = new FiltroAvisoDeducoes();
		filtroAvisoDeducoes.adicionarParametro(new ParametroSimples(FiltroAvisoDeducoes.AVISO_BANCARIO_ID, avisoBancario.getId()));
		filtroAvisoDeducoes.adicionarParametro(new ParametroSimples(FiltroAvisoDeducoes.DEDUCAO_TIPO_ID,
						DeducaoTipo.TARIFA_COBRANCA_BANCARIA));

		Collection<AvisoDeducoes> colecaoAvisoDeducoes = getControladorUtil().pesquisar(filtroAvisoDeducoes, AvisoDeducoes.class.getName());

		if(!Util.isVazioOrNulo(colecaoAvisoDeducoes)){

			for(AvisoDeducoes avisoDeducoes : colecaoAvisoDeducoes){

				/*
				 * O sistema atualiza o valor total de deduções com o valor da
				 * tarifa obtida no boleto: Valor recebido – valor líquido
				 */
				avisoDeducoes.setValorDeducao(valorRecebido.subtract(valorLiquido));
				getControladorUtil().atualizar(avisoDeducoes);
			}
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0015] – Gerar Ocorrência da ficha/boleto bancário na Coleção de Avisos Bancários
	 * 
	 * @author Anderson Lima
	 * @date 12/10/2011
	 */
	private AvisoBancario gerarOcorrenciaAvisoBancarioBoleto(ArrecadadorContrato arrecadadorContrato,
					RegistroHelperCodigo0 registroHelperCodigo0, ArrecadadorMovimento arrecadadorMovimento,
					SistemaParametro sistemaParametro, short numeroSequencialAvisoBancario, Date dataGeracao, Date dataPrevistaCredito,
					BigDecimal valorCalculadoPagamento, BigDecimal valorInformadoPagamento){

		AvisoBancario avisoBancario = new AvisoBancario();

		// Código do Banco Compensação
		avisoBancario.setArrecadador(arrecadadorContrato.getArrecadador());

		// Data Lançamento - Campo 0.17
		avisoBancario.setDataLancamento(dataGeracao);

		/*
		 * Máximo AVBC_NNSEQUENCIAL + 1 com ARRC_ID=Campo 0.01 e
		 * AVBC_DTLANCAMENTO=Campo 0.17 da tabela AVISO_BANCARIO, caso não
		 * exista atribuir o valor zero.
		 */
		avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);

		// Data Prevista
		avisoBancario.setDataPrevista(dataPrevistaCredito);

		// Data Realização
		avisoBancario.setDataRealizada(dataPrevistaCredito);

		// Valor Realizado
		avisoBancario.setValorRealizado(valorInformadoPagamento);

		// Valor Arrecadação Cálculado
		avisoBancario.setValorArrecadacaoCalculado(valorCalculadoPagamento);

		// Valor Devolução Calculado
		avisoBancario.setValorDevolucaoCalculado(BigDecimal.ZERO);

		// Valor Arrecadação Informado
		avisoBancario.setValorArrecadacaoInformado(valorInformadoPagamento);

		// Valor Devolução Informado
		avisoBancario.setValorDevolucaoInformado(BigDecimal.ZERO);

		// Valor Contabilizado
		avisoBancario.setValorContabilizado(BigDecimal.ZERO);

		int anoMesDataLancamento = Util.getAnoMesComoInt(dataGeracao);

		/*
		 * Ano/Mês Referência Arrecadação - Caso o ano/mês da data do lançamento seja maior que o
		 * PARM_AMREFERENCIAARRECADACAO da tabela SISTEMA_PARAMETROS atribuir
		 * ano/mês da data do lançamento
		 */
		if(anoMesDataLancamento > sistemaParametro.getAnoMesArrecadacao().intValue()){

			avisoBancario.setAnoMesReferenciaArrecadacao(anoMesDataLancamento);
		}else{

			// Caso contrário atribuir o PARM_AMREFERENCIAARRECADACAO
			avisoBancario.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao().intValue());
		}

		// Indicador Crédito/Débito
		avisoBancario.setIndicadorCreditoDebito(AvisoBancario.INDICADOR_CREDITO);

		// Data e Hora Correntes
		avisoBancario.setUltimaAlteracao(new Date());

		/*
		 * Conta Bancária - CTBC_IDDEPOSITOARRECBOLETO da tabela ARRECADADOR_CONTRATO com
		 * ARRC_ID=Campo 0.01 e ARCT_DTCONTRATOENCERRAMENTO com o valor nulo
		 */
		avisoBancario.setContaBancaria(arrecadadorContrato.getContaBancariaDepositoArrecadacaoBoleto());

		// Arrecadado Movimento - Id do ARRECADADOR_MOVIMENTO
		avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);

		return avisoBancario;
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * [SB0018] – Inserir o item de movimento do arrecadador do boleto bancário
	 * 
	 * @author Anderson Lima
	 * @date 04/10/2011
	 */
	private Integer inserirItemMovimentoArrecadadorBoletoBancario(String linhaRegistroCodigoT, String linhaRegistroCodigoU,
					Integer idMovimento, String descricaoOcorrencia, int indicadorAceitacaoRegistro, Integer idImovelBoleto)
					throws ControladorException{

		Integer idArrecadadorMovimentoItemInserido = null;

		/*
		 * Insere o item de movimento do arrecadador na tabela ARRECADADOR_MOVIMENTO_ITEM com os
		 * seguintes valores
		 */
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();

		// RGCD_ID da tabela REGISTRO_CODIGO com RGCD_CDREGISTROCODIGO igual ao código do registro
		String codigoRegistro = linhaRegistroCodigoT.substring(7, 8);
		Integer idRegistroCodigo = null;

		try{

			idRegistroCodigo = repositorioArrecadacao.pesquisarIdRegistroCodigo(codigoRegistro);
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		RegistroCodigo registroCodigo = new RegistroCodigo();
		registroCodigo.setId(idRegistroCodigo);
		arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);

		/*
		 * Conteúdo do movimento com 480 posições, obtido em [SB0019 – Gerar conteúdo do item do
		 * movimento de boleto bancário]
		 */
		String linhaRegistro = linhaRegistroCodigoT + linhaRegistroCodigoU;
		String caracterUltimaPosicaoLinha = linhaRegistro.substring(linhaRegistro.length() - 1);

		String linhaRegistroAuxiliar = "";
		if(caracterUltimaPosicaoLinha.equals(" ")){

			linhaRegistroAuxiliar = linhaRegistro.substring(0, linhaRegistro.length() - 1) + "*";
		}else{

			linhaRegistroAuxiliar = linhaRegistro;
		}

		arrecadadorMovimentoItem.setConteudoRegistro(linhaRegistroAuxiliar);

		// Arrecadador Movimento ARMV_ID
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);

		// Descrição da Ocorrência do Movimento
		arrecadadorMovimentoItem.setDescricaoOcorrencia(descricaoOcorrencia);

		// Indicador de Aceitação do Registro do Movimento
		arrecadadorMovimentoItem.setIndicadorAceitacao(Short.valueOf(String.valueOf(indicadorAceitacaoRegistro)));

		// Data e Hora Correntes
		arrecadadorMovimentoItem.setUltimaAlteracao(new Date());

		/*
		 * Caso a movimentação de retorno tenha sido gerada, atribuir a matrícula do imóvel do
		 * boleto bancário desta movimentação, caso contrário atribuir o valor nulo
		 */
		if(idImovelBoleto != null){

			Imovel imovel = new Imovel();
			imovel.setId(idImovelBoleto);
			arrecadadorMovimentoItem.setImovel(imovel);
		}

		try{

			idArrecadadorMovimentoItemInserido = (Integer) repositorioUtil.inserir(arrecadadorMovimentoItem);
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return idArrecadadorMovimentoItemInserido;
	}

	/**
	 * [UC3024] – Processar Movimento de Retorno do Boleto Bancário
	 * Este método permite o processamento dos movimentos de retornos obtidos na arrecadação que
	 * sejam de Boleto Bancário retornando uma coleção de pagamentos para inserção e efetuando os
	 * registros destas movimentações(Coleção de pagamentos gerada, Descrição da Ocorrência do
	 * Movimento, Indicador de Aceitação do Registro do Movimento).
	 * 
	 * @author Anderson Lima
	 * @date 04/10/2011
	 */
	private BoletoBancarioMovimentoProcessadoHelper processarMovimentoRetornoBoletoBancario(Integer idArrecadador,
					String codigoMovimentoRetorno, String identificacaoTituloBanco, String identificacaoTituloEmpresa,
					String motivosOcorrencia, String dataPagamento, BigDecimal valorRecebido, BigDecimal valorLiquido,
					BigDecimal valorAcrescimos, Date dataCredito, SistemaParametro sistemaParametro, String descricaoOcorrenciaMovimento,
					int indicadorAceitacaoRegistro) throws ControladorException, ErroRepositorioException{

		BoletoBancarioMovimentoProcessadoHelper boletoBancarioMovimentoProcessadoHelper = new BoletoBancarioMovimentoProcessadoHelper();
		boletoBancarioMovimentoProcessadoHelper.setDescricaoOcorrencia(descricaoOcorrenciaMovimento);
		boletoBancarioMovimentoProcessadoHelper.setIndicadorAceitacaoRegistro(String.valueOf(indicadorAceitacaoRegistro));

		Date dataMovimentacao = Util.converteStringParaDate(dataPagamento.substring(0, 2) + "/" + dataPagamento.substring(2, 4) + "/"
						+ dataPagamento.substring(4));

		// [FS0001] – Validar seqüencial do boleto bancário
		Long numeroSequencialBoleto = Long.valueOf(identificacaoTituloBanco.substring(7, 17));
		FiltroBoletoBancario filtroBoletoBancario = new FiltroBoletoBancario();
		filtroBoletoBancario.adicionarParametro(new ParametroSimples(FiltroBoletoBancario.NUMERO_SEQUENCIAL, numeroSequencialBoleto));
		filtroBoletoBancario.adicionarParametro(new ParametroSimples(FiltroBoletoBancario.ARRECADADOR_ID, idArrecadador));
		filtroBoletoBancario.adicionarCaminhoParaCarregamentoEntidade(FiltroBoletoBancario.DOCUMENTOCOBRANCA);

		Collection<BoletoBancario> colecaoBoletoBancario = getControladorUtil().pesquisar(filtroBoletoBancario,
						BoletoBancario.class.getName());

		if(Util.isVazioOrNulo(colecaoBoletoBancario)){

			boletoBancarioMovimentoProcessadoHelper.setDescricaoOcorrencia("BOLETO INEXISTENTE");
			boletoBancarioMovimentoProcessadoHelper.setIndicadorAceitacaoRegistro("2");
			return boletoBancarioMovimentoProcessadoHelper;
		}

		// [FS0002] – Validar a matrícula do imóvel
		Integer matriculaImovel = Util.obterInteger(identificacaoTituloEmpresa.substring(1, 9));
		FiltroImovel filtroImovel = new FiltroImovel();
		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, matriculaImovel));
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOCALIDADE);

		Collection<Imovel> colecaoImovel = getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());

		if(Util.isVazioOrNulo(colecaoImovel)){

			boletoBancarioMovimentoProcessadoHelper.setDescricaoOcorrencia("IMOVEL INEXISTENTE");
			boletoBancarioMovimentoProcessadoHelper.setIndicadorAceitacaoRegistro("2");
			return boletoBancarioMovimentoProcessadoHelper;
		}

		// O sistema consulta o boleto bancário
		BoletoBancario boletoBancario = (BoletoBancario) Util.retonarObjetoDeColecao(colecaoBoletoBancario);

		/*
		 * Caso o Código do Movimento Retorno seja um código de lançamento que efetue liquidação do
		 * boleto bancário
		 */
		FiltroBoletoBancarioLancamentoRetorno filtroBoletoBancarioLancamentoRetorno = new FiltroBoletoBancarioLancamentoRetorno();
		filtroBoletoBancarioLancamentoRetorno.adicionarParametro(new ParametroSimples(FiltroBoletoBancarioLancamentoRetorno.ID, Util
						.obterInteger(codigoMovimentoRetorno)));
		filtroBoletoBancarioLancamentoRetorno.adicionarParametro(new ParametroSimples(
						FiltroBoletoBancarioLancamentoRetorno.INDICADOR_LIQUIDACAO, ConstantesSistema.SIM));

		Collection<BoletoBancarioLancamentoRetorno> colecaoBoletoBancarioLancamentoRetorno = getControladorUtil().pesquisar(
						filtroBoletoBancarioLancamentoRetorno, BoletoBancarioLancamentoRetorno.class.getName());

		if(!Util.isVazioOrNulo(colecaoBoletoBancarioLancamentoRetorno)){

			/*
			 * o sistema processa o pagamento com boleto bancário <Inclui> [UC3021 – Processar
			 * Pagamento com Boleto Bancário] passando parâmetros a seguir e atribui o seu retorno a
			 * coleção de pagamentos, Descrição da Ocorrência do Movimento, Indicador de Aceitação
			 * do Registro do Movimento para repassar ao caso de uso/método que chamou este
			 */
			identificacaoTituloEmpresa = Util.completarStringZeroDireita(identificacaoTituloEmpresa, 23);
			String identificacaoDocumento = identificacaoTituloEmpresa.substring(11, 23);
			boletoBancarioMovimentoProcessadoHelper = this.processarPagamentoBoletoBancario(boletoBancario, identificacaoDocumento,
							dataMovimentacao, valorRecebido, valorAcrescimos, boletoBancarioMovimentoProcessadoHelper, sistemaParametro,
							(Imovel) Util.retonarObjetoDeColecao(colecaoImovel));

			/*
			 * Acumula o valor recebido se for do tipo 6 - Liquidação para no final atualizar o
			 * valor do movimento (ArrecadadorMovimento)
			 */
			boletoBancarioMovimentoProcessadoHelper.setValorRecebidoLiquidacao(valorRecebido);
		}

		/*
		 * O sistema armazena uma movimentação de boleto bancário (movimentação de retorno gerada)
		 * com os seguintes valores para ser retornada e inserida posteriormente na tabela
		 * BOLETO_BANCARIO_MOVIMENTACAO
		 */
		BoletoBancarioMovimentacao boletoBancarioMovimentacao = new BoletoBancarioMovimentacao();
		boletoBancarioMovimentacao.setBoletoBancario(boletoBancario);

		BoletoBancarioLancamentoRetorno boletoBancarioLancamentoRetorno = new BoletoBancarioLancamentoRetorno();
		boletoBancarioLancamentoRetorno.setId(Util.obterInteger(codigoMovimentoRetorno));

		boletoBancarioMovimentacao.setBoletoBancarioLancamentoRetorno(boletoBancarioLancamentoRetorno);
		boletoBancarioMovimentacao.setUsuario(Usuario.USUARIO_BATCH);
		boletoBancarioMovimentacao.setDataMovimentacao(dataMovimentacao);
		boletoBancarioMovimentacao.setUltimaAlteracao(new Date());
		boletoBancarioMovimentoProcessadoHelper.setMovimentacaoRetornoBoleto(boletoBancarioMovimentacao);

		/*
		 * O sistema trata os motivos de ocorrência para este retorno [SB0002] – Inserir
		 * ocorrências do retorno
		 */
		Object[] retornoInserirOcorrencias = this.inserirOcorrenciasRetornoBoletoBancario(motivosOcorrencia, boletoBancarioMovimentacao,
						boletoBancarioLancamentoRetorno);

		List<BoletoBancarioOcorrencias> colecaoBoletoBancarioOcorrencias = (List<BoletoBancarioOcorrencias>) retornoInserirOcorrencias[0];
		Boolean existeOcorrenciaMotivoProtestado = (Boolean) retornoInserirOcorrencias[1];

		boletoBancarioMovimentoProcessadoHelper.setColecaoOcorrenciasBoleto(colecaoBoletoBancarioOcorrencias);

		/*
		 * O sistema consulta os dados das relações Remessa-Retorno (código de remessa, código de
		 * retorno, situação do boleto, código de atualização da situação de cobrança, indicador de
		 * retirada de conta em revisão) para o código de retorno obtido
		 */
		FiltroBoletoBancarioEnvioRetornoSituacao filtroBoletoBancarioEnvioRetornoSituacao = new FiltroBoletoBancarioEnvioRetornoSituacao();
		filtroBoletoBancarioEnvioRetornoSituacao.adicionarParametro(new ParametroSimples(
						FiltroBoletoBancarioEnvioRetornoSituacao.BOLETO_BANCARIO_LANCAMENTO_RETORNO_ID, Util
										.obterInteger(codigoMovimentoRetorno)));
		filtroBoletoBancarioEnvioRetornoSituacao
						.adicionarCaminhoParaCarregamentoEntidade(FiltroBoletoBancarioEnvioRetornoSituacao.BOLETO_BANCARIO_LANCAMENTO_ENVIO);
		filtroBoletoBancarioEnvioRetornoSituacao.setCampoOrderBy(FiltroBoletoBancarioEnvioRetornoSituacao.BOLETO_BANCARIO_LANCAMENTO_ENVIO);

		// É necessário ordenar pelo BOLETO_BANCARIO_LANCAMENTO_ENVIO para tratar o movimento do
		// banco que não precisa de um envio associado

		Collection<BoletoBancarioEnvioRetornoSituacao> colecaoBoletoBancarioEnvioRetornoSituacao = getControladorUtil().pesquisar(
						filtroBoletoBancarioEnvioRetornoSituacao, BoletoBancarioEnvioRetornoSituacao.class.getName());

		// O sistema inicializa o campo “remessa-retorno” com nulo
		BoletoBancarioEnvioRetornoSituacao remessaRetorno = null;

		if(!Util.isVazioOrNulo(colecaoBoletoBancarioEnvioRetornoSituacao)){

			for(BoletoBancarioEnvioRetornoSituacao boletoBancarioEnvioRetornoSituacao : colecaoBoletoBancarioEnvioRetornoSituacao){

				// Caso exista uma remessa-retorno com código de envio diferente de nulo
				if(boletoBancarioEnvioRetornoSituacao.getBoletoBancarioLancamentoEnvio() != null){

					/*
					 * Caso exista uma movimentação de envio para o boleto bancário sem
					 * ter sido
					 * retornada e que seja deste tipo de envio
					 */
					FiltroBoletoBancarioMovimentacao filtroBoletoBancarioMovimentacao = new FiltroBoletoBancarioMovimentacao();
					filtroBoletoBancarioMovimentacao.adicionarParametro(new ParametroSimples(
									FiltroBoletoBancarioMovimentacao.BOLETO_BANCARIO_ID, boletoBancario.getId()));
					filtroBoletoBancarioMovimentacao.adicionarParametro(new ParametroSimples(
									FiltroBoletoBancarioMovimentacao.BOLETO_BANCARIO_LANCAMENTO_ENVIO_ID,
									boletoBancarioEnvioRetornoSituacao.getBoletoBancarioLancamentoEnvio().getId()));
					filtroBoletoBancarioMovimentacao.adicionarParametro(new ParametroNulo(
									FiltroBoletoBancarioMovimentacao.BOLETO_BANCARIO_MOVIMENTACAO_RETORNO_ID));

					Collection<BoletoBancarioMovimentacao> colecaoBoletoBancarioMovimentacao = getControladorUtil().pesquisar(
									filtroBoletoBancarioMovimentacao, BoletoBancarioMovimentacao.class.getName());

					if(!Util.isVazioOrNulo(colecaoBoletoBancarioMovimentacao)){
						// Caso exista movimentação, seta o campo “remessa-retorno”
						remessaRetorno = boletoBancarioEnvioRetornoSituacao;

						/*
						 * O sistema indica a atualização do retorno desta movimentação para a
						 * movimentação de retorno gerada e armazena esta movimentação de remessa
						 * para ser retornada e atualizada no caso de uso que chamou este (após a
						 * inserção da movimentação de retorno gerada)
						 */
						BoletoBancarioMovimentacao boletoBancarioMovimentacaoRemessa = (BoletoBancarioMovimentacao) Util
										.retonarObjetoDeColecao(colecaoBoletoBancarioMovimentacao);
						boletoBancarioMovimentacaoRemessa.setBoletoBancarioMovimentacaoRetorno(boletoBancarioMovimentoProcessadoHelper
										.getMovimentacaoRetornoBoleto());
						boletoBancarioMovimentoProcessadoHelper.setMovimentacaoRemessaBoleto(boletoBancarioMovimentacaoRemessa);
						break;
					}
				}else{
					// Caso em que o banco não precisa de um envio associado
					remessaRetorno = boletoBancarioEnvioRetornoSituacao;
				}
			}
		}

		/*
		 * Caso o campo remessaRetorno com valor nulo (não satisfez condições anteriores), atribuir
		 * o valor “CÓDIGO DE RETORNO NÃO ESPERADO” ao campo Descrição da Ocorrência do Movimento e
		 * o valor “2” e campo Indicador de Aceitação do Registro do Movimento
		 */
		if(remessaRetorno == null){

			boletoBancarioMovimentoProcessadoHelper.setDescricaoOcorrencia("CÓDIGO DE RETORNO NÃO ESPERADO");
			boletoBancarioMovimentoProcessadoHelper.setIndicadorAceitacaoRegistro(ConstantesSistema.NAO.toString());
		}else{

			// Para remessa de retorno selecionada
			this.tratarRemessaRetorno(dataMovimentacao, matriculaImovel, boletoBancario, remessaRetorno, existeOcorrenciaMotivoProtestado);
		}

		/*
		 * Caso a coleção de pagamentos não esteja vazia, o sistema atualiza o valor pago, o valor
		 * da tarifa e a data de crédito do boleto bancário, de acordo os valores
		 */
		if(!Util.isVazioOrNulo(boletoBancarioMovimentoProcessadoHelper.getColecaoPagamentos())){

			boletoBancario.setValorPago(valorRecebido);
			boletoBancario.setValorTarifa(valorRecebido.subtract(valorLiquido));
			boletoBancario.setDataPagamento(dataMovimentacao);
			boletoBancario.setDataCredito(dataCredito);
			boletoBancario.setUltimaAlteracao(new Date());
		}

		// Persiste a atualização do boleto bancario com os valores setados anteriormente
		getControladorUtil().atualizar(boletoBancario);

		return boletoBancarioMovimentoProcessadoHelper;

	}

	/**
	 * [UC3024] – Processar Movimento de Retorno do Boleto Bancário
	 * [SB0002] – Inserir ocorrências do retorno
	 * 
	 * @author Anderson Lima
	 * @date 10/10/2011
	 */
	private Object[] inserirOcorrenciasRetornoBoletoBancario(String motivosOcorrencia,
					BoletoBancarioMovimentacao boletoBancarioMovimentacao, BoletoBancarioLancamentoRetorno boletoBancarioLancamentoRetorno)
					throws ControladorException, ErroRepositorioException{

		Object[] retorno = new Object[2];

		// O sistema inicializa uma coleção de ocorrências
		List<BoletoBancarioOcorrencias> colecaoBoletoBancarioOcorrencias = new ArrayList<BoletoBancarioOcorrencias>();

		Boolean existeOcorrenciaMotivoProtestado = false;

		String codigosMotivosOcorrencia = "";

		// Caso os códigos de motivos de ocorrência não estejam em branco
		if(!Util.isVazioOuBranco(motivosOcorrencia)){

			// O sistema consulta os motivos de ocorrência para os códigos informados
			for(int i = 0; i < motivosOcorrencia.length(); i++){

				if(i % 2 > 0){

					switch(i){
						case 1:

							codigosMotivosOcorrencia += "'" + motivosOcorrencia.substring(0, 2) + "'";
							break;

						case 3:

							codigosMotivosOcorrencia += ",'" + motivosOcorrencia.substring(2, 4) + "'";
							break;
						case 5:

							codigosMotivosOcorrencia += ",'" + motivosOcorrencia.substring(4, 6) + "'";
							break;

						case 7:

							codigosMotivosOcorrencia += ",'" + motivosOcorrencia.substring(6, 8) + "'";
							break;
						case 9:

							codigosMotivosOcorrencia += ",'" + motivosOcorrencia.substring(8, 10) + "'";
							break;

						default:
							break;
					}
				}
			}

			List<BoletoBancarioMotivoOcorrencia> colecaoBoletoBancarioMotivoOcorrencias = repositorioArrecadacao
							.pesquisarBoletoBancarioMotivoOcorrencia(null, codigosMotivosOcorrencia);

			List<BoletoBancarioMotivoOcorrencia> colecaoBoletoBancarioMotivoOcorrenciasAdicionar = new ArrayList<BoletoBancarioMotivoOcorrencia>();

			if(boletoBancarioLancamentoRetorno != null && boletoBancarioLancamentoRetorno.getId() != null){

				FiltroBoletoBancarioLancamentoRetorno filtroBoletoBancarioLancamentoRetorno = new FiltroBoletoBancarioLancamentoRetorno();
				filtroBoletoBancarioLancamentoRetorno.adicionarParametro(new ParametroSimples(FiltroBoletoBancarioLancamentoRetorno.ID,
								boletoBancarioLancamentoRetorno.getId()));

				Collection<BoletoBancarioLancamentoRetorno> colecaoBoletoBancarioLancamentoRetorno = getControladorUtil().pesquisar(
								filtroBoletoBancarioLancamentoRetorno, BoletoBancarioLancamentoRetorno.class.getName());

				if(!Util.isVazioOrNulo(colecaoBoletoBancarioLancamentoRetorno)){

					boletoBancarioLancamentoRetorno = (BoletoBancarioLancamentoRetorno) Util
									.retonarObjetoDeColecao(colecaoBoletoBancarioLancamentoRetorno);

					// Caso o tipo de ocorrência do código de retorno esteja diferente de nulo
					if(boletoBancarioLancamentoRetorno.getBoletoBancarioTipoOcorrencia() != null){

						// Restringir a consulta para os motivos que estejam associados a este tipo
						if(colecaoBoletoBancarioMotivoOcorrencias != null && !colecaoBoletoBancarioMotivoOcorrencias.isEmpty()){

							for(BoletoBancarioMotivoOcorrencia boletoBancarioMotivoOcorrencia : colecaoBoletoBancarioMotivoOcorrencias){

								if(boletoBancarioMotivoOcorrencia.getBoletoBancarioTipoOcorrencia().getId().intValue() == boletoBancarioLancamentoRetorno
												.getBoletoBancarioTipoOcorrencia().getId().intValue()){

									colecaoBoletoBancarioMotivoOcorrenciasAdicionar.add(boletoBancarioMotivoOcorrencia);
								}
							}
						}
					}else{

						colecaoBoletoBancarioMotivoOcorrenciasAdicionar.addAll(colecaoBoletoBancarioMotivoOcorrencias);
					}

				}
			}

			/*
			 * Caso o resultado da consulta não seja vazio, para cada motivo da ocorrência
			 * resultante, o sistema adiciona na coleção de ocorrências, uma ocorrência com os
			 * seguintes valores para uma posterior inserção na tabela
			 * BOLETO_BANCARIO_OCORRENCIAS
			 */
			if(!colecaoBoletoBancarioMotivoOcorrenciasAdicionar.isEmpty()){
				Integer idBoletoBancarioMotivoOcorrencia = null;

				for(BoletoBancarioMotivoOcorrencia boletoBancarioMotivoOcorrencia : colecaoBoletoBancarioMotivoOcorrenciasAdicionar){
					idBoletoBancarioMotivoOcorrencia = boletoBancarioMotivoOcorrencia.getId();

					if(idBoletoBancarioMotivoOcorrencia.intValue() == BoletoBancarioMotivoOcorrencia.PROTESTADO.intValue()){
						existeOcorrenciaMotivoProtestado = true;
					}

					BoletoBancarioOcorrencias boletoBancarioOcorrencias = new BoletoBancarioOcorrencias();
					boletoBancarioOcorrencias.setBoletoBancarioMotivoOcorrencia(boletoBancarioMotivoOcorrencia);
					boletoBancarioOcorrencias.setBoletoBancarioMovimentacao(boletoBancarioMovimentacao);
					colecaoBoletoBancarioOcorrencias.add(boletoBancarioOcorrencias);
				}
			}
		}

		retorno[0] = colecaoBoletoBancarioOcorrencias;
		retorno[1] = existeOcorrenciaMotivoProtestado;

		return retorno;
	}

	/**
	 * [UC3024] – Processar Movimento de Retorno do Boleto Bancário
	 * Este método permite realizar o tratamento para remessa de retorno selecionada
	 * 
	 * @author Anderson Lima
	 * @date 11/10/2011
	 */
	private void tratarRemessaRetorno(Date dataMovimentacao, Integer matriculaImovel, BoletoBancario boletoBancario,
					BoletoBancarioEnvioRetornoSituacao remessaRetorno, Boolean existeOcorrenciaMotivoProtestado)
					throws ControladorException{

		/*
		 * Caso o campo “situação de boleto de
		 * cobrança” da remessa-retorno não esteja vazia, atualizar o boleto bancário com esta
		 * situação
		 */
		if(remessaRetorno.getSituacaoAtual() != null){

			// Caso a situação atual do boleto seja diferente da situação da remessa-retorno
			if(boletoBancario.getBoletoBancarioSituacao().getId().intValue() != remessaRetorno.getSituacaoAtual().getId().intValue()){

				/*
				 * Atualizar o boleto bancário com esta situação(Só persiste no final do método que
				 * chamou este pois ainda haverá outras atualizações no objeto boletoBancario em
				 * outros
				 * pontos.)
				 */
				boletoBancario.setBoletoBancarioSituacao(remessaRetorno.getSituacaoAtual());
				boletoBancario.setUltimaAlteracao(new Date());

				/*
				 * Caso BBST_ID de Remessa-retorno seja igual a BBST_ID de BOLETO_BANCARIO_SITUACAO
				 * com BBST_DSSITUACAOBOLETO igual a “CANCELADO”, atribuir BBMC_ID da tabela
				 * BOLETO_BANCARIO_MOT_CANCEL com BBMC_DSMOTIVOCANCELAMENTO referente a “CANCELADO
				 * POR REJEICAO DO BANCO”; caso contrário, atribuir nulo.
				 */
				if(remessaRetorno.getSituacaoAtual().getId().equals(BoletoBancarioSituacao.CANCELADO)){

					BoletoBancarioMotivoCancelamento boletoBancarioMotivoCancelamento = new BoletoBancarioMotivoCancelamento();
					boletoBancarioMotivoCancelamento.setId(BoletoBancarioMotivoCancelamento.CANCELADO_REJEICAO_BANCO);
					boletoBancario.setBoletoBancarioMotivoCancelamento(boletoBancarioMotivoCancelamento);
					boletoBancario.setDataCancelamento(dataMovimentacao);
				}else{

					boletoBancario.setBoletoBancarioMotivoCancelamento(null);
				}

				// Inclui na tabela BOLETO_BANCARIO_SIT_HISTORICO um registro com os seguintes dados
				BoletoBancarioSituacaoHistorico boletoBancarioSituacaoHistorico = new BoletoBancarioSituacaoHistorico();
				boletoBancarioSituacaoHistorico.setBoletoBancario(boletoBancario);
				boletoBancarioSituacaoHistorico.setBoletoBancarioSituacao(remessaRetorno.getSituacaoAtual());
				boletoBancarioSituacaoHistorico.setDataEntrada(new Date());
				boletoBancarioSituacaoHistorico.setUltimaAlteracao(new Date());

				getControladorUtil().inserir(boletoBancarioSituacaoHistorico);
			}
		}

		FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, matriculaImovel));
		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
						CobrancaSituacao.COBRANCA_BANCARIA));
		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroNulo(FiltroImovelCobrancaSituacao.DATA_RETIRADA_COBRANCA));

		Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
						ImovelCobrancaSituacao.class.getName());

		/*
		 * Caso a relação remessa-retorno esteja configurada para realizar a operação de INCLUIR
		 * (“código de atualização da situação de cobrança” da remessa-retorno igual a 1)
		 */
		if(remessaRetorno.getCodigoAtualizarSituacaoCobranca().shortValue() == ConstantesSistema.SIM.shortValue()){

			/*
			 * Caso o imóvel não tenha nenhuma situação de cobrança vigente do tipo “COBRANÇA
			 * BANCÁRIA”
			 */
			if(Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){

				/*
				 * o sistema deve realizar a inclusão de um registro na tabela
				 * IMOVEL_COBRANCA_SITUACAO com os seguintes valores
				 */
				ImovelCobrancaSituacao imovelCobrancaSituacao = new ImovelCobrancaSituacao();

				// Matrícula do Imóvel
				imovelCobrancaSituacao.setImovel(new Imovel(matriculaImovel));

				// Data da movimentação
				imovelCobrancaSituacao.setDataImplantacaoCobranca(dataMovimentacao);

				/*
				 * Caso o boleto bancário tenha um cliente responsável preenchido, atribuir
				 * CLIE_IDRESPONSAVEL da tabela BOELTO_BANCARIO
				 */
				if(boletoBancario.getCliente() != null){

					imovelCobrancaSituacao.setCliente(boletoBancario.getCliente());
				}else{

					// Caso contrário, CLIE_ID do cliente do tipo usuário do imóvel.
					Cliente clienteUsuario = getControladorImovel().pesquisarClienteUsuarioImovel(matriculaImovel);
					imovelCobrancaSituacao.setCliente(clienteUsuario);
				}

				// Data e hora correntes
				imovelCobrancaSituacao.setUltimaAlteracao(new Date());

				/*
				 * CBST_ID da tabela COBRANCA_SITUACAO referente ao registro com
				 * CBST_DSCOBRANCASITUACAO igual a “Cobrança Bancária”
				 */
				imovelCobrancaSituacao.setCobrancaSituacao(new CobrancaSituacao(CobrancaSituacao.COBRANCA_BANCARIA));

				/*
				 * Motivo de revisão das contas associadas a situação da cobrança (CMRV_ID da
				 * tabela COBRANCA_SITUACAO)
				 */
				FiltroCobrancaSituacao filtroCobrancaSituacao = new FiltroCobrancaSituacao();
				filtroCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroCobrancaSituacao.ID,
								CobrancaSituacao.COBRANCA_BANCARIA));

				Collection<CobrancaSituacao> colecaoCobrancaSituacao = getControladorUtil().pesquisar(filtroCobrancaSituacao,
								CobrancaSituacao.class.getName());

				CobrancaSituacao cobrancaSituacao = (CobrancaSituacao) Util.retonarObjetoDeColecao(colecaoCobrancaSituacao);
				imovelCobrancaSituacao.setContaMotivoRevisao(cobrancaSituacao.getContaMotivoRevisao());

				getControladorUtil().inserir(imovelCobrancaSituacao);
			}

		}else{

			/*
			 * Caso a relação remessa-retorno esteja configurada para realizar a operação de RETIRAR
			 * (“código de atualização da situação de cobrança” da remessa-retorno igual a 2). Caso
			 * o imóvel tenha alguma situação de cobrança vigente do tipo “COBRANÇA BANCÁRIA”
			 */
			if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){

				/*
				 * o sistema deve realizar a alteração da data de retirada da ocorrência
				 * encontrada com os seguintes valores
				 */
				for(ImovelCobrancaSituacao imovelCobrancaSituacao : colecaoImovelCobrancaSituacao){

					// APAGAR, MUDANÇA da OC923077
					// FiltroBoletoBancario filtroBoletoBancario = new FiltroBoletoBancario();
					// filtroBoletoBancario.adicionarCaminhoParaCarregamentoEntidade("boletoBancarioSituacao");
					//
					// filtroBoletoBancario.adicionarParametro(new
					// ParametroSimplesDiferenteDe(FiltroBoletoBancario.ID,
					// boletoBancario.getId()));
					//
					// Integer idImovel = imovelCobrancaSituacao.getImovel().getId();
					// filtroBoletoBancario.adicionarParametro(new
					// ParametroSimples(FiltroBoletoBancario.IMOVEL_ID, idImovel));
					//
					// filtroBoletoBancario.adicionarParametro(new
					// ParametroSimples(FiltroBoletoBancario.SITUACAO_ATUAL_ID,
					// BoletoBancarioSituacao.EM_CARTORIO, ConectorOr.CONECTOR_OR, 3));
					// filtroBoletoBancario.adicionarParametro(new
					// ParametroSimples(FiltroBoletoBancario.SITUACAO_ATUAL_ID,
					// BoletoBancarioSituacao.EM_CARTEIRA));
					// filtroBoletoBancario.adicionarParametro(new
					// ParametroSimples(FiltroBoletoBancario.SITUACAO_ATUAL_ID,
					// BoletoBancarioSituacao.BAIXA));
					/*
					 * ArrayList<Integer> listaBoletoSituacoes = new ArrayList<Integer>();
					 * listaBoletoSituacoes.add(BoletoBancarioSituacao.EM_CARTORIO);
					 * listaBoletoSituacoes.add(BoletoBancarioSituacao.EM_CARTEIRA);
					 * filtroBoletoBancario.adicionarParametro(new
					 * ParametroSimplesColecao(FiltroBoletoBancario.SITUACAO_ATUAL_ID,
					 * listaBoletoSituacoes));
					 */
					// Collection<BoletoBancario> colecaoBoletoBancario =
					// getControladorUtil().pesquisar(filtroBoletoBancario,
					// BoletoBancario.class.getName());

					Integer qtdBoletosVigentes = getControladorCobranca().pesquisarQuantidadeBoletosVigentesDoImovel(
									imovelCobrancaSituacao.getImovel().getId(), boletoBancario.getId());

					/*
					 * e não existam boletos bancários vigentes para este imóvel (não existe
					 * ocorrência na tabela BOLETO_BANCARIO com BBCO_ID diferente do Id do Boleto
					 * Bancário e IMOV_ID= Matrícula da imóvel e BBST_IDATUAL=relativos às situações
					 * “EM CARTEIRA” ou “EM CARTORIO”)
					 */
					if(qtdBoletosVigentes == 0){

						// Data da Movimentação
						imovelCobrancaSituacao.setDataRetiradaCobranca(dataMovimentacao);

						// Data e hora correntes
						imovelCobrancaSituacao.setUltimaAlteracao(new Date());

						getControladorUtil().atualizar(imovelCobrancaSituacao);
					}
				}
			}
		}

		/*
		 * Caso o boleto báncário possua documento de cobrança associado e caso a relação
		 * remessa-retorno esteja indicada para retirar contas de revisão (“indicador
		 * de retirada de conta em revisão” igual a 1), o sistema vai retirar de revisão as contas
		 * contidas no boleto bancário [SB0001 – Retirar Contas de Revisão]
		 */
		if(boletoBancario.getDocumentoCobranca() != null
						&& remessaRetorno.getIndicadorRetirarContasRevisao().shortValue() == ConstantesSistema.SIM.shortValue()){

			// Caso não exista ocorrência de protesto para a movimentação de retorno em
			// processamento
			if(existeOcorrenciaMotivoProtestado == null || (existeOcorrenciaMotivoProtestado != null && !existeOcorrenciaMotivoProtestado)){
				// O sistema retira de revisão as contas associadas ao boleto bancário de acordo com
				// as seguintes regras: Seleciona os itens de débito do documento de cobrança
				// associado ao boleto bancário do tipo conta.

				FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItem = new FiltroCobrancaDocumentoItem();
				filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.DOCUMENTO_TIPO_ID,
								DocumentoTipo.CONTA));
				filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ID,
								boletoBancario.getDocumentoCobranca().getId()));
				filtroCobrancaDocumentoItem.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.CONTA_GERAL);
				filtroCobrancaDocumentoItem.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.CONTA_GERAL_CONTA);

				Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItem = this.getControladorUtil().pesquisar(
								filtroCobrancaDocumentoItem, CobrancaDocumentoItem.class.getName());

				// Para cada item de débito do tipo conta selecionado
				for(CobrancaDocumentoItem cobrancaDocumentoItem : colecaoCobrancaDocumentoItem){

					String motivoRevisaoCobrancaBancaria = (String) ParametroCobranca.P_MOTIVO_REVISAO_COBRANCA_BANCARIA.executar(this);

					// Caso a conta não esteja no histórico e esteja em revisão pelo motivo de
					// cobrança bancária

					if(cobrancaDocumentoItem.getContaGeral().getConta() != null
									&& cobrancaDocumentoItem.getContaGeral().getConta().getContaMotivoRevisao() != null
									&& cobrancaDocumentoItem.getContaGeral().getConta().getContaMotivoRevisao().getId().intValue() == Util
													.obterInteger(motivoRevisaoCobrancaBancaria).intValue()){

						// Retira a conta de revisão. <<Inclui>> [UC0149 - Retirar Conta de
						// Revisão], passando a conta. Registra a transação de retirar conta de
						// revisão <<Inclui>> [UC0107 – Registrar Transação]

						Collection<Conta> colecaoConta = new ArrayList<Conta>();
						colecaoConta.add(cobrancaDocumentoItem.getContaGeral().getConta());

						this.getControladorFaturamento().retirarRevisaoConta(colecaoConta, null, Usuario.USUARIO_BATCH);
					}
				}
			}
		}
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * Este método permite o processamento de pagamento através de Boleto Bancário retornando uma
	 * Coleção de Pagamentos gerada para inserção, Descrição da Ocorrência do Movimento e Indicador
	 * de Aceitação do Registro do Movimento.
	 * 
	 * @author Anderson Lima
	 * @date 06/10/2011
	 */
	private BoletoBancarioMovimentoProcessadoHelper processarPagamentoBoletoBancario(BoletoBancario boletoBancario,
					String identificacaoDocumento, Date dataMovimentacao, BigDecimal valorRecebido, BigDecimal valorAcrescimos,
					BoletoBancarioMovimentoProcessadoHelper boletoBancarioMovimentoProcessadoHelper, SistemaParametro sistemaParametro,
					Imovel imovel) throws ControladorException, ErroRepositorioException{

		BoletoBancarioMovimentoProcessadoHelper boletoHelperRetorno = boletoBancarioMovimentoProcessadoHelper;

		// O sistema atribui o valor 1 (SIM) ao Indicador de Aceitação do Registro do Movimento
		boletoBancarioMovimentoProcessadoHelper.setIndicadorAceitacaoRegistro(ConstantesSistema.SIM.toString());

		// O sistema inicializa uma coleção de pagamentos
		boletoBancarioMovimentoProcessadoHelper.setColecaoPagamentos(new ArrayList<Pagamento>());

		// Caso o boleto bancário esteja associado a um documento de cobrança
		if(boletoBancario.getDocumentoCobranca() != null){

			// [SB0001] – Processar Pagamento de Documento de Cobrança
			boletoHelperRetorno = this.processarPagamentoDocumentoCobranca(boletoBancarioMovimentoProcessadoHelper, boletoBancario,
							dataMovimentacao, sistemaParametro, imovel, valorRecebido, valorAcrescimos);
		}

		// Caso o boleto bancário esteja associado a uma prestação de guia de pagamento
		if(boletoBancario.getGuiaPagamento() != null){

			// [SB002] – Processar pagamento de guia de pagamento prestação
			boletoHelperRetorno = this.processarPagamentoGuiaPagamentoPrestacao(boletoBancarioMovimentoProcessadoHelper, dataMovimentacao,
							sistemaParametro, valorRecebido, identificacaoDocumento, valorAcrescimos);
		}

		return boletoHelperRetorno;
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * [SB002] – Processar pagamento de guia de pagamento prestação
	 * 
	 * @author Anderson Lima
	 * @date 14/10/2011
	 */
	private BoletoBancarioMovimentoProcessadoHelper processarPagamentoGuiaPagamentoPrestacao(
					BoletoBancarioMovimentoProcessadoHelper boletoBancarioMovimentoProcessadoHelper, Date dataPagamento,
					SistemaParametro sistemaParametro, BigDecimal valorRecebido, String identificacaoDocumento, BigDecimal valorAcrescimos)
					throws ControladorException, ErroRepositorioException{

		BoletoBancarioMovimentoProcessadoHelper boletoHelperRetorno = boletoBancarioMovimentoProcessadoHelper;

		// Caso a Descrição da Ocorrência do Movimento corresponda a “OK”
		if(boletoHelperRetorno.getDescricaoOcorrencia().equals("OK")){

			Integer idGuiaPagamento = Util.obterInteger(identificacaoDocumento.substring(0, 9));
			Short numeroPrestacao = Util.obterShort(identificacaoDocumento.substring(9));
			Collection<Integer> colecaoDebitoCreditoSituacaoAtual = new ArrayList<Integer>();
			colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.NORMAL);
			colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.RETIFICADA);
			colecaoDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.INCLUIDA);

			FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
							idGuiaPagamento));
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
							numeroPrestacao));
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimplesColecao(
							FiltroGuiaPagamentoPrestacao.DEBITO_CREDITO_SITUACAO_ATUAL_ID, colecaoDebitoCreditoSituacaoAtual));
			filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO);

			Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacaoPrestacao = getControladorUtil().pesquisar(
							filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

			if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoPrestacao)){

				GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) Util
								.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoPrestacao);

				/*
				 * Armazena na coleção de pagamentos os dados do pagamento da guia de pagamento para
				 * posterior inserção na tabela PAGAMENTO com os seguintes valores
				 */
				Pagamento pagamento = new Pagamento();

				int anoMesPagamento = Util.getAnoMesComoInt(dataPagamento);

				/*
				 * Ano Mês Referênciada Arrecadação -
				 * Caso o ano/mês da data do pagamento seja maior que a
				 * PARM_AMREFERENCIAARRECADACAO da tabela SISTEMA_PARAMETROS
				 */
				if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao().intValue()){

					// Atribuir ano/mês da data do pagamento
					pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
				}else{

					// Caso contrário atribuir o PARM_AMREFERENCIAARRECADACAO
					pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao().intValue());
				}

				if(valorAcrescimos.compareTo(BigDecimal.ZERO) > 0){
					// [SB0006] – Acrescentar Acréscimos por Impontualidade na Guia de Pagamento
					// Prestação
					Integer idDebitoTipo = DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE;

					FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));

					Collection<DebitoTipo> colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo,
									DebitoTipo.class.getName());

					if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
						DebitoTipo debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

						this.acrescentarAcrescimosPorImpontualidadeNaGuia(idGuiaPagamento, numeroPrestacao, valorAcrescimos, debitoTipo,
										dataPagamento, sistemaParametro, guiaPagamentoPrestacao.getIndicadorPagamentoPendente(),
										guiaPagamentoPrestacao.getIndicadorCobrancaMulta(), guiaPagamentoPrestacao.getDataEmissao(),
										guiaPagamentoPrestacao.getDataVencimento());

						// [SB0007] – Distribuir Valores Guia por Categoria
						GuiaPagamento guiaPagamento = guiaPagamentoPrestacao.getGuiaPagamento();
						Imovel imovel = guiaPagamento.getImovel();

						this.distribuirValoresGuiaPorCategoria(idGuiaPagamento, numeroPrestacao, imovel);
					}
				}

				// Valor Pagamento
				pagamento.setValorPagamento(valorRecebido);

				// Data do Pagamento
				pagamento.setDataPagamento(dataPagamento);

				// Débito Tipo - DBTP_ID da tabela GUIA_PAGAMENTO_PRESTACAO
				pagamento.setDebitoTipo(guiaPagamentoPrestacao.getDebitoTipo());

				// Guia Pagamento - Atribuir o id da guia de pagamento
				GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
				guiaPagamentoGeral.setId(guiaPagamentoPrestacao.getGuiaPagamento().getId());
				guiaPagamentoGeral.setGuiaPagamento(new GuiaPagamento(guiaPagamentoPrestacao.getGuiaPagamento().getId()));
				pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);

				// Localidade - Atribuir LOCA_ID da tabela GUIA_PAGAMENTO
				pagamento.setLocalidade(guiaPagamentoPrestacao.getGuiaPagamento().getLocalidade());

				/*
				 * Documento Tipo - Com o valor correspondente a guia de pagamento da tabela
				 * DOCUMENTO_TIPO
				 */
				DocumentoTipo documentoTipo = new DocumentoTipo();
				documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
				pagamento.setDocumentoTipo(documentoTipo);

				// Imóvel - Atribuir IMOV_ID da tabela GUIA_PAGAMENTO
				pagamento.setImovel(guiaPagamentoPrestacao.getGuiaPagamento().getImovel());

				// Arrecador Forma
				ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				arrecadacaoForma.setId(ArrecadacaoForma.COBRANCA_BANCARIA);
				pagamento.setArrecadacaoForma(arrecadacaoForma);

				// Data e Hora Corrente
				pagamento.setUltimaAlteracao(new Date());

				// Número da Prestação atribuir GPPR_NNPRESTACAO da tabela GUIA_PAGAMENTO_PRESTACAO
				pagamento.setNumeroPrestacao(guiaPagamentoPrestacao.getComp_id().getNumeroPrestacao().intValue());

				boletoHelperRetorno.getColecaoPagamentos().add(pagamento);

				/*
				 * Caso a guia de pagamento se refira a última prestação de um parcelamento
				 * realizado para um boleto bancário (da tabela GUIA_PAGAMENTO com
				 * GPAG_NNPRESTACAOTOTAL = GPPR_NNPRESTACAO da prestação da guia de pagamento obtida
				 * no item 1.1)
				 */
				/*
				 * COMENTARIO GERADO PARA ATENDER A CR103158
				 * if(guiaPagamentoPrestacao.getGuiaPagamento().getNumeroPrestacaoTotal().shortValue(
				 * ) == guiaPagamentoPrestacao.getComp_id()
				 * .getNumeroPrestacao().shortValue()){
				 * E que não haja outros boletos vigentes para este imóvel (ocorrência na tabela
				 * BOLETO_BANCARIO com IMOV_ID = IMOV_ID da GUIA_PAGAMENTO e BBST_IDATUAL =
				 * BBST_IDATUAL não relativos as situações “LIQUIDAÇÃO” e “BAIXA”)
				 * Collection<Integer> colecaoIdBoletoBancarioSituacao = new ArrayList<Integer>();
				 * colecaoIdBoletoBancarioSituacao.add(BoletoBancarioSituacao.LIQUIDACAO);
				 * colecaoIdBoletoBancarioSituacao.add(BoletoBancarioSituacao.BAIXA);
				 * FiltroBoletoBancario filtroBoletoBancario = new FiltroBoletoBancario();
				 * filtroBoletoBancario.adicionarParametro(new
				 * ParametroSimples(FiltroBoletoBancario.IMOVEL, guiaPagamentoPrestacao
				 * .getGuiaPagamento().getImovel().getId()));
				 * filtroBoletoBancario.adicionarParametro(new
				 * ParametroSimplesColecao(FiltroBoletoBancario.SITUACAO_ATUAL_ID,
				 * colecaoIdBoletoBancarioSituacao));
				 * Collection<BoletoBancario> colecaoBoletoBancario =
				 * getControladorUtil().pesquisar(filtroBoletoBancario,
				 * BoletoBancario.class.getName());
				 * if(Util.isVazioOrNulo(colecaoBoletoBancario)){
				 * O sistema retira o imóvel da situação de cobrança “Cobrança bancária”
				 * [SB0006 – Retirar situação de cobrança do imóvel]
				 * this.retirarSituacaoCobrancaImovel(dataPagamento, guiaPagamentoPrestacao);
				 * }
				 * }
				 */

			}else{

				/*
				 * Caso a guia de pagamento não exista, atribuir o valor “GUIA DE PAGAMENTO
				 * INEXISTENTE” ao campo Descrição da Ocorrência do Movimento
				 */
				boletoHelperRetorno.setDescricaoOcorrencia("GUIA DE PAGAMENTO INEXISTENTE");

				// Atribuir o valor 2 (NÃO) ao Indicador de Aceitação do Registro do Movimento
				boletoHelperRetorno.setIndicadorAceitacaoRegistro(ConstantesSistema.NAO.toString());
			}
		}else{

			// Caso contrário, atribuir o valor 2 (NÃO) ao Indicador de Aceitação do Registro do
			// Movimento
			boletoHelperRetorno.setIndicadorAceitacaoRegistro(ConstantesSistema.NAO.toString());
		}

		return boletoHelperRetorno;
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * [SB0006] – Retirar situação de cobrança do imóvel
	 * 
	 * @author Anderson Lima
	 * @date 14/10/2011
	 */
	@Deprecated
	private void retirarSituacaoCobrancaImovel(Date dataPagamento, GuiaPagamentoPrestacao guiaPagamentoPrestacao)
					throws ControladorException{

		/*
		 * Caso o imóvel tenha alguma situação de cobrança vigente do tipo “COBRANÇA
		 * BANCÁRIA” (algum ocorrência na tabela IMOVEL_COBRANCA_SITUACAO com
		 * IMOV_ID = Matrícula da imóvel e CBST_ID = CBST_ID da tabela
		 * COBRANCA_SITUACAO referente ao registro com CBST_DSCOBRANCASITUACAO igual
		 * a “Cobrança Bancária” e ISCB_DTRETIRADACOBRANCA seja nulo)
		 */
		FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, guiaPagamentoPrestacao
						.getGuiaPagamento().getImovel().getId()));
		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
						CobrancaSituacao.COBRANCA_BANCARIA));
		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroNulo(FiltroImovelCobrancaSituacao.DATA_RETIRADA_COBRANCA));

		Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
						ImovelCobrancaSituacao.class.getName());

		if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){

			/*
			 * O sistema deve realizar a alteração da data de retirada da ocorrência
			 * encontrada com os seguintes valores
			 */

			ImovelCobrancaSituacao imovelCobrancaSituacao = (ImovelCobrancaSituacao) Util
							.retonarObjetoDeColecao(colecaoImovelCobrancaSituacao);

			// Data retirada cobrança - Atribuir data da movimentação/pagamento
			imovelCobrancaSituacao.setDataRetiradaCobranca(dataPagamento);

			// Data e Hora Corrente
			imovelCobrancaSituacao.setUltimaAlteracao(new Date());

			getControladorUtil().atualizar(imovelCobrancaSituacao);

		}
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * [SB0001] – Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Anderson Lima
	 * @date 06/10/2011
	 */
	private BoletoBancarioMovimentoProcessadoHelper processarPagamentoDocumentoCobranca(
					BoletoBancarioMovimentoProcessadoHelper boletoBancarioMovimentoProcessadoHelper, BoletoBancario boletoBancario,
					Date dataPagamento, SistemaParametro sistemaParametro, Imovel imovel, BigDecimal valorRecebido,
					BigDecimal valorAcrescimosRecebidos) throws ControladorException, ErroRepositorioException{

		BoletoBancarioMovimentoProcessadoHelper boletoHelperRetorno = boletoBancarioMovimentoProcessadoHelper;
		Pagamento pagamento = null;

		// Caso a Descrição da Ocorrência do Movimento corresponda a “OK”
		if(boletoHelperRetorno.getDescricaoOcorrencia().equals("OK")){

			CobrancaDocumento cobrancaDocumento = boletoBancario.getDocumentoCobranca();

			/*
			 * Valor total de acréscimos = Valor dos acréscimos do documento de cobrança
			 * (CBDO_VLACRESCIMOS da tabela COBRANCA_DOCUMENTO) + Valor dos acréscimos recebidos
			 */
			BigDecimal valorAcrescimos = cobrancaDocumento.getValorAcrescimos();

			// Caso o valor dos acréscimos seja nulo, atribuir o valor zero
			if(valorAcrescimos == null){

				valorAcrescimos = BigDecimal.ZERO;
			}

			if(valorAcrescimosRecebidos != null){

				valorAcrescimos = valorAcrescimos.add(valorAcrescimosRecebidos);
			}

			/*
			 * O método que representa este sub-fluxo não foi criado pois já existia para o
			 * [UC0259] - Processar Pagamento com código de Barras [SB0008] - Alterar Vencimento
			 * dos Itens do documento de cobrança um método com comportamento semelhante a este
			 * descrito pelo [SB0005 – Alterar vencimento dos
			 * itens do documento de cobrança] e
			 * foi reutilizado
			 */
			Date dataVencimento = null;

			/*
			 * Caso valor dos acréscimos recebidos pelo banco seja igual a zero, atribuir data
			 * do pagamento como a nova data de vencimento
			 */
			if(valorAcrescimosRecebidos.compareTo(BigDecimal.ZERO) == 0){

				dataVencimento = dataPagamento;
			}else{

				/*
				 * Caso contrário, atribuir data de emissão documento de cobrança (extrair a data do
				 * CBDO_TMEMISSAO da tabela COBRANCA_DOCUMENTO)
				 */
				dataVencimento = cobrancaDocumento.getEmissao();
			}

			this.alterarVencimentoItensDocumentoCobranca(cobrancaDocumento.getId(), dataVencimento);

			// Valor dos descontos do documento de cobrança
			BigDecimal valorDescontos = cobrancaDocumento.getValorDesconto();

			// Caso o valor dos descontos seja nulo, atribuir o valor zero
			if(valorDescontos == null){

				valorDescontos = BigDecimal.ZERO;
			}

			// Caso o valor dos acréscimos seja maior que o valor dos descontos
			if(valorAcrescimos.compareTo(valorDescontos) == 1){

				valorAcrescimos = valorAcrescimos.subtract(valorDescontos);
				valorDescontos = BigDecimal.ZERO;
			}else{

				valorDescontos = valorDescontos.subtract(valorAcrescimos);
				valorAcrescimos = BigDecimal.ZERO;
			}

			this.retificarContasDocumentoCobranca(cobrancaDocumento.getId(), valorAcrescimos, sistemaParametro, dataPagamento);

			/*
			 * Caso o valor da taxa referente ao documento de cobrança seja maior que zero [SB0004
			 * –Processar Taxa do Documento de Cobrança]
			 */
			if(cobrancaDocumento.getValorTaxa() != null && (cobrancaDocumento.getValorTaxa().compareTo(BigDecimal.ZERO) == 1)){

				/*
				 * O método que representa este sub-fluxo não foi criado pois já existia para o
				 * UC0259] - Processar Pagamento com código de Barras [SB0005] - Processar
				 * Recebimento de Acréscimos por Impontualidade um método com comportamento
				 * semelhante a este
				 * descrito pelo [SB0004
				 * –Processar Taxa do Documento de Cobrança] e
				 * foi reutilizado
				 */
				pagamento = this.processarTaxaDocumentoCobranca(cobrancaDocumento.getId(), dataPagamento, valorAcrescimos, imovel.getId(),
								imovel.getLocalidade().getId(), sistemaParametro, ArrecadacaoForma.COBRANCA_BANCARIA);

				boletoHelperRetorno.getColecaoPagamentos().add(pagamento);
			}

			/*
			 * Para os itens do documento de cobrança com o id do crédito a realizar não
			 * preenchido, o sistema armazena na coleção de pagamentos, para cada item cobrado os
			 * dados dos pagamentos dos itens do documento de cobrança para posterior inserção na
			 * tabela PAGAMENTO com os seguintes valores
			 */
			boletoHelperRetorno.getColecaoPagamentos().addAll(
							gerarPagamentoItensCobrancaDocumentoBoletoBancario(dataPagamento, sistemaParametro, valorRecebido,
											cobrancaDocumento));
		}else{

			// Caso contrário, atribuir o valor 2 (NÃO) ao Indicador de Aceitação do Registro do
			// Movimento
			boletoHelperRetorno.setIndicadorAceitacaoRegistro(ConstantesSistema.NAO.toString());
		}

		return boletoHelperRetorno;
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * [SB0001] – Processar Pagamento de Documento de Cobrança
	 * Para os itens do documento de cobrança com o id do crédito a realizar não
	 * preenchido, o sistema armazena na coleção de pagamentos, para cada item cobrado os
	 * dados dos pagamentos dos itens do documento de cobrança para posterior inserção na
	 * tabela PAGAMENTO com os seguintes valores
	 * 
	 * @author Anderson Lima
	 * @date 13/10/2011
	 */
	private List<Pagamento> gerarPagamentoItensCobrancaDocumentoBoletoBancario(Date dataPagamento, SistemaParametro sistemaParametro,
					BigDecimal valorRecebido, CobrancaDocumento cobrancaDocumento) throws ControladorException, ErroRepositorioException{

		List<Pagamento> colecaoPagamento = new ArrayList<Pagamento>();

		Collection colecaoCobrancaDocumentoItem = repositorioCobranca.pesquisarItensCobrancaDocumento(cobrancaDocumento.getId());

		if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){

			Pagamento pagamento = null;
			for(Iterator iterator = colecaoCobrancaDocumentoItem.iterator(); iterator.hasNext();){

				Object[] item = (Object[]) iterator.next();
				pagamento = new Pagamento();
				GuiaPagamentoGeral guiaPagamentoGeral = null;
				Conta conta = null;
				DebitoACobrar debitoACobrar = null;
				DebitoTipo debitoTipo = null;
				DocumentoTipo documentoTipo = null;

				// Caso CNTA_ID da tabela COBRANCA_DOCUMENTO_ITEM seja diferente de nulo
				if(item[22] != null && !item[22].toString().equals("")){

					// Caso a conta não esteja no histórico
					if(item[23].toString().equals(ConstantesSistema.NAO.toString())){

						// Conta - Atribuir CNTA_ID da tabela COBRANCA_DOCUMENTO_ITEM.
						conta = new Conta();
						conta.setId(Util.obterInteger(item[22].toString()));
						pagamento.setConta(conta);

						// Localidade - atribuir o LOCA_ID da tabela CONTA
						pagamento.setLocalidade(new Localidade(Util.obterInteger(item[16].toString())));

						// Ano Mês de referência pagamento - Atribuir a referência da conta
						pagamento.setAnoMesReferenciaPagamento(Util.obterInteger(item[4].toString()));

						// Imóvel - obter o IMOV_ID da tabela CONTA
						pagamento.setImovel(new Imovel(Util.obterInteger(item[13].toString())));
					}else{

						// Ano Mês de referência pagamento - Atribuir a referência da conta do
						// histórico
						pagamento.setAnoMesReferenciaPagamento(Util.obterInteger(item[5].toString()));

						// Localidade - atribuir o LOCA_ID da tabela CONTA_HISTORICO
						pagamento.setLocalidade(new Localidade(Util.obterInteger(item[28].toString())));

						// Imóvel - obter o IMOV_ID da tabela CONTA_HISTORICO
						pagamento.setImovel(new Imovel(Util.obterInteger(item[32].toString())));
					}

					/*
					 * Documento Tipo - Caso o pagamento seja referente a uma conta atribuir o
					 * valor correspondente a conta da tabela DOCUMENTO_TIPO
					 */
					documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.CONTA);
					pagamento.setDocumentoTipo(documentoTipo);
				}else{

					/*
					 * Caso CNTA_ID seja diferente de nulo, atribuir nulo.
					 * Caso GPAG_ID seja diferente de nulo
					 */
					if(item[24] != null && !item[24].toString().equals("")){

						// Número da Prestação
						Short numeroPrestacao = 0;
						if(item[19] != null && !item[19].toString().equals("")){

							numeroPrestacao = Util.obterShort(item[19].toString());
						}

						// Caso a guia de pagamento não esteja no histórico
						if(item[25].toString().equals(ConstantesSistema.NAO.toString())){

							/*
							 * Guia de Pagamento - atribuir GPAG_ID da tabela
							 * COBRANCA_DOCUMENTO_ITEM
							 */
							guiaPagamentoGeral = new GuiaPagamentoGeral();
							guiaPagamentoGeral.setId(Util.obterInteger(item[24].toString()));
							guiaPagamentoGeral.setGuiaPagamento(new GuiaPagamento(guiaPagamentoGeral.getId()));
							pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);

							// Localidade - atribuir o LOCA_ID da tabela GUIA_PAGAMENTO
							pagamento.setLocalidade(new Localidade(Util.obterInteger(item[17].toString())));

							/*
							 * Débito Tipo - atribuir DBTP_ID da tabela GUIA_PAGAMENTO_PRESTACAO com
							 * GPAG_ID=GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM e
							 * GPAG_NNPRESTACAO=CDIT_NNPRESTACAO da tabela COBRANCA_DOCUMENTO_ITEM
							 */
							debitoTipo = new DebitoTipo();
							debitoTipo.setId(Util.obterInteger(item[6].toString()));

							// Imóvel - obter o IMOV_ID da tabela GUIA_PAGAMENTO
							pagamento.setImovel(new Imovel(Util.obterInteger(item[14].toString())));
						}else{

							// Localidade - atribuir o LOCA_ID da tabela GUIA_PAGAMENTO_HISTORICO
							pagamento.setLocalidade(new Localidade(Util.obterInteger(item[29].toString())));

							/*
							 * Débito Tipo - DBTP_ID da tabela GUIA_PAGAMENTO_PRESTACAO_HIST com
							 * GPAG_ID=GPAG_ID
							 * da tabela COBRANCA_DOCUMENTO_ITEM e GPPH_NNPRESTACAO=CDIT_NNPRESTACAO
							 * da tabela COBRANCA_DOCUMENTO_ITEM
							 */
							debitoTipo = new DebitoTipo();
							debitoTipo.setId(Util.obterInteger(item[7].toString()));

							// Imóvel - obter o IMOV_ID da tabela GUIA_PAGAMENTO_HISTORICO
							pagamento.setImovel(new Imovel(Util.obterInteger(item[33].toString())));
						}

						// Débito Tipo
						pagamento.setDebitoTipo(debitoTipo);

						if(guiaPagamentoGeral != null){

							/*
							 * Número da prestação - (CDIT_NNPRESTACAO da tabela
							 * COBRANCA_DOCUMENTO_ITEM), caso GPAG_ID da tabela
							 * COBRANCA_DOCUMENTO_ITEM seja diferente de nulo
							 */
							pagamento.setNumeroPrestacao(numeroPrestacao.intValue());
						}

						/*
						 * Caso o pagamento seja referente a uma guia de pagamento, atribuir o valor
						 * correspondente a guia de pagamento da tabela DOCUMENTO_TIPO
						 */
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
						pagamento.setDocumentoTipo(documentoTipo);
					}else if(item[26] != null && !item[26].toString().equals("")){

						// Caso o DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM seja diferente de nulo
						// Caso o débito a cobrar não esteja no histórico
						if(item[27].toString().equals(ConstantesSistema.NAO.toString())){

							// Débito a cobrar - Atribuir DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
							debitoACobrar = new DebitoACobrar();
							debitoACobrar.setId(Util.obterInteger(item[26].toString()));
							pagamento.setDebitoACobrar(debitoACobrar);

							// Localidade - atribuir o LOCA_ID da tabela DEBITO_A_COBRAR
							pagamento.setLocalidade(new Localidade(Util.obterInteger(item[18].toString())));

							/*
							 * Caso o débito a cobrar não esteja no histórico, (DAGE_ICHISTORICO=2
							 * da tabela DEBITO_A_COBRAR_HISTORICO com DBAC_ID=DBAC_ID da tabela
							 * COBRANCA_DOCUMENTO_ITEM), atribuir o tipo de débito (DBTP_ID da
							 * tabela DEBITO_A_COBRAR com DBAC_ID=DBAC_ID da tabela
							 * COBRANCA_DOCUMENTO_ITEM)
							 */
							debitoTipo = new DebitoTipo();
							debitoTipo.setId(Util.obterInteger(item[8].toString()));

							/*
							 * Atualiza na tabela DEBITO_A_COBRAR a situação atual
							 * (DCST_IDATUAL)
							 * com o valor correspondente a pago da tabela
							 * DEBITO_CREDITO_SITUACAO
							 */
							pagamento.getDebitoACobrar().setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao());
							pagamento.getDebitoACobrar().getDebitoCreditoSituacaoAtual().setId(DebitoCreditoSituacao.PAGA);
							getControladorUtil().atualizar(pagamento.getDebitoACobrar());

							// Imóvel - obter o IMOV_ID da tabela DEBITO_A_COBRAR
							pagamento.setImovel(new Imovel(Util.obterInteger(item[15].toString())));

						}else{

							// Localidade - atribuir o LOCA_ID da tabela DEBITO_A_COBRAR_HISTORICO
							pagamento.setLocalidade(new Localidade(Util.obterInteger(item[30].toString())));

							/*
							 * Caso contrário, atribuir o tipo de débito do histórico (DBTP_ID da
							 * tabela DEBITO_A_COBRAR_HISTORICO com DBAC_ID=DBAC_ID da tabela
							 * COBRANCA_DOCUMENTO_ITEM)
							 */
							debitoTipo = new DebitoTipo();
							debitoTipo.setId(Util.obterInteger(item[9].toString()));

							// Imóvel - obter o IMOV_ID da tabela DEBITO_A_COBRAR_HISTORICO
							pagamento.setImovel(new Imovel(Util.obterInteger(item[34].toString())));
						}

						// Débito Tipo
						pagamento.setDebitoTipo(debitoTipo);

						/*
						 * Caso o pagamento seja referente a um débito a cobrar, atribuir o valor
						 * correspondente a débito a cobrar da tabela DOCUMENTO_TIPO
						 */
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
						pagamento.setDocumentoTipo(documentoTipo);
					}else{

						/*
						 * Caso CNTA_ID, DBAC_ID e GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM sejam
						 * todos nulos, atribuir o LOCA_ID da tabela IMOVEL
						 */
						pagamento.setLocalidade(new Localidade(Util.obterInteger(item[31].toString())));

						// Imóvel - Imóvel do Documento de Cobrança
						pagamento.setImovel(cobrancaDocumento.getImovel());
					}
				}

				int anoMesPagamento = Util.getAnoMesComoInt(dataPagamento);

				/*
				 * Ano Mês Referênciada Arrecadação -
				 * Caso o ano/mês da data do pagamento seja maior que a
				 * PARM_AMREFERENCIAARRECADACAO da tabela SISTEMA_PARAMETROS
				 */
				if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao().intValue()){

					// Atribuir ano/mês da data do pagamento
					pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
				}else{

					// Caso contrário atribuir o PARM_AMREFERENCIAARRECADACAO
					pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao().intValue());
				}

				// Valor do pagamento = CDIT_VLITEMCOBRADO
				BigDecimal valorItemCobrado = BigDecimal.ZERO;
				if(item[3] != null && !item[3].toString().equals("")){

					valorItemCobrado = new BigDecimal(item[3].toString());
				}

				pagamento.setValorPagamento(valorItemCobrado);

				// Data do Pagamento
				pagamento.setDataPagamento(dataPagamento);

				// Arrecador Forma
				ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				arrecadacaoForma.setId(ArrecadacaoForma.COBRANCA_BANCARIA);
				pagamento.setArrecadacaoForma(arrecadacaoForma);

				// Data e Hora Corrente
				pagamento.setUltimaAlteracao(new Date());

				colecaoPagamento.add(pagamento);
			}
		}

		return colecaoPagamento;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SB0017] – Gerar boletos bancários para prestações de guia de pagamento
	 * 
	 * @author Ailton Sousa
	 * @date 21/10/2011
	 * @param guiaPagamentoPrestacao
	 * @throws ControladorException
	 */
	private void gerarBoletoBancarioParaPrestacoesGuiaPagamento(Integer idGuiaPagamento, Short numeroPrestacao) throws ControladorException{

		// 1.Caso o número da prestação da guia de pagamento seja 1 (GPPR_NNPRESTACAO = 1).
		if(numeroPrestacao != null && numeroPrestacao.equals(Util.converterStringParaShort("1"))){
			try{
				// a.Caso a guia de pagamento faça parte de um parcelamento.
				// i.Caso exista um boleto bancário associado ao parcelamento
				Integer idBoletoBancario = repositorioArrecadacao.pesquisarBoletoBancarioAssociadoParcelamento(idGuiaPagamento);
				if(idBoletoBancario != null){

					try{
						// Chama o [UC3016 - Gerar Boleto Cobrança Bancária]
						this.getControladorCobranca().gerarBoletoCobrancaBancaria(null, idGuiaPagamento, 2, null);

						// obtem o usuário batch
						FiltroUsuario filtroUsuario = new FiltroUsuario();
						filtroUsuario.adicionarParametro(new ParametroSimples(FiltroUsuario.ID, Integer
										.valueOf((String) ParametroGeral.P_USUARIO_BATCH.executar())));

						Collection<Usuario> collUsuario = getControladorUtil().pesquisar(filtroUsuario, Usuario.class.getName());

						Usuario usuarioBatch = null;
						if(collUsuario != null && !collUsuario.isEmpty()){
							usuarioBatch = collUsuario.iterator().next();
						}

						// obtem boletoBancarioLancamentoEnvio
						BoletoBancarioLancamentoEnvio boletoBancarioLancamentoEnvio = BoletoBancarioLancamentoEnvio.PEDIDO_BAIXA;

						// obtem boleto bancario
						BoletoBancario boletoBancario = new BoletoBancario();
						boletoBancario.setId(idBoletoBancario);

						// Gerar pedido de baixa para o boleto bancário encontrado – BoletoUnico, ou
						// seja,
						// incluir registro na tabela BOLETO_BANCARIO_MOVIMENTACAO

						this.getControladorCobranca().inserirBoletoBancarioMovimentacao(boletoBancario, usuarioBatch,
										boletoBancarioLancamentoEnvio);

					}catch(ControladorException e){
						e.printStackTrace();
					}
				}
			}catch(ErroRepositorioException e){
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}
		}
	}

	/**
	 * @param idConta
	 * @param indicadorExclusao
	 * @return
	 * @throws ControladorException
	 */
	public DebitoAutomaticoMovimento pesquisarUltimoDebitoAutomaticoMovimentoConta(Integer idConta) throws ControladorException{

		try{

			return repositorioArrecadacao.pesquisarUltimoDebitoAutomaticoMovimentoConta(idConta);

		}catch(ErroRepositorioException e){

			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);

		}

	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * Gerar o relatório de resumo, envia por email, salva na pasta bin do servidor e disponibiliza
	 * pra download no sistema
	 * 
	 * @author Anderson Italo
	 * @date 11/03/2012
	 * @throws ControladorException
	 */
	public void gerarEnviarRelatorioResumoArrecadacao(int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;
		try{

			// Registrar o início do processamento da unidade de processamento do batch
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			// Selecionar o último movimento processado
			ArrecadadorMovimento movimento = repositorioArrecadacao.obterUltimoMovimentoGerado();

			if(movimento != null){

				EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.REGISTRAR_MOVIMENTO_ARRECADADORES_PDF);

				RelatorioMovimentoArrecadador relatorioMovimentoArrecadador = new RelatorioMovimentoArrecadador(Usuario.USUARIO_BATCH);
				relatorioMovimentoArrecadador.addParametro("arrecadadoresMovimento", movimento);
				relatorioMovimentoArrecadador.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);

				// Gera o relatório para ser salvo na pasta bin do servidor e enviar por email
				byte[] relatorioGerado = (byte[]) relatorioMovimentoArrecadador.executar();

				// Chama o processo do relatório para disponibiliza-lo para download
				GerenciadorExecucaoTarefaRelatorio.analisarExecucao(relatorioMovimentoArrecadador, 0);

				String emailRemetente = envioEmail.getEmailRemetente();
				String tituloMensagem = envioEmail.getTituloMensagem() + " " + movimento.getNumeroSequencialArquivo().toString();
				String corpoMensagem = envioEmail.getCorpoMensagem();
				String emailReceptor = envioEmail.getEmailReceptor();

				String codigoBanco = "0000";
				if(movimento.getCodigoBanco() != null){

					codigoBanco = movimento.getCodigoBanco().toString();
				}

				String nsaAquivoMovimento = "0000";
				if(movimento != null && movimento.getNumeroSequencialArquivo() != null){

					nsaAquivoMovimento = movimento.getNumeroSequencialArquivo().toString();
				}

				File leitura = new File("RETORNO_ARRECADACAO_" + codigoBanco + "_" + nsaAquivoMovimento + "_"
								+ Util.formatarDataComTracoAAAAMMDDHHMMSS(new Date()) + ".PDF");
				FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
				out.write(relatorioGerado);
				out.flush();
				out.close();

				ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

			}

			// Registrar o fim do processamento da unidade de processamento do batch
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * [UC3046] Filtrar Guia Pagamento Para Geração Débito Automático
	 * 
	 * @author Carlos Chrystian
	 * @created 20/03/2012
	 *          Filtrar Guia Pagamento Para Geração Débito Automático.
	 */
	public Collection<GuiaPagamentoPrestacaoHelper> pesquisarGuiaPagamentoPrestacao(Date dataVencimentoGuiaPagamentoInicial,
					Date dataVencimentoGuiaPagamentoFinal, Integer clienteResponsavel, Short indicadorTipoGuia, Integer pageOffset)
					throws ControladorException{

		Collection<GuiaPagamentoPrestacaoHelper> retorno = new ArrayList<GuiaPagamentoPrestacaoHelper>();
		Collection<Object[]> consulta = null;

		try{

			consulta = this.repositorioArrecadacao.pesquisarGuiaPagamentoPrestacao(dataVencimentoGuiaPagamentoInicial,
							dataVencimentoGuiaPagamentoFinal, clienteResponsavel, indicadorTipoGuia, pageOffset);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		if(!Util.isVazioOrNulo(consulta)){

			for(Object[] colunaArrayConta : consulta){

				GuiaPagamentoPrestacaoHelper guiaPagamentoPrestacaoHelper = new GuiaPagamentoPrestacaoHelper();

				int i = 0;
				guiaPagamentoPrestacaoHelper.setId(Long.valueOf(((Integer) colunaArrayConta[i]).longValue()));
				// 1 consulta += ("gppr.gpag_id as guiaPagamento, ");
				guiaPagamentoPrestacaoHelper.setIdGuiaPagamento((Integer) colunaArrayConta[i++]);
				// 2 consulta += ("gppr.gppr_nnprestacao as numeroPrestacao, ");
				guiaPagamentoPrestacaoHelper.setNumeroPrestacao(((Integer) colunaArrayConta[i++]).shortValue());
				// 3 consulta += ("gp.gpag_nnprestacaototal as numeroPrestacaoTotal, ");
				guiaPagamentoPrestacaoHelper.setNumeroPrestacaoTotal(((Integer) colunaArrayConta[i++]).shortValue());
				// 4 consulta += ("gp.imov_id as idImovel,  ");
				guiaPagamentoPrestacaoHelper.setIdImovel((Integer) colunaArrayConta[i++]);

				// Cliente Responsável
				Integer idClienteResponsavel = null;
				String nomeClienteResponsavel = "";
				FiltroClienteGuiaPagamento filtroClienteGuiaPagamento = new FiltroClienteGuiaPagamento();

				filtroClienteGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("cliente");
				filtroClienteGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroClienteGuiaPagamento.GUIA_PAGAMENTO_ID,
								guiaPagamentoPrestacaoHelper.getIdGuiaPagamento()));
				filtroClienteGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroClienteGuiaPagamento.CLIENTE_RELACAO_TIPO_ID,
								ClienteRelacaoTipo.RESPONSAVEL));

				Collection colecaoClienteGuiaPagamento = getControladorUtil().pesquisar(filtroClienteGuiaPagamento,
								ClienteGuiaPagamento.class.getName());

				if(!Util.isVazioOrNulo(colecaoClienteGuiaPagamento)){
					ClienteGuiaPagamento clienteGuiaPagamento = (ClienteGuiaPagamento) Util
									.retonarObjetoDeColecao(colecaoClienteGuiaPagamento);

					Cliente cliente = clienteGuiaPagamento.getCliente();
					idClienteResponsavel = cliente.getId();
					nomeClienteResponsavel = cliente.getNome();
				}

				// 5 Id do Cliente Responsável
				guiaPagamentoPrestacaoHelper.setIdCliente(idClienteResponsavel);
				// 6 Nome do Cliente Responsável
				guiaPagamentoPrestacaoHelper.setNomeCliente(nomeClienteResponsavel);
				// 7 cconsulta += ("gppr.gppr_dtvencimento as dataVencimento, ");
				guiaPagamentoPrestacaoHelper.setDataVencimento((Date) colunaArrayConta[i++]);
				// 8 consulta += ("sum(gppr_vlprestacao) as valorPrestacao ");
				guiaPagamentoPrestacaoHelper.setValorTotalPorPrestacao((BigDecimal) colunaArrayConta[i++]);

				// Descrição do Tipo de Débito
				FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
				filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoPrestacao.DEBITO_TIPO);
				filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
								guiaPagamentoPrestacaoHelper.getIdGuiaPagamento()));
				filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
								guiaPagamentoPrestacaoHelper.getNumeroPrestacao()));

				Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = Fachada.getInstancia().pesquisar(
								filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

				if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){
					String descricaoTipoDebito = "";
					int qtdRegistros = 1;
					for(GuiaPagamentoPrestacao guiaPagamentoPrestacao : colecaoGuiaPagamentoPrestacao){
						FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, guiaPagamentoPrestacao
										.getDebitoTipo().getId()));
						try{

							DebitoTipo debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(repositorioUtil.pesquisar(filtroDebitoTipo,
											DebitoTipo.class.getName()));

							if(qtdRegistros > 1){
								descricaoTipoDebito += " / " + debitoTipo.getDescricao();
							}else{
								descricaoTipoDebito += debitoTipo.getDescricao();
								qtdRegistros++;
							}
						}catch(ErroRepositorioException ex){

							throw new ControladorException("erro.sistema", ex);
						}
					}
					guiaPagamentoPrestacaoHelper.setDescricaoTipoDebito(descricaoTipoDebito);
				}

				retorno.add(guiaPagamentoPrestacaoHelper);
			}
		}

		return retorno;
	}

	/**
	 * [UC3046] Filtrar Guia Pagamento Para Geração Débito Automático
	 * 
	 * @author Carlos Chrystian
	 * @created 20/03/2012
	 *          Filtrar Guia Pagamento Para Geração Débito Automático.
	 */
	public Integer pesquisarQuantidadeGuiaPagamentoPrestacao(Date dataVencimentoGuiaPagamentoInicial,
					Date dataVencimentoGuiaPagamentoFinal, Integer clienteResponsavel, Short indicadorTipoGuia) throws ControladorException{

		Integer retorno = null;
		try{

			retorno = this.repositorioArrecadacao.pesquisarQuantidadeGuiaPagamentoPrestacao(dataVencimentoGuiaPagamentoInicial,
							dataVencimentoGuiaPagamentoFinal, clienteResponsavel, indicadorTipoGuia);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Permite gerar débito automático para guia de pagamento
	 * [UC3045] Gerar Débito Automático para Guia de Pagamento
	 * 
	 * @author Carlos Chrystian
	 * @created 20/03/2012
	 *          Gerar Débito Automático para Guia de Pagamento.
	 */
	public void gerarDebitoAutomaticoGuiaPagamento(String[] idsGuiaPagamentoPrestacaoSelecionadas, Usuario usuarioLogado)
					throws ControladorException{

		try{
			// Data Corrente
			Date dataCorrente = new Date();

			for(String idGuiaGeracaoDebitoAutomatico : idsGuiaPagamentoPrestacaoSelecionadas){

				String[] guiaPrestacaoSelecionados = idGuiaGeracaoDebitoAutomatico.split(",");
				Integer idGuia = Util.obterInteger(guiaPrestacaoSelecionados[0]);
				Short numeroPrestacao = Util.obterShort(guiaPrestacaoSelecionados[1]);

				FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
				filtroGuiaPagamentoPrestacao
								.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID, idGuia));
				filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
								numeroPrestacao));
				filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("comp_id");
				filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento");
				filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento.imovel");
				filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento.imovel.rota");
				filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento.imovel.rota.faturamentoGrupo");

				Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = Fachada.getInstancia().pesquisar(
								filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

				if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){

					GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) Util
									.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);

					BigDecimal valorTotalPrestacoesGuia = BigDecimal.ZERO;
					try{

						valorTotalPrestacoesGuia = repositorioArrecadacao.pesquisarValorTotalGuiaPagamentoPrestacao(guiaPagamentoPrestacao
										.getComp_id().getGuiaPagamentoId(), guiaPagamentoPrestacao.getComp_id().getNumeroPrestacao()
										.intValue());
					}catch(ErroRepositorioException e){
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

					// [FS0002 – Atualização realizada por outro usuário].
					FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacaoBase = new FiltroGuiaPagamentoPrestacao();
					filtroGuiaPagamentoPrestacaoBase.adicionarParametro(new ParametroSimples(
									FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID, guiaPagamentoPrestacao.getComp_id()
													.getGuiaPagamentoId()));

					Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacaoBase = Fachada.getInstancia().pesquisar(
									filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

					if(Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoBase)){
						throw new ControladorException("atencao.atualizacao.timestamp");
					}

					GuiaPagamentoPrestacao guiaPagamentoPrestacaoNaBase = (GuiaPagamentoPrestacao) Util
									.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoBase);

					if(guiaPagamentoPrestacaoNaBase.getUltimaAlteracao().after(guiaPagamentoPrestacao.getUltimaAlteracao())){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.gerar_debito_automatico_guia_pagamento_prestacao");
					}

					// 2.1. Caso exista ocorrência de débito automático para a prestação
					FiltroDebitoAutomaticoMovimento filtroDebitoAutomaticoMovimento = new FiltroDebitoAutomaticoMovimento();
					filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(
									FiltroDebitoAutomaticoMovimento.GUIA_PAGAMENTO_PRESTACAO_ID, guiaPagamentoPrestacao.getComp_id()
													.getGuiaPagamentoId()));
					filtroDebitoAutomaticoMovimento.adicionarParametro(new ParametroSimples(
									FiltroDebitoAutomaticoMovimento.NUMERO_PRESTACAO, guiaPagamentoPrestacao.getComp_id()
													.getNumeroPrestacao()));

					Collection<DebitoAutomaticoMovimento> colecaoDebitoAutomaticoMovimento = this.getControladorUtil().pesquisar(
									filtroDebitoAutomaticoMovimento, DebitoAutomaticoMovimento.class.getName());

					if(!Util.isVazioOrNulo(colecaoDebitoAutomaticoMovimento)){
						DebitoAutomaticoMovimento debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) Util
										.retonarObjetoDeColecao(colecaoDebitoAutomaticoMovimento);
						// 2.1.1. Caso o movimento já tenha sido enviado
						if(!Util.isVazioOuBranco(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado())){
							// 2.1.1.1. Caso o vencimento da prestação (GPRR_DTVENCIMENTO) seja
							// maior que a data corrente
							if(dataCorrente.compareTo(guiaPagamentoPrestacao.getDataVencimento()) < 0){
								// 2.1.1.1.1. Exibir a mensagem
								throw new ControladorException("atencao.debito_automatico_ja_enviado_para_prestacao", null,
												guiaPagamentoPrestacao.getComp_id().getNumeroPrestacao().toString(), guiaPagamentoPrestacao
																.getComp_id().getGuiaPagamentoId().toString());
							}else{
								debitoAutomaticoMovimento.setProcessamento(dataCorrente); // 1
								debitoAutomaticoMovimento.setEnvioBanco(null); // 2
								debitoAutomaticoMovimento.setNumeroSequenciaArquivoEnviado(null); // 3
								debitoAutomaticoMovimento.setRetornoBanco(null); // 4
								debitoAutomaticoMovimento.setNumeroSequenciaArquivoRecebido(null); // 5
								debitoAutomaticoMovimento.setIndicadorExclusao(null); // 6
								debitoAutomaticoMovimento.setDebitoAutomaticoMovimentoCancelamentoMotivo(null); // 7
								debitoAutomaticoMovimento.setDebitoAutomaticoRetornoCodigo(null); // 8
								debitoAutomaticoMovimento.setUltimaAlteracao(dataCorrente); // 9

								getControladorUtil().atualizar(debitoAutomaticoMovimento);
							}
						}else{
							debitoAutomaticoMovimento.setProcessamento(dataCorrente); // 1
							debitoAutomaticoMovimento.setEnvioBanco(null); // 2
							debitoAutomaticoMovimento.setNumeroSequenciaArquivoEnviado(null); // 3
							debitoAutomaticoMovimento.setRetornoBanco(null); // 4
							debitoAutomaticoMovimento.setNumeroSequenciaArquivoRecebido(null); // 5
							debitoAutomaticoMovimento.setIndicadorExclusao(null); // 6
							debitoAutomaticoMovimento.setDebitoAutomaticoMovimentoCancelamentoMotivo(null); // 7
							debitoAutomaticoMovimento.setDebitoAutomaticoRetornoCodigo(null); // 8
							debitoAutomaticoMovimento.setUltimaAlteracao(dataCorrente); // 9

							getControladorUtil().atualizar(debitoAutomaticoMovimento);
						}
					}else{
						// Consulta dados do débito automático para geração
						// do débito automático movimento.
						FiltroDebitoAutomatico filtroDebitoAutomatico = new FiltroDebitoAutomatico();
						filtroDebitoAutomatico.adicionarParametro(new ParametroSimples(FiltroDebitoAutomatico.IMOVEL_ID,
										guiaPagamentoPrestacao.getGuiaPagamento().getImovel().getId()));
						filtroDebitoAutomatico.adicionarParametro(new ParametroNulo(FiltroDebitoAutomatico.DATA_EXCLUSAO));

						filtroDebitoAutomatico.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoAutomatico.BANCO);
						filtroDebitoAutomatico.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoAutomatico.IMOVEL);

						DebitoAutomatico debitoAutomatico = (DebitoAutomatico) Util.retonarObjetoDeColecao(Fachada.getInstancia()
										.pesquisar(filtroDebitoAutomatico, DebitoAutomatico.class.getName()));

						DebitoAutomaticoMovimento debitoAutomaticoMovimento = new DebitoAutomaticoMovimento();

						debitoAutomaticoMovimento.setDebitoAutomatico(debitoAutomatico); // 1
						debitoAutomaticoMovimento.setDataVencimento(guiaPagamentoPrestacao.getDataVencimento()); // 2
						debitoAutomaticoMovimento.setValorDebito(valorTotalPrestacoesGuia); // 3
						debitoAutomaticoMovimento.setContaGeral(null); // 4
						debitoAutomaticoMovimento.setGuiaPagamento(guiaPagamentoPrestacao.getGuiaPagamento()); // 5
						debitoAutomaticoMovimento.setNumeroPrestacao(guiaPagamentoPrestacao.getComp_id().getNumeroPrestacao().intValue()); // 6
						debitoAutomaticoMovimento.setDebitoAutomaticoRetornoCodigo(null); // 7
						debitoAutomaticoMovimento.setFaturamentoGrupo(guiaPagamentoPrestacao.getGuiaPagamento().getImovel().getRota()
										.getFaturamentoGrupo()); // 8
						debitoAutomaticoMovimento.setProcessamento(dataCorrente); // 9
						debitoAutomaticoMovimento.setEnvioBanco(null); // 10
						debitoAutomaticoMovimento.setRetornoBanco(null); // 11
						debitoAutomaticoMovimento.setUltimaAlteracao(dataCorrente); // 12
						debitoAutomaticoMovimento.setNumeroSequenciaArquivoEnviado(null); // 13
						debitoAutomaticoMovimento.setNumeroSequenciaArquivoRecebido(null); // 14
						debitoAutomaticoMovimento.setIndicadorExclusao(null); // 15
						debitoAutomaticoMovimento.setDebitoAutomaticoMovimentoCancelamentoMotivo(null); // 16

						getControladorUtil().inserir(debitoAutomaticoMovimento);
					}

					//
					// Efetuando as alteraçõs
					//

					// ------------ <REGISTRAR TRANSAÇÃO>----------------------------

					if(usuarioLogado != null){
						RegistradorOperacao registradorOperacao = new RegistradorOperacao(
										Operacao.OPERACAO_GERAR_DEBITO_AUTOMATICO_GUIA_PAGAMENTO, guiaPagamentoPrestacao.getGuiaPagamento()
														.getImovel().getId(), guiaPagamentoPrestacao.getComp_id().getGuiaPagamentoId(),
										new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						registradorOperacao.registrarOperacao(guiaPagamentoPrestacao);

						getControladorTransacao().registrarTransacao(guiaPagamentoPrestacao);
					}
					// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

				}
			}

		}catch(ControladorException e){

			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * Atualiza o aviso bancário com o valores dos pagamentos classificados e não classificadaos e o
	 * valor calculado.
	 * 
	 * @author Anderson Italo
	 * @date 24/03/2012
	 * @throws ControladorException
	 */
	public void atualizaValorArrecadacaoBoletoAvisoBancario(AvisoBancario avisoBancario) throws ControladorException{

		BigDecimal valorPagamentosClassificados = BigDecimal.ZERO;
		BigDecimal valorPagamentosNaoClassificados = BigDecimal.ZERO;
		BigDecimal valorArrecadacaoCalculado = BigDecimal.ZERO;

		Collection colecaoPagamentos = this.pesquisarPagamentoAvisoBancario(avisoBancario.getId());
		if(!Util.isVazioOrNulo(colecaoPagamentos)){

			for(Object pagamentoAux : colecaoPagamentos){

				Pagamento pagamento = (Pagamento) pagamentoAux;
				valorPagamentosNaoClassificados = valorPagamentosNaoClassificados.add(pagamento.getValorPagamento());
			}
		}

		Collection colecaoPagamentosHistorico = this.pesquisarPagamentoHistoricoAvisoBancario(avisoBancario.getId());

		if(!Util.isVazioOrNulo(colecaoPagamentosHistorico)){

			for(Object pagamentoHistoricoAux : colecaoPagamentosHistorico){

				PagamentoHistorico pagamentoHistorico = (PagamentoHistorico) pagamentoHistoricoAux;
				valorPagamentosClassificados = valorPagamentosClassificados.add(pagamentoHistorico.getValorPagamento());
			}
		}

		valorArrecadacaoCalculado = valorArrecadacaoCalculado.add(valorPagamentosClassificados).add(valorPagamentosNaoClassificados);
		avisoBancario.setValorArrecadacaoCalculado(valorArrecadacaoCalculado);

		avisoBancario.setValorPagamentoClassificado(valorPagamentosClassificados);
		avisoBancario.setValorPagamentoNaoClassificado(valorPagamentosNaoClassificados);

		avisoBancario.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(avisoBancario);
	}

	/**
	 * [UC3053] - Gerar Guia de Pagamento Programa Água Para Todos
	 * Recupera o tipo de débito referente ao Programa Água para Todos
	 * 
	 * @author Luciano Galvão
	 * @date 23/03/2012
	 * @throws ControladorException
	 */
	public DebitoTipo consultarDebitoTipoAguaParaTodos() throws ControladorException{

		try{

			DebitoTipo debitoTipo = null;
			String paramDebitoTipo = ParametroArrecadacao.P_IDENTIFICACAO_DEBITO_TIPO_PROGRAMA_AGUA_PARA_TODOS.executar();

			if((paramDebitoTipo != null) && (!paramDebitoTipo.equals(""))){
				FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, Util.obterInteger(paramDebitoTipo)));

				Collection<DebitoTipo> colecaoDebitoTipos = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if((colecaoDebitoTipos != null) && (!colecaoDebitoTipos.isEmpty())){
					debitoTipo = colecaoDebitoTipos.iterator().next();
				}
			}

			return debitoTipo;

		}catch(Exception e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC3053] - Gerar Guia de Pagamento Programa Água Para Todos
	 * Recupera a coleção de contas que não possuem o motivo de revisão correspondente ao Programa
	 * Água Para Todos
	 * 
	 * @author Luciano Galvão
	 * @date 23/03/2012
	 * @throws ControladorException
	 */
	public Collection obterContasProgramaAguaParaTodos(Imovel imovel) throws ControladorException{

		Collection<ContaValoresHelper> contasSelecionadas = new ArrayList<ContaValoresHelper>();

		try{

			Integer paramMotivoRevisao = Util.obterInteger(ParametroArrecadacao.P_MOTIVO_REVISAO_PROGRAMA_AGUA_PARA_TODOS.executar());

			// Inicializando os parâmetros que serão passados para a consulta do [UC0067]
			int indicadorDebito = 1;
			String codigoCliente = null;
			Integer clienteRelacaoTipo = null;
			String anoMesInicialReferenciaDebito = "000101";
			String anoMesFinalReferenciaDebito = "999912";
			Date anoMesInicialVencimentoDebito = Util.criarData(1, 1, 1);
			Date anoMesFinalVencimentoDebito = new Date();
			int indicadorPagamento = 1;
			int indicadorConta = 1;
			int indicadorDebitoACobrar = 2;
			int indicadorCreditoARealizar = 2;
			int indicadorNotasPromissorias = 2;
			int indicadorGuiasPagamento = 2;
			int indicadorCalcularAcrescimoImpontualidade = 2;
			Boolean indicadorContas = Boolean.TRUE;
			SistemaParametro sistemaParametro = null;

			// [UC0067] - Obter Débito do Imóvel ou Cliente
			ObterDebitoImovelOuClienteHelper colecaoDebitoImovel = getControladorCobranca().obterDebitoImovelOuCliente(indicadorDebito,
							imovel.getId().toString(), codigoCliente, clienteRelacaoTipo, anoMesInicialReferenciaDebito,
							anoMesFinalReferenciaDebito, anoMesInicialVencimentoDebito, anoMesFinalVencimentoDebito, indicadorPagamento,
							indicadorConta, indicadorDebitoACobrar, indicadorCreditoARealizar, indicadorNotasPromissorias,
							indicadorGuiasPagamento, indicadorCalcularAcrescimoImpontualidade, indicadorContas, sistemaParametro, null,
							null, null, ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM);

			Collection<ContaValoresHelper> colecaoContaValores = colecaoDebitoImovel.getColecaoContasValores();

			if(colecaoContaValores != null && !colecaoContaValores.isEmpty()){

				Iterator<ContaValoresHelper> colecaoContaValoresIterator = colecaoContaValores.iterator();

				// percorre a colecao de conta somando o valor para obter um valor total
				while(colecaoContaValoresIterator.hasNext()){

					ContaValoresHelper dadosConta = colecaoContaValoresIterator.next();
					Conta conta = dadosConta.getConta();

					if(conta != null){
						ContaMotivoRevisao motivoRevisao = conta.getContaMotivoRevisao();

						// Selecionar apenas as contas que NÃO possuem motivo de revisão
						if((motivoRevisao == null) || (paramMotivoRevisao == null) || (!motivoRevisao.getId().equals(paramMotivoRevisao))){
							contasSelecionadas.add(dadosConta);
						}
					}
				}
			}
		}catch(Exception e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

		return contasSelecionadas;

	}

	/**
	 * [UC3053]: Gerar Guia Pagamento Programa Água para Todos
	 * Calcula o valor da Guia de Pagamento para o programa Água Para Todos
	 * 
	 * @param valorContas
	 * @author Luciano Galvão
	 * @date 23/03/2012
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorGuiaAguaParaTodos(BigDecimal valorContas) throws ControladorException{

		BigDecimal valorGuia = BigDecimal.ZERO;

		try{

			// Aplica o desconto sobre o total das contas
			String paramPercentualDesconto = ParametroArrecadacao.P_PERCENTUAL_DESCONTO_PROGRAMA_AGUA_PARA_TODOS.executar();
			String paramValorMaximo = ParametroArrecadacao.P_VALOR_MAXIMO_GUIA_PROGRAMA_AGUA_PARA_TODOS.executar();

			if((paramPercentualDesconto != null) && (!paramPercentualDesconto.equals("-1"))){

				// Valor com desconto = (valor da guia * percentual de desconto) / 100
				valorGuia = valorContas.multiply(new BigDecimal(paramPercentualDesconto)).divide(BigDecimal.valueOf(100));

				if((paramValorMaximo != null) && (!paramValorMaximo.equals("-1"))){
					BigDecimal paramValorMaximoNum = new BigDecimal(paramValorMaximo);

					// Se o valor total das contas com desconto é MAIOR que o valor máximo para
					// inclusão no programa, considerar o valor máximo. Caso contrário, considerar o
					// valor total das contas
					if(valorGuia.compareTo(paramValorMaximoNum) > 0){
						valorGuia = paramValorMaximoNum;
					}
				}
			}

			return valorGuia;

		}catch(Exception e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC3053 - Gerar Guia de Pagamento Programa Água para Todos]
	 * 
	 * @author Luciano Galvão
	 * @date 26/03/2012
	 * @param idImovel
	 * @param valorGuia
	 * @param contas
	 * @param usuario
	 * @throws ControladorException
	 */
	public void gerarGuiaPagamentoProgramaAguaParaTodos(Integer idImovel, BigDecimal valorGuia, Collection<Conta> contas, Usuario usuario)
					throws ControladorException{

		try{

			// ---- REGISTRAR TRANSAÇÃO - GERAR GUIA DE PAGAMENTO PROGRAMA ÁGUA PARA TODOS ----
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(
							Operacao.OPERACAO_GERAR_GUIA_PAGAMENTO_PROGRAMA_AGUA_PARA_TODOS, new UsuarioAcaoUsuarioHelper(usuario,
											UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_GERAR_GUIA_PAGAMENTO_PROGRAMA_AGUA_PARA_TODOS);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);
			// ---- REGISTRAR TRANSAÇÃO - GERAR GUIA DE PAGAMENTO PROGRAMA ÁGUA PARA TODOS ----

			// recupera o sistema parametro
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
			guiaPagamentoGeral.setIndicadorHistorico(ConstantesSistema.NAO);
			guiaPagamentoGeral.setUltimaAlteracao(new Date());

			// Insere a Guia de Pagamento Geral
			getControladorUtil().inserir(guiaPagamentoGeral);

			GuiaPagamento guiaPagamento = new GuiaPagamento();
			guiaPagamento.setId(guiaPagamentoGeral.getId());
			guiaPagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL);
			guiaPagamento.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

			FiltroImovel filtroImovel = new FiltroImovel();
			filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovel));
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOCALIDADE);
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.SETOR_COMERCIAL);

			Imovel imovel = (Imovel) getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()).iterator().next();

			guiaPagamento.setLocalidade(imovel.getLocalidade());
			guiaPagamento.setSetorComercial(imovel.getSetorComercial());
			guiaPagamento.setImovel(imovel);
			guiaPagamento.setCliente(null);
			guiaPagamento.setRegistroAtendimento(null);
			guiaPagamento.setOrdemServico(null);
			guiaPagamento.setParcelamento(null);

			DocumentoTipo documentoTipoGuiaPagamento = new DocumentoTipo();
			documentoTipoGuiaPagamento.setId(DocumentoTipo.GUIA_PAGAMENTO);
			guiaPagamento.setDocumentoTipo(documentoTipoGuiaPagamento);

			guiaPagamento.setOrigem(null);
			guiaPagamento.setValorDebito(valorGuia);
			guiaPagamento.setNumeroPrestacaoTotal(Util.obterShort("1"));
			guiaPagamento.setUltimaAlteracao(new Date());
			guiaPagamento.setDataInclusao(new Date());

			// ---- REGISTRAR TRANSAÇÃO - GERAR GUIA DE PAGAMENTO PROGRAMA ÁGUA PARA TODOS ----
			guiaPagamento.setOperacaoEfetuada(operacaoEfetuada);
			guiaPagamento.adicionarUsuario(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(guiaPagamento);
			// ---- REGISTRAR TRANSAÇÃO - GERAR GUIA DE PAGAMENTO PROGRAMA ÁGUA PARA TODOS ----

			// Insere a Guia de Pagamento
			getControladorUtil().inserir(guiaPagamento);

			Integer paramDebitoTipoId = Util.obterInteger(ParametroArrecadacao.P_IDENTIFICACAO_DEBITO_TIPO_PROGRAMA_AGUA_PARA_TODOS
							.executar());

			FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
			filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, paramDebitoTipoId));
			Collection colecaoDebitoTipo = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

			DebitoTipo debitoTipo = null;
			if((colecaoDebitoTipo != null) && (!colecaoDebitoTipo.isEmpty())){
				debitoTipo = (DebitoTipo) colecaoDebitoTipo.iterator().next();
			}
			if(debitoTipo == null){
				throw new ControladorException("atencao.parametro_debito_tipo_nao_cadastrado");
			}

			guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);

			GuiaPagamentoPrestacaoPK comp_id = new GuiaPagamentoPrestacaoPK(guiaPagamento.getId(), (short) 1, debitoTipo.getId(),
							debitoTipo.getLancamentoItemContabil().getId());

			GuiaPagamentoPrestacao guiaPagamentoPrestacao = new GuiaPagamentoPrestacao();
			guiaPagamentoPrestacao.setComp_id(comp_id);
			guiaPagamentoPrestacao.setDebitoCreditoSituacao(debitoCreditoSituacao);
			guiaPagamentoPrestacao.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
			guiaPagamentoPrestacao.setValorPrestacao(valorGuia);

			Integer paramNumeroDiasVencimento = Util
							.obterInteger(ParametroArrecadacao.P_NUMERO_DIAS_VENCIMENTO_GUIA_PROGRAMA_AGUA_PARA_TODOS.executar());
			if((paramNumeroDiasVencimento == null) || (paramNumeroDiasVencimento.intValue() == -1)){
				throw new ControladorException("atencao.parametro_numero_dias_vencimento_nao_cadastrado");
			}

			guiaPagamentoPrestacao.setDataVencimento(Util.adicionarNumeroDiasDeUmaData(new Date(), paramNumeroDiasVencimento));
			guiaPagamentoPrestacao.setIndicadorPagamentoPendente(ConstantesSistema.NAO);
			guiaPagamentoPrestacao.setIndicadorCobrancaMulta(ConstantesSistema.NAO);
			guiaPagamentoPrestacao.setAnoMesReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
			guiaPagamentoPrestacao.setUltimaAlteracao(new Date());
			guiaPagamentoPrestacao.setDataEmissao(new Date());

			// Insere a Guia Pagamento Prestação
			getControladorUtil().inserir(guiaPagamentoPrestacao);

			// [UC0108 - Obter Quantidade de Economias por Categoria]
			Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			if(Util.isVazioOrNulo(colecaoCategoriasImovel)){
				colecaoCategoriasImovel = new ArrayList();
				Categoria categoria = new Categoria(Categoria.RESIDENCIAL);
				categoria.setQuantidadeEconomiasCategoria(1);
				colecaoCategoriasImovel.add(categoria);
			}
			// [UC0185 - Obter Valor por Categoria]
			Collection valoresCategoriasImovel = getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel, valorGuia);

			Iterator<Categoria> iteratorCategoriasImovel = colecaoCategoriasImovel.iterator();
			Iterator<BigDecimal> iteratorValoresCategoriasImovel = valoresCategoriasImovel.iterator();

			GuiaPagamentoCategoriaPK guiaPagamentoCategoriaPK = null;
			GuiaPagamentoCategoria guiaPagamentoCategoria = null;
			Categoria categoria = null;

			while(iteratorCategoriasImovel.hasNext()){
				categoria = iteratorCategoriasImovel.next();

				guiaPagamentoCategoriaPK = new GuiaPagamentoCategoriaPK(categoria.getId(), guiaPagamento.getId(), debitoTipo
								.getLancamentoItemContabil().getId(), (short) 1);

				guiaPagamentoCategoria = new GuiaPagamentoCategoria(guiaPagamentoCategoriaPK);
				guiaPagamentoCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
				guiaPagamentoCategoria.setValorCategoria(iteratorValoresCategoriasImovel.next());
				guiaPagamentoCategoria.setUltimaAlteracao(new Date());

				// Insere Guia Pagamento Categoria
				getControladorUtil().inserir(guiaPagamentoCategoria);
			}

			// Recupera os relacionamentos cliente-imóvel de um determinado imóvel com a data fim da
			// relação (CLIM_DTRELACAOFIM) igual a Null
			Collection<ClienteImovel> colecaoClientesImovel = getControladorImovel().pesquisarClientesImovel(imovel.getId());

			ClienteGuiaPagamento clienteGuiaPagamento = null;

			if(!Util.isVazioOrNulo(colecaoClientesImovel)){
				for(ClienteImovel clienteImovel : colecaoClientesImovel){
					clienteGuiaPagamento = new ClienteGuiaPagamento(clienteImovel.getCliente(), clienteImovel.getClienteRelacaoTipo(),
									guiaPagamento);
					clienteGuiaPagamento.setUltimaAlteracao(new Date());

					// Insere Cliente Guia Pagamento
					getControladorUtil().inserir(clienteGuiaPagamento);
				}
			}

			// Coloca as contas em revisão
			if(!Util.isVazioOrNulo(contas)){
				Collection<Conta> contasEmRevisao = new ArrayList<Conta>();

				for(Conta conta : contas){
					if(conta.getDataRevisao() != null){
						contasEmRevisao.add(conta);
					}

					// ------------ REGISTRAR TRANSAÇÃO - COLOCAR CONTA EM REVISÃO ----------------
					RegistradorOperacao registradorOperacaoConta = new RegistradorOperacao(Operacao.OPERACAO_COLOCAR_CONTA_REVISAO, conta
									.getImovel().getId(), conta.getId(), new UsuarioAcaoUsuarioHelper(usuario,
									UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacaoConta.registrarOperacao(conta);
					ServiceLocator.getInstancia().getControladorTransacao().registrarTransacao(conta);
					// ------------ REGISTRAR TRANSAÇÃO - COLOCAR CONTA EM REVISÃO ----------------

				}

				// Retira as contas de revisão
				if(!contasEmRevisao.isEmpty()){
					getControladorFaturamento().retirarRevisaoConta(contasEmRevisao, null, usuario);
				}

				Integer paramMotivoRevisao = Util.obterInteger(ParametroArrecadacao.P_MOTIVO_REVISAO_PROGRAMA_AGUA_PARA_TODOS.executar());

				if((paramMotivoRevisao == null) || (paramMotivoRevisao.intValue() == -1)){
					throw new ControladorException("atencao.parametro_motivo_revisao_nao_cadastrado");
				}

				ContaMotivoRevisao contaMotivoRevisao = new ContaMotivoRevisao();
				contaMotivoRevisao.setId(paramMotivoRevisao);

				// Coloca todas as contas em revisão
				getControladorFaturamento().colocarRevisaoConta(contas, null, contaMotivoRevisao, usuario);

			}

		}catch(ControladorException e){
			e.printStackTrace();
			throw e;
		}catch(Exception e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * [SB0006] - Acrescentar Acréscimos por Impontualidade na Guia de Pagamento Prestação
	 * 
	 * @author Hebert Falcão
	 * @date 27/04/2012
	 */
	private GuiaPagamentoPrestacao acrescentarAcrescimosPorImpontualidadeNaGuia(Integer idGuiaPagamento, Short numeroPrestacao,
					BigDecimal valorAcrescimos,
					DebitoTipo debitoTipo, Date dataPagamento, SistemaParametro sistemaParametro, Short indicadorPagamentoPendente,
					Short indicadorCobrancaMulta, Date dataEmissao, Date dataVencimento) throws ControladorException{

		// Débito Tipo
		Integer idDebitoTipo = debitoTipo.getId();

		FiltroGuiaPagamentoPrestacao filtroGuiaPagPrest = new FiltroGuiaPagamentoPrestacao();
		filtroGuiaPagPrest.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID, idGuiaPagamento));
		filtroGuiaPagPrest.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO, numeroPrestacao));
		filtroGuiaPagPrest.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.DEBITO_TIPO_ID, idDebitoTipo));

		Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = this.getControladorUtil().pesquisar(filtroGuiaPagPrest,
						GuiaPagamentoPrestacao.class.getName());

		if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){
			GuiaPagamentoPrestacao guiaPagamentoPrestacaoAtualizar = (GuiaPagamentoPrestacao) Util
							.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);

			BigDecimal valorPrestacao = guiaPagamentoPrestacaoAtualizar.getValorPrestacao();
			valorPrestacao = valorPrestacao.add(valorAcrescimos);

			guiaPagamentoPrestacaoAtualizar.setValorPrestacao(valorPrestacao);
			guiaPagamentoPrestacaoAtualizar.setUltimaAlteracao(new Date());

			// Atualizar Guia de Pagamento prestação
			this.getControladorUtil().atualizar(guiaPagamentoPrestacaoAtualizar);

			guiaPagamentoPrestacaoAtualizar.setValorPrestacao(valorAcrescimos);

			return guiaPagamentoPrestacaoAtualizar;
		}else{
			GuiaPagamentoPrestacao guiaPagamentoPrestacaoInserir = new GuiaPagamentoPrestacao();

			// Lançamento Ítem Contábil
			LancamentoItemContabil lancamentoItemContabil = debitoTipo.getLancamentoItemContabil();
			Integer idLancamentoItemContabil = lancamentoItemContabil.getId();

			// PK
			GuiaPagamentoPrestacaoPK novaComp_id = new GuiaPagamentoPrestacaoPK();
			novaComp_id.setGuiaPagamentoId(idGuiaPagamento);
			novaComp_id.setNumeroPrestacao(numeroPrestacao);
			novaComp_id.setDebitoTipoId(idDebitoTipo);
			novaComp_id.setItemLancamentoContabilId(idLancamentoItemContabil);

			guiaPagamentoPrestacaoInserir.setComp_id(novaComp_id);
			guiaPagamentoPrestacaoInserir.setLancamentoItemContabil(lancamentoItemContabil);

			// Débito Crédito Situação
			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

			guiaPagamentoPrestacaoInserir.setDebitoCreditoSituacao(debitoCreditoSituacao);

			// Financiamento Tipo
			FinanciamentoTipo financiamentoTipo = debitoTipo.getFinanciamentoTipo();
			guiaPagamentoPrestacaoInserir.setFinanciamentoTipo(financiamentoTipo);

			guiaPagamentoPrestacaoInserir.setValorPrestacao(valorAcrescimos);

			guiaPagamentoPrestacaoInserir.setDataVencimento(dataVencimento);

			guiaPagamentoPrestacaoInserir.setIndicadorPagamentoPendente(indicadorPagamentoPendente);

			guiaPagamentoPrestacaoInserir.setIndicadorCobrancaMulta(indicadorCobrancaMulta);

			Integer anoMesReferenciaFaturamento = sistemaParametro.getAnoMesFaturamento();
			guiaPagamentoPrestacaoInserir.setAnoMesReferenciaFaturamento(anoMesReferenciaFaturamento);

			guiaPagamentoPrestacaoInserir.setDataEmissao(dataEmissao);

			guiaPagamentoPrestacaoInserir.setUltimaAlteracao(new Date());

			// Inserir Guia de Pagamento prestação
			this.getControladorUtil().inserir(guiaPagamentoPrestacaoInserir);
			
			return guiaPagamentoPrestacaoInserir;

		}
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * [SB0007] – Distribuir Valores Guia por Categoria
	 * 
	 * @author Hebert Falcão
	 * @date 12/05/2012
	 * @author Hiroshi Gonçalves
	 * @date 29/11/2013
	 *       Adicionando o parâmetro "colecaoGuiaPagamentoPrestacao" ao método original.
	 * @return retorna uma Coleção de GuiaPagamentoCategoria dos Acréscimos, apenas se a
	 *         "colecaoGuiaPagamentoPrestacao" for passado como parâmetro, caso contrário,
	 *         retornará null.
	 */
	public Collection<GuiaPagamentoCategoria> distribuirValoresGuiaPorCategoria(Integer idGuiaPagamento, Short numeroPrestacao,
					Imovel imovel, Collection<GuiaPagamentoPrestacao> colGuiaPagamentoPrestacaoAcrescimos)
					throws ControladorException{

		Collection<GuiaPagamentoCategoria> colGuiaPagamentoCategoriaAcrescimos = null;

		// Remover Guia de Pagamento Categoria
		try{
			repositorioArrecadacao.removerGuiaPagamentoCategoria(idGuiaPagamento, numeroPrestacao);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		// Prestações
		FiltroGuiaPagamentoPrestacao filtroGuiaPagPrest = new FiltroGuiaPagamentoPrestacao();
		filtroGuiaPagPrest.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID, idGuiaPagamento));
		filtroGuiaPagPrest.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO, numeroPrestacao));

		Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = this.getControladorUtil().pesquisar(filtroGuiaPagPrest,
						GuiaPagamentoPrestacao.class.getName());

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoCategoriasImovel = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		this.distribuirValoresGuiaPorCategoria(idGuiaPagamento, numeroPrestacao, colecaoCategoriasImovel, colecaoGuiaPagamentoPrestacao,
						true);

		if(colGuiaPagamentoPrestacaoAcrescimos != null){
			colGuiaPagamentoCategoriaAcrescimos = this.distribuirValoresGuiaPorCategoria(idGuiaPagamento, numeroPrestacao,
							colecaoCategoriasImovel, colGuiaPagamentoPrestacaoAcrescimos, false);
		}

		return colGuiaPagamentoCategoriaAcrescimos;
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * [SB0007] – Distribuir Valores Guia por Categoria
	 * 
	 * @author Hebert Falcão
	 * @date 12/05/2012
	 * @author Hiroshi Gonçalves
	 * @date 29/11/2013
	 */
	private Collection<GuiaPagamentoCategoria> distribuirValoresGuiaPorCategoria(Integer idGuiaPagamento, Short numeroPrestacao,
					Collection colecaoCategoriasImovel, Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao, boolean inInserir)
					throws ControladorException{

		Collection<GuiaPagamentoCategoria> colecaoGuiaPagamentoCategoriaRetorno = new ArrayList<GuiaPagamentoCategoria>();

		if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){
			Map<Integer, BigDecimal> mapPrestacoes = new HashMap<Integer, BigDecimal>();

			LancamentoItemContabil lancamentoItemContabilAux = null;
			Integer idLancamentoItemContabilAux = null;

			BigDecimal valorLancamento = BigDecimal.ZERO;
			BigDecimal valorPrestacao = BigDecimal.ZERO;

			for(GuiaPagamentoPrestacao guiaPagamentoPrestacaoAux : colecaoGuiaPagamentoPrestacao){
				lancamentoItemContabilAux = guiaPagamentoPrestacaoAux.getLancamentoItemContabil();
				idLancamentoItemContabilAux = lancamentoItemContabilAux.getId();

				valorPrestacao = guiaPagamentoPrestacaoAux.getValorPrestacao();

				if(mapPrestacoes.containsKey(idLancamentoItemContabilAux)){
					valorLancamento = mapPrestacoes.get(idLancamentoItemContabilAux);
					valorLancamento = valorLancamento.add(valorPrestacao);
				}else{
					valorLancamento = valorPrestacao;
				}

				mapPrestacoes.put(idLancamentoItemContabilAux, valorLancamento);
			}

			if(mapPrestacoes != null && !mapPrestacoes.isEmpty()){
				Collection<BigDecimal> colecaoValorCategoria = null;

				Iterator iteratorCategoria = null;
				Iterator iteratorValorCategoria = null;

				Categoria categoria = null;
				Integer idCategoria = null;
				Integer quantidadeEconomiasCategoria = null;

				BigDecimal valorPorCategoria = null;

				GuiaPagamentoCategoriaPK guiaPagamentoCategoriaPK = null;
				GuiaPagamentoCategoria guiaPagamentoCategoria = null;

				for(Integer idLancamentoItemContabilIt : mapPrestacoes.keySet()){
					valorLancamento = (BigDecimal) mapPrestacoes.get(idLancamentoItemContabilIt);

					// [UC0185] Obter Valor po Categoria
					colecaoValorCategoria = this.getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel, valorLancamento);

					// Cria as iterações de categoria e valor
					iteratorCategoria = colecaoCategoriasImovel.iterator();
					iteratorValorCategoria = colecaoValorCategoria.iterator();

					// Laço para criar os débitos a cobrar por categoria
					while(iteratorCategoria.hasNext()){
						// Recupera a categoria
						categoria = (Categoria) iteratorCategoria.next();
						idCategoria = categoria.getId();
						quantidadeEconomiasCategoria = categoria.getQuantidadeEconomiasCategoria();

						// Recupera o valor da categoria
						valorPorCategoria = (BigDecimal) iteratorValorCategoria.next();

						// Cria a guia de pagamento por categoria
						guiaPagamentoCategoriaPK = new GuiaPagamentoCategoriaPK();
						guiaPagamentoCategoriaPK.setGuiaPagamentoId(idGuiaPagamento);
						guiaPagamentoCategoriaPK.setNumeroPrestacao(numeroPrestacao);
						guiaPagamentoCategoriaPK.setCategoriaId(idCategoria);
						guiaPagamentoCategoriaPK.setLancamentoItemContabilId(idLancamentoItemContabilIt);

						guiaPagamentoCategoria = new GuiaPagamentoCategoria();
						guiaPagamentoCategoria.setComp_id(guiaPagamentoCategoriaPK);
						guiaPagamentoCategoria.setQuantidadeEconomia(quantidadeEconomiasCategoria);
						guiaPagamentoCategoria.setValorCategoria(valorPorCategoria);
						guiaPagamentoCategoria.setUltimaAlteracao(new Date());

						if(inInserir){
							this.getControladorUtil().inserir(guiaPagamentoCategoria);
						}else{
							colecaoGuiaPagamentoCategoriaRetorno.add(guiaPagamentoCategoria);
						}

					}
				}
			}
		}

		return colecaoGuiaPagamentoCategoriaRetorno;
	}

	/**
	 * [UC3021] – Processar Pagamento com Boleto Bancário
	 * [SB0007] – Distribuir Valores Guia por Categoria
	 * 
	 * @author Hebert Falcão
	 * @date 12/05/2012
	 * @author Hiroshi Gonçalves
	 * @date 29/11/2013
	 *       Adicionando o parâmetro "colecaoGuiaPagamentoPrestacao" ao método original,
	 *       utilizado para distribuir os valores considerando apenas as prestações desta
	 *       coleção.
	 */
	public void distribuirValoresGuiaPorCategoria(Integer idGuiaPagamento, Short numeroPrestacao, Imovel imovel)
					throws ControladorException{

		this.distribuirValoresGuiaPorCategoria(idGuiaPagamento, numeroPrestacao, imovel, null);
	}

	/**
	 * Retorna o valor de controladorMicromedicao
	 * 
	 * @return O valor de controladorMicromedicao
	 */
	protected ControladorMicromedicaoLocal getControladorMicromedicao(){

		ControladorMicromedicaoLocalHome localHome = null;
		ControladorMicromedicaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorMicromedicaoLocalHome) locator.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_MICROMEDICAO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retificar Contas do Documento de Cobrança
	 * 
	 * @author Hebert Falcão
	 * @date 14/05/2012
	 */
	private void retificarContasDocumentoCobranca(Integer idCobrancaDocumento, BigDecimal valorAcrescimosDoBanco,
					SistemaParametro sistemaParametro, Date dataPagamento) throws ControladorException{

		// Consulta documento ítem para adicionar na conta os valores de acrescimo
		FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItem = new FiltroCobrancaDocumentoItem();
		filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ID,
						idCobrancaDocumento));
		filtroCobrancaDocumentoItem.adicionarParametro(new ParametroNaoNulo(FiltroCobrancaDocumentoItem.CONTA_GERAL_CONTA));
		filtroCobrancaDocumentoItem.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.CONTA_GERAL_CONTA);

		Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItem = this.getControladorUtil().pesquisar(filtroCobrancaDocumentoItem,
						CobrancaDocumentoItem.class.getName());

		if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){
			boolean verificarAcrescimosDoBanco = true;

			// Débito tipo acrescimo por impontualidade

			FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
			filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE));
			filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO, ConstantesSistema.INDICADOR_USO_ATIVO));
			filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

			Collection colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

			if(Util.isVazioOrNulo(colecaoDebitoTipo)){
				throw new ActionServletException("atencao.pesquisa.nenhum_registro_tabela", null, "DEBITO_TIPO");
			}

			DebitoTipo objDebitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

			BigDecimal percentualEsgoto = null;
			BigDecimal valorAcrescimosPorImpontualidade = null;
			BigDecimal valorItemCobrado = null;
			BigDecimal valorTotalConta = null;

			Collection colecaoCategoria = null;
			Collection colecaoCreditoRealizado = null;
			Collection colecaoDebitoCobrado = null;
			Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta = null;
			Collection<MedicaoHistorico> colecaoMedicaoHistorico = null;

			ConsumoTarifa consumoTarifa = null;
			Conta contaAtual = null;
			ContaGeral contaGeral = null;
			ContaMotivoRetificacao contaMotivoRetificacao = null;

			Date dataLeituraAnterior = null;
			Date dataLeituraAtual = null;
			DebitoCobrado debitoCobrado = null;

			Imovel imovel = null;

			ImovelMicromedicao dadosMedicaoImovel = null;

			Integer consumoAgua = null;
			Integer idConsumoTarifa = null;
			Integer idConta = null;
			Integer idImovel = null;
			Integer idLigacaoAguaSituacao = null;
			Integer idLigacaoEsgotoSituacao = null;

			int anoMesReferencia = 0;

			LigacaoAguaSituacao ligacaoAguaSituacao = null;
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = null;

			Map<String, String[]> requestMap = null;

			String anoMesReferenciaStr = null;
			String consumoAguaStr = null;
			String idImovelStr = null;
			String mesAnoContaComBarraStr = null;
			String percentualEsgotoStr = null;

			Usuario usuarioLogado = Usuario.USUARIO_BATCH;

			for(CobrancaDocumentoItem cobrancaDocumentoItem : colecaoCobrancaDocumentoItem){
				// Preparando os valores para retificar

				contaGeral = cobrancaDocumentoItem.getContaGeral();

				idConta = contaGeral.getId();

				contaAtual = this.getControladorFaturamento().pesquisarContaRetificacao(idConta);

				if(contaAtual != null){
					valorTotalConta = contaAtual.getValorTotal();

					valorItemCobrado = cobrancaDocumentoItem.getValorItemCobrado();

					if(verificarAcrescimosDoBanco && valorAcrescimosDoBanco.compareTo(BigDecimal.ZERO) == 1){
						valorItemCobrado = valorItemCobrado.add(valorAcrescimosDoBanco);

						// Atualiza o Documento Ítem com o Acrescimo do Banco
						cobrancaDocumentoItem.setValorItemCobrado(valorItemCobrado);
						this.getControladorUtil().atualizar(cobrancaDocumentoItem);

						// Indicador para processar os acrescimos do banco apenas na primeia conta
						verificarAcrescimosDoBanco = false;
					}

					if(valorItemCobrado.compareTo(valorTotalConta) == 1){
						valorAcrescimosPorImpontualidade = valorItemCobrado.subtract(valorTotalConta);

						anoMesReferencia = contaAtual.getReferencia();
						anoMesReferenciaStr = Integer.toString(anoMesReferencia);

						mesAnoContaComBarraStr = Util.formatarAnoMesParaMesAno(anoMesReferencia);

						imovel = contaAtual.getImovel();

						idImovelStr = "";

						idImovel = imovel.getId();

						if(idImovel != null){
							idImovelStr = Integer.toString(idImovel);
						}

						colecaoDebitoCobrado = this.getControladorFaturamento().obterDebitosCobradosConta(contaAtual);

						// Débito cobrado do tipo acrescimo por impontualidade

						debitoCobrado = new DebitoCobrado();
						debitoCobrado.setUltimaAlteracao(new Date());
						debitoCobrado.setAnoMesReferenciaDebito(anoMesReferencia);
						debitoCobrado.setAnoMesCobrancaDebito(sistemaParametro.getAnoMesArrecadacao());
						debitoCobrado.setValorPrestacao(valorAcrescimosPorImpontualidade);
						debitoCobrado.setDebitoTipo(objDebitoTipo);
						debitoCobrado.setNumeroPrestacao(new Short("1").shortValue());
						debitoCobrado.setNumeroPrestacaoDebito(new Short("1").shortValue());

						colecaoDebitoCobrado.add(debitoCobrado);

						colecaoCreditoRealizado = this.getControladorFaturamento().obterCreditosRealizadosConta(contaAtual);

						ligacaoAguaSituacao = imovel.getLigacaoAguaSituacao();
						idLigacaoAguaSituacao = ligacaoAguaSituacao.getId();

						ligacaoEsgotoSituacao = imovel.getLigacaoEsgotoSituacao();
						idLigacaoEsgotoSituacao = ligacaoEsgotoSituacao.getId();

						colecaoCategoria = this.getControladorImovel().obterQuantidadeEconomiasContaCategoria(contaAtual);

						consumoAguaStr = null;

						consumoAgua = contaAtual.getConsumoAgua();

						if(consumoAgua != null){
							consumoAguaStr = Integer.toString(consumoAgua);
						}

						String consumoEsgotoStr = null;

						Integer consumoEsgoto = contaAtual.getConsumoEsgoto();

						if(consumoEsgoto != null){
							consumoEsgotoStr = Integer.toString(consumoEsgoto);
						}

						percentualEsgotoStr = null;

						percentualEsgoto = contaAtual.getPercentualEsgoto();

						if(percentualEsgoto != null){
							percentualEsgotoStr = Util.formatarMoedaReal(percentualEsgoto);
						}

						contaMotivoRetificacao = contaAtual.getContaMotivoRetificacao();

						consumoTarifa = contaAtual.getConsumoTarifa();
						idConsumoTarifa = consumoTarifa.getId();

						dataLeituraAtual = null;
						dataLeituraAnterior = null;

						dadosMedicaoImovel = this.getControladorMicromedicao().carregarDadosMedicaoResumido(idImovel, true,
										anoMesReferenciaStr);

						if(dadosMedicaoImovel != null && dadosMedicaoImovel.getMedicaoHistorico() != null){
							if(dadosMedicaoImovel.getMedicaoHistorico().getDataLeituraAtualFaturamento() != null){
								dataLeituraAtual = dadosMedicaoImovel.getMedicaoHistorico().getDataLeituraAtualFaturamento();
							}else{
								dataLeituraAtual = this.getControladorFaturamento().buscarDataLeituraCronograma(imovel, false,
												anoMesReferencia);
							}

							if(dadosMedicaoImovel.getMedicaoHistorico().getDataLeituraAnteriorFaturamento() != null){
								dataLeituraAnterior = dadosMedicaoImovel.getMedicaoHistorico().getDataLeituraAnteriorFaturamento();
							}else{
								dataLeituraAnterior = this.getControladorFaturamento().buscarDataLeituraCronograma(imovel, true,
												anoMesReferencia);
							}
						}

						// Calcular os valores da conta

						calcularValoresConta = this.getControladorFaturamento().calcularValoresConta(mesAnoContaComBarraStr, idImovelStr,
										idLigacaoAguaSituacao, idLigacaoEsgotoSituacao, colecaoCategoria, consumoAguaStr, consumoEsgotoStr,
										percentualEsgotoStr, idConsumoTarifa, usuarioLogado, dataLeituraAnterior, dataLeituraAtual);

						// Retificar conta

						this.getControladorFaturamento().retificarConta(anoMesReferencia, contaAtual, imovel, colecaoDebitoCobrado,
										colecaoCreditoRealizado, ligacaoAguaSituacao, ligacaoEsgotoSituacao, colecaoCategoria,
										consumoAguaStr, consumoEsgotoStr, percentualEsgotoStr, dataPagamento, calcularValoresConta,
										contaMotivoRetificacao, requestMap, usuarioLogado, colecaoMedicaoHistorico, consumoTarifa, null);
					}
				}
			}
		}
	}

	/**
	 * [UC0229] Obter Representação Numérica do Código de Barras
	 * 
	 * @author Hebert Falcão
	 * @date 18/06/2012
	 */
	public String obterRepresentacaoNumericaCodigoBarra(Integer tipoPagamento, BigDecimal valorCodigoBarra, Integer idLocalidade,
					Integer matriculaImovel, String mesAnoReferenciaConta, Integer digitoVerificadorRefContaModulo10, Integer idTipoDebito,
					String anoEmissaoGuiaPagamento, String sequencialDocumentoCobranca, Integer idTipoDocumento,
					Integer idClienteResponsavel, Integer seqFaturaClienteResponsavel, Short numeroPrestacaoDocumento,
					Integer idOpcaoPreParcelamento, Integer idGuiaPagamento, Integer idCliente) throws ControladorException{

		String paramIndicadorTrataLegado = ParametroArrecadacao.P_INDICADOR_TRATA_LEGADO.executar();

		if(ConstantesSistema.SIM.toString().equals(paramIndicadorTrataLegado)){
			if(idGuiaPagamento != null){
				// O método que tratava a parte de guia de pagamento enviava na variável
				// idTipoDocumento o id da guia de pagamento. Para não alterar o método antigo,
				// resolvemos que iríamos continuar enviando essa informação.

				idTipoDocumento = idGuiaPagamento;
				idClienteResponsavel = idCliente;
			}

			return this.obterRepresentacaoNumericaCodigoBarraSemParametrizacao(tipoPagamento, valorCodigoBarra, idLocalidade,
							matriculaImovel, mesAnoReferenciaConta, digitoVerificadorRefContaModulo10, idTipoDebito,
							anoEmissaoGuiaPagamento, sequencialDocumentoCobranca, idTipoDocumento, idClienteResponsavel,
							seqFaturaClienteResponsavel, numeroPrestacaoDocumento, idOpcaoPreParcelamento);
		}else{
			Object[] arrayCampos = this.distribuirCamposDoCodigoDeBarras(tipoPagamento, idLocalidade, matriculaImovel,
							mesAnoReferenciaConta, digitoVerificadorRefContaModulo10, idTipoDebito, anoEmissaoGuiaPagamento,
							sequencialDocumentoCobranca, idTipoDocumento, idClienteResponsavel, seqFaturaClienteResponsavel,
							numeroPrestacaoDocumento, idOpcaoPreParcelamento, idGuiaPagamento, idCliente);

			return this.obterRepresentacaoNumericaCodigoBarraComParametrizacao(arrayCampos, valorCodigoBarra, idTipoDocumento);
		}
	}

	/**
	 * [UC0229] Obter Representação Numérica do Código de Barras - Com Parametrização
	 * Distribuir Campos do Código de Barras
	 * 
	 * @author Hebert Falcão
	 * @date 18/06/2012
	 */
	private Object[] distribuirCamposDoCodigoDeBarras(Integer tipoPagamento, Integer idLocalidade, Integer matriculaImovel,
					String mesAnoReferenciaConta, Integer digitoVerificadorRefContaModulo10, Integer idTipoDebito,
					String anoEmissaoGuiaPagamento, String sequencialDocumentoCobranca, Integer idTipoDocumento,
					Integer idClienteResponsavel, Integer seqFaturaClienteResponsavel, Short numeroPrestacaoDocumento,
					Integer idOpcaoPreParcelamento, Integer idGuiaPagamento, Integer idCliente) throws ControladorException{

		Object[] retorno = new Object[2];

		Map<Integer, Object> mapCodigoBarrasCampos = new HashMap<Integer, Object>();

		Integer indicadorTipoProcessamento = null;

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.TIPO_DE_PAGAMENTO, tipoPagamento);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.CODIGO_DA_LOCALIDADE, idLocalidade);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.MATRICULA_DO_IMOVEL, matriculaImovel);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.MES_ANO_REFERENCIA_CONTA, mesAnoReferenciaConta);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.DIGITO_VERIFICADOR_DA_CONTA, digitoVerificadorRefContaModulo10);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.CODIGO_TIPO_DEBITO, idTipoDebito);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.ANO_EMISSAO_GUIA_PAGAMENTO, anoEmissaoGuiaPagamento);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.SEQUENCIAL_DOCUMENTO_COBRANCA, sequencialDocumentoCobranca);

		Integer codigoTipoDocumento = null;

		Integer indicadorDocumentoCliente = 0;
		
		Short sequencial = 0;

		Integer anoLancamento = 0;

		Integer numeroAviso = null;

		Integer numeroEmissao = 0;

		Integer codigoTributo = null;
		
		Integer valorFixo = null;

		FiltroDocumentoTipo filtroDocumentoTipo = new FiltroDocumentoTipo();
		filtroDocumentoTipo.adicionarParametro(new ParametroSimples(FiltroDocumentoTipo.ID, idTipoDocumento));

		Collection<DocumentoTipo> colecaoDocumentoTipo = this.getControladorUtil().pesquisar(filtroDocumentoTipo,
						DocumentoTipo.class.getName());

		if(!Util.isVazioOrNulo(colecaoDocumentoTipo)){
			DocumentoTipo documentoTipo = (DocumentoTipo) Util.retonarObjetoDeColecao(colecaoDocumentoTipo);
			codigoTipoDocumento = documentoTipo.getCodigo();

			PagamentoTipo tipoPagamentoImovel = documentoTipo.getTipoPagamentoImovel();
			PagamentoTipo tipoPagamentoCliente = documentoTipo.getTipoPagamentoCliente();

			if(tipoPagamentoImovel != null && tipoPagamentoCliente != null){
				Integer idTipoPagamentoCliente = tipoPagamentoCliente.getId();

				if(tipoPagamento != null && tipoPagamento.equals(idTipoPagamentoCliente)){
					indicadorDocumentoCliente = 1;

					indicadorTipoProcessamento = 1;
				}else{
					indicadorTipoProcessamento = 2;
				}
			}
			
			codigoTributo = documentoTipo.getCodigo();
			
			if(documentoTipo.getId().equals(DocumentoTipo.CONTA)){
				
				FiltroConta filtroConta = new FiltroConta();
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, matriculaImovel));
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, Util.formatarMesAnoParaAnoMes(Util
								.converterStringParaInteger(mesAnoReferenciaConta))));

				Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta,
								Conta.class.getName());
				
				if(!Util.isVazioOrNulo(colecaoConta)){
					Conta conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);
					numeroAviso = conta.getId();
				}
				
				valorFixo = 04;

			}else if(documentoTipo.getId().equals(DocumentoTipo.GUIA_PAGAMENTO)){
				
				numeroAviso = idGuiaPagamento;
				sequencial = numeroPrestacaoDocumento;
				valorFixo = 04;

			}else if(documentoTipo.getId().equals(DocumentoTipo.FATURA_CLIENTE)){
				
				FiltroFatura filtroFatura = new FiltroFatura();
				filtroFatura.adicionarParametro(new ParametroSimples(FiltroFatura.CLIENTE_ID, idClienteResponsavel));
				filtroFatura.adicionarParametro(new ParametroSimples(FiltroFatura.SEQUENCIAL, seqFaturaClienteResponsavel));

				Collection<Fatura> colecaoFatura = this.getControladorUtil().pesquisar(filtroFatura, Fatura.class.getName());
				
				if(!Util.isVazioOrNulo(colecaoFatura)){
					Fatura fatura = (Fatura) Util.retonarObjetoDeColecao(colecaoFatura);
					numeroAviso = fatura.getId();
					sequencial = fatura.getSequencial().shortValue();
				}

				valorFixo = 03;
			}
			
			
			
		}

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.CODIGO_TIPO_DOCUMENTO, codigoTipoDocumento);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.CODIGO_CLIENTE_RESPONSAVEL, idClienteResponsavel);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.SEQUENCIAL_FATURA_CLIENTE_RESPONSAVEL, seqFaturaClienteResponsavel);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.NUMERO_PRESTACAO_GUIA_PAGAMENTO, numeroPrestacaoDocumento);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.IDENTIFICACAO_GUIA_PAGAMENTO, idGuiaPagamento);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.IDENTIFICACAO_OPCAO_PRE_PARCELAMENTO, idOpcaoPreParcelamento);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.CODIGO_CLIENTE, idCliente);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.INDICADOR_DOCUMENTO_CLIENTE, indicadorDocumentoCliente);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.SEQUENCIAL, sequencial);
		
		mapCodigoBarrasCampos.put(CodigoBarrasCampos.ANO_LANCAMENTO, anoLancamento);
		
		mapCodigoBarrasCampos.put(CodigoBarrasCampos.NUMERO_AVISO, numeroAviso);
		
		mapCodigoBarrasCampos.put(CodigoBarrasCampos.NUMERO_EMISSAO, numeroEmissao);
		
		mapCodigoBarrasCampos.put(CodigoBarrasCampos.CODIGO_TRIBUTO, codigoTributo);

		mapCodigoBarrasCampos.put(CodigoBarrasCampos.VALOR_FIXO, valorFixo);

		retorno[0] = mapCodigoBarrasCampos;
		retorno[1] = indicadorTipoProcessamento;

		return retorno;
	}

	/**
	 * [UC0229] Obter Representação Numérica do Código de Barras - Com Parametrização
	 * 
	 * @author Hebert Falcão
	 * @date 18/06/2012
	 */
	private String obterRepresentacaoNumericaCodigoBarraComParametrizacao(Object[] arrayCampos, BigDecimal valorCodigoBarra,
					Integer idTipoDocumento) throws ControladorException{

		// Atribui precisão do Valor
		valorCodigoBarra = valorCodigoBarra.setScale(2);

		String representacaoNumericaCodigoBarra = "";

		// G.05.1 - Identificação do produto
		String identificacaoProduto = "8";
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoProduto;

		// G.05.2 - Identificação do segmento
		String identificacaoSegmento = "2";
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoSegmento;

		// G.05.3 - Identificação dovalor real ou referência
		String identificacaoValorRealOuReferencia = "6";
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoValorRealOuReferencia;

		// G.05.4 - Dígito verificador geral
		// Calculado posteriormente

		// G.05.5 - Valor do código de barras
		String valorCodigoBarraFormatado = Util.adicionarZerosEsquedaNumero(11, valorCodigoBarra.toString().replace(".", ""));
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + valorCodigoBarraFormatado;

		// G.05.7 - Identificação do Pagamento
		// [SB0001] – Obter Identificação do Pagamento
		StringBuilder identificacaoPagamento = new StringBuilder(Util.completarStringZeroDireita("", 25));

		Map<Integer, Object> mapCodigoBarrasCampos = (HashMap<Integer, Object>) arrayCampos[0];
		Integer indicadorTipoProcessamento = (Integer) arrayCampos[1];

		FiltroCodigoBarrasLayout filtroCodigoBarrasLayout = new FiltroCodigoBarrasLayout(FiltroCodigoBarrasLayout.POSICAO_INICIO);
		filtroCodigoBarrasLayout.adicionarParametro(new ParametroSimples(FiltroCodigoBarrasLayout.DOCUMENTO_TIPO_ID, idTipoDocumento));

		filtroCodigoBarrasLayout.adicionarParametro(new ParametroSimples(FiltroCodigoBarrasLayout.CONCESSIONARIA_ID, 1));

		if(indicadorTipoProcessamento != null){
			Collection<Integer> colecaoRestricaoCampos = new ArrayList<Integer>();

			if(indicadorTipoProcessamento.equals(new Integer("1"))){
				colecaoRestricaoCampos.add(CodigoBarrasCampos.MATRICULA_DO_IMOVEL);
			}else{
				colecaoRestricaoCampos.add(CodigoBarrasCampos.CODIGO_CLIENTE);
				colecaoRestricaoCampos.add(CodigoBarrasCampos.CODIGO_CLIENTE_RESPONSAVEL);
			}

			filtroCodigoBarrasLayout.adicionarParametro(new ParametroSimplesColecaoDiferenteDe(
							FiltroCodigoBarrasLayout.CODIGO_BARRAS_CAMPOS_ID, colecaoRestricaoCampos));
		}

		Collection<CodigoBarrasLayout> colecaoCodigoBarrasLayout = this.getControladorUtil().pesquisar(filtroCodigoBarrasLayout,
						CodigoBarrasLayout.class.getName());

		if(!Util.isVazioOrNulo(colecaoCodigoBarrasLayout)){
			CodigoBarrasCampos codigoBarrasCampos = null;
			Integer idCodigoBarrasCampos = null;
			Integer posicaoInicio = null;
			Integer tamanho = null;
			Short indicadorCampoObrigatorio = null;
			Object valor = null;
			String valorFormatado = null;

			for(CodigoBarrasLayout codigoBarrasLayout : colecaoCodigoBarrasLayout){
				codigoBarrasCampos = codigoBarrasLayout.getCodigoBarrasCampos();
				idCodigoBarrasCampos = codigoBarrasCampos.getId();

				posicaoInicio = codigoBarrasLayout.getPosicaoInicio();
				tamanho = codigoBarrasLayout.getTamanho();
				indicadorCampoObrigatorio = codigoBarrasLayout.getIndicadorCampoObrigatorio();

				if(indicadorCampoObrigatorio.equals(ConstantesSistema.SIM)
								&& (!mapCodigoBarrasCampos.containsKey(idCodigoBarrasCampos) || mapCodigoBarrasCampos
												.get(idCodigoBarrasCampos) == null)){
					log.error("idTipoDocumento: " + idTipoDocumento + ", idCodigoBarrasCampos: " + idCodigoBarrasCampos);

					throw new ControladorException("atencao.parametros_codigo_barras_incompletos", null,
									Integer.toString(idCodigoBarrasCampos));
				}else if(mapCodigoBarrasCampos.containsKey(idCodigoBarrasCampos)){
					valor = mapCodigoBarrasCampos.get(idCodigoBarrasCampos);

					if(valor != null){
						valorFormatado = Util.adicionarZerosEsqueda(tamanho, valor.toString());

						identificacaoPagamento.replace(posicaoInicio - 1, posicaoInicio + tamanho - 1, valorFormatado);
					}
				}
			}
		}

		// [SB0002] – Obter Identificação da Empresa
		Integer idLocalidade = null;

		String identificacaoEmpresa = "";

		if(!mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.CODIGO_DA_LOCALIDADE)
						|| (mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.CODIGO_DA_LOCALIDADE) && (mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.CODIGO_DA_LOCALIDADE) == null || ((Integer) mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.CODIGO_DA_LOCALIDADE)).intValue() == 0))){
			if(idTipoDocumento != null){
				if(idTipoDocumento == DocumentoTipo.CONTA){
					Integer idImovel = null;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.MATRICULA_DO_IMOVEL)){
						idImovel = (Integer) mapCodigoBarrasCampos.get(CodigoBarrasCampos.MATRICULA_DO_IMOVEL);
					}

					Integer anoMesReferencia = null;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.MES_ANO_REFERENCIA_CONTA)){
						String mesAnoReferenciaConta = (String) mapCodigoBarrasCampos.get(CodigoBarrasCampos.MES_ANO_REFERENCIA_CONTA);

						anoMesReferencia = Util.formatarMesAnoParaAnoMes(Integer.parseInt(mesAnoReferenciaConta));
					}

					if(idImovel != null && anoMesReferencia != null){
						FiltroConta filtroConta = new FiltroConta();
						filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, idImovel));
						filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, anoMesReferencia));

						Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

						if(!Util.isVazioOrNulo(colecaoConta)){
							Conta conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

							Localidade localidade = conta.getLocalidade();

							if(localidade != null){
								idLocalidade = localidade.getId();
							}
						}
					}

				}else if(idTipoDocumento == DocumentoTipo.DOCUMENTO_COBRANCA || idTipoDocumento == DocumentoTipo.AVISO_DE_CORTE
								|| idTipoDocumento == DocumentoTipo.EXTRATO_DE_DEBITO
								|| idTipoDocumento == DocumentoTipo.EXTRATO_DE_DEBITO_PARCELAMENTO
								|| idTipoDocumento == DocumentoTipo.EXTRATO_DE_DEBITO_PARCELAMENTO_CARTAO
								|| idTipoDocumento == DocumentoTipo.CARTA_OPCAO_PARCELAMENTO){

					Integer indicadorDocumentoCliente = 0;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.INDICADOR_DOCUMENTO_CLIENTE)){
						indicadorDocumentoCliente = (Integer) mapCodigoBarrasCampos.get(CodigoBarrasCampos.INDICADOR_DOCUMENTO_CLIENTE);
					}

					String sequencialDocumentoCobranca = null;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.SEQUENCIAL_DOCUMENTO_COBRANCA)){
						sequencialDocumentoCobranca = (String) mapCodigoBarrasCampos.get(CodigoBarrasCampos.SEQUENCIAL_DOCUMENTO_COBRANCA);
					}

					Integer idCliente = null;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.CODIGO_CLIENTE_RESPONSAVEL)){
						idCliente = (Integer) mapCodigoBarrasCampos.get(CodigoBarrasCampos.CODIGO_CLIENTE_RESPONSAVEL);
					}

					Integer idImovel = null;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.MATRICULA_DO_IMOVEL)){
						idImovel = (Integer) mapCodigoBarrasCampos.get(CodigoBarrasCampos.MATRICULA_DO_IMOVEL);
					}

					if(indicadorDocumentoCliente != null && sequencialDocumentoCobranca != null){
						FiltroCobrancaDocumento filtroCobrancaDocumento = null;

						if(indicadorDocumentoCliente == 1){
							if(idCliente != null){
								filtroCobrancaDocumento = new FiltroCobrancaDocumento();
								filtroCobrancaDocumento.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.NUMERO_SEQUENCIAL,
												sequencialDocumentoCobranca));
								filtroCobrancaDocumento.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.CLIENTE_ID,
												idCliente));
							}
						}else if(indicadorDocumentoCliente == 0){
							if(idImovel != null){
								filtroCobrancaDocumento = new FiltroCobrancaDocumento();
								filtroCobrancaDocumento.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.NUMERO_SEQUENCIAL,
												sequencialDocumentoCobranca));
								filtroCobrancaDocumento
												.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.IMOVEL_ID, idImovel));
							}
						}

						if(filtroCobrancaDocumento != null){
							Collection colecaoCobrancaDocumento = getControladorUtil().pesquisar(filtroCobrancaDocumento,
											CobrancaDocumento.class.getName());

							if(!Util.isVazioOrNulo(colecaoCobrancaDocumento)){
								CobrancaDocumento cobrancaDocumento = (CobrancaDocumento) Util
												.retonarObjetoDeColecao(colecaoCobrancaDocumento);

								Localidade localidade = cobrancaDocumento.getLocalidade();

								if(localidade != null){
									idLocalidade = localidade.getId();
								}
							}
						}
					}
				}else if(idTipoDocumento == DocumentoTipo.FATURA_CLIENTE){
					Integer idClienteResponsavel = null;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.CODIGO_CLIENTE_RESPONSAVEL)){
						idClienteResponsavel = (Integer) mapCodigoBarrasCampos.get(CodigoBarrasCampos.CODIGO_CLIENTE_RESPONSAVEL);
					}

					Integer seqFaturaClienteResponsavel = null;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.SEQUENCIAL_FATURA_CLIENTE_RESPONSAVEL)){
						seqFaturaClienteResponsavel = (Integer) mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.SEQUENCIAL_FATURA_CLIENTE_RESPONSAVEL);
					}

					if(idClienteResponsavel != null && seqFaturaClienteResponsavel != null && valorCodigoBarra != null){
						FiltroFatura filtroFatura = new FiltroFatura();
						filtroFatura.adicionarParametro(new ParametroSimples(FiltroFatura.CLIENTE_ID, idClienteResponsavel));
						filtroFatura.adicionarParametro(new ParametroSimples(FiltroFatura.SEQUENCIAL, seqFaturaClienteResponsavel));
						filtroFatura.adicionarParametro(new ParametroSimples(FiltroFatura.DEBITO_VALOR, valorCodigoBarra));

						Collection<Fatura> colecaoFatura = getControladorUtil().pesquisar(filtroFatura, Fatura.class.getName());
						if(!Util.isVazioOrNulo(colecaoFatura)){
							Collection<Object[]> faturaItens = null;

							try{
								faturaItens = repositorioFaturamento.pesquisarFaturaItem(seqFaturaClienteResponsavel);
							}catch(ErroRepositorioException e){
								throw new ControladorException("erro.sistema", e);
							}

							if(!Util.isVazioOrNulo(faturaItens)){
								for(Object[] faturaItem : faturaItens){
									if(faturaItem[2] != null){
										idLocalidade = (Integer) faturaItem[2];
										break;
									}
								}
							}
						}
					}

				}else if(idTipoDocumento == DocumentoTipo.GUIA_PAGAMENTO || idTipoDocumento == DocumentoTipo.NOTA_RECEBIMENTO){
					Integer idGuiaPagamento = null;

					if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.IDENTIFICACAO_GUIA_PAGAMENTO)){
						idGuiaPagamento = (Integer) mapCodigoBarrasCampos.get(CodigoBarrasCampos.IDENTIFICACAO_GUIA_PAGAMENTO);
					}

					if(idGuiaPagamento != null){
						FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
						filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));

						Collection<GuiaPagamento> colecaoGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamento,
										GuiaPagamento.class.getName());

						if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){
							GuiaPagamento guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);

							Localidade localidade = guiaPagamento.getLocalidade();

							if(localidade != null){
								idLocalidade = localidade.getId();
							}
						}
					}
				}
			}

			if(idLocalidade == null){
				String idLocalidadePadrao = ParametroCadastro.P_LOCA_ID_LOCALIDADE_PADRAO.executar();
				idLocalidade = Integer.valueOf(idLocalidadePadrao);
			}
		}else{
			idLocalidade = (Integer) mapCodigoBarrasCampos.get(CodigoBarrasCampos.CODIGO_DA_LOCALIDADE);
		}

		FiltroConcessionariaLocalidade filtroConcessionariaLocalidade = new FiltroConcessionariaLocalidade();
		filtroConcessionariaLocalidade.adicionarParametro(new ParametroSimples(FiltroConcessionariaLocalidade.ID_LOCALIDADE, idLocalidade));
		filtroConcessionariaLocalidade.adicionarParametro(new ParametroNulo(FiltroConcessionariaLocalidade.DATA_VIGENCIA_FIM));
		filtroConcessionariaLocalidade.adicionarCaminhoParaCarregamentoEntidade(FiltroConcessionariaLocalidade.CONCESSIONARIA);

		Collection<ConcessionariaLocalidade> colecaoConcessionariaLocalidade = this.getControladorUtil().pesquisar(
						filtroConcessionariaLocalidade, ConcessionariaLocalidade.class.getName());

		if(!Util.isVazioOrNulo(colecaoConcessionariaLocalidade)){
			ConcessionariaLocalidade concessionariaLocalidade = (ConcessionariaLocalidade) Util
							.retonarObjetoDeColecao(colecaoConcessionariaLocalidade);

			Concessionaria concessionaria = concessionariaLocalidade.getConcessionaria();

			if(concessionaria != null){
				Integer codigoEmpresaFebraban = concessionaria.getCodigoEmpresaFebraban();

				identificacaoEmpresa = Integer.toString(codigoEmpresaFebraban);
			}
		}

		// G.05.6 - Identificação da empresa
		identificacaoEmpresa = Util.adicionarZerosEsquedaNumero(4, identificacaoEmpresa);
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoEmpresa;

		// G.05.7 - Identificação do Pagamento
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + identificacaoPagamento;

		// G.05.4 - Dígito verificador geral
		String digitoVerificadorGeral = (Util.obterDigitoVerificadorGeral(representacaoNumericaCodigoBarra)).toString();

		representacaoNumericaCodigoBarra = identificacaoProduto + identificacaoSegmento + identificacaoValorRealOuReferencia
						+ digitoVerificadorGeral + valorCodigoBarraFormatado + identificacaoEmpresa + identificacaoPagamento;

		representacaoNumericaCodigoBarra = this.finalizarRepresentacaoNumericaCodigoBarra(representacaoNumericaCodigoBarra);

		return representacaoNumericaCodigoBarra;
	}

	/**
	 * [UC0264] – Distribuir Dados do Código de Barras
	 * Finalizar Distribuição do Código de Barras
	 * 
	 * @author Hebert Falcão
	 * @date 30/06/2012
	 */
	private String finalizarRepresentacaoNumericaCodigoBarra(String representacaoNumericaCodigoBarra){

		// Separa as 44 posições do código de barras em 4 grupos de onze posições e para cada um dos
		// grupos calcula o dígito verificador do módulo 10

		String codigoBarraCampo1 = representacaoNumericaCodigoBarra.substring(0, 11);
		String codigoBarraDigitoVerificadorCampo1 = (Util.obterDigitoVerificadorModulo10(Long.valueOf(codigoBarraCampo1))).toString();

		String codigoBarraCampo2 = representacaoNumericaCodigoBarra.substring(11, 22);
		String codigoBarraDigitoVerificadorCampo2 = (Util.obterDigitoVerificadorModulo10(Long.valueOf(codigoBarraCampo2))).toString();

		String codigoBarraCampo3 = representacaoNumericaCodigoBarra.substring(22, 33);
		String codigoBarraDigitoVerificadorCampo3 = (Util.obterDigitoVerificadorModulo10(Long.valueOf(codigoBarraCampo3))).toString();

		String codigoBarraCampo4 = representacaoNumericaCodigoBarra.substring(33, 44);
		String codigoBarraDigitoVerificadorCampo4 = (Util.obterDigitoVerificadorModulo10(Long.valueOf(codigoBarraCampo4))).toString();

		// Monta a representação númerica do código de barras com os dígitos verificadores
		String retorno = codigoBarraCampo1 + codigoBarraDigitoVerificadorCampo1 + codigoBarraCampo2 + codigoBarraDigitoVerificadorCampo2
						+ codigoBarraCampo3 + codigoBarraDigitoVerificadorCampo3 + codigoBarraCampo4 + codigoBarraDigitoVerificadorCampo4;

		return retorno;
	}

	/**
	 * [UC0264] – Distribuir Dados do Código de Barras
	 * [SB0020] – Distribuir Código de Barras – Modelo Gsan Parametrizado
	 * 
	 * @author Hebert Falcão
	 * @date 20/06/2012
	 */
	public Object[] distribuirDadosCodigoBarrasPeloModeloParametrizado(String idPagamento)
					throws ControladorException{

		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = null;
		Integer tipoPagamentoAux = null;
		String descricaoOcorrenciaMovimento = "OK";
		DocumentoTipo documentoTipo = null;

		Object[] retorno = new Object[3];

		retorno[0] = registroHelperCodigoBarrasTipoPagamento;
		retorno[1] = tipoPagamentoAux;
		retorno[2] = descricaoOcorrenciaMovimento;

		// Obter a posição do Código do Tipo de Documento
		FiltroCodigoBarrasLayout filtroCodigoBarrasLayout = new FiltroCodigoBarrasLayout();
		filtroCodigoBarrasLayout.adicionarParametro(new ParametroSimples(FiltroCodigoBarrasLayout.CODIGO_BARRAS_CAMPOS_ID,
						CodigoBarrasCampos.CODIGO_TIPO_DOCUMENTO));

		Collection<CodigoBarrasLayout> colecaoCodigoBarrasLayout = this.getControladorUtil().pesquisar(filtroCodigoBarrasLayout,
						CodigoBarrasLayout.class.getName());

		// [FS0001] – Verificar posição do código do tipo de documento no código de barras
		if(Util.isVazioOrNulo(colecaoCodigoBarrasLayout)){
			descricaoOcorrenciaMovimento = "NÃO FOI POSSÍVEL OBTER A POSIÇÃO DO CÓDIGO DO TIPO DE DOCUMENTO NO CÓDIGO DE BARRAS";

			return retorno;
		}

		// Obter o valor do Código do Tipo de Documento
		CodigoBarrasLayout codigoBarrasLayout = (CodigoBarrasLayout) Util.retonarObjetoDeColecao(colecaoCodigoBarrasLayout);
		Integer posicaoInicio = codigoBarrasLayout.getPosicaoInicio();
		Integer tamanho = codigoBarrasLayout.getTamanho();

		String codigoTipoDocumento = idPagamento.substring(posicaoInicio - 1, posicaoInicio + tamanho - 1);

		// [FS0002] – Validar código do tipo de documento

		// Verifica se o número da identificação do documento pagável contem caracteres não
		// numéricos
		if(Util.validarValorNaoNumerico(codigoTipoDocumento)){
			descricaoOcorrenciaMovimento = "CÓDIGO DO TIPO DE DOCUMENTO NÃO NUMÉRICO";

			return retorno;
		}

		// Verificar se o Tipo de Documento existe
		FiltroDocumentoTipo filtroDocumentoTipo = new FiltroDocumentoTipo();
		filtroDocumentoTipo.adicionarParametro(new ParametroSimples(FiltroDocumentoTipo.CODIGO, codigoTipoDocumento));
		filtroDocumentoTipo.adicionarCaminhoParaCarregamentoEntidade("tipoPagamentoImovel");
		filtroDocumentoTipo.adicionarCaminhoParaCarregamentoEntidade("tipoPagamentoCliente");

		Collection<DocumentoTipo> colecaoDocumentoTipo = this.getControladorUtil().pesquisar(filtroDocumentoTipo,
						DocumentoTipo.class.getName());

		if(Util.isVazioOrNulo(colecaoDocumentoTipo)){
			descricaoOcorrenciaMovimento = "CÓDIGO DO TIPO DE DOCUMENTO NÃO EXISTE";

			return retorno;
		}

		 documentoTipo = (DocumentoTipo) Util.retonarObjetoDeColecao(colecaoDocumentoTipo);

		Integer idDocumentoTipo = documentoTipo.getId();

		// Distribuir os dados do código de barras conforme o Código do Tipo de Documento
		filtroCodigoBarrasLayout = new FiltroCodigoBarrasLayout(FiltroCodigoBarrasLayout.POSICAO_INICIO);
		filtroCodigoBarrasLayout.adicionarParametro(new ParametroSimples(FiltroCodigoBarrasLayout.DOCUMENTO_TIPO_ID, idDocumentoTipo));

		colecaoCodigoBarrasLayout = this.getControladorUtil().pesquisar(filtroCodigoBarrasLayout, CodigoBarrasLayout.class.getName());

		// [FS0003] – Verificar existência dos campos do código de barras
		if(Util.isVazioOrNulo(colecaoCodigoBarrasLayout)){
			descricaoOcorrenciaMovimento = "NÃO FOI POSSÍVEL DISTRIBUIR OS CAMPOS DO CÓDIGO DE BARRAS";

			return retorno;
		}

		Map<Integer, String> mapCodigoBarrasCampos = new HashMap<Integer, String>();

		CodigoBarrasCampos codigoBarrasCampos = null;
		Integer idCodigoBarrasCampos = null;
		String valorCodigoBarras = null;

		for(CodigoBarrasLayout codigoBarrasLayoutAux : colecaoCodigoBarrasLayout){
			codigoBarrasCampos = codigoBarrasLayoutAux.getCodigoBarrasCampos();
			posicaoInicio = codigoBarrasLayoutAux.getPosicaoInicio();
			tamanho = codigoBarrasLayoutAux.getTamanho();

			idCodigoBarrasCampos = codigoBarrasCampos.getId();
			valorCodigoBarras = idPagamento.substring(posicaoInicio - 1, posicaoInicio + tamanho - 1);

			mapCodigoBarrasCampos.put(idCodigoBarrasCampos, valorCodigoBarras);
		}

		String indicadorDocumentoCliente = "0";

		if(mapCodigoBarrasCampos.containsKey(CodigoBarrasCampos.INDICADOR_DOCUMENTO_CLIENTE)){
			indicadorDocumentoCliente = mapCodigoBarrasCampos.get(CodigoBarrasCampos.INDICADOR_DOCUMENTO_CLIENTE);
		}

		// [SB0021] – Determinar Tipo de Pagamento
		tipoPagamentoAux = this.determinarTipoPagamentoCodigoBarras(documentoTipo, indicadorDocumentoCliente);

		if(tipoPagamentoAux != null){
			switch(tipoPagamentoAux.intValue()){

			// CONTA
				case PagamentoTipo.PAGAMENTO_TIPO_CONTA:
					registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();

					if(mapCodigoBarrasCampos.get(CodigoBarrasCampos.NUMERO_AVISO) != null){

						FiltroConta filtroConta = new FiltroConta();
						filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.NUMERO_AVISO)));

						Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

						if(!Util.isVazioOrNulo(colecaoConta)){
							Conta conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);
							registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(conta.getImovel().getId().toString());
							registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(Util.formatarAnoMesParaMesAnoSemBarra(conta
											.getAnoMesReferenciaConta()));
						}else{
							FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
							filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, mapCodigoBarrasCampos
											.get(CodigoBarrasCampos.NUMERO_AVISO)));

							Collection<ContaHistorico> colecaoContaHistorico = this.getControladorUtil().pesquisar(filtroContaHistorico,
											ContaHistorico.class.getName());

							if(!Util.isVazioOrNulo(colecaoContaHistorico)){
								ContaHistorico contaHistorico = (ContaHistorico) Util.retonarObjetoDeColecao(colecaoContaHistorico);
								registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(contaHistorico.getImovel().getId().toString());
								registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(contaHistorico.getAnoMesReferenciaConta() + "");
							}
						}

					}else{

						registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.MATRICULA_DO_IMOVEL));
						registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.MES_ANO_REFERENCIA_CONTA));
					}

					break;

				// GUIA DE PAGAMENTO (com matrícula do imóvel)
				case PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_MATRICULA_IMOVEL:
					registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();

					/**
					 * SOROCABA
					 * Este item ainda não foi completamente definido, aguardando definições
					 * migração!
					 */

					if(mapCodigoBarrasCampos.get(CodigoBarrasCampos.NUMERO_AVISO) != null){

						FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();

						filtroGuiaPagamento.adicionarParametro(new ParametroSimples(filtroGuiaPagamento.ID,
										mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.NUMERO_AVISO)));
						filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.IMOVEL);
						filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.CLIENTE);

						Collection<GuiaPagamento> colecaoGuiaPagamento = this.getControladorUtil().pesquisar(filtroGuiaPagamento,
										GuiaPagamento.class.getName());

						if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){

							GuiaPagamento guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);

							if(guiaPagamento.getImovel() != null){
								registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamento.getImovel().getId().toString());
							}else if(guiaPagamento.getCliente() != null){

								registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamento.getCliente().getId().toString());
							}

							registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
											.get(CodigoBarrasCampos.NUMERO_AVISO));
							registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
											.get(CodigoBarrasCampos.SEQUENCIAL));
						}else{
							FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();

							filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(filtroGuiaPagamentoHistorico.ID,
											mapCodigoBarrasCampos.get(CodigoBarrasCampos.NUMERO_AVISO)));
							filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoHistorico.IMOVEL);
							filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoHistorico.CLIENTE);

							Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = this.getControladorUtil().pesquisar(
											filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());

							if(!Util.isVazioOrNulo(colecaoGuiaPagamentoHistorico)){
								GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
												.retonarObjetoDeColecao(colecaoGuiaPagamentoHistorico);

								if(guiaPagamentoHistorico.getImovel() != null){
									registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamentoHistorico.getImovel().getId()
													.toString());
								}else if(guiaPagamentoHistorico.getCliente() != null){

									registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamentoHistorico.getCliente().getId()
													.toString());
								}

								registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
												.get(CodigoBarrasCampos.NUMERO_AVISO));
								registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
												.get(CodigoBarrasCampos.SEQUENCIAL));

							}
						}


						}else{

						registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.MATRICULA_DO_IMOVEL));
						registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.IDENTIFICACAO_GUIA_PAGAMENTO));
						registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.NUMERO_PRESTACAO_GUIA_PAGAMENTO));
					}

					break;

				// DOCUMENTO DE COBRANÇA (com matrícula do imóvel)
				case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_MATRICULA_IMOVEL:

					registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.MATRICULA_DO_IMOVEL));
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.SEQUENCIAL_DOCUMENTO_COBRANCA));

					break;

				// GUIA DE PAGAMENTO (com código do cliente)
				case PagamentoTipo.PAGAMENTO_TIPO_GUIA_PAGAMENTO_CODIGO_CLIENTE:

					if(mapCodigoBarrasCampos.get(CodigoBarrasCampos.NUMERO_AVISO) != null){

						FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();

						filtroGuiaPagamento.adicionarParametro(new ParametroSimples(filtroGuiaPagamento.ID, mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.NUMERO_AVISO)));
						filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.CLIENTE);
						filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.IMOVEL);

						Collection<GuiaPagamento> colecaoGuiaPagamento = this.getControladorUtil().pesquisar(filtroGuiaPagamento,
										GuiaPagamento.class.getName());

						if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){

							GuiaPagamento guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);

							if(guiaPagamento.getImovel() != null){
								registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamento.getImovel().getId().toString());
							}else if(guiaPagamento.getCliente() != null){

								registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamento.getCliente().getId().toString());
							}

							registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
											.get(CodigoBarrasCampos.NUMERO_AVISO));
							registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
											.get(CodigoBarrasCampos.SEQUENCIAL));
						}else{
							FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();

							filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(filtroGuiaPagamentoHistorico.ID,
											mapCodigoBarrasCampos.get(CodigoBarrasCampos.NUMERO_AVISO)));
							filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoHistorico.CLIENTE);
							filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamentoHistorico.IMOVEL);

							Collection<GuiaPagamentoHistorico> colecaoGuiaPagamentoHistorico = this.getControladorUtil().pesquisar(
											filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());

							if(!Util.isVazioOrNulo(colecaoGuiaPagamentoHistorico)){
								GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
												.retonarObjetoDeColecao(colecaoGuiaPagamentoHistorico);

								if(guiaPagamentoHistorico.getImovel() != null){
									registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamentoHistorico.getImovel().getId()
													.toString());
								}else if(guiaPagamentoHistorico.getCliente() != null){

									registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamentoHistorico.getCliente().getId()
													.toString());
								}

								registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
												.get(CodigoBarrasCampos.NUMERO_AVISO));
								registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
												.get(CodigoBarrasCampos.SEQUENCIAL));

							}
						}

					}else{
						registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
						registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.CODIGO_CLIENTE));
						registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.IDENTIFICACAO_GUIA_PAGAMENTO));
						registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.NUMERO_PRESTACAO_GUIA_PAGAMENTO));
					}



					break;

				// FATURA DO CLIENTE RESPONSÁVEL
				case PagamentoTipo.PAGAMENTO_TIPO_CLIENTE_RESPONSAVEL:

					/**
					 * SOROCABA
					 * Este item ainda não foi completamente definido, aguardando definições
					 * migração!
					 */

					registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
					if(mapCodigoBarrasCampos.get(CodigoBarrasCampos.NUMERO_AVISO) != null){

						FiltroFatura filtroFatura = new FiltroFatura();
						filtroFatura.adicionarParametro(new ParametroSimples(FiltroConta.ID, mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.NUMERO_AVISO)));
						filtroFatura.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.CLIENTE);

						Collection<Fatura> colecaoFatura = this.getControladorUtil().pesquisar(filtroFatura, Fatura.class.getName());

						if(!Util.isVazioOrNulo(colecaoFatura)){
							Fatura fatura = (Fatura) Util.retonarObjetoDeColecao(colecaoFatura);

							registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(fatura.getCliente().getId().toString());
							registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(fatura.getSequencial().toString());

						}

					}else{

						registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.CODIGO_CLIENTE_RESPONSAVEL));
						registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
										.get(CodigoBarrasCampos.SEQUENCIAL_FATURA_CLIENTE_RESPONSAVEL));
					}


					break;

				// DOCUMENTO DE COBRANÇA (com código do cliente)
				case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_CODIGO_CLIENTE:
					registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.CODIGO_CLIENTE_RESPONSAVEL));
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.SEQUENCIAL_DOCUMENTO_COBRANCA));
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.CODIGO_TIPO_DOCUMENTO));

					break;

				// DOCUMENTO DE COBRANÇA (pré parcelamento)
				case PagamentoTipo.PAGAMENTO_TIPO_COBANCA_PRE_PARCELAMENTO:
					registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.IDENTIFICACAO_OPCAO_PRE_PARCELAMENTO));
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.SEQUENCIAL_DOCUMENTO_COBRANCA));
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.CODIGO_TIPO_DOCUMENTO));

					break;

				// NOTA DE RECEBIMENTO
				case PagamentoTipo.PAGAMENTO_TIPO_NOTA_RECEBIMENTO:
					registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.MATRICULA_DO_IMOVEL));
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.CODIGO_DA_LOCALIDADE));
					registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(mapCodigoBarrasCampos
									.get(CodigoBarrasCampos.CODIGO_TIPO_DEBITO));

					break;

				// CASO NÃO SEJA NENHUM DESSES TIPOS DE PAGAMENTO
				default:
					descricaoOcorrenciaMovimento = "CÓDIGO DE BARRAS COM TIPO DE PAGAMENTO INVÁLIDO";

			}
		}else{
			descricaoOcorrenciaMovimento = "CÓDIGO DE BARRAS COM TIPO DE PAGAMENTO INVÁLIDO";
		}

		retorno[0] = registroHelperCodigoBarrasTipoPagamento;
		retorno[1] = tipoPagamentoAux;
		retorno[2] = descricaoOcorrenciaMovimento;

		return retorno;
	}

	/**
	 * [UC0264] – Distribuir Dados do Código de Barras
	 * [SB0021] – Determinar Tipo de Pagamento
	 * 
	 * @author Hebert Falcão
	 * @date 20/06/2012
	 */
	private Integer determinarTipoPagamentoCodigoBarras(DocumentoTipo documentoTipo, String indicadorDocumentoCliente)
					throws ControladorException{

		Integer tipoPagamento = null;

		PagamentoTipo tipoPagamentoImovel = documentoTipo.getTipoPagamentoImovel();
		PagamentoTipo tipoPagamentoCliente = documentoTipo.getTipoPagamentoCliente();

		if(tipoPagamentoImovel != null && tipoPagamentoCliente != null){
			if(("1").equals(indicadorDocumentoCliente)){
				tipoPagamento = tipoPagamentoCliente.getId();
			}else if(("0").equals(indicadorDocumentoCliente)){
				tipoPagamento = tipoPagamentoImovel.getId();
			}
		}else if(tipoPagamentoImovel != null){
			tipoPagamento = tipoPagamentoImovel.getId();
		}else if(tipoPagamentoCliente != null){
			tipoPagamento = tipoPagamentoCliente.getId();
		}

		return tipoPagamento;
	}

	/**
	 * [UC0259] – Processar Pagamento com Código de Barras
	 * [SB0022] – Processar Pagamento de Nota de Recebimento
	 * 
	 * @author Hebert Falcão
	 * @date 22/06/2012
	 */
	private PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasNotaRecebimento(
					RegistroHelperCodigoBarras registroHelperCodigoBarras, SistemaParametro sistemaParametro, Date dataPagamento,
					Integer anoMesPagamento, BigDecimal valorPagamento, Integer idFormaPagamento) throws ControladorException{

		Collection colecaoPagamentos = new ArrayList();
		String descricaoOcorrencia = "OK";
		String indicadorAceitacaoRegistro = "1";

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String paramIndicadorCadastroPrevioNR = ParametroArrecadacao.P_INDICADOR_CADASTRO_PREVIO_NOTA_RECEBIMENTO.executar();

		if(ConstantesSistema.SIM.toString().equals(paramIndicadorCadastroPrevioNR)){
			return this.processarPagamentosCodigoBarrasGuiaPagamento(registroHelperCodigoBarras, sistemaParametro, dataPagamento,
							anoMesPagamento, valorPagamento, idFormaPagamento);
		}else{
			// Validar matrícula do imóvel
			Imovel imovel = null;

			String idImovel = registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1();

			boolean matriculaImovelInvalido = Util.validarValorNaoNumerico(idImovel);

			if(matriculaImovelInvalido){
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL INVÁLIDA";
			}else{
				FiltroImovel filtroImovel = new FiltroImovel();
				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovel));

				Collection<Imovel> colecaoImovel = this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());

				if(Util.isVazioOrNulo(colecaoImovel)){
					descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
				}else{
					imovel = (Imovel) Util.retonarObjetoDeColecao(colecaoImovel);
				}
			}

			// Validar código do serviço
			String idServicoTipoStr = registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4();

			boolean codigoServicoInvalido = Util.validarValorNaoNumerico(idServicoTipoStr);

			if(codigoServicoInvalido){
				descricaoOcorrencia = "CÓDIGO DO SERVIÇO NÃO NUMÉRICO";
			}else{
				FiltroServicoTipo filtroServicoTipo = new FiltroServicoTipo();
				filtroServicoTipo.adicionarParametro(new ParametroSimples(FiltroServicoTipo.ID, idServicoTipoStr));

				Collection<ServicoTipo> colecaoServicoTipo = this.getControladorUtil().pesquisar(filtroServicoTipo,
								ServicoTipo.class.getName());

				if(Util.isVazioOrNulo(colecaoServicoTipo)){
					descricaoOcorrencia = "CÓDIGO DO SERVIÇO INEXISTENTE";
				}
			}

			if(descricaoOcorrencia.equals("OK")){
				// Inserir GuiaPagamentoGeral
				GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
				guiaPagamentoGeral.setIndicadorHistorico(ConstantesSistema.NAO);
				guiaPagamentoGeral.setUltimaAlteracao(new Date());

				this.getControladorUtil().inserir(guiaPagamentoGeral);

				// Inserir GuiaPagamento
				GuiaPagamento guiaPagamento = new GuiaPagamento();
				guiaPagamento.setId(guiaPagamentoGeral.getId());
				guiaPagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);

				DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
				debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
				guiaPagamento.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

				guiaPagamento.setLocalidade(imovel.getLocalidade());
				guiaPagamento.setSetorComercial(imovel.getSetorComercial());
				guiaPagamento.setImovel(imovel);
				guiaPagamento.setCliente(null);
				guiaPagamento.setRegistroAtendimento(null);
				guiaPagamento.setOrdemServico(null);
				guiaPagamento.setParcelamento(null);

				DocumentoTipo documentoTipoGuiaPagamento = new DocumentoTipo();
				documentoTipoGuiaPagamento.setId(DocumentoTipo.GUIA_PAGAMENTO);
				guiaPagamento.setDocumentoTipo(documentoTipoGuiaPagamento);

				guiaPagamento.setOrigem(null);
				guiaPagamento.setValorDebito(valorPagamento);
				guiaPagamento.setNumeroPrestacaoTotal(Util.obterShort("1"));
				guiaPagamento.setUltimaAlteracao(new Date());
				guiaPagamento.setDataInclusao(new Date());

				this.getControladorUtil().inserir(guiaPagamento);

				guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);

				// GuiaPagamentoPrestacao
				Integer idServicoTipo = Integer.valueOf(idServicoTipoStr);

				DebitoTipo debitoTipo = null;

				try{
					debitoTipo = repositorioArrecadacao.pesquisarDebitoTipoPorServicoTipo(idServicoTipo);
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				if(debitoTipo != null && debitoTipo.getLancamentoItemContabil() != null){
					GuiaPagamentoPrestacaoPK comp_id = new GuiaPagamentoPrestacaoPK(guiaPagamento.getId(), (short) 1, debitoTipo.getId(),
									debitoTipo.getLancamentoItemContabil().getId());

					GuiaPagamentoPrestacao guiaPagamentoPrestacao = new GuiaPagamentoPrestacao();
					guiaPagamentoPrestacao.setComp_id(comp_id);
					guiaPagamentoPrestacao.setDebitoCreditoSituacao(debitoCreditoSituacao);
					guiaPagamentoPrestacao.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
					guiaPagamentoPrestacao.setValorPrestacao(valorPagamento);
					guiaPagamentoPrestacao.setDataVencimento(dataPagamento);
					guiaPagamentoPrestacao.setIndicadorPagamentoPendente(ConstantesSistema.SIM);
					guiaPagamentoPrestacao.setIndicadorCobrancaMulta(ConstantesSistema.NAO);
					guiaPagamentoPrestacao.setAnoMesReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
					guiaPagamentoPrestacao.setDataEmissao(new Date());
					guiaPagamentoPrestacao.setUltimaAlteracao(new Date());

					this.getControladorUtil().inserir(guiaPagamentoPrestacao);
				}else{
					System.out.println("SVTP_ID S/ DBTP_ID E FNTP_ID: " + idServicoTipoStr);
					throw new ControladorException("erro.sistema");
				}

				// [UC0108] - Obter Quantidade de Economias por Categoria
				Collection colecaoCategoriasImovel = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

				if(Util.isVazioOrNulo(colecaoCategoriasImovel)){
					colecaoCategoriasImovel = new ArrayList();

					Categoria categoria = new Categoria(Categoria.RESIDENCIAL);
					categoria.setQuantidadeEconomiasCategoria(1);

					colecaoCategoriasImovel.add(categoria);
				}

				// [UC0185] – Obter Valor por Categoria
				Collection valoresCategoriasImovel = this.getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
								valorPagamento);

				// Insere GuiaPagamentoCategoria
				Iterator<Categoria> iteratorCategoriasImovel = colecaoCategoriasImovel.iterator();
				Iterator<BigDecimal> iteratorValoresCategoriasImovell = valoresCategoriasImovel.iterator();

				GuiaPagamentoCategoriaPK guiaPagamentoCategoriaPK = null;
				GuiaPagamentoCategoria guiaPagamentoCategoria = null;
				Categoria categoria = null;

				while(iteratorCategoriasImovel.hasNext()){
					categoria = iteratorCategoriasImovel.next();

					guiaPagamentoCategoriaPK = new GuiaPagamentoCategoriaPK(categoria.getId(), guiaPagamento.getId(), debitoTipo
									.getLancamentoItemContabil().getId(), (short) 1);

					guiaPagamentoCategoria = new GuiaPagamentoCategoria(guiaPagamentoCategoriaPK);
					guiaPagamentoCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
					guiaPagamentoCategoria.setValorCategoria(iteratorValoresCategoriasImovell.next());
					guiaPagamentoCategoria.setUltimaAlteracao(new Date());

					this.getControladorUtil().inserir(guiaPagamentoCategoria);
				}

				// Insere ClienteGuiaPagamento
				Collection<ClienteImovel> colecaoClientesImovel = this.getControladorImovel().pesquisarClientesImovel(imovel.getId());

				ClienteGuiaPagamento clienteGuiaPagamento = null;

				if(!Util.isVazioOrNulo(colecaoClientesImovel)){
					for(ClienteImovel clienteImovel : colecaoClientesImovel){
						clienteGuiaPagamento = new ClienteGuiaPagamento(clienteImovel.getCliente(), clienteImovel.getClienteRelacaoTipo(),
										guiaPagamento);

						clienteGuiaPagamento.setUltimaAlteracao(new Date());

						this.getControladorUtil().inserir(clienteGuiaPagamento);
					}
				}
				Pagamento pagamento = new Pagamento();

				if(anoMesPagamento > sistemaParametro.getAnoMesArrecadacao()){
					pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
				}else{
					pagamento.setAnoMesReferenciaArrecadacao(sistemaParametro.getAnoMesArrecadacao());
				}

				pagamento.setValorPagamento(valorPagamento);
				pagamento.setDataPagamento(dataPagamento);
				pagamento.setDebitoTipo(debitoTipo);
				pagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
				pagamento.setLocalidade(imovel.getLocalidade());
				pagamento.setDocumentoTipo(documentoTipoGuiaPagamento);
				pagamento.setImovel(imovel);

				ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				arrecadacaoForma.setId(idFormaPagamento);
				pagamento.setArrecadacaoForma(arrecadacaoForma);

				pagamento.setUltimaAlteracao(new Date());
				pagamento.setNumeroPrestacao(1);

				colecaoPagamentos.add(pagamento);

				// [SB0019] – Verificar Nota de Recebimento do Programa Água para Todos
				this.verificarNotaRecebimentoAguaParaTodos(registroHelperCodigoBarras, imovel);

			}else{
				indicadorAceitacaoRegistro = "2";
			}
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * Atualizar Valores do Aviso Bancário
	 * 
	 * @author Anderson Italo
	 * @date 16/06/2012
	 */
	public void atualizarValoresAvisoBancario(AvisoBancario avisoBancario, boolean alterarValorRealizado) throws ControladorException{

		BigDecimal valorPagamentosClassificados = BigDecimal.ZERO;
		BigDecimal valorPagamentosNaoClassificados = BigDecimal.ZERO;
		BigDecimal valorArrecadacaoCalculado = BigDecimal.ZERO;

		// Obtém o valor dos pagamentos não classificados
		Collection colecaoPagamentos = this.pesquisarPagamentoAvisoBancario(avisoBancario.getId());
		if(colecaoPagamentos != null){

			Iterator iteratorColecaoPagamentos = colecaoPagamentos.iterator();
			while(iteratorColecaoPagamentos.hasNext()){

				Pagamento pagamento = (Pagamento) iteratorColecaoPagamentos.next();
				valorPagamentosNaoClassificados = valorPagamentosNaoClassificados.add(pagamento.getValorPagamento());
			}
		}

		// Valor pagamentos não classificados
		avisoBancario.setValorPagamentoNaoClassificado(valorPagamentosNaoClassificados);

		// Obtém o valor dos pagamentos classificados
		Collection colecaoPagamentosHistorico = this.pesquisarPagamentoHistoricoAvisoBancario(avisoBancario.getId());
		if(colecaoPagamentosHistorico != null){

			Iterator iteratorColecaoPagamentoHistorico = colecaoPagamentosHistorico.iterator();

			while(iteratorColecaoPagamentoHistorico.hasNext()){

				PagamentoHistorico pagamentoHistorico = (PagamentoHistorico) iteratorColecaoPagamentoHistorico.next();
				valorPagamentosClassificados = valorPagamentosClassificados.add(pagamentoHistorico.getValorPagamento());
			}
		}

		// Valor pagamentos classificados
		avisoBancario.setValorPagamentoClassificado(valorPagamentosClassificados);

		// Caso seja para alterar o valor realizado
		if(alterarValorRealizado){

			// Caso o aviso seja de crédito
			if(avisoBancario.getIndicadorCreditoDebito().equals(AvisoBancario.INDICADOR_CREDITO)){

				// Atribui ao valor realizado o valor da arrecadação informado
				avisoBancario.setValorRealizado(avisoBancario.getValorArrecadacaoInformado());
			}else{

				// Atribui ao valor realizado o valor da devolução informado
				avisoBancario.setValorRealizado(avisoBancario.getValorDevolucaoInformado());
			}
		}

		// Valor Arrecadação Calculado (Valor pag. classificados + Valor pag. não classificados)
		valorArrecadacaoCalculado = valorPagamentosClassificados.add(valorPagamentosNaoClassificados);
		avisoBancario.setValorArrecadacaoCalculado(valorArrecadacaoCalculado);

		// Data ùltima alteração
		avisoBancario.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(avisoBancario);

	}

	/**
	 * [UC0339] - Consultar Dados Diários da Arrecadação
	 * [SB0011] – Obter Valor Despesa Bancária do Arrecadador
	 * Obtém os dados da tarifa do arrecadador a partir da tabela ARRECADADOR_CONTRATO_TARIFA.
	 * 
	 * @author Josenildo Neves
	 * @date 19/06/2012
	 * @throws ErroRepositorioException
	 */
	public List<ArrecadadorContratoTarifaHelper> pesquisarArrecadadorContratoTarifaPorArrecadacaoDadosDiarios(
					Integer idArrecadacaoDadosDiarios, Integer anoMesArrecadacao, String localidade, String idElo, String setorComercial,
					String idGerenciaRegional, String unidadeNegocioId, String[] idsImovelPerfil, String[] idsLigacaoAgua,
					String[] idsLigacaoEsgoto, String[] idsCategoria, String[] idsEsferaPoder, String[] idsDocumentosTipos)
					throws ControladorException{

		try{

			return repositorioArrecadacao.pesquisarArrecadadorContratoTarifaPorArrecadacaoDadosDiarios(idArrecadacaoDadosDiarios,
							anoMesArrecadacao, localidade, idElo, setorComercial, idGerenciaRegional, unidadeNegocioId, idsImovelPerfil,
							idsLigacaoAgua, idsLigacaoEsgoto, idsCategoria, idsEsferaPoder, idsDocumentosTipos);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0235] - Inserir aviso bancário
	 * [SB0001] - Preparar Preenchimento da Conta Bancária
	 * 
	 * @author André Lopes
	 * @date 07/05/2013
	 * @throws ErroRepositorioException
	 */
	public List<ArrecadadorContrato> pesquisarContaBancaria(Integer idArrecadacao) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarContaBancaria(idArrecadacao);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Remover Imóvel Cobrança Administriva - Conta
	 * 
	 * @author Hebert Falcão
	 * @date 07/07/2012
	 */
	private void removerImovelCobrancaAdministrivaConta(Integer idConta) throws ControladorException{

		Collection<Object> colecaoImovelCobrancaSituacaoAtualizar = new ArrayList<Object>();
		Collection<Object> colecaoImovelCobrancaAdministrivaItemRemover = new ArrayList<Object>();

		// Se a Conta pertencer a algum Item de Documento de Cobrança
		FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItem = new FiltroCobrancaDocumentoItem();
		filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.CONTA_GERAL_ID, idConta));
		filtroCobrancaDocumentoItem.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO);
		filtroCobrancaDocumentoItem
						.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ATIVIDADE_COMANDO);

		Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItem = this.getControladorUtil().pesquisar(filtroCobrancaDocumentoItem,
						CobrancaDocumentoItem.class.getName());

		if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){
			CobrancaDebitoSituacao cobrancaDebitoSituacaoPendente = new CobrancaDebitoSituacao();
			cobrancaDebitoSituacaoPendente.setId(CobrancaDebitoSituacao.PENDENTE);

			CobrancaDocumento cobrancaDocumento = null;
			CobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando = null;
			Imovel imovel = null;

			Integer idCobrancaAcaoAtividadeComando = null;
			Integer idImovel = null;
			Integer idImovelCobrancaSituacao = null;

			FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = null;
			FiltroImovelCobrancaAdministrivaItem filtroImovelCobrancaAdministrivaItem = null;

			Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = null;
			Collection<ImovelCobrancaAdministrivaItem> colecaoImovelCobrancaAdministrivaItem = null;

			for(CobrancaDocumentoItem cobrancaDocumentoItem : colecaoCobrancaDocumentoItem){
				// Se o Item em questão Pertencer a Cobrança Administrativa
				cobrancaDocumento = cobrancaDocumentoItem.getCobrancaDocumento();
				cobrancaAcaoAtividadeComando = cobrancaDocumento.getCobrancaAcaoAtividadeComando();
				imovel = cobrancaDocumento.getImovel();

				if(cobrancaAcaoAtividadeComando != null && imovel != null){
					idCobrancaAcaoAtividadeComando = cobrancaAcaoAtividadeComando.getId();
					idImovel = imovel.getId();

					filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(
									FiltroImovelCobrancaSituacao.COBRANCA_ACAO_ATIVIDADE_COMANDO_ID, idCobrancaAcaoAtividadeComando));
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, idImovel));
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
									CobrancaSituacao.COBRANCA_ADMINISTRATIVA));

					colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
									ImovelCobrancaSituacao.class.getName());

					if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){
						for(ImovelCobrancaSituacao imovelCobrancaSituacao : colecaoImovelCobrancaSituacao){
							imovelCobrancaSituacao.setDataAdimplencia(null);
							imovelCobrancaSituacao.setAnoMesAdimplencia(null);
							imovelCobrancaSituacao.setUltimaAlteracao(new Date());
							imovelCobrancaSituacao.setCobrancaDebitoSituacao(cobrancaDebitoSituacaoPendente);

							colecaoImovelCobrancaSituacaoAtualizar.add(imovelCobrancaSituacao);

							// Excluir da tabela Imóvel Cobrança Administração a Linha
							// Correspondente ao Documento em Questão
							idImovelCobrancaSituacao = imovelCobrancaSituacao.getId();

							filtroImovelCobrancaAdministrivaItem = new FiltroImovelCobrancaAdministrivaItem();
							filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples(
											FiltroImovelCobrancaAdministrivaItem.IMOVEL_COBRANCA_SITUACAO_ID, idImovelCobrancaSituacao));
							filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples(
											FiltroImovelCobrancaAdministrivaItem.CONTA_GERAL_ID, idConta));

							colecaoImovelCobrancaAdministrivaItem = this.getControladorUtil().pesquisar(
											filtroImovelCobrancaAdministrivaItem, ImovelCobrancaAdministrivaItem.class.getName());

							if(!Util.isVazioOrNulo(colecaoImovelCobrancaAdministrivaItem)){
								colecaoImovelCobrancaAdministrivaItemRemover.addAll(colecaoImovelCobrancaAdministrivaItem);
							}
						}
					}

				}
			}
		}else{
			// Excluir da tabela Imóvel Cobrança Administração a Linha Correspondente ao
			// Documento em Questão
			FiltroImovelCobrancaAdministrivaItem filtroImovelCobrancaAdministrivaItem = new FiltroImovelCobrancaAdministrivaItem();
			filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples(
							FiltroImovelCobrancaAdministrivaItem.CONTA_GERAL_ID, idConta));

			Collection<ImovelCobrancaAdministrivaItem> colecaoImovelCobrancaAdministrivaItem = this.getControladorUtil().pesquisar(
							filtroImovelCobrancaAdministrivaItem, ImovelCobrancaAdministrivaItem.class.getName());

			if(!Util.isVazioOrNulo(colecaoImovelCobrancaAdministrivaItem)){
				colecaoImovelCobrancaAdministrivaItemRemover.addAll(colecaoImovelCobrancaAdministrivaItem);
			}
		}

		this.getControladorUtil().atualizarColecaoObjetos(colecaoImovelCobrancaSituacaoAtualizar);
		this.getControladorUtil().removerColecaoObjetos(colecaoImovelCobrancaAdministrivaItemRemover);
	}

	/**
	 * Remover Imóvel Cobrança Administriva - Guia
	 * 
	 * @author Hebert Falcão
	 * @date 07/07/2012
	 */
	private void removerImovelCobrancaAdministrivaGuia(Integer idGuiaPagamento, Short numeroDaPrestacao) throws ControladorException{

		Collection<Object> colecaoImovelCobrancaSituacaoAtualizar = new ArrayList<Object>();
		Collection<Object> colecaoImovelCobrancaAdministrivaItemRemover = new ArrayList<Object>();

		// Se a Guia pertencer a algum Item de Documento de Cobrança
		FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItem = new FiltroCobrancaDocumentoItem();
		filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.GUIA_PAGAMENTO_GERAL_ID,
						idGuiaPagamento));
		filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.NUMERO_DA_PRESTACAO,
						numeroDaPrestacao));
		filtroCobrancaDocumentoItem.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO);
		filtroCobrancaDocumentoItem
						.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ATIVIDADE_COMANDO);

		Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItem = this.getControladorUtil().pesquisar(filtroCobrancaDocumentoItem,
						CobrancaDocumentoItem.class.getName());

		if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){
			CobrancaDebitoSituacao cobrancaDebitoSituacaoPendente = new CobrancaDebitoSituacao();
			cobrancaDebitoSituacaoPendente.setId(CobrancaDebitoSituacao.PENDENTE);

			CobrancaDocumento cobrancaDocumento = null;
			CobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando = null;
			Imovel imovel = null;

			Integer idCobrancaAcaoAtividadeComando = null;
			Integer idImovel = null;
			Integer idImovelCobrancaSituacao = null;

			FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = null;
			FiltroImovelCobrancaAdministrivaItem filtroImovelCobrancaAdministrivaItem = null;

			Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = null;
			Collection<ImovelCobrancaAdministrivaItem> colecaoImovelCobrancaAdministrivaItem = null;

			for(CobrancaDocumentoItem cobrancaDocumentoItem : colecaoCobrancaDocumentoItem){
				// Se o Item em questão Pertencer a Cobrança Administrativa
				cobrancaDocumento = cobrancaDocumentoItem.getCobrancaDocumento();
				cobrancaAcaoAtividadeComando = cobrancaDocumento.getCobrancaAcaoAtividadeComando();
				imovel = cobrancaDocumento.getImovel();

				if(cobrancaAcaoAtividadeComando != null && imovel != null){
					idCobrancaAcaoAtividadeComando = cobrancaAcaoAtividadeComando.getId();
					idImovel = imovel.getId();

					filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(
									FiltroImovelCobrancaSituacao.COBRANCA_ACAO_ATIVIDADE_COMANDO_ID, idCobrancaAcaoAtividadeComando));
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, idImovel));
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
									CobrancaSituacao.COBRANCA_ADMINISTRATIVA));

					colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
									ImovelCobrancaSituacao.class.getName());

					if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){
						for(ImovelCobrancaSituacao imovelCobrancaSituacao : colecaoImovelCobrancaSituacao){
							imovelCobrancaSituacao.setDataAdimplencia(null);
							imovelCobrancaSituacao.setAnoMesAdimplencia(null);
							imovelCobrancaSituacao.setUltimaAlteracao(new Date());
							imovelCobrancaSituacao.setCobrancaDebitoSituacao(cobrancaDebitoSituacaoPendente);

							colecaoImovelCobrancaSituacaoAtualizar.add(imovelCobrancaSituacao);

							// Excluir da tabela Imóvel Cobrança Administração a Linha
							// Correspondente ao Documento em Questão
							idImovelCobrancaSituacao = imovelCobrancaSituacao.getId();

							filtroImovelCobrancaAdministrivaItem = new FiltroImovelCobrancaAdministrivaItem();
							filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples(
											FiltroImovelCobrancaAdministrivaItem.IMOVEL_COBRANCA_SITUACAO_ID, idImovelCobrancaSituacao));
							filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples(
											FiltroImovelCobrancaAdministrivaItem.GUIA_PAGAMENTO_GERAL_ID, idGuiaPagamento));
							filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples(
											FiltroImovelCobrancaAdministrivaItem.NUMERO_PRESTACAO, numeroDaPrestacao));

							colecaoImovelCobrancaAdministrivaItem = this.getControladorUtil().pesquisar(
											filtroImovelCobrancaAdministrivaItem, ImovelCobrancaAdministrivaItem.class.getName());

							if(!Util.isVazioOrNulo(colecaoImovelCobrancaAdministrivaItem)){
								colecaoImovelCobrancaAdministrivaItemRemover.addAll(colecaoImovelCobrancaAdministrivaItem);
							}
						}
					}

				}
			}
		}else{
			// Excluir da tabela Imóvel Cobrança Administração a Linha Correspondente ao
			// Documento em Questão
			FiltroImovelCobrancaAdministrivaItem filtroImovelCobrancaAdministrivaItem = new FiltroImovelCobrancaAdministrivaItem();
			filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples(
							FiltroImovelCobrancaAdministrivaItem.GUIA_PAGAMENTO_GERAL_ID, idGuiaPagamento));
			filtroImovelCobrancaAdministrivaItem.adicionarParametro(new ParametroSimples(
							FiltroImovelCobrancaAdministrivaItem.NUMERO_PRESTACAO, numeroDaPrestacao));

			Collection<ImovelCobrancaAdministrivaItem> colecaoImovelCobrancaAdministrivaItem = this.getControladorUtil().pesquisar(
							filtroImovelCobrancaAdministrivaItem, ImovelCobrancaAdministrivaItem.class.getName());

			if(!Util.isVazioOrNulo(colecaoImovelCobrancaAdministrivaItem)){
				colecaoImovelCobrancaAdministrivaItemRemover.addAll(colecaoImovelCobrancaAdministrivaItem);
			}
		}

		this.getControladorUtil().atualizarColecaoObjetos(colecaoImovelCobrancaSituacaoAtualizar);
		this.getControladorUtil().removerColecaoObjetos(colecaoImovelCobrancaAdministrivaItemRemover);
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB0019] – Gerar Remuneração Cobrança Administrativa
	 * 
	 * @author Anderson Italo
	 * @date 06/07/2012
	 */
	private void gerarRemuneracaoCobrancaAdministrativaANTIGA(Integer idConta, Integer idGuiaPagamento, Integer idPagamento)
					throws ControladorException, ErroRepositorioException{

		PagamentoHistorico pagamentoHistorico = (PagamentoHistorico) getControladorUtil().pesquisar(idPagamento, PagamentoHistorico.class,
						false);
		String parametroTiposDebitosCobrancaAdministrativa = ParametroArrecadacao.P_SERVICO_PARCELAMENTO_COBRANCA_ADMINISTRATIVA.executar()
						.toString();
		parametroTiposDebitosCobrancaAdministrativa += ","
						+ ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_CONTA_COBRANCA_ADMINISTRATIVA.executar().toString();
		parametroTiposDebitosCobrancaAdministrativa += ","
						+ ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_GUIA_PAGAMENTO_COBRANCA_ADMINISTRATIVA.executar().toString();
		parametroTiposDebitosCobrancaAdministrativa += ","
						+ ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_ACRESCIMO_IMPONTUALIDADE_COBRANCA_ADMINISTRATIVA.executar()
										.toString();
		parametroTiposDebitosCobrancaAdministrativa += ","
						+ ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_JUROS_PARCELAMENTO_COBRANCA_ADMINISTRATIVA.executar().toString();

		String parametroServicosEspeciaisCobrancaAdministrativa = ParametroArrecadacao.P_SERVICOS_ESPECIAIS_COBRANCA_ADMINISTRATIVA
						.executar().toString();

		// Caso o pagamento tenha sido classificado
		if(pagamentoHistorico != null){

			ImovelCobrancaSituacao imovelCobrancaSituacao = null;
			CobrancaDocumentoItem cobrancaDocumentoItem = null;
			boolean classificouDocumentoCobrancaAdministrativa = false;
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// Caso o Pagamento seja de uma conta
			if(idConta != null){

				ContaHistorico contaHistorico = (ContaHistorico) getControladorUtil().pesquisar(idConta, ContaHistorico.class, false);

				// O Imóvel deve estar em cobrança Administrativa e em Atividade
				if(contaHistorico != null && contaHistorico.getImovel() != null){
					imovelCobrancaSituacao = repositorioArrecadacao.pesquisarImovelEmCobrancaAdministrativa(contaHistorico.getImovel()
									.getId());
				}

				if(imovelCobrancaSituacao != null){

					/*
					 * O Documento em questão deve pertencer ao conjunto de documentos Gerados pelo
					 * Comando de Ação associado ao Imóvel ou ser Parte do Parcelamento de pelo
					 * menos um Item do Conjunto e que tenha sido efetuado durante a Vigência do
					 * comando de
					 * Ação
					 */
					Collection colecaoCobrancaDocumentoItem = repositorioArrecadacao.pesquisarItensCobrancaDocumentoPorComando(
									imovelCobrancaSituacao.getCobrancaAcaoAtividadeComando().getId(), idConta, null, null, null);

					DebitoCobradoHistorico debitoCobradoHistorico = repositorioArrecadacao.pesquisarDebitoCobradoCobrancaAdministrativa(
									idConta, parametroTiposDebitosCobrancaAdministrativa,
									imovelCobrancaSituacao.getDataImplantacaoCobranca(), imovelCobrancaSituacao.getDataRetiradaCobranca());

					// Caso a conta esteja em cobrança administrativa
					if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem) || debitoCobradoHistorico != null){

						classificouDocumentoCobrancaAdministrativa = true;

						if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){

							Object[] retornoConsulta = Util.retonarObjetoDeColecaoArray(colecaoCobrancaDocumentoItem);
							cobrancaDocumentoItem = (CobrancaDocumentoItem) retornoConsulta[0];
						}

						/*
						 * Verificar se Conta em questão é uma de Entrada de Parcelamento e se o
						 * Parcelamento foi feito na vigência do Comando
						 */
						ContaHistorico contaEntradaParcelamento = repositorioArrecadacao
										.pesquisarContaEntradaParcelamentoCobrancaAdministrativa(idConta,
														imovelCobrancaSituacao.getDataImplantacaoCobranca(),
														imovelCobrancaSituacao.getDataRetiradaCobranca());

						// Calcular Remuneração para Entrada de parcelamento ou para Inadimplente
						boolean ehEntradaParcelamento = (contaEntradaParcelamento != null)
										&& contaEntradaParcelamento.getIndicadorCobrancaAdministrativa().equals(ConstantesSistema.SIM);

						if(ehEntradaParcelamento || imovelCobrancaSituacao.getDataAdimplencia() == null){

							// Achar base de Cálculo para a Remuneração
							BigDecimal valorBaseCalculo = contaHistorico.getValorTotalSemImpostos();

							// Achar Valor da Remuneração
							BigDecimal valorRemuneracao = (valorBaseCalculo.multiply(imovelCobrancaSituacao.getPercentualRemuneracao()))
											.divide(new BigDecimal("100"));

							// Incluir Remuneração
							ImovelCobrancaAdministrivaItem itemRemuneracao = new ImovelCobrancaAdministrivaItem();
							itemRemuneracao.setImovelCobrancaSituacao(imovelCobrancaSituacao);
							itemRemuneracao.setDocumentoTipo(new DocumentoTipo(DocumentoTipo.CONTA));

							ContaGeral contaGeral = new ContaGeral();
							contaGeral.setId(idConta);
							itemRemuneracao.setContaGeral(contaGeral);

							itemRemuneracao.setPercentualRemuneracao(imovelCobrancaSituacao.getPercentualRemuneracao());
							itemRemuneracao.setValorRemuneracao(valorRemuneracao);
							itemRemuneracao.setUltimaAlteracao(new Date());

							getControladorUtil().inserir(itemRemuneracao);
						}

						// Calcular Remuneração Adimplentes
						if(imovelCobrancaSituacao.getDataAdimplencia() != null){

							/*
							 * Achar Base de Cálculo dos serviços de parcelamento para os
							 * parcelamentos
							 * Realizados no Período da Ação
							 */
							BigDecimal valorBaseParcelamento = repositorioArrecadacao.obterValorBaseParcelamentoCobrancaAdministrativa(
											idConta, parametroTiposDebitosCobrancaAdministrativa,
											imovelCobrancaSituacao.getDataImplantacaoCobranca(),
											imovelCobrancaSituacao.getDataRetiradaCobranca());

							if(valorBaseParcelamento == null){

								valorBaseParcelamento = BigDecimal.ZERO;
							}

							/*
							 * Achar Base de Cálculo dos serviços Especiais Pertencentes a Conta em
							 * Questão
							 */
							BigDecimal valorServicosEspeciais = repositorioArrecadacao.obterValorBaseEspecialCobrancaAdministrativa(
											idConta, parametroTiposDebitosCobrancaAdministrativa,
											parametroServicosEspeciaisCobrancaAdministrativa,
											imovelCobrancaSituacao.getDataImplantacaoCobranca(),
											imovelCobrancaSituacao.getDataRetiradaCobranca());
							if(valorServicosEspeciais == null){

								valorServicosEspeciais = BigDecimal.ZERO;
							}

							/*
							 * Achar Valor Total dos Serviços Ditos Comuns Pertencentes a Conta em
							 * Questão
							 */
							BigDecimal valorServicosComuns = repositorioArrecadacao.obterValorServicosComumCobrancaAdministrativa(idConta,
											parametroTiposDebitosCobrancaAdministrativa, parametroServicosEspeciaisCobrancaAdministrativa,
											imovelCobrancaSituacao.getDataImplantacaoCobranca(),
											imovelCobrancaSituacao.getDataRetiradaCobranca());

							if(valorServicosComuns == null){

								valorServicosComuns = BigDecimal.ZERO;
							}

							ImovelCobrancaAdministrivaItem itemRemuneracao = new ImovelCobrancaAdministrivaItem();

							if(imovelCobrancaSituacao.getPercentualRemuneracao() != null){

								// Achar Valor da Remuneração
								BigDecimal valorRemuneracaoParcelamento = (valorBaseParcelamento.multiply(imovelCobrancaSituacao
												.getPercentualRemuneracao())).divide(new BigDecimal("100"));
								itemRemuneracao.setValorRemuneracaoParcelado(valorRemuneracaoParcelamento);
								itemRemuneracao.setPercentualRemuneracaoParcelado(imovelCobrancaSituacao.getPercentualRemuneracao());

								// **REMUNERAR SERVIÇOS ESPECIAIS**
								BigDecimal valorRemuneracaoEspecial = (valorServicosEspeciais.multiply(imovelCobrancaSituacao
												.getPercentualRemuneracao())).divide(new BigDecimal("100"));
								itemRemuneracao.setValorRemuneracaoEspecial(valorRemuneracaoEspecial);
								itemRemuneracao.setPercentualRemuneracaoEspecial(imovelCobrancaSituacao.getPercentualRemuneracao());
							}

							/*
							 * Achar Quantidade de Dias entre a Data do Pagamento e a Data de
							 * Vencimento
							 * a Conta em Questão
							 */
							int quantidadeDiasAtraso = 0;

							// Caso a conta tenha sido paga em atraso
							if(Util.compararData(pagamentoHistorico.getDataPagamento(), contaHistorico.getDataVencimentoConta()) == 1){

								quantidadeDiasAtraso = Util.calcularDiferencaEntreDatas(contaHistorico.getDataVencimentoConta(),
												pagamentoHistorico.getDataPagamento(), ConstantesSistema.DIFERENCA_DIAS).intValue();
							}

							// **REMUNERAR REINCIDÊNCIA**
							CobrancaContrato cobrancaContrato = repositorioArrecadacao
											.pesquisarContratoCobrancaAdministrativa(imovelCobrancaSituacao
															.getCobrancaAcaoAtividadeComando().getId());
							if(cobrancaContrato != null){

								int quantidadeDiasReincidencia = cobrancaContrato.getQuantidadeDiasReincidencia();
								BigDecimal valorBase = BigDecimal.ZERO;
								BigDecimal valorAgua = BigDecimal.ZERO;
								BigDecimal valorEsgoto = BigDecimal.ZERO;

								if(contaHistorico.getValorAgua() != null){

									valorAgua = contaHistorico.getValorAgua();
								}

								if(contaHistorico.getValorEsgoto() != null){

									valorEsgoto = contaHistorico.getValorEsgoto();
								}

								if(quantidadeDiasAtraso > quantidadeDiasReincidencia){

									// Achar base de Cálculo para a Remuneração
									valorBase = valorAgua.add(valorEsgoto).add(valorServicosComuns);

									itemRemuneracao.setValorRemuneracaoReincidente((valorBase.multiply(cobrancaContrato
													.getPercentualRemuneracaoReincidencia())).divide(new BigDecimal("100")));

									itemRemuneracao.setPercentualRemuneracaoReincidente(cobrancaContrato
													.getPercentualRemuneracaoReincidencia());
								}
							}

							// Incluir Remuneração
							itemRemuneracao.setImovelCobrancaSituacao(imovelCobrancaSituacao);
							itemRemuneracao.setDocumentoTipo(new DocumentoTipo(DocumentoTipo.CONTA));

							ContaGeral contaGeral = new ContaGeral();
							contaGeral.setId(idConta);
							itemRemuneracao.setContaGeral(contaGeral);

							itemRemuneracao.setUltimaAlteracao(new Date());

							getControladorUtil().inserir(itemRemuneracao);
						}
					}
				}
			}else if(idGuiaPagamento != null){

				// Caso o Pagamento seja de uma guia
				GuiaPagamento guiaPagamento = (GuiaPagamento) getControladorUtil().pesquisar(idGuiaPagamento, GuiaPagamento.class, false);

				GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) getControladorUtil().pesquisar(idGuiaPagamento,
								GuiaPagamentoHistorico.class, false);

				// O Imóvel deve estar em cobrança Administrativa e em Atividade
				if(guiaPagamento != null){
					if(guiaPagamento.getImovel() != null){
						imovelCobrancaSituacao = repositorioArrecadacao.pesquisarImovelEmCobrancaAdministrativa(guiaPagamento.getImovel()
										.getId());
					}
				}else if(guiaPagamentoHistorico != null){
					if(guiaPagamentoHistorico.getImovel() != null){
						imovelCobrancaSituacao = repositorioArrecadacao.pesquisarImovelEmCobrancaAdministrativa(guiaPagamentoHistorico
										.getImovel().getId());
					}
				}

				if(imovelCobrancaSituacao != null){

					// Obtém o item do documento de cobrança associado a prestação paga da guia
					Collection colecaoCobrancaDocumentoItem = repositorioArrecadacao.pesquisarItensCobrancaDocumentoPorComando(
									imovelCobrancaSituacao.getCobrancaAcaoAtividadeComando().getId(), null, idGuiaPagamento, null,
									pagamentoHistorico.getNumeroPrestacao());

					DebitoTipo debitoTipoEntradaParcelamentoCobrancaAdm = getControladorCobranca().filtrarDebitoTipo(
									DebitoTipo.ENTRADA_PARCELAMENTO_COBRANCA_ADMINISTRATIVA);

					Integer idDebitoTipoEntradaParcelamentoCobrancaAdm = null;
					if(debitoTipoEntradaParcelamentoCobrancaAdm != null){
						idDebitoTipoEntradaParcelamentoCobrancaAdm = debitoTipoEntradaParcelamentoCobrancaAdm.getId();
					}

					// Obtém a guia de pagamento do parcelamento em cobrança administrativa
					Object guiaPagamentoCobranca = null;
					if(guiaPagamento != null){

						guiaPagamentoCobranca = repositorioArrecadacao.pesquisarGuiaPagamentoCobrancaAdministrativa(idGuiaPagamento, null,
										imovelCobrancaSituacao.getDataImplantacaoCobranca(),
										imovelCobrancaSituacao.getDataRetiradaCobranca(), parametroTiposDebitosCobrancaAdministrativa,
										idDebitoTipoEntradaParcelamentoCobrancaAdm);
					}else{

						guiaPagamentoCobranca = repositorioArrecadacao.pesquisarGuiaPagamentoCobrancaAdministrativa(null, idGuiaPagamento,
										imovelCobrancaSituacao.getDataImplantacaoCobranca(),
										imovelCobrancaSituacao.getDataRetiradaCobranca(), parametroTiposDebitosCobrancaAdministrativa,
										idDebitoTipoEntradaParcelamentoCobrancaAdm);
					}

					// Caso exista guia em cobrança administrativa
					if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem) || guiaPagamentoCobranca != null){

						classificouDocumentoCobrancaAdministrativa = true;

						if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){

							Object[] retornoConsulta = Util.retonarObjetoDeColecaoArray(colecaoCobrancaDocumentoItem);
							cobrancaDocumentoItem = (CobrancaDocumentoItem) retornoConsulta[0];
						}

						// Achar Valor da Remuneração
						BigDecimal valorPrestacao = repositorioArrecadacao.pesquisarValorTotalGuiaPagamentoPrestacaoHistorico(
										idGuiaPagamento, pagamentoHistorico.getNumeroPrestacao());

						ImovelCobrancaAdministrivaItem itemRemuneracao = new ImovelCobrancaAdministrivaItem();
						itemRemuneracao.setValorRemuneracao((valorPrestacao.multiply(imovelCobrancaSituacao.getPercentualRemuneracao()))
										.divide(new BigDecimal("100")));
						itemRemuneracao.setPercentualRemuneracao(imovelCobrancaSituacao.getPercentualRemuneracao());

						// Incluir Remuneração
						itemRemuneracao.setImovelCobrancaSituacao(imovelCobrancaSituacao);
						itemRemuneracao.setDocumentoTipo(new DocumentoTipo(DocumentoTipo.GUIA_PAGAMENTO));

						GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
						guiaPagamentoGeral.setId(idGuiaPagamento);
						itemRemuneracao.setGuiaPagamentoGeral(guiaPagamentoGeral);

						itemRemuneracao.setNumeroPrestacao(pagamentoHistorico.getNumeroPrestacao());
						itemRemuneracao.setUltimaAlteracao(new Date());

						getControladorUtil().inserir(itemRemuneracao);
					}
				}
			}

			if(classificouDocumentoCobrancaAdministrativa){

				// Obténs os itens do documento de cobrança associados ao imóvel
				Collection colecaoCobrancaDocumentoItem = repositorioArrecadacao.pesquisarItensCobrancaDocumentoPorComando(
								imovelCobrancaSituacao.getCobrancaAcaoAtividadeComando().getId(), null, null, imovelCobrancaSituacao
												.getImovel().getId(), null);

				boolean alterarParaAdimplente = true;

				/*
				 * Se existir alguma conta não classificada não permite alterar para
				 * adimplente
				 */
				if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){

					for(Iterator iterator = colecaoCobrancaDocumentoItem.iterator(); iterator.hasNext();){
						Object[] item = (Object[]) iterator.next();

						if(item[1] != null && item[1].toString().equals(ConstantesSistema.NAO.toString())){

							alterarParaAdimplente = false;
							break;
						}
					}
				}

				/* Se existir alguma prestação pendente não permite alterar para adimplente */
				if(alterarParaAdimplente){

					if(!Util.isVazioOrNulo(repositorioArrecadacao.pesquisarGuiaPagamentoPrestacaoCobrancaAdministrativa(
									imovelCobrancaSituacao.getImovel().getId(), imovelCobrancaSituacao.getCobrancaAcaoAtividadeComando()
													.getId()))){

						alterarParaAdimplente = false;
					}
				}

				// Verifica permissão alteração de situação para adimplente
				if(alterarParaAdimplente){

					imovelCobrancaSituacao.setDataAdimplencia(new Date());
					imovelCobrancaSituacao.setAnoMesAdimplencia(sistemaParametro.getAnoMesArrecadacao());
					imovelCobrancaSituacao.setUltimaAlteracao(new Date());

					getControladorUtil().atualizar(imovelCobrancaSituacao);
				}

			}
		}
	}

	/**
	 * [UC0238] Manter Aviso Bancário
	 * 
	 * @author Hugo Lima
	 * @date 30/08/2012
	 * @param idAvisoBancario
	 * @return
	 * @throws ControladorException
	 */
	public Hashtable<Short, BigDecimal> obterValorTotalAcertosArrecadacaoAvisoBancario(Integer idAvisoBancario) throws ControladorException{

		Hashtable<Short, BigDecimal> retorno = new Hashtable<Short, BigDecimal>();
		BigDecimal valorTotalAcertosArrecadacao = null;
		BigDecimal valorTotalAcertosDevolucao = null;
		try{

			BigDecimal valorAcertosArrecadacaoCredito = this.repositorioArrecadacao.obterValorTotalAcertosAvisoBancario(idAvisoBancario,
							AvisoBancario.INDICADOR_CREDITO, ConstantesSistema.INDICADOR_AVISO_ACERTO_ARRECADACAO);
			BigDecimal valorAcertosArrecadacaoDebito = this.repositorioArrecadacao.obterValorTotalAcertosAvisoBancario(idAvisoBancario,
							AvisoBancario.INDICADOR_DEBITO, ConstantesSistema.INDICADOR_AVISO_ACERTO_ARRECADACAO);

			valorTotalAcertosArrecadacao = valorAcertosArrecadacaoCredito.subtract(valorAcertosArrecadacaoDebito);

			BigDecimal valorAcertosDevolucaoCredito = this.repositorioArrecadacao.obterValorTotalAcertosAvisoBancario(idAvisoBancario,
							AvisoBancario.INDICADOR_CREDITO, ConstantesSistema.INDICADOR_AVISO_ACERTO_DEVOLUCAO);
			BigDecimal valorAcertosDevolucaoDebito = this.repositorioArrecadacao.obterValorTotalAcertosAvisoBancario(idAvisoBancario,
							AvisoBancario.INDICADOR_DEBITO, ConstantesSistema.INDICADOR_AVISO_ACERTO_DEVOLUCAO);

			valorTotalAcertosDevolucao = valorAcertosDevolucaoCredito.subtract(valorAcertosDevolucaoDebito);

			retorno.put(ConstantesSistema.INDICADOR_AVISO_ACERTO_ARRECADACAO, valorTotalAcertosArrecadacao);
			retorno.put(ConstantesSistema.INDICADOR_AVISO_ACERTO_DEVOLUCAO, valorTotalAcertosDevolucao);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * Pesquiar Parâmetros de Acrescimos
	 * 
	 * @author Hebert Falcão
	 * @date 07/09/2012
	 */
	public ParametroAcrescimosEmissaoDocumento pesquisarParametroAcrescimosEmissaoDocumento(Date dataEmissao) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarParametroAcrescimosEmissaoDocumento(dataEmissao);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Tratar Acrescimos Pagamento Conta
	 * 
	 * @author Hebert Falcão
	 * @date 07/09/2012
	 * @author Saulo Lima
	 * @date 10/12/2013
	 *       Alteração para quando a 'diferença do pagamento' for maior que 'os acréscimos por
	 *       impontualidade'.
	 */
	private Object[] tratarAcrescimosPagamentoConta(Conta conta, Collection<Pagamento> colecaoPagamentos, BigDecimal diferenca)
					throws ControladorException{

		Object[] retorno = new Object[4];

		Date dataPagamentoAux = null;
		Date menorDataPagamento = null;
		Integer idContaGerada = null;
		Short indicadorTratamentoMulta = ConstantesSistema.NAO;

		Pagamento pagamento = null;

		for(Pagamento pagamentoAux : colecaoPagamentos){
			dataPagamentoAux = pagamentoAux.getDataPagamento();

			if(menorDataPagamento == null || dataPagamentoAux.before(menorDataPagamento)){
				menorDataPagamento = dataPagamentoAux;

				pagamento = pagamentoAux;
			}
		}

		FiltroDebitoCobrado filtroDebitoCobrado = new FiltroDebitoCobrado();
		filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.CONTA_ID, conta.getId()));
		filtroDebitoCobrado.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoCobrado.DEBITO_TIPO);

		Collection<DebitoCobrado> debitosCobrados = this.getControladorUtil().pesquisar(filtroDebitoCobrado, DebitoCobrado.class.getName());

		BigDecimal valorDebitosConta = this.getControladorFaturamento().calcularValorTotalMultasCobradasConta(debitosCobrados);

		Date dataEmissaoConta = conta.getDataEmissao();

		CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidadeHelper = this.getControladorCobranca()
						.calcularAcrescimoPorImpontualidadeBancoDeDados(conta.getReferencia(), conta.getDataVencimentoConta(),
										menorDataPagamento, conta.getValorTotalContaBigDecimal(), valorDebitosConta,
										conta.getIndicadorCobrancaMulta(), Integer.toString(pagamento.getAnoMesReferenciaArrecadacao()),
										conta.getId(), dataEmissaoConta, ConstantesSistema.SIM, ConstantesSistema.SIM,
										ConstantesSistema.SIM, ConstantesSistema.SIM);

		dataEmissaoConta = null;

		if(calcularAcrescimoPorImpontualidadeHelper != null){

			BigDecimal valorAcrescimoAux = BigDecimal.ZERO;

			BigDecimal valorJurosMora = calcularAcrescimoPorImpontualidadeHelper.getValorJurosMora();
			if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
				valorAcrescimoAux = valorAcrescimoAux.add(valorJurosMora);
			}

			BigDecimal valorAtualizacaoMonetaria = calcularAcrescimoPorImpontualidadeHelper.getValorAtualizacaoMonetaria();
			if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
				valorAcrescimoAux = valorAcrescimoAux.add(valorAtualizacaoMonetaria);
			}

			BigDecimal valorMulta = calcularAcrescimoPorImpontualidadeHelper.getValorMulta();
			if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
				valorAcrescimoAux = valorAcrescimoAux.add(valorMulta);
			}

			if((valorAcrescimoAux.compareTo(diferenca) == 0) || (valorAcrescimoAux.compareTo(diferenca) > 0)){

				Object[] resultado = this.tratarAcrescimosPagamentoContaValorDiferente(conta, pagamento, diferenca, valorJurosMora,
								valorAtualizacaoMonetaria, valorMulta);

				diferenca = (BigDecimal) resultado[0];
				idContaGerada = (Integer) resultado[1];
				dataEmissaoConta = (Date) resultado[2];

			}else{

				// Quando a 'diferença do pagamento' for maior que 'os acréscimos por
				// impontualidade', chamar novamente a rotina de CalcularAcrescimo passando null em
				// 'dataEmissaoDocumento' e 'indicadorEmissaoDocumento'.
				// Fazer novamente a validação da diferença agora com os 3 débitos (juros,
				// atualização monetária e multa).

				CalcularAcrescimoPorImpontualidadeHelper acrescimosHelper = this.getControladorCobranca()
								.calcularAcrescimoPorImpontualidadeBancoDeDados(conta.getReferencia(), conta.getDataVencimentoConta(),
												menorDataPagamento, conta.getValorTotalContaBigDecimal(), valorDebitosConta,
												conta.getIndicadorCobrancaMulta(),
												Integer.toString(pagamento.getAnoMesReferenciaArrecadacao()), conta.getId(), null, null,
												ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM);

				BigDecimal valorJurosMoraNovo = acrescimosHelper.getValorJurosMora();

				valorAcrescimoAux = BigDecimal.ZERO;
				if(valorJurosMoraNovo.compareTo(BigDecimal.ZERO) > 0){
					valorAcrescimoAux = valorAcrescimoAux.add(valorJurosMoraNovo);
				}

				BigDecimal valorAtualizacaoMonetariaNovo = acrescimosHelper.getValorAtualizacaoMonetaria();
				if(valorAtualizacaoMonetariaNovo.compareTo(BigDecimal.ZERO) > 0){
					valorAcrescimoAux = valorAcrescimoAux.add(valorAtualizacaoMonetariaNovo);
				}

				BigDecimal valorMultaNovo = acrescimosHelper.getValorMulta();
				if(valorMultaNovo.compareTo(BigDecimal.ZERO) > 0){
					valorAcrescimoAux = valorAcrescimoAux.add(valorMultaNovo);
				}

				if((valorAcrescimoAux.compareTo(diferenca) == 0) || (valorAcrescimoAux.compareTo(diferenca) > 0)){
					Object[] resultado = this.tratarAcrescimosPagamentoContaValorDiferente(conta, pagamento, diferenca, valorJurosMoraNovo,
									valorAtualizacaoMonetariaNovo, valorMultaNovo);

					diferenca = (BigDecimal) resultado[0];
					idContaGerada = (Integer) resultado[1];
					dataEmissaoConta = (Date) resultado[2];
					indicadorTratamentoMulta = ConstantesSistema.SIM;
				 }
			}
		}

		retorno[0] = diferenca;
		retorno[1] = idContaGerada;
		retorno[2] = dataEmissaoConta;
		retorno[3] = indicadorTratamentoMulta;

		return retorno;
	}

	/**
	 * Tratar Acrescimos Pagamento Conta
	 * 
	 * @author Saulo Lima
	 * @date 10/12/2013
	 */
	private Object[] tratarAcrescimosPagamentoContaValorDiferente(Conta conta, Pagamento pagamento, BigDecimal diferenca,
					BigDecimal valorJurosMora, BigDecimal valorAtualizacaoMonetaria, BigDecimal valorMulta) throws ControladorException{

		Object[] retorno = new Object[3];

		Integer idDebitoTipo = null;
		FiltroDebitoTipo filtroDebitoTipo = null;
		Collection<DebitoTipo> colecaoDebitoTipo = null;
		DebitoTipo debitoTipo = null;

		BigDecimal valorAcrescimoAux = valorJurosMora.add(valorAtualizacaoMonetaria).add(valorMulta);

		Map<Integer, Object[]> mapDebitos = new HashMap<Integer, Object[]>();

		Integer idContaGerada = null;
		Date dataEmissaoConta = null;

		if(valorAcrescimoAux.compareTo(diferenca) == 0){
			if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
				idDebitoTipo = DebitoTipo.JUROS_MORA;

				filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));
				filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

				colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
					debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

					mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorJurosMora});

					diferenca = diferenca.subtract(valorJurosMora);
				}
			}

			if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
				idDebitoTipo = DebitoTipo.ATUALIZACAO_MONETARIA;

				filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));
				filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

				colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
					debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

					mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorAtualizacaoMonetaria});

					diferenca = diferenca.subtract(valorAtualizacaoMonetaria);
				}
			}

			if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
				idDebitoTipo = DebitoTipo.MULTA_IMPONTUALIDADE;

				filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));
				filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

				colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
					debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

					mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorMulta});

					diferenca = diferenca.subtract(valorMulta);
				}
			}

			idContaGerada = this.retificarContaMovimentoArrecadadores(conta.getId(), mapDebitos, pagamento.getDataPagamento());

			dataEmissaoConta = conta.getDataEmissao();
		}else if(valorAcrescimoAux.compareTo(diferenca) > 0){
			// Lança a diferença em partes proporcionais a cada um dos acréscimos calculados

			Imovel imovel = this.getControladorImovel().pesquisarImovel(pagamento.getImovel().getId());

			Collection<Categoria> colecaoCategoria = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

			BigDecimal valorJurosMoraAux = BigDecimal.ZERO;
			BigDecimal valorAtualizacaoMonetariaAux = BigDecimal.ZERO;
			BigDecimal valorMultaAux = BigDecimal.ZERO;

			if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
				idDebitoTipo = DebitoTipo.JUROS_MORA;

				filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));
				filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

				colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
					debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

					valorJurosMoraAux = valorJurosMora.divide(valorAcrescimoAux, 4, BigDecimal.ROUND_DOWN);
					valorJurosMoraAux = valorJurosMoraAux.multiply(diferenca);
					valorJurosMoraAux = valorJurosMoraAux.setScale(2, BigDecimal.ROUND_DOWN);

					mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorJurosMoraAux});

					BigDecimal valorJurosMoraRestante = valorJurosMora.subtract(valorJurosMoraAux);

					if(valorJurosMoraRestante.compareTo(BigDecimal.ZERO) > 0){
						this.getControladorCobranca().inserirDebitoACobrarDebitoTipo(debitoTipo, imovel, new Short("1"),
										valorJurosMoraRestante, BigDecimal.ZERO, null, colecaoCategoria, null,
										DebitoCreditoSituacao.NORMAL, false, null, null, null, conta.getReferencia());
					}
				}
			}

			if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
				idDebitoTipo = DebitoTipo.ATUALIZACAO_MONETARIA;

				filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));
				filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

				colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
					debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

					if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0 && valorMulta.compareTo(BigDecimal.ZERO) == 0){
						valorAtualizacaoMonetariaAux = diferenca.subtract(valorJurosMoraAux);
					}else{
						valorAtualizacaoMonetariaAux = valorAtualizacaoMonetaria.divide(valorAcrescimoAux, 4, BigDecimal.ROUND_DOWN);
						valorAtualizacaoMonetariaAux = valorAtualizacaoMonetariaAux.multiply(diferenca);
						valorAtualizacaoMonetariaAux = valorAtualizacaoMonetariaAux.setScale(2, BigDecimal.ROUND_DOWN);
					}

					mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorAtualizacaoMonetariaAux});

					BigDecimal valorAtualizacaoMonetariaRestante = valorAtualizacaoMonetaria.subtract(valorAtualizacaoMonetariaAux);

					if(valorAtualizacaoMonetariaRestante.compareTo(BigDecimal.ZERO) > 0){
						this.getControladorCobranca().inserirDebitoACobrarDebitoTipo(debitoTipo, imovel, new Short("1"),
										valorAtualizacaoMonetariaRestante, BigDecimal.ZERO, null, colecaoCategoria, null,
										DebitoCreditoSituacao.NORMAL, false, null, null, null, conta.getReferencia());
					}
				}
			}

			if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
				idDebitoTipo = DebitoTipo.MULTA_IMPONTUALIDADE;

				filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));
				filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

				colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
					debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

					if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0 || valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
						valorMultaAux = diferenca.subtract(valorJurosMoraAux).subtract(valorAtualizacaoMonetariaAux);
					}else{
						valorMultaAux = valorMulta.divide(valorAcrescimoAux, 4, BigDecimal.ROUND_DOWN);
						valorMultaAux = valorMultaAux.multiply(diferenca);
						valorMultaAux = valorMultaAux.setScale(2, BigDecimal.ROUND_DOWN);
					}

					mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorMultaAux});

					BigDecimal valorMultaRestante = valorMulta.subtract(valorMultaAux);

					if(valorMultaRestante.compareTo(BigDecimal.ZERO) > 0){
						this.getControladorCobranca().inserirDebitoACobrarDebitoTipo(debitoTipo, imovel, new Short("1"),
										valorMultaRestante, BigDecimal.ZERO, null, colecaoCategoria, null, DebitoCreditoSituacao.NORMAL,
										false, null, null, null, conta.getReferencia());
					}
				}
			}

			diferenca = diferenca.subtract(valorJurosMoraAux).subtract(valorAtualizacaoMonetariaAux).subtract(valorMultaAux);

			idContaGerada = this.retificarContaMovimentoArrecadadores(conta.getId(), mapDebitos, pagamento.getDataPagamento());

			dataEmissaoConta = conta.getDataEmissao();
		}

		retorno[0] = diferenca;
		retorno[1] = idContaGerada;
		retorno[2] = dataEmissaoConta;

		return retorno;
	}

	/**
	 * Retificar Conta do Movimento Arrecadador
	 * 
	 * @author Hebert Falcão
	 * @date 08/09/2012
	 */
	private Integer retificarContaMovimentoArrecadadores(Integer idConta, Map<Integer, Object[]> mapDebitos, Date dataPagamento)
					throws ControladorException{

		Integer idContaGerada = null;

		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

		Map<String, String[]> requestMap = null;

		Collection<MedicaoHistorico> colecaoMedicaoHistorico = null;

		Usuario usuarioLogado = Usuario.USUARIO_BATCH;

		Conta contaAtual = this.getControladorFaturamento().pesquisarContaRetificacao(idConta);

		Date dataVencimento = contaAtual.getDataVencimentoConta();

		int anoMesReferencia = contaAtual.getReferencia();

		Imovel imovel = contaAtual.getImovel();

		Collection colecaoDebitoCobrado = this.getControladorFaturamento().obterDebitosCobradosConta(contaAtual);

		// Débito cobrado dos acrescimos
		Object[] debitoArray = null;

		DebitoTipo debitoTipo = null;

		BigDecimal valorDebito = null;

		DebitoCobrado debitoCobrado = null;

		for(Integer idDebitoTipo : mapDebitos.keySet()){
			debitoArray = mapDebitos.get(idDebitoTipo);

			debitoTipo = (DebitoTipo) debitoArray[0];

			valorDebito = (BigDecimal) debitoArray[1];

			debitoCobrado = new DebitoCobrado();
			debitoCobrado.setUltimaAlteracao(new Date());
			debitoCobrado.setAnoMesReferenciaDebito(anoMesReferencia);
			debitoCobrado.setAnoMesCobrancaDebito(sistemaParametro.getAnoMesArrecadacao());
			debitoCobrado.setValorPrestacao(valorDebito);
			debitoCobrado.setDebitoTipo(debitoTipo);
			debitoCobrado.setNumeroPrestacao(new Short("1").shortValue());
			debitoCobrado.setNumeroPrestacaoDebito(new Short("1").shortValue());

			colecaoDebitoCobrado.add(debitoCobrado);
		}

		Collection colecaoCreditoRealizado = this.getControladorFaturamento().obterCreditosRealizadosConta(contaAtual);

		LigacaoAguaSituacao ligacaoAguaSituacao = imovel.getLigacaoAguaSituacao();

		LigacaoEsgotoSituacao ligacaoEsgotoSituacao = imovel.getLigacaoEsgotoSituacao();

		Collection colecaoCategoria = this.getControladorImovel().obterQuantidadeEconomiasContaCategoria(contaAtual);

		String consumoAguaStr = null;

		Integer consumoAgua = contaAtual.getConsumoAgua();

		if(consumoAgua != null){
			consumoAguaStr = Integer.toString(consumoAgua);
		}

		String consumoEsgotoStr = null;

		Integer consumoEsgoto = contaAtual.getConsumoEsgoto();

		if(consumoEsgoto != null){
			consumoEsgotoStr = Integer.toString(consumoEsgoto);
		}

		String percentualEsgotoStr = null;

		BigDecimal percentualEsgoto = contaAtual.getPercentualEsgoto();

		if(percentualEsgoto != null){
			percentualEsgotoStr = Util.formatarMoedaReal(percentualEsgoto);
		}

		ContaMotivoRetificacao contaMotivoRetificacao = null;

		String idMotivoRetificacaoStr = (String) ParametroArrecadacao.P_CONTA_MOTIVO_RETIFICACAO_ACRESCIMOS_PAGAMENTO.executar(this);

		if(!Util.isVazioOuBranco(idMotivoRetificacaoStr)){
			Integer idMotivoRetificacao = Integer.valueOf(idMotivoRetificacaoStr);

			contaMotivoRetificacao = new ContaMotivoRetificacao();
			contaMotivoRetificacao.setId(idMotivoRetificacao);
		}

		ConsumoTarifa consumoTarifa = contaAtual.getConsumoTarifa();

		Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta = null;

		// Retificar conta
		idContaGerada = this.getControladorFaturamento().retificarConta(anoMesReferencia, contaAtual, imovel, colecaoDebitoCobrado,
						colecaoCreditoRealizado, ligacaoAguaSituacao, ligacaoEsgotoSituacao, colecaoCategoria, consumoAguaStr,
						consumoEsgotoStr, percentualEsgotoStr, dataVencimento, calcularValoresConta, contaMotivoRetificacao, requestMap,
						usuarioLogado, colecaoMedicaoHistorico, consumoTarifa, false, null);

		return idContaGerada;
	}

	/**
	 * Tratar Acrescimos Pagamento Guia
	 * 
	 * @author Hebert Falcão
	 * @date 09/09/2012
	 */
	private Object[] tratarAcrescimosPagamentoGuia(GuiaPagamento guiaPagamento,
					Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao, Collection<Pagamento> colecaoPagamentos,
					BigDecimal diferenca, BigDecimal valorDocumento) throws ControladorException{

		Object[] retorno = new Object[2];

		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

		Date dataPagamentoAux = null;

		Date menorDataPagamento = null;

		Pagamento pagamento = null;

		for(Pagamento pagamentoAux : colecaoPagamentos){
			dataPagamentoAux = pagamentoAux.getDataPagamento();

			if(menorDataPagamento == null || dataPagamentoAux.before(menorDataPagamento)){
				menorDataPagamento = dataPagamentoAux;

				pagamento = pagamentoAux;
			}
		}

		GuiaPagamentoPrestacao guiaPagamentoPrestacaoAux = (GuiaPagamentoPrestacao) Util
						.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);

		GuiaPagamentoPrestacaoPK guiaPagamentoPrestacaoPK = guiaPagamentoPrestacaoAux.getComp_id();

		Integer idGuiaPagamento = guiaPagamentoPrestacaoPK.getGuiaPagamentoId();
		Short numeroPrestacao = guiaPagamentoPrestacaoPK.getNumeroPrestacao();

		Date dataEmissaoGuia = guiaPagamentoPrestacaoAux.getDataEmissao();

		Integer anoMesReferenciaDebito = guiaPagamentoPrestacaoAux.getAnoMesReferenciaFaturamento();

		CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidadeHelper = this.getControladorCobranca()
						.calcularAcrescimoPorImpontualidadeBancoDeDados(guiaPagamentoPrestacaoAux.getAnoMesReferenciaFaturamento(),
										guiaPagamentoPrestacaoAux.getDataVencimento(), menorDataPagamento, valorDocumento, BigDecimal.ZERO,
										guiaPagamentoPrestacaoAux.getIndicadorCobrancaMulta().shortValue(),
										Integer.toString(pagamento.getAnoMesReferenciaArrecadacao()), null, dataEmissaoGuia,
										ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM);

		dataEmissaoGuia = null;

		if(calcularAcrescimoPorImpontualidadeHelper != null){
			Imovel imovel = this.getControladorImovel().pesquisarImovel(pagamento.getImovel().getId());

			Integer idDebitoTipo = null;

			FiltroDebitoTipo filtroDebitoTipo = null;

			Collection<DebitoTipo> colecaoDebitoTipo = null;

			DebitoTipo debitoTipo = null;

			Map<Integer, Object[]> mapDebitos = new HashMap<Integer, Object[]>();

			BigDecimal valorAcrescimoAux = BigDecimal.ZERO;

			BigDecimal valorJurosMora = calcularAcrescimoPorImpontualidadeHelper.getValorJurosMora();

			if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
				valorAcrescimoAux = valorAcrescimoAux.add(valorJurosMora);
			}

			BigDecimal valorAtualizacaoMonetaria = calcularAcrescimoPorImpontualidadeHelper.getValorAtualizacaoMonetaria();

			if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
				valorAcrescimoAux = valorAcrescimoAux.add(valorAtualizacaoMonetaria);
			}

			BigDecimal valorMulta = calcularAcrescimoPorImpontualidadeHelper.getValorMulta();

			if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
				valorAcrescimoAux = valorAcrescimoAux.add(valorMulta);
			}

			if(valorAcrescimoAux.compareTo(diferenca) == 0){
				if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
					idDebitoTipo = DebitoTipo.JUROS_MORA;

					filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
									ConstantesSistema.INDICADOR_USO_ATIVO));
					filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

					colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

					if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
						debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

						mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorJurosMora});

						diferenca = diferenca.subtract(valorJurosMora);
					}
				}

				if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
					idDebitoTipo = DebitoTipo.ATUALIZACAO_MONETARIA;

					filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
									ConstantesSistema.INDICADOR_USO_ATIVO));
					filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

					colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

					if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
						debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

						mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorAtualizacaoMonetaria});

						diferenca = diferenca.subtract(valorAtualizacaoMonetaria);
					}
				}

				if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
					idDebitoTipo = DebitoTipo.MULTA_IMPONTUALIDADE;

					filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
									ConstantesSistema.INDICADOR_USO_ATIVO));
					filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

					colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

					if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
						debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

						mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorMulta});

						diferenca = diferenca.subtract(valorMulta);
					}
				}
			}else if(valorAcrescimoAux.compareTo(diferenca) > 0){
				// Lança a diferença em partes proporcionais a cada um dos acréscimos calculados

				Collection<Categoria> colecaoCategoria = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

				BigDecimal valorJurosMoraAux = BigDecimal.ZERO;
				BigDecimal valorAtualizacaoMonetariaAux = BigDecimal.ZERO;
				BigDecimal valorMultaAux = BigDecimal.ZERO;

				if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
					idDebitoTipo = DebitoTipo.JUROS_MORA;

					filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
									ConstantesSistema.INDICADOR_USO_ATIVO));
					filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

					colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

					if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
						debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

						valorJurosMoraAux = valorJurosMora.divide(valorAcrescimoAux, 4, BigDecimal.ROUND_DOWN);
						valorJurosMoraAux = valorJurosMoraAux.multiply(diferenca);
						valorJurosMoraAux = valorJurosMoraAux.setScale(2, BigDecimal.ROUND_DOWN);

						mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorJurosMoraAux});

						BigDecimal valorJurosMoraRestante = valorJurosMora.subtract(valorJurosMoraAux);

						if(valorJurosMoraRestante.compareTo(BigDecimal.ZERO) > 0){
							this.getControladorCobranca().inserirDebitoACobrarDebitoTipo(debitoTipo, imovel, new Short("1"),
											valorJurosMoraRestante, BigDecimal.ZERO, null, colecaoCategoria, null,
											DebitoCreditoSituacao.NORMAL, false, null, null, null, anoMesReferenciaDebito);
						}
					}
				}

				if(valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
					idDebitoTipo = DebitoTipo.ATUALIZACAO_MONETARIA;

					filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
									ConstantesSistema.INDICADOR_USO_ATIVO));
					filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

					colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

					if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
						debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

						if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0 && valorMulta.compareTo(BigDecimal.ZERO) == 0){
							valorAtualizacaoMonetariaAux = diferenca.subtract(valorJurosMoraAux);
						}else{
							valorAtualizacaoMonetariaAux = valorAtualizacaoMonetaria.divide(valorAcrescimoAux, 4, BigDecimal.ROUND_DOWN);
							valorAtualizacaoMonetariaAux = valorAtualizacaoMonetariaAux.multiply(diferenca);
							valorAtualizacaoMonetariaAux = valorAtualizacaoMonetariaAux.setScale(2, BigDecimal.ROUND_DOWN);
						}

						mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorAtualizacaoMonetariaAux});

						BigDecimal valorAtualizacaoMonetariaRestante = valorAtualizacaoMonetaria.subtract(valorAtualizacaoMonetariaAux);

						if(valorAtualizacaoMonetariaRestante.compareTo(BigDecimal.ZERO) > 0){
							this.getControladorCobranca().inserirDebitoACobrarDebitoTipo(debitoTipo, imovel, new Short("1"),
											valorAtualizacaoMonetariaRestante, BigDecimal.ZERO, null, colecaoCategoria, null,
											DebitoCreditoSituacao.NORMAL, false, null, null, null, anoMesReferenciaDebito);
						}
					}
				}

				if(valorMulta.compareTo(BigDecimal.ZERO) > 0){
					idDebitoTipo = DebitoTipo.MULTA_IMPONTUALIDADE;

					filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
									ConstantesSistema.INDICADOR_USO_ATIVO));
					filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoTipo.LANCAMENTO_ITEM_CONTABIL);

					colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

					if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
						debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);

						if(valorJurosMora.compareTo(BigDecimal.ZERO) > 0 || valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
							valorMultaAux = diferenca.subtract(valorJurosMoraAux).subtract(valorAtualizacaoMonetariaAux);
						}else{
							valorMultaAux = valorMulta.divide(valorAcrescimoAux, 4, BigDecimal.ROUND_DOWN);
							valorMultaAux = valorMultaAux.multiply(diferenca);
							valorMultaAux = valorMultaAux.setScale(2, BigDecimal.ROUND_DOWN);
						}

						mapDebitos.put(idDebitoTipo, new Object[] {debitoTipo, valorMultaAux});

						BigDecimal valorMultaRestante = valorMulta.subtract(valorMultaAux);

						if(valorMultaRestante.compareTo(BigDecimal.ZERO) > 0){
							this.getControladorCobranca().inserirDebitoACobrarDebitoTipo(debitoTipo, imovel, new Short("1"),
											valorMultaRestante, BigDecimal.ZERO, null, colecaoCategoria, null,
											DebitoCreditoSituacao.NORMAL, false, null, null, null, anoMesReferenciaDebito);
						}
					}
				}

				diferenca = diferenca.subtract(valorJurosMoraAux).subtract(valorAtualizacaoMonetariaAux).subtract(valorMultaAux);
			}

			if(mapDebitos != null && !mapDebitos.isEmpty()){
				dataEmissaoGuia = guiaPagamentoPrestacaoAux.getDataEmissao();

				Object[] debitoArrayAux = null;

				DebitoTipo debitoTipoAux = null;

				BigDecimal valorDebitoAux = null;

				FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
				filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));
				filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.LOCALIDADE);
				filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.SETOR_COMERCIAL);

				Collection<GuiaPagamento> colecaoGuiaPagamento = this.getControladorUtil().pesquisar(filtroGuiaPagamento,
								GuiaPagamento.class.getName());

				GuiaPagamento guiaPagamentoAux = null;

				if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){

					guiaPagamentoAux = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);

					Set<GuiaPagamentoPrestacao> setGuiaPagamentoPrestacao = new HashSet<GuiaPagamentoPrestacao>();

					// Incluir Acrescimos na Guia
					for(Integer idDebitoTipoAux : mapDebitos.keySet()){
						debitoArrayAux = mapDebitos.get(idDebitoTipoAux);

						debitoTipoAux = (DebitoTipo) debitoArrayAux[0];

						valorDebitoAux = (BigDecimal) debitoArrayAux[1];

						setGuiaPagamentoPrestacao.add(this.acrescentarAcrescimosPorImpontualidadeNaGuia(idGuiaPagamento, numeroPrestacao,
										valorDebitoAux, debitoTipoAux,
										menorDataPagamento, sistemaParametro, guiaPagamentoPrestacaoAux.getIndicadorPagamentoPendente(),
										guiaPagamentoPrestacaoAux.getIndicadorCobrancaMulta(), guiaPagamentoPrestacaoAux.getDataEmissao(),
										guiaPagamentoPrestacaoAux.getDataVencimento()));
					}

					guiaPagamentoAux.setGuiasPagamentoPrestacao(setGuiaPagamentoPrestacao);

					// Distribuir Valores Guia por Categoria
					Collection<GuiaPagamentoCategoria> colecaoGuiaCategoriaAcrescimos = this.distribuirValoresGuiaPorCategoria(
									idGuiaPagamento,
									numeroPrestacao, imovel, setGuiaPagamentoPrestacao);

					// Lançamento Incluir Guia
					this.getControladorContabil().registrarLancamentoContabil(guiaPagamentoAux, OperacaoContabil.INCLUIR_GUIA_PAGAMENTO,
									colecaoGuiaCategoriaAcrescimos);
				}
			}
		}

		retorno[0] = diferenca;
		retorno[1] = dataEmissaoGuia;

		return retorno;
	}

	/**
	 * Retornar o somatório dos valores pagos da conta
	 * 
	 * @author Hebert Falcão
	 * @date 16/10/2012
	 */
	public BigDecimal retornarSomatorioPagamentoDaConta(Integer idConta) throws ControladorException{

		BigDecimal valorTotal = null;

		try{
			BigDecimal valorPagamento = this.repositorioArrecadacao.retornarSomatorioPagamentoDaConta(idConta);

			if(valorPagamento != null){
				if(valorTotal == null){
					valorTotal = BigDecimal.ZERO;
				}

				valorTotal = valorTotal.add(valorPagamento);
			}

			BigDecimal valorPagamentoPagamentoHistorico = this.repositorioArrecadacao.retornarSomatorioPagamentoHistoricoDaConta(idConta);

			if(valorPagamentoPagamentoHistorico != null){
				if(valorTotal == null){
					valorTotal = BigDecimal.ZERO;
				}

				valorTotal = valorTotal.add(valorPagamentoPagamentoHistorico);
			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return valorTotal;
	}

	/**
	 * [UC0247] Consultar Pagamentos
	 * Retornar Valor de Remuneração da Conta Histórico
	 * 
	 * @author Hebert Falcão
	 * @date 11/10/2012
	 */
	public BigDecimal retornarValorRemuneracaoContaHistorico(Integer idConta, Integer referencia) throws ControladorException{

		try{
			return this.repositorioArrecadacao.retornarValorRemuneracaoContaHistorico(idConta, referencia);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0247] Consultar Pagamentos
	 * Retornar Valor de Remuneração da Conta
	 * 
	 * @author Hebert Falcão
	 * @date 11/10/2012
	 */
	public BigDecimal retornarValorRemuneracaoConta(Integer idConta, Integer referencia) throws ControladorException{

		try{
			return this.repositorioArrecadacao.retornarValorRemuneracaoConta(idConta, referencia);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Retornar o somatório dos valores pagos da guia
	 * 
	 * @author Hebert Falcão
	 * @date 16/10/2012
	 */
	public BigDecimal retornarSomatorioPagamentoDaGuia(Integer idGuiaPagamento, Integer numeroPrestacao) throws ControladorException{

		BigDecimal valorTotal = null;

		try{
			BigDecimal valorPagamento = this.repositorioArrecadacao.retornarSomatorioPagamentoDaGuia(idGuiaPagamento, numeroPrestacao);

			if(valorPagamento != null){
				if(valorTotal == null){
					valorTotal = BigDecimal.ZERO;
				}

				valorTotal = valorTotal.add(valorPagamento);
			}

			BigDecimal valorPagamentoPagamentoHistorico = this.repositorioArrecadacao.retornarSomatorioPagamentoHistoricoDaGuia(
							idGuiaPagamento, numeroPrestacao);

			if(valorPagamentoPagamentoHistorico != null){
				if(valorTotal == null){
					valorTotal = BigDecimal.ZERO;
				}

				valorTotal = valorTotal.add(valorPagamentoPagamentoHistorico);
			}

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return valorTotal;
	}

	/**
	 * Método pesquisarIdsLocalidadeComPagamentosOuPagamentosHistoricos
	 * <p>
	 * Esse método implementa pesquisa dos Ids das Localidade Com {@link Pagamento} Ou
	 * {@link PagamentoHistorico}
	 * </p>
	 * RASTREIO: [OC920431][UC0301]
	 * 
	 * @return Lista de {@link Integer}.
	 * @author Marlos Ribeiro
	 * @param referenciaArrecadacao
	 * @since 14/11/2012
	 */
	public Collection<Integer> pesquisarIdsLocalidadeComPagamentosOuPagamentosHistoricos(Integer referenciaArrecadacao)
					throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarIdsLocalidadeComPagamentosOuPagamentosHistoricos(referenciaArrecadacao);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0259] – Processar Pagamento com Código de Barras
	 * [SB0024] – Verificar Guia de Pagamento de Boleto Bancário
	 * 
	 * @author Hebert Falcão
	 * @date 25/11/2012
	 */
	private void verificarGuiaPagamentoBoletoBancario(Integer idGuiaPagamento, Integer numeroPrestacao) throws ControladorException{

		if(idGuiaPagamento != null && numeroPrestacao != null){

			// Consulta realizada diferente do caso de uso para evitar dois acessos consecutivos a
			// mesma tabela (boleto_bancario). Essa consulta só deve retornar um registro, mas não
			// será feito restrição caso venha mais de um (seria uma inconsistência)

			Collection<BoletoBancario> colecaoBoletoBancario = this.getControladorCobranca()
							.pesquisarBoletoBaixadoEProtestadoPelaGuiaDePagamento(idGuiaPagamento, numeroPrestacao);

			if(!Util.isVazioOrNulo(colecaoBoletoBancario)){
				Collection<Object> colecaoBoletoBancarioAtualizar = new ArrayList<Object>();

				Collection<Object> colecaoBoletoBancarioSituacaoHistoricoIncluir = new ArrayList<Object>();

				BoletoBancarioSituacao boletoBancarioSituacaoLiguidacaoViaEmpresa = new BoletoBancarioSituacao();
				boletoBancarioSituacaoLiguidacaoViaEmpresa.setId(BoletoBancarioSituacao.LIQUIDACAO_VIA_EMPRESA);

				BoletoBancarioSituacaoHistorico boletoBancarioSituacaoHistorico = null;

				for(BoletoBancario boletoBancario : colecaoBoletoBancario){
					boletoBancario.setBoletoBancarioSituacao(boletoBancarioSituacaoLiguidacaoViaEmpresa);
					boletoBancario.setUltimaAlteracao(new Date());

					colecaoBoletoBancarioAtualizar.add(boletoBancario);

					boletoBancarioSituacaoHistorico = new BoletoBancarioSituacaoHistorico();
					boletoBancarioSituacaoHistorico.setBoletoBancario(boletoBancario);
					boletoBancarioSituacaoHistorico.setBoletoBancarioSituacao(boletoBancarioSituacaoLiguidacaoViaEmpresa);
					boletoBancarioSituacaoHistorico.setDataEntrada(new Date());
					boletoBancarioSituacaoHistorico.setUltimaAlteracao(new Date());

					colecaoBoletoBancarioSituacaoHistoricoIncluir.add(boletoBancarioSituacaoHistorico);
				}

				if(!Util.isVazioOrNulo(colecaoBoletoBancarioAtualizar)){
					this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoBoletoBancarioAtualizar);
				}

				if(!Util.isVazioOrNulo(colecaoBoletoBancarioSituacaoHistoricoIncluir)){
					this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoBoletoBancarioSituacaoHistoricoIncluir);
				}
			}
		}
	}

	/**
	 * [UC0259] – Processar Pagamento com Código de Barras
	 * [SB0003] – Processar Pagamento de Documento de Cobrança
	 * Tratar Boletos Bancários das Contas em Cobrança Bancária
	 * 
	 * @author Hebert Falcão
	 * @date 26/11/2012
	 */
	private void tratarBoletosBancariosDasContasEmCobrancaBancaria(Integer idCobrancaDocumento, Date dataEmissaoDocumento)
					throws ControladorException{

		FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItem = new FiltroCobrancaDocumentoItem();
		filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ID,
						idCobrancaDocumento));
		filtroCobrancaDocumentoItem.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.CONTA_GERAL);
		filtroCobrancaDocumentoItem.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.CONTA_GERAL_CONTA);

		Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItem = this.getControladorUtil().pesquisar(filtroCobrancaDocumentoItem,
						CobrancaDocumentoItem.class.getName());

		String motivoRevisaoCobrancaBancariaStr = (String) ParametroCobranca.P_MOTIVO_REVISAO_COBRANCA_BANCARIA.executar(this);

		Integer motivoRevisaoCobrancaBancaria = null;

		if(!Util.isVazioOuBranco(motivoRevisaoCobrancaBancariaStr)){
			motivoRevisaoCobrancaBancaria = Util.obterInteger(motivoRevisaoCobrancaBancariaStr);
		}

		if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem) && motivoRevisaoCobrancaBancaria != null){
			Collection<Integer> colecaoIdsConta = new ArrayList<Integer>();

			Integer idConta = null;

			for(CobrancaDocumentoItem cobrancaDocumentoItem : colecaoCobrancaDocumentoItem){
				ContaGeral contaGeral = cobrancaDocumentoItem.getContaGeral();

				if(contaGeral != null){
					Conta conta = contaGeral.getConta();

					if(conta != null){
						idConta = conta.getId();

						ContaMotivoRevisao contaMotivoRevisao = conta.getContaMotivoRevisao();

						if(contaMotivoRevisao != null){
							Integer idContaMotivoRevisao = contaMotivoRevisao.getId();

							if(idContaMotivoRevisao.intValue() == motivoRevisaoCobrancaBancaria.intValue()){
								colecaoIdsConta.add(idConta);
							}
						}
					}
				}
			}

			if(!Util.isVazioOrNulo(colecaoIdsConta)){
				Collection<Integer> idsBoletoBancarioAux = this.getControladorCobranca().obterBoletosBancariosDasContasEmCobrancaBancaria(
								colecaoIdsConta, idCobrancaDocumento, dataEmissaoDocumento);

				if(!Util.isVazioOrNulo(idsBoletoBancarioAux)){
					Collection<Integer> idsBoletoBancario = new ArrayList();

					for(Integer idBoletoBancario : idsBoletoBancarioAux){
						if(!idsBoletoBancario.contains(idBoletoBancario)){
							idsBoletoBancario.add(idBoletoBancario);
						}
					}

					Collection<BoletoBancario> colecaoBoletoBancario = this.getControladorCobranca()
									.pesquisarBoletoBaixadoEProtestadoPeloId(idsBoletoBancario);

					if(!Util.isVazioOrNulo(colecaoBoletoBancario)){
						Collection<Object> colecaoBoletoBancarioAtualizar = new ArrayList<Object>();

						Collection<Object> colecaoBoletoBancarioSituacaoHistoricoIncluir = new ArrayList<Object>();

						BoletoBancarioSituacao boletoBancarioSituacaoLiguidacaoViaEmpresa = new BoletoBancarioSituacao();
						boletoBancarioSituacaoLiguidacaoViaEmpresa.setId(BoletoBancarioSituacao.LIQUIDACAO_VIA_EMPRESA);

						BoletoBancarioSituacaoHistorico boletoBancarioSituacaoHistorico = null;

						for(BoletoBancario boletoBancario : colecaoBoletoBancario){
							boletoBancario.setBoletoBancarioSituacao(boletoBancarioSituacaoLiguidacaoViaEmpresa);
							boletoBancario.setUltimaAlteracao(new Date());

							colecaoBoletoBancarioAtualizar.add(boletoBancario);

							boletoBancarioSituacaoHistorico = new BoletoBancarioSituacaoHistorico();
							boletoBancarioSituacaoHistorico.setBoletoBancario(boletoBancario);
							boletoBancarioSituacaoHistorico.setBoletoBancarioSituacao(boletoBancarioSituacaoLiguidacaoViaEmpresa);
							boletoBancarioSituacaoHistorico.setDataEntrada(new Date());
							boletoBancarioSituacaoHistorico.setUltimaAlteracao(new Date());

							colecaoBoletoBancarioSituacaoHistoricoIncluir.add(boletoBancarioSituacaoHistorico);
						}

						if(!Util.isVazioOrNulo(colecaoBoletoBancarioAtualizar)){
							this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoBoletoBancarioAtualizar);
						}

						if(!Util.isVazioOrNulo(colecaoBoletoBancarioSituacaoHistoricoIncluir)){
							this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoBoletoBancarioSituacaoHistoricoIncluir);
						}
					}
				}
			}
		}
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0019] Verifica Associação do Pagamento com Itens de Documento de Cobrança
	 * 
	 * @author Hebert Falcão
	 * @date 11/12/2012
	 */
	private void verificarAssociacaoDoPagamentoComItensDeDocumentoDeCobranca(Pagamento pagamento) throws ControladorException{

		if(pagamento != null){
			// Situação 1: Pagamento referente a conta
			Conta conta = pagamento.getConta();

			if(conta != null){
				Integer idConta = conta.getId();

				// Verifica se há relação entre a conta com pagamento excluído e algum item de
				// documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
				this.getControladorCobranca().atualizarItemDocumentoCobranca(idConta, null, null, null, CobrancaDebitoSituacao.PENDENTE,
								new Date(), CobrancaDebitoSituacao.PAGO);
			}

			// Situação 2: Pagamento referente a prestação de guia de pagamento
			GuiaPagamentoGeral guiaPagamentoGeral = pagamento.getGuiaPagamentoGeral();

			if(guiaPagamentoGeral != null){
				Integer idGuiaPagamento = guiaPagamentoGeral.getId();
				Integer numeroPrestacao = pagamento.getNumeroPrestacao();

				if(numeroPrestacao != null){
					// Verifica se há relação entre a prestação de guia de pagamento com pagamento
					// excluído e algum item de documento de cobrança - [UC3082] Atualizar Item
					// Documento Cobrança
					this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamento, numeroPrestacao.shortValue(), null,
									CobrancaDebitoSituacao.PENDENTE, new Date(), CobrancaDebitoSituacao.PAGO);
				}
			}

			// Situação 3: Pagamento referente a débito a cobrar
			DebitoACobrar debitoACobrar = pagamento.getDebitoACobrar();

			if(debitoACobrar != null){
				Integer idDebitoACobrar = debitoACobrar.getId();

				// Verifica se há relação entre o débito a cobrar com pagamento excluído e algum
				// item de documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
				this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrar,
								CobrancaDebitoSituacao.PENDENTE, new Date(), CobrancaDebitoSituacao.PAGO);

			}
		}

	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0015] Verifica Associação do Pagamento da Conta com Itens de Documento de Cobrança
	 * 
	 * @author Hebert Falcão
	 * @throws ControladorException
	 * @date 11/12/2012
	 */
	private void verificarAssociacaoDoPagamentoDaContaComItensDeDocumentoDeCobranca(Pagamento pagamentoNovo, Pagamento pagamentoAntigo)
					throws ControladorException{

		Date dataPagamentoNovo = null;

		Integer idContaPagamentoNovo = null;

		if(pagamentoNovo != null){
			Conta conta = pagamentoNovo.getConta();

			if(conta != null){
				idContaPagamentoNovo = conta.getId();
			}

			// Data Pagamento
			dataPagamentoNovo = pagamentoNovo.getDataPagamento();
		}

		Date dataPagamentoAntigo = null;

		Integer idContaPagamentoAntigo = null;

		Integer idGuiaPagamentoAntigo = null;
		Integer numeroPrestacaoPagamentoAntigo = null;

		Integer idDebitoACobrarPagamentoAntigo = null;

		if(pagamentoAntigo != null){
			// Conta
			Conta conta = pagamentoAntigo.getConta();

			if(conta != null){
				idContaPagamentoAntigo = conta.getId();
			}

			// Guia de Pagamento
			GuiaPagamentoGeral guiaPagamentoGeral = pagamentoAntigo.getGuiaPagamentoGeral();

			if(guiaPagamentoGeral != null){
				idGuiaPagamentoAntigo = guiaPagamentoGeral.getId();
			}

			numeroPrestacaoPagamentoAntigo = pagamentoAntigo.getNumeroPrestacao();

			// Debito a Cobrar
			DebitoACobrar debitoACobrar = pagamentoAntigo.getDebitoACobrar();

			if(debitoACobrar != null){
				idDebitoACobrarPagamentoAntigo = debitoACobrar.getId();
			}

			// Data Pagamento
			dataPagamentoAntigo = pagamentoAntigo.getDataPagamento();
		}

		// Situação 1: Pagamento alterado para determinada conta

		// Caso o pagamento esteja sendo alterado para determinada conta
		if(idContaPagamentoAntigo == null && idContaPagamentoNovo != null){

			// Verifica se há relação entre a conta do pagamento e algum item de documento de
			// cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(idContaPagamentoNovo, null, null, null,
							CobrancaDebitoSituacao.PAGO, dataPagamentoNovo, CobrancaDebitoSituacao.PENDENTE);

			// Caso o pagamento estivesse associado a uma prestação de guia de pagamento
			if(idGuiaPagamentoAntigo != null && numeroPrestacaoPagamentoAntigo != null){

				// Verifica se há relação entre a prestação de guia de pagamento com pagamento
				// associado a uma conta e algum item de documento de cobrança - [UC3082] Atualizar
				// Item Documento Cobrança
				this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamentoAntigo,
								numeroPrestacaoPagamentoAntigo.shortValue(), null, CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo,
								CobrancaDebitoSituacao.PAGO);
			}

			// Caso o pagamento estivesse associado a um débito a cobrar
			if(idDebitoACobrarPagamentoAntigo != null){

				// Verifica se há relação entre o débito a cobrar com pagamento associado a uma
				// conta e algum item de documento de cobrança - [UC3082] Atualizar Item Documento
				// Cobrança
				this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrarPagamentoAntigo,
								CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);
			}
		}

		// Situação 2: Pagamento alterado para outra conta

		// Caso o pagamento esteja sendo alterado para outra conta
		if(idContaPagamentoAntigo != null && idContaPagamentoNovo != null
						&& idContaPagamentoAntigo.intValue() != idContaPagamentoNovo.intValue()){

			// Verifica se há relação entre a conta anterior do pagamento e algum item de documento
			// de cobrança - [UC3082] Atualizar Item Documento Cobrança]
			this.getControladorCobranca().atualizarItemDocumentoCobranca(idContaPagamentoAntigo, null, null, null,
							CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);

			// Verifica se há relação entre a conta atual do pagamento e algum item de documento de
			// cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(idContaPagamentoNovo, null, null, null,
							CobrancaDebitoSituacao.PAGO, dataPagamentoNovo, CobrancaDebitoSituacao.PENDENTE);
		}

		// Situação 3: Data do Pagamento alterado, sem mudança da conta do pagamento

		// Caso a data do pagamento esteja sendo alterada, sem mudança da conta do pagamento
		if(idContaPagamentoAntigo != null && idContaPagamentoNovo != null
						&& idContaPagamentoAntigo.intValue() == idContaPagamentoNovo.intValue() && dataPagamentoAntigo != null
						&& dataPagamentoNovo != null && dataPagamentoNovo.compareTo(dataPagamentoAntigo) != 0){

			// Verifica se há relação entre a conta do pagamento e algum item de documento de
			// cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(idContaPagamentoAntigo, null, null, null,
							CobrancaDebitoSituacao.PAGO, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);
		}
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0016] Verifica Associação Pagamento da Guia com Itens de Documento de Cobrança
	 * 
	 * @author Hebert Falcão
	 * @date 11/12/2012
	 */
	private void verificarAssociacaoDoPagamentoDaGuiaComItensDeDocumentoDeCobranca(Pagamento pagamentoNovo, Pagamento pagamentoAntigo)
					throws ControladorException{

		Date dataPagamentoNovo = null;

		Integer idGuiaPagamentoNovo = null;
		Integer numeroPrestacaoPagamentoNovo = null;

		if(pagamentoNovo != null){
			GuiaPagamentoGeral guiaPagamentoGeral = pagamentoNovo.getGuiaPagamentoGeral();

			if(guiaPagamentoGeral != null){
				idGuiaPagamentoNovo = guiaPagamentoGeral.getId();
			}

			numeroPrestacaoPagamentoNovo = pagamentoNovo.getNumeroPrestacao();

			// Data Pagamento
			dataPagamentoNovo = pagamentoNovo.getDataPagamento();
		}

		Date dataPagamentoAntigo = null;

		Integer idContaPagamentoAntigo = null;

		Integer idGuiaPagamentoAntigo = null;
		Integer numeroPrestacaoPagamentoAntigo = null;

		Integer idDebitoACobrarPagamentoAntigo = null;

		if(pagamentoAntigo != null){
			// Conta
			Conta conta = pagamentoAntigo.getConta();

			if(conta != null){
				idContaPagamentoAntigo = conta.getId();
			}

			// Guia de Pagamento
			GuiaPagamentoGeral guiaPagamentoGeral = pagamentoAntigo.getGuiaPagamentoGeral();

			if(guiaPagamentoGeral != null){
				idGuiaPagamentoAntigo = guiaPagamentoGeral.getId();
			}

			numeroPrestacaoPagamentoAntigo = pagamentoAntigo.getNumeroPrestacao();

			// Debito a Cobrar
			DebitoACobrar debitoACobrar = pagamentoAntigo.getDebitoACobrar();

			if(debitoACobrar != null){
				idDebitoACobrarPagamentoAntigo = debitoACobrar.getId();
			}

			// Data Pagamento
			dataPagamentoAntigo = pagamentoAntigo.getDataPagamento();
		}

		// Situação 1: Pagamento alterado para determinada prestação de guia de pagamento

		// Caso o pagamento esteja sendo alterado para determinada prestação de guia de pagamento
		if(idGuiaPagamentoAntigo == null && idGuiaPagamentoNovo != null && numeroPrestacaoPagamentoNovo != null){

			// Verifica se há relação entre a prestação de guia de pagamento do pagamento e algum
			// item de documento de cobrança - [UC3082] Atualizar Item Documento Cobrança]
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamentoNovo,
							numeroPrestacaoPagamentoNovo.shortValue(), null, CobrancaDebitoSituacao.PAGO, dataPagamentoNovo,
							CobrancaDebitoSituacao.PENDENTE);

			// Caso o pagamento estivesse associado a uma conta
			if(idContaPagamentoAntigo != null){

				// Verifica se há relação entre a conta com pagamento associado a uma prestação de
				// guia de pagamento e algum item de documento de cobrança - [UC3082] Atualizar Item
				// Documento Cobrança
				this.getControladorCobranca().atualizarItemDocumentoCobranca(idContaPagamentoAntigo, null, null, null,
								CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);
			}

			// Caso o pagamento estivesse associado a um débito a cobrar
			if(idDebitoACobrarPagamentoAntigo != null){
				// Verifica se há relação entre o débito a cobrar com pagamento associado a uma
				// prestação de guia de pagamento e algum item de documento de cobrança - [UC3082]
				// Atualizar Item Documento Cobrança
				this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrarPagamentoAntigo,
								CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);
			}

		}

		// Situação 2: Pagamento alterado para outra prestação de guia de pagamento

		// Caso o pagamento esteja sendo alterado para outra prestação de guia de pagamento
		if(idGuiaPagamentoAntigo != null
						&& numeroPrestacaoPagamentoAntigo != null
						&& idGuiaPagamentoNovo != null
						&& numeroPrestacaoPagamentoNovo != null
						&& (idGuiaPagamentoAntigo.intValue() != idGuiaPagamentoNovo.intValue() || numeroPrestacaoPagamentoAntigo.intValue() != numeroPrestacaoPagamentoNovo
										.intValue())){

			// Verifica se há relação entre a prestação de guia de pagamento anterior do pagamento e
			// algum item de documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamentoAntigo,
							numeroPrestacaoPagamentoAntigo.shortValue(), null, CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo,
							CobrancaDebitoSituacao.PAGO);

			// Verifica se há relação entre a prestação de guia de pagamento atual do pagamento e
			// algum item de documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamentoNovo,
							numeroPrestacaoPagamentoNovo.shortValue(), null, CobrancaDebitoSituacao.PAGO, dataPagamentoNovo,
							CobrancaDebitoSituacao.PENDENTE);

		}

		// Situação 3: Data do Pagamento alterado, sem mudança da prestação de guia de pagamento do
		// pagamento

		// Caso a data do pagamento esteja sendo alterada, sem mudança da prestação de guia de
		// pagamento do pagamento
		if(idGuiaPagamentoAntigo != null && numeroPrestacaoPagamentoAntigo != null && idGuiaPagamentoNovo != null
						&& numeroPrestacaoPagamentoNovo != null && idGuiaPagamentoAntigo.intValue() == idGuiaPagamentoNovo.intValue()
						&& numeroPrestacaoPagamentoAntigo.intValue() == numeroPrestacaoPagamentoNovo.intValue()
						&& dataPagamentoAntigo != null && dataPagamentoNovo != null
						&& dataPagamentoNovo.compareTo(dataPagamentoAntigo) != 0){

			// Verifica se há relação entre a prestação de guia de pagamento do pagamento e algum
			// item de documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamentoAntigo,
							numeroPrestacaoPagamentoAntigo.shortValue(), null, CobrancaDebitoSituacao.PAGO, dataPagamentoNovo,
							CobrancaDebitoSituacao.PAGO);
		}
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0017] Verifica Associação do Pagamento do Débito A Cobrar com Itens de Documento de
	 * Cobrança
	 * 
	 * @author Hebert Falcão
	 * @date 11/12/2012
	 */
	private void verificarAssociacaoDoPagamentoDoDebitoComItensDeDocumentoDeCobranca(Pagamento pagamentoNovo, Pagamento pagamentoAntigo)
					throws ControladorException{

		Date dataPagamentoNovo = null;

		Integer idDebitoACobrarPagamentoNovo = null;

		if(pagamentoNovo != null){
			DebitoACobrar debitoACobrar = pagamentoNovo.getDebitoACobrar();

			if(debitoACobrar != null){
				idDebitoACobrarPagamentoNovo = debitoACobrar.getId();
			}

			// Data Pagamento
			dataPagamentoNovo = pagamentoNovo.getDataPagamento();
		}

		Date dataPagamentoAntigo = null;

		Integer idContaPagamentoAntigo = null;

		Integer idGuiaPagamentoAntigo = null;
		Integer numeroPrestacaoPagamentoAntigo = null;

		Integer idDebitoACobrarPagamentoAntigo = null;

		if(pagamentoAntigo != null){
			// Conta
			Conta conta = pagamentoAntigo.getConta();

			if(conta != null){
				idContaPagamentoAntigo = conta.getId();
			}

			// Guia de Pagamento
			GuiaPagamentoGeral guiaPagamentoGeral = pagamentoAntigo.getGuiaPagamentoGeral();

			if(guiaPagamentoGeral != null){
				idGuiaPagamentoAntigo = guiaPagamentoGeral.getId();
			}

			numeroPrestacaoPagamentoAntigo = pagamentoAntigo.getNumeroPrestacao();

			// Debito a Cobrar
			DebitoACobrar debitoACobrar = pagamentoAntigo.getDebitoACobrar();

			if(debitoACobrar != null){
				idDebitoACobrarPagamentoAntigo = debitoACobrar.getId();
			}

			// Data Pagamento
			dataPagamentoAntigo = pagamentoAntigo.getDataPagamento();
		}

		// Situação 1: Pagamento alterado para determinado débito a cobrar

		// Caso o pagamento esteja sendo alterado para determinado débito a cobrar
		if(idDebitoACobrarPagamentoAntigo == null && idDebitoACobrarPagamentoNovo != null){

			// Verifica se há relação entre o débito a cobrar do pagamento e algum item de documento
			// de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrarPagamentoNovo,
							CobrancaDebitoSituacao.PAGO, dataPagamentoNovo, CobrancaDebitoSituacao.PENDENTE);

			// Caso o pagamento estivesse associado a uma conta
			if(idContaPagamentoAntigo != null){

				// Verifica se há relação entre a conta com pagamento associado a um débito a cobrar
				// e algum item de documento de cobrança - [UC3082] Atualizar Item Documento
				// Cobrança
				this.getControladorCobranca().atualizarItemDocumentoCobranca(idContaPagamentoAntigo, null, null, null,
								CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);
			}

			// Caso o pagamento estivesse associado a uma prestação de guia de pagamento
			if(idGuiaPagamentoAntigo != null && numeroPrestacaoPagamentoAntigo != null){

				// Verifica se há relação entre a prestação de guia de pagamento com pagamento
				// associado a um débito a cobrar e algum item de documento de cobrança - [UC3082]
				// Atualizar Item Documento Cobrança
				this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamentoAntigo,
								numeroPrestacaoPagamentoAntigo.shortValue(), null, CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo,
								CobrancaDebitoSituacao.PAGO);
			}
		}

		// Situação 2: Pagamento alterado para outro débito a cobrar

		// 2. Caso o pagamento esteja sendo alterado para outro débito a cobrar (DBAC_ID da tabela
		// PAGAMENTO com o valor diferente de nulo e diferente do débito a cobrar atual (Débito A
		// Cobrar) e débito a cobrar atual (Débito A Cobrar) com o valor diferente de nulo):
		if(idDebitoACobrarPagamentoAntigo != null && idDebitoACobrarPagamentoNovo != null
						&& idDebitoACobrarPagamentoAntigo.intValue() != idDebitoACobrarPagamentoNovo.intValue()){

			// Verifica se há relação entre o débito a cobrar anterior do pagamento e algum item de
			// documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrarPagamentoAntigo,
							CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);

			// Verifica se há relação entre o débito a cobrar atual do pagamento e algum item de
			// documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrarPagamentoNovo,
							CobrancaDebitoSituacao.PAGO, dataPagamentoNovo, CobrancaDebitoSituacao.PENDENTE);
		}

		// Situação 3: Data do Pagamento alterado, sem mudança do débito a cobrar do pagamento

		// Caso a data do pagamento esteja sendo alterada, sem mudança do débito a cobrar do
		// pagamento
		if(idDebitoACobrarPagamentoAntigo != null && idDebitoACobrarPagamentoNovo != null
						&& idDebitoACobrarPagamentoAntigo.intValue() == idDebitoACobrarPagamentoNovo.intValue()
						&& dataPagamentoAntigo != null && dataPagamentoNovo != null
						&& dataPagamentoNovo.compareTo(dataPagamentoAntigo) != 0){

			// Verifica se há relação entre o débito a cobrar do pagamento e algum item de documento
			// de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrarPagamentoAntigo,
							CobrancaDebitoSituacao.PAGO, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);
		}
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0018] Verifica Associação Novo Tipo Documento do Pagamento com Itens de Documento de
	 * Cobrança
	 * 
	 * @author Hebert Falcão
	 * @date 11/12/2012
	 */
	private void verificarAssociacaoNovoTipoDocumentoDoPagamentoComItensDeDocumentoDeCobranca(Pagamento pagamentoNovo,
					Pagamento pagamentoAntigo) throws ControladorException{

		Date dataPagamentoNovo = null;

		Integer idContaPagamentoNovo = null;

		Integer idGuiaPagamentoNovo = null;
		Integer numeroPrestacaoPagamentoNovo = null;

		Integer idDebitoACobrarPagamentoNovo = null;

		if(pagamentoNovo != null){
			// Conta
			Conta conta = pagamentoNovo.getConta();

			if(conta != null){
				idContaPagamentoNovo = conta.getId();
			}

			// Guia de Pagamento
			GuiaPagamentoGeral guiaPagamentoGeral = pagamentoNovo.getGuiaPagamentoGeral();

			if(guiaPagamentoGeral != null){
				idGuiaPagamentoNovo = guiaPagamentoGeral.getId();
			}

			numeroPrestacaoPagamentoNovo = pagamentoNovo.getNumeroPrestacao();

			// Debito a Cobrar
			DebitoACobrar debitoACobrar = pagamentoNovo.getDebitoACobrar();

			if(debitoACobrar != null){
				idDebitoACobrarPagamentoNovo = debitoACobrar.getId();
			}

			// Data Pagamento
			dataPagamentoNovo = pagamentoNovo.getDataPagamento();
		}

		Integer idContaPagamentoAntigo = null;

		Integer idGuiaPagamentoAntigo = null;
		Integer numeroPrestacaoPagamentoAntigo = null;

		Integer idDebitoACobrarPagamentoAntigo = null;

		if(pagamentoAntigo != null){
			// Conta
			Conta conta = pagamentoAntigo.getConta();

			if(conta != null){
				idContaPagamentoAntigo = conta.getId();
			}

			// Guia de Pagamento
			GuiaPagamentoGeral guiaPagamentoGeral = pagamentoAntigo.getGuiaPagamentoGeral();

			if(guiaPagamentoGeral != null){
				idGuiaPagamentoAntigo = guiaPagamentoGeral.getId();
			}

			numeroPrestacaoPagamentoAntigo = pagamentoAntigo.getNumeroPrestacao();

			// Debito a Cobrar
			DebitoACobrar debitoACobrar = pagamentoAntigo.getDebitoACobrar();

			if(debitoACobrar != null){
				idDebitoACobrarPagamentoAntigo = debitoACobrar.getId();
			}
		}

		// Situação 1: Pagamento desvinculado da conta

		// Caso o pagamento esteja sendo desvinculado da conta
		if(idContaPagamentoAntigo != null && idContaPagamentoNovo == null){

			// Verifica se há relação entre a conta anterior do pagamento e algum item de documento
			// de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(idContaPagamentoAntigo, null, null, null,
							CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);
		}

		// Situação 2: Pagamento desvinculado da prestação de guia de pagamento

		// Caso o pagamento esteja sendo desvinculado da prestação de guia de pagamento
		if(idGuiaPagamentoAntigo != null && numeroPrestacaoPagamentoAntigo != null && idGuiaPagamentoNovo == null
						&& numeroPrestacaoPagamentoNovo == null){

			// Verifica se há relação entre a prestação de guia de pagamento anterior do pagamento e
			// algum item de documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamentoAntigo,
							numeroPrestacaoPagamentoAntigo.shortValue(), null, CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo,
							CobrancaDebitoSituacao.PAGO);
		}

		// Situação 3: Pagamento desvinculado do débito a cobrar

		// Caso o pagamento esteja sendo desvinculado do débito a cobrar
		if(idDebitoACobrarPagamentoAntigo != null && idDebitoACobrarPagamentoNovo == null){

			// Verifica se há relação entre o débito a cobrar anterior do pagamento e algum item de
			// documento de cobrança - [UC3082] Atualizar Item Documento Cobrança
			this.getControladorCobranca().atualizarItemDocumentoCobranca(null, null, null, idDebitoACobrarPagamentoAntigo,
							CobrancaDebitoSituacao.PENDENTE, dataPagamentoNovo, CobrancaDebitoSituacao.PAGO);
		}
	}

	public void distribuirValoresGuiaPorCategoriaHistorico(Integer idGuiaPagamento, Short numeroPrestacao, Imovel imovel)
					throws ControladorException{

		// Remover Guia de Pagamento Categoria
		try{
			repositorioArrecadacao.removerGuiaPagamentoCategoriaHistorico(idGuiaPagamento, numeroPrestacao);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoCategoriasImovel = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		// Prestações
		FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
		filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
						FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
		filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
						FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacao));

		Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil().pesquisar(
						filtroGuiaPagamentoPrestacaoHistorico, GuiaPagamentoPrestacaoHistorico.class.getName());

		if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){
			Map<Integer, BigDecimal> mapPrestacoes = new HashMap<Integer, BigDecimal>();

			LancamentoItemContabil lancamentoItemContabilAux = null;
			Integer idLancamentoItemContabilAux = null;

			BigDecimal valorLancamento = BigDecimal.ZERO;
			BigDecimal valorPrestacao = BigDecimal.ZERO;

			for(GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoAux : colecaoGuiaPagamentoPrestacaoHistorico){
				lancamentoItemContabilAux = guiaPagamentoPrestacaoAux.getLancamentoItemContabil();
				idLancamentoItemContabilAux = lancamentoItemContabilAux.getId();

				valorPrestacao = guiaPagamentoPrestacaoAux.getValorPrestacao();

				if(mapPrestacoes.containsKey(idLancamentoItemContabilAux)){
					valorLancamento = mapPrestacoes.get(idLancamentoItemContabilAux);
					valorLancamento = valorLancamento.add(valorPrestacao);
				}else{
					valorLancamento = valorPrestacao;
				}

				mapPrestacoes.put(idLancamentoItemContabilAux, valorLancamento);
			}

			if(mapPrestacoes != null && !mapPrestacoes.isEmpty()){
				Collection<BigDecimal> colecaoValorCategoria = null;

				Iterator iteratorCategoria = null;
				Iterator iteratorValorCategoria = null;

				Categoria categoria = null;
				Integer idCategoria = null;
				Integer quantidadeEconomiasCategoria = null;

				BigDecimal valorPorCategoria = null;

				GuiaPagamentoCategoriaHistoricoPK guiaPagamentoCategoriaHistoricoPK = null;
				GuiaPagamentoCategoriaHistorico guiaPagamentoCategoriaHistorico = null;

				for(Integer idLancamentoItemContabilIt : mapPrestacoes.keySet()){
					valorLancamento = (BigDecimal) mapPrestacoes.get(idLancamentoItemContabilIt);

					// [UC0185] Obter Valor po Categoria
					colecaoValorCategoria = this.getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel, valorLancamento);

					// Cria as iterações de categoria e valor
					iteratorCategoria = colecaoCategoriasImovel.iterator();
					iteratorValorCategoria = colecaoValorCategoria.iterator();

					// Laço para criar os débitos a cobrar por categoria
					while(iteratorCategoria.hasNext()){
						// Recupera a categoria
						categoria = (Categoria) iteratorCategoria.next();
						idCategoria = categoria.getId();
						quantidadeEconomiasCategoria = categoria.getQuantidadeEconomiasCategoria();

						// Recupera o valor da categoria
						valorPorCategoria = (BigDecimal) iteratorValorCategoria.next();

						// Cria a guia de pagamento por categoria
						guiaPagamentoCategoriaHistoricoPK = new GuiaPagamentoCategoriaHistoricoPK();
						guiaPagamentoCategoriaHistoricoPK.setGuiaPagamentoId(idGuiaPagamento);
						guiaPagamentoCategoriaHistoricoPK.setNumeroPrestacao(numeroPrestacao);
						guiaPagamentoCategoriaHistoricoPK.setCategoriaId(idCategoria);
						guiaPagamentoCategoriaHistoricoPK.setLancamentoItemContabilId(idLancamentoItemContabilIt);

						guiaPagamentoCategoriaHistorico = new GuiaPagamentoCategoriaHistorico();
						guiaPagamentoCategoriaHistorico.setComp_id(guiaPagamentoCategoriaHistoricoPK);
						guiaPagamentoCategoriaHistorico.setQuantidadeEconomia(quantidadeEconomiasCategoria);
						guiaPagamentoCategoriaHistorico.setValorCategoria(valorPorCategoria);
						guiaPagamentoCategoriaHistorico.setUltimaAlteracao(new Date());

						this.getControladorUtil().inserir(guiaPagamentoCategoriaHistorico);
					}
				}
			}
		}
	}

	/**
	 * Metódo responsável por atualizar a tabela provisão devedores duvidosos
	 * para o encerramento da arrecadação do mês.
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 15/02/2013
	 * @param colecaoIdsLocalidades
	 * @throws ControladorException
	 */
	public void atualizarPDDParaEncerrarArrecadacao(int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;
		String[] idSituacaoAtualConta = null;

		// -------------------------
		// Registrar o início do processamento da Unidade de Processamento do Batch
		// -------------------------

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, idFuncionalidadeIniciada);

		try{
			// Recupera os parâmetros do sistema
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// Recupera o ano/mês de referência da arrecadação dos parâmetros de
			// sistema
			Integer anoMesReferenciaArrecadacao = sistemaParametro.getAnoMesArrecadacao();

			// Obtém o mês
			int mesReferenciaArrecadacao = Util.obterMes(anoMesReferenciaArrecadacao);
			// Obtém o ano
			int anoReferenciaArrecadacao = Util.obterAno(anoMesReferenciaArrecadacao);
			// Obtém o ultimo dia do mês/ano
			int ultimoDiaMes = Integer.valueOf(Util.obterUltimoDiaMes(mesReferenciaArrecadacao, anoReferenciaArrecadacao));

			// Data inicial
			Date dataInicialConta = Util.criarData(1, mesReferenciaArrecadacao, anoReferenciaArrecadacao);
			// Data final
			Date dataFinalConta = Util.criarData(ultimoDiaMes, mesReferenciaArrecadacao, anoReferenciaArrecadacao);

			// --------------------------------------------------------
			// Atualiza a tabela ProvisaoDevedoresDuvidosos, conforme
			// motivo de baixa
			// --------------------------------------------------------

			// MOTIVO BAIXA = 1
			idSituacaoAtualConta = new String[4];
			// DCST_IDATUAL 0,1,2,4
			idSituacaoAtualConta[0] = DebitoCreditoSituacao.NORMAL.toString();
			idSituacaoAtualConta[1] = DebitoCreditoSituacao.RETIFICADA.toString();
			idSituacaoAtualConta[2] = DebitoCreditoSituacao.INCLUIDA.toString();
			idSituacaoAtualConta[3] = DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO.toString();

			this.repositorioArrecadacao.atualizarProvisaoDevedoresDuvidosos(ProvisaoDevedoresDuvidososMotivoBaixa.RECEBIMENTO,
							Util.formatarDataSemHora(new Date()), anoMesReferenciaArrecadacao, dataInicialConta, dataFinalConta,
							idSituacaoAtualConta);

			// MOTIVO BAIXA = 2
			idSituacaoAtualConta = new String[1];
			// DCST_IDATUAL = 7
			idSituacaoAtualConta[0] = DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO.toString();

			this.repositorioArrecadacao.atualizarProvisaoDevedoresDuvidosos(ProvisaoDevedoresDuvidososMotivoBaixa.ALTERACAO_VENCIMENTO,
							Util.formatarDataSemHora(new Date()), anoMesReferenciaArrecadacao, dataInicialConta, dataFinalConta,
							idSituacaoAtualConta);

			// MOTIVO BAIXA = 3
			idSituacaoAtualConta = new String[1];
			// DCST_IDATUAL = 3
			idSituacaoAtualConta[0] = DebitoCreditoSituacao.CANCELADA.toString();

			this.repositorioArrecadacao.atualizarProvisaoDevedoresDuvidosos(ProvisaoDevedoresDuvidososMotivoBaixa.CANCELAMENTO,
							Util.formatarDataSemHora(new Date()), anoMesReferenciaArrecadacao, dataInicialConta, dataFinalConta,
							idSituacaoAtualConta);

			// MOTIVO BAIXA = 4
			idSituacaoAtualConta = new String[1];
			// DCST_IDATUAL = 5
			idSituacaoAtualConta[0] = DebitoCreditoSituacao.PARCELADA.toString();

			this.repositorioArrecadacao.atualizarProvisaoDevedoresDuvidosos(ProvisaoDevedoresDuvidososMotivoBaixa.PARCELAMENTO,
							Util.formatarDataSemHora(new Date()), anoMesReferenciaArrecadacao, dataInicialConta, dataFinalConta,
							idSituacaoAtualConta);

			// --------------------------------------------------------
			// Registrar o fim da execução da Unidade de Processamento
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	/**
	 * Metódo responsável por encerrar a arrecadação do mês.
	 * Encerrar Arrecadação do Mês
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 15/02/2013
	 * @param colecaoIdsLocalidades
	 * @throws ControladorException
	 */
	public void encerrarArrecadacao(int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		// -------------------------
		// Registrar o início do processamento da Unidade de Processamento do Batch
		// -------------------------

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, idFuncionalidadeIniciada);

		try{
			// Recupera os parâmetros do sistema
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// // Recupera o ano/mês de referência da arrecadação dos parâmetros de
			// // sistema
			Integer anoMesReferenciaArrecadacao = sistemaParametro.getAnoMesArrecadacao();

			// Registrar Data-Hora do Encerramento Contábil (tabela ENCERRAMENTO_CONTABIL_PARM)
			EncerramentoContabilParm encerramentoContabil = new EncerramentoContabilParm();
			encerramentoContabil.setAnoMesReferenciaArrecadacao(anoMesReferenciaArrecadacao);
			encerramentoContabil.setTmEncerramentoArrecadacao(new Date());
			encerramentoContabil.setUltimaAlteracao(new Date());

			FiltroEncerramentoContabilParm filtro = new FiltroEncerramentoContabilParm();
			filtro.adicionarParametro(new ParametroSimples(FiltroEncerramentoContabilParm.ANO_MES_REFERENCIA_ARRECADACAO,
							anoMesReferenciaArrecadacao));

			Collection colEncerramentoContabil = this.getControladorUtil().pesquisar(filtro, EncerramentoContabilParm.class.getName());

			if(colEncerramentoContabil.isEmpty()){
				// inseri
				this.getControladorUtil().inserir(encerramentoContabil);
			}else{
				// atualiza
				encerramentoContabil = (EncerramentoContabilParm) Util.retonarObjetoDeColecao(colEncerramentoContabil);
				encerramentoContabil.setTmEncerramentoArrecadacao(new Date());

				this.getControladorUtil().atualizar(encerramentoContabil);

			}

			String pNomeMetodoGerarDados = ((String) ParametroCobranca.P_GERACAO_DADOS_REMUNERACAO_COBRANCA_ADMINISTRATIVA.executar());

			if(pNomeMetodoGerarDados.equals("gerarDadosRemuneracaoCobrancaAdministrativaModelo1")){
				gerarDadosRemuneracaoCobrancaAdministrativaModelo1();
			}

			// Adiciona 1 mês a referência da arrecadação
			Integer anoMesArrecadacao = Util.somaUmMesAnoMesReferencia(anoMesReferenciaArrecadacao);

			// Atualiza o campo PARM_AMREFERENCIAARRECADACAO da tabela SISTEMA_PARAMETROS
			sistemaParametro.setAnoMesArrecadacao(anoMesArrecadacao);
			sistemaParametro.setUltimaAlteracao(new Date());

			this.getControladorUtil().atualizar(sistemaParametro);

			// Atualiza o campo PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA
			// onde PASI_CDPARAMETRO = 'P_REFERENCIA_CONTABIL';
			this.getControladorParametroSistema().atualizarValorParametroSistema(ParametroContabil.P_REFERENCIA_CONTABIL.getCodigo(),
							anoMesArrecadacao.toString());


			// --------------------------------------------------------
			// Registrar o fim da execução da Unidade de Processamento
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados
	 * 2.6. Situação do Pagamento
	 * 
	 * @author Josenildo Neves
	 * @since 29/11/2012
	 * @return listaPagamentoSituacao
	 * @throws ControladorException
	 */
	public Collection<PagamentoSituacao> pesquisarPagamentoSituacao() throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarPagamentoSituacao();
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * 
	 * @author Josenildo Neves
	 * @date 14/11/2012
	 */
	public void classificarLotePagamentosNaoClassificados(ClassificarLotePagamentosNaoClassificadosHelper helper, Usuario usuario,
					int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		try{

			// Registrar o início do processamento da unidade de processamento do batch
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			Collection<ClassificarPagamentosNaoClassificadosHelper> colecaoClassificarPagamentosNaoClassificadosHelper = this
							.classificarLotePagamentosNaoClassificados(helper, usuario);

			String tipoRelatorio = TarefaRelatorio.TIPO_PDF + "";

			RelatorioClassificarLotePagamentosNaoClassificados relatorio = new RelatorioClassificarLotePagamentosNaoClassificados(usuario);
			relatorio.addParametro("colecaoClassificarPagamentosNaoClassificadosHelper", colecaoClassificarPagamentosNaoClassificadosHelper);
			relatorio.addParametro("totalRegistrosRelatorio", colecaoClassificarPagamentosNaoClassificadosHelper.size());
			relatorio.addParametro("classificarLotePagamentosNaoClassificadosHelper", helper);

			relatorio.addParametro("tipoFormatoRelatorio", Integer.parseInt(tipoRelatorio));

			getControladorBatch().iniciarProcessoRelatorio(relatorio);

			// Registrar o fim do processamento da unidade de processamento do batch
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * Retorna a quantidade de pagamentos a serem processados.
	 * 
	 * @author Josenildo Neves
	 * @date 14/11/2012
	 */
	public Integer pesquisarQuantidadePagamentos(ClassificarLotePagamentosNaoClassificadosHelper helper) throws ControladorException{

		Integer retorno = Integer.valueOf(0);

		try{

			retorno = repositorioArrecadacao.pesquisarQuantidadePagamentos(helper);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados.
	 * 
	 * @author Josenildo Neves
	 * @date 30/11/2012
	 */
	public Collection<ClassificarPagamentosNaoClassificadosHelper> classificarLotePagamentosNaoClassificados(
					ClassificarLotePagamentosNaoClassificadosHelper helper, Usuario usuario) throws ControladorException{

		Collection<Pagamento> colecaoPagamentos = null;
		Collection<ClassificarPagamentosNaoClassificadosHelper> colecaoClassificarPagamentosNaoClassificadosHelper = new ArrayList<ClassificarPagamentosNaoClassificadosHelper>();

		// 3. O sistema seleciona lista pagamentos conforme os critérios informados, verificando os
		// seguintes itens:
		try{
			colecaoPagamentos = repositorioArrecadacao.pesquisarPagamentos(helper);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}


		// 4. Conforme as opções de geração informado pelo usuário:
		// 4.1. Caso a opção seja Classificar: Atualizar pagamentos selecionados
		if(ConstantesSistema.CLASSIFICAR == helper.getOpcaoGeracao()){

			// 2.7. Limite máximo da diferença
			if(helper.getLimiteMaximoDiferenca() != null && !helper.getLimiteMaximoDiferenca().equals("")){
				colecaoPagamentos = this.verificarLimiteMaximoDiferencaLotePagamento(colecaoPagamentos, helper);
			}

			// [SB0000] Classificar Pagamentos
			this.classificarPagamentosLote(colecaoPagamentos, colecaoClassificarPagamentosNaoClassificadosHelper, usuario);

		}

		return colecaoClassificarPagamentosNaoClassificadosHelper;

	}

	/**
	 * [OC1257292] - Verificar Limite Maximo da Diferença em um Lote de Pagamentos
	 * 
	 * @author Ado Rocha
	 * @date 10/03/2014
	 * @return Collection
	 */

	public Collection verificarLimiteMaximoDiferencaLotePagamento(Collection<Pagamento> colecaoPagamentos,
					ClassificarLotePagamentosNaoClassificadosHelper helper){

		Map<String, Collection> pagamentoContaMap = new HashMap<String, Collection>();
		Collection<Pagamento> colecaoPagamentosClassificar = new ArrayList<Pagamento>();
		Collection<Pagamento> colecaoPagamentosEmAnalise = new ArrayList<Pagamento>();
		BigDecimal valorTotalPagamentos = BigDecimal.ZERO;
		BigDecimal limiteMaximoDiferenca = helper.getLimiteMaximoDiferenca();
		
		// Ordenar a coleção por mais de um campo
		List<Pagamento> colecaoPagamentosOrdenada = new ArrayList<Pagamento>();
		colecaoPagamentosOrdenada.addAll(colecaoPagamentos);		
		List sortFields = new ArrayList();
		sortFields.add(new BeanComparator("imovel.id"));
		sortFields.add(new BeanComparator("anoMesReferenciaPagamento"));
		ComparatorChain multiSort = new ComparatorChain(sortFields);
		Collections.sort(colecaoPagamentosOrdenada, multiSort);

		// Montando o Map com os pagamentos chave = referenciaPagamento + idImovel
		Iterator iteratorColecaoPagamentos = colecaoPagamentosOrdenada.iterator();

		while(iteratorColecaoPagamentos.hasNext()){

			Pagamento pagamento = (Pagamento) iteratorColecaoPagamentos.next();

			String idImovel = pagamento.getImovel().getId().toString();
			String referenciaPagamento = pagamento.getAnoMesReferenciaPagamento().toString();

			String chave = referenciaPagamento + idImovel;

			if(pagamentoContaMap.containsKey(chave)){
				colecaoPagamentosEmAnalise = new ArrayList<Pagamento>();
				colecaoPagamentosEmAnalise = pagamentoContaMap.get(chave);
				colecaoPagamentosEmAnalise.add(pagamento);
				pagamentoContaMap.put(chave, colecaoPagamentosEmAnalise);

			}else{
				colecaoPagamentosEmAnalise = new ArrayList<Pagamento>();
				colecaoPagamentosEmAnalise.add(pagamento);
				pagamentoContaMap.put(chave, colecaoPagamentosEmAnalise);
			}
		}

		// Classificando os pagamentos
		Set<String> chaves = pagamentoContaMap.keySet();

		for(String chave : chaves){
			if(chave != null){
				colecaoPagamentosEmAnalise = pagamentoContaMap.get(chave);

				String referenciaPagamento = Util.formatarAnoMesSemBarraParaMesAnoComBarra(Integer.valueOf(chave.substring(0, 6)));
				String idImovel = chave.substring(6, chave.length());

				try{
					Conta conta = this.getControladorFaturamento().pesquisarContaDigitada(idImovel, referenciaPagamento);

					BigDecimal valorConta = conta.getValorTotalContaBigDecimal();

					Iterator iteratorPagamentosEmAnalise = colecaoPagamentosEmAnalise.iterator();

					while(iteratorPagamentosEmAnalise.hasNext()){
						Pagamento pagamento = (Pagamento) iteratorPagamentosEmAnalise.next();
						valorTotalPagamentos = valorTotalPagamentos.add(pagamento.getValorPagamento());
					}

					if((valorConta != null)
									&& (valorTotalPagamentos.compareTo(valorConta.subtract(limiteMaximoDiferenca)) >= 0 && valorTotalPagamentos
													.compareTo(valorConta.add(limiteMaximoDiferenca)) <= 0)){
						colecaoPagamentosClassificar.addAll(colecaoPagamentosEmAnalise);
						valorTotalPagamentos = BigDecimal.ZERO;
					}else{
						valorTotalPagamentos = BigDecimal.ZERO;
					}

				}catch(ControladorException e){
					e.printStackTrace();
				}
			}
		}

		return colecaoPagamentosClassificar;

	}

	/**
	 * [UC3080] Classificar em Lote Pagamentos Não Classificados
	 * [SB0000] Classificar Pagamentos
	 * 
	 * @author Luciano Galvão
	 * @date 04/09/2013
	 */
	private void classificarPagamentosLote(Collection<Pagamento> colecaoPagamentos,
					Collection<ClassificarPagamentosNaoClassificadosHelper> colecaoClassificarPagamentosNaoClassificadosHelper,
					Usuario usuario) throws ControladorException{

		Conta contaProcessada = null;
		PagamentoSituacao pagamentoSituacaoAtual = null;
		boolean continuarClassificandoPagamentosDaConta = true;
		boolean mudouConta = false;

		if(!Util.isVazioOrNulo(colecaoPagamentos)){

			// a coleção de pagamentos é ordenada pelo id da conta, ou seja, o processamento ocorre
			// para todos os pagamentos de uma conta por vez
			for(Pagamento pagamento : colecaoPagamentos){
				
				try{

					// Carrega o pagamento atualizado, pois este pode ter sido alterado
					pagamento = repositorioArrecadacao.consultarPagamentoParaAtualizacao(pagamento.getId());

				}catch(ErroRepositorioException e){
					e.printStackTrace();
					throw new ControladorException("erro.sistema", e);
				}
				
				if(pagamento != null){

					// verifica se houve a mudança da conta processada, em relação ao pagamento
					// processado anteriormente
					mudouConta = contaProcessada == null || pagamento.getConta() == null || !pagamento.getConta().equals(contaProcessada);

					// Se mudou a conta ou o processamento do pagamento anterior indicou a
					// continuação da classificação dos pagamentos desta conta, siga em frente. Caso
					// contrário, siga para o próximo pagamento a ser processado
					if(mudouConta || continuarClassificandoPagamentosDaConta){

						if(pagamento.getPagamentoSituacaoAtual() != null){

							pagamentoSituacaoAtual = null;

							// Caso a situação atual do pagamento corresponda a
							// "Pagamento em Duplicidade", a "Documento Inexistente" ou a
							// "Valor em Excesso"
							if(pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.FATURA_INEXISTENTE)
											|| pagamento.getPagamentoSituacaoAtual().getId()
															.equals(PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE)
											|| pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_EM_EXCESSO)
											|| pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.PAGAMENTO_DUPLICADO)
											|| pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.PAGAMENTO_A_MAIOR)
											|| pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.PAGAMENTO_DOC_PAGO)
											|| pagamento.getPagamentoSituacaoAtual().getId()
															.equals(PagamentoSituacao.PAGAMENTO_DOC_CANCELADO)
											|| pagamento.getPagamentoSituacaoAtual().getId()
															.equals(PagamentoSituacao.PAGAMENTO_DOC_PARCELADO)){

								// O sistema deve continuar processando os pagamentos da conta
								continuarClassificandoPagamentosDaConta = true;

								// Situação Atual do Pagamento com o valor correspondente a
								// "baixa de pagamento em duplicidade ou excesso"
								pagamentoSituacaoAtual = (PagamentoSituacao) getControladorUtil().pesquisar(
												PagamentoSituacao.VALOR_A_BAIXAR, PagamentoSituacao.class, true);

							}else if(pagamento.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.PAGAMENTO_A_MENOR)){
								// Caso a situação atual do pagamento seja "pagamento a menor"

								// O sistema deve seguir para o grupo de pagamentos da próxima conta
								continuarClassificandoPagamentosDaConta = false;

								// Situação Atual do Pagamento com o valor correspondente a
								// "baixa de pagamento a menor"
								pagamentoSituacaoAtual = (PagamentoSituacao) getControladorUtil().pesquisar(
												PagamentoSituacao.VALOR_A_BAIXAR_MENOR, PagamentoSituacao.class, true);
							}

							if(pagamentoSituacaoAtual != null){

								pagamento.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAtual());
								pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

								// Atualiza o pagamento
								// [UC0266 Manter Pagamentos] - [SB0004 - Atualiza Pagamento]
								atualizarPagamento(pagamento, usuario, null, null, null, colecaoClassificarPagamentosNaoClassificadosHelper);
							}

						}

					}

					contaProcessada = pagamento.getConta();
				}

			}

		}
	}

	/**
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Pagamento> selecionarPagamentoPorGuiaPagamento(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ControladorException{

		Collection<Pagamento> retorno = null;
		try{

			retorno = this.repositorioArrecadacao.selecionarPagamentoPorGuiaPagamento(idGuiaPagamento, numeroPrestacao);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> selecionarPagamentoHistoricoPorGuiaPagamentoHistorico(Integer idGuiaPagamento)
					throws ControladorException{

		Collection<PagamentoHistorico> retorno = null;
		try{

			retorno = this.repositorioArrecadacao.selecionarPagamentoHistoricoPorGuiaPagamentoHistorico(idGuiaPagamento);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * @param idConta
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Pagamento> selecionarPagamentoPorConta(Integer idConta) throws ControladorException{

		Collection<Pagamento> retorno = null;
		try{

			retorno = this.repositorioArrecadacao.selecionarPagamentoPorConta(idConta);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * @param idConta
	 * @return
	 * @throws ControladorException
	 */

	public Collection<PagamentoHistorico> selecionarPagamentoHistoricoPorContaHistorico(Integer idConta) throws ControladorException{

		Collection<PagamentoHistorico> retorno = null;
		try{

			retorno = this.repositorioArrecadacao.selecionarPagamentoHistoricoPorContaHistorico(idConta);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0020] – Gerar devolução de valores
	 * Autor: Josenildo Neves
	 * Data: 12/03/2013
	 * 
	 * @param pagamento
	 * @param usuario
	 * @param gerarDevolucaoValores
	 * @param idCreditoTipo
	 * @throws ControladorException
	 */
	private void gerarDevolucoesValores(Pagamento pagamento, PagamentoSituacao pagamentoSituacaoAtual, Usuario usuario,
					String gerarDevolucaoValores, Integer idCreditoTipo) throws ControladorException{

		if(Util.isNaoNuloBrancoZero(gerarDevolucaoValores) && Util.isNaoNuloBrancoZero(gerarDevolucaoValores)
						&& gerarDevolucaoValores.equals(ConstantesSistema.SIM.toString())){
			// 1.1. Chamar “[UC0194] Inserir Crédito A Realizar” passando:
			CreditoARealizar creditoARealizar = new CreditoARealizar();

			CreditoTipo creditoTipo = new CreditoTipo();
			creditoTipo.setId(idCreditoTipo);
			creditoARealizar.setCreditoTipo(creditoTipo);

			CreditoOrigem creditoOrigem = new CreditoOrigem();
			creditoOrigem.setId(CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO);
			creditoARealizar.setCreditoOrigem(creditoOrigem);

			creditoARealizar.setRegistroAtendimento(null);
			creditoARealizar.setOrdemServico(null);
			creditoARealizar.setAnoMesReferenciaCredito(pagamento.getAnoMesReferenciaPagamento());
			creditoARealizar.setNumeroPrestacaoCredito(ConstantesSistema.SIM);

			Imovel imovel = pagamento.getImovel();
			creditoARealizar.setImovel(imovel);

			creditoARealizar.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
			creditoARealizar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
			creditoARealizar.setNumeroLote(imovel.getLote());
			creditoARealizar.setNumeroSubLote(imovel.getSubLote());
			creditoARealizar.setQuadra(imovel.getQuadra());
			creditoARealizar.setLocalidade(imovel.getLocalidade());

			// [SB0021] – Determinar valor do crédito
			creditoARealizar.setValorCredito(this.determinarValorCredito(pagamento, pagamentoSituacaoAtual));

			PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();
			pagamentoHistorico.setId(pagamento.getId());
			creditoARealizar.setPagamentoHistorico(pagamentoHistorico);

			this.getControladorFaturamento().inserirCreditoARealizar(imovel, creditoARealizar, usuario);

		}
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * [SB0021] – Determinar valor do crédito
	 * 
	 * @param pagamento
	 * @param pagamentoSituacaoAtual
	 * @return
	 * @throws ControladorException
	 */
	private BigDecimal determinarValorCredito(Pagamento pagamento, PagamentoSituacao pagamentoSituacaoAtual) throws ControladorException{

		BigDecimal valorCredito = null;

		// 1.1. Caso a situação original do pagamento tenha o indicador de valor duplicado
		// (PGST_ICVALORDUPLICADO = 1 em PAGAMENTO_SITUACAO para PGST_ID = Id da situação):
		// Valor do crédito = Valor do pagamento.
		// Guarda a situação do pagamento Original, para verificar
		if(Util.isNaoNuloBrancoZero(pagamentoSituacaoAtual)
						&& pagamentoSituacaoAtual.getIndicadorValorDuplicado().equals(ConstantesSistema.SIM)){

			valorCredito = pagamento.getValorPagamento();
		}else{
			// 1.2.1. Caso a conta não seja NULL, pesquisar em CONTA pelo Id da Conta
			if(Util.isNaoNuloBrancoZero(pagamento.getConta())){
				// 1.2.1.1. Caso exista, Valor do crédito = Valor do pagamento – Valor da conta;
				valorCredito = pagamento.getValorPagamento().subtract(pagamento.getConta().getValorTotal());
			}else{
				// 1.2.2. Caso a guia não seja NULL, pesquisar em GUIA_PAGAMENTO_PRESTACAO pelo Id
				// da guia e Número da prestação do pagamento:
				if(Util.isNaoNuloBrancoZero(pagamento.getGuiaPagamentoGeral())){

					valorCredito = this.determinarValorCreditoQuandoPagamentoGuiaPagamento(pagamento);
				}else{
					// 1.2.3. Caso o débito a cobrar não seja NULL, pesquisar em DEBITO_A_COBRAR
					// pelo Id do débito
					valorCredito = this.determinarValorCreditoQuandoPagamentoDebitoACobrar(pagamento);
				}
			}
		}

		// 1.3. Caso o Valor do crédito seja menor que zero, abortar a operação exibindo a mensagem:
		// “Valor do crédito não pode ser negativo: {valor}”.
		if(valorCredito.compareTo(BigDecimal.ZERO) == ConstantesSistema.VALOR_MENOR){
			throw new ControladorException("atencao.valor_pagamento_negativo", null, Util.formatarMoedaReal(valorCredito));
		}

		return valorCredito;
	}

	/**
	 * [UC1016] Estornar Pagamentos
	 * 3.1.1. [SB0004 – Cancelar crédito associado ao pagamento]
	 * Author: Josenildo Neves
	 * Date: 14/03/2013
	 * 
	 * @param pagamentoHistorico
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	private void cancelarCreditoAssociadoAoPagamento(PagamentoHistorico pagamentoHistorico, Usuario usuarioLogado)
					throws ControladorException{

		FiltroCreditoARealizar filtroCreditoARealizar = new FiltroCreditoARealizar();
		filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.PAGAMENTO_HISTORICO, pagamentoHistorico));

		Collection colecaoCreditoARealizar = getControladorUtil().pesquisar(filtroCreditoARealizar, CreditoARealizar.class.getName());

		if(!Util.isVazioOrNulo(colecaoCreditoARealizar)){
			CreditoARealizar creditoARealizar = (CreditoARealizar) Util.retonarObjetoDeColecao(colecaoCreditoARealizar);

			creditoARealizar.setPagamentoHistorico(null);

			this.getControladorUtil().atualizar(creditoARealizar);

			// 1.2. Cancelar o crédito selecionado <<Inclui>> [UC0195] Manter Crédito A Realizar
			this.getControladorFaturamento().cancelarCreditoARealizar(new String[] {creditoARealizar.getId().toString()},
							pagamentoHistorico.getImovel(), usuarioLogado, true);

		}
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * 1.2.2. Caso a guia não seja NULL, pesquisar em GUIA_PAGAMENTO_PRESTACAO pelo Id da guia e
	 * Número da prestação do pagamento:
	 * 
	 * @param pagamento
	 * @return
	 * @throws ControladorException
	 */
	private BigDecimal determinarValorCreditoQuandoPagamentoGuiaPagamento(Pagamento pagamento) throws ControladorException{

		BigDecimal valorCredito = null;
		BigDecimal totalValorGuiaPagamentoPrestacao = null;
		Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = null;

		try{
			totalValorGuiaPagamentoPrestacao = repositorioArrecadacao.selecionarGuiaPagamentoPrestacaoPorGuiaPagamentoENumeroPrestacao(
							pagamento.getGuiaPagamentoGeral().getGuiaPagamento().getId(), pagamento.getNumeroPrestacao());
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		// 1.2.2.1. Caso exista, Valor do crédito = Valor do pagamento – Valor da
		// prestação;
		if(Util.isNaoNuloBrancoZero(totalValorGuiaPagamentoPrestacao)){
			// BigDecimal totalValorGuiaPagamentoPrestacao = BigDecimal.ZERO;
			//
			// for(GuiaPagamentoPrestacao guiaPagamentoPrestacao : colecaoGuiaPagamentoPrestacao){
			// totalValorGuiaPagamentoPrestacao =
			// totalValorGuiaPagamentoPrestacao.add(guiaPagamentoPrestacao.getValorPrestacao());
			// }
			valorCredito = pagamento.getValorPagamento().subtract(totalValorGuiaPagamentoPrestacao);
		}else{
			// 1.2.2.2. Caso não exista, Valor do crédito = Valor do pagamento.
			valorCredito = pagamento.getValorPagamento();
		}
		return valorCredito;
	}

	/**
	 * [UC0266] Manter Pagamentos
	 * 1.2.3. Caso o débito a cobrar não seja NULL, pesquisar em DEBITO_A_COBRAR pelo Id do débito
	 * 
	 * @param pagamento
	 * @return
	 */
	private BigDecimal determinarValorCreditoQuandoPagamentoDebitoACobrar(Pagamento pagamento){

		BigDecimal valorCredito;
		if(Util.isNaoNuloBrancoZero(pagamento.getDebitoACobrar())){
			// 1.2.3.1. Caso exista, Valor do crédito = Valor do pagamento – Valor de
			// uma prestação do débito (Verificar tratamento realizado no caso de ser a
			// última parcela);
			valorCredito = pagamento.getValorPagamento().subtract(pagamento.getDebitoACobrar().verificarTratamentoRealizadoUltimaParcela());
		}else{
			// 1.2.3.2. Caso não exista, Valor do crédito = Valor do pagamento.
			valorCredito = pagamento.getValorPagamento();
		}
		return valorCredito;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.arrecadacao.IControladorArrecadacao#verificarAgenteCaixaDeEmpresa(java.lang.Integer,
	 * java.lang.Integer)
	 */
	public Boolean isAgenteCaixaDeEmpresaAutorizado(Integer idArrecadador, Integer idUsuario) throws ControladorException{

		Boolean retorno = Boolean.FALSE;

		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
		filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.ID, idArrecadador));

		Arrecadador arrecadador = (Arrecadador) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtroArrecadador,
						Arrecadador.class.getName()));

		if(arrecadador != null && arrecadador.getIndicadorCaixaEmpresa().equals(ConstantesSistema.SIM)){

			FiltroArrecadadorAgenteCaixa filtroArrecadadorAgenteCaixa = new FiltroArrecadadorAgenteCaixa();
			filtroArrecadadorAgenteCaixa
							.adicionarParametro(new ParametroSimples(filtroArrecadadorAgenteCaixa.ARRECADADOR_ID, idArrecadador));
			filtroArrecadadorAgenteCaixa.adicionarParametro(new ParametroSimples(filtroArrecadadorAgenteCaixa.USUARIO_ID, idUsuario));

			Collection<ArrecadadorAgenteCaixa> coll = this.getControladorUtil().pesquisar(filtroArrecadadorAgenteCaixa,
							ArrecadadorAgenteCaixa.class.getName());

			if(!coll.isEmpty()){

				retorno = Boolean.TRUE;

			}

		}else{

			retorno = Boolean.TRUE;

		}

		return retorno;

	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.arrecadacao.IControladorArrecadacao#existeAvisoArrecadadorTipoCaixaEmpresa(java.lang
	 * .Integer, java.util.Date)
	 */
	public Boolean existeAvisoArrecadadorTipoCaixaEmpresa(Integer idArrecadador, Date dataLancamento) throws ControladorException{

		Boolean retorno = Boolean.FALSE;

		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
		filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.ID, idArrecadador));

		Arrecadador arrecadador = (Arrecadador) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtroArrecadador,
						Arrecadador.class.getName()));

		if(arrecadador != null && arrecadador.getIndicadorCaixaEmpresa().equals(ConstantesSistema.SIM)){

			FiltroAvisoBancario filtroAvisoBancario = new FiltroAvisoBancario();
			filtroAvisoBancario.adicionarParametro(new ParametroSimples(FiltroAvisoBancario.DATA_LANCAMENTO, Util
							.zerarHoraMinutoSegundo(dataLancamento)));
			filtroAvisoBancario.adicionarParametro(new ParametroSimples(FiltroAvisoBancario.ARRECADADOR_ID, idArrecadador));

			Collection<AvisoBancario> collAvisoBancario = this.getControladorUtil().pesquisar(filtroAvisoBancario,
							AvisoBancario.class.getName());

			if(!collAvisoBancario.isEmpty()){

				retorno = Boolean.TRUE;

			}

		}

		return retorno;

	}

	/**
	 * Remuneração do Legado Cobrança Administrativa - CASAL
	 * 
	 * @author Hebert Falcão
	 * @date 22/0/2013
	 */
	public void ajusteRemuneracaoDoLegadoCobrancaAdministrativaCASAL() throws ControladorException{

		log.info("*** INICIO - ajusteRemuneracaoDoLegadoCobrancaAdministrativaCASAL ");

		FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroNulo(FiltroImovelCobrancaSituacao.DATA_RETIRADA_COBRANCA));
		filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
						CobrancaSituacao.COBRANCA_ADMINISTRATIVA));
		// filtroImovelCobrancaSituacao.adicionarParametro(new
		// ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, 16411200));

		Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(
						filtroImovelCobrancaSituacao, ImovelCobrancaSituacao.class.getName());

		if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){
			log.info("*** Quantidade registros ImovelCobrancaSituacao -  " + colecaoImovelCobrancaSituacao.size());

			int qtd = 0;
			int qtdAux = 0;

			Integer numeroUltimoAvisoBancario = 10613554;
			log.info("*** NumeroUltimoAvisoBancario: " + numeroUltimoAvisoBancario);

			Imovel imovel = null;
			Integer idImovel = null;

			FiltroPagamentoHistorico filtroPagamentoHistorico = null;
			Collection<PagamentoHistorico> colecaoPagamentoHistorico = null;
			Date dataPagamento = null;
			BigDecimal valorPagamento = null;
			Integer numeroPrestacaoPagamento = null;

			DocumentoTipo documentoTipo = null;

			Integer anoMesReferenciaArrecadacao = null;

			GuiaPagamentoGeral guiaPagamentoGeral = null;

			DebitoACobrar debitoACobrar = null;

			ContaHistorico contaHistorico = null;

			ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

			Collection colecaoImovelCobrancaAdministrivaItem = new ArrayList();

			// Calcular a remuneração da cobrança administrativa

			for(ImovelCobrancaSituacao imovelCobrancaSituacao : colecaoImovelCobrancaSituacao){

				imovel = imovelCobrancaSituacao.getImovel();

				if(imovel != null){
					qtd = qtd + 1;
					qtdAux = qtdAux + 1;

					if(qtdAux == 1000){
						log.info("*** Registros processados: " + qtd);
						qtdAux = 0;
					}

					idImovel = imovel.getId();

					// Obter os pagamentos do imóvel

					filtroPagamentoHistorico = new FiltroPagamentoHistorico(FiltroPagamentoHistorico.DATA_PAGAMENTO);
					filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.IMOVEL_ID, idImovel));
					filtroPagamentoHistorico.adicionarParametro(new MaiorQue(FiltroPagamentoHistorico.AVISO_BANCARIO_ID,
									numeroUltimoAvisoBancario));
					filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.CONTA);
					filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.GUIA_PAGAMENTO_GERAL);
					// filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.GUIA_PAGAMENTO_HISTORICO);

					colecaoPagamentoHistorico = this.getControladorUtil().pesquisar(filtroPagamentoHistorico,
									PagamentoHistorico.class.getName());

					if(!Util.isVazioOrNulo(colecaoPagamentoHistorico)){
						for(PagamentoHistorico pagamentoHistorico : colecaoPagamentoHistorico){

							dataPagamento = pagamentoHistorico.getDataPagamento();

							valorPagamento = pagamentoHistorico.getValorPagamento();

							contaHistorico = pagamentoHistorico.getConta();

							guiaPagamentoGeral = pagamentoHistorico.getGuiaPagamentoGeral();

							debitoACobrar = pagamentoHistorico.getDebitoACobrar();

							numeroPrestacaoPagamento = pagamentoHistorico.getNumeroPrestacao();

							documentoTipo = pagamentoHistorico.getDocumentoTipo();

							anoMesReferenciaArrecadacao = pagamentoHistorico.getAnoMesReferenciaArrecadacao();

							imovelCobrancaAdministrivaItem = null;

							if(contaHistorico != null){
								// Caso o item pago seja uma CONTA

								imovelCobrancaAdministrivaItem = this.cobrancaAdministrativaContaModelo1(dataPagamento, valorPagamento,
												contaHistorico, imovelCobrancaSituacao, documentoTipo, anoMesReferenciaArrecadacao);

							}else if(guiaPagamentoGeral != null){
								// Caso o item pago seja uma PRESTAÇÃO DE GUIA DE PAGAMENTO

								imovelCobrancaAdministrivaItem = this.processarCobrancaAdministrativaGuiaPagamentoModelo1(dataPagamento,
												valorPagamento, numeroPrestacaoPagamento, guiaPagamentoGeral, imovelCobrancaSituacao,
												documentoTipo, anoMesReferenciaArrecadacao);

							}else if(debitoACobrar != null){
								// Caso o item pago seja um DÉBITO A COBRAR

								imovelCobrancaAdministrivaItem = this.processarCobrancaAdministrativaDebitoACobrarModelo1(dataPagamento,
												valorPagamento, debitoACobrar, imovelCobrancaSituacao, documentoTipo,
												anoMesReferenciaArrecadacao);
							}

							if(imovelCobrancaAdministrivaItem != null){
								colecaoImovelCobrancaAdministrivaItem.add(imovelCobrancaAdministrivaItem);
							}
						}
					}
				}
			}

			if(!Util.isVazioOrNulo(colecaoImovelCobrancaAdministrivaItem)){
				log.info("*** Incluindo ImovelCobrancaAdministrivaItem - " + colecaoImovelCobrancaAdministrivaItem.size());

				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoImovelCobrancaAdministrivaItem);
			}
		}

		log.info("*** FIM - ajusteRemuneracaoDoLegadoCobrancaAdministrativaCASAL ");
	}

	/**
	 * Processar Cobrança Administrativa - Conta
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	private ImovelCobrancaAdministrivaItem cobrancaAdministrativaContaModelo1(Date dataPagamento, BigDecimal valorPagamento,
					ContaHistorico contaHistorico, ImovelCobrancaSituacao imovelCobrancaSituacao, DocumentoTipo documentoTipo,
					Integer anoMesReferenciaArrecadacao) throws ControladorException{

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

		Integer idConta = contaHistorico.getId();
		Integer idGuiaPagamento = null;
		Integer numeroPrestacao = null;
		Integer idDebitoACobrar = null;
		BigDecimal percentualRemuneracao = null;
		BigDecimal valorRemuneracao = null;
		BigDecimal valorBaseRemuneracao = null;
		BigDecimal percentualRemuneracaoReincidente = null;
		BigDecimal valorRemuneracaoReincidente = null;
		BigDecimal valorBaseRemuneracaoReincidente = null;
		BigDecimal percentualRemuneracaoEspecial = null;
		BigDecimal valorRemuneracaoEspecial = null;
		BigDecimal valorBaseRemuneracaoEspecial = null;
		BigDecimal percentualRemuneracaoParcelado = null;
		BigDecimal valorRemuneracaoParcelado = null;
		BigDecimal valorBaseRemuneracaoParcelado = null;
		BigDecimal valorArrecadadoLote = null;

		BigDecimal percentualAuxiliar = null;
		BigDecimal valorAuxiliar = null;

		Short indicadorCobrancaAdministrativa = contaHistorico.getIndicadorCobrancaAdministrativa();
		Short indicadorRemuneraCobrancaAdministrativa = contaHistorico.getIndicadorRemuneraCobrancaAdministrativa();

		// Caso a conta esteja marcada na cobrança administrativa ou esteja marcada como remunerável

		if((indicadorCobrancaAdministrativa != null && indicadorCobrancaAdministrativa.equals(ConstantesSistema.SIM))
						|| (indicadorRemuneraCobrancaAdministrativa != null && indicadorRemuneraCobrancaAdministrativa
										.equals(ConstantesSistema.SIM))){

			percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

			valorAuxiliar = valorPagamento.multiply(percentualAuxiliar);
			valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

			// [SB0001 – Gerar Remuneração]
			percentualRemuneracao = percentualAuxiliar;
			valorRemuneracao = valorAuxiliar;
			valorBaseRemuneracao = valorPagamento;

			imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento, numeroPrestacao,
							idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
							percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
							percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
							percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado, dataPagamento,
							documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao, valorArrecadadoLote);
		}else{
			BigDecimal valorDebitos = contaHistorico.getValorDebitos();

			if(valorDebitos != null && valorDebitos.compareTo(BigDecimal.ZERO) > 0){

				BigDecimal valorPrestacao = null;
				BigDecimal valorTotalPrestacao = null;

				// Condição 1 - Caso a conta contenha algum débito remunerável de parcelamento

				Collection<Integer> colecaoDebitoTipo = this.retornarDebitoTipoRemuneravelDeParcelamentoModelo1();

				FiltroDebitoCobradoHistorico filtroDebitoCobradoHistorico = new FiltroDebitoCobradoHistorico();
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoCobradoHistorico.CONTA_HISTORICO_ID,
								idConta));
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimplesColecao(FiltroDebitoCobradoHistorico.DEBITO_TIPO_ID,
								colecaoDebitoTipo));
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(
								FiltroDebitoCobradoHistorico.INDICADOR_REMUNERA_COBRANCA_ADMINISTRATIVA, ConstantesSistema.SIM));

				Collection<DebitoCobradoHistorico> colecaoDebitoCobradoHistorico = this.getControladorUtil().pesquisar(
								filtroDebitoCobradoHistorico, DebitoCobradoHistorico.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoCobradoHistorico)){
					percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

					valorTotalPrestacao = BigDecimal.ZERO;

					for(DebitoCobradoHistorico debitoCobradoHistorico : colecaoDebitoCobradoHistorico){
						valorPrestacao = debitoCobradoHistorico.getValorPrestacao();

						if(valorPrestacao != null && valorPrestacao.compareTo(BigDecimal.ZERO) > 0){
							valorTotalPrestacao = valorTotalPrestacao.add(valorPrestacao);
						}
					}

					valorAuxiliar = valorTotalPrestacao.multiply(percentualAuxiliar);
					valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

					// Remuneração
					percentualRemuneracaoParcelado = percentualAuxiliar;
					valorRemuneracaoParcelado = valorAuxiliar;
					valorBaseRemuneracaoParcelado = valorTotalPrestacao;
				}

				// Condição 2 - Caso a conta contenha algum débito remunerável de acréscimos

				colecaoDebitoTipo = this.retornarDebitoTipoAcrescimos();

				filtroDebitoCobradoHistorico = new FiltroDebitoCobradoHistorico();
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoCobradoHistorico.CONTA_HISTORICO_ID,
								idConta));
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimplesColecao(FiltroDebitoCobradoHistorico.DEBITO_TIPO_ID,
								colecaoDebitoTipo));
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(
								FiltroDebitoCobradoHistorico.INDICADOR_REMUNERA_COBRANCA_ADMINISTRATIVA, ConstantesSistema.SIM));

				colecaoDebitoCobradoHistorico = this.getControladorUtil().pesquisar(filtroDebitoCobradoHistorico,
								DebitoCobradoHistorico.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoCobradoHistorico)){
					percentualAuxiliar = null;

					CobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando = imovelCobrancaSituacao.getCobrancaAcaoAtividadeComando();

					if(cobrancaAcaoAtividadeComando != null){
						Integer idCobrancaAcaoAtividadeComando = cobrancaAcaoAtividadeComando.getId();

						try{
							percentualAuxiliar = repositorioArrecadacao.retornarPercentualRemuneracaoReincidencia(
											idCobrancaAcaoAtividadeComando, dataPagamento);
						}catch(ErroRepositorioException e){
							throw new ControladorException("erro.sistema", e);
						}
					}

					if(percentualAuxiliar != null){
						valorTotalPrestacao = BigDecimal.ZERO;

						for(DebitoCobradoHistorico debitoCobradoHistorico : colecaoDebitoCobradoHistorico){
							valorPrestacao = debitoCobradoHistorico.getValorPrestacao();

							if(valorPrestacao != null && valorPrestacao.compareTo(BigDecimal.ZERO) > 0){
								valorTotalPrestacao = valorTotalPrestacao.add(valorPrestacao);
							}
						}

						BigDecimal valorAgua = contaHistorico.getValorAgua();

						if(valorAgua == null){
							valorAgua = BigDecimal.ZERO;
						}

						BigDecimal valorEsgoto = contaHistorico.getValorEsgoto();

						if(valorEsgoto == null){
							valorEsgoto = BigDecimal.ZERO;
						}

						valorTotalPrestacao = valorTotalPrestacao.add(valorAgua);
						valorTotalPrestacao = valorTotalPrestacao.add(valorEsgoto);

						valorAuxiliar = valorTotalPrestacao.multiply(percentualAuxiliar);
						valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

						// Remuneração
						percentualRemuneracaoReincidente = percentualAuxiliar;
						valorRemuneracaoReincidente = valorAuxiliar;
						valorBaseRemuneracaoReincidente = valorTotalPrestacao;
					}
				}

				// Condição 3 - Caso a conta contenha algum débito remunerável de serviços especiais

				colecaoDebitoTipo = retornarDebitoTipoServicosEspeciais();

				filtroDebitoCobradoHistorico = new FiltroDebitoCobradoHistorico();
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoCobradoHistorico.CONTA_HISTORICO_ID,
								idConta));
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimplesColecao(FiltroDebitoCobradoHistorico.DEBITO_TIPO_ID,
								colecaoDebitoTipo));
				filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(
								FiltroDebitoCobradoHistorico.INDICADOR_REMUNERA_COBRANCA_ADMINISTRATIVA, ConstantesSistema.SIM));

				colecaoDebitoCobradoHistorico = this.getControladorUtil().pesquisar(filtroDebitoCobradoHistorico,
								DebitoCobradoHistorico.class.getName());

				if(!Util.isVazioOrNulo(colecaoDebitoCobradoHistorico)){
					percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

					valorTotalPrestacao = BigDecimal.ZERO;

					for(DebitoCobradoHistorico debitoCobradoHistorico : colecaoDebitoCobradoHistorico){
						valorPrestacao = debitoCobradoHistorico.getValorPrestacao();

						if(valorPrestacao != null && valorPrestacao.compareTo(BigDecimal.ZERO) > 0){
							valorTotalPrestacao = valorTotalPrestacao.add(valorPrestacao);
						}
					}

					valorAuxiliar = valorTotalPrestacao.multiply(percentualAuxiliar);
					valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

					// Remuneração
					percentualRemuneracaoEspecial = percentualAuxiliar;
					valorRemuneracaoEspecial = valorAuxiliar;
					valorBaseRemuneracaoEspecial = valorTotalPrestacao;
				}

				if(percentualRemuneracaoParcelado != null || percentualRemuneracaoReincidente != null
								|| percentualRemuneracaoEspecial != null){
					// [SB0001 – Gerar Remuneração]

					imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento, numeroPrestacao,
									idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
									percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
									percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
									percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado,
									dataPagamento, documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao, valorArrecadadoLote);
				}
			}
		}

		return imovelCobrancaAdministrivaItem;
	}

	/**
	 * Processar Cobrança Administrativa - Guia Pagamento
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	private ImovelCobrancaAdministrivaItem processarCobrancaAdministrativaGuiaPagamentoModelo1(Date dataPagamento,
					BigDecimal valorPagamento, Integer numeroPrestacaoPagamento, GuiaPagamentoGeral guiaPagamentoGeral,
					ImovelCobrancaSituacao imovelCobrancaSituacao, DocumentoTipo documentoTipo, Integer anoMesReferenciaArrecadacao)
					throws ControladorException{

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

		Integer idConta = null;
		Integer idGuiaPagamento = null;
		Integer numeroPrestacao = numeroPrestacaoPagamento;
		Integer idDebitoACobrar = null;
		BigDecimal percentualRemuneracao = null;
		BigDecimal valorRemuneracao = null;
		BigDecimal valorBaseRemuneracao = null;
		BigDecimal percentualRemuneracaoReincidente = null;
		BigDecimal valorRemuneracaoReincidente = null;
		BigDecimal valorBaseRemuneracaoReincidente = null;
		BigDecimal percentualRemuneracaoEspecial = null;
		BigDecimal valorRemuneracaoEspecial = null;
		BigDecimal valorBaseRemuneracaoEspecial = null;
		BigDecimal percentualRemuneracaoParcelado = null;
		BigDecimal valorRemuneracaoParcelado = null;
		BigDecimal valorBaseRemuneracaoParcelado = null;
		BigDecimal valorArrecadadoLote = null;

		BigDecimal percentualAuxiliar = null;
		BigDecimal valorAuxiliar = null;

		Short indicadorCobrancaAdministrativa = null;
		Short indicadorRemuneraCobrancaAdministrativa = null;

		BigDecimal valorPrestacao = null;

		FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico;
		Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico;
		GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico;

		if(guiaPagamentoGeral != null && numeroPrestacaoPagamento != null){
			idGuiaPagamento = guiaPagamentoGeral.getId();

			filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
			filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
							FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
			filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
							FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacaoPagamento));

			colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil().pesquisar(filtroGuiaPagamentoPrestacaoHistorico,
							GuiaPagamentoPrestacaoHistorico.class.getName());

			if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){
				guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) Util
								.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHistorico);

				indicadorCobrancaAdministrativa = guiaPagamentoPrestacaoHistorico.getIndicadorCobrancaAdministrativa();
				indicadorRemuneraCobrancaAdministrativa = guiaPagamentoPrestacaoHistorico.getIndicadorRemuneraCobrancaAdministrativa();

				// Caso a prestação esteja marcada na cobrança administrativa ou esteja marcada como
				// remunerável

				if((indicadorCobrancaAdministrativa != null && indicadorCobrancaAdministrativa.equals(ConstantesSistema.SIM))
								|| (indicadorRemuneraCobrancaAdministrativa != null && indicadorRemuneraCobrancaAdministrativa
												.equals(ConstantesSistema.SIM))){

					DebitoTipo debitoTipoAux = null;
					Integer idDebitoTipoAux = null;

					Collection<Integer> colecaoDebitoTipoParcelamento = this.retornarDebitoTipoRemuneravelDeParcelamentoModelo1();
					colecaoDebitoTipoParcelamento.add(DebitoTipo.ENTRADA_PARCELAMENTO);
					colecaoDebitoTipoParcelamento.add(DebitoTipo.ENTRADA_PARCELAMENTO_COBRANCA_ADMINISTRATIVA);

					Collection<Integer> colecaoDebitoTipoServicosEspecias = this.retornarDebitoTipoServicosEspeciais();

					BigDecimal valorTotalPrestacaoRemuneracaoParcelado = null;
					BigDecimal valorTotalPrestacaoRemuneracaoEspecial = null;
					BigDecimal valorTotalPrestacaoRemuneracao = null;

					for(GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistoricoAux : colecaoGuiaPagamentoPrestacaoHistorico){
						debitoTipoAux = guiaPagamentoPrestacaoHistoricoAux.getDebitoTipo();

						if(debitoTipoAux != null){
							idDebitoTipoAux = debitoTipoAux.getId();

							valorPrestacao = guiaPagamentoPrestacaoHistoricoAux.getValorPrestacao();

							if(valorPrestacao != null && valorPrestacao.compareTo(BigDecimal.ZERO) > 0){
								if(colecaoDebitoTipoParcelamento.contains(idDebitoTipoAux)){
									// Caso a prestação paga tenha algum tipo de débito de
									// parcelamento

									if(valorTotalPrestacaoRemuneracaoParcelado == null){
										valorTotalPrestacaoRemuneracaoParcelado = BigDecimal.ZERO;
									}

									valorTotalPrestacaoRemuneracaoParcelado = valorTotalPrestacaoRemuneracaoParcelado.add(valorPrestacao);

								}else if(colecaoDebitoTipoServicosEspecias.contains(idDebitoTipoAux)){
									// Caso a prestação paga tenha algum tipo de débito de serviços
									// especiais

									if(valorTotalPrestacaoRemuneracaoEspecial == null){
										valorTotalPrestacaoRemuneracaoEspecial = BigDecimal.ZERO;
									}

									valorTotalPrestacaoRemuneracaoEspecial = valorTotalPrestacaoRemuneracaoEspecial.add(valorPrestacao);

								}else{
									// Caso a prestação paga tenha algum tipo de débito que não seja
									// de parcelamento, nem de serviços especiais

									if(valorTotalPrestacaoRemuneracao == null){
										valorTotalPrestacaoRemuneracao = BigDecimal.ZERO;
									}

									valorTotalPrestacaoRemuneracao = valorTotalPrestacaoRemuneracao.add(valorPrestacao);
								}
							}
						}
					}

					// Caso a prestação paga tenha algum tipo de débito de parcelamento

					if(valorTotalPrestacaoRemuneracaoParcelado != null){
						percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

						valorAuxiliar = valorTotalPrestacaoRemuneracaoParcelado.multiply(percentualAuxiliar);
						valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

						percentualRemuneracaoParcelado = percentualAuxiliar;
						valorRemuneracaoParcelado = valorAuxiliar;
						valorBaseRemuneracaoParcelado = valorTotalPrestacaoRemuneracaoParcelado;
					}

					// Caso a prestação paga tenha algum tipo de débito de serviços especiais

					if(valorTotalPrestacaoRemuneracaoEspecial != null){
						percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

						valorAuxiliar = valorTotalPrestacaoRemuneracaoEspecial.multiply(percentualAuxiliar);
						valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

						percentualRemuneracaoEspecial = percentualAuxiliar;
						valorRemuneracaoEspecial = valorAuxiliar;
						valorBaseRemuneracaoEspecial = valorTotalPrestacaoRemuneracaoEspecial;
					}

					// Caso a prestação paga tenha algum tipo de débito que não seja de
					// parcelamento, nem de serviços especiais

					if(valorTotalPrestacaoRemuneracao != null){
						percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

						valorAuxiliar = valorTotalPrestacaoRemuneracao.multiply(percentualAuxiliar);
						valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

						percentualRemuneracao = percentualAuxiliar;
						valorRemuneracao = valorAuxiliar;
						valorBaseRemuneracao = valorTotalPrestacaoRemuneracao;
					}

					// [SB0001 – Gerar Remuneração]

					imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento, numeroPrestacao,
									idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
									percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
									percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
									percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado,
									dataPagamento, documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao, valorArrecadadoLote);
				}
			}
		}

		return imovelCobrancaAdministrivaItem;
	}

	/**
	 * Processar Cobrança Administrativa - Débito a Cobrar
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	private ImovelCobrancaAdministrivaItem processarCobrancaAdministrativaDebitoACobrarModelo1(Date dataPagamento,
					BigDecimal valorPagamento, DebitoACobrar debitoACobrar, ImovelCobrancaSituacao imovelCobrancaSituacao,
					DocumentoTipo documentoTipo, Integer anoMesReferenciaArrecadacao) throws ControladorException{

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

		Integer idConta = null;
		Integer idGuiaPagamento = null;
		Integer numeroPrestacao = null;
		Integer idDebitoACobrar = debitoACobrar.getId();
		BigDecimal percentualRemuneracao = null;
		BigDecimal valorRemuneracao = null;
		BigDecimal valorBaseRemuneracao = null;
		BigDecimal percentualRemuneracaoReincidente = null;
		BigDecimal valorRemuneracaoReincidente = null;
		BigDecimal valorBaseRemuneracaoReincidente = null;
		BigDecimal percentualRemuneracaoEspecial = null;
		BigDecimal valorRemuneracaoEspecial = null;
		BigDecimal valorBaseRemuneracaoEspecial = null;
		BigDecimal percentualRemuneracaoParcelado = null;
		BigDecimal valorRemuneracaoParcelado = null;
		BigDecimal valorBaseRemuneracaoParcelado = null;
		BigDecimal valorArrecadadoLote = null;

		BigDecimal percentualAuxiliar = null;
		BigDecimal valorAuxiliar = null;

		Short indicadorRemuneraCobrancaAdministrativa = null;

		DebitoTipo debitoTipo = null;

		FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.ID, idDebitoACobrar));

		Collection<DebitoACobrarHistorico> colecaoDebitoACobrarHistorico = this.getControladorUtil().pesquisar(
						filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());

		if(!Util.isVazioOrNulo(colecaoDebitoACobrarHistorico)){
			DebitoACobrarHistorico debitoACobrarHistorico = (DebitoACobrarHistorico) Util
							.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico);

			indicadorRemuneraCobrancaAdministrativa = debitoACobrarHistorico.getIndicadorRemuneraCobrancaAdministrativa();

			debitoTipo = debitoACobrarHistorico.getDebitoTipo();
		}else{
			FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
			filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));

			Collection<DebitoACobrar> colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar,
							DebitoACobrar.class.getName());

			if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){
				debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);

				indicadorRemuneraCobrancaAdministrativa = debitoACobrar.getIndicadorRemuneraCobrancaAdministrativa();

				debitoTipo = debitoACobrar.getDebitoTipo();
			}
		}

		// Caso o débito a cobrar esteja marcado como remunerável

		if(indicadorRemuneraCobrancaAdministrativa != null && indicadorRemuneraCobrancaAdministrativa.equals(ConstantesSistema.SIM)){

			if(debitoTipo != null){
				Integer idDebitoTipo = debitoTipo.getId();

				Collection<Integer> colecaoDebitoTipo = this.retornarDebitoTipoRemuneravelDeParcelamentoModelo1();

				if(colecaoDebitoTipo.contains(idDebitoTipo)){
					// Caso o débito a cobrar pago seja de parcelamento

					percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

					valorAuxiliar = valorPagamento.multiply(percentualAuxiliar);
					valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

					// [SB0001 – Gerar Remuneração]
					percentualRemuneracaoParcelado = percentualAuxiliar;
					valorRemuneracaoParcelado = valorAuxiliar;
					valorBaseRemuneracaoParcelado = valorPagamento;

					imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento, numeroPrestacao,
									idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
									percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
									percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
									percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado,
									dataPagamento, documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao, valorArrecadadoLote);
				}else{

					colecaoDebitoTipo = this.retornarDebitoTipoServicosEspeciais();

					if(colecaoDebitoTipo.contains(idDebitoTipo)){
						// Caso a débito a cobrar pago seja de serviços especiais

						percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

						valorAuxiliar = valorPagamento.multiply(percentualAuxiliar);
						valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

						// [SB0001 – Gerar Remuneração]
						percentualRemuneracaoEspecial = percentualAuxiliar;
						valorRemuneracaoEspecial = valorAuxiliar;
						valorBaseRemuneracaoEspecial = valorPagamento;

						imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento,
										numeroPrestacao, idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
										percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
										percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
										percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado,
										dataPagamento, documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao,
										valorArrecadadoLote);
					}else{
						colecaoDebitoTipo = this.retornarDebitoTipoAcrescimos();

						if(colecaoDebitoTipo.contains(idDebitoTipo)){
							// Caso a débito a cobrar pago seja de acréscimos

							percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

							valorAuxiliar = valorPagamento.multiply(percentualAuxiliar);
							valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

							// [SB0001 – Gerar Remuneração]
							percentualRemuneracaoReincidente = percentualAuxiliar;
							valorRemuneracaoReincidente = valorAuxiliar;
							valorBaseRemuneracaoReincidente = valorPagamento;

							imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento,
											numeroPrestacao, idDebitoACobrar, percentualRemuneracao, valorRemuneracao,
											valorBaseRemuneracao, percentualRemuneracaoReincidente, valorRemuneracaoReincidente,
											valorBaseRemuneracaoReincidente, percentualRemuneracaoEspecial, valorRemuneracaoEspecial,
											valorBaseRemuneracaoEspecial, percentualRemuneracaoParcelado, valorRemuneracaoParcelado,
											valorBaseRemuneracaoParcelado, dataPagamento, documentoTipo, imovelCobrancaSituacao,
											anoMesReferenciaArrecadacao, valorArrecadadoLote);
						}else{

							// Caso a débito a cobrar pago não seja de parcelamento, nem de serviços
							// especiais, nem de acréscimos

							percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

							valorAuxiliar = valorPagamento.multiply(percentualAuxiliar);
							valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

							// [SB0001 – Gerar Remuneração]
							percentualRemuneracao = percentualAuxiliar;
							valorRemuneracao = valorAuxiliar;
							valorBaseRemuneracao = valorPagamento;

							imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento,
											numeroPrestacao, idDebitoACobrar, percentualRemuneracao, valorRemuneracao,
											valorBaseRemuneracao, percentualRemuneracaoReincidente, valorRemuneracaoReincidente,
											valorBaseRemuneracaoReincidente, percentualRemuneracaoEspecial, valorRemuneracaoEspecial,
											valorBaseRemuneracaoEspecial, percentualRemuneracaoParcelado, valorRemuneracaoParcelado,
											valorBaseRemuneracaoParcelado, dataPagamento, documentoTipo, imovelCobrancaSituacao,
											anoMesReferenciaArrecadacao, valorArrecadadoLote);
						}
					}

				}
			}
		}

		return imovelCobrancaAdministrivaItem;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB9000] Gerar Remuneração
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	private ImovelCobrancaAdministrivaItem gerarImovelCobrancaAdministrivaItem(Integer idConta, Integer idGuiaPagamento,
					Integer numeroPrestacao, Integer idDebitoACobrar, BigDecimal percentualRemuneracao, BigDecimal valorRemuneracao,
					BigDecimal valorBaseRemuneracao, BigDecimal percentualRemuneracaoReincidente, BigDecimal valorRemuneracaoReincidente,
					BigDecimal valorBaseRemuneracaoReincidente, BigDecimal percentualRemuneracaoEspecial,
					BigDecimal valorRemuneracaoEspecial, BigDecimal valorBaseRemuneracaoEspecial,
					BigDecimal percentualRemuneracaoParcelado, BigDecimal valorRemuneracaoParcelado,
					BigDecimal valorBaseRemuneracaoParcelado, Date dataPagamento, DocumentoTipo documentoTipo,
					ImovelCobrancaSituacao imovelCobrancaSituacao, Integer anoMesReferenciaArrecadacao, BigDecimal valorArrecadadoLote){

		ContaGeral contaGeral = null;

		if(idConta != null){
			contaGeral = new ContaGeral();
			contaGeral.setId(idConta);
		}

		GuiaPagamentoGeral guiaPagamentoGeral = null;

		if(idGuiaPagamento != null){
			guiaPagamentoGeral = new GuiaPagamentoGeral();
			guiaPagamentoGeral.setId(idGuiaPagamento);
		}

		DebitoACobrarGeral debitoACobrarGeral = null;

		if(idDebitoACobrar != null){
			debitoACobrarGeral = new DebitoACobrarGeral();
			debitoACobrarGeral.setId(idDebitoACobrar);
		}

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = new ImovelCobrancaAdministrivaItem();

		imovelCobrancaAdministrivaItem.setImovelCobrancaSituacao(imovelCobrancaSituacao);
		imovelCobrancaAdministrivaItem.setDocumentoTipo(documentoTipo);
		imovelCobrancaAdministrivaItem.setContaGeral(contaGeral);
		imovelCobrancaAdministrivaItem.setGuiaPagamentoGeral(guiaPagamentoGeral);
		imovelCobrancaAdministrivaItem.setNumeroPrestacao(numeroPrestacao);
		imovelCobrancaAdministrivaItem.setDebitoACobrarGeral(debitoACobrarGeral);

		imovelCobrancaAdministrivaItem.setPercentualRemuneracao(percentualRemuneracao);
		imovelCobrancaAdministrivaItem.setValorRemuneracao(valorRemuneracao);
		imovelCobrancaAdministrivaItem.setValorBaseRemuneracao(valorBaseRemuneracao);

		imovelCobrancaAdministrivaItem.setPercentualRemuneracaoReincidente(percentualRemuneracaoReincidente);
		imovelCobrancaAdministrivaItem.setValorRemuneracaoReincidente(valorRemuneracaoReincidente);
		imovelCobrancaAdministrivaItem.setValorBaseRemuneracaoReincidente(valorBaseRemuneracaoReincidente);

		imovelCobrancaAdministrivaItem.setPercentualRemuneracaoEspecial(percentualRemuneracaoEspecial);
		imovelCobrancaAdministrivaItem.setValorRemuneracaoEspecial(valorRemuneracaoEspecial);
		imovelCobrancaAdministrivaItem.setValorBaseRemuneracaoEspecial(valorBaseRemuneracaoEspecial);

		imovelCobrancaAdministrivaItem.setPercentualRemuneracaoParcelado(percentualRemuneracaoParcelado);
		imovelCobrancaAdministrivaItem.setValorRemuneracaoParcelado(valorRemuneracaoParcelado);
		imovelCobrancaAdministrivaItem.setValorBaseRemuneracaoParcelado(valorBaseRemuneracaoParcelado);

		imovelCobrancaAdministrivaItem.setUltimaAlteracao(new Date());
		imovelCobrancaAdministrivaItem.setDataPagamentoDocumento(dataPagamento);
		imovelCobrancaAdministrivaItem.setIndicadorRemuneracaoPaga(ConstantesSistema.NAO);
		imovelCobrancaAdministrivaItem.setDataPagamentoRemuneracao(null);
		imovelCobrancaAdministrivaItem.setAnoMesReferenciaArrecadacao(anoMesReferenciaArrecadacao);

		if(valorArrecadadoLote == null){
			valorArrecadadoLote = BigDecimal.ZERO;
		}

		imovelCobrancaAdministrivaItem.setValorArrecadadoLote(valorArrecadadoLote);

		imovelCobrancaAdministrivaItem.setCobrancaAdministrativaRemuneracaoMensal(null);

		return imovelCobrancaAdministrivaItem;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Tipos de Débito Remunerável de Parcelamento
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	private Collection<Integer> retornarDebitoTipoRemuneravelDeParcelamentoModelo1() throws ControladorException{

		Collection<Integer> colecaoDebitoTipo = new ArrayList<Integer>();

		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_CONTA_COBRANCA_ADMINISTRATIVA.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_GUIA_PAGAMENTO_COBRANCA_ADMINISTRATIVA
						.executar()));
		colecaoDebitoTipo.add(Integer
						.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_ACRESCIMO_IMPONTUALIDADE_COBRANCA_ADMINISTRATIVA
						.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_JUROS_PARCELAMENTO_COBRANCA_ADMINISTRATIVA
						.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_CONTA.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_GUIA_PAGAMENTO.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_ACRESCIMO_IMPONTUALIDADE.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_FINANCIAMENTO.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_PARCELAMENTO.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_JUROS_PARCELAMENTO.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_PARCELAMENTO_COBRANCA_ADMINISTRATIVA
						.executar()));

		return colecaoDebitoTipo;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Tipos de Débito de Acréscimos
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	private Collection<Integer> retornarDebitoTipoAcrescimos(){

		Collection<Integer> colecaoDebitoTipo = new ArrayList<Integer>();

		colecaoDebitoTipo.add(DebitoTipo.MULTA_IMPONTUALIDADE);
		colecaoDebitoTipo.add(DebitoTipo.ATUALIZACAO_MONETARIA);
		colecaoDebitoTipo.add(DebitoTipo.JUROS_MORA);

		return colecaoDebitoTipo;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Tipos de Débito de Serviços Especiais
	 * 
	 * @author Hebert Falcão
	 * @date 22/05/2013
	 */
	private Collection<Integer> retornarDebitoTipoServicosEspeciais() throws ControladorException{

		Collection<Integer> colecaoDebitoTipo = new ArrayList<Integer>();

		String parametroServicosEspeciaisCobrancaAdministrativa = ParametroArrecadacao.P_SERVICOS_ESPECIAIS_COBRANCA_ADMINISTRATIVA
						.executar().toString();

		String[] arrayParametroServicosEspeciaisCobrancaAdministrativa = parametroServicosEspeciaisCobrancaAdministrativa.split(",");

		if(!Util.isVazioOrNulo(arrayParametroServicosEspeciaisCobrancaAdministrativa)){
			for(int i = 0; i < arrayParametroServicosEspeciaisCobrancaAdministrativa.length; i++){
				colecaoDebitoTipo.add(Integer.valueOf(arrayParametroServicosEspeciaisCobrancaAdministrativa[i]));
			}
		}

		return colecaoDebitoTipo;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB2000] Gerar Remuneração Cobrança Administrativa - Modelo 1
	 * 
	 * @author Hebert Falcão
	 * @date 24/05/2013
	 */
	public void gerarRemuneracaoCobrancaAdministrativaModelo1(Integer idPagamento) throws ControladorException{

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

		Integer idConta = null;
		Integer idGuiaPagamento = null;
		Integer numeroPrestacao = null;
		Integer idDebitoACobrar = null;
		BigDecimal percentualRemuneracao = null;
		BigDecimal valorRemuneracao = null;
		BigDecimal valorBaseRemuneracao = null;
		BigDecimal percentualRemuneracaoReincidente = null;
		BigDecimal valorRemuneracaoReincidente = null;
		BigDecimal valorBaseRemuneracaoReincidente = null;
		BigDecimal percentualRemuneracaoEspecial = null;
		BigDecimal valorRemuneracaoEspecial = null;
		BigDecimal valorBaseRemuneracaoEspecial = null;
		BigDecimal percentualRemuneracaoParcelado = null;
		BigDecimal valorRemuneracaoParcelado = null;
		BigDecimal valorBaseRemuneracaoParcelado = null;
		BigDecimal valorArrecadadoLote = null;

		BigDecimal percentualAuxiliar = null;
		BigDecimal valorAuxiliar = null;

		FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
		filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.ID, idPagamento));
		filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.CONTA);
		filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.GUIA_PAGAMENTO_GERAL);

		Collection<PagamentoHistorico> colecaoPagamentoHistorico = this.getControladorUtil().pesquisar(filtroPagamentoHistorico,
						PagamentoHistorico.class.getName());

		if(!Util.isVazioOrNulo(colecaoPagamentoHistorico)){
			PagamentoHistorico pagamentoHistorico = (PagamentoHistorico) Util.retonarObjetoDeColecao(colecaoPagamentoHistorico);

			BigDecimal valorPagamento = pagamentoHistorico.getValorPagamento();

			Integer numeroPrestacaoPagamento = pagamentoHistorico.getNumeroPrestacao();

			DocumentoTipo documentoTipo = pagamentoHistorico.getDocumentoTipo();

			Imovel imovel = pagamentoHistorico.getImovel();

			Date dataPagamento = pagamentoHistorico.getDataPagamento();

			ContaHistorico contaHistorico = pagamentoHistorico.getConta();

			GuiaPagamentoGeral guiaPagamentoGeral = pagamentoHistorico.getGuiaPagamentoGeral();

			DebitoACobrar debitoACobrar = pagamentoHistorico.getDebitoACobrar();

			Integer anoMesReferenciaArrecadacao = pagamentoHistorico.getAnoMesReferenciaArrecadacao();

			if(contaHistorico != null){
				idConta = contaHistorico.getId();
			}else if(guiaPagamentoGeral != null && numeroPrestacaoPagamento != null){
				idGuiaPagamento = guiaPagamentoGeral.getId();
				numeroPrestacao = numeroPrestacaoPagamento;
			}else if(debitoACobrar != null){
				idDebitoACobrar = debitoACobrar.getId();
			}

			if(imovel != null){
				Integer idImovel = imovel.getId();

				// Verifica se imóvel já esteve na cobrança administrativa

				FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
				filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, idImovel));
				filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
								CobrancaSituacao.COBRANCA_ADMINISTRATIVA));

				Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(
								filtroImovelCobrancaSituacao, ImovelCobrancaSituacao.class.getName());

				if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){

					// Verifica se o imóvel está na cobrança administrativa

					filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, idImovel));
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroNulo(FiltroImovelCobrancaSituacao.DATA_RETIRADA_COBRANCA));
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
									CobrancaSituacao.COBRANCA_ADMINISTRATIVA));

					Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacaoAtivo = this.getControladorUtil().pesquisar(
									filtroImovelCobrancaSituacao, ImovelCobrancaSituacao.class.getName());

					if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacaoAtivo)){
						ImovelCobrancaSituacao imovelCobrancaSituacao = (ImovelCobrancaSituacao) Util
										.retonarObjetoDeColecao(colecaoImovelCobrancaSituacaoAtivo);

						// Caso o imóvel esteja na cobrança administrativa

						percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

						valorAuxiliar = valorPagamento.multiply(percentualAuxiliar);
						valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

						// [SB0020 – Gerar Remuneração]

						percentualRemuneracao = percentualAuxiliar;
						valorRemuneracao = valorAuxiliar;
						valorBaseRemuneracao = valorPagamento;

						imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento,
										numeroPrestacao, idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
										percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
										percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
										percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado,
										dataPagamento, documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao,
										valorArrecadadoLote);

						this.getControladorUtil().inserir(imovelCobrancaAdministrivaItem);
					}else{

						// Caso o imóvel NÃO esteja na cobrança administrativa

						ImovelCobrancaSituacao imovelCobrancaSituacao = null;
						ImovelCobrancaSituacao maiorImovelCobrancaSituacao = null;

						Integer idImovelCobrancaSituacaoAux = null;
						Integer maiorIdImovelCobrancaSituacao = null;

						Date dataImplantacaoCobranca = null;
						Date dataRetiradaCobranca = null;

						for(ImovelCobrancaSituacao imovelCobrancaSituacaoAux : colecaoImovelCobrancaSituacao){
							dataImplantacaoCobranca = imovelCobrancaSituacaoAux.getDataImplantacaoCobranca();
							dataRetiradaCobranca = imovelCobrancaSituacaoAux.getDataRetiradaCobranca();

							if(dataImplantacaoCobranca != null && dataRetiradaCobranca != null
											&& dataPagamento.compareTo(dataImplantacaoCobranca) >= 0
											&& dataPagamento.compareTo(dataRetiradaCobranca) <= 0){

								// Pagamento realizado em um dos períodos da cobrança administrativa
								// do imóvel

								imovelCobrancaSituacao = imovelCobrancaSituacaoAux;

								break;
							}else{
								// Armazena o registro com maior Id

								idImovelCobrancaSituacaoAux = imovelCobrancaSituacaoAux.getId();

								if(maiorIdImovelCobrancaSituacao == null || idImovelCobrancaSituacaoAux > maiorIdImovelCobrancaSituacao){
									maiorIdImovelCobrancaSituacao = idImovelCobrancaSituacaoAux;
									maiorImovelCobrancaSituacao = imovelCobrancaSituacaoAux;
								}
							}
						}

						if(imovelCobrancaSituacao != null){
							// Caso o pagamento tenha sido realizado em um dos períodos da cobrança
							// administrativa

							percentualAuxiliar = imovelCobrancaSituacao.getPercentualRemuneracao();

							valorAuxiliar = valorPagamento.multiply(percentualAuxiliar);
							valorAuxiliar = valorAuxiliar.divide(new BigDecimal("100"));

							// [SB0020 – Gerar Remuneração]

							percentualRemuneracao = percentualAuxiliar;
							valorRemuneracao = valorAuxiliar;
							valorBaseRemuneracao = valorPagamento;

							imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento,
											numeroPrestacao, idDebitoACobrar, percentualRemuneracao, valorRemuneracao,
											valorBaseRemuneracao, percentualRemuneracaoReincidente, valorRemuneracaoReincidente,
											valorBaseRemuneracaoReincidente, percentualRemuneracaoEspecial, valorRemuneracaoEspecial,
											valorBaseRemuneracaoEspecial, percentualRemuneracaoParcelado, valorRemuneracaoParcelado,
											valorBaseRemuneracaoParcelado, dataPagamento, documentoTipo, imovelCobrancaSituacao,
											anoMesReferenciaArrecadacao, valorArrecadadoLote);

							this.getControladorUtil().inserir(imovelCobrancaAdministrivaItem);
						}else{
							// Caso o pagamento NÃO tenha sido realizado em nenhum dos períodos da
							// cobrança administrativa

							imovelCobrancaSituacao = maiorImovelCobrancaSituacao;

							if(contaHistorico != null){
								// Caso o item pago seja uma CONTA

								imovelCobrancaAdministrivaItem = this.cobrancaAdministrativaContaModelo1(dataPagamento, valorPagamento,
												contaHistorico, imovelCobrancaSituacao, documentoTipo, anoMesReferenciaArrecadacao);

							}else if(guiaPagamentoGeral != null){
								// Caso o item pago seja uma PRESTAÇÃO DE GUIA DE PAGAMENTO

								imovelCobrancaAdministrivaItem = this.processarCobrancaAdministrativaGuiaPagamentoModelo1(dataPagamento,
												valorPagamento, numeroPrestacaoPagamento, guiaPagamentoGeral, imovelCobrancaSituacao,
												documentoTipo, anoMesReferenciaArrecadacao);

							}else if(debitoACobrar != null){
								// Caso o item pago seja um DÉBITO A COBRAR

								imovelCobrancaAdministrivaItem = this.processarCobrancaAdministrativaDebitoACobrarModelo1(dataPagamento,
												valorPagamento, debitoACobrar, imovelCobrancaSituacao, documentoTipo,
												anoMesReferenciaArrecadacao);
							}

							if(imovelCobrancaAdministrivaItem != null){
								this.getControladorUtil().inserir(imovelCobrancaAdministrivaItem);
							}
						}
					}
				}
			}
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB1000] Gerar Remuneração Acréscimos para Cobrança Administrativa - Modelo 1
	 * 
	 * @author Hebert Falcão
	 * @date 24/05/2013
	 */
	public boolean gerarRemuneracaoAcrescimosParaCobrancaAdministrativaModelo1(Pagamento pagamento) throws ControladorException{

		boolean atualizarRemuneraCobrancaAdministrativa = false;

		Integer idImovel = null;
		Imovel imovel = pagamento.getImovel();

		if(imovel != null){
			idImovel = imovel.getId();
		}

		Date dataPagamento = pagamento.getDataPagamento();

		Date dataVencimento = null;
		Short indicadorMarcacaoCobrancaAdministrativa = null;
		Short indicadorRemuneracaoCobrancaAdministrativa = null;

		Conta conta = pagamento.getConta();

		if(conta != null){
			Integer idConta = conta.getId();

			FiltroConta filtroConta = new FiltroConta();
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, idConta));

			Collection<Conta> colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

			if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){
				conta = (Conta) Util.retonarObjetoDeColecao(colecaoImovelCobrancaSituacao);

				dataVencimento = conta.getDataVencimentoConta();
				indicadorMarcacaoCobrancaAdministrativa = conta.getIndicadorCobrancaAdministrativa();
				indicadorRemuneracaoCobrancaAdministrativa = conta.getIndicadorRemuneraCobrancaAdministrativa();
			}
		}

		Integer numeroPrestacao = pagamento.getNumeroPrestacao();

		GuiaPagamentoGeral guiaPagamentoGeral = pagamento.getGuiaPagamentoGeral();

		if(guiaPagamentoGeral != null && numeroPrestacao != null){
			Integer idGuiaPagamentoGeral = guiaPagamentoGeral.getId();

			FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
							idGuiaPagamentoGeral));
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
							numeroPrestacao));

			Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = this.getControladorUtil().pesquisar(
							filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

			if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){
				GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) Util
								.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);

				dataVencimento = guiaPagamentoPrestacao.getDataVencimento();
				indicadorMarcacaoCobrancaAdministrativa = guiaPagamentoPrestacao.getIndicadorCobrancaAdministrativa();
				indicadorRemuneracaoCobrancaAdministrativa = guiaPagamentoPrestacao.getIndicadorRemuneraCobrancaAdministrativa();
			}
		}

		if(idImovel != null && dataVencimento != null && indicadorMarcacaoCobrancaAdministrativa != null
						&& indicadorRemuneracaoCobrancaAdministrativa != null && dataPagamento != null){

			// Verifica se o imóvel já esteve na cobrança administrativa

			FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
			filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, idImovel));
			filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
							CobrancaSituacao.COBRANCA_ADMINISTRATIVA));

			Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(
							filtroImovelCobrancaSituacao, ImovelCobrancaSituacao.class.getName());

			if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){

				// Verifica o número de dias de atraso do pagamento do item recebido em relação ao
				// número de dias mínimo determinado para remuneração dos acréscimos

				Long numeroDiasAtrasoLong = Util.diferencaDias(dataVencimento, dataPagamento);
				Integer numeroDiasAtraso = numeroDiasAtrasoLong.intValue();

				ImovelCobrancaSituacao imovelCobrancaSituacao = null;

				Integer idImovelCobrancaSituacaoAux = null;
				Integer maiorIdImovelCobrancaSituacao = null;

				Date dataImplantacaoCobranca = null;
				Date dataRetiradaCobranca = null;

				boolean pagamentoRealizadoEmUmPeriodoDaCobranca = false;

				// Obter número de dias mínimo determinado para remuneração dos acréscimos

				for(ImovelCobrancaSituacao imovelCobrancaSituacaoAux : colecaoImovelCobrancaSituacao){
					dataImplantacaoCobranca = imovelCobrancaSituacaoAux.getDataImplantacaoCobranca();
					dataRetiradaCobranca = imovelCobrancaSituacaoAux.getDataRetiradaCobranca();

					if((dataImplantacaoCobranca != null && dataPagamento.compareTo(dataImplantacaoCobranca) >= 0
									&& dataRetiradaCobranca != null && dataPagamento.compareTo(dataRetiradaCobranca) <= 0)
									|| (dataImplantacaoCobranca != null && dataPagamento.compareTo(dataImplantacaoCobranca) >= 0 && dataRetiradaCobranca == null)){

						// Pagamento realizado em um dos períodos da cobrança administrativa do
						// imóvel

						imovelCobrancaSituacao = imovelCobrancaSituacaoAux;

						pagamentoRealizadoEmUmPeriodoDaCobranca = true;

						break;
					}else{
						// Armazena o registro com maior Id

						idImovelCobrancaSituacaoAux = imovelCobrancaSituacaoAux.getId();

						if(maiorIdImovelCobrancaSituacao == null || idImovelCobrancaSituacaoAux > maiorIdImovelCobrancaSituacao){
							maiorIdImovelCobrancaSituacao = idImovelCobrancaSituacaoAux;
							imovelCobrancaSituacao = imovelCobrancaSituacaoAux;
						}
					}
				}

				if(imovelCobrancaSituacao != null){
					CobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando = imovelCobrancaSituacao.getCobrancaAcaoAtividadeComando();

					if(cobrancaAcaoAtividadeComando != null){
						Integer idCobrancaAcaoAtividadeComando = cobrancaAcaoAtividadeComando.getId();

						// Número de dias mínimo determinado para remuneração dos acréscimos

						Integer numeroDiasMinimo = null;

						try{
							numeroDiasMinimo = repositorioArrecadacao.retornarNumeroDeDiasMinimoDeterminadoParaRemuneracaoAcrescimos(
											idCobrancaAcaoAtividadeComando, dataPagamento);
						}catch(ErroRepositorioException e){
							throw new ControladorException("erro.sistema", e);
						}

						if(numeroDiasAtraso != null && numeroDiasMinimo != null && numeroDiasAtraso >= numeroDiasMinimo){

							// Verifica a marcação da remuneração dos acréscimos em relação à
							// situação do item recebido

							if((indicadorMarcacaoCobrancaAdministrativa.equals(ConstantesSistema.SIM))
											|| (indicadorRemuneracaoCobrancaAdministrativa.equals(ConstantesSistema.SIM))
											|| (indicadorMarcacaoCobrancaAdministrativa.equals(ConstantesSistema.NAO)
															&& indicadorRemuneracaoCobrancaAdministrativa.equals(ConstantesSistema.NAO) && pagamentoRealizadoEmUmPeriodoDaCobranca)){

								// Marcar a remuneração dos acréscimos

								atualizarRemuneraCobrancaAdministrativa = true;
							}
						}

					}
				}
			}
		}

		return atualizarRemuneraCobrancaAdministrativa;
	}

	/**
	 * @param idImovel
	 * @param idCobrancaSituacao
	 * @param prazoGeracao
	 * @return
	 * @throws ControladorException
	 */
	public Integer pesquisarImovelCobrancaSituacao(Integer idImovel, Integer idCobrancaSituacao, Integer prazoGeracao)
					throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarImovelCobrancaSituacao(idImovel, idCobrancaSituacao, prazoGeracao);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public void atualizarVencimentoGuiaPagamentoPrestacao(
					HashMap<GuiaPagamentoPrestacaoHelper, Date> hashMapGuiasPrestacoesVencimentoAlterado)
					throws ControladorException{
		
		// iterar sobre a hash
		Set<GuiaPagamentoPrestacaoHelper> chaves = hashMapGuiasPrestacoesVencimentoAlterado.keySet();
		for(GuiaPagamentoPrestacaoHelper guiaPagamentoPrestacaoHelper : chaves){
			
			FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(filtroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID, guiaPagamentoPrestacaoHelper.getIdGuiaPagamento()));
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(filtroGuiaPagamentoPrestacao.NUMERO_PRESTACAO, guiaPagamentoPrestacaoHelper.getNumeroPrestacao()));
	
			Collection colecaoGuiaPagamentoPrestacoesBase = getControladorUtil().pesquisar(filtroGuiaPagamentoPrestacao,
							GuiaPagamentoPrestacao.class.getName());
	
			if(colecaoGuiaPagamentoPrestacoesBase == null || colecaoGuiaPagamentoPrestacoesBase.isEmpty()){

				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");

			}else{
				for(Object objeto : colecaoGuiaPagamentoPrestacoesBase){
					GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) objeto;

					guiaPagamentoPrestacao.setUltimaAlteracao(new Date());
					guiaPagamentoPrestacao.setDataVencimento(hashMapGuiasPrestacoesVencimentoAlterado.get(guiaPagamentoPrestacaoHelper));

					getControladorUtil().atualizar(guiaPagamentoPrestacao);

				}
			}
	
		}
	}

	public Collection<Object[]> pesquisarConcessionariaPorArrecadadorMovimento(Integer idArrecadadorMovimento) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarConcessionariaPorArrecadadorMovimento(idArrecadadorMovimento);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Comprovantes da Arrecadação por Recebedor
	 * 
	 * @author Hebert Falcão
	 * @since 28/09/2013
	 */
	public Integer pesquisarComprovantesDaArrecadacaoPorRecebedorCount(Integer anoMesReferencia) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarComprovantesDaArrecadacaoPorRecebedorCount(anoMesReferencia);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Comprovantes da Arrecadação por Recebedor
	 * 
	 * @author Hebert Falcão
	 * @since 28/09/2013
	 */
	public Collection<Object[]> pesquisarComprovantesDaArrecadacaoPorRecebedorSintetico(Integer anoMesReferencia)
					throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarComprovantesDaArrecadacaoPorRecebedorSintetico(anoMesReferencia);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Comprovantes da Arrecadação por Recebedor
	 * 
	 * @author Hebert Falcão
	 * @since 28/09/2013
	 */
	public Collection<Object[]> pesquisarComprovantesDaArrecadacaoPorRecebedorAnalitico(Integer anoMesReferencia)
					throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarComprovantesDaArrecadacaoPorRecebedorAnalitico(anoMesReferencia);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Situação dos avisos bancários
	 * 
	 * @author Hebert Falcão
	 * @since 04/10/2013
	 */
	public int pesquisarSituacaoDosAvisosBancariosCount(Integer anoMesReferencia) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarSituacaoDosAvisosBancariosCount(anoMesReferencia);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Situação dos avisos bancários
	 * 
	 * @author Hebert Falcão
	 * @since 04/10/2013
	 */
	public Collection<Object[]> pesquisarSituacaoDosAvisosBancarios(Integer anoMesReferencia) throws ControladorException{

		try{
			return repositorioArrecadacao.pesquisarSituacaoDosAvisosBancarios(anoMesReferencia);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB2001] Gerar Remuneração Cobrança Administrativa - Modelo 2
	 * 
	 * @author Hebert Falcão
	 * @date 09/11/2013
	 */
	public void gerarRemuneracaoCobrancaAdministrativaModelo2(Integer idPagamento) throws ControladorException{

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

		Integer idConta = null;
		Integer idGuiaPagamento = null;
		Integer numeroPrestacao = null;
		Integer idDebitoACobrar = null;
		BigDecimal percentualRemuneracao = null;
		BigDecimal valorRemuneracao = null;
		BigDecimal valorBaseRemuneracao = null;
		BigDecimal percentualRemuneracaoReincidente = null;
		BigDecimal valorRemuneracaoReincidente = null;
		BigDecimal valorBaseRemuneracaoReincidente = null;
		BigDecimal percentualRemuneracaoEspecial = null;
		BigDecimal valorRemuneracaoEspecial = null;
		BigDecimal valorBaseRemuneracaoEspecial = null;
		BigDecimal percentualRemuneracaoParcelado = null;
		BigDecimal valorRemuneracaoParcelado = null;
		BigDecimal valorBaseRemuneracaoParcelado = null;
		BigDecimal valorArrecadadoLote = null;

		FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
		filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.ID, idPagamento));
		filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.CONTA);
		filtroPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamentoHistorico.GUIA_PAGAMENTO_GERAL);

		Collection<PagamentoHistorico> colecaoPagamentoHistorico = this.getControladorUtil().pesquisar(filtroPagamentoHistorico,
						PagamentoHistorico.class.getName());

		if(!Util.isVazioOrNulo(colecaoPagamentoHistorico)){
			PagamentoHistorico pagamentoHistorico = (PagamentoHistorico) Util.retonarObjetoDeColecao(colecaoPagamentoHistorico);

			BigDecimal valorPagamento = pagamentoHistorico.getValorPagamento();

			Integer numeroPrestacaoPagamento = pagamentoHistorico.getNumeroPrestacao();

			DocumentoTipo documentoTipo = pagamentoHistorico.getDocumentoTipo();

			Imovel imovel = pagamentoHistorico.getImovel();

			Date dataPagamento = pagamentoHistorico.getDataPagamento();

			ContaHistorico contaHistorico = pagamentoHistorico.getConta();

			GuiaPagamentoGeral guiaPagamentoGeral = pagamentoHistorico.getGuiaPagamentoGeral();

			DebitoACobrar debitoACobrar = pagamentoHistorico.getDebitoACobrar();

			Integer anoMesReferenciaArrecadacao = pagamentoHistorico.getAnoMesReferenciaArrecadacao();

			if(contaHistorico != null){
				idConta = contaHistorico.getId();
			}else if(guiaPagamentoGeral != null && numeroPrestacaoPagamento != null){
				idGuiaPagamento = guiaPagamentoGeral.getId();
				numeroPrestacao = numeroPrestacaoPagamento;
			}else if(debitoACobrar != null){
				idDebitoACobrar = debitoACobrar.getId();
			}

			if(imovel != null){
				Integer idImovel = imovel.getId();

				// Verifica se imóvel já esteve na cobrança administrativa

				FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
				filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, idImovel));
				filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
								CobrancaSituacao.COBRANCA_ADMINISTRATIVA));
				filtroImovelCobrancaSituacao
								.adicionarCaminhoParaCarregamentoEntidade(FiltroImovelCobrancaSituacao.COBRANCA_ACAO_ATIVIDADE_COMANDO);

				Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(
								filtroImovelCobrancaSituacao, ImovelCobrancaSituacao.class.getName());

				if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){
					ImovelCobrancaSituacao imovelCobrancaSituacao = null;

					Integer idImovelCobrancaSituacaoAux = null;
					Integer maiorIdImovelCobrancaSituacao = null;

					Date dataImplantacaoCobranca = null;
					Date dataRetiradaCobranca = null;

					for(ImovelCobrancaSituacao imovelCobrancaSituacaoAux : colecaoImovelCobrancaSituacao){
						dataImplantacaoCobranca = imovelCobrancaSituacaoAux.getDataImplantacaoCobranca();
						dataRetiradaCobranca = imovelCobrancaSituacaoAux.getDataRetiradaCobranca();

						if((dataImplantacaoCobranca != null && dataPagamento.compareTo(dataImplantacaoCobranca) >= 0
										&& dataRetiradaCobranca != null && dataPagamento.compareTo(dataRetiradaCobranca) <= 0)
										|| (dataImplantacaoCobranca != null && dataPagamento.compareTo(dataImplantacaoCobranca) >= 0 && dataRetiradaCobranca == null)){

							// Pagamento realizado em um dos períodos da cobrança administrativa do
							// imóvel

							imovelCobrancaSituacao = imovelCobrancaSituacaoAux;

							break;
						}else{
							// Armazena o registro com maior Id

							idImovelCobrancaSituacaoAux = imovelCobrancaSituacaoAux.getId();

							if(maiorIdImovelCobrancaSituacao == null || idImovelCobrancaSituacaoAux > maiorIdImovelCobrancaSituacao){
								maiorIdImovelCobrancaSituacao = idImovelCobrancaSituacaoAux;
								imovelCobrancaSituacao = imovelCobrancaSituacaoAux;
							}
						}
					}

					if(imovelCobrancaSituacao != null){
						CobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando = imovelCobrancaSituacao
										.getCobrancaAcaoAtividadeComando();

						if(cobrancaAcaoAtividadeComando != null){
							Empresa empresa = cobrancaAcaoAtividadeComando.getEmpresa();

							if(empresa != null){
								Integer idEmpresa = empresa.getId();

								FiltroCobrancaContrato filtroCobrancaContrato = new FiltroCobrancaContrato();
								filtroCobrancaContrato
												.adicionarParametro(new ParametroSimples(FiltroCobrancaContrato.EMPRESA_ID, idEmpresa));

								Collection<CobrancaContrato> colecaoCobrancaContrato = this.getControladorUtil().pesquisar(
												filtroCobrancaContrato, CobrancaContrato.class.getName());

								if(!Util.isVazioOrNulo(colecaoCobrancaContrato)){
									Date dataContratoInicio = null;
									Date dataContratoFim = null;

									boolean pagamentoRealizadoEmUmDosPeriodos = false;

									for(CobrancaContrato cobrancaContrato : colecaoCobrancaContrato){
										dataContratoInicio = cobrancaContrato.getDataInicial();
										dataContratoFim = cobrancaContrato.getDataFinal();

										if((dataContratoInicio != null && dataPagamento.compareTo(dataContratoInicio) >= 0
														&& dataContratoFim != null && dataPagamento.compareTo(dataContratoFim) <= 0)
														|| (dataContratoInicio != null && dataPagamento.compareTo(dataContratoInicio) >= 0 && dataContratoFim == null)){

											// Pagamento realizado em um dos períodos de vigência do
											// contrato da cobrança administrativa da empresa
											// responsável pela cobrança do item

											pagamentoRealizadoEmUmDosPeriodos = true;

											break;
										}
									}

									if(pagamentoRealizadoEmUmDosPeriodos){

										Short indicadorCobrancaAdministrativa = null;

										if(contaHistorico != null){
											indicadorCobrancaAdministrativa = contaHistorico.getIndicadorCobrancaAdministrativa();
										}else if(guiaPagamentoGeral != null){
											FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
											filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
															FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
											filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
															FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacao));

											Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = this
															.getControladorUtil().pesquisar(filtroGuiaPagamentoPrestacaoHistorico,
																			GuiaPagamentoPrestacaoHistorico.class.getName());

											if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){
												GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) Util
																.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHistorico);

												indicadorCobrancaAdministrativa = guiaPagamentoPrestacaoHistorico
																.getIndicadorCobrancaAdministrativa();
											}
										}

										// Caso o item esteja marcado na cobrança administrativa

										if(indicadorCobrancaAdministrativa != null
														&& indicadorCobrancaAdministrativa.equals(ConstantesSistema.SIM)){

											// [SB9000 - Gerar Remuneração]

											valorBaseRemuneracao = valorPagamento;
											valorArrecadadoLote = valorPagamento;

											imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta,
															idGuiaPagamento, numeroPrestacao, idDebitoACobrar, percentualRemuneracao,
															valorRemuneracao, valorBaseRemuneracao, percentualRemuneracaoReincidente,
															valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
															percentualRemuneracaoEspecial, valorRemuneracaoEspecial,
															valorBaseRemuneracaoEspecial, percentualRemuneracaoParcelado,
															valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado, dataPagamento,
															documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao,
															valorArrecadadoLote);
										}else{
											if(contaHistorico != null){
												// Caso o item pago seja uma CONTA

												imovelCobrancaAdministrivaItem = this.cobrancaAdministrativaContaModelo2(dataPagamento,
																valorPagamento, contaHistorico, imovelCobrancaSituacao, documentoTipo,
																anoMesReferenciaArrecadacao);

											}else if(guiaPagamentoGeral != null){
												// Caso o item pago seja uma PRESTAÇÃO DE GUIA DE
												// PAGAMENTO

												imovelCobrancaAdministrivaItem = this.processarCobrancaAdministrativaGuiaPagamentoModelo2(
																dataPagamento, valorPagamento, numeroPrestacaoPagamento,
																guiaPagamentoGeral, imovelCobrancaSituacao, documentoTipo,
																anoMesReferenciaArrecadacao);

											}else if(debitoACobrar != null){
												// Caso o item pago seja um DÉBITO A COBRAR

												imovelCobrancaAdministrivaItem = this.processarCobrancaAdministrativaDebitoACobrarModelo2(
																dataPagamento, valorPagamento, debitoACobrar, imovelCobrancaSituacao,
																documentoTipo, anoMesReferenciaArrecadacao);
											}
										}

										if(imovelCobrancaAdministrivaItem != null){
											this.getControladorUtil().inserir(imovelCobrancaAdministrivaItem);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Processar Cobrança Administrativa - Conta
	 * 
	 * @author Hebert Falcão
	 * @date 10/11/2013
	 */
	private ImovelCobrancaAdministrivaItem cobrancaAdministrativaContaModelo2(Date dataPagamento, BigDecimal valorPagamento,
					ContaHistorico contaHistorico, ImovelCobrancaSituacao imovelCobrancaSituacao, DocumentoTipo documentoTipo,
					Integer anoMesReferenciaArrecadacao) throws ControladorException{

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

		Integer idConta = contaHistorico.getId();
		Integer idGuiaPagamento = null;
		Integer numeroPrestacao = null;
		Integer idDebitoACobrar = null;
		BigDecimal percentualRemuneracao = null;
		BigDecimal valorRemuneracao = null;
		BigDecimal valorBaseRemuneracao = null;
		BigDecimal percentualRemuneracaoReincidente = null;
		BigDecimal valorRemuneracaoReincidente = null;
		BigDecimal valorBaseRemuneracaoReincidente = null;
		BigDecimal percentualRemuneracaoEspecial = null;
		BigDecimal valorRemuneracaoEspecial = null;
		BigDecimal valorBaseRemuneracaoEspecial = null;
		BigDecimal percentualRemuneracaoParcelado = null;
		BigDecimal valorRemuneracaoParcelado = null;
		BigDecimal valorBaseRemuneracaoParcelado = null;
		BigDecimal valorArrecadadoLote = null;

		Short indicadorRemuneraCobrancaAdministrativa = contaHistorico.getIndicadorRemuneraCobrancaAdministrativa();

		BigDecimal valorPrestacao = null;

		DebitoTipo debitoTipo = null;
		Integer idDebitoTipo = null;

		// Caso a conta esteja marcada como remunerável

		FiltroDebitoCobradoHistorico filtroDebitoCobradoHistorico = null;
		Collection<DebitoCobradoHistorico> colecaoDebitoCobradoHistorico = null;

		if(indicadorRemuneraCobrancaAdministrativa != null && indicadorRemuneraCobrancaAdministrativa.equals(ConstantesSistema.SIM)){

			valorBaseRemuneracao = valorPagamento;
			valorArrecadadoLote = BigDecimal.ZERO;

			Collection<Integer> colecaoDebitoTipo = this.retornarDebitoTipoRemuneravelDeParcelamentoModelo2();

			filtroDebitoCobradoHistorico = new FiltroDebitoCobradoHistorico();
			filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoCobradoHistorico.CONTA_HISTORICO_ID, idConta));
			filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimplesColecao(FiltroDebitoCobradoHistorico.DEBITO_TIPO_ID,
							colecaoDebitoTipo));
			filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(
							FiltroDebitoCobradoHistorico.INDICADOR_REMUNERA_COBRANCA_ADMINISTRATIVA, ConstantesSistema.SIM));

			colecaoDebitoCobradoHistorico = this.getControladorUtil().pesquisar(filtroDebitoCobradoHistorico,
							DebitoCobradoHistorico.class.getName());

			if(!Util.isVazioOrNulo(colecaoDebitoCobradoHistorico)){
				for(DebitoCobradoHistorico debitoCobradoHistorico : colecaoDebitoCobradoHistorico){
					valorPrestacao = debitoCobradoHistorico.getValorPrestacao();

					if(valorPrestacao != null && valorPrestacao.compareTo(BigDecimal.ZERO) > 0){
						valorArrecadadoLote = valorArrecadadoLote.add(valorPrestacao);
					}
				}
			}

			// [SB9000 - Gerar Remuneração]
			imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento, numeroPrestacao,
							idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
							percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
							percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
							percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado, dataPagamento,
							documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao, valorArrecadadoLote);
		}else{
			// Caso a conta tenha algum débito cobrado remunerável

			filtroDebitoCobradoHistorico = new FiltroDebitoCobradoHistorico();
			filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoCobradoHistorico.CONTA_HISTORICO_ID, idConta));
			filtroDebitoCobradoHistorico.adicionarParametro(new ParametroSimples(
							FiltroDebitoCobradoHistorico.INDICADOR_REMUNERA_COBRANCA_ADMINISTRATIVA, ConstantesSistema.SIM));

			colecaoDebitoCobradoHistorico = this.getControladorUtil().pesquisar(filtroDebitoCobradoHistorico,
							DebitoCobradoHistorico.class.getName());

			if(!Util.isVazioOrNulo(colecaoDebitoCobradoHistorico)){
				Collection<Integer> colecaoDebitoTipo = this.retornarDebitoTipoRemuneravelDeParcelamentoModelo2();

				valorBaseRemuneracao = BigDecimal.ZERO;
				valorArrecadadoLote = BigDecimal.ZERO;

				for(DebitoCobradoHistorico debitoCobradoHistorico : colecaoDebitoCobradoHistorico){
					valorPrestacao = debitoCobradoHistorico.getValorPrestacao();

					if(valorPrestacao != null && valorPrestacao.compareTo(BigDecimal.ZERO) > 0){
						// Somatório dos débitos cobrados remuneráveis
						valorBaseRemuneracao = valorBaseRemuneracao.add(valorPrestacao);

						debitoTipo = debitoCobradoHistorico.getDebitoTipo();

						if(debitoTipo != null){
							idDebitoTipo = debitoTipo.getId();

							if(colecaoDebitoTipo.contains(idDebitoTipo)){
								// Somatório dos débitos cobrados remuneráveis de parcelamento de
								// cobrança administrativa
								valorArrecadadoLote = valorArrecadadoLote.add(valorPrestacao);
							}

						}
					}
				}

				// [SB9000 - Gerar Remuneração]
				imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento, numeroPrestacao,
								idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
								percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
								percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
								percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado, dataPagamento,
								documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao, valorArrecadadoLote);
			}
		}

		return imovelCobrancaAdministrivaItem;
	}

	/**
	 * Processar Cobrança Administrativa - Guia Pagamento
	 * 
	 * @author Hebert Falcão
	 * @date 10/11/2013
	 */
	private ImovelCobrancaAdministrivaItem processarCobrancaAdministrativaGuiaPagamentoModelo2(Date dataPagamento,
					BigDecimal valorPagamento, Integer numeroPrestacaoPagamento, GuiaPagamentoGeral guiaPagamentoGeral,
					ImovelCobrancaSituacao imovelCobrancaSituacao, DocumentoTipo documentoTipo, Integer anoMesReferenciaArrecadacao)
					throws ControladorException{

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

		Integer idConta = null;
		Integer idGuiaPagamento = null;
		Integer numeroPrestacao = numeroPrestacaoPagamento;
		Integer idDebitoACobrar = null;
		BigDecimal percentualRemuneracao = null;
		BigDecimal valorRemuneracao = null;
		BigDecimal valorBaseRemuneracao = null;
		BigDecimal percentualRemuneracaoReincidente = null;
		BigDecimal valorRemuneracaoReincidente = null;
		BigDecimal valorBaseRemuneracaoReincidente = null;
		BigDecimal percentualRemuneracaoEspecial = null;
		BigDecimal valorRemuneracaoEspecial = null;
		BigDecimal valorBaseRemuneracaoEspecial = null;
		BigDecimal percentualRemuneracaoParcelado = null;
		BigDecimal valorRemuneracaoParcelado = null;
		BigDecimal valorBaseRemuneracaoParcelado = null;
		BigDecimal valorArrecadadoLote = null;

		Short indicadorRemuneraCobrancaAdministrativa = null;

		BigDecimal valorPrestacao = null;

		DebitoTipo debitoTipo = null;
		Integer idDebitoTipo = null;

		if(guiaPagamentoGeral != null && numeroPrestacaoPagamento != null){
			idGuiaPagamento = guiaPagamentoGeral.getId();

			FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
			filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
							FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
			filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
							FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacaoPagamento));

			Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil().pesquisar(
							filtroGuiaPagamentoPrestacaoHistorico, GuiaPagamentoPrestacaoHistorico.class.getName());

			if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){
				GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) Util
								.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHistorico);

				indicadorRemuneraCobrancaAdministrativa = guiaPagamentoPrestacaoHistorico.getIndicadorRemuneraCobrancaAdministrativa();

				// Caso a prestação esteja marcada como remunerável

				if(indicadorRemuneraCobrancaAdministrativa != null && indicadorRemuneraCobrancaAdministrativa.equals(ConstantesSistema.SIM)){

					boolean prestacaoEntradaDeParcelamento = false;

					DebitoCreditoSituacao debitoCreditoSituacao = guiaPagamentoPrestacaoHistorico.getDebitoCreditoSituacao();

					if(debitoCreditoSituacao != null){
						Integer idDebitoCreditoSituacao = debitoCreditoSituacao.getId();

						if(idDebitoCreditoSituacao.intValue() == DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO.intValue()){
							prestacaoEntradaDeParcelamento = true;
						}
					}

					filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
					filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
									FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, idGuiaPagamento));
					filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
									FiltroGuiaPagamentoPrestacaoHistorico.NUMERO_PRESTACAO, numeroPrestacaoPagamento));
					filtroGuiaPagamentoPrestacaoHistorico
									.adicionarParametro(new ParametroSimples(
													FiltroGuiaPagamentoPrestacaoHistorico.INDICADOR_REMUNERA_COBRANCA_ADMINISTRATIVA,
													ConstantesSistema.SIM));

					colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil().pesquisar(filtroGuiaPagamentoPrestacaoHistorico,
									GuiaPagamentoPrestacaoHistorico.class.getName());

					if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){
						valorBaseRemuneracao = BigDecimal.ZERO;
						valorArrecadadoLote = BigDecimal.ZERO;

						// Caso a prestação seja uma entrada de parcelamento

						if(prestacaoEntradaDeParcelamento){

							for(GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistoricoAux : colecaoGuiaPagamentoPrestacaoHistorico){
								valorPrestacao = guiaPagamentoPrestacaoHistoricoAux.getValorPrestacao();

								if(valorPrestacao != null && valorPrestacao.compareTo(BigDecimal.ZERO) > 0){
									// Somatório dos tipos de débitos remuneráveis
									valorBaseRemuneracao = valorBaseRemuneracao.add(valorPrestacao);

									debitoTipo = guiaPagamentoPrestacaoHistoricoAux.getDebitoTipo();

									if(debitoTipo != null){
										idDebitoTipo = debitoTipo.getId();

										if(idDebitoTipo.intValue() == DebitoTipo.ENTRADA_PARCELAMENTO_COBRANCA_ADMINISTRATIVA.intValue()){
											// Somatório dos tipos de débitos remuneráveis de
											// entrada de parcelamento da cobrança administrativa
											valorArrecadadoLote = valorArrecadadoLote.add(valorPrestacao);
										}
									}
								}
							}
						}else{
							Collection<Integer> colecaoDebitoTipo = this.retornarDebitoTipoRemuneravelDeParcelamentoModelo2();

							for(GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistoricoAux : colecaoGuiaPagamentoPrestacaoHistorico){
								valorPrestacao = guiaPagamentoPrestacaoHistoricoAux.getValorPrestacao();

								if(valorPrestacao != null && valorPrestacao.compareTo(BigDecimal.ZERO) > 0){
									// Somatório dos tipos de débitos remuneráveis
									valorBaseRemuneracao = valorBaseRemuneracao.add(valorPrestacao);

									debitoTipo = guiaPagamentoPrestacaoHistoricoAux.getDebitoTipo();

									if(debitoTipo != null){
										idDebitoTipo = debitoTipo.getId();

										if(colecaoDebitoTipo.contains(idDebitoTipo)){
											// Somatório dos tipos de débitos remuneráveis de
											// parcelamento da cobrança administrativa
											valorArrecadadoLote = valorArrecadadoLote.add(valorPrestacao);
										}
									}
								}
							}
						}

						// [SB9000 - Gerar Remuneração]
						imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento,
										numeroPrestacao, idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
										percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
										percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
										percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado,
										dataPagamento, documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao,
										valorArrecadadoLote);
					}
				}
			}
		}

		return imovelCobrancaAdministrivaItem;
	}

	/**
	 * Processar Cobrança Administrativa - Débito a Cobrar
	 * 
	 * @author Hebert Falcão
	 * @date 10/11/2013
	 */
	private ImovelCobrancaAdministrivaItem processarCobrancaAdministrativaDebitoACobrarModelo2(Date dataPagamento,
					BigDecimal valorPagamento, DebitoACobrar debitoACobrar, ImovelCobrancaSituacao imovelCobrancaSituacao,
					DocumentoTipo documentoTipo, Integer anoMesReferenciaArrecadacao) throws ControladorException{

		ImovelCobrancaAdministrivaItem imovelCobrancaAdministrivaItem = null;

		Integer idConta = null;
		Integer idGuiaPagamento = null;
		Integer numeroPrestacao = null;
		Integer idDebitoACobrar = debitoACobrar.getId();
		BigDecimal percentualRemuneracao = null;
		BigDecimal valorRemuneracao = null;
		BigDecimal valorBaseRemuneracao = null;
		BigDecimal percentualRemuneracaoReincidente = null;
		BigDecimal valorRemuneracaoReincidente = null;
		BigDecimal valorBaseRemuneracaoReincidente = null;
		BigDecimal percentualRemuneracaoEspecial = null;
		BigDecimal valorRemuneracaoEspecial = null;
		BigDecimal valorBaseRemuneracaoEspecial = null;
		BigDecimal percentualRemuneracaoParcelado = null;
		BigDecimal valorRemuneracaoParcelado = null;
		BigDecimal valorBaseRemuneracaoParcelado = null;
		BigDecimal valorArrecadadoLote = null;

		Short indicadorRemuneraCobrancaAdministrativa = null;

		DebitoTipo debitoTipo = null;

		FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.ID, idDebitoACobrar));

		Collection<DebitoACobrarHistorico> colecaoDebitoACobrarHistorico = this.getControladorUtil().pesquisar(
						filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());

		if(!Util.isVazioOrNulo(colecaoDebitoACobrarHistorico)){
			DebitoACobrarHistorico debitoACobrarHistorico = (DebitoACobrarHistorico) Util
							.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico);

			indicadorRemuneraCobrancaAdministrativa = debitoACobrarHistorico.getIndicadorRemuneraCobrancaAdministrativa();

			debitoTipo = debitoACobrarHistorico.getDebitoTipo();
		}else{
			FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
			filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));

			Collection<DebitoACobrar> colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar,
							DebitoACobrar.class.getName());

			if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){
				debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);

				indicadorRemuneraCobrancaAdministrativa = debitoACobrar.getIndicadorRemuneraCobrancaAdministrativa();

				debitoTipo = debitoACobrar.getDebitoTipo();
			}
		}

		// Caso o débito a cobrar esteja marcado como remunerável

		if(indicadorRemuneraCobrancaAdministrativa != null && indicadorRemuneraCobrancaAdministrativa.equals(ConstantesSistema.SIM)){

			valorBaseRemuneracao = valorPagamento;
			valorArrecadadoLote = BigDecimal.ZERO;

			if(debitoTipo != null){
				Integer idDebitoTipo = debitoTipo.getId();

				Collection<Integer> colecaoDebitoTipo = this.retornarDebitoTipoRemuneravelDeParcelamentoModelo2();

				if(colecaoDebitoTipo.contains(idDebitoTipo)){
					// Caso a débito a cobrar pago seja de parcelamento da cobrança administrativa

					valorArrecadadoLote = valorPagamento;
				}
			}

			imovelCobrancaAdministrivaItem = this.gerarImovelCobrancaAdministrivaItem(idConta, idGuiaPagamento, numeroPrestacao,
							idDebitoACobrar, percentualRemuneracao, valorRemuneracao, valorBaseRemuneracao,
							percentualRemuneracaoReincidente, valorRemuneracaoReincidente, valorBaseRemuneracaoReincidente,
							percentualRemuneracaoEspecial, valorRemuneracaoEspecial, valorBaseRemuneracaoEspecial,
							percentualRemuneracaoParcelado, valorRemuneracaoParcelado, valorBaseRemuneracaoParcelado, dataPagamento,
							documentoTipo, imovelCobrancaSituacao, anoMesReferenciaArrecadacao, valorArrecadadoLote);
		}

		return imovelCobrancaAdministrivaItem;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * [SB1001] Gerar Remuneração Acréscimos para Cobrança Administrativa - Modelo 2
	 * 
	 * @author Hebert Falcão
	 * @date 09/11/2013
	 */
	public boolean gerarRemuneracaoAcrescimosParaCobrancaAdministrativaModelo2(Pagamento pagamento) throws ControladorException{

		boolean atualizarRemuneraCobrancaAdministrativa = false;

		Integer idImovel = null;
		Imovel imovel = pagamento.getImovel();

		if(imovel != null){
			idImovel = imovel.getId();
		}

		Date dataPagamento = pagamento.getDataPagamento();

		Short indicadorCobrancaAdministrativa = null;

		Conta conta = pagamento.getConta();

		if(conta != null){
			Integer idConta = conta.getId();

			FiltroConta filtroConta = new FiltroConta();
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, idConta));

			Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

			if(!Util.isVazioOrNulo(colecaoConta)){
				conta = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

				indicadorCobrancaAdministrativa = conta.getIndicadorCobrancaAdministrativa();
			}
		}

		Integer numeroPrestacao = pagamento.getNumeroPrestacao();

		GuiaPagamentoGeral guiaPagamentoGeral = pagamento.getGuiaPagamentoGeral();

		if(guiaPagamentoGeral != null && numeroPrestacao != null){
			Integer idGuiaPagamentoGeral = guiaPagamentoGeral.getId();

			FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID,
							idGuiaPagamentoGeral));
			filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
							numeroPrestacao));

			Collection<GuiaPagamentoPrestacao> colecaoGuiaPagamentoPrestacao = this.getControladorUtil().pesquisar(
							filtroGuiaPagamentoPrestacao, GuiaPagamentoPrestacao.class.getName());

			if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacao)){
				GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) Util
								.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacao);

				indicadorCobrancaAdministrativa = guiaPagamentoPrestacao.getIndicadorCobrancaAdministrativa();
			}
		}

		if(indicadorCobrancaAdministrativa != null && indicadorCobrancaAdministrativa.equals(ConstantesSistema.SIM) && idImovel != null
						&& dataPagamento != null){

			// Verifica se o imóvel já esteve na cobrança administrativa

			FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
			filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, idImovel));
			filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.ID_COBRANCA_SITUACAO,
							CobrancaSituacao.COBRANCA_ADMINISTRATIVA));
			filtroImovelCobrancaSituacao
							.adicionarCaminhoParaCarregamentoEntidade(FiltroImovelCobrancaSituacao.COBRANCA_ACAO_ATIVIDADE_COMANDO);

			Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(
							filtroImovelCobrancaSituacao, ImovelCobrancaSituacao.class.getName());

			if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){
				ImovelCobrancaSituacao imovelCobrancaSituacao = null;

				Integer idImovelCobrancaSituacaoAux = null;
				Integer maiorIdImovelCobrancaSituacao = null;

				Date dataImplantacaoCobranca = null;
				Date dataRetiradaCobranca = null;

				for(ImovelCobrancaSituacao imovelCobrancaSituacaoAux : colecaoImovelCobrancaSituacao){
					dataImplantacaoCobranca = imovelCobrancaSituacaoAux.getDataImplantacaoCobranca();
					dataRetiradaCobranca = imovelCobrancaSituacaoAux.getDataRetiradaCobranca();

					if((dataImplantacaoCobranca != null && dataPagamento.compareTo(dataImplantacaoCobranca) >= 0
									&& dataRetiradaCobranca != null && dataPagamento.compareTo(dataRetiradaCobranca) <= 0)
									|| (dataImplantacaoCobranca != null && dataPagamento.compareTo(dataImplantacaoCobranca) >= 0 && dataRetiradaCobranca == null)){

						// Pagamento realizado em um dos períodos da cobrança administrativa do
						// imóvel

						imovelCobrancaSituacao = imovelCobrancaSituacaoAux;

						break;
					}else{
						// Armazena o registro com maior Id

						idImovelCobrancaSituacaoAux = imovelCobrancaSituacaoAux.getId();

						if(maiorIdImovelCobrancaSituacao == null || idImovelCobrancaSituacaoAux > maiorIdImovelCobrancaSituacao){
							maiorIdImovelCobrancaSituacao = idImovelCobrancaSituacaoAux;
							imovelCobrancaSituacao = imovelCobrancaSituacaoAux;
						}
					}
				}

				if(imovelCobrancaSituacao != null){
					CobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando = imovelCobrancaSituacao.getCobrancaAcaoAtividadeComando();

					if(cobrancaAcaoAtividadeComando != null){
						Empresa empresa = cobrancaAcaoAtividadeComando.getEmpresa();

						if(empresa != null){
							Integer idEmpresa = empresa.getId();

							FiltroCobrancaContrato filtroCobrancaContrato = new FiltroCobrancaContrato();
							filtroCobrancaContrato.adicionarParametro(new ParametroSimples(FiltroCobrancaContrato.EMPRESA_ID, idEmpresa));

							Collection<CobrancaContrato> colecaoCobrancaContrato = this.getControladorUtil().pesquisar(
											filtroCobrancaContrato, CobrancaContrato.class.getName());

							if(!Util.isVazioOrNulo(colecaoCobrancaContrato)){
								Date dataContratoInicio = null;
								Date dataContratoFim = null;

								for(CobrancaContrato cobrancaContrato : colecaoCobrancaContrato){
									dataContratoInicio = cobrancaContrato.getDataInicial();
									dataContratoFim = cobrancaContrato.getDataFinal();

									if((dataContratoInicio != null && dataPagamento.compareTo(dataContratoInicio) >= 0
													&& dataContratoFim != null && dataPagamento.compareTo(dataContratoFim) <= 0)
													|| (dataContratoInicio != null && dataPagamento.compareTo(dataContratoInicio) >= 0 && dataContratoFim == null)){

										// Pagamento realizado em um dos períodos de vigência do
										// contrato da cobrança administrativa da empresa
										// responsável pela cobrança do item

										atualizarRemuneraCobrancaAdministrativa = true;

										break;
									}
								}
							}
						}
					}
				}
			}
		}

		return atualizarRemuneraCobrancaAdministrativa;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * Tipos de Débito Remunerável de Parcelamento
	 * 
	 * @author Hebert Falcão
	 * @date 10/11/2013
	 */
	private Collection<Integer> retornarDebitoTipoRemuneravelDeParcelamentoModelo2() throws ControladorException{

		Collection<Integer> colecaoDebitoTipo = new ArrayList<Integer>();

		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_CONTA_COBRANCA_ADMINISTRATIVA.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_GUIA_PAGAMENTO_COBRANCA_ADMINISTRATIVA
						.executar()));
		colecaoDebitoTipo.add(Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_PARCELAMENTO_COBRANCA_ADMINISTRATIVA
						.executar()));

		return colecaoDebitoTipo;
	}

	/**
	 * Ajustar arrecacador movimento item - código de barras inválido
	 * Esse processo foi criado para corrigir um erro nos códigos de barras criados pela leitura da
	 * CAB no faturamento imediato da CASAL
	 * 
	 * @author Hebert Falcão
	 * @date 11/12/2013
	 */
	public void ajustarArrecadadorMovimentoItemCodigoBarrasInvalido(int idFuncionalidadeIniciada) throws ControladorException{

		log.info("*** INICIO - ajustarArrecadadorMovimentoItemCodigoBarrasInvalido");

		int idUnidadeIniciada = 0;

		try{

			// Registrar o início do processamento da unidade de processamento do batch
			idUnidadeIniciada = this.getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

			Map<Integer, AvisoBancario> mapAvisoBancario = new HashMap<Integer, AvisoBancario>();

			Map<String, Integer> mapArrecadacaoForma = new TreeMap<String, Integer>();
			Collection<ArrecadacaoForma> colecaoArrecadacaoForma = this.getControladorUtil().pesquisar(new FiltroArrecadacaoForma(),
							ArrecadacaoForma.class.getName());

			if(colecaoArrecadacaoForma != null && !colecaoArrecadacaoForma.isEmpty()){
				for(ArrecadacaoForma arrecadacaoForma : colecaoArrecadacaoForma){
					mapArrecadacaoForma.put(arrecadacaoForma.getCodigoArrecadacaoForma(), arrecadacaoForma.getId());
				}
			}

			Collection<ArrecadadorMovimentoItem> colecaoArrecadadorMovimentoItem = null;

			try{
				colecaoArrecadadorMovimentoItem = repositorioArrecadacao.pesquisarArrecadadorMovimentoItemCodigoBarrasInvalido(
								"G%122013000000002%", "MATRICULA DO IMÓVEL NAO CADASTRADA", ArrecadadorMovimentoItem.INDICADOR_NAO_ACEITO);

				if(!Util.isVazioOrNulo(colecaoArrecadadorMovimentoItem)){
					this.ajustarCodigoBarrasInvalido("CONTA", colecaoArrecadadorMovimentoItem, sistemaParametro, mapAvisoBancario,
									mapArrecadacaoForma, null);
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			try{
				colecaoArrecadadorMovimentoItem = repositorioArrecadacao.pesquisarArrecadadorMovimentoItemCodigoBarrasInvalido(
								"G%84%00000000000000%", "DOCUMENTO DE COBRANCA INEXISTENTE", ArrecadadorMovimentoItem.INDICADOR_NAO_ACEITO);

				if(!Util.isVazioOrNulo(colecaoArrecadadorMovimentoItem)){
					this.ajustarCodigoBarrasInvalido("COBRANCA", colecaoArrecadadorMovimentoItem, sistemaParametro, mapAvisoBancario,
									mapArrecadacaoForma, "MODELO_01");
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			try{
				colecaoArrecadadorMovimentoItem = repositorioArrecadacao.pesquisarArrecadadorMovimentoItemCodigoBarrasInvalido(
								"G%82%00000000000000%", "CONTA INEXISTENTE", ArrecadadorMovimentoItem.INDICADOR_NAO_ACEITO);

				if(!Util.isVazioOrNulo(colecaoArrecadadorMovimentoItem)){
					this.ajustarCodigoBarrasInvalido("COBRANCA", colecaoArrecadadorMovimentoItem, sistemaParametro, mapAvisoBancario,
									mapArrecadacaoForma, "MODELO_02");
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			try{
				colecaoArrecadadorMovimentoItem = repositorioArrecadacao.pesquisarArrecadadorMovimentoItemCodigoBarrasInvalido("G%82%",
								"CONTA INEXISTENTE", ArrecadadorMovimentoItem.INDICADOR_NAO_ACEITO);

				if(!Util.isVazioOrNulo(colecaoArrecadadorMovimentoItem)){
					this.ajustarCodigoBarrasInvalido("COBRANCA", colecaoArrecadadorMovimentoItem, sistemaParametro, mapAvisoBancario,
									mapArrecadacaoForma, "MODELO_03");
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			// Registrar o fim do processamento da unidade de processamento do batch
			this.getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

			log.info("*** FIM - ajustarArrecadadorMovimentoItemCodigoBarrasInvalido");
		}catch(Exception e){

			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			this.getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * Ajustar arrecacador movimento item - código de barras inválido
	 * Esse processo foi criado para corrigir um erro nos códigos de barras criados pela leitura da
	 * CAB no faturamento imediato da CASAL
	 * 
	 * @author Hebert Falcão
	 * @date 11/12/2013
	 */
	private void ajustarCodigoBarrasInvalido(String tipo, Collection<ArrecadadorMovimentoItem> colecaoArrecadadorMovimentoItem,
					SistemaParametro sistemaParametro, Map<Integer, AvisoBancario> mapAvisoBancario,
					Map<String, Integer> mapArrecadacaoForma, String modelo) throws ControladorException{

		String conteudoRegistro = null;

		String codigoBarrasNovo = null;
		String codigoBarrasAntigo = null;
		String codigoBarrasAntigoAux = null;

		RegistroHelperCodigoG registroHelperCodigoG = null;

		for(ArrecadadorMovimentoItem arrecadadorMovimentoItem : colecaoArrecadadorMovimentoItem){
			conteudoRegistro = arrecadadorMovimentoItem.getConteudoRegistro();

			if(conteudoRegistro != null){
				registroHelperCodigoG = (RegistroHelperCodigoG) this.distribuirdadosRegistroMovimentoArrecadador(conteudoRegistro, null);

				if(registroHelperCodigoG != null){
					codigoBarrasAntigo = registroHelperCodigoG.getCodigoBarras();

					if(tipo.equals("CONTA")){
						if(codigoBarrasAntigo.contains("122013000000002")){
							codigoBarrasNovo = codigoBarrasAntigo.substring(0, 21) + "0" + codigoBarrasAntigo.substring(21, 42) + "3";

							this.processarCodigoBarrasNovo(tipo, sistemaParametro, mapAvisoBancario, mapArrecadacaoForma, codigoBarrasNovo,
											codigoBarrasAntigo, registroHelperCodigoG, arrecadadorMovimentoItem, false);
						}
					}else if(tipo.equals("COBRANCA")){
						if(modelo != null){
							if(modelo.equals("MODELO_01")){
								if(codigoBarrasAntigo.contains("000000000")){

									RegistroHelperCodigoBarras registroHelperCodigoBarras = this
													.distribuirDadosCodigoBarras(codigoBarrasAntigo);

									RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = registroHelperCodigoBarras
													.getRegistroHelperCodigoBarrasTipoPagamento();

									String idCobrancaDocumentoStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento3();

									if(idCobrancaDocumentoStr != null && idCobrancaDocumentoStr.equals("000000000")){
										String idImovelStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento2();
										Integer idImovel = Integer.valueOf(idImovelStr);

										this.processarCodigoBarrasDocumentoCobranca(tipo, sistemaParametro, mapAvisoBancario,
														mapArrecadacaoForma, codigoBarrasAntigo, registroHelperCodigoG,
														arrecadadorMovimentoItem, idImovel, false);
									}
								}
							}else if(modelo.equals("MODELO_02")){
								if(codigoBarrasAntigo.contains("000000000")){
									codigoBarrasAntigoAux = codigoBarrasAntigo;

									String tipoPagamento = codigoBarrasAntigoAux.substring(19, 21);

									if(tipoPagamento.equals("82")){
										codigoBarrasAntigoAux = codigoBarrasAntigoAux.substring(0, 19) + "84"
														+ codigoBarrasAntigoAux.substring(21);
									}

									RegistroHelperCodigoBarras registroHelperCodigoBarras = this
													.distribuirDadosCodigoBarras(codigoBarrasAntigoAux);

									RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = registroHelperCodigoBarras
													.getRegistroHelperCodigoBarrasTipoPagamento();

									String idCobrancaDocumentoStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento3();

									if(idCobrancaDocumentoStr != null && idCobrancaDocumentoStr.equals("000000000")){
										String idImovelStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento2();
										Integer idImovel = Integer.valueOf(idImovelStr);

										this.processarCodigoBarrasDocumentoCobranca(tipo, sistemaParametro, mapAvisoBancario,
														mapArrecadacaoForma, codigoBarrasAntigo, registroHelperCodigoG,
														arrecadadorMovimentoItem, idImovel, true);
									}
								}
							}else if(modelo.equals("MODELO_03")){
								codigoBarrasAntigoAux = codigoBarrasAntigo;

								String tipoPagamento = codigoBarrasAntigoAux.substring(19, 21);

								if(tipoPagamento.equals("82")){
									codigoBarrasAntigoAux = codigoBarrasAntigoAux.substring(0, 19) + "84"
													+ codigoBarrasAntigoAux.substring(21);
								}

								RegistroHelperCodigoBarras registroHelperCodigoBarras = this
												.distribuirDadosCodigoBarras(codigoBarrasAntigoAux);

								RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = registroHelperCodigoBarras
												.getRegistroHelperCodigoBarrasTipoPagamento();

								String idCobrancaDocumentoStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento3();

								if(idCobrancaDocumentoStr != null && !idCobrancaDocumentoStr.equals("000000000")){
									String idImovelStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento2();
									Integer idImovel = Integer.valueOf(idImovelStr);

									Integer idCobrancaDocumento = Integer.valueOf(idCobrancaDocumentoStr);

									FiltroCobrancaDocumento filtroCobrancaDocumento = new FiltroCobrancaDocumento();
									filtroCobrancaDocumento.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.ID,
													idCobrancaDocumento));
									filtroCobrancaDocumento.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.IMOVEL_ID,
													idImovel));

									Collection<CobrancaDocumento> colecaoCobrancaDocumento = this.getControladorUtil().pesquisar(
													filtroCobrancaDocumento, CobrancaDocumento.class.getName());

									if(!Util.isVazioOrNulo(colecaoCobrancaDocumento)){
										codigoBarrasNovo = codigoBarrasAntigo;

										tipoPagamento = codigoBarrasNovo.substring(19, 21);

										if(tipoPagamento.equals("82")){
											codigoBarrasNovo = codigoBarrasNovo.substring(0, 19) + "84" + codigoBarrasNovo.substring(21);
										}

										this.processarCodigoBarrasNovo(tipo, sistemaParametro, mapAvisoBancario, mapArrecadacaoForma,
														codigoBarrasNovo, codigoBarrasAntigo, registroHelperCodigoG,
														arrecadadorMovimentoItem, true);
									}
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Ajustar arrecacador movimento item - código de barras inválido
	 * Esse processo foi criado para corrigir um erro nos códigos de barras criados pela leitura da
	 * CAB no faturamento imediato da CASAL
	 * 
	 * @author Hebert Falcão
	 * @date 11/12/2013
	 */
	private void processarCodigoBarrasDocumentoCobranca(String tipo, SistemaParametro sistemaParametro,
					Map<Integer, AvisoBancario> mapAvisoBancario, Map<String, Integer> mapArrecadacaoForma, String codigoBarrasAntigo,
					RegistroHelperCodigoG registroHelperCodigoG, ArrecadadorMovimentoItem arrecadadorMovimentoItem, Integer idImovel,
					boolean excluirPagamentoAntigo) throws ControladorException{

		String codigoBarrasNovo = null;

		String valorRecebidoStr = registroHelperCodigoG.getValorRecebido();
		BigDecimal valorRecebido = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(valorRecebidoStr);

		Integer qtdDiasVencContaAvisoCorte = Integer.parseInt((String) ParametroCobranca.P_QUANTIDADE_DIAS_VENCIMENTO_CONTA_AVISO_CORTE
						.executar(this));

		BigDecimal vlMinDebitosAnteriores = Util.formatarStringParaBigDecimal((String) ParametroCobranca.P_VALOR_MINIMO_DEBITOS_ANTERIORES
						.executar(this));

		FiltroMovimentoRoteiroEmpresa filtroMovimentoRoteiroEmpresa = new FiltroMovimentoRoteiroEmpresa();
		filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO, "201312"));
		filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.IMOVEL_ID, idImovel));

		Collection<MovimentoRoteiroEmpresa> colecaoMovimentoRoteiroEmpresa = this.getControladorUtil().pesquisar(
						filtroMovimentoRoteiroEmpresa, MovimentoRoteiroEmpresa.class.getName());

		if(!Util.isVazioOrNulo(colecaoMovimentoRoteiroEmpresa)){
			MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = (MovimentoRoteiroEmpresa) Util
							.retonarObjetoDeColecao(colecaoMovimentoRoteiroEmpresa);

			Date dataProcessamento = movimentoRoteiroEmpresa.getTempoGeracaoArquivoTexto();
			dataProcessamento = Util.formatarDataSemHora(dataProcessamento);

			Date dataVencimento = Util.subtrairNumeroDiasDeUmaData(dataProcessamento, qtdDiasVencContaAvisoCorte);

			Collection<Conta> colecaoConta = null;

			try{
				colecaoConta = repositorioFaturamento.obterDebitosAnteriores(idImovel, vlMinDebitosAnteriores,
								ContaMotivoRevisao.REVISAO_SPC, dataVencimento);
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			BigDecimal valorCalculado = BigDecimal.ZERO;
			BigDecimal valorAcrescimosImpontualidade = BigDecimal.ZERO;

			Collection<ContaValoresHelper> colecaoContaValoresHelper = new ArrayList<ContaValoresHelper>();

			if(!Util.isVazioOrNulo(colecaoConta)){
				ContaValoresHelper contaValoresHelper = null;

				for(Conta conta : colecaoConta){
					Integer idConta = conta.getId();
					Imovel imovelConta = conta.getImovel();
					Integer idImovelConta = imovelConta.getId();
					int referenciaConta = conta.getReferencia();

					Date pagamentoContasMenorData = null;

					try{
						pagamentoContasMenorData = repositorioFaturamento.obterPagamentoContasMenorData(idConta, idImovelConta,
										referenciaConta);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}

					BigDecimal valorMultasCobradas = null;

					try{
						valorMultasCobradas = repositorioFaturamento.pesquisarValorMultasCobradas(idConta);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}

					Date dataVencimentoConta = conta.getDataVencimentoConta();
					BigDecimal valorTotalConta = conta.getValorTotalContaBigDecimal();
					short indicadorCobrancaMulta = conta.getIndicadorCobrancaMulta();

					String anoMesArrecadacaoStr = "201312";

					CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidade = this.getControladorCobranca()
									.calcularAcrescimoPorImpontualidadeBancoDeDados(referenciaConta, dataVencimentoConta,
													pagamentoContasMenorData, valorTotalConta, valorMultasCobradas, indicadorCobrancaMulta,
													anoMesArrecadacaoStr, idConta, new Date(), ConstantesSistema.SIM,
													ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM, dataProcessamento);

					BigDecimal valorAtualizacaoMonetaria = calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria();
					BigDecimal valorJurosMora = calcularAcrescimoPorImpontualidade.getValorJurosMora();
					BigDecimal valorMulta = calcularAcrescimoPorImpontualidade.getValorMulta();

					valorAcrescimosImpontualidade = valorAcrescimosImpontualidade.add(valorAtualizacaoMonetaria);
					valorAcrescimosImpontualidade = valorAcrescimosImpontualidade.add(valorJurosMora);
					valorAcrescimosImpontualidade = valorAcrescimosImpontualidade.add(valorMulta);

					contaValoresHelper = new ContaValoresHelper();
					contaValoresHelper.setConta(conta);
					contaValoresHelper.setValorAtualizacaoMonetaria(valorAtualizacaoMonetaria);
					contaValoresHelper.setValorJurosMora(valorJurosMora);
					contaValoresHelper.setValorMulta(valorMulta);

					colecaoContaValoresHelper.add(contaValoresHelper);

					valorCalculado = valorCalculado.add(valorTotalConta);
				}

				valorCalculado = valorCalculado.add(valorAcrescimosImpontualidade);
			}

			if(valorCalculado.compareTo(valorRecebido) == 0){
				FiltroImovel filtroImovel = new FiltroImovel();
				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovel));
				filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.SETOR_COMERCIAL);
				filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.QUADRA);

				Collection<Imovel> colecaoImovel = this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());

				if(!Util.isVazioOrNulo(colecaoImovel)){
					Imovel imovel = (Imovel) Util.retonarObjetoDeColecao(colecaoImovel);

					ExtratoDebitoRelatorioHelper extratoDebitoRelatorioHelper = this.getControladorCobranca().gerarEmitirExtratoDebito(
									imovel, ConstantesSistema.NAO, colecaoContaValoresHelper, null, null, valorAcrescimosImpontualidade,
									BigDecimal.ZERO, valorCalculado, null, null, null, null);

					CobrancaDocumento documentoCobranca = extratoDebitoRelatorioHelper.getDocumentoCobranca();

					Integer idNovoCobrancaDocumento = documentoCobranca.getId();

					String idNovoCobrancaDocumentoStr = Util.completarNumeroComValorEsquerda(idNovoCobrancaDocumento, "0", 9);

					codigoBarrasNovo = codigoBarrasAntigo.substring(0, 30) + idNovoCobrancaDocumentoStr + codigoBarrasAntigo.substring(39);

					String tipoPagamento = codigoBarrasNovo.substring(19, 21);

					if(tipoPagamento.equals("82")){
						codigoBarrasNovo = codigoBarrasNovo.substring(0, 19) + "84" + codigoBarrasNovo.substring(21);
					}

					this.processarCodigoBarrasNovo(tipo, sistemaParametro, mapAvisoBancario, mapArrecadacaoForma, codigoBarrasNovo,
									codigoBarrasAntigo, registroHelperCodigoG, arrecadadorMovimentoItem, excluirPagamentoAntigo);
				}
			}else{
				AjusteCodigoBarras ajusteCodigoBarras = new AjusteCodigoBarras();

				Integer idArrecadadorMovimentoItem = arrecadadorMovimentoItem.getId();

				String descricaoOcorrenciaMovimento = "VALOR CALCULADO DIFERENTE DO RECEBIDO (Imovel: " + idImovel + "; valorCalculado: "
								+ valorCalculado + "; valorRecebido: " + valorRecebido + ")";

				ajusteCodigoBarras.setIdArrecadadorMovimentoItem(idArrecadadorMovimentoItem);
				ajusteCodigoBarras.setCodigoBarrasAntigo(codigoBarrasAntigo);
				ajusteCodigoBarras.setCodigoBarrasNovo(null);
				ajusteCodigoBarras.setDescricaoOcorrenciaMovimento(descricaoOcorrenciaMovimento);
				ajusteCodigoBarras.setIndicadorAceitacaoRegistro(ConstantesSistema.NAO.intValue());
				ajusteCodigoBarras.setIdImovel(idImovel);
				ajusteCodigoBarras.setReferencia(null);
				ajusteCodigoBarras.setIdCobrancaDocumento(null);
				ajusteCodigoBarras.setIdPagamento(null);
				ajusteCodigoBarras.setUltimaAlteracao(new Date());

				this.getControladorUtil().inserir(ajusteCodigoBarras);
			}
		}
	}

	/**
	 * Ajustar arrecacador movimento item - código de barras inválido
	 * Esse processo foi criado para corrigir um erro nos códigos de barras criados pela leitura da
	 * CAB no faturamento imediato da CASAL
	 * 
	 * @author Hebert Falcão
	 * @date 11/12/2013
	 */
	private void processarCodigoBarrasNovo(String tipo, SistemaParametro sistemaParametro, Map<Integer, AvisoBancario> mapAvisoBancario,
					Map<String, Integer> mapArrecadacaoForma, String codigoBarrasNovo, String codigoBarrasAntigo,
					RegistroHelperCodigoG registroHelperCodigoG, ArrecadadorMovimentoItem arrecadadorMovimentoItem,
					boolean excluirPagamentoAntigo) throws ControladorException{

		Integer anoMesArrecadacao = sistemaParametro.getAnoMesArrecadacao();

		Integer idArrecadadorMovimentoItem = arrecadadorMovimentoItem.getId();

		AjusteCodigoBarras ajusteCodigoBarras = new AjusteCodigoBarras();

		ajusteCodigoBarras.setIdArrecadadorMovimentoItem(idArrecadadorMovimentoItem);
		ajusteCodigoBarras.setCodigoBarrasAntigo(codigoBarrasAntigo);
		ajusteCodigoBarras.setCodigoBarrasNovo(codigoBarrasNovo);

		RegistroHelperCodigoBarras registroHelperCodigoBarras = this.distribuirDadosCodigoBarras(codigoBarrasNovo);

		String dataPagamentoStr = registroHelperCodigoG.getDataPagamento();
		Date dataPagamento = Util.converteStringInvertidaSemBarraParaDate(dataPagamentoStr);

		String codigoFormaArrecadacao = registroHelperCodigoG.getCodigoFormaArrecadacao();
		Integer idFormaPagamentoStr = mapArrecadacaoForma.get(codigoFormaArrecadacao);

		if(idFormaPagamentoStr == null){
			idFormaPagamentoStr = ArrecadacaoForma.GUICHE_CAIXA;
		}

		Integer idFormaPagamento = Integer.valueOf(idFormaPagamentoStr);

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarras(registroHelperCodigoBarras,
						dataPagamento, idFormaPagamento, sistemaParametro, null, null);

		if(pagamentoHelperCodigoBarras != null){
			String descricaoOcorrenciaMovimento = pagamentoHelperCodigoBarras.getDescricaoOcorrencia();

			String indicadorAceitacaoRegistroStr = pagamentoHelperCodigoBarras.getIndicadorAceitacaoRegistro();
			Integer indicadorAceitacaoRegistro = Integer.parseInt(indicadorAceitacaoRegistroStr);

			ajusteCodigoBarras.setDescricaoOcorrenciaMovimento(descricaoOcorrenciaMovimento);
			ajusteCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

			RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento();

			Integer idImovel = null;
			Integer referencia = null;
			Integer idCobrancaDocumento = null;

			if(tipo.equals("CONTA")){
				String idImovelStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento1();
				idImovel = Integer.valueOf(idImovelStr);

				String referenciaStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento2();
				referencia = Integer.valueOf(referenciaStr);
				referencia = Util.formatarMesAnoParaAnoMes(referencia);
			}else{
				String idImovelStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento2();
				idImovel = Integer.valueOf(idImovelStr);

				String idCobrancaDocumentoStr = registroHelperCodigoBarrasTipoPagamento.getIdPagamento3();
				idCobrancaDocumento = Integer.valueOf(idCobrancaDocumentoStr);
			}

			ajusteCodigoBarras.setIdImovel(idImovel);
			ajusteCodigoBarras.setReferencia(referencia);
			ajusteCodigoBarras.setIdCobrancaDocumento(idCobrancaDocumento);

			if(indicadorAceitacaoRegistro == 1 && descricaoOcorrenciaMovimento.equalsIgnoreCase("OK")){

				Collection colecaoPagamentos = pagamentoHelperCodigoBarras.getColecaoPagamentos();

				ArrecadadorMovimento arrecadadorMovimento = arrecadadorMovimentoItem.getArrecadadorMovimento();

				if(!Util.isVazioOrNulo(colecaoPagamentos) && arrecadadorMovimento != null){
					Integer idArrecadadorMovimento = arrecadadorMovimento.getId();

					AvisoBancario avisoBancarioNovo = null;

					if(mapAvisoBancario.containsKey(idArrecadadorMovimento)){
						avisoBancarioNovo = mapAvisoBancario.get(idArrecadadorMovimento);
					}else{
						FiltroAvisoBancario filtroAvisoBancario = new FiltroAvisoBancario();
						filtroAvisoBancario.adicionarParametro(new ParametroSimples(FiltroAvisoBancario.ARRECADADOR_MOVIMENTO_ID,
										idArrecadadorMovimento));
						filtroAvisoBancario.adicionarCaminhoParaCarregamentoEntidade(FiltroAvisoBancario.ARRECADADOR);

						Collection<AvisoBancario> colecaoAvisoBancario = this.getControladorUtil().pesquisar(filtroAvisoBancario,
										AvisoBancario.class.getName());

						if(!Util.isVazioOrNulo(colecaoAvisoBancario)){
							AvisoBancario avisoBancarioAntigo = (AvisoBancario) Util.retonarObjetoDeColecao(colecaoAvisoBancario);

							Arrecadador arrecadador = avisoBancarioAntigo.getArrecadador();

							if(arrecadador != null){
								Date dataPrevista = avisoBancarioAntigo.getDataPrevista();
								Date dataLancamento = avisoBancarioAntigo.getDataLancamento();

								Integer idArrecadador = arrecadador.getId();
								String idArrecadadorStr = Integer.toString(idArrecadador);

								Short valorMaximoNumeroSequencia = null;

								try{
									valorMaximoNumeroSequencia = repositorioArrecadacao.pesquisarValorMaximoNumeroSequencial(
													dataLancamento, idArrecadadorStr);
								}catch(ErroRepositorioException e){
									throw new ControladorException("erro.sistema", e);
								}

								Short numeroSequencialAvisoBancario = 1;

								if(valorMaximoNumeroSequencia != null){
									numeroSequencialAvisoBancario = (short) (valorMaximoNumeroSequencia.shortValue() + 1);
								}

								RegistroHelperCodigoA registroHelperCodigoA = new RegistroHelperCodigoA();

								String dataLancamentoAAAAMMDD = Util.formatarDataAAAAMMDD(dataLancamento);
								registroHelperCodigoA.setDataGeracaoArquivo(dataLancamentoAAAAMMDD);

								FiltroArrecadadorMovimento filtroArrecadadorMovimento = new FiltroArrecadadorMovimento();
								filtroArrecadadorMovimento.adicionarParametro(new ParametroSimples(FiltroArrecadadorMovimento.ID,
												idArrecadadorMovimento));

								Collection<ArrecadadorMovimento> colecaoArrecadadorMovimento = this.getControladorUtil().pesquisar(
												filtroArrecadadorMovimento, ArrecadadorMovimento.class.getName());

								if(!Util.isVazioOrNulo(colecaoArrecadadorMovimento)){
									arrecadadorMovimento = (ArrecadadorMovimento) Util.retonarObjetoDeColecao(colecaoArrecadadorMovimento);
								}

								String codigoConvenio = arrecadadorMovimento.getCodigoConvenio();

								FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
								filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID,
												idArrecadador));
								filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(
												FiltroArrecadadorContrato.CODIGO_CONVENIO, codigoConvenio));

								Collection<ArrecadadorContrato> colecaoArrecadadorContrato = this.getControladorUtil().pesquisar(
												filtroArrecadadorContrato, ArrecadadorContrato.class.getName());

								if(!Util.isVazioOrNulo(colecaoArrecadadorContrato)){
									ArrecadadorContrato arrecadadorContrato = (ArrecadadorContrato) Util
													.retonarObjetoDeColecao(colecaoArrecadadorContrato);

									avisoBancarioNovo = this.gerarOcorrenciaAvisoBancario(null, registroHelperCodigoA, dataPrevista,
													BigDecimal.ZERO.toString(), anoMesArrecadacao, null, BigDecimal.ZERO, BigDecimal.ZERO,
													BigDecimal.ZERO, BigDecimal.ZERO, numeroSequencialAvisoBancario, arrecadadorContrato,
													arrecadador);

									Integer idAvisoBancario = (Integer) this.getControladorUtil().inserir(avisoBancarioNovo);
									avisoBancarioNovo.setId(idAvisoBancario);
								}
							}
						}

						mapAvisoBancario.put(idArrecadadorMovimento, avisoBancarioNovo);
					}

					if(avisoBancarioNovo == null){
						throw new ActionServletException("atencao.pesquisa.nenhum_registro_tabela", null, "AvisoBancario");
					}

					Integer idPagamentoNovo = this.inserirPagamentosCodigoBarras(colecaoPagamentos, null, Usuario.USUARIO_BATCH,
									avisoBancarioNovo, true);

					if(excluirPagamentoAntigo && idImovel != null && idPagamentoNovo != null){
						FiltroPagamento filtroPagamentoAntigo = new FiltroPagamento();
						filtroPagamentoAntigo.adicionarParametro(new ParametroSimples(FiltroPagamento.IMOVEL_ID, idImovel));
						filtroPagamentoAntigo.adicionarParametro(new ParametroSimples(FiltroPagamento.ARRECADADOR_MOVIMENTO_ITEM_ID,
										idArrecadadorMovimentoItem));

						Collection<Pagamento> colecaoPagamentoAntigo = this.getControladorUtil().pesquisar(filtroPagamentoAntigo,
										Pagamento.class.getName());

						if(!Util.isVazioOrNulo(colecaoPagamentoAntigo)){
							Collection<String> idsPagamentoAntigo = new ArrayList<String>();

							Integer idPagamentoAntigo = null;
							String idPagamentoAntigoStr = null;

							for(Pagamento pagamentoAntigo : colecaoPagamentoAntigo){
								idPagamentoAntigo = pagamentoAntigo.getId();
								idPagamentoAntigoStr = Integer.toString(idPagamentoAntigo);

								idsPagamentoAntigo.add(idPagamentoAntigoStr);
							}

							String[] idsPagamentoAntigoArrayStr = idsPagamentoAntigo.toArray(new String[idsPagamentoAntigo.size()]);
							this.removerPagamentosDESO(idsPagamentoAntigoArrayStr, Usuario.USUARIO_BATCH);
						}
					}

					ajusteCodigoBarras.setIdPagamento(idPagamentoNovo);
				}
			}
		}

		ajusteCodigoBarras.setUltimaAlteracao(new Date());

		this.getControladorUtil().inserir(ajusteCodigoBarras);
	}


	/**
	 * [OC1196098] - Quadro Comparativo de Faturamento e Arrecadação
	 * 
	 * @author Yara Souza
	 * @date 15/04/2014
	 */

	public void gerarQuadroComparativoFaturamentoEArrecadacao(int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		// -------------------------
		// Registrar o início do processamento da Unidade de Processamento do Batch
		// -------------------------

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, idFuncionalidadeIniciada);

		try{

			// Recupera os parâmetros do sistema
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			// Recupera o ano/mês de referência da arrecadação dos parâmetros de
			// sistema
			Integer anoMesReferenciaArrecadacao = sistemaParametro.getAnoMesArrecadacao();

			String parametroGerarQuadroFaturamentoArrecadacao = ParametroArrecadacao.P_GERACAO_QUADRO_FATURAMENTO_ARRECADACAO.executar();

			if(parametroGerarQuadroFaturamentoArrecadacao != null && !parametroGerarQuadroFaturamentoArrecadacao.equals("")
							&& parametroGerarQuadroFaturamentoArrecadacao.equals("1")){
				Date dateInicioMes = Util.converterAnoMesParaDataInicial(anoMesReferenciaArrecadacao.toString());
				String stringInicioMes = Util.formatarData(dateInicioMes);
				Date dateFimMes = Util.converterAnoMesParaDataFinal(anoMesReferenciaArrecadacao.toString());
				String stringFimMes = Util.formatarData(dateFimMes);

				Integer anoMesInicio = anoMesReferenciaArrecadacao;
				Integer anoMesFim = Util.somaUmMesAnoMesReferencia(anoMesInicio);

				repositorioArrecadacao.gerarQuadroComparativoFaturamentoArrecadacao(stringInicioMes, stringFimMes, anoMesInicio, anoMesFim);
			}

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}

		getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

	}

}
