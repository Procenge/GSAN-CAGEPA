/*
 * Copyright (C) 2007-2007 the GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 *
 * This file is part of GSAN, an integrated service management system for Sanitation
 *
 * GSAN is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * GSAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place – Suite 330, Boston, MA 02111-1307, USA
 */

/*
 * GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 * Copyright (C) <2007> 
 * Adriano Britto Siqueira
 * Alexandre Santos Cabral
 * Ana Carolina Alves Breda
 * Ana Maria Andrade Cavalcante
 * Aryed Lins de Araújo
 * Bruno Leonardo Rodrigues Barros
 * Carlos Elmano Rodrigues Ferreira
 * Cláudio de Andrade Lira
 * Denys Guimarães Guenes Tavares
 * Eduardo Breckenfeld da Rosa Borges
 * Fabíola Gomes de Araújo
 * Flávio Leonardo Cavalcanti Cordeiro
 * Francisco do Nascimento Júnior
 * Homero Sampaio Cavalcanti
 * Ivan Sérgio da Silva Júnior
 * José Edmar de Siqueira
 * José Thiago Tenório Lopes
 * Kássia Regina Silvestre de Albuquerque
 * Leonardo Luiz Vieira da Silva
 * Márcio Roberto Batista da Silva
 * Maria de Fátima Sampaio Leite
 * Micaela Maria Coelho de Araújo
 * Nelson Mendonça de Carvalho
 * Newton Morais e Silva
 * Pedro Alexandre Santos da Silva Filho
 * Rafael Corrêa Lima e Silva
 * Rafael Francisco Pinto
 * Rafael Koury Monteiro
 * Rafael Palermo de Araújo
 * Raphael Veras Rossiter
 * Roberto Sobreira Barbalho
 * Rodrigo Avellar Silveira
 * Rosana Carvalho Barbosa
 * Sávio Luiz de Andrade Cavalcante
 * Tai Mu Shih
 * Thiago Augusto Souza do Nascimento
 * Tiago Moreno Rodrigues
 * Vivianne Barbosa Sousa
 *
 * Este programa é software livre; você pode redistribuí-lo e/ou
 * modificá-lo sob os termos de Licença Pública Geral GNU, conforme
 * publicada pela Free Software Foundation; versão 2 da
 * Licença.
 * Este programa é distribuído na expectativa de ser útil, mas SEM
 * QUALQUER GARANTIA; sem mesmo a garantia implícita de
 * COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM
 * PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais
 * detalhes.
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU
 * junto com este programa; se não, escreva para Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307, USA.
 * 
 * GSANPCG
 * Eduardo Henrique
 * Virgínia Melo
 * Saulo Lima
 * 
 */

package gcom.faturamento;

import gcom.arrecadacao.ContratoDemandaConsumo;
import gcom.arrecadacao.debitoautomatico.DebitoAutomatico;
import gcom.arrecadacao.debitoautomatico.DebitoAutomaticoMovimento;
import gcom.arrecadacao.pagamento.*;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgoto;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.cadastro.cliente.ClienteConta;
import gcom.cadastro.cliente.ClienteFone;
import gcom.cadastro.cliente.ClienteRelacaoTipo;
import gcom.cadastro.cliente.EsferaPoder;
import gcom.cadastro.imovel.*;
import gcom.cadastro.localidade.*;
import gcom.cobranca.*;
import gcom.cobranca.bean.ContaValoresHelper;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.cobranca.parcelamento.ParcelamentoItem;
import gcom.cobranca.parcelamento.ParcelamentoPerfil;
import gcom.cobranca.parcelamento.ParcelamentoSituacao;
import gcom.faturamento.bean.*;
import gcom.faturamento.consumotarifa.ConsumoTarifa;
import gcom.faturamento.consumotarifa.ConsumoTarifaCategoria;
import gcom.faturamento.consumotarifa.ConsumoTarifaFaixa;
import gcom.faturamento.consumotarifa.ConsumoTarifaVigencia;
import gcom.faturamento.conta.*;
import gcom.faturamento.credito.*;
import gcom.faturamento.debito.*;
import gcom.faturamento.faturamentosimulacaocomando.FaturamentoSimulacaoComando;
import gcom.financeiro.FinanciamentoTipo;
import gcom.financeiro.ResumoFaturamento;
import gcom.financeiro.lancamento.LancamentoItemContabil;
import gcom.gui.faturamento.bean.GuiaPagamentoPrestacaoHelper;
import gcom.gui.faturamento.bean.ManterContaHelper;
import gcom.interceptor.RegistradorOperacao;
import gcom.micromedicao.MovimentoRoteiroEmpresa;
import gcom.micromedicao.Rota;
import gcom.micromedicao.consumo.ConsumoHistorico;
import gcom.micromedicao.consumo.LigacaoTipo;
import gcom.micromedicao.hidrometro.HidrometroInstalacaoHistorico;
import gcom.micromedicao.medicao.FiltroMedicaoHistoricoSql;
import gcom.micromedicao.medicao.MedicaoHistorico;
import gcom.micromedicao.medicao.MedicaoTipo;
import gcom.relatorio.faturamento.RelatorioSituacaoEspecialFaturamentoHelper;
import gcom.relatorio.ordemservico.DadosContaEmRevisaoHelper;
import gcom.seguranca.acesso.Operacao;
import gcom.seguranca.acesso.OperacaoEfetuada;
import gcom.seguranca.acesso.usuario.Usuario;
import gcom.seguranca.acesso.usuario.UsuarioAcao;
import gcom.seguranca.acesso.usuario.UsuarioAcaoUsuarioHelper;
import gcom.util.*;
import gcom.util.filtro.*;
import gcom.util.parametrizacao.ParametroGeral;

import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.sql.*;
import java.util.*;
import java.util.Date;
import java.util.concurrent.CopyOnWriteArraySet;

import org.apache.commons.beanutils.PropertyUtils;
import org.hibernate.*;
import org.hibernate.criterion.Expression;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;

/**
 * < <Descrição da Classe>>
 * 
 * @author Administrador
 */
public final class RepositorioFaturamentoHBM
				implements IRepositorioFaturamento {

	private static IRepositorioFaturamento instancia;

	/**
	 * Construtor da classe RepositorioFaturamentoHBM
	 */
	private RepositorioFaturamentoHBM() {

	}

	/**
	 * Retorna o valor de instance
	 * 
	 * @return O valor de instance]
	 */
	public static IRepositorioFaturamento getInstancia(){

		if(instancia == null){
			instancia = new RepositorioFaturamentoHBM();
		}
		return instancia;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaConta(Imovel imovel, int anoMesReferencia) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ct.id from Conta ct " + "inner join ct.imovel " + "where ct.referencia = :referencia "
							+ "and ct.imovel.id = :imovel ";

			retorno = (Integer) session.createQuery(consulta).setInteger("referencia", anoMesReferencia)
							.setInteger("imovel", imovel.getId()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @author eduardo henrique
	 * @date 20/10/2008
	 *       Alteração no método para retornar o indicador de obrigatoriedade da Atividade de
	 *       Faturamento
	 * @param faturamentoGrupo
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @param faturamentoAtividade
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Object[] obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(FaturamentoGrupo faturamentoGrupo, int anoMesReferencia,
					FaturamentoAtividade faturamentoAtividade) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select fac.dataPrevista,fac.dataRealizacao, fa.indicadorPossibilidadeRepeticaoAtividade from FaturamentoAtividadeCronograma fac "
							+ "inner join fac.faturamentoGrupoCronogramaMensal fgcm "
							+ "inner join fgcm.faturamentoGrupo fg "
							+ "inner join fac.faturamentoAtividade fa "
							+ "where  fg.id = :id and fgcm.anoMesReferencia = :anoMesReferencia and fa.id = :fa ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("id", faturamentoGrupo.getId())
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("fa", faturamentoAtividade.getId()).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @param idFaturamentoAtividadeCronograma
	 * @exception ErroRepositorioException
	 *                Erro no BD
	 */
	public void removerTodasRotasPorCronogramaFaturamento(Integer idFaturamentoAtividadeCronograma) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			Iterator iterator = session
							.createQuery("from gcom.faturamento.FaturamentoAtivCronRota CronogramaRota where CronogramaRota.comp_id.faturamentoAtividadeCronogramaId = :faturamentoAtividadeCronograma")
							.setInteger("faturamentoAtividadeCronograma", idFaturamentoAtividadeCronograma.intValue()).iterate();

			while(iterator.hasNext()){
				iterator.next();
				iterator.remove();

			}

			session.flush();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Este caso de uso permite alterar ou excluir um comando de atividade de
	 * faturamento
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * buscarAtividadeComandadaNaoRealizada
	 * 
	 * @author Roberta Costa
	 * @date 18/07/2006
	 * @return uma lista de atividades de faturamento comandadas e ainda não
	 *         realizadas
	 * @throws ErroRepositorioException
	 */
	public Collection buscarAtividadeComandadaNaoRealizada(Integer numeroPagina, Integer idFaturamentoGrupo, Integer anoMesReferencia)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("SELECT ftac.id, ftac.faturamentoAtividade, ftac.comando, ftac.dataPrevista, ftcm, ftgr ");
			consulta.append("FROM ");
			consulta.append("FaturamentoAtividadeCronograma ftac ");
			consulta.append("INNER JOIN ftac.faturamentoAtividade ftat ");
			consulta.append("INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm ");
			consulta.append("INNER JOIN ftcm.faturamentoGrupo ftgr ");
			consulta.append("WHERE ");
			consulta.append("ftac.comando IS NOT NULL ");
			consulta.append("AND ");
			consulta.append("(ftac.dataRealizacao IS NULL OR ftac.dataRealizacao < ftac.comando) ");

			if(idFaturamentoGrupo != null && anoMesReferencia != null){

				consulta.append(" and ftgr.id = " + idFaturamentoGrupo);
				consulta.append(" and ftcm.anoMesReferencia = " + anoMesReferencia);

			}else{

				if(idFaturamentoGrupo != null){

					consulta.append(" and ftgr.id = " + idFaturamentoGrupo);

				}else if(anoMesReferencia != null){

					consulta.append(" and ftcm.anoMesReferencia = " + anoMesReferencia);

				}

			}

			consulta.append(" order by ftgr.id, ftcm.anoMesReferencia, ftat.descricao, ftac.comando, ftac.dataPrevista");

			// consulta =
			// "SELECT ftac.id, ftac.faturamentoAtividade, ftac.comando, ftac.dataPrevista" +
			// ", ftcm, ftgr "
			// + "FROM FaturamentoAtividadeCronograma ftac " +
			// "INNER JOIN ftac.faturamentoAtividade ftat "
			// + "INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm " +
			// "INNER JOIN ftcm.faturamentoGrupo ftgr "
			// + "WHERE ftac.comando IS NOT NULL AND " +
			// "(ftac.dataRealizacao IS NULL OR ftac.dataRealizacao < ftac.comando)"
			// +
			// " order by ftgr.id, ftcm.anoMesReferencia, ftat.descricao, ftac.comando, ftac.dataPrevista ";

			retorno = session.createQuery(consulta.toString()).setFirstResult(10 * numeroPagina).setMaxResults(10).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite alterar ou excluir um comando de atividade de
	 * faturamento
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * Retorna o count do resultado da pesquisa de Faturamento Atividade
	 * Cronograma não realizadas
	 * buscarAtividadeComandadaNaoRealizadaCount
	 * 
	 * @author Roberta Costa
	 * @date 18/07/2006
	 * @param filtroFaturamentoAtividadeCronograma
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer buscarAtividadeComandadaNaoRealizadaCount(Integer idFaturamentoGrupo, Integer anoMesReferencia)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("SELECT count(ftac.id) ");
			consulta.append("FROM ");
			consulta.append("FaturamentoAtividadeCronograma ftac ");
			consulta.append("INNER JOIN ftac.faturamentoAtividade ftat ");
			consulta.append("INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm ");
			consulta.append("INNER JOIN ftcm.faturamentoGrupo ftgr ");
			consulta.append("WHERE ");
			consulta.append("ftac.comando IS NOT NULL ");
			consulta.append("AND ");
			consulta.append("(ftac.dataRealizacao IS NULL OR ftac.dataRealizacao < ftac.comando) ");

			if(idFaturamentoGrupo != null && anoMesReferencia != null){

				consulta.append(" and ftgr.id = " + idFaturamentoGrupo);
				consulta.append(" and ftcm.anoMesReferencia = " + anoMesReferencia);

			}else{

				if(idFaturamentoGrupo != null){

					consulta.append(" and ftgr.id = " + idFaturamentoGrupo);

				}else if(anoMesReferencia != null){

					consulta.append(" and ftcm.anoMesReferencia = " + anoMesReferencia);

				}

			}

			// consulta = "SELECT count(ftac.id)" + "FROM FaturamentoAtividadeCronograma ftac " +
			// "INNER JOIN ftac.faturamentoAtividade ftat "
			// + "INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm " +
			// "INNER JOIN ftcm.faturamentoGrupo ftgr "
			// + "WHERE ftac.comando IS NOT NULL AND " +
			// "(ftac.dataRealizacao IS NULL OR ftac.dataRealizacao < ftac.comando)";

			retorno = ((Number) session.createQuery(consulta.toString()).uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * 
	 * @return uma coleção de FATURAMENTO_ATIVIDADE_CRONOGRAMA
	 * @throws ErroRepositorioException
	 */
	public Collection buscarFaturamentoAtividadeCronograma(String ids) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			// String idsFormatados = ids

			consulta = "SELECT new FaturamentoAtividadeCronograma(ftac.id, ftac.dataPrevista, ftac.dataRealizacao"
							+ ", ftac.comando, ftac.ultimaAlteracao, ftac.faturamentoAtividade, ftac.faturamentoGrupoCronogramaMensal) "
							+ "FROM FaturamentoAtividadeCronograma ftac " + "WHERE ftac.id IN (" + ids + ")";

			retorno = session.createQuery(consulta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 26/12/2005
	 * 
	 * @param conta
	 * @return uma coleção com os débitos cobrados de uma conta
	 * @throws ErroRepositorioException
	 */
	public Collection buscarDebitosCobradosConta(Conta conta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT dbcb.id, dbtp.id, dbtp.descricao, dbcb.anoMesReferenciaDebito, ");
			consulta.append("dbcb.anoMesCobrancaDebito, dbcb.numeroPrestacao, dbcb.numeroPrestacaoDebito, ");
			consulta.append("dbcb.valorPrestacao, dbcb.ultimaAlteracao, dbtp.descricaoAbreviada, fntp.id, ");
			consulta.append("lict.id, dbcb.indicadorRemuneraCobrancaAdministrativa, parc.id ");
			consulta.append("FROM DebitoCobrado dbcb ");
			consulta.append("INNER JOIN dbcb.conta cnta ");
			consulta.append("INNER JOIN dbcb.debitoTipo dbtp ");
			consulta.append("INNER JOIN dbtp.financiamentoTipo fntp ");
			consulta.append("INNER JOIN dbtp.lancamentoItemContabil lict ");
			consulta.append("LEFT JOIN dbcb.parcelamento parc ");
			consulta.append("WHERE  cnta.id = :contaid ");

			retorno = session.createQuery(consulta.toString()).setInteger("contaid", conta.getId().intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection buscarDebitosCobradosEmitirContaCaern(Conta conta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT dbtp.id, dbtp.descricao, " + "dbcb.numeroPrestacao, dbcb.numeroPrestacaoDebito, "
							+ "SUM(dbcb.valorPrestacao)" + "" + "FROM DebitoCobrado dbcb " + "INNER JOIN dbcb.conta cnta "
							+ "INNER JOIN dbcb.debitoTipo dbtp " + "INNER JOIN dbtp.financiamentoTipo fntp "
							+ "INNER JOIN dbtp.lancamentoItemContabil lict " + "WHERE  cnta.id = :contaid "
							+ "GROUP BY  dbtp.id, dbtp.descricao, dbcb.numeroPrestacao, dbcb.numeroPrestacaoDebito";

			retorno = session.createQuery(consulta).setInteger("contaid", conta.getId().intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 28/12/2005
	 * 
	 * @param conta
	 * @return uma coleção com os créditos realizados de uma conta
	 * @throws ErroRepositorioException
	 */
	public Collection buscarCreditosRealizadosConta(Conta conta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT crrz.id, crtp.id, crtp.descricao, crtp.descricaoAbreviada, "
							+ "crrz.anoMesReferenciaCredito, crrz.anoMesCobrancaCredito, crrz.numeroPrestacao, "
							+ "crrz.numeroPrestacaoCredito, crrz.valorCredito, crrz.ultimaAlteracao, "
							+ "lict.id, crrz.creditoOrigem.id, crrz.creditoOrigem.descricao, crrz.creditoOrigem.indicadorUsoLivre, crg.id , crrz.lancamentoItemContabil.id "
							+ "FROM CreditoRealizado crrz " + "INNER JOIN crrz.conta cnta " + "INNER JOIN crrz.creditoTipo crtp "
							+ "INNER JOIN crtp.lancamentoItemContabil lict " + "INNER JOIN crrz.creditoOrigem crOr "
							+ "LEFT JOIN crrz.creditoARealizarGeral crg " + "WHERE  cnta.id = :contaid ";

			retorno = session.createQuery(consulta).setInteger("contaid", conta.getId().intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarConsumoTarifaVigenciaEntreDataLeituraAnterioreDataLeituraAtual(ConsumoTarifa consumoTarifa,
					Date dataLeituraAnterior, Date dataLeituraAtual) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ctv from gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "where ctv.dataVigencia between :dataLeituraAnterior  and  :dataLeituraAtual  "
							+ "and ctv.consumoTarifa.id = :idConsumoTarifa " + "order by ctv.dataVigencia ";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifa", consumoTarifa.getId().intValue())
							.setDate("dataLeituraAnterior", dataLeituraAnterior).setDate("dataLeituraAtual", dataLeituraAtual).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * @author Raphael Rossiter
	 * @date 29/06/2007
	 * @param consumoTarifa
	 * @param dataFaturamento
	 * @throws ErroRepositorioException
	 */
	public ConsumoTarifaVigencia pesquisarConsumoTarifaVigenciaMenorOUIgualDataFaturamento(Integer idConsumoTarifa, Date dataFaturamento)
					throws ErroRepositorioException{

		ConsumoTarifaVigencia retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ctv from gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "inner join fetch ctv.consumoTarifa ct "
							+ "where ctv.dataVigencia <= :dataFaturamento and ctv.consumoTarifa.id = :idConsumoTarifa "
							+ "order by ctv.dataVigencia desc ";

			retorno = (ConsumoTarifaVigencia) session.createQuery(consulta).setInteger("idConsumoTarifa", idConsumoTarifa)
							.setDate("dataFaturamento", dataFaturamento).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarConsumoTarifaVigenciaMenorDataLeituraAnterior(ConsumoTarifa consumoTarifa, Date dataLeituraAnterior)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ctv.id, ctv.dataVigencia " + "from gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "inner join ctv.consumoTarifa ct "
							+ "where ctv.dataVigencia < :dataLeituraAnterior and ct.id = :idConsumoTarifa "
							+ "order by ctv.dataVigencia desc ";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifa", consumoTarifa.getId().intValue())
							.setDate("dataLeituraAnterior", dataLeituraAnterior).setMaxResults(1).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarConsumoTarifaCategoria(ConsumoTarifaVigencia consumoTarifaVigencia, Categoria categoria)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ctc from ConsumoTarifaCategoria ctc " + "inner join fetch ctc.categoria ct "
							+ "where ctc.consumoTarifaVigencia.id = :idConsumoTarifaVigencia " + "and ct.id = :idCategoria "
							+ "and ctc.subCategoria.id = :idSubCategoria ";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifaVigencia", consumoTarifaVigencia.getId())
							.setInteger("idCategoria", categoria.getId())
							.setInteger("idSubCategoria", Subcategoria.SUBCATEGORIA_ZERO.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarConsumoTarifaFaixa(ConsumoTarifaCategoria consumoTarifaCategoria) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ctf from ConsumoTarifaFaixa ctf " + "where ctf.consumoTarifaCategoria.id = :idConsumoTarifaCategoria "
							+ "order by ctf.numeroConsumoFaixaInicio ";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifaCategoria", consumoTarifaCategoria.getId().intValue())
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo Retorna a date de vigência em vigor
	 * de uma tarifa de consumo
	 * 
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConsumoTarifaVigenciaEmVigor(ConsumoTarifa consumoTarifa) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT ctv.dataVigencia " + "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "INNER JOIN ctv.consumoTarifa ct " + "where ct.id = :idConsumoTarifa " + "ORDER BY ctv.dataVigencia DESC";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifa", consumoTarifa.getId().intValue()).setMaxResults(1).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo Retorna a date de vigência em vigor
	 * de uma tarifa de consumo Pesquisa a Data de Vigencia da Consumo Tarifa e
	 * da Consumo Tarifa Vigencia
	 * 
	 * @author Rafael Santos
	 * @since 11/07/2006
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConsumoTarifaVigenciaEmVigor(ConsumoTarifa consumoTarifa, int idConsumoTarifaVigencia)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT ctv.dataVigencia " + "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "INNER JOIN ctv.consumoTarifa ct " + "where ct.id = :idConsumoTarifa "
							+ "and ctv.id = :idConsumoTarifaVigencia";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifa", consumoTarifa.getId().intValue())
							.setInteger("idConsumoTarifaVigencia", idConsumoTarifaVigencia).setMaxResults(1).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo
	 * Pesquisa a Menor Maior data da vigencia
	 * 
	 * @author Rafael Santos
	 * @since 12/07/2006
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarMenorDataConsumoTarifaVigenciaEmVigor(ConsumoTarifa consumoTarifa, int idConsumoTarifaVigencia)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT max(ctv.dataVigencia) " + "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "INNER JOIN ctv.consumoTarifa ct " + "where ct.id = :idConsumoTarifa "
							+ " and ctv.dataVigencia < (SELECT max(ctv.dataVigencia) "
							+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv " + "INNER JOIN ctv.consumoTarifa ct "
							+ "where ct.id = :idConsumoTarifa " + "and ctv.id = :idConsumoTarifaVigencia)";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifa", consumoTarifa.getId().intValue())
							.setInteger("idConsumoTarifaVigencia", idConsumoTarifaVigencia)

			.setMaxResults(1).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo Retorna a date de vigência em vigor
	 * de uma tarifa de consumo Pesuisar a Maior Menor data de todas as
	 * vigências do Consumo Tarifa
	 * 
	 * @author Rafael Santos
	 * @since 12/07/2006
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarMaiorDataConsumoTarifaVigencia(ConsumoTarifa consumoTarifa) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT max(ctv.dataVigencia) " + "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "INNER JOIN ctv.consumoTarifa ct " + "where ct.id = :idConsumoTarifa ";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifa", consumoTarifa.getId().intValue())

			.setMaxResults(1).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo Retorna a date de vigência em vigor
	 * de uma tarifa de consumo Pesquisa a Maior Menor data das vigencia
	 * 
	 * @author Rafael Santos
	 * @since 11/07/2006
	 * @param consumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarMaiorDataConsumoTarifaVigenciaEmVigor(ConsumoTarifa consumoTarifa, int idConsumoTarifaVigencia)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT min(ctv.dataVigencia) " + "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "INNER JOIN ctv.consumoTarifa ct " + "where ct.id = :idConsumoTarifa "
							+ " and ctv.dataVigencia > (SELECT max(ctv.dataVigencia) "
							+ "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv " + "INNER JOIN ctv.consumoTarifa ct "
							+ "where ct.id = :idConsumoTarifa " + "and ctv.id = :idConsumoTarifaVigencia)";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifa", consumoTarifa.getId().intValue())
							.setInteger("idConsumoTarifaVigencia", idConsumoTarifaVigencia)

			.setMaxResults(1).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * Seleciona a partir da tabela CLIENTE_IMOVEL para IMOV_ID=Id do imóvel e
	 * CLIM_DTRELACAOFIM com o valor correspondente a nulo
	 * 
	 * @param IMOVEL
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteImovelDataRelacaoFimNull(Imovel imovel) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT clim.cliente, clim.clienteRelacaoTipo, clim.indicadorNomeConta " + "FROM ClienteImovel clim "
							+ "INNER JOIN clim.imovel imov " + "WHERE imov.id = :idImovel AND clim.dataFimRelacao IS NULL";

			retorno = session.createQuery(consulta).setInteger("idImovel", imovel.getId().intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades Autor: Sávio Luiz Data:
	 * 18/01/2006
	 */

	public Integer pesquisarFaturamentoGrupoCronogramaMensal(Integer idFaturamentoGrupo, Integer anoMes) throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "select fgcm.id " + "from FaturamentoGrupoCronogramaMensal fgcm "
							+ "left join fgcm.faturamentoGrupo faturamentoGrupo " + "where fgcm.anoMesReferencia = :anoMes and "
							+ "faturamentoGrupo.id = :idFaturamentoGrupo ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idFaturamentoGrupo", idFaturamentoGrupo.intValue())
							.setInteger("anoMes", anoMes.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades Autor: Sávio Luiz Data:
	 * 18/01/2006
	 */

	public Integer pesquisarFaturamentoAtividadeCronograma(Integer idFaturamentoGrupoCronogramaMensal, Integer idFaturamentoAtividade)
					throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "select fac.id " + "from FaturamentoAtividadeCronograma fac " + "left join fac.faturamentoAtividade fa "
							+ "left join fac.faturamentoGrupoCronogramaMensal fgcm " + "where fa.id = :idFaturamentoAtividade and "
							+ "fgcm.id = :idFaturamentoGrupoCronogramaMensal ";

			retorno = (Integer) session.createQuery(consulta)
							.setInteger("idFaturamentoGrupoCronogramaMensal", idFaturamentoGrupoCronogramaMensal.intValue())
							.setInteger("idFaturamentoAtividade", idFaturamentoAtividade).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades Autor: Sávio Luiz Data:
	 * 18/01/2006
	 */

	// autor : Sávio Luiz atualiza a data de realização e a data de ultima
	// alteração
	// do faturamento atividade cronograma
	public void atualizarFaturamentoAtividadeCronograma(Integer idFaturamentoAtividadeCronograma, Date dataRealizada)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try{
			atualizarImovel = "update gcom.faturamento.FaturamentoAtividadeCronograma "
							+ "set ftac_tmrealizacao = :dataRealizacao,ftac_tmultimaalteracao = :dataUltimaAlteracao where ftac_id = :idFaturamentoAtividadeCronograma";

			session.createQuery(atualizarImovel).setTimestamp("dataRealizacao", dataRealizada)
							.setTimestamp("dataUltimaAlteracao", new Date())
							.setInteger("idFaturamentoAtividadeCronograma", idFaturamentoAtividadeCronograma.intValue()).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0083] - [Gerar dados para leitura] [Atualizar faturamento atividade cronograma]
	 * 
	 * @author Bruno Ferreira dos Santos
	 * @date 02/08/2011
	 */

	public void atualizarFaturamentoAtividadeCronograma(FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try{
			atualizarImovel = "update gcom.faturamento.FaturamentoAtividadeCronograma "
							+ " SET ftac_tmrealizacao = :dataRealizacao, ftac_tmultimaalteracao = :dataUltimaAlteracao "
							+ " where ftat_id = :faturamentoAtividade and "
							+ " ftcm_id in (select id from gcom.faturamento.FaturamentoGrupoCronogramaMensal where anoMesReferencia = :referencia and faturamentoGrupo.id = :faturamentoGrupo) ";

			session.createQuery(atualizarImovel).setTimestamp("dataRealizacao", new Date()).setTimestamp("dataUltimaAlteracao", new Date())
							.setInteger("faturamentoAtividade", FaturamentoAtividade.GERAR_ARQUIVO_LEITURA)
							.setInteger("referencia", faturamentoGrupoCronogramaMensal.getAnoMesReferencia())
							.setInteger("faturamentoGrupo", faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getId()).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Rhawi Dantas
	 * @created 18/01/2006
	 */
	public void inserirFaturamentoSituacaoHistorico(Collection collectionFaturamentoSituacaoHistorico) throws ErroRepositorioException{

		// StatelessSession session = HibernateUtil.getStatelessSession();

		try{
			Iterator iteratorFSH = collectionFaturamentoSituacaoHistorico.iterator();
			// int i = 1;
			while(iteratorFSH.hasNext()){
				FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = (FaturamentoSituacaoHistorico) iteratorFSH.next();
				RepositorioUtilHBM.getInstancia().inserir(faturamentoSituacaoHistorico);
				/*
				 * if (i % 50 == 0) { // 20, same as the JDBC batch size //
				 * flush a batch of inserts and release memory: session.flush();
				 * session.clear(); } i++;
				 */
			}
			// session.flush();
			// session.clear();
		}catch(HibernateException e){
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}
		// finally{
		//
		// // session.clear();
		// HibernateUtil.closeSession(session);
		// // session.close();
		// }

	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira,Vivianne Sousa
	 * @created 18/01/2006,22/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstado(int anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(rf.valorItemFaturamento), "
							+ // 0
							"lt.descricao, "
							+ // 1
							"li.descricao, "
							+ // 2
							"lic.descricao, "
							+ // 3
							"lt.indicadorImpressao, "
							+ // 4
							"lt.indicadorTotal, "
							+ // 5
							"lt.id, "
							+ // 6
							"lt.lancamentoTipo.id, "
							+ // 7
							"rf.categoria.id, "
							+ // 8
							"rf.sequenciaTipoLancamento, "
							+ // 9
							"rf.sequenciaItemTipoLancamento "
							+ // 10
							"from ResumoFaturamento rf "
							+ "left join rf.lancamentoTipo lt "
							+ "left join rf.lancamentoItem li "
							+ "left join rf.lancamentoItemContabil lic "
							+ "where rf.anoMesReferencia = :anoMesReferencia and "
							+ "(rf.categoria.id = 1 or "
							+ "rf.categoria.id = 2 or "
							+ "rf.categoria.id = 3 or "
							+ "rf.categoria.id = 4) "
							+ "group by lt.descricao,li.descricao,lic.descricao,lt.indicadorImpressao,lt.indicadorTotal,lt.id,lt.lancamentoTipo.id,rf.categoria.id,rf.sequenciaTipoLancamento,rf.sequenciaItemTipoLancamento  "
							+ "order by rf.sequenciaTipoLancamento,rf.sequenciaItemTipoLancamento,rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstadoPorGerenciaRegional(int anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(rf.valorItemFaturamento), "
							+ // 0
							"lt.descricao, "
							+ // 1
							"li.descricao, "
							+ // 2
							"lic.descricao, "
							+ // 3
							"lt.indicadorImpressao, "
							+ // 4
							"lt.indicadorTotal, "
							+ // 5
							"lt.id, "
							+ // 6
							"lt.lancamentoTipo.id, "
							+ // 7
							"rf.categoria.id, "
							+ // 8
							"rf.gerenciaRegional.nome, "
							+ // 9
							"rf.gerenciaRegional.id, "
							+ // 10
							"rf.sequenciaTipoLancamento, "
							+ // 11
							"rf.sequenciaItemTipoLancamento "
							+ // 12
							"from ResumoFaturamento rf  " + "left join rf.lancamentoTipo lt " + "left join rf.lancamentoItem li "
							+ "left join rf.lancamentoItemContabil lic " + "where rf.anoMesReferencia = :anoMesReferencia and  "
							+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) "
							+ "group by rf.gerenciaRegional.nome, rf.gerenciaRegional.id, lt.descricao, li.descricao, "
							+ "lic.descricao, lt.indicadorImpressao,lt.indicadorTotal, lt.id,lt.lancamentoTipo.id,  "
							+ "rf.categoria.id, rf.sequenciaTipoLancamento,rf.sequenciaItemTipoLancamento "
							+ "order by rf.gerenciaRegional.id, rf.sequenciaTipoLancamento,  "
							+ "rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstadoPorLocalidade(int anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(rf.valorItemFaturamento), "
							+ // 0
							"lt.descricao, "
							+ // 1
							"li.descricao, "
							+ // 2
							"lic.descricao, "
							+ // 3
							"lt.indicadorImpressao, "
							+ // 4
							"lt.indicadorTotal, "
							+ // 5
							"lt.id, "
							+ // 6
							"lt.lancamentoTipo.id, "
							+ // 7
							"rf.categoria.id, "
							+ // 8
							"rf.gerenciaRegional.nome, "
							+ // 9
							"rf.gerenciaRegional.id, "
							+ // 10
							"rf.localidade.descricao, "
							+ // 11
							"rf.localidade.id, "
							+ // 12
							"rf.sequenciaTipoLancamento, "
							+ // 13
							"rf.sequenciaItemTipoLancamento, "
							+ // 14
							" rf.unidadeNegocio.nome, "
							+ // 15
							" rf.unidadeNegocio.id " // 16
							+ "from ResumoFaturamento rf " + "left join rf.lancamentoTipo lt " + "left join rf.lancamentoItem li "
							+ "left join rf.lancamentoItemContabil lic " + "where rf.anoMesReferencia = :anoMesReferencia and "
							+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) "
							+ "group by rf.gerenciaRegional.nome, rf.gerenciaRegional.id, rf.localidade.descricao, rf.localidade.id, "
							+ "lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, "
							+ "lt.lancamentoTipo.id, rf.categoria.id, rf.sequenciaTipoLancamento, "
							+ "rf.sequenciaItemTipoLancamento,rf.unidadeNegocio.nome, rf.unidadeNegocio.id " + " order by "
							+ " rf.localidade.id," + " rf.unidadeNegocio.id," + " rf.gerenciaRegional.id," + " rf.sequenciaTipoLancamento,"
							+ " rf.sequenciaItemTipoLancamento," + " rf.categoria.id";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorGerenciaRegional(int anoMesReferencia, Integer gerenciaRegional)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(rf.valorItemFaturamento), "
							+ // 0
							"lt.descricao, "
							+ // 1
							"li.descricao, "
							+ // 2
							"lic.descricao, "
							+ // 3
							"lt.indicadorImpressao, "
							+ // 4
							"lt.indicadorTotal, "
							+ // 5
							"lt.id, "
							+ // 6
							"lt.lancamentoTipo.id, "
							+ // 7
							"rf.categoria.id, "
							+ // 8
							"rf.gerenciaRegional.nome, "
							+ // 9
							"rf.gerenciaRegional.id, "
							+ // 10
							"rf.sequenciaTipoLancamento, "
							+ // 11
							"rf.sequenciaItemTipoLancamento "
							+ // 12
							"from ResumoFaturamento rf " + "left join rf.lancamentoTipo lt " + "left join rf.lancamentoItem li "
							+ "left join rf.lancamentoItemContabil lic "
							+ "where rf.anoMesReferencia = :anoMesReferencia and rf.gerenciaRegional = :gerenciaRegional "
							+ "and (rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) "
							+ "group by lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, "
							+ "lt.indicadorTotal, lt.id, lt.lancamentoTipo.id, rf.categoria.id, rf.gerenciaRegional.nome, "
							+ "rf.gerenciaRegional.id, rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento "
							+ "order by rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("gerenciaRegional", gerenciaRegional).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorGerenciaRegionalPorLocalidade(int anoMesReferencia, Integer gerenciaRegional)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(rf.valorItemFaturamento), "
							+ // 0
							"lt.descricao, "
							+ // 1
							"li.descricao, "
							+ // 2
							"lic.descricao, "
							+ // 3
							"lt.indicadorImpressao, "
							+ // 4
							"lt.indicadorTotal, "
							+ // 5
							"lt.id, "
							+ // 6
							"lt.lancamentoTipo.id, "
							+ // 7
							"rf.categoria.id, "
							+ // 8
							"rf.gerenciaRegional.nome, "
							+ // 9
							"rf.gerenciaRegional.id, "
							+ // 10
							"rf.localidade.descricao, "
							+ // 11
							"rf.localidade.id, "
							+ // 12
							"rf.sequenciaTipoLancamento, "
							+ // 13
							"rf.sequenciaItemTipoLancamento "
							+ // 14
							"from ResumoFaturamento rf " + "left join rf.lancamentoTipo lt left join rf.lancamentoItem li "
							+ "left join rf.lancamentoItemContabil lic "
							+ "where rf.anoMesReferencia = :anoMesReferencia and rf.gerenciaRegional = :gerenciaRegional and "
							+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) "
							+ "group by rf.localidade.descricao, rf.localidade.id,  lt.descricao, "
							+ "li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, "
							+ "lt.lancamentoTipo.id, rf.categoria.id, rf.gerenciaRegional.nome, rf.gerenciaRegional.id, "
							+ "rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento  "
							+ "order by rf.localidade.id, rf.sequenciaTipoLancamento,  "
							+ "rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("gerenciaRegional", gerenciaRegional).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira, Vivianne Sousa
	 * @created 18/01/2006, 22/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorLocalidade(int anoMesReferencia, Integer localidade)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(rf.valorItemFaturamento), "
							+ // 0
							"lt.descricao, "
							+ // 1
							"li.descricao, "
							+ // 2
							"lic.descricao, "
							+ // 3
							"lt.indicadorImpressao, "
							+ // 4
							"lt.indicadorTotal, "
							+ // 5
							"lt.id, "
							+ // 6
							"lt.lancamentoTipo.id, "
							+ // 7
							"rf.categoria.id, "
							+ // 8
							"rf.localidade.descricao, "
							+ // 9
							"rf.localidade.id, "
							+ // 10
							"rf.sequenciaTipoLancamento, "
							+ // 11
							"rf.sequenciaItemTipoLancamento "
							+ // 12
							"from ResumoFaturamento rf "
							+ "left join rf.lancamentoTipo lt "
							+ "left join rf.lancamentoItem li "
							+ "left join rf.lancamentoItemContabil lic "
							+ "where rf.anoMesReferencia = :anoMesReferencia and "
							+ "rf.localidade = :localidade and "
							+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) "
							+ "group by  lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, lt.lancamentoTipo.id, "
							+ "rf.categoria.id, rf.localidade.descricao, rf.localidade.id, rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento "
							+ "order by rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("localidade", localidade)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0146] - Manter Conta Author: Raphael Rossiter Data: 21/01/2006
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @author Saulo Lima
	 * @date 10/09/2008
	 *       Alteração na chamada do método pra satifazer as especificações do UC0146 (ADA):
	 *       Remover os parâmetros: situacaoNormal, situacaoIncluida e situacaoRetificada
	 * @param imovel
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImovelManter(Imovel imovel) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, cnta.valorEsgoto, "
							+ "cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
							+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, cnta.referenciaContabil, "
							+ "cnta.ultimaAlteracao, cnta.codigoSetorComercial, cnta.quadra, cnta.indicadorAlteracaoVencimento, "
							+ "cnta.dataRetificacao, cnta.dataEmissao, cnta.indicadorExecucaoFiscal  " + "FROM Conta cnta "
							+ "INNER JOIN cnta.imovel imov " + "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
							+ "WHERE imov.id = :idImovel " + "AND cnta.debitoCreditoSituacaoAtual <> :idSituacaoPreFaturada "
							+ "ORDER BY cnta.referencia";

			retorno = session.createQuery(consulta).setInteger("idImovel", imovel.getId())
							.setInteger("idSituacaoPreFaturada", DebitoCreditoSituacao.PRE_FATURADA).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0146] - Manter Conta
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @author Hugo Lima
	 * @date 10/09/2012
	 * @param manterContaHelper
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImovelManterParametros(ManterContaHelper manterContaHelper) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		Query query = null;
		String consulta;

		try{
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, cnta.valorEsgoto, "
							+ "cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
							+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, cnta.referenciaContabil, "
							+ "cnta.ultimaAlteracao, cnta.codigoSetorComercial, cnta.quadra, cnta.indicadorAlteracaoVencimento, "
							+ "cnta.dataRetificacao, cnta.dataEmissao, cnta.indicadorExecucaoFiscal " + "FROM Conta cnta "
							+ "INNER JOIN cnta.imovel imov " + "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst ";

			if(manterContaHelper.getInContasRevisao().equals(ConstantesSistema.SIM.toString())){
				consulta += "INNER JOIN cnta.contaMotivoRevisao cmr ";
			}else{
				consulta += "LEFT JOIN cnta.contaMotivoRevisao cmr ";
			}

			consulta += "WHERE imov.id = :idImovel " + "AND cnta.debitoCreditoSituacaoAtual <> :idSituacaoPreFaturada ";

			if(!Util.isVazioOuBranco(manterContaHelper.getAnoMesReferenciaContaInicio())
							&& !Util.isVazioOuBranco(manterContaHelper.getAnoMesReferenciaContaFim())){
				consulta += "AND (cnta.referencia >= :anoMesReferenciaContaInicio AND cnta.referencia <= :anoMesReferenciaContaFim) ";
			}

			if(!Util.isVazioOuBranco(manterContaHelper.getDataPagamentoContaInicio())
							&& !Util.isVazioOuBranco(manterContaHelper.getDataPagamentoContaFim())){
				consulta += "AND (cnta.dataVencimentoConta >= :dataPagamentoContaInicio AND cnta.dataVencimentoConta <= :dataPagamentoContaFim) ";
			}

			if(manterContaHelper.getInContasRevisao().equals(ConstantesSistema.SIM.toString())
							&& !Util.isVazioOrNulo(manterContaHelper.getMotivosRevisaoDisponiveis())){
				consulta += "AND cmr.id in (:motivosRevisaoDisponiveis) ";
			}else if(manterContaHelper.getInContasRevisao().equals(ConstantesSistema.NAO.toString())
							&& !Util.isVazioOrNulo(manterContaHelper.getMotivosRevisaoDisponiveis())){
				consulta += "AND (cmr.id in (:motivosRevisaoDisponiveis) or cmr.id is null) ";
			}

			consulta += "ORDER BY cnta.referencia";

			query = session.createQuery(consulta).setInteger("idImovel", manterContaHelper.getImovel().getId())
							.setInteger("idSituacaoPreFaturada", DebitoCreditoSituacao.PRE_FATURADA);

			if(!Util.isVazioOuBranco(manterContaHelper.getAnoMesReferenciaContaInicio())
							&& !Util.isVazioOuBranco(manterContaHelper.getAnoMesReferenciaContaFim())){
				query.setInteger("anoMesReferenciaContaInicio", manterContaHelper.getAnoMesReferenciaContaInicio()).setInteger(
								"anoMesReferenciaContaFim", manterContaHelper.getAnoMesReferenciaContaFim());
			}

			if(!Util.isVazioOuBranco(manterContaHelper.getDataPagamentoContaInicio())
							&& !Util.isVazioOuBranco(manterContaHelper.getDataPagamentoContaFim())){
				query.setDate("dataPagamentoContaInicio", manterContaHelper.getDataPagamentoContaInicio()).setDate("dataPagamentoContaFim",
								manterContaHelper.getDataPagamentoContaFim());
			}

			if(!Util.isVazioOrNulo(manterContaHelper.getMotivosRevisaoDisponiveis())){
				query.setParameterList("motivosRevisaoDisponiveis", manterContaHelper.getMotivosRevisaoDisponiveis());
			}

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0147] - Cancelar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void cancelarContaReferenciaContabilMenorSistemaParametro(Conta conta, Integer debitoCreditoSituacaoAnterior)
					throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			// Atualiza apenas os dados (data do cancelamento, motivo, situação
			// anterior, situação atual) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET " + "cnta_dtcancelamento = :dataCancelamento, cmcn_id = :motivo, "
							+ "dcst_idanterior = " + debitoCreditoSituacaoAnterior + ", dcst_idatual = :situacaoAtual, "
							+ "cnta_tmultimaalteracao = :dataUltimaAlteracao, " + "cnta_amreferenciacontabil = :referenciaContabil, "
							+ "usur_id = :usuarioLogado " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setDate("dataCancelamento", conta.getDataCancelamento())
							.setInteger("motivo", conta.getContaMotivoCancelamento().getId())
							.setInteger("situacaoAtual", conta.getDebitoCreditoSituacaoAtual().getId())
							.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao())
							.setInteger("referenciaContabil", conta.getReferenciaContabil()).setInteger("idConta", conta.getId())
							.setInteger("usuarioLogado", conta.getUsuario().getId()).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0147] - Cancelar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void cancelarContaReferenciaContabilMaiorIgualSistemaParametro(Conta conta) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			// Atualiza apenas os dados (data do cancelamento,
			// motivoCancelamento, situação atual,
			// situação atual, dataRetificacao, motivoRetificacao,
			// referenciaContabil) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET "
							+ "cnta_dtcancelamento = :dataCancelamento, cmcn_id = :motivoCancelamento, "
							+ "dcst_idatual = :situacaoAtual, cnta_dtretificacao = null, "
							+ "cmrt_id = null, cnta_amreferenciacontabil = :referenciaContabil, "
							+ "cnta_tmultimaalteracao = :dataUltimaAlteracao, " + "usur_id = :usuarioLogado " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setDate("dataCancelamento", conta.getDataCancelamento())
							.setInteger("motivoCancelamento", conta.getContaMotivoCancelamento().getId())
							.setInteger("situacaoAtual", conta.getDebitoCreditoSituacaoAtual().getId())
							.setInteger("referenciaContabil", conta.getReferenciaContabil())
							.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao()).setInteger("idConta", conta.getId())
							.setInteger("usuarioLogado", conta.getUsuario().getId()).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0147] - Colocar Revisão Conta Author: Raphael Rossiter Data:
	 * 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void colocarContaRevisao(Conta conta) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			// Atualiza apenas os dados (dataRevisao, motivoRevisao) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET " + "cnta_dtrevisao = :dataRevisao, cmrv_id = :motivoRevisao, "
							+ "cnta_tmultimaalteracao = :dataUltimaAlteracao, " + "usur_id = :usuarioLogado " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setDate("dataRevisao", conta.getDataRevisao())
							.setInteger("motivoRevisao", conta.getContaMotivoRevisao().getId())
							.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao()).setInteger("idConta", conta.getId())
							.setInteger("usuarioLogado", conta.getUsuario().getId()).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0149] - Retirar Revisão Conta Author: Raphael Rossiter Data:
	 * 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void retirarContaRevisao(Conta conta) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			// Atualiza apenas os dados (dataRevisao, motivoRevisao) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET " + "cnta_dtrevisao = null, cmrv_id = null, "
							+ "cnta_tmultimaalteracao = :dataUltimaAlteracao " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao())
							.setInteger("idConta", conta.getId()).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0151] - Alterar Vencimento Conta Author: Raphael Rossiter Data:
	 * 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void alterarVencimentoConta(Conta conta) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			// Atualiza apenas os dados (dataRevisao, motivoRevisao) da
			// conta
			update = "UPDATE gcom.faturamento.conta.Conta SET cnta_dtvencimentooriginal = cnta_dtvencimentoconta, "
							+ "cnta_dtvencimentoconta = :dataVencimento, cnta_dtvalidadeconta = :dataValidade, "
							+ "cnta_icalteracaovencimento = :indicadorAlteracaoVencimento, "
							+ "cnta_tmultimaalteracao = :dataUltimaAlteracao " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setDate("dataVencimento", conta.getDataVencimentoConta())
							.setDate("dataValidade", conta.getDataValidadeConta())
							.setShort("indicadorAlteracaoVencimento", conta.getIndicadorAlteracaoVencimento())
							.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao()).setInteger("idConta", conta.getId())
							.executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public Collection<Integer> pesquisarQuadras(Integer rotaId) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select qd.id from Quadra qd " + "inner join qd.rota rt where rt.id = :rotaId ";

			retorno = session.createQuery(consulta).setInteger("rotaId", rotaId.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Object pesquisarFaturamentoAtividadeCronogramaDataRealizacao(Integer faturamentoGrupoId, Integer faturamentoAtividadeId)
					throws ErroRepositorioException{

		Object retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("select fac.dataRealizacao from FaturamentoAtividadeCronograma fac ")
							// .append("inner join fac.faturamentoAtividade fa ")
							.append("inner join fac.faturamentoGrupoCronogramaMensal fcm ")
							// .append("inner join fcm.faturamentoGrupo fg ")
							.append("where fcm.faturamentoGrupo = :faturamentoGrupoId and fac.faturamentoAtividade = :faturamentoAtividadeId ");

			retorno = session.createQuery(consulta.toString()).setInteger("faturamentoGrupoId", faturamentoGrupoId.intValue())
							.setInteger("faturamentoAtividadeId", faturamentoAtividadeId).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Leonardo Vieria, Rafael
	 * Santos Data:17/01/2006 Consultar os Debitos a Cobrar do Imovel
	 * (Utilizado no obterDebitoACobrarImovel)
	 * 
	 * @author eduardo henrique
	 * @date 22/09/2008
	 *       Alterações no [SB0003] para a v0.05
	 * @param imovelId
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualId
	 *            Id do Debito Credito Situação
	 * @param anoMesReferencia
	 *            Referência para obter débitos de determinada data e anteriores
	 * @return Coleção de Debitos a Cobrar
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrar(Integer imovelId, Integer debitoCreditoSituacaoAtualId, Integer anoMesReferenciaCobrancaDebito)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			// consulta =
			// "select dc.id, ft.id, ltc.id,dc.valorDebito,dc.numeroPrestacaoDebito,dc.numeroPrestacaoCobradas, "
			// +
			// " debitoTipo.id, localidade.id,quadra.id, dc.codigoSetorComercial,dc.numeroQuadra,dc.numeroLote,dc.numeroSubLote,dc.anoMesReferenciaDebito,dc.anoMesCobrancaDebito,parcelamento.anoMesReferenciaFaturamento,parcelamento.id "
			// + " ,dc.dataAntecipacao,dc.quantidadeParcelasAntecipadas "
			// + "from DebitoACobrar dc "
			// + "inner join dc.debitoCreditoSituacaoAtual dcs "
			// + "inner join dc.imovel im "
			// + "inner join dc.financiamentoTipo ft "
			// + "inner join dc.lancamentoItemContabil ltc "
			// + "inner join dc.debitoTipo debitoTipo "
			// + "inner join dc.localidade localidade "
			// + "inner join dc.quadra quadra "
			// + "left join dc.parcelamento parcelamento "
			// +
			// "where im.id = :imovelId and dc.numeroPrestacaoCobradas < dc.numeroPrestacaoDebito "
			// + "and dc.debitoCreditoSituacaoAtual.id = :debitoCreditoSituacaoAtualId "
			// + "and dc.anoMesCobrancaDebito <= :anoMesReferenciaCobrancaDebito";

			consulta = "select dc " + "from DebitoACobrar dc " + "inner join dc.debitoCreditoSituacaoAtual dcs "
							+ "inner join dc.imovel im " + "inner join dc.financiamentoTipo ft "
							+ "inner join dc.lancamentoItemContabil ltc " + "inner join dc.debitoTipo debitoTipo "
							+ "inner join dc.localidade localidade " + "inner join dc.quadra quadra "
							+ "left join dc.parcelamento parcelamento "
							+ "where im.id = :imovelId and dc.numeroPrestacaoCobradas < dc.numeroPrestacaoDebito "
							+ "and dc.debitoCreditoSituacaoAtual.id = :debitoCreditoSituacaoAtualId "
							+ "and dc.anoMesCobrancaDebito <= :anoMesReferenciaCobrancaDebito";

			retorno = session.createQuery(consulta).setInteger("imovelId", imovelId.intValue())
							.setInteger("debitoCreditoSituacaoAtualId", debitoCreditoSituacaoAtualId)
							.setInteger("anoMesReferenciaCobrancaDebito", anoMesReferenciaCobrancaDebito).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Rafael Santos Data:
	 * 13/01/2006 Consultar os Debitos a Cobrar CAtegoria do Debito a Cobrar
	 * 
	 * @param debitoACobrarID
	 *            Id do Debito a Cobrar
	 * @return Coleção de Debitos a Cobrar Categoria
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarCategoria(Integer debitoACobrarID) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select categoria.id, dacc.quantidadeEconomia " + "from DebitoACobrarCategoria dacc "
							+ "inner join dacc.categoria categoria " + "inner join dacc.debitoACobrar debitoACobrar "
							+ "where debitoACobrar.id = :debitoACobrarID";

			retorno = session.createQuery(consulta).setInteger("debitoACobrarID", debitoACobrarID).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consultar os Créditos a Realizar do Imovel
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * @author Leonardo Vieria, Rafael Santos
	 * @data 17/01/2006
	 * @author eduardo henrique
	 * @date 22/09/2008
	 *       Alteração no método para desativação dos parâmetros debitoCreditoSituacao e
	 *       AnoMesFaturamento para a v0.05
	 * @author Saulo Lima
	 * @date 09/03/2009
	 *       Remover parâmetros inutilizados + novos retornos
	 * @param imovelId
	 *            Id do Imovel
	 * @return Coleção de atributos de Creditos a Realizar
	 * @exception ErroRepositorioException
	 */
	public Collection<Object> pesquisarCreditoARealizar(Integer imovelId) throws ErroRepositorioException{

		Collection<Object> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT cr.id, cr.numeroPrestacaoRealizada, cr.numeroPrestacaoRealizada, cr.valorCredito, cr.valorResidualMesAnterior, "
							+ "creditoTipo.id, lancamentoItemContabil.id, localidade.id, quadra.id, cr.codigoSetorComercial, cr.numeroQuadra, cr.numeroLote, "
							+ "cr.numeroSubLote, cr.anoMesReferenciaCredito, cr.anoMesCobrancaCredito, cr.numeroPrestacaoRealizada, cr.numeroPrestacaoCredito, "
							+ "creditoOrigem.id, parcelamento.anoMesReferenciaFaturamento, cr.debitoCreditoSituacaoAtual.id, parcelamento.id "
							+ "FROM CreditoARealizar cr "
							+ "INNER JOIN cr.creditoTipo creditoTipo "
							+ "INNER JOIN cr.lancamentoItemContabil lancamentoItemContabil "
							+ "INNER JOIN cr.localidade localidade "
							+ "INNER JOIN cr.quadra quadra "
							+ "INNER JOIN cr.creditoOrigem creditoOrigem "
							+ "LEFT JOIN cr.parcelamento parcelamento " + "WHERE cr.imovel.id = :imovelId";
			/*
			 * +
			 * "where im.id = :imovelId and cr.debitoCreditoSituacaoAtual.id = :debitoCreditoSituacaoAtualId "
			 * +
			 * "and (cr.numeroPrestacaoRealizada < cr.numeroPrestacaoCredito or cr.valorResidualMesAnterior > 0) and "
			 * + " ((parcelamento.id is null) "
			 * + "or  (cr.numeroPrestacaoRealizada > 0) "
			 * +
			 * "or  (parcelamento.id is not null  and cr.numeroPrestacaoRealizada = 0 and parcelamento.anoMesReferenciaFaturamento < :anoMesFaturamento)) "
			 * ;
			 */

			retorno = session.createQuery(consulta).setInteger("imovelId", imovelId.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consultar os Créditos a Realizar do Imovel
	 * [UC0113] - Faturar Grupo Faturamento
	 * 
	 * @author Leonardo Vieria, Rafael Santos
	 * @data 17/01/2006
	 * @author eduardo henrique
	 * @date 22/09/2008
	 *       Alteração no método para desativação dos parâmetros debitoCreditoSituacao e
	 *       AnoMesFaturamento para a v0.05
	 * @author Saulo Lima
	 * @date 09/03/2009
	 *       Remover parâmetros inutilizados + novos retornos
	 * @param imovelId
	 *            Id do Imovel
	 * @return Coleção de atributos de Creditos a Realizar
	 * @exception ErroRepositorioException
	 *                O método foi reescrito para que o crédito a realizar possa ser transferido
	 *                para
	 *                histórico.
	 */
	public Collection pesquisarCreditoARealizarObjeto(Integer imovelId) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT cr " + "FROM CreditoARealizar cr left join fetch cr.parcelamento " + "WHERE cr.imovel.id = :imovelId";

			retorno = session.createQuery(consulta).setInteger("imovelId", imovelId.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Leonardo Vieria, Rafael
	 * Santos Data:17/01/2006 Consultar os Cre´ditos a Realizar do Imovel
	 * 
	 * @param imovelId
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualId
	 *            Id do Debito Credito Situação
	 * @return Coleção de Creditos a Realizar
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizarHistorico(Integer imovelId, int anoMesFaturamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select cr " + "from CreditoARealizarHistorico cr "
			/*
			 * + "inner join cr.debitoCreditoSituacaoAtual dcs "
			 * + "inner join cr.imovel im "
			 * + "inner join cr.creditoTipo creditoTipo "
			 * + "inner join cr.lancamentoItemContabil lancamentoItemContabil "
			 * + "inner join cr.localidade localidade "
			 * + "inner join cr.quadra quadra "
			 * + "inner join cr.creditoOrigem creditoOrigem "
			 * + "left join cr.parcelamento parcelamento "
			 */
			+ "where cr.im.id = :imovelId "
			// +
							// "and (cr.numeroPrestacaoRealizada < cr.numeroPrestacaoCredito or cr.valorResidualMesAnterior > 0) and "
							// + " ((parcelamento.id is null) "
							// + "or  (cr.numeroPrestacaoRealizada > 0) "
							+ "and cr.parcelamento.anoMesReferenciaFaturamento < :anoMesFaturamento)) ";

			retorno = session.createQuery(consulta).setInteger("imovelId", imovelId.intValue())
							.setInteger("anoMesFaturamento", anoMesFaturamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Rafael Santos Data:
	 * 14/01/2006 Consultar os Creditos Realizados Categoria do Credito A
	 * Realizar
	 * 
	 * @param creditoARealizarID
	 *            Id do Creditoa A Realizar
	 * @return Coleção de Creditoa a Realizar Categoria
	 * @exception ErroRepositorioException
	 */
	public Collection pesquisarCreditoRealizarCategoria(Integer creditoARealizarID) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select categoria.id,creditoARealizar.id, crc.quantidadeEconomia " + "from " + "CreditoARealizarCategoria crc "
							+ "inner join crc.categoria categoria " + "inner join crc.creditoARealizar creditoARealizar "
							+ "where creditoARealizar.id = :creditoARealizarID";

			retorno = session.createQuery(consulta).setInteger("creditoARealizarID", creditoARealizarID).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Metódo responsável por inserir um
	 * objeto de ResumoFaturamento no sistema
	 * 
	 * @param resumoFaturamento
	 *            Objeto de resumo de faturamento que vai ser inserido
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void inserirResumoFaturamentoAnoMesReferencia(ResumoFaturamento resumoFaturamento) throws ErroRepositorioException{

		// obtém uma instância com o hibernate
		Session session = HibernateUtil.getSession();
		try{
			// inseri o objeto na base de dados
			session.save(resumoFaturamento);

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 01
	 * Retorna o valor de água
	 * acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual a normal
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no Hibernate
	 */
	public ResumoFaturamento acumularValorAguaSituacaoContaNormal(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(ctcg.valorAgua),cnta.localidade,cnta.localidade.gerenciaRegional,ctcg.comp_id.categoria, cnta.localidade.unidadeNegocio ) "
							+ "from ContaCategoria ctcg "
							+ "inner join ctcg.comp_id.conta cnta "
							+ "left join cnta.localidade loca "
							+ "left join ctcg.comp_id.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
							+ "group by cnta.referencia,cnta.localidade,cnta.localidade.gerenciaRegional,ctcg.comp_id.categoria, cnta.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 02
	 * Retorna o valor de esgoto
	 * acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual a normal
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no Hibernate
	 */
	public ResumoFaturamento acumularValorEsgotoSituacaoContaNormal(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(ctcg.valorEsgoto),cnta.localidade,cnta.localidade.gerenciaRegional,ctcg.comp_id.categoria, cnta.localidade.unidadeNegocio ) "
							+ "from ContaCategoria ctcg "
							+ "inner join ctcg.comp_id.conta cnta "
							+ "left join cnta.localidade loca "
							+ "left join ctcg.comp_id.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
							+ "group by cnta.referencia,cnta.localidade,cnta.localidade.gerenciaRegional,ctcg.comp_id.categoria, cnta.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL).uniqueResult();
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 03 e 04
	 * Retorna uma coleção
	 * de débitos a cobrar por ano e mês de referência, por gerência regional,
	 * localidade e categoria
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @param idLancamentoItemContabil
	 *            Código do itemde lançamento contábil
	 * @return retorna a coleção pesquisada de acordo com os parâmetros
	 *         informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalFinanciamentoServico(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pesquisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
							+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 07
	 * Retorna o valor de guia
	 * de pagamento acumulado, de acordo com o ano/mês de referência, a situação
	 * da conta igual a normal e o tipo de financiamento igual a serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorGuiaPagamentoSituacaoNormalFinanciamentoServico(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		// cria a coleção que vai armazenar o resultado da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(gupg.anoMesReferenciaContabil,sum(gpct.valorCategoria),lcic.sequenciaImpressao,lcic,gupg.localidade,gupg.localidade.gerenciaRegional,gpct.categoria, gupg.localidade.unidadeNegocio ) "
							+ "from GuiaPagamentoCategoria gpct "
							+ "inner join gpct.guiaPagamento gupg "
							+ "inner join gupg.lancamentoItemContabil lcic "
							+ "where gupg.anoMesReferenciaContabil = :anoMesReferencia "
							+ "and gupg.localidade.id = :idLocalidade "
							+ "and gpct.categoria.id = :idCategoria "
							+ "and (gupg.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or gupg.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
							+ "and (gupg.financiamentoTipo = :idFinanciamentoTipo) "
							+ "group by gupg.anoMesReferenciaContabil,lcic.sequenciaImpressao,lcic,gupg.localidade,gupg.localidade.gerenciaRegional,gpct.categoria,gupg.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 17 e 18
	 * Retorna uma coleção
	 * de débitos a cobrar por ano e mês de referência, por gerência regional,
	 * localidade e categoria
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @param idLancamentoItemContabil
	 *            Código de lançamento de item contábil
	 * @return retorna a coleção pesquisada de acordo com os parâmetros
	 *         informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoFinanciamentoServico(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria a coleçãoque vai armazenar os débitos a cobrar pesquisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
							+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 27
	 * Retorna o valor de água
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorAguaSituacaoCancelada(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(ctcg.valorAgua) " + "from ContaCategoria ctcg " + "inner join ctcg.comp_id.conta cnta "
							+ "inner join cnta.localidade loca " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade " + "and ctcg.comp_id.categoria.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 28
	 * Retorna o valor de esgoto
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorEsgotoSituacaoCancelada(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(ctcg.valorEsgoto) " + "from ContaCategoria ctcg " + "inner join ctcg.comp_id.conta cnta "
							+ "inner join cnta.localidade loca " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade " + "and ctcg.comp_id.categoria.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA;

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 29
	 * Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoServicoSituacaoCancelada(int anoMesReferencia, int idLocalidade, int idCategoria,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os resumos de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.lancamentoItemContabil lict " + "inner join dbcb.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join dccg.categoria catg " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and lict.id = :idLancamentoItemContabil " + "and loca.id = :idLocalidade " + "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 30
	 * Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a parcelamento de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoParcelamentoAguaSituacaoCancelada(int anoMesReferencia, int idLocalidade,
					int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta " + "inner join cnta.localidade loca " + "inner join dccg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria " + "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_AGUA).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 31
	 * Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a parcelamento de
	 * esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoParcelamentoEsgotoSituacaoCancelada(int anoMesReferencia, int idLocalidade,
					int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta " + "inner join cnta.localidade loca " + "inner join dccg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria " + "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_ESGOTO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 32
	 * Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a parcelamento de
	 * serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoParcelamentoServicoSituacaoCancelada(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria a coleção que vai armazenar a coleção de resumo de faturamento
		// pesquisados
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.lancamentoItemContabil lict " + "inner join dbcb.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join dccg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and lict.id = :idLancamentoItemContabil "
							+ "and loca.id = :idLocalidade " + "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).setInteger("idLocalidade", idLocalidade)
							.setInteger("idCategoria", idCategoria).setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_SERVICO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 33
	 * Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a cancelada e o tipo de financiamento igual a juros de parcelamento
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoJurosParcelamentoSituacaoCancelada(int anoMesReferencia, int idLocalidade,
					int idCategoria) throws ErroRepositorioException{

		// cria o objetode resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta " + "inner join cnta.localidade loca " + "inner join dccg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria " + "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.JUROS_PARCELAMENTO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 08
	 * Retorna o valor de água
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a incluída
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorAguaSituacaoIncluida(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(ctcg.valorAgua) " + "from ContaCategoria ctcg " + "inner join ctcg.comp_id.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join ctcg.comp_id.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria " + "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "or cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior )";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.INCLUIDA).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 09
	 * Retorna o valor de esgoto
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a incluída
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorEsgotoSituacaoIncluida(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(ctcg.valorEsgoto) " + "from ContaCategoria ctcg " + "inner join ctcg.comp_id.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join ctcg.comp_id.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria " + "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual or "
							+ "cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.INCLUIDA).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 10
	 * Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação da conta
	 * igual a incluída e o tipo de financiamento igual a serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoTipoFinanciamentoServicoSituacaoIncluida(int anoMesReferencia, int idLocalidade, int idCategoria,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria a coleção que vai armazenar a coleção de resumo de faturamento
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.lancamentoItemContabil lict " + "inner join dbcb.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join dccg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and lict.id = :idLancamentoItemContabil "
							+ "and loca.id = :idLocalidade " + "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual or "
							+ "cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).setInteger("idLocalidade", idLocalidade)
							.setInteger("idCategoria", idCategoria).setInteger("idSituacaoAtual", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 62
	 * Retorna o valor de
	 * categoria de débito acumulado, de acordo com o ano/mês de referência, a
	 * situação da conta igual a normal e o tipo de financiamento igual a
	 * serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoTipoFinanciamentoServicoSituacaoNormal(int anoMesReferencia, int idLocalidade,
					int idCategoria) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 41
	 * Retorna o valor de
	 * categoria de débito acumulado, de acordo com o ano/mês de referência, a
	 * situação da conta igual a normal e o tipo de financiamento igual a
	 * serviço, quando o número de prestações cobradas for maior que 11(onze)
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoTipoFinanciamentoServicoSituacaoNormalNumeroPrestacoesCobradasMaiorQue11(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "inner join dbcb.conta cnta "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and dbcb.localidade.id = :idLocalidade "
							+ "and dccg.categoria.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) "
							+ "and ((dbcb.numeroPrestacao - dbcb.numeroPrestacaoDebito) > 11) "
							+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.SERVICO_NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 43 e 44
	 * Retorna uma coleção
	 * de débito a cobrar , de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a documentos emitidos
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoDocumentosEmitidos(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pesquisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
							+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idParcelamentoGrupo", ParcelamentoGrupo.DOCUMENTOS_EMITIDOS)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 45 e 46
	 * Retorna uma coleção
	 * de débito a cobrar , de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a financiamentos a cobrar
	 * de curto prazo
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
							+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idParcelamentoGrupo", ParcelamentoGrupo.FINANCIAMENTOS_A_COBRAR_CURTO_PRAZO)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 47 e 48
	 * Retorna uma coleção
	 * de débito a cobrar de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a financiamentos a cobrar
	 * de longo prazo
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
							+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idParcelamentoGrupo", ParcelamentoGrupo.FINANCIAMENTOS_A_COBRAR_LONGO_PRAZO)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 49 e 50
	 * Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a parcelamentos a cobrar
	 * de curto prazo
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
							+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idParcelamentoGrupo", ParcelamentoGrupo.PARCELAMENTOS_A_COBRAR_CURTO_PRAZO)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 51 e 52
	 * Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a normal e o grupo de parcelamento igual a parcelamentos a cobrar a
	 * longo prazo
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
							+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idParcelamentoGrupo", ParcelamentoGrupo.PARCELAMENTOS_A_COBRAR_LONGO_PRAZO)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 05 e 06
	 * Retorna uma coleção de débitos a cobrar, de acordo com o ano/mês de referência,
	 * a situação igual a normal e o grupo de parcelamento igual a juros cobrados
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoJurosCobrados(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.parcelamentoGrupo.id = :idParcelamentoGrupo "
							+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idParcelamentoGrupo", ParcelamentoGrupo.JUROS_COBRADOS)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Linha 34 e 35 Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a cancelado por parcelamento e o grupo de parcelamento igual a
	 * juros cobrados
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoPorParcelamentoGrupoParcelamentoJurosCobrados(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = "
							+ idLocalidade
							+ " "
							+ "and catg.id = "
							+ idCategoria
							+ " "
							+ "and dbac.parcelamentoGrupo.id = "
							+ ParcelamentoGrupo.JUROS_COBRADOS
							+ " "
							+ "and dbac.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.CANCELADA;

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 53
	 * Retorna o valor de débito
	 * acumulado, de acordo com o ano/mês de referência, a situação igual a
	 * normal e o tipo de financiamento igual a arrasto de água ou arrasto de
	 * esgoto ou arrasto de serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorDebitoSituacaoNormalTipoFinanciamentoArrastoAguaArrastoEsgotoArrastoServico(
					int anoMesReferenciaContabil, Integer idLocalidade) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(dbac.anoMesReferenciaContabil,sum(dbcg.valorCategoria),loca,greg,catg, uneg ) "
							+ "from DebitoACobrarCategoria dbcg " + "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg " + "inner join dbac.financiamentoTipo fntp "
							+ "inner join dbac.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "where loca.id = :idLocalidade "
							+ "and dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and (dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or dbac.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) " + "and (fntp.id = :arrastoAgua or "
							+ "fntp.id = :arrastoEsgoto or " + "fntp.id = :arrastoServico) "
							+ "group by dbac.anoMesReferenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL)
							.setInteger("arrastoAgua", FinanciamentoTipo.ARRASTO_AGUA)
							.setInteger("arrastoEsgoto", FinanciamentoTipo.ARRASTO_ESGOTO)
							.setInteger("arrastoServico", FinanciamentoTipo.ARRASTO_SERVICO).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 19 e 20
	 * Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a cancelado e o tipo de financiamento igual a parcelamento de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoAgua(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
							+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_AGUA)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 21 e 22
	 * Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a cancelado e o tipo de financiamento igual a parcelamento de
	 * esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
							+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_ESGOTO)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 23 e 24
	 * Retorna uma coleção
	 * de débito a cobrar acumulado, de acordo com o ano/mês de referência, a
	 * situação igual a cancelado e o tipo de financiamento igual a parcelamento
	 * de serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoServico(int anoMesReferencia,
					int idLocalidade, int idCategoria, Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.lancamentoItemContabil.id = :idLancamentoItemContabil "
							+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
							+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_SERVICO)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 25 e 26
	 * Retorna uma coleção
	 * de débito a cobrar, de acordo com o ano/mês de referência, a situação
	 * igual a cancelado e o tipo de financiamento igual a juros de parcelamento
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoJurosParcelamento(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a coleção que vai armazenar os débitos a cobrar pequisados
		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new DebitoACobrar(dbcg.valorCategoria,dbac.numeroPrestacaoDebito,dbac.numeroPrestacaoCobradas,dbac.lancamentoItemContabil ) "
							+ "from DebitoACobrarCategoria dbcg "
							+ "inner join dbcg.comp_id.debitoACobrar dbac "
							+ "inner join dbcg.comp_id.categoria catg "
							+ "where dbac.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and dbac.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and dbac.financiamentoTipo.id = :idFinanciamentoTipo "
							+ "and dbac.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.JUROS_PARCELAMENTO)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.CANCELADA).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 64
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * parcelamento de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoAguaSituacaoNormal(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_AGUA).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 65
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * parcelamento de esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoEsgotoSituacaoNormal(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and dbcb.localidade.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_ESGOTO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 66
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * parcelamento de serviços
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoServicosSituacaoNormal(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.PARCELAMENTO_SERVICO).list();
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 67
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * juros de parcelamento
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoJurosParcelamentoSituacaoNormal(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.JUROS_PARCELAMENTO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 42
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * juros de parcelamento e a diferença de prestações maior que 11(onze)
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoJurosParcelamentoSituacaoNormalDiferencaPrestacoesMaiorQue11(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and dbcb.localidade.id = :idLocalidade "
							+ "and dccg.categoria.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
							+ "and (dbcb.financiamentoTipo = :idFinanciamentoTipo) "
							+ "and ((dbcb.numeroPrestacao - dbcb.numeroPrestacaoDebito) > 11) "
							+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.NORMAL)
							.setInteger("idSituacaoAnterior", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.JUROS_PARCELAMENTO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 68
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * arrasto de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoAguaSituacaoNormal(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.ARRASTO_AGUA).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 69
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * arrasto de esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoEsgotoSituacaoNormal(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.ARRASTO_ESGOTO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 70
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * arrasto de serviço
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoServicoSituacaoNormal(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.ARRASTO_SERVICO).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 75
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e a origem do crédito igual a
	 * contas pagas em duplicidade ou em excesso
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoContasPagasEmDuplicidadeEmExcessoSituacaoContaNormal(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
							+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idCreditoOrigem", CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO).uniqueResult();
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 80
	 * Retorna o valor de
	 * categoria de crédito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação de conta igual a normal e a origem do crédito
	 * igual a devolução de tarifa de água
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoTarifaAguaSituacaoContaNormal(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id  = :idSituacao ) "
							+ "and crrz.creditoOrigem.id = :idCreditoOrigem "
							+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idCreditoOrigem", CreditoOrigem.DEVOLUCAO_TARIFA_AGUA).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 81
	 * Retorna o valor de
	 * categoria de crédito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação de conta igual a normal e a origem do crédito
	 * igual a devolução de tarifa de esgoto
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoTarifaEsgotoSituacaoContaNormal(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
							+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idCreditoOrigem", CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 82
	 * Retorna o valor de
	 * categoria de crédito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação de conta igual a normal e a origem do crédito
	 * igual a serviços indiretos pagos indevidamente
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoServicosIndiretosPagosIndevidamenteSituacaoContaNormal(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),lict.sequenciaImpressao,lict,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.lancamentoItemContabil lict "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ "or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
							+ "group by cnta.referencia,lict.sequenciaImpressao,lict,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idCreditoOrigem", CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 83
	 * Retorna o valor de
	 * categoria de crédito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação de conta igual a normal e a origem do crédito
	 * igual a devolução de juros de parcelamento
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoJurosParcelamentoSituacaoContaNormal(
					int anoMesReferencia, int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and crrz.localidade.id = :idLocalidade "
							+ "and crcg.categoria.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
							+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idCreditoOrigem", CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 71
	 * Retorna o valor de
	 * imposto de renda acumulado, de acordo com o ano/mês de referência, a
	 * situação de conta igual a normal e a categoria igual a pública
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorIRSituacaoContaNormalCategoriaPublica(int anoMesReferencia, Integer idLocalidade, Integer idCategoria)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
							+ "from ContaImpostosDeduzidos cnid " + "inner join cnid.impostoTipo imtp " + "inner join cnid.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg " + "where loca.id= :idLocalidade and "
							+ "catg.id = :idCategoria and " + "cnta.referencia = :anoMesReferencia " + "and imtp.id = :idTipoImposto "
							+ " and (cnta.debitoCreditoSituacaoAtual = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) " + "group by cnta.referencia,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idTipoImposto", ImpostoTipo.IR)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 72
	 * Retorna o valor de cofins
	 * acumulado, de acordo com o ano/mês de referência, a situação de conta
	 * igual a normal e a categoria igual a pública
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCOFINSSituacaoContaNormalCategoriaPublica(int anoMesReferencia, Integer idLocalidade, Integer idCategoria)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(cnid.valorImposto),loca,greg,catg,uneg) "
							+ "from ContaImpostosDeduzidos cnid " + "inner join cnid.impostoTipo imtp " + "inner join cnid.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg " + "where loca.id= :idLocalidade " + "and catg.id = :idCategoria "
							+ "and cnta.referencia = :anoMesReferencia " + "and imtp.id = :idTipoImposto "
							+ " and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior = :idSituacao ) " + "group by cnta.referencia,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idTipoImposto", ImpostoTipo.COFINS)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 73
	 * Retorna o valor de csll
	 * acumulado, de acordo com o ano/mês de referência, a situação de conta
	 * igual a normal e a categoria igual a pública
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCSLLSituacaoContaNormalCategoriaPublica(int anoMesReferencia, Integer idLocalidade, Integer idCategoria)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
							+ "from ContaImpostosDeduzidos cnid " + "inner join cnid.impostoTipo imtp " + "inner join cnid.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg " + "where loca.id= :idLocalidade " + "and catg.id = :idCategoria "
							+ "and cnta.referencia = :anoMesReferencia " + "and imtp.id = :idTipoImposto "
							+ " and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ "or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) " + "group by cnta.referencia,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idTipoImposto", ImpostoTipo.CSLL)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 74
	 * Retorna o valor de pis e
	 * pasep acumulado, de acordo com o ano/mês de referência, a situação de
	 * conta igual a normal e a categoria igual a pública
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorPISPASEPSituacaoContaNormalCategoriaPublica(int anoMesReferencia, Integer idLocalidade,
					Integer idCategoria) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
							+ "from ContaImpostosDeduzidos cnid " + "inner join cnid.impostoTipo imtp " + "inner join cnid.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg " + "where loca.id= :idLocalidade " + "and catg.id = :idCategoria "
							+ "and cnta.referencia = :anoMesReferencia " + "and imtp.id = :idTipoImposto "
							+ " and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "group by cnta.referencia,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idTipoImposto", ImpostoTipo.PIS_PASEP)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL).list();
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	// metódos para o sub-fluxo 01 e 02 do [UC0155] - [SB0001]/[SB0002]

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - acumula o valor de
	 * débito cobrado para situação de conta igual a cancelada por retificação
	 * de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaCanceladaPorRetificacao(int anoMesReferencia,
					int idLocalidade, int idCategoria, Integer tipoFinanciamento, Integer itemContabil) throws ErroRepositorioException{

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dccg.categoria ctcg " + "inner join dbcb.lancamentoItemContabil lict "
							+ "inner join dbcb.conta cnta " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and cnta.localidade.id = " + idLocalidade + " " + "and ctcg.id = " + idCategoria + " "
							+ "and dbcb.financiamentoTipo.id = " + tipoFinanciamento + " " + "and lict.id = " + itemContabil + " "
							+ "and cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO;

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - acumula o valor de
	 * débito cobrado para situação de conta igual a retificada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaRetificada(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer tipoFinanciamento, Integer itemContabil) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dccg.categoria ctcg " + "inner join dbcb.lancamentoItemContabil lict "
							+ "inner join dbcb.conta cnta " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and cnta.localidade.id = " + idLocalidade + " " + "and ctcg.id = " + idCategoria + " "
							+ "and dbcb.financiamentoTipo.id = " + tipoFinanciamento + " " + "and lict.id = " + itemContabil + " "
							+ "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.RETIFICADA
							+ " or cnta.debitoCreditoSituacaoAnterior = " + DebitoCreditoSituacao.RETIFICADA + ") ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - acumula o valor de
	 * débito cobrado para situação de conta igual a cancelada por retificação
	 * de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @param tipoFinanciamento
	 *            Tipo de Financiamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaCanceladaPorRetificacao(int anoMesReferencia,
					int idLocalidade, int idCategoria, Integer tipoFinanciamento) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dccg.categoria ctcg " + "inner join dbcb.conta cnta "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and cnta.localidade.id = " + idLocalidade + " "
							+ "and ctcg.id = " + idCategoria + " " + "and dbcb.financiamentoTipo.id = " + tipoFinanciamento + " "
							+ "and cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO;

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - acumula o valor de
	 * débito cobrado para situação de conta igual a retificada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @param tipoFinanciamento
	 *            Tipo de Financiamento
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaRetificada(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer tipoFinanciamento) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg " + "inner join dccg.debitoCobrado dbcb "
							+ "inner join dccg.categoria ctcg " + "inner join dbcb.conta cnta "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and cnta.localidade.id = " + idLocalidade + " "
							+ "and ctcg.id = " + idCategoria + " " + "and dbcb.financiamentoTipo.id = " + tipoFinanciamento + " "
							+ "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.RETIFICADA
							+ " or cnta.debitoCreditoSituacaoAnterior = " + DebitoCreditoSituacao.RETIFICADA + ") ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - acumula o valor de guia
	 * de pagamento para situação de conta igual a cancelada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @param tipoFinanciamento
	 *            Tipo de Financiamento
	 * @param itemContabil
	 *            Item Contábil
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal acumularValorGuiaPagamentoSituacaoCancelada(int anoMesReferencia, int idLocalidade, int idCategoria,
					Integer tipoFinanciamento, Integer itemContabil) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(gpcg.valorCategoria) " + "from GuiaPagamentoCategoria gpcg  " + "inner join gpcg.guiaPagamento gpag "
							+ "inner join gpag.lancamentoItemContabil lict " + "where gpag.anoMesReferenciaContabil = :anoMesReferencia "
							+ "and gpag.localidade.id = " + idLocalidade + " " + "and gpcg.categoria.id = " + idCategoria + " "
							+ "and gpag.financiamentoTipo.id = " + tipoFinanciamento + " " + "and lict.id = " + itemContabil + " "
							+ "and gpag.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA + " ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor de água para situação de conta igual a cancelada por retificação de
	 * acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorAguaSituacaoCanceladaPorRetificacao(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(ctcg.valorAgua) " + "from ContaCategoria ctcg " + "inner join ctcg.comp_id.conta cnta "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and cnta.localidade.id = " + idLocalidade + " "
							+ "and ctcg.comp_id.categoria.id = " + idCategoria + " " + "and cnta.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor de água para situação de conta igual a retificada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorAguaSituacaoRetificada(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(ctcg.valorAgua) " + "from ContaCategoria ctcg " + "inner join ctcg.comp_id.conta cnta "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and cnta.localidade.id = " + idLocalidade + " "
							+ "and ctcg.comp_id.categoria.id = " + idCategoria + " " + "and (cnta.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.RETIFICADA + " or " + "cnta.debitoCreditoSituacaoAnterior = "
							+ DebitoCreditoSituacao.RETIFICADA + ")";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor débito cobrado para situação de conta igual a cancelada por
	 * retificação e parcelamento de água de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorDebitoCobradoParcelamentoAguaSituacaoCanceladaPorRetificacao(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.comp_id.debitoCobrado dbcb " + "inner join dbcb.conta cnta "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and cnta.localidade.id = " + idLocalidade + " "
							+ "and dccg.comp_id.categoria.id = " + idCategoria + " " + "and dbcb.financiamentoTipo.id = "
							+ FinanciamentoTipo.PARCELAMENTO_AGUA + " " + "and cnta.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor débito cobrado para situação de conta igual a retificada e
	 * parcelamento de água de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorDebitoCobradoParcelamentoAguaSituacaoRetificada(int anoMesReferencia, int idLocalidade,
					int idCategoria) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(dccg.valorCategoria) " + "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.comp_id.debitoCobrado dbcb " + "inner join dbcb.conta cnta "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and cnta.localidade.id = " + idLocalidade + " "
							+ "and dccg.comp_id.categoria.id = " + idCategoria + " " + "and dbcb.financiamentoTipo.id = "
							+ FinanciamentoTipo.PARCELAMENTO_AGUA + " " + "and (cnta.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.RETIFICADA + " or " + "cnta.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.RETIFICADA + ")";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor de esgoto para situação de conta igual a cancelada por retificação
	 * de acordo com o ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorEsgotoSituacaoCanceladaPorRetificacao(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(ctcg.valorEsgoto) " + "from ContaCategoria ctcg " + "inner join ctcg.comp_id.conta cnta "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and cnta.localidade.id = " + idLocalidade + " "
							+ "and ctcg.comp_id.categoria.id = " + idCategoria + " " + "and cnta.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - pesquisar a soma do
	 * valor de esgoto para situação de conta igual a retificada de acordo com o
	 * ano/mês de referência
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public BigDecimal pesquisarSomaValorEsgotoSituacaoRetificada(int anoMesReferencia, int idLocalidade, int idCategoria)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select sum(ctcg.valorEsgoto) " + "from ContaCategoria ctcg " + "inner join ctcg.comp_id.conta cnta "
							+ "where cnta.referenciaContabil = :anoMesReferencia " + "and cnta.localidade.id = " + idLocalidade + " "
							+ "and ctcg.comp_id.categoria.id = " + idCategoria + " " + "and (cnta.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.RETIFICADA + " or " + "cnta.debitoCreditoSituacaoAnterior = "
							+ DebitoCreditoSituacao.RETIFICADA + ")";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// fim dos metódos para os sub-fluxos 01 e 02 do [UC0155]

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 08 - atualizar ano mÊs de
	 * referência do faturamento de acordo com o ano/mês de referência
	 * 
	 * @param anoMesFaturamentoAtual
	 *            Ano e mês de referência do faturamento atual
	 * @param anoMesFaturamentoNovo
	 *            Ano e mês de referência do faturamento anterior
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void atualizarAnoMesfaturamento(int anoMesFaturamentoAtual, int anoMesFaturamentoNovo) throws ErroRepositorioException{

		// obtém uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		String atualizarAnoMesFaturamento;

		try{
			// constroi o hql
			atualizarAnoMesFaturamento = "update SistemaParametro " + "set parm_amreferenciafaturamento = " + anoMesFaturamentoNovo + " "
							+ "where parm_amreferenciafaturamento = :anoMesFaturamentoAtual and parmId = "
							+ ConstantesConfig.getIdEmpresa();

			// executa o hql
			session.createQuery(atualizarAnoMesFaturamento).setInteger("anoMesFaturamentoAtual", anoMesFaturamentoAtual).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês - Item 04
	 * Atualiza a situação de imóvel com faturamento finalizado
	 * 
	 * @author Pedro Alexandre
	 * @date 07/10/2006
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarImoveisSituacaoEspecialFaturamentoFinalizada(int anoMesFaturamento, Integer idSetorComercial)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoFaturamentoImovel;
		String atualizarAnoMesFaturamentoRetirada;

		try{
			// Atualiza situação do faturamento do imóvel *******
			atualizarSituacaoFaturamentoImovel = "update Imovel " + "set faturamentoSituacaoTipo = null "
							+ "where setorComercial = :idSetorComercial and faturamentoSituacaoTipo is not null " + "and id in "
							+ "(select distinct (ftsh.imovel.id) " + "from FaturamentoSituacaoHistorico ftsh "
							+ "where ftsh.anoMesFaturamentoSituacaoFim <= :anoMesFaturamento and ftsh.anoMesFaturamentoRetirada is null"
							+ ")";

			session.createQuery(atualizarSituacaoFaturamentoImovel).setInteger("idSetorComercial", idSetorComercial)
							.setInteger("anoMesFaturamento", anoMesFaturamento).executeUpdate();
			// ***************************************************

			// Atualizar o ano/mês de faturamento retirada *******
			atualizarAnoMesFaturamentoRetirada = "update FaturamentoSituacaoHistorico "
							+ "set anoMesFaturamentoRetirada = :anoMesFaturamento "
							+ "where anoMesFaturamentoSituacaoFim <= :anoMesFaturamento "
							+ "and anoMesFaturamentoRetirada is null and imovel in (select imov.id from Imovel imov where imov.setorComercial = :idSetorComercial)";
			// +"imovel.localidade.id = :idLocalidade";

			session.createQuery(atualizarAnoMesFaturamentoRetirada).setInteger("idSetorComercial", idSetorComercial)
							.setInteger("anoMesFaturamento", anoMesFaturamento).executeUpdate();
			// *****************************************************

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 06 - pesquisar contas
	 * canceladas
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<Conta> pesquisarContasCanceladasPorMesAnoReferenciaContabil(int anoMesReferenciaContabil, Integer idLocalidade)
					throws ErroRepositorioException{

		Collection<Conta> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cnta " + "from Conta cnta " + "inner join cnta.localidade loca "
							+ "where loca.id=:idLocalidade and cnta.referenciaContabil <= :anoMesReferenciaContabil "
							+ "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade)
							.setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 05 - pesquisar debitos
	 * cobrados de contas canceladas
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoCobrado> pesquisarDebitosCobradosCanceladosPorMesAnoReferenciaContabil(int anoMesReferenciaContabil,
					Integer idConta) throws ErroRepositorioException{

		Collection<DebitoCobrado> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select dbcb " + "from DebitoCobrado dbcb " + "inner join dbcb.conta cnta "
							+ "where cnta.referenciaContabil <= :anoMesReferenciaContabil " + "and cnta.id = " + idConta + " "
							+ "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.ARRASTADA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 05 - pesquisar debitos
	 * cobrados de contas canceladas
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoCobradoHistorico> pesquisarDebitosCobradosHistoricoCanceladosPorMesAnoReferenciaContabil(
					int anoMesReferenciaContabil, Integer idConta) throws ErroRepositorioException{

		Collection<DebitoCobradoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select dbcb " + "from DebitoCobradoHistorico dbcb " + "inner join dbcb.contaHistorico cnta "
							+ "where cnta.anoMesReferenciaContabil <= :anoMesReferenciaContabil " + "and cnta.id = " + idConta + " "
							+ "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.ARRASTADA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 05 - pesquisar créditos
	 * realizados de contas canceladas
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<CreditoRealizado> pesquisarCreditosRealizadosCanceladosPorMesAnoReferenciaContabil(int anoMesReferenciaContabil,
					Integer idConta) throws ErroRepositorioException{

		Collection<CreditoRealizado> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select crrz " + "from CreditoRealizado crrz " + "inner join crrz.conta cnta "
							+ "where cnta.referenciaContabil <= :anoMesReferenciaContabil " + "and cnta.id = " + idConta + " "
							+ "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.ARRASTADA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 05 - pesquisar créditos
	 * realizados de contas canceladas
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<CreditoRealizadoHistorico> pesquisarCreditosRealizadosCanceladosPorMesAnoReferenciaContabilHistorico(
					int anoMesReferenciaContabil, Integer idConta) throws ErroRepositorioException{

		Collection<CreditoRealizadoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select crrz " + "from CreditoRealizadoHistorico crrz " + "inner join fetch crrz.contaHistorico cnta "
							+ "where cnta.anoMesReferenciaContabil <= :anoMesReferenciaContabil " + "and cnta.id = :idConta "
							+ "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.ARRASTADA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 06 - pesquisar débitos a
	 * cobrar cancelados
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrar> pesquisarDebitosACobrarCanceladosPorMesAnoReferenciaContabil(int anoMesReferenciaContabil,
					Integer idSetorComercial) throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select dbac "
							+ "from DebitoACobrar dbac "
							+ "inner join dbac.imovel imo "
							+ "where imo.setorComercial = :idSetorComercial and dbac.anoMesReferenciaContabil <= :anoMesReferenciaContabil "
							+ "and ((dbac.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA + " or "
							+ "dbac.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + ") " + " or "
							+ "(dbac.numeroPrestacaoDebito = dbac.numeroPrestacaoCobradas) )";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idSetorComercial", idSetorComercial)
							.setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Item 07 - pesquisar créditos a
	 * realizar cancelados
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<CreditoARealizar> pesquisarCreditosARealizarCanceladosPorMesAnoReferenciaContabil(int anoMesReferenciaContabil,
					Integer idSetorComercial) throws ErroRepositorioException{

		Collection<CreditoARealizar> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select crar "
							+ "from CreditoARealizar crar "
							+ "inner join crar.imovel imo "
							+ "where imo.setorComercial = :idSetorComercial and (crar.anoMesReferenciaContabil <= :anoMesReferenciaContabil "
							+ "and (crar.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.CANCELADA + " or "
							+ "crar.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + ") ) " + " or "
							+ "((crar.numeroPrestacaoCredito = crar.numeroPrestacaoRealizada) and crar.valorResidualMesAnterior = 0) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idSetorComercial", idSetorComercial)
							.setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Pesquisa uma coleção de resumos
	 * defaturamento por ano e mês de referência
	 * 
	 * @param anoMesReferenciaContabil
	 *            Ano e mês de referência contabil
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ResumoFaturamento> pesquisarResumoFaturamentoPorAnoMes(int anoMesFaturameto, Integer idLocalidade)
					throws ErroRepositorioException{

		Collection<ResumoFaturamento> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select reft from ResumoFaturamento reft " + "inner join reft.localidade loca "
							+ "where  loca.id =:idLocalidade and reft.anoMesReferencia = :anoMesFaturameto ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade)
							.setInteger("anoMesFaturameto", anoMesFaturameto).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void retificarContaAtualizarSituacao(Conta conta, Integer situacaoAnterior) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			update = "UPDATE gcom.faturamento.conta.Conta SET " + "dcst_idanterior = " + situacaoAnterior
							+ ", dcst_idatual = :situacaoAtual, " + "cnta_amreferenciacontabil = :referenciaContabil, " + "usur_id = "
							+ conta.getUsuario().getId() + " , cnta_tmultimaalteracao = :dataUltimaAlteracao "
							+ "WHERE cnta_id = :idConta ";

			session.createQuery(update).setInteger("situacaoAtual", conta.getDebitoCreditoSituacaoAtual().getId())
							.setInteger("referenciaContabil", conta.getReferenciaContabil())
							.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao()).setInteger("idConta", conta.getId())
							.executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void retificarContaAtualizarValores(Conta conta) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			update = "UPDATE gcom.faturamento.conta.Conta SET " + "last_id = :situacaoAgua, lest_id = :situacaoEsgoto, "
							+ "cnta_dtvencimentoconta = :dataVencimento, cnta_nnconsumoagua = :consumoAgua, "
							+ "cnta_nnconsumoesgoto = :consumoEsgoto, cnta_vlagua = :valorAgua, "
							+ "cnta_vlesgoto = :valorEsgoto, cnta_vldebitos = :valorDebitos, "
							+ "cnta_vlcreditos = :valorCreditos, cnta_pcesgoto = :percentualEsgoto, "
							+ "cnta_dtvalidadeconta = :dataValidade, cnta_amreferenciacontabil = :referenciaContabil, "
							+ "cnta_dtretificacao = :dataRetificacao, cmrt_id = :motivoRetificacao, "
							+ "cnta_tmultimaalteracao = :dataUltimaAlteracao, "
							+ "cnta_vlimpostos = :valorImpostos, usur_id = :usuarioLogado " + "WHERE cnta_id = :idConta ";

			session.createQuery(update).setInteger("situacaoAgua", conta.getLigacaoAguaSituacao().getId())
							.setInteger("situacaoEsgoto", conta.getLigacaoEsgotoSituacao().getId())
							.setDate("dataVencimento", conta.getDataVencimentoConta()).setInteger("consumoAgua", conta.getConsumoAgua())
							.setInteger("consumoEsgoto", conta.getConsumoEsgoto()).setBigDecimal("valorAgua", conta.getValorAgua())
							.setBigDecimal("valorEsgoto", conta.getValorEsgoto()).setBigDecimal("valorDebitos", conta.getDebitos())
							.setBigDecimal("valorCreditos", conta.getValorCreditos())
							.setBigDecimal("percentualEsgoto", conta.getPercentualEsgoto())
							.setDate("dataValidade", conta.getDataValidadeConta())
							.setInteger("referenciaContabil", conta.getReferenciaContabil())
							.setDate("dataRetificacao", conta.getDataRetificacao())
							.setInteger("motivoRetificacao", conta.getContaMotivoRetificacao().getId())
							.setTimestamp("dataUltimaAlteracao", conta.getUltimaAlteracao()).setInteger("idConta", conta.getId())
							.setBigDecimal("valorImpostos", conta.getValorImposto())
							.setInteger("usuarioLogado", conta.getUsuario().getId()).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void removerContaCategoria(Conta conta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection<ContaCategoria> categorias = new ArrayList();

		try{
			categorias = session.createQuery("FROM gcom.faturamento.conta.ContaCategoria ctcg WHERE ctcg.comp_id.conta.id = :idConta")
							.setInteger("idConta", conta.getId()).list();

			Iterator iterator = categorias.iterator();

			while(iterator.hasNext()){

				ContaCategoria contaCateg = (ContaCategoria) iterator.next();

				session.delete(contaCateg);
				// iterator.remove();

			}

			session.flush();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void removerDebitoCobrado(Conta conta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection debitosBase = null;
		try{
			debitosBase = session.createQuery("FROM gcom.faturamento.debito.DebitoCobrado dbcb WHERE dbcb.conta.id = :idConta")
							.setInteger("idConta", conta.getId()).list();
			Iterator iterator = debitosBase.iterator();

			while(iterator.hasNext()){
				DebitoCobrado debito = (DebitoCobrado) iterator.next();

				session.delete(debito);
				iterator.remove();
			}

			session.flush();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 23/01/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void removerCreditoRealizado(Conta conta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			Iterator iterator = session.createQuery("FROM gcom.faturamento.credito.CreditoRealizado crrz WHERE crrz.conta.id = :idConta")
							.setInteger("idConta", conta.getId()).iterate();

			while(iterator.hasNext()){
				CreditoRealizado credito = (CreditoRealizado) iterator.next();

				session.delete(credito);
				iterator.remove();

			}

			session.flush();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento Author: Rafael Santos
	 * Data:03/02/2006
	 * 
	 * @param imovelID
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	/*
	 * public Collection<DebitoACobrar>
	 * pesquisarDebitosACobrarCanceladosPorMesAnoReferenciaContabil( int
	 * anoMesReferenciaContabil) throws ErroRepositorioException { Collection<DebitoACobrar>
	 * retorno = null; // cria uma sessão com o hibernate Session session =
	 * HibernateUtil.getSession(); // cria a variável que vai conter o hql
	 * String consulta;
	 * try { // constroi o hql consulta = "select dbac " + "from DebitoACobrar
	 * dbac " + "where (dbac.anoMesReferenciaContabil <=
	 * :anoMesReferenciaContabil " + "and (dbac.debitoCreditoSituacaoAtual = " +
	 * DebitoCreditoSituacao.CANCELADA + " or " +
	 * "dbac.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.PARCELADA + ") ) " + "
	 * or " + "(dbac.numeroPrestacaoDebito = dbac.numeroPrestacaoCobradas) "; //
	 * executa o hql retorno = session.createQuery(consulta).setInteger(
	 * "anoMesReferenciaContabil", anoMesReferenciaContabil) .list(); } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * [UC0113] - Gerar Faturamento Grupo Author: Rafael Santos Data: 16/02/2006
	 * retorna o objeto debito automatico movimento
	 * 
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	/*
	 * public Object obterDebitoAutomatico(Integer idImovel) throws
	 * ErroRepositorioException {
	 * Object retorno = null;
	 * Session session = HibernateUtil.getSession(); String consulta;
	 * try { consulta = "SELECT da " + "FROM DebitoAutomatico da " + "INNER JOIN
	 * cnta.imovel imov " + "WHERE imov.id = :idImovel AND " + "da.dataExclusao
	 * is null ";
	 * retorno = session.createQuery(consulta).setInteger("idImovel",
	 * idImovel.intValue()).setMaxResults(1).uniqueResult(); } catch
	 * (HibernateException e) { // levanta a exceção para a próxima camada throw
	 * new ErroRepositorioException(e, "Erro no Hibernate"); } finally { //
	 * fecha a sessão HibernateUtil.closeSession(session); }
	 * return retorno; }
	 */

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Retorna o código do débito automático.
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 16/02/2006,18/09/2006
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public DebitoAutomatico obterObjetoDebitoAutomatico(Integer idImovel) throws ErroRepositorioException{

		DebitoAutomatico retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select da " + "from DebitoAutomatico da " + "inner join da.imovel imov " + "inner join fetch da.agencia agen "
							+ "inner join fetch agen.banco banc " + "where imov.id = :idImovel and " + "da.dataExclusao is null ";

			retorno = (DebitoAutomatico) session.createQuery(consulta).setInteger("idImovel", idImovel.intValue()).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Retorna o código do débito automático.
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 16/02/2006,18/09/2006
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer obterDebitoAutomatico(Integer idImovel) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select da.id " + "from DebitoAutomatico da " + "inner join da.imovel imov " + "where imov.id = :idImovel and "
							+ "da.dataExclusao is null and imov.indicadorDebitoConta = " + ConstantesSistema.SIM;

			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Gerar Faturamento Grupo Author: Rafael Santos Data: 16/02/2006
	 * (utilizado pelo [UC0084])
	 * 
	 * @author eduardo henrique
	 * @date 25/09/2008
	 *       (Alteração para inclusão de novos atributos necessários para o UC. v0.05)
	 * @author eduardo henrique
	 * @date 22/11/2008
	 *       Mudança na consulta para não realizar join de ClientesImovel com apenas alguns tipos de
	 *       Cliente.
	 * @author eduardo henrique
	 * @date 07/01/2009
	 *       Paginação do hibernate desativada, por forma inadequada de execução para o cache do
	 *       Oracle.
	 *       Dados do Imovel para o caso de Uso
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImovelGrupoFaturamento(Integer idRota, Collection<Integer> colecaoMatriculasComandoSimulacaoFaturamento)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Query query = null;

		try{
			consulta = "select distinct "
							+ "imoveis.ligacaoAguaSituacao.id," // 0
							+ "imoveis.ligacaoEsgotoSituacao.id," // 1
							+ "consumoTarifa.id, " // 2
							+ "localidade.id," // 3
							+ "quadras.id," // 4
							+ "quadras.numeroQuadra," // 5
							+ "imoveis.lote," // 6
							+ "setorComercial.codigo," // 7
							+ "faturamentoTipo.id, " // 8
							+ "imovelPerfil.id," // 9
							+ "imoveis.indicadorDebitoConta," // 10
							+ "imovelContaEnvio.id," // 11
							+ "imoveis.subLote, " // 12
							+ "imoveis.indicadorEmissaoExtratoFaturamento, " // 13
							+ "localidade.gerenciaRegional.id," // 14
							+ "setorComercial.id," // 15
							+ "imoveis.rota.id," // 16
							+ "esferaPoder.id, " // 17
							+ "imoveis.id, " // 18
							+ "imoveis.diaVencimento, " // 19
							+ "ligacaoAguaSituacao.indicadorFaturamentoSituacao, " // 20
							+ "ligacaoEsgotoSituacao.indicadorFaturamentoSituacao, " // 21
							+ "leituristaRota.id, " // 22
							+ "empresaRota.id, " // 23
							+ "areaTipo.descricao, " // 24
							+ "hidInstHistoricoAgua," // 25
							+ "hidInstHistoricoPoco, " // 26
							+ "medTipoAgua.id, "// 27
							+ "medTipoPoco.id, "// 28
							+ "ligacaoAgua.id, " // 29
							+ "ligacaoAgua.numeroConsumoMinimoAgua, " // 30
							+ "ligacaoEsgoto.consumoMinimo, " // 31
							+ "imoveis.quantidadeEconomias, " // 32
							+ "ligacaoEsgoto.percentualAguaConsumidaColetada, " // 33
							+ "rota.codigo, " // 34
							+ "ligacaoAgua.dataCorte, " // 35
							+ "ligacaoEsgotoPerfil.percentualEsgotoConsumidaColetada, " // 36
							+ "localidade.unidadeNegocio.id, " // 37
							+ "consumoTarifaTemporaria.id, " // 38
							+ "imoveis.dataValidadeTarifaTemporaria " // 39
							+ "from Imovel imoveis " + "left join imoveis.rota rota " + "left join imoveis.quadra quadras "
							+ "left join imoveis.consumoTarifa consumoTarifa  " + "left join imoveis.localidade localidade  "
							+ "left join quadras.areaTipo areaTipo " + "left join rota.leiturista leituristaRota "
							+ "left join rota.empresa empresaRota " + "left join imoveis.imovelPerfil imovelPerfil "
							+ "left join imoveis.setorComercial setorComercial  " + "left join imoveis.faturamentoTipo faturamentoTipo  "
							+ "left join imoveis.consumoTarifa consumoTarifa  " + "left join imoveis.imovelContaEnvio imovelContaEnvio "
							+ "left join imoveis.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "left join imoveis.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
							+ "left join imoveis.hidrometroInstalacaoHistorico hidInstHistoricoPoco "
							+ "left join imoveis.ligacaoAgua ligacaoAgua " + "left join imoveis.ligacaoEsgoto ligacaoEsgoto "
							+ "left join ligacaoEsgoto.ligacaoEsgotoPerfil ligacaoEsgotoPerfil "
							+ "left join ligacaoAgua.hidrometroInstalacaoHistorico hidInstHistoricoAgua "
							+ "left join hidInstHistoricoAgua.hidrometroProtecao "
							+ "left join hidInstHistoricoAgua.hidrometroLocalInstalacao " + "left join hidInstHistoricoAgua.hidrometro "
							+ "left join hidInstHistoricoPoco.hidrometroProtecao "
							+ "left join hidInstHistoricoPoco.hidrometroLocalInstalacao " + "left join hidInstHistoricoPoco.hidrometro "
							+ "left join hidInstHistoricoAgua.medicaoTipo medTipoAgua "
							+ "left join hidInstHistoricoPoco.medicaoTipo medTipoPoco "
							+ "left join imoveis.consumoTarifaTemporaria consumoTarifaTemporaria "
							+ "left outer join imoveis.clienteImoveis clienteImoveisReposanvel "
							+ "left outer join clienteImoveisReposanvel.cliente clienteResposanvel "
							+ "left outer join clienteResposanvel.clienteTipo clienteTipo "
							+ "left outer join clienteTipo.esferaPoder esferaPoder " + "where rota.id = :rotaId "
							+ "and imoveis.indicadorImovelCondominio <> 1 ";

			if(!Util.isVazioOrNulo(colecaoMatriculasComandoSimulacaoFaturamento)){

				consulta += "and imoveis.id in (:idsImovel) ";
			}

			consulta += "order by quadras.numeroQuadra ";

			query = session.createQuery(consulta).setInteger("rotaId", idRota.intValue());

			if(!Util.isVazioOrNulo(colecaoMatriculasComandoSimulacaoFaturamento)){

				if(colecaoMatriculasComandoSimulacaoFaturamento.size() > 1000){

					Collection colecaoAuxiliar = new ArrayList<Object>();
					retorno = new ArrayList<Object>();
					for(Object idImovel : colecaoMatriculasComandoSimulacaoFaturamento){

						colecaoAuxiliar.add(idImovel);

						if(colecaoAuxiliar.size() == 1000){

							retorno.addAll(query.setInteger("rotaId", idRota.intValue()).setParameterList("idsImovel", colecaoAuxiliar)
											.list());
							colecaoAuxiliar.clear();
						}
					}
					if(!colecaoAuxiliar.isEmpty()){
						retorno.addAll(query.setInteger("rotaId", idRota.intValue()).setParameterList("idsImovel", colecaoAuxiliar).list());
					}

				}else{

					retorno = query.setInteger("rotaId", idRota.intValue())
									.setParameterList("idsImovel", colecaoMatriculasComandoSimulacaoFaturamento).list();
				}
			}else{

				retorno = query.setInteger("rotaId", idRota.intValue()).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Felipe Rosacruz
	 * @date 22/04/2014
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImoveisGrupoFaturamento(Collection<Integer> idsRota,
					Collection<Integer> colecaoMatriculasComandoSimulacaoFaturamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Query query = null;

		try{
			consulta = "select distinct " + "imoveis.id " + "from Imovel imoveis " + "left join imoveis.rota rota "
							+ "where rota.id in (:rotaId) " + "and imoveis.indicadorImovelCondominio <> 1 ";

			if(!Util.isVazioOrNulo(colecaoMatriculasComandoSimulacaoFaturamento)){

				consulta += "and imoveis.id in (:idsImovel) ";
			}

			query = session.createQuery(consulta).setParameterList("rotaId", idsRota);

			if(!Util.isVazioOrNulo(colecaoMatriculasComandoSimulacaoFaturamento)){

				if(colecaoMatriculasComandoSimulacaoFaturamento.size() > 1000){

					Collection colecaoAuxiliar = new ArrayList<Object>();
					retorno = new ArrayList<Object>();
					for(Object idImovel : colecaoMatriculasComandoSimulacaoFaturamento){

						colecaoAuxiliar.add(idImovel);

						if(colecaoAuxiliar.size() == 1000){

							retorno.addAll(query.setParameterList("rotaId", idsRota).setParameterList("idsImovel", colecaoAuxiliar).list());
							colecaoAuxiliar.clear();
						}
					}
					if(!colecaoAuxiliar.isEmpty()){
						retorno.addAll(query.setParameterList("rotaId", idsRota).setParameterList("idsImovel", colecaoAuxiliar).list());
					}

				}else{

					retorno = query.setParameterList("rotaId", idsRota)
									.setParameterList("idsImovel", colecaoMatriculasComandoSimulacaoFaturamento).list();
				}
			}else{

				retorno = query.setParameterList("rotaId", idsRota).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Gerar Faturamento Grupo Author: Rafael Santos Data: 16/02/2006
	 * Dados do Cliente Imovel
	 * 
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Short pesquisarClienteImovelGrupoFaturamento(Integer idImovel, Integer relacaoTipo) throws ErroRepositorioException{

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cliente.dataVencimento " + "from ClienteImovel clienteImovel  " + "inner join clienteImovel.imovel imovel "
							+ "inner join clienteImovel.clienteRelacaoTipo clienteRelacaoTipo "
							+ "inner join clienteImovel.cliente cliente " + "inner join cliente.clienteTipo clienteTipo "
							+ "where imovel.id = :idImovel and " + "clienteRelacaoTipo.id = :relacaoTipo and "
							+ "clienteImovel.dataFimRelacao is null";

			Object pesquisa = session.createQuery(consulta).setInteger("idImovel", idImovel.intValue())
							.setInteger("relacaoTipo", relacaoTipo.shortValue()).setMaxResults(1).uniqueResult();

			if(pesquisa != null){
				retorno = (Short) pesquisa;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores Author: Sávio Luiz Data:
	 * 01/02/2006
	 * retorna o objeto debito automatico movimento
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public DebitoAutomaticoMovimento obterDebitoAutomaticoMovimento(Integer idImovel, Integer anoMesReferencia)
					throws ErroRepositorioException{

		DebitoAutomaticoMovimento retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			// Consulta os movimentos que sejam de inclusão com retorno não processado, pois os
			// movimentos de exclusão não geram retorno do banco.

			consulta.append("SELECT dam ");
			consulta.append("FROM DebitoAutomaticoMovimento dam ");
			consulta.append("INNER JOIN dam.contaGeral contaGeral ");
			consulta.append("INNER JOIN contaGeral.conta cnta ");
			consulta.append("INNER JOIN cnta.imovel imov ");
			consulta.append("INNER JOIN cnta.debitoCreditoSituacaoAtual dcst ");
			consulta.append("WHERE imov.id = :idImovel ");
			consulta.append("  AND cnta.referencia = :anoMesReferencia ");
			consulta.append("  AND cnta.debitoCreditoSituacaoAtual.id IN (:normal, :incluida, :retificada) ");
			consulta.append("  AND dam.numeroSequenciaArquivoEnviado IS NOT NULL ");
			consulta.append("  AND dam.numeroSequenciaArquivoRecebido IS NULL ");
			consulta.append("  AND dam.indicadorExclusao IS NULL ");
			consulta.append("  AND dam.debitoAutomaticoMovimentoCancelamentoMotivo IS NULL ");
			consulta.append("ORDER BY dam.numeroSequenciaArquivoEnviado ");

			Query query = session.createQuery(consulta.toString());

			query.setInteger("idImovel", idImovel.intValue());
			query.setInteger("normal", DebitoCreditoSituacao.NORMAL);
			query.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA);
			query.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA);
			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = (DebitoAutomaticoMovimento) query.setMaxResults(1).uniqueResult();

			if(retorno == null){
				consulta = new StringBuilder();
				consulta.append("SELECT dam ");
				consulta.append("FROM DebitoAutomaticoMovimento dam ");
				consulta.append("INNER JOIN dam.contaGeral contaGeral ");
				consulta.append("INNER JOIN contaGeral.contaHistorico cnta ");
				consulta.append("INNER JOIN cnta.imovel imov ");
				consulta.append("INNER JOIN cnta.debitoCreditoSituacaoAtual dcst ");
				consulta.append("WHERE imov.id = :idImovel ");
				consulta.append("  AND cnta.anoMesReferenciaConta = :anoMesReferencia ");
				consulta.append("  AND cnta.debitoCreditoSituacaoAtual.id IN (:normal, :incluida, :retificada) ");
				consulta.append("  AND dam.numeroSequenciaArquivoEnviado IS NOT NULL ");
				consulta.append("  AND dam.numeroSequenciaArquivoRecebido IS NULL ");
				consulta.append("  AND dam.indicadorExclusao IS NULL ");
				consulta.append("  AND dam.debitoAutomaticoMovimentoCancelamentoMotivo IS NULL ");
				consulta.append("ORDER BY dam.numeroSequenciaArquivoEnviado ");

				query = session.createQuery(consulta.toString());

				query.setInteger("idImovel", idImovel.intValue());
				query.setInteger("normal", DebitoCreditoSituacao.NORMAL);
				query.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA);
				query.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA);
				query.setInteger("anoMesReferencia", anoMesReferencia);

				retorno = (DebitoAutomaticoMovimento) query.setMaxResults(1).uniqueResult();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores Author: Sávio Luiz Data:
	 * 01/02/2006
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaContaComSituacaoAtual(Imovel imovel, int anoMesReferencia) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select cnta_id as idConta ").append("FROM conta  ").append("WHERE cnta_amreferenciaconta = :referencia ")
							.append("and imov_id = :idImovel  ").append("and dcst_idatual in ( ").append(DebitoCreditoSituacao.NORMAL)
							.append(", ").append(DebitoCreditoSituacao.INCLUIDA).append(", ").append(DebitoCreditoSituacao.RETIFICADA)
							.append(", ").append(DebitoCreditoSituacao.PRE_FATURADA).append(", ")
							.append(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO).append(", ").append(DebitoCreditoSituacao.PRESCRITA)
							.append(" ) ");

			retorno = (Integer) session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.INTEGER)
							.setInteger("referencia", anoMesReferencia).setInteger("idImovel", imovel.getId().intValue()).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras [SF0003] - Processar
	 * Pagamento de Documento de Cobrança Author: Sávio Luiz Data: 01/02/2006
	 * retorna o objeto debito automatico movimento
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSituacaoAtualDebitoACobrar(Integer idDebitoACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "update gcom.faturamento.debito.DebitoACobrar "
							+ "set dcst_idatual = :idSituacaoAtual where dbac_id = :idDebitoACobrar";

			session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar.intValue())
							.setInteger("idSituacaoAtual", DebitoCreditoSituacao.PAGA);

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @created 16/02/2006
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarFaturaItem(Integer idCliente, Integer anoMesReferencia, Integer numeroSequencial, BigDecimal valordebito)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{
			// Verifica se já tem débito automático
			consulta = "SELECT fi.valorConta, conta.id, localidade.id, " + "imovel.id, localidadeHistorico.id, imovelHistorico.id "
							+ "FROM FaturaItem fi " + "LEFT JOIN fi.fatura fatura " + "LEFT JOIN fi.contaGeral contaGeral "
							+ "LEFT JOIN contaGeral.conta conta " + "LEFT JOIN contaGeral.contaHistorico contaHistorico "
							+ "LEFT JOIN conta.imovel imovel " + "LEFT JOIN conta.localidade localidade "
							+ "LEFT JOIN contaHistorico.imovel imovelHistorico "
							+ "LEFT JOIN contaHistorico.localidade localidadeHistorico " + "LEFT JOIN fatura.cliente cliente "
							+ "WHERE cliente.id = :idCliente AND " + "fatura.anoMesReferencia = :anoMesReferencia AND "
							+ "fatura.sequencial = :numeroSequencial AND " + "fatura.debito = :valordebito";

			retorno = session.createQuery(consulta).setInteger("idCliente", idCliente.intValue())
							.setInteger("anoMesReferencia", anoMesReferencia.intValue())
							.setInteger("numeroSequencial", numeroSequencial.intValue()).setBigDecimal("valordebito", valordebito)

			.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Saulo Lima
	 * @created 16/12/2008
	 * @param idCliente
	 * @param numeroSequencial
	 * @param valordebito
	 * @return Collection<Object>
	 * @exception ErroRepositorioException
	 */
	public Collection<Object> pesquisarFaturaItem(Integer idCliente, Integer numeroSequencial, BigDecimal valordebito)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{
			consulta = "SELECT fi.valorConta, conta.id, localidade.id, " + "imovel.id, localidadeHistorico.id, imovelHistorico.id "
							+ "FROM FaturaItem fi " + "LEFT JOIN fi.fatura fatura " + "LEFT JOIN fi.contaGeral contaGeral "
							+ "LEFT JOIN contaGeral.conta conta " + "LEFT JOIN contaGeral.contaHistorico contaHistorico "
							+ "LEFT JOIN conta.imovel imovel " + "LEFT JOIN conta.localidade localidade "
							+ "LEFT JOIN contaHistorico.imovel imovelHistorico "
							+ "LEFT JOIN contaHistorico.localidade localidadeHistorico " + "LEFT JOIN fatura.cliente cliente "
							+ "WHERE cliente.id = :idCliente AND " + "fatura.sequencial = :numeroSequencial AND "
							+ "fatura.debito = :valordebito";

			retorno = session.createQuery(consulta).setInteger("idCliente", idCliente.intValue())
							.setInteger("numeroSequencial", numeroSequencial.intValue()).setBigDecimal("valordebito", valordebito).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta os ids dos imóveis para atualizar
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 17/03/2006
	 * @param situacaoEspecialFaturamentoHelper
	 * @return
	 * @throws ErroRepositorioException
	 * @date 08/04/2014
	 * @author Felipe Rosacruz
	 *         Modificado para fazer o registro das transações
	 */
	public Collection consultaIdImovelParaAtualizarAnoMesFaturamentoSituacaoHistorico(
					SituacaoEspecialFaturamentoHelper situacaoEspecialFaturamentoHelper) throws ErroRepositorioException{

		String consulta = "";
		Collection collectionIdImoveis = null;

		Session session = HibernateUtil.getSession();
		try{
			consulta = "select im.id from Imovel im" + " inner join im.localidade lo" + " inner join im.setorComercial sc"
							+ " inner join im.quadra qu" + " inner join qu.rota rt" + " inner join rt.faturamentoGrupo fg"
								+ " left join im.faturamentoSituacaoTipo fst"
								+ " where fst.id is not null and (im.indicadorExclusao <> :idExclusao OR im.indicadorExclusao is null) and ";

				String idLocalidadeOrigem = situacaoEspecialFaturamentoHelper.getLocalidadeOrigemID();
				String idLocalidadeDestino = situacaoEspecialFaturamentoHelper.getLocalidadeDestinoID();
				String setorComercialOrigemID = situacaoEspecialFaturamentoHelper.getSetorComercialOrigemID();
				String setorComercialDestinoID = situacaoEspecialFaturamentoHelper.getSetorComercialDestinoID();
				String quadraOrigemID = situacaoEspecialFaturamentoHelper.getQuadraOrigemID();
				String quadraDestinoID = situacaoEspecialFaturamentoHelper.getQuadraDestinoID();
				String loteOrigem = situacaoEspecialFaturamentoHelper.getLoteOrigem();
				String loteDestino = situacaoEspecialFaturamentoHelper.getLoteDestino();
				String subLoteOrigem = situacaoEspecialFaturamentoHelper.getSubloteOrigem();
				String subLoteDestino = situacaoEspecialFaturamentoHelper.getSubloteDestino();

				if(!idLocalidadeOrigem.equalsIgnoreCase("") && !idLocalidadeDestino.equalsIgnoreCase("")) consulta += " lo.id between "
								+ idLocalidadeOrigem + " and " + idLocalidadeDestino + " and ";

				if(!setorComercialOrigemID.equalsIgnoreCase("") && !setorComercialOrigemID.equalsIgnoreCase("")) consulta += "sc.id between "
								+ setorComercialOrigemID + " and " + setorComercialDestinoID + " and ";

			if(!quadraOrigemID.equalsIgnoreCase("") && !quadraOrigemID.equalsIgnoreCase("")) consulta += "qu.id between " + quadraOrigemID
							+ " and " + quadraDestinoID + " and ";

			if(!loteOrigem.equalsIgnoreCase("") && !loteOrigem.equalsIgnoreCase("")) consulta += "im.lote between " + loteOrigem + " and "
							+ loteDestino + " and ";

				if(!subLoteOrigem.equalsIgnoreCase("") && !subLoteOrigem.equalsIgnoreCase("")) consulta += "im.subLote between "
								+ subLoteOrigem + " and " + subLoteDestino + " and ";

			collectionIdImoveis = session.createQuery(Util.formatarHQL(consulta, 4)).setShort("idExclusao", Imovel.IMOVEL_EXCLUIDO).list();

			// if(collectionIdImoveis != null && !collectionIdImoveis.isEmpty()){
			//
			// Iterator icolecaoMatriculasImoveis = collectionIdImoveis.iterator();
			//
			// while(icolecaoMatriculasImoveis.hasNext()){
			//
			// String id = ((Integer) icolecaoMatriculasImoveis.next()).toString();
			// consulta = "update gcom.faturamento.FaturamentoSituacaoHistorico set "
			// + "ftsh_amfaturamentoretirada = :anoMesReferenciaFaturamentoGrupo,"
			// + "ftsh_tmultimaalteracao = :ultimaAlteracao where imov_id = :imov"
			// + " and ftsh_amfaturamentoretirada is null";
			//
			// session.createQuery(consulta).setInteger("imov",
			// Integer.valueOf(id).intValue()).setInteger(
			// "anoMesReferenciaFaturamentoGrupo", anoMesReferenciaFaturamentoGrupo).setTimestamp(
			// "ultimaAlteracao", new Date()).executeUpdate();
			// }
			// }
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return collectionIdImoveis;
	}

	/**
	 * O sistema seleciona as atividades que foram previamente comandadas e
	 * ainda não realizadas (a partir da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA
	 * com FTCM_ID = FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL e
	 * FTAC_TMCOMANDO preenchido e FTAC_TMREALIZACAO não preenchido ou com um
	 * valor anterior à FTAC_TMCOMANDO)
	 * 
	 * @author Roberta Costa
	 * @date 29/03/2006
	 * @param FaturamentoGrupoCronogramaMensal
	 * @return Collection<FaturamentoAtividadeCronograma>
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoAtividadeCronograma> pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizada(Integer numeroPagina)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		// Collection retorno = new ArrayList();
		Collection colecaoAtividadeCronograma = new ArrayList();
		String consulta = null;

		try{

			/*
			 * consulta = " SELECT ftac FROM FaturamentoAtividadeCronograma as
			 * ftac " + " INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm " + "
			 * INNER JOIN ftac.faturamentoAtividade ftat " + " WHERE ftcm.id IN" + " ( " + "
			 * select fgcm.id " + " from FaturamentoGrupoCronogramaMensal fgcm " + " )" + "
			 * AND ftac.comando IS NOT NULL AND (ftac.dataRealizacao IS NULL " + "
			 * OR ftac.dataRealizacao < ftac.comando)";
			 */
			consulta = " SELECT ftac FROM FaturamentoAtividadeCronograma ftac "
							+ " INNER JOIN FETCH ftac.faturamentoGrupoCronogramaMensal ftcm "
							+ " INNER JOIN FETCH ftcm.faturamentoGrupo ftgr " + " INNER JOIN FETCH ftac.faturamentoAtividade ftat "
							+ " WHERE ftcm.id IN" + " ( " + " select fgcm.id " + " from FaturamentoGrupoCronogramaMensal fgcm " + " )"
							+ " AND ftac.comando IS NOT NULL AND (ftac.dataRealizacao IS NULL  "
							+ " OR ftac.dataRealizacao < ftac.comando)";

			// Iterator<FaturamentoAtividadeCronograma> iterator = null;

			// Para paginação deve-se pegar o resultado da consulta
			// multiplicando o número de páginas por 10
			// com um máximo de 10 registros por vez
			colecaoAtividadeCronograma = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta)
							.setFirstResult(10 * numeroPagina).setMaxResults(10).list()));

			/**
			 * alterado por pedro alexandre dia 23/01/2007
			 */
			/*
			 * iterator = colecaoAtividadeCronograma.iterator(); while
			 * (iterator.hasNext()) {
			 * FaturamentoAtividadeCronograma faturamentoAtividadeCronograma =
			 * iterator .next(); // carrega todos os objetos
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoAtividade());
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal
			 * ());
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal
			 * ().getFaturamentoGrupo());
			 * retorno.add(faturamentoAtividadeCronograma); }
			 */
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// return retorno;
		return colecaoAtividadeCronograma;
	}

	/**
	 * Retorna o count do resultado da pesquisa de Faturamento Atividade
	 * Cronograma
	 * pesquisarFaturamentoAtividadeCronogramaCount
	 * 
	 * @author Roberta Costa
	 * @date 05/05/2006
	 * @param FaturamentoGrupoCronogramaMensal
	 *            faturamentoGrupoCronogramaMensal
	 * @param Integer
	 *            numeroPagina
	 * @return Integer retorno
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizadaCount() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try{
			consulta = "SELECT count(ftac.id) FROM FaturamentoAtividadeCronograma ftac "
							+ "INNER JOIN ftac.faturamentoGrupoCronogramaMensal ftcm " + "INNER JOIN ftac.faturamentoAtividade ftat "
							+ "WHERE ftcm.id IN ( " + "select fgcm.id " + "from FaturamentoGrupoCronogramaMensal fgcm " + " ) AND "
							+ "ftac.comando IS NOT NULL AND (ftac.dataRealizacao IS NULL OR " + "ftac.dataRealizacao < ftac.comando)";

			retorno = ((Number) session.createQuery(consulta).uniqueResult()).intValue();
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna todos os imóveis que tenham cliente responsável e
	 * indicacao de conta a ser entregue em outro endereço e que estejam nas
	 * quadras pertencentes às rotas passadas
	 * UC0209 Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Thiago Toscano
	 * @date 04/04/2006
	 * @param rotas
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterImoveisPorRotasComContaEntregaEmOutroEndereco(Integer idRota) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select i.localidade.id, i.setorComercial.codigo, q.numeroQuadra, " + "q.id , i.id ,i.lote, i.subLote, ip.id "
							+ "from ClienteImovel ci " + "inner join ci.imovel i " + "inner join ci.cliente clie "
							+ "inner join clie.clienteTipo cltp " + "inner join cltp.esferaPoder epod "
							+ "inner join ci.clienteRelacaoTipo crt " + "inner join i.quadra q " + "inner join i.setorComercial sc "
							+ "inner join i.imovelPerfil ip " + "where ci.dataFimRelacao is null " + "and epod.id= :idEsferaPoder "
							+ "and i.rota.id = :idRota " + " and crt.id = " + ClienteRelacaoTipo.RESPONSAVEL
							+ " and (i.imovelContaEnvio.id <> " + ImovelContaEnvio.ENVIAR_IMOVEL + " )";

			retorno = session.createQuery(consulta).setInteger("idRota", idRota).setInteger("idEsferaPoder", EsferaPoder.PARTICULAR).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Metodo que retorno o debito Tipo do id passado
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author thiago
	 * @date 05/04/2006
	 * @param id
	 * @return
	 * @throws ErroRepositorioException
	 */
	public DebitoTipo getDebitoTipo(Integer id) throws ErroRepositorioException{

		DebitoTipo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select debitoTipo " + "from DebitoTipo debitoTipo " + "left join fetch debitoTipo.financiamentoTipo "
							+ "left join fetch debitoTipo.lancamentoItemContabil " + "where debitoTipo.id = :idDebitoTipo ";

			Object pesquisa = session.createQuery(consulta).setInteger("idDebitoTipo", id.intValue()).setMaxResults(1).uniqueResult();

			if(pesquisa != null){
				retorno = (DebitoTipo) pesquisa;
				/**
				 * alterado por pedro alexandre dia 23/01/2007
				 */
				// Hibernate.initialize(retorno.getFinanciamentoTipo());
				// /Hibernate.initialize(retorno.getLancamentoItemContabil());
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metodo que retorno o debito Tipo do id passado
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author thiago
	 * @date 05/04/2006
	 * @param id
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] getDebitoTipoHql(Integer id) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta;

		Object[] retorno = null;

		try{
			consulta = "select dt.id, dt.financiamentoTipo.id, dt.lancamentoItemContabil.id, dt.valorPadrao " + "from DebitoTipo dt  "
							+ "where dt.id = :idDebitoTipo ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idDebitoTipo", id.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metodo que retorna o id debito a cobrar, o id do imóvel, o id do debito
	 * tipo e o ano/mês de referência do débito
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Rafael Corrêa e Leonardo Vieira
	 * @date 24/08/2006
	 * @param idImovel
	 *            ,
	 *            idDebitoTipo, anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoACobrar(Integer idImovel, Integer idDebitoTipo, Integer anoMesReferenciaDebito)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta;

		Object[] retorno = null;

		try{
			consulta = "select dc.id, dc.imovel.id, dc.debitoTipo.id, dc.anoMesReferenciaDebito " + "from DebitoACobrar dc "
							+ "where dc.imovel.id = :idImovel and " + "dc.debitoTipo.id = :idDebitoTipo and "
							+ "dc.anoMesReferenciaDebito = :anoMesReferenciaDebito";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setInteger("idDebitoTipo", idDebitoTipo.intValue())
							.setInteger("anoMesReferenciaDebito", anoMesReferenciaDebito).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metodo que deleta os débitos a cobrar categoria de um respectivo débito a
	 * cobrar
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Rafael Corrêa e Leonardo Vieira
	 * @date 24/08/2006
	 * @param idDebitoACobrar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDebitoACobrarCategoria(Integer idDebitoACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete DebitoACobrarCategoria dcc " + "where dcc.debitoACobrar.id = :idDebitoACobrar ";

			session.createQuery(delete).setInteger("idDebitoACobrar", idDebitoACobrar).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Metodo que insere ou atualiza os débitos a cobrar
	 * [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author Rafael Corrêa, Leonardo Vieira, Pedro Alexandre
	 * @date 24/08/2006
	 * @param colecaoDebitosACobrar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoACobrar> insereOuAtualizaDebitoACobrar(Collection colecaoDebitosACobrar) throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = new ArrayList();
		StatelessSession session = HibernateUtil.getStatelessSession();

		try{

			Iterator colecaoDebitosACobrarIterator = colecaoDebitosACobrar.iterator();
			// int i = 1;
			while(colecaoDebitosACobrarIterator.hasNext()){

				DebitoACobrar debitoACobrar = (DebitoACobrar) colecaoDebitosACobrarIterator.next();

				if(debitoACobrar.getId() == null){
					Integer idGerado = (Integer) session.insert(debitoACobrar);
					debitoACobrar.setId(idGerado);
				}else{
					session.update(debitoACobrar);
				}

				retorno.add(debitoACobrar);

				/*
				 * if (i % 50 == 0) { // 20, same as the JDBC batch size //
				 * flush a batch of inserts and release memory: session.flush();
				 * session.clear(); } i++;
				 */
			}
			// session.flush();
			// session.clear();

			return retorno;

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * [UC0209] Gerar Taxa de Entrega de Conta em Outro Endereço
	 * 
	 * @author Pedro Alexandre
	 * @date 29/08/2006
	 * @param colecaoDebitosACobrarCategoria
	 * @throws ErroRepositorioException
	 */
	public void inserirDebitoACobrarCategoria(Collection colecaoDebitosACobrarCategoria) throws ErroRepositorioException{

		StatelessSession session = HibernateUtil.getStatelessSession();

		try{
			// int i = 1;
			Iterator colecaoDebitosACobrarCategoriaIterator = colecaoDebitosACobrarCategoria.iterator();

			while(colecaoDebitosACobrarCategoriaIterator.hasNext()){

				DebitoACobrarCategoria debitoACobrarCategoria = (DebitoACobrarCategoria) colecaoDebitosACobrarCategoriaIterator.next();
				session.insert(debitoACobrarCategoria);

				/*
				 * if (i % 50 == 0) { session.flush(); session.clear(); } i++;
				 */
			}

			// session.flush();
			// session.clear();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
	}

	public void inserirDebitoACobrarCategoriaHistorico(Collection colecaoDebitosACobrarCategoria) throws ErroRepositorioException{

		StatelessSession session = HibernateUtil.getStatelessSession();

		try{
			Iterator colecaoDebitosACobrarCategoriaIterator = colecaoDebitosACobrarCategoria.iterator();

			while(colecaoDebitosACobrarCategoriaIterator.hasNext()){

				DebitoACobrarCategoria debitoACobrarCategoria = (DebitoACobrarCategoria) colecaoDebitosACobrarCategoriaIterator.next();
				session.insert(debitoACobrarCategoria);

			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Metodo que retorno o valor da tarifa normal a ser cobrando no caso de uso
	 * [UC029]
	 * Utilizado pelo [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author thiago
	 * @date 05/04/2006
	 * @param anoMes
	 * @return
	 */
	// public BigDecimal obterValorTarifaSocial(Integer anoMes)
	// throws ErroRepositorioException {
	// BigDecimal retorno = null;
	//
	// Session session = HibernateUtil.getSession();
	// String consulta;
	//
	// try {
	// consulta = "select "
	// + " ctc.valorTarifaMinima "
	// + "from "
	// + " gcom.faturamento.consumotarifa.ConsumoTarifaCategoria ctc "
	// + " inner join ctc.categoria cat"
	// + " inner join ctc.consumoTarifaVigencia ctv"
	// + " "
	// + " "
	// + "where "
	// + " cat.id = "
	// + Categoria.RESIDENCIAL
	// + " and ctv.dataVigencia in "
	// + " ( select max(ctv.dataVigencia)"
	// + " from "
	// + " gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv"
	// + " inner join ctv.consumoTarifa ct"
	// + " where " + " ct.id = "
	// + ConsumoTarifa.CONSUMO_SOCIAL
	// + " and ctv.dataVigencia <= :dataVigencia " + ") "
	// + " ";
	//
	// Object pesquisa = session.createQuery(consulta).setDate(
	// "dataVigencia", new Date(System.currentTimeMillis()))
	// .setMaxResults(1).uniqueResult();
	//
	// if (pesquisa != null) {
	// retorno = (BigDecimal) pesquisa;
	// }
	//
	// } catch (HibernateException e) {
	// // levanta a exceção para a próxima camada
	// throw new ErroRepositorioException(e, "Erro no Hibernate");
	// } finally {
	// // fecha a sessão
	// HibernateUtil.closeSession(session);
	// }
	//
	// return retorno;
	// }
	/**
	 * Metodo que retorno o valor da tarifa a ser cobrada
	 * [UC029] Gerar Taxa de Entrega de Conta em Outro Endereço.
	 * 
	 * @author thiago, pedro alexandre
	 * @date 05/04/2006, 30/08/2006
	 * @return valor da tarifa
	 */
	public BigDecimal obterValorTarifa(Integer consumoTarifaId) throws ErroRepositorioException{

		BigDecimal retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select " + "		ctc.valorTarifaMinima " + "from " + "		gcom.faturamento.consumotarifa.ConsumoTarifaCategoria ctc  "
							+ "		inner join ctc.categoria cat" + "		inner join ctc.consumoTarifaVigencia ctv"
							+ "     inner join ctv.consumoTarifa ct" + "		" + " " + "where " + " 	cat.id = " + Categoria.RESIDENCIAL
							+ " 	and " + "ct.id = " + consumoTarifaId + " and ctv.dataVigencia in "
							+ "						( 	select max(ctv.dataVigencia)"
							+ "							from gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "							where 	ctv.dataVigencia <= :dataVigencia " + " and ctv.consumoTarifa.id=" + consumoTarifaId + ") "
							+ " ";

			Object pesquisa = session.createQuery(consulta).setDate("dataVigencia", new Date(System.currentTimeMillis())).setMaxResults(1)
							.uniqueResult();

			if(pesquisa != null){
				retorno = (BigDecimal) pesquisa;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metodo que retorna os imóveis das quadras pertencentes às rotas
	 * Utilizado pelo [UC0302] Gerar Débitos a Cobrar de Acréscimos por
	 * Impontualidade
	 * 
	 * @author Fernanda Paiva
	 * @date 20/04/2006
	 * @param anoMes
	 * @return
	 */
	public Collection pesquisarImoveisDasQuadrasPorRota(Collection colecaoRotas) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			Iterator rotaIterator = colecaoRotas.iterator();
			Collection idsRotas = new ArrayList();
			while(rotaIterator.hasNext()){
				Rota rota = (Rota) rotaIterator.next();
				idsRotas.add(rota.getId());
			}

			String consulta = "select imovel.id,"
							+ // 0
							"localidade.id,"
							+ // 1
							"setorComercial.codigo,"
							+ // 2
							"quadra.numeroQuadra,"
							+ // 3
							"imovel.lote,"
							+ // 4
							"imovel.subLote,"
							+ // 5
							"rota.id, "
							+ // 6
							"quadra.id, "
							+ // 7
							"imovel.indicadorDebitoConta " // 8

							+ "from Imovel imovel " + "left join imovel.localidade localidade "
							+ "left join imovel.setorComercial setorComercial " + "left join imovel.quadra quadra "
							+ "left join imovel.rota rota "

							+ "where rota.id IN (:ids)";

			retorno = session.createQuery(consulta).setParameterList("ids", idsRotas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém as contas de um imóvel com ano/mes da data de vencimento menor ou
	 * igual ao ano/mes de referencia da arrecadacao corrente e com situacao
	 * atual correspondente a normal, retificada ou incluida.
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Fernanda Paiva, Pedro Alexandre
	 * @date 24/04/2006,15/03/2007
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImovel(Integer imovel, Integer situacaoNormal, Integer situacaoIncluida, Integer situacaoRetificada,
					Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, "
							+ "cnta.valorEsgoto, cnta.debitos, cnta.valorCreditos, cnta.indicadorCobrancaMulta " + "FROM Conta cnta "
							+ "INNER JOIN cnta.imovel imov " + "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
							+ "WHERE imov.id = :idImovel AND " + "cnta.dataVencimentoConta <= :anoMesReferenciaArrecadacao AND "
							+ "cnta.dataRevisao is null AND " + "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada)";

			retorno = session.createQuery(consulta).setInteger("idImovel", imovel).setInteger("normal", situacaoNormal)
							.setInteger("incluida", situacaoIncluida).setInteger("retificada", situacaoRetificada)
							.setInteger("anoMesReferenciaArrecadacao", anoMesReferenciaArrecadacao).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection obterContasImovelIntervalo(Integer imovel, Integer situacaoNormal, Integer situacaoIncluida,
					Integer situacaoRetificada, Integer anoMesInicio, Integer anoMesFim) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, "
							+ "cnta.valorEsgoto, cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
							+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, "
							+ "cnta.referenciaContabil, cnta.ultimaAlteracao " + "FROM Conta cnta " + "INNER JOIN cnta.imovel imov "
							+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst " + "WHERE imov.id = :idImovel AND "
							+ "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada) AND "
							+ "cnta.referencia BETWEEN :inicio AND :fim";

			retorno = session.createQuery(consulta).setInteger("idImovel", imovel).setInteger("normal", situacaoNormal)
							.setInteger("incluida", situacaoIncluida).setInteger("retificada", situacaoRetificada)
							.setInteger("inicio", anoMesInicio).setInteger("fim", anoMesFim).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection obterContasImovelIntervalo(Integer imovel, Integer situacaoNormal, Integer situacaoIncluida,
					Integer situacaoRetificada, Integer anoMesInicio, Integer anoMesFim, Integer idContaMotivoRevisao)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, "
							+ "cnta.valorEsgoto, cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
							+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, "
							+ "cnta.referenciaContabil, cnta.ultimaAlteracao " + "FROM Conta cnta " + "INNER JOIN cnta.imovel imov "
							+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst " + "WHERE imov.id = :idImovel AND "
							+ "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada) AND "
							+ "cnta.referencia BETWEEN :inicio AND :fim" + " and cnta.contaMotivoRevisao.id = :idContaMotivoRevisao";

			retorno = session.createQuery(consulta).setInteger("idImovel", imovel).setInteger("normal", situacaoNormal)
							.setInteger("incluida", situacaoIncluida).setInteger("retificada", situacaoRetificada)
							.setInteger("inicio", anoMesInicio).setInteger("fim", anoMesFim)
							.setInteger("idContaMotivoRevisao", idContaMotivoRevisao).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 24/04/2006
	 * Obtém as guias de pagamento de um imóvel com ano/mes da data de
	 * vencimento menor ou igual ao ano/mes de referencia da arrecadacao
	 * corrente e com situacao atual correspondente a normal, retificada ou
	 * incluida.
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterGuiasPagamentoImovel(Integer imovel, Integer situacaoNormal, Integer situacaoIncluida,
					Integer situacaoRetificada, Integer anoMesReferenciaArrecadacao) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT gpag.id, gpag.anoMesReferenciaContabil, gpag.dataVencimento, gpag.valorDebito, gpag.indicadoCobrancaMulta, dbtp.id "
							+ "FROM GuiaPagamento gpag "
							+ "INNER JOIN gpag.imovel imov "
							+ "INNER JOIN gpag.debitoCreditoSituacaoAtual dcst "
							+ "INNER JOIN gpag.debitoTipo dbtp "
							+ "WHERE dbtp.id <> :idDebitoTipo AND "
							+ "imov.id = :idImovel AND "
							+ "gpag.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada) ";

			retorno = session.createQuery(consulta).setInteger("idImovel", imovel).setInteger("normal", situacaoNormal)
							.setInteger("incluida", situacaoIncluida).setInteger("retificada", situacaoRetificada)
							.setInteger("idDebitoTipo", DebitoTipo.ENTRADA_PARCELAMENTO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 25/04/2006
	 * Obtém os pagamentos da conta que contem a menor data de pagamento
	 * 
	 * @param conta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date obterPagamentoContasMenorData(Integer conta, Integer idImovel, Integer anoMesReferenciaConta)
					throws ErroRepositorioException{

		Date retorno = null;

		Date data1 = null;
		Date data2 = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT MIN(pgmt.dataPagamento) " + "FROM Pagamento pgmt " + "INNER JOIN pgmt.conta cnta "
							+ "WHERE cnta.id = :idConta ";

			data1 = (Date) session.createQuery(consulta).setInteger("idConta", conta).uniqueResult();

			consulta = "SELECT MIN(pgmt.dataPagamento) " + "FROM Pagamento pgmt " + "INNER JOIN pgmt.conta cnta "
							+ "INNER JOIN cnta.imovel imov "
							+ "WHERE pgmt.imovel.id= :idImovel and pgmt.anoMesReferenciaPagamento = :anoMesReferenciaConta";

			data2 = (Date) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferenciaConta", anoMesReferenciaConta).uniqueResult();

			if(data2 == null){
				retorno = data1;
			}else{
				if(data1 == null){
					retorno = data2;
				}else{
					if(data1.before(data2)){
						retorno = data1;
					}else{
						retorno = data2;
					}
				}
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0302] Gerar Débito a Cobrar de Acrescimos por Impontualidade [SB0001]
	 * Gerar Débito a Cobrar
	 * 
	 * @author Fernanda Paiva
	 * @created 25/04/2006
	 * @param valor
	 *            da multa/juros/atualização monetaria
	 * @param ano
	 *            /mes
	 *            referencia
	 * @param tipo
	 *            debito
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object gerarDebitoACobrar(DebitoACobrar debitoACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Object retorno;
		try{
			// Inclui o débito a cobrar
			retorno = session.save(debitoACobrar);
			session.flush();
			session.clear();
			return retorno;
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 26/04/2006
	 * Obtém o tipo do debito
	 * 
	 * @param tipoDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterDebitoTipo(Integer debitoTipo) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT fntp.id, lict.id " + "FROM DebitoTipo dbtp " + "INNER JOIN dbtp.financiamentoTipo fntp "
							+ "INNER JOIN dbtp.lancamentoItemContabil lict " + "WHERE dbtp.id = :idDebitoTipo ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idDebitoTipo", debitoTipo).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os relacionamentos entre o cliente e os imóveis de acordo com o
	 * código do cliente responsável
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 25/04/2006, 18/12/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarClienteImovelPorClienteResponsavel(Integer idCliente) throws ErroRepositorioException{

		// Cria a variável que vai armazenar a coleção de ClienteImovel
		// responsável
		Collection<Integer> retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			// Monta o hql
			consulta = "select imov.id " + "from ClienteImovel clim " + "inner join clim.imovel imov " + "inner join clim.cliente clie "
							+ "where clim.cliente.id = :idCliente and " + "clim.clienteRelacaoTipo.id = :idTipoRelacao and "
							+ "clim.dataFimRelacao is null and " + "imov.indicadorEmissaoExtratoFaturamento = :indicadorFaturamento "
							+ "order by imov.id ";

			// Executa o hql
			retorno = session.createQuery(consulta).setInteger("idCliente", idCliente)
							.setInteger("idTipoRelacao", ClienteRelacaoTipo.RESPONSAVEL)
							.setInteger("indicadorFaturamento", ConstantesSistema.SIM).list();

			// Erro na consulta
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// Retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Pesquisa todos os clientes responsáveis na tabela de ClienteImovel para
	 * tipo de relação igual a responsável e data de fim de relação iguala a
	 * nula
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 25/04/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarClientesResponsaveis(Integer numeroIndice, Integer quantidadeRegistros)
					throws ErroRepositorioException{

		// Cria a variável que vai armazenar a coleção de clientes responsáveis
		Collection<Integer> retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			// Monta o HQL
			consulta = "select distinct clim.cliente.id " + "from ClienteImovel clim " + "inner join clim.imovel imov "
							+ "inner join clim.cliente clie " + "where clim.clienteRelacaoTipo.id = :idTipoRelacao "
							+ "and clim.dataFimRelacao is null "
							+ "and imov.indicadorEmissaoExtratoFaturamento = :indicadorEmissaoExtratoFaturamento";

			// Executa o HQL
			retorno = session.createQuery(consulta).setInteger("idTipoRelacao", ClienteRelacaoTipo.RESPONSAVEL)
							.setInteger("indicadorEmissaoExtratoFaturamento", ConstantesSistema.SIM).setMaxResults(quantidadeRegistros)
							.setFirstResult(numeroIndice).list();

			// Erro na consulta
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de clientes responsáveis pesquisados
		return retorno;
	}

	/**
	 * Pesquisa a coleção de contas para os imóveis do cliente responsável para
	 * o ano/mês de referÊncia igual ao ano/mês de referÊncia corrente e a
	 * situação da conta igual a Normal ou Retificada ou Incluída
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 25/04/2006
	 * @param idsConcatenadosImoveis
	 * @param anoMesReferenciaConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContaImovelResponsabilidadeCliente(String idsConcatenadosImoveis, Integer anoMesReferenciaConta)
					throws ErroRepositorioException{

		// Cria a variável que vai armazenar a coleção de contas
		Collection<Conta> retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			// Monta o HQL
			consulta = "select cnta from Conta cnta " + "inner join cnta.imovel imov " + "inner join fetch cnta.ligacaoAguaSituacao last "
							+ "where cnta.referencia = :referenciaConta and " + "(cnta.debitoCreditoSituacaoAtual = "
							+ DebitoCreditoSituacao.NORMAL + " or cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.RETIFICADA
							+ " or cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.INCLUIDA + ") and " + "cnta.imovel.id in ("
							+ idsConcatenadosImoveis + ")";

			// Executa o HQL
			retorno = session.createQuery(consulta).setInteger("referenciaConta", anoMesReferenciaConta).list();

			// Erro na pesquisa
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de contas dos imóveis sobre responsabilidade do
		// cliente informado
		return retorno;
	}

	/**
	 * Retorna um Object contendo um array de object com três posições contendo
	 * na primeira posição a soma do valor total das contas na segunda posição a
	 * maior data de vencimento das contas e na terceira posiçãoa maior data de
	 * validade das contas esses dados são necessários para gerar a fatura
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 25/04/2006
	 * @param idsConcatenadosImoveis
	 * @param anoMesReferenciaConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object pesquisarResumoContasClienteResponsavel(String idsConcatenadosImoveis, Integer anoMesReferenciaConta)
					throws ErroRepositorioException{

		// Cria a variável que vai armazenar o array retornado
		Object retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			// Monta o HQL
			consulta = "select sum(((cnta.valorAgua + cnta.valorEsgoto + cnta.debitos) - cnta.valorCreditos) - cnta.valorImposto ), "
							+ "max(cnta.dataVencimentoConta), " + "max(cnta.dataValidadeConta) " + "from Conta cnta "
							+ "inner join cnta.imovel imov " + "where cnta.referencia = :referenciaConta and "
							+ "(cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.NORMAL
							+ " or cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.RETIFICADA
							+ " or cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.INCLUIDA + ") and " + "cnta.imovel.id in ("
							+ idsConcatenadosImoveis + ")";

			// Executa o HQL
			retorno = session.createQuery(consulta).setInteger("referenciaConta", anoMesReferenciaConta).uniqueResult();

			// Erro na consulta
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna o array contendo os dados do resumo das contas necessários
		// para gerar a fatura
		return retorno;
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 27/04/2006
	 * Atualiza o indicador de cobranca de multa na tabela de conta
	 * 
	 * @param idMulta
	 * @return
	 * @throws ErroRepositorioException
	 */

	public void atualizarIndicadorMultaDeConta(Collection<Integer> colecaoIdsContas) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try{
			atualizarConta = "update Conta cnta " + "set ultimaAlteracao = :dataUltimaAlteracao, indicadorCobrancaMulta = 1 "
							+ "where cnta.id in (:idsContas) ";

			session.createQuery(atualizarConta).setTimestamp("dataUltimaAlteracao", new Date())
							.setParameterList("idsContas", colecaoIdsContas).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Fernanda Paiva Data: 27/04/2006
	 * Atualiza o indicador de cobranca de multa na tabela de Guia Pagamento
	 * 
	 * @param idMulta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorMultaDeGuiaPagamento(Collection<Integer> colecaoIdsGuiasPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarGuia;

		try{
			atualizarGuia = "update GuiaPagamento gpag " + "set ultimaAlteracao = :dataUltimaAlteracao, indicadoCobrancaMulta = 1 "
							+ "where gpag.id in (:idsGuiasPagamentos) ";

			session.createQuery(atualizarGuia).setTimestamp("dataUltimaAlteracao", new Date())
							.setParameterList("idsGuiasPagamentos", colecaoIdsGuiasPagamento).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Leonardo Maranhão Data: 06/12/2008
	 * Atualiza o indicador de cobranca de multa na tabela de Guia Pagamento Prestacao
	 * 
	 * @param colecaoIdsGuiasPagamentoPrestacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorMultaDeGuiaPagamentoPrestacao(Collection<GuiaPagamentoPrestacaoPK> colecaoIdsGuiasPagamentoPrestacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{

			for(GuiaPagamentoPrestacaoPK guiaPagamentoPrestacaoPK : colecaoIdsGuiasPagamentoPrestacao){

				GuiaPagamentoPrestacao guiaPagamentoPrestacao = (GuiaPagamentoPrestacao) session
								.createCriteria(GuiaPagamentoPrestacao.class).add(Restrictions.eq("comp_id", guiaPagamentoPrestacaoPK))
								.uniqueResult();
				guiaPagamentoPrestacao.setUltimaAlteracao(new Date());
				guiaPagamentoPrestacao.setIndicadorCobrancaMulta(Short.valueOf("1"));

				session.update(guiaPagamentoPrestacao);
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualiza o indicador de cobranca de multa na tabela de Guia Pagamento Prestacao Historico
	 * 
	 * @param colecaoIdsGuiasPagamentoPrestacaoHistorico
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorMultaDeGuiaPagamentoPrestacaoHistorico(
					Collection<GuiaPagamentoPrestacaoHistoricoPK> colecaoIdsGuiasPagamentoPrestacaoHistorico)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{

			for(GuiaPagamentoPrestacaoHistoricoPK guiaPagamentoPrestacaoHistoricoPK : colecaoIdsGuiasPagamentoPrestacaoHistorico){

				GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico = (GuiaPagamentoPrestacaoHistorico) session
								.createCriteria(GuiaPagamentoPrestacaoHistorico.class)
								.add(Restrictions.eq("comp_id", guiaPagamentoPrestacaoHistoricoPK)).uniqueResult();
				guiaPagamentoPrestacaoHistorico.setUltimaAlteracao(new Date());
				guiaPagamentoPrestacaoHistorico.setIndicadorCobrancaMulta(Short.valueOf("1"));

				session.update(guiaPagamentoPrestacaoHistorico);
			}
			session.flush();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	public void atualizarIndicadorMultaDeContaHistorico(Collection<Integer> colecaoIdsContasHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{

			for(Integer idContaHistorico : colecaoIdsContasHistorico){
				ContaHistorico contaHistorico = (ContaHistorico) session.createCriteria(ContaHistorico.class)
								.add(Restrictions.eq("id", idContaHistorico)).uniqueResult();
				contaHistorico.setUltimaAlteracao(new Date());
				contaHistorico.setIndicadorCobrancaMulta(Short.valueOf("1"));

				session.update(contaHistorico);

			}

			session.flush();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa os items da fatura informada com o código da fatura igua ao
	 * código da fatura dos items para emitir a fatura do cliente responsável
	 * [UC0321] Emitir Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 28/04/2006
	 * @param idFatura
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturaItem> pesquisarItemsFatura(Integer idFatura) throws ErroRepositorioException{

		// Cria a variável que vai armazenar a coleção de items de fatura
		Collection<FaturaItem> retorno = null;

		// Cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			// Monta o HQL
			consulta = "select fitm " + "from FaturaItem fitm " + "inner join fitm.fatura fatu " + "inner join fitm.imovel imov "
							+ "where fatu.id = :idFatura " + "order by imov.id";

			// Executa o HQL
			retorno = session.createQuery(consulta).setInteger("idFatura", idFatura).list();

			// Erro na consulta
		}catch(HibernateException e){
			// Levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// Fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// Retorna a coleção de itens da fatura da fatura informada
		return retorno;
	}

	/**
	 * [UC0329] - Restabelecer Situação Anterior da Conta Atualiza para null a
	 * data de cancelamento e o motivo do cancelamento Author: Fernanda Paiva
	 * Date: 05/05/2006
	 * Atualiza a situacao anterior da conta de situacao atual cancelada
	 * 
	 * @param idConta
	 * @return
	 */

	public void restabelecerSituacaoAnteriorContaCancelada(String idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try{

			atualizarConta = "UPDATE gcom.faturamento.conta.Conta SET " + "cnta_dtcancelamento = null, cmcn_id = null, "
							+ "cnta_tmultimaalteracao = :dataUltimaAlteracao " + "WHERE cnta_id = :idConta ";

			session.createQuery(atualizarConta).setTimestamp("dataUltimaAlteracao", new Date())
							.setInteger("idConta", Integer.valueOf(idConta).intValue()).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0329] - Alterar as Situação Anterior e atual da Conta Author: Fernanda
	 * Paiva Date: 05/05/2006
	 * Atualiza a situacao anterior da conta de situacao atual da conta
	 * 
	 * @param idConta
	 *            situacaoAnterior situacaoAtual
	 * @return
	 */

	public void alterarSituacaoAnteriorAtualConta(String idConta, Integer situacaoAnterior, Integer situacaoAtual)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try{

			atualizarConta = "UPDATE gcom.faturamento.conta.Conta SET ";

			if(situacaoAnterior != null){
				atualizarConta = atualizarConta + " dcst_idanterior = :situacaoAnterior, dcst_idatual = :situacaoAtual, "
								+ "cnta_tmultimaalteracao = :dataUltimaAlteracao " + "WHERE cnta_id = :idConta ";
			}else{
				atualizarConta = atualizarConta + " dcst_idanterior = null, dcst_idatual = :situacaoAtual, "
								+ "cnta_tmultimaalteracao = :dataUltimaAlteracao " + "WHERE cnta_id = :idConta ";
			}

			if(situacaoAnterior != null){
				session.createQuery(atualizarConta).setTimestamp("dataUltimaAlteracao", new Date())
								.setInteger("idConta", Integer.valueOf(idConta).intValue())
								.setInteger("situacaoAnterior", situacaoAnterior.intValue())
								.setInteger("situacaoAtual", situacaoAtual.intValue()).executeUpdate();
			}else{
				session.createQuery(atualizarConta).setTimestamp("dataUltimaAlteracao", new Date())
								.setInteger("idConta", Integer.valueOf(idConta).intValue())
								.setInteger("situacaoAtual", situacaoAtual.intValue()).executeUpdate();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0329] - Restabelecer Situação Anterior da Conta Author: Fernanda Paiva
	 * Date: 05/05/2006
	 * Atualiza a situacao atual da conta
	 * 
	 * @param idConta
	 * @return
	 */

	public void alterarSituacaoConta(String idConta, Integer situacao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try{

			atualizarConta = "UPDATE gcom.faturamento.conta.Conta SET "
							+ "dcst_idatual = :situacao, cnta_tmultimaalteracao = :dataUltimaAlteracao " + "WHERE cnta_id = :idConta ";

			session.createQuery(atualizarConta).setTimestamp("dataUltimaAlteracao", new Date())
							.setInteger("idConta", Integer.valueOf(idConta).intValue()).setInteger("situacao", situacao.intValue())
							.executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Permite FAturar um conjunto de rotas de um grupo de faturamento
	 * [UC0067] - Faturar Grupo de Faturaumetno
	 * Determinar VAlores para Faturamento de Água e/ou Esgoto
	 * [SF0002] - Determinar VAlores para Faturamento de Água e/ou Esgoto
	 * 
	 * @author Rafael Santos
	 * @date 26/04/2006
	 * @param faturamentoGrupoId
	 * @param faturamentoAtividadeId
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object pesquisarFaturamentoAtividadeCronogramaDataRealizacao(Integer faturamentoGrupoId, Integer faturamentoAtividadeId,
					Integer anoMesReferencia) throws ErroRepositorioException{

		Object retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("select fac.dataRealizacao from FaturamentoAtividadeCronograma fac ")
							// .append("inner join fac.faturamentoAtividade fa ")
							.append("inner join fac.faturamentoGrupoCronogramaMensal fcm ")
							// .append("inner join fcm.faturamentoGrupo fg ")
							.append("where fcm.faturamentoGrupo = :faturamentoGrupoId and fac.faturamentoAtividade = :faturamentoAtividadeId ")
							.append("and fcm.anoMesReferencia = :anoMesReferencia");

			retorno = session.createQuery(consulta.toString()).setInteger("faturamentoGrupoId", faturamentoGrupoId.intValue())
							.setInteger("faturamentoAtividadeId", faturamentoAtividadeId).setInteger("anoMesReferencia", anoMesReferencia)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Atualizar Debito a Cobrar Campo numero de prestações cobradas
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * @author Rafael Santos
	 * @date 03/05/2006
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void atualizarDebitoAcobrar(Integer idDebitoAcobrar, Short prestacaoCobrada, Integer anoMesReferenciaUltimaCobranca)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try{
			atualizarImovel = "update gcom.faturamento.debito.DebitoACobrar "
							+ "set dbac_nnprestacaocobradas = :numeroPrestacao, dbac_tmultimaalteracao = :dataAtual, "
							+ "dbac_amrefultimacobranca = :anoMesReferenciaUltimaCobranca " + " where dbac_id = :idDebitoAcobrar";

			session.createQuery(atualizarImovel).setShort("numeroPrestacao", prestacaoCobrada)
							.setInteger("idDebitoAcobrar", idDebitoAcobrar.intValue()).setTimestamp("dataAtual", new Date())
							.setInteger("anoMesReferenciaUltimaCobranca", anoMesReferenciaUltimaCobranca).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar Debito a Cobrar Campo numero de prestações cobradas
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 15/09/2006
	 * @param colecaoDebitosACobrar
	 * @throws ErroRepositorioException
	 */
	public void atualizarDebitoACobrar(List colecaoDebitosACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarDebitoACobrar = "update gcom.faturamento.debito.DebitoACobrar "
						+ "set dbac_nnprestacaocobradas = :numeroPrestacao " + " where dbac_id = :idDebitoAcobrar";

		try{

			Iterator<DebitoACobrar> iteratorDebitosACobrar = colecaoDebitosACobrar.iterator();

			while(iteratorDebitosACobrar.hasNext()){

				DebitoACobrar debitoACobrar = iteratorDebitosACobrar.next();

				session.createQuery(atualizarDebitoACobrar).setShort("numeroPrestacao", debitoACobrar.getNumeroPrestacaoCobradas())
								.setInteger("idDebitoAcobrar", debitoACobrar.getId()).executeUpdate();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Atualizar Credito a Realizar Campo numero de prestações realizadas e
	 * valor mes anterior
	 * [UC00113] - Faturar Grupo de Faturamento
	 * 
	 * @author Rafael Santos
	 * @date 03/05/2006
	 * @param idDebitoAcobrar
	 * @param prestacaoCobrada
	 * @throws ErroRepositorioException
	 */
	public void atualizarCreditoARealizar(Integer idCreditoARelizar, Short numeroprestacaoRealizadas, BigDecimal valorResidualMesAnterior)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try{
			atualizarImovel = "update gcom.faturamento.credito.CreditoARealizar "
							+ "set crar_nnprestacaorealizadas = :numeroPrestacao,crar_vlresidualmesanterior = :valorMesAnterior, "
							+ "crar_tmultimaalteracao = :dataAtual" + " where crar_id = :idCreditoARelizar";

			session.createQuery(atualizarImovel).setShort("numeroPrestacao", numeroprestacaoRealizadas.shortValue())
							.setBigDecimal("valorMesAnterior", valorResidualMesAnterior)
							.setInteger("idCreditoARelizar", idCreditoARelizar.intValue()).setTimestamp("dataAtual", new Date())
							.executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Obtem a Ligacao Esgoto do Imovel UC0113 - Faturar Grupo Faturamento
	 * 
	 * @author Rafael Santos
	 * @date 05/05/2006
	 * @param idImovel
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public LigacaoEsgoto obterLigacaoEsgotoImovel(Integer idImovel) throws ErroRepositorioException{

		LigacaoEsgoto retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select le " + "from LigacaoEsgoto le " + "inner join le.imovel imovel " + "where imovel.id = :imovelId ";

			Object pesquisa = session.createQuery(consulta).setInteger("imovelId", idImovel.intValue()).setMaxResults(1).uniqueResult();

			if(pesquisa != null){
				retorno = (LigacaoEsgoto) pesquisa;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00113] - Faturar Grupo de Faturamento
	 * Recupera o percentual de esgoto para o imóvel informado.
	 * 
	 * @author Pedro Alexandre
	 * @date 18/09/2006
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterPercentualLigacaoEsgotoImovel(Integer idImovel) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select le.percentual " + "from LigacaoEsgoto le " + "where le.id = :imovelId ";

			retorno = (BigDecimal) session.createQuery(consulta).setInteger("imovelId", idImovel.intValue()).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com estouro de consumo ou com baixo consumo [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasEmitir(Collection<Integer> idTipoConta, Integer idEmpresa, Integer numeroPaginas,
					Integer anoMesReferencia, Integer idFaturamentoGrupo, Integer anoMesReferenciaFaturamentoAntecipado)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cttp_id as tipoConta "// 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id in (:idTipoConta) AND "
							+ "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND " + "contaImpressao.empr_id = :idEmpresa AND ";
			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ") ";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idUsuario";
			consulta += " order by cnt.cnta_amreferenciaconta, contaImpressao.empr_id, loc.loca_id, cnt.cnta_cdsetorcomercial, "
							+ "rota.rota_cdrota, imovel.imov_nnsequencialrota, cnt.cnta_nnquadra, cnt.cnta_nnlote, cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("tipoConta", Hibernate.INTEGER)
							.setParameterList("idTipoConta", idTipoConta).setInteger("idEmpresa", idEmpresa)
							.setInteger("idUsuario", ClienteRelacaoTipo.USUARIO).setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo)
							.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * /**
	 * [UC0352] Emitir Contas
	 * 
	 * @author Saulo Lima, Eduardo Henrique
	 * @date 20/10/2008, 18/11/2008
	 *       Alteração no método para consulta de Contas Não-Impressas, retirada de filtro de Tipos
	 *       de Conta
	 *       e adição de campos utilizados na impressão da Conta.
	 *       Alteração para inclusão de atributo Tipo de Envio de Conta de Imóvel.
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasEmitirTipo2(Integer idEmpresa, Integer anoMesReferencia, Integer idFaturamentoGrupo,
					Integer anoMesReferenciaFaturamentoAntecipado) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, " // 00
							+ "cli.clie_nmcliente as nomeCliente, " // 01
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, " // 02
							+ "cnt.cnta_amreferenciaconta as amReferencia, " // 03
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, " // 04
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, " // 05
							+ "cnt.cnta_nnquadra as numeroQuadra, " // 06
							+ "cnt.cnta_nnlote as lote, " // 07
							+ "cnt.cnta_nnsublote as sublote, " // 08
							+ "cnt.cnta_nnconsumoagua as consumoAgua, " // 09
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, " // 10
							+ "cnt.cnta_vlagua as valorAgua, " // 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, " // 12
							+ "cnt.cnta_vldebitos as debitos, " // 13
							+ "cnt.cnta_vlcreditos as valorCreditos, " // 14
							+ "cnt.cnta_vlimpostos as valorImpostos, " // 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, " // 16
							+ "imovel.imov_id as idImovel, " // 17
							+ "loc.loca_id as idLocalidade, " // 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, " // 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, " // 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, " // 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, " // 22
							+ "imovelPerfil.iper_id as idImovelPerfil, " // 23
							+ "setorComercial.stcm_id as idSetorComercial, " // 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, " // 25
							+ "contaImpressao.empr_id as idEmpresa, " // 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, " // 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, " // 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, " // 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, " // 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, " // 31
							+ "imovel.imov_nmimovel as nomeImovel, " // 32
							+ "rota.rota_cdrota as codigoRota, " // 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, " // 34
							+ "cnt.cnta_idorigem as origem, " // 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, " // 36
							+ "func.func_id as idFuncionario, " // 37
							+ "func.func_nmfuncionario as nomeFuncionario, " // 38
							+ "contaImpressao.cttp_id as tipoConta, " // 39
							+ "rota.rota_id as idRota, " // 40
							+ "imovel.imov_icDebitoConta as icDebitoConta, " // 41
							+ "imovel.icte_id as tipoEnvioConta, " // 42
							+ "cliCnt.crtp_id as idTipoRelacao, " // 43
							+ "loc.loca_cdelo as elo, " // 44
							+ "cli.clie_id as idClienteUsuario, " // 45
							+ "cnt.cnta_dtrevisao as dataRevisao, " // 46
							+ "cnt.cmrv_id as idMotivoRevisao, " // 47
							+ "imovel.stcm_id as idSetorComercial, " // 48
							+ "cli.clie_iccontabraille as icContaBraille " // 49
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND " + "contaImpressao.empr_id = :idEmpresa AND ";
			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta = " + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta = "
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta = " + anoMesReferencia;
			}
			consulta += " AND cliCnt.clct_icnomeconta = :indicadorNomeConta";
			consulta += " AND contaImpressao.cnti_icimpressao = :idIndicadorImpressao ";
			consulta += " AND cnt.dcst_idatual in ( " + DebitoCreditoSituacao.NORMAL.toString() + ","
							+ DebitoCreditoSituacao.RETIFICADA.toString() + ")";
			consulta += " order by contaImpressao.empr_id, loc.loca_cdelo, loc.loca_id,cnt.cnta_cdsetorcomercial, "
							+ "rota.rota_cdrota, imovel.imov_nnsequencialrota, cnt.cnta_nnquadra, cnt.cnta_nnlote, cnt.cnta_nnsublote, cnt.cnta_amreferenciaconta";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPerfil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("tipoConta", Hibernate.INTEGER)
							.addScalar("idRota", Hibernate.INTEGER).addScalar("icDebitoConta", Hibernate.SHORT)
							.addScalar("tipoEnvioConta", Hibernate.INTEGER).addScalar("idTipoRelacao", Hibernate.INTEGER)
							.addScalar("elo", Hibernate.INTEGER).addScalar("idClienteUsuario", Hibernate.INTEGER)
							.addScalar("dataRevisao", Hibernate.DATE).addScalar("idMotivoRevisao", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("icContaBraille", Hibernate.SHORT)
							.setInteger("idEmpresa", idEmpresa).setInteger("indicadorNomeConta", ConstantesSistema.SIM.intValue())
							.setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo)
							.setInteger("idIndicadorImpressao", Integer.valueOf("2")).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Método que retorna as contas para impressao
	 * Pesquisar Contas Emitir Caern
	 * 
	 * @author Tiago Moreno
	 * @date 05/05/2007
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasEmitirCAERN(Integer idTipoConta, Integer idEmpresa, Integer numeroPaginas, Integer anoMesReferencia,
					Integer idFaturamentoGrupo) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel "// 32
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao "
							+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao "
							+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "where "
							// + "contaImpressao.cttp_id = :idTipoConta AND "
							+ "contaImpressao.cnti_amreferenciaconta = :referencia AND " + "cnt.cnta_tmultimaalteracao > :data AND "
							+ "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND " + "contaImpressao.empr_id = :idEmpresa AND "
							+ "cliCnt.crtp_id = :idUsuario AND imovel.icte_id <> 9 "
							+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id, loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota, imovel.imov_nnsequencialrota";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING)
							.addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL)
							.addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING)

							// .setInteger("idTipoConta", idTipoConta)
							.setInteger("idEmpresa", idEmpresa).setDate("data", Util.criarData(16, 05, 2007))
							.setInteger("idUsuario", ClienteRelacaoTipo.USUARIO).setInteger("referencia", anoMesReferencia)
							.setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo).setMaxResults(1000).setFirstResult(numeroPaginas)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarContasEmitirOrgaoPublicoCAERN(Integer idTipoConta, Integer idEmpresa, Integer numeroPaginas,
					Integer anoMesReferencia, Integer idFaturamentoGrupo) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel "// 32
							+ "from cliente_conta cliCnt "
							+ "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao "
							+ "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao "
							+ "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "where "
							+ "contaImpressao.cnti_amreferenciaconta = :referencia AND "
							+ "contaImpressao.empr_id = :idEmpresa AND "
							+ "cliCnt.crtp_id = :idUsuario AND imovel.icte_id = 9 "
							+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.clie_idresponsavel, loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota, imovel.imov_nnsequencialrota";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).setInteger("idEmpresa", idEmpresa)
							.setInteger("idUsuario", ClienteRelacaoTipo.USUARIO).setInteger("referencia", anoMesReferencia)
							.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Atualiza os Clientes Responsáveis para de Conta Impressao
	 * Alteracao feita para a ordenacao das contas de clientes orgaos publicos
	 * Por Tiago Moreno - 25/08/2007 - Alterado: 17/10/2007
	 * OBS: Nao estou usando o HQL e sim o próprio UPDATE do SQL.
	 */

	public void atualizaClienteResponsavelOrgaoPublicoCAERN(Integer anoMesReferencia) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try{
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			// update
			update = "update conta_impressao set " + "clie_idresponsavel = (select cliImo.clie_id " + "from   conta conta, "
							+ "imovel imov, " + "cliente_imovel cliImo " + "where  conta_impressao.cnta_id = conta.cnta_id and "
							+ "conta.imov_id = imov.imov_id and " + "imov.icte_id = 9 and " + "imov.imov_id = cliImo.imov_id and "
							+ "cliImo.crtp_id = 3 and " + "cliImo.clim_dtrelacaofim is null) " + "where cnti_amreferenciaconta = ? and "
							+ "cnti_nnsequencialimpressao is null";

			// abre a conexao
			st = jdbcCon.prepareStatement(update);
			// seta o parametro de ano mes
			st.setInt(1, anoMesReferencia.intValue());

			// executa o update
			st.executeUpdate();

		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera as contas com debito automático [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasDebitoAutomatico(Collection idsContas) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select " + " new " + EmitirContaHelper.class.getName() + " ( " + "cnt.id, " + "cli.nome, "
							+ "cnt.dataVencimentoConta, " + "cnt.referencia, " + "cnt.digitoVerificadorConta, "
							+ "cnt.codigoSetorComercial, " + "cnt.quadra, " + "cnt.lote, " + "cnt.subLote, " + "cnt.consumoAgua, "
							+ "cnt.consumoEsgoto, " + "cnt.valorAgua, " + "cnt.valorEsgoto, " + "cnt.debitos, " + "cnt.valorCreditos, "
							+ "cnt.valorImposto, " + "cnt.dataValidadeConta, " + "imovel.id, " + "loc.id, " + "gerenciaRegional.id, "
							+ "gerenciaRegional.nome, " + "ligacaoAguaSituacao.id, " + "ligacaoEsgotoSituacao.id, " + "imovelPerfil.id, "
							+ "setorComercial.id, " + "faturamentoGrupo.id, " + "emp.id, " + "loc.descricao, "
							+ "ligacaoAguaSituacao.descricao, " + "ligacaoEsgotoSituacao.descricao, " + "cnt.percentualEsgoto) "
							+ "from ClienteConta cliCnt " + "inner join cliCnt.conta cnt " + "inner join cliCnt.clienteRelacaoTipo crt "
							+ "inner join cliCnt.cliente cli " + "inner join cnt.quadraConta quadraConta "
							+ "inner join cnt.localidade loc " + "inner join loc.gerenciaRegional gerenciaRegional "
							+ "inner join cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "inner join cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao " + "inner join cnt.imovelPerfil imovelPerfil "
							+ "inner join quadraConta.rota rota " + "inner join rota.empresa emp "
							+ "inner join quadraConta.setorComercial setorComercial "
							+ "inner join rota.faturamentoGrupo faturamentoGrupo " + "inner join cnt.imovel imovel "
							+ "where cnt.id in (:idsContas)  AND " + "crt.id = :idUsuario AND "
							+ "cnt.indicadorDebitoConta = :indDebConta "
							+ "order by  cnt.referencia,emp.id,loc.id,cnt.codigoSetorComercial," + "cnt.quadra,cnt.lote,cnt.subLote";

			retorno = session.createQuery(consulta).setParameterList("idsContas", idsContas)
							.setShort("indDebConta", Conta.INDICADOR_DEBITO_CONTA_SIM).setInteger("idUsuario", ClienteRelacaoTipo.USUARIO)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id do cliente responsável pela conta [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdClienteResponsavelConta(Integer idConta) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cli.id " + "from ClienteConta cliCnt " + "inner join cliCnt.conta cnt "
							+ "inner join cliCnt.clienteRelacaoTipo crt " + "inner join cliCnt.cliente cli "
							+ "where cnt.id = :idConta AND " + "crt.id = :idResponsavel";

			retorno = (Integer) session.createQuery(consulta).setInteger("idConta", idConta)
							.setInteger("idResponsavel", ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com entrega para o cliente responsável [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavel(Collection<Integer> idTipoConta, Integer numeroPaginas, Integer anoMesReferencia,
					Integer idFaturamentoGrupo, Short indicadorEmissaoExtratoFaturamento, Integer anoMesReferenciaFaturamentoAntecipado)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cttp_id as tipoConta "// 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id in (:idTipoConta) AND " + "contaImpressao.ftgr_id = :idFaturamentoGrupo AND "
							+ "contaImpressao.empr_id is null AND ";
			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
							+ "imovel.imov_icemissaoextratofaturamen = :indicadorEmissaoExtratoFaturamento "
							+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("tipoConta", Hibernate.INTEGER)
							.setParameterList("idTipoConta", idTipoConta).setInteger("idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
							.setShort("indicadorEmissaoExtratoFaturamento", indicadorEmissaoExtratoFaturamento).setMaxResults(1000)
							.setFirstResult(numeroPaginas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas normais [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasNormais(Collection idsContas) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select " + " new " + EmitirContaHelper.class.getName() + " ( " + "cnt.id, " + "cli.nome, "
							+ "cnt.dataVencimentoConta, " + "cnt.referencia, " + "cnt.digitoVerificadorConta, "
							+ "cnt.codigoSetorComercial, " + "cnt.quadra, " + "cnt.lote, " + "cnt.subLote, " + "cnt.consumoAgua, "
							+ "cnt.consumoEsgoto, " + "cnt.valorAgua, " + "cnt.valorEsgoto, " + "cnt.debitos, " + "cnt.valorCreditos, "
							+ "cnt.valorImposto, " + "cnt.dataValidadeConta, " + "imovel.id, " + "loc.id, " + "gerenciaRegional.id, "
							+ "gerenciaRegional.nome, " + "ligacaoAguaSituacao.id, " + "ligacaoEsgotoSituacao.id, " + "imovelPerfil.id, "
							+ "setorComercial.id, " + "faturamentoGrupo.id, " + "emp.id, " + "loc.descricao, "
							+ "ligacaoAguaSituacao.descricao, " + "ligacaoEsgotoSituacao.descricao, " + "cnt.percentualEsgoto) "
							+ "from ClienteConta cliCnt " + "inner join cliCnt.conta cnt " + "inner join cliCnt.clienteRelacaoTipo crt "
							+ "inner join cliCnt.cliente cli " + "inner join cnt.quadraConta quadraConta "
							+ "inner join cnt.localidade loc " + "inner join loc.gerenciaRegional gerenciaRegional "
							+ "inner join cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "inner join cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao " + "inner join cnt.imovelPerfil imovelPerfil "
							+ "inner join quadraConta.rota rota " + "inner join rota.empresa emp "
							+ "inner join quadraConta.setorComercial setorComercial "
							+ "inner join rota.faturamentoGrupo faturamentoGrupo " + "inner join cnt.imovel imovel "
							+ "where cnt.id in (:idsContas) AND " + "crt.id = :idUsuario "
							+ "order by  cnt.referencia,emp.id,loc.id,cnt.codigoSetorComercial," + "cnt.quadra,cnt.lote,cnt.subLote";

			retorno = session.createQuery(consulta).setParameterList("idsContas", idsContas)
							.setInteger("idUsuario", ClienteRelacaoTipo.USUARIO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o nome do cliente usuário pela conta [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String pesquisarNomeClienteUsuarioConta(Integer idConta) throws ErroRepositorioException{

		String retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cli.nome " + "from ClienteConta cliCnt " + "inner join cliCnt.conta cnt "
							+ "inner join cliCnt.clienteRelacaoTipo crt " + "inner join cliCnt.cliente cli "
							+ "where cnt.id = :idConta AND " + "crt.id = :idUsuario";

			retorno = (String) session.createQuery(consulta).setInteger("idConta", idConta)
							.setInteger("idUsuario", ClienteRelacaoTipo.USUARIO).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id do cliente responsável pela conta [UC0348] - Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 05/12/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsClienteResponsavelConta(Integer idConta) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cli.id,cli.nome " + "from ClienteConta cliCnt " + "inner join cliCnt.conta cnt "
							+ "inner join cliCnt.clienteRelacaoTipo crt " + "inner join cliCnt.cliente cli "
							+ "where cnt.id = :idConta AND " + "crt.id = :idResponsavel";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idConta", idConta)
							.setInteger("idResponsavel", ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna a soma de quantidade economia
	 * [UC0348] Emitir Contas
	 * [SB0007] Obter Quantidade de Economias da Conta
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Short obterQuantidadeEconomiasConta(Integer idConta) throws ErroRepositorioException{

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select sum(contaCategoria.quantidadeEconomia) " + "from ContaCategoria contaCategoria "
							+ "left join contaCategoria.comp_id.conta conta " + "where conta.id = :idConta";

			retorno = ((Number) session.createQuery(consulta).setInteger("idConta", idConta).setMaxResults(1).uniqueResult()).shortValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * [UC0348] Emitir Contas
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoria(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select contaCategoria ").append("from ContaCategoria contaCategoria ")
							.append("inner join contaCategoria.comp_id.conta conta ")
							.append("inner join fetch contaCategoria.comp_id.categoria categoria ").append("where conta.id = :idConta ");

			retorno = session.createQuery(consulta.toString()).setInteger("idConta", idConta).list();

			/**
			 * alterado por pedro alexandre dia 23/01/2007
			 */
			/*
			 * consulta = "select contaCategoria " + "from ContaCategoria
			 * contaCategoria " + "inner join contaCategoria.comp_id.conta conta " +
			 * "inner join contaCategoria.comp_id.categoria categoria " + "where
			 * conta.id = :idConta " + "order by categoria.id";
			 * Iterator iterator = session.createQuery(consulta).setInteger(
			 * "idConta", idConta.intValue()).iterate();
			 * while (iterator.hasNext()) { ContaCategoria contaCategoria =
			 * (ContaCategoria) iterator .next(); // carrega todos os objetos
			 * Hibernate
			 * .initialize(contaCategoria.getComp_id().getCategoria());
			 * retorno.add(contaCategoria); }
			 */
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém uma conta categoria pela contaCategoriaPK
	 * 
	 * @param contaCategoriaPK
	 * @return contaCategoria
	 * @throws ErroRepositorioException
	 */
	public ContaCategoria obterContaCategoria(ContaCategoriaPK contaCategoriaPK) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta;
		ContaCategoria retorno = new ContaCategoria();
		try{
			consulta = "select contaCategoria " + "from ContaCategoria contaCategoria "
							+ "inner join fetch contaCategoria.comp_id.conta conta "
							+ "inner join fetch contaCategoria.comp_id.conta.localidade localidade "
							+ "inner join fetch contaCategoria.comp_id.conta.localidade.gerenciaRegional gerenciaRegional "
							+ "inner join fetch contaCategoria.comp_id.conta.localidade.unidadeNegocio unidadeNegocio "
							+ "inner join fetch contaCategoria.comp_id.conta.quadraConta quadraConta "
							+ "inner join fetch contaCategoria.comp_id.conta.quadraConta.setorComercial setorComercial "
							+ "inner join fetch contaCategoria.comp_id.categoria categoria "
							+ "inner join fetch contaCategoria.comp_id.subcategoria subcategoria "
							+ "inner join fetch contaCategoria.comp_id.categoria.categoriaTipo categoriaTipo "
							+ "inner join fetch contaCategoria.comp_id.conta.consumoTarifa consumoTarifa "
							+ "inner join fetch contaCategoria.comp_id.conta.imovelPerfil imovelPerfil "
							+ "inner join fetch contaCategoria.comp_id.conta.imovel imovel "
							+ "inner join fetch contaCategoria.comp_id.conta.clienteContas clienteContas "
							+ "left join fetch contaCategoria.comp_id.conta.imovel.ligacaoAgua ligacaoAgua "
							+ "left join fetch contaCategoria.comp_id.conta.imovel.ligacaoEsgoto ligacaoEsgoto "
							+ "where conta.id = :contaId " + "and categoria.id = :categoriaId " + "and subcategoria.id = :subCategoriaId ";

			retorno = (ContaCategoria) session.createQuery(consulta).setParameter("contaId", contaCategoriaPK.getConta().getId())
							.setParameter("categoriaId", contaCategoriaPK.getCategoria().getId())
							.setParameter("subCategoriaId", contaCategoriaPK.getSubcategoria().getId()).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * [UC0348] Emitir Contas
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaFaixas(Integer idConta, Integer idCategoria) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaCategoriaConsumoFaixa " + "from ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa "
							+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.conta conta "
							+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.categoria categoria "
							+ "where conta.id = :idConta AND " + "categoria.id = :idCategoria "
							+ "order by contaCategoriaConsumoFaixa.consumoFaixaInicio";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setInteger("idCategoria", idCategoria.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object com a soma do valor dos debitos
	 * cobrados de parcelamento,o numero da prestacao e o numero total de
	 * prestações
	 * [UC0348] Emitir Contas
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParmsDebitoAutomatico(Integer idConta, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select sum(debCobrado.valorPrestacao), debCobrado.numeroPrestacaoDebito, debCobrado.numeroPrestacao "
							+ "from DebitoCobrado debCobrado " + "inner join debCobrado.financiamentoTipo finTipo "
							+ "inner join debCobrado.conta conta " + "where conta.id = :idConta AND finTipo.id in (:tiposParcelamento) "
							+ "group by debCobrado.numeroPrestacaoDebito,debCobrado.numeroPrestacao";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setParameterList("tiposParcelamento", tiposParcelamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#listarParametrosDebitosCobradoParcelamento(java.
	 * lang.Integer)
	 */
	public Collection<Object[]> listarParametrosDebitosCobradoParcelamento(Integer idConta, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{

		Collection<Object[]> objs = this.pesquisarParmsDebitoAutomatico(idConta, tiposParcelamento);
		Collection<Object[]> parametros = new ArrayList<Object[]>();

		for(Object[] obj : objs){

			BigDecimal valorTotalPrestacoes = (BigDecimal) obj[0];
			short numeroPrestacaoDebito = (Short) obj[1];
			short numeroPrestacao = (Short) obj[2];

			Criteria criteria = HibernateUtil.getSession().createCriteria(DebitoCobrado.class);
			criteria.createAlias("financiamentoTipo", "financiamentoTipo", Criteria.INNER_JOIN);
			criteria.createAlias("conta", "conta", Criteria.INNER_JOIN);
			criteria.createAlias("parcelamento", "parcelamento", Criteria.INNER_JOIN);
			criteria.createAlias("parcelamento.resolucaoDiretoria", "resolucaoDiretoria", Criteria.LEFT_JOIN);
			criteria.add(Restrictions.eq("numeroPrestacaoDebito", numeroPrestacaoDebito));
			criteria.add(Restrictions.eq("numeroPrestacao", numeroPrestacao));
			if(!Util.isVazioOrNulo(tiposParcelamento)){
				criteria.add(Restrictions.in("financiamentoTipo.id", tiposParcelamento));
			}
			criteria.add(Restrictions.eq("conta.id", idConta));
			criteria.setProjection(Projections.property("parcelamento"));

			Parcelamento parcelamento = (Parcelamento) Util.retonarObjetoDeColecao(criteria.list());

			Object[] parametro = new Object[4];
			parametro[0] = valorTotalPrestacoes;
			parametro[1] = numeroPrestacaoDebito;
			parametro[2] = numeroPrestacao;
			parametro[3] = parcelamento;

			parametros.add(parametro);

		}

		return parametros;

	}

	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * [UC0348] Emitir Contas
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 19/05/2006, 16/01/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsDebitoCobradoPorTipo(Integer idConta, Collection<Integer> tiposParcelamento) throws ErroRepositorioException{

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select sum(debCobrado.valorPrestacao), "// 0
							+ "debCobrado.numeroPrestacaoDebito," // 1
							+ "debCobrado.numeroPrestacao, "// 2
							+ "debCobrado.anoMesReferenciaDebito, "// 3
							+ "debitoTipo.id, "// 4
							+ "debCobrado.debitoTipo.descricao "// 5
							+ "from DebitoCobrado debCobrado "
							+ "inner join debCobrado.financiamentoTipo finTipo "
							+ "inner join debCobrado.debitoTipo debitoTipo "
							+ "inner join debCobrado.conta conta "
							+ "where conta.id = :idConta AND finTipo.id not in (:tiposParcelamento) " + "group by "
							+ "debitoTipo.id, "
							+ "debCobrado.numeroPrestacaoDebito," + "debCobrado.numeroPrestacao, "
							+ "debCobrado.anoMesReferenciaDebito, "
							+ "debCobrado.debitoTipo.descricao " + "order by debitoTipo.id,debCobrado.anoMesReferenciaDebito desc";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setParameterList("tiposParcelamento", tiposParcelamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do crédito realizado ordenado pelo
	 * tipo de crédito
	 * [UC0348] Emitir Contas
	 * [SB0014] Gerar Linhas dos Creditos Realizados
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsCreditoRealizadoPorTipo(Integer idConta) throws ErroRepositorioException{

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select credRealizado.valorCredito,"// 0
							+ "credRealizado.numeroPrestacaoCredito," // 1
							+ "credRealizado.numeroPrestacao, "// 2
							+ "credRealizado.anoMesReferenciaCredito, "// 3
							+ "creditoTipo.id, "// 4
							+ "creditoTipo.descricao "// 5
							+ "from CreditoRealizado credRealizado "
							+ "inner join credRealizado.creditoTipo creditoTipo "
							+ "inner join credRealizado.conta conta "
							+ "where conta.id = :idConta "
							+ "order by creditoTipo.id,credRealizado.anoMesReferenciaCredito desc";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object de qualidade de agua
	 * [UC0348] Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 25/05/2006
	 *       Correção nos campos obtidos e inclusão de novos campos.
	 * @author Virgínia Melo
	 * @date 06/01/2009
	 * @author eduardo henrique
	 * @date 26/01/2009
	 *       Alteração no método para obter os dados de Qualidade de Água da Referência da Conta.
	 * @param emitirContaHelper
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsQualidadeAgua(EmitirContaHelper emitirContaHelper) throws ErroRepositorioException{

		Object[] retorno = null;

		/*
		 * Integer anoMesFaturamentoSubtraido = Util.subtrairMesDoAnoMes(
		 * emitirContaHelper.getAmReferencia(), 1);
		 */

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select qualidadeAgua.numeroAmostrasMediaTurbidez, "// 0
							+ "qualidadeAgua.numeroAmostrasMediaCloro, " // 1
							+ "qualidadeAgua.numeroAmostrasMediaCor, " // 2
							+ "qualidadeAgua.numeroAmostrasMediaPH, " // 3
							+ "qualidadeAgua.numeroAmostrasMediaBacteriasHeterotroficas, " // 4
							+ "qualidadeAgua.numeroAmostrasMediaColiformesTermotolerantes, " // 5
							+ "qualidadeAgua.numeroAmostrasMediaColiformesTotais " // 6
							+ "from QualidadeAgua qualidadeAgua "
							+ "inner join qualidadeAgua.localidade localidade "
							+ "where localidade.id = :idLocalidade AND " + "qualidadeAgua.anoMesReferencia = :anoMesReferencia ";

			retorno = (Object[]) session.createQuery(consulta)
							.setInteger("anoMesReferencia", Integer.valueOf(emitirContaHelper.getAmReferencia()))
							.setInteger("idLocalidade", emitirContaHelper.getIdLocalidade()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que verifica se há referência de Qualidade de Água em Faturamento já realizado
	 * [UC0597] - FS0001
	 * 
	 * @author eduardo henrique
	 * @date 17/07/2008
	 */
	public boolean verificarExistenciaFaturamentoQualidadeAgua(QualidadeAgua qualidadeAgua) throws ErroRepositorioException{

		boolean retorno = true;
		if(qualidadeAgua == null){
			retorno = false;
		}

		String consulta = "";
		Session session = HibernateUtil.getSession();
		try{
			consulta = "select distinct fg.id " +

			"from Rota rota join rota.faturamentoGrupo fg " +

			"join rota.setorComercial setor join setor.localidade localidade " +

			"where  fg.anoMesReferencia  > :anoMesReferencia " +

			"and setor.localidade.id = :idLocalidade  ";

			if(qualidadeAgua.getSetorComercial() != null){
				consulta += " and setor.id = " + qualidadeAgua.getSetorComercial().getId();
			}

			Collection colecao = session.createQuery(consulta).setInteger("anoMesReferencia", qualidadeAgua.getAnoMesReferencia())
							.setInteger("idLocalidade", qualidadeAgua.getLocalidade().getId()).list();

			if(colecao != null && !colecao.isEmpty()){ // GrupoFaturamento já teve faturamento com
				// parâmetros de Qualidade de água
				retorno = false;
			}
			// Se igual, consulta se o Faturamento foi iniciado e utilizou a qualidade
			consulta = "select distinct fg.id "
							+

							"from Rota rota join rota.faturamentoGrupo fg "
							+

							" join rota.setorComercial setor "
							+

							" join setor.localidade localidade "
							+

							"where setor.localidade.id = :idLocalidade "
							+

							" and fg.anoMesReferencia = :anoMesReferencia "
							+

							" and fg.id in (select fgcm.faturamentoGrupo.id from FaturamentoAtividadeCronograma fac "
							+

							" 			   join fac.faturamentoGrupoCronogramaMensal fgcm "
							+

							" 			    where fac.dataRealizacao is not null and fac.faturamentoAtividade.id = 1 and fgcm.anoMesReferencia = :anoMesReferenciaCronograma )";

			if(qualidadeAgua.getSetorComercial() != null){
				consulta += " and setor.id = " + qualidadeAgua.getSetorComercial().getId();
			}

			colecao = session.createQuery(consulta).setInteger("anoMesReferencia", qualidadeAgua.getAnoMesReferencia())
							.setInteger("idLocalidade", qualidadeAgua.getLocalidade().getId())
							.setInteger("anoMesReferenciaCronograma", qualidadeAgua.getAnoMesReferencia()).list();

			if(colecao != null && !colecao.isEmpty()){ // GrupoFaturamento já teve faturamento com
				// parâmetros de Qualidade de água
				retorno = false;
			}
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Método que retorna uma array de object do conta impostos deduzidos
	 * [UC0348] Emitir Contas
	 * [SB0015] Gerar Linhas dos Impostos Deduzidos
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParmsContaImpostosDeduzidos(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select impostoTipo.descricaoAbreviada,"// 0
							+ "contaImpostosDeduzidos.percentualAliquota," // 1
							+ "contaImpostosDeduzidos.valorImposto " // 1
							+ "from ContaImpostosDeduzidos contaImpostosDeduzidos "
							+ "inner join contaImpostosDeduzidos.conta conta "
							+ "inner join contaImpostosDeduzidos.impostoTipo impostoTipo " + "where conta.id = :idConta";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa todas as contas para testar o batch
	 * 
	 * @author Sávio Luiz
	 * @date 02/06/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsTodasConta() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select conta.id " + "from Conta conta " + "order by conta.id";

			retorno = session.createQuery(consulta).setMaxResults(115).list();
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relacao Acompanhamento Faturamento
	 * [UC0336] GerarRelacaoAcompanhamentoFaturamento
	 * 
	 * @author Fernanda Paiva
	 * @date 15/06/2006
	 */
	public Collection gerarRelacaoAcompanhamentoFaturamento(String idImovelCondominio, String idImovelPrincipal, String idNomeConta,
					String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
					String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
					String intervaloValorPercentualEsgotoInicial, String intervaloValorPercentualEsgotoFinal,
					String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
					String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
					String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
					String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal, String idCadastroOcorrencia,
					String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial, String idLocalidadeFinal,
					String setorComercialInicial, String setorComercialFinal, String quadraInicial, String quadraFinal, String loteOrigem,
					String loteDestno, String cep, String logradouro, String bairro, String municipio, String idTipoMedicao,
					String indicadorMedicao, String idSubCategoria, String idCategoria, String quantidadeEconomiasInicial,
					String quantidadeEconomiasFinal, String diaVencimento, String idCliente, String idClienteTipo,
					String idClienteRelacaoTipo, String numeroPontosInicial, String numeroPontosFinal, String numeroMoradoresInicial,
					String numeroMoradoresFinal, String idAreaConstruidaFaixa, String consumoFixadoEsgotoPocoInicial,
					String consumoFixadoEsgotoPocoFinal) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select distinct "
							+ "gerenciaRegional.id,"
							+ "gerenciaRegional.nomeAbreviado,"
							+ "localidade.id,"
							+ "localidade.descricao,"
							+ "imovel.id,"
							+ "imovel.quantidadeEconomias,"
							+ "setorComercial.codigo,"
							+ "quadra.numeroQuadra,"
							+ "imovel.lote,"
							+ "imovel.subLote,"
							+ "ligacaoAguaSituacao.descricaoAbreviado,"
							+ "ligacaoEsgotoSituacao.descricaoAbreviado,"
							+ "ligacaoEsgoto.percentual,"
							+ "ligacaoAgua.dataCorte, "
							+ "gerenciaRegional.nome, "
							+ "ligacaoEsgoto.consumoMinimo, "
							+ "clienteUsuario.nome "
							+ // "consumosHistorico.consumoMedio "

							" from ImovelSubcategoria imovelSubcategoria "
							+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
							+ " left  join  imovelSubcategoria.comp_id.subcategoria subcategoria "
							+ " left join subcategoria.categoria categoria   "
							+ " inner join imovel.localidade localidade   "
							+ " inner join localidade.gerenciaRegional gerenciaRegional "
							+ " inner join imovel.setorComercial setorComercial   "
							+ " left  join imovel.logradouroBairro logradouroBairro  "
							+ " left  join logradouroBairro.bairro bairro   "
							+ " left  join bairro.municipio municipio   "
							+ " left  join imovel.logradouroBairro logradouroBairro "
							+ " left  join logradouroBairro.bairro bairro   "
							+ " inner join imovel.quadra quadra   "
							+ " left  join imovel.logradouroCep logradouroCep "
							+ " left  join logradouroCep.cep cep   "
							+ " left  join imovel.logradouroCep logradouroCep "
							+ " left  join logradouroCep.logradouro logradouro   "
							+ " left  join imovel.imovelCondominio imovelCondominio   "
							+ " left  join imovel.imovelPrincipal imovelPrincipal   "
							// + " left join imovel.nomeConta nomeConta "
							+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ " left  join imovel.ligacaoAgua ligacaoAgua  "
							+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
							+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  "
							+ " left  join imovel.imovelPerfil imovelPerfil  "
							+ " left  join imovel.pocoTipo pocoTipo   "
							+ " left  join imovel.faturamentoTipo faturamentoTipo "
							+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
							+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
							+ " left  join imovel.eloAnormalidade eloAnormalidade   "
							+ " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
							+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  "
							+ " left  join imovel.consumoTarifa consumoTarifa   "
							+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ " left  join imovel.ligacaoAgua ligacaoAgua   "
							+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
							+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
							+ " left  join imovel.ligacaoAgua ligacaoAgua   "
							+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
							+ " left join imovel.consumosHistoricos consumosHistorico   "
							+ " left join imovel.medicaoHistoricos medicaoHistorico   "
							+ " left join imovel.clienteImoveis clienteImoveis "
							+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo "
							+ " left join clienteImoveis.cliente cliente "
							+ " left join cliente.clienteTipo clienteTipo "
							+ " left join imovel.consumosHistoricos consumosHistorico "
							+ " left outer join imovel.clienteImoveis clienteImoveisUsuario with (clienteImoveisUsuario.clienteRelacaoTipo.id = "
							+ ClienteRelacaoTipo.USUARIO.toString() + ") and clienteImoveisUsuario.dataFimRelacao is null "
							+ " left outer join clienteImoveisUsuario.cliente clienteUsuario ";

			consulta = consulta
							+ montarCondicaoWhereFiltrarImovelOutrosCriterio(idImovelCondominio, idImovelPrincipal, idNomeConta,
											idSituacaoLigacaoAgua, consumoMinimoInicialAgua, consumoMinimoFinalAgua,
											idSituacaoLigacaoEsgoto, consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
											intervaloValorPercentualEsgotoInicial, intervaloValorPercentualEsgotoFinal,
											intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal,
											intervaloMediaMinimaHidrometroInicial, intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
											idPocoTipo, idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
											idEloAnormalidade, areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia,
											idConsumoTarifa, idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal,
											setorComercialInicial, setorComercialFinal, quadraInicial, quadraFinal, loteOrigem, loteDestno,
											cep, logradouro, bairro, municipio, idTipoMedicao, indicadorMedicao, idSubCategoria,
											idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal, diaVencimento, idCliente,
											idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal,
											numeroMoradoresInicial, numeroMoradoresFinal, idAreaConstruidaFaixa,
											consumoFixadoEsgotoPocoInicial, consumoFixadoEsgotoPocoFinal);

			/*
			 * # COLOCANDO O VALOR NAS CONDIÇÕES#
			 */

			/*
			 * consulta = consulta + " consumosHistorico.referenciaFaturamento = " +
			 * "(select max(consumoHistorico.referenciaFaturamento) from
			 * ConsumoHistorico consumoHistorico " + " left join
			 * consumoHistorico.imovel imovelConsumoHistorico " + "where
			 * imovelConsumoHistorico.id = imovel.id) and ";
			 */

			Query query = session.createQuery(consulta.substring(0, (consulta.length() - 5)));

			informarDadosQueryFiltrarImovelOutrosCriterio(query, idImovelCondominio, idImovelPrincipal, idNomeConta, idSituacaoLigacaoAgua,
							consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto, consumoMinimoInicialEsgoto,
							consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial, intervaloValorPercentualEsgotoFinal,
							intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal, intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal, idImovelPerfil, idPocoTipo, idFaturamentoSituacaoTipo,
							idCobrancaSituacaoTipo, idSituacaoEspecialCobranca, idEloAnormalidade, areaConstruidaInicial,
							areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa, idGerenciaRegional, idLocalidadeInicial,
							idLocalidadeFinal, setorComercialInicial, setorComercialFinal, quadraInicial, quadraFinal, loteOrigem,
							loteDestno, cep, logradouro, bairro, municipio, idTipoMedicao, indicadorMedicao, idSubCategoria, idCategoria,
							quantidadeEconomiasInicial, quantidadeEconomiasFinal, diaVencimento, idCliente, idClienteTipo,
							idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal, numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa, consumoFixadoEsgotoPocoInicial, consumoFixadoEsgotoPocoFinal);

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	private String montarCondicaoWhereFiltrarImovelOutrosCriterio(String idImovelCondominio, String idImovelPrincipal, String idNomeConta,
					String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
					String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
					String intervaloValorPercentualEsgotoInicial, String intervaloValorPercentualEsgotoFinal,
					String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
					String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
					String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
					String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal, String idCadastroOcorrencia,
					String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial, String idLocalidadeFinal,
					String setorComercialInicial, String setorComercialFinal, String quadraInicial, String quadraFinal, String loteOrigem,
					String loteDestno, String cep, String logradouro, String bairro, String municipio, String idTipoMedicao,
					String indicadorMedicao, String idSubCategoria, String idCategoria, String quantidadeEconomiasInicial,
					String quantidadeEconomiasFinal, String diaVencimento, String idCliente, String idClienteTipo,
					String idClienteRelacaoTipo, String numeroPontosInicial, String numeroPontosFinal, String numeroMoradoresInicial,
					String numeroMoradoresFinal, String idAreaConstruidaFaixa, String consumoFixadoEsgotoPocoInicial,
					String consumoFixadoEsgotoPocoFinal){

		String consulta = "";
		/*
		 * ## CONDIÇÕES ##
		 */
		consulta = consulta + " where ";

		// cliente
		if(idCliente != null && !idCliente.equals("")
						&& !idCliente.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " cliente.id = :idCliente  and  ";
		}

		// cliente tipo
		if(idClienteTipo != null && !idClienteTipo.equals("")
						&& !idClienteTipo.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " clienteTipo.id = :idClienteTipo  and  ";
		}

		// cliente relacao tipo
		if(idClienteRelacaoTipo != null
						&& !idClienteRelacaoTipo.equals("")
						&& !idClienteRelacaoTipo.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " clienteRelacaoTipo.id = :idClienteRelacaoTipo  and  ";
		}

		// gerencia regional
		if(idGerenciaRegional != null && !idGerenciaRegional.equals("")
						&& !idGerenciaRegional.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " gerenciaRegional.id = :idGerenciaRegional and ";
		}
		// localidade inicial e final
		if(((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) && (idLocalidadeFinal != null
						&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())))){
			consulta = consulta + " localidade.id >= :idLocalidadeInicial and localidade.id <= :idLocalidadeFinal  and  ";
		}
		// setor comercial inicial e final
		if(((setorComercialInicial != null && !setorComercialInicial.equals("") && !setorComercialInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) && (setorComercialFinal != null
						&& !setorComercialFinal.equals("") && !setorComercialFinal.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())))){
			consulta = consulta
							+ " setorComercial.codigo >= :setorComercialInicial and setorComercial.codigo <= :setorComercialFinal  and  ";
		}
		// quadra
		if((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta + " quadra.numeroQuadra >= :quadraInicial and quadra.numeroQuadra <= :quadraFinal and  ";
		}
		// lote
		if((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (loteDestno != null && !loteDestno.equals("") && !loteDestno.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta + " imovel.lote >= :loteOrigem  and  imovel.lote <= :loteDestino";
		}

		// cep
		if(cep != null && !cep.equals("")
						&& !cep.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " cep.codigo = :cep  and  ";
		}
		// logradouro
		if(logradouro != null && !logradouro.equals("")
						&& !logradouro.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " logradouro.id = :logradouro  and  ";
		}
		// bairro
		if(bairro != null && !bairro.equals("")
						&& !bairro.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " bairro.codigo = :bairro  and  ";
		}
		// municipio
		if(municipio != null && !municipio.equals("")
						&& !municipio.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " municipio.id = :municipio  and  ";
		}
		// consumo minimo agua inicial e final
		if((consumoMinimoInicialAgua != null && !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (consumoMinimoFinalAgua != null && !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta
							+ "ligacaoAgua.numeroConsumoMinimoAgua >= :consumoMinimoInicialAgua and ligacaoAgua.numeroConsumoMinimoAgua <= :consumoMinimoFinalAgua  and  ";
		}
		// consumo minimo esgoto inicial e final
		if((consumoMinimoInicialEsgoto != null && !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto.trim()
						.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (consumoMinimoFinalEsgoto != null && !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta
							+ "ligacaoEsgoto.consumoMinimo >= :consumoMinimoInicialEsgoto and ligacaoEsgoto.consumoMinimo <= :consumoMinimoFinalEsgoto  and  ";
		}

		// consumo fixado esgoto do poço inicial e final
		if(consumoFixadoEsgotoPocoInicial != null && !consumoFixadoEsgotoPocoInicial.toString().equals("")
						&& consumoFixadoEsgotoPocoFinal != null && !consumoFixadoEsgotoPocoFinal.toString().equals("")){

			consulta += " ligacaoEsgoto.numeroConsumoFixoPoco >= :consumoFixadoEsgotoPocoInicial and ligacaoEsgoto.numeroConsumoFixoPoco <= :consumoFixadoEsgotoPocoFinal  and  ";

		}

		// percentual esgoto inicial e final
		if((intervaloValorPercentualEsgotoInicial != null && !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
						.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (intervaloValorPercentualEsgotoFinal != null && !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
										.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){

			consulta = consulta
							+ "ligacaoEsgoto.percentual >= :intervaloValorPercentualEsgotoInicial and ligacaoEsgoto.percentual <= :intervaloValorPercentualEsgotoFinal  and  ";
		}
		// indicador medição
		if(indicadorMedicao != null && indicadorMedicao.equals("comMedicao")){
			// tipo medicao
			if(idTipoMedicao != null && idTipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA.toString())){
				consulta = consulta + "hidrometroInstalacaoHistorico.id is not null  and  ";
			}else if(idTipoMedicao != null && idTipoMedicao.equals(MedicaoTipo.POCO.toString())){
				consulta = consulta + "hidrometroInstalacaoHistoricoImovel.id is not null and  ";
			}else{
				consulta = consulta + "(hidrometroInstalacaoHistorico.id is not null or ";
				consulta = consulta + "hidrometroInstalacaoHistoricoImovel.id is not null) and  ";
			}
		}else if(indicadorMedicao != null && indicadorMedicao.equals("semMedicao")){
			consulta = consulta + "(hidrometroInstalacaoHistorico.id is null and";
			consulta = consulta + "hidrometroInstalacaoHistoricoImovel.id is null) and  ";
		}
		// imovel condominio
		if(idImovelCondominio != null && !idImovelCondominio.equals("")
						&& !idImovelCondominio.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " imovelCondominio.id = :idImovelCondominio ";
		}
		// imovel principal
		if(idImovelPrincipal != null && !idImovelPrincipal.equals("")
						&& !idImovelPrincipal.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " imovelPrincipal.id: = idImovelPrincipal ";
		}
		// nome conta
		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// consulta = consulta + " nomeConta.id = :idNomeConta and ";
		// }
		// situação da ligação de agua
		if(idSituacaoLigacaoAgua != null
						&& !idSituacaoLigacaoAgua.equals("")
						&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " ligacaoAguaSituacao.id = :idSituacaoLigacaoAgua  and  ";
		}
		// situação ligação de esgoto
		if(idSituacaoLigacaoEsgoto != null
						&& !idSituacaoLigacaoEsgoto.equals("")
						&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " ligacaoEsgotoSituacao.id = :idSituacaoLigacaoEsgoto  and  ";
		}
		// imovel Perfil
		if(idImovelPerfil != null && !idImovelPerfil.equals("")
						&& !idImovelPerfil.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " imovelPerfil.id = :idImovelPerfil  and  ";
		}
		// poço tipo
		if(idPocoTipo != null && !idPocoTipo.equals("")
						&& !idPocoTipo.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " pocoTipo.id = :idPocoTipo  and  ";
		}
		// faturamento situacao tipo
		if(idFaturamentoSituacaoTipo != null
						&& !idFaturamentoSituacaoTipo.equals("")
						&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " faturamentoTipo.id = idFaturamentoSituacaoTipo  and  ";
		}
		// cobranca situacao tipo
		if(idCobrancaSituacaoTipo != null
						&& !idCobrancaSituacaoTipo.equals("")
						&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " cobrancaSituacaoTipo.id = :idCobrancaSituacaoTipo  and  ";
		}
		// Situacao Especial Cobranca
		if(idSituacaoEspecialCobranca != null
						&& !idSituacaoEspecialCobranca.equals("")
						&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " faturamentoSituacaoTipo.id = :idSituacaoEspecialCobranca ";
		}

		// elo anormalidade
		if(idEloAnormalidade != null && !idEloAnormalidade.equals("")
						&& !idEloAnormalidade.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + "eloAnormalidade.id = :idEloAnormalidade  and  ";
		}
		// cadastro ocorrencia
		if(idCadastroOcorrencia != null
						&& !idCadastroOcorrencia.equals("")
						&& !idCadastroOcorrencia.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " cadastroOcorrencia.id = :idCadastroOcorrencia  and  ";
		}
		// area construida inicial e final
		if((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (areaConstruidaFinal != null && !areaConstruidaFinal.equals("") && !areaConstruidaFinal.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta
							+ " imovel.areaConstruida >= :areaConstruidaInicial and imovel.areaConstruida <= :areaConstruidaFinal  and  ";
		}
		// consumo tarifa
		if(idConsumoTarifa != null && !idConsumoTarifa.equals("")
						&& !idConsumoTarifa.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " consumoTarifa.id = :idConsumoTarifa   and  ";
		}
		// intervalo Media Minima Imovel Inicial e Final
		if((intervaloMediaMinimaImovelInicial != null && !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
						.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (intervaloMediaMinimaImovelFinal != null && !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
										.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta
							+ " consumosHistorico.consumoMedio >= :intervaloMediaMinimaImovelInicial and consumosHistorico.consumoMedio <= :intervaloMediaMinimaImovelFinal  and  ";
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if((intervaloMediaMinimaHidrometroInicial != null && !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
						.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (intervaloMediaMinimaHidrometroFinal != null && !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
										.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta
							+ " medicaoHistorico.consumoMedioHidrometro >= :intervaloMediaMinimaHidrometroInicial and medicaoHistorico.consumoMedioHidrometro <= :intervaloMediaMinimaHidrometroFinal  and  ";
		}
		// categoria
		if(idCategoria != null && !idCategoria.equals("")
						&& !idCategoria.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " categoria.id = :idCategoria  and  ";
		}
		// sub categoria
		if(idSubCategoria != null && !idSubCategoria.equals("")
						&& !idSubCategoria.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " subCategoria.id = :idSubCategoria  and  ";
		}
		// quantidade economias inicial e final
		if((quantidadeEconomiasInicial != null && !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial.trim()
						.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (quantidadeEconomiasFinal != null && !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta
							+ "imovelSubcategoria.quantidadeEconomias >= :quantidadeEconomiasInicial and imovelSubcategoria.quantidadeEconomias <= :quantidadeEconomiasFinal  and  ";
		}

		// dia Vencimento
		if(diaVencimento != null && !diaVencimento.equals("")
						&& !diaVencimento.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			if(diaVencimento.equals("1")){// sim
				consulta = consulta + " imovel.diaVencimento  is not null ";
			}
		}

		// numero prontos inicial e final
		if((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta
							+ " imove.numeroPontosUtilizacao >= :numeroPontosInicial and imovel.numeroPontosUtilizacao <= :numeroPontosFinal and ";
		}

		// numero moradores inicial e final
		if((numeroMoradoresInicial != null && !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (numeroMoradoresFinal != null && !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			consulta = consulta + " imovel.numeroMorador >= :numeroMoradoresInicial and imovel.numeroMorador <= :numeroMoradoresFinal and ";
		}
		// area construida faixa
		if(idAreaConstruidaFaixa != null
						&& !idAreaConstruidaFaixa.equals("")
						&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			consulta = consulta + " areaConstruidaFaixa.id = :idAreaConstruidaFaixa and ";
		}

		return consulta;
	}

	private void informarDadosQueryFiltrarImovelOutrosCriterio(Query query, String idImovelCondominio, String idImovelPrincipal,
					String idNomeConta, String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
					String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
					String intervaloValorPercentualEsgotoInicial, String intervaloValorPercentualEsgotoFinal,
					String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
					String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
					String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
					String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal, String idCadastroOcorrencia,
					String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial, String idLocalidadeFinal,
					String setorComercialInicial, String setorComercialFinal, String quadraInicial, String quadraFinal, String loteOrigem,
					String loteDestno, String cep, String logradouro, String bairro, String municipio, String idTipoMedicao,
					String indicadorMedicao, String idSubCategoria, String idCategoria, String quantidadeEconomiasInicial,
					String quantidadeEconomiasFinal, String diaVencimento, String idCliente, String idClienteTipo,
					String idClienteRelacaoTipo, String numeroPontosInicial, String numeroPontosFinal, String numeroMoradoresInicial,
					String numeroMoradoresFinal, String idAreaConstruidaFaixa, String consumoFixadoEsgotoPocoInicial,
					String consumoFixadoEsgotoPocoFinal){

		// gerencia regional
		if(idGerenciaRegional != null && !idGerenciaRegional.equals("")
						&& !idGerenciaRegional.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idGerenciaRegional", Integer.valueOf(idGerenciaRegional).intValue());
		}
		// localidade inicial e final
		if(((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) && (idLocalidadeFinal != null
						&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())))){
			query.setInteger("idLocalidadeInicial", Integer.valueOf(idLocalidadeInicial).intValue());
			query.setInteger("idLocalidadeFinal", Integer.valueOf(idLocalidadeFinal).intValue());
		}
		// setor comercial inicial e final
		if(((setorComercialInicial != null && !setorComercialInicial.equals("") && !setorComercialInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())) && (setorComercialFinal != null
						&& !setorComercialFinal.equals("") && !setorComercialFinal.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())))){
			query.setInteger("setorComercialInicial", Integer.valueOf(setorComercialInicial).intValue());
			query.setInteger("setorComercialFinal", Integer.valueOf(setorComercialFinal).intValue());
		}
		// quadra inicial e final
		if((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setInteger("quadraInicial", Integer.valueOf(quadraInicial).intValue());
			query.setInteger("quadraFinal", Integer.valueOf(quadraFinal).intValue());
		}
		// lote
		if((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (loteDestno != null && !loteDestno.equals("") && !loteDestno.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setInteger("loteOrigem", Integer.valueOf(loteOrigem).intValue());
			query.setInteger("loteDestino", Integer.valueOf(loteDestno).intValue());
		}
		// cep
		if(cep != null && !cep.equals("")
						&& !cep.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("cep", Integer.valueOf(cep).intValue());
		}
		// logradouro
		if(logradouro != null && !logradouro.equals("")
						&& !logradouro.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("logradouro", Integer.valueOf(logradouro).intValue());
		}
		// bairro
		if(bairro != null && !bairro.equals("")
						&& !bairro.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("bairro", Integer.valueOf(bairro).intValue());
		}
		// municipio
		if(municipio != null && !municipio.equals("")
						&& !municipio.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("municipio", Integer.valueOf(municipio).intValue());
		}
		// consumo minimo agua inicial e final
		if((consumoMinimoInicialAgua != null && !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (consumoMinimoFinalAgua != null && !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setInteger("consumoMinimoInicialAgua", Integer.valueOf(consumoMinimoInicialAgua).intValue());
			query.setInteger("consumoMinimoFinalAgua", Integer.valueOf(consumoMinimoFinalAgua).intValue());
		}
		// consumo minimo esgoto inicial e final
		if((consumoMinimoInicialEsgoto != null && !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto.trim()
						.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (consumoMinimoFinalEsgoto != null && !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setInteger("consumoMinimoInicialEsgoto", Integer.valueOf(consumoMinimoInicialEsgoto).intValue());
			query.setInteger("consumoMinimoFinalEsgoto", Integer.valueOf(consumoMinimoFinalEsgoto).intValue());
		}

		// consumo fixado esgoto do poço inicial e final
		if(consumoFixadoEsgotoPocoInicial != null && !consumoFixadoEsgotoPocoInicial.toString().equals("")
						&& consumoFixadoEsgotoPocoFinal != null && !consumoFixadoEsgotoPocoFinal.toString().equals("")){

			query.setInteger("consumoFixadoEsgotoPocoInicial", Integer.valueOf(consumoFixadoEsgotoPocoInicial).intValue());
			query.setInteger("consumoFixadoEsgotoPocoFinal", Integer.valueOf(consumoFixadoEsgotoPocoFinal).intValue());
		}

		// percentual esgoto inicial e final
		if((intervaloValorPercentualEsgotoInicial != null && !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
						.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (intervaloValorPercentualEsgotoFinal != null && !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
										.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setInteger("intervaloValorPercentualEsgotoInicial", new BigDecimal(intervaloValorPercentualEsgotoInicial).intValue());
			query.setInteger("intervaloValorPercentualEsgotoFinal", new BigDecimal(intervaloValorPercentualEsgotoFinal).intValue());
		}
		// imovel condominio
		if(idImovelCondominio != null && !idImovelCondominio.equals("")
						&& !idImovelCondominio.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idImovelCondominio", Integer.valueOf(idImovelCondominio).intValue());
		}
		// imovel principal
		if(idImovelPrincipal != null && !idImovelPrincipal.equals("")
						&& !idImovelPrincipal.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idImovelPrincipal", Integer.valueOf(idImovelPrincipal).intValue());
		}

		// nome conta
		if(idNomeConta != null && !idNomeConta.equals("")
						&& !idNomeConta.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idNomeConta", Integer.valueOf(idNomeConta).intValue());
		}
		// Situacao Ligacao Agua
		if(idSituacaoLigacaoAgua != null
						&& !idSituacaoLigacaoAgua.equals("")
						&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idSituacaoLigacaoAgua", Integer.valueOf(idSituacaoLigacaoAgua).intValue());
		}

		// situação ligação de esgoto
		if(idSituacaoLigacaoEsgoto != null
						&& !idSituacaoLigacaoEsgoto.equals("")
						&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idSituacaoLigacaoEsgoto", Integer.valueOf(idSituacaoLigacaoEsgoto).intValue());
		}
		// imovel Perfil
		if(idImovelPerfil != null && !idImovelPerfil.equals("")
						&& !idImovelPerfil.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idImovelPerfil", Integer.valueOf(idImovelPerfil).intValue());
		}
		// poço tipo
		if(idPocoTipo != null && !idPocoTipo.equals("")
						&& !idPocoTipo.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idPocoTipo", Integer.valueOf(idPocoTipo).intValue());
		}
		// faturamento situacao tipo
		if(idFaturamentoSituacaoTipo != null
						&& !idFaturamentoSituacaoTipo.equals("")
						&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idFaturamentoSituacaoTipo", Integer.valueOf(idFaturamentoSituacaoTipo).intValue());
		}
		// cobranca situacao tipo
		if(idCobrancaSituacaoTipo != null
						&& !idCobrancaSituacaoTipo.equals("")
						&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idCobrancaSituacaoTipo", Integer.valueOf(idCobrancaSituacaoTipo).intValue());
		}
		// Situacao Especial Cobranca
		if(idSituacaoEspecialCobranca != null
						&& !idSituacaoEspecialCobranca.equals("")
						&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idSituacaoEspecialCobranca", Integer.valueOf(idSituacaoEspecialCobranca).intValue());
		}
		// elo anormalidade
		if(idEloAnormalidade != null && !idEloAnormalidade.equals("")
						&& !idEloAnormalidade.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idEloAnormalidade", Integer.valueOf(idEloAnormalidade).intValue());
		}
		// cadastro ocorrencia
		if(idCadastroOcorrencia != null
						&& !idCadastroOcorrencia.equals("")
						&& !idCadastroOcorrencia.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idCadastroOcorrencia", Integer.valueOf(idCadastroOcorrencia).intValue());
		}
		// area construida inicial e final
		if((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (areaConstruidaFinal != null && !areaConstruidaFinal.equals("") && !areaConstruidaFinal.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setBigDecimal("areaConstruidaInicial", Util.formatarMoedaRealparaBigDecimal(areaConstruidaInicial));
			query.setBigDecimal("areaConstruidaFinal", Util.formatarMoedaRealparaBigDecimal(areaConstruidaFinal));
		}
		// consumo tarifa
		if(idConsumoTarifa != null && !idConsumoTarifa.equals("")
						&& !idConsumoTarifa.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idConsumoTarifa", Integer.valueOf(idConsumoTarifa).intValue());
		}
		// intervalo Media Minima Imovel Inicial e Final
		if((intervaloMediaMinimaImovelInicial != null && !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
						.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (intervaloMediaMinimaImovelFinal != null && !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
										.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setInteger("intervaloMediaMinimaImovelInicial", Integer.valueOf(intervaloMediaMinimaImovelInicial).intValue());
			query.setInteger("intervaloMediaMinimaImovelFinal", Integer.valueOf(intervaloMediaMinimaImovelFinal).intValue());
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if((intervaloMediaMinimaHidrometroInicial != null && !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
						.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (intervaloMediaMinimaHidrometroFinal != null && !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
										.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setInteger("intervaloMediaMinimaHidrometroInicial", Integer.valueOf(intervaloMediaMinimaHidrometroInicial).intValue());
			query.setInteger("intervaloMediaMinimaHidrometroFinal", Integer.valueOf(intervaloMediaMinimaHidrometroFinal).intValue());
		}

		// quantidade economias inicial e final
		if((quantidadeEconomiasInicial != null && !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial.trim()
						.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (quantidadeEconomiasFinal != null && !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setShort("quantidadeEconomiasInicial", Short.valueOf(quantidadeEconomiasInicial).shortValue());
			query.setShort("quantidadeEconomiasFinal", Short.valueOf(quantidadeEconomiasFinal).shortValue());
		}

		// categoria
		if(idCategoria != null && !idCategoria.equals("")
						&& !idCategoria.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idCategoria", Integer.valueOf(idCategoria).intValue());
		}

		// sub categoria
		if(idSubCategoria != null && !idSubCategoria.equals("")
						&& !idSubCategoria.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idSubCategoria", Integer.valueOf(idSubCategoria).intValue());
		}

		// numero prontos inicial e final
		if((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setShort("numeroPontosInicial", Short.valueOf(numeroPontosInicial).shortValue());
			query.setShort("numeroPontosFinal", Short.valueOf(numeroPontosFinal).shortValue());
		}

		// numero moradores inicial e final
		if((numeroMoradoresInicial != null && !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial.trim().equalsIgnoreCase(
						Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))
						&& (numeroMoradoresFinal != null && !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))){
			query.setShort("numeroMoradoresInicial", Short.valueOf(numeroMoradoresInicial).shortValue());
			query.setShort("numeroMoradoresFinal", Short.valueOf(numeroMoradoresFinal).shortValue());
		}
		// area construida faixa
		if(idAreaConstruidaFaixa != null
						&& !idAreaConstruidaFaixa.equals("")
						&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
										Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idAreaConstruidaFaixa", Integer.valueOf(idAreaConstruidaFaixa).intValue());
		}

		// cliente
		if(idCliente != null && !idCliente.equals("")
						&& !idCliente.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idCliente", Integer.valueOf(idCliente).intValue());
		}

		// cliente tipo
		if(idClienteTipo != null && !idClienteTipo.equals("")
						&& !idClienteTipo.trim().equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idClienteTipo", Integer.valueOf(idClienteTipo).intValue());
		}

		// cliente relacao tipo
		if(idClienteRelacaoTipo != null
						&& !idClienteRelacaoTipo.equals("")
						&& !idClienteRelacaoTipo.trim()
										.equalsIgnoreCase(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO).toString())){
			query.setInteger("idClienteRelacaoTipo", Integer.valueOf(idClienteRelacaoTipo).intValue());
		}
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<Conta> pesquisarContasDoImovelPorMesAnoReferencia(int anoMesReferencia, String idImovel)
					throws ErroRepositorioException{

		Collection<Conta> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cnta " + "from Conta cnta " + "where cnta.referencia = :anoMesReferencia " + "and cnta.imovel = :idImovel "
							+ "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.NORMAL + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.RETIFICADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.INCLUIDA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idImovel", Integer.valueOf(idImovel)).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoMedioLigacaoAgua(String idImovel, int anoMesReferencia)
					throws ErroRepositorioException{

		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cshi " + "from ConsumoHistorico cshi " + " left join cshi.imovel imovel "
							+ " left join cshi.ligacaoTipo ligacaoTipo " + "where imovel.id = :idImovel  and "
							+ "ligacaoTipo.id = :idLigacaoTipo and " + "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idLigacaoTipo", LigacaoTipo.LIGACAO_AGUA).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoMedioLigacaoEsgoto(String idImovel, int anoMesReferencia)
					throws ErroRepositorioException{

		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cshi " + "from ConsumoHistorico cshi " + " left join cshi.imovel imovel "
							+ " left join cshi.ligacaoTipo ligacaoTipo " + "where imovel.id = :idImovel  and "
							+ "ligacaoTipo.id = :idLigacaoTipo and " + "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idLigacaoTipo", LigacaoTipo.LIGACAO_ESGOTO)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoMesLigacaoAgua(String idImovel, int anoMesReferencia)
					throws ErroRepositorioException{

		// Alteração conforme OC0857313
		// .......................................................

		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cshi.numeroConsumoFaturadoMes, consumoAnormalidade.descricaoAbreviada " + "from ConsumoHistorico cshi "
							+ " left join cshi.consumoAnormalidade consumoAnormalidade " + " left join cshi.imovel imovel "
							+ " left join imovel.ligacaoAguaSituacao ligacaoAguaSituacao " + " left join cshi.ligacaoTipo ligacaoTipo "
							+ "where imovel.id = :idImovel  and " + "ligacaoTipo.id = :idLigacaoTipo and "
							+ "ligacaoAguaSituacao.indicadorFaturamentoSituacao = :indicadorFaturamentoSituacao and "
							// + "(imovel.ligacaoAguaSituacao = :idLigacaoAguaLigado or "
							// + "imovel.ligacaoAguaSituacao = :idLigacaoAguaCortado) and "
							+ "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idLigacaoTipo", LigacaoTipo.LIGACAO_AGUA)
							.setShort("indicadorFaturamentoSituacao", LigacaoAguaSituacao.FATURAMENTO_ATIVO)
			// .setInteger("idLigacaoAguaLigado",LigacaoAguaSituacao.LIGADO)
							// .setInteger("idLigacaoAguaCortado", LigacaoAguaSituacao.CORTADO)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoMesLigacaoEsgoto(String idImovel, int anoMesReferencia)
					throws ErroRepositorioException{

		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cshi.numeroConsumoFaturadoMes, consumoAnormalidade.descricaoAbreviada " + "from ConsumoHistorico cshi "
							+ " left join cshi.consumoAnormalidade consumoAnormalidade " + " left join cshi.imovel imovel "
							+ " left join cshi.ligacaoTipo ligacaoTipo " + "where imovel.id = :idImovel  and "
							+ "ligacaoTipo.id = :idLigacaoTipo and " + "imovel.ligacaoEsgotoSituacao = :idLigacaoEsgotoLigado and "
							+ "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idLigacaoTipo", LigacaoTipo.LIGACAO_ESGOTO)
							.setInteger("idLigacaoEsgotoLigado", LigacaoEsgotoSituacao.LIGADO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @author Eduardo Henrique
	 * @date 15/05/2008
	 *       Correção na consulta pois LigacaoAgua não possui entidade LigacaoAguaSituacao , e sim
	 *       Imovel
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<MedicaoHistorico> pesquisarLeituraFaturadaLigacaoAgua(String idImovel, int anoMesReferencia)
					throws ErroRepositorioException{

		// Alteração conforme OC0857313
		// .......................................................

		Collection<MedicaoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select mdhi.leituraAtualFaturamento, leituraAnormalidadeFaturamento.id " + "from MedicaoHistorico mdhi "
							+ " left join mdhi.ligacaoAgua ligacaoAgua " + " left join mdhi.imovel imovel "
							+ " left join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ " left join mdhi.leituraAnormalidadeFaturamento leituraAnormalidadeFaturamento "
							+ "where ligacaoAgua.id = :idImovel  and "
							+ "ligacaoAguaSituacao.indicadorFaturamentoSituacao = :indicadorFaturamentoSituacao and "
							+ "mdhi.anoMesReferencia = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
							.setInteger("anoMesReferencia", anoMesReferencia)
			// .setInteger("idLigacaoAguaLigado", LigacaoAguaSituacao.LIGADO)
							// .setInteger("idLigacaoAguaCortado", LigacaoAguaSituacao.CORTADO)
							.setShort("indicadorFaturamentoSituacao", LigacaoAguaSituacao.FATURAMENTO_ATIVO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<MedicaoHistorico> pesquisarLeituraFaturadaLigacaoEsgoto(String idImovel, int anoMesReferencia)
					throws ErroRepositorioException{

		Collection<MedicaoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select mdhi " + "from MedicaoHistorico mdhi " + " left join mdhi.imovel imovel "
							+ "where imovel.id = :idImovel  and " + "imovel.ligacaoEsgotoSituacao = :idLigacaoEsgotoLigado and "
							+ "mdhi.anoMesReferencia = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
							.setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLigacaoEsgotoLigado", LigacaoEsgotoSituacao.LIGADO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public String pesquisarAnormalidadeLeitura(Integer idAnormalidadeLeitura) throws ErroRepositorioException{

		String retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ltan.descricaoAbreviada from LeituraAnormalidade ltan " + "where ltan.id = :idAnormalidadeLeitura ";

			retorno = (String) session.createQuery(consulta).setInteger("idAnormalidadeLeitura", idAnormalidadeLeitura).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 * @author Eduardo Henrique
	 * @date 15/05/2008
	 *       Correção na consulta. LigacaoAgua não possui entidade LigacaoAguaSituacao, e sim
	 *       Imovel.
	 */
	public Collection<HidrometroInstalacaoHistorico> pesquisarDataHidrometroLigacaoAgua(String idImovel) throws ErroRepositorioException{

		// Alteração conforme OC0857313
		// .......................................................
		Collection<HidrometroInstalacaoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select hidi " + "from HidrometroInstalacaoHistorico hidi " + " left join hidi.ligacaoAgua ligacaoAgua "
							+ " left join hidi.imovel imovel " + " left join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "where ligacaoAgua.id = :idImovel  and "
							+ "ligacaoAguaSituacao.indicadorFaturamentoSituacao = :indicadorFaturamentoSituacao";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
			// .setInteger("idLigacaoAguaLigado",LigacaoAguaSituacao.LIGADO)
							// .setInteger("idLigacaoAguaCortado", LigacaoAguaSituacao.CORTADO)
							.setShort("indicadorFaturamentoSituacao", LigacaoAguaSituacao.FATURAMENTO_ATIVO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<HidrometroInstalacaoHistorico> pesquisarDataHidrometroLigacaoEsgoto(String idImovel) throws ErroRepositorioException{

		Collection<HidrometroInstalacaoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select hidi " + "from HidrometroInstalacaoHistorico hidi " + " left join hidi.imovel imovel "
							+ "where imovel.id = :idImovel  and " + "imovel.ligacaoEsgotoSituacao = :idLigacaoEsgotoLigado ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
							.setInteger("idLigacaoEsgotoLigado", LigacaoEsgotoSituacao.LIGADO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0336] - Gerar Relatorio de Acompanhamento do Faturamento
	 * 
	 * @param anoMesReferenciaContabil
	 *            idImovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<ConsumoHistorico> pesquisarConsumoFaturadoMes(String idImovel, int anoMesReferencia) throws ErroRepositorioException{

		Collection<ConsumoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cshi " + "from ConsumoHistorico cshi " + " left join cshi.imovel imovel "
							+ "where imovel.id = :idImovel  and " + "cshi.referenciaFaturamento = :anoMesReferencia";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel))
							.setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<FaturamentoAtividadeCronograma> pesquisarRelacaoAtividadesGrupo(Integer faturamentoGrupoId)
					throws ErroRepositorioException{

		Collection<FaturamentoAtividadeCronograma> retorno = new ArrayList();

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		Iterator iterator = null;

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select faturamentoAtividadeCronograma from FaturamentoAtividadeCronograma faturamentoAtividadeCronograma "
							+ " inner join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal fatGrupoCronMensal "
							+ " inner join fatGrupoCronMensal.faturamentoGrupo fatGrupo "
							+ " where fatGrupo.id = :faturamentoGrupoId and "
							+ " fatGrupo.anoMesReferencia = fatGrupoCronMensal.anoMesReferencia order by faturamentoAtividadeCronograma.faturamentoAtividade.ordemRealizacao";

			// executa o hql
			iterator = session.createQuery(consulta).setInteger("faturamentoGrupoId", faturamentoGrupoId).iterate();

			while(iterator.hasNext()){
				FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iterator.next();
				faturamentoAtividadeCronograma.getFaturamentoAtividade();
				faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal();
				faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal().getFaturamentoGrupo();

				retorno.add(faturamentoAtividadeCronograma);
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso calcula a tarifa miníma de água para um imóvel
	 * [UC0451] Obter Tarifa Miníma de Água para um Imóvel
	 * Para cada categoria e maior data de vigência retorna o valor da tarifa
	 * minima
	 * pesquisarTarifaMinimaCategoriaVigencia
	 * 
	 * @author Roberta Costa
	 * @date 09/08/2006
	 * @param dataCorrente
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object pesquisarTarifaMinimaCategoriaVigencia(Categoria categoria, ConsumoTarifaVigencia consumoTarifaVigencia,
					Integer idSubCategoria) throws ErroRepositorioException{

		Object retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select ct.valorTarifaMinima " + "from ConsumoTarifaCategoria ct "
							+ "inner join ct.consumoTarifaVigencia ctv " + "inner join ct.categoria ctg "
							+ "inner join ct.subCategoria sc " + "where ctv.id = :consumoTarifaVigenciaId " + "and ctg.id = :categoriaId "
							+ "and sc.id = :subcategoriaId";

			retorno = session.createQuery(consulta).setInteger("consumoTarifaVigenciaId", consumoTarifaVigencia.getId())
							.setInteger("categoriaId", categoria.getId()).setInteger("subcategoriaId", idSubCategoria).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso inicia um processo para o mecanismo batch
	 * [UC0111] - Iniciar Processo
	 * Este subfluxo tem o papel de iniciar um processo de faturamento
	 * comandado, neste método é feita uma busca para obter as atividades
	 * comandadas e não realizadas
	 * [SB0001] - Iniciar Processo de Faturamento Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 14/08/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoAtividadeCronograma> pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadas(int numeroPagina)
					throws ErroRepositorioException{

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		Collection<FaturamentoAtividadeCronograma> retorno = new ArrayList();

		// Iterator iterator = null;

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select faturamentoAtividadeCronograma from FaturamentoAtividadeCronograma faturamentoAtividadeCronograma "
							+ " inner join fetch faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal "
							+ " left join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo faturamentoGrupo "
							+ " left join fetch faturamentoAtividadeCronograma.faturamentoAtividade faturamentoAtividade "
							+ " where faturamentoGrupo.anoMesReferencia = faturamentoGrupoCronogramaMensal.anoMesReferencia and "
							+ " faturamentoAtividadeCronograma.comando is not null and "
							+ "(faturamentoAtividadeCronograma.dataRealizacao is null and faturamentoAtividadeCronograma.dataPrevista <= :dataAtual)"
							+ " order by  faturamentoGrupoCronogramaMensal.anoMesReferencia, faturamentoGrupo.id, faturamentoAtividade.descricao";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta).setDate("dataAtual", new Date())
							.setFirstResult(10 * numeroPagina).setMaxResults(10).list()));

			/**
			 * alterado por pedro alexandre dia 23/01/2007
			 */
			/*
			 * // constroi o hql consulta = "select
			 * faturamentoAtividadeCronograma from
			 * FaturamentoAtividadeCronograma faturamentoAtividadeCronograma " + "
			 * inner join
			 * faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal
			 * faturamentoGrupoCronogramaMensal " + " left join
			 * faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo
			 * faturamentoGrupo " + " where faturamentoGrupo.anoMesReferencia =
			 * faturamentoGrupoCronogramaMensal.anoMesReferencia and " + "
			 * faturamentoAtividadeCronograma.comando is not null and " +
			 * "(faturamentoAtividadeCronograma.dataRealizacao is null or
			 * (faturamentoAtividadeCronograma.dataRealizacao <
			 * faturamentoAtividadeCronograma.comando))"; // executa o hql
			 * iterator = session.createQuery(consulta).setFirstResult(10 *
			 * numeroPagina).setMaxResults(10).list().iterator();
			 * while (iterator.hasNext()) { FaturamentoAtividadeCronograma
			 * faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma)
			 * iterator.next();
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal
			 * ());
			 * Hibernate.initialize(faturamentoAtividadeCronograma.getFaturamentoAtividade());
			 * retorno.add(faturamentoAtividadeCronograma); }
			 */
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de uso inicia um processo para o mecanismo batch
	 * [UC0111] - Iniciar Processo
	 * Este subfluxo tem o papel de iniciar um processo de faturamento
	 * comandado, neste método é feita uma busca para obter as atividades
	 * comandadas e não realizadas
	 * [SB0001] - Iniciar Processo de Faturamento Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 14/08/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadasCount() throws ErroRepositorioException{

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		int retorno = 0;

		try{
			// constroi o hql
			consulta = "select count(faturamentoAtividadeCronograma.id) from FaturamentoAtividadeCronograma faturamentoAtividadeCronograma "
							+ " inner join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal "
							+ " left join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo faturamentoGrupo "
							+ " where faturamentoGrupo.anoMesReferencia = faturamentoGrupoCronogramaMensal.anoMesReferencia and "
							+ " faturamentoAtividadeCronograma.comando is not null and "
							+ "(faturamentoAtividadeCronograma.dataRealizacao is null and faturamentoAtividadeCronograma.dataPrevista <= :dataAtual)";

			// executa o hql
			retorno = ((Number) session.createQuery(consulta).setDate("dataAtual", new Date()).uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa a existencia de uma conta pelo id da conta e pela data da ultima alteracao
	 * 
	 * @author Saulo Lima
	 * @date 31/01/2009
	 *       Alteração no tipo do parâmetro 'ultimaAlteracao' para Date
	 * @param String
	 *            Id da Conta pesquisada
	 * @param Date
	 *            Data da última alteração
	 * @return Integer
	 *         Id da Conta localizada
	 * @throws ControladorException
	 */
	@Deprecated
	public Integer pesquisarExistenciaContaParaConcorrencia(String idConta, Date ultimaAlteracao) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			/*
			 * Date ultimaAlteracaoInicio = Util.criarData() Date
			 * ultimaAlteracaoFim = ultimaAlteracao + ".999";
			 */

			/*
			 * consulta = "SELECT ct.id FROM Conta ct " + "WHERE ct.id =
			 * :idConta " + "AND ct.ultimaAlteracao >= :ultimaAlteracaoInicio " +
			 * "AND ct.ultimaAlteracao <= :ultimaAlteracaoFim ";
			 * retorno = (Integer) session.createQuery(consulta).setString(
			 * "idConta", idConta).setString("ultimaAlteracaoInicio",
			 * ultimaAlteracaoInicio).setString("ultimaAlteracaoFim",
			 * ultimaAlteracaoFim).setMaxResults(1).uniqueResult();
			 */

			consulta = "SELECT ct.id FROM Conta ct " + "WHERE ct.id = :idConta " + "AND ct.ultimaAlteracao <= :ultimaAlteracao ";

			retorno = (Integer) session.createQuery(consulta).setTimestamp("ultimaAlteracao", ultimaAlteracao)
							.setInteger("idConta", Integer.valueOf(idConta)).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer verificarExistenciaDebitoTipo(Integer idDebitoTipo) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada

		Integer retorno = null;

		// cria a sessão com o hibernate
		Session session = HibernateUtil.getSession();

		try{
			// cria o HQL para consulta
			String consulta = "select debitoTipo.id " + "from DebitoTipo debitoTipo " + "where debitoTipo.id = :idDebitoTipo";

			retorno = (Integer) session.createQuery(consulta).setInteger("idDebitoTipo", idDebitoTipo.intValue()).setMaxResults(1)
							.uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		// retorna a coleção pesquisada
		return retorno;
	}

	/**
	 * Este caso de uso consultar os dados da conta
	 * 
	 * @param idConta
	 *            Id da Conta
	 * @author Fernanda Paiva
	 * @date 04/09/2006
	 * @return uma colecao de conta
	 * @throws ErroRepositorioException
	 */
	public Collection consultarConta(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "SELECT imov.id, " // 0
							+ "cnta.referencia, " // 1
							+ "cnta.debitoCreditoSituacaoAtual, "// 2
							+ "cnta.ligacaoAguaSituacao, "// 3
							+ "cnta.ligacaoEsgotoSituacao, " // 4
							+ "cnta.indicadorCobrancaMulta, "// 5
							+ "cnta.indicadorAlteracaoVencimento, "// 6
							+ "cnta.consumoAgua, "// 7
							+ "cnta.consumoEsgoto, " // 8
							+ "cnta.percentualEsgoto, "// 9
							+ "cnta.valorAgua, " // 10
							+ "cnta.valorEsgoto, " // 11
							+ "cnta.debitos, " // 12
							+ "cnta.valorCreditos, "// 13
							+ "cnta.indicadorDebitoConta, "// 14
							+ "cnta.id, " // 15
							+ "cnta.dataVencimentoConta, "// 16
							+ "cnta.dataValidadeConta, " // 17
							+ "cnta.dataInclusao, " // 18
							+ "cnta.dataRetificacao, "// 19
							+ "cnta.dataCancelamento, " // 20
							+ "cnta.dataRevisao, "// 21
							+ "mned.id, "// 22
							+ "mned.descricao, "// 23
							+ "mned.descricaoAbreviada, "// 24
							+ "mned.indicadorUso, "// 25
							+ "mned.ultimaAlteracao, "// 26

							+ "cnmi.id, "// 27
							+ "cnmi.descricaoMotivoInclusaoConta, "// 28
							+ "cnmi.indicadorUso, "// 29
							+ "cnmi.ultimaAlteracao, "// 30

							+ "cnmr.id, "// 31
							+ "cnmr.descricaoMotivoRetificacaoConta, "// 32
							+ "cnmr.indicadorUso, "// 33
							+ "cnmr.ultimaAlteracao, "// 34

							+ "cnmc.id, "// 35
							+ "cnmc.descricaoMotivoCancelamentoConta, "// 36
							+ "cnmc.indicadorUso, "// 37
							+ "cnmc.ultimaAlteracao, "// 38

							+ "cnmrv.id, "// 39
							+ "cnmrv.descricaoMotivoRevisaoConta, "// 40
							+ "cnmrv.indicadorUso, "// 41
							+ "cnmrv.ultimaAlteracao, "// 42

							+ "contaOrigem.id, "// 43
							+ "imovelOrigem.id, "// 44

							+ "cnta.referenciaContabil, "// 45
							+ "cnta.referenciaBaixaContabil, "// 46
							+ "cnta.creditoConsumo, "// 47
							+ "cstf.id, "// 48
							+ "cstf.descricao, "// 49
							+ "cnta.consumoMinimoEsgoto, " // 50
							+ "cnta.valorImposto, " // 51
							+ "cnta.indicadorCobrancaAdministrativa, " // 52
							+ "cnta.indicadorRemuneraCobrancaAdministrativa, " // 53
							+ "cnta.indicadorExecucaoFiscal " // 54
							+ "FROM Conta cnta " + "INNER JOIN cnta.imovel imov "
							+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst "
							+ "INNER JOIN cnta.ligacaoAguaSituacao last "
							+ "INNER JOIN cnta.ligacaoEsgotoSituacao lest "
							+ "INNER JOIN cnta.consumoTarifa cstf "
							+ "LEFT JOIN cnta.motivoNaoEntregaDocumento mned "
							+ "LEFT JOIN cnta.contaMotivoInclusao cnmi "
							+ "LEFT JOIN cnta.contaMotivoRetificacao cnmr "
							+ "LEFT JOIN cnta.contaMotivoCancelamento cnmc " + "LEFT JOIN cnta.contaMotivoRevisao cnmrv "

							+ "LEFT JOIN cnta.origem contaGeralOrigem "
							+ "LEFT JOIN contaGeralOrigem.conta contaOrigem "
							+ "LEFT JOIN contaOrigem.imovel imovelOrigem "

							+ "WHERE  cnta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * Este caso de uso permite a emissão de uma ou mais contas.
	 * 
	 * @author Pedro Alexandre
	 * @date 19/09/2006
	 * @param anoMesReferencia
	 * @param faturamentoGrupo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpressao(Integer anoMesReferencia, FaturamentoGrupo faturamentoGrupo) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaImpressao.id " + "from ContaImpressao contaImpressao "
							+ "where contaImpressao.referenciaConta =:referencia "
							+ "and contaImpressao.faturamentoGrupo.id = :idFaturamentoGrupo " + "and contaImpressao.indicadorImpressao ="
							+ ConstantesSistema.NAO + " order by contaImpressao.id";

			retorno = session.createQuery(consulta).setInteger("referencia", anoMesReferencia)
							.setInteger("idFaturamentoGrupo", faturamentoGrupo.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * Este caso de uso permite a emissão de uma ou mais contas.
	 * 
	 * @author Pedro Alexandre
	 * @date 24/10/2006
	 * @param anoMesReferencia
	 * @param faturamentoGrupo
	 * @param numeroPaginas
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImpressao(Integer anoMesReferencia, FaturamentoGrupo faturamentoGrupo, Integer numeroPaginas)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaImpressao.cnta_id as idContaImpressao "
							+ "from conta_impressao contaImpressao "
							+ "inner join conta cnt on cnt.cnta_id=contaImpressao.cnta_id "
							+ "inner join quadra qdraConta on qdraConta.qdra_id = cnt.qdra_id "
							+ "inner join rota rot on rot.rota_id = qdraConta.rota_id "
							+ "inner join empresa emp on emp.empr_id = rot.empr_id "
							+ "where contaImpressao.cnti_amreferenciaconta =:referencia "
							+ "and contaImpressao.ftgr_id = :idFaturamentoGrupo "
							+ "and contaImpressao.cnti_icimpressao ="
							+ ConstantesSistema.NAO
							+ " order by cnta_amreferenciaconta,contaImpressao.clie_idresponsavel,emp.empr_id,cnt.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idContaImpressao", Hibernate.INTEGER)
							.setInteger("referencia", anoMesReferencia).setInteger("idFaturamentoGrupo", faturamentoGrupo.getId())
							.setMaxResults(1000).setFirstResult(numeroPaginas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Pedro Alexandre
	 * @date 19/09/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorMultasCobradas(int idConta) throws ErroRepositorioException{

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuffer consulta = new StringBuffer();

		try{
			// constroi o hql
			consulta.append("select sum(dbcb.valorPrestacao) ").append("from DebitoCobrado dbcb ").append("inner join dbcb.conta cnta ")
							.append("inner join dbcb.debitoTipo dbtp ").append("where cnta.id = :idConta ").append("and dbtp.id = ")
							.append(DebitoTipo.MULTA_IMPONTUALIDADE);

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * Recupera os dados da conta p emitir a 2ª via [UC0482]Emitir 2ª Via de
	 * Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 15/09/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConta(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT " + " new "
							+ EmitirContaHelper.class.getName()
							+ " ( "
							+ "cnt.id, "
							+ "cli.nome, "
							+ "cli.cpf, "
							+ "cli.cnpj, "
							+ "cnt.dataVencimentoConta, "
							+ "cnt.referencia, "
							+ "cnt.digitoVerificadorConta, "
							+ "cnt.codigoSetorComercial, "
							+ "cnt.quadra, "
							+ "cnt.lote, "
							+ "cnt.subLote, "
							+ "cnt.consumoAgua, "
							+ "cnt.consumoEsgoto, "
							+ "cnt.valorAgua, "
							+ "cnt.valorEsgoto, "
							+ "cnt.debitos, "
							+ "cnt.valorCreditos, "
							+ "cnt.valorImposto, "
							+ "cnt.dataValidadeConta, "
							+ "imovel.id, "
							+ "loc.id, "
							+ "gerenciaRegional.id, "
							+ "gerenciaRegional.nome, "
							+ "ligacaoAguaSituacao.id, "
							+ "ligacaoEsgotoSituacao.id, "
							+ "imovelPerfil.id, "
							+ "setorComercial.id, "
							+ "faturamentoGrupo.id, "
							+ "emp.id, "
							+ "loc.descricao, "
							+ "ligacaoAguaSituacao.descricao, "
							+ "ligacaoEsgotoSituacao.descricao, "
							+ "imovelContaEnvio.id, "
							+ "cnt.percentualEsgoto, "
							+ "imovel.nomeImovel,"
							+ "cnt.debitoCreditoSituacaoAtual.id, "
							+ "cmret.id, "
							+ "funcionario.id, cnt.dataEmissao, cnt.indicadorPagamento, cnt.indicadorCobrancaMulta, cmret.descricaoMotivoRetificacaoConta "
							+ " ) " + "from ClienteConta cliCnt " + "RIGHT JOIN cliCnt.conta cnt "
							+ "LEFT JOIN cliCnt.clienteRelacaoTipo crt " + "LEFT JOIN cliCnt.cliente cli "
							+ "LEFT JOIN cnt.contaMotivoRevisao cmr " + "LEFT JOIN cnt.quadraConta quadraConta "
							+ "LEFT JOIN cnt.localidade loc " + "LEFT JOIN loc.gerenciaRegional gerenciaRegional "
							+ "LEFT JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "LEFT JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao " + "LEFT JOIN cnt.imovelPerfil imovelPerfil "
							+ "LEFT JOIN quadraConta.rota rota " + "LEFT JOIN rota.empresa emp "
							+ "LEFT JOIN quadraConta.setorComercial setorComercial " + "LEFT JOIN rota.faturamentoGrupo faturamentoGrupo "
							+ "LEFT JOIN cnt.imovel imovel " + "LEFT JOIN imovel.imovelContaEnvio imovelContaEnvio "
							+ "LEFT JOIN cnt.contaMotivoRetificacao cmret " + "LEFT JOIN cnt.usuario usuario "
							+ "LEFT JOIN usuario.funcionario funcionario " + "WHERE  cnt.id = :idConta "
							+ "AND cliCnt.indicadorNomeConta = 1 "
							+ "ORDER BY cnt.referencia,emp.id,loc.id,cnt.codigoSetorComercial," + "cnt.quadra,cnt.lote,cnt.subLote";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0209] Gerar Taxa de Entrega de Conta em Outro Endereço
	 * Atualiza os dados do débito a cobrar e a data de última atualização do
	 * débito a cobrar geral.
	 * 
	 * @author Pedro Alexandre
	 * @date 20/09/2006
	 * @param colecaoDebitosACobrar
	 * @throws ErroRepositorioException
	 */
	public void atualizaDebitoACobrar(Collection colecaoDebitosACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			Iterator colecaoDebitosACobrarIterator = colecaoDebitosACobrar.iterator();

			String sqlAtualizar = "";
			// Laço para atualizar todos os débitos a cobrar informados
			while(colecaoDebitosACobrarIterator.hasNext()){
				// Atualiza o débito a cobrar
				DebitoACobrar debitoACobrar = (DebitoACobrar) colecaoDebitosACobrarIterator.next();
				session.merge(debitoACobrar);

				// Atualiza a data de última alteração do débito a cobrar geral.
				sqlAtualizar = "update DebitoACobrarGeral dage " + "set dage.ultimaAlteracao = :dataUltimaAlteracao "
								+ "where dage.id = :idDebitoACobrarCategoria";

				session.createQuery(sqlAtualizar).setTimestamp("dataUltimaAlteracao", new Date())
								.setInteger("idDebitoACobrarCategoria", debitoACobrar.getId()).executeUpdate();

				session.flush();
			}
		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0351 - Calcular Impostos Deduzidos da Conta] Author: Fernanda Paiva
	 * Data: 21/09/2006
	 * 
	 * @param idImovel
	 *            Id do Imóvel
	 * @return cliente responsavel pelo imovel marcado como esferaPoder =
	 *         federal
	 */
	public Integer pesquisarClienteResponsavelEsferaPoderFederal(Integer idImovel) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select cli.id from ClienteImovel cliImo " + "inner join cliImo.clienteRelacaoTipo crt "
							+ "inner join cliImo.cliente cli " + "inner join cliImo.imovel imo " + "inner join cli.clienteTipo cltp "
							+ "where imo.id = :idImovel AND " + "crt.id = :idResponsavel AND " + "cltp.esferaPoder.id = :esferaPoder AND "
							+ "cliImo.dataFimRelacao is null ";
			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setInteger("idResponsavel", ClienteRelacaoTipo.RESPONSAVEL).setInteger("esferaPoder", EsferaPoder.FEDERAL)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0351 - Calcular Impostos Deduzidos da Conta] Author: Fernanda Paiva
	 * Data: 22/09/2006
	 * 
	 * @param idImpostoTipo
	 *            Id do ImpostoTipo
	 * @param anoMesReferencia
	 *            Ano Mês de Referência
	 * @return aliquotas do imposto
	 */
	public ImpostoTipoAliquota pesquisarAliquotaImposto(Integer idImpostoTipo, Integer anoMesReferencia) throws ErroRepositorioException{

		ImpostoTipoAliquota retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select itpa from ImpostoTipoAliquota itpa " + "where itpa.impostoTipo.id = :idImpostoTipo AND "
							+ "(itpa.anoMesReferencia = :anoMesReferencia OR " + "itpa.anoMesReferencia < :anoMesReferencia) "
							+ " order by itpa.anoMesReferencia ";
			retorno = (ImpostoTipoAliquota) session.createQuery(consulta).setInteger("idImpostoTipo", idImpostoTipo)
							.setInteger("anoMesReferencia", anoMesReferencia).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Fernanda Paiva Data: 25/09/2006
	 * 
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public void removerClientesConta(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection<ClienteConta> clienteConta = new ArrayList();

		try{
			clienteConta = session.createQuery("FROM gcom.cadastro.cliente.ClienteConta clct WHERE clct.conta = :idConta")
							.setInteger("idConta", idConta).list();

			Iterator iterator = clienteConta.iterator();

			while(iterator.hasNext()){
				session.delete(iterator.next());
				// iterator.remove();

			}

			session.flush();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0150] - Retificar Conta Author: Fernanda Paiva Data: 25/09/2006
	 * 
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public void removerImpostosDeduzidosConta(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection<ContaImpostosDeduzidos> contaImpostosDeduzidos = new ArrayList();

		try{
			contaImpostosDeduzidos = session
							.createQuery("FROM gcom.faturamento.conta.ContaImpostosDeduzidos clid WHERE clid.conta = :idConta")
							.setInteger("idConta", idConta).list();

			Iterator iterator = contaImpostosDeduzidos.iterator();

			while(iterator.hasNext()){
				session.delete(iterator.next());
				// iterator.remove();

			}

			session.flush();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * Atualiza a data e hora da realização da atividade.
	 * 
	 * @author Pedro Alexandre
	 * @date 27/09/2006
	 * @param idAtividade
	 * @param anoMesReferencia
	 * @param idFaturamentoGrupo
	 * @throws ErroRepositorioException
	 */
	public void atualizarDataHoraRealizacaoAtividade(Integer idAtividade, Integer anoMesReferencia, Integer idFaturamentoGrupo)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String atualizar;

		try{

			atualizar = "update FaturamentoAtividadeCronograma ftcr "
							+ "set ftcr.dataRealizacao = :dataRealizacao, ftcr.ultimaAlteracao = :dataUltimaAlteracao "
							+ "where ftcr.faturamentoAtividade.id = :idAtividade and ftcr.faturamentoGrupoCronogramaMensal.id in "
							+ "(select fgcm.id from FaturamentoGrupoCronogramaMensal fgcm "
							// + "inner join fgcm.faturamentoGrupo fagr "
							+ "where fgcm.anoMesReferencia = :anoMesReferencia and fgcm.faturamentoGrupo.id = :idFaturamentoGrupo)";

			session.createQuery(atualizar).setTimestamp("dataRealizacao", new Date()).setTimestamp("dataUltimaAlteracao", new Date())
							.setInteger("idAtividade", idAtividade).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * Atualiza o ano/mês de referência do faturamento para o mês seguinte.
	 * 
	 * @author Pedro Alexandre
	 * @date 27/09/2006
	 * @param idFaturamentoGrupo
	 * @param anoMesReferencia
	 * @throws ErroRepositorioException
	 */
	public void atualizarAnoMesReferenciaFaturamentoGrupo(Integer idFaturamentoGrupo, Integer anoMesReferencia)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String atualizar;

		try{
			Integer anoMesReferenciaAtualizado = Util.somaUmMesAnoMesReferencia(anoMesReferencia);

			atualizar = "update FaturamentoGrupo fagr "
							+ "set fagr.anoMesReferencia = :anoMesReferencia ,fagr.ultimaAlteracao = :dataUltimaAlteracao "
							+ "where fagr.id = :idFaturamentoGrupo ";

			session.createQuery(atualizar).setTimestamp("dataUltimaAlteracao", new Date())
							.setInteger("anoMesReferencia", anoMesReferenciaAtualizado)
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			HibernateUtil.closeSession(session);

		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Verifica se todos os grupos já foram faturados
	 * 
	 * @author Pedro Alexandre
	 * @date 07/10/2006
	 * @param anoMesReferenciaFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarFaturamentoGrupoNaoFaturados(Integer anoMesReferenciaFaturamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "from FaturamentoGrupo fatGrupo " + "where fatGrupo.anoMesReferencia <= :anoMesReferenciaFaturamento ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaFaturamento", anoMesReferenciaFaturamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Permite inserir DebitoACobrarGeral contidos numa coleção [UC0394] Gerar
	 * Débitos a Cobrar de Doações
	 * 
	 * @author César Araújo
	 * @date 05/08/2006
	 * @param Collection
	 *            <DebitoACobrarGeral> colecaoDebitosACobrarGeral - Coleção de
	 *            DebitoACobrarGeral
	 * @throws ErroRepositorioException
	 */
	public Integer inserirDebitoACobrarGeral(DebitoACobrarGeral debitoACobrarGeral) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = null;

		try{
			retorno = (Integer) session.save(debitoACobrarGeral);
			session.flush();
			session.clear();
		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Permite inserir DebitoACobrar contidos numa coleção [UC0394] Gerar
	 * Débitos a Cobrar de Doações
	 * 
	 * @author César Araújo
	 * @date 05/08/2006
	 * @param Collection
	 *            <DebitoACobrarGeral> colecaoDebitosACobrarGeral - Coleção de
	 *            DebitoACobrarGeral
	 * @throws ErroRepositorioException
	 */
	public void inserirDebitoACobrar(DebitoACobrar debitoACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			session.save(debitoACobrar);
			session.flush();
			session.clear();
		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês - Item 05
	 * Atualiza a situação de imóvel com cobrança finalizada
	 * 
	 * @author Pedro Alexandre
	 * @date 07/10/2006
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarImoveisSituacaoEspecialCobrancaFinalizada(int anoMesFaturamento, Integer idSetorComercial)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarSituacaoCobrancaImovel;
		String atualizarAnoMesCobrancaRetirada;

		try{
			// Atualiza situação de cobrança do imóvel *******
			atualizarSituacaoCobrancaImovel = "update Imovel imov " + "set imov.cobrancaSituacaoTipo.id = null "
							+ "where imov.setorComercial = :idSetorComercial and imov.cobrancaSituacaoTipo.id is not null "
							+ "and imov.id in " + "(select distinct (cbsh.imovel.id) " + "from CobrancaSituacaoHistorico cbsh "
							+ "where cbsh.anoMesCobrancaSituacaoFim <= :anoMesFaturamento and cbsh.anoMesCobrancaRetirada is null" + ")";

			session.createQuery(atualizarSituacaoCobrancaImovel).setInteger("idSetorComercial", idSetorComercial)
							.setInteger("anoMesFaturamento", anoMesFaturamento).executeUpdate();
			// ***************************************************

			// Atualizar o ano/mês de cobrança retirada *******
			atualizarAnoMesCobrancaRetirada = "update CobrancaSituacaoHistorico "
							+ "set anoMesCobrancaRetirada = :anoMesFaturamento "
							+ "where anoMesCobrancaSituacaoFim <= :anoMesFaturamento "
							+ "and anoMesCobrancaRetirada is null and imovel in (select imovel.id from Imovel imovel where imovel.setorComercial =:idSetorComercial)";

			session.createQuery(atualizarAnoMesCobrancaRetirada).setInteger("idSetorComercial", idSetorComercial)
							.setInteger("anoMesFaturamento", anoMesFaturamento).executeUpdate();
			// *****************************************************

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os débitos cobrados por categoria
	 * 
	 * @author Pedro Alexandre
	 * @date 09/10/2006
	 * @param idDebitoCobrado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoCobradoCategoria(Integer idDebitoCobrado) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "from DebitoCobradoCategoria dccg " + "where dccg.debitoCobrado.id = :idDebitoCobrado ";

			retorno = session.createQuery(consulta).setInteger("idDebitoCobrado", idDebitoCobrado).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os débitos cobrados por categoria
	 * 
	 * @author Vitor Hora
	 * @date 21/08/2008
	 * @param idDebitoCobrado
	 * @return
	 * @throws ErroRepositorioException
	 *             [CR21755] inclída checagem se a consulta retornou vazia
	 * @author: Andre Nishimura
	 * @date 19/05/2009
	 */
	public Collection pesquisarDebitoCobradoCategoriaHistorico(Integer idDebitoCobrado) throws ErroRepositorioException{

		Collection retorno = null;
		Collection collRetorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select DBHI_ID, CATG_ID, DCCH_QTECONOMIA, DCCH_VLCATEGORIA, DCCH_TMULTIMAALTERACAO from debito_cobrado_categoria_hist where dbhi_id = "
							+ idDebitoCobrado;

			collRetorno = session.createSQLQuery(consulta).addScalar("DBHI_ID", Hibernate.INTEGER).addScalar("CATG_ID", Hibernate.INTEGER)
							.addScalar("DCCH_QTECONOMIA", Hibernate.INTEGER).addScalar("DCCH_VLCATEGORIA", Hibernate.BIG_DECIMAL)
							.addScalar("DCCH_TMULTIMAALTERACAO", Hibernate.TIMESTAMP).list();

			retorno = new ArrayList<DebitoCobradoCategoriaHistorico>();
			Iterator it = collRetorno.iterator();
			while(it.hasNext()){

				DebitoCobradoCategoriaHistorico dcch = new DebitoCobradoCategoriaHistorico();

				Object[] retornoArray = (Object[]) it.next();

				DebitoCobradoHistorico dch = new DebitoCobradoHistorico();
				dch.setId((Integer) retornoArray[0]);
				dcch.setDebitoCobradoHistorico(dch);

				Categoria cat = new Categoria();
				cat.setId((Integer) retornoArray[1]);
				dcch.setCategoria(cat);

				DebitoCobradoCategoriaHistoricoPK comp_id = new DebitoCobradoCategoriaHistoricoPK(dch, cat);
				dcch.setComp_id(comp_id);

				dcch.setQuantidadeEconomia((Integer) retornoArray[2]);
				dcch.setValorCategoria((BigDecimal) retornoArray[3]);
				dcch.setUltimaAlteracao((Date) retornoArray[4]);

				retorno.add(dcch);
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os débitos cobrados por categoria
	 * 
	 * @author Vitor Hora
	 * @date 21/08/2008
	 * @param idDebitoCobrado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarCategoriaHistorico(Integer idDebitoACobrar) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "from DebitoACobrarCategoriaHistorico debitoACobrarCategoriaHistorico "
							+ "where debitoACobrarCategoriaHistorico.debitoACobrarHistorico.id = :idDebitoACobrar ";

			retorno = session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).list();

			for(DebitoACobrarCategoriaHistorico debitoACobrarCategoriaHistorico : (Collection<DebitoACobrarCategoriaHistorico>) retorno){
				Hibernate.initialize(debitoACobrarCategoriaHistorico.getDebitoACobrarHistorico());
				Hibernate.initialize(debitoACobrarCategoriaHistorico.getComp_id());
				Hibernate.initialize(debitoACobrarCategoriaHistorico.getCategoria());
			}



		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os credios realizados por categoria
	 * 
	 * @author Pedro Alexandre
	 * @date 09/10/2006
	 * @param idCreditoRealizado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditoRealizadoCategoria(Integer idCreditoRealizado) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "from CreditoRealizadoCategoria crcg " + "where crcg.creditoRealizado.id = :idCreditoRealizado ";

			retorno = session.createQuery(consulta).setInteger("idCreditoRealizado", idCreditoRealizado).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os credios realizados por categoria
	 * 
	 * @author Vitor Hora
	 * @date 21/08/2008
	 * @param idCreditoRealizado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditoRealizadoCategoriaHistorico(Integer idCreditoRealizado) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "from CreditoRealizadoCategoriaHistorico crcg " + "where crcg.creditoRealizadoHistorico.id = :idCreditoRealizado ";

			retorno = session.createQuery(consulta).setInteger("idCreditoRealizado", idCreditoRealizado).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os débitos a cobrar por categoria.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/10/2006
	 * @param debitoACobrar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarCategoriaHistorico(DebitoACobrar debitoACobrar) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select dacc " + "from DebitoACobrarCategoriaHistorico dacc "
							+ "where dacc.debitoACobrarHistorico.id = :idDebitoACobrar";

			retorno = session.createQuery(consulta).setInteger("idDebitoACobrar", debitoACobrar.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os créditos a realizar por categoria.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/10/2006
	 * @param creditoARealizar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizarCategoria(CreditoARealizar creditoARealizar) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select cacg from " + "CreditoARealizarCategoria cacg " + "where cacg.creditoARealizar.id = :idCreditoARealizar";

			retorno = session.createQuery(consulta).setInteger("idCreditoARealizar", creditoARealizar.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os créditos a realizar por categoria historico.
	 * 
	 * @author Vitor Hora
	 * @date 02/09/2008
	 * @param creditoARealizar
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizarCategoriaHistorico(CreditoARealizarHistorico creditoARealizar)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select cacg " + "from " + "CreditoARealizarCategoria cacg "
							+ "where cacg.creditoARealizar.id = :idCreditoARealizar";

			retorno = session.createQuery(consulta).setInteger("idCreditoARealizar", creditoARealizar.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os impostos deduzidos da conta.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/10/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaImpostosDeduzidos(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select cnid from " + "ContaImpostosDeduzidos cnid " + " inner join fetch cnid.impostoTipo "
							+ " where cnid.conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os impostos deduzidos da conta.
	 * 
	 * @author Vitor Hora
	 * @date 21/08/2008
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaImpostosDeduzidosHistorico(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select cnid from " + "ContaImpostosDeduzidosHistorico cnid " + "where cnid.contaHistorico.id = :idConta";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa as conta categoria consumo de faixa.
	 * 
	 * @author Pedro Alexandre
	 * @date 10/10/2005
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaConsumoFaixa(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaCategoriaConsumoFaixa " + "from ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa "
							+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.conta conta " + "where conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa as conta categoria consumo de faixa.
	 * 
	 * @author Vitor Hora
	 * @date 21/08/2008
	 * @author Yara Souza
	 * @date 30/06/2010
	 *       Carregar id's contaHistorico,categoria,subcategoria.
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaConsumoFaixaHistorico(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaCategoriaConsumoFaixaHistorico "
							+ "from ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistorico "
							+ "inner join fetch contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.contaHistorico contaHistorico "
							+ "where contaHistorico.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * [UC0150] Retificar Conta
	 * [UC0147] Cancelar Conta
	 * Para cada conta transferida para o histórico, atualiza o indicador de que
	 * a conta está no histórico na tabela ContaGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * @param idsContas
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorContaNoHistorico(Collection idsContas) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarContaGeral;

		try{
			Object obj = null;

			if(idsContas != null && idsContas.size() > 0){
				obj = idsContas.iterator().next();
			}
			if(obj instanceof Integer){
				atualizarContaGeral = "update ContaGeral cntg "
								+ "set cntg.indicadorHistorico = :indicadorHistorico, cntg.ultimaAlteracao= :dataUltimaAlteracao where cntg.id in (:idsContas)";

				session.createQuery(atualizarContaGeral).setInteger("indicadorHistorico", ConstantesSistema.SIM)
								.setTimestamp("dataUltimaAlteracao", new Date()).setParameterList("idsContas", idsContas).executeUpdate();

			}else {
				throw new ErroRepositorioException(
								"Parametro de identificação da Conta Geral inválido (atualizarIndicadorContaNoHistorico)");
			}
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Para cada débito a cobrar transferido para o histórico, atualiza o
	 * indicador de que o débito a cobrar está no histórico na tabela
	 * DebitoACobrarGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * @param idsDebitosACobrar
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorDebitoACobrarNoHistorico(Collection idsDebitosACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarDebitoACobrarGeral;

		try{

			Object obj = null;
			if(idsDebitosACobrar != null && idsDebitosACobrar.size() > 0){
				obj = idsDebitosACobrar.iterator().next();
				if(obj instanceof DebitoACobrar){
					atualizarDebitoACobrarGeral = "update DebitoACobrarGeral dage "
									+ "set dage.indicadorHistorico = :indicadorHistorico, dage.ultimaAlteracao = :dataUltimaAlteracao where dage.id in ( "
									+ "select debitoACobrar.id from DebitoACobrar debitoACobrar where debitoACobrar in (:idsDebitosACobrar)"
									+ ")";

					session.createQuery(atualizarDebitoACobrarGeral).setInteger("indicadorHistorico", ConstantesSistema.SIM)
									.setDate("dataUltimaAlteracao", new Date()).setParameterList("idsDebitosACobrar", idsDebitosACobrar)
									.executeUpdate();

				}else if(obj instanceof DebitoACobrarHistorico){

					atualizarDebitoACobrarGeral = "update DebitoACobrarGeral dage "
									+ "set dage.indicadorHistorico = :indicadorHistorico, dage.ultimaAlteracao = :dataUltimaAlteracao where dage.id in ( "
									+ "select debitoACobrar.id from DebitoACobrarHistorico debitoACobrar where debitoACobrar in (:idsDebitosACobrar)"
									+ ")";

					session.createQuery(atualizarDebitoACobrarGeral).setInteger("indicadorHistorico", ConstantesSistema.SIM)
									.setDate("dataUltimaAlteracao", new Date()).setParameterList("idsDebitosACobrar", idsDebitosACobrar)
									.executeUpdate();

				}
			}
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Para cada crédito a realizar transferido para o histórico, atualiza o
	 * indicador de que o crédito a realizar está no histórico na tabela
	 * CreditoARealizarGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * @param idsCreditoARealizar
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorCreditoARealizarNoHistorico(Collection idsCreditoARealizar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarCreditoARealizarGeral;

		try{
			atualizarCreditoARealizarGeral = "update CreditoARealizarGeral cage "
							+ "set cage.indicadorHistorico = :indicadorHistorico, cage.ultimaAlteracao = :dataUltimaAlteracao where cage.id in (:idsCreditoARealizar)";

			session.createQuery(atualizarCreditoARealizarGeral).setInteger("indicadorHistorico", ConstantesSistema.SIM)
							.setDate("dataUltimaAlteracao", new Date()).setParameterList("idsCreditoARealizar", idsCreditoARealizar)
							.executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os relacionamentos entre cliente e conta.
	 * 
	 * @author Pedro Alexandre
	 * @date 13/10/2005
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteConta(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select clienteConta " + "from ClienteConta clienteConta " + "inner join clienteConta.conta conta "
							+ "where conta.id = :idConta order by clienteConta.indicadorNomeConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa os relacionamentos entre cliente e conta.
	 * 
	 * @author Vitor Hora
	 * @date 21/08/2008
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteContaHistorico(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select clienteContaHistorico " + "from ClienteContaHistorico clienteContaHistorico "
							+ "inner join fetch clienteContaHistorico.contaHistorico contaHistorico "
							+ "where contaHistorico.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void inserirDebitoAutomaticoMovimento(DebitoAutomaticoMovimento debitoAutomaticoMovimento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			session.save(debitoAutomaticoMovimento);
			session.flush();
			session.clear();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Raphael Rossiter
	 * @date 30/10/2006
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaRetificacao(Integer idConta) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT "
							+ "cnt.id, " // 0
							+ "cnt.dataVencimentoConta, " // 1
							+ "cnt.referencia, " // 2
							+ "cnt.referenciaContabil, " // 3
							+ "cnt.consumoAgua, " // 4
							+ "cnt.consumoEsgoto, " // 5
							+ "cnt.valorAgua, " // 6
							+ "cnt.valorEsgoto, " // 7
							+ "cnt.debitos, " // 8
							+ "cnt.valorCreditos, " // 9
							+ "cnt.valorImposto, " // 10
							+ "cnt.dataValidadeConta, " // 11
							+ "cnt.lote, " // 12
							+ "cnt.subLote, " // 13
							+ "debitoCreditoSituacaoAtual.id, " // 14
							+ "localidadeConta.id, " // 15
							+ "quadraConta.id, " // 16
							+ "quadraConta.numeroQuadra, " // 17
							+ "setorComercialConta.id, " // 18
							+ "setorComercialConta.codigo, " // 19
							+ "cnt.indicadorCobrancaMulta, " // 20
							+ "consumoTarifa.id, " // 21
							+ "imovelPerfilConta.id, " // 22
							+ "ligacaoAguaSituacaoConta.id, " // 23
							+ "ligacaoEsgotoSituacaoConta.id, " // 24
							+ "imovel.id, " // 25
							+ "imovelPerfilImovel.id, " // 26
							+ "localidadeImovel.id, " // 27
							+ "quadraImovel.id, " // 28
							+ "quadraImovel.numeroQuadra, " // 29
							+ "setorComercialImovel.id, " // 30
							+ "setorComercialImovel.codigo, " // 31
							+ "ligacaoAguaSituacaoImovel.id, " // 32
							+ "ligacaoAguaSituacaoImovel.descricao, " // 33
							+ "ligacaoEsgotoSituacaoImovel.id, " // 34
							+ "ligacaoEsgotoSituacaoImovel.descricao, " // 35
							+ "consumoTarifaImovel.id, " // 36
							+ "cnt.dataVencimentoOriginal, " // 37
							+ "cnt.percentualEsgoto, " // 38
							+ "imovel.indicadorDebitoConta, " // 39
							+ "cnt.creditoConsumo, " // 40
							+ "cnt.dataInclusao, " // 41
							+ "debitoCreditoSituacaoAtual.descricaoDebitoCreditoSituacao, " // 42
							+ "contaMotivoRetificacao.id, " // 43
							+ "cnt.indicadorAlteracaoVencimento, " // 44
							+ "cnt.dataRetificacao, " // 45
							+ "cnt.dataEmissao, " // 46
							+ "ligacaoEsgotoSituacaoConta.indicadorFaturamentoSituacao, " // 47
							+ "rotaImovel.id, " // 48
							+ "ftgr.id, " // 49
							+ "cnt.indicadorPagamento, " // 50
							+ "cnt.indicadorCobrancaAdministrativa, " // 51
							+ "cnt.indicadorRemuneraCobrancaAdministrativa, " // 52
							+ "contaMotivoRevi.id, " // 53
							+ "ftgr.anoMesReferencia, " // 54
							+ "cnt.consumoPoco " // 55
							+ "FROM Conta cnt " + "INNER JOIN cnt.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
							+ "INNER JOIN cnt.localidade localidadeConta " + "INNER JOIN cnt.quadraConta quadraConta "
							+ "INNER JOIN quadraConta.setorComercial setorComercialConta " + "INNER JOIN cnt.consumoTarifa consumoTarifa "
							+ "LEFT JOIN cnt.imovelPerfil imovelPerfilConta "
							+ "INNER JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacaoConta "
							+ "LEFT JOIN cnt.contaMotivoRetificacao contaMotivoRetificacao "
							+ "INNER JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacaoConta " + "INNER JOIN cnt.imovel imovel "
							+ "INNER JOIN imovel.imovelPerfil imovelPerfilImovel " + "INNER JOIN imovel.localidade localidadeImovel "
							+ "INNER JOIN imovel.setorComercial setorComercialImovel " + "INNER JOIN imovel.quadra quadraImovel "
							+ "INNER JOIN imovel.ligacaoAguaSituacao ligacaoAguaSituacaoImovel "
							+ "INNER JOIN imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacaoImovel " + "LEFT JOIN imovel.rota rotaImovel "
							+ "LEFT JOIN rotaImovel.faturamentoGrupo ftgr " + "INNER JOIN imovel.consumoTarifa consumoTarifaImovel "
							+ "LEFT JOIN cnt.contaMotivoRevisao contaMotivoRevi " + "WHERE  cnt.id = :idConta ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idConta", idConta.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona as contas agrupando por imóvel
	 * [UC0485] - Gerar Resumo dos Devedores Duvidosos
	 * 
	 * @author Rafael Pinto, Pedro Alexandre
	 * @date 22/11/2006, 21/07/2007
	 * @param anoMesReferenciaContabil
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> obterContaAgrupadasPorImovel(int anoMesReferenciaContabil, int idLocalidade, int idQuadra)
					throws ErroRepositorioException{

		Collection<Object[]> retornoConsulta = null;
		Collection<Conta> retorno = null;

		StatelessSession session = HibernateUtil.getStatelessSession();
		String consulta;

		try{
			consulta = "select " + "cnta.cnta_id as col_0, " + "cnta.cnta_amreferenciaconta as col_1, "
							+ "cnta.cnta_dtvencimentoconta as col_2, " + "cnta.cnta_vlagua as col_3, " + "cnta.cnta_vlesgoto as col_4, "
							+ "cnta.cnta_vldebitos as col_5, " + "cnta.cnta_vlcreditos as col_6, " + "cnta.cnta_vlimpostos as col_7, "
							+ "cnta.cnta_nnconsumoagua as col_8, " + "cnta.cnta_nnconsumoesgoto as col_9, "
							+ "cnta.cnta_dtvalidadeconta as col_10, " + "cnta.cnta_dtrevisao as col_11, "
							+ "cnta.cnta_amreferenciacontabil as col_12, " + "imov.imov_id as col_13, " + "imov.cbst_id as col_14, "
							+ "cnta.cnta_amreferenciabaixacontabil as col_15 " + "from " + "conta cnta "
							+ "inner join imovel imov on cnta.imov_id=imov.imov_id and imov.loca_id = :idLocalidade "
							+ "where cnta.cnta_id in (select " + "distinct (cnta.cnta_id) " + "from " + "conta_categoria ctcg "
							+ "inner join conta cnta on ctcg.catg_id<> :idCategoria and ctcg.cnta_id=cnta.cnta_id "
							+ "inner join imovel imov on cnta.imov_id=imov.imov_id and imov.loca_id = :idLocalidade "
							+ "where cnta.loca_id=:idLocalidade and cnta.qdra_id = :idQuadra "
							+ "and cnta.dcst_idatual in ( :normal , :incluida , :retificada) "
							+ "and cnta.cnta_amreferenciaconta< :anoMesReferencia)";

			retornoConsulta = session.createSQLQuery(consulta).addScalar("col_0", Hibernate.INTEGER).addScalar("col_1", Hibernate.INTEGER)
							.addScalar("col_2", Hibernate.DATE).addScalar("col_3", Hibernate.BIG_DECIMAL)
							.addScalar("col_4", Hibernate.BIG_DECIMAL).addScalar("col_5", Hibernate.BIG_DECIMAL)
							.addScalar("col_6", Hibernate.BIG_DECIMAL).addScalar("col_7", Hibernate.BIG_DECIMAL)
							.addScalar("col_8", Hibernate.INTEGER).addScalar("col_9", Hibernate.INTEGER)
							.addScalar("col_10", Hibernate.DATE).addScalar("col_11", Hibernate.DATE).addScalar("col_12", Hibernate.INTEGER)
							.addScalar("col_13", Hibernate.INTEGER).addScalar("col_14", Hibernate.INTEGER)
							.addScalar("col_15", Hibernate.INTEGER).setInteger("idCategoria", Categoria.PUBLICO)
							.setInteger("idLocalidade", idLocalidade).setInteger("idQuadra", idQuadra)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL).setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
							.setInteger("anoMesReferencia", anoMesReferenciaContabil)
							// .setFirstResult(numeroPagina)
							// .setMaxResults(25000)
							.list();

			if(retornoConsulta.size() > 0){

				retorno = new ArrayList();

				Conta conta = null;
				Imovel imovel = null;

				for(Iterator iter = retornoConsulta.iterator(); iter.hasNext();){

					Object[] element = (Object[]) iter.next();

					Integer idImovel = (Integer) element[13];

					conta = new Conta();
					conta.setId((Integer) element[0]);
					conta.setReferencia((Integer) element[1]);
					conta.setDataVencimentoConta((Date) element[2]);
					conta.setValorAgua((BigDecimal) element[3]);
					conta.setValorEsgoto((BigDecimal) element[4]);
					conta.setDebitos((BigDecimal) element[5]);
					conta.setValorCreditos((BigDecimal) element[6]);
					// conta.setValorImposto((BigDecimal) element[7]);
					conta.setConsumoAgua((Integer) element[8]);
					conta.setConsumoEsgoto((Integer) element[9]);
					conta.setDataValidadeConta((Date) element[10]);
					conta.setDataRevisao((Date) element[11]);
					conta.setReferenciaContabil((Integer) element[12]);
					conta.setReferenciaBaixaContabil((Integer) element[15]);

					CobrancaSituacao cobrancaSituacao = null;
					if(element[14] != null){
						cobrancaSituacao = new CobrancaSituacao();
						cobrancaSituacao.setId((Integer) element[14]);
					}

					imovel = new Imovel();
					imovel.setId(idImovel);
					imovel.setCobrancaSituacao(cobrancaSituacao);
					conta.setImovel(imovel);

					retorno.add(conta);
					element = null;
				}
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Utilizado pelo [UC0] Manter Conta
	 * 
	 * @author Rafael Santos
	 * @date 23/11/2006
	 * @param idConta
	 * @param dataUltimaAlteracao
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Object pesquisarDataUltimaAlteracaoConta(Integer idConta) throws ErroRepositorioException{

		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT conta.ultimaAlteracao " + "FROM Conta conta " + "WHERE conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * [SB0004] - Calcular Valor de Água e/ou Esgoto
	 * 
	 * @author Sávio Luiz
	 * @date 04/12/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */
	public Object[] pesquisarParmsFaturamentoGrupo(Integer idImovel) throws ErroRepositorioException{

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT fatGrupo.id, fatGrupo.anoMesReferencia " + "FROM Imovel imov " + "INNER JOIN imov.quadra qdr "
							+ "INNER JOIN qdr.rota rota " + "INNER JOIN rota.faturamentoGrupo fatGrupo " + "WHERE imov.id = :idImovel ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * [SB0004] - Calcular Valor de Água e/ou Esgoto
	 * 
	 * @author Sávio Luiz
	 * @date 04/12/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Date pesquisarDataRealizacaoFaturamentoAtividadeCronograma(Integer idFaturamentoGrupo, Integer idFaturamentoAtividade,
					Integer amReferencia) throws ErroRepositorioException{

		Date retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT ftac.dataRealizacao " + "FROM FaturamentoAtividadeCronograma ftac "
							+ "LEFT JOIN ftac.faturamentoAtividade ftat " + "LEFT JOIN ftac.faturamentoGrupoCronogramaMensal ftcm "
							+ "LEFT JOIN ftcm.faturamentoGrupo ftgr " + "WHERE ftat.id = :idFaturamentoAtividade AND "
							+ "ftgr.id = :idFaturamentoGrupo AND " + "ftcm.anoMesReferencia = :amReferencia ";

			retorno = (Date) session.createQuery(consulta).setInteger("idFaturamentoAtividade", idFaturamentoAtividade)
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo).setInteger("amReferencia", amReferencia).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Inserir Pagamentos
	 * Pesquisa a conta digitada
	 * 
	 * @author Rafael Corrêa
	 * @date 07/12/2006
	 * @param idImovel
	 * @param referenciaConta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */

	public Object[] pesquisarContaDigitada(String idImovel, String referenciaConta) throws ErroRepositorioException{

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = " SELECT conta.id, conta.referencia, conta.valorAgua, "
							+ " conta.valorEsgoto, conta.debitos, conta.valorCreditos,conta.valorImposto " + " FROM Conta conta "
							+ " INNER JOIN conta.imovel imov " + " INNER JOIN conta.debitoCreditoSituacaoAtual dcsa "
							+ " WHERE imov.id = :idImovel and " + " conta.referencia = " + referenciaConta + " and ( dcsa.id = "
							+ DebitoCreditoSituacao.NORMAL + " or dcsa.id = " + DebitoCreditoSituacao.RETIFICADA + " or dcsa.id = "
							+ DebitoCreditoSituacao.INCLUIDA + ")";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel)).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 12/12/2006
	 * 
	 * @param idImovel
	 *            Id do Imóvel
	 * @return cliente responsavel
	 */
	public Object pesquisarClienteResponsavel(Integer idImovel) throws ErroRepositorioException{

		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select cli.id from ClienteImovel cliImo " + "inner join cliImo.clienteRelacaoTipo crt "
							+ "inner join cliImo.cliente cli " + "inner join cliImo.imovel imo " + "where imo.id = :idImovel AND "
							+ "crt.id = :idResponsavel AND " + "cliImo.dataFimRelacao is null ";
			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setInteger("idResponsavel", ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 27/12/2006
	 * Pesquisar o Resumo Faturamento Simulação
	 */
	public ResumoFaturamentoSimulacao pesquisarResumoFaturamentoSimulacao(ResumoFaturamentoSimulacao resumoFaturamentoSimulacao)
					throws ErroRepositorioException{

		ResumoFaturamentoSimulacao retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select resumoFaturamentoSimulacao from ResumoFaturamentoSimulacao resumoFaturamentoSimulacao " + "where "
							+ "resumoFaturamentoSimulacao.faturamentoGrupo.id = :idFaturamentoGrupo and "
							+ "resumoFaturamentoSimulacao.localidade.id = :idLocalidade and "
							+ "resumoFaturamentoSimulacao.quadra.id = :idQuadra and "
							+ "resumoFaturamentoSimulacao.ligacaoAguaSituacao.id = :idLigacaoAguaSituacao and "
							+ "resumoFaturamentoSimulacao.ligacaoEsgotoSituacao.id = :idLigacaoEsgotoSituacao and "
							+ "resumoFaturamentoSimulacao.categoria.id = :idCategoria and "
							+ "resumoFaturamentoSimulacao.imovelPerfil.id = :idImovelPerfil and ";

			if(resumoFaturamentoSimulacao.getAnoMesReferencia() != null){
				consulta = consulta + " resumoFaturamentoSimulacao.anoMesReferencia = :anoMesReferencia and ";
			}

			if(resumoFaturamentoSimulacao.getIndicadorDebitoConta() != null){
				consulta = consulta + " resumoFaturamentoSimulacao.indicadorDebitoConta = :indicadorDebitoConta and ";
			}

			if(resumoFaturamentoSimulacao.getGerenciaRegional() != null){
				consulta = consulta + " resumoFaturamentoSimulacao.gerenciaRegional.id = :idGerenciaRegional and ";
			}

			if(resumoFaturamentoSimulacao.getSetorComercial() != null){
				consulta = consulta + " resumoFaturamentoSimulacao.setorComercial.id = :idSetorComercial and ";
			}

			if(resumoFaturamentoSimulacao.getRota() != null){
				consulta = consulta + " resumoFaturamentoSimulacao.rota.id = :idRota and ";
			}

			if(resumoFaturamentoSimulacao.getEsferaPoder() != null){
				consulta = consulta + " resumoFaturamentoSimulacao.esferaPoder.id = :idEsferaPoder ";
			}else{
				consulta = consulta + " resumoFaturamentoSimulacao.esferaPoder.id is null ";
			}

			Query query = session.createQuery(consulta);

			query.setInteger("idFaturamentoGrupo", resumoFaturamentoSimulacao.getFaturamentoGrupo().getId().intValue())
							.setInteger("idLocalidade", resumoFaturamentoSimulacao.getLocalidade().getId().intValue())
							.setInteger("idQuadra", resumoFaturamentoSimulacao.getQuadra().getId().intValue())
							.setInteger("idLigacaoAguaSituacao", resumoFaturamentoSimulacao.getLigacaoAguaSituacao().getId().intValue())
							.setInteger("idLigacaoEsgotoSituacao", resumoFaturamentoSimulacao.getLigacaoEsgotoSituacao().getId().intValue())
							.setInteger("idCategoria", resumoFaturamentoSimulacao.getCategoria().getId().intValue())
							.setInteger("idImovelPerfil", resumoFaturamentoSimulacao.getImovelPerfil().getId().intValue());

			if(resumoFaturamentoSimulacao.getAnoMesReferencia() != null){
				query.setInteger("anoMesReferencia", resumoFaturamentoSimulacao.getAnoMesReferencia().intValue());
			}

			if(resumoFaturamentoSimulacao.getIndicadorDebitoConta() != null){
				query.setInteger("indicadorDebitoConta", resumoFaturamentoSimulacao.getIndicadorDebitoConta().shortValue());
			}

			if(resumoFaturamentoSimulacao.getGerenciaRegional() != null){
				query.setInteger("idGerenciaRegional", resumoFaturamentoSimulacao.getGerenciaRegional().getId().intValue());
			}

			if(resumoFaturamentoSimulacao.getSetorComercial() != null){
				query.setInteger("idSetorComercial", resumoFaturamentoSimulacao.getSetorComercial().getId().intValue());
			}

			if(resumoFaturamentoSimulacao.getRota() != null){
				query.setInteger("idRota", resumoFaturamentoSimulacao.getRota().getId().intValue());
			}

			if(resumoFaturamentoSimulacao.getEsferaPoder() != null){
				query.setInteger("idEsferaPoder", resumoFaturamentoSimulacao.getEsferaPoder().getId());

			}

			retorno = (ResumoFaturamentoSimulacao) query.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta CONTA_CATEGORIA_CONSUMO_FAIXA
	 */
	public void apagarContaCategoriaConsumoFaixa(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = "delete from conta_categoria_consumo_faixa where cnta_id in "
							+ " (select cnta_id from conta c, quadra q, rota r " + " where c.cnta_amreferenciaconta = ? "
							+ " and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0)";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta CONTA_CATEGORIA
	 */
	public void apagarContaCategoria(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = "delete from conta_categoria where cnta_id in  " + " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta = ? "
							+ " and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id = ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta CONTA_IMPRESSAO
	 */
	public void apagarContaImpressao(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = "delete from conta_impressao where cnta_id in " + " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta = ? "
							+ " and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id = ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta CLIENTE_CONTA
	 */
	public void apagarClienteConta(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = " delete from cliente_conta where cnta_id in " + " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta = ? "
							+ " and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta CONTA_IMPOSTOS_DEDUZIDOS
	 */
	public void apagarContaImpostosDeduzidos(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = "delete from conta_impostos_deduzidos where cnta_id in " + " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta = ? "
							+ "and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id = ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta DEBITO_COBRADO_CATEGORIA
	 */
	public void apagarDebitoCobradoCategoria(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = " delete from debito_cobrado_categoria where dbcb_id in "
							+ " (select d.dbcb_id from debito_cobrado d, conta c, quadra q, rota r "
							+ " where d.cnta_id=c.cnta_id and c.cnta_amreferenciaconta = ? "
							+ " and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id = ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta DEBITO_COBRADO
	 */
	public void apagarDebitoCobrado(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = "delete from debito_cobrado where cnta_id in "
							+ " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta= ? and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta CREDITO_REALIZADO_CATEGORIA
	 */
	public void apagarCreditoRealizadoCategoria(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = "delete from credito_realizado_categoria where crrz_id in "
							+ " (select cr.crrz_id from credito_realizado cr, conta c, quadra q, rota r "
							+ " where cr.cnta_id=c.cnta_id and c.cnta_amreferenciaconta= ? and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta CREDITO_REALIZADO
	 */
	public void apagarCreditoRealizado(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			String delete = "delete from credito_realizado where cnta_id in "
							+ " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta= ? and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Update DEBITO_A_COBRAR
	 */
	public void atualizarDebitoACobrar(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		String atualizar = null;
		try{

			Connection jdbcCon = session.connection();

			atualizar = " update debito_a_cobrar set dbac_nnprestacaocobradas=dbac_nnprestacaocobradas - 1 "
							+ " where dbac_nnprestacaocobradas > 0 and imov_id in "
							+ " (select imov_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta= ? and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0 )";

			st = jdbcCon.prepareStatement(atualizar);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Update CREDITO_A_REALIZAR
	 */
	public void atualizarCreditoARealizar(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		String atualizar = null;
		try{

			Connection jdbcCon = session.connection();

			atualizar = "update credito_a_realizar set crar_nnprestacaorealizadas=crar_nnprestacaorealizadas - 1 "
							+ " where crar_nnprestacaorealizadas > 0 and imov_id in "
							+ " (select imov_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta= ? and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(atualizar);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Update CONTA_GERAL
	 */
	public void atualizarContaGeral(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;
		String atualizar = null;
		try{

			Connection jdbcCon = session.connection();

			atualizar = "update conta_geral set cntg_ichistorico=3 where cnta_id in "
							+ " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta=? and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(atualizar);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Deleta CONTA
	 */
	public void apagarConta(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String atualizar = null;

		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			atualizar = "update pagamento set cnta_id=null where cnta_id in "
							+ " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta= ? and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id= ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(atualizar);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();

			st = null;

			String delete = "delete from conta where cnta_id in "
							+ " (select cnta_id from conta c, quadra q, rota r "
							+ " where c.cnta_amreferenciaconta= ? and c.qdra_id=q.qdra_id and q.rota_id=r.rota_id and r.rota_id = ? and c.dcst_idatual = 0 ) ";

			st = jdbcCon.prepareStatement(delete);
			st.setInt(1, Integer.valueOf(anoMesFaturamento).intValue());
			st.setInt(2, idRota.intValue());

			st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Delete CONTA_GERAL
	 */
	public void apagarContaGeral(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String atualizar = null;

		PreparedStatement st = null;
		try{

			Connection jdbcCon = session.connection();

			atualizar = "update parcelamento_item set cnta_id=null where cnta_id in "
							+ "(select cnta_id from conta_geral where cntg_ichistorico=3) ";

			st = jdbcCon.prepareStatement(atualizar);
			st.executeUpdate();

			// Colocado por Raphael Rossiter em 01/03/2007
			st = null;

			String delete = "delete from cobranca_documento_item where cnta_id in "
							+ " (select cnta_id from conta_geral where cntg_ichistorico=3) ";

			st = jdbcCon.prepareStatement(delete);

			st.executeUpdate();

			// =========================================================================================

			st = null;

			delete = "delete from conta_geral where cntg_ichistorico=3 ";

			st = jdbcCon.prepareStatement(delete);

			st.executeUpdate();

		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * UC0113 - Faturar Grupo Faturamento Author: Rafael Santos Data: 02/01/2007
	 * Saber a quantidade de contas da rota
	 */
	public Integer quantidadeContasRota(String anoMesFaturamento, Integer idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String consulta = null;

		Integer retorno = null;

		try{
			consulta = " select count(conta.id) from Conta conta " + " left join conta.rota rota "
							+ " where rota.id = :idRota and conta.referencia = :anoMesFaturamento ";

			retorno = ((Number) session.createQuery(consulta)
							.setInteger("anoMesFaturamento", Integer.valueOf(anoMesFaturamento).intValue())
							.setInteger("idRota", idRota.intValue()).uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Collection pesquisarConsumoTarifaCategoriaPorSubCategoria(ConsumoTarifaVigencia consumoTarifaVigencia, Categoria categoria,
					Subcategoria subCategoria) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ctc from ConsumoTarifaCategoria ctc " + "where ctc.consumoTarifaVigencia.id = :idConsumoTarifaVigencia "
							+ "and ctc.categoria.id = :idCategoria " + "and ctc.subCategoria.id = :idSubCategoria ";

			retorno = session.createQuery(consulta).setInteger("idConsumoTarifaVigencia", consumoTarifaVigencia.getId().intValue())
							.setInteger("idCategoria", categoria.getId()).setInteger("idSubCategoria", subCategoria.getId()).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * Deleta as faturas e os items da fatura por cliente responsável e ano/mês
	 * de referência.
	 * 
	 * @author Pedro Alexandre,Sávio Luiz
	 * @date 04/01/2007,19/11/2007
	 * @param idCliente
	 * @param anoMesReferenciaFatura
	 * @throws ErroRepositorioException
	 */
	public void deletarFaturaClienteResponsavel(Integer idCliente, Integer anoMesReferenciaFatura, Integer anoMesReferenciaFaturaAntecipada)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		try{
			String deleteFaturaItem = "delete FaturaItem as fitm " + "where fitm.fatura.id in " + "(select fatu.id " + "from Fatura fatu "
							+ "where ";
			if(anoMesReferenciaFaturaAntecipada != null){
				deleteFaturaItem += "fatu.anoMesReferencia =" + anoMesReferenciaFatura + " AND fatu.anoMesReferencia ="
								+ anoMesReferenciaFaturaAntecipada;
			}else{
				deleteFaturaItem += "fatu.anoMesReferencia =" + anoMesReferenciaFatura;
			}

			deleteFaturaItem += " and fatu.cliente.id =:idCliente)";

			session.createQuery(deleteFaturaItem).setInteger("idCliente", idCliente).executeUpdate();

			String deleteFatura = "delete from Fatura fatu " + "where ";
			if(anoMesReferenciaFaturaAntecipada != null){
				deleteFatura += "fatu.anoMesReferencia =" + anoMesReferenciaFatura + " AND fatu.anoMesReferencia ="
								+ anoMesReferenciaFaturaAntecipada;
			}else{
				deleteFatura += "fatu.anoMesReferencia =" + anoMesReferenciaFatura;
			}

			deleteFatura += " and fatu.cliente.id =:idCliente";

			session.createQuery(deleteFatura).setInteger("idCliente", idCliente).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	public void removerFaturamentoGrupoAtividades(Integer idFaturamentoGrupoMensal, Usuario usuarioLogado) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;
		try{

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_REMOVER_CRONOGRAMA_FATURAMENTO);

			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_REMOVER_CRONOGRAMA_FATURAMENTO,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);
			operacaoEfetuada.setArgumentoValor(idFaturamentoGrupoMensal);




			Connection jdbcCon = session.connection();

			st = null;

			String selectFatRota = "select ftac_id, rota_id from faturamento_ativ_cron_rota "
							+ " where ftac_id in ("
							+ " select distinct(facr.ftac_id)"
							+ " from faturamento_ativ_cron_rota facr"
							// +
							// " inner join faturamento_atividade_cronograma ftac on ftac.ftac_id = facr.ftac_id"
							// +
							// " inner join faturamento_grupo_cronograma_mensal fgcm on fgcm.ftcm_id = ftac.ftcm_id"
							+ " inner join faturamento_atividade_cron ftac on ftac.ftac_id = facr.ftac_id"
							+ " inner join faturamento_grupo_cron_mensal fgcm on fgcm.ftcm_id = ftac.ftcm_id" + " where fgcm.ftcm_id = "
							+ idFaturamentoGrupoMensal + ")";

			st = jdbcCon.prepareStatement(selectFatRota);

			ResultSet resultSet = st.executeQuery();

			while(resultSet.next()){

				FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();
				filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_ID,
								resultSet.getInt("rota_id")));
				filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_ID, resultSet.getInt("ftac_id")));
				FaturamentoAtivCronRota faturamentoAtivCronRota = (FaturamentoAtivCronRota) Util.retonarObjetoDeColecao(RepositorioUtilHBM
								.getInstancia().pesquisar(filtroFaturamentoAtivCronRota, FaturamentoAtivCronRota.class.getName()));

				faturamentoAtivCronRota.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				faturamentoAtivCronRota.setOperacaoEfetuada(operacaoEfetuada);
				registradorOperacao.registrarOperacao(faturamentoAtivCronRota);

				RepositorioUtilHBM.getInstancia().remover(faturamentoAtivCronRota);

			}

			st = null;

			// String deleteFatAti = "delete from faturamento_atividade_cronograma" +
			// " where ftcm_id = " + idFaturamentoGrupoMensal;
			String selectFatAti = "select ftac_id from faturamento_atividade_cron" + " where ftcm_id = " + idFaturamentoGrupoMensal;

			st = jdbcCon.prepareStatement(selectFatAti);

			resultSet = st.executeQuery();

			while(resultSet.next()){
				FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
				filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtividadeCronograma.ID,
								resultSet.getInt("ftac_id")));
				FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
								.retonarObjetoDeColecao(RepositorioUtilHBM.getInstancia().pesquisar(filtroFaturamentoAtividadeCronograma,
												FaturamentoAtividadeCronograma.class.getName()));

				faturamentoAtividadeCronograma.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				faturamentoAtividadeCronograma.setOperacaoEfetuada(operacaoEfetuada);
				registradorOperacao.registrarOperacao(faturamentoAtividadeCronograma);

				RepositorioUtilHBM.getInstancia().remover(faturamentoAtividadeCronograma);
			}

			st = null;

			// String deleteGruMen = "delete from faturamento_grupo_cronograma_mensal" +
			// " where ftcm_id = " + idFaturamentoGrupoMensal;
			// String deleteGruMen = "delete from faturamento_grupo_cron_mensal" +
			// " where ftcm_id = " + idFaturamentoGrupoMensal;

			FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();
			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupoCronogramaMensal.ID,
							idFaturamentoGrupoMensal));
			FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal = (FaturamentoGrupoCronogramaMensal) Util
							.retonarObjetoDeColecao(RepositorioUtilHBM.getInstancia().pesquisar(filtroFaturamentoGrupoCronogramaMensal,
											FaturamentoGrupoCronogramaMensal.class.getName()));

			faturamentoGrupoCronogramaMensal.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			faturamentoGrupoCronogramaMensal.setOperacaoEfetuada(operacaoEfetuada);

			registradorOperacao.registrarOperacao(faturamentoGrupoCronogramaMensal);
			RepositorioUtilHBM.getInstancia().remover(faturamentoGrupoCronogramaMensal);

			// st = jdbcCon.prepareStatement(deleteGruMen);

			// st.executeUpdate();
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisar os ids das localidades para encerrar o faturamento do ano/mês
	 * de referência corrente.
	 * 
	 * @author Pedro Alexandre
	 * @date 05/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsLocalidadeParaEncerrarFaturamento() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select loca_id as localidade from conta " + "union " + "select loca_id as localidade from debito_a_cobrar "
							+ "union " + "select loca_id as localidade from credito_a_realizar " + "union "
							+ "select loca_id as localidade from guia_pagamento ";
			// + "order by localidade";

			retorno = session.createSQLQuery(consulta).addScalar("localidade", Hibernate.INTEGER).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar os ids das localidades para gerar o resumo das
	 * ligações/economias.
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/01/2007
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarIdsLocalidadeParaGerarResumoLigacoesEconomias() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select distinct (imovel.localidade.id) from Imovel imovel";

			retorno = session.createQuery(consulta).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Recupera os dados da conta p emitir a 2ª via [UC0482]Emitir 2ª Via de
	 * Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 08/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaERota(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT " + " new " + EmitirContaHelper.class.getName() + " ( " + "cnt.id, " + "cli.nome, "
							+ "cnt.dataVencimentoConta, " + "cnt.referencia, " + "cnt.digitoVerificadorConta, "
							+ "cnt.codigoSetorComercial, " + "cnt.quadra, " + "cnt.lote, " + "cnt.subLote, " + "cnt.consumoAgua, "
							+ "cnt.consumoEsgoto, " + "cnt.valorAgua, " + "cnt.valorEsgoto, " + "cnt.debitos, " + "cnt.valorCreditos, "
							+ "cnt.valorImposto, " + "cnt.dataValidadeConta, " + "imovel.id, " + "loc.id, " + "gerenciaRegional.id, "
							+ "gerenciaRegional.nome, " + "ligacaoAguaSituacao.id, " + "ligacaoEsgotoSituacao.id, " + "imovelPerfil.id, "
							+ "setorComercial.id, " + "faturamentoGrupo.id, " + "emp.id, " + "loc.descricao, "
							+ "ligacaoAguaSituacao.descricao, " + "ligacaoEsgotoSituacao.descricao, " + "cnt.percentualEsgoto, "
							+ "rota.codigo, " + "imovel.numeroSequencialRota, " + "hidrometro.numero, " + "debitoCreditoSituacaoAtual.id, "
							+ "imovel.nomeImovel ) " + "from ClienteConta cliCnt " + "RIGHT JOIN cliCnt.conta cnt "
							+ "LEFT JOIN cliCnt.clienteRelacaoTipo crt " + "LEFT JOIN cliCnt.cliente cli "
							+ "LEFT JOIN cnt.contaMotivoRevisao cmr " + "LEFT JOIN cnt.quadraConta quadraConta "
							+ "LEFT JOIN cnt.localidade loc " + "LEFT JOIN loc.gerenciaRegional gerenciaRegional "
							+ "LEFT JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "LEFT JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao " + "LEFT JOIN cnt.imovelPerfil imovelPerfil "
							+ "LEFT JOIN quadraConta.rota rota " + "LEFT JOIN rota.empresa emp "
							+ "LEFT JOIN quadraConta.setorComercial setorComercial " + "LEFT JOIN rota.faturamentoGrupo faturamentoGrupo "
							+ "LEFT JOIN cnt.imovel imovel " + "LEFT JOIN imovel.hidrometroInstalacaoHistorico hih "
							+ "LEFT JOIN hih.hidrometro hidrometro "
							+ "LEFT JOIN cnt.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual " + "WHERE  cnt.id = :idConta "
							+ "AND  cliCnt.indicadorNomeConta = 1 " + "ORDER BY cnt.referencia,emp.id,loc.id,cnt.codigoSetorComercial,"
							+ "cnt.quadra,cnt.lote,cnt.subLote";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição
	 * Individualizada
	 * 
	 * @author Vivianne Sousa
	 * @date 09/01/2007
	 * @param filtroMedicaoHistoricoSql
	 * @param anoMesfaturamentoGrupo
	 * @throws ControladorException
	 */

	public Collection pesquisarIdImovelCondominioLigacoesMedicaoIndividualizada(FiltroMedicaoHistoricoSql filtroMedicaoHistoricoSql,
					Integer anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;

		Collection medicaohistoricoParametros = filtroMedicaoHistoricoSql.getParametros();

		Session session = HibernateUtil.getSession();

		String sql = "";
		try{

			if(!medicaohistoricoParametros.isEmpty() && medicaohistoricoParametros.size() >= 1){

				sql = "select imovel.imov_id as idImovel,"// 0
								+ " imovel.loca_id as idLocalidade," // 01
								+ " localidade.loca_nmlocalidade as nomeLocalidade," // 02
								+ " imovel.poco_id as idPoco" // 03
								+ " from imovel imovel"
								+ " inner join localidade localidade on imovel.loca_id = localidade.loca_id"
								+ " inner join consumo_historico consumoHistorico on imovel.imov_id=consumoHistorico.imov_id and consumoHistorico.cshi_amfaturamento = "
								+ anoMesReferencia
								+ " and consumoHistorico.lgti_id = "
								+ LigacaoTipo.LIGACAO_AGUA
								+ " inner join medicao_historico medicaoHistorico on  consumoHistorico.imov_id=medicaoHistorico.lagu_id and medicaoHistorico.mdhi_amleitura = "
								+ anoMesReferencia
								+ " and medicaoHistorico.medt_id = "
								+ LigacaoTipo.LIGACAO_AGUA
								+ " left outer join imovel_subcategoria imovelSubcategoria on imovel.imov_id=imovelSubcategoria.imov_id  left outer join quadra quadra on imovel.qdra_id=quadra.qdra_id"
								+ " left outer join setor_comercial setorComercial on imovel.stcm_id=setorComercial.stcm_id  left outer join rota rota on imovel.rota_id=rota.rota_id"
								+ " left outer join faturamento_grupo faturamentoGrupo on rota.ftgr_id=faturamentoGrupo.ftgr_id  left outer join empresa empresa on rota.empr_id=empresa.empr_id"
								+ " left outer join imovel_perfil imovelPerfil on imovel.iper_id=imovelPerfil.iper_id"
								+ " left outer join subcategoria subcategoria on imovelSubcategoria.scat_id=subcategoria.scat_id"
								+ " left outer join consumo_anormalidade consumoAnormalidade on consumoHistorico.csan_id=consumoAnormalidade.csan_id"
								+ " left outer join categoria categoria on subcategoria.catg_id=categoria.catg_id"
								+ " left outer join medicao_tipo medicaoTipo on medicaoHistorico.medt_id=medicaoTipo.medt_id"
								+ " left outer join leitura_anormalidade leituraAnormalidadeFaturamento on medicaoHistorico.ltan_idleituraanormalidadefatu=leituraAnormalidadeFaturamento.ltan_id"
								+ " where ";

				String sqlSegundaParte = " select  imovel.imov_id as idImovel," // 0
								+ " imovel.loca_id as idLocalidade," // 01
								+ " localidade.loca_nmlocalidade as nomeLocalidade," // 02
								+ " imovel.poco_id as idPoco" // 03
								+ " from imovel imovel"
								+ " inner join localidade localidade on imovel.loca_id = localidade.loca_id"
								+ " inner join consumo_historico consumoHistorico on imovel.imov_id=consumoHistorico.imov_id and consumoHistorico.cshi_amfaturamento =  "
								+ anoMesReferencia
								+ "  and consumoHistorico.lgti_id = "
								+ LigacaoTipo.LIGACAO_ESGOTO
								+ " inner join medicao_historico medicaoHistorico on  consumoHistorico.imov_id=medicaoHistorico.imov_id and medicaoHistorico.mdhi_amleitura =  "
								+ anoMesReferencia
								+ " and medicaoHistorico.medt_id = "
								+ LigacaoTipo.LIGACAO_ESGOTO
								+ " left outer join imovel_subcategoria imovelSubcategoria on imovel.imov_id=imovelSubcategoria.imov_id  left outer join quadra quadra on imovel.qdra_id=quadra.qdra_id "
								+ " left outer join setor_comercial setorComercial on imovel.stcm_id=setorComercial.stcm_id  left outer join rota rota on imovel.rota_id=rota.rota_id"
								+ " left outer join faturamento_grupo faturamentoGrupo on rota.ftgr_id=faturamentoGrupo.ftgr_id  left outer join empresa empresa on rota.empr_id=empresa.empr_id"
								+ " left outer join imovel_perfil imovelPerfil on imovel.iper_id=imovelPerfil.iper_id"
								+ " left outer join subcategoria subcategoria on imovelSubcategoria.scat_id=subcategoria.scat_id"
								+ " left outer join consumo_anormalidade consumoAnormalidade on consumoHistorico.csan_id=consumoAnormalidade.csan_id"
								+ " left outer join categoria categoria on subcategoria.catg_id=categoria.catg_id"
								+ " left outer join medicao_tipo medicaoTipo on medicaoHistorico.medt_id=medicaoTipo.medt_id"
								+ " left outer join leitura_anormalidade leituraAnormalidadeFaturamento on medicaoHistorico.ltan_idleituraanormalidadefatu=leituraAnormalidadeFaturamento.ltan_id"
								+ " where ";

				Iterator iteratorImovelSub = medicaohistoricoParametros.iterator();
				while(iteratorImovelSub.hasNext()){
					FiltroParametro filtroParametro = (FiltroParametro) iteratorImovelSub.next();

					if(filtroParametro instanceof Intervalo){

						Intervalo intervalo = ((Intervalo) filtroParametro);

						sql = sql + " (quadra.qdra_nnquadra between " + intervalo.getIntervaloInicial() + " and "
										+ intervalo.getIntervaloFinal() + ") and ";

						sqlSegundaParte = sqlSegundaParte + " (quadra.qdra_nnquadra between " + intervalo.getIntervaloInicial() + " and "
										+ intervalo.getIntervaloFinal() + ") and ";

					}

					if(filtroParametro instanceof ParametroSimples){
						ParametroSimples parametroSimples = ((ParametroSimples) filtroParametro);

						if(parametroSimples.getNomeAtributo().trim().equalsIgnoreCase(FiltroMedicaoHistoricoSql.IMOVEL_CONDOMINIO_ID)){

							sql = sql + " (" + parametroSimples.getNomeAtributo() + " = " + parametroSimples.getValor() + " and ";

							sql = Util.formatarHQL(sql, 4);
							sql = sql + " or imovel.imov_id " + " = " + parametroSimples.getValor() + ") and ";

							sqlSegundaParte = sqlSegundaParte + " (" + parametroSimples.getNomeAtributo() + " = "
											+ parametroSimples.getValor() + " and ";

							sqlSegundaParte = Util.formatarHQL(sqlSegundaParte, 4);
							sqlSegundaParte = sqlSegundaParte + " or imovel.imov_id " + " = " + parametroSimples.getValor() + ") and ";

						}else{
							sql = sql + parametroSimples.getNomeAtributo() + " = " + parametroSimples.getValor() + " and ";

							sqlSegundaParte = sqlSegundaParte + parametroSimples.getNomeAtributo() + " = " + parametroSimples.getValor()
											+ " and ";
						}
					}

					if(filtroParametro instanceof ParametroNaoNulo){
						ParametroNaoNulo parametroSimples = ((ParametroNaoNulo) filtroParametro);

						sql = sql + " (" + parametroSimples.getNomeAtributo() + " is not null) and ";

						sqlSegundaParte = sqlSegundaParte + " (" + parametroSimples.getNomeAtributo() + " is not null) and ";

					}

					if(filtroParametro instanceof MaiorQue){
						MaiorQue parametroSimples = ((MaiorQue) filtroParametro);

						sql = sql + " (" + parametroSimples.getNomeAtributo() + " >= " + parametroSimples.getNumero() + ") and ";

						sqlSegundaParte = sqlSegundaParte + " (" + parametroSimples.getNomeAtributo() + " >= "
										+ parametroSimples.getNumero() + ") and ";
					}

				}

				sql = Util.formatarHQL(sql, 4);

				sqlSegundaParte = Util.formatarHQL(sqlSegundaParte, 4);

				sql = sql + " UNION " + sqlSegundaParte;
				sql = sql + " order by idLocalidade";
			}

			retorno = session.createSQLQuery(sql).addScalar("idImovel", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
							.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("idPoco", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição
	 * Individualizada
	 * 
	 * @author Vivianne Sousa
	 * @date 09/01/2007
	 * @param idImovel
	 * @param anoMesfaturamentoGrupo
	 * @throws ControladorException
	 */
	public Collection pesquisarLigacoesMedicaoIndividualizadaRelatorio(Integer idImovel, String anoMesfaturamentoGrupo)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = " select imovel.imov_id as idImovel, " // 0
							+ " imovel.imov_qteconomia as qtdEconomias, "// 1
							+ " medicaoHistorico.mdhi_dtleituraanteriorfaturame as dataLeituraAnterior,"// 2
							+ " medicaoHistorico.mdhi_nnleituraanteriorfaturame as leituraAnterior,"// 3
							+ " medicaoHistorico.mdhi_dtleituraatualfaturamento as dataLeituraAtualFaturamento,"// 4
							+ " medicaoHistorico.mdhi_nnleituraatualfaturamento as leituraAtualFaturamento,"// 5
							+ " consumoHistorico.cshi_nnconsumoimoveisvinculado as consumoImoveisVinculados,"// 6
							+ " medicaoHistorico.ltan_idleituraanormalidadefatu as idAnormalidadeLeitura,"// 7
							+ " consumoHistorico.cshi_nnconsumomedio as consumoMedio,"// 8
							+ " consumoHistorico.cshi_nnconsumofaturadomes as consumoFaturado,"// 9
							+ " consumoHistorico.cshi_nnconsumorateio as rateio,"// 10
							+ " consumoAnormalidade.csan_dsabreviadaconsumoanormal as dsAbreviadaAnormalidadeConsumo,"// 11
							+ " consumoTipo.cstp_dsabreviadaconsumotipo as dsAbreviadaTipoConsumo,"// 12

							// 13 Consumo Esgoto
							+ " (select consumo.cshi_nnconsumofaturadomes"
							+ " from consumo_historico consumo"
							+ " where consumo.imov_id = imovel.imov_id" + " and consumo.cshi_amfaturamento = "
							+ anoMesfaturamentoGrupo
							+ " and consumo.lgti_id = "
							+ LigacaoTipo.LIGACAO_ESGOTO.toString()
							+ ") as consumoEsgoto,"

							+ " setorComercial.stcm_cdsetorcomercial as codigoSetorComercial,"// 14
							+ " quadra.qdra_nnquadra as numeroQuadra,"// 15
							+ " imovel.imov_nnlote as numeroLote,"// 16
							+ " imovel.imov_nnsublote as numeroSubLote,"// 17

							+ " (select cliente.clie_nmcliente from cliente_imovel clienteImovel"
							+ " left outer join cliente cliente on clienteImovel.clie_id = cliente.clie_id"
							+ " where imovel.imov_id = clienteImovel.imov_id and clienteImovel.clim_dtrelacaofim is null"
							+ " and clienteImovel.crtp_id = "
							+ ClienteRelacaoTipo.USUARIO.toString()
							+ " ) as nomeCliente," // 18

							+ " imovel.last_id as ligacaoSituacaoAgua," // 19
							+ " imovel.lest_id as ligacaoSituacaoEsgoto," // 20
							+ " hidInsHist.hidi_nnhidrometro as numeroHidrometro," // 21
							+ " imovel.imov_icimovelcondominio as indicadorImovelCondominio," // 22
							+ " hidInsHist.rttp_id as idRateioTipo, " // 23
							+ " LA.LTAN_DSLEITURAANORMALIDADE  AS descricaoAnormalidade"//24 OC1173220
							+ " from imovel imovel"
							+ " left outer join consumo_historico consumoHistorico on (imovel.imov_id=consumoHistorico.imov_id and consumoHistorico.cshi_amfaturamento = "
							+ anoMesfaturamentoGrupo
							+ " and consumoHistorico.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ ") "
							+ " left outer join medicao_historico medicaoHistorico on  (consumoHistorico.imov_id=medicaoHistorico.lagu_id and medicaoHistorico.mdhi_amleitura = "
							+ anoMesfaturamentoGrupo
							+ " and medicaoHistorico.medt_id = "
							+ MedicaoTipo.LIGACAO_AGUA.toString()
							+ ") "
							+ " left outer join consumo_anormalidade consumoAnormalidade on consumoHistorico.csan_id=consumoAnormalidade.csan_id"
							+ " left outer join medicao_tipo medicaoTipo on medicaoHistorico.medt_id=medicaoTipo.medt_id"
							+ " left outer join consumo_tipo consumoTipo on consumoHistorico.cstp_id=consumoTipo.cstp_id"
							+ " left outer join quadra quadra on imovel.qdra_id=quadra.qdra_id"
							+ " left outer join setor_comercial setorComercial on imovel.stcm_id=setorComercial.stcm_id"
							+ " left outer join hidrometro_instalacao_hist hidInsHist on hidInsHist.hidi_id = medicaoHistorico.hidi_id"
							+ " LEFT OUTER JOIN LEITURA_ANORMALIDADE LA ON medicaoHistorico.ltan_idleituraanormalidadefatu = LA.LTAN_ID"
							+ " where "
							+ " (imovel.imov_idimovelcondominio = "
							+ idImovel
							+ " or imovel.imov_id = "
							+ idImovel
							+ ")"
							+ " and  imovel.imov_icexclusao =  "
							+ ConstantesSistema.NAO
							+ " and imovel.last_id not in ("
							+ LigacaoAguaSituacao.POTENCIAL
							+ ","
							+ LigacaoAguaSituacao.FACTIVEL
							+ ") "
							+ " order by imovel.imov_icimovelcondominio,imovel.imov_id ";

			retorno = (Collection) session
							.createSQLQuery(consulta)
							.addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("qtdEconomias", Hibernate.SHORT)
							// .addScalar("idMedicaoHistorico", Hibernate.INTEGER)
							.addScalar("dataLeituraAnterior", Hibernate.DATE)
							.addScalar("leituraAnterior", Hibernate.INTEGER)
							.addScalar("dataLeituraAtualFaturamento", Hibernate.DATE)
							.addScalar("leituraAtualFaturamento", Hibernate.INTEGER)
							.addScalar("consumoImoveisVinculados", Hibernate.INTEGER)
							.addScalar("idAnormalidadeLeitura", Hibernate.INTEGER)
							// .addScalar("idConsumoHistorico", Hibernate.INTEGER)
							.addScalar("consumoMedio", Hibernate.INTEGER)
							.addScalar("consumoFaturado", Hibernate.INTEGER)
							.addScalar("rateio", Hibernate.INTEGER)
							.addScalar("dsAbreviadaAnormalidadeConsumo", Hibernate.STRING)
							.addScalar("dsAbreviadaTipoConsumo", Hibernate.STRING)
							// .addScalar("tipoMedicao", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER)
							// .addScalar("consumoInformado", Hibernate.INTEGER)
							.addScalar("codigoSetorComercial", Hibernate.INTEGER).addScalar("numeroQuadra", Hibernate.INTEGER)
							.addScalar("numeroLote", Hibernate.SHORT).addScalar("numeroSubLote", Hibernate.SHORT)
							.addScalar("nomeCliente", Hibernate.STRING).addScalar("ligacaoSituacaoAgua", Hibernate.INTEGER)
							.addScalar("ligacaoSituacaoEsgoto", Hibernate.INTEGER).addScalar("numeroHidrometro", Hibernate.STRING)
							.addScalar("indicadorImovelCondominio", Hibernate.INTEGER).addScalar("idRateioTipo", Hibernate.INTEGER)
							.addScalar("descricaoAnormalidade", Hibernate.STRING).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0493] Emitir de Extrato de Consumo de Imóvel Condomínio
	 * Flávio Cordeiro 08/01/2007
	 * 
	 * @throws ErroRepositorioException
	 *             idsRotas string formatada com valores separados por virgula.
	 *             Ex: 1,2,5,6 anoMesFaturamento
	 */

	public Collection pesquisarEmitirExtratoConsumoImovelCondominio(Collection idsRotas, String anoMesFaturamento)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String sql;
		try{

			sql = "select distinct(imovel.imov_id) as idImovel, "// 0
							+ " localidade.loca_id as idLocalidade,"// 1
							+ " localidade.loca_nmlocalidade as nomeLocalidade, "// 2
							+ " medicaoHistorico.mdhi_dtleituraatualfaturamento as dataLeituraAtualFat,"// 3
							+ " medicaoHistorico.mdhi_nnleituraatualfaturamento as numeroLeituraAtualFat,"// 4
							+ " consumoHistorico.cshi_nnconsumofaturadomes as consumoFaturadoMes,"// 5
							+ " leituraSituacao.ltst_dsleiturasituacao as descricaoLeituraSituacao,"// 6
							+ " consumoTipo.cstp_dsconsumotipo as descricaoConsumoTipo,"// 7
							+ " consumoAnormalidade.csan_dsconsumoanormalidade as descricaoAnormalidadeConsumo,"// 8
							+ " imovel.imov_qteconomia as qtdEconomias,"// 9
							+ " imovel.last_id as situacaoAgua,"// 10
							+ " imovel.lest_id as situacaoEsgoto,"// 11
							+ " consumoTipo.cstp_dsabreviadaconsumotipo as abreviadaConsumoTipo,"// 12
							+ " medicaoHistorico.ltan_idleituraanormalidadefatu as anormalidadeLeituraFat,"// 13
							+ " consumoAnormalidade.csan_dsabreviadaconsumoanormal as abreviadaConsumoAnormalidade,"// 14
							+ " imovel.iper_id as perfilImovel,"// 15
							+ " medicaoHistorico.mdhi_dtleituraanteriorfaturame as dataLeituraAnteriorFat,"// 16
							+ " consumoHistorico.cshi_nnconsumomedio as consumoMedio,"// 17
							+ " consumoHistorico.cshi_nnconsumorateio as rateio,"// 18
							+ " rota.empr_id as idEmpresa,"// 19
							+ " leituraSituacao.ltst_id as idLeituraSituacao,"// 20
							+ " setorComercial.stcm_cdsetorcomercial as codigoSetorComercial,"// 21
							+ " imovel.qdra_id as idQuadra,"// 22
							+ " imovel.imov_nnlote as lote,"// 23
							+ " imovel.imov_nnsublote as subLote,"// 24
							+ " consumoHistorico.cshi_nnconsumoimoveisvinculado as consumovinculados"// 25
							+ " from imovel imovel"
							+ " inner join consumo_historico consumoHistorico on imovel.imov_id = consumoHistorico.imov_id"
							+ " inner join medicao_historico medicaoHistorico on imovel.imov_id = medicaoHistorico.lagu_id"
							+ " left join quadra quadra on imovel.qdra_id = quadra.qdra_id"
							+ " left join rota rota on rota.rota_id = imovel.rota_id"
							+ " left join faturamento_ativ_cron_rota fatAtivCronRota on fatAtivCronRota.rota_id = rota.rota_id"
							+ " left join setor_comercial setorComercial on setorComercial.stcm_id = imovel.stcm_id"
							+ " left join localidade localidade on localidade.loca_id = imovel.loca_id"
							+ " left join leitura_situacao leituraSituacao on leituraSituacao.ltst_id = medicaoHistorico.ltst_idleiturasituacaoatual"
							+ " left join consumo_tipo consumoTipo on consumoTipo.cstp_id = consumoHistorico.cstp_id"
							+ " left join consumo_anormalidade consumoAnormalidade on consumoAnormalidade.csan_id = consumoHistorico.csan_id"
							+ " where rota.rota_id in (:idsRotas)"
							+ " and consumoHistorico.cshi_icimovelcondominio = 1"
							+ " and consumoHistorico.lgti_id = " + LigacaoTipo.LIGACAO_AGUA
							+ " and consumoHistorico.cshi_amfaturamento = "
							+ anoMesFaturamento + " and medicaoHistorico.medt_id = "
							+ LigacaoTipo.LIGACAO_AGUA
							+ " and medicaoHistorico.mdhi_amleitura = " + anoMesFaturamento
							+ " order by idEmpresa, idLocalidade,"
							+ " codigoSetorComercial, idQuadra," + " imovel.imov_nnlote";

			retorno = session.createSQLQuery(sql).addScalar("idImovel", Hibernate.INTEGER).addScalar("idLocalidade", Hibernate.INTEGER)
							.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("dataLeituraAtualFat", Hibernate.DATE)
							.addScalar("numeroLeituraAtualFat", Hibernate.INTEGER).addScalar("consumoFaturadoMes", Hibernate.INTEGER)
							.addScalar("descricaoLeituraSituacao", Hibernate.STRING).addScalar("descricaoConsumoTipo", Hibernate.STRING)
							.addScalar("descricaoAnormalidadeConsumo", Hibernate.STRING).addScalar("qtdEconomias", Hibernate.INTEGER)
							.addScalar("situacaoAgua", Hibernate.INTEGER).addScalar("situacaoEsgoto", Hibernate.INTEGER)
							.addScalar("abreviadaConsumoTipo", Hibernate.STRING).addScalar("anormalidadeLeituraFat", Hibernate.INTEGER)
							.addScalar("abreviadaConsumoAnormalidade", Hibernate.STRING).addScalar("perfilImovel", Hibernate.INTEGER)
							.addScalar("dataLeituraAnteriorFat", Hibernate.DATE).addScalar("consumoMedio", Hibernate.INTEGER)
							.addScalar("rateio", Hibernate.INTEGER).addScalar("idEmpresa", Hibernate.INTEGER)
							.addScalar("idLeituraSituacao", Hibernate.INTEGER).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("idQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.INTEGER)
							.addScalar("subLote", Hibernate.INTEGER).addScalar("consumovinculados", Hibernate.INTEGER)
							.setParameterList("idsRotas", idsRotas).list();

		}catch(HibernateException e){
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * soma dos consumos dos imoveis associados [UC0493] Emitir de Extrato de
	 * Consumo de Imóvel Condomínio
	 * Flávio Cordeiro 12/01/2007
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer somaConsumosImoveisAssociados(Integer idImovel, String anoMes) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String sql;

		try{
			sql = "select sum(consumoHistorico.cshi_nnconsumofaturadomes) as consumos" + " from consumo_historico consumoHistorico"
							+ " inner join imovel imovel on consumoHistorico.imov_id = imovel.imov_id"
							+ " where consumoHistorico.cshi_amfaturamento = " + anoMes + " and imovel.imov_idimovelcondominio = "
							+ idImovel + " and consumoHistorico.lgti_id = " + LigacaoTipo.LIGACAO_AGUA;

			retorno = ((Number) session.createSQLQuery(sql).addScalar("consumos", Hibernate.INTEGER).uniqueResult()).intValue();

		}catch(HibernateException e){
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * quantidade de imoveis associados [UC0493] Emitir de Extrato de Consumo de
	 * Imóvel Condomínio
	 * Flávio Cordeiro 12/01/2007
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer quantidadeImoveisAssociados(Integer idImovel, String anoMes) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String sql;

		try{
			sql = "select count(consumoHistorico.cshi_nnconsumofaturadomes) as qtd" + " from consumo_historico consumoHistorico"
							+ " inner join imovel imovel on consumoHistorico.imov_id = imovel.imov_id"
							+ " where consumoHistorico.cshi_amfaturamento = " + anoMes + " and imovel.imov_idimovelcondominio = "
							+ idImovel + " and consumoHistorico.lgti_id = " + LigacaoTipo.LIGACAO_AGUA;

			retorno = (Integer) session.createSQLQuery(sql).addScalar("qtd", Hibernate.INTEGER).uniqueResult();

		}catch(HibernateException e){
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0173] Gerar Relatório de Resumo do Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @created 24/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQtdeRegistrosResumoFaturamentoRelatorio(int anoMesReferencia, Integer localidade, Integer gerenciaRegional,
					String opcaoTotalizacao) throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select count(rf.id)" + " from ResumoFaturamento rf" + " where rf.anoMesReferencia = :anoMesReferencia and"
							+ " (rf.categoria.id = 1 or" + " rf.categoria.id = 2 or" + " rf.categoria.id = 3 or" + " rf.categoria.id = 4)";

			if(opcaoTotalizacao.equals("localidade") && localidade != null){

				consulta = consulta + " and rf.localidade = :localidade";

				retorno = ((Number) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
								.setInteger("localidade", localidade).uniqueResult()).intValue();

			}else if((opcaoTotalizacao.equals("gerenciaRegionalLocalidade") || opcaoTotalizacao.equals("gerenciaRegional"))
							&& gerenciaRegional != null){

				consulta = consulta + " and rf.gerenciaRegional = :gerenciaRegional";

				retorno = ((Number) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
								.setInteger("gerenciaRegional", gerenciaRegional).uniqueResult()).intValue();
			}else{
				retorno = ((Number) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult())
								.intValue();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * @author Ana Maria
	 * @date 26/01/2007
	 * @param idConta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection obterConta(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT conta " + "FROM Conta conta " + "WHERE conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0335] Gerar Resumo de Pendência
	 * Pesquisar os ids das localidade
	 * 
	 * @author Ana Maria
	 * @date 29/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsLocalidade() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try{

			consulta = "select loca_id as localidade from conta " + "union " + "select loca_id as localidade from guia_pagamento "
							+ "order by localidade";

			retorno = session.createSQLQuery(consulta).addScalar("localidade", Hibernate.INTEGER).list();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o Id da Localidade de uma Conta
	 * 
	 * @author Saulo Lima
	 * @date 03/05/2012
	 * @return idLocalidade
	 * @throws ErroRepositorioException
	 */
	public Integer obterIdLocalidadePorConta(Integer idConta) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		try{

			String consulta = "SELECT loca_id AS idLocalidade FROM conta WHERE cnta_id = :idConta";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("idLocalidade", Hibernate.INTEGER)
							.setInteger("idConta", idConta.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o Id da Localidade de uma Conta no Histórico
	 * 
	 * @author Saulo Lima
	 * @date 03/05/2012
	 * @return idLocalidade
	 * @throws ErroRepositorioException
	 */
	public Integer obterIdLocalidadePorContaHistorico(Integer idContaHistorico) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		try{

			String consulta = "SELECT loca_id AS idLocalidade FROM conta_historico WHERE cnta_id = :idContaHistorico";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("idLocalidade", Hibernate.INTEGER)
							.setInteger("idContaHistorico", idContaHistorico.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * atualiza o sequencial de conta impressão
	 * 
	 * @author Sávio Luiz
	 * @date 29/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSequencialContaImpressao(Map<Integer, Integer> mapAtualizaSequencial) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta = "update gcom.faturamento.conta.ContaImpressao "
						+ "set cnti_nnsequencialimpressao =:sequencialConta ,cnti_tmultimaalteracao = :dataAtual "
						+ "where cnta_id = :idConta ";
		try{
			if(mapAtualizaSequencial != null && !mapAtualizaSequencial.isEmpty()){
				Iterator iteMapAtualizaSequencia = mapAtualizaSequencial.keySet().iterator();

				while(iteMapAtualizaSequencia.hasNext()){
					Integer idConta = (Integer) iteMapAtualizaSequencia.next();
					Integer sequencialConta = mapAtualizaSequencial.get(idConta);
					session.createQuery(consulta).setInteger("idConta", idConta).setInteger("sequencialConta", sequencialConta)
									.setDate("dataAtual", new Date()).executeUpdate();
				}
			}
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);

		}

	}

	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Vivianne Sousa
	 * @created 30/01/2007
	 * @author eduardo henrique
	 * @date 20/01/2009
	 *       Alteração para não limitar em somente contas com Cliente Responsável.
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarContasEmitidasRelatorio(int anoMesReferencia, Integer grupoFaturamento, Collection esferaPoder)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select contaImpressao.id, "
							+ // 0
							"clienteResponsavel.id, "
							+ // 1
							"clienteResponsavel.nome, "
							+ // 2
							"imovel.localidade.id, "
							+ // 3
							"imovel.localidade.descricao, "
							+ // 4
							"conta.dataVencimentoConta, "
							+ // 5
							"imovel.id, "
							+ // 6
							"imovel.setorComercial.codigo, "
							+ // 7
							"imovel.quadra.numeroQuadra, "
							+ // 8
							"imovel.lote, "
							+ // 9
							"imovel.subLote, "
							+ // 10
							"(select clienteImovel.cliente.nome "
							+ "from ClienteImovel clienteImovel "
							+ "where clienteImovel.imovel.id = imovel.id "
							+ "and clienteImovel.clienteRelacaoTipo.id = 2 "
							+ "and clienteImovel.dataFimRelacao is null), "
							+ // 11
							"conta.valorAgua, "
							+ // 12
							"conta.valorEsgoto, "
							+ // 13
							"conta.debitos, "
							+ // 14
							"conta.valorCreditos, "
							+ // 15
							"esferaPoder.id, "
							+ // 16
							"esferaPoder.descricao "
							+ // 17
							"from ContaImpressao contaImpressao " + "inner join contaImpressao.faturamentoGrupo faturamentoGrupo "
							+ "left join contaImpressao.clienteResponsavel clienteResponsavel "
							+ "left join clienteResponsavel.clienteTipo clienteTipo " + "left join clienteTipo.esferaPoder esferaPoder "
							+ "left join contaImpressao.contaGeral contaGeral " + "left join contaGeral.conta conta "
							+ "left join conta.imovel imovel " + "where contaImpressao.faturamentoGrupo.id = :grupoFaturamento "
							+ "and esferaPoder.id in (:esferaPoder) " + "and contaImpressao.referenciaConta = :anoMesReferencia "
							+ "order by esferaPoder.id,clienteResponsavel.id ";

			retorno = session.createQuery(consulta).setInteger("grupoFaturamento", grupoFaturamento)
							.setParameterList("esferaPoder", esferaPoder).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Vivianne Sousa
	 * @created 02/02/2007
	 * @author eduardo henrique
	 * @date 20/01/2009
	 *       Alteração para não limitar em somente contas com Cliente Responsável.
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQtdeContasEmitidasRelatorio(int anoMesReferencia, Integer grupoFaturamento, Collection esferaPoder)
					throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select count(contaImpressao.id) " + "from ContaImpressao contaImpressao "
							+ "inner join contaImpressao.faturamentoGrupo faturamentoGrupo "
							+ "left join contaImpressao.clienteResponsavel clienteResponsavel "
							+ "left join clienteResponsavel.clienteTipo clienteTipo " + "left join clienteTipo.esferaPoder esferaPoder "
							+ "where contaImpressao.faturamentoGrupo.id = :grupoFaturamento " + "and esferaPoder.id in (:esferaPoder) "
							+ "and contaImpressao.referenciaConta = :anoMesReferencia ";

			retorno = ((Number) session.createQuery(consulta).setInteger("grupoFaturamento", grupoFaturamento)
							.setParameterList("esferaPoder", esferaPoder).setInteger("anoMesReferencia", anoMesReferencia).uniqueResult())
							.intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	// retorna o anoMes do faturamento grupo do imóvel passado
	public Integer retornaAnoMesFaturamentoGrupo(Integer idImovel) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer anoMesFaturamento = null;

		try{

			// Pesquisa para saber qual o anoMes de faturamento do grupo q akele
			// imovel pertence
			String sqlMesFaturamentoGrupo = "select fg.ftgr_amreferencia as anoMes " + " from faturamento_grupo fg," + "	imovel im, "
							+ "	quadra qd, " + " rota rota " + " where im.qdra_id = qd.qdra_id " + " and qd.rota_id = rota.rota_id "
							+ " and rota.ftgr_id = fg.ftgr_id " + " and im.imov_id =:idImovel ";

			anoMesFaturamento = (Integer) session.createSQLQuery(sqlMesFaturamentoGrupo).addScalar("anoMes", Hibernate.INTEGER)
							.setInteger("idImovel", idImovel.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return anoMesFaturamento;
	}

	/**
	 * Monta a colecao de resultdos apartir da tbela conta impressao para
	 * geracao do relatorio de MAPA DE CONTROLE DAS CONTAS EMITIDAS
	 * 
	 * @author Flávio Cordeiro
	 * @date 13/02/2007
	 * @author Eduardo Henrique
	 * @date 16/05/2008
	 *       Alteração na validação do parâmetro de indicador de Ficha de Compensação
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarMapaControleContaRelatorio(Integer idGrupoFaturamento, String anoMes, String indicadorFichaCompensacao)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String sql = "select "
							+ " contaImpressao.empr_id as idEmpresa,"// 0
							+ " empresa.empr_nmempresa as nomeEmpresa,"// 1
							+ " contaImpressao.cttp_id as idTipoConta,"// 2
							+ " tipoConta.cttp_dstipoconta as descricaoTipoConta,"// 3
							+ " localidade.loca_id as idLocalidade,"// 4
							+ " setor.stcm_cdsetorcomercial as codigoSetor,"// 5
							+ " contaImpressao.ftgr_id as idFaturamentoGrupo, "// 6
							+ " min(contaImpressao.cnti_nnsequencialimpressao) as sequencialInicial,"// 7
							+ " max(contaImpressao.cnti_nnsequencialimpressao) as sequencialFinal,"// 8
							+ " sum(nvl(conta.cnta_vlagua, contaHistorico.cnhi_vlagua)) as somaValorAgua,"// 9
							+ " sum(nvl(conta.cnta_vlesgoto, contaHistorico.cnhi_vlesgoto)) as somaValorEsgoto,"// 10
							+ " sum(nvl(conta.cnta_vldebitos, contahistorico.cnhi_vldebitos)) as somaValordebito,"// 11
							+ " sum(nvl(conta.cnta_vlcreditos, contahistorico.cnhi_vlcreditos)) as somaValorCredito,"// 12
							+ " count(contaImpressao.cnta_id) as quantidadeContas"// 13
							+ " from conta_impressao contaImpressao" + " left join conta conta on contaImpressao.cnta_id = conta.cnta_id"
							+ " left join conta_historico contaHistorico on contaImpressao.cnta_id = contaHistorico.cnta_id"
							+ " inner join faturamento_grupo grupoFaturamento on contaImpressao.ftgr_id = grupoFaturamento.ftgr_id"
							+ " left join empresa empresa on empresa.empr_id = contaImpressao.empr_id"
							+ " left join conta_tipo tipoConta on contaImpressao.cttp_id = tipoConta.cttp_id"
							+ " inner join imovel imovel on conta.imov_id = imovel.imov_id"
							+ " inner join localidade localidade on imovel.loca_id = localidade.loca_id"
							+ " inner join setor_comercial setor on imovel.stcm_id = setor.stcm_id"
							+ " where contaImpressao.ftgr_id = :idGrupoFaturamento"
							+ " and contaImpressao.cnti_amreferenciaconta = :anoMes"
							+ " and contaImpressao.cnti_icfichacompensacao = :indicadorFichaCompensacao ";

			sql = sql
							+ " group by contaImpressao.ftgr_id, contaImpressao.empr_id, empresa.empr_nmempresa, "
							+ "   contaImpressao.cttp_id, tipoConta.cttp_dstipoconta, localidade.loca_id,  setor.stcm_cdsetorcomercial "
							+ " order by empresa.empr_nmempresa, tipoConta.cttp_dstipoconta, localidade.loca_id, setor.stcm_cdsetorcomercial  ";

			retorno = (Collection) session.createSQLQuery(sql).addScalar("idEmpresa", Hibernate.INTEGER)
			// 0
							.addScalar("nomeEmpresa", Hibernate.STRING)
							// 1
							.addScalar("idTipoConta", Hibernate.INTEGER)
							// 2
							.addScalar("descricaoTipoConta", Hibernate.STRING)
							// 3
							.addScalar("idLocalidade", Hibernate.INTEGER)
							// 4
							.addScalar("codigoSetor", Hibernate.INTEGER)
							// 5
							.addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							// 6
							.addScalar("sequencialInicial", Hibernate.INTEGER)
							// 7
							.addScalar("sequencialFinal", Hibernate.INTEGER)
							// 8
							.addScalar("somaValorAgua", Hibernate.BIG_DECIMAL)
							// 9
							.addScalar("somaValorEsgoto", Hibernate.BIG_DECIMAL)
							// 10
							.addScalar("somaValordebito", Hibernate.BIG_DECIMAL)
							// 11
							.addScalar("somaValorCredito", Hibernate.BIG_DECIMAL)
							// 12
							.addScalar("quantidadeContas", Hibernate.INTEGER)
							// 13
							.setInteger("idGrupoFaturamento", idGrupoFaturamento).setInteger("anoMes", Integer.valueOf(anoMes))
							.setInteger("indicadorFichaCompensacao", Integer.valueOf(indicadorFichaCompensacao)).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Monta a colecao de resultdos apartir da tabela conta impressao para
	 * geracao do relatorio de RESUMO CONTAS EMITIDAS POR LOCALIDADE NO GRUPO
	 * 
	 * @author Flávio Cordeiro
	 * @date 13/02/2007
	 * @author Virgínia Melo
	 * @date 23/04/2009
	 *       Consulta modificada para considerar também as contas que foram enviadas para histórico.
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarResumoContasLocalidade(Integer idGrupoFaturamento, String anoMes, Integer idFirma, Integer idSetorComercial,
					Integer idLocalidade) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String sql = "select " + " localidade.loca_id as idLocalidade," + " contaImpressao.empr_id as idEmpresa,"

			+ " clienteTipo.epod_id as esferaPoder," + " setorComercial.stcm_cdsetorcomercial as setorComercial,"
							+ " min(contaImpressao.cnti_nnsequencialimpressao) as sequencialInicial,"
							+ " max(contaImpressao.cnti_nnsequencialimpressao) as sequencialFinal,"
							+ " count(contaImpressao.cnta_id) as qtdeContas," + " SUM(contaImpressao.cnti_vlconta) as valorConta"
							+ " from conta_impressao contaImpressao" + " inner join conta conta on contaImpressao.cnta_id = conta.cnta_id"
							+ " inner join faturamento_grupo grupoFaturamento on contaImpressao.ftgr_id = grupoFaturamento.ftgr_id"
							+ " left join empresa empresa on empresa.empr_id = contaImpressao.empr_id"
							+ " inner join imovel imovel on conta.imov_id = imovel.imov_id"
							+ " inner join setor_comercial setorComercial ON setorComercial.stcm_id = imovel.stcm_id"
							+ " inner join localidade localidade ON setorcomercial.loca_id = localidade.loca_id"
							+ " left join cliente clienteResponsavel on clienteResponsavel.clie_id = contaImpressao.clie_idresponsavel"
							+ " left join cliente_tipo clienteTipo on clienteResponsavel.cltp_id = clienteTipo.cltp_id"
							+ " where contaImpressao.ftgr_id = :idGrupoFaturamento"
							+ " and contaImpressao.cnti_amreferenciaconta = :anoMes";

			if(idFirma != null){
				sql = sql + " and empresa.empr_id = :idEmpresa ";
			}
			if(idSetorComercial != null){
				sql = sql + " and setorComercial.stcm_id = :idSetorComercial ";
			}
			if(idLocalidade != null){
				sql = sql + " and localidade.loca_id = :idLocalidade ";
			}
			sql = sql + " group by  " + " localidade.loca_id," + " contaImpressao.empr_id," + " clienteTipo.epod_id,"
							+ " setorComercial.stcm_id, " + " setorComercial.stcm_cdsetorcomercial";

			sql = sql + " union " + " select " + " localidade.loca_id as idLocalidade," + " contaImpressao.empr_id as idEmpresa,"

			+ " clienteTipo.epod_id as esferaPoder," + " setorComercial.stcm_cdsetorcomercial as setorComercial,"
							+ " min(contaImpressao.cnti_nnsequencialimpressao) as sequencialInicial,"
							+ " max(contaImpressao.cnti_nnsequencialimpressao) as sequencialFinal,"
							+ " count(contaImpressao.cnta_id) as qtdeContas," + " SUM(contaImpressao.cnti_vlconta) as valorConta"
							+ " from conta_impressao contaImpressao"
							+ " inner join conta_historico contaHistorico on contaImpressao.cnta_id = contaHistorico.cnta_id"
							+ " inner join faturamento_grupo grupoFaturamento on contaImpressao.ftgr_id = grupoFaturamento.ftgr_id"
							+ " left join empresa empresa on empresa.empr_id = contaImpressao.empr_id"
							+ " inner join imovel imovel on contaHistorico.imov_id = imovel.imov_id"
							+ " inner join setor_comercial setorComercial ON setorComercial.stcm_id = imovel.stcm_id"
							+ " inner join localidade localidade ON setorcomercial.loca_id = localidade.loca_id"
							+ " left join cliente clienteResponsavel on clienteResponsavel.clie_id = contaImpressao.clie_idresponsavel"
							+ " left join cliente_tipo clienteTipo on clienteResponsavel.cltp_id = clienteTipo.cltp_id"
							+ " where contaImpressao.ftgr_id = :idGrupoFaturamento"
							+ " and contaImpressao.cnti_amreferenciaconta = :anoMes ";

			if(idFirma != null){
				sql = sql + " and empresa.empr_id = :idEmpresa ";
			}
			if(idSetorComercial != null){
				sql = sql + " and setorComercial.stcm_id = :idSetorComercial ";
			}
			if(idLocalidade != null){
				sql = sql + " and localidade.loca_id = :idLocalidade ";
			}
			sql = sql + " group by  " + " localidade.loca_id," + " contaImpressao.empr_id," + " clienteTipo.epod_id, "
							+ " setorComercial.stcm_id, " + " setorComercial.stcm_cdsetorcomercial "
							+ " order by idLocalidade, idEmpresa, esferaPoder";

			if(idFirma != null && idLocalidade == null || idFirma != null && idLocalidade == null && idSetorComercial == null){
				retorno = (Collection) session.createSQLQuery(sql).addScalar("idLocalidade", Hibernate.INTEGER)
								// 0

								.addScalar("idEmpresa", Hibernate.INTEGER)
								// 1

								.addScalar("esferaPoder", Hibernate.INTEGER)
								// 2

								.addScalar("setorComercial", Hibernate.INTEGER)
								// 3

								.addScalar("sequencialInicial", Hibernate.INTEGER)
								// 4

								.addScalar("sequencialFinal", Hibernate.INTEGER)
								// 5

								.addScalar("qtdeContas", Hibernate.INTEGER)
								// 6

								.addScalar("valorConta", Hibernate.DOUBLE)
								// 7

								.setInteger("idGrupoFaturamento", idGrupoFaturamento).setInteger("anoMes", Integer.valueOf(anoMes))
								.setInteger("idEmpresa", idFirma).list();

			}else if(idFirma != null && idLocalidade != null && idSetorComercial == null){
				retorno = (Collection) session.createSQLQuery(sql).addScalar("idLocalidade", Hibernate.INTEGER)
								// 0

								.addScalar("idEmpresa", Hibernate.INTEGER)
								// 1

								.addScalar("esferaPoder", Hibernate.INTEGER)
								// 2

								.addScalar("setorComercial", Hibernate.INTEGER)
								// 3

								.addScalar("sequencialInicial", Hibernate.INTEGER)
								// 4

								.addScalar("sequencialFinal", Hibernate.INTEGER)
								// 5

								.addScalar("qtdeContas", Hibernate.INTEGER)
								// 6

								.addScalar("valorConta", Hibernate.DOUBLE)
								// 7

								.setInteger("idGrupoFaturamento", idGrupoFaturamento).setInteger("anoMes", Integer.valueOf(anoMes))
								.setInteger("idEmpresa", idFirma).setInteger("idLocalidade", idLocalidade).list();

			}else if(idFirma != null && idSetorComercial != null){
				retorno = (Collection) session
								.createSQLQuery(sql)
								.addScalar("idLocalidade", Hibernate.INTEGER)
								// 0

								.addScalar("idEmpresa", Hibernate.INTEGER)
								// 1

								.addScalar("esferaPoder", Hibernate.INTEGER)
								// 2

								.addScalar("setorComercial", Hibernate.INTEGER)
								// 3

								.addScalar("sequencialInicial", Hibernate.INTEGER)
								// 4

								.addScalar("sequencialFinal", Hibernate.INTEGER)
								// 5

								.addScalar("qtdeContas", Hibernate.INTEGER)
								// 6

								.addScalar("valorConta", Hibernate.DOUBLE)
								// 7

								.setInteger("idGrupoFaturamento", idGrupoFaturamento).setInteger("anoMes", Integer.valueOf(anoMes))
								.setInteger("idEmpresa", idFirma).setInteger("idLocalidade", idLocalidade)
								.setInteger("idSetorComercial", idSetorComercial).list();

			}

			else if(idFirma == null && idSetorComercial != null && idLocalidade == null){
				retorno = (Collection) session.createSQLQuery(sql).addScalar("idLocalidade", Hibernate.INTEGER)
				// 0

								.addScalar("idEmpresa", Hibernate.INTEGER)
								// 1

								.addScalar("esferaPoder", Hibernate.INTEGER)
								// 2

								.addScalar("setorComercial", Hibernate.INTEGER)
								// 3

								.addScalar("sequencialInicial", Hibernate.INTEGER)
								// 4

								.addScalar("sequencialFinal", Hibernate.INTEGER)
								// 5

								.addScalar("qtdeContas", Hibernate.INTEGER)
								// 6

								.addScalar("valorConta", Hibernate.DOUBLE)
								// 7

								.setInteger("idGrupoFaturamento", idGrupoFaturamento).setInteger("anoMes", Integer.valueOf(anoMes))

								.setInteger("idSetorComercial", idSetorComercial).list();

			}

			else if(idFirma == null && idSetorComercial != null && idLocalidade != null){
				retorno = (Collection) session.createSQLQuery(sql).addScalar("idLocalidade", Hibernate.INTEGER)
								// 0

								.addScalar("idEmpresa", Hibernate.INTEGER)
								// 1

								.addScalar("esferaPoder", Hibernate.INTEGER)
								// 2

								.addScalar("setorComercial", Hibernate.INTEGER)
								// 3

								.addScalar("sequencialInicial", Hibernate.INTEGER)
								// 4

								.addScalar("sequencialFinal", Hibernate.INTEGER)
								// 5

								.addScalar("qtdeContas", Hibernate.INTEGER)
								// 6

								.addScalar("valorConta", Hibernate.DOUBLE)
								// 7

								.setInteger("idGrupoFaturamento", idGrupoFaturamento).setInteger("anoMes", Integer.valueOf(anoMes))
								.setInteger("idLocalidade", idLocalidade).setInteger("idSetorComercial", idSetorComercial).list();

			}else if(idFirma == null && idSetorComercial == null && idLocalidade != null){
				retorno = (Collection) session.createSQLQuery(sql).addScalar("idLocalidade", Hibernate.INTEGER)
								// 0

								.addScalar("idEmpresa", Hibernate.INTEGER)
								// 1

								.addScalar("esferaPoder", Hibernate.INTEGER)
								// 2

								.addScalar("setorComercial", Hibernate.INTEGER)
								// 3

								.addScalar("sequencialInicial", Hibernate.INTEGER)
								// 4

								.addScalar("sequencialFinal", Hibernate.INTEGER)
								// 5

								.addScalar("qtdeContas", Hibernate.INTEGER)
								// 6

								.addScalar("valorConta", Hibernate.DOUBLE)
								// 7

								.setInteger("idGrupoFaturamento", idGrupoFaturamento).setInteger("anoMes", Integer.valueOf(anoMes))
								.setInteger("idLocalidade", idLocalidade).list();

			}

			else{
				retorno = (Collection) session.createSQLQuery(sql).addScalar("idLocalidade", Hibernate.INTEGER)// 0
								.addScalar("idEmpresa", Hibernate.INTEGER)// 1

								.addScalar("esferaPoder", Hibernate.INTEGER)// 2
								.addScalar("setorComercial", Hibernate.INTEGER) // 3
								.addScalar("sequencialInicial", Hibernate.INTEGER)// 4
								.addScalar("sequencialFinal", Hibernate.INTEGER)// 5
								.addScalar("qtdeContas", Hibernate.INTEGER) // 6
								.addScalar("valorConta", Hibernate.DOUBLE) // 7

								.setInteger("idGrupoFaturamento", idGrupoFaturamento).setInteger("anoMes", Integer.valueOf(anoMes)).list();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Author: Vivianne Sousa Data: 06/03/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterGuiasPagamentoPagamento(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT gpag.id " + "FROM Pagamento pgto " + "LEFT JOIN pgto.guiaPagamentoGeral gpag "
							+ "WHERE gpag.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Author: Vivianne Sousa Data: 06/03/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterGuiasPagamentoCobrancaDocumentoItem(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT gpag.id " + "FROM CobrancaDocumentoItem cdi " + "LEFT JOIN cdi.guiaPagamentoGeral gpag "
							+ "WHERE gpag.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Author: Vivianne Sousa Data: 06/03/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterGuiasPagamentoParcelamentoItem(Integer idGuiaPagamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT gpag.id " + "FROM ParcelamentoItem parcItem " + "LEFT JOIN parcItem.guiaPagamentoGeral gpag "
							+ "WHERE gpag.id = :idGuiaPagamento ";

			retorno = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 17/03/2007
	 * @param conta
	 * @param idImovel
	 * @param anoMesReferenciaConta
	 * @param anoMesReferenciaAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean obterIndicadorPagamentosClassificadosContaReferenciaMenorIgualAtual(Integer conta, Integer idImovel,
					Integer anoMesReferenciaConta, Integer anoMesReferenciaAtual) throws ErroRepositorioException{

		boolean retorno;

		Collection colecaoRetorno1;
		// Collection colecaoRetorno2;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT pgmt.id " + "FROM Pagamento pgmt " + "INNER JOIN pgmt.conta cnta " + "WHERE (cnta.id = :idConta "
							+ "AND pgmt.pagamentoSituacaoAtual.id = :idSituacaoAtual "
							+ "AND pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaAtual) ";

			colecaoRetorno1 = session.createQuery(consulta).setInteger("idConta", conta)
							.setInteger("idSituacaoAtual", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("anoMesReferenciaAtual", anoMesReferenciaAtual).list();

			/*
			 * consulta = "SELECT pgmt.id " + "FROM Pagamento pgmt " + "INNER
			 * JOIN pgmt.conta cnta " + "INNER JOIN cnta.imovel imov " + "WHERE
			 * pgmt.imovel.id= :idImovel and pgmt.anoMesReferenciaPagamento =
			 * :anoMesReferenciaConta ";
			 * colecaoRetorno2 = session.createQuery(consulta)
			 * .setInteger("idImovel", idImovel)
			 * .setInteger("anoMesReferenciaConta", anoMesReferenciaConta)
			 * .list();
			 */

			if(colecaoRetorno1 != null && !colecaoRetorno1.isEmpty()){
				retorno = true;
			}else{
				retorno = false;
				/*
				 * if(colecaoRetorno2 != null && !colecaoRetorno2.isEmpty()){
				 * retorno = true; }else{ retorno = false; }
				 */
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 19/03/2007
	 * @param idGuiaPagamento
	 * @param idImovel
	 * @param idDebitoTipo
	 * @param anoMesReferenciaAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean obterIndicadorPagamentosClassificadosGuiaPagamentoReferenciaMenorIgualAtual(Integer idGuiaPagamento, Integer idImovel,
					Integer idDebitoTipo, Integer anoMesReferenciaAtual) throws ErroRepositorioException{

		boolean retorno;

		Collection colecaoRetorno1;
		// Collection colecaoRetorno2;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT MIN(pgmt.dataPagamento) " + "FROM Pagamento pgmt " + "INNER JOIN pgmt.guiaPagamentoGeral gpag "
							+ "WHERE (gpag.id = :idGuiaPagamento " + "AND pgmt.pagamentoSituacaoAtual.id = :idSituacaoAtual "
							+ "AND pgmt.anoMesReferenciaArrecadacao <= :anoMesReferenciaAtual) ";

			colecaoRetorno1 = session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento)
							.setInteger("idSituacaoAtual", PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
							.setInteger("anoMesReferenciaAtual", anoMesReferenciaAtual).list();

			// consulta = "SELECT MIN(pgmt.dataPagamento) "
			// + "FROM Pagamento pgmt "
			// + "INNER JOIN pgmt.guiaPagamento gpag "
			// + "INNER JOIN gpag.imovel imov "
			// + "WHERE pgmt.imovel.id= :idImovel and pgmt.debitoTipo.id =
			// :idDebitoTipo";
			//
			//
			// colecaoRetorno2 = session.createQuery(consulta)
			// .setInteger("idImovel", idImovel)
			// .setInteger("idDebitoTipo", idDebitoTipo)
			// .list();

			if(colecaoRetorno1 != null && !colecaoRetorno1.isEmpty()){
				retorno = true;
			}else{
				retorno = false;
				/*
				 * if(colecaoRetorno2 != null && !colecaoRetorno2.isEmpty()){
				 * retorno = true; }else{ retorno = false; }
				 */
			}
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém as contas de um imóvel com ano/mes da data de vencimento menor ou
	 * igual ao ano/mes de referencia da arrecadacao corrente e com situacao
	 * atual correspondente a normal, retificada ou incluida.
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Fernanda Paiva, Pedro Alexandre
	 * @date 24/04/2006,15/03/2007
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImovel(Integer imovel, Integer situacaoNormal, Integer situacaoIncluida, Integer situacaoRetificada,
					Date dataAnoMesReferenciaUltimoDia) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, ")
							.append("cnta.valorEsgoto, cnta.debitos, cnta.valorCreditos, cnta.indicadorCobrancaMulta ")
							.append("FROM Conta cnta ").append("INNER JOIN cnta.imovel imov ")
							.append("INNER JOIN cnta.debitoCreditoSituacaoAtual dcst ").append("WHERE imov.id = :idImovel AND ")
							.append("cnta.dataVencimentoConta <= :dataAnoMesReferenciaUltimoDia AND ")
							.append("cnta.dataRevisao is null AND ")
							.append("cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada)");

			retorno = session.createQuery(consulta.toString()).setInteger("idImovel", imovel).setInteger("normal", situacaoNormal)
							.setInteger("incluida", situacaoIncluida).setInteger("retificada", situacaoRetificada)
							.setDate("dataAnoMesReferenciaUltimoDia", dataAnoMesReferenciaUltimoDia).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Linha 63
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação igual a normal e o tipo de financiamento igual a
	 * doações.
	 * 
	 * @param anoMesReferencia
	 *            Ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            Código da localidade
	 * @param idCategoria
	 *            Código da categoria
	 * @return retorna o valor acumulado de acordo com os parâmetros informados
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoDoacoesSituacaoNormal(int anoMesReferencia,
					int idLocalidade, int idCategoria) throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacao "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacao ) "
							+ "and (dbcb.financiamentoTipo.id = :idFinanciamentoTipo ) "
							+ "group by cnta.referencia,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("idFinanciamentoTipo", FinanciamentoTipo.DOACOES).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * Recupera as contas do Conjunto de Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasImoveis(Integer anoMes, Collection idsImovel, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim, String inContasRevisao, Integer[] motivosRevisaoDisponiveis)
					throws ErroRepositorioException{

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			Collection idsDebitoCreditoSituacao = new ArrayList();
			idsDebitoCreditoSituacao.add(DebitoCreditoSituacao.NORMAL);
			idsDebitoCreditoSituacao.add(DebitoCreditoSituacao.INCLUIDA);
			idsDebitoCreditoSituacao.add(DebitoCreditoSituacao.RETIFICADA);

			List colecaoAuxiliar = new ArrayList();

			colecaoAuxiliar.addAll(idsImovel);

			int i = 0;
			int cont = 500;

			Collection colecao = new ArrayList();
			while(i <= idsImovel.size()){

				if(idsImovel.size() - i >= cont){
					colecao = colecaoAuxiliar.subList(i, i + cont);
				}else{
					colecao = colecaoAuxiliar.subList(i, idsImovel.size());
				}

				i = i + cont;

				consulta = "select count(cnta.id) " + "from Conta cnta " + "inner join cnta.imovel imov "
								+ "inner join cnta.debitoCreditoSituacaoAtual dcst ";

				if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())){
					consulta += "INNER JOIN cnta.contaMotivoRevisao cmr ";
				}else{
					consulta += "LEFT JOIN cnta.contaMotivoRevisao cmr ";
				}

				consulta += "where cnta.referencia BETWEEN :anoMes AND :anoMesFim " + "and imov.id in (:idsImovel) "
								+ "and dcst.id in(:idsDebitoCreditoSituacao)";

				if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())
								&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
					consulta += "AND cmr.id in (:motivosRevisaoDisponiveis) ";
				}else if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.NAO.toString())
								&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
					consulta += "AND (cmr.id in (:motivosRevisaoDisponiveis) or cmr.id is null) ";
				}

				if(dataVencimentoContaInicio != null){

					consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if(dataVencimentoContaFim != null){
						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = retorno
											+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
															.setInteger("anoMesFim", anoMesFim).setParameterList("idsImovel", colecao)
															.setParameterList("idsDebitoCreditoSituacao", idsDebitoCreditoSituacao)
															.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
															.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
															.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis)
															.uniqueResult()).intValue();

						}else{
							retorno = retorno
											+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
															.setInteger("anoMesFim", anoMesFim).setParameterList("idsImovel", colecao)
															.setParameterList("idsDebitoCreditoSituacao", idsDebitoCreditoSituacao)
															.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
															.setDate("dataVencimentoContaFim", dataVencimentoContaFim).uniqueResult())
															.intValue();
						}

					}else{
						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = retorno
											+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
															.setInteger("anoMesFim", anoMesFim).setParameterList("idsImovel", colecao)
															.setParameterList("idsDebitoCreditoSituacao", idsDebitoCreditoSituacao)
															.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
															.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
															.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis)
															.uniqueResult()).intValue();

						}else{
							retorno = retorno
											+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
															.setInteger("anoMesFim", anoMesFim).setParameterList("idsImovel", colecao)
															.setParameterList("idsDebitoCreditoSituacao", idsDebitoCreditoSituacao)
															.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
															.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).uniqueResult())
															.intValue();
						}
					}
				}else{

					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = retorno
										+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
														.setInteger("anoMesFim", anoMesFim).setParameterList("idsImovel", colecao)
														.setParameterList("idsDebitoCreditoSituacao", idsDebitoCreditoSituacao)
														.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis)
														.uniqueResult()).intValue();

					}else{
						retorno = retorno
										+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
														.setInteger("anoMesFim", anoMesFim).setParameterList("idsImovel", colecao)
														.setParameterList("idsDebitoCreditoSituacao", idsDebitoCreditoSituacao)
														.uniqueResult()).intValue();
					}

				}

			}
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas do Conjunto de Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImoveis(Integer anoMes, Collection idsImovel, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim, String inContasRevisao, Integer[] motivosRevisaoDisponiveis)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, cnta.valorEsgoto, "
							+ "cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
							+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, cnta.referenciaContabil, "
							+ "cnta.ultimaAlteracao, imov, dcsan, cnta.localidade, cnta.valorImposto " + "from Conta cnta "
							+ "inner join cnta.imovel imov " + "inner join cnta.debitoCreditoSituacaoAtual dcst "
							+ "left join cnta.debitoCreditoSituacaoAnterior dcsan ";

			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())){
				consulta += "INNER JOIN cnta.contaMotivoRevisao cmr ";
			}else{
				consulta += "LEFT JOIN cnta.contaMotivoRevisao cmr ";
			}

			consulta += "where cnta.referencia BETWEEN :anoMes AND :anoMesFim " + "and imov.id in (:idsImovel) "
							+ "and cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND cmr.id in (:motivosRevisaoDisponiveis) ";
			}else if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.NAO.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND (cmr.id in (:motivosRevisaoDisponiveis) or cmr.id is null) ";
			}

			Query query = null;

			if(dataVencimentoContaInicio != null){

				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				consulta += "ORDER BY cnta.referencia";

				if(dataVencimentoContaFim != null){

					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						query = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
										.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis);

					}else{
						query = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaFim);
					}

				}else{

					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						query = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
										.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis);

					}else{
						query = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaInicio);
					}

				}
			}else{
				consulta += "ORDER BY cnta.referencia";

				if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
					query = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis);

				}else{
					query = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA);
				}

			}

			// Realiza a consulta quebrando a clausula IN de imóveis a cada 1000 registros, quando
			// necessário
			if(idsImovel != null && idsImovel.size() > 1000){
				Collection colecaoAuxiliar = new ArrayList<Object>();
				retorno = new ArrayList<Object>();
				for(Object idImovel : idsImovel){
					colecaoAuxiliar.add(idImovel);
					if(colecaoAuxiliar.size() == 1000){
						retorno.addAll(query.setParameterList("idsImovel", colecaoAuxiliar).list());
						colecaoAuxiliar.clear();
					}
				}
				if(!colecaoAuxiliar.isEmpty()){
					retorno.addAll(query.setParameterList("idsImovel", colecaoAuxiliar).list());
				}
			}else{
				retorno = query.setParameterList("idsImovel", idsImovel).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * @param anoMes
	 * @param idCliente
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection gerarArquivoTextoFaturamento(int anoMes, Integer idCliente) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		try{
			String sql = "select conta.imov_id as idImovel," // 0
							+ " conta.cnta_amreferenciaconta as amReferencia," // 1
							+ " conta.cnta_vlagua as valorAgua," // 2
							+ " conta.cnta_vlesgoto as valorEsgoto," // 3
							+ " conta.cnta_vldebitos as valorDebitos," // 4
							+ " cnta_vlcreditos as valorCreditos," // 5
							+ " medicao.mdhi_dtleituraatualfaturamento as dataLeituraAtualFaturamento," // 6
							+ " medicao.mdhi_nnleituraatualfaturamento as leituraAtualFaturamento," // 7
							+ " conta.cnta_id as idConta," // 8
							+ " municipio.muni_nmmunicipio as nomeMunicipio," // 9
							+ " conta.cnta_nnconsumoagua as consumoAgua," // 10
							+ " conta.cnta_nnconsumoesgoto as consumoEsgoto," // 11
							+ " debitoCobrado.dbtp_id as idDebitoTipo," // 12
							+ " debitoCobrado.dbcb_vlprestacao as valorPrestacao," // 13
							+ " creditoRealizado.crti_id as idCreditoTipo," // 14
							+ " creditoRealizado.crrz_vlcredito as valorCredito," // 15
							+ " (select sum(cnid_vlimposto) from conta_impostos_deduzidos contaImposto "
							+ " where contaImposto.cnta_id = conta.cnta_id) as somaImpostos," // 16
							+ " conta.cnta_dtvencimentoconta as vencimentoConta"

							+ " from conta conta"

							+ "  left join medicao_historico medicao on medicao.lagu_id = conta.imov_id and medicao.mdhi_amleitura = :anoMes"
							+ " inner join cliente_imovel clienteImovel on clienteImovel.imov_id = conta.imov_id and crtp_id = :relacaoTipo and clim_dtrelacaofim is null"
							+ " inner join cliente cliente on cliente.clie_id = clienteImovel.clie_id"
							+ " inner join setor_comercial setorComercial on setor.loca_id = conta.loca_id and setor.stcm_cdsetorcomercial = conta.cnta_cdsetorcomercial"
							+ " left join municipio municipio on municipio.muni_id = setor.muni_id"
							+ " left join debito_cobrado debitoCobrado on debitoCobrado.cnta_id = conta.cnta_id"
							+ " left join credito_realizado creditoRealizado on creditoRealizado.cnta_id = conta.cnta_id"

							+ " where conta.cnta_amreferenciaconta = :anoMes and  "
							+ " conta.dcst_idatual in (0,1,2) "
							+ " and cliente.clie_id = :idCliente" + " and cliente.clie_icgeraarquivotexto = 1";

			retorno = session.createSQLQuery(sql).addScalar("idImovel", Hibernate.INTEGER)
			// 0
							.addScalar("amReferencia", Hibernate.INTEGER)
							// 1
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							// 2
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
							// 3
							.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
							// 4
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							// 5
							.addScalar("dataLeituraAtualFaturamento", Hibernate.DATE)
							// 6
							.addScalar("leituraAtualFaturamento", Hibernate.INTEGER)
							// 7
							.addScalar("idConta", Hibernate.INTEGER)
							// 8
							.addScalar("nomeMunicipio", Hibernate.STRING)
							// 9
							.addScalar("consumoAgua", Hibernate.INTEGER)
							// 10
							.addScalar("consumoEsgoto", Hibernate.INTEGER)
							// 11
							.addScalar("idDebitoTipo", Hibernate.INTEGER)
							// 12
							.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL)
							// 13
							.addScalar("idCreditoTipo", Hibernate.INTEGER)
							// 14
							.addScalar("valorCredito", Hibernate.BIG_DECIMAL)
							// 15
							.addScalar("somaImpostos", Hibernate.BIG_DECIMAL)
							// 16
							.addScalar("vencimentoConta", Hibernate.DATE)
							// 17
							.setInteger("anoMes", anoMes).setInteger("idCliente", idCliente)
							.setInteger("relacaoTipo", ClienteRelacaoTipo.RESPONSAVEL).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas do Conjunto de Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasImoveis(Integer anoMes, Collection idsImovel, Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
					Integer anoMesFim) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{ // 0 ,1
			consulta = "select cnta, imov " + "from Conta cnta " + "inner join cnta.imovel imov "
							+ "inner join fetch cnta.consumoTarifa cstf " + "inner join fetch cnta.quadraConta quad "
							+ "inner join fetch quad.setorComercial strc " + "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
							+ "and imov.id in (:idsImovel) " + "and cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if(dataVencimentoContaInicio != null){
				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if(dataVencimentoContaFim != null){

					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("idsImovel", idsImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
									.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();

				}else{

					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("idsImovel", idsImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
									.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();

				}
			}else{

				retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
								.setParameterList("idsImovel", idsImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o maior valor do sequêncial de impressão e soma 10 ao valor
	 * maximo retornado
	 * [UC0155] Encerrar Faturamento do Mês
	 * 
	 * @author Pedro
	 * @date 27/03/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Short recuperarValorMaximoSequencialImpressaoMais10() throws ErroRepositorioException{

		Short retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select max(lict.sequenciaImpressao)+10 " + "from LancamentoItemContabil lict ";

			// executa o hql
			retorno = ((Number) session.createQuery(consulta).uniqueResult()).shortValue();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void transferirContaParaHistorico(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		CallableStatement statement = null;
		try{
			String pTipoBancoDeDados = (String) ParametroGeral.P_TIPO_BANCO_DE_DADOS.executar();

			if(pTipoBancoDeDados.equals(ConstantesSistema.BANCO_ORACLE)){
				String call = "BEGIN ? := fun_gsan_trans_conta_hist(?); END;";
				statement = session.connection().prepareCall(call);
				statement.registerOutParameter(1, Types.NUMERIC);
				statement.setInt(2, idConta);
				statement.execute();
			}else if(pTipoBancoDeDados.equals(ConstantesSistema.BANCO_POSTGRESQL)){
				String call = "{? = call fun_gsan_trans_conta_hist(?)}";
				statement = session.connection().prepareCall(call);
				statement.registerOutParameter(1, Types.BIGINT);
				statement.setInt(2, idConta);
				statement.execute();
			}
		}catch(Exception e){
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(statement != null){
				try{
					statement.close();
				}catch(SQLException e){
					e.printStackTrace();
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * @author Saulo Lima
	 * @date 22/08/2012
	 *       Método criado para chamar a Function do Banco de Dados.
	 * @param pagamento
	 */
	public Object[] gerarDebitosACobrarDeAcrescimosPorImpontualidadeBancoDeDados(Pagamento pagamento, Date dataEmissaoDocumento)
					throws ErroRepositorioException{

		java.sql.Date dataEmissaoDocumentoSql = null;

		if(dataEmissaoDocumento != null){
			dataEmissaoDocumentoSql = new java.sql.Date(dataEmissaoDocumento.getTime());
		}

		Session session = HibernateUtil.getSession();
		CallableStatement statement = null;

		Object[] retorno = new Object[5];

		try{
			String pTipoBancoDeDados = (String) ParametroGeral.P_TIPO_BANCO_DE_DADOS.executar();

			if(pTipoBancoDeDados.equals(ConstantesSistema.BANCO_ORACLE)){
				String call = "BEGIN PCK_GSAN_DEBITO_COBRAR.gerarDebitosCobrarAcrImpont(?, ?, ?, ?, ?, ?, ?); END;";

				statement = session.connection().prepareCall(call);
				statement.setInt(1, pagamento.getId());
				statement.setDate(2, dataEmissaoDocumentoSql);
				statement.registerOutParameter(3, Types.INTEGER);
				statement.registerOutParameter(4, Types.INTEGER);
				statement.registerOutParameter(5, Types.INTEGER);
				statement.registerOutParameter(6, Types.INTEGER);
				statement.registerOutParameter(7, Types.VARCHAR);
				statement.execute();

				retorno[0] = statement.getObject(3);
				retorno[1] = statement.getObject(4);
				retorno[2] = statement.getObject(5);
				retorno[3] = statement.getObject(6);
				retorno[4] = statement.getObject(7);
			}else if(pTipoBancoDeDados.equals(ConstantesSistema.BANCO_POSTGRESQL)){
				retorno[0] = null;
				retorno[1] = null;
				retorno[2] = null;
				retorno[3] = null;
				retorno[4] = null;
			}
		}catch(Exception e){
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(statement != null){
				try{
					statement.close();
				}catch(SQLException e){
					e.printStackTrace();
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			}

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Remove o id da conta dos pagamentos referentes a conta para poder mandar
	 * a conta para o histórico.
	 * [UC0000] Gerar Histórco para encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 01/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void apagarIdContaPagamentos(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("UPDATE Pagamento ").append("SET conta = null ")
							.append("WHERE id in (select pgmt.id from Pagamento pgmt where pgmt.conta.id = :idConta) ");

			session.createQuery(consulta.toString()).setInteger("idConta", idConta).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Remove o id da Guia dos pagamentos referentes a Guia de Pagamento para poder mandar a Guia
	 * para o histórico.
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Saulo Lima
	 * @date 28/11/2008
	 * @author Saulo Lima
	 * @date 09/07/2009
	 *       Atualização para novo mapeamento Pagamento->GuiaPagamentoGeral
	 * @param idGuiaPagameno
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void apagarIdGuiaPagamentoPagamentos(Integer idGuiaPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "UPDATE Pagamento pag " + "SET pag.guiaPagamentoGeral = null, pag.numeroPrestacao = null "
							+ "WHERE pag.id IN (SELECT pgmt.id FROM Pagamento pgmt WHERE pgmt.guiaPagamentoGeral = :idGuiaPagamento)";

			session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Remove o id do débito a cobrar dos pagamentos referentes a conta para
	 * poder mandar o débito a cobrar para o histórico.
	 * [UC0000] Gerar Histórco para encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 01/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void apagarIdDebitoACobrarPagamentos(Integer idDebitoACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "UPDATE Pagamento " + "SET debitoACobrar = null "
							+ "WHERE id in (select pgmt.id from Pagamento pgmt where pgmt.debitoACobrar.id = :idDebitoACobrar) ";

			session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * Pesquisa as contas canceladas por localidade com paginação
	 * [UC0000] Gerar Historico para Encerrar Faturamento
	 * 
	 * @author Pedro Alexandre
	 * @date 03/04/2007
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param numeroIndice
	 * @param quantidadeRegistros
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContasCanceladasPorMesAnoReferenciaContabil(int anoMesReferenciaContabil, Integer idSetorComercial,
					Integer numeroIndice, Integer quantidadeRegistros) throws ErroRepositorioException{

		Collection<Conta> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cnta "
							+ "from Conta cnta "
							+ "inner join cnta.imovel imo "
							+ "where imo.setorComercial =:idSetorComercial "
							+ "and cnta.referenciaContabil <= :anoMesReferenciaContabil "
							+ "and ((cnta.debitoCreditoSituacaoAtual = :situacaoCancelada or cnta.debitoCreditoSituacaoAtual = :situacaoRetificacao or cnta.debitoCreditoSituacaoAtual = :situacaoParcelada or cnta.debitoCreditoSituacaoAtual = :situacaoDebitoPrescrito) "
							+ "or (cnta.valorAgua + cnta.valorEsgoto + cnta.debitos - cnta.valorCreditos - cnta.valorImposto = 0) )";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idSetorComercial", idSetorComercial)
							.setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("situacaoCancelada", DebitoCreditoSituacao.CANCELADA)
							.setInteger("situacaoRetificacao", DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)
							.setInteger("situacaoParcelada", DebitoCreditoSituacao.PARCELADA)
							.setInteger("situacaoDebitoPrescrito", DebitoCreditoSituacao.PRESCRITA).setMaxResults(quantidadeRegistros)
							.setFirstResult(numeroIndice).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] Emitir Aviso de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @date 09/04/2007
	 */
	public Object[] pesquisarAnoMesEDiaVencimentoFaturamentoGrupo(Integer idImovel) throws ErroRepositorioException{

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT fatGrupo.anoMesReferencia,fatGrupo.diaVencimento " + "FROM Imovel imov " + "INNER JOIN imov.quadra qdr "
							+ "INNER JOIN qdr.rota rota " + "INNER JOIN rota.faturamentoGrupo fatGrupo " + "WHERE imov.id = :idImovel ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * retorna o nome do cliente usuario da conta
	 * 
	 * @author Flávio Cordeiro
	 * @date 09/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String pesquisarClienteUsuarioConta(Integer idConta) throws ErroRepositorioException{

		String retorno = "";

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cliente.clie_nmcliente as nome " + "from cliente_conta clienteConta "
							+ "inner join cliente cliente on cliente.clie_id = clienteConta.clie_id "
							+ "where clienteConta.cnta_id =:idConta " + "and clienteConta.crtp_id =:relacaoTipo ";

			// executa o hql
			retorno = (String) session.createSQLQuery(consulta).addScalar("nome", Hibernate.STRING).setInteger("idConta", idConta)
							.setInteger("relacaoTipo", ClienteRelacaoTipo.USUARIO).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorMultasCobradasPorFinanciamnetoTipo(int idConta, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuffer consulta = new StringBuffer();

		try{
			// constroi o hql
			consulta.append("select sum(dbcb.valorPrestacao) ").append("from DebitoCobrado dbcb ").append("inner join dbcb.conta cnta ")
							.append("inner join dbcb.financiamentoTipo fntp ").append("where cnta.id = :idConta ")
							.append("and fntp.id in (:tiposParcelamento)");

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta)
							.setParameterList("tiposParcelamento", tiposParcelamento).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso calcula a tarifa miníma de água para um imóvel
	 * (SUBCATEGORIA)
	 * [UC0451] Obter Tarifa Miníma de Água para um Imóvel
	 * 
	 * @author Raphael Rossiter
	 * @date 14/04/2007
	 * @param consumoTarifaVigencia
	 * @param subcategoria
	 * @return Object
	 * @throws ErroRepositorioException
	 */
	public Object pesquisarTarifaMinimaCategoriaVigenciaPorSubcategoria(ConsumoTarifaVigencia consumoTarifaVigencia,
					Subcategoria subcategoria) throws ErroRepositorioException{

		Object retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select ct.valorTarifaMinima " + "from ConsumoTarifaCategoria ct "
							+ "inner join ct.consumoTarifaVigencia ctv " + "inner join ct.subCategoria sc "
							+ "where ctv.id = :consumoTarifaVigenciaId " + "and sc.id = :subcategoriaId";

			retorno = session.createQuery(consulta).setInteger("consumoTarifaVigenciaId", consumoTarifaVigencia.getId())
							.setInteger("subcategoriaId", subcategoria.getId()).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês pesquisar debitos cobrados de
	 * contas
	 * 
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoCobrado> pesquisarDebitosCobrados(Integer idConta) throws ErroRepositorioException{

		Collection<DebitoCobrado> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select dbcb " + "from DebitoCobrado dbcb " + "inner join dbcb.conta cnta " + "where cnta.id = :idConta ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês pesquisar debitos cobrados de
	 * contas
	 * 
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoCobradoHistorico> pesquisarDebitosCobradosHistorico(Integer idConta) throws ErroRepositorioException{

		Collection<DebitoCobradoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select debitoCobradoHistorico " + "from DebitoCobradoHistorico debitoCobradoHistorico "
							+ " inner join fetch debitoCobradoHistorico.debitoTipo "
							+ " inner join fetch debitoCobradoHistorico.lancamentoItemContabil "
							+ "where debitoCobradoHistorico.contaHistorico.id = :idConta ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * pesquisa debito a cobrar historico pelo id da conta historico
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CreditoRealizadoHistorico> pesquisarCreditosRealizadosHistorico(Integer idConta) throws ErroRepositorioException{

		Collection<CreditoRealizadoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "SELECT creditoRealizadoHistorico " + "FROM CreditoRealizadoHistorico creditoRealizadoHistorico "
							+ "JOIN FETCH creditoRealizadoHistorico.creditoTipo "
							+ "JOIN FETCH creditoRealizadoHistorico.lancamentoItemContabil "
							+ "WHERE creditoRealizadoHistorico.contaHistorico.id = :idConta ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês pesquisar DebitoACobrarHistorico
	 * 
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<DebitoACobrarHistorico> pesquisarDebitosACobrarHistorico(ParcelamentoItem parcelamentoItem)
					throws ErroRepositorioException{

		Collection<DebitoACobrarHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select debitoACobrarHistorico " + "from DebitoACobrarHistorico debitoACobrarHistorico "

			+ "where debitoACobrarHistorico.parcelamento.id = :idParcelamento ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idParcelamento", parcelamentoItem.getParcelamento().getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês Pesquisar créditos realizados de
	 * contas canceladas
	 * 
	 * @param idConta
	 *            Código da conta
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Collection<CreditoRealizado> pesquisarCreditosRealizados(Integer idConta) throws ErroRepositorioException{

		Collection<CreditoRealizado> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select crrz " + "from CreditoRealizado crrz "

			+ "inner join fetch crrz.conta cnta "

			+ "inner join fetch cnta.imovel imov "

			+ "inner join fetch imov.setorComercial stcm "

			+ "inner join fetch imov.quadra qdra "

			+ "where cnta.id = :idConta ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0004] Verificar Critério
	 * de Cobrança para Imóvel Pesquisa a soma dos imoveis com parcelamento.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarQuantidadeDebitosCobradosComParcelamento(Collection<ContaValoresHelper> colecaoContasValores,
					Collection<Integer> tiposParcelamento) throws ErroRepositorioException{

		// cria a variável que vai armazenar o valor pesquisado
		int retorno = 0;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuffer consulta = new StringBuffer();

		try{
			Collection idsContas = new ArrayList();
			if(colecaoContasValores != null && !colecaoContasValores.isEmpty()){
				Iterator iteContaValoresHelper = colecaoContasValores.iterator();
				while(iteContaValoresHelper.hasNext()){
					ContaValoresHelper contaValoresHelper = (ContaValoresHelper) iteContaValoresHelper.next();
					if(contaValoresHelper.getConta() != null){
						idsContas.add(contaValoresHelper.getConta().getId());
					}
				}
			}

			// constroi o hql
			consulta.append("select count(distinct cnta.id) ").append(" from DebitoCobrado dbcb ").append("  inner join dbcb.conta cnta ")
							.append("  inner join dbcb.financiamentoTipo fntp ").append("where cnta.id in (:idsConta) ")
							.append("  and fntp.id in (:tiposParcelamento)");

			// executa o hql
			retorno = ((Number) session.createQuery(consulta.toString()).setParameterList("idsConta", idsContas)
							.setParameterList("tiposParcelamento", tiposParcelamento).uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os ids das contas do Conjunto de Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/04/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdContasImoveis(Integer anoMes, Collection idsImovel, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cnta.id " + "from Conta cnta " + "inner join cnta.imovel imov "
							+ "inner join cnta.debitoCreditoSituacaoAtual dcst " + "where cnta.referencia BETWEEN :anoMes AND :anoMesFim "
							+ "and imov.id in (:idsImovel) " + "and cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if(dataVencimentoContaInicio != null){
				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if(dataVencimentoContaFim != null){

					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("idsImovel", idsImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
									.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();

				}else{

					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("idsImovel", idsImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
									.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();

				}
			}else{

				retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
								.setParameterList("idsImovel", idsImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 25/04/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualConta(Integer idConta) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select dcst.id " + "from Conta cnta " + "inner join cnta.debitoCreditoSituacaoAtual dcst "
							+ "where cnta.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 10/08/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualConta(Integer idImovel, Integer anoMesReferencia) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select dcst.id " + "from Conta cnta " + "inner join cnta.imovel imov "
							+ "inner join cnta.debitoCreditoSituacaoAtual dcst "
							+ "where imov.id = :idImovel AND cnta.referencia = :anoMesReferencia ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * [UC0348] Emitir Contas
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 28/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaFaixas(Integer idConta, Integer idCategoria, Integer idSubCategoria)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaCategoriaConsumoFaixa " + "from ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa "
							+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.conta conta "
							+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.categoria categoria "
							+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.subcategoria subCategoria "
							+ "where conta.id = :idConta AND " + "categoria.id = :idCategoria AND " + "subCategoria.id = :idSubCategoria "
							+ "order by contaCategoriaConsumoFaixa.consumoFaixaInicio";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setInteger("idCategoria", idCategoria.intValue()).setInteger("idSubCategoria", idSubCategoria).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 02/05/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaSubCategoria(Integer idConta) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select contaCategoria " + "from ContaCategoria contaCategoria " + "inner join contaCategoria.comp_id.conta conta "
							+ "inner join fetch contaCategoria.comp_id.categoria categoria "
							+ "inner join fetch contaCategoria.comp_id.subcategoria subCategoria " + "where conta.id = :idConta "
							+ "order by categoria.id ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta).setInteger("idConta", idConta).list()));

			/**
			 * alterado por pedro alexandre dia 23/01/2007
			 */
			/*
			 * consulta = "select contaCategoria " + "from ContaCategoria
			 * contaCategoria " + "inner join contaCategoria.comp_id.conta conta " +
			 * "inner join contaCategoria.comp_id.categoria categoria " + "where
			 * conta.id = :idConta " + "order by categoria.id";
			 * Iterator iterator = session.createQuery(consulta).setInteger(
			 * "idConta", idConta.intValue()).iterate();
			 * while (iterator.hasNext()) { ContaCategoria contaCategoria =
			 * (ContaCategoria) iterator .next(); // carrega todos os objetos
			 * Hibernate
			 * .initialize(contaCategoria.getComp_id().getCategoria());
			 * retorno.add(contaCategoria); }
			 */
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id da Conta Retificada
	 * 
	 * @author Vivianne Sousa
	 * @date 27/04/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarContaRetificada(Integer idImovel, int anoMesReferenciaConta) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cnta.id " + "from Conta cnta " + "inner join cnta.debitoCreditoSituacaoAtual dcst "
							+ "where cnta.imovel.id = :idImovel  " + "and cnta.referencia = :anoMesReferenciaConta "
							+ "and dcst.id = :debitoCreditoSituacao ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferenciaConta", anoMesReferenciaConta)
							.setInteger("debitoCreditoSituacao", DebitoCreditoSituacao.RETIFICADA).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gera credito a realizar para os imóveis de determinados grupos
	 * BATCH PARA CORREÇÃO DA BASE
	 * 
	 * @author Sávio Luiz
	 * @date 02/05/2007
	 */
	public Collection pesquisarDadosImoveisParaGerarCreditoARealizar(Collection idsGrupos, Integer anoMesReferenciaConta,
					Integer anoMesReferenciaDebito) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select imov.id,"// 0 - Integer
							+ "loc.id,"// 1 - Integer
							+ "qdrImovel.id,"// 2 - Integer
							+ "qdrImovel.numeroQuadra,"// 3 - Integer
							+ "setComercial.codigo,"// 4 - Integer
							+ "imov.lote,"// 5 - Short
							+ "imov.subLote,"// 6 - Short
							+ "debCobrado.valorPrestacao "// 7 - BigDecimal
							+ "from DebitoCobrado debCobrado "
							+ "inner join debCobrado.conta cnta "
							+ "inner join cnta.imovel imov "
							+ "inner join imov.localidade loc "
							+ "inner join imov.quadra qdrImovel "
							+ "inner join imov.setorComercial setComercial "
							+ "inner join cnta.quadraConta qdrConta "
							+ "inner join qdrConta.rota rot "
							+ "inner join rot.faturamentoGrupo ftgr "
							+ "inner join debCobrado.debitoTipo debTipo "
							+ "inner join cnta.debitoCreditoSituacaoAtual debCerdSitAtual "
							+ "where cnta.referencia = :anoMesReferenciaConta  "
							+ "and ftgr.id = 29"// in (:idsGrupos) "
							+ "and debTipo.id = :idDebitoTipo "
							+ "and debCobrado.anoMesReferenciaDebito = :anoMesReferenciaDebito "
							+ "and debCerdSitAtual.id = :idDebCerdSitAtual and "
							+ "cnta.id in (select pag.conta.id "
							+ "from Pagamento pag "
							+ "where pag.conta.id = cnta.id and "
							+ "pag.dataPagamento <= (cnta.dataVencimentoConta + 3))";

			retorno = session.createQuery(consulta)
							.setInteger("anoMesReferenciaConta", anoMesReferenciaConta)
			// .setParameterList("idsGrupos", idsGrupos)
							.setInteger("idDebitoTipo", DebitoTipo.MULTA_IMPONTUALIDADE)
							.setInteger("anoMesReferenciaDebito", anoMesReferenciaDebito)
							.setInteger("idDebCerdSitAtual", DebitoCreditoSituacao.NORMAL).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Recupera o id da Conta Retificada
	 * 
	 * @author Vivianne Sousa
	 * @date 08/05/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarAnoMesReferenciaFaturamentoGrupo(Integer idImovel) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select faturamentoGrupo.anoMesReferencia " + "from Imovel imovel " + "left join imovel.rota rota "
							+ "left join rota.faturamentoGrupo faturamentoGrupo " + "where imovel.id = :idImovel ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * Pesquisas os debitos para serem removidos
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * @param colecaoRotas
	 *            ,
	 *            Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarParaRemocao(Collection colecaoRotas, Integer anoMesReferenciaContabil)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;

		try{
			Collection idsRotas = new ArrayList();
			if(colecaoRotas != null && !colecaoRotas.isEmpty()){

				Iterator iteRotas = colecaoRotas.iterator();
				while(iteRotas.hasNext()){
					Rota rota = (Rota) iteRotas.next();
					idsRotas.add(rota);
				}
			}
			consulta = "select dc.id " + "from DebitoACobrar dc,ImovelDoacao imovDoacao " + "inner join dc.imovel imov "
							+ "inner join imov.quadra qdr " + "inner join qdr.rota rot " + "inner join imovDoacao.imovel imovD "
							+ "inner join imovDoacao.entidadeBeneficente entBenef " + "inner join entBenef.debitoTipo debTipoEntBef "
							+ "inner join dc.debitoTipo debTipoACob " + "where rot.id in (:idsRotas) and "
							+ "dc.anoMesReferenciaContabil = :anoMesReferenciaContabil and "
							+ "debTipoEntBef.id = debTipoACob.id and imov.id = imovD.id ";

			retorno = session.createQuery(consulta).setParameterList("idsRotas", idsRotas)
							.setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] - Gerar Relatório de Tarifa de Consumo
	 * Pesquisas a data final de validade de uma tarifa de consumo
	 * 
	 * @author Rafael Corrêa
	 * @date 11/05/2007
	 * @param Integer
	 *            idConsumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarDataFinalValidadeConsumoTarifa(Integer idConsumoTarifa, Date dataInicioVigencia) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta;
		Date retorno = null;
		try{
			consulta = "select ctv.dataVigencia " + " from ConsumoTarifaVigencia ctv " + " where ctv.consumoTarifa.id = :idConsumoTarifa "
							+ " and ctv.dataVigencia > :dataInicioVigencia " + " order by ctv.dataVigencia";

			retorno = (Date) session.createQuery(consulta).setInteger("idConsumoTarifa", idConsumoTarifa)
							.setDate("dataInicioVigencia", dataInicioVigencia).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] - Gerar Relatório Tarifa de Consumo
	 * Pesquisas as tarifas de consumo para o relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 11/05/2007
	 * @param descricao
	 *            ,
	 *            dataVigenciaInicial, dataVigenciaFinal
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConsumoTarifaRelatorio(String descricao, Date dataVigenciaInicial, Date dataVigenciaFinal,
					String descricaoAtoAdministrativo) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta;
		Collection retorno = null;

		try{

			consulta = "SELECT ct.cstf_id as idConsumoTarifa, ct.cstf_dsconsumotarifa as descricaoConsumoTarifa, " // 0,
			// 1
							+ " ctg.catg_dscategoria as categoria, ctf.ctfx_nncosumofaixainicio as faixaInicial, " // 2,
							// 3
							+ " ctf.ctfx_nnconsumofaixafim as faixaFinal, ctf.ctfx_vlconsumotarifa as custo, " // 4,
							// 5
							+ " ctc.cstc_vltarifaminima as tarifaMinima, ctv.cstv_dtvigencia as dataVigencia, " // 6,
							// 7
							+ " ctc.cstc_nnconsumominimo as consumoMinimo " // 8
							+ " FROM consumo_tarifa ct "
							+ " INNER JOIN consumo_tarifa_vigencia ctv on ctv.cstf_id = ct.cstf_id "
							+ " INNER JOIN consumo_tarifa_categoria ctc on ctc.cstv_id = ctv.cstv_id "
							+ " INNER JOIN categoria ctg on ctc.catg_id = ctg.catg_id "
							+ " INNER JOIN consumo_tarifa_faixa ctf on ctf.cstc_id = ctc.cstc_id " + " WHERE ";

			if(descricao != null && !descricao.trim().equals("")){
				consulta = consulta + "ct.cstf_dsconsumotarifa LIKE '" + descricao + "%' and ";
			}

			if(dataVigenciaInicial != null && dataVigenciaFinal != null){
				consulta = consulta + " ctv.cstv_dtvigencia between :dataVigenciaInicial and :dataVigenciaFinal and ";
			}else if(dataVigenciaInicial != null){
				consulta = consulta + " ctv.cstv_dtvigencia >= :dataVigenciaInicial and ";
			}else if(dataVigenciaFinal != null){
				consulta = consulta + " ctv.cstv_dtvigencia <= :dataVigenciaFinal and ";
			}

			if(descricaoAtoAdministrativo != null && !descricaoAtoAdministrativo.trim().equals("")){

				consulta = consulta + "ctv.cstv_dsatoadministrativo LIKE '" + descricaoAtoAdministrativo + "%' and ";
			}

			consulta = Util.formatarHQL(consulta, 4);

			consulta = consulta + " ORDER BY ct.cstf_dsconsumotarifa, ctv.cstv_dtvigencia, ctc.cstc_id, ctf.ctfx_nncosumofaixainicio ";

			SQLQuery sqlQuery = session.createSQLQuery(consulta);

			sqlQuery.addScalar("idConsumoTarifa", Hibernate.INTEGER);
			sqlQuery.addScalar("descricaoConsumoTarifa", Hibernate.STRING);
			sqlQuery.addScalar("categoria", Hibernate.STRING);
			sqlQuery.addScalar("faixaInicial", Hibernate.INTEGER);
			sqlQuery.addScalar("faixaFinal", Hibernate.INTEGER);
			sqlQuery.addScalar("custo", Hibernate.BIG_DECIMAL);
			sqlQuery.addScalar("tarifaMinima", Hibernate.BIG_DECIMAL);
			sqlQuery.addScalar("dataVigencia", Hibernate.DATE);
			sqlQuery.addScalar("consumoMinimo", Hibernate.INTEGER);

			if(dataVigenciaInicial != null){
				sqlQuery.setDate("dataVigenciaInicial", dataVigenciaInicial);
			}

			if(dataVigenciaFinal != null){
				sqlQuery.setDate("dataVigenciaFinal", dataVigenciaFinal);
			}

			retorno = sqlQuery.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * Deleta as categorias do débito a cobrar
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * @param colecaoRotas
	 *            ,
	 *            Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDebitosACobrarCategoria(Collection idsDebitoACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete DebitoACobrarCategoria dcc " + "where dcc.debitoACobrar.id in (:idsDebitoACobrar) ";

			session.createQuery(delete).setParameterList("idsDebitoACobrar", idsDebitoACobrar).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0394] - Gerar Débitos a Cobrar de Doações
	 * Deleta os debitos a cobrar e os debitos a cobrar geral para o ano e mes
	 * de faturamento. Esse caso é quando um faturamento é rodado mais de 1 vez.
	 * 
	 * @author Sávio Luiz
	 * @date 09/05/2007
	 * @param colecaoRotas
	 *            ,
	 *            Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDebitosACobrar(Collection idsDebitoACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete DebitoACobrar dc " + "where dc.id in (:idsDebitoACobrar) ";

			session.createQuery(delete).setParameterList("idsDebitoACobrar", idsDebitoACobrar).executeUpdate();

			delete = "delete DebitoACobrarGeral dcg " + "where dcg.id in (:idsDebitoACobrar) ";

			session.createQuery(delete).setParameterList("idsDebitoACobrar", idsDebitoACobrar).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera id de contas que estão em revisão por acão do usuario
	 * 
	 * @author Vivianne Sousa
	 * @date 14/05/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasEmRevisaoPorAcaoUsuario(Collection idsConta) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		Query query = null;

		try{
			consulta = "select cnta " + "from Conta cnta " + "left join cnta.contaMotivoRevisao contaMotivoRevisao "
							+ "where cnta.id in (:idsConta) " + "and contaMotivoRevisao.id <> :revisaoAutomaticaEstouroConsumo "
							+ "and contaMotivoRevisao.id <> :revisaoAutomaticaBaixoConsumo ";

			query = session.createQuery(consulta)
							.setInteger("revisaoAutomaticaEstouroConsumo", ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO)
							.setInteger("revisaoAutomaticaBaixoConsumo", ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO);

			// Realiza a consulta quebrando a clausula IN de contas a cada 1000 registros, quando
			// necessário
			if(idsConta != null && idsConta.size() > 1000){

				Collection colecaoAuxiliar = new ArrayList<Object>();
				retorno = new ArrayList<Object>();

				for(Object idConta : idsConta){

					colecaoAuxiliar.add(idConta);

					if(colecaoAuxiliar.size() == 1000){

						retorno.addAll(query.setParameterList("idsConta", colecaoAuxiliar).list());
						colecaoAuxiliar.clear();
					}
				}

				if(!colecaoAuxiliar.isEmpty()){

					retorno.addAll(query.setParameterList("idsConta", colecaoAuxiliar).list());
				}
			}else{

				retorno = query.setParameterList("idsConta", idsConta).list();
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas do Cliente
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasCliente(Integer codigoCliente, Integer relacaoTipo, Integer anoMes,
					Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Integer anoMesFim, String inContasRevisao,
					Integer[] motivosRevisaoDisponiveis) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select count(distinct conta.id) from ClienteConta clienteConta " + "inner join clienteConta.cliente cliente "
							+ "inner join clienteConta.conta conta " + "inner join conta.debitoCreditoSituacaoAtual dcst ";

			if(relacaoTipo != null){
				consulta = consulta + " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}
			
			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())){
				consulta += "INNER JOIN conta.contaMotivoRevisao cmr ";
			}else{
				consulta += "LEFT JOIN conta.contaMotivoRevisao cmr ";
			}
						
			consulta = consulta + "where cliente.id = :codigo " + "and conta.referencia BETWEEN :anoMes AND :anoMesFim "
							+ "and dcst.id in(:normal, :incluida, :retificada) ";

			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND cmr.id in (:motivosRevisaoDisponiveis) ";
			}else if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.NAO.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND (cmr.id in (:motivosRevisaoDisponiveis) or cmr.id is null) ";
			}
			
			if(relacaoTipo != null){
				consulta = consulta + " and clienteRelacaoTipo.id = :relacao ";

				if(dataVencimentoContaInicio != null){
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					consulta += "ORDER BY conta.referencia";
					
					if(dataVencimentoContaFim != null){
						
						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
											.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).uniqueResult())
											.intValue();
							
						}else{
							retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaFim).uniqueResult()).intValue();
						}
						
					}else{
						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
											.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).uniqueResult())
											.intValue();
							
						}else{
							retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).uniqueResult()).intValue();
						}
					}
				}else{
					consulta += "ORDER BY conta.referencia";

					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente).setInteger("anoMes", anoMes)
										.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
										.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).uniqueResult())
										.intValue();
						
					}else{
						retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente).setInteger("anoMes", anoMes)
										.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
										.uniqueResult()).intValue();
					}
				}
			}

			if(relacaoTipo == null){

				if(dataVencimentoContaInicio != null){
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					consulta += "ORDER BY conta.referencia";
					
					if(dataVencimentoContaFim != null){
						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
											.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).uniqueResult())
											.intValue();
							
						}else{
							retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaFim).uniqueResult()).intValue();
						}

					}else{
						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
											.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).uniqueResult())
											.intValue();
							
						}else{
							retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).uniqueResult()).intValue();
						}
					}
				}else{
					consulta += "ORDER BY conta.referencia";

					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente).setInteger("anoMes", anoMes)
										.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).uniqueResult())
										.intValue();

					}else{
						retorno = ((Number) session.createQuery(consulta).setInteger("codigo", codigoCliente).setInteger("anoMes", anoMes)
										.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).uniqueResult()).intValue();
					}
				}
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Recupera as contas do Cliente
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @autor isilva
	 * @date 01/01/2011
	 *       Retornar também a localidade
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasCliente(Integer codigoCliente, Integer relacaoTipo, Integer anoMes, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim, String inContasRevisao, Integer[] motivosRevisaoDisponiveis)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select conta.id, conta.referencia, conta.dataVencimentoConta, conta.valorAgua, conta.valorEsgoto, "
							+ "conta.debitos, conta.valorCreditos, conta.consumoAgua, conta.consumoEsgoto, "
							+ "conta.dataValidadeConta, conta.dataRevisao, conta.debitoCreditoSituacaoAtual, conta.referenciaContabil, "
							+ "conta.ultimaAlteracao, imov, dcsan, loca.id, conta.valorImposto, conta.indicadorExecucaoFiscal "
							+ "from ClienteConta clienteConta " + "inner join clienteConta.cliente cliente "
							+ "inner join clienteConta.conta conta " + "inner join conta.imovel imov "
							+ "inner join conta.debitoCreditoSituacaoAtual dcst " + "left join conta.debitoCreditoSituacaoAnterior dcsan "
							+ "inner join conta.localidade loca ";

			if(relacaoTipo != null){
				consulta = consulta + " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())){
				consulta += "INNER JOIN conta.contaMotivoRevisao cmr ";
			}else{
				consulta += "LEFT JOIN conta.contaMotivoRevisao cmr ";
			}

			consulta = consulta + "where cliente.id = :codigo " + "and conta.referencia BETWEEN :anoMes AND :anoMesFim "
							+ "and dcst.id in(:normal, :incluida, :retificada) ";

			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND cmr.id in (:motivosRevisaoDisponiveis) ";
			}else if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.NAO.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND (cmr.id in (:motivosRevisaoDisponiveis) or cmr.id is null) ";
			}

			if(relacaoTipo != null){
				consulta = consulta + " and clienteRelacaoTipo.id = :relacao ";

				if(dataVencimentoContaInicio != null){
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					consulta += "ORDER BY conta.referencia";

					if(dataVencimentoContaFim != null){

						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
											.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();
						}else{
							retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();
						}
					}else{
						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
											.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();

						}else{
							retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();
						}
					}
				}else{

					consulta += "ORDER BY conta.referencia";

					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
										.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();
					}else{
						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
										.list();
					}
				}

			}

			if(relacaoTipo == null){

				if(dataVencimentoContaInicio != null){
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					consulta += "ORDER BY conta.referencia";

					if(dataVencimentoContaFim != null){

						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
											.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();

						}else{
							retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();
						}
					}

					else{
						if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
							retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
											.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();

						}else{
							retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
											.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
											.setInteger("normal", DebitoCreditoSituacao.NORMAL)
											.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
											.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
											.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
											.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();
						}

					}
				}else{
					consulta += "ORDER BY conta.referencia";

					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();

					}else{
						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();
					}

				}
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Recupera as contas do Cliente
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasCliente(Integer codigoCliente, Integer relacaoTipo, Integer anoMes, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select conta, imov " + "from ClienteConta clienteConta " + "inner join clienteConta.cliente cliente "
							+ "inner join clienteConta.conta conta " + "inner join fetch conta.consumoTarifa cstf "
							+ "inner join fetch conta.quadraConta quad " + "inner join fetch quad.setorComercial strc "
							+ "inner join conta.imovel imov " + "inner join conta.debitoCreditoSituacaoAtual dcst "
							+ "left join conta.debitoCreditoSituacaoAnterior dcsan ";

			if(relacaoTipo != null){
				consulta = consulta + " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo " + "and conta.referencia BETWEEN :anoMes AND :anoMesFim "
							+ "and dcst.id in(:normal, :incluida, :retificada) ";

			if(relacaoTipo != null){
				consulta = consulta + " and clienteRelacaoTipo.id = :relacao ";

				if(dataVencimentoContaInicio != null){
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if(dataVencimentoContaFim != null){

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();

					}else{

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();

					}
				}else{

					retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente).setInteger("anoMes", anoMes)
									.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo).list();
				}
			}

			if(relacaoTipo == null){

				if(dataVencimentoContaInicio != null){
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if(dataVencimentoContaFim != null){

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();

					}else{

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();

					}
				}else{

					retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente).setInteger("anoMes", anoMes)
									.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();
				}

			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas do Cliente
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdContasCliente(Integer codigoCliente, Integer relacaoTipo, Integer anoMes, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select distinct conta.id from ClienteConta clienteConta " + "inner join clienteConta.cliente cliente "
							+ "inner join clienteConta.conta conta " + "inner join conta.debitoCreditoSituacaoAtual dcst ";

			if(relacaoTipo != null){
				consulta = consulta + " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo " + "and conta.referencia BETWEEN :anoMes AND :anoMesFim "
							+ "and dcst.id in(:normal, :incluida, :retificada) ";

			if(relacaoTipo != null){
				consulta = consulta + " and clienteRelacaoTipo.id = :relacao ";

				if(dataVencimentoContaInicio != null){
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if(dataVencimentoContaFim != null){

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();

					}else{

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();

					}
				}else{

					retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente).setInteger("anoMes", anoMes)
									.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).setInteger("relacao", relacaoTipo).list();
				}

			}
			if(relacaoTipo == null){

				if(dataVencimentoContaInicio != null){
					consulta += " and conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

					if(dataVencimentoContaFim != null){

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();

					}else{

						retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente)
										.setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();

					}
				}else{

					retorno = (Collection) session.createQuery(consulta).setInteger("codigo", codigoCliente).setInteger("anoMes", anoMes)
									.setInteger("anoMesFim", anoMesFim).setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();
				}

			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Recupera id de conta(s) sem revisão ou em revisão por ação do usuário
	 * 
	 * @author Vivianne Sousa
	 * @date 14/05/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasNaoEmRevisaoOuEmRevisaoPorAcaoUsuario(Collection idsConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cnta.id " + "from Conta cnta " + "left join cnta.contaMotivoRevisao contaMotivoRevisao "
							+ "where cnta.id in (:idsConta) " + "and (cnta.dataRevisao is not null "
							+ "or(contaMotivoRevisao.id <> :revisaoAutomaticaEstouroConsumo "
							+ "and contaMotivoRevisao.id <> :revisaoAutomaticaBaixoConsumo)) ";

			retorno = session.createQuery(consulta).setParameterList("idsConta", idsConta)
							.setInteger("revisaoAutomaticaEstouroConsumo", ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO)
							.setInteger("revisaoAutomaticaBaixoConsumo", ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os dados da conta historico p emitir a 2ª via [UC0482]Emitir 2ª
	 * Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaHistorico(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT " + " new " + EmitirContaHelper.class.getName() + " ( " + "cntHist.id, " + "cli.nome, "
							+ "cntHist.dataVencimentoConta, " + "cntHist.anoMesReferenciaConta, " + "cntHist.verificadorConta, "
							+ "cntHist.setorComercial, " + "cntHist.numeroQuadra, " + "cntHist.lote, " + "cntHist.sublote, "
							+ "cntHist.consumoAgua, " + "cntHist.consumoEsgoto, " + "cntHist.valorAgua, " + "cntHist.valorEsgoto, "
							+ "cntHist.valorDebitos, " + "cntHist.valorCreditos, " + "cntHist.valorImposto, "
							+ "cntHist.dataValidadeConta, " + "imovel.id, " + "loc.id, " + "gerenciaRegional.id, "
							+ "gerenciaRegional.nome, " + "ligacaoAguaSituacao.id, " + "ligacaoEsgotoSituacao.id, " + "imovelPerfil.id, "
							+ "setorComercial.id, " + "faturamentoGrupo.id, " + "emp.id, " + "loc.descricao, "
							+ "ligacaoAguaSituacao.descricao, " + "ligacaoEsgotoSituacao.descricao, " + "imovelContaEnvio.id, "
							+ "cntHist.percentualEsgoto, " + "imovel.nomeImovel ," + " cntHist.debitoCreditoSituacaoAtual.id, "
							+ "cmret.id, " + "funcionario.id, cmret.descricaoMotivoRetificacaoConta " + "  ) "
							+ "from ClienteContaHistorico cliCntHist " + "RIGHT JOIN cliCntHist.contaHistorico cntHist "
							+ "LEFT JOIN cliCntHist.clienteRelacaoTipo crt " + "LEFT JOIN cliCntHist.cliente cli "
							+ "LEFT JOIN cntHist.contaMotivoRevisao cmr " + "LEFT JOIN cntHist.quadra quadraConta "
							+ "LEFT JOIN cntHist.localidade loc " + "LEFT JOIN loc.gerenciaRegional gerenciaRegional "
							+ "LEFT JOIN cntHist.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "LEFT JOIN cntHist.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
							+ "LEFT JOIN cntHist.imovelPerfil imovelPerfil " + "LEFT JOIN quadraConta.rota rota "
							+ "LEFT JOIN rota.empresa emp " + "LEFT JOIN quadraConta.setorComercial setorComercial "
							+ "LEFT JOIN rota.faturamentoGrupo faturamentoGrupo " + "LEFT JOIN cntHist.imovel imovel "
							+ "LEFT JOIN imovel.imovelContaEnvio imovelContaEnvio " + "LEFT JOIN cntHist.usuario usuario "
							+ "LEFT JOIN cntHist.contaMotivoRetificacao cmret " + "LEFT JOIN usuario.funcionario funcionario "
							+ "WHERE  cntHist.id = :idConta " + "AND crt.id = :usuario "
							+ "ORDER BY cntHist.anoMesReferenciaConta,emp.id,loc.id,cntHist.setorComercial,"
							+ "cntHist.numeroQuadra,cntHist.lote,cntHist.sublote";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setInteger("usuario", ClienteRelacaoTipo.USUARIO.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o id do cliente responsável pela conta historico [UC0482]Emitir
	 * 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdClienteResponsavelContaHistorico(Integer idConta) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cli.id " + "from ClienteContaHistorico cliCntHist " + "inner join cliCntHist.contaHistorico cntHist "
							+ "inner join cliCntHist.clienteRelacaoTipo crt " + "inner join cliCntHist.cliente cli "
							+ "where cntHist.id = :idConta AND " + "crt.id = :idResponsavel";

			retorno = (Integer) session.createQuery(consulta).setInteger("idConta", idConta)
							.setInteger("idResponsavel", ClienteRelacaoTipo.RESPONSAVEL).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna a soma de quantidade economia
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0007] Obter Quantidade de Economias da Conta Historico
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Short obterQuantidadeEconomiasContaHistorico(Integer idConta) throws ErroRepositorioException{

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select sum(contaCategoriaHist.quantidadeEconomia) " + "from ContaCategoriaHistorico contaCategoriaHist "
							+ "left join contaCategoriaHist.comp_id.contaHistorico contaHist " + "where contaHist.id = :idConta";

			retorno = ((Number) session.createQuery(consulta).setInteger("idConta", idConta).setMaxResults(1).uniqueResult()).shortValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * Pesquisa as contas do cliente responsável para todos os grupos de
	 * faturamento.
	 * [UC0348] Emitir Contas
	 * 
	 * @author Pedro Alexandre
	 * @date 17/05/2007
	 * @param idTipoConta
	 * @param numeroPaginas
	 * @param anoMesReferencia
	 * @param indicadorEmissaoExtratoFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavel(Collection<Integer> idTipoConta, Integer numeroPaginas, Integer anoMesReferencia,
					Short indicadorEmissaoExtratoFaturamento, Integer anoMesReferenciaFaturamentoAntecipado)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cttp_id as tipoConta "// 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id in (:idTipoConta) AND " + "contaImpressao.empr_id is null AND ";
			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
							+ "imovel.imov_icemissaoextratofaturamen = :indicadorEmissaoExtratoFaturamento "
							+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("tipoConta", Hibernate.INTEGER)
							.setParameterList("idTipoConta", idTipoConta).setInteger("idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
							.setShort("indicadorEmissaoExtratoFaturamento", indicadorEmissaoExtratoFaturamento).setMaxResults(1000)
							.setFirstResult(numeroPaginas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaHistorico(Integer idConta) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select contaCategoriaHist " + "from ContaCategoriaHistorico contaCategoriaHist "
							+ "inner join fetch contaCategoriaHist.comp_id.contaHistorico contaHist "
							+ "inner join fetch contaCategoriaHist.comp_id.categoria categoria "
							+ "inner join fetch contaCategoriaHist.comp_id.subcategoria subcategoria " + "where contaHist.id = :idConta ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta).setInteger("idConta", idConta).list()));

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @param idConta
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaHistoricoFaixas(Integer idConta, Integer idCategoria) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaCategoriaConsumoFaixaHistorico "
							+ "from ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistorico "
							+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.contaHistorico contaHist "
							+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.categoria categoria "
							+ "where contaHist.id = :idConta AND " + "categoria.id = :idCategoria "
							+ "order by contaCategoriaConsumoFaixaHistorico.consumoFaixaInicio";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setInteger("idCategoria", idCategoria.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do conta impostos deduzidos
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0015] Gerar Linhas dos Impostos Deduzidos
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParmsContaImpostosDeduzidosHistorico(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select impostoTipo.descricaoAbreviada,"// 0
							+ "contaImpostosDeduzidosHist.percentualAliquota," // 1
							+ "contaImpostosDeduzidosHist.valorImposto " // 1
							+ "from ContaImpostosDeduzidosHistorico contaImpostosDeduzidosHist "
							+ "inner join contaImpostosDeduzidosHist.contaHistorico contaHist "
							+ "inner join contaImpostosDeduzidosHist.impostoTipo impostoTipo " + "where contaHist.id = :idConta";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object com a soma do valor dos debitos
	 * cobrados de parcelamento,o numero da prestacao e o numero total de
	 * prestações
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParmsDebitoCobradoHistorico(Integer idConta, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select sum(debCobradoHist.valorPrestacao),debCobradoHist.numeroPrestacaoDebito,debCobradoHist.numeroPrestacao "
							+ "from DebitoCobradoHistorico debCobradoHist " + "inner join debCobradoHist.financiamentoTipo finTipo "
							+ "inner join debCobradoHist.contaHistorico contaHist " + "where contaHist.id = :idConta AND "
							+ "finTipo.id in (:tiposParcelamento) "
							+ "group by debCobradoHist.numeroPrestacaoDebito,debCobradoHist.numeroPrestacao";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setParameterList("tiposParcelamento", tiposParcelamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Object[]> listarParmsDebitoCobradoHistorico(Integer idConta, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{
		
		Session session = HibernateUtil.getSession();

		Collection<Object[]> objs = this.pesquisarParmsDebitoCobradoHistorico(idConta, tiposParcelamento);
		Collection<Object[]> parametros = new ArrayList<Object[]>();

		try{

		for(Object[] obj : objs){

			BigDecimal valorTotalPrestacoes = (BigDecimal) obj[0];
			short numeroPrestacaoDebito = (Short) obj[1];
			short numeroPrestacao = (Short) obj[2];

			Criteria criteria = HibernateUtil.getSession().createCriteria(DebitoCobradoHistorico.class);
			criteria.createAlias("financiamentoTipo", "financiamentoTipo", Criteria.INNER_JOIN);
			criteria.createAlias("contaHistorico", "contaHistorico", Criteria.INNER_JOIN);
			criteria.createAlias("parcelamento", "parcelamento", Criteria.INNER_JOIN);
			criteria.createAlias("parcelamento.resolucaoDiretoria", "resolucaoDiretoria", Criteria.INNER_JOIN);
			criteria.add(Restrictions.eq("numeroPrestacaoDebito", numeroPrestacaoDebito));
			criteria.add(Restrictions.eq("numeroPrestacao", numeroPrestacao));
			if(!Util.isVazioOrNulo(tiposParcelamento)){
				criteria.add(Restrictions.in("financiamentoTipo.id", tiposParcelamento));
			}
			criteria.add(Restrictions.eq("contaHistorico.id", idConta));
			criteria.setProjection(Projections.property("parcelamento"));

			Parcelamento parcelamento = null;
			Collection colecaoParcelamento = criteria.list();


			if(!Util.isVazioOrNulo(colecaoParcelamento)){
				parcelamento = (Parcelamento) Util.retonarObjetoDeColecao(criteria.list());

			}

			Object[] parametro = new Object[4];
			parametro[0] = valorTotalPrestacoes;
			parametro[1] = numeroPrestacaoDebito;
			parametro[2] = numeroPrestacao;
			parametro[3] = parcelamento;

			parametros.add(parametro);

			
		}	
			

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}


		return parametros;

	}

	public ResolucaoDiretoria pesquisarRD(Integer idparcelamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		ResolucaoDiretoria resolucaoDiretoria = new ResolucaoDiretoria();

		try{
		Criteria criteria = HibernateUtil.getSession().createCriteria(Parcelamento.class);
		criteria.createAlias("resolucaoDiretoria", "resolucaoDiretoria", Criteria.INNER_JOIN);
		criteria.add(Restrictions.eq("id", idparcelamento));
		criteria.setProjection(Projections.property("resolucaoDiretoria"));
			resolucaoDiretoria = (ResolucaoDiretoria) criteria.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}


		return resolucaoDiretoria;

	}

	/**
	 * Método que retorna uma array de object do debito cobrado ordenado pelo
	 * tipo de debito
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0013] Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsDebitoCobradoHistoricoPorTipo(Integer idConta, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select sum(debCobradoHist.valorPrestacao), "// 0
							+ "debCobradoHist.numeroPrestacaoDebito," // 1
							+ "debCobradoHist.numeroPrestacao, "// 2
							+ "debCobradoHist.anoMesReferenciaDebito, "// 3
							+ "debitoTipo.id, "// 4
							+ "debCobradoHist.debitoTipo.descricao "// 5
							+ "from DebitoCobradoHistorico debCobradoHist "
							+ "inner join debCobradoHist.financiamentoTipo finTipo "
							+ "inner join debCobradoHist.debitoTipo debitoTipo "
							+ "inner join debCobradoHist.contaHistorico contaHist "
							+ "where contaHist.id = :idConta AND " + "finTipo.id not in (:tiposParcelamento) "
							+ "group by "
							+ "debitoTipo.id, " + "debCobradoHist.numeroPrestacaoDebito,"
							+ "debCobradoHist.numeroPrestacao, "
							+ "debCobradoHist.anoMesReferenciaDebito, "
							+ "debCobradoHist.debitoTipo.descricao "
							+ "order by debitoTipo.id,debCobradoHist.anoMesReferenciaDebito desc";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setParameterList("tiposParcelamento", tiposParcelamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma array de object do crédito realizado ordenado pelo
	 * tipo de crédito
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0014] Gerar Linhas dos Creditos Realizados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/05/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List pesquisarParmsCreditoRealizadoHistoricoPorTipo(Integer idConta) throws ErroRepositorioException{

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select credRealizadoHist.valorCredito,"// 0
							+ "credRealizadoHist.numeroPrestacaoCredito," // 1
							+ "credRealizadoHist.numeroPrestacao, "// 2
							+ "credRealizadoHist.anoMesReferenciaCredito, "// 3
							+ "creditoTipo.id, "// 4
							+ "creditoTipo.descricao "// 5
							+ "from CreditoRealizadoHistorico credRealizadoHist "
							+ "inner join credRealizadoHist.creditoTipo creditoTipo "
							+ "inner join credRealizadoHist.contaHistorico contaHist "
							+ "where contaHist.id = :idConta "
							+ "order by creditoTipo.id,credRealizadoHist.anoMesReferenciaCredito desc";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar um relatório analítico do faturamento.
	 * [UC0593]Gerar Relatório Analítico do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 18/05/2007
	 * @author Saulo Lima
	 * @date 07/02/2009
	 *       Colocados os Generics nas coleções.
	 * @author Virgínia Melo
	 * @date 26/03/2009
	 *       Adicionado o parâmetro valor mínimo.
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @param indicadorLocalidadeInformatizada
	 * @param colecaoLocalidades
	 * @param colecaoSetores
	 * @param colecaoQuadras
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDadosRelatorioAnaliticoFaturamento(int anoMesFaturamento, Integer idFaturamentoGrupo,
					int indicadorLocalidadeInformatizada, Collection<Localidade> colecaoLocalidades,
					Collection<SetorComercial> colecaoSetores, Collection<Quadra> colecaoQuadras, BigDecimal valorMinimo)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select conta.imovel.id,"// 0 0
							+ " conta.consumoAgua,"// 1
							+ " conta.consumoRateioAgua,"// 2
							+ " conta.valorAgua,"// 3
							+ " conta.consumoEsgoto,"// 4
							+ " conta.consumoRateioEsgoto,"// 5
							+ " conta.valorEsgoto,"// 6
							+ " conta.debitos,"// 7
							+ " conta.valorCreditos,"// 8
							+ " conta.valorImposto,"// 9
							+ " conta.codigoSetorComercial,"// 10
							+ " localidade.id,"// 11
							+ " conta.digitoVerificadorConta,"// 12
							+ " localidade.descricao"// 13
							+ " from Conta conta" + " inner join conta.quadraConta quadra"
							+ " inner join conta.rota rota"
							+ " inner join rota.faturamentoGrupo faturamentoGrupo"
							+ " inner join conta.localidade localidade"
							+ " where conta.referencia = :anoMes" + " and faturamentoGrupo.id = :idFaturamentoGrupo";
			// + " and localidade.indicadorLocalidadeInformatizada = :indicadorInformatizada";

			if(indicadorLocalidadeInformatizada == 1 || indicadorLocalidadeInformatizada == 2){

				consulta = consulta + " and localidade.indicadorLocalidadeInformatizada = :indicadorInformatizada ";
			}
			if(valorMinimo != null){
				consulta = consulta
								+ " and (conta.valorAgua + conta.valorEsgoto + conta.debitos - conta.valorCreditos - conta.valorImposto ) >= :valorMinimo ";
			}

			if(colecaoLocalidades != null && !colecaoLocalidades.isEmpty()){
				consulta = consulta + " and conta.localidade in (";
				Iterator iterator = colecaoLocalidades.iterator();
				while(iterator.hasNext()){
					Localidade localidade = (Localidade) iterator.next();
					consulta = consulta + localidade.getId().toString() + ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			if(colecaoSetores != null && !colecaoSetores.isEmpty()){
				consulta = consulta + " and conta.codigoSetorComercial in (";
				Iterator iterator = colecaoSetores.iterator();
				while(iterator.hasNext()){
					SetorComercial setorComercial = (SetorComercial) iterator.next();
					consulta = consulta + setorComercial.getCodigo() + ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			if(colecaoQuadras != null && !colecaoQuadras.isEmpty()){
				consulta = consulta + " and conta.quadra in (";
				Iterator iterator = colecaoQuadras.iterator();
				while(iterator.hasNext()){
					Quadra quadra = (Quadra) iterator.next();
					consulta = consulta + quadra.getNumeroQuadra() + ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			consulta = consulta + " order by localidade.id, conta.codigoSetorComercial";

			if(indicadorLocalidadeInformatizada == 1 || indicadorLocalidadeInformatizada == 2){

				retorno = session.createQuery(consulta).setInteger("anoMes", anoMesFaturamento)
								.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
								.setShort("indicadorInformatizada", Short.valueOf(indicadorLocalidadeInformatizada + ""))
								.setBigDecimal("valorMinimo", valorMinimo).list();
			}else{
				retorno = session.createQuery(consulta).setInteger("anoMes", anoMesFaturamento)
								.setInteger("idFaturamentoGrupo", idFaturamentoGrupo).setBigDecimal("valorMinimo", valorMinimo).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar um relatório analítico do faturamento em Conta Historico.
	 * [UC0593]Gerar Relatório Analítico do Faturamento
	 * Alteração OC0931748 obter de historico.
	 * 
	 * @date 23/01/2013
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDadosRelatorioAnaliticoFaturamentoContaHistorico(int anoMesFaturamento,
					Integer idFaturamentoGrupo, int indicadorLocalidadeInformatizada, Collection<Localidade> colecaoLocalidades,
					Collection<SetorComercial> colecaoSetores, Collection<Quadra> colecaoQuadras, BigDecimal valorMinimo)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select conta.imovel.id,"// 0
							+ " conta.consumoAgua,"// 1
							+ " conta.consumoRateioAgua,"// 2
							+ " conta.valorAgua,"// 3
							+ " conta.consumoEsgoto,"// 4
							+ " conta.consumoRateioEsgoto,"// 5
							+ " conta.valorEsgoto,"// 6
							+ " conta.valorDebitos,"// 7
							+ " conta.valorCreditos,"// 8
							+ " conta.setorComercial,"// 9
							+ " localidade.id,"// 10
							+ " conta.verificadorConta"// 11
							+ " from ContaHistorico conta" //
							+ " inner join conta.quadra quadra"
							+ " inner join conta.rota rota"
							+ " inner join rota.faturamentoGrupo faturamentoGrupo"
							+ " inner join conta.localidade localidade"
							+ " where conta.anoMesReferenciaConta = :anoMes" + " and faturamentoGrupo.id = :idFaturamentoGrupo";
			// + " and localidade.indicadorLocalidadeInformatizada = :indicadorInformatizada";

			if(indicadorLocalidadeInformatizada == 1 || indicadorLocalidadeInformatizada == 2){

				consulta = consulta + " and localidade.indicadorLocalidadeInformatizada = :indicadorInformatizada";
			}

			if(valorMinimo != null){
				consulta = consulta
								+ " and (conta.valorAgua + conta.valorEsgoto + conta.valorDebitos - conta.valorCreditos ) >= :valorMinimo ";
			}

			consulta = consulta + " and conta.debitoCreditoSituacaoAtual in (" + DebitoCreditoSituacao.NORMAL + ", "
							+ DebitoCreditoSituacao.RETIFICADA + ", " + DebitoCreditoSituacao.INCLUIDA + ", "
							+ DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO + " )";

			if(colecaoLocalidades != null && !colecaoLocalidades.isEmpty()){
				consulta = consulta + " and conta.localidade in (";
				Iterator iterator = colecaoLocalidades.iterator();
				while(iterator.hasNext()){
					Localidade localidade = (Localidade) iterator.next();
					consulta = consulta + localidade.getId().toString() + ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			if(colecaoSetores != null && !colecaoSetores.isEmpty()){
				consulta = consulta + " and conta.setorComercial in (";
				Iterator iterator = colecaoSetores.iterator();
				while(iterator.hasNext()){
					SetorComercial setorComercial = (SetorComercial) iterator.next();
					consulta = consulta + setorComercial.getCodigo() + ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			if(colecaoQuadras != null && !colecaoQuadras.isEmpty()){
				consulta = consulta + " and conta.quadra in (";
				Iterator iterator = colecaoQuadras.iterator();
				while(iterator.hasNext()){
					Quadra quadra = (Quadra) iterator.next();
					consulta = consulta + quadra.getNumeroQuadra() + ",";
				}
				consulta = consulta.substring(0, (consulta.length() - 1));
				consulta = consulta + ")";
			}
			consulta = consulta + " order by localidade.id, conta.setorComercial";

			if(indicadorLocalidadeInformatizada == 1 || indicadorLocalidadeInformatizada == 2){

				retorno = session.createQuery(consulta).setInteger("anoMes", anoMesFaturamento)
								.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
								.setShort("indicadorInformatizada", Short.valueOf(indicadorLocalidadeInformatizada + ""))
								.setBigDecimal("valorMinimo", valorMinimo).list();
			}else{
				retorno = session.createQuery(consulta).setInteger("anoMes", anoMesFaturamento)
								.setInteger("idFaturamentoGrupo", idFaturamentoGrupo).setBigDecimal("valorMinimo", valorMinimo).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorno o id do imvel com FNTP_ID da tabela DEBITO_A_COBRAR com o valor
	 * correspondente a parcelamento de água (2), parcelamento de esgoto (3), ou
	 * parcelamento de serviço(4)
	 * [UC0259] - Processar Pagamento com código de Barras
	 * [SB0012] – Verifica Pagamento de Debito a Cobrar de Parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @date 30/05/2007
	 * @param idDebitoACobrar
	 * @return retorna o id do imovel do debito
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public Integer pesquisarImovelDebitoACobrar(Integer idDebitoACobrar, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{

		Integer retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select imov.id from DebitoACobrar dbac left join dbac.financiamentoTipo fntp "
							+ "left join dbac.imovel imov where dbac.id = :idDebitoACobrar and fntp.id in (:tiposParcelamento) ";

			// executa o hql
			retorno = (Integer) session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar)
							.setParameterList("tiposParcelamento", tiposParcelamento).setMaxResults(1).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar
		return retorno;
	}

	/**
	 * atualiza DSCT_IDATUAL com o valor correspondente a cancelado (3), na
	 * tabela DEBITO_A_COBRAR com IMOV_ID do debito a cobrar que foi pago,
	 * DCST_IDATUAL com o valor correspondente a normal (0) e FNTP_ID com o
	 * valor correspondente a juros de parcelamento (8)
	 * [UC0259] - Processar Pagamento com código de Barras
	 * [SB0012] – Verifica Pagamento de Debito a Cobrar de Parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @date 30/05/2007
	 * @author Saulo Lima
	 * @date 23/09/2009
	 *       Novo parâmetro idParcelamento
	 * @param idimovel
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void atualizarDebitoCreditoSituacaoAtualDoDebitoACobrar(Integer idImovel, Integer idParcelamento)
					throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			update = "UPDATE gcom.faturamento.debito.DebitoACobrar SET " + "dcst_idatual = :situacaoAtual " + "WHERE imov_id = :idImovel "
							+ "AND fntp_id = :financiamentoTipo " + "AND dcst_idatual = :debitoCreditoSituacaoNormal "
							+ "AND parc_id = :idParcelamento";

			session.createQuery(update).setInteger("situacaoAtual", DebitoCreditoSituacao.CANCELADA).setInteger("idImovel", idImovel)
							.setInteger("debitoCreditoSituacaoNormal", DebitoCreditoSituacao.NORMAL)
							.setInteger("financiamentoTipo", FinanciamentoTipo.JUROS_PARCELAMENTO)
							.setInteger("idParcelamento", idParcelamento).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos a Cobrar de Acréscimos por Impontualidade
	 * Author: Raphael Rossiter Data: 31/05/2007
	 * Obtém os pagamentos da conta que contem a menor data de pagamento
	 * 
	 * @param Integer
	 *            conta, Integer idImovel, Integer anoMesReferenciaConta
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] obterArrecadacaoFormaPagamentoContasMenorData(Integer conta, Integer idImovel, Integer anoMesReferenciaConta)
					throws ErroRepositorioException{

		Object[] retorno = null;

		Object[] pesquisa1 = null;
		Object[] pesquisa2 = null;

		Date data1 = null;
		Date data2 = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT pgmt.arrecadacaoForma.id , MIN(pgmt.dataPagamento) " + "FROM Pagamento pgmt "
							+ "INNER JOIN pgmt.conta cnta " + "WHERE cnta.id = :idConta " + "GROUP BY pgmt.arrecadacaoForma.id "
							+ "ORDER BY 2 ";

			pesquisa1 = (Object[]) session.createQuery(consulta).setInteger("idConta", conta).setMaxResults(1).uniqueResult();

			consulta = "SELECT pgmt.arrecadacaoForma.id , MIN(pgmt.dataPagamento) " + "FROM Pagamento pgmt "
							+ "INNER JOIN pgmt.conta cnta " + "INNER JOIN cnta.imovel imov "
							+ "WHERE pgmt.imovel.id= :idImovel and pgmt.anoMesReferenciaPagamento = :anoMesReferenciaConta "
							+ "GROUP BY pgmt.arrecadacaoForma.id " + "ORDER BY 2 ";

			pesquisa2 = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferenciaConta", anoMesReferenciaConta).setMaxResults(1).uniqueResult();

			if(pesquisa1 != null){
				data1 = (Date) pesquisa1[1];
			}

			if(pesquisa2 != null){
				data2 = (Date) pesquisa2[1];
			}

			if(data2 == null){
				retorno = pesquisa1;
			}else{
				if(data1 == null){
					retorno = pesquisa2;
				}else{
					if(data1.before(data2)){
						retorno = pesquisa1;
					}else{
						retorno = pesquisa2;
					}
				}
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 31/05/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioEstadoPorUnidadeNegocio(int anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(rf.valorItemFaturamento), "
							+ // 0
							"lt.descricao, "
							+ // 1
							"li.descricao, "
							+ // 2
							"lic.descricao, "
							+ // 3
							"lt.indicadorImpressao, "
							+ // 4
							"lt.indicadorTotal, "
							+ // 5
							"lt.id, "
							+ // 6
							"lt.lancamentoTipo.id, "
							+ // 7
							"rf.categoria.id, "
							+ // 8
							"rf.unidadeNegocio.nome, "
							+ // 9
							"rf.unidadeNegocio.id, "
							+ // 10
							"rf.sequenciaTipoLancamento, "
							+ // 11
							"rf.sequenciaItemTipoLancamento, "
							+ // 12
							"rf.gerenciaRegional.nome, "
							+ // 13
							"rf.gerenciaRegional.id "

							// + // 10
							// "rf.localidade.descricao, "
							// + // 11
							// "rf.localidade.id, "

							+ "from ResumoFaturamento rf " + "left join rf.lancamentoTipo lt " + "left join rf.lancamentoItem li "
							+ "left join rf.lancamentoItemContabil lic " + "where rf.anoMesReferencia = :anoMesReferencia and "
							+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) "
							+ "group by rf.unidadeNegocio.nome,rf.unidadeNegocio.id,"
							+ "lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, "
							+ "lt.lancamentoTipo.id, rf.categoria.id, rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, "
							+ "rf.gerenciaRegional.nome, rf.gerenciaRegional.id "
							+ "order by rf.gerenciaRegional.nome, rf.unidadeNegocio.nome, rf.sequenciaTipoLancamento, "
							+ "rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar
	 * Relatório de Resumo Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @created 31/05/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorUnidadeNegocio(int anoMesReferencia, Integer unidadeNegocio)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{

			consulta = "select sum(rf.valorItemFaturamento), "
							+ // 0
							"lt.descricao, "
							+ // 1
							"li.descricao, "
							+ // 2
							"lic.descricao, "
							+ // 3
							"lt.indicadorImpressao, "
							+ // 4
							"lt.indicadorTotal, "
							+ // 5
							"lt.id, "
							+ // 6
							"lt.lancamentoTipo.id, "
							+ // 7
							"rf.categoria.id, "
							+ // 8
							"rf.unidadeNegocio.nome, "
							+ // 9
							"rf.unidadeNegocio.id, "
							+ // 10
							"rf.sequenciaTipoLancamento, "
							+ // 11
							"rf.sequenciaItemTipoLancamento, "
							+ // 12
							" rf.gerenciaRegional.nome," // 13
							+ " rf.gerenciaRegional.id " // 14
							+ "from ResumoFaturamento rf "
							+ "left join rf.lancamentoTipo lt "
							+ "left join rf.lancamentoItem li "
							+ "left join rf.lancamentoItemContabil lic "
							+ "where rf.anoMesReferencia = :anoMesReferencia and "
							+ "rf.unidadeNegocio = :unidadeNegocio and "
							+ "(rf.categoria.id = 1 or rf.categoria.id = 2 or rf.categoria.id = 3 or rf.categoria.id = 4) "
							+ "group by  lt.descricao, li.descricao, lic.descricao, lt.indicadorImpressao, lt.indicadorTotal, lt.id, lt.lancamentoTipo.id, "
							+ "rf.categoria.id, rf.unidadeNegocio.nome, rf.unidadeNegocio.id, rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, rf.gerenciaRegional.nome, rf.gerenciaRegional.id  "
							+ "order by rf.sequenciaTipoLancamento, rf.sequenciaItemTipoLancamento, rf.categoria.id ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("unidadeNegocio", unidadeNegocio).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * [SB0014] Selecionar por Indicador de Consumo [SB0015] Selecionar por
	 * Indicador de Medido [SB0016] Selecionar por Indicador de Poço [SB0017]
	 * Selecionar por Indicador de Volume Fixo de Água
	 * 
	 * @author Rafael Pinto
	 * @date 01/06/2007
	 * @author eduardo henrique
	 * @date 09/09/2009
	 *       correcao nas intruções de group by para emissão do relatório.
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Collection<Object[]> pesquisarEmitirHistogramaAgua(FiltrarEmitirHistogramaAguaHelper filtro) throws ErroRepositorioException{

		Collection<Object[]> retornoConsulta = null;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoAgua = filtro.getColecaoSituacaoLigacaoAgua();

			Categoria categoria = filtro.getCategoria();
			ConsumoTarifa tarifa = filtro.getTarifa();
			ImovelPerfil perfilImovel = filtro.getPerfilImovel();
			EsferaPoder esferaPoder = filtro.getEsferaPoder();
			LigacaoAguaSituacao situacaoLigacaoAgua = filtro.getSituacaoLigacaoAgua();

			Short consumo = filtro.getConsumo();
			Short medicao = filtro.getMedicao();
			Short poco = filtro.getPoco();
			Short volumoFixoAgua = filtro.getVolumoFixoAgua();

			ConsumoFaixaLigacao consumoFaixaLigacao = filtro.getConsumoFaixaLigacao();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro.getConsumoFaixaLigacaoIntervaloMedido();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro.getConsumoFaixaLigacaoIntervaloNaoMedido();

			String clausulaGroup = filtro.getTipoGroupBy();

			Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
			Integer numeroQuadra = filtro.getNumeroQuadra();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT categoria.id," // 0
							+ "categoria.descricao," // 1
							+ "sum(histograma.quantidadeLigacao + histograma.quantidadeLigacaoRefaturamento)," // 2
							+ "sum(histograma.quantidadeEconomiaLigacao + histograma.quantidadeEconomiaLigacaoRefaturamento)," // 3
							+ "sum(histograma.valorFaturadoLigacao + histograma.valorFaturadoLigacaoRefaturamento) "; // 4

			if(clausulaGroup != null){
				consulta += "," + clausulaGroup;
			}

			String consultaFrom = "FROM HistogramaAguaLigacao histograma INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if(consumoFaixaLigacao != null){
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if(consumoFaixaLigacaoIntervaloMedido != null && consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
								.concat("AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ");

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
								.concat("AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ");

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if(codigoSetorComercial != null){
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);
			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if(numeroQuadra != null){
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if(categoria != null){
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			}else if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(perfilImovel != null){
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			}else if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(esferaPoder != null){
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			}else if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if(situacaoLigacaoAgua != null){
				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id = (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", situacaoLigacaoAgua.getId());

			}else if(colecaoSituacaoLigacaoAgua != null && !colecaoSituacaoLigacaoAgua.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoAgua != null){
				consultaWhere += "AND histograma.indicadorVolFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			String groupBy = "GROUP BY categoria.id,categoria.descricao";
			String orderBy = "";
			if(clausulaGroup != null){
				groupBy += ",".concat(clausulaGroup);
				orderBy = " ORDER BY ".concat(clausulaGroup).concat(",categoria.id");
			}else{
				orderBy = " ORDER BY categoria.id,categoria.descricao";
			}

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0600] Emitir Histograma de Água - Volume Faturado Ligacao Estimado ou Real
	 * 
	 * @author Rafael Pinto
	 * @date 01/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Integer pesquisarEmitirHistogramaAguaVolumeConsumo(FiltrarEmitirHistogramaAguaHelper filtro, Short consumo, Categoria categoria,
					Short medicao) throws ErroRepositorioException{

		Integer retornoConsulta = 0;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();

			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoAgua = filtro.getColecaoSituacaoLigacaoAgua();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
			ConsumoTarifa tarifa = filtro.getTarifa();
			ImovelPerfil perfilImovel = filtro.getPerfilImovel();
			EsferaPoder esferaPoder = filtro.getEsferaPoder();
			LigacaoAguaSituacao situacaoLigacaoAgua = filtro.getSituacaoLigacaoAgua();

			Short poco = filtro.getPoco();
			Short volumoFixoAgua = filtro.getVolumoFixoAgua();

			ConsumoFaixaLigacao consumoFaixaLigacao = filtro.getConsumoFaixaLigacao();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro.getConsumoFaixaLigacaoIntervaloMedido();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro.getConsumoFaixaLigacaoIntervaloNaoMedido();

			Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
			Integer numeroQuadra = filtro.getNumeroQuadra();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum(histograma.volumeFaturadoLigacao + histograma.volumeFaturadoLigacaoRefaturamento) "; // 0

			String consultaFrom = "FROM HistogramaAguaLigacao histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if(consumoFaixaLigacao != null){
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if(consumoFaixaLigacaoIntervaloMedido != null && consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if(codigoSetorComercial != null){
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if(numeroQuadra != null){
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if(categoria != null){
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			}else if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(perfilImovel != null){
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			}else if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(esferaPoder != null){
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			}else if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if(situacaoLigacaoAgua != null){
				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id = (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", situacaoLigacaoAgua.getId());
			}else if(colecaoSituacaoLigacaoAgua != null && !colecaoSituacaoLigacaoAgua.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoAgua != null){
				consultaWhere += "AND histograma.indicadorVolumeFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}

			Number retorno = (Number) query.setMaxResults(1).uniqueResult();
			if(retorno != null){
				retornoConsulta = retorno.intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0600] Emitir Histograma de Água - Total Geral
	 * [SB0014] Selecionar por Indicador de Consumo [SB0015] Selecionar por
	 * Indicador de Medido [SB0016] Selecionar por Indicador de Poço [SB0017]
	 * Selecionar por Indicador de Volume Fixo de Água
	 * 
	 * @author Rafael Pinto
	 * @date 01/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Object[] pesquisarEmitirHistogramaAguaTotalGeral(FiltrarEmitirHistogramaAguaHelper filtro, Categoria categoria)
					throws ErroRepositorioException{

		Object[] retornoConsulta = null;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoAgua = filtro.getColecaoSituacaoLigacaoAgua();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
			ConsumoTarifa tarifa = filtro.getTarifa();
			ImovelPerfil perfilImovel = filtro.getPerfilImovel();
			EsferaPoder esferaPoder = filtro.getEsferaPoder();
			LigacaoAguaSituacao situacaoLigacaoAgua = filtro.getSituacaoLigacaoAgua();

			Short consumo = filtro.getConsumo();
			Short medicao = filtro.getMedicao();
			Short poco = filtro.getPoco();
			Short volumoFixoAgua = filtro.getVolumoFixoAgua();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro.getConsumoFaixaLigacaoIntervaloMedido();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro.getConsumoFaixaLigacaoIntervaloNaoMedido();

			Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
			Integer numeroQuadra = filtro.getNumeroQuadra();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum(histograma.quantidadeLigacao + histograma.quantidadeLigacaoRefaturamento)," // 0
							+ "sum(histograma.volumeFaturadoLigacao + histograma.volumeFaturadoLigacaoRefaturamento)," // 1
							+ "sum(histograma.valorFaturadoLigacao + histograma.valorFaturadoLigacaoRefaturamento) "; // 2

			String consultaFrom = "FROM HistogramaAguaLigacao histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if(consumoFaixaLigacaoIntervaloMedido != null && consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if(codigoSetorComercial != null){
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if(numeroQuadra != null){
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if(categoria != null){
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			}else if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(perfilImovel != null){
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			}else if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(esferaPoder != null){
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			}else if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if(situacaoLigacaoAgua != null){
				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id = (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", situacaoLigacaoAgua.getId());

			}else if(colecaoSituacaoLigacaoAgua != null && !colecaoSituacaoLigacaoAgua.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoAgua != null){
				consultaWhere += "AND histograma.indicadorVolumeFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = (Object[]) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0605] Emitir Histograma de Água por Economia
	 * 
	 * @author Rafael Pinto
	 * @date 14/06/2007
	 * @author eduardo henrique
	 * @date 09/09/2009
	 *       Correcao na instrução de group by para compatibilizacao com Oracle
	 * @param FiltrarEmitirHistogramaAguaEconomiaHelper
	 * @return Object[]
	 * @throws ControladorException
	 */
	public Object[] pesquisarEmitirHistogramaAguaEconomia(FiltrarEmitirHistogramaAguaEconomiaHelper filtro) throws ErroRepositorioException{

		Object[] retornoConsulta = null;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();
			Integer tarifa = filtro.getTarifa();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoAgua = filtro.getColecaoSituacaoLigacaoAgua();

			Short consumo = filtro.getConsumo();
			Short medicao = filtro.getMedicao();
			Short poco = filtro.getPoco();
			Short volumoFixoAgua = filtro.getVolumoFixoAgua();

			ConsumoFaixaCategoria consumoFaixaCategoria = filtro.getConsumoFaixaCategoria();
			Categoria categoria = filtro.getCategoria();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT categoria.id," // 0
							+ "categoria.descricao," // 1
							+ "sum(histograma.quantidadeEconomia + histograma.quantidadeEconomiaRefaturamento)," // 2
							+ "sum(histograma.quantidadeConsumo * (histograma.quantidadeEconomia + histograma.quantidadeEconomiaRefaturamento))," // 3
							+ "sum(histograma.volumeFaturadoEconomia + histograma.volumeFaturadoEconomiaRefaturamento)," // 4
							+ "sum(histograma.valorFaturadoEconomia + histograma.valorFaturadoEconomiaRefaturamento), " // 5
							+ "sum(histograma.quantidadeLigacao + histograma.quantidadeLigacaoRefaturamento) ";// 6

			String consultaFrom = "FROM HistogramaAguaEconomia histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Categoria
			if(consumoFaixaCategoria != null){
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaCategoria.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaCategoria.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if(categoria != null){
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			}else if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa);

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if(colecaoSituacaoLigacaoAgua != null && !colecaoSituacaoLigacaoAgua.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoAgua != null){
				consultaWhere += "AND histograma.indicadorVolFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			String groupBy = "GROUP BY categoria.id, categoria.descricao ";
			String orderBy = "ORDER BY categoria.id, categoria.descricao ";

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}

			}
			retornoConsulta = (Object[]) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0605] Emitir Histograma de Água por Economia
	 * Monta as quebras que serão necessarias para o relatorio
	 * 
	 * @author Rafael Pinto
	 * @date 18/06/2007
	 * @param FiltrarEmitirHistogramaAguaEconomiaHelper
	 * @return Collection<Object[]>
	 * @throws ControladorException
	 */
	public Collection<Object[]> pesquisarEmitirHistogramaAguaEconomiaChavesAgrupadas(FiltrarEmitirHistogramaAguaEconomiaHelper filtro)
					throws ErroRepositorioException{

		Collection<Object[]> retornoConsulta = null;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();
			Integer tarifa = filtro.getTarifa();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoAgua = filtro.getColecaoSituacaoLigacaoAgua();

			Short consumo = filtro.getConsumo();
			Short medicao = filtro.getMedicao();
			Short poco = filtro.getPoco();
			Short volumoFixoAgua = filtro.getVolumoFixoAgua();

			String clausulaGroup = filtro.getTipoGroupBy();
			String clausulaOrder = filtro.getTipoOrderBy();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT " + clausulaGroup; // 0

			String consultaFrom = " FROM HistogramaAguaEconomia histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.anoMesReferencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa);

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Agua Situação
			if(colecaoSituacaoLigacaoAgua != null && !colecaoSituacaoLigacaoAgua.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoAguaSituacao ligacaoAguaSituacao ";

				consultaWhere += "AND ligacaoAguaSituacao.id in (:situacaoLigacaoAgua) ";
				parameters.put("situacaoLigacaoAgua", colecaoSituacaoLigacaoAgua);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoAgua != null){
				consultaWhere += "AND histograma.indicadorVolFixadoAgua = (:volumoFixoAgua) ";
				parameters.put("volumoFixoAgua", volumoFixoAgua);
			}

			String groupBy = "GROUP BY " + clausulaGroup;
			String orderBy = " ORDER BY " + clausulaOrder;

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	// ///////////////////////////////////////////////////////////////////////////////////
	/**
	 * Recupera os dados da conta p emitir a 2ª via [UC0482]Emitir 2ª Via de
	 * Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/06/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaHistoricoERota(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "SELECT " + " new " + EmitirContaHelper.class.getName() + " ( " + "cntHist.id, " + "cli.nome, "
							+ "cntHist.dataVencimentoConta, " + "cntHist.anoMesReferenciaConta, " + "cntHist.verificadorConta, "
							+ "cntHist.setorComercial, " + "cntHist.numeroQuadra, " + "cntHist.lote, " + "cntHist.sublote, "
							+ "cntHist.consumoAgua, " + "cntHist.consumoEsgoto, " + "cntHist.valorAgua, " + "cntHist.valorEsgoto, "
							+ "cntHist.valorDebitos, " + "cntHist.valorCreditos, " + "cntHist.valorImposto, "
							+ "cntHist.dataValidadeConta, " + "imovel.id, " + "loc.id, " + "gerenciaRegional.id, "
							+ "gerenciaRegional.nome, " + "ligacaoAguaSituacao.id, " + "ligacaoEsgotoSituacao.id, " + "imovelPerfil.id, "
							+ "setorComercial.id, " + "faturamentoGrupo.id, " + "emp.id, " + "loc.descricao, "
							+ "ligacaoAguaSituacao.descricao, " + "ligacaoEsgotoSituacao.descricao, " + "cntHist.percentualEsgoto, "
							+ "rota.codigo, " + "imovel.numeroSequencialRota, " + "hidrometro.numero, " + "debitoCreditoSituacaoAtual.id, "
							+ "imovel.nomeImovel ) " + "from ClienteContaHistorico cliCntHist "
							+ "RIGHT JOIN cliCntHist.contaHistorico cntHist " + "LEFT JOIN cliCntHist.clienteRelacaoTipo crt "
							+ "LEFT JOIN cliCntHist.cliente cli " + "LEFT JOIN cntHist.contaMotivoRevisao cmr "
							+ "LEFT JOIN cntHist.quadra quadraConta " + "LEFT JOIN cntHist.localidade loc "
							+ "LEFT JOIN loc.gerenciaRegional gerenciaRegional "
							+ "LEFT JOIN cntHist.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "LEFT JOIN cntHist.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
							+ "LEFT JOIN cntHist.imovelPerfil imovelPerfil " + "LEFT JOIN quadraConta.rota rota "
							+ "LEFT JOIN rota.empresa emp " + "LEFT JOIN quadraConta.setorComercial setorComercial "
							+ "LEFT JOIN rota.faturamentoGrupo faturamentoGrupo " + "LEFT JOIN cntHist.imovel imovel "
							+ "LEFT JOIN imovel.hidrometroInstalacaoHistorico hih " + "LEFT JOIN hih.hidrometro hidrometro "
							+ "LEFT JOIN cntHist.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual " + "WHERE  cntHist.id = :idConta "
							+ "ORDER BY cntHist.anoMesReferenciaConta,emp.id,loc.id,cntHist.setorComercial,"
							+ "cntHist.numeroQuadra,cntHist.lote,cntHist.sublote";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * [UC0482]Emitir 2ª Via de Conta
	 * [SB0011] Obter Quantidade de Economias da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/06/2007
	 * @param idConta
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaHistoricoFaixas(Integer idConta, Integer idCategoria, Integer idSubCategoria)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select contaCategoriaConsumoFaixaHistorico "
							+ "from ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistorico "
							+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.contaHistorico contaHist "
							+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.categoria categoria "
							+ "inner join contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.subcategoria subCategoria "
							+ "where contaHist.id = :idConta AND " + "categoria.id = :idCategoria AND "
							+ "subCategoria.id = :idSubCategoria " + "order by contaCategoriaConsumoFaixaHistorico.consumoFaixaInicio";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).setInteger("idCategoria", idCategoria)
							.setInteger("idSubCategoria", idSubCategoria).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/06/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualContaHistorico(Integer idConta) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select dcst.id " + "from ContaHistorico cnta " + "inner join cnta.debitoCreditoSituacaoAtual dcst "
							+ "where cnta.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna uma colecao de conta categoria
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/06/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaHistoricoCategoriaSubCategoria(Integer idConta) throws ErroRepositorioException{

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select contaCategoriaHist " + "from ContaCategoriaHistorico contaCategoriaHist "
							+ "inner join contaCategoriaHist.comp_id.contaHistorico contaHist "
							+ "inner join fetch contaCategoriaHist.comp_id.categoria categoria "
							+ "inner join fetch contaCategoriaHist.comp_id.subcategoria subCategoria " + "where contaHist.id = :idConta ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session.createQuery(consulta).setInteger("idConta", idConta).list()));

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Metodo que retorna a data de revisão da conta
	 * 
	 * @author Vivianne Sousa
	 * @date 06/07/2007
	 * @param idsConta
	 * @return
	 */
	public Collection pesquisarDataRevisaoConta(Collection idsConta, Integer parametroMotivoRevisaoCobrancaBancaria)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select conta.id, conta.dataRevisao, conta.parcelamento.id " // 8
							+ "from Conta conta " + "where conta.id IN (:ids) and "
							+ "conta.dataRevisao is not null "
							+ "and conta.contaMotivoRevisao.id <> " + parametroMotivoRevisaoCobrancaBancaria.toString();

			// trata a consulta para não deixar trazer mais de 1000 resultados de uma vez.
			if(idsConta != null && idsConta.size() > 1000){
				Collection colecaoAuxiliar = new ArrayList<Object>();
				retorno = new ArrayList<Object>();
				for(Object id : idsConta){
					colecaoAuxiliar.add(id);
					if(colecaoAuxiliar.size() == 1000){
						retorno.addAll(session.createQuery(consulta).setParameterList("ids", colecaoAuxiliar).list());
						colecaoAuxiliar.clear();
					}
				}
				if(!colecaoAuxiliar.isEmpty()){
					retorno.addAll(session.createQuery(consulta).setParameterList("ids", colecaoAuxiliar).list());
				}
			}else{
				retorno = session.createQuery(consulta).setParameterList("ids", idsConta).list();
			}
			// ---

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * atualiza DSCT_IDATUAL com o valor correspondente a cancelado (3), na
	 * tabela CREDITO_A_REALIZAR com IMOV_ID do debito a cobrar que foi pago,
	 * DCST_IDATUAL com o valor correspondente a normal (0) e CROG_ID com o
	 * valor correspondente a descontos concedidos no parcelamento (6)
	 * [UC0259] - Processar Pagamento com código de Barras
	 * [SB0012] – Verifica Pagamento de Debito a Cobrar de Parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @date 18/07/2007
	 * @param idimovel
	 * @return
	 * @throws ErroRepositorioException
	 *             Erro no hibernate
	 */
	public void atualizarDebitoCreditoSituacaoAtualDoCreditoARealizar(Integer idImovel) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			update = "UPDATE gcom.faturamento.credito.CreditoARealizar SET " + "dcst_idatual = :situacaoAtual "
							+ "WHERE imov_id = :idImovel and " + "crog_id = :creditoOrigem and "
							+ "dcst_idatual = :debitoCreditoSituacaoNormal ";

			session.createQuery(update).setInteger("situacaoAtual", DebitoCreditoSituacao.CANCELADA).setInteger("idImovel", idImovel)
							.setInteger("debitoCreditoSituacaoNormal", DebitoCreditoSituacao.NORMAL)
							.setInteger("creditoOrigem", CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterIdsContasImovel(Integer idImovel) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT cnta.id " + "FROM Conta cnta " + "INNER JOIN cnta.imovel imov "
							+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst " + "WHERE imov.id = :idImovel AND "
							+ "cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada)";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int obterPagamentosContas(Collection idsContas) throws ErroRepositorioException{

		int retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT count(distinct conta.id) " + "FROM Pagamento pagamento " + "INNER JOIN conta conta "
							+ "WHERE conta.id in (:idsContas)";

			retorno = ((Number) session.createQuery(consulta).setParameterList("idsContas", idsContas).uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0485] Gerar Resumo dos Devedores Duvidosos
	 * verifica se a conta informada possui cliente responsável com esfera de
	 * poder de tipo de cliente igual a municipal, estadual ou federal.
	 * 
	 * @author Pedro Alexandre
	 * @date 23/07/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean verificarExistenciaClienteResponsavelConta(int idConta) throws ErroRepositorioException{

		boolean retorno = false;

		Collection retornoPesquisa = null;
		Collection<Short> colecaoIdsEsferasPoder = new ArrayList();
		colecaoIdsEsferasPoder.add(EsferaPoder.MUNICIPAL);
		colecaoIdsEsferasPoder.add(EsferaPoder.ESTADUAL);
		colecaoIdsEsferasPoder.add(EsferaPoder.FEDERAL);

		StatelessSession session = HibernateUtil.getStatelessSession();
		String consulta;

		try{
			consulta = "select clct.id " + "from ClienteConta clct " + "inner join clct.conta cnta " + "inner join clct.cliente clie "
							+ "inner join clct.clienteRelacaoTipo crtp " + "inner join clie.clienteTipo cltp "
							+ "inner join cltp.esferaPoder epod " + "where cnta.id = :idConta and crtp.id = :idRelacaoTipo "
							+ "and epod.id in (:idsEsferasPoder) ";

			retornoPesquisa = session.createQuery(consulta).setInteger("idConta", idConta)
							.setInteger("idRelacaoTipo", ClienteRelacaoTipo.RESPONSAVEL)
							.setParameterList("idsEsferasPoder", colecaoIdsEsferasPoder).list();

			if(retornoPesquisa != null && !retornoPesquisa.isEmpty()){
				retorno = true;
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoMetas(Integer anoMesReferencia) throws ErroRepositorioException{

		Session session = HibernateUtil.getSessionGerencial();
		String consulta;

		Collection retorno = null;

		try{
			consulta = "select unResumoMetas.id " + "from UnResumoMeta unResumoMetas "
							+ "where unResumoMetas.anoMesReferencia = :anoMesReferencia ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data:
	 * 20/07/2007
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoMetasAcumulado(Integer anoMesReferencia) throws ErroRepositorioException{

		Session session = HibernateUtil.getSessionGerencial();
		String consulta;

		Collection retorno = null;

		try{
			consulta = "select unResumoMetasAcumulado.id " + "from UnResumoMetasAcumulado unResumoMetasAcumulado "
							+ "where unResumoMetasAcumulado.anoMesReferencia = :anoMesReferencia ";

			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 20/08/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeContasGrupoFaturamento(Integer anoMes, Collection colecaoGrupoFaturamento,
					Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Integer anoMesFim, String inContasRevisao,
					Integer[] motivosRevisaoDisponiveis) throws ErroRepositorioException{

		Integer retorno = 0;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "SELECT COUNT(cnta.id) " + "FROM Conta cnta " + "INNER JOIN cnta.imovel imov " + "INNER JOIN imov.rota rota "
							+ "INNER JOIN rota.faturamentoGrupo ftgr " + "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst ";

			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())){
				consulta += "INNER JOIN cnta.contaMotivoRevisao cmr ";
			}else{
				consulta += "LEFT JOIN cnta.contaMotivoRevisao cmr ";
			}

			consulta += "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim " + "AND ftgr.id IN(:colecaoGrupoFaturamento) "
							+ "AND dcst.id IN(:normal, :incluida, :retificada)";

			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND cmr.id in (:motivosRevisaoDisponiveis) ";
			}else if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.NAO.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND (cmr.id in (:motivosRevisaoDisponiveis) or cmr.id is null) ";
			}

			if(dataVencimentoContaInicio != null){

				consulta += " AND cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				consulta += "ORDER BY cnta.referencia";

				if(dataVencimentoContaFim != null){
					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = retorno
										+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
														.setInteger("anoMesFim", anoMesFim)
														.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
														.setInteger("normal", DebitoCreditoSituacao.NORMAL)
														.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
														.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
														.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
														.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
														.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis)
														.uniqueResult()).intValue();

					}else{
						retorno = retorno
										+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
														.setInteger("anoMesFim", anoMesFim)
														.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
														.setInteger("normal", DebitoCreditoSituacao.NORMAL)
														.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
														.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
														.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
														.setDate("dataVencimentoContaFim", dataVencimentoContaFim).uniqueResult())
														.intValue();
					}

				}else{
					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = retorno
										+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
														.setInteger("anoMesFim", anoMesFim)
														.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
														.setInteger("normal", DebitoCreditoSituacao.NORMAL)
														.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
														.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
														.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
														.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
														.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis)
														.uniqueResult()).intValue();

					}else{
						retorno = retorno
										+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
														.setInteger("anoMesFim", anoMesFim)
														.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
														.setInteger("normal", DebitoCreditoSituacao.NORMAL)
														.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
														.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
														.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
														.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).uniqueResult())
														.intValue();
					}
				}
			}else{
				consulta += "ORDER BY cnta.referencia";

				if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
					retorno = retorno
									+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
													.setInteger("anoMesFim", anoMesFim)
													.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
													.setInteger("normal", DebitoCreditoSituacao.NORMAL)
													.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
													.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
													.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis)
													.uniqueResult()).intValue();

				}else{
					retorno = retorno
									+ ((Number) session.createQuery(consulta).setInteger("anoMes", anoMes)
													.setInteger("anoMesFim", anoMesFim)
													.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
													.setInteger("normal", DebitoCreditoSituacao.NORMAL)
													.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
													.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).uniqueResult()).intValue();
				}

			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 20/08/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasGrupoFaturamento(Integer anoMes, Collection colecaoGrupoFaturamento, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim, String inContasRevisao, Integer[] motivosRevisaoDisponiveis)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT cnta.id, cnta.referencia, cnta.dataVencimentoConta, cnta.valorAgua, cnta.valorEsgoto, "
							+ "cnta.debitos, cnta.valorCreditos, cnta.consumoAgua, cnta.consumoEsgoto, "
							+ "cnta.dataValidadeConta, cnta.dataRevisao, cnta.debitoCreditoSituacaoAtual, cnta.referenciaContabil, "
							+ "cnta.ultimaAlteracao, imov, dcsan, cnta.valorImposto " + "FROM Conta cnta " + "INNER JOIN cnta.imovel imov "
							+ "INNER JOIN imov.quadra quadra " + "INNER JOIN imov.rota rota " + "INNER JOIN rota.faturamentoGrupo ftgr "
							+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst " + "LEFT JOIN cnta.debitoCreditoSituacaoAnterior dcsan ";
							
			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())){
				consulta += "INNER JOIN cnta.contaMotivoRevisao cmr ";
			}else{
				consulta += "LEFT JOIN cnta.contaMotivoRevisao cmr ";
			}
						
			consulta += "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim " + "AND ftgr.id in (:colecaoGrupoFaturamento) "
							+ "AND cnta.debitoCreditoSituacaoAtual IN(:normal, :incluida, :retificada)";
							
			if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.SIM.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND cmr.id in (:motivosRevisaoDisponiveis) ";
			}else if(!Util.isVazioOuBranco(inContasRevisao) && inContasRevisao.equals(ConstantesSistema.NAO.toString())
							&& !Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
				consulta += "AND (cmr.id in (:motivosRevisaoDisponiveis) or cmr.id is null) ";
			}

			if(dataVencimentoContaInicio != null){

				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				consulta += "ORDER BY cnta.referencia";
				
				if(dataVencimentoContaFim != null){

					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaFim)
										.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();

					}else{
						retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();
					}

				}else{
					
					if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
						retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaInicio)
										.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();

					}else{
						retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
										.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
										.setInteger("normal", DebitoCreditoSituacao.NORMAL)
										.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
										.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
										.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
										.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();
					}

				}
			}else{
				consulta += "ORDER BY cnta.referencia";
				
				if(!Util.isVazioOrNulo(motivosRevisaoDisponiveis)){
					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
									.setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setParameterList("motivosRevisaoDisponiveis", motivosRevisaoDisponiveis).list();

				}else{
					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("colecaoGrupoFaturamento", colecaoGrupoFaturamento)
									.setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();
				}

			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasGrupoFaturamento(Integer anoMes, String idGrupoFaturamento, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection<Integer> colecaoIdsGrupoFaturamento = Util.converterStringParaColecaoInteger(idGrupoFaturamento, ";");

		try{ // 0 ,1
			consulta = "SELECT cnta, imov " + "FROM Conta cnta " + "INNER JOIN cnta.imovel imov " + "INNER JOIN imov.quadra quadra "
							+ "INNER JOIN cnta.rota rota " + "INNER JOIN rota.faturamentoGrupo ftgr "
							+ "INNER JOIN FETCH cnta.consumoTarifa cstf " + "INNER JOIN FETCH cnta.quadraConta quad "
							+ "INNER JOIN FETCH quad.setorComercial strc " + "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim "
							+ "AND ftgr.id in(:colecaoIdsGrupoFaturamento) "
							+ "AND cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if(dataVencimentoContaInicio != null){
				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if(dataVencimentoContaFim != null){

					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("colecaoIdsGrupoFaturamento", colecaoIdsGrupoFaturamento)
									.setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
									.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();

				}else{

					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("colecaoIdsGrupoFaturamento", colecaoIdsGrupoFaturamento)
									.setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
									.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();

				}
			}else{

				retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
								.setParameterList("colecaoIdsGrupoFaturamento", colecaoIdsGrupoFaturamento)
								.setInteger("normal", DebitoCreditoSituacao.NORMAL).setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os ids das contas de um grupo de faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdContasGrupoFaturamento(Integer anoMes, String idGrupoFaturamento, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection<Integer> colecaoIdsGrupo = Util.converterStringParaColecaoInteger(idGrupoFaturamento, ";");

		try{
			consulta = "SELECT cnta.id " + "FROM Conta cnta " + "INNER JOIN cnta.imovel imov " + "INNER JOIN imov.quadra quadra "
							+ "INNER JOIN cnta.rota rota " + "INNER JOIN rota.faturamentoGrupo ftgr "
							+ "INNER JOIN cnta.debitoCreditoSituacaoAtual dcst " + "WHERE cnta.referencia BETWEEN :anoMes AND :anoMesFim "
							+ "AND ftgr.id  in (:colecaoIdsGrupo) "
							+ "AND cnta.debitoCreditoSituacaoAtual in(:normal, :incluida, :retificada)";

			if(dataVencimentoContaInicio != null){
				consulta += " and cnta.dataVencimentoConta BETWEEN :dataVencimentoContaInicio AND :dataVencimentoContaFim ";

				if(dataVencimentoContaFim != null){

					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("colecaoIdsGrupo", colecaoIdsGrupo)
									.setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
									.setDate("dataVencimentoContaFim", dataVencimentoContaFim).list();

				}else{

					retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
									.setParameterList("colecaoIdsGrupo", colecaoIdsGrupo)
									.setInteger("normal", DebitoCreditoSituacao.NORMAL)
									.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
									.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
									.setDate("dataVencimentoContaInicio", dataVencimentoContaInicio)
									.setDate("dataVencimentoContaFim", dataVencimentoContaInicio).list();

				}
			}else{

				retorno = session.createQuery(consulta).setInteger("anoMes", anoMes).setInteger("anoMesFim", anoMesFim)
								.setParameterList("colecaoIdsGrupo", colecaoIdsGrupo).setInteger("normal", DebitoCreditoSituacao.NORMAL)
								.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
								.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA).list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0151] Alterar Vencimento Conta Author: Raphael Rossiter Data:
	 * 
	 * @autor Raphael Rossiter
	 * @data 22/08/2007
	 * @throws ErroRepositorioException
	 */
	public void alterarVencimentoContaGrupoFaturamento(Date dataVencimento, Date dataValidade, Short indicadorAlteracaoVencimento,
					Integer idGrupoFaturamento, Integer anoMes, Integer anoMesFim, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim) throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try{

			Connection jdbcCon = session.connection();

			update = "UPDATE conta SET " + "cnta_dtvencimentoconta = ?, cnta_dtvalidadeconta = ?, "
							+ "cnta_icalteracaovencimento = ?, cnta_tmultimaalteracao = ? " + "WHERE cnta_id IN( " + "SELECT cnta.cnta_id "
							+ "FROM conta cnta " + "INNER JOIN imovel imov on cnta.imov_id = imov.imov_id "
							+ "INNER JOIN quadra qdra on imov.qdra_id = qdra.qdra_id "
							+ "INNER JOIN rota rota on qdra.rota_id = rota.rota_id "
							+ "INNER JOIN faturamento_grupo ftgr on rota.ftgr_id = ftgr.ftgr_id "
							+ "INNER JOIN debito_credito_situacao dcst on cnta.dcst_idatual = dcst.dcst_id "
							+ "WHERE cnta.cnta_amreferenciaconta BETWEEN ? AND ? " + "AND ftgr.ftgr_id = ? "
							+ "AND dcst.dcst_id IN(?, ?, ?)";

			if(dataVencimentoContaInicio != null){
				update += " AND cnta.cnta_dtvencimentoconta BETWEEN ? AND ? ) ";

				if(dataVencimentoContaFim != null){

					st = jdbcCon.prepareStatement(update);

					st.setDate(1, Util.getSQLDate(dataVencimento));
					st.setDate(2, Util.getSQLDate(dataValidade));
					st.setShort(3, indicadorAlteracaoVencimento.shortValue());
					st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
					st.setInt(5, anoMes.intValue());
					st.setInt(6, anoMesFim.intValue());
					st.setInt(7, idGrupoFaturamento.intValue());
					st.setInt(8, DebitoCreditoSituacao.NORMAL.intValue());
					st.setInt(9, DebitoCreditoSituacao.INCLUIDA.intValue());
					st.setInt(10, DebitoCreditoSituacao.RETIFICADA.intValue());
					st.setDate(11, Util.getSQLDate(dataVencimentoContaInicio));
					st.setDate(12, Util.getSQLDate(dataVencimentoContaFim));

					st.executeUpdate();

				}else{

					st = jdbcCon.prepareStatement(update);

					st.setDate(1, Util.getSQLDate(dataVencimento));
					st.setDate(2, Util.getSQLDate(dataValidade));
					st.setShort(3, indicadorAlteracaoVencimento.shortValue());
					st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
					st.setInt(5, anoMes.intValue());
					st.setInt(6, anoMesFim.intValue());
					st.setInt(7, idGrupoFaturamento.intValue());
					st.setInt(8, DebitoCreditoSituacao.NORMAL.intValue());
					st.setInt(9, DebitoCreditoSituacao.INCLUIDA.intValue());
					st.setInt(10, DebitoCreditoSituacao.RETIFICADA.intValue());
					st.setDate(11, Util.getSQLDate(dataVencimentoContaInicio));
					st.setDate(12, Util.getSQLDate(dataVencimentoContaInicio));

					st.executeUpdate();

				}
			}else{

				update += ")";

				st = jdbcCon.prepareStatement(update);

				st.setDate(1, Util.getSQLDate(dataVencimento));
				st.setDate(2, Util.getSQLDate(dataValidade));
				st.setShort(3, indicadorAlteracaoVencimento.shortValue());
				st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
				st.setInt(5, anoMes.intValue());
				st.setInt(6, anoMesFim.intValue());
				st.setInt(7, idGrupoFaturamento.intValue());
				st.setInt(8, DebitoCreditoSituacao.NORMAL.intValue());
				st.setInt(9, DebitoCreditoSituacao.INCLUIDA.intValue());
				st.setInt(10, DebitoCreditoSituacao.RETIFICADA.intValue());

				st.executeUpdate();

			}

			// erro no hibernate
		}catch(SQLException e){
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			if(null != st) try{
				st.close();
			}catch(SQLException e){
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Metodo temporario para correção da base de dados
	 * Gerar Crédito a Realizar para os imóveis com contas com vencimento em
	 * 14/08/2007 com multa da conta 06/2007 cobrada na conta 07/2007 e que
	 * pagaram em 17/07/2007
	 * 
	 * @author Pedro Alexandre
	 * @date 20/08/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosImoveisParaGerarCreditoARealizarPorImoveisComContasComVencimento14082007()
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select imov.imov_id as imovid, " + "dbcb.dbcb_vlprestacao as prestacao, " + "loca.loca_id as locaid, "
							+ "qdra.qdra_id as qdraid,  " + "stcm.stcm_cdsetorcomercial as codsetor,  "
							+ "qdra.qdra_nnquadra as numeroqdra,  " + "imov.imov_nnlote as numerolote,  "
							+ "imov.imov_nnsublote as numerosublote, " + "dbcb.dbcb_amreferenciadebito as anomesreferenciadebito "
							+ "from conta cnta " + "left join debito_cobrado dbcb on cnta.cnta_id=dbcb.cnta_id "
							+ "inner join imovel imov on cnta.imov_id=imov.imov_id "
							+ "inner join localidade loca on imov.loca_id = loca.loca_id "
							+ "inner join setor_comercial stcm on imov.stcm_id=stcm.stcm_id "
							+ "inner join quadra qdra on imov.qdra_id=qdra.qdra_id  " + "where cnta.cnta_amreferenciaconta = 200707 "
							+ "and cnta.cnta_id = dbcb.cnta_id " + "and cnta.cnta_dtvencimentoconta = '2007-08-14' "
							+ "and dbcb.dbtp_id=80 " + "and dbcb.dbcb_amreferenciadebito=200706 " + "and cnta.dcst_idatual = 0 "
							+ "and exists (select pghi_id " + "from pagamento_historico pghi " + "where pghi.imov_id = cnta.imov_id "
							+ "and pghi.pghi_amreferenciapagamento=200706 " + "and pghi_dtpagamento < '2007-07-18') ";

			retorno = session.createSQLQuery(consulta).addScalar("imovid", Hibernate.INTEGER).addScalar("prestacao", Hibernate.BIG_DECIMAL)
							.addScalar("locaid", Hibernate.INTEGER).addScalar("qdraid", Hibernate.INTEGER)
							.addScalar("codsetor", Hibernate.INTEGER).addScalar("numeroqdra", Hibernate.INTEGER)
							.addScalar("numerolote", Hibernate.INTEGER).addScalar("numerosublote", Hibernate.INTEGER)
							.addScalar("anomesreferenciadebito", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 20/08/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarTipoConta(Integer idConta) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaTipo.id " + "from ContaImpressao contaImpressao " + "inner join contaImpressao.contaGeral contaGeral "
							+ "inner join contaImpressao.contaTipo contaTipo " + "where contaGeral.id = :idConta ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Date pesquisarFaturamentoAtividadeCronogramaDataPrevista(Integer faturamentoGrupoId, Integer faturamentoAtividadeId,
					Integer anoMesReferencia) throws ErroRepositorioException{

		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select fac.dataPrevista from FaturamentoAtividadeCronograma fac " + "inner join fac.faturamentoAtividade fa "
							+ "inner join fac.faturamentoGrupoCronogramaMensal fcm " + "inner join fcm.faturamentoGrupo fg "
							+ "where fg.id = :faturamentoGrupoId and fa.id = :faturamentoAtividadeId and "
							+ "fcm.anoMesReferencia = :anoMesReferencia";

			retorno = (Date) session.createQuery(consulta).setInteger("faturamentoGrupoId", faturamentoGrupoId.intValue())
							.setInteger("faturamentoAtividadeId", faturamentoAtividadeId).setInteger("anoMesReferencia", anoMesReferencia)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0216] Calcular Acrescimo por Impontualidade
	 * 
	 * @author Raphael Rossiter
	 * @date 28/08/2007
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaAtualizacaoTarifaria(Integer idConta) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT ")
							.append("cnt.id, ")
			// 0
							.append("cnt.consumoAgua, ")
							// 1
							.append("cnt.consumoEsgoto, ")
							// 2
							.append("ligacaoAguaSituacao.id, ")
							// 3
							.append("ligacaoEsgotoSituacao.id, ")
							// 4
							.append("consumoTarifa.id, ")
							// 5
							.append("cnt.percentualEsgoto, ")
							// 6
							.append("imovel.id, ")
							// 7
							.append("qdra.id, ")
							// 8
							.append("rota.id, ")
							// 9
							.append("ftgr.id, ")
							// 10
							.append("cnt.valorAgua, ")
							// 11
							.append("cnt.valorEsgoto, ")
							// 12
							.append("cnt.referencia ")
							// 13
							.append("FROM Conta cnt ").append("INNER JOIN cnt.consumoTarifa consumoTarifa ")
							.append("INNER JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao ")
							.append("INNER JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ").append("INNER JOIN cnt.imovel imovel ")
							.append("INNER JOIN imovel.quadra qdra ").append("INNER JOIN imovel.rota rota ")
							.append("INNER JOIN rota.faturamentoGrupo ftgr ").append("WHERE  cnt.id = :idConta ");

			retorno = (Object[]) session.createQuery(consulta.toString()).setInteger("idConta", idConta.intValue()).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/09/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeFaturaPorQualificador(Short codigoQualificador) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT COUNT(fatu.id)" + "FROM Fatura fatu " + "WHERE fatu.codigoQualifica = :codigoQualifica ";

			retorno = ((Number) session.createQuery(consulta).setShort("codigoQualifica", codigoQualificador).setMaxResults(1)
							.uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/09/2007
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarFaturaPorQualificador(Short codigoQualificador, Integer anoMesReferencia, BigDecimal valorDebito)
					throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT fatu.id, clie.id " + "FROM Fatura fatu " + "INNER JOIN fatu.cliente clie "
							+ "WHERE fatu.codigoQualifica = :codigoQualifica " + "AND fatu.anoMesReferencia = :anoMesReferencia "
							+ "AND fatu.debito = :valorDebito ";

			retorno = (Object[]) session.createQuery(consulta).setShort("codigoQualifica", codigoQualificador)
							.setInteger("anoMesReferencia", anoMesReferencia).setBigDecimal("valorDebito", valorDebito).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * [SF0003] - Processar Pagamento de Documento de Cobrança
	 * 
	 * @author Sávio Luiz
	 * @created 16/02/2006
	 * @author Saulo Lima
	 * @date 12/08/2009
	 *       Alteração para retornar o id da contaHistorico, quando existir.
	 * @param matriculaImovel
	 *            Matrícula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarFaturaItem(Integer idFatura) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			consulta = "SELECT fi.valorConta, conta.id, localidade.id, "
							+ "imovel.id, localidadeHistorico.id, imovelHistorico.id, contaHistorico.id " + "FROM FaturaItem fi "
							+ "LEFT JOIN fi.fatura fatura " + "LEFT JOIN fi.contaGeral contaGeral " + "LEFT JOIN contaGeral.conta conta "
							+ "LEFT JOIN contaGeral.contaHistorico contaHistorico " + "LEFT JOIN conta.imovel imovel "
							+ "LEFT JOIN conta.localidade localidade " + "LEFT JOIN contaHistorico.imovel imovelHistorico "
							+ "LEFT JOIN contaHistorico.localidade localidadeHistorico " + "WHERE fatura.id = :idFatura ";

			retorno = session.createQuery(consulta).setInteger("idFatura", idFatura).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [UC0637] - Gerar Relatórios Volumes Faturados
	 * 
	 * @author Rafael Corrêa
	 * @created 11/09/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioVolumesFaturados(Integer idLocalidade, Integer anoMes, Integer anoMesInformado,
					Integer anoMes1, Integer anoMes2, Integer anoMes3, Integer anoMes4, Integer anoMes5) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			consulta = "SELECT DISTINCT imov.imov_id as idImovel, loc.loca_id as idLocalidade, "
							+ " loc.loca_nmlocalidade as nomeLocalidade, stcm.stcm_id as idSetor, "
							+ " stcm.stcm_cdsetorcomercial as codSetor, stcm.stcm_nmsetorcomercial as nomeSetor, "
							+ " quadra.qdra_id as idQuadra, quadra.qdra_nnquadra as numeroQuadra, "
							+ " clieUsuario.clie_nmcliente as nomeUsuario, "
							+ " imov.last_id as situacaoAgua, imov.lest_id as situacaoEsgoto, "
							// +
							// " CASE WHEN (consHistMes.cshi_nnconsumomedio is not null and consHistMes.cshi_nnconsumomedio <> 0) THEN "
							+ " consHistMes.cshi_nnconsumomedio "
							// + " ELSE "
							// + " 10 END "
							+ " as consumoMedio, " + " consHistMesInformado.cshi_nnconsumofaturadomes as consumoMesInformado, "
							+ " consHistMes1.cshi_nnconsumofaturadomes as consumoMes1, "
							+ " consHistMes2.cshi_nnconsumofaturadomes as consumoMes2, "
							+ " consHistMes3.cshi_nnconsumofaturadomes as consumoMes3, "
							+ " consHistMes4.cshi_nnconsumofaturadomes as consumoMes4, "
							+ " consHistMes5.cshi_nnconsumofaturadomes as consumoMes5 " + " FROM imovel imov "
							+ " INNER JOIN ligacao_agua ligAgua " + " on imov.imov_id = ligAgua.lagu_id " + " INNER JOIN localidade loc "
							+ " on imov.loca_id = loc.loca_id " + " INNER JOIN setor_comercial stcm " + " on imov.stcm_id = stcm.stcm_id "
							+ " INNER JOIN quadra quadra " + " on imov.qdra_id = quadra.qdra_id "
							+ " INNER JOIN cliente_imovel clieImovUsuario " + " on imov.imov_id = clieImovUsuario.imov_id "
							+ " and clieImovUsuario.crtp_id = "
							+ ClienteRelacaoTipo.USUARIO
							+ " and clieImovUsuario.clim_dtrelacaofim is null "
							+ " INNER JOIN cliente clieUsuario "
							+ " on clieImovUsuario.clie_id = clieUsuario.clie_id "
							+ " LEFT OUTER JOIN consumo_historico consHistMes "
							+ " on imov.imov_id = consHistMes.imov_id and consHistMes.cshi_amfaturamento = :anoMes "
							+ " and consHistMes.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMesInformado "
							+ " on imov.imov_id = consHistMesInformado.imov_id and consHistMesInformado.cshi_amfaturamento = :anoMesInformado "
							+ " and consHistMesInformado.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes1 "
							+ " on imov.imov_id = consHistMes1.imov_id and consHistMes1.cshi_amfaturamento = :anoMes1 "
							+ " and consHistMes1.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes2 "
							+ " on imov.imov_id = consHistMes2.imov_id and consHistMes2.cshi_amfaturamento = :anoMes2 "
							+ " and consHistMes2.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes3 "
							+ " on imov.imov_id = consHistMes3.imov_id and consHistMes3.cshi_amfaturamento = :anoMes3 "
							+ " and consHistMes3.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes4 "
							+ " on imov.imov_id = consHistMes4.imov_id and consHistMes4.cshi_amfaturamento = :anoMes4 "
							+ " and consHistMes4.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes5 "
							+ " on imov.imov_id = consHistMes5.imov_id and consHistMes5.cshi_amfaturamento = :anoMes5 "
							+ " and consHistMes5.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " WHERE imov.loca_id = :idLocalidade "
							+ " and ligAgua.hidi_id is not null "
							+ " ORDER BY loc.loca_id, stcm.stcm_cdsetorcomercial, quadra.qdra_nnquadra, imov.imov_id ";

			retorno = session.createSQLQuery(consulta).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("nomeLocalidade", Hibernate.STRING)
							.addScalar("idSetor", Hibernate.INTEGER).addScalar("codSetor", Hibernate.INTEGER)
							.addScalar("nomeSetor", Hibernate.STRING).addScalar("idQuadra", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("nomeUsuario", Hibernate.STRING)
							.addScalar("situacaoAgua", Hibernate.INTEGER).addScalar("situacaoEsgoto", Hibernate.INTEGER)
							.addScalar("consumoMedio", Hibernate.INTEGER).addScalar("consumoMesInformado", Hibernate.INTEGER)
							.addScalar("consumoMes1", Hibernate.INTEGER).addScalar("consumoMes2", Hibernate.INTEGER)
							.addScalar("consumoMes3", Hibernate.INTEGER).addScalar("consumoMes4", Hibernate.INTEGER)
							.addScalar("consumoMes5", Hibernate.INTEGER).setInteger("anoMes", anoMes)
							.setInteger("anoMesInformado", anoMesInformado).setInteger("anoMes1", anoMes1).setInteger("anoMes2", anoMes2)
							.setInteger("anoMes3", anoMes3).setInteger("anoMes4", anoMes4).setInteger("anoMes5", anoMes5)
							.setInteger("idLocalidade", idLocalidade).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório resumido
	 * [UC0637] - Gerar Relatórios Volumes Faturados
	 * 
	 * @author Rafael Corrêa
	 * @created 13/09/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioVolumesFaturadosResumido(Integer idLocalidade, Integer anoMes, Integer anoMesInformado,
					Integer anoMes1, Integer anoMes2, Integer anoMes3, Integer anoMes4, Integer anoMes5) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			consulta = "SELECT DISTINCT loc.loca_id as idLocalidade, "
							+ " loc.loca_nmlocalidade as nomeLocalidade, stcm.stcm_id as idSetor, "
							+ " stcm.stcm_cdsetorcomercial as codSetor, stcm.stcm_nmsetorcomercial as nomeSetor, "
							+ " quadra.qdra_nnquadra as numeroQuadra, " + " sum(consHistMes.cshi_nnconsumomedio) as consumoMedio, "
							+ " sum(consHistMesInformado.cshi_nnconsumofaturadomes) as consumoMesInformado, "
							+ " sum(consHistMes1.cshi_nnconsumofaturadomes) as consumoMes1, "
							+ " sum(consHistMes2.cshi_nnconsumofaturadomes) as consumoMes2, "
							+ " sum(consHistMes3.cshi_nnconsumofaturadomes) as consumoMes3, "
							+ " sum(consHistMes4.cshi_nnconsumofaturadomes) as consumoMes4, "
							+ " sum(consHistMes5.cshi_nnconsumofaturadomes) as consumoMes5 " + " FROM imovel imov "
							+ " INNER JOIN ligacao_agua ligAgua " + " on imov.imov_id = ligAgua.lagu_id " + " INNER JOIN localidade loc "
							+ " on imov.loca_id = loc.loca_id " + " INNER JOIN setor_comercial stcm " + " on imov.stcm_id = stcm.stcm_id "
							+ " INNER JOIN quadra quadra " + " on imov.qdra_id = quadra.qdra_id "
							+ " LEFT OUTER JOIN consumo_historico consHistMes "
							+ " on imov.imov_id = consHistMes.imov_id and consHistMes.cshi_amfaturamento = :anoMes "
							+ " and consHistMes.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMesInformado "
							+ " on imov.imov_id = consHistMesInformado.imov_id and consHistMesInformado.cshi_amfaturamento = :anoMesInformado "
							+ " and consHistMesInformado.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes1 "
							+ " on imov.imov_id = consHistMes1.imov_id and consHistMes1.cshi_amfaturamento = :anoMes1 "
							+ " and consHistMes1.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes2 "
							+ " on imov.imov_id = consHistMes2.imov_id and consHistMes2.cshi_amfaturamento = :anoMes2 "
							+ " and consHistMes2.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes3 "
							+ " on imov.imov_id = consHistMes3.imov_id and consHistMes3.cshi_amfaturamento = :anoMes3 "
							+ " and consHistMes3.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes4 "
							+ " on imov.imov_id = consHistMes4.imov_id and consHistMes4.cshi_amfaturamento = :anoMes4 "
							+ " and consHistMes4.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " LEFT OUTER JOIN consumo_historico consHistMes5 "
							+ " on imov.imov_id = consHistMes5.imov_id and consHistMes5.cshi_amfaturamento = :anoMes5 "
							+ " and consHistMes5.lgti_id = "
							+ LigacaoTipo.LIGACAO_AGUA.toString()
							+ " WHERE imov.loca_id = :idLocalidade "
							+ " and ligAgua.hidi_id is not null "
							+ " GROUP BY loc.loca_id, loc.loca_nmlocalidade, stcm.stcm_id, stcm.stcm_cdsetorcomercial, "
							+ " stcm.stcm_nmsetorcomercial, quadra.qdra_nnquadra "
							+ " ORDER BY loc.loca_id, stcm.stcm_cdsetorcomercial, quadra.qdra_nnquadra ";

			retorno = session.createSQLQuery(consulta).addScalar("idLocalidade", Hibernate.INTEGER)
							.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("idSetor", Hibernate.INTEGER)
							.addScalar("codSetor", Hibernate.INTEGER).addScalar("nomeSetor", Hibernate.STRING)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("consumoMedio", Hibernate.INTEGER)
							.addScalar("consumoMesInformado", Hibernate.INTEGER).addScalar("consumoMes1", Hibernate.INTEGER)
							.addScalar("consumoMes2", Hibernate.INTEGER).addScalar("consumoMes3", Hibernate.INTEGER)
							.addScalar("consumoMes4", Hibernate.INTEGER).addScalar("consumoMes5", Hibernate.INTEGER)
							.setInteger("anoMes", anoMes).setInteger("anoMesInformado", anoMesInformado).setInteger("anoMes1", anoMes1)
							.setInteger("anoMes2", anoMes2).setInteger("anoMes3", anoMes3).setInteger("anoMes4", anoMes4)
							.setInteger("anoMes5", anoMes5).setInteger("idLocalidade", idLocalidade).list();
			System.out.println(consulta);
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioContasRevisao(Integer idGerenciaRegional, Integer idUnidadeNegocio, Integer idElo,
					Integer idLocalidadeInicial, Integer idLocalidadeFinal, Integer idMotivoRevisao, Integer idImovelPerfil,
					Integer referenciaInicial, Integer referenciaFinal) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		StringBuilder consulta = new StringBuilder();

		try{

			String where = this.criarCondicionaisRelatorioContasRevisao(idGerenciaRegional, idUnidadeNegocio, idElo, idLocalidadeInicial,
							idLocalidadeFinal, idMotivoRevisao, idImovelPerfil, referenciaInicial, referenciaFinal);

			consulta.append("SELECT DISTINCT imov.imov_id as idImovel, ");
			consulta.append(" 		 		 gerReg.greg_id as idGerencia, ");
			consulta.append(" 		 		 gerReg.greg_nmabreviado as nomeGerencia, ");
			consulta.append(" 		 		 elo.loca_id as idElo, ");
			consulta.append(" 		 		 elo.loca_nmlocalidade as nomeElo, ");
			consulta.append(" 		 		 loc.loca_id as idLocalidade, ");
			consulta.append(" 		 		 loc.loca_nmlocalidade as nomeLocalidade, ");
			consulta.append(" 		 		 setor.stcm_cdsetorcomercial as codigoSetor, ");
			consulta.append(" 		 		 quadra.qdra_nnquadra as numeroQuadra, ");
			consulta.append(" 		 		 imov.imov_nnlote as lote, ");
			consulta.append(" 		 		 imov.imov_nnsublote as sublote, ");
			consulta.append(" 		 		 clieUsuario.clie_nmcliente as nomeClienteUsuario, ");
			consulta.append(" 		 		 clieUsuarioFone.cfon_cdddd as dddFoneUsuario, ");
			consulta.append(" 		 		 clieUsuarioFone.cfon_nnfone as numeroFoneUsuario, ");
			consulta.append(" 		 		 clieUsuarioFone.cfon_nnfoneramal AS ramalFoneUsuario, ");
			consulta.append(" 		 		 conta.cnta_amreferenciaconta AS anoMesReferencia, ");
			consulta.append(" 		 		 (conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - coalesce( conta.cnta_vlimpostos, 0 ) ) as valorConta, ");
			consulta.append(" 		 		 conta.cnta_dtrevisao as dataRevisao, ");
			consulta.append(" 		 		 contaMotRev.cmrv_id as idMotivoRevisao, ");
			consulta.append(" 		 		 contaMotRev.cmrv_dsmotivorevisaoconta AS descricaoMotivoRevisao, ");
			consulta.append(" 		 		 undNeg.uneg_id as idUnidadeNegocio, ");
			consulta.append(" 		 		 undNeg.uneg_nmabreviado as nomeUnidadeNegocio, ");
			consulta.append(" 		 		 iper.iper_id as idImovelPerfil, ");
			consulta.append(" 		 		 iper.iper_dsimovelperfil as descricaoImovelPerfil, ");
			consulta.append(" 		 		 CASE ");
			consulta.append(" 		 		 	WHEN pagto.pgmt_id IS NULL THEN ' ' ");
			consulta.append(" 		 		 	ELSE '*' ");
			consulta.append("				 END AS pagto ");
			consulta.append(" FROM imovel imov ");
			consulta.append(" INNER JOIN IMOVEL_PERFIL iper ON imov.iper_id = iper.iper_id");
			consulta.append(" INNER JOIN conta conta ON conta.imov_id = imov.imov_id ");
			consulta.append("		 AND conta.cnta_dtrevisao IS NOT NULL ");
			consulta.append("    	 AND conta.dcst_idatual IN (");
			consulta.append(DebitoCreditoSituacao.NORMAL);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.RETIFICADA);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.INCLUIDA);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
			consulta.append(") ");
			consulta.append(" INNER JOIN cliente_imovel clieImovUsuario ON clieImovUsuario.imov_id = imov.imov_id ");
			consulta.append(" 		 AND clieImovUsuario.crtp_id = " + ClienteRelacaoTipo.USUARIO);
			consulta.append(" 		 AND clieImovUsuario.clim_dtrelacaofim IS NULL ");
			consulta.append(" INNER JOIN cliente clieUsuario ON clieUsuario.clie_id = clieImovUsuario.clie_id ");
			consulta.append(" INNER JOIN setor_comercial setor ON setor.stcm_id = imov.stcm_id ");
			consulta.append(" INNER JOIN quadra quadra ON quadra.qdra_id = imov.qdra_id ");
			consulta.append(" INNER JOIN localidade loc ON loc.loca_id = imov.loca_id ");
			consulta.append(" INNER JOIN localidade elo ON elo.loca_id = loc.loca_cdelo ");
			consulta.append(" INNER JOIN gerencia_regional gerReg ON gerReg.greg_id = loc.greg_id ");
			consulta.append(" LEFT OUTER JOIN unidade_negocio undNeg ON undNeg.uneg_id = loc.uneg_id ");
			consulta.append(" LEFT OUTER JOIN cliente_fone clieUsuarioFone ON clieUsuarioFone.clie_id = clieUsuario.clie_id ");
			consulta.append(" 			  AND clieUsuarioFone.cfon_icfonepadrao = " + ClienteFone.INDICADOR_FONE_PADRAO);
			consulta.append(" LEFT OUTER JOIN conta_motivo_revisao contaMotRev ON contaMotRev.cmrv_id = conta.cmrv_id ");
			consulta.append(" LEFT OUTER JOIN pagamento pagto ON pagto.cnta_id = conta.cnta_id ");

			consulta.append(where);
			consulta.append(" ORDER BY gerReg.greg_id, elo.loca_id, loc.loca_id, setor.stcm_cdsetorcomercial,  quadra.qdra_nnquadra, imov.imov_nnlote, imov.imov_nnsublote, conta.cnta_amreferenciaconta");

			retorno = session.createSQLQuery(consulta.toString()).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idGerencia", Hibernate.INTEGER).addScalar("nomeGerencia", Hibernate.STRING)
							.addScalar("idElo", Hibernate.INTEGER).addScalar("nomeElo", Hibernate.STRING)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("nomeLocalidade", Hibernate.STRING)
							.addScalar("codigoSetor", Hibernate.INTEGER).addScalar("numeroQuadra", Hibernate.INTEGER)
							.addScalar("lote", Hibernate.SHORT).addScalar("sublote", Hibernate.SHORT)
							.addScalar("nomeClienteUsuario", Hibernate.STRING).addScalar("dddFoneUsuario", Hibernate.STRING)
							.addScalar("numeroFoneUsuario", Hibernate.STRING).addScalar("ramalFoneUsuario", Hibernate.STRING)
							.addScalar("anoMesReferencia", Hibernate.INTEGER).addScalar("valorConta", Hibernate.BIG_DECIMAL)
							.addScalar("dataRevisao", Hibernate.DATE).addScalar("idMotivoRevisao", Hibernate.INTEGER)
							.addScalar("descricaoMotivoRevisao", Hibernate.STRING).addScalar("idUnidadeNegocio", Hibernate.INTEGER)
							.addScalar("nomeUnidadeNegocio", Hibernate.STRING).addScalar("idImovelPerfil", Hibernate.INTEGER)
							.addScalar("descricaoImovelPerfil", Hibernate.STRING).addScalar("pagto", Hibernate.STRING).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * pesquisa os dados nessesários para a geracao do relatório analitico de contas
	 * 
	 * @author Adriano Sousa
	 * @created09/10/2014
	 * @throws ControladorException
	 */

	// MINHA QUERY
	public Collection pesquisarDadosRelatorioAnaliticoContas(Integer idGerenciaRegional, Integer idLocalidade, Integer idCategoria,
					Integer idCliente, Integer idImovel, Integer idSituacao, Integer motivoRetificacao, Integer referencia,
					Integer faturamentoGrupo, Integer setorComercial, Integer quadra) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();


		// int mes = Util.obterMes(referencia);

		Collection retorno = null;
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append(" 	 select 'Histórico (1,2,3,5)' Origem,  ");
			consulta.append(" 			ch.imov_id MATRICULA,  ");
			consulta.append("       (SELECT CL.CLIE_NMCLIENTE  ");
			consulta.append("         FROM CLIENTE_CONTA_HISTORICO CC   ");
			consulta.append("         INNER JOIN CLIENTE CL ON (CL.CLIE_ID = CC.CLIE_ID)  ");
			consulta.append("         WHERE CC.CNTA_ID = CH.CNTA_ID AND CC.CLCH_ICNOMECONTA = 1) USUARIO_TITULAR_CONTA,  ");
			consulta.append(" 			ch.cnhi_amreferenciaconta REFERENCIA,   ");
			consulta.append(" 			(select ch_2.cnhi_vlagua+ch_2.cnhi_vlesgoto+ch_2.cnhi_vldebitos-ch_2.cnhi_vlcreditos-ch_2.cnhi_vlimpostos   ");
			consulta.append(" 			from conta_historico ch_2    ");
			consulta.append(" 			where ch_2.cnta_id = ( select min(ch_3.cnta_id) from conta_historico ch_3   ");
			consulta.append(" 			                        where ch_3.imov_id = ch.imov_id    ");
			consulta.append(" 			                          and ch_3.cnhi_amreferenciaconta = ch.cnhi_amreferenciaconta   ");
			consulta.append(" 			                          and ch_3.dcst_idatual = 7   ");
			consulta.append(" 			                          and ch_3.cnhi_tmultimaalteracao < ch.cnhi_tmultimaalteracao  ");
			consulta.append("                                 	  and to_char(trunc(ch_3.cnhi_tmultimaalteracao),'yyyymm') = :referencia  )) VALOR_ORIGINAL,  ");
			consulta.append(" 			ch.cnhi_vlagua+ch.cnhi_vlesgoto+ch.cnhi_vldebitos-ch.cnhi_vlcreditos-ch.cnhi_vlimpostos VALOR_REFATURADO,   ");
			consulta.append(" 			ch.cnhi_tmultimaalteracao DATA_FATURAMENTO,    ");
			consulta.append(" 			 TO_CHAR(ch.cnhi_tmultimaalteracao, 'hh24:mi') AS HORA_ALTERACAO,  ");
			consulta.append(" 			cmr.CMRT_DSMOTIVORETIFICACAOCONTA MOTIVO_REFATURAMENTO,  ");
			consulta.append(" 			u.USUR_NMLOGIN  USUARIO_GSAN  ");
			consulta.append(" 	from conta_historico ch    ");
			consulta.append(" 	inner join conta_motivo_retificacao cmr on (ch.cmrt_id = cmr.cmrt_id)  ");
			consulta.append(" 	left join usuario u on (ch.usur_id = u.usur_id)  ");
			consulta.append("   left join conta_categoria cct on (ch.cnta_id=cct.cnta_id) ");
			consulta.append("   left join cliente_conta clct on (ch.cnta_id = clct.cnta_id) ");
			consulta.append("   left join localidade l on (l.loca_id = ch.loca_id) ");
			consulta.append("   inner join imovel i on (ch.imov_id = i.imov_id) ");
			consulta.append("   inner join ROTA r on (i.ROTA_ID = r.rota_id) ");
			consulta.append(" 	where ch.dcst_idatual in (1,2,3,5)   ");

			// verifica motivoRetificacao
			if(motivoRetificacao != null){
				consulta.append("AND ch.cmrt_id = :motivoRetificacao ");
			}
			// verifica idcategoria
			if(idCategoria != null){
				consulta.append("AND cct.catg_id = :idCategoria  ");
			}
			// verifica id situacao
			if(idSituacao != null){
				consulta.append("AND ch.dcst_idatual  = :idSituacao  ");
			}
			// verifica localidade
			if(idLocalidade != null){
				consulta.append("AND ch.LOCA_ID   = :idLocalidade  ");
			}
			// verifica se a idImovel não é null
			if(idImovel != null){
				consulta.append("AND ch.imov_id   = :idImovel  ");
			}
			// verifica se a IdCliente não é null
			if(idCliente != null){
				consulta.append("AND clct.CLIE_ID = :idCliente   ");
			}
			// verifica idGerenciaRegional
			if(idGerenciaRegional != null){
				consulta.append("AND l.greg_id =:idGerenciaRegional ");
			}
			if(quadra != null){
				consulta.append("AND ch.CNHI_NNQUADRA = :quadra ");
			}
			if(setorComercial != null){
				consulta.append(" AND ch.CNHI_CDSETORCOMERCIAL = :setorComercial ");
			}
			if(faturamentoGrupo != null){
				consulta.append(" AND r.ftgr_id = :faturamentoGrupo ");
			}

			consulta.append("and exists (select * from conta_historico ch_1   ");
			consulta.append("            where ch.imov_id = ch_1.imov_id   ");
			consulta.append("              and ch_1.cnhi_amreferenciaconta = ch.cnhi_amreferenciaconta  ");
			consulta.append("              and ch_1.dcst_idatual = 7  ");
			consulta.append("              and to_char(trunc(ch_1.cnhi_tmultimaalteracao),'yyyymm') = :referencia  ");
			consulta.append("              and ch.cnhi_tmultimaalteracao > ch_1.cnhi_tmultimaalteracao )  ");
			consulta.append("union  ");
			consulta.append("   select 'Conta (1) com historico (7)' Origem,  ");
			consulta.append("     ch.imov_id MATRICULA,  ");
			consulta.append("     (SELECT CL.CLIE_NMCLIENTE   ");
			consulta.append("      FROM CLIENTE_CONTA_HISTORICO CC   ");
			consulta.append("      INNER JOIN CLIENTE CL ON (CL.CLIE_ID = CC.CLIE_ID)  ");
			consulta.append("      WHERE CC.CNTA_ID = CH.CNTA_ID AND CC.CLCH_ICNOMECONTA = 1) USUARIO_TITULAR_CONTA,  ");
			consulta.append("      ch.CNTA_AMREFERENCIACONTA REFERENCIA,   ");
			consulta.append("      (select ch_2.cnhi_vlagua+ch_2.cnhi_vlesgoto+ch_2.cnhi_vldebitos-ch_2.cnhi_vlcreditos-ch_2.cnhi_vlimpostos  ");
			consulta.append("      from conta_historico ch_2   ");
			consulta.append("      where ch_2.cnta_id = ( select min(ch_3.cnta_id) from conta_historico ch_3  ");
			consulta.append("                             where ch_3.imov_id = ch.imov_id   ");
			consulta.append("                             and ch_3.cnhi_amreferenciaconta = ch.cnta_amreferenciaconta  ");
			consulta.append("                             and ch_3.dcst_idatual = 7  ");
			consulta.append("                             and to_char(trunc(ch_3.cnhi_tmultimaalteracao),'yyyymm') = :referencia  )) VALOR_ORIGINAL,  ");
			consulta.append("      (ch.cnta_vlagua+ch.cnta_vlesgoto+ch.cnta_vldebitos-ch.cnta_vlcreditos-ch.cnta_vlimpostos) VALOR_REFATURADO,  ");
			consulta.append("      ch.CNTA_TMULTIMAALTERACAO DATA_FATURAMENTO,    ");
			consulta.append(" 		 TO_CHAR(ch.CNTA_TMULTIMAALTERACAO, 'hh24:mi') AS HORA_ALTERACAO,  ");
			consulta.append(" 		 cmr.CMRT_DSMOTIVORETIFICACAOCONTA MOTIVO_REFATURAMENTO,  ");
			consulta.append("      u.USUR_NMLOGIN  USUARIO_GSAN  ");
			consulta.append("     from conta ch   ");
			consulta.append("     INNER join conta_motivo_retificacao cmr on (ch.cmrt_id = cmr.cmrt_id)  ");
			consulta.append("     left join usuario u on (ch.usur_id = u.usur_id)  ");
			consulta.append("     left join conta_categoria cct on (ch.cnta_id=cct.cnta_id) ");
			consulta.append("     left join cliente_conta clct on (ch.cnta_id = clct.cnta_id) ");
			consulta.append("     left join localidade l on (l.loca_id = ch.loca_id) ");
			consulta.append("   inner join imovel i on (ch.imov_id = i.imov_id) ");
			consulta.append("   inner join ROTA r on (i.ROTA_ID = r.rota_id) ");
			consulta.append("     where cnta_amreferenciaconta = :referencia    ");
			consulta.append("     and ch.dcst_idatual in (1)   ");
			consulta.append("     and exists (select * from conta_historico ch_1   ");
			consulta.append("                 where ch.imov_id = ch_1.imov_id   ");
			consulta.append("                  and ch_1.cnhi_amreferenciaconta = ch.cnta_amreferenciaconta  ");
			consulta.append("                  and ch_1.dcst_idatual = 7  ");
			consulta.append("                  and to_char(trunc(ch_1.cnhi_tmultimaalteracao),'yyyymm') = :referencia  )  ");
			// verifica motivoRetificacao
			if(motivoRetificacao != null){
				consulta.append("AND ch.cmrt_id = :motivoRetificacao ");
			}
			// verifica idcategoria
			if(idCategoria != null){
				consulta.append("AND cct.catg_id = :idCategoria  ");
			}
			// verifica id situacao
			if(idSituacao != null){
				consulta.append("AND ch.dcst_idatual  = :idSituacao  ");
			}
			// verifica localidade
			if(idLocalidade != null){
				consulta.append("AND ch.LOCA_ID   = :idLocalidade  ");
			}
			// verifica se a idImovel não é null
			if(idImovel != null){
				consulta.append("AND ch.imov_id   =:idImovel   ");
			}
			// verifica idGerenciaRegional
			if(idGerenciaRegional != null){
				consulta.append("AND l.greg_id =:idGerenciaRegional ");
			}
			// verifica se a IdCliente não é null
			if(idCliente != null){
				consulta.append("AND clct.CLIE_ID = :idCliente   ");
			}
			if(quadra != null){
				consulta.append("AND ch.CNTA_NNQUADRA = :quadra ");
			}
			if(setorComercial != null){
				consulta.append(" AND ch.CNTA_CDSETORCOMERCIAL = :setorComercial ");
			}
			if(faturamentoGrupo != null){
				consulta.append(" AND r.ftgr_id = :faturamentoGrupo ");
			}
			consulta.append("and exists (select * from conta_historico ch_1   ");
			consulta.append("            where ch.imov_id = ch_1.imov_id   ");
			consulta.append("              and ch_1.cnhi_amreferenciaconta = ch.cnta_amreferenciaconta  ");
			consulta.append("              and to_char(trunc(ch_1.cnhi_tmultimaalteracao),'yyyymm') = :referencia  ");
			consulta.append("              and ch_1.dcst_idatual = 7 )  ");
			consulta.append(" union  ");
			consulta.append("   select 'Histórico (3)' Origem,  ");
			consulta.append("   ch.imov_id MATRICULA,  ");
			consulta.append("   (SELECT CL.CLIE_NMCLIENTE  ");
			consulta.append("           FROM CLIENTE_CONTA_HISTORICO CC   ");
			consulta.append("           INNER JOIN CLIENTE CL ON (CL.CLIE_ID = CC.CLIE_ID)  ");
			consulta.append("           WHERE CC.CNTA_ID = CH.CNTA_ID AND CC.CLCH_ICNOMECONTA = 1) USUARIO_TITULAR_CONTA,  ");
			consulta.append("   ch.cnhi_amreferenciaconta REFERENCIA,  ");
			consulta.append("   ch.cnhi_vlagua+ch.cnhi_vlesgoto+ch.cnhi_vldebitos-ch.cnhi_vlcreditos-ch.cnhi_vlimpostos  VALOR_ORIGINAL,  ");
			consulta.append("   0 VALOR_REFATURADO,  ");
			consulta.append("   ch.cnhi_tmultimaalteracao DATA_FATURAMENTO,  ");
			consulta.append("   TO_CHAR(ch.cnhi_tmultimaalteracao, 'hh24:mi') AS HORA_ALTERACAO,  ");
			consulta.append("   cmr.CMRT_DSMOTIVORETIFICACAOCONTA MOTIVO_REFATURAMENTO,  ");
			consulta.append("   u.USUR_NMLOGIN  USUARIO_GSAN  ");
			consulta.append("   from conta_historico ch   ");
			consulta.append("  INNER join conta_motivo_retificacao cmr on (ch.cmrt_id = cmr.cmrt_id)  ");
			consulta.append("     left join usuario u on (ch.usur_id = u.usur_id)  ");
			consulta.append("     left join conta_categoria cct on (ch.cnta_id=cct.cnta_id) ");
			consulta.append("     left join cliente_conta clct on (ch.cnta_id = clct.cnta_id) ");
			consulta.append("     left join localidade l on (l.loca_id = ch.loca_id) ");
			consulta.append("   inner join imovel i on (ch.imov_id = i.imov_id) ");
			consulta.append("   inner join ROTA r on (i.ROTA_ID = r.rota_id) ");
			consulta.append("   where cnhi_amreferenciaconta = :referencia  ");
			consulta.append("   and ch.dcst_idatual in (3)   ");
			// verifica motivoRetificacao
			if(motivoRetificacao != null){
				consulta.append("AND ch.cmrt_id = :motivoRetificacao ");
			}
			// verifica idcategoria
			if(idCategoria != null){
				consulta.append("AND cct.catg_id = :idCategoria  ");
			}
			// verifica id situacao
			if(idSituacao != null){
				consulta.append("AND ch.dcst_idatual   = :idSituacao   ");
			}
			// verifica localidade
			if(idLocalidade != null){
				consulta.append("AND ch.LOCA_ID   = :idLocalidade  ");
			}
			// verifica se a idImovel não é null
			if(idImovel != null){
				consulta.append("AND ch.imov_id   = :idImovel  ");
			}
			// verifica idGerenciaRegional
			if(idGerenciaRegional != null){
				consulta.append("AND l.greg_id =:idGerenciaRegional  ");
			}
			// verifica se a IdCliente não é null
			if(idCliente != null){
				consulta.append("AND clct.CLIE_ID = :idCliente   ");
			}
			if(quadra != null){
				consulta.append("AND ch.CNHI_NNQUADRA = :quadra ");
			}
			if(setorComercial != null){
				consulta.append(" AND ch.CNHI_CDSETORCOMERCIAL = :setorComercial ");
			}
			if(faturamentoGrupo != null){
				consulta.append(" AND r.ftgr_id = :faturamentoGrupo ");
			}
			consulta.append(" union   ");
			consulta.append("   select 'Histórico (2)' Origem,  ");
			consulta.append("   ch.imov_id MATRICULA,  ");
			consulta.append("   (SELECT CL.CLIE_NMCLIENTE   ");
			consulta.append("           FROM CLIENTE_CONTA_HISTORICO CC   ");
			consulta.append("           INNER JOIN CLIENTE CL ON (CL.CLIE_ID = CC.CLIE_ID)  ");
			consulta.append("           WHERE CC.CNTA_ID = CH.CNTA_ID AND CC.CLCH_ICNOMECONTA = 1) USUARIO_TITULAR_CONTA,  ");
			consulta.append("   ch.cnhi_amreferenciaconta REFERENCIA,   ");
			consulta.append("   0  VALOR_ORIGINAL,  ");
			consulta.append("   (ch.cnhi_vlagua+ch.cnhi_vlesgoto+ch.cnhi_vldebitos-ch.cnhi_vlcreditos-ch.cnhi_vlimpostos) VALOR_REFATURADO,  ");
			consulta.append("   ch.cnhi_tmultimaalteracao DATA_FATURAMENTO,    ");
			consulta.append("   TO_CHAR(ch.cnhi_tmultimaalteracao, 'hh24:mi') AS HORA_ALTERACAO,  ");
			consulta.append("   cmr.CMRT_DSMOTIVORETIFICACAOCONTA MOTIVO_REFATURAMENTO,  ");
			consulta.append("   u.USUR_NMLOGIN  USUARIO_GSAN  ");
			consulta.append("   from conta_historico ch   ");
			consulta.append("   INNER JOIN conta_motivo_retificacao cmr ON (ch.cmrt_id = cmr.cmrt_id) ");
			consulta.append("   left join usuario u on (ch.usur_id = u.usur_id)  ");
			consulta.append("   left join conta_categoria cct on (ch.cnta_id=cct.cnta_id) ");
			consulta.append("   left join cliente_conta clct on (ch.cnta_id = clct.cnta_id) ");
			consulta.append("   left join localidade l on (l.loca_id = ch.loca_id) ");
			consulta.append("   inner join imovel i on (ch.imov_id = i.imov_id) ");
			consulta.append("   inner join ROTA r on (i.ROTA_ID = r.rota_id) ");
			consulta.append("   where cnhi_amreferenciaconta = :referencia  ");
			consulta.append("   and ch.dcst_idatual in (2)   ");
			// verifica motivoRetificacao
			if(motivoRetificacao != null){
				consulta.append("AND ch.cmrt_id = :motivoRetificacao  ");
			}
			// verifica idcategoria
			if(idCategoria != null){
				consulta.append("AND cct.catg_id = :idCategoria   ");
			}
			// verifica id situacao
			if(idSituacao != null){
				consulta.append("AND ch.dcst_idatual  = :idSituacao  ");
			}
			// verifica localidade
			if(idLocalidade != null){
				consulta.append("AND ch.LOCA_ID   = :idLocalidade  ");
			}
			// verifica idGerenciaRegional
			if(idGerenciaRegional != null){
				consulta.append("AND l.greg_id =:idGerenciaRegional  ");
			}
			// verifica se a idImovel não é null
			if(idImovel != null){
				consulta.append("AND ch.imov_id   = :idImovel  ");
			}
			// verifica se a IdCliente não é null
			if(idCliente != null){
				consulta.append("AND clct.CLIE_ID = :idCliente     ");
			}
			if(quadra != null){
				consulta.append("AND ch.CNHI_NNQUADRA = :quadra ");
			}
			if(setorComercial != null){
				consulta.append(" AND ch.CNHI_CDSETORCOMERCIAL = :setorComercial ");
			}
			if(faturamentoGrupo != null){
				consulta.append(" AND r.ftgr_id = :faturamentoGrupo ");
			}
			consulta.append(" union   ");
			consulta.append(" select 'Conta (2)' Origem,  ");
			consulta.append(" ch.imov_id MATRICULA,  ");
			consulta.append(" (SELECT CL.CLIE_NMCLIENTE   ");
			consulta.append("           FROM CLIENTE_CONTA_HISTORICO CC   ");
			consulta.append("           INNER JOIN CLIENTE CL ON (CL.CLIE_ID = CC.CLIE_ID)  ");
			consulta.append("           WHERE CC.CNTA_ID = CH.CNTA_ID AND CC.CLCH_ICNOMECONTA = 1) USUARIO_TITULAR_CONTA,  ");
			consulta.append(" ch.cnta_amreferenciaconta REFERENCIA,  ");
			consulta.append(" 0  VALOR_ORIGINAL,  ");
			consulta.append(" (ch.cnta_vlagua+ch.cnta_vlesgoto+ch.cnta_vldebitos-ch.cnta_vlcreditos-ch.cnta_vlimpostos) VALOR_REFATURADO,  ");
			consulta.append(" ch.CNTA_tmultimaalteracao DATA_FATURAMENTO,  ");
			consulta.append(" TO_CHAR(ch.cnta_tmultimaalteracao, 'hh24:mi') AS HORA_ALTERACAO,  ");
			consulta.append(" cmr.CMRT_DSMOTIVORETIFICACAOCONTA MOTIVO_REFATURAMENTO,  ");
			consulta.append(" u.USUR_NMLOGIN  USUARIO_GSAN  ");
			consulta.append(" from conta ch   ");
			consulta.append(" INNER JOIN conta_motivo_retificacao cmr ON (ch.cmrt_id = cmr.cmrt_id)  ");
			consulta.append("   left join usuario u on (ch.usur_id = u.usur_id)  ");
			consulta.append("   left join conta_categoria cct on (ch.cnta_id=cct.cnta_id) ");
			consulta.append("   left join cliente_conta clct on (ch.cnta_id = clct.cnta_id) ");
			consulta.append("   left join localidade l on (l.loca_id = ch.loca_id) ");
			consulta.append("   inner join imovel i on (ch.imov_id = i.imov_id) ");
			consulta.append("   inner join ROTA r on (i.ROTA_ID = r.rota_id) ");
			consulta.append(" where ch.cnta_amreferenciaconta = :referencia  ");
			consulta.append(" and ch.dcst_idatual in (2)     ");
			// verifica motivoRetificacao
			if(motivoRetificacao != null){
				consulta.append("AND ch.cmrt_id = :motivoRetificacao  ");
			}
			// verifica idcategoria
			if(idCategoria != null){
				consulta.append("AND cct.catg_id = :idCategoria   ");
			}
			// verifica id situacao
			if(idSituacao != null){
				consulta.append("AND ch.dcst_idatual = :idSituacao  ");
			}
			// verifica localidade
			if(idLocalidade != null){
				consulta.append("AND ch.LOCA_ID   = :idLocalidade  ");
			}
			// verifica idGerenciaRegional
			if(idGerenciaRegional != null){
				consulta.append("AND l.greg_id =:idGerenciaRegional  ");
			}
			// verifica se a idImovel não é null
			if(idImovel != null){
				consulta.append("AND ch.imov_id   = :idImovel  ");
			}
			// verifica se a IdCliente não é null
			if(idCliente != null){
				consulta.append("AND clct.CLIE_ID = :idCliente    ");
			}
			if(quadra != null){
				consulta.append("AND ch.CNTA_NNQUADRA = :quadra ");
			}
			if(setorComercial != null){
				consulta.append(" AND ch.CNTA_CDSETORCOMERCIAL = :setorComercial ");
			}
			if(faturamentoGrupo != null){
				consulta.append(" AND r.ftgr_id = :faturamentoGrupo ");
			}
			consulta.append("order by 2,3 ");

			SQLQuery sqlAnaliticoContas = session.createSQLQuery(consulta.toString()).addScalar("ORIGEM", Hibernate.STRING)
							.addScalar("MATRICULA", Hibernate.STRING).addScalar("USUARIO_TITULAR_CONTA", Hibernate.STRING)
							.addScalar("REFERENCIA", Hibernate.STRING).addScalar("VALOR_ORIGINAL", Hibernate.BIG_DECIMAL)
							.addScalar("VALOR_REFATURADO", Hibernate.BIG_DECIMAL).addScalar("DATA_FATURAMENTO", Hibernate.DATE)
							.addScalar("HORA_ALTERACAO", Hibernate.STRING).addScalar("MOTIVO_REFATURAMENTO", Hibernate.STRING)
							.addScalar("USUARIO_GSAN", Hibernate.STRING);
			

				sqlAnaliticoContas.setInteger("referencia", referencia);

			if(motivoRetificacao != null){
				sqlAnaliticoContas.setInteger("motivoRetificacao", motivoRetificacao);
			}
			if(idCategoria != null){
				sqlAnaliticoContas.setInteger("idCategoria", idCategoria);
			}
			if(idSituacao != null){
				sqlAnaliticoContas.setInteger("idSituacao", idSituacao);
			}
			if(idImovel != null){
				sqlAnaliticoContas.setInteger("idImovel", idImovel);
			}
			if(idCliente != null){
				sqlAnaliticoContas.setInteger("idCliente", idCliente);
			}
			if(idGerenciaRegional != null){
				sqlAnaliticoContas.setInteger("idGerenciaRegional", idGerenciaRegional);
			}
			if(idLocalidade != null){
				sqlAnaliticoContas.setInteger("idLocalidade", idLocalidade);
			}
			if(quadra != null){
				sqlAnaliticoContas.setInteger("quadra", quadra);
			}
			if(setorComercial != null){
				sqlAnaliticoContas.setInteger("setorComercial", setorComercial);
			}
			if(faturamentoGrupo != null){
				sqlAnaliticoContas.setInteger("faturamentoGrupo", faturamentoGrupo);
			}

			retorno = sqlAnaliticoContas.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
		}

	/**
	 * Pesquisa os dados necessário para a geração do relatório resumido
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioContasRevisaoResumido(Integer idGerenciaRegional, Integer idElo, Integer idLocalidadeInicial,
					Integer idLocalidadeFinal, Integer idMotivoRevisao, Integer idImovelPerfil, Integer referenciaInicial,
					Integer referenciaFinal) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			consulta = "SELECT gerReg.greg_id as idGerencia, "
							+ " gerReg.greg_nmabreviado as nomeGerencia, "
							+ " elo.loca_id as idElo, "
							+ " elo.loca_nmlocalidade as nomeElo, "
							+ " loc.loca_id as idLocalidade, "
							+ " loc.loca_nmlocalidade as nomeLocalidade, "
							+ " conta.cnta_amreferenciaconta as anoMesReferencia, "
							+ " contaMotRev.cmrv_id as idMotivoRevisao, "
							+ " contaMotRev.cmrv_dsmotivorevisaoconta as descricaoMotivoRevisao, "
							+ " count( conta.cnta_id ) as qtdeContas, "
							+ " sum( conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - coalesce( conta.cnta_vlimpostos, 0 ) ) as valorContas "
							+ " FROM imovel imov " + " INNER JOIN conta conta "
							+ " on conta.imov_id = imov.imov_id and conta.cnta_dtrevisao is not null " + " and conta.dcst_idatual in ("
							+ DebitoCreditoSituacao.NORMAL + ", " + DebitoCreditoSituacao.RETIFICADA + ", "
							+ DebitoCreditoSituacao.INCLUIDA + ", " + DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO + ") "
							+ " INNER JOIN localidade loc " + " on loc.loca_id = imov.loca_id " + " INNER JOIN localidade elo "
							+ " on elo.loca_id = loc.loca_cdelo " + " INNER JOIN gerencia_regional gerReg "
							+ " on gerReg.greg_id = loc.greg_id " + " LEFT OUTER JOIN conta_motivo_revisao contaMotRev "
							+ " on contaMotRev.cmrv_id = conta.cmrv_id " + " LEFT OUTER JOIN pagamento pagto "
							+ " on pagto.cnta_id = conta.cnta_id ";

			consulta = consulta
							+ criarCondicionaisRelatorioContasRevisao(idGerenciaRegional, null, idElo, idLocalidadeInicial,
											idLocalidadeFinal, idMotivoRevisao, idImovelPerfil, referenciaInicial, referenciaFinal);

			consulta = consulta + " GROUP BY gerReg.greg_id, gerReg.greg_nmabreviado, " + " elo.loca_id, elo.loca_nmlocalidade, "
							+ " contaMotRev.cmrv_id, contaMotRev.cmrv_dsmotivorevisaoconta, " + " loc.loca_id, loc.loca_nmlocalidade, "
							+ " conta.cnta_amreferenciaconta " + " ORDER BY gerReg.greg_id, gerReg.greg_nmabreviado, "
							+ " elo.loca_id, elo.loca_nmlocalidade, " + " contaMotRev.cmrv_id, contaMotRev.cmrv_dsmotivorevisaoconta, "
							+ " loc.loca_id, loc.loca_nmlocalidade, " + " conta.cnta_amreferenciaconta ";

			retorno = session.createSQLQuery(consulta).addScalar("idGerencia", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idElo", Hibernate.INTEGER)
							.addScalar("nomeElo", Hibernate.STRING).addScalar("idLocalidade", Hibernate.INTEGER)
							.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("anoMesReferencia", Hibernate.INTEGER)
							.addScalar("idMotivoRevisao", Hibernate.INTEGER).addScalar("descricaoMotivoRevisao", Hibernate.STRING)
							.addScalar("qtdeContas", Hibernate.INTEGER).addScalar("valorContas", Hibernate.BIG_DECIMAL).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Cria as condiçoes da query que os dados necessário para a geração do relatório
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String criarCondicionaisRelatorioContasRevisao(Integer idGerenciaRegional, Integer idUnidadeNegocio, Integer idElo,
					Integer idLocalidadeInicial, Integer idLocalidadeFinal, Integer idMotivoRevisao, Integer idImovelPerfil,
					Integer referenciaInicial, Integer referenciaFinal){

		// String sql = " WHERE pagto.pgmt_id is null and ";
		StringBuilder sql = new StringBuilder(" WHERE ");

		if(idGerenciaRegional != null){
			sql.append(" gerReg.greg_id = " + idGerenciaRegional.toString() + " AND ");
		}

		if(idUnidadeNegocio != null){
			sql.append(" undNeg.uneg_id = " + idUnidadeNegocio.toString() + " AND ");
		}

		if(idElo != null){
			sql.append(" elo.loca_id = " + idElo.toString() + " AND ");
		}

		if(idLocalidadeInicial != null){
			sql.append(" loc.loca_id between " + idLocalidadeInicial.toString() + " AND " + idLocalidadeFinal.toString() + " AND ");
		}

		if(idMotivoRevisao != null){
			sql.append(" contaMotRev.cmrv_id = " + idMotivoRevisao.toString() + " AND ");
		}

		if(idImovelPerfil != null){
			sql.append(" imov.iper_id = " + idImovelPerfil.toString() + " AND ");
		}

		if(referenciaInicial != null){
			sql.append("conta.cnta_amreferenciaconta between " + referenciaInicial.toString() + " AND " + referenciaFinal.toString()
							+ " AND ");
		}

		return Util.formatarHQL(sql.toString(), 4);
	}

	/**
	 * @author Vivianne Sousa
	 * @date 18/09/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasAtualizacaoTarifaria(Integer idImovel, Integer inicialReferencia, Integer finalReferencia,
					Date inicialVencimento, Date finalVencimento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT "
							+ "cnt.id, " // 0
							+ "cnt.consumoAgua, " // 1
							+ "cnt.consumoEsgoto, " // 2
							+ "ligacaoAguaSituacao.id, " // 3
							+ "ligacaoEsgotoSituacao.id, " // 4
							+ "consumoTarifa.id, " // 5
							+ "cnt.percentualEsgoto, " // 6
							+ "imovel.id, " // 7
							+ "qdra.id, " // 8
							+ "rota.id, " // 9
							+ "ftgr.id, " // 10
							+ "cnt.valorAgua, " // 11
							+ "cnt.valorEsgoto, " // 12
							+ "cnt.referencia " // 13
							+ "FROM Conta cnt " + "INNER JOIN cnt.consumoTarifa consumoTarifa "
							+ "INNER JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "INNER JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
							+ "inner join cnt.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual " + "INNER JOIN cnt.imovel imovel "
							+ "INNER JOIN imovel.quadra qdra " + "INNER JOIN imovel.rota rota " + "INNER JOIN rota.faturamentoGrupo ftgr "
							+ "WHERE imovel.id = :idImovel " + " and cnt.consumoTarifa <> :tarifaSocial "
							+ " and (debitoCreditoSituacaoAtual.id = :situacaoNormal "
							+ " or debitoCreditoSituacaoAtual.id = :situacaoRetificada "
							+ " or debitoCreditoSituacaoAtual.id = :situacaoIncluida "
							+ " or debitoCreditoSituacaoAtual.id = :situacaoParcelada)" + " and (cnt.referencia >= :inicialReferencia "
							+ " and cnt.referencia <= :finalReferencia) " + " and (cnt.dataVencimentoConta >=  :inicialVencimento "
							+ " and cnt.dataVencimentoConta <= :finalVencimento) order by cnt.referencia";

			retorno = session.createQuery(consulta).setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
							.setInteger("situacaoRetificada", DebitoCreditoSituacao.RETIFICADA)
							.setInteger("situacaoIncluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("situacaoParcelada", DebitoCreditoSituacao.PARCELADA)
							.setInteger("inicialReferencia", inicialReferencia).setInteger("finalReferencia", finalReferencia)
							.setDate("inicialVencimento", inicialVencimento).setDate("finalVencimento", finalVencimento)
							.setInteger("tarifaSocial", ConsumoTarifa.CONSUMO_SOCIAL).setInteger("idImovel", idImovel).list();
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os Valores das Faixas de Débitos
	 * 
	 * @author Ivan Sérgio
	 * @created 14/09/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDebitoFaixaValores(Integer idFaixaValor, Double valorFaixa) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;
		boolean finaliza = false;

		try{

			consulta = "select " + "	id, valorFaixaInicio, valorFaixaFim " + "from" + "	gcom.faturamento.debito.DebitoFaixaValore "
							+ "where ";

			if(!idFaixaValor.equals(0)){
				consulta += "id = " + idFaixaValor + " and ";
				finaliza = true;
			}

			if(valorFaixa != null){
				consulta += "valorFaixaInicio <= " + valorFaixa + " and ";
				consulta += "valorFaixaFim >= " + valorFaixa + " and ";
				finaliza = true;
			}

			// Finaliza a instrucao
			if(finaliza){
				consulta = consulta.substring(0, consulta.length() - 5);
			}else{
				consulta = consulta.substring(0, consulta.length() - 6);
			}

			// Ordena pelo ID
			consulta += " ORDER BY id";

			retorno = session.createQuery(consulta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [UC0638] - Gerar Relatórios Anormalidade Consumo
	 * 
	 * @author Rafael Corrêa
	 * @created 15/10/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosRelatorioAnormalidadeConsumo(Integer idGrupoFaturamento, Short codigoRota, Integer idGerenciaRegional,
					Integer idUnidadeNegocio, Integer idElo, Integer idLocalidadeInicial, Integer idLocalidadeFinal, Integer referencia,
					Integer idImovelPerfil, Integer numOcorConsecutivas, String indicadorOcorrenciasIguais, Integer mediaConsumoInicial,
					Integer mediaConsumoFinal, Integer idAnormalidadeConsumo, Integer idAnormalidadeLeitura)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			consulta = "SELECT grupoFat.ftgr_id as idGrupoFaturamento, "
							+ " grupoFat.ftgr_dsfaturamentogrupo as descricaoGrupoFaturamento, "
							+ " greg.greg_id as idGerencia, greg.greg_nmabreviado as nomeGerencia, "
							+ " unidNeg.uneg_id as idUnidadeNegocio, unidNeg.uneg_nmabreviado as nomeUnidadeNegocio, "
							+ " elo.loca_id as idElo, elo.loca_nmlocalidade as nomeElo, "
							+ " loc.loca_id as idLocalidade, loc.loca_nmlocalidade as nomeLocalidade, "
							+ " imov.imov_id as idImovel, clieUsuario.clie_nmcliente as nomeUsuario, "
							+ " imov.last_id as sitLigAgua, imov.lest_id as sitLigEsgoto, "
							+ " imov.imov_icdebitoconta as indicadorDebito, "
							+ " consHist.cshi_nnconsumomedio as consumoMedio, consHist.cshi_nnconsumofaturadomes as consumoMes, "
							+ " consAnor.csan_dsabreviadaconsumoanormal as anormalidadeConsumo, "
							+ " leitAnor.ltan_id as anormalidadeLeitura, " + " imov.imov_qteconomia as qtdeEconomias, "
							+ " medHist.medt_id as tipoMedicao, " + " hidrCapPoco.hicp_dsabreviadahidrometrocapa as capHidPoco, "
							+ " hidrLocInstPoco.hili_dsabreviadahidrometroloca as locInstHidPoco, "
							+ " hidrCapAgua.hicp_dsabreviadahidrometrocapa as capHidAgua, "
							+ " hidrLocInstAgua.hili_dsabreviadahidrometroloca as locInstHidAgua " + " FROM imovel imov "
							+ " INNER JOIN cliente_imovel clieImovUsuario " + " on clieImovUsuario.imov_id = imov.imov_id "
							+ " and clieImovUsuario.crtp_id = " + ClienteRelacaoTipo.USUARIO
							+ " and clieImovUsuario.clim_dtrelacaofim is null " + " INNER JOIN cliente clieUsuario "
							+ " on clieUsuario.clie_id = clieImovUsuario.clie_id " + " INNER JOIN consumo_historico consHist "
							+ " on consHist.imov_id = imov.imov_id " + " and ( consHist.cshi_amfaturamento = :referencia ";
			int ocorConsecutiva = 0;
			if(numOcorConsecutivas != null && numOcorConsecutivas > 0){
				ocorConsecutiva = numOcorConsecutivas;
				while(numOcorConsecutivas > 0){
					int anoMes = Util.subtrairMesDoAnoMes(referencia, numOcorConsecutivas);
					consulta = consulta + " or consHist.cshi_amfaturamento = " + anoMes + " ";
					numOcorConsecutivas--;
				}
			}

			consulta = consulta + " ) ";

			consulta = consulta + "and consHist.lgti_id = " + LigacaoTipo.LIGACAO_AGUA + " INNER JOIN localidade loc "
							+ " on loc.loca_id = imov.loca_id " + " INNER JOIN localidade elo " + " on elo.loca_id = loc.loca_cdelo "
							+ " INNER JOIN unidade_negocio unidNeg " + " on unidNeg.uneg_id = loc.uneg_id "
							+ " INNER JOIN gerencia_regional greg " + " on greg.greg_id = unidNeg.greg_id " + " INNER JOIN quadra quadra "
							+ " on quadra.qdra_id = imov.qdra_id " + " INNER JOIN rota rota " + " on rota.rota_id = imov.rota_id "
							+ " INNER JOIN faturamento_grupo grupoFat " + " on grupoFat.ftgr_id = rota.ftgr_id "
							+ " LEFT OUTER JOIN consumo_anormalidade consAnor " + " on consAnor.csan_id = consHist.csan_id "
							+ " LEFT OUTER JOIN medicao_historico medHist " + " on medHist.imov_id = imov.imov_id "
							+ " and ( medHist.mdhi_amleitura = :referencia ";
			numOcorConsecutivas = ocorConsecutiva;
			if(numOcorConsecutivas != null && numOcorConsecutivas > 0){
				while(numOcorConsecutivas > 0){
					int anoMes = Util.subtrairMesDoAnoMes(referencia, numOcorConsecutivas);
					consulta = consulta + " or medHist.mdhi_amleitura = " + anoMes + " ";
					numOcorConsecutivas--;
				}
			}

			consulta = consulta + " ) ";

			consulta = consulta + "LEFT OUTER JOIN leitura_anormalidade leitAnor "
							+ " on leitAnor.ltan_id = medHist.ltan_idleituraanormalidadefatu "
							+ " LEFT OUTER JOIN hidrometro_instalacao_hist hidrInstHistPoco "
							+ " on hidrInstHistPoco.hidi_id = imov.hidi_id " + " LEFT OUTER JOIN hidrometro hidrPoco "
							+ " on hidrPoco.hidr_id = hidrInstHistPoco.hidr_id " + " LEFT OUTER JOIN hidrometro_capacidade hidrCapPoco "
							+ " on hidrCapPoco.hicp_id = hidrPoco.hicp_id "
							+ " LEFT OUTER JOIN hidrometro_local_instalacao hidrLocInstPoco "
							+ " on hidrLocInstPoco.hili_id = hidrInstHistPoco.hili_id " + " LEFT OUTER JOIN ligacao_agua lagu "
							+ " on lagu.lagu_id = imov.imov_id " + " LEFT OUTER JOIN hidrometro_instalacao_hist hidrInstHistAgua "
							+ " on hidrInstHistAgua.hidi_id = lagu.hidi_id " + " LEFT OUTER JOIN hidrometro hidrAgua "
							+ " on hidrAgua.hidr_id = hidrInstHistAgua.hidr_id " + " LEFT OUTER JOIN hidrometro_capacidade hidrCapAgua "
							+ " on hidrCapAgua.hicp_id = hidrAgua.hicp_id "
							+ " LEFT OUTER JOIN hidrometro_local_instalacao hidrLocInstAgua "
							+ " on hidrLocInstAgua.hili_id = hidrInstHistAgua.hili_id ";

			consulta = consulta
							+ criarCondicionaisRelatorioAnormalidadesConsumo(idGrupoFaturamento, codigoRota, idGerenciaRegional,
											idUnidadeNegocio, idElo, idLocalidadeInicial, idLocalidadeFinal, referencia, idImovelPerfil,
											numOcorConsecutivas, indicadorOcorrenciasIguais, mediaConsumoInicial, mediaConsumoFinal,
											idAnormalidadeConsumo, idAnormalidadeLeitura);

			if(ocorConsecutiva > 0){
				consulta = consulta + " group by grupoFat.ftgr_id, " + " grupoFat.ftgr_dsfaturamentogrupo , " + " greg.greg_id, "
								+ "greg.greg_nmabreviado , " + " unidNeg.uneg_id , " + "unidNeg.uneg_nmabreviado , " + " elo.loca_id, "
								+ "elo.loca_nmlocalidade, " + " loc.loca_id," + " loc.loca_nmlocalidade, " + " imov.imov_id ,"
								+ " clieUsuario.clie_nmcliente, " + " imov.last_id, " + "imov.lest_id, " + " imov.imov_icdebitoconta, "
								+ " consHist.cshi_nnconsumomedio," + " consHist.cshi_nnconsumofaturadomes, "
								+ " consAnor.csan_dsabreviadaconsumoanormal, " + " leitAnor.ltan_id, " + " imov.imov_qteconomia, "
								+ " medHist.medt_id," + " hidrCapPoco.hicp_dsabreviadahidrometrocapa, "
								+ " hidrLocInstPoco.hili_dsabreviadahidrometroloca, " + " hidrCapAgua.hicp_dsabreviadahidrometrocapa, "
								+ " hidrLocInstAgua.hili_dsabreviadahidrometroloca" + " " + "having count(imov.imov_id) > "
								+ ocorConsecutiva;
			}

			consulta = consulta + " ORDER BY grupoFat.ftgr_id, greg.greg_id, unidNeg.uneg_id, elo.loca_id, "
							+ " loc.loca_id, imov.imov_id ";

			retorno = session.createSQLQuery(consulta).addScalar("idGrupoFaturamento", Hibernate.INTEGER)
							.addScalar("descricaoGrupoFaturamento", Hibernate.STRING).addScalar("idGerencia", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idUnidadeNegocio", Hibernate.INTEGER)
							.addScalar("nomeUnidadeNegocio", Hibernate.STRING).addScalar("idElo", Hibernate.INTEGER)
							.addScalar("nomeElo", Hibernate.STRING).addScalar("idLocalidade", Hibernate.INTEGER)
							.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("nomeUsuario", Hibernate.STRING).addScalar("sitLigAgua", Hibernate.INTEGER)
							.addScalar("sitLigEsgoto", Hibernate.INTEGER).addScalar("indicadorDebito", Hibernate.SHORT)
							.addScalar("consumoMedio", Hibernate.INTEGER).addScalar("consumoMes", Hibernate.INTEGER)
							.addScalar("anormalidadeConsumo", Hibernate.STRING).addScalar("anormalidadeLeitura", Hibernate.INTEGER)
							.addScalar("qtdeEconomias", Hibernate.SHORT).addScalar("tipoMedicao", Hibernate.INTEGER)
							.addScalar("capHidPoco", Hibernate.STRING).addScalar("locInstHidPoco", Hibernate.STRING)
							.addScalar("capHidAgua", Hibernate.STRING).addScalar("locInstHidAgua", Hibernate.STRING)
							.setInteger("referencia", referencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Cria as condiçoes da query que os dados necessário para a geração do relatório
	 * [UC0638] - Gerar Relatórios Anormalidade Consumo
	 * 
	 * @author Rafael Corrêa
	 * @created 15/10/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String criarCondicionaisRelatorioAnormalidadesConsumo(Integer idGrupoFaturamento, Short codigoRota, Integer idGerenciaRegional,
					Integer idUnidadeNegocio, Integer idElo, Integer idLocalidadeInicial, Integer idLocalidadeFinal, Integer referencia,
					Integer idImovelPerfil, Integer numOcorConsecutivas, String indicadorOcorrenciasIguais, Integer mediaConsumoInicial,
					Integer mediaConsumoFinal, Integer idAnormalidadeConsumo, Integer idAnormalidadeLeitura){

		String sql = " WHERE (consAnor.csan_id is not null or leitAnor.ltan_id is not null) and ";

		if(idGerenciaRegional != null){
			sql = sql + " greg.greg_id = " + idGerenciaRegional.toString() + " and ";
		}

		if(idElo != null){
			sql = sql + " elo.loca_id = " + idElo.toString() + " and ";
		}

		if(idLocalidadeInicial != null){
			sql = sql + " loc.loca_id between " + idLocalidadeInicial.toString() + " and " + idLocalidadeFinal.toString() + " and ";
		}

		if(idUnidadeNegocio != null){
			sql = sql + " unidNeg.uneg_id = " + idUnidadeNegocio.toString() + " and ";
		}

		if(idGrupoFaturamento != null){
			sql = sql + " grupoFat.ftgr_id = " + idGrupoFaturamento.toString() + " and ";
		}

		if(codigoRota != null){
			sql = sql + " rota.rota_cdrota = " + codigoRota.toString() + " and ";
		}

		if(idImovelPerfil != null){
			sql = sql + " imov.iper_id = " + idImovelPerfil.toString() + " and ";
		}

		if(mediaConsumoInicial != null){
			sql = sql + " consHist.cshi_nnconsumofaturadomes between " + mediaConsumoInicial + " and " + mediaConsumoInicial + " and ";
		}

		if(idAnormalidadeConsumo != null){
			sql = sql + " consAnor.csan_id = " + idAnormalidadeConsumo.toString() + " and ";
		}

		if(idAnormalidadeLeitura != null){
			sql = sql + " leitAnor.ltan_id = " + idAnormalidadeLeitura.toString() + " and ";
		}

		sql = Util.formatarHQL(sql, 4);

		return sql;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de crédito a realizar
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(int anoMesReferenciaContabil, Integer idLocalidade,
					Integer idOrigemCredito, Integer idSituacaoAtual, Integer idSituacaoAnterior) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),loca,greg,catg,uneg) "
							+ "from CreditoARealizarCategoria cacg " + "inner join cacg.creditoARealizar crar "
							+ "inner join cacg.categoria catg " + "inner join crar.creditoOrigem crog "
							+ "inner join crar.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "where loca.id = :idLocalidade "
							+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and (crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or crar.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) " + "and (crog.id = :idOrigemCredito) "
							+ "group by crar.anoMesReferenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idSituacaoAnterior", idSituacaoAnterior).setInteger("idOrigemCredito", idOrigemCredito).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de crédito a realizar
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(int anoMesReferenciaContabil, Integer idLocalidade,
					Integer idOrigemCredito, Integer idSituacaoAtual) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),loca,greg,catg,uneg) "
							+ "from CreditoARealizarCategoria cacg " + "inner join cacg.creditoARealizar crar "
							+ "inner join cacg.categoria catg " + "inner join crar.creditoOrigem crog "
							+ "inner join crar.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "where loca.id = :idLocalidade "
							+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and crar.debitoCreditoSituacaoAtual = :idSituacaoAtual " + "and crog.id = :idOrigemCredito "
							+ "group by crar.anoMesReferenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idOrigemCredito", idOrigemCredito).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, situação anterior
	 * e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer idCreditoOrigem, Integer idSituacaoAtual, Integer idSituacaoAnterior)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual "
							+ " or cnta.debitoCreditoSituacaoAnterior.id = :idSituacaoAnterior) "
							+ "and (crrz.creditoOrigem.id = :idCreditoOrigem ) "
							+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idSituacaoAnterior", idSituacaoAnterior)
							.setInteger("idCreditoOrigem", idCreditoOrigem).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual e o tipo de financiamento
	 * com o ano/mês de referência da baixa contábil da conta preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer idFinanciamentoTipo, Integer idSituacaoAtual)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "left join dbcb.financiamentoTipo fntp "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual.id  = :idSituacaoAtual "
							+ "and fntp.id = :idFinanciamentoTipo "
							+ "and cnta.referenciaBaixaContabil is not null "
							+ "group by cnta.referenciaContabil,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
							.uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual e o tipo de financiamento
	 * com o ano/mês de referência da baixa contábil da conta não preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer idFinanciamentoTipo, Integer idSituacaoAtual)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "left join dbcb.financiamentoTipo fntp "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual.id  = :idSituacaoAtual "
							+ "and fntp.id = :idFinanciamentoTipo "
							+ "and cnta.referenciaBaixaContabil is null "
							+ "group by cnta.referenciaContabil,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
							.uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual
	 * e a origem do crédito informados
	 * e com o ano/mês da baixa contábil preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer idCreditoOrigem, Integer idSituacaoAtual)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual "
							+ "and crrz.creditoOrigem.id = :idCreditoOrigem "
							+ "and cnta.referenciaBaixaContabil is not null "
							+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idCreditoOrigem", idCreditoOrigem).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual
	 * e a origem do crédito informados
	 * e com o ano/mês da baixa contábil não preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer idCreditoOrigem, Integer idSituacaoAtual)
					throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual "
							+ "and crrz.creditoOrigem.id = :idCreditoOrigem "
							+ "and cnta.referenciaBaixaContabil is null "
							+ "group by cnta.referenciaContabil,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idCreditoOrigem", idCreditoOrigem).uniqueResult();
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor do imposto acumulado
	 * de acordo com o ano/mês de referência da conta, a
	 * situação atual da conta e o tipo de imposto
	 * e com o ano/mês da baixa contábil da conta preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(int anoMesReferencia,
					Integer idLocalidade, Integer idCategoria, Integer idImpostoTipo, Integer idSituacaoAtual)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
							+ "from ContaImpostosDeduzidos cnid " + "inner join cnid.impostoTipo imtp " + "inner join cnid.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg " + "where loca.id= :idLocalidade and "
							+ "catg.id = :idCategoria and " + "cnta.referenciaContabil = :anoMesReferencia "
							+ "and imtp.id = :idTipoImposto " + "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "and cnta.referenciaBaixaContabil is not null " + "group by cnta.referenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idTipoImposto", idImpostoTipo)
							.setInteger("idSituacaoAtual", idSituacaoAtual).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor do imposto acumulado
	 * de acordo com o ano/mês de referência da conta, a
	 * situação atual da conta e o tipo de imposto
	 * e com o ano/mês da baixa contábil da conta não preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(int anoMesReferencia,
					Integer idLocalidade, Integer idCategoria, Integer idImpostoTipo, Integer idSituacaoAtual)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar a coleção pesquisada
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
							+ "from ContaImpostosDeduzidos cnid " + "inner join cnid.impostoTipo imtp " + "inner join cnid.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg " + "where loca.id= :idLocalidade and "
							+ "catg.id = :idCategoria and " + "cnta.referenciaContabil = :anoMesReferencia "
							+ "and imtp.id = :idTipoImposto " + "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "and cnta.referenciaBaixaContabil is null " + "group by cnta.referenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("anoMesReferencia", anoMesReferencia).setInteger("idTipoImposto", idImpostoTipo)
							.setInteger("idSituacaoAtual", idSituacaoAtual).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, tipo de financiamento e
	 * pelo lançamento item contábil
	 * com o ano/mês de referência da baixa contábil da conta preenchido
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResumoFaturamento> acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer idFinanciamentoTipo, Integer idSituacaoAtual,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		Collection<ResumoFaturamento> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "left join dbcb.financiamentoTipo fntp "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and lict.id = :idLancamentoItemContabil "
							+ "and cnta.debitoCreditoSituacaoAtual.id  = :idSituacaoAtual "
							+ "and fntp.id = :idFinanciamentoTipo "
							+ "and cnta.referenciaBaixaContabil is not null "
							+ "group by cnta.referenciaContabil,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, tipo de financiamento e
	 * pelo lançamento item contábil
	 * com o ano/mês de referência da baixa contábil da conta não preenchido
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer idFinanciamentoTipo, Integer idSituacaoAtual,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "left join dbcb.financiamentoTipo fntp "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and lict.id = :idLancamentoItemContabil "
							+ "and cnta.debitoCreditoSituacaoAtual.id  = :idSituacaoAtual "
							+ "and fntp.id = :idFinanciamentoTipo "
							+ "and cnta.referenciaBaixaContabil is null "
							+ "group by cnta.referenciaContabil,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idFinanciamentoTipo", idFinanciamentoTipo)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, o item de financiamento contábil
	 * e a origem do crédito informados
	 * e com o ano/mês da baixa contábil preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer[] idsCreditoOrigem, Integer idSituacaoAtual,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "inner join crrz.lancamentoItemContabil lict "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and lict.id = :idLancamentoItemContabil "
							+ "and cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual "
							+ "and crrz.creditoOrigem.id in (:idsCreditoOrigem) "
							+ "and cnta.referenciaBaixaContabil is not null "
							+ "group by cnta.referencia,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setParameterList("idsCreditoOrigem", idsCreditoOrigem)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).uniqueResult();
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, o item de financiamento contábil
	 * e a origem do crédito informados
	 * e com o ano/mês da baixa contábil não preenchida.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer[] idsCreditoOrigem, Integer idSituacaoAtual,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(crcg.valorCategoria),crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria, crrz.localidade.unidadeNegocio ) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "inner join crrz.lancamentoItemContabil lict "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and lict.id = :idLancamentoItemContabil "
							+ "and cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual "
							+ "and crrz.creditoOrigem.id in (:idsCreditoOrigem) "
							+ "and cnta.referenciaBaixaContabil is null "
							+ "group by cnta.referenciaContabil,crrz.localidade,crrz.localidade.gerenciaRegional,crcg.categoria,crrz.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setParameterList("idsCreditoOrigem", idsCreditoOrigem)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).uniqueResult();
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de águae o de esgoto
	 * acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual aos ids informados
	 * com ano/mês da baixa contábil preenchida
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilPreenchida(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer[] idsSituacaoAtual) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select sum(ctcg.valorAgua),sum(ctcg.valorEsgoto) " + "from ContaCategoria ctcg "
							+ "inner join ctcg.comp_id.conta cnta " + "left join cnta.localidade loca "
							+ "left join ctcg.comp_id.categoria catg " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade " + "and catg.id = :idCategoria "
							+ "and cnta.referenciaBaixaContabil is not null "
							+ "and cnta.debitoCreditoSituacaoAtual in (:idsSituacaoAtual) ";

			// executa o hql
			retorno = (Object[]) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setParameterList("idsSituacaoAtual", idsSituacaoAtual).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de águae o de esgoto
	 * acumulado, de acordo com o ano/mês de referência, a localiade, a
	 * categoria e a situação da conta igual aos ids informados
	 * com ano/mês da baixa contábil não preenchida
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilNaoPreenchida(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer[] idsSituacaoAtual) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		Object[] retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select sum(ctcg.valorAgua),sum(ctcg.valorEsgoto) " + "from ContaCategoria ctcg "
							+ "inner join ctcg.comp_id.conta cnta " + "left join cnta.localidade loca "
							+ "left join ctcg.comp_id.categoria catg " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade " + "and catg.id = :idCategoria " + "and cnta.referenciaBaixaContabil is null "
							+ "and cnta.debitoCreditoSituacaoAtual in (:idsSituacaoAtual) ";

			// executa o hql
			retorno = (Object[]) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setParameterList("idsSituacaoAtual", idsSituacaoAtual).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão com o hibernate
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a(s) situação(ões) atual(ais)
	 * com o ano/mês de referência da baixa contábil da conta preenchido.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorCategoriaDebitoCobradoCategoriaComBaixaContabilPreenchida(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer[] idsSituacaoAtual) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referencia,sum(dccg.valorCategoria),dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "where cnta.referencia = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual.id in (:idSituacaoAtual) "
							+ "and cnta.referenciaBaixaContabil is not null "
							+ "group by cnta.referencia,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setParameterList("idSituacaoAtual", idsSituacaoAtual).uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor do imposto acumulado
	 * de acordo com o ano/mês de referência cntábil da conta, as
	 * situações atuais da conta e o tipo de imposto.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idsSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResumoFaturamento acumularValorImpostoPorTipoImpostoESituacaoConta(int anoMesReferencia, Integer idLocalidade,
					Integer idCategoria, Integer idImpostoTipo, Integer[] idsSituacaoAtual) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		ResumoFaturamento retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(cnid.valorImposto),loca,greg,catg,uneg ) "
							+ "from ContaImpostosDeduzidos cnid " + "inner join cnid.impostoTipo imtp " + "inner join cnid.conta cnta "
							+ "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg " + "where loca.id= :idLocalidade and "
							+ "catg.id = :idCategoria and " + "cnta.referenciaContabil = :anoMesReferencia "
							+ "and imtp.id = :idTipoImposto " + "and cnta.debitoCreditoSituacaoAtual in (:idsSituacaoAtual) "
							+ "group by cnta.referenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = (ResumoFaturamento) session.createQuery(consulta).setInteger("idLocalidade", idLocalidade)
							.setInteger("idCategoria", idCategoria).setInteger("referenciaContabil", anoMesReferencia)
							.setInteger("idTipoImposto", idImpostoTipo).setParameterList("idsSituacaoAtual", idsSituacaoAtual)
							.uniqueResult();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor do imposto acumulado
	 * de acordo com o ano/mês de referência contábil da conta, a
	 * situação atual da conta e o tipo de imposto.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorImpostoPorTipoImpostoESituacaoAtualConta(int anoMesReferencia, Integer idLocalidade,
					Integer idCategoria, Integer idImpostoTipo, Integer idSituacaoAtual) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select sum(cnid.valorImposto) " + "from ContaImpostosDeduzidos cnid " + "inner join cnid.impostoTipo imtp "
							+ "inner join cnid.conta cnta " + "inner join cnta.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg " + "where loca.id= :idLocalidade and "
							+ "catg.id = :idCategoria and " + "cnta.referenciaContabil = :anoMesReferencia "
							+ "and imtp.id = :idTipoImposto " + "and cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idLocalidade", idLocalidade)
							.setInteger("idCategoria", idCategoria).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idTipoImposto", idImpostoTipo).setInteger("idSituacaoAtual", idSituacaoAtual).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor do imposto acumulado
	 * de acordo com o ano/mês de referência contábil da conta, a
	 * situação atual e anterior da conta e o tipo de imposto.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idImpostoTipo
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorImpostoPorTipoImpostoESituacaoAtualConta(int anoMesReferencia, Integer idLocalidade,
					Integer idCategoria, Integer idImpostoTipo, Integer idSituacaoAtual, Integer idSituacaoAnterior)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select sum(cnid.valorImposto) "
							+ "from ContaImpostosDeduzidos cnid "
							+ "inner join cnid.impostoTipo imtp "
							+ "inner join cnid.conta cnta "
							+ "inner join cnta.localidade loca "
							+ "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg "
							+ "inner join cnta.contaCategorias ctcg "
							+ "inner join ctcg.comp_id.categoria catg "
							+ "where loca.id= :idLocalidade and "
							+ "catg.id = :idCategoria and "
							+ "cnta.referenciaContabil = :anoMesReferencia "
							+ "and imtp.id = :idTipoImposto "
							+ "and (cnta.debitoCreditoSituacaoAtual = :idSituacaoAtual or cnta.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("idLocalidade", idLocalidade)
							.setInteger("idCategoria", idCategoria).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idTipoImposto", idImpostoTipo).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idSituacaoAnterior", idSituacaoAnterior).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual,
	 * e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer[] idsCreditoOrigem, Integer idSituacaoAtual) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz " + "inner join crrz.conta cnta " + "left join crrz.localidade loca "
							+ "left join crcg.categoria catg " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade " + "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual "
							+ "and crrz.creditoOrigem.id in (:idsCreditoOrigem) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setParameterList("idsCreditoOrigem", idsCreditoOrigem)
							.uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, a situação anterior
	 * e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(int anoMesReferencia, int idLocalidade,
					int idCategoria, Integer[] idsCreditoOrigem, Integer idSituacaoAtual, Integer idSituacaoAnterior)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select sum(crcg.valorCategoria) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual or cnta.debitoCreditoSituacaoAnterior.id = :idSituacaoAnterior) "
							+ "and crrz.creditoOrigem.id in (:idsCreditoOrigem) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idSituacaoAnterior", idSituacaoAnterior)
							.setParameterList("idsCreditoOrigem", idsCreditoOrigem).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, o item de lançamento contábil
	 * e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(int anoMesReferencia,
					int idLocalidade, int idCategoria, Integer[] idsCreditoOrigem, Integer idSituacaoAtual, Integer idLancamentoItemContabil)
					throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select sum(crcg.valorCategoria) " + "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz " + "inner join crrz.conta cnta "
							+ "inner join crrz.lancamentoItemContabil lict " + "left join crrz.localidade loca "
							+ "left join crcg.categoria catg " + "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade " + "and catg.id = :idCategoria "
							+ "and cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual " + "and lict.id = :idLancamentoItemContabil "
							+ "and crrz.creditoOrigem.id in (:idsCreditoOrigem) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.setParameterList("idsCreditoOrigem", idsCreditoOrigem).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}
			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de credito realizado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, a situação anterior, item lançamento contábil
	 * e a origem do crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsCreditoOrigem
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(int anoMesReferencia,
					int idLocalidade, int idCategoria, Integer[] idsCreditoOrigem, Integer idSituacaoAtual, Integer idSituacaoAnterior,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select sum(crcg.valorCategoria) "
							+ "from CreditoRealizadoCategoria crcg "
							+ "inner join crcg.creditoRealizado crrz "
							+ "inner join crrz.conta cnta "
							+ "inner join crrz.lancamentoItemContabil lict "
							+ "left join crrz.localidade loca "
							+ "left join crcg.categoria catg "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and (cnta.debitoCreditoSituacaoAtual.id = :idSituacaoAtual or cnta.debitoCreditoSituacaoAnterior.id = :idSituacaoAnterior) "
							+ "and lict.id = :idLancamentoItemContabil " + "and crrz.creditoOrigem.id in (:idsCreditoOrigem) ";

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idSituacaoAnterior", idSituacaoAnterior)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil)
							.setParameterList("idsCreditoOrigem", idsCreditoOrigem).uniqueResult();

			if(retorno == null){
				retorno = BigDecimal.ZERO;
			}

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de crédito a realizar
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(int anoMesReferenciaContabil, Integer idLocalidade,
					Integer[] idsOrigemCredito, Integer idSituacaoAtual, Integer idSituacaoAnterior) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),lict.sequenciaImpressao,lict,loca,greg,catg,uneg) "
							+ "from CreditoARealizarCategoria cacg "
							+ "inner join cacg.creditoARealizar crar "
							+ "inner join crar.lancamentoItemContabil lict "
							+ "inner join cacg.categoria catg "
							+ "inner join crar.creditoOrigem crog "
							+ "inner join crar.localidade loca "
							+ "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg "
							+ "where loca.id = :idLocalidade "
							+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and (crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or crar.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
							+ "and (crog.id in (:idsOrigemCredito)) "
							+ "group by crar.anoMesReferenciaContabil,lict.sequenciaImpressao,lict,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idSituacaoAnterior", idSituacaoAnterior).setParameterList("idsOrigemCredito", idsOrigemCredito)
							.list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de crédito a realizar
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(int anoMesReferenciaContabil, Integer idLocalidade,
					Integer[] idsOrigemCredito, Integer idSituacaoAtual) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),lict.sequenciaImpressao,lict,loca,greg,catg,uneg) "
							+ "from CreditoARealizarCategoria cacg "
							+ "inner join cacg.creditoARealizar crar "
							+ "inner join crar.lancamentoItemContabil lict "
							+ "inner join cacg.categoria catg "
							+ "inner join crar.creditoOrigem crog "
							+ "inner join crar.localidade loca "
							+ "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg "
							+ "where loca.id = :idLocalidade "
							+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "and crog.id in (:idsOrigemCredito) "
							+ "group by crar.anoMesReferenciaContabil,lict.sequenciaImpressao,lict,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setParameterList("idsOrigemCredito", idsOrigemCredito).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna uma coleção
	 * de crédito a realizar, de acordo com o ano/mês de referência, a situação
	 * atual, a situação anterior e origem de crédito informados.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditoARealizarPorOrigemCredito(int anoMesReferencia, int idLocalidade, int idCategoria,
					Integer[] idsOrigemCredito, Integer idSituacaoAtual, Integer idSituacaoAnterior) throws ErroRepositorioException{

		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cacg.valorCategoria,crar.numeroPrestacaoCredito " + "from CreditoARealizarCategoria cacg "
							+ "inner join cacg.creditoARealizar crar " + "inner join cacg.categoria catg "
							+ "inner join crar.localidade loca " + "inner join crar.creditoOrigem crog "
							+ "where crar.anoMesReferenciaContabil = :anoMesReferenciaContabil " + "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria " + "and crog.id in (:idsOrigemCredito) "
							+ "and (crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or crar.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setParameterList("idsOrigemCredito", idsOrigemCredito).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idSituacaoAnterior", idSituacaoAnterior).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de débitos a cobrar pesquisada
		return retorno;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de guia de devolução
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * e lançamento item contábil.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorGuiaDevolucaoPorLancamentoItemContabil(int anoMesReferencia, Integer idLocalidade,
					Integer idSituacaoAtual, Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select imov.id, sum(gdev.valorDevolucao) " + "from GuiaDevolucao gdev " + "inner join gdev.imovel imov "
							+ "inner join gdev.localidade loca " + "inner join gdev.lancamentoItemContabil lict "
							+ "where loca.id = :idLocalidade " + "and gdev.anoMesReferenciaContabil = :anoMesReferencia "
							+ "and gdev.debitoCreditoSituacaoAtual = :idSituacaoAtual " + "and lict.id = :idLancamentoItemContabil "
							+ "group by imov.id ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de guia de devolução
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual,
	 * a situação anterior e lançamento item contábil.
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorGuiaDevolucaoPorLancamentoItemContabil(int anoMesReferencia, Integer idLocalidade,
					Integer idSituacaoAtual, Integer idSituacaoAnterior, Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select imov.id, sum(gdev.valorDevolucao) "
							+ "from GuiaDevolucao gdev "
							+ "inner join gdev.imovel imov "
							+ "inner join gdev.localidade loca "
							+ "inner join gdev.lancamentoItemContabil lict "
							+ "where loca.id = :idLocalidade "
							+ "and gdev.anoMesReferenciaContabil = :anoMesReferencia "
							+ "and (gdev.debitoCreditoSituacaoAtual.id = :idSituacaoAtual or gdev.debitoCreditoSituacaoAnterior.id = :idSituacaoAnterior) "
							+ "and lict.id = :idLancamentoItemContabil " + "group by imov.id ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idSituacaoAnterior", idSituacaoAnterior)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de crédito a realizar
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @param categoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(int anoMesReferenciaContabil, Integer idLocalidade,
					Integer[] idsOrigemCredito, Integer idSituacaoAtual, Categoria categoria) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),lict.sequenciaImpressao,lict,loca,greg,catg,uneg) "
							+ "from CreditoARealizarCategoria cacg "
							+ "inner join cacg.creditoARealizar crar "
							+ "inner join crar.lancamentoItemContabil lict "
							+ "inner join cacg.categoria catg "
							+ "inner join crar.creditoOrigem crog "
							+ "inner join crar.localidade loca "
							+ "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg "
							+ "where loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ "and crog.id in (:idsOrigemCredito) "
							+ "group by crar.anoMesReferenciaContabil,lict.sequenciaImpressao,lict,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", categoria.getId())
							.setInteger("idSituacaoAtual", idSituacaoAtual).setParameterList("idsOrigemCredito", idsOrigemCredito).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de crédito a realizar
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @param categoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(int anoMesReferenciaContabil, Integer idLocalidade,
					Integer idOrigemCredito, Integer idSituacaoAtual, Categoria categoria) throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),loca,greg,catg,uneg) "
							+ "from CreditoARealizarCategoria cacg " + "inner join cacg.creditoARealizar crar "
							+ "inner join cacg.categoria catg " + "inner join crar.creditoOrigem crog "
							+ "inner join crar.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "where loca.id = :idLocalidade " + "and catg.id = :idCategoria "
							+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and crar.debitoCreditoSituacaoAtual = :idSituacaoAtual " + "and crog.id = :idOrigemCredito "
							+ "group by crar.anoMesReferenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idSituacaoAtual", idSituacaoAtual)
							.setInteger("idOrigemCredito", idOrigemCredito).setInteger("idCategoria", categoria.getId()).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de crédito a realizar
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idsOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param categoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(int anoMesReferenciaContabil, Integer idLocalidade,
					Integer[] idsOrigemCredito, Integer idSituacaoAtual, Integer idSituacaoAnterior, Categoria categoria)
					throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),lict.sequenciaImpressao,lict,loca,greg,catg,uneg) "
							+ "from CreditoARealizarCategoria cacg "
							+ "inner join cacg.creditoARealizar crar "
							+ "inner join crar.lancamentoItemContabil lict "
							+ "inner join cacg.categoria catg "
							+ "inner join crar.creditoOrigem crog "
							+ "inner join crar.localidade loca "
							+ "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg "
							+ "where loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and (crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or crar.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) "
							+ "and (crog.id in (:idsOrigemCredito)) "
							+ "group by crar.anoMesReferenciaContabil,lict.sequenciaImpressao,lict,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", categoria.getId())
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idSituacaoAnterior", idSituacaoAnterior)
							.setParameterList("idsOrigemCredito", idsOrigemCredito).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de crédito a realizar
	 * acumulado, de acordo com o ano/mês de referência contábil, a situação atual
	 * ou anterior e a origem de crédito informados.
	 * 
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @param idOrigemCredito
	 * @param idSituacaoAtual
	 * @param idSituacaoAnterior
	 * @param categoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection acumularValorCreditoARealizarPorOrigemCredito(int anoMesReferenciaContabil, Integer idLocalidade,
					Integer idOrigemCredito, Integer idSituacaoAtual, Integer idSituacaoAnterior, Categoria categoria)
					throws ErroRepositorioException{

		// cria a coleção de retorno da pesquisa
		Collection retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			consulta = "select new ResumoFaturamento(crar.anoMesReferenciaContabil,sum(cacg.valorCategoria),loca,greg,catg,uneg) "
							+ "from CreditoARealizarCategoria cacg " + "inner join cacg.creditoARealizar crar "
							+ "inner join cacg.categoria catg " + "inner join crar.creditoOrigem crog "
							+ "inner join crar.localidade loca " + "inner join loca.gerenciaRegional greg "
							+ "inner join loca.unidadeNegocio uneg " + "where loca.id = :idLocalidade " + "and catg.id = :idCategoria "
							+ "and crar.anoMesReferenciaContabil = :anoMesReferenciaContabil "
							+ "and (crar.debitoCreditoSituacaoAtual = :idSituacaoAtual "
							+ " or crar.debitoCreditoSituacaoAnterior = :idSituacaoAnterior) " + "and (crog.id = :idOrigemCredito) "
							+ "group by crar.anoMesReferenciaContabil,loca,greg,catg,uneg ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferenciaContabil", anoMesReferenciaContabil)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", categoria.getId())
							.setInteger("idSituacaoAtual", idSituacaoAtual).setInteger("idSituacaoAnterior", idSituacaoAnterior)
							.setInteger("idOrigemCredito", idOrigemCredito).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna a coleção de resumo de faturamento criada
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, tipo de financiamento e
	 * pelo lançamento item contábil
	 * com o ano/mês de referência da baixa contábil da conta preenchido
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResumoFaturamento> acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer[] idsFinanciamentoTipo, Integer idSituacaoAtual,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		Collection<ResumoFaturamento> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "left join dbcb.financiamentoTipo fntp "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and lict.id = :idLancamentoItemContabil "
							+ "and cnta.debitoCreditoSituacaoAtual.id  = :idSituacaoAtual "
							+ "and fntp.id in (:idsFinanciamentoTipo) "
							+ "and cnta.referenciaBaixaContabil is not null "
							+ "group by cnta.referenciaContabil,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setParameterList("idsFinanciamentoTipo", idsFinanciamentoTipo)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês
	 * Retorna o valor de
	 * categoria de débito cobrado acumulado, de acordo com o ano/mês de
	 * referência, a situação atual, tipo de financiamento e
	 * pelo lançamento item contábil
	 * com o ano/mês de referência da baixa contábil da conta não preenchido
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsFinanciamentoTipo
	 * @param idSituacaoAtual
	 * @param idLancamentoItemContabil
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResumoFaturamento> acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
					int anoMesReferencia, int idLocalidade, int idCategoria, Integer[] idsFinanciamentoTipo, Integer idSituacaoAtual,
					Integer idLancamentoItemContabil) throws ErroRepositorioException{

		// cria o objeto de resumo de faturamento
		Collection<ResumoFaturamento> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{

			// constroi o hql
			consulta = "select new ResumoFaturamento(cnta.referenciaContabil,sum(dccg.valorCategoria),lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria, dbcb.localidade.unidadeNegocio ) "
							+ "from DebitoCobradoCategoria dccg "
							+ "inner join dccg.debitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "inner join dbcb.lancamentoItemContabil lict "
							+ "left join dbcb.localidade loca "
							+ "left join dccg.categoria catg "
							+ "left join dbcb.financiamentoTipo fntp "
							+ "where cnta.referenciaContabil = :anoMesReferencia "
							+ "and loca.id = :idLocalidade "
							+ "and catg.id = :idCategoria "
							+ "and lict.id = :idLancamentoItemContabil "
							+ "and cnta.debitoCreditoSituacaoAtual.id  = :idSituacaoAtual "
							+ "and fntp.id in (:idsFinanciamentoTipo) "
							+ "and cnta.referenciaBaixaContabil is null "
							+ "group by cnta.referenciaContabil,lict.sequenciaImpressao,lict,dbcb.localidade,dbcb.localidade.gerenciaRegional,dccg.categoria,dbcb.localidade.unidadeNegocio ";
			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("idLocalidade", idLocalidade).setInteger("idCategoria", idCategoria)
							.setInteger("idSituacaoAtual", idSituacaoAtual).setParameterList("idsFinanciamentoTipo", idsFinanciamentoTipo)
							.setInteger("idLancamentoItemContabil", idLancamentoItemContabil).list();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		// retorna o resumo de faturamento criado
		return retorno;

	}

	/**
	 * [UC0600] Emitir Histograma de Esgoto
	 * [SB0014] Selecionar por Indicador de Consumo
	 * [SB0015] Selecionar por Indicador de Medido
	 * [SB0016] Selecionar por Indicador de Poço
	 * [SB0017] Selecionar por Indicador de Volume Fixo de Água
	 * 
	 * @author Rafael Pinto
	 * @date 05/11/2007
	 * @param FiltrarEmitirHistogramaEsgotoHelper
	 * @return Collection<Object[]>
	 * @throws ControladorException
	 */
	public Collection<Object[]> pesquisarEmitirHistogramaEsgoto(FiltrarEmitirHistogramaEsgotoHelper filtro) throws ErroRepositorioException{

		Collection<Object[]> retornoConsulta = null;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro.getColecaoSituacaoLigacaoEsgoto();
			Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro.getColecaoPercentualLigacaoEsgoto();

			Categoria categoria = filtro.getCategoria();
			ConsumoTarifa tarifa = filtro.getTarifa();
			ImovelPerfil perfilImovel = filtro.getPerfilImovel();
			EsferaPoder esferaPoder = filtro.getEsferaPoder();
			LigacaoEsgotoSituacao situacaoLigacaoEsgoto = filtro.getSituacaoLigacaoEsgoto();

			Short percentualLigacaoEsgoto = null;
			if(filtro.getPercentualLigacaoEsgoto() != null){
				percentualLigacaoEsgoto = filtro.getPercentualLigacaoEsgoto().shortValue();
			}

			Short consumo = filtro.getConsumo();
			Short medicao = filtro.getMedicao();
			Short poco = filtro.getPoco();
			Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

			ConsumoFaixaLigacao consumoFaixaLigacao = filtro.getConsumoFaixaLigacao();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro.getConsumoFaixaLigacaoIntervaloMedido();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro.getConsumoFaixaLigacaoIntervaloNaoMedido();

			String clausulaGroup = filtro.getTipoGroupBy();

			Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
			Integer numeroQuadra = filtro.getNumeroQuadra();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT categoria.id," // 0
							+ "categoria.descricao," // 1
							+ "sum(histograma.quantidadeLigacao + histograma.quantidadeLigacaoRefaturamento)," // 2
							+ "sum(histograma.quantidadeEconomiaLigacao + histograma.quantidadeEconomiaLigacaoRefaturamento)," // 3
							+ "sum(histograma.valorFaturadoLigacao + histograma.valorFaturadoLigacaoRefaturamento) "; // 4

			if(clausulaGroup != null){
				consulta += "," + clausulaGroup;
			}

			String consultaFrom = "FROM HistogramaEsgotoLigacao histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if(consumoFaixaLigacao != null){
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if(consumoFaixaLigacaoIntervaloMedido != null && consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if(codigoSetorComercial != null){
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);
			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if(numeroQuadra != null){
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if(categoria != null){
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			}else if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(perfilImovel != null){
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			}else if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(esferaPoder != null){
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			}else if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if(situacaoLigacaoEsgoto != null){
				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id = (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", situacaoLigacaoEsgoto.getId());

			}else if(colecaoSituacaoLigacaoEsgoto != null && !colecaoSituacaoLigacaoEsgoto.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if(percentualLigacaoEsgoto != null){

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", percentualLigacaoEsgoto);

			}else if(colecaoPercentualLigacaoEsgoto != null && !colecaoPercentualLigacaoEsgoto.isEmpty()){

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoEsgoto != null){
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			String groupBy = "GROUP BY categoria.id,categoria.descricao";
			String orderBy = "";
			if(clausulaGroup != null){
				groupBy += ",".concat(clausulaGroup);
				orderBy = " ORDER BY ".concat(clausulaGroup).concat(",categoria.id");
			}else{
				orderBy = " ORDER BY categoria.id,categoria.descricao";
			}
			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0600] Emitir Histograma de Esgoto - Total Geral
	 * [SB0014] Selecionar por Indicador de Consumo
	 * [SB0015] Selecionar por Indicador de Medido
	 * [SB0016] Selecionar por Indicador de Poço
	 * [SB0017] Selecionar por Indicador de Volume Fixo de Água
	 * 
	 * @author Rafael Pinto
	 * @date 05/11/2007
	 * @param FiltrarEmitirHistogramaEsgotoHelper
	 * @return Object[]
	 * @throws ControladorException
	 */
	public Object[] pesquisarEmitirHistogramaEsgotoTotalGeral(FiltrarEmitirHistogramaEsgotoHelper filtro, Categoria categoria)
					throws ErroRepositorioException{

		Object[] retornoConsulta = null;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro.getColecaoSituacaoLigacaoEsgoto();
			Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro.getColecaoPercentualLigacaoEsgoto();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
			ConsumoTarifa tarifa = filtro.getTarifa();
			ImovelPerfil perfilImovel = filtro.getPerfilImovel();
			EsferaPoder esferaPoder = filtro.getEsferaPoder();
			LigacaoEsgotoSituacao situacaoLigacaoEsgoto = filtro.getSituacaoLigacaoEsgoto();
			BigDecimal percentualLigacaoEsgoto = filtro.getPercentualLigacaoEsgoto();

			Short consumo = filtro.getConsumo();
			Short medicao = filtro.getMedicao();
			Short poco = filtro.getPoco();
			Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro.getConsumoFaixaLigacaoIntervaloMedido();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro.getConsumoFaixaLigacaoIntervaloNaoMedido();

			Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
			Integer numeroQuadra = filtro.getNumeroQuadra();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum(histograma.quantidadeLigacao + histograma.quantidadeLigacaoRefaturamento)," // 0
							+ "sum(histograma.volumeFaturadoLigacao + histograma.volumeFaturadoLigacaoRefaturamento)," // 1
							+ "sum(histograma.valorFaturadoLigacao + histograma.valorFaturadoLigacaoRefaturamento) "; // 2

			String consultaFrom = "FROM HistogramaEsgotoLigacao histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if(consumoFaixaLigacaoIntervaloMedido != null && consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if(codigoSetorComercial != null){
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if(numeroQuadra != null){
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if(categoria != null){
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			}else if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(perfilImovel != null){
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			}else if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(esferaPoder != null){
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			}else if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if(situacaoLigacaoEsgoto != null){
				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id = (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", situacaoLigacaoEsgoto.getId());

			}else if(colecaoSituacaoLigacaoEsgoto != null && !colecaoSituacaoLigacaoEsgoto.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if(percentualLigacaoEsgoto != null){

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", percentualLigacaoEsgoto);

			}else if(colecaoPercentualLigacaoEsgoto != null && !colecaoPercentualLigacaoEsgoto.isEmpty()){

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoEsgoto != null){
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = (Object[]) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0600] Emitir Histograma de Esgoto -
	 * Volume Faturado Ligacao Estimado ou Real
	 * 
	 * @author Rafael Pinto
	 * @date 05/11/2007
	 * @param FiltrarEmitirHistogramaEsgotoHelper
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Integer pesquisarEmitirHistogramaEsgotoVolumeConsumo(FiltrarEmitirHistogramaEsgotoHelper filtro, Short consumo,
					Categoria categoria, Short medicao) throws ErroRepositorioException{

		Integer retornoConsulta = 0;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();

			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro.getColecaoSituacaoLigacaoEsgoto();
			Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro.getColecaoPercentualLigacaoEsgoto();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();
			ConsumoTarifa tarifa = filtro.getTarifa();
			ImovelPerfil perfilImovel = filtro.getPerfilImovel();
			EsferaPoder esferaPoder = filtro.getEsferaPoder();
			LigacaoEsgotoSituacao situacaoLigacaoEsgoto = filtro.getSituacaoLigacaoEsgoto();
			BigDecimal percentualLigacaoEsgoto = filtro.getPercentualLigacaoEsgoto();

			Short poco = filtro.getPoco();
			Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

			ConsumoFaixaLigacao consumoFaixaLigacao = filtro.getConsumoFaixaLigacao();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloMedido = filtro.getConsumoFaixaLigacaoIntervaloMedido();

			ConsumoFaixaLigacao consumoFaixaLigacaoIntervaloNaoMedido = filtro.getConsumoFaixaLigacaoIntervaloNaoMedido();

			Integer codigoSetorComercial = filtro.getCodigoSetorComercial();
			Integer numeroQuadra = filtro.getNumeroQuadra();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT sum(histograma.volumeFaturadoLigacao + histograma.volumeFaturadoLigacaoRefaturamento) "; // 0

			String consultaFrom = "FROM HistogramaEsgotoLigacao histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Ligacao
			if(consumoFaixaLigacao != null){
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaLigacao.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaLigacao.getNumeroFaixaFim());
			}

			// Faixa Consumo Ligacao Intervalo Medido
			// Faixa Consumo Ligacao Intervalo Não Medido
			if(consumoFaixaLigacaoIntervaloMedido != null && consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND ( (histograma.indicadorHidrometro=1 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido) ) ";

				consultaWhere += "OR (histograma.indicadorHidrometro=2 "
								+ "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ) ) ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());
				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioMedido) AND (:numeroFaixaFimMedido)  ";

				parameters.put("numeroFaixaInicioMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimMedido", consumoFaixaLigacaoIntervaloMedido.getNumeroFaixaFim());

			}else if(consumoFaixaLigacaoIntervaloNaoMedido != null){

				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicioNaoMedido) AND (:numeroFaixaFimNaoMedido) ";

				parameters.put("numeroFaixaInicioNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFimNaoMedido", consumoFaixaLigacaoIntervaloNaoMedido.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Codigo do Setor Comercial
			if(codigoSetorComercial != null){
				consultaWhere += "AND histograma.codigoSetorComercial = (:codigoSetorComercial) ";
				parameters.put("codigoSetorComercial", codigoSetorComercial);

			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Numero da Quadra
			if(numeroQuadra != null){
				consultaWhere += "AND histograma.numeroQuadra = (:numeroQuadra) ";
				parameters.put("numeroQuadra", numeroQuadra);
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if(categoria != null){
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			}else if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa.getId());

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(perfilImovel != null){
				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id = (:perfilImovel) ";
				parameters.put("perfilImovel", perfilImovel.getId());

			}else if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(esferaPoder != null){
				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id = (:esfera) ";
				parameters.put("esfera", esferaPoder.getId());

			}else if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if(situacaoLigacaoEsgoto != null){
				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id = (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", situacaoLigacaoEsgoto.getId());
			}else if(colecaoSituacaoLigacaoEsgoto != null && !colecaoSituacaoLigacaoEsgoto.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if(percentualLigacaoEsgoto != null){

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", percentualLigacaoEsgoto);

			}else if(colecaoPercentualLigacaoEsgoto != null && !colecaoPercentualLigacaoEsgoto.isEmpty()){

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoEsgoto != null){
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			consulta += consultaFrom + consultaWhere;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}

			Number retorno = (Number) query.setMaxResults(1).uniqueResult();
			if(retorno != null){
				retornoConsulta = retorno.intValue();
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0606] Emitir Histograma de Esgoto por Economia
	 * 
	 * @author Rafael Pinto
	 * @date 07/11/2007
	 * @author eduardo henrique
	 * @date 09/09/2009
	 *       Correcao na instrução de group by para compatibilizacao com Oracle
	 * @param FiltrarEmitirHistogramaEsgotoEconomiaHelper
	 * @return Object[]
	 * @throws ControladorException
	 */
	public Object[] pesquisarEmitirHistogramaEsgotoEconomia(FiltrarEmitirHistogramaEsgotoEconomiaHelper filtro)
					throws ErroRepositorioException{

		Object[] retornoConsulta = null;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();
			Integer tarifa = filtro.getTarifa();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro.getColecaoSituacaoLigacaoEsgoto();
			Collection<Short> colecaoPercentualLigacaoEsgoto = new ArrayList();

			if(filtro.getColecaoPercentualLigacaoEsgoto() != null && !filtro.getColecaoPercentualLigacaoEsgoto().isEmpty()){

				for(BigDecimal valor : filtro.getColecaoPercentualLigacaoEsgoto()){

					colecaoPercentualLigacaoEsgoto.add(Short.parseShort(valor.toString()));
				}
			}

			Short consumo = filtro.getConsumo();
			Short medicao = filtro.getMedicao();
			Short poco = filtro.getPoco();
			Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();
			Short percentualLigacaoEsgoto = null;

			if(filtro.getPercentualLigacaoEsgoto() != null){
				percentualLigacaoEsgoto = filtro.getPercentualLigacaoEsgoto().shortValue();
			}
			ConsumoFaixaCategoria consumoFaixaCategoria = filtro.getConsumoFaixaCategoria();
			Categoria categoria = filtro.getCategoria();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT categoria.id," // 0
							+ "categoria.descricao," // 1
							+ "sum(histograma.quantidadeEconomia + histograma.quantidadeEconomiaRefaturamento)," // 2
							+ "sum(histograma.quantidadeConsumo * (histograma.quantidadeEconomia + histograma.quantidadeEconomiaRefaturamento))," // 3
							+ "sum(histograma.volumeFaturadoEconomia + histograma.volumeFaturadoEconomiaRefaturamento), " // 4
							+ "sum(histograma.valorFaturadoEconomia + histograma.valorFaturadoEconomiaRefaturamento), " // 5

							+ "sum(histograma.quantidadeLigacao + histograma.quantidadeLigacaoRefaturamento), "// 6
							+ "histograma.percentualEsgoto "; // 7

			String consultaFrom = "FROM HistogramaEsgotoEconomia histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Faixa Consumo Categoria
			if(consumoFaixaCategoria != null){
				consultaWhere += "AND histograma.quantidadeConsumo BETWEEN (:numeroFaixaInicio) AND (:numeroFaixaFim) ";

				parameters.put("numeroFaixaInicio", consumoFaixaCategoria.getNumeroFaixaInicio());
				parameters.put("numeroFaixaFim", consumoFaixaCategoria.getNumeroFaixaFim());
			}

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			// Categoria
			if(categoria != null){
				consultaWhere += "AND categoria.id = (:cate) ";
				parameters.put("cate", categoria.getId());
			}else if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa);

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if(colecaoSituacaoLigacaoEsgoto != null && !colecaoSituacaoLigacaoEsgoto.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", colecaoSituacaoLigacaoEsgoto);
			}


			// Percentual Ligacao de Esgoto
			if(percentualLigacaoEsgoto != null){

				consultaWhere += "AND histograma.percentualEsgoto =  (:percentualLigacaoEsgoto)";
				parameters.put("percentualLigacaoEsgoto", percentualLigacaoEsgoto);


			}else if(colecaoPercentualLigacaoEsgoto != null && !colecaoPercentualLigacaoEsgoto.isEmpty()){

				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", colecaoPercentualLigacaoEsgoto);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoEsgoto != null){
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			String groupBy = "GROUP BY categoria.id, categoria.descricao, histograma.percentualEsgoto ";
			String orderBy = "ORDER BY categoria.id, categoria.descricao, histograma.percentualEsgoto ";

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}
			retornoConsulta = (Object[]) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	/**
	 * [UC0606] Emitir Histograma de Esgoto por Economia
	 * Monta as quebras que serão necessarias para o relatorio
	 * 
	 * @author Rafael Pinto
	 * @date 07/11/2007
	 * @param FiltrarEmitirHistogramaEsgotoEconomiaHelper
	 * @return Collection<Object[]>
	 * @throws ControladorException
	 */
	public Collection<Object[]> pesquisarEmitirHistogramaEsgotoEconomiaChavesAgrupadas(FiltrarEmitirHistogramaEsgotoEconomiaHelper filtro)
					throws ErroRepositorioException{

		Collection<Object[]> retornoConsulta = null;

		Session session = HibernateUtil.getSession();

		try{
			Integer mesAnoFaturamento = filtro.getMesAnoFaturamento();

			GerenciaRegional gerenciaRegional = filtro.getGerenciaRegional();
			UnidadeNegocio unidadeNegocio = filtro.getUnidadeNegocio();
			Localidade eloPolo = filtro.getEloPolo();
			Localidade localidade = filtro.getLocalidade();
			SetorComercial setorComercial = filtro.getSetorComercial();
			Quadra quadra = filtro.getQuadra();
			Integer tarifa = filtro.getTarifa();

			CategoriaTipo tipoCategoria = filtro.getTipoCategoria();

			Collection<Integer> colecaoCategoria = filtro.getColecaoCategoria();
			Collection<Integer> colecaoTarifa = filtro.getColecaoTarifa();
			Collection<Integer> colecaoPerfilImovel = filtro.getColecaoPerfilImovel();
			Collection<Integer> colecaoEsferaPoder = filtro.getColecaoEsferaPoder();
			Collection<Integer> colecaoSituacaoLigacaoEsgoto = filtro.getColecaoSituacaoLigacaoEsgoto();

			Collection<BigDecimal> colecaoPercentualLigacaoEsgoto = filtro.getColecaoPercentualLigacaoEsgoto();

			Short percentualLigacaoEsgoto = null;
			if(filtro.getPercentualLigacaoEsgoto() != null) percentualLigacaoEsgoto = filtro.getPercentualLigacaoEsgoto().shortValue();

			Short consumo = filtro.getConsumo();
			Short medicao = filtro.getMedicao();
			Short poco = filtro.getPoco();
			Short volumoFixoEsgoto = filtro.getVolumoFixoEsgoto();

			String clausulaGroup = filtro.getTipoGroupBy();
			String clausulaOrder = filtro.getTipoOrderBy();

			String consulta = "";
			Query query = null;
			Map parameters = new HashMap();

			consulta = "SELECT " + clausulaGroup; // 0

			String consultaFrom = " FROM HistogramaEsgotoEconomia histograma " + "INNER JOIN histograma.categoria categoria ";

			String consultaWhere = "WHERE histograma.referencia=(:mesAnoFaturamento) ";
			parameters.put("mesAnoFaturamento", mesAnoFaturamento);

			// Gerencia Regional
			if(gerenciaRegional != null){
				consultaFrom += "INNER JOIN histograma.gerenciaRegional gerenciaRegional ";

				consultaWhere += "AND gerenciaRegional.id = (:gerencia) ";
				parameters.put("gerencia", gerenciaRegional.getId());
			}

			// Unidade de Negocio
			if(unidadeNegocio != null){
				consultaFrom += "INNER JOIN histograma.unidadeNegocio unidadeNegocio ";

				consultaWhere += "AND unidadeNegocio.id = (:unidade) ";
				parameters.put("unidade", unidadeNegocio.getId());
			}

			// Elo Pólo
			if(eloPolo != null){
				consultaFrom += "INNER JOIN histograma.localidadeElo localidadeElo ";

				consultaWhere += "AND localidadeElo.id = (:eloPolo) ";
				parameters.put("eloPolo", eloPolo.getId());
			}

			// Localidade
			if(localidade != null){
				consultaFrom += "INNER JOIN histograma.localidade localidade ";

				consultaWhere += "AND localidade.id = (:local) ";
				parameters.put("local", localidade.getId());
			}

			// Setor Comercial
			if(setorComercial != null){
				consultaFrom += "INNER JOIN histograma.setorComercial setorComercial ";

				consultaWhere += "AND setorComercial.id = (:setor) ";
				parameters.put("setor", setorComercial.getId());
			}

			// Quadra
			if(quadra != null){
				consultaFrom += "INNER JOIN histograma.quadra quadra ";

				consultaWhere += "AND quadra.id = (:quad) ";
				parameters.put("quad", quadra.getId());
			}

			// Tipo Categoria
			if(tipoCategoria != null){
				consultaFrom += "INNER JOIN histograma.categoriaTipo categoriaTipo ";

				consultaWhere += "AND categoriaTipo.id = (:tipoCategoria) ";
				parameters.put("tipoCategoria", tipoCategoria.getId());
			}

			if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){
				consultaWhere += "AND categoria.id in (:cate) ";
				parameters.put("cate", colecaoCategoria);
			}

			// Tarifa
			if(tarifa != null){
				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id = (:tarifa) ";
				parameters.put("tarifa", tarifa);

			}else if(colecaoTarifa != null && !colecaoTarifa.isEmpty()){

				consultaFrom += "INNER JOIN histograma.consumoTarifa consumoTarifa ";

				consultaWhere += "AND consumoTarifa.id in (:tarifa) ";
				parameters.put("tarifa", colecaoTarifa);
			}

			// Imovel Perfil
			if(colecaoPerfilImovel != null && !colecaoPerfilImovel.isEmpty()){

				consultaFrom += "INNER JOIN histograma.imovelPerfil imovelPerfil ";

				consultaWhere += "AND imovelPerfil.id in (:perfilImovel) ";
				parameters.put("perfilImovel", colecaoPerfilImovel);
			}

			// Esfera Poder
			if(colecaoEsferaPoder != null && !colecaoEsferaPoder.isEmpty()){

				consultaFrom += "INNER JOIN histograma.esferaPoder esferaPoder ";

				consultaWhere += "AND esferaPoder.id in (:esfera) ";
				parameters.put("esfera", colecaoEsferaPoder);
			}

			// Ligacao de Esgoto Situação
			if(colecaoSituacaoLigacaoEsgoto != null && !colecaoSituacaoLigacaoEsgoto.isEmpty()){

				consultaFrom += "INNER JOIN histograma.ligacaoEsgotoSituacao ligacaoEsgotoSituacao ";

				consultaWhere += "AND ligacaoEsgotoSituacao.id in (:situacaoLigacaoEsgoto) ";
				parameters.put("situacaoLigacaoEsgoto", colecaoSituacaoLigacaoEsgoto);
			}

			// Percentual Ligacao de Esgoto
			if(percentualLigacaoEsgoto != null){

				consultaWhere += "AND histograma.percentualEsgoto = (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", percentualLigacaoEsgoto);

			}else if(colecaoPercentualLigacaoEsgoto != null && !colecaoPercentualLigacaoEsgoto.isEmpty()){
				List<Short> valores = new ArrayList<Short>();
				for(BigDecimal val : colecaoPercentualLigacaoEsgoto){
					valores.add(val.shortValue());
				}
				consultaWhere += "AND histograma.percentualEsgoto in (:percentualLigacaoEsgoto) ";
				parameters.put("percentualLigacaoEsgoto", valores);
			}

			// [SB0014] Selecionar por Indicador de Consumo
			if(consumo != null){
				consultaWhere += "AND histograma.indicadorConsumoReal = (:consumo) ";
				parameters.put("consumo", consumo);
			}

			// [SB0015] Selecionar por Indicador de Medido
			if(medicao != null){
				consultaWhere += "AND histograma.indicadorHidrometro = (:medicao) ";
				parameters.put("medicao", medicao);
			}

			// [SB0016] Selecionar por Indicador de Poço
			if(poco != null){
				consultaWhere += "AND histograma.indicadorPoco = (:poco) ";
				parameters.put("poco", poco);
			}

			// [SB0017] Selecionar por Indicador de Volume Fixo de Água
			if(volumoFixoEsgoto != null){
				consultaWhere += "AND histograma.indicadorVolumeFixadoEsgoto = (:volumoFixoEsgoto) ";
				parameters.put("volumoFixoEsgoto", volumoFixoEsgoto);
			}

			String groupBy = "GROUP BY " + clausulaGroup;
			String orderBy = " ORDER BY " + clausulaOrder;

			consulta += consultaFrom + consultaWhere + groupBy + orderBy;

			query = session.createQuery(consulta);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Collection){
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				}else{
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retornoConsulta;
	}

	// **********************************************************************

	/**
	 * Recupera as contas com estouro de consumo ou com baixo consumo [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006, 20/11/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasNaoFichaCompensacao(Integer idTipoConta, Integer idEmpresa, Integer numeroPaginas,
					Integer anoMesReferencia, Integer idFaturamentoGrupo, Integer anoMesReferenciaFaturamentoAntecipado)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cnti_vlconta as valorConta " // 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id = :idTipoConta AND " + "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND "
							+ "contaImpressao.empr_id = :idEmpresa AND "

							+ "contaImpressao.cnti_vlconta <= :valorLimite AND ";

			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idUsuario "
							+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("valorConta", Hibernate.BIG_DECIMAL)
							.setInteger("idTipoConta", idTipoConta).setInteger("idEmpresa", idEmpresa)
							.setInteger("idUsuario", ClienteRelacaoTipo.USUARIO).setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo)
							.setBigDecimal("valorLimite", EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO).setMaxResults(1000)
							.setFirstResult(numeroPaginas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com estouro de consumo ou com baixo consumo [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006, 20/11/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasFichaCompensacao(Integer idTipoConta, Integer idEmpresa, Integer numeroPaginas,
					Integer anoMesReferencia, Integer idFaturamentoGrupo, Integer anoMesReferenciaFaturamentoAntecipado)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cnti_vlconta as valorConta " // 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id = :idTipoConta AND " + "contaImpressao.ftgr_id = :idFaturamentoGrupoParms AND "
							+ "contaImpressao.empr_id = :idEmpresa AND "

							+ "contaImpressao.cnti_vlconta > :valorLimite AND ";

			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idUsuario "
							+ "order by  cnt.cnta_amreferenciaconta,contaImpressao.empr_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("valorConta", Hibernate.BIG_DECIMAL)
							.setInteger("idTipoConta", idTipoConta).setInteger("idEmpresa", idEmpresa)
							.setInteger("idUsuario", ClienteRelacaoTipo.USUARIO).setInteger("idFaturamentoGrupoParms", idFaturamentoGrupo)
							.setBigDecimal("valorLimite", EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com entrega para o cliente responsável [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006, 20/11/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelNaoFichaCompensacao(Integer idTipoConta, Integer numeroPaginas,
					Integer anoMesReferencia, Integer idFaturamentoGrupo, Short indicadorEmissaoExtratoFaturamento,
					Integer anoMesReferenciaFaturamentoAntecipado) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cnti_vlconta as valorConta " // 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id = :idTipoConta AND " + "contaImpressao.ftgr_id = :idFaturamentoGrupo AND "
							+ "contaImpressao.empr_id is null AND ";

			// + "contaImpressao.cnti_vlconta <= :valorLimite AND ";

			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
							+ "imovel.imov_icemissaoextratofaturamen = :indicadorEmissaoExtratoFaturamento "
							+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("valorConta", Hibernate.BIG_DECIMAL)
							.setInteger("idTipoConta", idTipoConta).setInteger("idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
							.setShort("indicadorEmissaoExtratoFaturamento", indicadorEmissaoExtratoFaturamento).
							// setBigDecimal("valorLimite",EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO).
							setMaxResults(1000).setFirstResult(numeroPaginas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera as contas com entrega para o cliente responsável [UC0348] -
	 * Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006, 20/11/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelFichaCompensacao(Integer idTipoConta, Integer numeroPaginas,
					Integer anoMesReferencia, Integer idFaturamentoGrupo, Short indicadorEmissaoExtratoFaturamento,
					Integer anoMesReferenciaFaturamentoAntecipado) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cnti_vlconta as valorConta " // 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id = :idTipoConta AND " + "contaImpressao.ftgr_id = :idFaturamentoGrupo AND "
							+ "contaImpressao.empr_id is null AND "

							+ "contaImpressao.cnti_vlconta > :valorLimite AND ";

			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
							+ "imovel.imov_icemissaoextratofaturamen = :indicadorEmissaoExtratoFaturamento "
							+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("valorConta", Hibernate.BIG_DECIMAL)
							.setInteger("idTipoConta", idTipoConta).setInteger("idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
							.setShort("indicadorEmissaoExtratoFaturamento", indicadorEmissaoExtratoFaturamento)
							.setBigDecimal("valorLimite", EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa as contas do cliente responsável para todos os grupos de
	 * faturamento.
	 * [UC0348] Emitir Contas
	 * 
	 * @author Pedro Alexandre,Vivianne Sousa
	 * @date 17/05/2007, 20/11/2007
	 * @param idTipoConta
	 * @param numeroPaginas
	 * @param anoMesReferencia
	 * @param indicadorEmissaoExtratoFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelNaoFichaCompensacao(Integer idTipoConta, Integer numeroPaginas,
					Integer anoMesReferencia, Short indicadorEmissaoExtratoFaturamento, Integer anoMesReferenciaFaturamentoAntecipado)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cnti_vlconta as valorConta " // 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id = :idTipoConta AND " + "contaImpressao.empr_id is null AND ";

			// + "contaImpressao.cnti_vlconta <= :valorLimite AND ";

			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
							+ "imovel.imov_icemissaoextratofaturamen = :indicadorEmissaoExtratoFaturamento "
							+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("valorConta", Hibernate.BIG_DECIMAL)
							.setInteger("idTipoConta", idTipoConta).setInteger("idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
							.setShort("indicadorEmissaoExtratoFaturamento", indicadorEmissaoExtratoFaturamento).
							// setBigDecimal("valorLimite",EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO).
							setMaxResults(1000).setFirstResult(numeroPaginas).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa as contas do cliente responsável para todos os grupos de
	 * faturamento.
	 * [UC0348] Emitir Contas
	 * 
	 * @author Pedro Alexandre,Vivianne Sousa
	 * @date 17/05/2007, 20/11/2007
	 * @param idTipoConta
	 * @param numeroPaginas
	 * @param anoMesReferencia
	 * @param indicadorEmissaoExtratoFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasClienteResponsavelFichaCompensacao(Integer idTipoConta, Integer numeroPaginas,
					Integer anoMesReferencia, Short indicadorEmissaoExtratoFaturamento, Integer anoMesReferenciaFaturamentoAntecipado)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select "
							+ "cnt.cnta_id as idConta, "// 0
							+ "cli.clie_nmcliente as nomeCliente, "// 1
							+ "cnt.cnta_dtvencimentoconta as dataVencimentoConta, "// 2
							+ "cnt.cnta_amreferenciaconta as amReferencia, "// 3
							+ "cnt.cnta_dgverificadorconta as digitoVerificador, "// 4
							+ "cnt.cnta_cdsetorcomercial as codigoSetorComercial, "// 5
							+ "cnt.cnta_nnquadra as numeroQuadra, "// 6
							+ "cnt.cnta_nnlote as lote, "// 7
							+ "cnt.cnta_nnsublote as sublote, "// 8
							+ "cnt.cnta_nnconsumoagua as consumoAgua, "// 9
							+ "cnt.cnta_nnconsumoesgoto as consumoEsgoto, "// 10
							+ "cnt.cnta_vlagua as valorAgua, "// 11
							+ "cnt.cnta_vlesgoto as valorEsgoto, "// 12
							+ "cnt.cnta_vldebitos as debitos, "// 13
							+ "cnt.cnta_vlcreditos as valorCreditos, "// 14
							+ "cnt.cnta_vlimpostos as valorImpostos, "// 15
							+ "cnt.cnta_dtvalidadeconta as dataValidade, "// 16
							+ "imovel.imov_id as idImovel, "// 17
							+ "loc.loca_id as idLocalidade, "// 18
							+ "gerenciaRegional.greg_id as idGerenciaRegional, "// 19
							+ "gerenciaRegional.greg_nmregional as nomeGerencia, "// 20
							+ "ligacaoAguaSituacao.last_id as idLigacaoAguaSituacao, "// 21
							+ "ligacaoEsgotoSituacao.lest_id as idLigacaoEsgotoSituacao, "// 22
							+ "imovelPerfil.iper_id as idImovelPrefil, "// 23
							+ "setorComercial.stcm_id as idSetorComercial, "// 24
							+ "contaImpressao.ftgr_id as idFaturamentoGrupo, "// 25
							+ "contaImpressao.empr_id as idEmpresa, "// 26
							+ "loc.loca_nmlocalidade as descricaoLocalidade, "// 27
							+ "ligacaoAguaSituacao.last_dsligacaoaguasituacao as descricaoLigAguaSit, "// 28
							+ "ligacaoEsgotoSituacao.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSit, "// 29
							+ "cnt.cnta_pcesgoto as percentualEsgoto, "// 30
							+ "contaImpressao.clie_idresponsavel as idClienteResponsavel, "// 31
							+ "imovel.imov_nmimovel as nomeImovel, "// 32
							+ "rota.rota_cdrota as codigoRota, "// 33
							+ "imovel.imov_nnsequencialrota as sequencialRota, "// 34
							+ "cnt.cnta_idorigem as origem, "// 35
							+ "cnt.dcst_idatual as debitoCreditoSituacaoAtual, "// 36
							+ "func.func_id as idFuncionario, "// 37
							+ "func.func_nmfuncionario as nomeFuncionario, "// 38
							+ "contaImpressao.cnti_vlconta as valorConta " // 39
							+ "from cliente_conta cliCnt " + "inner join conta cnt on cliCnt.cnta_id=cnt.cnta_id "
							+ "inner join conta_impressao contaImpressao on cnt.cnta_id = contaImpressao.cnta_id "
							+ "inner join quadra quadraConta on cnt.qdra_id=quadraConta.qdra_id "
							+ "inner join rota rota on quadraConta.rota_id=rota.rota_id "
							+ "inner join setor_comercial setorComercial on quadraConta.stcm_id=setorComercial.stcm_id "
							+ "inner join localidade loc on cnt.loca_id=loc.loca_id "
							+ "inner join gerencia_regional gerenciaRegional on loc.greg_id=gerenciaRegional.greg_id "
							+ "inner join ligacao_agua_situacao ligacaoAguaSituacao " + "on cnt.last_id=ligacaoAguaSituacao.last_id "
							+ "inner join ligacao_esgoto_situacao ligacaoEsgotoSituacao " + "on cnt.lest_id=ligacaoEsgotoSituacao.lest_id "
							+ "inner join imovel_perfil imovelPerfil on cnt.iper_id=imovelPerfil.iper_id "
							+ "inner join imovel imovel on cnt.imov_id=imovel.imov_id "
							+ "inner join cliente cli on cliCnt.clie_id=cli.clie_id "
							+ "left join funcionario func on imovel.func_id=func.func_id "
							+ "where contaImpressao.cttp_id = :idTipoConta AND " + "contaImpressao.empr_id is null AND "

							+ "contaImpressao.cnti_vlconta > :valorLimite AND ";

			if(anoMesReferenciaFaturamentoAntecipado != null){
				consulta += "(contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia + " OR contaImpressao.cnti_amreferenciaconta ="
								+ anoMesReferenciaFaturamentoAntecipado + ")";
			}else{
				consulta += "contaImpressao.cnti_amreferenciaconta =" + anoMesReferencia;
			}
			consulta += " AND cliCnt.crtp_id = :idResposavel AND "
							+ "imovel.imov_icemissaoextratofaturamen = :indicadorEmissaoExtratoFaturamento "
							+ "order by  cnt.cnta_amreferenciaconta,cli.clie_id,loc.loca_id,cnt.cnta_cdsetorcomercial,"
							+ "rota.rota_cdrota,imovel.imov_nnsequencialrota,cnt.cnta_nnquadra,cnt.cnta_nnlote,cnt.cnta_nnsublote";

			retorno = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).addScalar("nomeCliente", Hibernate.STRING)
							.addScalar("dataVencimentoConta", Hibernate.DATE).addScalar("amReferencia", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT).addScalar("codigoSetorComercial", Hibernate.INTEGER)
							.addScalar("numeroQuadra", Hibernate.INTEGER).addScalar("lote", Hibernate.SHORT)
							.addScalar("sublote", Hibernate.SHORT).addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("consumoEsgoto", Hibernate.INTEGER).addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL).addScalar("debitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL).addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("dataValidade", Hibernate.DATE).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("idLocalidade", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER)
							.addScalar("nomeGerencia", Hibernate.STRING).addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
							.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovelPrefil", Hibernate.INTEGER)
							.addScalar("idSetorComercial", Hibernate.INTEGER).addScalar("idFaturamentoGrupo", Hibernate.INTEGER)
							.addScalar("idEmpresa", Hibernate.INTEGER).addScalar("descricaoLocalidade", Hibernate.STRING)
							.addScalar("descricaoLigAguaSit", Hibernate.STRING).addScalar("descricaoLigEsgotoSit", Hibernate.STRING)
							.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idClienteResponsavel", Hibernate.INTEGER)
							.addScalar("nomeImovel", Hibernate.STRING).addScalar("codigoRota", Hibernate.SHORT)
							.addScalar("sequencialRota", Hibernate.INTEGER).addScalar("origem", Hibernate.INTEGER)
							.addScalar("debitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("idFuncionario", Hibernate.INTEGER)
							.addScalar("nomeFuncionario", Hibernate.STRING).addScalar("valorConta", Hibernate.BIG_DECIMAL)
							.setInteger("idTipoConta", idTipoConta).setInteger("idResposavel", ClienteRelacaoTipo.RESPONSAVEL)
							.setShort("indicadorEmissaoExtratoFaturamento", indicadorEmissaoExtratoFaturamento)
							.setBigDecimal("valorLimite", EmitirContaHelper.VALOR_LIMITE_FICHA_COMPENSACAO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0626] Gerar Resumo de Metas Acumulado no Mês (CAERN)
	 * 
	 * @author Sávio Luiz
	 * @data 28/11/2007
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarIdsContasDoImovelPorMesAnoReferencia(int anoMesReferencia, Integer idImovel) throws ErroRepositorioException{

		Collection<Conta> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select cnta.id " + "from Conta cnta " + "where cnta.referencia < :anoMesReferencia "
							+ "and cnta.imovel = :idImovel " + "and (cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.NORMAL
							+ " or " + "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.RETIFICADA + " or "
							+ "cnta.debitoCreditoSituacaoAtual = " + DebitoCreditoSituacao.INCLUIDA + ")";

			// executa o hql
			retorno = session.createQuery(consulta).setInteger("anoMesReferencia", anoMesReferencia).setInteger("idImovel", idImovel)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * atualiza o sequencial de conta impressão
	 * e o indicador de fichaCompensação
	 * 
	 * @author Vivianne Sousa
	 * @date 02/12/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSequencialContaImpressaoFichaCompensacao(Map<Integer, Integer> mapAtualizaSequencial)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String consulta = "update gcom.faturamento.conta.ContaImpressao "
						+ "set cnti_nnsequencialimpressao =:sequencialConta ,cnti_tmultimaalteracao = :dataAtual, "
						+ "cnti_icfichacompensacao = :indicadorFichaCompensacao " + "where cnta_id = :idConta ";

		try{
			if(mapAtualizaSequencial != null && !mapAtualizaSequencial.isEmpty()){
				Iterator iteMapAtualizaSequencia = mapAtualizaSequencial.keySet().iterator();

				while(iteMapAtualizaSequencia.hasNext()){
					Integer idConta = (Integer) iteMapAtualizaSequencia.next();
					Integer sequencialConta = mapAtualizaSequencial.get(idConta);
					session.createQuery(consulta).setInteger("idConta", idConta).setInteger("sequencialConta", sequencialConta)
									.setShort("indicadorFichaCompensacao", ConstantesSistema.SIM).setDate("dataAtual", new Date())
									.executeUpdate();
				}
			}
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);

		}

	}

	/**
	 * [UC0724] - Processar Pagamento com Ficha de Compensação
	 * Author: Vivianne Sousa
	 * Data: 26/11/2007
	 * 
	 * @param idConta
	 * @return Descrição do retorno
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Conta pesquisarExistenciaContaComSituacaoAtual(Integer idConta) throws ErroRepositorioException{

		Conta retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select ct " + "from Conta ct " + "inner join fetch ct.imovel imov " + "inner join fetch imov.localidade loc "
							+ "inner join ct.debitoCreditoSituacaoAtual " + "where ct.id = :idConta and "
							+ "ct.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada, :prescrita)";

			retorno = (Conta) session.createQuery(consulta).setInteger("idConta", idConta)
							.setInteger("normal", DebitoCreditoSituacao.NORMAL).setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
							.setInteger("prescrita", DebitoCreditoSituacao.PRESCRITA).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Boolean pesquisarExisteciaParcelamentoConta(Integer idConta, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{

		Boolean retorno = false;
		Collection pesquisa = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT dbcb FROM DebitoCobrado dbcb INNER JOIN dbcb.financiamentoTipo fntp "
							+ "WHERE dbcb.conta.id = :idConta and fntp.id in (:tiposParcelamento)";

			pesquisa = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setParameterList("tiposParcelamento", tiposParcelamento).list();

			if(pesquisa != null && !pesquisa.isEmpty()){
				retorno = true;
			}else{
				retorno = false;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto CAER
	 * 
	 * @author Raphael Rossiter
	 * @param idConsumoTarifa
	 * @return ConsumoTarifaVigencia
	 * @throws ErroRepositorioException
	 */
	public ConsumoTarifaVigencia pesquisarConsumoTarifaVigenciaEmVigor(Integer idConsumoTarifa) throws ErroRepositorioException{

		ConsumoTarifaVigencia retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT ctv " + "FROM gcom.faturamento.consumotarifa.ConsumoTarifaVigencia ctv "
							+ "INNER JOIN ctv.consumoTarifa ct " + "where ct.id = :idConsumoTarifa " + "ORDER BY ctv.dataVigencia DESC";

			retorno = (ConsumoTarifaVigencia) session.createQuery(consulta).setInteger("idConsumoTarifa", idConsumoTarifa).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00730] Gerar Relatório de Imóveis com Faturas Recentes em Dia e Faturas Antigas em Atraso
	 * 
	 * @author Rafael Pinto
	 * @date 10/01/2008
	 * @param idImovel
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarQuantidadeFaturasValorFaturas(Integer idImovel) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "SELECT count(*) as quantidade,sum(cnta_vlagua + cnta_vlesgoto + cnta_vldebitos - cnta_vlcreditos) as valor "
							+ "FROM conta contaAtual " + "WHERE contaAtual.dcst_idatual IN ( 0,1,2 ) "
							+ "AND contaAtual.imov_id = :idImovel " + "AND NOT EXISTS ( " + "SELECT pgto.cnta_id FROM pagamento pgto "
							+ "WHERE contaAtual.cnta_id = pgto.cnta_id )";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar("quantidade", Hibernate.INTEGER)
							.addScalar("valor", Hibernate.BIG_DECIMAL).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00730] Gerar Relatório de Imóveis com Faturas Recentes em Dia e Faturas Antigas em Atraso
	 * 
	 * @author Rafael Pinto
	 * @date 10/01/2008
	 * @param idImovel
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarReferenciaAntigaContaSemPagamento(Integer idImovel) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "SELECT contaAntigo.cnta_amreferenciaconta as anoMes,min(contaAntigo.cnta_amreferenciaconta) as referencia "
							+ "FROM conta contaAntigo " + "WHERE contaAntigo.dcst_idatual IN ( 0,1,2 ) "
							+ "AND contaAntigo.imov_id = :idImovel " + "AND NOT EXISTS ( " + "SELECT pgto.cnta_id FROM pagamento pgto "
							+ "WHERE contaAntigo.cnta_id = pgto.cnta_id )" + "GROUP BY contaAntigo.cnta_amreferenciaconta";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar("anoMes", Hibernate.INTEGER)
							.addScalar("referencia", Hibernate.INTEGER).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00730] Gerar Relatório de Imóveis com Faturas Recentes em Dia e Faturas Antigas em Atraso
	 * 
	 * @author Rafael Pinto
	 * @date 10/01/2008
	 * @param idImovel
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarReferenciaAtualContaSemPagamento(Integer idImovel) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "SELECT contaAtual.cnta_amreferenciaconta as anoMes,max(contaAtual.cnta_amreferenciaconta) as referencia "
							+ "FROM conta contaAtual " + "WHERE contaAtual.dcst_idatual IN ( 0,1,2 ) "
							+ "AND contaAtual.imov_id = :idImovel " + "AND NOT EXISTS ( " + "SELECT pgto.cnta_id FROM pagamento pgto "
							+ "WHERE contaAtual.cnta_id = pgto.cnta_id )" + "GROUP BY contaAtual.cnta_amreferenciaconta ";

			retorno = (Object[]) session.createSQLQuery(consulta).addScalar("anoMes", Hibernate.INTEGER)
							.addScalar("referencia", Hibernate.INTEGER).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0187] Inserir Guia de Pagamento
	 * 
	 * @author Eduardo Henrique
	 * @date 25/07/2008
	 * @param idRegistroAtendimento
	 * @param idDebitoTipo
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean verificarExistenciaRegistroAtendimentoGuiaPagamento(Integer idRegistroAtendimento, Integer idDebitoTipo)
					throws ErroRepositorioException{

		boolean retorno = true;
		if(idRegistroAtendimento == null || idDebitoTipo == null){
			retorno = false;
		}

		String consulta = "";
		Session session = HibernateUtil.getSession();
		try{
			consulta = "Select distinct gpp.comp_id " +

			"from GuiaPagamentoPrestacao gpp gpp.guiaPagamento gp " +

			"where gp.registroAtendimento.id = :idRegistroAtendimento " +

			"and gpp.debitoTipo.id = :idDebitoTipo  ";

			Collection colecao = session.createQuery(consulta).setInteger("idRegistroAtendimento", idRegistroAtendimento)
							.setInteger("idDebitoTipo", idDebitoTipo).list();

			if(colecao != null && !colecao.isEmpty()){ // Já houve Guia de Pagamento para o RA e
				// Tipo de Débito
				retorno = false;
			}
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa os dados de Guias de Pagamento (e suas Prestações) de um determinado Imóvel.
	 * 
	 * @author eduardo henrique
	 * @date 08/08/2008
	 *       OBS : Obrigatório informar ou Imóvel ou Cliente para funcionamento
	 * @param idImovel
	 * @param idCliente
	 * @return Collection Helper's
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoPrestacaoImovelOuCliente(Integer idImovel, Integer idCliente) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select new " + GuiaPagamentoPrestacaoHelper.class.getName() + " ( " + "guiaPrestacoes.comp_id.guiaPagamentoId, "
							+ "guiaPrestacoes.comp_id.numeroPrestacao, " + "guiaPrestacoes.comp_id.debitoTipoId, "
							+ "guiaPrestacoes.comp_id.itemLancamentoContabilId, " + "guia.documentoTipo.descricaoDocumentoTipo, "
							+ "guia.numeroPrestacaoTotal, " + "guiaPrestacoes.dataEmissao, " + "guiaPrestacoes.dataVencimento, "
							+ "guiaPrestacoes.valorPrestacao, " + "guiaPrestacoes.indicadorPagamentoPendente, "
							+ "guia.debitoCreditoSituacaoAtual.descricaoDebitoCreditoSituacao, guiaPrestacoes.indicadorExecucaoFiscal) " +

							"from GuiaPagamento guia join guia.guiasPagamentoPrestacao guiaPrestacoes ";

			if(idImovel != null){
				consulta += " where guia.imovel.id =  " + idImovel;
			}else{
				consulta += " where guia.cliente.id = " + idCliente;
			}

			consulta += "order by guiaPrestacoes.anoMesReferenciaFaturamento, guiaPrestacoes.dataVencimento, guiaPrestacoes.comp_id.debitoTipoId, guiaPrestacoes.comp_id.numeroPrestacao ";

			retorno = session.createQuery(consulta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados de Debito a Cobrar.
	 * 
	 * @author Vitor Hora
	 * @date 04/09/2008
	 * @param debitoACobrar
	 * @return Collection Helper's
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarCategoria(DebitoACobrar debitoACobrar) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select dacc " + "from DebitoACobrarCategoria dacc " + "where dacc.debitoACobrar.id = :idDebitoACobrar";

			retorno = session.createQuery(consulta).setInteger("idDebitoACobrar", debitoACobrar.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa a categoria com mais economias de uma Conta
	 * 
	 * @author eduardo henrique
	 * @date 23/09/2008
	 * @param conta
	 *            - Conta de Referência para Pesquisa
	 * @return ContaCategoria com id populado.
	 * @throws ErroRepositorioException
	 */
	public ContaCategoria obterPrincipalCategoriaConta(Conta conta) throws ErroRepositorioException{

		ContaCategoria contaCategoriaRetorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String hql = " select " + " cc.comp_id.categoria as categoria " + " from " + "   ContaCategoria cc " + " where "
							+ "   cc.comp_id.conta.id = :idConta " + " group by " + "   cc.comp_id.categoria.id "
							+ " order by sum( cc.quantidadeEconomia ) desc ";

			Integer idCategoria = (Integer) session.createQuery(hql).setInteger("idConta", conta.getId()).setMaxResults(1).uniqueResult();

			Categoria categoria = new Categoria();
			categoria.setId(idCategoria);

			// monta o ContaCategoria com a Categoria mais relevante
			ContaCategoriaPK contaCategoriaPK = new ContaCategoriaPK();
			contaCategoriaPK.setConta(conta);
			contaCategoriaPK.setCategoria(categoria);

			contaCategoriaRetorno = new ContaCategoria();
			contaCategoriaRetorno.setComp_id(contaCategoriaPK);

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return contaCategoriaRetorno;
	}

	/**
	 * Método responsável por pesquisar o volume de um FaturamentoSituacaoHistorico.
	 * 
	 * @author Virgínia Melo
	 * @date 01/10/2008
	 * @param idImovel
	 *            - ID do imóvel
	 * @param anoMesFaturamento
	 *            - AnoMês de Faturamento
	 */
	public Integer pesquisarVolumeFaturamentoSituacaoHistorico(Integer idImovel, Integer anoMesFaturamento) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select ftsh.volume from gcom.faturamento.FaturamentoSituacaoHistorico ftsh "
							+ "where ftsh.imovel.id = :idImovel and ftsh.anoMesFaturamentoRetirada is null "
							+ "and :anoMesFaturamento between ftsh.anoMesFaturamentoSituacaoInicio and ftsh.anoMesFaturamentoSituacaoFim";

			retorno = (Integer) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setInteger("anoMesFaturamento", anoMesFaturamento).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por pesquisar o FaturamentoSituacaoHistorico de um Imóvel
	 * 
	 * @author Eduardo Henrique
	 * @date 06/10/2008
	 * @param idImovel
	 *            - ID do imóvel
	 * @param anoMesFaturamento
	 *            - AnoMês de Faturamento
	 */
	public Collection<FaturamentoSituacaoHistorico> pesquisarFaturamentoSituacaoHistoricoImovel(Integer idImovel, Integer anoMesFaturamento)
					throws ErroRepositorioException{

		Collection<FaturamentoSituacaoHistorico> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = " select ftsh from FaturamentoSituacaoHistorico ftsh "
							+ " inner join fetch ftsh.faturamentoSituacaoTipo faturamentoSituacaoTipo "
							+ "where ftsh.imovel.id = :idImovel and ftsh.anoMesFaturamentoRetirada is null "
							+ "and :anoMesFaturamento between ftsh.anoMesFaturamentoSituacaoInicio and ftsh.anoMesFaturamentoSituacaoFim";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).setInteger("anoMesFaturamento", anoMesFaturamento)
							.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por pesquisar o FaturamentoSituacaoHistorico ativo de um Imóvel
	 * 
	 * @author Saulo Lima
	 * @date 24/01/2013
	 * @param idImovel
	 */
	public Collection<FaturamentoSituacaoHistorico> pesquisarFaturamentoSituacaoHistoricoAtivoImovel(Integer idImovel)
					throws ErroRepositorioException{

		Collection<FaturamentoSituacaoHistorico> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "SELECT ftsh FROM FaturamentoSituacaoHistorico ftsh "
							+ "WHERE ftsh.imovel.id = :idImovel AND ftsh.anoMesFaturamentoRetirada IS NULL";

			retorno = session.createQuery(consulta).setInteger("idImovel", idImovel).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato
	 * 
	 * @author eduardo henrique
	 * @date 08/10/2008
	 * @param imoveis
	 *            (Coleção de Rotas que tiveram Faturamento Imediato gerado)
	 * @param anoMesReferencia
	 *            (Ano/Mês referente ao Faturamento)
	 *            Obtém os movimentos Roteiro com Indicador de Fase '1' de um determinado ano Mês
	 *            Referência e de Imóveis de Rotas de um Grupo de Faturamento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasPreFaturadasImoveisFaturamentoImediato(Collection listImoveisRota, Integer anoMesReferencia)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select distinct conta " + "from Conta conta  " + "inner join conta.imovel imovel "
							+ "inner join conta.imovel.setorComercial setor " + "inner join conta.imovel.localidade localidade "
							+ "inner join conta.imovel.quadra quadra " + "left join conta.imovel.hidrometroInstalacaoHistorico hih "
							+ "left join conta.imovel.ligacaoAgua ligacaoAgua "
							+ "left join ligacaoAgua.hidrometroInstalacaoHistorico hidInstHistoricoAgua "
							+ "left join conta.imovel.ligacaoEsgoto ligacaoEsgoto " + "inner join conta.localidade loc "
							+ "left join fetch conta.contaCategorias ctcg " + "left join fetch conta.debitoCobrados dc "
							+ "left join fetch dc.debitoCobradoCategorias dcc " + "left join fetch conta.contaImpostosDeduzidos cid "
							+ "left join fetch conta.creditoRealizados cr " + "left join fetch cr.creditoRealizadoCategorias crc "
							+ "where conta.debitoCreditoSituacaoAtual.id = :idSituacaoPreFaturada "
							+ "and conta.referencia = :anoMesReferencia " + "and conta.imovel in (:listImoveisRota) ";

			// retorno = (Collection)
			// session.createQuery(consulta).setInteger("idSituacaoPreFaturada",
			// DebitoCreditoSituacao.PRE_FATURADA)
			// .setInteger("anoMesReferencia", anoMesReferencia).setParameterList("listImoveisRota",
			// listImoveisRota).list();
			//

			// trata a consulta para não deixar trazer mais de 1000 resultados de uma vez.
			if(listImoveisRota != null && listImoveisRota.size() > 1000){
				Collection colecaoAuxiliar = new ArrayList<Object>();
				retorno = new ArrayList<Object>();
				for(Object id : listImoveisRota){
					colecaoAuxiliar.add(id);
					if(colecaoAuxiliar.size() == 1000){
						retorno.addAll(session.createQuery(consulta)
										.setInteger("idSituacaoPreFaturada", DebitoCreditoSituacao.PRE_FATURADA)
										.setInteger("anoMesReferencia", anoMesReferencia)
										.setParameterList("listImoveisRota", colecaoAuxiliar).list());
						colecaoAuxiliar.clear();
					}
				}
				if(!colecaoAuxiliar.isEmpty()){

					retorno.addAll(session.createQuery(consulta).setInteger("idSituacaoPreFaturada", DebitoCreditoSituacao.PRE_FATURADA)
									.setInteger("anoMesReferencia", anoMesReferencia).setParameterList("listImoveisRota", colecaoAuxiliar)
									.list());
				}
			}else{

				retorno = session.createQuery(consulta).setInteger("idSituacaoPreFaturada", DebitoCreditoSituacao.PRE_FATURADA)
								.setInteger("anoMesReferencia", anoMesReferencia).setParameterList("listImoveisRota", listImoveisRota)
								.list();

			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por retornar o valor de cada prestação de uma determinada guia de
	 * pagamento.
	 * 
	 * @author Virgínia Melo
	 */
	public Collection<Object[]> pesquisarValorPrestacoesGuiaPagamento(Integer idGuia) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "SELECT gpp.comp_id.numeroPrestacao, sum(gpp.valorPrestacao) "
							+ "FROM gcom.arrecadacao.pagamento.GuiaPagamentoPrestacao gpp "
							+ "WHERE gpp.comp_id.guiaPagamentoId = :idGuia " + "GROUP BY gpp.comp_id.numeroPrestacao ";

			retorno = session.createQuery(consulta).setInteger("idGuia", idGuia.intValue()).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato
	 * Método responsável por pesquisar a quantidade de MovimentoRoteiroEmpresa .
	 * 
	 * @author Eduardo Henrique
	 * @date 14/10/2008
	 * @param anoMesFaturamento
	 *            - AnoMês de Faturamento
	 * @param idImovel
	 *            - ID do imóvel
	 * @param indicadorFase
	 *            - Indicador de Fase do Movimento (utilizada '<> de')
	 * @author eduardo henrique
	 * @date 07/01/2009
	 *       Alteração no método para passagem de parâmetro do indicador de fase.
	 */
	public Integer pesquisarQuantidadeMovimentosRoteiroEmpresaSemProcessamento(Integer idFaturamentoGrupo, Integer anoMesFaturamento,
					Short indicadorFase) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select count(mre.id) from gcom.micromedicao.MovimentoRoteiroEmpresa mre "
							+ "where mre.anoMesMovimento = :anoMesFaturamento " + "and mre.faturamentoGrupo.id = :idFaturamentoGrupo "
							+ "and mre.indicadorFase <> :idFaseProcessado ";

			retorno = ((Number) session.createQuery(consulta).setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
							.setInteger("anoMesFaturamento", anoMesFaturamento).setShort("idFaseProcessado", indicadorFase)
							.setMaxResults(1).uniqueResult()).intValue();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por Inserir ou Atualizar uma colecão de ResumosFaturamentoSimulação.
	 * (Utiliza uma sessão Stateless para melhor performance)
	 * 
	 * @author Eduardo Henrique
	 * @date 15/10/2008
	 * @param colecaoResumoFaturamentoSimulacao
	 *            - coleção de Resumos
	 */
	public void inserirOuAtualizarResumoFaturamentoSimulacao(Collection<ResumoFaturamentoSimulacao> colecaoResumoFaturamentoSimulacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			Iterator iteratorColecaoResumoSimulacao = colecaoResumoFaturamentoSimulacao.iterator();

			while(iteratorColecaoResumoSimulacao.hasNext()){

				ResumoFaturamentoSimulacao resumoFaturamentoSimulacao = (ResumoFaturamentoSimulacao) iteratorColecaoResumoSimulacao.next();

				if(resumoFaturamentoSimulacao.getId() == null){
					session.save(resumoFaturamentoSimulacao);
				}else{
					session.update(resumoFaturamentoSimulacao);
				}

				session.flush();
			}

		}catch(HibernateException e){
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato
	 * Método responsável por Atualizar o status dos Imóveis que tiveram Consumos Estimados para um
	 * Grupo de Faturamento / Ano/Mês
	 * 
	 * @author Eduardo Henrique
	 * @date 21/10/2008
	 * @param idFaturamentoGrupo
	 *            - ID do Grupo de Faturamento
	 * @param anoMesFaturamento
	 *            - AnoMês de Faturamento
	 */
	public void atualizarSituacaoMovimentoRoteiroEmpresaImoveisConsumoEstimado(Integer idFaturamentoGrupo, Integer anoMesReferencia)
					throws ErroRepositorioException{

		String update;
		Session session = HibernateUtil.getSession();

		try{
			update = "UPDATE gcom.micromedicao.MovimentoRoteiroEmpresa as movimentoRoteiro SET " + " indicadorFase = :idFase,  "
							+ " tempoGeracao = :ultimaAlteracao " + "WHERE movimentoRoteiro.faturamentoGrupo.id = :idFaturamentoGrupo  "
							+ " and movimentoRoteiro.anoMesMovimento = :anoMesMovimento "
							+ " and movimentoRoteiro.indicadorFase = :idFaseLido " + " and movimentoRoteiro.numeroHidrometro is null ";

			session.createQuery(update).setShort("idFase", Short.valueOf("2")).setDate("ultimaAlteracao", new Date())
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo).setInteger("anoMesMovimento", anoMesReferencia)
							.setShort("idFaseLido", Short.valueOf("1")).executeUpdate();

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0084] - Gerar Faturamento Imediato
	 * 
	 * @author eduardo henrique
	 * @date 03/12/2008
	 * @param imovel
	 *            (Imóvel que será verificado)
	 * @param anoMesReferencia
	 *            (AnoMes de Referência que será verificado)
	 */
	public Object pesquisarIdMovimentoRoteiroEmpresaImovel(Imovel imovel, Integer anoMesReferencia) throws ErroRepositorioException{

		Object retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try{

			consulta = "select movimentoRoteiro.id from MovimentoRoteiroEmpresa movimentoRoteiro "

			+ "inner join movimentoRoteiro.imovel im "

			+ "where im.id = :imovelId and movimentoRoteiro.anoMesMovimento = :anoMesReferencia";

			retorno = session.createQuery(consulta).setInteger("imovelId", imovel.getId()).setInteger("anoMesReferencia", anoMesReferencia)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			// fecha a sessão

			HibernateUtil.closeSession(session);

		}

		return retorno;

	}

	/**
	 * Recupera o anoMesReferencia baseado em filtros do FaturamentoGrupo
	 * 
	 * @author eduardo henrique
	 * @date 10/12/2008
	 * @param idFaturamentoGrupo
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarAnoMesReferenciaPorIdFaturamentoGrupo(Integer idFaturamentoGrupo) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select faturamentoGrupo.anoMesReferencia " + "from FaturamentoGrupo faturamentoGrupo "
							+ "where faturamentoGrupo.id = :idFaturamentoGrupo ";

			retorno = (Integer) session.createQuery(consulta).setInteger("idFaturamentoGrupo", idFaturamentoGrupo).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por retornar o Débito A Cobrar
	 * 
	 * @author Saulo Lima
	 * @date 01/12/2008
	 * @param idDebitoACobrar
	 * @return DebitoACobrar
	 */
	public DebitoACobrar pesquisarDebitoACobrar(Integer idDebitoACobrar) throws ErroRepositorioException{

		String consulta;
		Session session = HibernateUtil.getSession();
		DebitoACobrar debito = null;

		try{
			consulta = "select debitoACobrar from DebitoACobrar debitoACobrar " + "WHERE debitoACobrar.id = :idDebitoACobrar";

			debito = (DebitoACobrar) session.createQuery(consulta).setInteger("idDebitoACobrar", idDebitoACobrar).setMaxResults(1)
							.uniqueResult();

			Hibernate.initialize(debito.getDebitoACobrarCategorias());
			Hibernate.initialize(debito.getDebitoTipo());
			Hibernate.initialize(debito.getLocalidade());

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return debito;
	}

	/**
	 * Método responsável por pesquisar Débitos A Cobrar
	 * 
	 * @author Saulo Lima
	 * @date 23/08/2012
	 * @param idsDebitosACobrar
	 * @return Collection<DebitoACobrar>
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrar(Collection<Integer> idsDebitosACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection<DebitoACobrar> retorno = null;

		try{
			String consulta = "SELECT DISTINCT(debitoACobrar) FROM DebitoACobrar debitoACobrar "
							+ "INNER JOIN FETCH debitoACobrar.debitoACobrarCategorias "
							+ "INNER JOIN FETCH debitoACobrar.debitoTipo INNER JOIN FETCH debitoACobrar.localidade "
							+ "WHERE debitoACobrar.id IN (:idsDebitosACobrar)";

			if(idsDebitosACobrar != null && idsDebitosACobrar.size() > 1000){
				// Calendar tempo = Calendar.getInstance();
				Collection<Integer> colecaoAuxiliar = new ArrayList<Integer>();
				retorno = new ArrayList<DebitoACobrar>();
				// int contador = 1;
				for(Integer id : idsDebitosACobrar){
					colecaoAuxiliar.add(id);
					if(colecaoAuxiliar.size() == 1000){
						retorno.addAll(session.createQuery(consulta).setParameterList("idsDebitosACobrar", colecaoAuxiliar).list());
						colecaoAuxiliar.clear();
						// System.out.println("Tempo pesquisarDebitoACobrar 1: " + contador + " -> "
						// + Util.calcularDiferencaTempo(tempo));
						// contador++;
					}
				}
				if(!colecaoAuxiliar.isEmpty()){
					retorno.addAll(session.createQuery(consulta).setParameterList("idsDebitosACobrar", colecaoAuxiliar).list());
					// System.out.println("Tempo pesquisarDebitoACobrar 2: " +
					// Util.calcularDiferencaTempo(tempo));
				}
			}else{
				// Calendar tempo = Calendar.getInstance();
				retorno = session.createQuery(consulta).setParameterList("idsDebitosACobrar", idsDebitosACobrar).list();
				// System.out.println("Tempo pesquisarDebitoACobrar 3: " +
				// Util.calcularDiferencaTempo(tempo));
			}

			// erro no hibernate
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa DebitoACobrarHistorico pelo Id
	 * 
	 * @param debitoACobrarHistorico
	 * @return DebitoACobrarHistorico
	 * @throws ErroRepositorioException
	 */
	public DebitoACobrarHistorico pesquisarDebitoACobrarHistorico(DebitoACobrarHistorico debitoACobrarHistorico)
					throws ErroRepositorioException{

		DebitoACobrarHistorico retorno = null;
		Session session = null;

		try{

			session = HibernateUtil.getSession();
			Criteria criteria = session.createCriteria(DebitoACobrarHistorico.class);
			criteria.add(Restrictions.eq("id", debitoACobrarHistorico.getId()));
			criteria.setFetchMode("debitoACobrarCategoriasHistorico", FetchMode.JOIN);

			retorno = (DebitoACobrarHistorico) criteria.uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores
	 * 
	 * @author eduardo henrique
	 * @date 17/12/2008
	 *       Metódo para consulta de Conta Histórico a partir de um Imóvel e Referência.
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param anoMesReferencia
	 *            Descrição do parâmetro
	 * @return id da ContaHistorico
	 * @exception ErroRepositorioException
	 *                Descrição da exceção
	 */
	public Integer pesquisarExistenciaContaHistoricoComSituacaoAtual(Imovel imovel, Integer anoMesReferencia)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cth.id from ContaHistorico cth " + "inner join cth.imovel " + "inner join cth.debitoCreditoSituacaoAtual "
							+ "where cth.anoMesReferenciaConta = :referencia " + "and cth.imovel.id = :imovel and "
							+ "cth.debitoCreditoSituacaoAtual.id IN(:normal, :incluida, :retificada, :entradaParcelamento, :prefaturada)";

			retorno = (Integer) session.createQuery(consulta).setInteger("imovel", imovel.getId().intValue())
							.setInteger("referencia", anoMesReferencia).setInteger("normal", DebitoCreditoSituacao.NORMAL)
							.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
							.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
							.setInteger("entradaParcelamento", DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO)
							.setInteger("prefaturada", DebitoCreditoSituacao.PRE_FATURADA).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por pesquisar o histórico de instalação hidrômetro (água)
	 * 
	 * @author Virgínia Melo
	 * @date 27/02/2009
	 * @param imovel
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMedicaoAgua(Integer idImovel, int anoMesReferencia) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select mh.hidrometroInstalacaoHistorico.id from MedicaoHistorico mh " + "where mh.anoMesReferencia = :referencia "
							+ "and mh.medicaoTipo.id = 1 " + "and mh.ligacaoAgua.id = :imovel ";

			retorno = (Integer) session.createQuery(consulta).setInteger("imovel", idImovel).setInteger("referencia", anoMesReferencia)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por pesquisar o histórico de instalação hidrômetro (poço)
	 * 
	 * @author Virgínia Melo
	 * @date 27/02/2009
	 * @param imovel
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMedicaoPoco(Integer idImovel, int anoMesReferencia) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select mh.hidrometroInstalacaoHistorico.id from MedicaoHistorico mh " + "where mh.anoMesReferencia = :referencia "
							+ "and mh.medicaoTipo.id = 2 " + "and mh.imovel.id = :imovel ";

			retorno = (Integer) session.createQuery(consulta).setInteger("imovel", idImovel).setInteger("referencia", anoMesReferencia)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por pesquisar o número do hidrômetro a partir do id do histórico de
	 * instalação.
	 * 
	 * @author Virgínia Melo
	 * @date 27/02/2009
	 * @param idHistoricoInstalacaoHidr
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String pesquisarNumeroHidrometro(Integer idHistoricoInstalacaoHidr) throws ErroRepositorioException{

		String retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{

			consulta = "select hih.numeroHidrometro from HidrometroInstalacaoHistorico hih " + "where hih.id = :idHistoricoInstalacaoHidr ";

			retorno = (String) session.createQuery(consulta).setInteger("idHistoricoInstalacaoHidr", idHistoricoInstalacaoHidr)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#inserirContaMotivoRevisao(gcom.faturamento.conta
	 * .ContaMotivoRevisao, gcom.seguranca.acesso.usuario.Usuario)
	 */
	public Integer inserirContaMotivoRevisao(ContaMotivoRevisao contaMotivoRevisao, Usuario usuarioLogado) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = null;

		try{
			retorno = (Integer) session.save(contaMotivoRevisao);
			session.flush();
			session.clear();
		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#atualizarContaMotivoRevisao(gcom.faturamento.conta
	 * .ContaMotivoRevisao)
	 */
	public void atualizarContaMotivoRevisao(ContaMotivoRevisao contaMotivoRevisao) throws ErroRepositorioException{

		StatelessSession session = HibernateUtil.getStatelessSession();

		try{
			session.update(contaMotivoRevisao);

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#pesquisarContaMotivoRevisao(gcom.faturamento.conta
	 * .ContaMotivoRevisao, java.lang.String)
	 */
	public Collection<ContaMotivoRevisao> pesquisarContaMotivoRevisao(ContaMotivoRevisao contaMotivoRevisao, String tipoPesquisa)
					throws ErroRepositorioException{

		Collection<ContaMotivoRevisao> contasMotivoRevisao = new ArrayList<ContaMotivoRevisao>();
		Session session = HibernateUtil.getSession();
		try{
			Criteria criteria = session.createCriteria(ContaMotivoRevisao.class);

			if(tipoPesquisa.equalsIgnoreCase(String.valueOf(ConstantesSistema.TIPO_PESQUISA_INICIAL))){
				criteria.add(Expression.like("descricaoMotivoRevisaoConta", contaMotivoRevisao.getDescricaoMotivoRevisaoConta() + "%"));
			}else{
				criteria.add(Restrictions.eq("descricaoMotivoRevisaoConta", contaMotivoRevisao.getDescricaoMotivoRevisaoConta()));
			}

			if(contaMotivoRevisao.getIndicadorUso().equals(ConstantesSistema.INDICADOR_USO_ATIVO)
							|| contaMotivoRevisao.getIndicadorUso().equals(ConstantesSistema.INDICADOR_USO_DESATIVO)){
				criteria.add(Restrictions.eq("indicadorUso", contaMotivoRevisao.getIndicadorUso()));
			}

			contasMotivoRevisao = criteria.addOrder(Order.asc("descricaoMotivoRevisaoConta")).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return contasMotivoRevisao;

	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#inserirContaMotivoRetificacao(gcom.faturamento.conta
	 * .ContaMotivoRetificacao, gcom.seguranca.acesso.usuario.Usuario)
	 */
	public Integer inserirContaMotivoRetificacao(ContaMotivoRetificacao contaMotivoRetificacao, Usuario usuarioLogado)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = null;

		try{
			retorno = (Integer) session.save(contaMotivoRetificacao);
			session.flush();
			session.clear();
		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#atualizarContaMotivoRetificacao(gcom.faturamento
	 * .conta.ContaMotivoRetificacao)
	 */
	public void atualizarContaMotivoRetificacao(ContaMotivoRetificacao contaMotivoRetificacao) throws ErroRepositorioException{

		StatelessSession session = HibernateUtil.getStatelessSession();

		try{
			session.update(contaMotivoRetificacao);

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#pesquisarContaMotivoRetificacao(gcom.faturamento
	 * .conta.ContaMotivoRetificacao, java.lang.String)
	 */
	public Collection<ContaMotivoRetificacao> pesquisarContaMotivoRetificacao(ContaMotivoRetificacao contaMotivoRetificacao,
					String tipoPesquisa) throws ErroRepositorioException{

		Collection<ContaMotivoRetificacao> contasMotivoRetificacao = new ArrayList<ContaMotivoRetificacao>();
		Session session = HibernateUtil.getSession();
		try{
			Criteria criteria = session.createCriteria(ContaMotivoRetificacao.class);

			String descricaoMotivoRetificacaoConta = contaMotivoRetificacao.getDescricaoMotivoRetificacaoConta();

			if(tipoPesquisa.equalsIgnoreCase(String.valueOf(ConstantesSistema.TIPO_PESQUISA_INICIAL))){
				criteria.add(Restrictions.like("descricaoMotivoRetificacaoConta", descricaoMotivoRetificacaoConta + "%"));
			}else{
				criteria.add(Restrictions.like("descricaoMotivoRetificacaoConta", "%" + descricaoMotivoRetificacaoConta + "%"));
			}

			Short indicadorUso = contaMotivoRetificacao.getIndicadorUso();

			if(indicadorUso.equals(ConstantesSistema.INDICADOR_USO_ATIVO) || indicadorUso.equals(ConstantesSistema.INDICADOR_USO_DESATIVO)){
				criteria.add(Restrictions.eq("indicadorUso", indicadorUso));
			}

			contasMotivoRetificacao = criteria.addOrder(Order.asc("descricaoMotivoRetificacaoConta")).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return contasMotivoRetificacao;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#pesquisarParcelamentoItem(gcom.faturamento.debito
	 * .DebitoACobrarHistorico, gcom.cobranca.parcelamento.Parcelamento)
	 */
	public ParcelamentoItem pesquisarParcelamentoItem(DebitoACobrarHistorico debitoACobrarHistorico, Parcelamento parcelamento)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		try{
			Criteria criteria = session.createCriteria(ParcelamentoItem.class);
			criteria.add(Restrictions.eq("parcelamentoItem.getParcelamento().getId()", parcelamento.getId()));
			criteria.add(Restrictions.eq("parcelamentoItem.getDebitoACobrarHistorico().getId()", debitoACobrarHistorico.getId()));
			return (ParcelamentoItem) criteria.uniqueResult();
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#pesquisarDebitoACobrarGeral(gcom.faturamento.debito
	 * .DebitoACobrarHistorico)
	 */
	public DebitoACobrarGeral pesquisarDebitoACobrarGeral(DebitoACobrarHistorico debitoACobrarHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		try{
			Criteria criteria = session.createCriteria(DebitoACobrarGeral.class);
			criteria.add(Restrictions.eq("id", debitoACobrarHistorico.getId()));
			return (DebitoACobrarGeral) criteria.uniqueResult();
		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Método que consulta se existe uma conta de referência anterior a referência de faturamento
	 * com a data de vencimento igaul ou superiro ao mes da nova conta gerada
	 * UC113-Faturar Grupo de Faturamento
	 * 
	 * @param idImovel
	 * @param anoMesReferenciaFaturamento
	 * @param anoMesVencimentoConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean verificarExistenciaContaComMesmoMesVencimento(Integer idImovel, Integer anoMesReferenciaFaturamento,
					Integer anoMesVencimentoConta) throws ErroRepositorioException{

		boolean retorno = false;
		Session session = HibernateUtil.getSession();
		try{

			String consulta = " "
							+ " select c.cnta_id as idConta"
							+ " from conta c "
							+ " where c.imov_id = :idImovel "
							+ " and c.cnta_amreferenciaconta = (case substr(:anoMesReferenciaFaturamento,5,2) when '01' then substr(:anoMesReferenciaFaturamento - 100,1,4) else substr(:anoMesReferenciaFaturamento,1,4) end || "
							+ "                                 case substr(:anoMesReferenciaFaturamento,5,2) when '01' then '12' else substr(:anoMesReferenciaFaturamento - 1,5,2) end) "
							+ " and c.dcst_idatual in (0,1) "
							+ " and to_number(to_char(c.cnta_dtvencimentoconta,'yyyymm')) >= :anoMesVencimentoConta "
							+ " union "
							+ " select ch.CNTA_ID  as idConta"
							+ " from conta_historico ch "
							+ " where ch.imov_id = :idImovel "
							+ " and ch.cnhi_amreferenciaconta = (case substr(:anoMesReferenciaFaturamento,5,2) when '01' then substr(:anoMesReferenciaFaturamento - 100,1,4) else substr(:anoMesReferenciaFaturamento,1,4) end || "
							+ "                                  case substr(:anoMesReferenciaFaturamento,5,2) when '01' then '12' else substr(:anoMesReferenciaFaturamento - 1,5,2) end) "
							+ " and ch.dcst_idatual in (0,1,5) "
							+ " and to_number(to_char(ch.cnhi_dtvencimentoconta,'yyyymm')) >= :anoMesVencimentoConta ";

			List lista = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferenciaFaturamento", anoMesReferenciaFaturamento)
							.setInteger("anoMesVencimentoConta", anoMesVencimentoConta).list();
			if(lista != null && !lista.isEmpty()){
				retorno = true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que consulta se existe uma conta de referência anterior a referência de faturamento
	 * com a data de vencimento igual ou superior ao mes da nova conta gerada e com data de
	 * vencimento igual a data de vencimento original
	 * UC113-Faturar Grupo de Faturamento
	 * 
	 * @param idImovel
	 * @param anoMesReferenciaFaturamento
	 * @param anoMesVencimentoConta
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean verificarExistenciaContaComMesmoMesVencimentoOriginal(Integer idImovel, Integer anoMesReferenciaFaturamento,
					Integer anoMesVencimentoConta) throws ErroRepositorioException{

		boolean retorno = false;
		Session session = HibernateUtil.getSession();
		try{

			String consulta = " select c.cnta_id as idConta"
							+ " from conta c "
							+ " where c.imov_id = :idImovel "
							+ " and c.cnta_amreferenciaconta = (case substr(:anoMesReferenciaFaturamento,5,2) when '01' then substr(:anoMesReferenciaFaturamento - 100,1,4) else substr(:anoMesReferenciaFaturamento,1,4) end || "
							+ "                                 case substr(:anoMesReferenciaFaturamento,5,2) when '01' then '12' else substr(:anoMesReferenciaFaturamento - 1,5,2) end) "
							+ " and c.dcst_idatual in (0,1) "
							+ " and c.cnta_dtvencimentoconta = c.cnta_dtvencimentooriginal"
							+ " and to_number(to_char(c.cnta_dtvencimentoconta,'yyyymm')) >= :anoMesVencimentoConta "
							+ " union "
							+ " select ch.CNTA_ID  as idConta"
							+ " from conta_historico ch "
							+ " where ch.imov_id = :idImovel "
							+ " and ch.cnhi_amreferenciaconta = (case substr(:anoMesReferenciaFaturamento,5,2) when '01' then substr(:anoMesReferenciaFaturamento - 100,1,4) else substr(:anoMesReferenciaFaturamento,1,4) end || "
							+ "                                  case substr(:anoMesReferenciaFaturamento,5,2) when '01' then '12' else substr(:anoMesReferenciaFaturamento - 1,5,2) end) "
							+ " and ch.dcst_idatual in (0,1,5) " + " and ch.cnhi_dtvencimentoconta = ch.cnhi_dtvencimentooriginal"
							+ " and to_number(to_char(ch.cnhi_dtvencimentoconta,'yyyymm')) >= :anoMesVencimentoConta ";

			List lista = session.createSQLQuery(consulta).addScalar("idConta", Hibernate.INTEGER).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferenciaFaturamento", anoMesReferenciaFaturamento)
							.setInteger("anoMesVencimentoConta", anoMesVencimentoConta).list();
			if(lista != null && !lista.isEmpty()){
				retorno = true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * Lista a quantidade das faturas em débito e o somatório das mesmas. Subtraindo os Impostos e
	 * os Créditos
	 * 
	 * @param imovel
	 * @return List de inteiros, posicao 0 = count, posicao 1 = somatorio
	 * @throws ErroRepositorioException
	 */
	public Object[] listarSomatorioEValorFaturasDebito(Integer idImovel, Date dataVencimentoLimite) throws ErroRepositorioException{

		Object[] retorno = new Object[2];
		Session session = HibernateUtil.getSession();
		try{
			StringBuilder consulta = new StringBuilder(" select count(*) as contador, ")
							//
							.append(" sum( nvl(c.cnta_vlagua,0) + c.cnta_vlesgoto + c.cnta_vldebitos - c.cnta_vlcreditos - nvl( c.cnta_vlimpostos, 0 )) as somatorio ")
							.append(" from conta c") //
							.append(" where c.imov_id= :imov_id");

			if(dataVencimentoLimite != null){
				consulta.append(" and c.cnta_dtvencimentoconta < :dataVencimentoLimite ");
			}

			SQLQuery createSQLQuery = session.createSQLQuery(consulta.toString());
			createSQLQuery.addScalar("contador", Hibernate.INTEGER);
			createSQLQuery.addScalar("somatorio", Hibernate.BIG_DECIMAL);

			createSQLQuery.setInteger("imov_id", idImovel);
			if(dataVencimentoLimite != null){
				createSQLQuery.setDate("dataVencimentoLimite", dataVencimentoLimite);
			}

			retorno = (Object[]) createSQLQuery.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * Pesquisa as conta categoria consumo de faixa.
	 * 
	 * @author Vitor Hora
	 * @date 21/08/2008
	 * @author Yara Souza
	 * @date 30/06/2010
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaConsumoFaixaHistorico(Integer idConta, Integer idCategoria) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaCategoriaConsumoFaixaHistorico "
							+ "from ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistorico "
							+ "inner join fetch contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.contaHistorico contaHistorico "
							+ "inner join fetch contaCategoriaConsumoFaixaHistorico.contaCategoriaHistorico.comp_id.categoria categoria "
							+ "where contaHistorico.id = :idConta " + "and  categoria.id = :idCategoria ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setInteger("idCategoria", idCategoria.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisa as conta categoria consumo de faixa.
	 * 
	 * @author Yara Souza
	 * @date 01/06/2010
	 * @param idConta
	 * @param idCategoria
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCategoriaConsumoFaixa(Integer idConta, Integer idCategoria) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select contaCategoriaConsumoFaixa " + "from ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa "
							+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.conta conta "
							+ "inner join contaCategoriaConsumoFaixa.contaCategoria.comp_id.categoria categoria "
							+ "where conta.id = :idConta " + "and categoria.id = :idCategoria ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta.intValue())
							.setInteger("idCategoria", idCategoria.intValue()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Pagamento consultarPagamento(Integer idPagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Pagamento pagamento = null;

		try{

			Criteria crit = session.createCriteria(Pagamento.class);

			crit.add(Expression.idEq(idPagamento));

			Object obj = crit.uniqueResult();

			if(obj != null){
				pagamento = (Pagamento) obj;

				if(pagamento.getImovel() != null){
					Hibernate.initialize(pagamento.getImovel());
					Hibernate.initialize(pagamento.getImovel().getSetorComercial());
					Hibernate.initialize(pagamento.getImovel().getQuadra());
				}

				if(pagamento.getConta() != null){

					Hibernate.initialize(pagamento.getConta().getPagamentos());
					Hibernate.initialize(pagamento.getConta().getDebitoCobrados());

				}

				if(pagamento.getGuiaPagamentoGeral() != null && pagamento.getGuiaPagamentoGeral().getGuiaPagamento() != null){

					Hibernate.initialize(pagamento.getGuiaPagamentoGeral().getGuiaPagamento().getGuiasPagamentoPrestacao());
					Hibernate.initialize(pagamento.getGuiaPagamentoGeral().getGuiaPagamento().getPagamentos());

				}

			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return pagamento;
	}

	public Pagamento consultarPagamento(Pagamento pagamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Criteria criteria = null;

		if(pagamento.getGuiaPagamentoGeral() != null){
			criteria = session.createCriteria(GuiaPagamentoGeral.class);
			criteria.setFetchMode("guiaPagamento", FetchMode.JOIN);
			criteria.setFetchMode("guiaPagamento.guiasPagamentoPrestacao", FetchMode.JOIN);
			criteria.setFetchMode("guiaPagamento.pagamentos", FetchMode.JOIN);

			criteria.add(Expression.idEq(pagamento.getGuiaPagamentoGeral().getId()));

			Object result = criteria.uniqueResult();

			if(result != null){
				pagamento.setGuiaPagamentoGeral((GuiaPagamentoGeral) result);
			}
		}

		return pagamento;
	}

	/**
	 * @author Yara Souza
	 * @date
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarQuantidadeDebitosCobradosComParcelamentoPorConta(Collection idsContas, Collection<Integer> tiposParcelamento)
					throws ErroRepositorioException{

		// cria a variável que vai armazenar o valor pesquisado
		int retorno = 0;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuffer consulta = new StringBuffer();

		try{

			// constroi o hql
			consulta.append("select count(distinct dbcb.cnta_id) as quantidade").append(" from debito_cobrado dbcb ")
							.append("  where dbcb.cnta_id in (:idsConta) ").append("   and  dbcb.fntp_id in (:tiposParcelamento) ");

			retorno = (Integer) session.createSQLQuery(consulta.toString()).addScalar("quantidade", Hibernate.INTEGER)
							.setParameterList("idsConta", idsContas).setParameterList("tiposParcelamento", tiposParcelamento)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * Metodo que retorno o somátorio dos debitos cobrados.
	 * [0] - Multas,
	 * [1] - Juros
	 * [2] - Outros Serviços
	 * 
	 * @author isilva
	 * @date 17/11/2010
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitosCobradosPorConta(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		Object[] retorno = new Object[3];
		retorno[0] = BigDecimal.ZERO;
		retorno[1] = BigDecimal.ZERO;
		retorno[2] = BigDecimal.ZERO;

		try{
			consulta.append("select dbcb ");
			consulta.append("from DebitoCobrado dbcb ");
			consulta.append("left join dbcb.debitoTipo dbtp ");
			consulta.append("where dbcb.conta.id = :idConta ");

			Collection<DebitoCobrado> debitoCobradoCollection = new ArrayList<DebitoCobrado>();

			debitoCobradoCollection = (ArrayList<DebitoCobrado>) session.createQuery(consulta.toString())
							.setInteger("idConta", idConta.intValue()).list();

			if(debitoCobradoCollection != null && !debitoCobradoCollection.isEmpty()){
				for(DebitoCobrado debitoCobrado : debitoCobradoCollection){

					if(debitoCobrado.getDebitoTipo().getId().intValue() == DebitoTipo.MULTA_PARA_ATRASO_PAGAMENTO_DO_MES.intValue()
									|| debitoCobrado.getDebitoTipo().getId().intValue() == DebitoTipo.MULTA_NAO_USAR.intValue()
									|| debitoCobrado.getDebitoTipo().getId().intValue() == DebitoTipo.MULTA_IMPONTUALIDADE.intValue()
									|| debitoCobrado.getDebitoTipo().getId().intValue() == DebitoTipo.MULTA_POR_ATRASO_DE_PAGAMENTO
													.intValue()){
						// Multas
						retorno[0] = ((BigDecimal) retorno[0]).add(debitoCobrado.getValorPrestacao());

					}else if(debitoCobrado.getDebitoTipo().getId().intValue() == DebitoTipo.JUROS_SOBRE_PARCELAS_FATURAS_A.intValue()
									|| debitoCobrado.getDebitoTipo().getId().intValue() == DebitoTipo.JUROS_MORA.intValue()){
						// Juros
						retorno[1] = ((BigDecimal) retorno[1]).add(debitoCobrado.getValorPrestacao());
					}else{
						// Outros Serviços
						retorno[2] = ((BigDecimal) retorno[2]).add(debitoCobrado.getValorPrestacao());
					}
				}
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna os SetorComercialVencimento, Ativos ou Inativos;
	 * Ordenados pelo dia de Vencimento.
	 * Não Carrega Localidade, ném SetorComercial
	 * 
	 * @author isilva
	 * @date 21/01/2011
	 * @param idLocalidade
	 * @param idSetorComercial
	 * @param indicadorUso
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<SetorComercialVencimento> pesquisarSetorComercialVencimentoPorLocalidadeSetorComercial(Integer idLocalidade,
					Integer idSetorComercial, Short indicadorUso) throws ErroRepositorioException{

		Collection<SetorComercialVencimento> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();
		Map parameters = new HashMap();
		Query query = null;

		try{

			hql.append("select scv ");
			hql.append("from SetorComercialVencimento scv ");

			if(idLocalidade != null || idSetorComercial != null || indicadorUso != null){
				hql.append("where ");
			}

			if(idLocalidade != null){
				hql.append("scv.localidade.id = :idLocalidade ");
				parameters.put("idLocalidade", idLocalidade);
			}

			if(idSetorComercial != null){
				hql.append("and scv.setorComercial.id = :idSetorComercial ");
				parameters.put("idSetorComercial", idSetorComercial);
			}

			if(indicadorUso != null){
				hql.append("and scv.indicadorUso = :indicadorUso ");
				parameters.put("indicadorUso", indicadorUso);
			}

			hql.append("order by scv.diaVencimento asc");

			query = session.createQuery(hql.toString());

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Integer){
					query.setParameter(key, parameters.get(key));
				}else if(parameters.get(key) instanceof Short){
					query.setParameter(key, parameters.get(key));
				}else if(parameters.get(key) instanceof String){
					query.setParameter(key, parameters.get(key));
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método responsável por retornar a Mensagens de Quitação
	 * 
	 * @author Hebert Falcão
	 * @date 02/05/2011
	 */
	public Object[] pesquisarParmsQuitacaoMensagem(Integer idQuitacaoMensagem) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select qtms.descricaoQuitacaoMensagem01, "); // 0
			consulta.append("       qtms.descricaoQuitacaoMensagem02, "); // 1
			consulta.append("       qtms.descricaoQuitacaoMensagem03 "); // 2
			consulta.append("from QuitacaoMensagem qtms ");
			consulta.append("where qtms.id = :idQuitacaoMensagem ");
			consulta.append("  and qtms.indicadorUso = :indicador ");

			retorno = (Object[]) session.createQuery(consulta.toString()).setInteger("idQuitacaoMensagem", idQuitacaoMensagem)
							.setInteger("indicador", ConstantesSistema.INDICADOR_USO_ATIVO).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Relatório Ordem de Serviço de Substituição de Hidrômetro
	 * Obter dados de até duas contas em revisão
	 * 
	 * @author Anderson Italo
	 * @date 26/05/2011
	 */
	public Collection<DadosContaEmRevisaoHelper> pesquisarDadosContasEmRevisao(Integer idImovel) throws ErroRepositorioException{

		Collection<DadosContaEmRevisaoHelper> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select new gcom.relatorio.ordemservico.DadosContaEmRevisaoHelper(conta.referencia, ");
			consulta.append("conta.dataVencimentoConta, ");
			consulta.append("conta.valorAgua, ");
			consulta.append("conta.valorEsgoto, ");
			consulta.append("conta.debitos, ");
			consulta.append("conta.valorCreditos, ");
			consulta.append("motivoRev.id, ");
			consulta.append("motivoRev.descricaoMotivoRevisaoConta) ");
			consulta.append("from Conta conta ");
			consulta.append("left join conta.contaMotivoRevisao motivoRev ");
			consulta.append("where ");
			consulta.append("conta.dataRevisao is not null and ");
			consulta.append("conta.imovel.id = :idImovel ");
			consulta.append("order by conta.referencia ");

			retorno = (Collection<DadosContaEmRevisaoHelper>) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setMaxResults(2).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0083] Gerar Dados para Leitura
	 * - Atualizar situação do faturamento do imóvel
	 * - Atualizar o ano/mês de faturamento retirada
	 * 
	 * @author Hebert Falcão
	 * @date 28/06/2011
	 */
	public void atualizarImoveisSituacaoEspecialFaturamentoFinalizadaPorGrupo(Integer anoMesFaturamento, Integer idGrupoFaturamento)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuilder hql = new StringBuilder();
			hql.append("select distinct(ftsh.imovel.id) ");
			hql.append("from FaturamentoSituacaoHistorico ftsh ");
			hql.append("inner join ftsh.imovel imov ");
			hql.append("inner join imov.quadra qdra ");
			hql.append("inner join qdra.rota rta ");
			hql.append("where ftsh.anoMesFaturamentoSituacaoFim < :anoMesFaturamento ");
			hql.append("  and ftsh.anoMesFaturamentoRetirada is null ");
			hql.append("  and rta.faturamentoGrupo.id = :idGrupoFaturamento ");
			hql.append("  and imov.faturamentoSituacaoTipo.id is not null ");

			List imoveis = session.createQuery(hql.toString()).setInteger("anoMesFaturamento", anoMesFaturamento)
							.setInteger("idGrupoFaturamento", idGrupoFaturamento).list();

			if(!Util.isVazioOrNulo(imoveis)){
				// Atualiza situação do faturamento do imóvel
				hql = new StringBuilder();
				hql.append("update Imovel imov set imov.faturamentoSituacaoTipo.id = null ");
				hql.append("where imov.id in ( :imoveis ) ");

				session.createQuery(hql.toString()).setParameterList("imoveis", imoveis).executeUpdate();

				// Atualizar o ano/mês de faturamento retirada
				hql = new StringBuilder();
				hql.append("update FaturamentoSituacaoHistorico ftsh set ftsh.anoMesFaturamentoRetirada = :anoMesFaturamento ");
				hql.append("where ftsh.anoMesFaturamentoSituacaoFim < :anoMesFaturamento ");
				hql.append("  and ftsh.anoMesFaturamentoRetirada is null ");
				hql.append("  and ftsh.imovel.id in ( :imoveis ) ");

				session.createQuery(hql.toString()).setInteger("anoMesFaturamento", anoMesFaturamento).setParameterList("imoveis", imoveis)
								.executeUpdate();
			}
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0113 - Faturar Grupo Faturamento] Author: Leonardo Vieira, Rafael
	 * Santos DAta: 17/02/2006 Remove o Resumo Faturamento Simulação
	 * 
	 * @param idFaturamentoGrupo
	 *            Id do Faturamento Grupo
	 * @param anoMesReferencia
	 *            Ano Mes Referencia
	 * @exception ErroRepositorioException
	 *                Erro de Hibernate
	 */
	public void deletarResumoFaturamentoSimulacaoPorColecaoRotas(Integer idFaturamentoGrupo, Integer anoMesReferencia,
					Collection<Integer> idRotas) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete ResumoFaturamentoSimulacao as resumoFaturamentoSimulacao "
							+ "where resumoFaturamentoSimulacao.anoMesReferencia = :anoMesReferencia "
							+ "and resumoFaturamentoSimulacao.faturamentoGrupo.id = :idFaturamentoGrupo "
							+ "and resumoFaturamentoSimulacao.rota.id IN (:idRotas) ";

			if(idRotas != null && idRotas.size() > 1000){

				Collection<Integer> colecaoAuxiliar = new ArrayList<Integer>();

				for(Integer id : idRotas){
					colecaoAuxiliar.add(id);
					if(colecaoAuxiliar.size() == 1000){

						session.createQuery(delete).setInteger("idFaturamentoGrupo", idFaturamentoGrupo.intValue())
										.setInteger("anoMesReferencia", anoMesReferencia.intValue())
										.setParameterList("idRotas", colecaoAuxiliar).executeUpdate();

						colecaoAuxiliar.clear();

					}
				}
				if(!colecaoAuxiliar.isEmpty()){

					session.createQuery(delete).setInteger("idFaturamentoGrupo", idFaturamentoGrupo.intValue())
									.setInteger("anoMesReferencia", anoMesReferencia.intValue())
									.setParameterList("idRotas", colecaoAuxiliar).executeUpdate();

				}
			}else{

				session.createQuery(delete).setInteger("idFaturamentoGrupo", idFaturamentoGrupo.intValue())
								.setInteger("anoMesReferencia", anoMesReferencia.intValue()).setParameterList("idRotas", idRotas)
								.executeUpdate();

			}

	

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * @author
	 * @date 29/06/2011
	 * @param idFaturamentoAtividade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrar(Integer idImovel, Integer anoMesCobrancaDebito) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");
		Query query = null;

		try{
			consulta.append("select ");
			consulta.append("dbac ");
			consulta.append("from ");
			consulta.append("DebitoACobrar dbac  ");
			consulta.append("inner join dbac.debitoTipo dbtp ");
			consulta.append("where ");
			consulta.append("dbac.imovel.id = :idImovel ");
			consulta.append("and dbac.debitoCreditoSituacaoAtual.id = :idDebitoCreditoSituacao ");
			consulta.append("and dbac.numeroPrestacaoCobradas < dbac.numeroPrestacaoDebito ");
			consulta.append("and dbac.anoMesCobrancaDebito <= :anoMesCobrancaDebito ");
			consulta.append("and dbtp.indicadorGeracaoConta = :indicadorGeracaoConta ");

			query = session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL)
							.setInteger("anoMesCobrancaDebito", anoMesCobrancaDebito)
							.setShort("indicadorGeracaoConta", ConstantesSistema.SIM);
			retorno = (Collection<DebitoACobrar>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * 
	 * @author Ailton Sousa
	 * @date 19/08/2011
	 */
	public List pesquisarTodosDebitoTipos() throws ErroRepositorioException{

		List retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select dt.id, dt.descricao from DebitoTipo dt order by dt.id";

			retorno = session.createQuery(consulta).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * Retorna a Descrição da ContaMensagem mais recente de acordo com o AnoMesFaturamento e com o
	 * GrupoFaturamento.
	 */
	public Object[] pesquisarDescricaoContaMensagemMaisRecente(Integer anoMesFaturamento, Integer idFaturamentoGrupo)
					throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			StringBuilder consulta = new StringBuilder();
			consulta.append("select cm.descricaoContaMensagem01, cm.descricaoContaMensagem02, cm.descricaoContaMensagem03 ");
			consulta.append("  from ContaMensagem cm ");
			consulta.append("  where cm.anoMesRreferenciaFaturamento <= :anoMesFaturamento ");

			if(idFaturamentoGrupo != null){
				consulta.append("  and cm.faturamentoGrupo = :idFaturamentoGrupo ");
			}else{
				consulta.append("  and cm.faturamentoGrupo is null ");
			}

			consulta.append("  and cm.indicadorUso = :indicadorUso ");
			consulta.append("  order by cm.anoMesRreferenciaFaturamento desc ");

			Query hql = session.createQuery(consulta.toString());
			hql.setInteger("anoMesFaturamento", anoMesFaturamento);
			if(idFaturamentoGrupo != null){
				hql.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			}
			hql.setShort("indicadorUso", ConstantesSistema.INDICADOR_USO_ATIVO);

			retorno = (Object[]) hql.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * [SB0002] – Obter Dados da Qualidade Água
	 * Retorna a entidade QualidadeAgua de acordo com o AnoMesFaturamento e com a Localidade.
	 * 
	 * @author Ailton Sousa
	 * @date 19/08/2011
	 */
	public QualidadeAgua pesquisarQualidadeAguaPorLocalidadeAnoMesFaturamento(Integer anoMesFaturamento, Integer idLocalidade)
					throws ErroRepositorioException{

		QualidadeAgua retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select qa from QualidadeAgua qa " + "where qa.anoMesReferencia <= :anoMesFaturamento "
							+ "and qa.localidade = :idLocalidade " + "order by qa.anoMesReferencia desc";

			retorno = (QualidadeAgua) session.createQuery(consulta).setInteger("anoMesFaturamento", anoMesFaturamento)
							.setInteger("idLocalidade", idLocalidade).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * Retorna a entidade QualidadeAguaPadrao.
	 * Em conversa com Fátima, ficou esclarecido que essa tabela só vai ter uma linha de dados.
	 * 
	 * @author Ailton Sousa
	 * @date 19/08/2011
	 */
	public QualidadeAguaPadrao retornarQualidadeAguaPadrao() throws ErroRepositorioException{

		QualidadeAguaPadrao retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select qap from QualidadeAguaPadrao qap";

			retorno = (QualidadeAguaPadrao) session.createQuery(consulta).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * Retorna a o Dia de Vencimento do FaturamentoGrupo de acordo com o IdFaturamentoGrupo.
	 * 
	 * @author Ailton Sousa
	 * @date 19/08/2011
	 */
	public Short pesquisarDiaVencimentoPorFaturamentoGrupo(Integer idFaturamentoGrupo) throws ErroRepositorioException{

		Short retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select fg.diaVencimento from FaturamentoGrupo fg " + "where fg.id = :idFaturamentoGrupo ";

			retorno = (Short) session.createQuery(consulta).setInteger("idFaturamentoGrupo", idFaturamentoGrupo).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * Retorna a Maior Data de Vencimento da Conta de FaturamentoAtividadeCronogramaRota.
	 * 
	 * @author Ailton Sousa
	 * @date 19/08/2011
	 */
	public Date retornarMaiorDtContaVencimentoPorRotaIdFaturamentoAnoMesFaturamento(String idsRotas, Integer idFaturamentoGrupo,
					Integer anoMesFaturamento) throws ErroRepositorioException{

		Date retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select facr.dataContaVencimento from FaturamentoAtivCronRota facr "
							+ "where facr.rota.id in ( "
							+ idsRotas
							+ " ) "
							+ "and facr.faturamentoAtividadeCronograma.faturamentoAtividade.id = :idFaturamentoAtividade "
							+ "and facr.faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo.id = :idFaturamentoGrupo "
							+ "and facr.faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.anoMesReferencia = :anoMesFaturamento "
							+ "and facr.dataContaVencimento is not null " + "order by  facr.dataContaVencimento desc";

			retorno = (Date) session.createQuery(consulta).setInteger("idFaturamentoAtividade", FaturamentoAtividade.GERAR_ARQUIVO_LEITURA)
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo).setInteger("anoMesFaturamento", anoMesFaturamento)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer obterMaiorAnoMesReferenciaConsumoHistorico(Integer idImovel) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");

		try{
			consulta.append("select ");
			consulta.append("max(consumoHistorico.referenciaFaturamento)");
			consulta.append("from ");
			consulta.append("ConsumoHistorico consumoHistorico ");
			consulta.append("where consumoHistorico.imovel.id = :idImovel");

			retorno = (Integer) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3037] Filtrar Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 12/03/2012
	 *          Exibir Contas Pré-Faturadas.
	 */
	public Integer obterMaiorAnoMesReferenciaAnteriorMedicaoHistorico(Integer idImovel, Integer anoMesConta)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");

		try{
			consulta.append("select ");
			consulta.append("max(medicaoHistorico.anoMesReferencia) ");
			consulta.append("from ");
			consulta.append("MedicaoHistorico medicaoHistorico ");
			consulta.append("where medicaoHistorico.ligacaoAgua.id = :idImovel ");
			consulta.append("and medicaoHistorico.anoMesReferencia < :anoMesConta ");

			retorno = (Integer) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesConta", anoMesConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3037] Filtrar Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 12/03/2012
	 *          Exibir Contas Pré-Faturadas.
	 */
	public Integer obterMaiorAnoMesReferenciaAnteriorConsumoHistorico(Integer idImovel, Integer anoMesConta)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");

		try{
			consulta.append("select ");
			consulta.append("max(consumoHistorico.referenciaFaturamento)");
			consulta.append("from ");
			consulta.append("ConsumoHistorico consumoHistorico ");
			consulta.append("where consumoHistorico.imovel.id = :idImovel ");
			consulta.append("and consumoHistorico.referenciaFaturamento < :anoMesConta ");

			retorno = (Integer) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesConta", anoMesConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer obterConsumoMedioImovel(Integer idImovel, Integer referencia, Integer idLigacaoTipo) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");

		try{
			consulta.append("select consumoHistorico.consumoMedio ");
			consulta.append("from ");
			consulta.append("ConsumoHistorico consumoHistorico ");
			consulta.append("where consumoHistorico.imovel.id = :idImovel ");
			consulta.append("and consumoHistorico.ligacaoTipo.id = :idLigacaoTipo ");

			if(referencia != null){
				consulta.append("and consumoHistorico.referenciaFaturamento = :referencia ");
				retorno = (Integer) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
								.setInteger("idLigacaoTipo", idLigacaoTipo).setInteger("referencia", referencia).uniqueResult();
			}else{
				retorno = (Integer) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
								.setInteger("idLigacaoTipo", idLigacaoTipo).uniqueResult();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0146][FS0027] Validar motivo da retificação
	 * 
	 * @autor Bruno Ferreira dos Santos
	 * @date 15/08/2011
	 * @param idTipoEspecificacaoSolicitacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer obterQuantidadeRAEncerradaAnoCorrentePorTipoSolicitacaoEspecificacao(Integer idTipoEspecificacaoSolicitacao,
					Integer idImovel) throws ErroRepositorioException{

		Integer retorno;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT count(ra) FROM RegistroAtendimento ra "
							+ " WHERE ra.solicitacaoTipoEspecificacao.id = :idTipoEspecificacaoSolicitacao and ra.dataEncerramento >= :dataInicial "
							+ " and ra.dataEncerramento <= :dataFinal ";

			if(idImovel != null){
				consulta = consulta + " and ra.imovel = :idImovel ";
			}

			Calendar dataCalendar = new GregorianCalendar();

			int ano = dataCalendar.get(Calendar.YEAR);

			Date dataAnoCorrenteInicial = Util.criarData(1, 1, ano);
			Date dataAnoCorrenteFinal = Util.criarData(31, 12, ano);

			if(idImovel != null){
				retorno = ((Number) session.createQuery(consulta)
								.setInteger("idTipoEspecificacaoSolicitacao", idTipoEspecificacaoSolicitacao)
								.setDate("dataInicial", dataAnoCorrenteInicial).setDate("dataFinal", dataAnoCorrenteFinal)
								.setInteger("idImovel", idImovel).uniqueResult()).intValue();
			}else{
				retorno = ((Number) session.createQuery(consulta)
								.setInteger("idTipoEspecificacaoSolicitacao", idTipoEspecificacaoSolicitacao)
								.setDate("dataInicial", dataAnoCorrenteInicial).setDate("dataFinal", dataAnoCorrenteFinal).uniqueResult())
								.intValue();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * Retorna os Dados Dos Grandes Conumidores.
	 * 
	 * @author Ailton Sousa
	 * @date 20/08/2011
	 */
	public Collection obterDadosGrandesConsumidores() throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");
		Query query = null;

		try{
			consulta.append("select cfac ");
			consulta.append("From ");
			consulta.append(" ConsumoFaixaAreaCategoria cfac ");
			consulta.append(" inner join cfac.categoria ");
			consulta.append("order by cfac.categoria.id, cfac.faixaInicialArea ");

			query = session.createQuery(consulta.toString());

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * Retorna os Ids de COnsumoFaixaAreaCategoria de acordo com a categoria recebida.
	 * 
	 * @author Ailton Sousa
	 * @date 22/08/2011
	 */
	public Collection obterIdsConsumoFaixaAreaCategoriaPorCategoria(Integer idCategoria) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");
		Query query = null;

		try{
			consulta.append("select cfac.id ");
			consulta.append("From ");
			consulta.append(" ConsumoFaixaAreaCategoria cfac ");
			consulta.append(" where cfac.categoria.id = :idCategoria ");
			consulta.append("order by cfac.faixaInicialArea ");

			query = session.createQuery(consulta.toString()).setInteger("idCategoria", idCategoria);

			retorno = query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * Obter o maior e o menor ano anterior ao ano de referencia do faturamento, com conta vencida.
	 * 
	 * @author Ailton Sousa
	 * @date 22/08/2011
	 * @param idImovel
	 * @param anoFaturamento
	 * @throws ErroRepositorioException
	 */
	public Object[] obterMaiorMenorAnoAnteriorReferenciaComContaVencida(Integer idImovel, Integer anoFaturamento)
					throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dtVencimentoConta = new Date();
		dtVencimentoConta = Util.subtrairNumeroDiasDeUmaData(dtVencimentoConta, 1);

		try{

			consulta = "SELECT substring(str(max(contaAtual.referencia)), 1, 4), substring(str(min(contaAtual.referencia)), 1, 4) "
							+ "FROM Conta contaAtual " + "WHERE contaAtual.debitoCreditoSituacaoAtual.id IN ( 0,1,2,4 ) "
							+ "AND contaAtual.imovel.id = :idImovel " + "AND contaAtual.dataVencimentoConta < :dtVencimentoConta "
							+ "AND (contaAtual.indicadorPagamento = 2 OR contaAtual.indicadorPagamento IS NULL) "
							+ "AND cast(substring(str(contaAtual.referencia), 1, 4) as int) < :anoFaturamento "
							// + "AND NOT EXISTS ( " + "SELECT pgto.cnta_id FROM pagamento pgto "
							// + "WHERE contaAtual.cnta_id = pgto.cnta_id )"
							// + "GROUP BY contaAtual.referencia "
							+ "ORDER BY contaAtual.referencia ";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setDate("dtVencimentoConta", dtVencimentoConta).setInteger("anoFaturamento", anoFaturamento).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * Obter os Ultimos doze meses anteriores ao ano de referencia do faturamento, com conta
	 * vencida.
	 * 
	 * @author Ailton Sousa
	 * @date 23/08/2011
	 * @param idImovel
	 * @param anoFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection obterUltimosDozeMesesAnterioresReferenciaComContaVencida(Integer idImovel, Integer anoFaturamento)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dtVencimentoConta = new Date();
		dtVencimentoConta = Util.subtrairNumeroDiasDeUmaData(dtVencimentoConta, 1);


		try{

			consulta = "SELECT substring(str(contaAtual.referencia), 5, 6) " + "FROM Conta contaAtual "
							+ "WHERE contaAtual.debitoCreditoSituacaoAtual.id IN ( 0,1,2,4 ) " + "AND contaAtual.imovel.id = :idImovel "
							+ "AND contaAtual.dataVencimentoConta < :dtVencimentoConta "
							+ "AND (contaAtual.indicadorPagamento = 2 OR contaAtual.indicadorPagamento IS NULL) "
							+ "AND cast(substring(str(contaAtual.referencia), 1, 4) as int) = :anoFaturamento "
							// + "AND NOT EXISTS ( " + "SELECT pgto.cnta_id FROM pagamento pgto "
							// + "WHERE contaAtual.cnta_id = pgto.cnta_id )"
							// + "GROUP BY contaAtual.referencia "
							+ "ORDER BY contaAtual.referencia ";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setDate("dtVencimentoConta", dtVencimentoConta).setInteger("anoFaturamento", anoFaturamento).setMaxResults(12)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores
	 * 
	 * @author Péricles Tavares
	 * @date 05/09/2011
	 * @param idImovel
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return Integer
	 * @exception ErroRepositorioException
	 */
	public Integer pesquisarExistenciaGuiaPamentoComSituacaoAtual(int idImovel, int idGuiaPagamento, int numeroPrestacao)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select gp.id FROM GuiaPagamento gp ");
			consulta.append("inner join gp.guiasPagamentoPrestacao gpp ");
			consulta.append("WHERE gp.imovel.id = :idImovel ");
			consulta.append("and gp.id = :idGuiaPagamento ");
			consulta.append("and gpp.comp_id.numeroPrestacao = :numeroPrestacao ");
			consulta.append("and gp.debitoCreditoSituacaoAtual.id in (:colecaoDebitoSituacaoAtual)");

			retorno = (Integer) session
							.createQuery(consulta.toString())
							.setInteger("idImovel", idImovel)
							.setInteger("idGuiaPagamento", idGuiaPagamento)
							.setInteger("numeroPrestacao", numeroPrestacao)
							.setParameterList(
											"colecaoDebitoSituacaoAtual",
							new Object[] {DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.RETIFICADA})
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores
	 * 
	 * @author Péricles Tavares
	 * @date 05/09/2011
	 * @param idImovel
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return Integer
	 * @exception ErroRepositorioException
	 */
	public Integer pesquisarExistenciaGuiaPamentoHistoricoComSituacaoAtual(int idImovel, int idGuiaPagamento, int numeroPrestacao)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select gph.id FROM GuiaPagamentoHistorico gph ");
			consulta.append("inner join gph.guiasPagamentoPrestacaoHistorico gpph ");
			consulta.append("WHERE gph.imovel.id = :idImovel ");
			consulta.append("and gph.id = :idGuiaPagamento ");
			consulta.append("and gpph.comp_id.numeroPrestacao = :numeroPrestacao ");
			consulta.append("and gph.debitoCreditoSituacaoAtual.id in (:colecaoDebitoSituacaoAtual)");

			retorno = (Integer) session
							.createQuery(consulta.toString())
							.setInteger("idImovel", idImovel)
							.setInteger("idGuiaPagamento", idGuiaPagamento)
							.setInteger("numeroPrestacao", numeroPrestacao)
							.setParameterList(
											"colecaoDebitoSituacaoAtual",
											new Object[] {DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.RETIFICADA, DebitoCreditoSituacao.PRESCRITA})
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores
	 * 
	 * @date 06/09/2011
	 * @author Péricles Tavares
	 * @param imovel
	 * @param idGuiaPagamento
	 * @param numeroPrestacao
	 * @return retorna o objeto debito automatico movimento
	 * @throws ErroRepositorioException
	 */
	public DebitoAutomaticoMovimento obterDebitoAutomaticoMovimentoGuiaPagamento(Integer idGuiaPagamento, Integer numeroPrestacao)
					throws ErroRepositorioException{

		DebitoAutomaticoMovimento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT dam " + "FROM DebitoAutomaticoMovimento dam " + "INNER JOIN dam.guiaPagamento gp "
							+ "WHERE  gp.id = :idGuiaPagamento and dam.numeroPrestacao = :numeroPrestacao";

			retorno = (DebitoAutomaticoMovimento) session.createQuery(consulta).setInteger("idGuiaPagamento", idGuiaPagamento)
							.setInteger("numeroPrestacao", numeroPrestacao).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0027] – Gerar Linhas dos Débitos Cobrados
	 * Obtém uma coleção com os débitos cobrados de uma conta
	 * 
	 * @author Anderson Italo
	 * @date 26/08/2011
	 * @param idConta
	 *            , idsFinanciamentoTipo
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoCobrado> buscarDebitosCobradosContaEmissaoTxt(Integer idConta, String idsFinanciamentoTipo)
					throws ErroRepositorioException{

		Collection<DebitoCobrado> retorno = null;
		Collection retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT dbtp.descricao, dbcb.valorPrestacao, parc.id, resDir.id, resDir.descricaoAssunto, ");
			consulta.append("dbcb.numeroPrestacao, dbcb.numeroPrestacaoDebito ");
			consulta.append("FROM DebitoCobrado dbcb ");
			consulta.append("INNER JOIN dbcb.debitoTipo dbtp ");
			consulta.append("LEFT JOIN dbcb.parcelamento parc ");
			consulta.append("LEFT JOIN parc.resolucaoDiretoria resDir ");
			consulta.append("WHERE  dbcb.conta.id = :contaId  and dbtp.financiamentoTipo.id in (");
			consulta.append(idsFinanciamentoTipo);
			consulta.append(") ");
			consulta.append("ORDER BY dbtp.id");

			retornoConsulta = session.createQuery(consulta.toString()).setInteger("contaId", idConta.intValue()).list();

			if(retornoConsulta != null){

				retorno = new ArrayList<DebitoCobrado>();

				for(Iterator iteratorRetorno = retornoConsulta.iterator(); iteratorRetorno.hasNext();){

					Object[] arrayObject = (Object[]) iteratorRetorno.next();
					DebitoCobrado debitoCobrado = new DebitoCobrado();
					DebitoTipo debitoTipo = new DebitoTipo();
					debitoTipo.setDescricao((String) arrayObject[0]);
					debitoCobrado.setValorPrestacao((BigDecimal) arrayObject[1]);
					debitoCobrado.setDebitoTipo(debitoTipo);
					debitoCobrado.setNumeroPrestacao(Util.obterShort(arrayObject[5].toString()));
					debitoCobrado.setNumeroPrestacaoDebito(Util.obterShort(arrayObject[6].toString()));

					if(arrayObject[2] != null){
						Parcelamento parcelamento = new Parcelamento((Integer) arrayObject[2]);

						if(arrayObject[3] != null){
							ResolucaoDiretoria rd = new ResolucaoDiretoria((Integer) arrayObject[3]);

							if(arrayObject[4] != null){
								rd.setDescricaoAssunto((String) arrayObject[4]);
							}

							parcelamento.setResolucaoDiretoria(rd);
						}

						debitoCobrado.setParcelamento(parcelamento);
					}

					retorno.add(debitoCobrado);
				}
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0027] – Gerar Linhas dos Débitos Cobrados
	 * Obtém a soma dos débitos cobrados de parcelamentos de uma conta
	 * 
	 * @author Anderson Italo
	 * @date 26/08/2011
	 * @param idConta
	 *            , idsFinanciamentoTipo
	 * @throws ErroRepositorioException
	 */
	public BigDecimal somarDebitosCobradosContaEmissaoTxt(Integer idConta, String idsFinanciamentoTipo) throws ErroRepositorioException{

		BigDecimal retorno = BigDecimal.valueOf(0);
		Object retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT sum(dbcb.valorPrestacao) FROM DebitoCobrado dbcb ");
			consulta.append("WHERE  dbcb.conta.id = :contaId  and dbcb.debitoTipo.financiamentoTipo.id in (" + idsFinanciamentoTipo + ")");

			retornoConsulta = (Object) session.createQuery(consulta.toString()).setInteger("contaId", idConta.intValue()).uniqueResult();

			if(retornoConsulta != null){

				retorno = (BigDecimal) retornoConsulta;
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0028] – Gerar Linhas dos Créditos Realizados
	 * Obtém uma coleção com os créditos realizados de uma conta
	 * 
	 * @author Anderson Italo
	 * @date 26/08/2011
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public Collection<CreditoRealizado> buscarCreditosRealizadosContaEmissaoTxt(Integer idConta) throws ErroRepositorioException{

		Collection<CreditoRealizado> retorno = null;
		Collection retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT crti.descricao, crre.valorCredito FROM CreditoRealizado crre ");
			consulta.append("INNER JOIN crre.creditoTipo crti ");
			consulta.append("WHERE  crre.conta.id = :contaId ");
			consulta.append("ORDER BY crti.id");

			retornoConsulta = session.createQuery(consulta.toString()).setInteger("contaId", idConta.intValue()).list();

			if(retornoConsulta != null){

				retorno = new ArrayList<CreditoRealizado>();

				for(Iterator iteratorRetorno = retornoConsulta.iterator(); iteratorRetorno.hasNext();){

					Object[] arrayObject = (Object[]) iteratorRetorno.next();
					CreditoRealizado creditoRealizado = new CreditoRealizado();
					CreditoTipo creditoTipo = new CreditoTipo();
					creditoTipo.setDescricao((String) arrayObject[0]);
					creditoRealizado.setValorCredito((BigDecimal) arrayObject[1]);
					creditoRealizado.setCreditoTipo(creditoTipo);

					retorno.add(creditoRealizado);
				}
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * Obtém o fone da localidade ou elo informado como parametro
	 * 
	 * @author Anderson Italo
	 * @date 27/08/2011
	 */
	public String retornarFoneLocalidade(Integer idLocalidade) throws ErroRepositorioException{

		String retorno = "";
		Object retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT loc.fone FROM Localidade loc ");
			consulta.append("WHERE  loc.id = :idLocalidade ");

			retornoConsulta = (Object) session.createQuery(consulta.toString()).setInteger("idLocalidade", idLocalidade.intValue())
							.uniqueResult();

			if(retornoConsulta != null){

				retorno = (String) retornoConsulta;
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0352] Emitir Contas
	 * Obter os Ultimos cinco anos anteriores ao ano de referencia do faturamento, com conta
	 * vencida.
	 * 
	 * @author Anderson Italo
	 * @date 29/08/2011
	 * @param idImovel
	 * @param anoFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection obterUltimosCincoAnosAnterioresReferenciaComContaVencida(Integer idImovel, Integer anoFaturamento)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dtVencimentoConta = new Date();
		dtVencimentoConta = Util.subtrairNumeroDiasDeUmaData(dtVencimentoConta, 1);

		try{

			consulta = "SELECT substring(str(contaAtual.referencia), 1, 4) " + "FROM Conta contaAtual "
							+ "WHERE contaAtual.debitoCreditoSituacaoAtual.id IN ( 0,1,2,4 ) " + "AND contaAtual.imovel.id = :idImovel "
							+ "AND contaAtual.dataVencimentoConta < :dtVencimentoConta " + "AND contaAtual.indicadorPagamento = 2 "
							+ "AND cast(substring(str(contaAtual.referencia), 1, 4) as int) < :anoFaturamento "
							+ "ORDER BY contaAtual.referencia desc";

			retorno = (Collection) session.createQuery(consulta).setInteger("idImovel", idImovel)
							.setDate("dtVencimentoConta", dtVencimentoConta).setInteger("anoFaturamento", anoFaturamento).setMaxResults(5)
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#buscarDebitoCobradoCategoriaPorConta(gcom.faturamento
	 * .conta.Conta)
	 */
	public Collection buscarDebitoCobradoCategoriaHistoricoPorIdConta(Integer idConta) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = " SELECT dbcc FROM DebitoCobradoCategoriaHistorico dbcc " + " INNER JOIN dbcc.debitoCobradoHistorico dbco "
							+ " INNER JOIN dbco.contaHistorico conta " + " WHERE conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

			for(DebitoCobradoCategoriaHistorico debitoCategoriaHistorico : (Collection<DebitoCobradoCategoriaHistorico>) retorno){
				Hibernate.initialize(debitoCategoriaHistorico.getDebitoCobradoHistorico());
				Hibernate.initialize(debitoCategoriaHistorico.getComp_id());
				Hibernate.initialize(debitoCategoriaHistorico.getCategoria());
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection buscarDebitoCobradoCategoriaPorIdConta(Integer idConta) throws ErroRepositorioException{

		Collection<DebitoCobradoCategoria> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = " SELECT dbcc FROM DebitoCobradoCategoria dbcc " + " INNER JOIN dbcc.debitoCobrado dbco "
							+ " INNER JOIN dbco.conta conta " + " WHERE conta.id = :idConta ";

			retorno = session.createQuery(consulta).setInteger("idConta", idConta).list();

			for(DebitoCobradoCategoria debitoCategoria : retorno){
				Hibernate.initialize(debitoCategoria.getDebitoCobrado());
				Hibernate.initialize(debitoCategoria.getComp_id());
				Hibernate.initialize(debitoCategoria.getCategoria());
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Isaac Silva
	 * @date 15/09/2011
	 * @param codigoSetorComercial
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoGrupo> pesquisarFaturamentoGrupoPorCodigoSetorComercialELocalidade(Integer codigoSetorComercial,
					Integer idLocalidade) throws ErroRepositorioException{

		Collection<FaturamentoGrupo> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select distinct(fg) ");
			consulta.append("from ");
			consulta.append("Rota rt ");
			consulta.append("inner join rt.setorComercial sc ");
			consulta.append("inner join sc.localidade loc ");
			consulta.append("left join rt.faturamentoGrupo fg ");
			consulta.append("where ");
			consulta.append("sc.codigo = :codigoSetorComercial ");
			consulta.append("and loc.id = :idLocalidade ");
			consulta.append("and rt.indicadorUso = :indicadorUsoRota ");
			consulta.append("and loc.indicadorUso = :indicadorUsoLocalidade ");
			consulta.append("and sc.indicadorUso = :indicadorUsoSetorComercial ");
			consulta.append("and fg.indicadorUso = :indicadorUsoFaturamentoGrupo ");
			consulta.append("order by fg.descricao ");

			retorno = (Collection<FaturamentoGrupo>) session.createQuery(consulta.toString())
							.setInteger("codigoSetorComercial", codigoSetorComercial).setInteger("idLocalidade", idLocalidade)
							.setShort("indicadorUsoRota", ConstantesSistema.INDICADOR_USO_ATIVO)
							.setShort("indicadorUsoLocalidade", ConstantesSistema.INDICADOR_USO_ATIVO)
							.setShort("indicadorUsoSetorComercial", ConstantesSistema.INDICADOR_USO_ATIVO)
							.setShort("indicadorUsoFaturamentoGrupo", ConstantesSistema.INDICADOR_USO_ATIVO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Verifica se a ROTA informada está em
	 * (SETOR COMERCIAL, FATURAMENTO_GRUPO)
	 * 
	 * @author Isaac Silva
	 * @date 15/09/2011
	 * @param codigoSetorComercial
	 * @param idLocalidade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean existeVinculoRotaSetorComercialFaturamentoGrupo(Quadra quadra) throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select count(fg.id) ");
			consulta.append("from ");
			consulta.append("Rota rt ");
			consulta.append("inner join rt.setorComercial sc ");
			consulta.append("inner join sc.localidade loc ");
			consulta.append("left join rt.faturamentoGrupo fg ");
			consulta.append("where ");
			consulta.append("sc.codigo = :codigoSetorComercial ");
			consulta.append("and loc.id = :idLocalidade ");
			consulta.append("and rt.codigo = :codigoRota ");
			consulta.append("and rt.indicadorUso = :indicadorUsoRota ");
			consulta.append("and loc.indicadorUso = :indicadorUsoLocalidade ");
			consulta.append("and sc.indicadorUso = :indicadorUsoSetorComercial ");
			consulta.append("and fg.indicadorUso = :indicadorUsoFaturamentoGrupo ");

			Long qtd = (Long) session.createQuery(consulta.toString())
							.setInteger("codigoSetorComercial", quadra.getSetorComercial().getCodigo())
							.setShort("codigoRota", quadra.getRota().getCodigo())
							.setInteger("idLocalidade", quadra.getSetorComercial().getLocalidade().getId())
							.setShort("indicadorUsoRota", ConstantesSistema.INDICADOR_USO_ATIVO)
							.setShort("indicadorUsoLocalidade", ConstantesSistema.INDICADOR_USO_ATIVO)
							.setShort("indicadorUsoSetorComercial", ConstantesSistema.INDICADOR_USO_ATIVO)
							.setShort("indicadorUsoFaturamentoGrupo", ConstantesSistema.INDICADOR_USO_ATIVO).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o Objeto FaturamentoGrupo pelo ID pesquisado.
	 * 
	 * @author Ailton Sousa
	 * @date 04/10/2011
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public FaturamentoGrupo pesquisarFaturamentoGrupoPorID(Integer idFaturamentoGrupo) throws ErroRepositorioException{

		FaturamentoGrupo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select fatGrupo from FaturamentoGrupo fatGrupo " + "where fatGrupo.id = :idFaturamentoGrupo ";

			retorno = (FaturamentoGrupo) session.createQuery(consulta).setInteger("idFaturamentoGrupo", idFaturamentoGrupo)
							.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * obtem imovel, localidade e conta atraves do id da conta
	 * 
	 * @author Vivianne Sousa
	 * @date 29/01/2008
	 * @param idConta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Conta obterImovelLocalidadeConta(Integer idConta) throws ErroRepositorioException{

		Conta retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT conta " + "FROM Conta conta " + "INNER JOIN fetch conta.imovel imov "
							+ "INNER JOIN fetch conta.localidade loc " + "WHERE conta.id = :idConta ";

			retorno = (Conta) session.createQuery(consulta).setInteger("idConta", idConta.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * obtem imovel, localidade e contaHistorico atraves do id da conta historico
	 * 
	 * @author Vivianne Sousa
	 * @date 29/01/2008
	 * @param idConta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public ContaHistorico obterImovelLocalidadeContaHistorico(Integer idConta) throws ErroRepositorioException{

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = "SELECT conta " + "FROM ContaHistorico conta " + "INNER JOIN fetch conta.imovel imov "
							+ "INNER JOIN fetch conta.localidade loc " + "WHERE conta.id = :idConta ";

			retorno = (ContaHistorico) session.createQuery(consulta).setInteger("idConta", idConta.intValue()).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public String[] pesquisarDebitoACobrarPorDebitoTipo(Integer idImovel, Integer idDebitoTipo, Integer anoMesReferenciaDebito)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retornoConsulta = null;
		String[] retorno = null;

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select dc.id from DebitoACobrar dc " + "where dc.imovel.id = :idImovel and ");
			consulta.append("dc.debitoTipo.id = :idDebitoTipo and " + "dc.anoMesReferenciaDebito = :anoMesReferenciaDebito and ");
			consulta.append("dc.debitoCreditoSituacaoAtual.id in (:colecaoDebitoSituacaoAtual) ");

			retornoConsulta = session
							.createQuery(consulta.toString())
							.setInteger("idImovel", idImovel)
							.setInteger("idDebitoTipo", idDebitoTipo.intValue())
							.setInteger("anoMesReferenciaDebito", anoMesReferenciaDebito)
							.setParameterList(
							"colecaoDebitoSituacaoAtual",
							new Object[] {DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.RETIFICADA})
							.list();

			if(retornoConsulta != null && !retornoConsulta.isEmpty()){

				retorno = new String[retornoConsulta.size()];
				int i = 0;

				Iterator it = retornoConsulta.iterator();

				while(it.hasNext()){

					Integer idDebitoACobrar = (Integer) it.next();

					retorno[i] = idDebitoACobrar.toString();

					i++;

				}

			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UCXXXX] - Consultar contas para provisão de devedores duvidosos
	 * obtem imovel, localidade e conta atraves do id da conta
	 * 
	 * @author Genival Barbosa
	 * @date 06/12/2011
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection<Conta> consultarContasProvisaoDevedoresDuvidosos() throws ErroRepositorioException{

		Collection<Conta> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		// Utilizando para forçar o batch a gerar os dados para a data determinada
		// Para finalidade emergêncial deve-se retornar ao modelo anterior pegando a data de sistema
		// parâmetro.
		// Date data = new Date();
		// data = Util.criarData(30, 11, 2012);

		Date dataLimite = Util.adicionarNumeroMesDeUmaData(new Date(), -6);

		try{
			consulta = " SELECT conta " + "FROM Conta conta " + " WHERE conta.dataVencimentoConta < :dataLimite "
							+ " AND NOT EXISTS (select pddv.id from ProvisaoDevedoresDuvidosos pddv where pddv.contaGeral.id = conta.id)";
			// // TODO usado para teste
			// + " AND conta.localidade.id = 51";

			retorno = session.createQuery(consulta).setDate("dataLimite", dataLimite).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC3027] Filtrar Guia de Pagamento
	 * 
	 * @author Anderson Italo
	 * @date 27/10/2011
	 */
	public Collection pesquisarRegistrosManterGuiaPagamento(FiltroGuiaPagamentoHelper filtro) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		StringBuffer consulta = new StringBuffer();
		StringBuffer consultaAgrupada = new StringBuffer();
		boolean informouParametro = false;

		try{

			consulta.append("SELECT distinct guiaGeral.id, guia.id, guiaHistorico.id, "); // 0,1,2
			consulta.append("imovelGuia.id, imovelGuiaHistorico.id, "); // 3,4
			consulta.append("(SELECT cliente.id FROM ClienteGuiaPagamento clienteGuiaPagamento ");
			consulta.append("INNER JOIN clienteGuiaPagamento.cliente cliente ");
			consulta.append("where  clienteGuiaPagamento.guiaPagamento.id = guia.id ");
			consulta.append("and clienteGuiaPagamento.clienteRelacaoTipo.id = 3) as idClienteResponsavel, "); // 5
			consulta.append("(SELECT cliente.nome FROM ClienteGuiaPagamento clienteGuiaPagamento ");
			consulta.append("INNER JOIN clienteGuiaPagamento.cliente cliente ");
			consulta.append("where  clienteGuiaPagamento.guiaPagamento.id = guia.id ");
			consulta.append("and clienteGuiaPagamento.clienteRelacaoTipo.id = 3) as nomeClienteResponsavel, "); // 6
			consulta.append("(SELECT cliente.id FROM ClienteGuiaPagamentoHistorico clienteGuiaPagamentoHistorico ");
			consulta.append("INNER JOIN clienteGuiaPagamentoHistorico.cliente cliente where ");
			consulta.append("clienteGuiaPagamentoHistorico.guiaPagamentoHistorico.id = guiaHistorico.id and ");
			consulta.append("clienteGuiaPagamentoHistorico.clienteRelacaoTipo.id = 3) as idClienteResponsavelHistorico, "); // 7
			consulta.append("(SELECT cliente.nome FROM ClienteGuiaPagamentoHistorico clienteGuiaPagamentoHistorico ");
			consulta.append("INNER JOIN clienteGuiaPagamentoHistorico.cliente cliente ");
			consulta.append("where  clienteGuiaPagamentoHistorico.guiaPagamentoHistorico.id = guiaHistorico.id ");
			consulta.append(" and clienteGuiaPagamentoHistorico.clienteRelacaoTipo.id = 3) as nomeClienteResponsavelHistorico, "); // 8
			consulta.append("clienteGuia.id, clienteGuia.nome, "); // 9,10
			consulta.append("clienteGuiaHistorico.id, clienteGuiaHistorico.nome, "); // 11,12
			consulta.append("guia.valorDebito, guiaHistorico.valorDebito, "); // 13, 14
			consulta.append("guia.numeroPrestacaoTotal, guiaHistorico.numeroPrestacaoTotal, "); // 15,16
			consulta.append("guia.numeroContratoParcelOrgaoPublico, guiaHistorico.numeroContratoParcelOrgaoPublico, "); // 17,18
			consulta.append("guia.registroAtendimento.id, guiaHistorico.registroAtendimento.id "); // 19,
																									// 20
			consulta.append("FROM GuiaPagamentoGeral guiaGeral ");
			consulta.append("LEFT JOIN guiaGeral.guiaPagamento guia ");
			consulta.append("LEFT JOIN guiaGeral.guiaPagamentoHistorico guiaHistorico ");
			consulta.append("LEFT JOIN guia.guiasPagamentoPrestacao guiaPrestacao ");
			consulta.append("LEFT JOIN guiaHistorico.guiasPagamentoPrestacaoHistorico guiaPrestacaoHistorico ");
			consulta.append("LEFT JOIN guia.imovel imovelGuia ");
			consulta.append("LEFT JOIN guiaHistorico.imovel imovelGuiaHistorico ");
			consulta.append("LEFT JOIN guia.cliente clienteGuia ");
			consulta.append("LEFT JOIN guiaHistorico.cliente clienteGuiaHistorico ");
			consulta.append("LEFT JOIN guia.clientesGuiaPagamento clienteGuiaPagamento ");
			consulta.append("LEFT JOIN guiaHistorico.clientesGuiaPagamentoHistorico clienteGuiaPagamentoHistorico ");
			consulta.append("WHERE ");

			/*
			 * Número da Guia (selecionar as guias de pagamento para o número informado - a partir
			 * da tabela
			 * GUIA_PAGAMENTO com GPAG_ID=Número da Guia informado e a partir da tabela
			 * GUIA_PAGAMENTO_HISTORICO com GPAG_ID=Número da Guia informado)
			 */
			if(filtro.getIdGuiaPagamento() != null){

				informouParametro = true;
				consulta.append("(guia.id = " + filtro.getIdGuiaPagamento().toString() + " OR ");
				consulta.append("guiaHistorico.id = " + filtro.getIdGuiaPagamento().toString() + ") AND ");
			}

			/*
			 * No. Contrato Parcelamento Órgão Público (selecionar as guias de pagamento para o
			 * No. Contrato Parcelamento Órgão Público informado - a partir da tabela GUIA_PAGAMENTO
			 * com GPAG_NNCONTRATOPARCORGAOPUBLIC=No. Contrato Parcelamento Órgão Público informado
			 * e GUIA_PAGAMENTO_HISTORICO com GPHI_NNCONTRATOPARCORGAOPUBLIC=
			 * No. Contrato Parcelamento Órgão Público informado)
			 */
			else if(filtro.getNumeroContratoParcelOrgaoPublico() != null){

				informouParametro = true;
				consulta.append("(guia.numeroContratoParcelOrgaoPublico = " + filtro.getNumeroContratoParcelOrgaoPublico().toString()
								+ " OR ");
				consulta.append("guiaHistorico.numeroContratoParcelOrgaoPublico = "
								+ filtro.getNumeroContratoParcelOrgaoPublico().toString() + ") AND ");

			}else{

				/*
				 * Cliente da Guia (selecionar as guias de pagamento para o cliente informado - a
				 * partir da tabela GUIA_PAGAMENTO com CLIE_ID=Id do Cliente da Guia
				 * informado/selecionado e a partir da tabela GUIA_PAGAMENTO_HISTORICO com
				 * CLIE_ID=Id do Cliente da Guia informado/selecionado)
				 */
				if(filtro.getCodigoClienteGuia() != null){

					informouParametro = true;
					consulta.append("(clienteGuia.id = " + filtro.getCodigoClienteGuia().toString() + " OR ");
					consulta.append("clienteGuiaHistorico.id = " + filtro.getCodigoClienteGuia().toString() + ") AND ");
				}else{

					/*
					 * Imóvel (selecionar as guias de pagamento para o imóvel informado - a partir
					 * da tabela GUIA_PAGAMENTO com IMOV_ID=Id do Imóvel da Guia
					 * informado/selecionado e GUIA_PAGAMENTO_HISTORICO com IMOV_ID=Id do Imóvel da
					 * Guia informado/selecionado)
					 */
					if(filtro.getIdImovel() != null){

						informouParametro = true;
						consulta.append("(imovelGuia.id = " + filtro.getIdImovel().toString() + " OR ");
						consulta.append("imovelGuiaHistorico.id = " + filtro.getIdImovel().toString() + ") AND ");
					}

					/*
					 * Cliente Responsável (selecionar as guias de pagamento para o cliente
					 * responsável informado - a partir da tabela GUIA_PAGAMENTO com IMOV_ID
					 * diferente de nulo e GPAG_ID=GPAG_ID da tabela CLIENTE_GUIA_PAGAMENTO com
					 * CLIE_ID=Id do Cliente Responsável informado/selecionado e CRTP_ID
					 * correspondente a responsável e a partir da tabela GUIA_PAGAMENTO_HISTORICO
					 * com GPAG_ID=GPAG_ID da tabela CLIENTE_GUIA_PAGAMENTO_HIST com CLIE_ID=Id do
					 * Cliente Responsável informado/selecionado e CRTP_ID correspondente a
					 * responsável)
					 */
					if(filtro.getCodigoClienteResponsavel() != null){

						informouParametro = true;
						consulta.append("imovelGuia.id is not null AND ");
						consulta.append("(clienteGuiaPagamento.cliente.id = ");
						consulta.append(filtro.getCodigoClienteResponsavel().toString() + " OR ");
						consulta.append("clienteGuiaPagamentoHistorico.cliente.id = ");
						consulta.append(filtro.getCodigoClienteResponsavel().toString() + ") AND ");
						consulta.append("(clienteGuiaPagamento.clienteRelacaoTipo.id = ");
						consulta.append(ClienteRelacaoTipo.RESPONSAVEL.toString() + " OR ");
						consulta.append("clienteGuiaPagamentoHistorico.clienteRelacaoTipo.id = ");
						consulta.append(ClienteRelacaoTipo.RESPONSAVEL.toString() + ") AND ");

					}else{

						/*
						 * Tipo da Relação do Cliente com o Imóvel (selecionar as guias de pagamento
						 * com tipo de relação correspondente a algum dos tipos de relação
						 * selecionados - a partir da tabela GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da
						 * tabela CLIENTE_GUIA_PAGAMENTO com CRTP_ID=algum dos CRTP_ID selecionados
						 * e a partir da tabela GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da
						 * tabela CLIENTE_GUIA_PAGAMENTO_HIST com CRTP_ID=algum dos CRTP_ID
						 * selecionados)
						 */
						if(filtro.getIdsClienteRelacaoTipo() != null){

							informouParametro = true;
							consulta.append("(clienteGuiaPagamento.clienteRelacaoTipo.id in ( ");
							consulta.append(filtro.getIdsClienteRelacaoTipo() + ") OR ");
							consulta.append("clienteGuiaPagamentoHistorico.clienteRelacaoTipo.id in ( ");
							consulta.append(filtro.getIdsClienteRelacaoTipo() + ")) AND ");
						}
					}
				}

				/*
				 * Localidade (selecionar as guias de pagamento para a localidade informada - a
				 * partir da tabela GUIA_PAGAMENTO com LOCA_ID=Id da Localidade
				 * informada/selecionada e a partir da tabela GUIA_PAGAMENTO_HISTORICO com
				 * LOCA_ID=Id da Localidade informada/selecionada)
				 */
				if(filtro.getIdLocalidade() != null){

					informouParametro = true;
					consulta.append("(guia.localidade.id = " + filtro.getIdLocalidade().toString() + " OR ");
					consulta.append("guiaHistorico.localidade.id = " + filtro.getIdLocalidade().toString() + ") AND ");
				}

				/*
				 * Período de Referência do Faturamento (selecionar as guias de pagamento com
				 * referência do faturamento no período informado - a partir da tabela
				 * GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da tabela GUIA_PAGAMENTO_PRESTACAO com
				 * GPPR_AMREFERENCIAFATURAMENTO maior ou igual à referência inicial e
				 * GPPR_AMREFERENCIAFATURAMENTO menor ou igual à referência final e a partir da
				 * tabela GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da tabela
				 * GUIA_PAGAMENTO_PRESTACAO_HIST com GPPH_AMREFERENCIAFATURAMENTO maior ou igual à
				 * referência inicial e GPPH_AMREFERENCIAFATURAMENTO menor ou igual à referência
				 * final)
				 */
				if(filtro.getAnoMesReferenciaInicial() > 0 && filtro.getAnoMesReferenciaFinal() > 0){

					informouParametro = true;
					consulta.append("(guiaPrestacao.anoMesReferenciaFaturamento >= " + String.valueOf(filtro.getAnoMesReferenciaInicial()));
					consulta.append(" AND guiaPrestacao.anoMesReferenciaFaturamento <=");
					consulta.append(String.valueOf(filtro.getAnoMesReferenciaFinal()) + ")");
					consulta.append(" OR (guiaPrestacaoHistorico.anoMesReferenciaFaturamento >= ");
					consulta.append(String.valueOf(filtro.getAnoMesReferenciaInicial()));
					consulta.append(" AND guiaPrestacaoHistorico.anoMesReferenciaFaturamento <=");
					consulta.append(String.valueOf(filtro.getAnoMesReferenciaFinal()) + ") AND ");
				}

				/*
				 * Período de Emissão (selecionar as guias de pagamento com data de emissão no
				 * período informado – a partir da tabela GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da
				 * tabela GUIA_PAGAMENTO_PRESTACAO com GPPR_DTEMISSAO maior ou igual à data de
				 * emissão inicial e GPPR_DTEMISSAO menor ou igual à data de emissão final e a
				 * partir da tabela GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da tabela
				 * GUIA_PAGAMENTO_PRESTACAO_HIST com GPPH_DTEMISSAO maior ou igual à data de emissão
				 * inicial e GPPH_DTEMISSAO menor ou igual à data de emissão final)
				 */
				if(filtro.getDataEmissaoInicial() != null && filtro.getDataEmissaoFinal() != null){

					informouParametro = true;
					consulta.append("(guiaPrestacao.dataEmissao between :dataEmissaoInicial AND :dataEmissaoFinal OR ");
					// consulta.append(Util.formatarData(filtro.getDataEmissaoInicial()).toString());
					// consulta.append("' AND '" +
					// Util.formatarData(filtro.getDataEmissaoFinal()).toString() + "' OR ");
					consulta.append("guiaPrestacaoHistorico.dataEmissao between :dataEmissaoInicial AND :dataEmissaoFinal) AND ");
					// consulta.append(Util.formatarData(filtro.getDataEmissaoInicial()).toString()
					// + "' AND '");
					// consulta.append(Util.formatarData(filtro.getDataEmissaoFinal()).toString() +
					// "') AND ");
				}

				/*
				 * Período Vencimento (selecionar as guias de pagamento com data de vencimento no
				 * período informado – a partir da tabela GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da
				 * tabela GUIA_PAGAMENTO_PRESTACAO com GPPR_DTVENCIMENTO maior ou igual à data de
				 * vencimento inicial e GPPR_DTVENCIMENTO menor ou igual à data de vencimento final
				 * e a partir da tabela GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da tabela
				 * GUIA_PAGAMENTO_PRESTACAO_HIST com GPPH_DTVENCIMENTO maior ou igual à data de
				 * vencimento inicial e GPPH_DTVENCIMENTO menor ou igual à data de vencimento final)
				 */
				if(filtro.getDataVencimentoInicial() != null && filtro.getDataVencimentoFinal() != null){
					informouParametro = true;
					consulta.append("(guiaPrestacao.dataVencimento between :dataVencimentoInicial AND :dataVencimentoFinal OR ");
					// consulta.append(Util.formatarData(filtro.getDataVencimentoInicial()).toString());
					// consulta.append("' AND '" +
					// Util.formatarData(filtro.getDataVencimentoFinal()).toString() + "' OR ");
					consulta.append("guiaPrestacaoHistorico.dataVencimento between :dataVencimentoInicial AND :dataVencimentoFinal) AND ");
					// consulta.append(Util.formatarData(filtro.getDataVencimentoInicial()).toString()
					// + "' AND '");
					// consulta.append(Util.formatarData(filtro.getDataVencimentoFinal()).toString()
					// + "') AND ");
				}

				/*
				 * Tipo do Documento (selecionar as guias de pagamento com tipo do documento
				 * correspondente a um dos tipos do documento selecionados - a partir da tabela
				 * GUIA_PAGAMENTO com DOTP_ID=algum dos DOTP_ID selecionados e a partir da tabela
				 * GUIA_PAGAMENTO_HISTORICO com DOTP_ID=algum dos DOTP_ID selecionados)
				 */
				if(filtro.getIdsDocumentoTipo() != null){

					informouParametro = true;
					consulta.append("(guia.documentoTipo.id in ( ");
					consulta.append(filtro.getIdsDocumentoTipo() + ") OR ");
					consulta.append("guiaHistorico.documentoTipo.id in ( ");
					consulta.append(filtro.getIdsDocumentoTipo() + ")) AND ");
				}

				/*
				 * Tipo do Débito (selecionar as guias de pagamento com tipo de débito
				 * correspondente a algum dos tipos de débito selecionados - a partir da tabela
				 * GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da tabela GUIA_PAGAMENTO_PRESTACAO com
				 * DBTP_ID=algum dos DBTP_ID selecionados e a partir da tabela
				 * GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da tabela
				 * GUIA_PAGAMENTO_PRESTACAO_HIST com DBTP_ID=algum dos DBTP_ID selecionados)
				 */
				if(filtro.getIdsDebitoTipo() != null){

					informouParametro = true;
					consulta.append("(guiaPrestacao.debitoTipo.id in ( ");
					consulta.append(filtro.getIdsDebitoTipo() + ") OR ");
					consulta.append("guiaPrestacaoHistorico.debitoTipo.id in ( ");
					consulta.append(filtro.getIdsDebitoTipo() + ")) AND ");
				}
			}

			if(filtro.getNumeroRA() != null){

				informouParametro = true;
				consulta.append("(guia.registroAtendimento.id in ( ");
				consulta.append(filtro.getNumeroRA() + ") OR ");
				consulta.append("guiaHistorico.registroAtendimento.id in ( ");
				consulta.append(filtro.getNumeroRA() + ")) AND ");
			}

			if(informouParametro == false){

				consultaAgrupada.append(consulta.toString().replace("WHERE", ""));
			}else{

				consultaAgrupada.append(consulta.toString().substring(0, consulta.toString().length() - 4));
			}

			consultaAgrupada.append(" ORDER BY 3,4,9,11,1 ");

			if(filtro.getNumeroPagina().intValue() == ConstantesSistema.NUMERO_NAO_INFORMADO){
				Query query = session.createQuery(consultaAgrupada.toString());

				if(filtro.getDataEmissaoInicial() != null && filtro.getDataEmissaoFinal() != null){
					query.setTimestamp("dataEmissaoInicial", Util.formatarDataInicial(filtro.getDataEmissaoInicial()));
					query.setTimestamp("dataEmissaoFinal", Util.formatarDataFinal(filtro.getDataEmissaoFinal()));
				}
				if(filtro.getDataVencimentoInicial() != null && filtro.getDataVencimentoFinal() != null){
					query.setTimestamp("dataVencimentoInicial", Util.formatarDataInicial(filtro.getDataVencimentoInicial()));
					query.setTimestamp("dataVencimentoFinal", Util.formatarDataFinal(filtro.getDataVencimentoFinal()));
				}
				retorno = query.list();
			}else{

				Query query = session.createQuery(consultaAgrupada.toString());

				if(filtro.getDataEmissaoInicial() != null && filtro.getDataEmissaoFinal() != null){
					query.setTimestamp("dataEmissaoInicial", Util.formatarDataInicial(filtro.getDataEmissaoInicial()));
					query.setTimestamp("dataEmissaoFinal", Util.formatarDataFinal(filtro.getDataEmissaoFinal()));
				}
				if(filtro.getDataVencimentoInicial() != null && filtro.getDataVencimentoFinal() != null){
					query.setTimestamp("dataVencimentoInicial", Util.formatarDataInicial(filtro.getDataVencimentoInicial()));
					query.setTimestamp("dataVencimentoFinal", Util.formatarDataFinal(filtro.getDataVencimentoFinal()));
				}
				retorno = query.setFirstResult(10 * filtro.getNumeroPagina()).setMaxResults(10).list();
			}

		}catch(Exception e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3027] Filtrar Guia de Pagamento
	 * Obter total de registros retornados na consulta
	 * 
	 * @author Anderson Italo
	 * @date 27/10/2011
	 */
	public Integer pesquisarTotalRegistrosManterGuiaPagamento(FiltroGuiaPagamentoHelper filtro) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = 0;
		Object retornoConsulta = null;
		StringBuffer consulta = new StringBuffer();
		StringBuffer consultaAgrupada = new StringBuffer();
		boolean informouParametro = false;

		try{

			consulta.append(" SELECT count( distinct guiaGeral.id) ");
			consulta.append("FROM GuiaPagamentoGeral guiaGeral ");
			consulta.append("LEFT JOIN guiaGeral.guiaPagamento guia ");
			consulta.append("LEFT JOIN guiaGeral.guiaPagamentoHistorico guiaHistorico ");
			consulta.append("LEFT JOIN guia.guiasPagamentoPrestacao guiaPrestacao ");
			consulta.append("LEFT JOIN guiaHistorico.guiasPagamentoPrestacaoHistorico guiaPrestacaoHistorico ");
			consulta.append("LEFT JOIN guia.imovel imovelGuia ");
			consulta.append("LEFT JOIN guiaHistorico.imovel imovelGuiaHistorico ");
			consulta.append("LEFT JOIN guia.clientesGuiaPagamento clienteGuiaPagamento ");
			consulta.append("LEFT JOIN guiaHistorico.clientesGuiaPagamentoHistorico clienteGuiaPagamentoHistorico ");
			consulta.append("LEFT JOIN guia.cliente clienteGuia ");
			consulta.append("LEFT JOIN guiaHistorico.cliente clienteGuiaHistorico ");
			consulta.append("WHERE ");

			/*
			 * Número da Guia (selecionar as guias de pagamento para o número informado - a partir
			 * da tabela
			 * GUIA_PAGAMENTO com GPAG_ID=Número da Guia informado e a partir da tabela
			 * GUIA_PAGAMENTO_HISTORICO com GPAG_ID=Número da Guia informado)
			 */
			if(filtro.getIdGuiaPagamento() != null){

				informouParametro = true;
				consulta.append("(guia.id = " + filtro.getIdGuiaPagamento().toString() + " OR ");
				consulta.append("guiaHistorico.id = " + filtro.getIdGuiaPagamento().toString() + ") AND ");
			}

			/*
			 * No. Contrato Parcelamento Órgão Público (selecionar as guias de pagamento para o
			 * No. Contrato Parcelamento Órgão Público informado - a partir da tabela GUIA_PAGAMENTO
			 * com GPAG_NNCONTRATOPARCORGAOPUBLIC=No. Contrato Parcelamento Órgão Público informado
			 * e GUIA_PAGAMENTO_HISTORICO com GPHI_NNCONTRATOPARCORGAOPUBLIC=
			 * No. Contrato Parcelamento Órgão Público informado)
			 */
			else if(filtro.getNumeroContratoParcelOrgaoPublico() != null){

				informouParametro = true;
				consulta.append("(guia.numeroContratoParcelOrgaoPublico = " + filtro.getNumeroContratoParcelOrgaoPublico().toString()
								+ " OR ");
				consulta.append("guiaHistorico.numeroContratoParcelOrgaoPublico = "
								+ filtro.getNumeroContratoParcelOrgaoPublico().toString() + ") AND ");

			}else{

				/*
				 * Cliente da Guia (selecionar as guias de pagamento para o cliente informado - a
				 * partir da tabela GUIA_PAGAMENTO com CLIE_ID=Id do Cliente da Guia
				 * informado/selecionado e a partir da tabela GUIA_PAGAMENTO_HISTORICO com
				 * CLIE_ID=Id do Cliente da Guia informado/selecionado)
				 */
				if(filtro.getCodigoClienteGuia() != null){

					informouParametro = true;
					consulta.append("(clienteGuia.id = " + filtro.getCodigoClienteGuia().toString() + " OR ");
					consulta.append("clienteGuiaHistorico.id = " + filtro.getCodigoClienteGuia().toString() + ") AND ");
				}else{

					/*
					 * Imóvel (selecionar as guias de pagamento para o imóvel informado - a partir
					 * da tabela GUIA_PAGAMENTO com IMOV_ID=Id do Imóvel da Guia
					 * informado/selecionado e GUIA_PAGAMENTO_HISTORICO com IMOV_ID=Id do Imóvel da
					 * Guia informado/selecionado)
					 */
					if(filtro.getIdImovel() != null){

						informouParametro = true;
						consulta.append("(imovelGuia.id = " + filtro.getIdImovel().toString() + " OR ");
						consulta.append("imovelGuiaHistorico.id = " + filtro.getIdImovel().toString() + ") AND ");
					}

					/*
					 * Cliente Responsável (selecionar as guias de pagamento para o cliente
					 * responsável informado - a partir da tabela GUIA_PAGAMENTO com IMOV_ID
					 * diferente de nulo e GPAG_ID=GPAG_ID da tabela CLIENTE_GUIA_PAGAMENTO com
					 * CLIE_ID=Id do Cliente Responsável informado/selecionado e CRTP_ID
					 * correspondente a responsável e a partir da tabela GUIA_PAGAMENTO_HISTORICO
					 * com GPAG_ID=GPAG_ID da tabela CLIENTE_GUIA_PAGAMENTO_HIST com CLIE_ID=Id do
					 * Cliente Responsável informado/selecionado e CRTP_ID correspondente a
					 * responsável)
					 */
					if(filtro.getCodigoClienteResponsavel() != null){

						informouParametro = true;
						consulta.append("imovelGuia.id is not null AND ");
						consulta.append("(clienteGuia.id = ");
						consulta.append(filtro.getCodigoClienteResponsavel().toString() + " OR ");
						consulta.append("clienteGuiaHistorico.id = ");
						consulta.append(filtro.getCodigoClienteResponsavel().toString() + ") AND ");
						consulta.append("(clienteGuiaPagamento.clienteRelacaoTipo.id = ");
						consulta.append(ClienteRelacaoTipo.RESPONSAVEL.toString() + " OR ");
						consulta.append("clienteGuiaPagamentoHistorico.clienteRelacaoTipo.id = ");
						consulta.append(ClienteRelacaoTipo.RESPONSAVEL.toString() + ") AND ");

					}else{

						/*
						 * Tipo da Relação do Cliente com o Imóvel (selecionar as guias de pagamento
						 * com tipo de relação correspondente a algum dos tipos de relação
						 * selecionados - a partir da tabela GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da
						 * tabela CLIENTE_GUIA_PAGAMENTO com CRTP_ID=algum dos CRTP_ID selecionados
						 * e a partir da tabela GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da
						 * tabela CLIENTE_GUIA_PAGAMENTO_HIST com CRTP_ID=algum dos CRTP_ID
						 * selecionados)
						 */
						if(filtro.getIdsClienteRelacaoTipo() != null){

							informouParametro = true;
							consulta.append("(clienteGuiaPagamento.clienteRelacaoTipo.id in ( ");
							consulta.append(filtro.getIdsClienteRelacaoTipo() + ") OR ");
							consulta.append("clienteGuiaPagamentoHistorico.clienteRelacaoTipo.id in ( ");
							consulta.append(filtro.getIdsClienteRelacaoTipo() + ")) AND ");
						}
					}
				}

				/*
				 * Localidade (selecionar as guias de pagamento para a localidade informada - a
				 * partir da tabela GUIA_PAGAMENTO com LOCA_ID=Id da Localidade
				 * informada/selecionada e a partir da tabela GUIA_PAGAMENTO_HISTORICO com
				 * LOCA_ID=Id da Localidade informada/selecionada)
				 */
				if(filtro.getIdLocalidade() != null){

					informouParametro = true;
					consulta.append("(guia.localidade.id = " + filtro.getIdLocalidade().toString() + " OR ");
					consulta.append("guiaHistorico.localidade.id = " + filtro.getIdLocalidade().toString() + ") AND ");
				}

				/*
				 * Período de Referência do Faturamento (selecionar as guias de pagamento com
				 * referência do faturamento no período informado - a partir da tabela
				 * GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da tabela GUIA_PAGAMENTO_PRESTACAO com
				 * GPPR_AMREFERENCIAFATURAMENTO maior ou igual à referência inicial e
				 * GPPR_AMREFERENCIAFATURAMENTO menor ou igual à referência final e a partir da
				 * tabela GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da tabela
				 * GUIA_PAGAMENTO_PRESTACAO_HIST com GPPH_AMREFERENCIAFATURAMENTO maior ou igual à
				 * referência inicial e GPPH_AMREFERENCIAFATURAMENTO menor ou igual à referência
				 * final)
				 */
				if(filtro.getAnoMesReferenciaInicial() > 0 && filtro.getAnoMesReferenciaFinal() > 0){

					informouParametro = true;
					consulta.append("(guiaPrestacao.anoMesReferenciaFaturamento >= " + String.valueOf(filtro.getAnoMesReferenciaInicial()));
					consulta.append(" AND guiaPrestacao.anoMesReferenciaFaturamento <=");
					consulta.append(String.valueOf(filtro.getAnoMesReferenciaFinal()) + ")");
					consulta.append(" OR (guiaPrestacaoHistorico.anoMesReferenciaFaturamento >= ");
					consulta.append(String.valueOf(filtro.getAnoMesReferenciaInicial()));
					consulta.append(" AND guiaPrestacaoHistorico.anoMesReferenciaFaturamento <=");
					consulta.append(String.valueOf(filtro.getAnoMesReferenciaFinal()) + ") AND ");
				}

				/*
				 * Período de Emissão (selecionar as guias de pagamento com data de emissão no
				 * período informado – a partir da tabela GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da
				 * tabela GUIA_PAGAMENTO_PRESTACAO com GPPR_DTEMISSAO maior ou igual à data de
				 * emissão inicial e GPPR_DTEMISSAO menor ou igual à data de emissão final e a
				 * partir da tabela GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da tabela
				 * GUIA_PAGAMENTO_PRESTACAO_HIST com GPPH_DTEMISSAO maior ou igual à data de emissão
				 * inicial e GPPH_DTEMISSAO menor ou igual à data de emissão final)
				 */
				if(filtro.getDataEmissaoInicial() != null && filtro.getDataEmissaoFinal() != null){

					informouParametro = true;
					consulta.append("(guiaPrestacao.dataEmissao between :dataEmissaoInicial AND :dataEmissaoFinal OR ");
//					consulta.append(Util.formatarData(filtro.getDataEmissaoInicial()).toString());
					// consulta.append("' AND '" +
					// Util.formatarData(filtro.getDataEmissaoFinal()).toString() + "' OR ");
					consulta.append("guiaPrestacaoHistorico.dataEmissao between :dataEmissaoInicial AND :dataEmissaoFinal) AND ");
					// consulta.append(Util.formatarData(filtro.getDataEmissaoInicial()).toString()
					// + "' AND '");
					// consulta.append(Util.formatarData(filtro.getDataEmissaoFinal()).toString() +
					// "') AND ");
				}

				/*
				 * Período Vencimento (selecionar as guias de pagamento com data de vencimento no
				 * período informado – a partir da tabela GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da
				 * tabela GUIA_PAGAMENTO_PRESTACAO com GPPR_DTVENCIMENTO maior ou igual à data de
				 * vencimento inicial e GPPR_DTVENCIMENTO menor ou igual à data de vencimento final
				 * e a partir da tabela GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da tabela
				 * GUIA_PAGAMENTO_PRESTACAO_HIST com GPPH_DTVENCIMENTO maior ou igual à data de
				 * vencimento inicial e GPPH_DTVENCIMENTO menor ou igual à data de vencimento final)
				 */
				if(filtro.getDataVencimentoInicial() != null && filtro.getDataVencimentoFinal() != null){
					informouParametro = true;
					consulta.append("(guiaPrestacao.dataVencimento between :dataVencimentoInicial AND :dataVencimentoFinal OR ");
//					consulta.append(Util.formatarData(filtro.getDataVencimentoInicial()).toString());
					// consulta.append("' AND '" +
					// Util.formatarData(filtro.getDataVencimentoFinal()).toString() + "' OR ");
					consulta.append("guiaPrestacaoHistorico.dataVencimento between :dataVencimentoInicial AND :dataVencimentoFinal) AND ");
					// consulta.append(Util.formatarData(filtro.getDataVencimentoInicial()).toString()
					// + "' AND '");
					// consulta.append(Util.formatarData(filtro.getDataVencimentoFinal()).toString()
					// + "') AND ");
				}

				/*
				 * Tipo do Documento (selecionar as guias de pagamento com tipo do documento
				 * correspondente a um dos tipos do documento selecionados - a partir da tabela
				 * GUIA_PAGAMENTO com DOTP_ID=algum dos DOTP_ID selecionados e a partir da tabela
				 * GUIA_PAGAMENTO_HISTORICO com DOTP_ID=algum dos DOTP_ID selecionados)
				 */
				if(filtro.getIdsDocumentoTipo() != null){

					informouParametro = true;
					consulta.append("(guia.documentoTipo.id in ( ");
					consulta.append(filtro.getIdsDocumentoTipo() + ") OR ");
					consulta.append("guiaHistorico.documentoTipo.id in ( ");
					consulta.append(filtro.getIdsDocumentoTipo() + ")) AND ");
				}

				/*
				 * Tipo do Débito (selecionar as guias de pagamento com tipo de débito
				 * correspondente a algum dos tipos de débito selecionados - a partir da tabela
				 * GUIA_PAGAMENTO com GPAG_ID=GPAG_ID da tabela GUIA_PAGAMENTO_PRESTACAO com
				 * DBTP_ID=algum dos DBTP_ID selecionados e a partir da tabela
				 * GUIA_PAGAMENTO_HISTORICO com GPAG_ID=GPAG_ID da tabela
				 * GUIA_PAGAMENTO_PRESTACAO_HIST com DBTP_ID=algum dos DBTP_ID selecionados)
				 */
				if(filtro.getIdsDebitoTipo() != null){

					informouParametro = true;
					consulta.append("(guiaPrestacao.debitoTipo.id in ( ");
					consulta.append(filtro.getIdsDebitoTipo() + ") OR ");
					consulta.append("guiaPrestacaoHistorico.debitoTipo.id in ( ");
					consulta.append(filtro.getIdsDebitoTipo() + ")) AND ");
				}
			}

			if(filtro.getNumeroRA() != null){

				informouParametro = true;
				consulta.append("(guia.registroAtendimento.id in ( ");
				consulta.append(filtro.getNumeroRA() + ") OR ");
				consulta.append("guiaHistorico.registroAtendimento.id in ( ");
				consulta.append(filtro.getNumeroRA() + ")) AND ");
			}

			if(informouParametro == false){

				consultaAgrupada.append(consulta.toString().replace("WHERE", ""));
			}else{

				consultaAgrupada.append(consulta.toString().substring(0, consulta.toString().length() - 4));
			}

			 Query query = session.createQuery(consultaAgrupada.toString());
			
			 if(filtro.getDataEmissaoInicial() != null && filtro.getDataEmissaoFinal() != null){
			 query.setTimestamp("dataEmissaoInicial", Util.formatarDataInicial(filtro.getDataEmissaoInicial()));
			 query.setTimestamp("dataEmissaoFinal", Util.formatarDataFinal(filtro.getDataEmissaoFinal()));
			 }
			 if(filtro.getDataVencimentoInicial() != null && filtro.getDataVencimentoFinal() != null){
			query.setTimestamp("dataVencimentoInicial", Util.formatarDataInicial(filtro.getDataVencimentoInicial()));
			query.setTimestamp("dataVencimentoFinal", Util.formatarDataFinal(filtro.getDataVencimentoFinal()));
			 }
			retornoConsulta = query.setMaxResults(1).uniqueResult();

			if(retornoConsulta != null){

				retorno = ((Number) retornoConsulta).intValue();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0188] Manter Guia de Pagamento
	 * Método que obtém o somatório de PGHI_VLPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * GPAG_ID=GPAG_ID da tabela
	 * GUIA_PAGAMENTO_HISTORICO, caso exista pagamento para a guia
	 * 
	 * @author Anderson Italo
	 * @date 28/10/2011
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterTotalPagamentosPorGuiaPagamento(Integer idGuiaPagamentoGeral) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Object retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("SELECT SUM(pgmt.valorPagamento) ");
			consulta.append("FROM PagamentoHistorico pgmt ");
			consulta.append("WHERE pgmt.guiaPagamentoGeral.id = :idGuiaPagamentoGeral");

			retornoConsulta = (Object) session.createQuery(consulta.toString()).setInteger("idGuiaPagamentoGeral", idGuiaPagamentoGeral)
							.setMaxResults(1).uniqueResult();

			if(retornoConsulta == null){

				retorno = BigDecimal.ZERO;
			}else{

				retorno = (BigDecimal) retornoConsulta;
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0188] Manter Guia de Pagamento
	 * Método que obtém a maior prestação paga da guia (PGHI_NNPRESTACAO) PAGAMENTO_HISTORICO com
	 * GPAG_ID=GPAG_ID da
	 * tabela GUIA_PAGAMENTO_HISTORICO, caso exista pagamento para a guia)
	 * 
	 * @author Anderson Italo
	 * @date 28/10/2011
	 * @throws ErroRepositorioException
	 */
	public List<PagamentoHistorico> obterTotalPrestacoesPagas(Integer idGuiaPagamentoGeral) throws ErroRepositorioException{

		List<PagamentoHistorico> retorno = null;
		Collection retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("FROM PagamentoHistorico pgmt ");
			consulta.append("WHERE pgmt.guiaPagamentoGeral.id = :idGuiaPagamentoGeral ");
			consulta.append("ORDER BY pgmt.numeroPrestacao desc");

			retornoConsulta = session.createQuery(consulta.toString()).setInteger("idGuiaPagamentoGeral", idGuiaPagamentoGeral).list();

			if(retornoConsulta == null){

				retorno = null;
			}else{

				retorno = (List<PagamentoHistorico>) retornoConsulta;
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar Prestações de Guia de Pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * idConsulta = 1 -> [SB0001] Item 3
	 * 2 -> [SB0009] Item 1.2
	 * 
	 * @author Hugo Lima
	 * @date 20/12/2011
	 */
	public Collection<GuiaPagamentoPrestacaoHelper> pesquisarGuiasPagamentoPrestacaoFiltrar(Integer guiaPagamentoId, int idConsulta)
					throws ErroRepositorioException{

		List retorno = null;
		List retorno1 = null;
		List retorno2 = null;
		List retorno3 = null;
		List retorno4 = null;

		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql = new StringBuffer();
			if(idConsulta == ConstantesSistema.CONSULTA_UC0188_SB0001_ITEM_3){

				hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
				hql.append(" gpph.comp_id.numeroPrestacao, ");
				hql.append(" gpph.dataVencimento, ");
				hql.append(" sum(gpph.valorPrestacao), ");
				hql.append(" dt.descricaoDocumentoTipo, ");
				hql.append(" gpph.comp_id.guiaPagamentoId, ");
				hql.append(" gphi.numeroPrestacaoTotal, ");
				hql.append(" gpph.dataEmissao, ");
				hql.append(" gpph.indicadorPagamentoPendente, ");
				hql.append(" gphi.imovel.id, ");
				hql.append(" dcs.descricaoAbreviada, ");
				hql.append(" gphi.numeroContratoParcelOrgaoPublico, ");
				hql.append(" gpph.indicadorCobrancaAdministrativa, ");
				hql.append(" gpph.indicadorExecucaoFiscal, ");
				hql.append(" gpph.indicadorDividaAtiva , ");
				hql.append(" gpph.comp_id.numeroProcessoAdministrativoExecucaoFiscal ) ");
				hql.append(" from GuiaPagamentoHistorico gphi ");
				hql.append(" join gphi.guiasPagamentoPrestacaoHistorico gpph ");
				hql.append(" join gphi.documentoTipo dt ");
				hql.append(" join gpph.debitoCreditoSituacao dcs ");
				hql.append(" where gpph.comp_id.guiaPagamentoId = :guiaPagamentoId ");
				hql.append(" group by  dt.descricaoDocumentoTipo, gpph.comp_id.guiaPagamentoId, ");
				hql.append(" gpph.comp_id.numeroPrestacao, gphi.numeroPrestacaoTotal, ");
				hql.append(" gpph.dataEmissao, gpph.dataVencimento, ");
				hql.append(" gpph.indicadorPagamentoPendente, dcs.descricaoAbreviada, gphi.numeroContratoParcelOrgaoPublico, gphi.imovel.id, "
								+ "gpph.indicadorCobrancaAdministrativa, gpph.indicadorExecucaoFiscal, gpph.indicadorDividaAtiva, gpph.comp_id.numeroProcessoAdministrativoExecucaoFiscal  ");

			}else if(idConsulta == ConstantesSistema.CONSULTA_UC0188_SB0009_ITEM_1_2){

				hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
				hql.append(" gpph.comp_id.numeroPrestacao, ");
				hql.append(" gpph.dataVencimento, ");
				hql.append(" sum(gpph.valorPrestacao))");
				hql.append(" from GuiaPagamentoHistorico gphi ");
				hql.append(" join gphi.guiasPagamentoPrestacaoHistorico gpph ");
				hql.append(" where gpph.comp_id.guiaPagamentoId = :guiaPagamentoId ");
				hql.append(" group by  gpph.comp_id.numeroPrestacao, gpph.dataVencimento ");
				hql.append(" order by  gpph.comp_id.numeroPrestacao ");

			}

			retorno1 = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();
			// Insere o indicador informando que as prestaçãos são oriundas do histórico
			this.inserirIndicadorHistoricoPrestacaoHelper(retorno1);

			hql = new StringBuffer();
			if(idConsulta == ConstantesSistema.CONSULTA_UC0188_SB0001_ITEM_3){
				hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
				hql.append(" gpph.comp_id.numeroPrestacao, ");
				hql.append(" gpph.dataVencimento, ");
				hql.append(" sum(gpph.valorPrestacao), ");
				hql.append(" dt.descricaoDocumentoTipo, ");
				hql.append(" gpph.comp_id.guiaPagamentoId, ");
				hql.append(" gpag.numeroPrestacaoTotal, ");
				hql.append(" gpph.dataEmissao, ");
				hql.append(" gpph.indicadorPagamentoPendente, ");
				hql.append(" gpag.imovel.id, ");
				hql.append(" dcs.descricaoAbreviada, ");
				hql.append(" gpag.numeroContratoParcelOrgaoPublico, ");
				hql.append(" gpph.indicadorCobrancaAdministrativa, ");
				hql.append(" gpph.indicadorExecucaoFiscal , ");
				hql.append(" gpph.indicadorDividaAtiva, ");
				hql.append(" gpph.comp_id.numeroProcessoAdministrativoExecucaoFiscal ) ");
				hql.append(" from GuiaPagamento gpag ");
				hql.append(" join gpag.guiasPagamentoPrestacaoHistorico gpph ");
				hql.append(" join gpag.documentoTipo dt ");
				hql.append(" join gpph.debitoCreditoSituacao dcs ");
				hql.append(" where gpph.comp_id.guiaPagamentoId = :guiaPagamentoId ");
				hql.append(" group by  dt.descricaoDocumentoTipo, gpph.comp_id.guiaPagamentoId, ");
				hql.append(" gpph.comp_id.numeroPrestacao, gpag.numeroPrestacaoTotal, ");
				hql.append(" gpph.dataEmissao, gpph.dataVencimento, ");
				hql.append(" gpph.indicadorPagamentoPendente, dcs.descricaoAbreviada, gpag.imovel.id, gpag.numeroContratoParcelOrgaoPublico,"
								+ " gpph.indicadorCobrancaAdministrativa, gpph.indicadorExecucaoFiscal, gpph.indicadorDividaAtiva, gpph.comp_id.numeroProcessoAdministrativoExecucaoFiscal  ");

			}else if(idConsulta == ConstantesSistema.CONSULTA_UC0188_SB0009_ITEM_1_2){

				hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
				hql.append(" gpph.comp_id.numeroPrestacao, ");
				hql.append(" gpph.dataVencimento, ");
				hql.append(" sum(gpph.valorPrestacao))");
				hql.append(" from GuiaPagamento gpag ");
				hql.append(" join gpag.guiasPagamentoPrestacaoHistorico gpph ");
				hql.append(" where gpph.comp_id.guiaPagamentoId = :guiaPagamentoId ");
				hql.append(" group by  gpph.comp_id.numeroPrestacao, gpph.dataVencimento ");
				hql.append(" order by  gpph.comp_id.numeroPrestacao ");

			}

			retorno2 = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();
			// Insere o indicador informando que as prestaçãos são oriundas do histórico
			this.inserirIndicadorHistoricoPrestacaoHelper(retorno2);

			hql = new StringBuffer();
			if(idConsulta == ConstantesSistema.CONSULTA_UC0188_SB0001_ITEM_3){
				hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
				hql.append(" gppr.comp_id.numeroPrestacao, ");
				hql.append(" gppr.dataVencimento, ");
				hql.append(" sum(gppr.valorPrestacao), ");
				hql.append(" dt.descricaoDocumentoTipo, ");
				hql.append(" gppr.comp_id.guiaPagamentoId, ");
				hql.append(" gphi.numeroPrestacaoTotal, ");
				hql.append(" gppr.dataEmissao, ");
				hql.append(" gppr.indicadorPagamentoPendente, ");
				hql.append(" gphi.imovel.id, ");
				hql.append(" dcs.descricaoAbreviada, ");
				hql.append(" gphi.numeroContratoParcelOrgaoPublico, ");
				hql.append(" gppr.indicadorCobrancaAdministrativa, ");
				hql.append(" gppr.indicadorExecucaoFiscal, ");
				hql.append(" gppr.indicadorDividaAtiva, ");
				hql.append(" gppr.comp_id.numeroProcessoAdministrativoExecucaoFiscal ) ");
				hql.append(" from GuiaPagamentoHistorico gphi ");
				hql.append(" join gphi.guiasPagamentoPrestacao gppr ");
				hql.append(" join gphi.documentoTipo dt ");
				hql.append(" join gppr.debitoCreditoSituacao dcs ");
				hql.append(" where gppr.comp_id.guiaPagamentoId = :guiaPagamentoId ");
				hql.append(" group by  dt.descricaoDocumentoTipo, gppr.comp_id.guiaPagamentoId, ");
				hql.append(" gppr.comp_id.numeroPrestacao, gphi.numeroPrestacaoTotal, ");
				hql.append(" gppr.dataEmissao, gppr.dataVencimento, ");
				hql.append(" gppr.indicadorPagamentoPendente, dcs.descricaoAbreviada, gphi.imovel.id, gphi.numeroContratoParcelOrgaoPublico, "
								+ "gppr.indicadorCobrancaAdministrativa, gppr.indicadorExecucaoFiscal, gppr.indicadorDividaAtiva, gppr.comp_id.numeroProcessoAdministrativoExecucaoFiscal  ");

			}else if(idConsulta == ConstantesSistema.CONSULTA_UC0188_SB0009_ITEM_1_2){

				hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
				hql.append(" gppr.comp_id.numeroPrestacao, ");
				hql.append(" gppr.dataVencimento, ");
				hql.append(" sum(gppr.valorPrestacao))");
				hql.append(" from GuiaPagamentoHistorico gphi ");
				hql.append(" join gphi.guiasPagamentoPrestacao gppr ");
				hql.append(" where gppr.comp_id.guiaPagamentoId = :guiaPagamentoId ");
				hql.append(" group by  gppr.comp_id.numeroPrestacao, gppr.dataVencimento ");
				hql.append(" order by  gppr.comp_id.numeroPrestacao ");

			}

			retorno3 = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();

			hql = new StringBuffer();
			if(idConsulta == ConstantesSistema.CONSULTA_UC0188_SB0001_ITEM_3){
				hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
				hql.append(" gppr.comp_id.numeroPrestacao, ");
				hql.append(" gppr.dataVencimento, ");
				hql.append(" sum(gppr.valorPrestacao), ");
				hql.append(" dt.descricaoDocumentoTipo, ");
				hql.append(" gppr.comp_id.guiaPagamentoId, ");
				hql.append(" gpag.numeroPrestacaoTotal, ");
				hql.append(" gppr.dataEmissao, ");
				hql.append(" gppr.indicadorPagamentoPendente, ");
				hql.append(" gpag.imovel.id, ");
				hql.append(" dcs.descricaoAbreviada, ");
				hql.append(" gpag.numeroContratoParcelOrgaoPublico, ");
				hql.append(" gppr.indicadorCobrancaAdministrativa, ");
				hql.append(" gppr.indicadorExecucaoFiscal, ");
				hql.append(" gppr.indicadorDividaAtiva, ");
				hql.append(" gppr.comp_id.numeroProcessoAdministrativoExecucaoFiscal ) ");
				hql.append(" from GuiaPagamento gpag ");
				hql.append(" join gpag.guiasPagamentoPrestacao gppr ");
				hql.append(" join gpag.documentoTipo dt ");
				hql.append(" join gppr.debitoCreditoSituacao dcs ");
				hql.append(" where gppr.comp_id.guiaPagamentoId = :guiaPagamentoId ");
				hql.append(" group by  dt.descricaoDocumentoTipo, gppr.comp_id.guiaPagamentoId, ");
				hql.append(" gppr.comp_id.numeroPrestacao, gpag.numeroPrestacaoTotal, ");
				hql.append(" gppr.dataEmissao, gppr.dataVencimento, ");
				hql.append(" gppr.indicadorPagamentoPendente, dcs.descricaoAbreviada, gpag.imovel.id, gpag.numeroContratoParcelOrgaoPublico,"
								+ " gppr.indicadorCobrancaAdministrativa, gppr.indicadorExecucaoFiscal, gppr.indicadorDividaAtiva, gppr.comp_id.numeroProcessoAdministrativoExecucaoFiscal  ");

			}else if(idConsulta == ConstantesSistema.CONSULTA_UC0188_SB0009_ITEM_1_2){

				hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
				hql.append(" gppr.comp_id.numeroPrestacao, ");
				hql.append(" gppr.dataVencimento, ");
				hql.append(" sum(gppr.valorPrestacao))");
				hql.append(" from GuiaPagamento gpag ");
				hql.append(" join gpag.guiasPagamentoPrestacao gppr ");
				hql.append(" where gppr.comp_id.guiaPagamentoId = :guiaPagamentoId ");
				hql.append(" group by  gppr.comp_id.numeroPrestacao, gppr.dataVencimento ");
				hql.append(" order by  gppr.comp_id.numeroPrestacao ");

			}

			retorno4 = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();

			// Union
			retorno = retorno1;
			retorno.addAll(retorno2);
			retorno.addAll(retorno3);
			retorno.addAll(retorno4);

			Collections.sort(retorno, new Comparator() {

				public int compare(Object o1, Object o2){

					GuiaPagamentoPrestacaoHelper cd1 = (GuiaPagamentoPrestacaoHelper) o1;
					GuiaPagamentoPrestacaoHelper cd2 = (GuiaPagamentoPrestacaoHelper) o2;
					return cd1.getNumeroPrestacao().compareTo(cd2.getNumeroPrestacao());
				}
			});
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar Prestações de Guia de Pagamento
	 * 
	 * @author Gicevalter Couto
	 * @date 29/01/2015
	 */
	public Collection<GuiaPagamentoPrestacaoHelper> pesquisarGuiasPagamentoPrestacaoPorParcelamento(Integer parcelamentoId)
					throws ErroRepositorioException{

		List retorno = null;
		List retorno1 = null;
		List retorno2 = null;
		List retorno3 = null;
		List retorno4 = null;

		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql = new StringBuffer();
			hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
			hql.append(" gpph.comp_id.guiaPagamentoId, ");
			hql.append(" gpph.comp_id.numeroPrestacao, ");
			hql.append(" gpph.dataVencimento, ");
			hql.append(" sum(gpph.valorPrestacao))");
			hql.append(" from ParcelamentoItem parcItem ");
			hql.append(" join parcItem.guiaPagamentoGeral gpg ");
			hql.append(" join gpg.guiaPagamentoHistorico gphi ");
			hql.append(" join gphi.guiasPagamentoPrestacaoHistorico gpph ");
			hql.append("where gpph.comp_id.guiaPagamentoId = parcItem.guiaPagamentoGeral.id ");
			hql.append("  and gpph.comp_id.numeroPrestacao = parcItem.numeroPrestacao ");
			hql.append(" and parcItem.parcelamento.id = :parcelamentoId ");
			hql.append(" group by  gpph.comp_id.guiaPagamentoId, gpph.comp_id.numeroPrestacao, gpph.dataVencimento ");
			hql.append(" order by  gpph.comp_id.guiaPagamentoId, gpph.comp_id.numeroPrestacao ");

			Query qryGuiaPagamento = session.createQuery(hql.toString());
			qryGuiaPagamento.setInteger("parcelamentoId", parcelamentoId);

			retorno1 = qryGuiaPagamento.list();

			hql = new StringBuffer();
			hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
			hql.append(" gpph.comp_id.guiaPagamentoId, ");
			hql.append(" gpph.comp_id.numeroPrestacao, ");
			hql.append(" gpph.dataVencimento, ");
			hql.append(" sum(gpph.valorPrestacao))");
			hql.append(" from ParcelamentoItem parcItem ");
			hql.append(" join parcItem.guiaPagamentoGeral gpg ");
			hql.append(" join gpg.guiaPagamento gpag ");
			hql.append(" join gpag.guiasPagamentoPrestacaoHistorico gpph ");
			hql.append("where gpph.comp_id.guiaPagamentoId = parcItem.guiaPagamentoGeral.id ");
			hql.append("  and gpph.comp_id.numeroPrestacao = parcItem.numeroPrestacao ");
			hql.append("  and parcItem.parcelamento.id = :parcelamentoId ");
			hql.append(" group by  gpph.comp_id.guiaPagamentoId, gpph.comp_id.numeroPrestacao, gpph.dataVencimento ");
			hql.append(" order by  gpph.comp_id.guiaPagamentoId, gpph.comp_id.numeroPrestacao ");

			qryGuiaPagamento = session.createQuery(hql.toString());
			qryGuiaPagamento.setInteger("parcelamentoId", parcelamentoId);

			retorno2 = qryGuiaPagamento.list();

			hql = new StringBuffer();
			hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
			hql.append(" gppr.comp_id.guiaPagamentoId, ");
			hql.append(" gppr.comp_id.numeroPrestacao, ");
			hql.append(" gppr.dataVencimento, ");
			hql.append(" sum(gppr.valorPrestacao))");
			hql.append(" from ParcelamentoItem parcItem ");
			hql.append(" join parcItem.guiaPagamentoGeral gpg ");
			hql.append(" join gpg.guiaPagamentoHistorico gphi ");
			hql.append(" join gphi.guiasPagamentoPrestacao gppr ");
			hql.append("where gppr.comp_id.guiaPagamentoId = parcItem.guiaPagamentoGeral.id ");
			hql.append("  and gppr.comp_id.numeroPrestacao = parcItem.numeroPrestacao ");
			hql.append("  and parcItem.parcelamento.id = :parcelamentoId ");
			hql.append(" group by  gppr.comp_id.guiaPagamentoId, gppr.comp_id.numeroPrestacao, gppr.dataVencimento ");
			hql.append(" order by  gppr.comp_id.guiaPagamentoId, gppr.comp_id.numeroPrestacao ");

			qryGuiaPagamento = session.createQuery(hql.toString());
			qryGuiaPagamento.setInteger("parcelamentoId", parcelamentoId);

			retorno3 = qryGuiaPagamento.list();

			hql = new StringBuffer();
			hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
			hql.append(" gppr.comp_id.guiaPagamentoId, ");
			hql.append(" gppr.comp_id.numeroPrestacao, ");
			hql.append(" gppr.dataVencimento, ");
			hql.append(" sum(gppr.valorPrestacao))");
			hql.append(" from ParcelamentoItem parcItem ");
			hql.append(" join parcItem.guiaPagamentoGeral gpg ");
			hql.append(" join gpg.guiaPagamento gpag ");
			hql.append(" join gpag.guiasPagamentoPrestacao gppr ");
			hql.append("where gppr.comp_id.guiaPagamentoId = parcItem.guiaPagamentoGeral.id ");
			hql.append("  and gppr.comp_id.numeroPrestacao = parcItem.numeroPrestacao ");
			hql.append("  and parcItem.parcelamento.id = :parcelamentoId ");
			hql.append(" group by  gppr.comp_id.guiaPagamentoId, gppr.comp_id.numeroPrestacao, gppr.dataVencimento ");
			hql.append(" order by  gppr.comp_id.guiaPagamentoId, gppr.comp_id.numeroPrestacao ");

			qryGuiaPagamento = session.createQuery(hql.toString());
			qryGuiaPagamento.setInteger("parcelamentoId", parcelamentoId);

			retorno4 = qryGuiaPagamento.list();

			// Union
			retorno = retorno1;
			retorno.addAll(retorno2);
			retorno.addAll(retorno3);
			retorno.addAll(retorno4);

			Collections.sort(retorno, new Comparator() {

				public int compare(Object o1, Object o2){

					GuiaPagamentoPrestacaoHelper cd1 = (GuiaPagamentoPrestacaoHelper) o1;
					GuiaPagamentoPrestacaoHelper cd2 = (GuiaPagamentoPrestacaoHelper) o2;
					return cd1.getIdGuiaPagamento().compareTo(cd2.getIdGuiaPagamento());
				}
			});

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar Prestações de Guia de Pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 05/01/2012
	 */
	public Collection<GuiaPagamentoPrestacaoHelper> pesquisarGuiasPagamentoPrestacaoRelatorio(Integer guiaPagamentoId)
					throws ErroRepositorioException{

		List retorno = null;
		List retorno1 = null;
		List retorno2 = null;
		List retorno3 = null;
		List retorno4 = null;

		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{

			hql = new StringBuffer();
			hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
			hql.append(" dt.descricaoDocumentoTipo, ");
			hql.append(" gpph.comp_id.guiaPagamentoId, ");
			hql.append(" gpph.comp_id.numeroPrestacao, ");
			hql.append(" gphi.numeroPrestacaoTotal, ");
			hql.append(" gpph.valorPrestacao, ");
			hql.append(" gpph.dataEmissao, ");
			hql.append(" gpph.dataVencimento, ");
			hql.append(" gpph.indicadorPagamentoPendente, ");
			hql.append(" dbttp.id, ");
			hql.append(" dbttp.descricao, ");
			hql.append(" dcs.descricaoAbreviada, ");
			hql.append(" gpph.indicadorDividaAtiva, ");
			hql.append(" gpph.indicadorExecucaoFiscal, ");
			hql.append(" gpph.comp_id.numeroProcessoAdministrativoExecucaoFiscal) ");
			hql.append(" from GuiaPagamentoHistorico gphi ");
			hql.append(" join gphi.guiasPagamentoPrestacaoHistorico gpph ");
			hql.append(" join gphi.documentoTipo dt ");
			hql.append(" join gpph.debitoTipo dbttp ");
			hql.append(" join gpph.debitoCreditoSituacao dcs ");
			hql.append(" where gpph.comp_id.guiaPagamentoId = :guiaPagamentoId ");
			hql.append(" order by  gpph.comp_id.guiaPagamentoId, gpph.comp_id.numeroPrestacao ");

			retorno1 = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();

			hql = new StringBuffer();
			hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
			hql.append(" dt.descricaoDocumentoTipo, ");
			hql.append(" gpph.comp_id.guiaPagamentoId, ");
			hql.append(" gpph.comp_id.numeroPrestacao, ");
			hql.append(" gpag.numeroPrestacaoTotal, ");
			hql.append(" gpph.valorPrestacao, ");
			hql.append(" gpph.dataEmissao, ");
			hql.append(" gpph.dataVencimento, ");
			hql.append(" gpph.indicadorPagamentoPendente, ");
			hql.append(" dbttp.id, ");
			hql.append(" dbttp.descricao, ");
			hql.append(" dcs.descricaoAbreviada, ");
			hql.append(" gpph.indicadorDividaAtiva, ");
			hql.append(" gpph.indicadorExecucaoFiscal, ");
			hql.append(" gpph.comp_id.numeroProcessoAdministrativoExecucaoFiscal) ");
			hql.append(" from GuiaPagamento gpag ");
			hql.append(" join gpag.guiasPagamentoPrestacaoHistorico gpph ");
			hql.append(" join gpag.documentoTipo dt ");
			hql.append(" join gpph.debitoTipo dbttp ");
			hql.append(" join gpph.debitoCreditoSituacao dcs ");
			hql.append(" where gpph.comp_id.guiaPagamentoId = :guiaPagamentoId ");
			hql.append(" order by  gpph.comp_id.guiaPagamentoId, gpph.comp_id.numeroPrestacao ");

			retorno2 = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();

			hql = new StringBuffer();
			hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
			hql.append(" dt.descricaoDocumentoTipo, ");
			hql.append(" gppr.comp_id.guiaPagamentoId, ");
			hql.append(" gppr.comp_id.numeroPrestacao, ");
			hql.append(" gphi.numeroPrestacaoTotal, ");
			hql.append(" gppr.valorPrestacao, ");
			hql.append(" gppr.dataEmissao, ");
			hql.append(" gppr.dataVencimento, ");
			hql.append(" gppr.indicadorPagamentoPendente, ");
			hql.append(" dbttp.id, ");
			hql.append(" dbttp.descricao, ");
			hql.append(" dcs.descricaoAbreviada, ");
			hql.append(" gppr.indicadorDividaAtiva, ");
			hql.append(" gppr.indicadorExecucaoFiscal, ");
			hql.append(" gppr.comp_id.numeroProcessoAdministrativoExecucaoFiscal) ");
			hql.append(" from GuiaPagamentoHistorico gphi ");
			hql.append(" join gphi.guiasPagamentoPrestacao gppr ");
			hql.append(" join gphi.documentoTipo dt ");
			hql.append(" join gppr.debitoTipo dbttp ");
			hql.append(" join gppr.debitoCreditoSituacao dcs ");
			hql.append(" where gppr.comp_id.guiaPagamentoId = :guiaPagamentoId ");
			hql.append(" order by gppr.comp_id.guiaPagamentoId, gppr.comp_id.numeroPrestacao ");

			retorno3 = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();

			hql = new StringBuffer();
			hql.append(" select new " + GuiaPagamentoPrestacaoHelper.class.getName() + "(");
			hql.append(" dt.descricaoDocumentoTipo, ");
			hql.append(" gppr.comp_id.guiaPagamentoId, ");
			hql.append(" gppr.comp_id.numeroPrestacao, ");
			hql.append(" gpag.numeroPrestacaoTotal, ");
			hql.append(" gppr.valorPrestacao, ");
			hql.append(" gppr.dataEmissao, ");
			hql.append(" gppr.dataVencimento, ");
			hql.append(" gppr.indicadorPagamentoPendente, ");
			hql.append(" dbttp.id, ");
			hql.append(" dbttp.descricao, ");
			hql.append(" dcs.descricaoAbreviada, ");
			hql.append(" gppr.indicadorDividaAtiva, ");
			hql.append(" gppr.indicadorExecucaoFiscal, ");
			hql.append(" gppr.comp_id.numeroProcessoAdministrativoExecucaoFiscal) ");
			hql.append(" from GuiaPagamento gpag ");
			hql.append(" join gpag.guiasPagamentoPrestacao gppr ");
			hql.append(" join gpag.documentoTipo dt ");
			hql.append(" join gppr.debitoTipo dbttp ");
			hql.append(" join gppr.debitoCreditoSituacao dcs ");
			hql.append(" where gppr.comp_id.guiaPagamentoId = :guiaPagamentoId ");
			hql.append(" order by gppr.comp_id.guiaPagamentoId, gppr.comp_id.numeroPrestacao ");

			retorno4 = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();

			// Union
			retorno = retorno1;
			retorno.addAll(retorno2);
			retorno.addAll(retorno3);
			retorno.addAll(retorno4);

			Collections.sort(retorno, new Comparator() {

				public int compare(Object o1, Object o2){

					GuiaPagamentoPrestacaoHelper cd1 = (GuiaPagamentoPrestacaoHelper) o1;
					GuiaPagamentoPrestacaoHelper cd2 = (GuiaPagamentoPrestacaoHelper) o2;
					return cd1.getId().compareTo(cd2.getId());
				}
			});
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seta uma coleção de GuiaPagamentoPrestacaoHelper com indicadores de ocorrência vinda do
	 * histórico
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 05/01/2012
	 */
	private void inserirIndicadorHistoricoPrestacaoHelper(List<GuiaPagamentoPrestacaoHelper> lista){

		if(!Util.isVazioOrNulo(lista)){
			for(GuiaPagamentoPrestacaoHelper guiaPagamentoPrestacaoHelper : lista){
				guiaPagamentoPrestacaoHelper.setIdOcorrenciaHistorico(ConstantesSistema.SIM);
			}
		}
	}

	/**
	 * Pesquisar tipos de financiamento de débitos que não permitam o cancelamento de uma guia de
	 * pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 02/01/2012
	 */
	public Collection<String> pesquisarTipoFinanciamentoDebitoNaoPermiteCancelarGuiaPagamento(Integer guiaPagamentoId)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append(" select ft.descricao ");
			hql.append(" from GuiaPagamentoPrestacao gpp ");
			hql.append(" inner join gpp.guiaPagamento gp ");
			hql.append(" inner join gpp.debitoTipo dt ");
			hql.append(" inner join dt.financiamentoTipo ft ");
			hql.append(" where gpp.comp_id.guiaPagamentoId = :guiaPagamentoId ");
			hql.append(" and ft.indicadorCancelaDebito = " + ConstantesSistema.NAO);

			retorno = session.createQuery(hql.toString()).setInteger("guiaPagamentoId", guiaPagamentoId).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar parcelamentos de cobranca bancarias correspondentes a uma guia de pagamento
	 * pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 02/01/2012
	 */
	public Collection<String> pesquisarBoletoEmissaoGuiaPagamento(Integer guiaPagamentoId) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select bb.cbdo_id as idConta from boleto_bancario bb ");
			consulta.append("inner join guia_pagamento gp on bb.parc_id=gp.parc_id ");
			consulta.append("where bb.cbdo_id is not null ");
			consulta.append("and bb.parc_id is not null ");
			consulta.append("and gp.gpag_id = :guiaPagamentoId");

			retorno = session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.STRING)
							.setInteger("guiaPagamentoId", guiaPagamentoId).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar boletos bancarios já pagos de guia de pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 05/01/2012
	 */
	public Collection<Object[]> pesquisarBoletoGeradoGuiaPagamento(Integer guiaPagamentoId, Short numeroPrestacao)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select bbP.bbco_id as idBoletoBancario, bbs.BBST_DSSITUACAOBOLETO descricaoSituacao  ");
			consulta.append("    from boleto_bancario bbP  ");
			consulta.append(" 	 INNER JOIN boleto_bancario_situacao bbs on bbs.BBST_ID = bbP.BBST_IDATUAL ");
			consulta.append(" 	 where bbP.gpag_id = :guiaPagamentoId ");
			consulta.append(" 	 and bbP.bbco_nnprestacao = :numeroPrestacao ");
			consulta.append(" 	 and ( bbs.BBST_ID <> :idSituacaoBaixa  ");
			consulta.append(" 	    OR (bbs.BBST_ID = :idSituacaoBaixa and NOT EXISTS (");
			consulta.append(" 	      select bb.BBCO_ID from BOLETO_BANCARIO_OCORRENCIAS bbo ");
			consulta.append(" 	      	INNER JOIN BOLETO_BANCARIO_MOTIVO_OCORR bbmo on bbmo.BMTO_ID = bbo.BMTO_ID ");
			consulta.append(" 	       	INNER JOIN BOLETO_BANCARIO_MOVIMENTACAO bbm on bbm.BBMV_ID = bbo.BBMV_ID ");
			consulta.append(" 	     	INNER JOIN BOLETO_BANCARIO bb on (bb.BBCO_ID = bbm.BBCO_ID) ");
			consulta.append(" 	      	WHERE bbmo.BMTO_ID = " + BoletoBancarioMotivoOcorrencia.PROTESTADO);
			consulta.append(" 	    	 and bb.BBCO_ID = bbP.BBCO_ID  ");
			consulta.append(" 	    	                               )  "); // NOT EXISTS
			consulta.append(" 	    	)  "); // OR
			consulta.append(" 	      )  "); // AND

			retorno = session.createSQLQuery(consulta.toString()).addScalar("idBoletoBancario", Hibernate.STRING)
							.addScalar("descricaoSituacao", Hibernate.STRING).setInteger("guiaPagamentoId", guiaPagamentoId)
							.setShort("numeroPrestacao", numeroPrestacao).setInteger("idSituacaoBaixa", BoletoBancarioSituacao.BAIXA)
							.list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3034] Gerar Multa por Descumprimento de Parcelamento
	 * Selecionar as RDs que possuem multa por descumprimento com valor maior que zero
	 * 
	 * @author Anderson Italo
	 * @date 04/02/2012
	 * @throws ErroRepositorioException
	 */
	public Collection<ParcelamentoPerfil> selecionarResolucaoDiretoriaComMultaDescumprimentoMaiorQueZero() throws ErroRepositorioException{

		Collection<ParcelamentoPerfil> retorno = null;
		Collection retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("FROM ParcelamentoPerfil perfil ");
			consulta.append("WHERE perfil.percentualMultaPrestacaoDescumprida is not null ");
			consulta.append("AND perfil.percentualMultaPrestacaoDescumprida > 0 ");
			consulta.append("AND perfil.numeroPretacoesDescumpridasParaCobrancaMulta is not null ");
			consulta.append("AND perfil.numeroPretacoesDescumpridasParaCobrancaMulta > 0 ");

			retornoConsulta = session.createQuery(consulta.toString()).list();

			if(!Util.isVazioOrNulo(retornoConsulta)){

				retorno = retornoConsulta;
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3034] Gerar Multa por Descumprimento de Parcelamento
	 * Consultar os parcelamentos ativos realizados com o perfil informado e com forma de cobrança
	 * em
	 * conta e com prestações a serem cobradas
	 * 
	 * @author Anderson Italo
	 * @date 04/02/2012
	 * @throws ErroRepositorioException
	 */
	public Collection<Parcelamento> consultarParcelamentoAtivosRealizadosPorPerfil(Integer idPerfilParcelamento, Integer idFaturamentoGrupo)
					throws ErroRepositorioException{

		Collection<Parcelamento> retorno = null;
		Collection retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("SELECT parcel FROM Parcelamento parcel ");
			consulta.append("INNER JOIN FETCH parcel.imovel imov ");
			consulta.append("INNER JOIN imov.rota rot ");
			consulta.append("INNER JOIN FETCH imov.setorComercial setor ");
			consulta.append("INNER JOIN FETCH imov.quadra quadra ");
			consulta.append("WHERE parcel.parcelamentoPerfil.id = :idPerfilParcelamento ");
			consulta.append("AND parcel.parcelamentoSituacao.id = " + ParcelamentoSituacao.NORMAL.toString() + " ");
			consulta.append("AND parcel.cobrancaForma.id = " + CobrancaForma.COBRANCA_EM_CONTA.toString() + " ");
			consulta.append("AND EXISTS ( SELECT debito.id FROM DebitoACobrar debito ");
			consulta.append("WHERE debito.parcelamento.id = parcel.id ");
			consulta.append("AND debito.numeroPrestacaoDebito > debito.numeroPrestacaoCobradas ");
			consulta.append("AND debito.debitoCreditoSituacaoAtual.id IN ( ");
			consulta.append(DebitoCreditoSituacao.NORMAL.toString() + ",");
			consulta.append(DebitoCreditoSituacao.RETIFICADA.toString() + ",");
			consulta.append(DebitoCreditoSituacao.INCLUIDA.toString() + ")) ");
			consulta.append("AND rot.faturamentoGrupo.id = " + idFaturamentoGrupo.toString());

			retornoConsulta = session.createQuery(consulta.toString()).setInteger("idPerfilParcelamento", idPerfilParcelamento).list();

			if(!Util.isVazioOrNulo(retornoConsulta)){

				retorno = retornoConsulta;
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3034] Gerar Multa por Descumprimento de Parcelamento
	 * [SB001] – Selecionar débitos cobrados vencidos
	 * Selecionar os débitos cobrados do tipo de financiamento de parcelamento já vencidos
	 * associados ao parcelamento ordenados pelo número da prestação
	 * 
	 * @author Anderson Italo
	 * @date 04/02/2012
	 * @throws ErroRepositorioException
	 */
	public List<DebitoCobrado> selecionarDebitosCobradosVencidos(Integer idParcelamento) throws ErroRepositorioException{

		List<DebitoCobrado> retorno = null;
		List retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("SELECT new DebitoCobrado(debito.numeroPrestacaoDebito, max(conta.referencia)) ");
			consulta.append("FROM DebitoCobrado debito ");
			consulta.append("INNER JOIN debito.conta conta ");
			consulta.append("WHERE debito.parcelamento.id = :idParcelamento ");
			consulta.append("AND conta.debitoCreditoSituacaoAtual.id IN ( ");
			consulta.append(DebitoCreditoSituacao.NORMAL.toString() + ",");
			consulta.append(DebitoCreditoSituacao.RETIFICADA.toString() + ",");
			consulta.append(DebitoCreditoSituacao.INCLUIDA.toString() + ") ");
			consulta.append("AND conta.dataVencimentoConta < :dataAtual ");
			consulta.append("AND debito.lancamentoItemContabil.id <> :idlancamentoItemContabil ");
			consulta.append("GROUP BY debito.numeroPrestacaoDebito ");
			consulta.append("ORDER BY debito.numeroPrestacaoDebito DESC");

			retornoConsulta = session.createQuery(consulta.toString()).setInteger("idParcelamento", idParcelamento)
							.setDate("dataAtual", new Date())
							.setInteger("idlancamentoItemContabil", LancamentoItemContabil.JUROS_DO_PARCELAMENTO).list();

			if(retornoConsulta != null){

				retorno = retornoConsulta;
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3034] Gerar Multa por Descumprimento de Parcelamento
	 * Obter Débitos a Cobrar relativo a parcelamento de conta para o ano/mês de referência
	 * informados
	 * 
	 * @author Anderson Italo
	 * @date 04/02/2012
	 * @throws ErroRepositorioException
	 */
	public DebitoACobrar obterDebitoParcelamentoPorAnoMesSelecionado(Integer idParcelamento, Integer anoMesReferencia)
					throws ErroRepositorioException{

		DebitoACobrar retorno = null;
		Object retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("FROM DebitoACobrar debito ");
			consulta.append("WHERE debito.parcelamento.id = :idParcelamento ");
			consulta.append("AND debito.anoMesReferenciaDebito = :anoMesReferencia ");
			consulta.append("AND debito.debitoTipo.id = " + DebitoTipo.MULTA_POR_DESCUMPRIMENTO_PARCELAMENTO.toString());

			retornoConsulta = session.createQuery(consulta.toString()).setInteger("idParcelamento", idParcelamento)
							.setInteger("anoMesReferencia", anoMesReferencia).setMaxResults(1).uniqueResult();

			if(retornoConsulta != null){

				retorno = (DebitoACobrar) retornoConsulta;
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3034] Gerar Multa por Descumprimento de Parcelamento
	 * Obter Débitos a Cobrar relativos a parcelamento de contas para gerar a multa por
	 * descumprimento
	 * 
	 * @author Anderson Italo
	 * @date 04/02/2012
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoACobrar> obterDebitoParcelamentoParaGerarMultaPorDescumprimento(Integer idParcelamento)
					throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = null;
		Collection retornoConsulta = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("FROM DebitoACobrar debito ");
			consulta.append("WHERE debito.parcelamento.id = :idParcelamento ");
			consulta.append("AND debito.debitoCreditoSituacaoAtual.id IN ( ");
			consulta.append(DebitoCreditoSituacao.NORMAL.toString() + ",");
			consulta.append(DebitoCreditoSituacao.RETIFICADA.toString() + ",");
			consulta.append(DebitoCreditoSituacao.INCLUIDA.toString() + ") ");
			consulta.append("AND debito.lancamentoItemContabil.id <> " + LancamentoItemContabil.JUROS_DO_PARCELAMENTO);

			retornoConsulta = session.createQuery(consulta.toString()).setInteger("idParcelamento", idParcelamento).list();

			if(retornoConsulta != null){

				retorno = retornoConsulta;
			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0111] Iniciar Processo
	 * [SB0006] – Obter Dados Complementares de Comando de Faturamento
	 * 
	 * @author Hugo Lima
	 * @date 28/02/2012
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosComplementaresComandoFaturamento(Integer idComandoFaturamento) throws ErroRepositorioException{

		Object[] retorno = null;
		Object retornoConsulta = null;
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append(" select faturamentoGrupo.descricao, ");
			consulta.append(" faturamentoGrupoCronogramaMensal.anoMesReferencia ");
			consulta.append(" from FaturamentoAtividadeCronograma faturamentoAtividadeCronograma ");
			consulta.append(" inner join faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal ");
			consulta.append(" inner join faturamentoGrupoCronogramaMensal.faturamentoGrupo faturamentoGrupo ");
			consulta.append(" where faturamentoAtividadeCronograma.id = :idComandoFaturamento ");

			retornoConsulta = session.createQuery(consulta.toString()).setInteger("idComandoFaturamento", idComandoFaturamento)
							.setMaxResults(1).uniqueResult();

			if(!Util.isVazioOuBranco(retornoConsulta)){
				retorno = (Object[]) retornoConsulta;
			}

		}catch(HibernateException e){
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores
	 * [SB0016] – Processar Pagamento Legado DESO
	 * 
	 * @author Anderson Italo
	 * @date 09/03/2012
	 */
	public Integer pesquisarExistenciaContaComSituacaoAtualLegadoDESO(Imovel imovel, int anoMesReferencia) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select conta.id FROM Conta  conta ");
			consulta.append("where conta.referencia = :referencia ");
			consulta.append("and conta.imovel.id = :idImovel  and conta.debitoCreditoSituacaoAtual.id in ( ");
			consulta.append(DebitoCreditoSituacao.NORMAL).append(", ");
			consulta.append(DebitoCreditoSituacao.INCLUIDA).append(", ");
			consulta.append(DebitoCreditoSituacao.RETIFICADA).append(", ");
			consulta.append(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO).append(", ");
			consulta.append(DebitoCreditoSituacao.PRE_FATURADA).append(", ");
			consulta.append(DebitoCreditoSituacao.PRESCRITA).append(" ) ");

			retorno = (Integer) session.createQuery(consulta.toString()).setInteger("referencia", anoMesReferencia)
							.setInteger("idImovel", imovel.getId().intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * [UC0242] - Registrar Movimento de Arrecadadores
	 * [SB0016] – Processar Pagamento Legado DESO
	 * 
	 * @author Anderson Italo
	 * @date 09/03/2012
	 */
	public Integer pesquisarExistenciaContaHistoricoComSituacaoAtualLegadoDESO(Imovel imovel, int anoMesReferencia)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select conta.id FROM ContaHistorico  conta ");
			consulta.append("where conta.anoMesReferenciaConta = :referencia ");
			consulta.append("and conta.imovel.id = :idImovel  and conta.debitoCreditoSituacaoAtual.id in ( ");
			consulta.append(DebitoCreditoSituacao.NORMAL).append(", ");
			consulta.append(DebitoCreditoSituacao.INCLUIDA).append(", ");
			consulta.append(DebitoCreditoSituacao.RETIFICADA).append(", ");
			consulta.append(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO).append(", ");
			consulta.append(DebitoCreditoSituacao.PRESCRITA).append(", ");
			consulta.append(DebitoCreditoSituacao.PRE_FATURADA).append(" ) ");

			retorno = (Integer) session.createQuery(consulta.toString()).setInteger("referencia", anoMesReferencia)
							.setInteger("idImovel", imovel.getId().intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * [UC3037] Filtrar Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 10/02/2012
	 *          Exibir Contas Pré-Faturadas.
	 */
	public Collection pesquisarContasPreFaturadas(FaturaContasPreFaturadasHelper faturaContasPreFaturadasHelper, Integer pageOffset,
					boolean indicadorRelatorio) throws ErroRepositorioException{

		// Objeto de retorno
		Collection retorno = null;

		// Cria sessão
		Session session = HibernateUtil.getSession();

		// Armazena os parâmetros da consulta
		Map parameters = new HashMap();
		Query query = null;

		// Cria objeto de consulta
		StringBuffer consulta = new StringBuffer();

		// Recupera as informações preenchidas no formulário
		Integer dataReferenciaContaInicial = faturaContasPreFaturadasHelper.getDataReferenciaContaInicial();

		Integer dataReferenciaContaFinal = faturaContasPreFaturadasHelper.getDataReferenciaContaFinal();

		Date dataVencimentoContaInicial = faturaContasPreFaturadasHelper.getDataVencimentoContaInicial();

		Date dataVencimentoContaFinal = faturaContasPreFaturadasHelper.getDataVencimentoContaFinal();

		Integer imovelID = faturaContasPreFaturadasHelper.getImovelID();

		Integer faturamentoGrupoID = faturaContasPreFaturadasHelper.getFaturamentoGrupoID();

		Integer localidadeOrigemID = faturaContasPreFaturadasHelper.getLocalidadeOrigemID();

		Integer setorComercialOrigemCD = faturaContasPreFaturadasHelper.getSetorComercialOrigemCD();

		Integer localidadeDestinoID = faturaContasPreFaturadasHelper.getLocalidadeDestinoID();

		Integer setorComercialDestinoCD = faturaContasPreFaturadasHelper.getSetorComercialDestinoCD();

		Integer rotaOrigemID = faturaContasPreFaturadasHelper.getRotaOrigemID();

		Integer rotaDestinoID = faturaContasPreFaturadasHelper.getRotaDestinoID();

		try{
			// Cria Consulta
			consulta.append("SELECT conta.id, conta.referencia, conta.dataVencimentoConta, conta.codigoSetorComercial, ");
			consulta.append("conta.valorAgua, conta.valorEsgoto, conta.debitos, conta.valorCreditos, conta.valorImposto, ");
			consulta.append("imovel.id, loca.id, dcsa.id, dcsa.descricaoAbreviada, rota.id, ");
			consulta.append("ftgr.id, ftgr.descricaoAbreviada, ftgr.anoMesReferencia, ftgr.descricao, ");
			consulta.append("conta.quadra, conta.lote, conta.subLote, situacaoAgua.descricao, ");
			consulta.append("situacaoEsgoto.descricao, perfilImovel.descricao, conta.dataVencimentoConta, ");
			consulta.append("tarifa.descricao, conta.codigoSetorComercial, conta.referenciaContabil ");
			consulta.append("FROM Conta conta ");
			consulta.append("LEFT JOIN conta.imovel imovel ");
			consulta.append("LEFT JOIN conta.localidade loca ");
			consulta.append("LEFT JOIN conta.debitoCreditoSituacaoAtual dcsa ");
			consulta.append("LEFT JOIN conta.rota rota ");
			consulta.append("LEFT JOIN rota.faturamentoGrupo ftgr ");
			consulta.append("LEFT JOIN conta.ligacaoAguaSituacao situacaoAgua ");
			consulta.append("LEFT JOIN conta.ligacaoEsgotoSituacao situacaoEsgoto ");
			consulta.append("LEFT JOIN conta.imovelPerfil perfilImovel ");
			consulta.append("LEFT JOIN conta.consumoTarifa tarifa ");

			// Cláusula Where
			consulta.append("WHERE conta.debitoCreditoSituacaoAtual = :idSituacaoPreFaturada ");
			// consulta.append("AND ((conta.valorAgua + conta.valorEsgoto + conta.debitos) - ");
			// consulta.append("(conta.valorCreditos + coalesce(conta.valorImposto, 0))) > 0 ");
			consulta.append("AND conta.referencia <= ftgr.anoMesReferencia ");

			if(!Util.isVazioOuBranco(dataReferenciaContaInicial) && !Util.isVazioOuBranco(dataReferenciaContaFinal)){
				consulta.append("AND conta.referencia BETWEEN :dataReferenciaContaInicial AND :dataReferenciaContaFinal ");
				parameters.put("dataReferenciaContaInicial", dataReferenciaContaInicial);
				parameters.put("dataReferenciaContaFinal", dataReferenciaContaFinal);
			}

			if(!Util.isVazioOuBranco(dataVencimentoContaInicial) && !Util.isVazioOuBranco(dataVencimentoContaFinal)){
				consulta.append("AND conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicial AND :dataVencimentoContaFinal ");
				parameters.put("dataVencimentoContaInicial", dataVencimentoContaInicial);
				parameters.put("dataVencimentoContaFinal", dataVencimentoContaFinal);
			}

			if(!Util.isVazioOuBranco(imovelID)){
				consulta.append("AND imovel.id = :imovelID ");
				parameters.put("imovelID", imovelID);
			}

			if(!Util.isVazioOuBranco(faturamentoGrupoID)){
				consulta.append("AND ftgr.id = :faturamentoGrupoID ");
				parameters.put("faturamentoGrupoID", faturamentoGrupoID);
			}

			if(!Util.isVazioOuBranco(localidadeOrigemID) && !Util.isVazioOuBranco(localidadeDestinoID)){
				consulta.append("AND loca.id BETWEEN :localidadeOrigemID AND :localidadeDestinoID ");
				parameters.put("localidadeOrigemID", localidadeOrigemID);
				parameters.put("localidadeDestinoID", localidadeDestinoID);
			}

			if(!Util.isVazioOuBranco(setorComercialOrigemCD) && !Util.isVazioOuBranco(setorComercialDestinoCD)){
				consulta.append("AND conta.codigoSetorComercial BETWEEN :setorComercialOrigemCD AND :setorComercialDestinoCD ");
				parameters.put("setorComercialOrigemCD", setorComercialOrigemCD);
				parameters.put("setorComercialDestinoCD", setorComercialDestinoCD);
			}

			if(!Util.isVazioOuBranco(rotaOrigemID) && !Util.isVazioOuBranco(rotaDestinoID)){
				consulta.append("AND rota.id BETWEEN :rotaOrigemID AND :rotaDestinoID ");
				parameters.put("rotaOrigemID", rotaOrigemID);
				parameters.put("rotaDestinoID", rotaDestinoID);
			}

			parameters.put("idSituacaoPreFaturada", DebitoCreditoSituacao.PRE_FATURADA);

			if(indicadorRelatorio){

				consulta.append("ORDER BY  ftgr.id, imovel.id ASC, conta.referencia DESC ");
			}else{

				consulta.append("ORDER BY imovel.id ASC, conta.referencia DESC ");
			}

			// Retorno da consulta
			query = session.createQuery(consulta.toString());

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Integer){
					query.setInteger(key, (Integer) parameters.get(key));
				}else if(parameters.get(key) instanceof Date){
					query.setDate(key, (Date) parameters.get(key));
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}

			if(pageOffset < 0){
				retorno = (List) query.list();
			}else{
				retorno = (List) query.setFirstResult(10 * pageOffset).setMaxResults(10).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3035] Concluir Faturamento Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 16/02/2012
	 */
	public Conta pesquisarContaPeloID(Integer idConta) throws ErroRepositorioException{

		// Objeto de retorno
		Conta retorno = null;

		// Cria sessão
		Session session = HibernateUtil.getSession();

		// Cria objeto de consulta
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT conta FROM Conta conta ");
			consulta.append("LEFT JOIN FETCH conta.imovel imovel ");
			consulta.append("LEFT JOIN FETCH imovel.localidade loca ");
			consulta.append("LEFT JOIN FETCH imovel.setorComercial stcm ");
			consulta.append("LEFT JOIN FETCH imovel.quadra qdra ");
			consulta.append("LEFT JOIN FETCH imovel.ligacaoAguaSituacao last ");
			consulta.append("LEFT JOIN FETCH imovel.ligacaoEsgotoSituacao lest ");
			consulta.append("LEFT JOIN FETCH imovel.imovelPerfil iper ");
			consulta.append("LEFT JOIN FETCH conta.localidade loca ");
			consulta.append("LEFT JOIN FETCH conta.debitoCreditoSituacaoAtual dcsa ");
			consulta.append("LEFT JOIN FETCH conta.ligacaoAguaSituacao ctlgagua ");
			consulta.append("LEFT JOIN FETCH conta.consumoTarifa consumotarifa ");
			consulta.append("LEFT JOIN FETCH conta.ligacaoEsgotoSituacao ctlgesgoto ");
			consulta.append("LEFT JOIN FETCH conta.imovelPerfil imovperfil ");
			consulta.append("LEFT JOIN FETCH conta.rota rota ");
			consulta.append("LEFT JOIN FETCH rota.faturamentoGrupo ftgr ");
			consulta.append("LEFT JOIN FETCH conta.usuario usuario ");
			consulta.append("WHERE conta.id = :idConta ");

			retorno = (Conta) session.createQuery(consulta.toString()).setInteger("idConta", idConta.intValue()).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3037] Filtrar Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 24/02/2012
	 *          Exibir Contas Pré-Faturadas.
	 */
	public Collection<Integer> pesquisarQuantidadeContasPreFaturadas(FaturaContasPreFaturadasHelper faturaContasPreFaturadasHelper,
					Short permiteFaturarContaPreFaturadaZero) throws ErroRepositorioException{

		// Objeto de retorno
		Collection<Integer> retorno = null;

		// Cria sessão
		Session session = HibernateUtil.getSession();

		// Armazena os parâmetros da consulta
		Map parameters = new HashMap();
		Query query = null;

		// Cria objeto de consulta
		StringBuffer consulta = new StringBuffer();

		// Recupera as informações preenchidas no formulário
		Integer dataReferenciaContaInicial = faturaContasPreFaturadasHelper.getDataReferenciaContaInicial();

		Integer dataReferenciaContaFinal = faturaContasPreFaturadasHelper.getDataReferenciaContaFinal();

		Date dataVencimentoContaInicial = faturaContasPreFaturadasHelper.getDataVencimentoContaInicial();

		Date dataVencimentoContaFinal = faturaContasPreFaturadasHelper.getDataVencimentoContaFinal();

		Integer imovelID = faturaContasPreFaturadasHelper.getImovelID();

		Integer faturamentoGrupoID = faturaContasPreFaturadasHelper.getFaturamentoGrupoID();

		Integer localidadeOrigemID = faturaContasPreFaturadasHelper.getLocalidadeOrigemID();

		Integer setorComercialOrigemCD = faturaContasPreFaturadasHelper.getSetorComercialOrigemCD();

		Integer localidadeDestinoID = faturaContasPreFaturadasHelper.getLocalidadeDestinoID();

		Integer setorComercialDestinoCD = faturaContasPreFaturadasHelper.getSetorComercialDestinoCD();

		Integer rotaOrigemID = faturaContasPreFaturadasHelper.getRotaOrigemID();

		Integer rotaDestinoID = faturaContasPreFaturadasHelper.getRotaDestinoID();

		try{
			// Cria Consulta
			// Retorna o id da conta para controle da paginação
			// na tela de Atualizar Situação da Conta
			consulta.append("SELECT conta.id ");
			consulta.append("FROM Conta conta ");
			consulta.append("LEFT JOIN conta.imovel imovel ");
			consulta.append("LEFT JOIN conta.localidade loca ");
			consulta.append("LEFT JOIN conta.debitoCreditoSituacaoAtual dcsa ");
			consulta.append("LEFT JOIN conta.rota rota ");
			consulta.append("LEFT JOIN rota.faturamentoGrupo ftgr ");
			consulta.append("LEFT JOIN conta.ligacaoAguaSituacao situacaoAgua ");
			consulta.append("LEFT JOIN conta.ligacaoEsgotoSituacao situacaoEsgoto ");
			consulta.append("LEFT JOIN conta.imovelPerfil perfilImovel ");
			consulta.append("LEFT JOIN conta.consumoTarifa tarifa ");

			// Cláusula Where
			consulta.append("WHERE conta.debitoCreditoSituacaoAtual = :idSituacaoPreFaturada ");

			if(permiteFaturarContaPreFaturadaZero.equals(ConstantesSistema.NAO)){

				consulta.append("AND ((conta.valorAgua + conta.valorEsgoto + conta.debitos) - ");
				consulta.append("(conta.valorCreditos + coalesce(conta.valorImposto, 0))) > 0 ");
			}else{

				consulta.append(" AND exists( ");
				consulta.append(" select 1 from MovimentoRoteiroEmpresa mov where ");
				consulta.append(" mov.imovel.id = conta.imovel.id and mov.anoMesMovimento = conta.referencia and mov.indicadorFase in (4,1,2) ");
				consulta.append(" and ( (coalesce(mov.valorAgua,0) > 0) ");
				consulta.append(" or (coalesce(mov.valorEsgoto,0) > 0) ");
				consulta.append(" or (coalesce(mov.valorDebitos,0) > 0) ");
				consulta.append(" or (coalesce(mov.valorCreditos,0) > 0) ) ) ");
			}

			consulta.append("AND conta.referencia <= ftgr.anoMesReferencia ");

			if(!Util.isVazioOuBranco(dataReferenciaContaInicial) && !Util.isVazioOuBranco(dataReferenciaContaFinal)){
				consulta.append("AND conta.referencia BETWEEN :dataReferenciaContaInicial AND :dataReferenciaContaFinal ");
				parameters.put("dataReferenciaContaInicial", dataReferenciaContaInicial);
				parameters.put("dataReferenciaContaFinal", dataReferenciaContaFinal);
			}

			if(!Util.isVazioOuBranco(dataVencimentoContaInicial) && !Util.isVazioOuBranco(dataVencimentoContaFinal)){
				consulta.append("AND conta.dataVencimentoConta BETWEEN :dataVencimentoContaInicial AND :dataVencimentoContaFinal ");
				parameters.put("dataVencimentoContaInicial", dataVencimentoContaInicial);
				parameters.put("dataVencimentoContaFinal", dataVencimentoContaFinal);
			}

			if(!Util.isVazioOuBranco(imovelID)){
				consulta.append("AND imovel.id = :imovelID ");
				parameters.put("imovelID", imovelID);
			}

			if(!Util.isVazioOuBranco(faturamentoGrupoID)){
				consulta.append("AND ftgr.id = :faturamentoGrupoID ");
				parameters.put("faturamentoGrupoID", faturamentoGrupoID);
			}

			if(!Util.isVazioOuBranco(localidadeOrigemID) && !Util.isVazioOuBranco(localidadeDestinoID)){
				consulta.append("AND loca.id BETWEEN :localidadeOrigemID AND :localidadeDestinoID ");
				parameters.put("localidadeOrigemID", localidadeOrigemID);
				parameters.put("localidadeDestinoID", localidadeDestinoID);
			}

			if(!Util.isVazioOuBranco(setorComercialOrigemCD) && !Util.isVazioOuBranco(setorComercialDestinoCD)){
				consulta.append("AND conta.codigoSetorComercial BETWEEN :setorComercialOrigemCD AND :setorComercialDestinoCD ");
				parameters.put("setorComercialOrigemCD", setorComercialOrigemCD);
				parameters.put("setorComercialDestinoCD", setorComercialDestinoCD);
			}

			if(!Util.isVazioOuBranco(rotaOrigemID) && !Util.isVazioOuBranco(rotaDestinoID)){
				consulta.append("AND rota.id BETWEEN :rotaOrigemID AND :rotaDestinoID ");
				parameters.put("rotaOrigemID", rotaOrigemID);
				parameters.put("rotaDestinoID", rotaDestinoID);
			}

			parameters.put("idSituacaoPreFaturada", DebitoCreditoSituacao.PRE_FATURADA);

			consulta.append("ORDER BY imovel.id ASC, conta.referencia DESC ");

			// Retorno da consulta
			query = session.createQuery(consulta.toString());

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while(iterMap.hasNext()){
				String key = (String) iterMap.next();
				if(parameters.get(key) instanceof Integer){
					query.setInteger(key, (Integer) parameters.get(key));
				}else if(parameters.get(key) instanceof Date){
					query.setDate(key, (Date) parameters.get(key));
				}else{
					query.setParameter(key, parameters.get(key));
				}
			}

			Object resultadoConsulta = query.list();

			if(!Util.isVazioOuBranco(resultadoConsulta)){
				retorno = (Collection<Integer>) resultadoConsulta;
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [FS0005] - Verificar existência da conta
	 * 
	 * @author Anderson Italo
	 * @date 02/08/2011
	 * @return Object
	 * @exception ErroRepositorioException
	 */
	public Object verificarExistenciaConta(Integer imovelId, Integer anoMesReferencia) throws ErroRepositorioException{

		Object retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select ct.id from Conta ct ");
			consulta.append("inner join ct.imovel im ");
			consulta.append("where im.id = :imovelId and ct.referencia = :anoMesReferencia");

			retorno = session.createQuery(consulta.toString()).setInteger("imovelId", imovelId.intValue())
							.setInteger("anoMesReferencia", anoMesReferencia).setMaxResults(1).uniqueResult();
		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3055] Encerrar Faturamento
	 * [SB0001] – Selecionar Grupos de Faturamento por Situação
	 * 
	 * @author Hebert Falcão
	 * @date 01/04/2012
	 */
	public Collection<Object[]> selecionarGruposFaturamentoPorSituacao(Integer referencia, Short situacao) throws ErroRepositorioException{

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT FTGR.FTGR_DSFATURAMENTOGRUPO as descricao, ");
			consulta.append("       FTGR.FTGR_AMREFERENCIA as referencia, ");
			consulta.append("       FTAC.FTAC_TMREALIZACAO as dataUltimoFaturamento, ");
			consulta.append("       FTGR.FTGR_ID as id, ");

			consulta.append("       case when FTGR.FTGR_AMREFERENCIA > " + referencia);
			consulta.append("       then (select count(*) from rota  ");
			consulta.append("       where ftgr_id = FTGR.FTGR_ID  ");
			consulta.append("       and rota_id not in( ");
			consulta.append("       select rota.rota_id ");
			consulta.append("       from rota rota  ");
			consulta.append("       inner join setor_comercial stcm on rota.stcm_id=stcm.stcm_id  ");
			consulta.append("       inner join faturamento_ativ_cron_rota facr on rota.rota_id=facr.rota_id  ");
			consulta.append("       inner join faturamento_atividade_cron ftac on facr.ftac_id=ftac.ftac_id  ");
			consulta.append("       inner join faturamento_grupo_cron_mensal ftcm on ftac.ftcm_id=ftcm.ftcm_id  ");
			consulta.append("       inner join  faturamento_atividade ftat on ftac.ftat_id=ftat.ftat_id	");
			consulta.append("       where (ftat.ftat_dsfaturamentoatividade in ('FATURAR GRUPO' , 'ATUALIZAR FATURAMENTO IMEDIATO'))  ");
			consulta.append("       and (ftac.ftac_tmcomando is not null) and (ftac.ftac_tmrealizacao is not null)  ");
			consulta.append("       and ftcm.ftgr_id=FTGR.FTGR_ID and ftcm.ftcm_amreferencia = " + referencia + "))  ");
			consulta.append("       else 0 end as qtRotasNaoFaturadas ");

			consulta.append("FROM FATURAMENTO_GRUPO FTGR  ");
			consulta.append("LEFT JOIN FATURAMENTO_GRUPO_CRON_MENSAL FTCM ON FTCM.FTGR_ID = FTGR.FTGR_ID  ");
			consulta.append("LEFT JOIN FATURAMENTO_ATIVIDADE_CRON FTAC ON (FTAC.FTCM_ID = FTCM.FTCM_ID ");
			consulta.append("                                              AND FTAC.FTAT_ID = :faturamentoAtividade) ");
			consulta.append("WHERE (FTCM.FTCM_AMREFERENCIA = (SELECT MAX(FTCM_AMREFERENCIA) ");
			consulta.append("                                FROM FATURAMENTO_GRUPO_CRON_MENSAL FTCM2 ");
			consulta.append("                                WHERE FTCM2.FTGR_ID = FTGR.FTGR_ID) ");
			consulta.append("       OR FTCM.FTCM_AMREFERENCIA IS NULL) ");

			if(situacao.equals(ConstantesSistema.FATURADOS)){
				consulta.append("  AND FTGR.FTGR_AMREFERENCIA > " + referencia + " ");
			}else if(situacao.equals(ConstantesSistema.NAO_FATURADOS)){
				consulta.append("  AND FTGR.FTGR_AMREFERENCIA <= " + referencia + " ");
			}

			consulta.append("ORDER BY FTGR.FTGR_DSFATURAMENTOGRUPO ");

			retorno = session.createSQLQuery(consulta.toString()).addScalar("descricao", Hibernate.STRING)
							.addScalar("referencia", Hibernate.INTEGER).addScalar("dataUltimoFaturamento", Hibernate.DATE)
							.addScalar("id", Hibernate.STRING).addScalar("qtRotasNaoFaturadas", Hibernate.STRING)
							.setInteger("faturamentoAtividade", FaturamentoAtividade.FATURAR_GRUPO).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3055] Encerrar Faturamento
	 * Pesquisar Grupos Não Faturados
	 * 
	 * @author Hebert Falcão
	 * @date 01/04/2012
	 */
	public Collection<FaturamentoGrupo> pesquisarGruposNaoFaturados(Integer referencia) throws ErroRepositorioException{

		Collection<FaturamentoGrupo> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select ftgr ");
			hql.append("from FaturamentoGrupo ftgr ");
			hql.append("where ftgr.anoMesReferencia <= :referencia ");
			hql.append("order by ftgr.descricao ");

			retorno = (Collection<FaturamentoGrupo>) session.createQuery(hql.toString()).setInteger("referencia", referencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public BigDecimal pesquisarValorAtualizacaoCobradas(int idConta) throws ErroRepositorioException{

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuffer consulta = new StringBuffer();

		try{
			// constroi o hql
			consulta.append("select sum(dbcb.valorPrestacao) ").append("from DebitoCobrado dbcb ").append("inner join dbcb.conta cnta ")
							.append("inner join dbcb.debitoTipo dbtp ").append("where cnta.id = :idConta ").append("and dbtp.id = ")
							.append(DebitoTipo.ATUALIZACAO_MONETARIA);

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	public BigDecimal pesquisarValorJurosCobrados(int idConta) throws ErroRepositorioException{

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuffer consulta = new StringBuffer();

		try{
			// constroi o hql
			consulta.append("select sum(dbcb.valorPrestacao) ").append("from DebitoCobrado dbcb ").append("inner join dbcb.conta cnta ")
							.append("inner join dbcb.debitoTipo dbtp ").append("where cnta.id = :idConta ").append("and dbtp.id = ")
							.append(DebitoTipo.JUROS_MORA);

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Atualiza os imóveis com situação especial de cobrança finalizada
	 * 
	 * @author Hebert Falcão
	 * @date 02/05/2012
	 */
	public void atualizarImoveisSituacaoEspecialCobrancaFinalizada(int anoMesFaturamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer hql = new StringBuffer();

			hql.append("update Imovel imov set imov.cobrancaSituacaoTipo.id = null ");
			hql.append("where imov.cobrancaSituacaoTipo.id is not null ");
			hql.append("  and imov.id in (select distinct(cbsh.imovel.id) ");
			hql.append("                  from CobrancaSituacaoHistorico cbsh ");
			hql.append("                  where cbsh.anoMesCobrancaSituacaoFim <= :anoMesFaturamento ");
			hql.append("                    and cbsh.anoMesCobrancaRetirada is null) ");

			session.createQuery(hql.toString()).setInteger("anoMesFaturamento", anoMesFaturamento).executeUpdate();

			hql = new StringBuffer();

			hql.append("update CobrancaSituacaoHistorico set anoMesCobrancaRetirada = :anoMesFaturamento, ");
			hql.append("                                            dataHoraExclusao = :dataHoraExclusao ");
			hql.append("where anoMesCobrancaSituacaoFim <= :anoMesFaturamento ");
			hql.append("  and anoMesCobrancaRetirada is null ");

			session.createQuery(hql.toString()).setInteger("anoMesFaturamento", anoMesFaturamento)
							.setTimestamp("dataHoraExclusao", new Date()).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Atualiza os imóveis com situação especial de faturamento finalizada
	 * 
	 * @author Hebert Falcão
	 * @date 02/05/2012
	 */
	public void atualizarImoveisSituacaoEspecialFaturamentoFinalizada(int anoMesFaturamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer hql = new StringBuffer();

			hql.append("update Imovel imov set imov.faturamentoSituacaoTipo.id = null ");
			hql.append("where imov.faturamentoSituacaoTipo.id is not null ");
			hql.append("  and imov.id in (select distinct(ftsh.imovel.id) ");
			hql.append("                  from FaturamentoSituacaoHistorico ftsh ");
			hql.append("                  where ftsh.anoMesFaturamentoSituacaoFim <= :anoMesFaturamento ");
			hql.append("                    and ftsh.anoMesFaturamentoRetirada is null) ");

			session.createQuery(hql.toString()).setInteger("anoMesFaturamento", anoMesFaturamento).executeUpdate();

			hql = new StringBuffer();

			hql.append("update FaturamentoSituacaoHistorico set anoMesFaturamentoRetirada = :anoMesFaturamento, ");
			hql.append("                                                  ultimaAlteracao = :dataUltimaAlteracao ");
			hql.append("where anoMesFaturamentoSituacaoFim <= :anoMesFaturamento ");
			hql.append("  and anoMesFaturamentoRetirada is null ");

			session.createQuery(hql.toString()).setInteger("anoMesFaturamento", anoMesFaturamento)
							.setTimestamp("dataUltimaAlteracao", new Date()).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC3057] Retirar Conta de Revisão Prazo Vencido
	 * Pesquisa Todas as contas em Revisão e com Código de Revisão que possua Prazo de Validade e
	 * que o prazo de Validade já esteja vencido
	 * 
	 * @author Hugo Lima
	 * @date 15/05/2012
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContasRevisaoPrazoVencido() throws ErroRepositorioException{

		Collection<Conta> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append(" select conta ");
			hql.append(" from Conta conta ");
			hql.append(" inner join conta.contaMotivoRevisao contaMotivoRevisao ");
			hql.append(" where conta.dataRevisao is not null ");
			hql.append(" and contaMotivoRevisao.indicadorUso = 1 ");
			hql.append(" and contaMotivoRevisao.prazoValidade is not null ");
			hql.append(" and contaMotivoRevisao.prazoValidade < trunc(current_date - conta.dataRevisao) ");
			hql.append(" order by conta.id ");

			retorno = (Collection<Conta>) session.createQuery(hql.toString()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0088] Registrar Faturamento Imediato
	 * Pesquisa os motivos de revisão associados a um grupo de faturamento em determinado periodo
	 * 
	 * @author Hugo Lima
	 * @date 23/05/2012
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoGrupoRevisao> pesquisarContasMotivoRevisaoGrupoFaturamento(Integer idFaturamentoGrupo, Integer referencia)
					throws ErroRepositorioException{

		Collection<FaturamentoGrupoRevisao> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append(" select faturamentoGrupoRevisao ");
			hql.append(" from FaturamentoGrupoRevisao faturamentoGrupoRevisao ");
			hql.append(" inner join faturamentoGrupoRevisao.faturamentoGrupo faturamentoGrupo ");
			hql.append(" inner join faturamentoGrupoRevisao.contaMotivoRevisao contaMotivoRevisao ");
			hql.append(" where faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append(" and faturamentoGrupoRevisao.anoMesReferenciaFaturamentoInicial <= :referencia ");
			hql.append(" and faturamentoGrupoRevisao.anoMesReferenciaFaturamentoFinal >= :referencia ");

			retorno = (Collection<FaturamentoGrupoRevisao>) session.createQuery(hql.toString())
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo).setInteger("referencia", referencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// ---------------------------------------

	/**
	 * Atenção método provisório apenas para correção do faturamento imediato 08/05/2012
	 */
	public Collection<Object[]> selecionarContasCorrigirFaturamentoImediato() throws ErroRepositorioException{

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("SELECT DISTINCT CO.CNTA_ID AS CONTA, " + "CO.IMOV_ID AS IMOVEL," + " CO.CNTA_AMREFERENCIACONTA AS REF  "
							+ "FROM   CONTA CO,   CONTA_CATEGORIA CC " + " WHERE  CO.CNTA_ID = CC.CNTA_ID   AND "
							+ " CNTA_AMREFERENCIACONTA = 201205   AND " + "( (CNTA_VLAGUA   > 0   AND  CTCG_VLAGUA   = 0)     "
							+ " OR  (CNTA_VLESGOTO > 0   AND  CTCG_VLESGOTO = 0) ) ");

			retorno = session.createSQLQuery(consulta.toString()).addScalar("CONTA", Hibernate.INTEGER)
							.addScalar("IMOVEL", Hibernate.INTEGER).addScalar("REF", Hibernate.INTEGER).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012] Gerar Arquivo Texto Faturamento Imediato
	 * Obtém IMTA_PCALIQUOTA da tabela IMPOSTO_TIPO_ALIQUOTA com IMTA_AMREFERENCIA com o maior
	 * valor que seja igual ou menor ao ano/mês de referência e IMTP_ID igual à IMTP_ID da tabela
	 * IMPOSTO_TIPO com IMTP_ICUSO igual “1” - Ativo
	 * 
	 * @author Anderson Italo
	 * @date 02/06/2012
	 * @throws ErroRepositorioException
	 */
	public BigDecimal obterPercentualAliquotaImpostoFederal(Integer anoMesReferencia) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append(" select sum(imposto.percentualAliquota) ");
			hql.append(" from ImpostoTipoAliquota imposto ");
			hql.append(" inner join imposto.impostoTipo impostoTip ");
			hql.append(" where imposto.anoMesReferencia <= :referencia ");
			hql.append(" and impostoTip.indicadorUso = " + ConstantesSistema.INDICADOR_USO_ATIVO.toString());

			retorno = (BigDecimal) session.createQuery(hql.toString()).setInteger("referencia", anoMesReferencia).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012] Gerar Arquivo Texto Faturamento Imediato
	 * Obtém as tarifas a partir da tabela CONSUMO_TARIFA_FAIXA com CSTC_ID = CSTC_ID da tabela
	 * CONSUMO_TARIFA_CATEGORIA com CSTV_ID = CSTV_ID da tabela CONSUMO_TARIFA_VIGENCIA com ano/mês
	 * de vigência (CSTV_DTVIGENCIA) menor ou igual ao ano/mês do faturamento recebido, ordenando
	 * pela tarifa (CSTF_ID), pela vigência (CSTV_DTVIGENCIA) em ordem decrescente, pela categoria
	 * (CATG_ID) e pela faixa (CTFX_NNCONSUMOFAIXAFIM) em ordem crescente
	 * 
	 * @author Anderson Italo
	 * @date 02/06/2012
	 * @throws ErroRepositorioException
	 */
	public List pesquisarTarifasArquivoTextoFaturamentoImediato(Integer referencia) throws ErroRepositorioException{

		List retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();

		String anoMes = Util.formatarAnoMesParaMesAnoSemBarra(referencia);
		String dataFormatada = "01/" + anoMes.substring(0, 2) + "/" + anoMes.substring(4, 6);

		try{
			sql.append(" select ctv.cstf_id as tarifa, ctc.catg_id as categ, ");
			sql.append(" ctf.ctfx_nnconsumofaixafim as faixaFim, ctf.ctfx_vlconsumotarifa as valorTarifa, ");
			sql.append(" ctf.ctfx_nncosumofaixainicio as faixaInicio, ctv.cstv_dtvigencia as vigencia, ");
			sql.append(" ctf.ctfx_vlusoesgototarifa as valorUsoEsgotoTarifa ");
			sql.append(" from consumo_tarifa_faixa ctf ");
			sql.append(" inner join consumo_tarifa_categoria  ctc on ctc.cstc_id = ctf.cstc_id ");
			sql.append(" inner join consumo_tarifa_vigencia ctv on ctv.cstv_id = ctc.cstv_id ");
			sql.append(" where ctv.cstv_dtvigencia = ");
			sql.append(" (select max(ctv2.cstv_dtvigencia) ");
			sql.append(" from consumo_tarifa_vigencia ctv2 ");
			sql.append(" where ctv2.cstf_id = ctv.cstf_id ");
			sql.append(" and ctv2.cstv_dtvigencia <= to_date('" + dataFormatada + "', 'dd/mm/yy')) ");
			sql.append(" order by ctv.cstf_id asc, ctv.cstv_dtvigencia desc, ");
			sql.append(" ctc.catg_id asc, ctf.ctfx_nnconsumofaixafim asc ");

			retorno = session.createSQLQuery(sql.toString()).addScalar("tarifa", Hibernate.INTEGER).addScalar("categ", Hibernate.INTEGER)
							.addScalar("faixaFim", Hibernate.INTEGER).addScalar("valorTarifa", Hibernate.BIG_DECIMAL)
							.addScalar("faixaInicio", Hibernate.INTEGER).addScalar("vigencia", Hibernate.DATE)
							.addScalar("valorUsoEsgotoTarifa", Hibernate.BIG_DECIMAL).list();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012] Gerar Arquivo Texto Faturamento Imediato
	 * Obtém as anormalidades de leitura (a partir da tabela LEITURA_ANORMALIDADE com LTAN_ICUSO=1
	 * (um), ordenando pelo código da anormalidade (LTAN_ID))
	 * 
	 * @author Anderson Italo
	 * @date 02/06/2012
	 * @throws ErroRepositorioException
	 */
	public List pesquisarLeituraAnormalidadeFaturamentoImediato() throws ErroRepositorioException{

		List retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{

			hql.append(" from LeituraAnormalidade l");
			hql.append(" where l.indicadorUso = " + ConstantesSistema.SIM.toString());
			hql.append(" order by l.id ");

			retorno = session.createQuery(hql.toString()).list();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012] Gerar Arquivo Texto Faturamento Imediato
	 * Obtém os setores (a partir da tabela SETOR_COMERCIAL ordenando
	 * pela localidade (LOCA_ID) e código do setor comercial (STCM_CDSETORCOMERCIAL)) das rotas
	 * selecionadas
	 * 
	 * @author Anderson Italo
	 * @date 03/06/2012
	 * @throws ErroRepositorioException
	 */
	public List<Object[]> pesquisarSetorComercialFaturamentoImediato(String idsRotas) throws ErroRepositorioException{

		List<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();

		try{

			sql.append(" select s.loca_id as idLocalidade, l.loca_nmlocalidade as nomeLocalidade, ");
			sql.append(" s.stcm_cdsetorcomercial as codigoSetor, l.loca_nnconsumograndeusuario as consumoGrandeUsuario, ");
			sql.append(" l.loca_cdelo as elo, s.stcm_id as idSetor, l.greg_id as idGerenciaRegional ");
			sql.append(" from setor_comercial s ");
			sql.append(" inner join localidade l on l.loca_id = s.loca_id ");
			sql.append(" where exists (select 1 from imovel i where i.rota_id in (" + idsRotas + ") and s.stcm_id = i.stcm_id ) ");
			sql.append(" order by s.loca_id, s.stcm_cdsetorcomercial ");

			retorno = session.createSQLQuery(sql.toString()).addScalar("idLocalidade", Hibernate.INTEGER)
							.addScalar("nomeLocalidade", Hibernate.STRING).addScalar("codigoSetor", Hibernate.SHORT)
							.addScalar("consumoGrandeUsuario", Hibernate.INTEGER).addScalar("elo", Hibernate.INTEGER)
							.addScalar("idSetor", Hibernate.INTEGER).addScalar("idGerenciaRegional", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * Retorna a Descrição da ContaMensagem mais recente de acordo com o AnoMesFaturamento e com o
	 * GrupoFaturamento.
	 * 
	 * @author Anderson Italo
	 * @date 03/06/2012
	 * @author Hiroshi Goncalves
	 * @date 09/01/2014
	 */
	public Object[] pesquisarDescricaoContaMensagemFaturamentoImediato(Integer anoMesFaturamento, Integer idFaturamentoGrupo,
					Integer idGerenciaRegional, Integer idLocalidade, Integer idSetorComercial) throws ErroRepositorioException{

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "SELECT MSG1, MSG2, MSG3, AMFATUR, PRIORIDADE FROM ( ";

			// Setor Comercial
			consulta += this.montarSubSelectPesquisarDescricaoContaMensagemFaturamentoImediato(ContaMensagem.SETOR_COMERCIAL,
							idSetorComercial);

			consulta += " \nUNION\n ";

			// Localidade
			consulta += this.montarSubSelectPesquisarDescricaoContaMensagemFaturamentoImediato(ContaMensagem.LOCALIDADE, idLocalidade);

			consulta += " \nUNION\n ";

			// Gerência Regional
			consulta += this.montarSubSelectPesquisarDescricaoContaMensagemFaturamentoImediato(ContaMensagem.GERENCIA_REGIONAL,
							idGerenciaRegional);

			consulta += " \nUNION\n ";

			// Faturamento Grupo
			consulta += this.montarSubSelectPesquisarDescricaoContaMensagemFaturamentoImediato(ContaMensagem.GRUPO_FATURAMENTO,
							idFaturamentoGrupo);

			consulta += " \nUNION\n ";

			// Geral
			consulta += this.montarSubSelectPesquisarDescricaoContaMensagemFaturamentoImediato(ContaMensagem.GERAL, null);

			consulta += ") TAB ORDER BY AMFATUR DESC, PRIORIDADE";

			Query query = session.createSQLQuery(consulta).setInteger("anoMesFaturamento", anoMesFaturamento);
			
			if(idSetorComercial != null){
				query = query.setInteger("idSetorComercial", idSetorComercial);
			}
			if(idLocalidade != null){
				query = query.setInteger("idLocalidade", idLocalidade);
			}
			if(idGerenciaRegional != null){
				query = query.setInteger("idGerenciaRegional", idGerenciaRegional);
			}
			if(idFaturamentoGrupo != null){
				query = query.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			}

			query.setShort("indicadorUso", ConstantesSistema.INDICADOR_USO_ATIVO);

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0001] – Gerar Arquivo Texto para Faturamento Imediato.
	 * Retorna a Descrição da ContaMensagem mais recente de acordo com o AnoMesFaturamento e com o
	 * GrupoFaturamento.
	 * 
	 * @author Hiroshi Goncalves
	 * @date 10/01/2014
	 */
	private String montarSubSelectPesquisarDescricaoContaMensagemFaturamentoImediato(int campoConsulta, Integer valor){

		int prioridade = 0;
		String ultimaLinha = "";

		switch(campoConsulta){
			case ContaMensagem.SETOR_COMERCIAL:
				prioridade = 1;

				if(valor != null){
					ultimaLinha = "AND STCM_ID = :idSetorComercial ";
				}else{
					ultimaLinha = "AND STCM_ID is null ";
				}

				break;

			case ContaMensagem.LOCALIDADE:
				prioridade = 2;

				if(valor != null){
					ultimaLinha = "AND LOCA_ID = :idLocalidade ";
				}else{
					ultimaLinha = "AND LOCA_ID is null ";
				}

				break;

			case ContaMensagem.GERENCIA_REGIONAL:
				prioridade = 3;

				if(valor != null){
					ultimaLinha = "AND GREG_ID = :idGerenciaRegional ";
				}else{
					ultimaLinha = "AND GREG_ID is null ";
				}

				break;

			case ContaMensagem.GRUPO_FATURAMENTO:
				prioridade = 4;

				if(valor != null){
					ultimaLinha = "AND FTGR_ID = :idFaturamentoGrupo ";
				}else{
					ultimaLinha = "AND FTGR_ID is null ";
				}

				break;

			case ContaMensagem.GERAL:
				prioridade = 5;

				ultimaLinha = "AND STCM_ID is null AND LOCA_ID is null AND GREG_ID is null AND FTGR_ID is null ";

				break;

			default:

				break;
		}

		String retorno = "SELECT CTMS_AMREFERENCIAFATURAMENTO AS AMFATUR, ";
		retorno += prioridade + "  AS PRIORIDADE, ";
		retorno += "  CONTA_MENSAGEM.CTMS_DSCONTAMENSAGEM01 AS MSG1, ";
		retorno += "  CONTA_MENSAGEM.CTMS_DSCONTAMENSAGEM02 AS MSG2, ";
		retorno += "  CONTA_MENSAGEM.CTMS_DSCONTAMENSAGEM03 AS MSG3 ";
		retorno += " FROM CONTA_MENSAGEM ";
		retorno += " WHERE CTMS_AMREFERENCIAFATURAMENTO <= :anoMesFaturamento ";
		retorno += "   AND CTMS_ICUSO = :indicadorUso ";
		retorno += ultimaLinha;

		return retorno;

	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * Obtém o débito automático do imóvel
	 * 
	 * @author Anderson Italo
	 * @date 04/06/2012
	 */
	public DebitoAutomatico pesquisarDebitoAutomaticoImovel(Integer idImovel) throws ErroRepositorioException{

		DebitoAutomatico retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");

		try{
			consulta.append("select debito from DebitoAutomatico debito  ");
			consulta.append("inner join fetch debito.agencia age ");
			consulta.append("inner join fetch age.banco ");
			consulta.append("where debito.imovel.id = :idImovel ");
			consulta.append("and debito.dataExclusao is null ");

			retorno = (DebitoAutomatico) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0002] – Obter Dados da Qualidade Água
	 * Retorna dados da qualidade da água de acordo com o a referência do faturamento e com o setor
	 * comercial.
	 * 
	 * @author Anderson Italo
	 * @date 04/06/2012
	 */
	public QualidadeAgua pesquisarQualidadeAguaPorSetorComercialAnoMesFaturamento(Integer anoMesFaturamento, Integer idSetorComercial)
					throws ErroRepositorioException{

		QualidadeAgua retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select qa from QualidadeAgua qa where qa.anoMesReferencia <= :anoMesFaturamento "
							+ "and qa.setorComercial.id = :idSetorComercial order by qa.anoMesReferencia desc";

			retorno = (QualidadeAgua) session.createQuery(consulta).setInteger("anoMesFaturamento", anoMesFaturamento)
							.setInteger("idSetorComercial", idSetorComercial).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0006] – Obter débitos anteriores
	 * 
	 * @author Anderson Italo
	 * @date 05/06/2012
	 */
	public List obterTotalDebitosContaAnteriores(Integer idCobrancaDocumento) throws ErroRepositorioException{

		List retorno = null;

		Session session = HibernateUtil.getSession();

		try{
			String consulta = " from CobrancaDocumentoItem item inner join fetch item.contaGeral contaGeral "
							+ " inner join fetch contaGeral.conta c "
							+ " where item.cobrancaDocumento.id = :idCobrancaDocumento) order by c.referencia desc ";

			retorno = session.createQuery(consulta).setInteger("idCobrancaDocumento", idCobrancaDocumento).list();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see gcom.faturamento.IRepositorioFaturamento#obterDebitosAnteriores(java.lang.Integer)
	 */
	public List<Conta> obterDebitosAnteriores(Integer idImovel, Integer qtdDiasVencContaAvisoCorte, BigDecimal vlMinDebitosAnteriores,
					Integer idMotivoNegativacao) throws ErroRepositorioException{

		List<Conta> retorno = new ArrayList<Conta>();
		Session session = HibernateUtil.getSession();
		StringBuffer sb = new StringBuffer();

		try{

			sb.append("select cnta from Conta cnta ");
			sb.append("left join cnta.contaMotivoRevisao contaMotivoRevisao ");
			sb.append("inner join cnta.imovel imovel ");
			sb.append("where ");
			sb.append("imovel.id = :idImovel ");
			sb.append("and ");
			sb.append("cnta.dataVencimentoConta < :dataCorrente ");
			sb.append("and ");
			sb.append("(contaMotivoRevisao is null or contaMotivoRevisao.id = :idMotivoNegativacao) ");
			sb.append("and ");
			sb.append("not exists (");
			sb.append("select contaPgt.id from Pagamento pgt ");
			sb.append("inner join pgt.conta contaPgt ");
			sb.append("inner join contaPgt.imovel imovelPgt ");
			sb.append("where imovelPgt.id = :idImovel) ");

			Date dataCorrente = Util.subtrairNumeroDiasDeUmaData(new Date(), qtdDiasVencContaAvisoCorte);

			List<Conta> collContas = session.createQuery(sb.toString()).setInteger("idImovel", idImovel)
							.setInteger("idMotivoNegativacao", idMotivoNegativacao).setDate("dataCorrente", dataCorrente).list();

			for(Conta conta : collContas){

				if(conta.getValorTotal().compareTo(vlMinDebitosAnteriores) == 1){

					retorno.add(conta);

				}

			}

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Atualizar Indicador PDD Conta
	 * Author: Hugo Lima
	 * Data: 27/06/2012
	 * Atualiza o indicador de PDD na tabela de conta
	 * 
	 * @param idConta
	 * @param indicadorPDD
	 * @throws ErroRepositorioException
	 */
	public void atualizarIndicadorPDDDeConta(Integer idConta, Short indicadorPDD, boolean indicadorHistorico)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String atualizarConta;

		try{
			if(!indicadorHistorico){
				atualizarConta = "update Conta cnta set indicadorPDD = :indicadorPDD where cnta.id = :idConta ";
			}else{
				atualizarConta = "update ContaHistorico cnta set indicadorPDD = :indicadorPDD where cnta.id = :idConta ";
			}

			session.createQuery(atualizarConta).setShort("indicadorPDD", indicadorPDD).setInteger("idConta", idConta).executeUpdate();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] Retificar Conta
	 * Alterar a Conta dos Itens do Documento de Cobrança
	 * 
	 * @author Hebert Falcão
	 * @date 12/07/2012
	 */
	public void alterarContaCobrancaDocumentoItem(Integer idContaAntiga, Integer idContaNova) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.cobranca.CobrancaDocumentoItem set cnta_id = :idContaNova ");
			sql.append("where cnta_id = :idContaAntiga ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idContaAntiga", idContaAntiga);
			createQuery.setInteger("idContaNova", idContaNova);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] Retificar Conta
	 * Alterar a Conta da Administração da Cobrança do Imóvel
	 * 
	 * @author Hebert Falcão
	 * @date 12/07/2012
	 */
	public void alterarContaImovelCobrancaAdministrivaItem(Integer idContaAntiga, Integer idContaNova) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.cadastro.imovel.ImovelCobrancaAdministrivaItem set cnta_id = :idContaNova ");
			sql.append("where cnta_id = :idContaAntiga ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idContaAntiga", idContaAntiga);
			createQuery.setInteger("idContaNova", idContaNova);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] Retificar Conta
	 * Alterar a Conta dos Documentos Não Entregues
	 * 
	 * @author Hebert Falcão
	 * @date 12/07/2012
	 */
	public void alterarContaDocumentoNaoEntregue(Integer idContaAntiga, Integer idContaNova) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.faturamento.DocumentoNaoEntregue set cnta_id = :idContaNova ");
			sql.append("where cnta_id = :idContaAntiga ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idContaAntiga", idContaAntiga);
			createQuery.setInteger("idContaNova", idContaNova);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] Retificar Conta
	 * Alterar a Conta dos Itens da Fatura
	 * 
	 * @author Hebert Falcão
	 * @date 12/07/2012
	 */
	public void alterarContaFaturaItem(Integer idContaAntiga, Integer idContaNova) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.faturamento.conta.FaturaItem set cnta_id = :idContaNova ");
			sql.append("where cnta_id = :idContaAntiga ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idContaAntiga", idContaAntiga);
			createQuery.setInteger("idContaNova", idContaNova);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0150] Retificar Conta
	 * Atualizar itens da execução fiscal.
	 * 
	 * @author Gicevalter Couto
	 * @date 10/08/2014
	 */
	public void alterarContaExecucaoFiscalItem(Integer idContaAntiga, Integer idContaNova) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.cadastro.imovel.ImovelCobrancaSituacaoItem imovelCobSitItem ");
			sql.append("   set cnta_id = :idContaNova, ");
			sql.append("       ICSI_ICATUALIZADO = 1, ");
			sql.append("       ICSI_TMULTIMAALTERACAO = :ultimaAlteracao ");
			sql.append("where cnta_id = :idContaAntiga ");
			sql.append("  and ISCB_ID in (select id from gcom.cadastro.imovel.ImovelCobrancaSituacao imovelCobSit ");
			sql.append(" 			    	where imovelCobSit.dataRetiradaCobranca is null) ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idContaAntiga", idContaAntiga);
			createQuery.setInteger("idContaNova", idContaNova);
			createQuery.setDate("ultimaAlteracao", new Date());

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1016] Estornar Pagamentos
	 * Atualizar itens da execução fiscal.
	 * 
	 * @author Gicevalter Couto
	 * @date 12/08/2014
	 */
	public void estornarContaExecucaoFiscalItem(Integer idConta, Date dataEstorno) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.cadastro.imovel.ImovelCobrancaSituacaoItem imovelCobSitItem ");
			sql.append("   set CDST_ID = 1, ");
			sql.append("       ICSI_DTSITUACAODEBITO = :dataEstorno, ");
			sql.append("       ICSI_ICATUALIZADO  = 1, ");
			sql.append("       ICSI_TMULTIMAALTERACAO = :ultimaAlteracao ");
			sql.append("where cnta_id = :idConta ");
			sql.append("  and ISCB_ID in (select id from gcom.cadastro.imovel.ImovelCobrancaSituacao imovelCobSit ");
			sql.append(" 			    	where imovelCobSit.dataRetiradaCobranca is null) ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idConta", idConta);
			createQuery.setDate("ultimaAlteracao", new Date());
			createQuery.setDate("dataEstorno", dataEstorno);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC3082] Atualizar Item Documento Cobrança
	 * Atualizar itens da execução fiscal.
	 * 
	 * @author Gicevalter Couto
	 * @date 12/08/2014
	 */
	public void alterarContaExecucaoFiscalItem(Integer idConta, Integer idSituacaoDebitoItem, Date dataSituacaoDebitoItem)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.cadastro.imovel.ImovelCobrancaSituacaoItem imovelCobSitItem ");
			sql.append("   set CDST_ID = :idSituacaoDebitoItem, ");
			sql.append("       ICSI_DTSITUACAODEBITO = :dataSituacaoDebitoItem, ");
			sql.append("       ICSI_ICATUALIZADO  = 1, ");
			sql.append("       ICSI_TMULTIMAALTERACAO = :ultimaAlteracao ");
			sql.append("where cnta_id = :idConta ");
			sql.append("  and ISCB_ID in (select id from gcom.cadastro.imovel.ImovelCobrancaSituacao imovelCobSit ");
			sql.append(" 			    	where imovelCobSit.dataRetiradaCobranca is null) ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idConta", idConta);
			createQuery.setInteger("idSituacaoDebitoItem", idSituacaoDebitoItem);
			createQuery.setDate("ultimaAlteracao", new Date());
			createQuery.setDate("dataSituacaoDebitoItem", dataSituacaoDebitoItem);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC3082] Atualizar Item Documento Cobrança
	 * Atualizar itens da execução fiscal.
	 * 
	 * @author Gicevalter Couto
	 * @date 12/08/2014
	 */
	public void alterarGuiaPagamentoExecucaoFiscalItem(Integer idGuiaPagamento, Short numeroPrestacao, Integer idSituacaoDebitoItem,
					Date dataSituacaoDebitoItem) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.cadastro.imovel.ImovelCobrancaSituacaoItem imovelCobSitItem ");
			sql.append("   set CDST_ID = :idSituacaoDebitoItem, ");
			sql.append("       ICSI_DTSITUACAODEBITO = :dataSituacaoDebitoItem, ");
			sql.append("       ICSI_ICATUALIZADO  = 1, ");
			sql.append("       ICSI_TMULTIMAALTERACAO = :ultimaAlteracao ");
			sql.append("where GPAG_ID  = :idGuiaPagamento ");
			sql.append("  and ICSI_NNPRESTACAO  = :numeroPrestacao ");
			sql.append("  and ISCB_ID in (select id from gcom.cadastro.imovel.ImovelCobrancaSituacao imovelCobSit ");
			sql.append(" 			    	where imovelCobSit.dataRetiradaCobranca is null) ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idGuiaPagamento", idGuiaPagamento);
			createQuery.setInteger("numeroPrestacao", numeroPrestacao);
			createQuery.setInteger("idSituacaoDebitoItem", idSituacaoDebitoItem);
			createQuery.setDate("ultimaAlteracao", new Date());
			createQuery.setDate("dataSituacaoDebitoItem", dataSituacaoDebitoItem);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1016] Estornar Pagamentos
	 * Atualizar itens da execução fiscal.
	 * 
	 * @author Gicevalter Couto
	 * @date 12/08/2014
	 */
	public void estornarGuiaPagamentoExecucaoFiscalItem(Integer idGuiaPagamento, Short numeroPrestacao, Date dataEstorno)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.cadastro.imovel.ImovelCobrancaSituacaoItem imovelCobSitItem ");
			sql.append("   set CDST_ID = 1, ");
			sql.append("       ICSI_DTSITUACAODEBITO = :dataEstorno, ");
			sql.append("       ICSI_ICATUALIZADO  = 1, ");
			sql.append("       ICSI_TMULTIMAALTERACAO = :ultimaAlteracao ");
			sql.append("where GPAG_ID = :idGuiaPagamento ");
			sql.append("  and ICSI_NNPRESTACAO = :numeroPrestacao ");
			sql.append("  and ISCB_ID in (select id from gcom.cadastro.imovel.ImovelCobrancaSituacao imovelCobSit ");
			sql.append(" 			    	where imovelCobSit.dataRetiradaCobranca is null) ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idGuiaPagamento", idGuiaPagamento);
			createQuery.setShort("numeroPrestacao", numeroPrestacao);
			createQuery.setDate("ultimaAlteracao", new Date());
			createQuery.setDate("dataEstorno", dataEstorno);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC3061] Gerar Relatório Posição do Débito da Negativação – Legado CASAL
	 * Pesquisar as contas em processo de negativação e já transferidas para o histórico
	 * 
	 * @date 28/07/2012
	 * @author Hebert Falcão
	 */
	public Collection<ContaHistorico> pesquisarContaEmProcessoNegativacao(Integer anoMesFaturamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select cnhi ");
			consulta.append("from ContaHistorico cnhi ");
			consulta.append("inner join fetch cnhi.debitoCreditoSituacaoAtual ");
			consulta.append("left join fetch cnhi.contaMotivoCancelamento ");
			consulta.append("left join fetch cnhi.parcelamento ");
			consulta.append("where cnhi.anoMesReferenciaConta <= :anoMesFaturamento ");
			consulta.append("  and cnhi.debitoCreditoSituacaoAtual.id in (:normal, :retificada, :incluida, ");
			consulta.append("                                             :cancelada, :parcelada) ");
			consulta.append("  and cnhi.contaMotivoRevisao.id = :revisaoSPC ");
			consulta.append("  and exists (select iscb.imovel.id ");
			consulta.append("              from ImovelCobrancaSituacao iscb ");
			consulta.append("              where iscb.dataRetiradaCobranca is null ");
			consulta.append("                and iscb.cobrancaSituacao.id = :negativadoLegado ");
			consulta.append("                and iscb.imovel.id = cnhi.imovel.id) ");
			consulta.append("order by cnhi.imovel, cnhi.anoMesReferenciaConta ");

			Query query = session.createQuery(consulta.toString());

			query.setInteger("anoMesFaturamento", anoMesFaturamento);
			query.setInteger("normal", DebitoCreditoSituacao.NORMAL);
			query.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA);
			query.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA);
			query.setInteger("cancelada", DebitoCreditoSituacao.CANCELADA);
			query.setInteger("parcelada", DebitoCreditoSituacao.PARCELADA);
			query.setInteger("revisaoSPC", ContaMotivoRevisao.REVISAO_SPC);
			query.setInteger("negativadoLegado", CobrancaSituacao.NEGATIVADO_LEGADO);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3165] Gerar Relatório Posição do Débito da Negativação - Legado CAGEPA
	 * Pesquisar as contas em processo de negativação e já transferidas para o histórico
	 * 
	 * @date 07/03/2015
	 * @author Luciano Galvão
	 */
	public Collection<ContaHistorico> pesquisarContaEmProcessoNegativacaoCagepa(Integer anoMesFaturamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			// cnhi
			consulta.append("select cnhi ");
			consulta.append("from gcom.cadastro.imovel.ImovelCobrancaSituacaoItem icsItem ");
			consulta.append("inner join icsItem.imovelCobrancaSituacao ics ");
			consulta.append("inner join icsItem.contaGeral cntaGeral ");
			consulta.append("inner join cntaGeral.contaHistorico cnhi ");
			consulta.append("left join fetch cnhi.debitoCreditoSituacaoAtual ");
			consulta.append("left join fetch cnhi.contaMotivoCancelamento ");
			consulta.append("left join fetch cnhi.parcelamento ");
			consulta.append("where  ");
			consulta.append("cnhi.anoMesReferenciaConta <= :anoMesFaturamento ");
			consulta.append("and ics.dataRetiradaCobranca is null ");
			consulta.append("and ics.cobrancaSituacao.id = :negativadoLegado ");
			consulta.append("and not exists (select id from gcom.cadastro.imovel.ImovelCobrancaSituacaoItem icsItem1 ");
			consulta.append("				  where icsItem1.imovelCobrancaSituacao.id = ics.id ");
			consulta.append("			        and exists (select id from Conta c where c.id = icsItem1.contaGeral.id)) ");
			
			Query query = session.createQuery(consulta.toString());

			query.setInteger("anoMesFaturamento", anoMesFaturamento);
			query.setInteger("negativadoLegado", CobrancaSituacao.NEGATIVADO_LEGADO);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0187] Inserir Guia de Pagamento
	 * Processos das execuções especiais pendentes de cobrança do valor de sucumbência
	 * 
	 * @date 08/09/2014
	 * @author Gicevalter Couto
	 * @date 20/10/2014S
	 * @author Saulo Lima
	 */
	public Collection<Integer> pesquisarProcessosExecucaoEspeciaisPendentesCobranca(Integer idImovel, Integer idCobrancaSituacaoExecFiscal,
					Integer idSucumbencia) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select imovelCobSit.numeroProcessoAdministrativoExecucaoFiscal ");
			consulta.append("from ImovelCobrancaSituacao imovelCobSit ");
			consulta.append("where imovelCobSit.imovel.id = :idImovel ");
			consulta.append("  and imovelCobSit.cobrancaSituacao.id = :idCobrancaSituacao ");
			consulta.append("  and imovelCobSit.numeroProcessoAdministrativoExecucaoFiscal not in ( ");
			consulta.append("     select distinct gppe.comp_id.numeroProcessoAdministrativoExecucaoFiscal ");
			consulta.append("     from GuiaPagamentoPrestacao gppe ");
			consulta.append("     where gppe.debitoCreditoSituacao.id = 0 ");
			consulta.append("     and gppe.debitoTipo.id = :idSucumbencia) ");
			consulta.append("  and numeroProcessoAdministrativoExecucaoFiscal not in ( ");
			consulta.append("     select distinct gpph.comp_id.numeroProcessoAdministrativoExecucaoFiscal ");
			consulta.append("     from GuiaPagamentoPrestacaoHistorico gpph ");
			consulta.append("     where gpph.debitoCreditoSituacao.id = 0 ");
			consulta.append("     and gpph.debitoTipo.id = :idSucumbencia) ");
			consulta.append("order by imovelCobSit.numeroProcessoAdministrativoExecucaoFiscal ");
			
			Query query = session.createQuery(consulta.toString());

			query.setInteger("idImovel", idImovel);
			query.setInteger("idCobrancaSituacao", idCobrancaSituacaoExecFiscal);
			query.setInteger("idSucumbencia", idSucumbencia);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa as contas pertencentes a matricula passada
	 * 
	 * @author Jose Claudio
	 * @date 08/08/2012
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean existePermissaoImovelConta(Integer idConta, Integer idImovel) throws ErroRepositorioException{

		boolean retorno = false;
		Collection collRetorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = " select distinct * from Conta c " + " inner join Cliente_Imovel ci on ci.IMOV_ID = c.IMOV_ID "
							+ " where c.IMOV_ID = :idImovel and c.CNTA_ID = :idConta ";

			collRetorno = session.createSQLQuery(consulta).setInteger("idConta", idConta).setInteger("idImovel", idImovel).list();

			if(collRetorno != null && !collRetorno.isEmpty()){
				retorno = true;
			}else{
				retorno = false;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0614] Gerar Resumo das Ações de Cobrança Eventuais
	 * 
	 * @author Anderson Italo
	 * @date 13/07/2012
	 */
	public List<FaturamentoAtividadeCronograma> pesquisarFaturamentoAtividadeCronograma(Integer idFaturamentoGrupoCronogramaMensal,
					String idsFaturamentoAtividades) throws ErroRepositorioException{

		List<FaturamentoAtividadeCronograma> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("select fac.id from FaturamentoAtividadeCronograma fac left join fac.faturamentoAtividade fa ");
			consulta.append("left join fac.faturamentoGrupoCronogramaMensal fgcm where fa.id in (:idFaturamentoAtividade) ");

			if(idFaturamentoGrupoCronogramaMensal != null){

				consulta.append("and fgcm.id = :idFaturamentoGrupoCronogramaMensal ");

				retorno = (List<FaturamentoAtividadeCronograma>) session.createQuery(consulta.toString())
								.setInteger("idFaturamentoGrupoCronogramaMensal", idFaturamentoGrupoCronogramaMensal)
								.setString("idFaturamentoAtividade", idsFaturamentoAtividades).list();
			}else{

				consulta.append("and fac.dataRealizacao is not null ");

				retorno = (List<FaturamentoAtividadeCronograma>) session.createQuery(consulta.toString())
								.setString("idFaturamentoAtividade", idsFaturamentoAtividades).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0150] Retificar Conta
	 * Alterar a Conta dos Boletos Bancarios
	 * 
	 * @author Hebert Falcão
	 * @date 15/08/2012
	 */
	public void alterarContaBoletoBancario(Integer idContaAntiga, Integer idContaNova) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			StringBuffer sql = new StringBuffer();

			sql.append("update gcom.cobranca.BoletoBancario set cnta_id = :idContaNova ");
			sql.append("where cnta_id = :idContaAntiga ");

			Query createQuery = session.createQuery(sql.toString());
			createQuery.setInteger("idContaAntiga", idContaAntiga);
			createQuery.setInteger("idContaNova", idContaNova);

			createQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Retorna a lista de ids tipos de debitos dos itens de parcelamento (prestacoes)
	 * 
	 * @author Hugo Lima
	 * @date 15/08/2012
	 * @param idParcelamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> obterDebitosGuiasPagamentoPrestacoesParcelamento(Integer idParcelamento) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select gppr.dbtp_id as idTipoDebito  ");
			consulta.append(" from guia_pagamento_prestacao gppr ");
			consulta.append(" where (gppr.gpag_id) in ( ");
			consulta.append("   select gpag.gpag_id ");
			consulta.append("   from guia_pagamento gpag ");
			consulta.append("   where gpag.parc_id = :idParcelamento ");
			consulta.append("   ) ");

			retorno = session.createSQLQuery(consulta.toString()).addScalar("idTipoDebito", Hibernate.INTEGER)
							.setInteger("idParcelamento", idParcelamento).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Count do Gerar Relacao Acompanhamento Faturamento
	 * [UC0336] GerarRelacaoAcompanhamentoFaturamento
	 * 
	 * @author Jose Claudio
	 * @date 29/08/2012
	 */
	public Integer gerarRelacaoAcompanhamentoFaturamentoCount(String idImovelCondominio, String idImovelPrincipal, String idNomeConta,
					String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
					String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
					String intervaloValorPercentualEsgotoInicial, String intervaloValorPercentualEsgotoFinal,
					String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
					String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
					String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
					String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal, String idCadastroOcorrencia,
					String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial, String idLocalidadeFinal,
					String setorComercialInicial, String setorComercialFinal, String quadraInicial, String quadraFinal, String loteOrigem,
					String loteDestno, String cep, String logradouro, String bairro, String municipio, String idTipoMedicao,
					String indicadorMedicao, String idSubCategoria, String idCategoria, String quantidadeEconomiasInicial,
					String quantidadeEconomiasFinal, String diaVencimento, String idCliente, String idClienteTipo,
					String idClienteRelacaoTipo, String numeroPontosInicial, String numeroPontosFinal, String numeroMoradoresInicial,
					String numeroMoradoresFinal, String idAreaConstruidaFaixa, String consumoFixadoEsgotoPocoInicial,
					String consumoFixadoEsgotoPocoFinal) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select distinct count(*) "
							+ " from ImovelSubcategoria imovelSubcategoria "
							+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
							+ " left  join  imovelSubcategoria.comp_id.subcategoria subcategoria "
							+ " left join subcategoria.categoria categoria   "
							+ " inner join imovel.localidade localidade   "
							+ " inner join localidade.gerenciaRegional gerenciaRegional "
							+ " inner join imovel.setorComercial setorComercial   "
							+ " left  join imovel.logradouroBairro logradouroBairro  "
							+ " left  join logradouroBairro.bairro bairro   "
							+ " left  join bairro.municipio municipio   "
							+ " left  join imovel.logradouroBairro logradouroBairro "
							+ " left  join logradouroBairro.bairro bairro   "
							+ " inner join imovel.quadra quadra   "
							+ " left  join imovel.logradouroCep logradouroCep "
							+ " left  join logradouroCep.cep cep   "
							+ " left  join imovel.logradouroCep logradouroCep "
							+ " left  join logradouroCep.logradouro logradouro   "
							+ " left  join imovel.imovelCondominio imovelCondominio   "
							+ " left  join imovel.imovelPrincipal imovelPrincipal   "
							// + " left join imovel.nomeConta nomeConta "
							+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ " left  join imovel.ligacaoAgua ligacaoAgua  "
							+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
							+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  "
							+ " left  join imovel.imovelPerfil imovelPerfil  "
							+ " left  join imovel.pocoTipo pocoTipo   "
							+ " left  join imovel.faturamentoTipo faturamentoTipo "
							+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
							+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
							+ " left  join imovel.eloAnormalidade eloAnormalidade   "
							+ " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
							+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  "
							+ " left  join imovel.consumoTarifa consumoTarifa   "
							+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ " left  join imovel.ligacaoAgua ligacaoAgua   "
							+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
							+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
							+ " left  join imovel.ligacaoAgua ligacaoAgua   "
							+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
							+ " left join imovel.consumosHistoricos consumosHistorico   "
							+ " left join imovel.medicaoHistoricos medicaoHistorico   "
							+ " left join imovel.clienteImoveis clienteImoveis "
							+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo "
							+ " left join clienteImoveis.cliente cliente "
							+ " left join cliente.clienteTipo clienteTipo "
							+ " left join imovel.consumosHistoricos consumosHistorico "
							+ " left outer join imovel.clienteImoveis clienteImoveisUsuario with (clienteImoveisUsuario.clienteRelacaoTipo.id = "
							+ ClienteRelacaoTipo.USUARIO.toString() + ") and clienteImoveisUsuario.dataFimRelacao is null "
							+ " left outer join clienteImoveisUsuario.cliente clienteUsuario ";

			consulta = consulta
							+ montarCondicaoWhereFiltrarImovelOutrosCriterio(idImovelCondominio, idImovelPrincipal, idNomeConta,
											idSituacaoLigacaoAgua, consumoMinimoInicialAgua, consumoMinimoFinalAgua,
											idSituacaoLigacaoEsgoto, consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
											intervaloValorPercentualEsgotoInicial, intervaloValorPercentualEsgotoFinal,
											intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal,
											intervaloMediaMinimaHidrometroInicial, intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
											idPocoTipo, idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
											idEloAnormalidade, areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia,
											idConsumoTarifa, idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal,
											setorComercialInicial, setorComercialFinal, quadraInicial, quadraFinal, loteOrigem, loteDestno,
											cep, logradouro, bairro, municipio, idTipoMedicao, indicadorMedicao, idSubCategoria,
											idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal, diaVencimento, idCliente,
											idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal,
											numeroMoradoresInicial, numeroMoradoresFinal, idAreaConstruidaFaixa,
											consumoFixadoEsgotoPocoInicial, consumoFixadoEsgotoPocoFinal);

			/*
			 * # COLOCANDO O VALOR NAS CONDIÇÕES#
			 */

			/*
			 * consulta = consulta + " consumosHistorico.referenciaFaturamento = " +
			 * "(select max(consumoHistorico.referenciaFaturamento) from
			 * ConsumoHistorico consumoHistorico " + " left join
			 * consumoHistorico.imovel imovelConsumoHistorico " + "where
			 * imovelConsumoHistorico.id = imovel.id) and ";
			 */

			Query query = session.createQuery(consulta.substring(0, (consulta.length() - 5)));

			informarDadosQueryFiltrarImovelOutrosCriterio(query, idImovelCondominio, idImovelPrincipal, idNomeConta, idSituacaoLigacaoAgua,
							consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto, consumoMinimoInicialEsgoto,
							consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial, intervaloValorPercentualEsgotoFinal,
							intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal, intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal, idImovelPerfil, idPocoTipo, idFaturamentoSituacaoTipo,
							idCobrancaSituacaoTipo, idSituacaoEspecialCobranca, idEloAnormalidade, areaConstruidaInicial,
							areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa, idGerenciaRegional, idLocalidadeInicial,
							idLocalidadeFinal, setorComercialInicial, setorComercialFinal, quadraInicial, quadraFinal, loteOrigem,
							loteDestno, cep, logradouro, bairro, municipio, idTipoMedicao, indicadorMedicao, idSubCategoria, idCategoria,
							quantidadeEconomiasInicial, quantidadeEconomiasFinal, diaVencimento, idCliente, idClienteTipo,
							idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal, numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa, consumoFixadoEsgotoPocoInicial, consumoFixadoEsgotoPocoFinal);

			retorno = ((Number) query.uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Diogo Monteiro
	 * @date 03/09/2012
	 * @param anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> obterValorTotalContasSelicionadas(String anoMesFaturamento) throws ErroRepositorioException{

		Collection retorno = null;

		Integer anoMes = Integer.valueOf(anoMesFaturamento);

		Session session = HibernateUtil.getSession();

		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select sum(CNTA_VLAGUA+CNTA_VLESGOTO+CNTA_VLDEBITOS-CNTA_VLCREDITOS-CNTA_VLIMPOSTOS)  ");
			consulta.append(" from   CONTA CTA ");
			consulta.append(" inner join IMOVEL IMO on IMO.IMOV_ID = CTA.IMOV_ID ");
			consulta.append(" inner join CLIENTE_CONTA CLCU on CTA.CNTA_ID = CLCU.CNTA_ID ");
			consulta.append("   and CLCU.CRTP_ID = 2 ");
			consulta.append(" inner join CLIENTE CLU on CLCU.CLIE_ID = CLU.CLIE_ID ");
			consulta.append(" inner join LOGRADOURO L on L.LOGR_ID = IMO.LOGR_ID ");
			consulta.append(" left outer join LOGRADOURO_TIPO LT on LT.LGTP_ID = L.LGTP_ID ");
			consulta.append(" left outer join LOGRADOURO_TITULO LTT on LTT.LGTT_ID = L.LGTP_ID ");
			consulta.append(" where  CTA.DCST_IDATUAL in (0,1,2,4) ");
			consulta.append(" and  CTA.CNTA_AMREFERENCIACONTA = :anoMes ");
			consulta.append(" and  CTA.CNTA_DTVENCIMENTOCONTA > current_date ");

			retorno = session.createSQLQuery(consulta.toString()).setInteger("anoMes", anoMes).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna os registros de movimento roteiro empresa para a referência e grupo informado
	 * 
	 * @author Anderson Italo
	 * @date 13/11/2012
	 */
	public Collection<MovimentoRoteiroEmpresa> pesquisarDadosMovimentoRoteiroEmpresaAjuste1(Integer anoMesFaturamento, Integer idRota)
					throws ErroRepositorioException{

		Collection<MovimentoRoteiroEmpresa> retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select mov from MovimentoRoteiroEmpresa mov where "
							+ " mov.rota.id = :idRota and mov.anoMesMovimento = :anoMesFaturamento and mov.indicadorFase in (1,2) "
							+ " and ((mov.descricaoRubrica1 is not null and mov.descricaoRubrica3 is null) "
							+ " or (mov.descricaoRubrica4 is not null and mov.descricaoRubrica6 is null) "
							+ " or (mov.descricaoRubrica7 is not null and mov.descricaoRubrica9 is null) "
							+ " or (mov.descricaoRubrica10 is not null and mov.descricaoRubrica12 is null) "
							+ " or (mov.descricaoRubrica13 is not null and mov.descricaoRubrica15 is null) ) ";

			retorno = (Collection<MovimentoRoteiroEmpresa>) session.createQuery(consulta).setInteger("idRota", idRota)
							.setInteger("anoMesFaturamento", anoMesFaturamento).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém a conta do imóvel pela referência informada
	 * 
	 * @author Anderson Italo
	 * @date 13/11/2012
	 */
	public Conta pesquisarContaDaReferenciaPorImovel(Integer idImovel, Integer anoMesReferencia, String idsDebitoCreditoSituacaoAtual)
					throws ErroRepositorioException{

		Conta retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select contaImovel from Conta contaImovel  where ");
			consulta.append("contaImovel.imovel.id = :idImovel ");
			consulta.append("and contaImovel.referencia =  :anoMesReferencia ");

			if(idsDebitoCreditoSituacaoAtual != null){

				consulta.append("and contaImovel.debitoCreditoSituacaoAtual.id in (" + idsDebitoCreditoSituacaoAtual.toString() + ")");
			}

			retorno = (Conta) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém os débitos cobrados da conta pra referência informada
	 * 
	 * @author Anderson Italo
	 * @date 13/11/2012
	 */
	public Collection<DebitoCobrado> pesquisarDebitosCobradoDaConta(Integer idConta, Integer idDebitoTipo, Short numeroPrestacao,
					Short numeroPrestacaoDebito) throws ErroRepositorioException{

		Collection<DebitoCobrado> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select debito from DebitoCobrado debito  ");
			consulta.append("inner join fetch debito.debitoTipo debtipo where ");
			consulta.append("debito.conta.id = :idConta ");

			if(idDebitoTipo != null){

				consulta.append("and debito.numeroPrestacao = :numeroPrest ");
				consulta.append("and debito.numeroPrestacaoDebito = :numeroPrestacaoDeb ");
				consulta.append("and debtipo.id = :idDebitoTipo ");
				consulta.append("order by debito.valorPrestacao desc ");

				retorno = session.createQuery(consulta.toString()).setInteger("idConta", idConta).setShort("numeroPrest", numeroPrestacao)
								.setShort("numeroPrestacaoDeb", numeroPrestacaoDebito).setInteger("idDebitoTipo", idDebitoTipo).list();
			}else{

				consulta.append("order by debito.valorPrestacao desc ");
				retorno = session.createQuery(consulta.toString()).setInteger("idConta", idConta).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém os débitos a cobrar do imóvel pra referência informada
	 * 
	 * @author Anderson Italo
	 * @date 13/11/2012
	 */
	public Collection<DebitoACobrar> pesquisarDebitosACobrarDoImovel(Integer idImovel, Integer anoMesReferencia, Integer idDebitoTipo,
					Short numeroPrestacaoDebito) throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select debito from DebitoACobrar debito  ");
			consulta.append("inner join fetch debito.debitoTipo debtipo where ");
			consulta.append("debito.imovel.id = :idImovel ");
			consulta.append("and debito.anoMesCobrancaDebito = :anoMesCobranca ");
			consulta.append("and debtipo.id = :idDebitoTipo ");
			consulta.append("and debito.numeroPrestacaoDebito = :numeroPrestacaoDeb ");

			retorno = session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesCobranca", anoMesReferencia).setInteger("idDebitoTipo", idDebitoTipo)
							.setShort("numeroPrestacaoDeb", numeroPrestacaoDebito).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém o pagamento da conta
	 * 
	 * @author Anderson Italo
	 * @date 13/11/2012
	 */
	public Pagamento pesquisarPagamentoConta(Integer idConta, Integer anoMesReferencia) throws ErroRepositorioException{

		Pagamento retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select pag from Pagamento pag  where ");
			consulta.append("pag.conta.id = :idConta ");
			consulta.append("and pag.anoMesReferenciaPagamento =  :anoMesReferencia ");

			retorno = (Pagamento) session.createQuery(consulta.toString()).setInteger("idConta", idConta)
							.setInteger("anoMesReferencia", anoMesReferencia).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna os registros de movimento roteiro empresa para a referência e grupo informado
	 * 
	 * @author Anderson Italo
	 * @date 13/11/2012
	 */
	public Collection<MovimentoRoteiroEmpresa> pesquisarDadosMovimentoRoteiroEmpresaAjuste2(Integer anoMesFaturamento, Integer idRota)
					throws ErroRepositorioException{

		Collection<MovimentoRoteiroEmpresa> retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String consulta = "select mov from MovimentoRoteiroEmpresa mov where "
							+ " mov.rota.id = :idRota and mov.anoMesMovimento = :anoMesFaturamento and mov.indicadorFase in (1,2) ";

			retorno = (Collection<MovimentoRoteiroEmpresa>) session.createQuery(consulta).setInteger("idRota", idRota)
							.setInteger("anoMesFaturamento", anoMesFaturamento).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Yara Souza
	 * @date 15/11/2012
	 */
	public Collection pesquisarContaHistoricoDaReferenciaPorRota(Integer idRota, Integer anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select contaImovel from ContaHistorico contaImovel   ");
			consulta.append("inner join fetch contaImovel.imovel imovel  ");
			consulta.append("inner join  imovel.rota rota ");
			consulta.append("where rota.id = :idRota ");
			consulta.append("and contaImovel.anoMesReferenciaConta =  :anoMesReferencia ");
			consulta.append("and contaImovel.debitoCreditoSituacaoAtual.id in (" + DebitoCreditoSituacao.NORMAL + ","
							+ DebitoCreditoSituacao.PARCELADA + ")");

			retorno = (Collection) session.createQuery(consulta.toString()).setInteger("idRota", idRota)
							.setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Yara Souza
	 * @date 15/11/2012
	 */

	public Collection pesquisarContaDaReferenciaPorRota(Integer idRota, Integer anoMesReferencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select contaImovel from Conta contaImovel   ");
			consulta.append("inner join fetch contaImovel.imovel imovel ");
			consulta.append("inner join  imovel.rota rota ");
			consulta.append("where rota.id = :idRota ");
			consulta.append("and contaImovel.referencia = :anoMesReferencia ");
			consulta.append("and contaImovel.debitoCreditoSituacaoAtual.id in (" + DebitoCreditoSituacao.NORMAL + " ) ");

			retorno = (Collection) session.createQuery(consulta.toString()).setInteger("idRota", idRota)
							.setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public EmitirContaHelper pesquisarContaHelper(Integer idConta) throws ErroRepositorioException{

		EmitirContaHelper retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT " + " new " + EmitirContaHelper.class.getName() + " ( " + "cnt.id, " + "cnt.referencia, "
							+ "cnt.consumoAgua, " + "cnt.consumoEsgoto, " + "cnt.valorAgua, " + "cnt.valorEsgoto, " + "cnt.debitos, "
							+ "cnt.valorCreditos, " + "cnt.valorImposto, " + "imovel.id, " + "ligacaoAguaSituacao.id, "
							+ "ligacaoEsgotoSituacao.id, " + "ligacaoAguaSituacao.indicadorFaturamentoSituacao,"
							+ "ligacaoEsgotoSituacao.indicadorFaturamentoSituacao,  " + " cnt.consumoTarifa.id , cnt.percentualEsgoto  ) "
							+ "from Conta cnt " + "INNER JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "INNER JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao " + "INNER JOIN cnt.imovel imovel "
							+ "WHERE  cnt.id = :idConta ";

			retorno = (EmitirContaHelper) session.createQuery(consulta).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public EmitirContaHelper pesquisarContaHistoricoHelper(Integer idConta) throws ErroRepositorioException{

		EmitirContaHelper retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT " + " new " + EmitirContaHelper.class.getName() + " ( " + "cnt.id, " + "cnt.anoMesReferenciaConta, "
							+ "cnt.consumoAgua, " + "cnt.consumoEsgoto, " + "cnt.valorAgua, " + "cnt.valorEsgoto, " + "cnt.valorDebitos, "
							+ "cnt.valorCreditos, " + "cnt.valorImposto, " + "imovel.id, " + "ligacaoAguaSituacao.id, "
							+ "ligacaoEsgotoSituacao.id, " + "ligacaoAguaSituacao.indicadorFaturamentoSituacao,"
							+ "ligacaoEsgotoSituacao.indicadorFaturamentoSituacao,  " + " cnt.consumoTarifa.id , cnt.percentualEsgoto  ) "
							+ "from ContaHistorico cnt " + "INNER JOIN cnt.ligacaoAguaSituacao ligacaoAguaSituacao "
							+ "INNER JOIN cnt.ligacaoEsgotoSituacao ligacaoEsgotoSituacao " + "INNER JOIN cnt.imovel imovel "
							+ "WHERE  cnt.id = :idConta ";

			retorno = (EmitirContaHelper) session.createQuery(consulta).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Verificar existência de movimento para a conta
	 * 
	 * @author Anderson Italo
	 * @date 02/11/2012
	 * @return Object
	 * @exception ErroRepositorioException
	 */
	public Object verificarExistenciaDebitoAutomaticoMovimentoConta(Integer idConta) throws ErroRepositorioException{

		Object retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select mt.id from DebitoAutomaticoMovimento mt ");
			consulta.append("where mt.contaGeral.id = :idConta ");

			retorno = session.createQuery(consulta.toString()).setInteger("idConta", idConta).setMaxResults(1).uniqueResult();
		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna os débitos a cobrar a serem cancelados
	 * 
	 * @author Anderson Italo
	 * @date 26/11/2012
	 */
	public Collection<Object[]> pesquisarDebitoACobrarParaCancelar() throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String consulta = " select dbac_id, imov_id from debito_a_cobrar where  dbac_amcobrancadebito = 999999 and dbac_nndiassuspensao = 9999 ";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna a existência de débitos a cobrar de rateio
	 * 
	 * @author Carlos Chrystian
	 * @date 07/12/2012
	 */
	public Integer pesquisarExistenciaRateio(Integer idImovel, int anoMesReferencia, String parametroDebitoTipoRateio)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select count(*) as total from debito_a_cobrar where imov_id = :imovel and dbtp_id = :parametroDebitoTipoRateio and dbac_amreferenciadebito = :anoMesReferencia ";

			retorno = (Integer) session.createSQLQuery(consulta).addScalar("total", Hibernate.INTEGER).setInteger("imovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia)
							.setString("parametroDebitoTipoRateio", parametroDebitoTipoRateio).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna a soma dos débitos a cobrar do imóvel
	 * 
	 * @author Carlos Chrystian
	 * @date 11/12/2012
	 */
	public BigDecimal somaValorDebitoACobrarImovel(Integer idImovel, Integer anoMesReferencia) throws ErroRepositorioException{

		// cria a variável que vai armazenar o valor pesquisado
		BigDecimal retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		StringBuffer consulta = new StringBuffer();

		try{
			// constroi o hql
			consulta.append("select sum(debito.valorDebito) from DebitoACobrar debito ");
			consulta.append("where debito.imovel.id = :idImovel ");
			consulta.append("and debito.anoMesCobrancaDebito <= :anoMesReferencia ");

			// executa o hql
			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
			consulta = null;
		}

		return retorno;
	}

	/**
	 * Obtém somatório dos débitos cobrados da conta pra referência, tipo de débito e prestação
	 * informada
	 * 
	 * @author Anderson Italo
	 * @date 09/12/2012
	 */
	public BigDecimal pesquisarSomatorioDebitosCobradoDaContaOriginal(Integer idConta, Integer idDebitoTipo, Short numeroPrestacao,
					Short numeroPrestacaoDebito) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select sum(debito.valorPrestacao) from DebitoCobradoHistorico debito  ");
			consulta.append(" where debito.contaHistorico.id = :idConta ");

			if(idDebitoTipo != null){

				consulta.append(" and debito.numeroPrestacao = :numeroPrest ");
				consulta.append(" and debito.numeroPrestacaoDebito = :numeroPrestacaoDeb ");
				consulta.append(" and debito.debitoTipo.id = :idDebitoTipo ");

				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta)
								.setShort("numeroPrest", numeroPrestacao).setShort("numeroPrestacaoDeb", numeroPrestacaoDebito)
								.setInteger("idDebitoTipo", idDebitoTipo).setMaxResults(1).uniqueResult();
			}else{

				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setMaxResults(1)
								.uniqueResult();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public DebitoACobrar pesquisarDebitosACobrarDoImovel(Integer idImovel, Integer anoMesCobranca, Integer idDebitoTipo)
					throws ErroRepositorioException{

		DebitoACobrar retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select debito from DebitoACobrar debito  ");
			consulta.append(" inner join fetch debito.debitoTipo debtipo where ");
			consulta.append(" debito.imovel.id = :idImovel ");
			consulta.append(" and debito.numeroPrestacaoCobradas = 1 ");
			consulta.append(" and debito.numeroPrestacaoDebito = 0 ");
			consulta.append(" and debtipo.id = :idDebitoTipo ");
			consulta.append(" and debito.anoMesCobrancaDebito = : anoMes");

			retorno = (DebitoACobrar) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("idDebitoTipo", idDebitoTipo).setInteger("anoMes", anoMesCobranca).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Conta pesquisarContaAtualRetificada(Integer idImovel, Integer anoMesReferencia) throws ErroRepositorioException{

		Conta retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select contaImovel from Conta contaImovel  where ");
			consulta.append(" contaImovel.imovel.id = :idImovel ");
			consulta.append(" and contaImovel.referencia =  :anoMesReferencia ");
			consulta.append(" and contaImovel.debitoCreditoSituacaoAtual.id = " + DebitoCreditoSituacao.RETIFICADA.toString());
			consulta.append(" and contaImovel.usuario.id =  " + Usuario.getIdUsuarioBatchParametro().toString());
			consulta.append(" and contaImovel.contaMotivoRetificacao.id = 36 ");

			retorno = (Conta) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public ContaHistorico pesquisarContaOriginalRetificada(Integer idImovel, Integer anoMesReferencia) throws ErroRepositorioException{

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		Date dataInicialPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:35:00");
		Date dataFinalPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:59:00");
		Date dataInicialSegundoAjuste = Util.converteStringParaDateHora("29/11/2012 00:00:00");
		Date dataFinalSegundoAjuste = Util.converteStringParaDateHora("29/11/2012 00:30:00");
		Date dataInicialTerceiroAjuste = Util.converteStringParaDateHora("04/12/2012 21:00:00");
		Date dataFinalTerceiroAjuste = Util.converteStringParaDateHora("04/12/2012 21:40:00");
		Date dataInicialQuartoAjuste = Util.converteStringParaDateHora("05/12/2012 00:00:00");
		Date dataFinalQuartoAjuste = Util.converteStringParaDateHora("05/12/2012 02:00:00");
		Date dataInicialQuintoAjuste = Util.converteStringParaDateHora("05/12/2012 08:40:00");
		Date dataFinalQuintoAjuste = Util.converteStringParaDateHora("05/12/2012 10:30:00");
		Date dataInicialAjusteQtdRubrica = Util.converteStringParaDateHora("27/11/2012 22:00:00");
		Date dataFinalAjusteQtdRubrica = Util.converteStringParaDateHora("27/11/2012 23:34:59");

		try{

			consulta.append(" select contaImovel from ContaHistorico contaImovel  where ");
			consulta.append(" contaImovel.imovel.id = :idImovel ");
			consulta.append(" and contaImovel.anoMesReferenciaConta =  :anoMesReferencia ");
			consulta.append(" and contaImovel.debitoCreditoSituacaoAtual.id = "
							+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO.toString());
			consulta.append(" and contaImovel.usuario.id =  " + Usuario.getIdUsuarioBatchParametro().toString());
			consulta.append(" and ( ");
			consulta.append(" (contaImovel.contaHistorico between :dataInicialPrimeiroAjuste ");
			consulta.append(" and :dataFinalPrimeiroAjuste) ");
			consulta.append(" or (contaImovel.contaHistorico between :dataInicialSegundoAjuste ");
			consulta.append(" and :dataFinalSegundoAjuste) ");
			consulta.append(" or (contaImovel.contaHistorico between :dataInicialTerceiroAjuste ");
			consulta.append(" and :dataFinalTerceiroAjuste) ");
			consulta.append(" or (contaImovel.contaHistorico between :dataInicialQuartoAjuste ");
			consulta.append(" and :dataFinalQuartoAjuste) ");
			consulta.append(" or (contaImovel.contaHistorico between :dataInicialQuintoAjuste ");
			consulta.append(" and :dataFinalQuintoAjuste) ");
			consulta.append(" or (contaImovel.contaHistorico between :dataInicialAjusteQtdRubrica ");
			consulta.append(" and :dataFinalAjusteQtdRubrica) ");
			consulta.append(")");
			consulta.append(" order by contaImovel.id desc ");

			retorno = (ContaHistorico) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia)
							.setTimestamp("dataInicialPrimeiroAjuste", dataInicialPrimeiroAjuste)
							.setTimestamp("dataFinalPrimeiroAjuste", dataFinalPrimeiroAjuste)
							.setTimestamp("dataInicialSegundoAjuste", dataInicialSegundoAjuste)
							.setTimestamp("dataFinalSegundoAjuste", dataFinalSegundoAjuste)
							.setTimestamp("dataInicialTerceiroAjuste", dataInicialTerceiroAjuste)
							.setTimestamp("dataFinalTerceiroAjuste", dataFinalTerceiroAjuste)
							.setTimestamp("dataInicialQuartoAjuste", dataInicialQuartoAjuste)
							.setTimestamp("dataFinalQuartoAjuste", dataFinalQuartoAjuste)
							.setTimestamp("dataInicialQuintoAjuste", dataInicialQuintoAjuste)
							.setTimestamp("dataFinalQuintoAjuste", dataFinalQuintoAjuste)
							.setTimestamp("dataInicialAjusteQtdRubrica", dataInicialAjusteQtdRubrica)
							.setTimestamp("dataFinalAjusteQtdRubrica", dataFinalAjusteQtdRubrica).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<ContaHistorico> pesquisarContaRetificadaOutroUsuarioPeriodo(Integer idImovel, Integer anoMesReferencia,
					Date dataInicialPrimeiroAjuste) throws ErroRepositorioException{

		Collection<ContaHistorico> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select contaImovel from ContaHistorico contaImovel  where ");
			consulta.append(" contaImovel.imovel.id = :idImovel ");
			consulta.append(" and contaImovel.anoMesReferenciaConta =  :anoMesReferencia ");
			consulta.append(" and contaImovel.debitoCreditoSituacaoAtual.id = "
							+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO.toString());
			consulta.append(" and contaImovel.usuario.id <>  " + Usuario.getIdUsuarioBatchParametro().toString());
			consulta.append(" and (contaImovel.contaHistorico between :dataInicialPrimeiroAjuste ");
			consulta.append(" and :dataCorrente) ");
			consulta.append(" order by contaImovel.id ");

			retorno = (Collection<ContaHistorico>) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia)
							.setTimestamp("dataInicialPrimeiroAjuste", dataInicialPrimeiroAjuste).setTimestamp("dataCorrente", new Date())
							.list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<DebitoCobradoHistorico> pesquisarDebitosCobradoDaContaOriginal(Integer idConta) throws ErroRepositorioException{

		Collection<DebitoCobradoHistorico> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select debito from DebitoCobradoHistorico debito  ");
			consulta.append(" inner join fetch debito.debitoTipo debtipo where ");
			consulta.append(" debito.contaHistorico.id = :idConta ");
			consulta.append(" order by debtipo.id, debito.numeroPrestacao, debito.numeroPrestacaoDebito ");

			retorno = session.createQuery(consulta.toString()).setInteger("idConta", idConta).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public BigDecimal pesquisarSomatorioDebitosACobrarNaoFaturadosGeradoPrimeiroAjuste(Integer idImovel, Integer anoMesReferenciaDebito,
					Integer anoMesCobranca, Integer idDebitoTipo) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		Date dataInicialPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:35:00");
		Date dataFinalPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:59:00");
		Date dataInicialSegundoAjuste = Util.converteStringParaDateHora("29/11/2012 00:00:00");
		Date dataFinalSegundoAjuste = Util.converteStringParaDateHora("29/11/2012 00:30:00");
		Date dataInicialTerceiroAjuste = Util.converteStringParaDateHora("04/12/2012 21:00:00");
		Date dataFinalTerceiroAjuste = Util.converteStringParaDateHora("04/12/2012 21:40:00");
		Date dataInicialQuartoAjuste = Util.converteStringParaDateHora("05/12/2012 00:00:00");
		Date dataFinalQuartoAjuste = Util.converteStringParaDateHora("05/12/2012 02:00:00");
		Date dataInicialQuintoAjuste = Util.converteStringParaDateHora("05/12/2012 08:40:00");
		Date dataFinalQuintoAjuste = Util.converteStringParaDateHora("05/12/2012 10:30:00");

		try{

			consulta.append("select sum(debito.valorDebito) from DebitoACobrar debito  ");
			consulta.append(" inner join debito.debitoTipo debtipo where ");
			consulta.append(" debito.imovel.id = :idImovel ");
			consulta.append(" and debtipo.id = :idDebitoTipo ");
			consulta.append(" and debito.anoMesReferenciaDebito = :anoMesReferencia ");
			consulta.append(" and debito.anoMesCobrancaDebito = :anoMesCobranca ");
			consulta.append(" and ( ");
			consulta.append(" (debito.geracaoDebito between :dataInicialPrimeiroAjuste ");
			consulta.append(" and :dataFinalPrimeiroAjuste) ");
			consulta.append(" or (debito.geracaoDebito between :dataInicialSegundoAjuste ");
			consulta.append(" and :dataFinalSegundoAjuste) ");
			consulta.append(" or (debito.geracaoDebito between :dataInicialTerceiroAjuste ");
			consulta.append(" and :dataFinalTerceiroAjuste) ");
			consulta.append(" or (debito.geracaoDebito between :dataInicialQuartoAjuste ");
			consulta.append(" and :dataFinalQuartoAjuste) ");
			consulta.append(" or (debito.geracaoDebito between :dataInicialQuintoAjuste ");
			consulta.append(" and :dataFinalQuintoAjuste) ");
			consulta.append(" )");
			consulta.append(" and debito.valorDebito > 0 ");
			consulta.append(" and debito.codigoSetorComercial is null ");
			consulta.append(" and debito.numeroQuadra is null ");
			consulta.append(" and debito.numeroLote is null ");
			consulta.append(" and debito.numeroSubLote is null ");

			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("idDebitoTipo", idDebitoTipo).setInteger("anoMesReferencia", anoMesReferenciaDebito)
							.setInteger("anoMesCobranca", anoMesCobranca)
							.setTimestamp("dataInicialPrimeiroAjuste", dataInicialPrimeiroAjuste)
							.setTimestamp("dataFinalPrimeiroAjuste", dataFinalPrimeiroAjuste)
							.setTimestamp("dataInicialSegundoAjuste", dataInicialSegundoAjuste)
							.setTimestamp("dataFinalSegundoAjuste", dataFinalSegundoAjuste)
							.setTimestamp("dataInicialTerceiroAjuste", dataInicialTerceiroAjuste)
							.setTimestamp("dataFinalTerceiroAjuste", dataFinalTerceiroAjuste)
							.setTimestamp("dataInicialQuartoAjuste", dataInicialQuartoAjuste)
							.setTimestamp("dataFinalQuartoAjuste", dataFinalQuartoAjuste)
							.setTimestamp("dataInicialQuintoAjuste", dataInicialQuintoAjuste)
							.setTimestamp("dataFinalQuintoAjuste", dataFinalQuintoAjuste).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public BigDecimal pesquisarSomatorioDebitosACobrarHistoricoFaturadosGeradoPrimeiroAjuste(Integer idImovel,
					Integer anoMesReferenciaDebito, Integer anoMesCobranca, Integer idDebitoTipo) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		Date dataInicialPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:35:00");
		Date dataFinalPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:59:00");
		Date dataInicialSegundoAjuste = Util.converteStringParaDateHora("29/11/2012 00:00:00");
		Date dataFinalSegundoAjuste = Util.converteStringParaDateHora("29/11/2012 00:30:00");
		Date dataInicialTerceiroAjuste = Util.converteStringParaDateHora("04/12/2012 21:00:00");
		Date dataFinalTerceiroAjuste = Util.converteStringParaDateHora("04/12/2012 21:40:00");
		Date dataInicialQuartoAjuste = Util.converteStringParaDateHora("05/12/2012 00:00:00");
		Date dataFinalQuartoAjuste = Util.converteStringParaDateHora("05/12/2012 02:00:00");
		Date dataInicialQuintoAjuste = Util.converteStringParaDateHora("05/12/2012 08:40:00");
		Date dataFinalQuintoAjuste = Util.converteStringParaDateHora("05/12/2012 10:30:00");

		try{

			consulta.append("select sum(debito.valorDebito) from DebitoACobrarHistorico debito  ");
			consulta.append(" inner join debito.debitoTipo debtipo where ");
			consulta.append(" debito.imovel.id = :idImovel ");
			consulta.append(" and debtipo.id = :idDebitoTipo ");
			consulta.append(" and debito.anoMesReferenciaDebito = :anoMesReferencia ");
			consulta.append(" and debito.anoMesCobrancaDebito = :anoMesCobranca ");
			consulta.append(" and ( ");
			consulta.append(" (debito.debitoGeradoRealizar between :dataInicialPrimeiroAjuste ");
			consulta.append(" and :dataFinalPrimeiroAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar between :dataInicialSegundoAjuste ");
			consulta.append(" and :dataFinalSegundoAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar between :dataInicialTerceiroAjuste ");
			consulta.append(" and :dataFinalTerceiroAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar between :dataInicialQuartoAjuste ");
			consulta.append(" and :dataFinalQuartoAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar between :dataInicialQuintoAjuste ");
			consulta.append(" and :dataFinalQuintoAjuste) ");
			consulta.append(" )");
			consulta.append(" and debito.valorDebito > 0 ");
			consulta.append(" and debito.codigoSetorComercial is null ");
			consulta.append(" and debito.numeroQuadra is null ");
			consulta.append(" and debito.lote is null ");
			consulta.append(" and debito.sublote is null ");

			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("idDebitoTipo", idDebitoTipo).setInteger("anoMesReferencia", anoMesReferenciaDebito)
							.setInteger("anoMesCobranca", anoMesCobranca)
							.setTimestamp("dataInicialPrimeiroAjuste", dataInicialPrimeiroAjuste)
							.setTimestamp("dataFinalPrimeiroAjuste", dataFinalPrimeiroAjuste)
							.setTimestamp("dataInicialSegundoAjuste", dataInicialSegundoAjuste)
							.setTimestamp("dataFinalSegundoAjuste", dataFinalSegundoAjuste)
							.setTimestamp("dataInicialTerceiroAjuste", dataInicialTerceiroAjuste)
							.setTimestamp("dataFinalTerceiroAjuste", dataFinalTerceiroAjuste)
							.setTimestamp("dataInicialQuartoAjuste", dataInicialQuartoAjuste)
							.setTimestamp("dataFinalQuartoAjuste", dataFinalQuartoAjuste)
							.setTimestamp("dataInicialQuintoAjuste", dataInicialQuintoAjuste)
							.setTimestamp("dataFinalQuintoAjuste", dataFinalQuintoAjuste).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public ContaHistorico pesquisarContaRetificadaPeriodoAnterior(Integer idImovel, Integer anoMesReferencia)
					throws ErroRepositorioException{

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		Date dataInicialPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 22:00:00");
		Date dataFinalPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:34:00");

		try{

			consulta.append(" select contaImovel from ContaHistorico contaImovel  where ");
			consulta.append(" contaImovel.imovel.id = :idImovel ");
			consulta.append(" and contaImovel.anoMesReferenciaConta =  :anoMesReferencia ");
			consulta.append(" and contaImovel.debitoCreditoSituacaoAtual.id = "
							+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO.toString());
			consulta.append(" and contaImovel.usuario.id =  " + Usuario.getIdUsuarioBatchParametro().toString());
			consulta.append(" and ( ");
			consulta.append(" (contaImovel.contaHistorico between :dataInicialPrimeiroAjuste ");
			consulta.append(" and :dataFinalPrimeiroAjuste) ");
			consulta.append(")");
			consulta.append(" order by contaImovel.id desc ");

			retorno = (ContaHistorico) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia)
							.setTimestamp("dataInicialPrimeiroAjuste", dataInicialPrimeiroAjuste)
							.setTimestamp("dataFinalPrimeiroAjuste", dataFinalPrimeiroAjuste).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Object[]> pesquisarDebitoACobrarParaCancelarRotinaAjuste() throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		Date dataAjuste = Util.converteStringParaDateHora("11/12/2012 21:00:00");

		try{
			String consulta = " select dbac_id, imov_id from debito_a_cobrar where  dbac_amcobrancadebito = 201301 and dbac_tmatudebito = :dataAjuste"
							+ " and dbac_nnlote is null and dbac_nnquadra is null and dbac_cdsetorcomercial is null and dbac_nnsublote is null ";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta).setTimestamp("dataAjuste", dataAjuste).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public ContaHistorico pesquisarContaEmHistoricoIncluidaCanceladaParcelada(Integer idImovel, Integer anoMesReferencia)
					throws ErroRepositorioException{

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();

		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select cnhi ");
			consulta.append("from ContaHistorico cnhi ");
			consulta.append("left join fetch cnhi.debitoCreditoSituacaoAtual ");
			consulta.append("where cnhi.imovel.id = :idImovel ");
			consulta.append("  and cnhi.anoMesReferenciaConta = :anoMesReferencia ");
			consulta.append("  and cnhi.debitoCreditoSituacaoAtual.id in (:idsDebitoCreditoSituacaoAtual) ");
			consulta.append("order by cnhi.id desc ");

			Collection<Integer> idsDebitoCreditoSituacaoAtual = new ArrayList<Integer>();
			idsDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.INCLUIDA);
			idsDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.CANCELADA);
			idsDebitoCreditoSituacaoAtual.add(DebitoCreditoSituacao.PARCELADA);

			Query query = session.createQuery(consulta.toString());

			query.setInteger("idImovel", idImovel);
			query.setInteger("anoMesReferencia", anoMesReferencia);
			query.setParameterList("idsDebitoCreditoSituacaoAtual", idsDebitoCreditoSituacaoAtual);

			retorno = (ContaHistorico) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém os débitos a cobrar do imóvel pra referência informada
	 * 
	 * @author Anderson Italo
	 * @date 13/11/2012
	 */
	public Collection<DebitoACobrar> pesquisarDebitosACobrarDoImovel(Integer idImovel, Collection anoMesReferencia, Integer idDebitoTipo)
					throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select debito from DebitoACobrar debito  ");
			consulta.append("inner join fetch debito.debitoTipo debtipo where ");
			consulta.append("debito.imovel.id = :idImovel ");
			consulta.append("and debito.anoMesCobrancaDebito in (:anoMesCobranca) ");
			consulta.append("and debito.debitoTipo.id = :idDebitoTipo ");

			retorno = session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setParameterList("anoMesCobranca", anoMesReferencia).setInteger("idDebitoTipo", idDebitoTipo).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public ContaHistorico pesquisarContaHistoricoOriginalRetificadaRotinaQuantidadeRubricas(Integer idImovel, Integer anoMesReferencia)
					throws ErroRepositorioException{

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		Date dataRetificacao = Util.converteStringParaDateHora("27/11/2012 22:00:00");

		try{

			consulta.append(" select contaImovel from ContaHistorico contaImovel  where ");
			consulta.append(" contaImovel.imovel.id = :idImovel ");
			consulta.append(" and contaImovel.anoMesReferenciaConta =  :anoMesReferencia ");
			consulta.append(" and contaImovel.debitoCreditoSituacaoAtual.id = " + DebitoCreditoSituacao.RETIFICADA.toString());
			consulta.append(" and contaImovel.usuario.id =  " + Usuario.getIdUsuarioBatchParametro().toString());
			consulta.append(" and contaImovel.contaMotivoRetificacao.id = 36");
			consulta.append(" and contaImovel.dataRetificacao = :dataRetif ");
			consulta.append(" order by contaImovel.id desc ");

			retorno = (ContaHistorico) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia).setDate("dataRetif", dataRetificacao).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Conta pesquisarContaOriginalRetificadaRotinaQuantidadeRubricas(Integer idImovel, Integer anoMesReferencia)
					throws ErroRepositorioException{

		Conta retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		Date dataRetificacao = Util.converteStringParaDateHora("27/11/2012 22:00:00");

		try{

			consulta.append(" select contaImovel from Conta contaImovel  where ");
			consulta.append(" contaImovel.imovel.id = :idImovel ");
			consulta.append(" and contaImovel.referencia =  :anoMesReferencia ");
			consulta.append(" and contaImovel.debitoCreditoSituacaoAtual.id = " + DebitoCreditoSituacao.RETIFICADA.toString());
			consulta.append(" and contaImovel.usuario.id =  " + Usuario.getIdUsuarioBatchParametro().toString());
			consulta.append(" and contaImovel.contaMotivoRetificacao.id = 36");
			consulta.append(" and contaImovel.dataRetificacao = :dataRetif ");

			retorno = (Conta) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia).setDate("dataRetif", dataRetificacao).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<DebitoCobrado> pesquisarDebitosCobradoDaContaRetificada(Integer idConta) throws ErroRepositorioException{

		Collection<DebitoCobrado> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select debito from DebitoCobrado debito  ");
			consulta.append(" inner join fetch debito.debitoTipo debtipo where ");
			consulta.append(" debito.conta.id = :idConta ");
			consulta.append(" order by debtipo.id, debito.numeroPrestacao, debito.numeroPrestacaoDebito ");

			retorno = session.createQuery(consulta.toString()).setInteger("idConta", idConta).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public BigDecimal pesquisarSomatorioDebitosCobradoDaContaRetificada(Integer idConta, Integer idDebitoTipo, Short numeroPrestacao,
					Short numeroPrestacaoDebito) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select sum(debito.valorPrestacao) from DebitoCobrado debito  ");
			consulta.append(" where debito.conta.id = :idConta ");

			if(idDebitoTipo != null){

				consulta.append(" and debito.numeroPrestacao = :numeroPrest ");
				consulta.append(" and debito.numeroPrestacaoDebito = :numeroPrestacaoDeb ");
				consulta.append(" and debito.debitoTipo.id = :idDebitoTipo ");

				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta)
								.setShort("numeroPrest", numeroPrestacao).setShort("numeroPrestacaoDeb", numeroPrestacaoDebito)
								.setInteger("idDebitoTipo", idDebitoTipo).setMaxResults(1).uniqueResult();
			}else{

				retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setMaxResults(1)
								.uniqueResult();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Object[]> pesquisarDebitoACobrarParaCancelarDuplicados() throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String consulta = " select dac.dbac_id, dac.imov_id from debito_a_cobrar dac where "
							+ "( "
							+ "				(dbac_tmatudebito between to_date('27/11/2012 23:35', 'dd/mm/yyyy hh24:mi') and to_date('27/11/2012 23:59', 'dd/mm/yyyy hh24:mi')) or "
							+ "	(dbac_tmatudebito between to_date('29/11/2012 00:00', 'dd/mm/yyyy hh24:mi') and to_date('29/11/2012 00:30', 'dd/mm/yyyy hh24:mi')) or "
							+ "	(dbac_tmatudebito between to_date('04/12/2012 21:00', 'dd/mm/yyyy hh24:mi') and to_date('04/12/2012 21:40', 'dd/mm/yyyy hh24:mi')) or "
							+ "	(dbac_tmatudebito between to_date('05/12/2012 00:00', 'dd/mm/yyyy hh24:mi') and to_date('05/12/2012 02:00', 'dd/mm/yyyy hh24:mi')) or "
							+ "	(dbac_tmatudebito between to_date('05/12/2012 08:40', 'dd/mm/yyyy hh24:mi') and to_date('05/12/2012 10:30', 'dd/mm/yyyy hh24:mi')) or "
							+ "	(dbac_tmatudebito = to_date('11/12/2012 21:00', 'dd/mm/yyyy hh24:mi')) "
							+ "	) "
							+ " and dac.dbac_nnlote is null and dac.dbac_nnquadra is null and dac.dbac_cdsetorcomercial is null and dac.dbac_nnsublote is null "
							+ " and exists ( select 1 from TAB_DCCORIGINAL a "
							+ " left join TAB_DCCATUAL b on a.imov_id = b.imov_id and a.dbtp_id = b.dbtp_id "
							+ " left join TAB_DCAJUSTE c on a.imov_id = c.imov_id and a.dbtp_id = c.dbtp_id "
							+ " where a.VLPRESTACAO <> (b.VLPRESTACAO + c.VLDEBITO)  and a.imov_id in (select distinct pag.imov_id "
							+ " from pagamento_historico pag  inner join conta_historico ch on pag.imov_id = ch.imov_id "
							+ " where pag.pghi_amreferenciapagamento = 201211 "
							+ " and ch.cnhi_amreferenciaconta = 201211 and pag.cnta_id is not null and ch.DCST_IDATUAL = 7 "
							+ " and pag.pghi_vlpagamento = (ch.cnhi_vlagua+ ch.cnhi_vldebitos+ ch.cnhi_vlesgoto- ch.cnhi_vlcreditos)) "
							+ " and dac.imov_id = a.imov_id and dac.dbac_vldebito <= c.VLDEBITO and dac.dbtp_id = a.dbtp_id) ";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Object[]> pesquisarDebitoACobrarParaCancelarDuplicados2() throws ErroRepositorioException{

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String consulta = " select dac.dbac_id, dac.imov_id "
							+ " from debito_a_cobrar dac "
							+ " where "
							+ " ( "
							+ " (dbac_tmatudebito between to_date('27/11/2012 23:35', 'dd/mm/yyyy hh24:mi') and to_date('27/11/2012 23:59', 'dd/mm/yyyy hh24:mi')) or "
							+ " (dbac_tmatudebito between to_date('29/11/2012 00:00', 'dd/mm/yyyy hh24:mi') and to_date('29/11/2012 00:30', 'dd/mm/yyyy hh24:mi')) or "
							+ " (dbac_tmatudebito between to_date('04/12/2012 21:00', 'dd/mm/yyyy hh24:mi') and to_date('04/12/2012 21:40', 'dd/mm/yyyy hh24:mi')) or "
							+ " (dbac_tmatudebito between to_date('05/12/2012 00:00', 'dd/mm/yyyy hh24:mi') and to_date('05/12/2012 02:00', 'dd/mm/yyyy hh24:mi')) or "
							+ " (dbac_tmatudebito between to_date('05/12/2012 08:40', 'dd/mm/yyyy hh24:mi') and to_date('05/12/2012 10:30', 'dd/mm/yyyy hh24:mi')) or "
							+ " (dbac_tmatudebito = to_date('11/12/2012 21:00', 'dd/mm/yyyy hh24:mi')) "
							+ " ) "
							+ " and dac.dbac_nnlote is null "
							+ " and dac.dbac_nnquadra is null "
							+ " and dac.dbac_cdsetorcomercial is null "
							+ " and dac.dbac_nnsublote is null "
							+ " and exists "
							+ " ( "
							+ " select a.imov_id , a.dbtp_id, c.VLDEBITO as ajuste "
							+ " from TAB_DCCORIGINAL a "
							+ " left join TAB_DCCATUAL b on a.imov_id = b.imov_id and a.dbtp_id = b.dbtp_id "
							+ " left join TAB_DCAJUSTE c on a.imov_id = c.imov_id and a.dbtp_id = c.dbtp_id "
							+ " where a.VLPRESTACAO <> (b.VLPRESTACAO + c.VLDEBITO) "
							+ " and a.imov_id in (select distinct (pag.imov_id) "
							+ " from pagamento_historico pag "
							+ " inner join conta_historico ch on pag.imov_id = ch.imov_id "
							+ " where pag.imov_id in (select distinct aa.imov_id "
							+ " from TAB_DCCORIGINAL aa "
							+ " left join TAB_DCCATUAL bb on aa.imov_id = bb.imov_id and aa.dbtp_id = bb.dbtp_id "
							+ " left join TAB_DCAJUSTE cc on aa.imov_id = cc.imov_id and aa.dbtp_id = cc.dbtp_id "
							+ " where aa.VLPRESTACAO <> (bb.VLPRESTACAO + cc.VLDEBITO)) "
							+ " and pag.pghi_amreferenciapagamento = 201211 "
							+ " and ch.cnhi_amreferenciaconta = 201211 "
							+ " and pag.cnta_id is not null "
							+ " and ch.DCST_IDATUAL = 1 "
							+ " and pag.pghi_vlpagamento = (ch.cnhi_vlagua+ ch.cnhi_vldebitos+ ch.cnhi_vlesgoto- ch.cnhi_vlcreditos) "
							+ " and ch.usur_id = 9999 "
							+ " and ch.cmrt_id = 36 "
							+ " and pag.imov_id not in (553123,2507625,2443562,243183,2346249,4545303,4405226,3234932,3104303,2507358,2395622,5229219,4284488,4952340,3104753,3093204,2181754,4120566, "
							+ " 3115305,4252772,205362,2521687,2147998,252255,3117111,5040302,4118669,2376920,2385996)  ) "
							+ " and dac.imov_id = a.imov_id and dac.dbac_vldebito <= c.VLDEBITO and dac.dbtp_id = a.dbtp_id)";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Integer> pesquisarIdsPagamentosAMaiorParaClassificar() throws ErroRepositorioException{

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append(" select pag.pgmt_id from pagamento pag ");
			consulta.append(" where  ");
			consulta.append(" pag.cnta_id is not null ");
			consulta.append(" and pag.pgmt_amreferenciapagamento=201211 ");
			consulta.append(" and pag.pgmt_amreferenciaarrecadacao in (201211,201212,201301,201302) ");
			consulta.append(" and pag.pgst_idatual=14 ");
			consulta.append(" and exists (select 1 from conta co where co.cnta_id = pag.cnta_id and co.cmrt_id = 36 ");
			consulta.append(" and co.usur_id = 9999 and co.cnta_amreferenciaconta=201211) ");

			retorno = (Collection<Integer>) session.createSQLQuery(consulta.toString()).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public BigDecimal pesquisarSomatorioDebitosACobrarFaturadosGeradosRotinaAjuste(Integer idImovel) throws ErroRepositorioException{

		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		Date dataInicialPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:35:00");
		Date dataFinalPrimeiroAjuste = Util.converteStringParaDateHora("27/11/2012 23:59:00");
		Date dataInicialSegundoAjuste = Util.converteStringParaDateHora("29/11/2012 00:00:00");
		Date dataFinalSegundoAjuste = Util.converteStringParaDateHora("29/11/2012 00:30:00");
		Date dataInicialTerceiroAjuste = Util.converteStringParaDateHora("04/12/2012 21:00:00");
		Date dataFinalTerceiroAjuste = Util.converteStringParaDateHora("04/12/2012 21:40:00");
		Date dataInicialQuartoAjuste = Util.converteStringParaDateHora("05/12/2012 00:00:00");
		Date dataFinalQuartoAjuste = Util.converteStringParaDateHora("05/12/2012 02:00:00");
		Date dataInicialQuintoAjuste = Util.converteStringParaDateHora("05/12/2012 08:40:00");
		Date dataFinalQuintoAjuste = Util.converteStringParaDateHora("05/12/2012 10:30:00");
		Date dataFixaSextoAjuste = Util.converteStringParaDateHora("11/12/2012 21:00:00");
		Date dataFixaSetimoAjuste = Util.converteStringParaDateHora("20/12/2012 20:00:00");

		try{

			consulta.append("select sum(debito.valorDebito) from DebitoACobrarHistorico debito  ");
			consulta.append(" inner join debito.debitoTipo debtipo where ");
			consulta.append(" debito.imovel.id = :idImovel ");
			consulta.append(" and debito.anoMesReferenciaDebito = 201211 ");
			consulta.append(" and debito.anoMesCobrancaDebito in (201212, 201301) ");
			consulta.append(" and debito.debitoCreditoSituacaoAtual.id = " + DebitoCreditoSituacao.NORMAL.toString());
			consulta.append(" and ( ");
			consulta.append(" (debito.debitoGeradoRealizar between :dataInicialPrimeiroAjuste ");
			consulta.append(" and :dataFinalPrimeiroAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar between :dataInicialSegundoAjuste ");
			consulta.append(" and :dataFinalSegundoAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar between :dataInicialTerceiroAjuste ");
			consulta.append(" and :dataFinalTerceiroAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar between :dataInicialQuartoAjuste ");
			consulta.append(" and :dataFinalQuartoAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar between :dataInicialQuintoAjuste ");
			consulta.append(" and :dataFinalQuintoAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar = :dataFixaSextoAjuste) ");
			consulta.append(" or (debito.debitoGeradoRealizar = :dataFixaSetimoAjuste) ");
			consulta.append(" )");
			consulta.append(" and debito.valorDebito > 0 ");
			consulta.append(" and debito.codigoSetorComercial is null ");
			consulta.append(" and debito.numeroQuadra is null ");
			consulta.append(" and debito.lote is null ");
			consulta.append(" and debito.sublote is null ");

			retorno = (BigDecimal) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setTimestamp("dataInicialPrimeiroAjuste", dataInicialPrimeiroAjuste)
							.setTimestamp("dataFinalPrimeiroAjuste", dataFinalPrimeiroAjuste)
							.setTimestamp("dataInicialSegundoAjuste", dataInicialSegundoAjuste)
							.setTimestamp("dataFinalSegundoAjuste", dataFinalSegundoAjuste)
							.setTimestamp("dataInicialTerceiroAjuste", dataInicialTerceiroAjuste)
							.setTimestamp("dataFinalTerceiroAjuste", dataFinalTerceiroAjuste)
							.setTimestamp("dataInicialQuartoAjuste", dataInicialQuartoAjuste)
							.setTimestamp("dataFinalQuartoAjuste", dataFinalQuartoAjuste)
							.setTimestamp("dataInicialQuintoAjuste", dataInicialQuintoAjuste)
							.setTimestamp("dataFinalQuintoAjuste", dataFinalQuintoAjuste)
							.setTimestamp("dataFixaSextoAjuste", dataFixaSextoAjuste)
							.setTimestamp("dataFixaSetimoAjuste", dataFixaSetimoAjuste).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarIdsContaPorGrupo(Integer situacao, Integer idGrupo, Integer referencia) throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" SELECT distinct(cnta_id) ");
			consulta.append(" FROM  CONTA ");
			consulta.append(" WHERE CNTA_AMREFERENCIACONTA = " + referencia);
			consulta.append("   AND  dcst_idatual = " + situacao);
			consulta.append("   AND FTGR_ID = " + idGrupo);

			retorno = (Collection) session.createSQLQuery(consulta.toString()).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public DebitoAutomaticoMovimento pesquisarUltimoDebitoAutomaticoMovimentoConta(Integer idConta) throws ErroRepositorioException{

		DebitoAutomaticoMovimento debitoAutomaticoMovimento = null;
		Session session = HibernateUtil.getSession();

		try{

			Criteria criteria = session.createCriteria(DebitoAutomaticoMovimento.class);
			criteria.add(Restrictions.eq("conta.id", idConta));
			criteria.addOrder(Order.desc("ultimaAlteracao"));
			criteria.setMaxResults(1);

			debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) criteria.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

		return debitoAutomaticoMovimento;

	}

	public Object[] verificaExistenciaContaOuContaHistoricoGerarProvisaoReceita(Integer idImovel, Integer referenciaConta)
					throws ErroRepositorioException{

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		try{

			consulta.append(" select distinct(cont.cnta_id) as idConta, cont.cnta_nnconsumoagua consumoAgua, ");
			consulta.append(" cont.cnta_nnconsumoesgoto consumoEsgoto ");
			consulta.append(" from conta cont ");
			consulta.append(" where cont.cnta_amreferenciaconta = " + referenciaConta.toString());
			consulta.append(" and cont.dcst_idatual in (" + DebitoCreditoSituacao.NORMAL.toString() + ","
							+ DebitoCreditoSituacao.RETIFICADA.toString() + ") ");
			consulta.append(" and cont.imov_id = " + idImovel.toString());
			consulta.append(" union ");
			consulta.append(" select distinct(cont.cnta_id) as idConta, cont.cnhi_nnconsumoagua consumoAgua, ");
			consulta.append(" cont.cnhi_nnconsumoesgoto consumoEsgoto ");
			consulta.append(" from conta_historico cont ");
			consulta.append(" where cont.cnhi_amreferenciaconta = " + referenciaConta.toString());
			consulta.append(" and cont.dcst_idatual in (" + DebitoCreditoSituacao.NORMAL.toString() + ","
							+ DebitoCreditoSituacao.RETIFICADA.toString() + "," + DebitoCreditoSituacao.PARCELADA.toString() + ")");
			consulta.append(" and cont.imov_id = " + idImovel.toString());

			retorno = (Object[]) session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.INTEGER)
							.addScalar("consumoAgua", Hibernate.INTEGER).addScalar("consumoEsgoto", Hibernate.INTEGER).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public void removerProvisaoReceitaAnoMes(Integer anoMesProvisao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();
		try{

			sql.append(" delete from provisao_receita where  ");
			sql.append(" prec_amreferenciaprovisao = " + anoMesProvisao.toString());

			session.createSQLQuery(sql.toString()).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
	}

	public Integer verificaExistenciaProvisaoReceitaAnoMes(Integer anoMesProvisao, Integer idImovel) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();
		Integer retorno = null;
		Number retornoConsulta = null;

		try{

			sql.append(" select imov_id from provisao_receita where  ");
			sql.append(" prec_amreferenciaprovisao = " + anoMesProvisao.toString());
			sql.append(" and imov_id = " + idImovel.toString());

			retornoConsulta = (Number) session.createSQLQuery(sql.toString()).setMaxResults(1).uniqueResult();

			if(retornoConsulta != null){

				retorno = retornoConsulta.intValue();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<DebitoACobrar> pesquisarDebitoACobrarSuspensoParaCancelar(Integer limite, Integer numeroDiasSuspensao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection<DebitoACobrar> retorno = new ArrayList();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select dbac ");
			consulta.append("from DebitoACobrar dbac ");
			consulta.append("where dbac.numeroDiasSuspensao = :numeroDiasSuspensao ");

			Query query = session.createQuery(consulta.toString());
			query.setInteger("numeroDiasSuspensao", numeroDiasSuspensao);

			retorno = (Collection<DebitoACobrar>) query.setMaxResults(limite).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public boolean verificarExistenciaDeGrupoFaturamentoParaImovel(Integer idImovel) throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select count(*) from FATURAMENTO_ATIVIDADE_CRON fac  ");
			consulta.append("  inner join faturamento_atividade fa on fac.FTAT_ID = fa.FTAT_ID ");
			consulta.append("  inner join FATURAMENTO_GRUPO_CRON_MENSAL fgcm on fgcm.FTCM_ID = fac.FTCM_ID ");
			consulta.append("  inner join FATURAMENTO_GRUPO fg on fg.ftgr_id = fgcm.FTGR_ID ");
			consulta.append("  inner join ROTA rota on rota.FTGR_ID = fg.FTGR_ID      ");
			consulta.append("  inner join IMOVEL imov on imov.ROTA_ID = rota.ROTA_ID  ");
			consulta.append("where fa.FTAT_ID in (5 , 11)   ");
			consulta.append("  and FTCM_AMREFERENCIA = (Select PARM_AMREFERENCIAFATURAMENTO from SISTEMA_PARAMETROS) ");
			consulta.append("  and fac.FTAC_TMCOMANDO is not null     ");
			consulta.append("  and fac.FTAC_TMREALIZACAO is not null  ");
			consulta.append("  and imov.IMOV_ID = " + idImovel.intValue());

			BigDecimal qtd = (BigDecimal) session.createSQLQuery(consulta.toString()).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * [FS0006] – Verifica existência de imóveis de localidades associadas a concessionárias
	 * diversas
	 * 
	 * @author Anderson Italo
	 * @date 22/02/2013
	 */
	public Integer verificaExistenciaLocalidadesAssociadaConcessionariasDiversas(Integer periodoReferenciaContasInicial,
					Integer periodoReferenciaContasFinal, Integer idImovel) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();
		Integer retorno = null;
		Number retornoConsulta = null;

		try{

			sql.append(" select count(distinct(cl.conc_id)) from conta cc ");
			sql.append(" inner join concessionaria_localidade cl on cl.loca_id = cc.loca_id ");
			sql.append(" where ");
			if(periodoReferenciaContasInicial != null && periodoReferenciaContasFinal != null){
				sql.append(" cc.cnta_amreferenciaconta between " + periodoReferenciaContasInicial + " and " + periodoReferenciaContasFinal);
				sql.append(" and ");
			}else if(periodoReferenciaContasInicial != null){
				sql.append(" cc.cnta_amreferenciaconta >= " + periodoReferenciaContasInicial);
				sql.append(" and ");
			}
			sql.append(" cc.imov_id = " + idImovel.toString());

			retornoConsulta = (Number) session.createSQLQuery(sql.toString()).setMaxResults(1).uniqueResult();

			if(retornoConsulta != null){

				retorno = retornoConsulta.intValue();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0203] Consultar Débitos
	 * [FS0012] – Verifica existência de imóveis de localidades associadas a concessionárias
	 * diversas
	 * 
	 * @author Anderson Italo
	 * @date 23/02/2013
	 */
	public Integer verificaExistenciaLocalidadesAssociadaConcessionariasDiversas(Collection colecaoContas, String idsGuias,
					String idsDebitos, String idsCreditos) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();
		Integer retorno = null;
		Number retornoConsulta = null;

		try{

			if(colecaoContas != null && colecaoContas.size() > 0){

				sql.append(" select count(distinct(cl.conc_id)) from conta cc ");
				sql.append(" inner join concessionaria_localidade cl on cl.loca_id = cc.loca_id ");
				sql.append(" where cc.cnta_id in (:idContas)  ");
				sql.append("   and cl.cnlc_dtvigenciafim is null ");

				Collection<Integer> colecaoIdsContas = new ArrayList<Integer>();
				for(Object idConta : colecaoContas){
					colecaoIdsContas.add(Integer.valueOf(idConta.toString()));
				}

				retornoConsulta = (Number) session.createSQLQuery(sql.toString()).setParameterList("idContas", colecaoIdsContas)
								.setMaxResults(1).uniqueResult();

				if(retornoConsulta != null){

					retorno = retornoConsulta.intValue();
				}
			}else if(idsGuias != null){

				sql.append(" select count(distinct(cl.conc_id)) from guia_pagamento gp ");
				sql.append(" inner join concessionaria_localidade cl on cl.loca_id = gp.loca_id ");
				sql.append(" where gp.gpag_id in(" + idsGuias + ")");
				sql.append("   and cl.cnlc_dtvigenciafim is null ");

				retornoConsulta = (Number) session.createSQLQuery(sql.toString()).setMaxResults(1).uniqueResult();
				if(retornoConsulta != null){

					retorno = retornoConsulta.intValue();
				}

			}else if(idsDebitos != null){

				sql.append(" select count(distinct(cl.conc_id)) from debito_a_cobrar dc ");
				sql.append(" inner join concessionaria_localidade cl on cl.loca_id = dc.loca_id ");
				sql.append(" where dc.dbac_id in(" + idsDebitos + ")");
				sql.append("   and cl.cnlc_dtvigenciafim is null ");

				retornoConsulta = (Number) session.createSQLQuery(sql.toString()).setMaxResults(1).uniqueResult();
				if(retornoConsulta != null){

					retorno = retornoConsulta.intValue();
				}

			}else if(idsCreditos != null){

				sql.append(" select count(distinct(cl.conc_id)) from credito_a_realizar cr ");
				sql.append(" inner join concessionaria_localidade cl on cl.loca_id = cr.loca_id ");
				sql.append(" where cr.crar_id in(" + idsCreditos + ")");
				sql.append("   and cl.cnlc_dtvigenciafim is null ");

				retornoConsulta = (Number) session.createSQLQuery(sql.toString()).setMaxResults(1).uniqueResult();
				if(retornoConsulta != null){

					retorno = retornoConsulta.intValue();
				}

			}



		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * pesquisa credito realizado pelo id da conta
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosRealizadoPorCreditoTipo(Integer idConta, Integer idCreditoTipo, String condicao)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" SELECT crrz_id ");
			consulta.append(" FROM  credito_realizado ");
			consulta.append(" WHERE CNTA_ID = " + idConta);
			consulta.append("   AND crti_id = " + idCreditoTipo);

			retorno = (Collection) session.createSQLQuery(consulta.toString()).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarIdsImoveisAjusteRetificarContasRetirarDebitorateioDuplicado() throws ErroRepositorioException{

		Collection<MovimentoRoteiroEmpresa> retorno = null;
		Session session = HibernateUtil.getSession();

		try{
			String consulta = " select mov.imov_id as idImovel from movimento_roteiro_empresa  mov where mov.mrem_vlrateio > 0 "
							+ " and mov.mrem_ammovimento = 201303 and mov.mrem_icmodofaturrateio = 1 and mov.mrem_icfase = 2 "
							+ " and exists (select 1 from debito_a_cobrar_historico dh where dh.dahi_amreferenciadebito=201302 "
							+ " and dh.dahi_amcobrancadebito=201303 and dh.dbtp_id = 50 and dh.imov_id = mov.imov_id) "
							+ " and exists (select 1 from imovel im where im.imov_idimovelcondominio = 628573 and im.imov_id = mov.imov_id) "
							+ " and exists (select 1 from conta co where co.imov_id = mov.imov_id and co.cnta_amreferenciaconta = 201303 "
							+ "  and (select count(*) from debito_cobrado dc where dc.cnta_id = co.cnta_id and dc.dbtp_id = 50) > 1 "
							+ " ) ";

			retorno = (Collection) session.createSQLQuery(consulta).addScalar("idImovel", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarIdsImovel() throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select imov_id from imovel where imov_idimovelcondominio = 5920760 ");

			retorno = (Collection) session.createSQLQuery(consulta.toString()).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0101] – Gerar Integração para Faturamento Imediato – Modelo 3
	 * 
	 * @author Anderson Italo
	 * @date 01/04/2013
	 */
	public Object verificarDebitosPendentesImovelTipoConta(Integer idImovel) throws ErroRepositorioException{

		StringBuffer consulta = new StringBuffer("");
		Session session = HibernateUtil.getSession();
		Object retorno = null;

		try{
			consulta.append(" select co.cnta_id as idConta ");
			consulta.append(" FROM conta co ");
			consulta.append(" where co.imov_id = " + idImovel.toString());
			consulta.append(" and co.cnta_dtvencimentoconta < :dataAtual ");

			retorno = session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.INTEGER)
							.setParameter("dataAtual", new Date(), Hibernate.DATE).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * [SB0101] – Gerar Integração para Faturamento Imediato – Modelo 3
	 * 
	 * @author Anderson Italo
	 * @date 01/04/2013
	 */
	public Collection<Object[]> pesquisarDadosContasVinculadasDocumentoReaviso(Integer idGrupo, Integer anoMesReferencia)
					throws ErroRepositorioException{

		StringBuffer consulta = new StringBuffer("");
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;

		try{
			consulta.append(" select co.imov_id as idImovel, co.cnta_amreferenciaconta as anoMesConta, ");
			consulta.append(" co.cnta_dtvencimentoconta as vencimento, cdi.cdit_vlitemcobrado as valorItem, ");
			consulta.append(" cd.cbdo_nnsequenciadocumento as seqDoc ");
			consulta.append(" FROM cobranca_documento cd ");
			consulta.append(" inner join cobranca_documento_item cdi on cdi.cbdo_id = cd.cbdo_id ");
			consulta.append(" inner join conta co on co.cnta_id = cdi.cnta_id ");
			consulta.append(" inner join movimento_roteiro_empresa mov on ");
			consulta.append(" mov.mrem_nndocumentocobranca = cd.cbdo_nnsequenciadocumento ");
			consulta.append(" where mov.mrem_ammovimento = " + anoMesReferencia.toString());
			consulta.append(" and mov.ftgr_id = " + idGrupo.toString());
			consulta.append(" order by co.cnta_amreferenciaconta desc ");

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta.toString()).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("anoMesConta", Hibernate.INTEGER).addScalar("vencimento", Hibernate.DATE)
							.addScalar("valorItem", Hibernate.BIG_DECIMAL).addScalar("seqDoc", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * Obtém BANC_ID da agencia de débito automático do imóvel
	 * 
	 * @author Anderson Italo
	 * @date 05/04/2013
	 */
	public Integer pesquisarBancoDebitoAutomaticoImovel(Integer idImovel) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");

		try{
			consulta.append("select age.bnco_id as idBanco from debito_automatico debito  ");
			consulta.append("inner join agencia age on age.agen_id = debito.agen_id ");
			consulta.append("where debito.imov_id = :idImovel ");
			consulta.append("and debito.deba_dtexclusao is null ");

			retorno = (Integer) session.createSQLQuery(consulta.toString()).addScalar("idBanco", Hibernate.INTEGER)
							.setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see gcom.faturamento.IRepositorioFaturamento#listarCreditoOrigem(java.lang.Integer)
	 */
	public Collection<CreditoOrigem> listarCreditoOrigem(Integer idCreditoTipo, Short indicadorUsoLivre) throws ErroRepositorioException{
		
		Collection<CreditoOrigem> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer sb = new StringBuffer();
		
		try{

			// (CROG_ID na tabela CREDITO_TIPO_ORIGEM com CRTI_ID = Tipo de Crédito selecionado e
			// CROG_ICUSOLIVRE = 1 em CREDITO_ORIGEM);

			sb.append("select distinct(co) ");
			sb.append("from CreditoTipoOrigem cto ");
			sb.append("inner join cto.creditoTipo ct ");
			sb.append("inner join cto.creditoOrigem co ");
			sb.append("where ct.id = :idCreditoTipo ");

			if(indicadorUsoLivre != null){

				sb.append("and co.indicadorUsoLivre = :indicador ");

			}

			sb.append("order by co.descricao");
			
			Query query = session.createQuery(sb.toString());
			query.setInteger("idCreditoTipo", idCreditoTipo);

			if(indicadorUsoLivre != null){

				query.setShort("indicador", indicadorUsoLivre);

			}

			retorno = query.list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

		return retorno;

	}

	/*
	 * (non-Javadoc)
	 * @see gcom.faturamento.IRepositorioFaturamento#estornarCreditoARealizar(java.lang.Integer,
	 * java.lang.Short)
	 */
	public void estornarCreditoARealizar(Integer idCreditoARealizarHistorico, Short numeroPrestacaoRealizada)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{

			String consulta = "select dac from CreditoARealizarHistorico dac where dac.id = :idCreditoARealizarHistorico";

			CreditoARealizarHistorico creditoARealizarHistorico = (CreditoARealizarHistorico) session.createQuery(consulta)
							.setInteger("idCreditoARealizarHistorico", idCreditoARealizarHistorico.intValue()).uniqueResult();

			CreditoARealizarCategoriaHistorico creditoARealizarCategoriaHistorico = creditoARealizarHistorico
							.getCreditoARealizarCategoriasHistorico().iterator().next();

			creditoARealizarHistorico.setPrestacaoRealizadas(numeroPrestacaoRealizada);

			CreditoARealizar creditoARealizar = new CreditoARealizar();

			try{

				PropertyUtils.copyProperties(creditoARealizar, creditoARealizarHistorico);

			}catch(IllegalAccessException e){

				throw new ErroRepositorioException(e);

			}catch(InvocationTargetException e){

				throw new ErroRepositorioException(e);

			}catch(NoSuchMethodException e){

				throw new ErroRepositorioException(e);

			}

			DebitoCreditoSituacao dcsAnteriorHistorico = creditoARealizarHistorico.getDebitoCreditoSituacaoAnterior();

			if(dcsAnteriorHistorico == null){

				DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao();
				debitoCreditoSituacaoAtual.setId(DebitoCreditoSituacao.NORMAL);
				creditoARealizar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);

			}else{

				creditoARealizar.setDebitoCreditoSituacaoAtual(dcsAnteriorHistorico);

			}

			/*
			 * Validação para settar NULL nos atributos numéricos de destino
			 * porque o método PropertyUtils.copyProperties(X, Y) coloca o valor
			 * 0 (zero) quando os atributos numéricos da origem são nulos.
			 * Obs.: Solução para implantação. TODO
			 * Saulo Lima - 06/02/2009
			 */
			if(creditoARealizarHistorico.getAnoMesReferenciaCredito() == null){
				creditoARealizar.setAnoMesReferenciaCredito(null);
			}

			Date ultimaAlt = new Date();

			creditoARealizar.setDebitoCreditoSituacaoAnterior(null);
			creditoARealizar.setUltimaAlteracao(ultimaAlt);
			creditoARealizar.setGeracaoCredito(creditoARealizarHistorico.getGeracaoCreditoARealizar());
			creditoARealizar.setNumeroLote(creditoARealizarHistorico.getLote());
			creditoARealizar.setNumeroPrestacaoCredito(creditoARealizarHistorico.getPrestacaoCredito());
			creditoARealizar.setNumeroPrestacaoRealizada(Short.valueOf("0"));
			creditoARealizar.setNumeroSubLote(creditoARealizarHistorico.getSubLote());

			consulta = "select dac from CreditoARealizarGeral dac where dac.id = :idCreditoARealizarHistorico";
			CreditoARealizarGeral creditoARealizarGeral = (CreditoARealizarGeral) session.createQuery(consulta)
							.setInteger("idCreditoARealizarHistorico", idCreditoARealizarHistorico.intValue()).uniqueResult();
			creditoARealizarGeral.setIndicadorHistorico(ConstantesSistema.NAO);
			creditoARealizarGeral.setUltimaAlteracao(ultimaAlt);
			creditoARealizar.setCreditoARealizarGeral(creditoARealizarGeral);
			creditoARealizar.setParcelamento(null);

			CreditoARealizarCategoria creditoARealizarCategoria = new CreditoARealizarCategoria();

			creditoARealizarCategoria.setCategoria(creditoARealizarCategoriaHistorico.getCategoria());
			creditoARealizarCategoria.setCreditoARealizar(creditoARealizar);
			creditoARealizarCategoria.setUltimaAlteracao(ultimaAlt);
			creditoARealizarCategoria.setValorCategoria(creditoARealizarCategoriaHistorico.getValorCategoria());
			creditoARealizarCategoria.setQuantidadeEconomia(creditoARealizarCategoriaHistorico.getQuantidadeEconomia());

			CreditoARealizarCategoriaPK pk = new CreditoARealizarCategoriaPK();
			pk.setCategoria(creditoARealizarCategoriaHistorico.getCategoria());
			pk.setCreditoARealizar(creditoARealizar);
			creditoARealizarCategoria.setComp_id(pk);

			Set<CreditoARealizarCategoria> creditoARealizarCategorias = new HashSet<CreditoARealizarCategoria>();
			creditoARealizarCategorias.add(creditoARealizarCategoria);
			creditoARealizar.setCreditoARealizarCategoria(creditoARealizarCategorias);

			session.delete(creditoARealizarCategoriaHistorico);
			session.delete(creditoARealizarHistorico);
			session.save(creditoARealizar);
			session.save(creditoARealizarCategoria);
			session.flush();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

	}

	/**
	 * Inserir Pagamentos
	 * Pesquisa a conta digitada
	 */
	public Object[] pesquisarContaHistoricoDigitada(String idImovel, String referenciaConta) throws ErroRepositorioException{

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			consulta = " SELECT conta.id, conta.anoMesReferenciaConta, conta.valorAgua, "
							+ " conta.valorEsgoto, conta.valorDebitos, conta.valorCreditos,conta.valorImposto "
							+ " FROM ContaHistorico conta " + " INNER JOIN conta.imovel imov "
							+ " INNER JOIN conta.debitoCreditoSituacaoAtual dcsa " + " WHERE imov.id = :idImovel and "
							+ " conta.anoMesReferenciaConta = " + referenciaConta + " and ( dcsa.id = " + DebitoCreditoSituacao.NORMAL
							+ " or dcsa.id = " + DebitoCreditoSituacao.RETIFICADA + " or dcsa.id = " + DebitoCreditoSituacao.INCLUIDA + ")";

			retorno = (Object[]) session.createQuery(consulta).setInteger("idImovel", Integer.valueOf(idImovel)).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#obterTotalEconomiasETotalLigacoesHistogramaAgua(
	 * java.lang.Integer, java.lang.Integer, java.lang.Integer)
	 */
	public Object[] obterTotalEconomiasETotalLigacoesHistogramaAgua(Integer idGerenciaRegional, Integer idLocalidade, Integer idCategoria)
					throws ErroRepositorioException{

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer sb = new StringBuffer();

		try{

			sb.append("SELECT COUNT(*), SUM(IMSB_QTECONOMIA) FROM IMOVEL_SUBCATEGORIA ");
			sb.append("WHERE CATG_ID = " + idCategoria);

			if(idLocalidade != null){

				sb.append(" AND IMOV_ID IN (SELECT IMOV_ID FROM IMOVEL WHERE LOCA_ID = " + idLocalidade + ")");

			}else if(idGerenciaRegional != null){

				sb.append(" AND IMOV_ID IN (SELECT IMOV_ID FROM IMOVEL WHERE LOCA_ID IN (SELECT LOCA_ID FROM LOCALIDADE WHERE GREG_ID = "
								+ idGerenciaRegional + "))");

			}

			retorno = (Object[]) session.createSQLQuery(sb.toString()).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0002] – Verificar Não Geração da Declaração para o Imóvel – Modelo 1
	 * Verifica se o imóvel tem contas vencida no ano de refência
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 19/04/2013
	 */
	public boolean verificarImovelContasVencidasAnoReferencia(Integer idImovel, Date dataVencimentoConta) throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select count(*) from conta c ");
			consulta.append("where c.imov_id = :idImovel ");
			consulta.append("and c.dcst_idatual in(");
			consulta.append(DebitoCreditoSituacao.NORMAL);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.RETIFICADA);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.INCLUIDA);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
			consulta.append(") ");
			consulta.append("and c.cnta_dtvencimentoconta <= :dataVencimentoConta ");
			consulta.append("and (c.cmrv_id <> 26 or c.cmrv_id is null) ");
			consulta.append("and (c.cnta_icpagamento = 2 or c.cnta_icpagamento is null) ");

			Number qtd = (Number) session.createSQLQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setDate("dataVencimentoConta", dataVencimentoConta).setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0002] – Verificar Não Geração da Declaração para o Imóvel – Modelo 1
	 * Verifica se tem pagamentos para imóvel no ano de refência
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 19/04/2013
	 */
	public boolean verificarPagamentosParaImovelAnoReferencia(Integer idImovel, Date dataVencimentoConta) throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select count(*) from pagamento pg ");
			consulta.append("where pg.imov_id = :idImovel ");
			consulta.append("and exists(");
			consulta.append("select c.cnta_id from conta c ");
			consulta.append("where c.imov_id = pg.imov_id ");
			consulta.append("and c.cnta_amreferenciaconta = pg.pgmt_amreferenciapagamento ");
			consulta.append("and c.dcst_idatual in(");
			consulta.append(DebitoCreditoSituacao.NORMAL);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.RETIFICADA);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.INCLUIDA);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
			consulta.append(") ");
			consulta.append("and c.cnta_dtvencimentoconta <= :dataVencimentoConta ");
			consulta.append(") ");

			Number qtd = (Number) session.createSQLQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setDate("dataVencimentoConta", dataVencimentoConta).setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0002] – Verificar Não Geração da Declaração para o Imóvel – Modelo 1
	 * Verifica se tem pagamentos no histórico para imóvel no ano de refência
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 19/04/2013
	 */
	public boolean verificarPagamentosHistoricoParaImovelAnoReferencia(Integer idImovel, Date dataVencimentoConta)
					throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select count(*) from pagamento_historico pgh ");
			consulta.append("where pgh.imov_id = :idImovel ");
			consulta.append("and exists(");
			consulta.append("select ch.imov_id from conta_historico ch ");
			consulta.append("where ch.imov_id = pgh.imov_id ");
			consulta.append("and ch.cnhi_amreferenciaconta = pgh.pghi_amreferenciapagamento ");
			consulta.append("and ch.dcst_idatual in(");
			consulta.append(DebitoCreditoSituacao.NORMAL);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.RETIFICADA);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.INCLUIDA);
			consulta.append(", ");
			consulta.append(DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
			consulta.append(") ");
			consulta.append("and ch.cnhi_dtvencimentoconta <= :dataVencimentoConta ");
			consulta.append(") ");

			Number qtd = (Number) session.createSQLQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setDate("dataVencimentoConta", dataVencimentoConta).setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * Pesquisa contas quitadas no ano de refência
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 24/04/2013
	 */
	public Collection<ContaHistorico> pesquisaContasQuitadasAnoReferencia(Integer idImovel, Integer referenciaFinal, Date dataFinal)
					throws ErroRepositorioException{

		Collection<ContaHistorico> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select ch ");
			consulta.append("from ContaHistorico ch ");
			consulta.append("inner join ch.imovel imov ");
			consulta.append("inner join ch.debitoCreditoSituacaoAtual dcsa ");
			consulta.append("where imov.id = :idImovel ");
			consulta.append("  and ch.anoMesReferenciaConta <= :referenciaFinal ");
			consulta.append("  and ch.dataVencimentoConta <= :dataFinal ");
			consulta.append("  and ((    dcsa.id in (:debitoCreditoSituacaoNormal, :debitoCreditoSituacaoRetificada, ");
			consulta.append("                        :debitoCreditoSituacaoIncluida, :debitoCreditoSituacaoEntradaParcelamento) ");
			consulta.append("        and ch.id in (select conta.id ");
			consulta.append("                      from PagamentoHistorico pgh ");
			consulta.append("                      inner join pgh.pagamentoSituacaoAtual pghs ");
			consulta.append("                      inner join pgh.conta conta ");
			consulta.append("                      where pghs.id = :pagamentoSituacaoClassificado ");
			consulta.append("                        and pgh.dataPagamento <= :dataFinal) ");
			consulta.append("       ) ");
			consulta.append("       or ");
			consulta.append("       (dcsa.id = :debitoCreditoSituacaoParcelada) ");
			consulta.append("      ) ");

			Query query = session.createQuery(consulta.toString());
			query.setInteger("idImovel", idImovel);
			query.setInteger("referenciaFinal", referenciaFinal);
			query.setDate("dataFinal", dataFinal);
			query.setInteger("debitoCreditoSituacaoNormal", DebitoCreditoSituacao.NORMAL);
			query.setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA);
			query.setInteger("debitoCreditoSituacaoIncluida", DebitoCreditoSituacao.INCLUIDA);
			query.setInteger("debitoCreditoSituacaoEntradaParcelamento", DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
			query.setInteger("pagamentoSituacaoClassificado", PagamentoSituacao.PAGAMENTO_CLASSIFICADO);
			query.setInteger("debitoCreditoSituacaoParcelada", DebitoCreditoSituacao.PARCELADA);

			retorno = (Collection<ContaHistorico>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3014] Emitir Declaração Anual Quitação Débitos
	 * [SB0001] Emitir Declaração Anual de Quitação de Débitos
	 * 
	 * @author Hebert Falcão
	 * @created 27/04/2013
	 */
	public Collection<QuitacaoDebitoAnual> pesquisarQuitacaoDebitoAnualParaEmicao(Integer idFaturamentoGrupo, Integer anoReferencia,
					Integer idImovel) throws ErroRepositorioException{

		Collection<QuitacaoDebitoAnual> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select qadb ");
			hql.append("from QuitacaoDebitoAnual qadb ");
			hql.append("inner join fetch qadb.imovel imov ");
			hql.append("inner join fetch imov.localidade loca ");
			hql.append("inner join fetch imov.rota rota ");
			hql.append("inner join fetch imov.setorComercial stcm ");
			hql.append("inner join fetch imov.quadra qdra ");
			hql.append("inner join fetch imov.logradouroCep lgcp ");
			hql.append("inner join fetch imov.logradouroCep.cep cep ");
			hql.append("where ");

			if(idImovel != null){

				hql.append("imov.id = :idImovel and ");
			}

			if(idFaturamentoGrupo != null){

				hql.append("rota.faturamentoGrupo.id = :idFaturamentoGrupo and");
			}

			hql.append("  qadb.anoReferencia = :anoReferencia ");

			// hql.append("order by qadb.clienteResponsavel.id, ");
			// hql.append("         rota.codigo, ");
			// hql.append("         loca.gerenciaRegional.id, ");
			// hql.append("         loca.localidade.id, ");
			// hql.append("         loca.id, ");
			// hql.append("         stcm.codigo, ");
			// hql.append("         qdra.numeroQuadra, ");
			// hql.append("         imov.lote, ");
			// hql.append("         imov.subLote, ");
			// hql.append("         imov.id ");

			// inscrição antiga: local, código do setor comercial, código da rota, segmento, lote e
			// sublote).
			hql.append("order by  ");
			hql.append("         loca.id, ");
			hql.append("         stcm.codigo, ");
			hql.append("         rota.codigo, ");
			hql.append("         imov.numeroSegmento, ");
			hql.append("         imov.lote, ");
			hql.append("         imov.subLote ");

			Query query = session.createQuery(hql.toString());

			if(idImovel != null){

				query.setInteger("idImovel", idImovel);
			}

			if(idFaturamentoGrupo != null){

				query.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			}

			query.setInteger("anoReferencia", anoReferencia);

			retorno = (Collection<QuitacaoDebitoAnual>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0003] Verificar Não Geração da Declaração para o Imóvel – Modelo 2
	 * 
	 * @author Hebert Falcão
	 * @created 28/04/2013
	 */
	public boolean verificarImovelContasVencidasAnoReferencia(Integer idImovel, Date dataInicial, Date dataFinal)
					throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select count(*) ");
			consulta.append("from conta cnta ");
			consulta.append("where cnta.imov_id = :idImovel ");
			consulta.append("  and cnta.dcst_idatual in (:debitoCreditoSituacaoNormal, :debitoCreditoSituacaoRetificada, ");
			consulta.append("                            :debitoCreditoSituacaoIncluida, :debitoCreditoSituacaoEntradaParcelamento) ");
			consulta.append("  and cnta.cnta_dtvencimentoconta between :dataInicial and :dataFinal ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.setInteger("idImovel", idImovel);
			query.setInteger("debitoCreditoSituacaoNormal", DebitoCreditoSituacao.NORMAL);
			query.setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA);
			query.setInteger("debitoCreditoSituacaoIncluida", DebitoCreditoSituacao.INCLUIDA);
			query.setInteger("debitoCreditoSituacaoEntradaParcelamento", DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
			query.setDate("dataInicial", dataInicial);
			query.setDate("dataFinal", dataFinal);

			Number qtd = (Number) query.setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0003] Verificar Não Geração da Declaração para o Imóvel – Modelo 2
	 * 
	 * @author Hebert Falcão
	 * @created 28/04/2013
	 */
	public boolean verificarImovelGuiasVencidasAnoReferencia(Integer idImovel, Date dataInicial, Date dataFinal)
					throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select count(*) ");
			consulta.append("from guia_pagamento_prestacao gppr ");
			consulta.append("inner join guia_pagamento gpag on gpag.gpag_id = gppr.gpag_id ");
			consulta.append("where gpag.imov_id = :idImovel ");
			consulta.append("  and gppr.gppr_dtvencimento between :dataInicial and :dataFinal ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.setInteger("idImovel", idImovel);
			query.setDate("dataInicial", dataInicial);
			query.setDate("dataFinal", dataFinal);

			Number qtd = (Number) query.setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0003] Verificar Não Geração da Declaração para o Imóvel – Modelo 2
	 * 
	 * @author Hebert Falcão
	 * @created 28/04/2013
	 */
	public boolean verificarPagamentosHistoricoParaImovelAnoReferencia(Integer idImovel, Integer referenciaInicial, Integer referenciaFinal)
					throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select count(*) ");
			consulta.append("from pagamento_historico pghi ");
			consulta.append("where pghi.imov_id = :idImovel ");
			consulta.append("  and pghi.pghi_amreferenciapagamento between :referenciaInicial and :referenciaFinal ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.setInteger("idImovel", idImovel);
			query.setInteger("referenciaInicial", referenciaInicial);
			query.setInteger("referenciaFinal", referenciaFinal);

			Number qtd = (Number) query.setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0003] Verificar Não Geração da Declaração para o Imóvel – Modelo 2
	 * 
	 * @author Hebert Falcão
	 * @created 28/04/2013
	 */
	public boolean verificarImovelParcelamentoAnoReferencia(Integer idImovel, Integer referenciaFinal, Date dataFinal)
					throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select count(*) ");
			consulta.append("from conta_historico cnhi ");
			consulta.append("where cnhi.imov_id = :idImovel ");
			consulta.append("  and cnhi.cnhi_amreferenciaconta <= :referenciaFinal ");
			consulta.append("  and cnhi.cnhi_dtvencimentoconta <= :dataFinal ");
			consulta.append("  and cnhi.dcst_idatual in (:debitoCreditoSituacaoNormal, :debitoCreditoSituacaoRetificada, ");
			consulta.append("                            :debitoCreditoSituacaoIncluida, :debitoCreditoSituacaoEntradaParcelamento, ");
			consulta.append("                            :debitoCreditoSituacaoParcelada) ");
			consulta.append("  and cnhi.cnhi_tmultimaalteracao > :dataHoraFinal ");

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.setInteger("idImovel", idImovel);
			query.setInteger("referenciaFinal", referenciaFinal);
			query.setDate("dataFinal", dataFinal);
			query.setInteger("debitoCreditoSituacaoNormal", DebitoCreditoSituacao.NORMAL);
			query.setInteger("debitoCreditoSituacaoRetificada", DebitoCreditoSituacao.RETIFICADA);
			query.setInteger("debitoCreditoSituacaoIncluida", DebitoCreditoSituacao.INCLUIDA);
			query.setInteger("debitoCreditoSituacaoEntradaParcelamento", DebitoCreditoSituacao.ENTRADA_DE_PARCELAMENTO);
			query.setInteger("debitoCreditoSituacaoParcelada", DebitoCreditoSituacao.PARCELADA);
			query.setTimestamp("dataHoraFinal", dataFinal);

			Number qtd = (Number) query.setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3014] Emitir Declaração Anual Quitação Débitos
	 * [SB0001] Emitir Declaração Anual de Quitação de Débitos
	 * 
	 * @author Hebert Falcão
	 * @created 27/04/2013
	 */
	public Integer pesquisarQuitacaoDebitoAnualParaEmicaoQtd(Integer idFaturamentoGrupo, Integer anoReferencia)
					throws ErroRepositorioException{

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select count(qadb.id) ");
			hql.append("from QuitacaoDebitoAnual qadb ");
			hql.append("inner join qadb.imovel imov ");
			hql.append("inner join imov.localidade loca ");
			hql.append("inner join imov.rota rota ");
			hql.append("where rota.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append("  and qadb.anoReferencia = :anoReferencia ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			query.setInteger("anoReferencia", anoReferencia);

			retorno = ((Number) query.uniqueResult()).intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#obterPercentualEsgotoHistogramaEsgotoEconomia(java
	 * .lang.Integer, java.lang.Integer, java.lang.Integer, java.lang.Integer)
	 */
	public Short obterPercentualEsgotoHistogramaEsgotoEconomia(Integer anoMesFaturamento, Integer idGerenciaRegional, Integer idLocalidade,
					Integer idCategoria) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Short retorno = 0;

		try{

			Criteria criteria = session.createCriteria(HistogramaEsgotoEconomia.class);
			criteria.setProjection(Projections.property("percentualEsgoto"));

			if(anoMesFaturamento != null){

				criteria.add(Restrictions.eq("referencia", anoMesFaturamento));

			}

			if(idGerenciaRegional != null){

				criteria.add(Restrictions.eq("gerenciaRegional.id", idGerenciaRegional));

			}

			if(idLocalidade != null){

				criteria.add(Restrictions.eq("localidade.id", idLocalidade));

			}

			if(idCategoria != null){

				criteria.add(Restrictions.eq("categoria.id", idCategoria));

			}

			retorno = (Short) criteria.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

		return retorno;

	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#obterValorTarifaVigentePorCategoria(java.lang.Integer
	 * , java.lang.Integer, java.lang.Integer)
	 */
	public BigDecimal obterValorTarifaVigentePorCategoria(Integer idConsumoTarifaDefault, Integer anoMesReferencia, Integer idCategoria,
					Integer numeroFaixaInicio, Integer numeroFaixaFim, boolean isPrimeiraFaixa) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Calendar cDataVigencia = Calendar.getInstance();
		cDataVigencia.setTime(Util.gerarDataInicialApartirAnoMesRefencia(anoMesReferencia));
		cDataVigencia.set(Calendar.DAY_OF_MONTH, cDataVigencia.getActualMaximum(Calendar.DAY_OF_MONTH));

		BigDecimal valorTarifaVigente = null;

		try{

			Criteria criteria = session.createCriteria(ConsumoTarifaFaixa.class);
			criteria.createAlias("consumoTarifaCategoria", "consumoTarifaCategoria", Criteria.INNER_JOIN);
			criteria.createAlias("consumoTarifaCategoria.consumoTarifaVigencia", "consumoTarifaVigencia", Criteria.INNER_JOIN);
			criteria.createAlias("consumoTarifaCategoria.categoria", "categoria", Criteria.INNER_JOIN);
			criteria.createAlias("consumoTarifaVigencia.consumoTarifa", "consumoTarifa", Criteria.INNER_JOIN);
			criteria.add(Restrictions.eq("consumoTarifa.id", idConsumoTarifaDefault));
			criteria.add(Restrictions.le("consumoTarifaVigencia.dataVigencia", cDataVigencia.getTime()));
			criteria.add(Restrictions.eq("categoria.id", idCategoria));

			if(numeroFaixaInicio != null){

				criteria.add(Restrictions.eq("numeroConsumoFaixaInicio", numeroFaixaInicio));

			}

			if(numeroFaixaFim != null){

				criteria.add(Restrictions.eq("numeroConsumoFaixaIFim", numeroFaixaFim));

			}

			if(isPrimeiraFaixa) criteria.setProjection(Projections.property("consumoTarifaCategoria.valorTarifaMinima"));
			else criteria.setProjection(Projections.property("valorConsumoTarifa"));

			criteria.addOrder(Order.desc("consumoTarifaVigencia.dataVigencia"));

			valorTarifaVigente = (BigDecimal) criteria.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);

		}

		return valorTarifaVigente;

	}
	
	/**
	 * Ajuste
	 * Reverter contas pré-faturadas
	 */

	public Collection<Conta> pesquisarConta(Integer referencia, Integer faturamentoGrupo, Integer situacao) throws ErroRepositorioException{

		Collection<Conta> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select conta ");
			hql.append("from Conta conta ");
			hql.append("inner join conta.rota rota ");
			hql.append("where conta.referencia = :referencia ");
			hql.append("  and rota.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append("  and conta.debitoCreditoSituacaoAtual = :situacao ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("referencia", referencia);
			query.setInteger("idFaturamentoGrupo", faturamentoGrupo);
			query.setInteger("situacao", situacao);

			retorno = (Collection<Conta>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// select * from debito_cobrado where cnta_id in (select cnta_id
	// from conta where imov_id in (select imov_id from movimento_roteiro_empresa where ftgr_id =
	// 100 and mrem_ammovimento= 201304 )
	// and cnta_amreferenciaconta = 201304 and dcst_idatual = 9);

	public Collection<DebitoCobrado> pesquisarDebitoCobrado(Integer idConta) throws ErroRepositorioException{

		Collection<DebitoCobrado> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select debitoCobrado ");
			hql.append("from DebitoCobrado debitoCobrado ");
			hql.append("inner join debitoCobrado.conta conta ");
			hql.append("inner join conta.rota rota ");
			hql.append("where ");			
			hql.append("   conta.id = :idConta ");

			Query query = session.createQuery(hql.toString());			
			query.setInteger("idConta", idConta);

			retorno = (Collection<DebitoCobrado>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// select count(*) from debito_a_cobrar where imov_id in (select imov_id from
	// movimento_roteiro_empresa where ftgr_id = 100 and mrem_ammovimento= 201304 ) and
	// dbac_amrefultimacobranca = 201304

	public Collection<DebitoACobrar> pesquisarDebitoACobrarPorReferenciaUltimaCobranca(Integer referencia, Integer idImovel)
					throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select debitoACobrar ");
			hql.append("from DebitoACobrar debitoACobrar ");
			hql.append("where ");
			hql.append("   debitoACobrar.imovel.id = :idImovel ");
			hql.append(" and  debitoACobrar.anoMesReferenciaUltimaCobranca = :referencia ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idImovel", idImovel);
			query.setInteger("referencia", referencia);

			retorno = (Collection<DebitoACobrar>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<DebitoACobrar> pesquisarDebitoACobrarHistoricoPorReferenciaUltimaCobranca(Integer referencia, Integer idImovel)
					throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select debitoACobrarHistorico ");
			hql.append("from DebitoACobrarHistorico debitoACobrarHistorico ");
			hql.append("where ");
			hql.append("   debitoACobrarHistorico.imovel.id = :idImovel ");
			hql.append(" and  debitoACobrarHistorico.anoMesReferenciaUltimaCobranca = :referencia ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idImovel", idImovel);
			query.setInteger("referencia", referencia);

			retorno = (Collection<DebitoACobrar>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar os débitos que não estão no histórico
	 * para atualizar o número de prestações.
	 * select dc.* from debito_cobrado dc
	 * inner join conta c on c.cnta_id = dc.cnta_id
	 * inner join rota r on r.rota_id = c.rota_id
	 * where r.ftgr_id = 100 and
	 * c.cnta_amreferenciaconta = 201304 and
	 * dc.dbcb_nnprestacao > dbcb_nnprestacaodebito
	 */
	public Collection<Integer> pesquisarImovelDoDebitoCobradoPorPrestacaoCobradas(Integer idFaturamentoGrupo, Integer anoMesReferencia,
					String sinal) throws ErroRepositorioException{

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select conta.imovel.id ");
			hql.append("from DebitoCobrado debitoCobrado ");
			hql.append("inner join debitoCobrado.conta conta ");
			hql.append("inner join conta.rota rota ");
			hql.append("where ");
			hql.append(" rota.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append(" and  conta.referencia = :anoMesReferencia ");
			hql.append(" and  debitoCobrado.numeroPrestacao ");
			hql.append("" + sinal + "");
			hql.append(" debitoCobrado.numeroPrestacaoDebito ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = (Collection<Integer>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<DebitoACobrar> pesquisarDebitoACobrarPorListaDeImoveis(Collection collIdImoveis,
					Integer anoMesReferenciaUltimaCobranca) throws ErroRepositorioException{

		Collection<DebitoACobrar> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select debitoACobrar ");
			hql.append("from DebitoACobrar debitoACobrar ");			
			hql.append("where ");
			hql.append(" debitoACobrar.imovel.id IN(:collIdImoveis)");
			hql.append(" and  debitoACobrar.anoMesReferenciaUltimaCobranca = :anoMesReferenciaUltimaCobranca ");
		

			Query query = session.createQuery(hql.toString());

			if(!Util.isVazioOrNulo(collIdImoveis) && collIdImoveis.size() > 1000){
				Collection colecaoAuxiliar = new ArrayList<Object>();

				for(Object id : collIdImoveis){
					colecaoAuxiliar.add(id);

					if(colecaoAuxiliar.size() == 1000){
						query.setParameterList("collIdImoveis", colecaoAuxiliar);
						query.setInteger("anoMesReferenciaUltimaCobranca", anoMesReferenciaUltimaCobranca);

						retorno.addAll((Collection<DebitoACobrar>) query.list());
						// retorno = (Collection<DebitoACobrarHistorico>) query.list();
						colecaoAuxiliar.clear();
					}
				}

				if(!Util.isVazioOrNulo(colecaoAuxiliar)){
					query.setParameterList("collIdImoveis", colecaoAuxiliar);
					query.setInteger("anoMesReferenciaUltimaCobranca", anoMesReferenciaUltimaCobranca);
					retorno.addAll((Collection<DebitoACobrar>) query.list());
				}
			}else{
				query.setParameterList("collIdImoveis", collIdImoveis);
				query.setInteger("anoMesReferenciaUltimaCobranca", anoMesReferenciaUltimaCobranca);

				retorno = (Collection<DebitoACobrar>) query.list();
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<DebitoACobrarHistorico> pesquisarDebitoACobrarHistoricoPorListaDeImoveis(Collection collIdImoveis,
					Integer anoMesReferenciaUltimaCobranca) throws ErroRepositorioException{

		Collection<DebitoACobrarHistorico> retorno = new ArrayList();
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select distinct debitoACobrarHistorico ");
			hql.append("from DebitoACobrarHistorico debitoACobrarHistorico ");
			hql.append("where ");
			hql.append(" debitoACobrarHistorico.imovel.id IN(:collIdImoveis)");
			hql.append(" and  debitoACobrarHistorico.anoMesReferenciaUltimaCobranca = :anoMesReferenciaUltimaCobranca ");


			Query query = session.createQuery(hql.toString());

			if(!Util.isVazioOrNulo(collIdImoveis) && collIdImoveis.size() > 1000){
				Collection colecaoAuxiliar = new ArrayList<Object>();

				for(Object id : collIdImoveis){
					colecaoAuxiliar.add(id);

					if(colecaoAuxiliar.size() == 1000){
						query.setParameterList("collIdImoveis", colecaoAuxiliar);
						query.setInteger("anoMesReferenciaUltimaCobranca", anoMesReferenciaUltimaCobranca);

						retorno.addAll((Collection<DebitoACobrarHistorico>) query.list());
						// retorno = (Collection<DebitoACobrarHistorico>) query.list();
						colecaoAuxiliar.clear();
					}
				}

				if(!Util.isVazioOrNulo(colecaoAuxiliar)){
					query.setParameterList("collIdImoveis", colecaoAuxiliar);
					query.setInteger("anoMesReferenciaUltimaCobranca", anoMesReferenciaUltimaCobranca);
					retorno.addAll((Collection<DebitoACobrarHistorico>) query.list());
				}
			}else{
				query.setParameterList("collIdImoveis", collIdImoveis);
				query.setInteger("anoMesReferenciaUltimaCobranca", anoMesReferenciaUltimaCobranca);

				retorno = (Collection<DebitoACobrarHistorico>) query.list();
			}





			// retorno = (Collection<DebitoACobrarHistorico>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<ContaCategoria> pesquisarContaCategoriaPorConta(Integer idConta) throws ErroRepositorioException{

		Collection<ContaCategoria> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select cc ");
			hql.append("from gcom.faturamento.conta.ContaCategoria cc ");
			hql.append("where cc.conta.id = :idConta ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idConta", idConta);

			retorno = (Collection<ContaCategoria>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<ClienteConta> pesquisarClienteConta(Integer referencia, Integer faturamentoGrupo, Integer situacao)
					throws ErroRepositorioException{

		Collection<ClienteConta> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select clienteConta ");
			hql.append("from ClienteConta clienteConta ");
			hql.append("inner join clienteConta.conta conta ");
			hql.append("inner join conta.rota rota ");
			hql.append("where conta.referencia = :referencia ");
			hql.append("  and rota.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append("  and conta.debitoCreditoSituacaoAtual = :situacao ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("referencia", referencia);
			query.setInteger("idFaturamentoGrupo", faturamentoGrupo);
			query.setInteger("situacao", situacao);

			retorno = (Collection<ClienteConta>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<MovimentoRoteiroEmpresa> pesquisarMovimentoRoteiroEmpresa(Integer referencia, Integer faturamentoGrupo,
					Integer situacao) throws ErroRepositorioException{

		Collection<MovimentoRoteiroEmpresa> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select movimentoRoteiroEmpresa ");
			hql.append("from MovimentoRoteiroEmpresa movimentoRoteiroEmpresa ");
			hql.append("inner join movimentoRoteiroEmpresa.imovel imovel ");
			hql.append("inner join imovel.rota rota ");
			hql.append("where movimentoRoteiroEmpresa.anoMesMovimento = :referencia ");
			hql.append("  and rota.faturamentoGrupo.id = :idFaturamentoGrupo ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("referencia", referencia);
			query.setInteger("idFaturamentoGrupo", faturamentoGrupo);

			retorno = (Collection<MovimentoRoteiroEmpresa>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<ContaGeral> pesquisarContaGeral(Integer referencia, Integer faturamentoGrupo, Integer situacao)
					throws ErroRepositorioException{

		Collection<ContaGeral> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select contaGeral ");
			hql.append("from ContaGeral contaGeral ");
			hql.append("inner join contaGeral.conta conta ");
			hql.append("inner join conta.rota rota ");
			hql.append("where conta.referencia = :referencia ");
			hql.append("  and rota.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append("  and conta.debitoCreditoSituacaoAtual = :situacao ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("referencia", referencia);
			query.setInteger("idFaturamentoGrupo", faturamentoGrupo);
			query.setInteger("situacao", situacao);

			retorno = (Collection<ContaGeral>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<DebitoCobrado> pesquisarDebitoCobradoPorPrestacaoCobradas(Integer idFaturamentoGrupo, Integer anoMesReferencia,
					String sinal) throws ErroRepositorioException{

		Collection<DebitoCobrado> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select debitoCobrado ");
			hql.append("from DebitoCobrado debitoCobrado ");
			hql.append("inner join debitoCobrado.conta conta ");
			hql.append("inner join conta.rota rota ");
			hql.append("where ");
			hql.append(" rota.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append(" and  conta.referencia = :anoMesReferencia ");
			hql.append(" and  debitoCobrado.numeroPrestacao ");
			hql.append("" + sinal + "");
			hql.append(" debitoCobrado.numeroPrestacaoDebito ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = (Collection<DebitoCobrado>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<Integer> pesquisarIdImoveisDebitoCobradoPorPrestacaoCobradas(Integer idFaturamentoGrupo, Integer anoMesReferencia,
					String sinal) throws ErroRepositorioException{

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select debitoCobrado.conta.imovel.id ");
			hql.append("from DebitoCobrado debitoCobrado ");
			hql.append("inner join debitoCobrado.conta conta ");
			hql.append("inner join conta.rota rota ");
			hql.append("where ");
			hql.append(" rota.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append(" and  conta.referencia = :anoMesReferencia ");
			hql.append(" and  debitoCobrado.numeroPrestacao ");
			hql.append("" + sinal + "");
			hql.append(" debitoCobrado.numeroPrestacaoDebito ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = (Collection<Integer>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @param idDebitoACobrarHistorico
	 * @throws ErroRepositorioException
	 */
	public void deletarDebitoACobrarCategoriaHistorico(Integer idDebitoACobrarHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete DebitoACobrarCategoriaHistorico dcc "
							+ "where dcc.debitoACobrarHistorico.id = :idDebitoACobrarHistorico ";

			session.createQuery(delete).setInteger("idDebitoACobrarHistorico", idDebitoACobrarHistorico).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public void deletarDebitoACobrarHistorico(Integer idDebitoACobrarHistorico) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete DebitoACobrarHistorico dcc " + "where dcc.id = :idDebitoACobrarHistorico ";

			session.createQuery(delete).setInteger("idDebitoACobrarHistorico", idDebitoACobrarHistorico).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * @param idDebitoACobrarHistorico
	 * @throws ErroRepositorioException
	 */
	public void deletarDebitoCobradoCategoria(Integer idDebitoCobrado) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete DebitoCobradoCategoria dcc " + "where dcc.debitoCobrado.id = :idDebitoCobrado ";

			session.createQuery(delete).setInteger("idDebitoCobrado", idDebitoCobrado).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public void deletarDebitoCobrado(Integer idDebitoCobrado) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete DebitoCobrado dcc " + "where dcc.id = :idDebitoCobrado ";

			session.createQuery(delete).setInteger("idDebitoCobrado", idDebitoCobrado).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public void deletarContaCategoria(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete gcom.faturamento.conta.ContaCategoria cc " + "where cc.comp_id.conta.id = :idConta ";

			session.createQuery(delete).setInteger("idConta", idConta).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	public void deletarClienteConta(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete ClienteConta cc " + "where cc.conta.id = :idConta ";

			session.createQuery(delete).setInteger("idConta", idConta).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	public void deletarConta(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete Conta cc " + "where cc.id = :idConta ";

			session.createQuery(delete).setInteger("idConta", idConta).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}
	
	public void deletarContaGeral(Integer idConta) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		try{
			String delete = "delete ContaGeral cg " + "where cg.id = :idConta ";

			session.createQuery(delete).setInteger("idConta", idConta).executeUpdate();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 */

	public Integer pesquisarDebitoACobrarPorParcelamento(Integer idParcelamento,Integer idDebitoCreditoSituacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append(" select max(DBAC_AMCOBRANCADEBITO) as anoMesCobrancaDebito from debito_a_cobrar  ");		
			consulta.append("where  ");			
				consulta.append(" parc_id = :idParcelamento  ");
				consulta.append(" and  dcst_idatual = :idDebitoCreditoSituacao  ");
			
			retorno = (Integer) session.createSQLQuery(consulta.toString()).addScalar("anoMesCobrancaDebito", Hibernate.INTEGER)
							.setInteger("idParcelamento", idParcelamento).setInteger("idDebitoCreditoSituacao", idDebitoCreditoSituacao)
							.uniqueResult();
			

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
    
	/**
	 * 
	 */
    public Integer pesquisarDebitoACobrarHistoricoPorParcelamento(Integer idParcelamento, Integer idDebitoCreditoSituacao)
	throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		StringBuilder consulta = new StringBuilder();

    	try{
			consulta.append(" select max(DAHI_AMCOBRANCADEBITO) as anoMesCobrancaDebito from debito_a_cobrar_historico  ");
			consulta.append("where  ");
			consulta.append(" parc_id = :idParcelamento  ");
			consulta.append(" and  dcst_idatual = :idDebitoCreditoSituacao  ");

			retorno = (Integer) session.createSQLQuery(consulta.toString()).addScalar("anoMesCobrancaDebito", Hibernate.INTEGER)
							.setInteger("idParcelamento", idParcelamento).setInteger("idDebitoCreditoSituacao", idDebitoCreditoSituacao)
				.uniqueResult();



		}catch(HibernateException e){

    		throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

    		HibernateUtil.closeSession(session);
		}

    	return retorno;
	}

	/**
	 * @param idParcelamento
	 * @param idDebitoCreditoSituacao
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Date pesquisarGuiaPagamentoPorParcelamento(Integer idParcelamento, Integer idDebitoCreditoSituacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Date retorno = null;
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append(" select max(GPAG_DTINCLUSAO) as dataInclusao from guia_pagamento  ");
			consulta.append("where  ");
			consulta.append(" parc_id = :idParcelamento  ");
			consulta.append(" and  dcst_id = :idDebitoCreditoSituacao  ");

			retorno = (Date) session.createSQLQuery(consulta.toString()).addScalar("dataInclusao", Hibernate.DATE)
							.setInteger("idParcelamento", idParcelamento).setInteger("idDebitoCreditoSituacao", idDebitoCreditoSituacao)
							.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @param idParcelamento
	 * @param idDebitoCreditoSituacao
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Date pesquisarGuiaPagamentoHistoricoPorParcelamento(Integer idParcelamento, Integer idDebitoCreditoSituacao)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Date retorno = null;
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append(" select max(GPHI_DTINCLUSAO) as dataInclusao from guia_pagamento_historico  ");
			consulta.append("where  ");
			consulta.append(" parc_id = :idParcelamento  ");
			consulta.append(" and  dcst_id = :idDebitoCreditoSituacao  ");

			retorno = (Date) session.createSQLQuery(consulta.toString()).addScalar("dataInclusao", Hibernate.DATE)
							.setInteger("idParcelamento", idParcelamento).setInteger("idDebitoCreditoSituacao", idDebitoCreditoSituacao)
							.uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// select a.cnta_id, cnta_vldebitos, sum(dbcb_vlprestacao), count(*) from conta a,
	// debito_cobrado b where cnta_amreferenciaconta <= 201301 and
	// substr(cnta_tmultimaalteracao,1,10)<'03/02/13'
	// and a.cnta_id=b.cnta_id group by a.cnta_id, cnta_vldebitos having cnta_vldebitos >
	// sum(dbcb_vlprestacao);

	public Collection<Object[]> pesquisarContasAjusteCasal() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select a.cnta_id as conta, cnta_vldebitos as valorDebitosConta, sum(dbcb_vlprestacao) as valorPestacao , count(*) as quantidadeDebitos from conta a,  ");
			consulta.append(" debito_cobrado b where cnta_amreferenciaconta <= 201301 and  ");
			consulta.append("substr(cnta_tmultimaalteracao,1,10)<'03/02/13'  ");
			consulta.append("and a.cnta_id=b.cnta_id group by a.cnta_id, cnta_vldebitos having cnta_vldebitos >  ");
			consulta.append(" sum(dbcb_vlprestacao)  ");

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta.toString()).addScalar("conta", Hibernate.INTEGER)
							.addScalar("valorDebitosConta", Hibernate.BIG_DECIMAL).addScalar("valorPestacao", Hibernate.BIG_DECIMAL)
							.addScalar("quantidadeDebitos", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public DebitoCobradoCategoria buscarDebitoCobradoCategoriaPorId(Integer idDebitoCobrado) throws ErroRepositorioException{

		DebitoCobradoCategoria retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = " SELECT dbcc FROM DebitoCobradoCategoria dbcc " + " INNER JOIN dbcc.debitoCobrado dbco "
							+ " INNER JOIN dbco.conta conta " + " WHERE dbco.id = :idDebitoCobrado ";

			retorno = (DebitoCobradoCategoria) session.createQuery(consulta).setInteger("idDebitoCobrado", idDebitoCobrado).uniqueResult();

			Hibernate.initialize(retorno.getDebitoCobrado());
			Hibernate.initialize(retorno.getComp_id());
			Hibernate.initialize(retorno.getCategoria());

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public DebitoCobrado pesquisarMaiorIdDebitoCobradoPorIdConta(Integer idConta) throws ErroRepositorioException{

		DebitoCobrado retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select dbcb "
							+ "from DebitoCobrado dbcb "
							+ "inner join dbcb.conta cnta "
							+ "where cnta.id = :idConta  and  dbcb.id in (select max(dc.id) from DebitoCobrado dc where dc.conta.id = :idConta ) ";

			// executa o hql
			retorno = (DebitoCobrado) session.createQuery(consulta).setInteger("idConta", idConta).uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// select a.cnta_id, cnhi_vldebitos, sum(dbhi_vlprestacao), count(*)
	// from conta_historico a, debito_cobrado_historico b
	// where cnhi_amreferenciaconta <= 201301
	// and dcst_idatual=5
	// and a.cnta_id=b.cnta_id
	// and imov_id in
	// (select imov_id from imovel_cobranca_situacao where iscb_dtretiradacobranca is null and
	// CBST_ID = 4 )
	// group by a.cnta_id, cnhi_vldebitos having cnhi_vldebitos > sum(dbhi_vlprestacao);

	public Collection<Object[]> pesquisarContasHistoricoAjusteCasal(String condicao) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select a.cnta_id as conta, cnhi_vldebitos as valorDebitosConta, sum(dbhi_vlprestacao) as valorPestacao , count(*) as quantidadeDebitos from conta_historico a,  ");
			consulta.append(" debito_cobrado_historico b where cnhi_amreferenciaconta <= 201301   ");
			consulta.append(" and dcst_idatual = 5 ");
			consulta.append(" and a.cnta_id=b.cnta_id ");
			consulta.append(" and imov_id in  ");
			consulta.append(" (select imov_id from imovel_cobranca_situacao where iscb_dtretiradacobranca is null and CBST_ID = 4 )  ");
			consulta.append(" group by a.cnta_id, cnhi_vldebitos having cnhi_vldebitos " + condicao + " sum(dbhi_vlprestacao) ");

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta.toString()).addScalar("conta", Hibernate.INTEGER)
							.addScalar("valorDebitosConta", Hibernate.BIG_DECIMAL).addScalar("valorPestacao", Hibernate.BIG_DECIMAL)
							.addScalar("quantidadeDebitos", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @param idContaHistorico
	 * @return
	 * @throws ErroRepositorioException
	 */

	public DebitoCobradoHistorico pesquisarMaiorIdDebitoCobradoHistoricoPorIdContaHistorico(Integer idContaHistorico)
					throws ErroRepositorioException{

		DebitoCobradoHistorico retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "select dbcb "
							+ "from DebitoCobradoHistorico dbcb "
							+ "inner join dbcb.contaHistorico cnta "
							+ "where cnta.id = :idContaHistorico  and  dbcb.id in (select max(dc.id) from DebitoCobradoHistorico dc where dc.contaHistorico.id = :idContaHistorico ) ";

			// executa o hql
			retorno = (DebitoCobradoHistorico) session.createQuery(consulta).setInteger("idContaHistorico", idContaHistorico)
							.uniqueResult();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 */
	public Collection<DebitoCobradoHistorico> pesquisarDebitoCobradoHistoricoPorIdContaHistorico(Integer idContaHistorico)
					throws ErroRepositorioException{

		Collection<DebitoCobradoHistorico> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select dbcb from DebitoCobradoHistorico dbcb inner join dbcb.contaHistorico cnta where cnta.id = :idContaHistorico  ";

			// executa o hql
			retorno = (Collection<DebitoCobradoHistorico>) session.createQuery(consulta.toString())
							.setInteger("idContaHistorico", idContaHistorico).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @param idDebitoCobrado
	 * @throws ErroRepositorioException
	 */

	public void removerDebitoCobradoCategoriaHistorico(Integer idDebitoCobrado) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();
		try{

			sql.append(" delete from debito_cobrado_categoria_hist where  ");
			sql.append(" dbhi_id  = :idDebitoCobrado ");

			session.createSQLQuery(sql.toString()).setInteger("idDebitoCobrado", idDebitoCobrado).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * @param idDebitoCobrado
	 * @throws ErroRepositorioException
	 */

	public void removerDebitoCobradoHistorico(Integer idDebitoCobrado) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();
		try{

			sql.append(" delete from debito_cobrado_historico where  ");
			sql.append(" dbhi_id  = :idDebitoCobrado ");

			session.createSQLQuery(sql.toString()).setInteger("idDebitoCobrado", idDebitoCobrado).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0084] - Gerar Faturamento Imediato
	 * [SB0004] – Obter os Créditos a Realizar
	 * 
	 * @author Anderson Italo
	 * @date 08/05/2013
	 */
	public Collection<CreditoARealizar> pesquisarCreditosARealizarImovelFaturamentoImediato(Integer idImovel, Integer anoMesCobrancaDebito,
					boolean isRetornoFaturamento, Date dataGeracaoFaturamento) throws ErroRepositorioException{

		Collection<CreditoARealizar> colecaoCreditos = null;
		List<Object[]> retornoConsulta = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			if(isRetornoFaturamento){

				consulta.append(" select car.crar_nnprestacaocredito as colum1, car.crar_nnprestacaorealizadas as colum2, car.crar_nnparcelabonus as colum3, ");
				consulta.append(" car.crar_vlresidualmesanterior as colum4, car.crar_vlcredito as colum5, car.dcst_idatual as colum6, ");
				consulta.append(" ct.crti_id as colum7, ct.crti_dscreditotipo as colum8, ");
				consulta.append(" car.parc_id as colum9, pa.parc_amreferenciafaturamento as colum10, ");
				consulta.append(" car.crar_amreferenciacredito as colum11, ");
				consulta.append(" car.crar_id as colum12 ");
				consulta.append(" from credito_a_realizar car ");
				consulta.append(" inner join credito_tipo ct on ct.crti_id = car.crti_id ");
				consulta.append(" left join parcelamento pa on pa.parc_id = car.parc_id ");
				consulta.append(" where ");
				consulta.append(" car.imov_id = :idImovel ");
				consulta.append(" and car.dcst_idatual = :idDebitoCreditoSituacao ");
				consulta.append(" and ((car.crar_nnprestacaorealizadas < car.crar_nnprestacaocredito) ");
				consulta.append(" 	or car.crar_vlresidualmesanterior > 0) ");
				consulta.append(" and car.crar_amcobrancacredito <= :anoMesCobrancaCredito ");
				consulta.append(" and car.crar_tmatucredito <= :dataGeracaoFaturamento ");
				consulta.append(" order by car.crar_amreferenciacredito asc, car.crar_vlcredito desc ");

				retornoConsulta = session.createSQLQuery(consulta.toString()).addScalar("colum1", Hibernate.SHORT)
								.addScalar("colum2", Hibernate.SHORT).addScalar("colum3", Hibernate.SHORT)
								.addScalar("colum4", Hibernate.BIG_DECIMAL).addScalar("colum5", Hibernate.BIG_DECIMAL)
								.addScalar("colum6", Hibernate.INTEGER).addScalar("colum7", Hibernate.INTEGER)
								.addScalar("colum8", Hibernate.STRING).addScalar("colum9", Hibernate.INTEGER)
								.addScalar("colum10", Hibernate.INTEGER).addScalar("colum11", Hibernate.INTEGER)
								.addScalar("colum12", Hibernate.INTEGER).setInteger("idImovel", idImovel)
								.setInteger("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL)
								.setInteger("anoMesCobrancaCredito", anoMesCobrancaDebito)
								.setTimestamp("dataGeracaoFaturamento", dataGeracaoFaturamento).list();

			}else{

				consulta.append(" select car.crar_nnprestacaocredito as colum1, car.crar_nnprestacaorealizadas as colum2, car.crar_nnparcelabonus as colum3, ");
				consulta.append(" car.crar_vlresidualmesanterior as colum4, car.crar_vlcredito as colum5, car.dcst_idatual as colum6, ");
				consulta.append(" ct.crti_id as colum7, ct.crti_dscreditotipo as colum8, ");
				consulta.append(" car.parc_id as colum9, pa.parc_amreferenciafaturamento as colum10, ");
				consulta.append(" car.crar_amreferenciacredito as colum11, ");
				consulta.append(" car.crar_id as colum12 ");
				consulta.append(" from credito_a_realizar car ");
				consulta.append(" inner join credito_tipo ct on ct.crti_id = car.crti_id ");
				consulta.append(" left join parcelamento pa on pa.parc_id = car.parc_id ");
				consulta.append(" where ");
				consulta.append(" car.imov_id = :idImovel ");
				consulta.append(" and car.dcst_idatual = :idDebitoCreditoSituacao ");
				consulta.append(" and ((car.crar_nnprestacaorealizadas < car.crar_nnprestacaocredito) ");
				consulta.append(" 	or car.crar_vlresidualmesanterior > 0) ");
				consulta.append(" and car.crar_amcobrancacredito <= :anoMesCobrancaCredito ");
				consulta.append(" order by car.crar_amreferenciacredito asc, car.crar_vlcredito desc ");

				retornoConsulta = session.createSQLQuery(consulta.toString()).addScalar("colum1", Hibernate.SHORT)
								.addScalar("colum2", Hibernate.SHORT).addScalar("colum3", Hibernate.SHORT)
								.addScalar("colum4", Hibernate.BIG_DECIMAL).addScalar("colum5", Hibernate.BIG_DECIMAL)
								.addScalar("colum6", Hibernate.INTEGER).addScalar("colum7", Hibernate.INTEGER)
								.addScalar("colum8", Hibernate.STRING).addScalar("colum9", Hibernate.INTEGER)
								.addScalar("colum10", Hibernate.INTEGER).addScalar("colum11", Hibernate.INTEGER)
								.addScalar("colum12", Hibernate.INTEGER).setInteger("idImovel", idImovel)
								.setInteger("idDebitoCreditoSituacao", DebitoCreditoSituacao.NORMAL)
								.setInteger("anoMesCobrancaCredito", anoMesCobrancaDebito).list();

			}

			if(!Util.isVazioOrNulo(retornoConsulta)){

				colecaoCreditos = new ArrayList<CreditoARealizar>();

				for(Object[] dadosCredito : retornoConsulta){

					CreditoARealizar creditoARealizar = new CreditoARealizar();
					if(dadosCredito[0] != null){

						creditoARealizar.setNumeroPrestacaoCredito(((Number) dadosCredito[0]).shortValue());
					}

					if(dadosCredito[1] != null){

						creditoARealizar.setNumeroPrestacaoRealizada(((Number) dadosCredito[1]).shortValue());
					}

					if(dadosCredito[2] != null){

						creditoARealizar.setNumeroParcelaBonus(((Number) dadosCredito[2]).shortValue());
					}

					if(dadosCredito[3] != null){

						creditoARealizar.setValorResidualMesAnterior((BigDecimal) dadosCredito[3]);
					}

					if(dadosCredito[4] != null){

						creditoARealizar.setValorCredito((BigDecimal) dadosCredito[4]);
					}

					if(dadosCredito[5] != null){

						DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao(((Number) dadosCredito[5]).intValue());
						creditoARealizar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
					}

					if(dadosCredito[6] != null){

						CreditoTipo creditoTipo = new CreditoTipo(((Number) dadosCredito[6]).intValue());
						creditoTipo.setDescricao((String) dadosCredito[7]);
						creditoARealizar.setCreditoTipo(creditoTipo);
					}

					if(dadosCredito[8] != null){

						Parcelamento parcelamento = new Parcelamento(((Number) dadosCredito[8]).intValue());
						parcelamento.setAnoMesReferenciaFaturamento(((Number) dadosCredito[9]).intValue());
						creditoARealizar.setParcelamento(parcelamento);
					}

					if(dadosCredito[10] != null){

						creditoARealizar.setAnoMesReferenciaCredito(((Number) dadosCredito[10]).intValue());
					}

					creditoARealizar.setId(((Number) dadosCredito[11]).intValue());

					colecaoCreditos.add(creditoARealizar);
				}
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
		return colecaoCreditos;
	}


	public void removerDebitoACobrarCategoriaHistorico(Integer idDebitoACobrar) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();
		try{

			sql.append(" delete from debito_a_cobrar_categoria_hist where  ");
			sql.append(" dbac_id  = :idDebitoACobrar ");

			session.createSQLQuery(sql.toString()).setInteger("idDebitoACobrar", idDebitoACobrar).executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * @param debitoACobrarCategoria
	 * @throws ErroRepositorioException
	 */

	public void inserirDebitoACobrarCategoria(DebitoACobrarCategoria debitoACobrarCategoria) throws ErroRepositorioException{

		StatelessSession session = HibernateUtil.getStatelessSession();

		try{

			session.insert(debitoACobrarCategoria);

		}catch(HibernateException e){
			throw new ErroRepositorioException("Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
	}

	public Collection pesquisarIdsContaAjusteContasEnviadasHistoricoPreFaturadasComValor(String idRota) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<Object>();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("select ch.cnta_id as idConta from conta_historico ch where ch.cnhi_amreferenciaconta = 201306 ");
			consulta.append("				and ch.dcst_idatual = 9 ");
			consulta.append("				and nvl(ch.cnhi_vlagua,0) = 0");
			consulta.append("				and nvl(ch.cnhi_vlesgoto,0) = 0");
			consulta.append("and nvl(ch.cnhi_vldebitos,0) = 0");
			consulta.append("and exists (select 1 from movimento_roteiro_empresa mov where mov.imov_id = ch.imov_id");
			consulta.append("				and mov.mrem_ammovimento = 201306 and mov.rota_id = " + idRota);
			consulta.append("				and (nvl(mov.mrem_vlagua,0) > 0 or nvl(mov.mrem_vlesgoto,0) > 0)");
			consulta.append("				)");

			retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * [SF009] - Adiconar na coleção para gerar o resumo faturamento simulação
	 * 
	 * @date 19/06/2013
	 */
	public Collection<ResumoFaturamentoSimulacao> pesquisarResumoFaturamentoSimulacao(Integer idFaturamentoGrupo, Integer anoMesReferencia,
					Integer idRota) throws ErroRepositorioException{

		Collection<ResumoFaturamentoSimulacao> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{
			hql.append("select rfts from ResumoFaturamentoSimulacao rfts ");
			hql.append("where ");
			hql.append(" rfts.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append(" and  rfts.anoMesReferencia = :anoMesReferencia ");
			hql.append(" and  rfts.rota.id = :idRota ");
			hql.append(" and  rfts.indicadorSimulacao = :indicadorSimulacao ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			query.setInteger("anoMesReferencia", anoMesReferencia);
			query.setInteger("idRota", idRota);
			query.setInteger("indicadorSimulacao", ConstantesSistema.NAO.intValue());

			retorno = (Collection<ResumoFaturamentoSimulacao>) query.list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3100] Consultar Histórico de Débito Automático Imóvel
	 * 24/07/2013
	 * 
	 * @param imovel
	 * @param ehContasOuGuia
	 *            true = ContaGeral, false GuiaPagamento
	 * @return retorna lista debito automatico movimento
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarDebitoAutomaticoMovimentoPorImovel(Integer idImovel, boolean ehContasOuGuia)
					throws ErroRepositorioException{

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select dam.damv_id as id, ");
			consulta.append(" dam.cnta_id as idConta, ");
			consulta.append(" cg.cntg_ichistorico indicadorHistorico,  ");
			consulta.append(" dam.gpag_id as idGuia,   ");
			consulta.append(" dam.DAMV_NNPRESTACAO as prestacao,   ");
			consulta.append(" i.imov_id as idImovel,   ");
			consulta.append(" dam.DAMV_TMENVIOBANCO as dtEnvio,  ");
			consulta.append(" dam.DAMV_DTVENCIMENTO as dtVencimento,  ");
			consulta.append(" dam.DAMV_TMRETORNOBANCO as tsRetornoBco, ");
			consulta.append(" dam.DAMV_VLDEBITO as valorDebito,  ");
			consulta.append(" damcm.damc_dsmotivo as descMotivo,  ");
			consulta.append(" (select MIN(DAMV_TMULTIMAALTERACAO) from debito_automatico_movimento) as tsUltimaAlteracao,  ");
			consulta.append(" darc.DURC_DSDEBITOAUTOMATICO as descRetornoCod, ");
			consulta.append(" dam.damv_icexclusao as indicadorExclusao ");
			consulta.append("   ");
			consulta.append("  from debito_automatico_movimento dam  ");
			consulta.append("  inner join debito_automatico d on dam.deba_id = d.deba_id ");
			consulta.append("  inner join imovel i on i.imov_id = d.imov_id ");
			consulta.append("  left join conta_geral cg on cg.cnta_id = dam.cnta_id ");
			consulta.append("  left join guia_pagamento gp on gp.gpag_id = dam.gpag_id ");
			consulta.append("  left join debito_autom_movto_canc_motivo damcm on damcm.damc_id = dam.damc_id ");
			consulta.append("  left join DEBITO_AUTOMATICO_RETORNO_COD darc on darc.durc_id = dam.durc_id ");
			consulta.append("   ");
			consulta.append(" where i.imov_id = " + idImovel);

			if(ehContasOuGuia){
				consulta.append(" and dam.cnta_id is not null ");
			}else{
				consulta.append(" and dam.gpag_id is not null ");
			}

			consulta.append("ORDER BY dam.damv_id desc ");

			SQLQuery sqlQuery = session.createSQLQuery(consulta.toString());
			sqlQuery.addScalar("id", Hibernate.INTEGER);
			sqlQuery.addScalar("idConta", Hibernate.INTEGER);
			sqlQuery.addScalar("indicadorHistorico", Hibernate.SHORT);
			sqlQuery.addScalar("idGuia", Hibernate.INTEGER);
			sqlQuery.addScalar("prestacao", Hibernate.INTEGER);
			sqlQuery.addScalar("idImovel", Hibernate.INTEGER);
			sqlQuery.addScalar("dtEnvio", Hibernate.DATE);
			sqlQuery.addScalar("dtVencimento", Hibernate.DATE);
			sqlQuery.addScalar("tsRetornoBco", Hibernate.TIMESTAMP);
			sqlQuery.addScalar("valorDebito", Hibernate.BIG_DECIMAL);
			sqlQuery.addScalar("descMotivo", Hibernate.STRING);
			sqlQuery.addScalar("tsUltimaAlteracao", Hibernate.TIMESTAMP);
			sqlQuery.addScalar("descRetornoCod", Hibernate.STRING);
			sqlQuery.addScalar("indicadorExclusao", Hibernate.SHORT);
			retorno = sqlQuery.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3055] - Encerrar Faturamento
	 * 
	 * @date 26/07/2013
	 */
	public Collection<Rota> consultarRotasGrupo(Integer idFaturamentoGrupo, Integer anoMesReferencia, int tipoConsulta)
					throws ErroRepositorioException{

		Collection<Rota> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuilder hql = new StringBuilder();

		try{
			if(tipoConsulta == ConstantesSistema.CONSULTA_ROTAS_FATURADAS){
				hql.append("select rota ");
				hql.append("from Rota rota ");
				hql.append("join fetch rota.setorComercial stcm ");
				hql.append("join rota.faturamentoAtivCronRotas facr ");
				hql.append("join facr.faturamentoAtividadeCronograma ftac ");
				hql.append("join ftac.faturamentoGrupoCronogramaMensal ftcm ");
				hql.append("where ftac.faturamentoAtividade.descricao in ('FATURAR GRUPO','ATUALIZAR FATURAMENTO IMEDIATO') ");
				hql.append("and ftac.comando is not null ");
				hql.append("and ftac.dataRealizacao is not null ");
				hql.append("and ftcm.faturamentoGrupo = :idFaturamentoGrupo ");
				hql.append("and ftcm.anoMesReferencia = :anoMesReferencia ");
				hql.append("order by rota.faturamentoGrupo, rota.codigo ");

			}else if(tipoConsulta == ConstantesSistema.CONSULTA_ROTAS_NAO_FATURADAS){

				hql.append("select rota2 from Rota rota2 ");
				hql.append("join fetch rota2.setorComercial stcm ");
				hql.append("where rota2.faturamentoGrupo = :idFaturamentoGrupo ");
				hql.append("and rota2.id not in ( ");
				hql.append("select rota.id ");
				hql.append("from Rota rota ");
				hql.append("join rota.setorComercial stcm ");
				hql.append("join rota.faturamentoAtivCronRotas facr ");
				hql.append("join facr.faturamentoAtividadeCronograma ftac ");
				hql.append("join ftac.faturamentoGrupoCronogramaMensal ftcm ");
				hql.append("where ftac.faturamentoAtividade.descricao in ('FATURAR GRUPO','ATUALIZAR FATURAMENTO IMEDIATO') ");
				hql.append("and ftac.comando is not null ");
				hql.append("and ftac.dataRealizacao is not null ");
				hql.append("and ftcm.faturamentoGrupo = :idFaturamentoGrupo ");
				hql.append("and ftcm.anoMesReferencia = :anoMesReferencia ");
				hql.append(") ");
				hql.append("order by rota2.faturamentoGrupo, rota2.codigo ");
			}

			Query query = session.createQuery(hql.toString());

			query.setInteger("idFaturamentoGrupo", idFaturamentoGrupo);
			query.setInteger("anoMesReferencia", anoMesReferencia);

			retorno = (Collection<Rota>) query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#pesquisarClienteImovelCondominioHelper(java.lang
	 * .Integer)
	 */
	public List<ClienteImovelCondominioHelper> pesquisarClienteImovelCondominioHelper(Integer idImovel) throws ErroRepositorioException{

		List<Object> listRetorno = null;
		ClienteImovelCondominioHelper clienteImovelCondominioHelper = null;
		List<ClienteImovelCondominioHelper> lista = new ArrayList<ClienteImovelCondominioHelper>();

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT ");
			consulta.append("	c.CLIE_ID AS idCliente, ");
			consulta.append("	c.CLIE_NMCLIENTE AS nomeCliente, ");
			consulta.append("	crtp.CRTP_DSCLIENTERELACAOTIPO AS descricaoClienteRelacaoTipo, ");
			consulta.append("	ci.CLIM_DTRELACAOINICIO AS dataRelacaoInicio, ");
			consulta.append("	cf.CFON_CDDDD AS dddPrincipal, ");
			consulta.append("	cf.CFON_NNFONE AS telefonePrincipal, ");
			consulta.append("	CASE ");
			consulta.append("		WHEN (ctp.CLTP_ICPESSOAFISICAJURIDICA = :pessoaFisica) THEN (CLIE_NNCPF) ");
			consulta.append(" 		WHEN (ctp.CLTP_ICPESSOAFISICAJURIDICA = :pessoaJuridica) THEN (CLIE_NNCNPJ) ");
			consulta.append("	END AS cfpCnpj ");
			consulta.append("FROM CLIENTE_IMOVEL ci	");
			consulta.append("INNER JOIN CLIENTE c ON ci.CLIE_ID = c.CLIE_ID ");
			consulta.append("INNER JOIN CLIENTE_RELACAO_TIPO crtp ON ci.CRTP_ID = crtp.CRTP_ID ");
			consulta.append("LEFT JOIN CLIENTE_FONE cf ON ci.CLIE_ID = cf.CLIE_ID AND cf.CFON_ICFONEPADRAO = :indicadorTelefonePadrao ");
			consulta.append("INNER JOIN CLIENTE_TIPO ctp ON c.CLTP_ID = ctp.CLTP_ID ");
			consulta.append("WHERE ");
			consulta.append("	ci.IMOV_ID = :idImovel ");
			consulta.append("	AND ci.CLIM_DTRELACAOFIM IS NULL");

			SQLQuery sqlQuery = session.createSQLQuery(consulta.toString());
			sqlQuery.addScalar("idCliente", Hibernate.INTEGER);
			sqlQuery.addScalar("nomeCliente", Hibernate.STRING);
			sqlQuery.addScalar("descricaoClienteRelacaoTipo", Hibernate.STRING);
			sqlQuery.addScalar("dataRelacaoInicio", Hibernate.DATE);
			sqlQuery.addScalar("dddPrincipal", Hibernate.STRING);
			sqlQuery.addScalar("telefonePrincipal", Hibernate.STRING);
			sqlQuery.addScalar("cfpCnpj", Hibernate.STRING);

			sqlQuery.setInteger("idImovel", idImovel);
			sqlQuery.setShort("indicadorTelefonePadrao", ConstantesSistema.SIM);
			sqlQuery.setShort("pessoaFisica", ConstantesSistema.SIM);
			sqlQuery.setShort("pessoaJuridica", ConstantesSistema.NAO);

			listRetorno = (List<Object>) sqlQuery.list();

			if(Util.isNaoNuloBrancoZero(listRetorno)){

				for(Object object : listRetorno){
					Object[] objects = (Object[]) object;
					clienteImovelCondominioHelper = new ClienteImovelCondominioHelper((Integer) objects[0], (String) objects[1],
									(String) objects[2], (Date) objects[3], (String) objects[4], (String) objects[5], (String) objects[6]);
					lista.add(clienteImovelCondominioHelper);
				}
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return lista;
	}

	/*
	 * (non-Javadoc)
	 * @see
	 * gcom.faturamento.IRepositorioFaturamento#pesquisarHistoricoMedicaoIndividualizadaHelper(java
	 * .lang.Integer, java.lang.Integer, java.lang.Integer)
	 */
	public HistoricoMedicaoIndividualizadaHelper pesquisarHistoricoMedicaoIndividualizadaHelper(Integer idImovel, Integer idLigacaoTipo,
					Integer anoMesRefFaturamento) throws ErroRepositorioException{

		Object[] listRetorno = null;
		HistoricoMedicaoIndividualizadaHelper historicoMedicaoIndividualizadaHelper = null;
		List<HistoricoMedicaoIndividualizadaHelper> lista = new ArrayList<HistoricoMedicaoIndividualizadaHelper>();

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT ");
			consulta.append("CH.IMOV_ID AS idImovel, ");
			consulta.append(" COALESCE(RT.RTTP_DSRATEIOTIPO, ' ') AS dsRateioTipo, ");
			consulta.append(" COALESCE(CT.CSTP_DSCONSUMOTIPO,' ')      AS dsConsumoTipo, ");
			consulta.append(" COALESCE(MH.MDHI_NNCONSUMOMEDIDOMES,0)   AS consumoMedidoMes, ");
			consulta.append(" CH.CSHI_NNCONSUMORATEIO             AS consumoRateio,");
			consulta.append(" CH.CSHI_NNCONSUMOFATURADOMES        AS consumoFaturadoMes ");
			consulta.append(" FROM CONSUMO_HISTORICO CH	");
			consulta.append(" LEFT OUTER JOIN RATEIO_TIPO RT ");
			consulta.append(" ON RT.RTTP_ID = CH.RTTP_ID ");
			consulta.append(" LEFT OUTER JOIN CONSUMO_TIPO CT ");
			consulta.append(" ON CT.CSTP_ID = CH.CSTP_ID");
			consulta.append(" LEFT OUTER JOIN MEDICAO_HISTORICO MH");
			consulta.append(" ON (MH.LAGU_ID            = CH.IMOV_ID");
			consulta.append(" AND MH.MEDT_ID            = :idLigacaoTipo");
			consulta.append(" AND MH.MDHI_AMLEITURA     = CH.CSHI_AMFATURAMENTO)");
			consulta.append(" WHERE ");
			consulta.append(" CH.IMOV_ID = :idImovel ");
			consulta.append(" AND CH.LGTI_ID  = :idLigacaoTipo");
			consulta.append(" AND CH.CSHI_AMFATURAMENTO = :anoMesRefFaturamento");

			SQLQuery sqlQuery = session.createSQLQuery(consulta.toString());
			sqlQuery.addScalar("idImovel", Hibernate.INTEGER);
			sqlQuery.addScalar("dsRateioTipo", Hibernate.STRING);
			sqlQuery.addScalar("dsConsumoTipo", Hibernate.STRING);
			sqlQuery.addScalar("consumoMedidoMes", Hibernate.INTEGER);
			sqlQuery.addScalar("consumoRateio", Hibernate.INTEGER);
			sqlQuery.addScalar("consumoFaturadoMes", Hibernate.INTEGER);
			sqlQuery.setInteger("idImovel", idImovel);
			sqlQuery.setInteger("idLigacaoTipo", idLigacaoTipo);
			sqlQuery.setInteger("anoMesRefFaturamento", anoMesRefFaturamento);

			listRetorno = (Object[]) sqlQuery.setMaxResults(1).uniqueResult();

			if(Util.isNaoNuloBrancoZero(listRetorno)){

				// for(Object object : listRetorno){
				Object[] objects = (Object[]) listRetorno;
				historicoMedicaoIndividualizadaHelper = new HistoricoMedicaoIndividualizadaHelper((Integer) objects[0],
								(String) objects[1], (String) objects[2], (Integer) objects[3], (Integer) objects[4], (Integer) objects[5]);
				// lista.add(historicoMedicaoIndividualizadaHelper);
				}
			// }

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return historicoMedicaoIndividualizadaHelper;
	}

	public List<DebitosACobrarRateioImoveisVinculadosHelper> pesquisarDebitosACobrarRateioImoveisVinculadosHelper(Integer idImovel,
					Integer idLigacaoTipo, Integer anoMesRefFaturamento) throws ErroRepositorioException{


		List<Object> listRetorno = null;
		DebitosACobrarRateioImoveisVinculadosHelper debitosACobrarRateioImoveisVinculadosHelper = null;
		List<DebitosACobrarRateioImoveisVinculadosHelper> lista = new ArrayList<DebitosACobrarRateioImoveisVinculadosHelper>();

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT ");
			consulta.append("	dac.DBAC_ID AS idDebitoACobrar, ");
			consulta.append("	ci.IMOV_ID AS idImovel, ");
			consulta.append("	c.CLIE_ID AS idCliente, ");
			consulta.append("	c.CLIE_NMCLIENTE AS nomeCliente, ");
			consulta.append("	(SELECT ctp.CSTP_DSCONSUMOTIPO FROM CONSUMO_TIPO ctp ");
			consulta.append("	WHERE ");
			consulta.append("	 ctp.CSTP_ID = ch.CSTP_ID) AS dsTipoConsumo, ");
			consulta.append("	(SELECT mh.MDHI_NNCONSUMOMEDIDOMES FROM MEDICAO_HISTORICO mh ");
			consulta.append("	WHERE ");
			consulta.append("		mh.LAGU_ID = dac.IMOV_ID ");
			consulta.append("		AND mh.MEDT_ID = :idLigacaoTipo ");
			consulta.append("		AND mh.MDHI_AMLEITURA = :anoMesRefFaturamento) AS consumoMedidoAgua, ");
			consulta.append("	ch.CSHI_NNCONSUMORATEIO AS consumoRateado, ");
			consulta.append("	ch.CSHI_NNCONSUMOFATURADOMES AS consumoAguaFaturado, ");
			consulta.append("	dtp.DBTP_ID AS idDebitoTipo, ");
			consulta.append("	dtp.DBTP_DSDEBITOTIPO AS dsDebitoTipo, ");
			consulta.append("	dac.DBAC_VLDEBITO AS valorRateado ");
			consulta.append("FROM DEBITO_A_COBRAR dac	");
			consulta.append("INNER JOIN CLIENTE_IMOVEL ci ON dac.IMOV_ID = ci.IMOV_ID AND ci.CIFR_ID IS NULL AND ci.CRTP_ID = :idClienteRelacaoTipo ");
			consulta.append("INNER JOIN CLIENTE c ON ci.CLIE_ID = c.CLIE_ID ");
			consulta.append("LEFT JOIN CONSUMO_HISTORICO ch ON dac.IMOV_ID = ch.IMOV_ID AND ch.LGTI_ID = :idLigacaoTipo AND ch.CSHI_AMFATURAMENTO= :anoMesRefFaturamento ");
			consulta.append("INNER JOIN DEBITO_TIPO dtp ON dac.DBTP_ID = dtp.DBTP_ID ");
			consulta.append("WHERE ");
			consulta.append("	(dac.DBTP_ID = (SELECT ps.PASI_VLPARAMETRO FROM PARAMETRO_SISTEMA ps WHERE ps.PASI_CDPARAMETRO = 'P_DEBITO_TIPO_RATEIO') or ");
			consulta.append("	dac.DBTP_ID in (" + DebitoTipo.RATEIO_AGUA.toString() + "," + DebitoTipo.RATEIO_ESGOTO.toString() + ",");
			consulta.append(DebitoTipo.RATEIO_TEE.toString() + "))");
			consulta.append("	AND dac.IMOV_ID = :idImovel ");
			consulta.append("	AND dac.DBAC_AMREFERENCIADEBITO = :anoMesRefFaturamento");

			SQLQuery sqlQuery = session.createSQLQuery(consulta.toString());
			sqlQuery.addScalar("idDebitoACobrar", Hibernate.INTEGER);
			sqlQuery.addScalar("idImovel", Hibernate.INTEGER);
			sqlQuery.addScalar("idCliente", Hibernate.INTEGER);
			sqlQuery.addScalar("nomeCliente", Hibernate.STRING);
			sqlQuery.addScalar("dsTipoConsumo", Hibernate.STRING);
			sqlQuery.addScalar("consumoMedidoAgua", Hibernate.INTEGER);
			sqlQuery.addScalar("consumoRateado", Hibernate.INTEGER);
			sqlQuery.addScalar("consumoAguaFaturado", Hibernate.INTEGER);
			sqlQuery.addScalar("idDebitoTipo", Hibernate.INTEGER);
			sqlQuery.addScalar("dsDebitoTipo", Hibernate.STRING);
			sqlQuery.addScalar("valorRateado", Hibernate.BIG_DECIMAL);

			sqlQuery.setInteger("idImovel", idImovel);
			sqlQuery.setInteger("idLigacaoTipo", idLigacaoTipo);
			sqlQuery.setInteger("anoMesRefFaturamento", anoMesRefFaturamento);
			sqlQuery.setInteger("idClienteRelacaoTipo", ClienteRelacaoTipo.USUARIO);

			listRetorno = (List<Object>) sqlQuery.list();
			if(Util.isNaoNuloBrancoZero(listRetorno)){

				for(Object object : listRetorno){
					Object[] objects = (Object[]) object;
					debitosACobrarRateioImoveisVinculadosHelper = new DebitosACobrarRateioImoveisVinculadosHelper((Integer) objects[0],
									(Integer) objects[1], (Integer) objects[2], (String) objects[3], (String) objects[4],
									(Integer) objects[5], (Integer) objects[6], (Integer) objects[7], (Integer) objects[8],
									(String) objects[9], (BigDecimal) objects[10]);
					lista.add(debitosACobrarRateioImoveisVinculadosHelper);
				}
			}

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return lista;
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição Individualizada
	 * 
	 * @author Carlos Chrystian
	 * @date 20/09/2013
	 * @param idImovel
	 * @param anoMesReferencia
	 * @throws ControladorException
	 */
	public ContaHistorico pesquisarContaOriginalAntesDaRetificacao(Integer idImovel, Integer anoMesReferencia)
					throws ErroRepositorioException{

		ContaHistorico retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append(" select contaImovel from ContaHistorico contaImovel  where ");
			consulta.append(" contaImovel.imovel.id = :idImovel ");
			consulta.append(" and contaImovel.anoMesReferenciaConta =  :anoMesReferencia ");
			consulta.append(" and contaImovel.debitoCreditoSituacaoAtual.id = "
							+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO.toString());
			consulta.append(" and contaImovel.ultimaAlteracao in "); // Alteração solicitada na
																		// OC1197593
			consulta.append(" ( ");
			consulta.append(" select contaImovel.ultimaAlteracao from ContaHistorico contaImovel  where ");
			consulta.append(" contaImovel.imovel.id = :idImovel ");
			consulta.append(" and contaImovel.anoMesReferenciaConta =  :anoMesReferencia ");
			consulta.append(" and contaImovel.debitoCreditoSituacaoAtual.id = "
							+ DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO.toString());
			consulta.append(" ) ");
			
			retorno = (ContaHistorico) session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("anoMesReferencia", anoMesReferencia).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [UC3114] - Gerar Relatório Faturamento e Consumo Direto e Indireto Estadual
	 * 
	 * @author Victon Santos
	 * @created 27/09/2013
	 * @throws ControladorException
	 */
	public Collection<FaturamentoConsumoDiretoIndiretoEstadualRelatorioHelper> pesquisarDadosRelatorioFaturamentoConsumoDiretoIndiretoEstadual(
					Integer anoMes, Integer opcaoRelatorio) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			consulta = "SELECT M.MREM_AMMOVIMENTO AS REFERENCIA,"
							+ "CC1.CLIE_ID AS COD_RESP,"
							+ "CLI1.CLIE_NMCLIENTE AS RESPONSAVEL,"
							+ "CT.CLTP_DSCLIENTETIPO AS TIPO_RESP,"
							+ "IMO.LOCA_ID AS LOCALIDADE,"
							+ "LO.LOCA_NMLOCALIDADE AS NOME_LOCALID,"
							+ "IMO.IMOV_ID AS MATRICULA,"
							+ "CC2.CLIE_ID AS COD_USUARIO,"
							+ "CLI2.CLIE_NMCLIENTE AS USUARIO,"
							+ "IMO.LAST_ID AS TIPO_AGUA,"
							+ "IMO.LEST_ID AS TIPO_ESGOTO,"
							+ "'PUB' AS  CATEGORIA,"
							+ "( DECODE(MREM_QTECONOMIARESIDENCIAL, null, 0,MREM_QTECONOMIARESIDENCIAL) + "
							+ "DECODE(MREM_QTECONOMIACOMERCIAL, null, 0,MREM_QTECONOMIACOMERCIAL) + "
							+ "DECODE(MREM_QTECONOMIAINDUSTRIAL, null, 0,MREM_QTECONOMIAINDUSTRIAL) + "
							+ "DECODE(MREM_QTECONOMIAPUBLICA, null, 0,MREM_QTECONOMIAPUBLICA)) AS ECONOMIA,"
							+ "M.MREM_ENDERECOIMOVEL AS ENDERECO,"
							+ "M.MREM_NNLEITURAANTERIOR AS VL_LEITURA_ANTERIOR,"
							+ "M.MREM_NNLEITURA  AS VL_LEITURA_ATUAL,"
							+ "M.MREM_NNCONSUMOMEDIDO AS CONSUMO_MICROMEDIDO,"
							+ "M.MREM_NNCONSUMOFATURADOAGUA AS CONSUMO_FATURADO,"
							+ "M.MREM_NNCONSUMOMEDIO AS CONSUMO_MEDIO "
							+ "FROM IMOVEL IMO "
							+ "INNER JOIN CLIENTE_IMOVEL CC1 ON IMO.IMOV_ID = CC1.IMOV_ID AND CC1.CRTP_ID = 3 AND CC1.CLIM_DTRELACAOFIM IS NULL "
							+ "INNER JOIN CLIENTE CLI1 ON CC1.CLIE_ID = CLI1.CLIE_ID "
							+ "INNER JOIN CLIENTE_TIPO CT ON CLI1.CLTP_ID = CT.CLTP_ID "
							+ "INNER JOIN CLIENTE_IMOVEL CC2 ON IMO.IMOV_ID = CC2.IMOV_ID AND CC2.CRTP_ID = 2 AND CC2.CLIM_DTRELACAOFIM IS NULL "
							+ "INNER JOIN CLIENTE CLI2 ON CC2.CLIE_ID = CLI2.CLIE_ID "
							+ "INNER JOIN MOVIMENTO_ROTEIRO_EMPRESA M ON IMO.IMOV_ID = M.IMOV_ID "
							+ "INNER JOIN LOCALIDADE LO ON LO.LOCA_ID = IMO.LOCA_ID " + "WHERE IMO.CSTF_IDTEMPORARIA = 6 "
							+ "AND ((CC1.CLIM_DTRELACAOINICIO IS NULL AND CC1.CLIM_DTRELACAOFIM IS NULL) OR "
							+ "(MREM_DTLEITURAFATURADA <= CC1.CLIM_DTRELACAOFIM AND CC1.CLIM_DTRELACAOINICIO IS NULL) OR "
							+ "(MREM_DTLEITURAFATURADA >= CC1.CLIM_DTRELACAOINICIO AND CC1.CLIM_DTRELACAOFIM IS NULL) OR "
							+ "MREM_DTLEITURAFATURADA BETWEEN CC1.CLIM_DTRELACAOINICIO AND CC1.CLIM_DTRELACAOFIM) "
							+ "AND IMOV_DTVALIDADETARIFATEMP > MREM_DTLEITURAFATURADA " + "AND CLI1.CLTP_ID = :opcaoRelatorio "
							+ "AND M.MREM_AMMOVIMENTO = :anoMes " + "ORDER BY CC1.CLIE_ID,IMO.LOCA_ID,IMO.IMOV_ID ";

			retorno = session.createSQLQuery(consulta).setInteger("opcaoRelatorio", opcaoRelatorio).setInteger("anoMes", anoMes).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author
	 * @date 29/06/2011
	 * @param idFaturamentoAtividade
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarPorDebitoTipo(Integer idImovel, Integer idDebitoTipo)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer("");
		Query query = null;

		try{
			consulta.append("select ");
			consulta.append("dbac ");
			consulta.append("from ");
			consulta.append("DebitoACobrar dbac  ");
			consulta.append("inner join dbac.debitoTipo dbtp ");
			consulta.append("where ");
			consulta.append("dbac.imovel.id = :idImovel ");
			consulta.append("and dbtp.id = :idDebitoTipo ");

			query = session.createQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("idDebitoTipo", DebitoTipo.JUROS_SOBRE_PARCELAMENTO);
			retorno = (Collection<DebitoACobrar>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarDadosRelatorioMaioresConsumidores(Integer anoMes, Integer localidade, Integer registros)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			consulta = "select refe,loc,setor,quadra,tipo,matricula,nome,consumo,conta from "
							+ "(select refe,loc,setor,quadra,tipo,matricula,nome,consumo,conta "
							+ "from (select a.CNTI_AMREFERENCIACONTA as refe,c.LOCA_NMLOCALIDADE as loc,"
							+ "b.CNTA_CDSETORCOMERCIAL as setor,b.CNTA_NNQUADRA as quadra,z.CLTP_DSCLIENTETIPO as tipo,"
							+ "b.imov_id as matricula,y.CLIE_NMCLIENTE as nome,b.CNTA_NNCONSUMOAGUA as consumo"
							+ ",a.CNTI_VLCONTA as conta " + "from conta_impressao a " + "inner join conta b on a.cnta_id=b.cnta_id "
							+ "inner join cliente_conta x on a.cnta_id=x.cnta_id and x.crtp_id=2 "
							+ "inner join cliente y on x.clie_id=y.clie_id " + "inner join cliente_tipo z on y.cltp_id=z.cltp_id "
							+ "inner join localidade c on b.loca_id=c.loca_id " + "where a.CNTI_VLCONTA > 0 "
							+ "and y.cltp_id in (16,24,25,56,59,60) "
							+ "and a.CNTI_AMREFERENCIACONTA = :anoMes and b.LOCA_ID = :localidade " + "union "
							+ "select a.CNTI_AMREFERENCIACONTA as refe,c.LOCA_NMLOCALIDADE as loc,b.CNHI_CDSETORCOMERCIAL as setor,"
							+ "b.CNHI_NNQUADRA as quadra,z.CLTP_DSCLIENTETIPO as tipo,b.imov_id as matricula,"
							+ "y.CLIE_NMCLIENTE as nome,b.CNHI_NNCONSUMOAGUA as consumo,a.CNTI_VLCONTA as conta "
							+ "from conta_impressao a " + "inner join conta_historico b on a.cnta_id=b.cnta_id "
							+ "inner join cliente_conta_historico x on a.cnta_id=x.cnta_id and x.crtp_id=2 "
							+ "inner join cliente y on x.clie_id=y.clie_id " + "inner join cliente_tipo z on y.cltp_id=z.cltp_id "
							+ "inner join localidade c on b.loca_id=c.loca_id " + "where a.CNTI_VLCONTA > 0 "
							+ "and y.cltp_id in (16,24,25,56,59,60) " + "and a.CNTI_AMREFERENCIACONTA = :anoMes "
							+ "and b.LOCA_ID = :localidade) TAB1 " + "order by refe,loc,conta desc) TAB2 ";

			retorno = session.createSQLQuery(consulta).setInteger("anoMes", anoMes).setInteger("localidade", localidade)
							.setMaxResults(registros).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarDadosRelatorioMaioresDevedores(Integer localidade, Integer registros, Integer[] idsTipoCliente)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try{

			consulta = "SELECT * FROM ("
							+ "SELECT TO_CHAR(IMO.LOCA_ID) || '-' || "
							+ "LO.LOCA_NMLOCALIDADE AS LOCALIDADE, "
							+ "IMO.STCM_CDSETORCOMERCIAL AS SETOR, "
							+ "IMO.IMOV_ID AS MATRICULA, "
							+ "CLU.CLIE_NMCLIENTE AS NOME, "
							+ "(CASE WHEN CT.CLTP_ICPESSOAFISICAJURIDICA = 1 THEN CLU.CLIE_NNCPF ELSE CLU.CLIE_NNCNPJ END) AS CPF_CNPJ, "
							+ "CT.CLTP_DSCLIENTETIPO AS TIPO_CLIENTE, "
							+ "TRIM(LT.LGTP_DSABREVIADO) || ' ' || "
							+ "TRIM(LTT.LGTT_DSABREVIADO) || ' ' || "
							+ "TRIM(L.LOGR_NMLOGRADOURO) || ' ' || "
							+ "TRIM(IMO.IMOV_NNIMOVEL) || ' ' || "
							+ "TRIM(IMO.IMOV_DSCOMPLEMENTOENDERECO) AS ENDERECO, "
							+ "COUNT(*) AS QTDE, "
							+ "SUM(COALESCE(CTA.CNTA_VLAGUA,0) + COALESCE(CTA.CNTA_VLESGOTO,0) + COALESCE(CTA.CNTA_VLDEBITOS,0) - COALESCE(CTA.CNTA_VLCREDITOS,0) - COALESCE(CTA.CNTA_VLIMPOSTOS,0)) AS VALOR_DEBITO "
							+ "FROM CONTA CTA " + "INNER JOIN IMOVEL IMO ON IMO.IMOV_ID = CTA.IMOV_ID "
							+ "INNER JOIN CLIENTE_CONTA CLCU ON CTA.CNTA_ID = CLCU.CNTA_ID AND CLCU.CRTP_ID = 2 "
							+ "INNER JOIN CLIENTE CLU ON CLCU.CLIE_ID = CLU.CLIE_ID "
							+ "INNER JOIN CLIENTE_TIPO CT ON CLU.CLTP_ID = CT.CLTP_ID "
							+ "INNER JOIN LOGRADOURO L ON L.LOGR_ID = IMO.LOGR_ID "
							+ "INNER JOIN LOCALIDADE LO ON LO.LOCA_ID = IMO.LOCA_ID "
							+ "LEFT OUTER JOIN LOGRADOURO_TIPO LT ON LT.LGTP_ID = L.LGTP_ID "
							+ "LEFT OUTER JOIN LOGRADOURO_TITULO LTT ON LTT.LGTT_ID = L.LGTP_ID "
							+ "WHERE CTA.DCST_IDATUAL IN (0, 1, 2, 4) " + "AND CTA.CNTA_DTVENCIMENTOCONTA < :dataAtual "
							+ "AND CTA.LOCA_ID = :localidade ";

			if(idsTipoCliente != null){
				consulta = consulta
								+ "AND CLU.CLTP_ID IN (:idsTipoCliente) "
								+ "GROUP BY TO_CHAR(IMO.LOCA_ID) || '-' || "
								+ "LO.LOCA_NMLOCALIDADE, IMO.STCM_CDSETORCOMERCIAL, IMO.IMOV_ID, CLU.CLIE_NMCLIENTE, (CASE WHEN CT.CLTP_ICPESSOAFISICAJURIDICA = 1 THEN CLU.CLIE_NNCPF ELSE CLU.CLIE_NNCNPJ END), CT.CLTP_DSCLIENTETIPO, TRIM(LT.LGTP_DSABREVIADO) || ' ' || "
								+ "TRIM(LTT.LGTT_DSABREVIADO) || ' ' || "
								+ "TRIM(L.LOGR_NMLOGRADOURO) || ' ' || "
								+ "TRIM(IMO.IMOV_NNIMOVEL) || ' ' || "
								+ "TRIM(IMO.IMOV_DSCOMPLEMENTOENDERECO) "
								+ "ORDER BY SUM(COALESCE(CTA.CNTA_VLAGUA,0) + COALESCE(CTA.CNTA_VLESGOTO,0) + COALESCE(CTA.CNTA_VLDEBITOS,0) - COALESCE(CTA.CNTA_VLCREDITOS,0) - COALESCE(CTA.CNTA_VLIMPOSTOS,0)) DESC) TAB1 ";
				retorno = session.createSQLQuery(consulta).setInteger("localidade", localidade).setDate("dataAtual", new Date())
								.setParameterList("idsTipoCliente", idsTipoCliente).setMaxResults(registros).list();
			}else{
				consulta = consulta
								+ "AND CLU.CLTP_ID IN (16,24,25,56,59,60,99,119) "
								+ "GROUP BY TO_CHAR(IMO.LOCA_ID) || '-' || "
								+ "LO.LOCA_NMLOCALIDADE, IMO.STCM_CDSETORCOMERCIAL, IMO.IMOV_ID, CLU.CLIE_NMCLIENTE, (CASE WHEN CT.CLTP_ICPESSOAFISICAJURIDICA = 1 THEN CLU.CLIE_NNCPF ELSE CLU.CLIE_NNCNPJ END), CT.CLTP_DSCLIENTETIPO, TRIM(LT.LGTP_DSABREVIADO) || ' ' || "
								+ "TRIM(LTT.LGTT_DSABREVIADO) || ' ' || "
								+ "TRIM(L.LOGR_NMLOGRADOURO) || ' ' || "
								+ "TRIM(IMO.IMOV_NNIMOVEL) || ' ' || "
								+ "TRIM(IMO.IMOV_DSCOMPLEMENTOENDERECO) "
								+ "ORDER BY SUM(COALESCE(CTA.CNTA_VLAGUA,0) + COALESCE(CTA.CNTA_VLESGOTO,0) + COALESCE(CTA.CNTA_VLDEBITOS,0) - COALESCE(CTA.CNTA_VLCREDITOS,0) - COALESCE(CTA.CNTA_VLIMPOSTOS,0)) DESC) TAB1 ";
				retorno = session.createSQLQuery(consulta).setInteger("localidade", localidade).setDate("dataAtual", new Date())
								.setMaxResults(registros).list();
			}



		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3128] GerarRelatorioImóveiscomLigaçãoCortadacomConsumo
	 * 
	 * @author Hiroshi Gonçalves
	 * @created 09/12/2013
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarImoveisLigacaoCortadaComConsumo(int anoMesReferencia, Integer grupoFaturamento)
					throws ErroRepositorioException{

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try{
			
			consulta = "SELECT " 
							+ "A.LOCA_ID || ' - ' || L.LOCA_NMLOCALIDADE, " // 0
							+ "N.STCM_CDSETORCOMERCIAL, " // 1
							+ "A.QDRA_NNQUADRA, " // 2
						    + "A.IMOV_NNLOTE, " // 3
						    + "A.IMOV_ID, " // 4
						    + "E.CLIE_NMCLIENTE, " // 5
						    + "F.LAGU_DTCORTE, " // 6
							+ "G.HIDI_NNLEITURACORTE AS LCORTE_LAGU, "// 7
							+ "H.HIDI_NNLEITURACORTE AS LCORTE_IMOV, " // 8
							+ "I.CSHI_NNCONSUMOFATURADOMES AS CONS_ANT, " // 9
						    + "I.CSHI_AMFATURAMENTO, " // 10       
							+ "J.MDHI_NNLEITURAANTERIORFATURAME AS LANT_LAGU, " // 11
							+ "J.MDHI_NNLEITURAATUALFATURAMENTO AS LATU_LAGU, " // 12
							+ "K.MDHI_NNLEITURAANTERIORFATURAME AS LANT_IMOV, " // 13
							+ "K.MDHI_NNLEITURAATUALFATURAMENTO AS LATU_IMOV, " // 14
							+ "M.CSHI_NNCONSUMOFATURADOMES AS CONS_ATUAL " // 15
						+ "FROM IMOVEL A "
						+ "JOIN ROTA B ON B.ROTA_ID = A.ROTA_ID " 
						+ "JOIN LIGACAO_AGUA_SITUACAO C ON C.LAST_ID = A.LAST_ID "
						+ "JOIN CLIENTE_IMOVEL D ON D.IMOV_ID = A.IMOV_ID AND D.CRTP_ID = 2 AND D.CLIM_DTRELACAOFIM IS NULL "
						+ "JOIN CLIENTE E ON E.CLIE_ID = D.CLIE_ID "
						+ "JOIN LIGACAO_AGUA F ON F.LAGU_ID = A.IMOV_ID "
						+ "LEFT OUTER JOIN HIDROMETRO_INSTALACAO_HIST G ON G.LAGU_ID = A.IMOV_ID AND G.HIDI_DTRETIRADAHIDROMETRO IS NULL "
						+ "LEFT OUTER JOIN HIDROMETRO_INSTALACAO_HIST H ON H.IMOV_ID = A.IMOV_ID AND H.HIDI_DTRETIRADAHIDROMETRO IS NULL "
							+ "JOIN CONSUMO_HISTORICO I ON I.IMOV_ID = A.IMOV_ID AND I.LGTI_ID = 1 AND I.CSHI_AMFATURAMENTO = :anoMesReferenciaAnterior " // Data
																																							// imediatamente
																																							// menor
																																							// q
																																							// a
																																							// solicitada
							+ "LEFT JOIN MEDICAO_HISTORICO J ON J.LAGU_ID = A.IMOV_ID AND J.MDHI_AMLEITURA = :anoMesReferencia " // Data
																																	// solicitada
							+ "LEFT JOIN MEDICAO_HISTORICO K ON K.IMOV_ID = A.IMOV_ID AND K.MDHI_AMLEITURA = :anoMesReferencia " // Data
																																	// solicitada
						+ "JOIN LOCALIDADE L ON L.LOCA_ID = A.LOCA_ID "
						+ "JOIN SETOR_COMERCIAL N ON N.STCM_ID = A.STCM_ID "
						+ "JOIN CONSUMO_HISTORICO M ON M.IMOV_ID = A.IMOV_ID AND M.LGTI_ID = 1 AND M.CSHI_AMFATURAMENTO = :anoMesReferencia "

							+ "WHERE B.FTGR_ID = :grupoFaturamento " + "AND C.LAST_CDCONSTANTE IN ('CORTADO', 'CORTADO A PEDIDO') "
							+ "AND M.CSHI_NNCONSUMOFATURADOMES > 0 " + "ORDER BY A.LOCA_ID, N.STCM_CDSETORCOMERCIAL ";

			retorno = session.createSQLQuery(consulta).setInteger("grupoFaturamento", grupoFaturamento)
							.setInteger("anoMesReferencia", anoMesReferencia)
							.setInteger("anoMesReferenciaAnterior", Util.subtrairMesDoAnoMes(anoMesReferencia, 1)).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection pesquisarIdsContaAjusteContasEnviadasHistorico(Integer anoMesRefInicial, Integer anoMesRefFinal, String[] idsCliente)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<Object>();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append("select CH.cnta_id as idConta from conta_historico CH ");
			consulta.append(" inner join cliente_conta_historico CCH on cch.cnta_id = ch.cnta_id ");
			consulta.append(" WHERE CH.dcst_idanterior in (19,49,59) ");
			consulta.append("  and CH.cnhi_amreferenciaconta between :anoMesRefInicial and :anoMesRefFinal ");
			consulta.append("  and CCH.clie_id in (:idsCliente)		");
			consulta.append("  and CCH.crtp_id=3");
			consulta.append(" order by CCH.clie_id,CH.imov_id,CH.cnhi_amreferenciaconta");

			retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.INTEGER)
							.setInteger("anoMesRefInicial", anoMesRefInicial).setInteger("anoMesRefFinal", anoMesRefFinal)
							.setParameterList("idsCliente", idsCliente).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public List<Conta> obterDebitosAnteriores(Integer idImovel, BigDecimal vlMinDebitosAnteriores, Integer idMotivoNegativacao,
					Date dataVencimento) throws ErroRepositorioException{

		List<Conta> retorno = new ArrayList<Conta>();
		Session session = HibernateUtil.getSession();
		StringBuffer sb = new StringBuffer();

		try{
			sb.append("select cnta from Conta cnta ");
			sb.append("left join cnta.contaMotivoRevisao contaMotivoRevisao ");
			sb.append("inner join cnta.imovel imovel ");
			sb.append("where ");
			sb.append("imovel.id = :idImovel ");
			sb.append("and ");
			sb.append("cnta.dataVencimentoConta < :dataVencimento ");
			sb.append("and ");
			sb.append("(contaMotivoRevisao is null or contaMotivoRevisao.id = :idMotivoNegativacao) ");
			sb.append("and ");
			sb.append("not exists (");
			sb.append("select contaPgt.id from Pagamento pgt ");
			sb.append("inner join pgt.conta contaPgt ");
			sb.append("inner join contaPgt.imovel imovelPgt ");
			sb.append("where imovelPgt.id = :idImovel) ");

			List<Conta> collContas = session.createQuery(sb.toString()).setInteger("idImovel", idImovel)
							.setInteger("idMotivoNegativacao", idMotivoNegativacao).setDate("dataVencimento", dataVencimento).list();

			for(Conta conta : collContas){
				if(conta.getValorTotal().compareTo(vlMinDebitosAnteriores) == 1){
					retorno.add(conta);
				}
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarIdsContaAjusteContasEnviadasHistoricoPreFaturadasZeradasIndicadorEmissaoCampo3(Integer idRota)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<Object>();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append(" select cnt.cnta_id as idConta from conta_historico cnt where cnt.dcst_idatual = 9 and (nvl(cnt.cnhi_vlagua,0) = 0)");
			consulta.append(" and (nvl(cnt.cnhi_vlesgoto,0) = 0) and (nvl(cnt.cnhi_vldebitos,0) = 0)");
			consulta.append(" and exists (select 1 from movimento_roteiro_empresa mre where mre.mrem_icemissaocampo = 3");
			consulta.append(" and (nvl(mre.mrem_vlagua,0) = 0) and (nvl(mre.mrem_vlesgoto,0) = 0) and (nvl(mre.mrem_vldebitos,0) = 0)");
			consulta.append(" and mre.mrem_icfase = 2 and cnt.cnhi_amreferenciaconta = mre.mrem_ammovimento and cnt.imov_id = mre.imov_id");
			consulta.append(" and mre.rota_id = :idRota)");

			retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.INTEGER)
							.setInteger("idRota", idRota).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * [UC3118] Inserir Comando de Simulação de Faturamento
	 * [FS0007] - Verificar existência do comando
	 * 
	 * @author Anderson Italo
	 * @date 24/12/2013
	 */
	public FaturamentoSimulacaoComando pesquisarFaturamentoSimulacaoComando(
					InserirComandoSimulacaoFaturamentoHelper inserirComandoSimulacaoFaturamentoHelper) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		FaturamentoSimulacaoComando faturamentoSimulacaoComando = null;
		try{
			StringBuilder hql = new StringBuilder(" from FaturamentoSimulacaoComando fsc ");
			hql.append(" where fsc.faturamentoGrupo.id = :idFaturamentoGrupo ");
			hql.append(" and fsc.gerenciaRegional.id = :idGerenciaRegional ");
			hql.append(" and fsc.unidadeNegocio.id = :idUnidadeNegocio ");
			hql.append(" and fsc.localidadeInicial.id = :idLocalidadeInicial ");
			hql.append(" and fsc.localidadeFinal.id = :idLocalidadeFinal ");
			hql.append(" and fsc.setorComercialInicial.id = :idSetorComercialInicial ");
			hql.append(" and fsc.setorComercialFinal.id = :idSetorComercialFinal ");
			hql.append(" and fsc.quadraInicial.id = :idQuadraInicial ");
			hql.append(" and fsc.quadraFinal.id = :idQuadraFinal ");
			hql.append(" and fsc.rotaInicial.id = :idRotaInicial ");
			hql.append(" and fsc.rotaFinal.id = :idRotaFinal ");
			hql.append(" and fsc.loteInicial = :loteInicial ");
			hql.append(" and fsc.loteFinal = :loteFinal ");
			hql.append(" and fsc.codigoTipoConsumoAgua = :codigoTipoConsumoAgua ");
			hql.append(" and fsc.codigoTipoConsumoEsgoto = :codigoTipoConsumoEsgoto ");
			hql.append(" and fsc.consumoTarifa.id = :idConsumoTarifa ");
			hql.append(" and fsc.dataRealizacao is null ");

			Query query = session.createQuery(hql.toString());
			query.setProperties(inserirComandoSimulacaoFaturamentoHelper);
			query.setLockMode("fsc", LockMode.WRITE);

			faturamentoSimulacaoComando = (FaturamentoSimulacaoComando) query.uniqueResult();
		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}
		return faturamentoSimulacaoComando;
	}

	/**
	 * [UC3118] Inserir Comando de Simulação de Faturamento
	 * [FS0008] - Verificar existência de imóveis para os parâmetros
	 * 
	 * @author Anderson Italo
	 * @date 27/12/2013
	 */
	public Collection pesquisarIdsImoveisComandoSimulacaoFaturamento(InserirComandoSimulacaoFaturamentoHelper helper) 
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<Object>();
		StringBuilder consulta = new StringBuilder();
		String condicoes = "";

		try{

			consulta.append(" select im.imov_id as idImovel from imovel im");
			consulta.append(" inner join localidade lo on lo.loca_id = im.loca_id");

			if(helper.getIdGerenciaRegional() != null){

				condicoes += " lo.greg_id =  " + helper.getIdGerenciaRegional().toString() + " and";
			}

			if(helper.getIdUnidadeNegocio() != null){

				condicoes += " lo.uneg_id =  " + helper.getIdUnidadeNegocio().toString() + " and";
			}
			
			if (helper.getIdRotaInicial() != null && helper.getIdRotaFinal() != null){
				
				condicoes += " (im.rota_id >= " + helper.getIdRotaInicial().toString();
				condicoes += " and im.rota_id <= " + helper.getIdRotaFinal().toString() + ") and";

				if(helper.getLoteInicial() != null && helper.getLoteFinal() != null){

					condicoes += " (im.imov_nnlote >= " + helper.getLoteInicial().toString();
					condicoes += " and im.imov_nnlote <= " + helper.getLoteFinal().toString() + ")";
				}

			}else if(helper.getNumeroQuadraInicial() != null && helper.getNumeroQuadraFinal() != null){
				
				consulta.append(" inner join quadra qu on qu.qdra_id = im.qdra_id");
				consulta.append(" inner join setor_comercial sc on sc.stcm_id = im.stcm_id");

				condicoes += " (qu.qdra_nnquadra >= " + helper.getNumeroQuadraInicial().toString();
				condicoes += " and qu.qdra_nnquadra <= " + helper.getNumeroQuadraFinal().toString() + ") and";
				condicoes += " (sc.stcm_cdsetorcomercial >= " + helper.getCodigoSetorComercialInicial().toString();
				condicoes += " and sc.stcm_cdsetorcomercial <= " + helper.getCodigoSetorComercialFinal().toString() + ") and";
				condicoes += " (lo.loca_id >= " + helper.getIdLocalidadeInicial().toString();
				condicoes += " and lo.loca_id <= " + helper.getIdLocalidadeFinal().toString() + ") and";

				if(helper.getLoteInicial() != null && helper.getLoteFinal() != null){

					condicoes += " (im.imov_nnlote >= " + helper.getLoteInicial().toString();
					condicoes += " and im.imov_nnlote <= " + helper.getLoteFinal().toString() + ")";
				}

			}else if(helper.getCodigoSetorComercialInicial() != null && helper.getCodigoSetorComercialFinal() != null){

				consulta.append(" inner join setor_comercial sc on sc.stcm_id = im.stcm_id");

				condicoes += " (sc.stcm_cdsetorcomercial >= " + helper.getCodigoSetorComercialInicial().toString();
				condicoes += " and sc.stcm_cdsetorcomercial <= " + helper.getCodigoSetorComercialFinal().toString() + ") and";
				condicoes += " (lo.loca_id >= " + helper.getIdLocalidadeInicial().toString();
				condicoes += " and lo.loca_id <= " + helper.getIdLocalidadeFinal().toString() + ")";

			}else if(helper.getIdLocalidadeInicial() != null && helper.getIdLocalidadeFinal() != null){

				condicoes += " (lo.loca_id >= " + helper.getIdLocalidadeInicial().toString();
				condicoes += " and lo.loca_id <= " + helper.getIdLocalidadeFinal().toString() + ")";

			}else if(helper.getIdFaturamentoGrupo() != null){

				consulta.append(" inner join rota ro on ro.rota_id = im.rota_id");
				consulta.append(" inner join faturamento_grupo fg on fg.ftgr_id = ro.ftgr_id");

				condicoes += " fg.ftgr_id = " + helper.getIdFaturamentoGrupo().toString();
			}

			if(condicoes.substring(condicoes.length() - 3, condicoes.length()).equals("and")){

				consulta.append(" where " + condicoes.substring(0, condicoes.length() - 3));
			}else{

				consulta.append(" where " + condicoes);
			}
		
			retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idImovel", Hibernate.INTEGER).list();
			
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113 - Faturar Grupo Faturamento]
	 * 
	 * @author Anderson Italo
	 * @date 30/12/2013
	 */
	public void deletarResumoFaturamentoSimulacaoPorComando(Integer idFaturamentoSimulacaoComando) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		try{

			String delete = "delete ResumoFaturamentoSimulacao as rfs where rfs.faturamentoSimulacaoComando.id = :idFaturamentoSimulacaoComando ";

			session.createQuery(delete).setInteger("idFaturamentoSimulacaoComando", idFaturamentoSimulacaoComando.intValue())
							.executeUpdate();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * O sistema seleciona as rotas dos imóveis, que não sejam imóvel condomínio
	 * (IMOV_ICIMOVELCONDOMÍNIO<>1 da tabela IMOVEL), associados ao filtro do comando de simulação
	 * recebido
	 * 
	 * @author Anderson Italo
	 * @date 31/12/2013
	 */
	public Collection pesquisarIdsRotasComandoSimulacaoFaturamento(FaturamentoSimulacaoComando faturamentoSimulacaoComando)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<Object>();
		StringBuilder consulta = new StringBuilder();
		String condicoes = "";

		try{

			consulta.append(" select distinct(im.rota_id) as idRota from imovel im");
			consulta.append(" inner join localidade lo on lo.loca_id = im.loca_id");

			if(faturamentoSimulacaoComando.getFaturamentoGrupo() != null){

				consulta.append(" inner join rota ro on ro.rota_id = im.rota_id");
				consulta.append(" inner join faturamento_grupo fg on fg.ftgr_id = ro.ftgr_id");

				condicoes += " fg.ftgr_id = " + faturamentoSimulacaoComando.getFaturamentoGrupo().getId().toString() + " and";
			}

			if(faturamentoSimulacaoComando.getGerenciaRegional() != null){

				condicoes += " lo.greg_id =  " + faturamentoSimulacaoComando.getGerenciaRegional().getId().toString() + " and";
			}

			if(faturamentoSimulacaoComando.getUnidadeNegocio() != null){

				condicoes += " lo.uneg_id =  " + faturamentoSimulacaoComando.getUnidadeNegocio().getId().toString() + " and";
			}

			if(faturamentoSimulacaoComando.getLocalidadeInicial() != null && faturamentoSimulacaoComando.getLocalidadeFinal() != null){

				condicoes += " (im.loca_id >= " + faturamentoSimulacaoComando.getLocalidadeInicial().getId().toString();
				condicoes += " and im.loca_id <= " + faturamentoSimulacaoComando.getLocalidadeFinal().getId().toString() + ") and";
			}

			if(faturamentoSimulacaoComando.getSetorComercialInicial() != null
							&& faturamentoSimulacaoComando.getSetorComercialFinal() != null){

				condicoes += " (im.stcm_id >= " + faturamentoSimulacaoComando.getSetorComercialInicial().getId().toString();
				condicoes += " and im.stcm_id <= " + faturamentoSimulacaoComando.getSetorComercialFinal().getId().toString() + ") and";
			}

			if(faturamentoSimulacaoComando.getQuadraInicial() != null && faturamentoSimulacaoComando.getQuadraFinal() != null){

				condicoes += " (im.qdra_id >= " + faturamentoSimulacaoComando.getQuadraInicial().getId().toString();
				condicoes += " and im.qdra_id <= " + faturamentoSimulacaoComando.getQuadraFinal().getId().toString() + ") and";
			}

			if(faturamentoSimulacaoComando.getRotaInicial() != null && faturamentoSimulacaoComando.getRotaFinal() != null){

				condicoes += " (im.rota_id >= " + faturamentoSimulacaoComando.getRotaInicial().getId().toString();
				condicoes += " and im.rota_id <= " + faturamentoSimulacaoComando.getRotaFinal().getId().toString() + ") and";
			}

			if(faturamentoSimulacaoComando.getLoteInicial() != null && faturamentoSimulacaoComando.getLoteFinal() != null){

				condicoes += " (im.imov_nnlote >= " + faturamentoSimulacaoComando.getLoteInicial().toString();
				condicoes += " and im.imov_nnlote <= " + faturamentoSimulacaoComando.getLoteFinal().toString() + ") and";
			}
			
			condicoes += " imov_icimovelcondominio <> 1 ";

			if(condicoes.substring(condicoes.length() - 3, condicoes.length()).equals("and")){

				consulta.append(" where " + condicoes.substring(0, condicoes.length() - 3));
			}else{

				consulta.append(" where " + condicoes);
			}

			retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idRota", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * O sistema seleciona as rotas dos imóveis, que não sejam imóvel condomínio
	 * (IMOV_ICIMOVELCONDOMÍNIO<>1 da tabela IMOVEL), associados ao filtro do comando de simulação
	 * recebido
	 * 
	 * @author Anderson Italo
	 * @date 31/12/2013
	 */
	public Collection pesquisarMatriculasImoveisComandoSimulacaoFaturamento(FaturamentoSimulacaoComando faturamentoSimulacaoComando)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<Object>();
		StringBuilder consulta = new StringBuilder();
		String condicoes = "";

		try{

			consulta.append(" select im.imov_id as idRota from imovel im");
			consulta.append(" inner join localidade lo on lo.loca_id = im.loca_id");

			if(faturamentoSimulacaoComando.getFaturamentoGrupo() != null){

				consulta.append(" inner join rota ro on ro.rota_id = im.rota_id");
				consulta.append(" inner join faturamento_grupo fg on fg.ftgr_id = ro.ftgr_id");

				condicoes += " fg.ftgr_id = " + faturamentoSimulacaoComando.getFaturamentoGrupo().getId().toString() + " and";
			}

			if(faturamentoSimulacaoComando.getGerenciaRegional() != null){

				condicoes += " lo.greg_id =  " + faturamentoSimulacaoComando.getGerenciaRegional().getId().toString() + " and";
			}

			if(faturamentoSimulacaoComando.getUnidadeNegocio() != null){

				condicoes += " lo.uneg_id =  " + faturamentoSimulacaoComando.getUnidadeNegocio().getId().toString() + " and";
			}

			if(faturamentoSimulacaoComando.getLocalidadeInicial() != null && faturamentoSimulacaoComando.getLocalidadeFinal() != null){

				condicoes += " (im.loca_id >= " + faturamentoSimulacaoComando.getLocalidadeInicial().getId().toString();
				condicoes += " and im.loca_id <= " + faturamentoSimulacaoComando.getLocalidadeFinal().getId().toString() + ") and";
			}

			if(faturamentoSimulacaoComando.getSetorComercialInicial() != null
							&& faturamentoSimulacaoComando.getSetorComercialFinal() != null){

				condicoes += " (im.stcm_id >= " + faturamentoSimulacaoComando.getSetorComercialInicial().getId().toString();
				condicoes += " and im.stcm_id <= " + faturamentoSimulacaoComando.getSetorComercialFinal().getId().toString() + ") and";
			}

			if(faturamentoSimulacaoComando.getQuadraInicial() != null && faturamentoSimulacaoComando.getQuadraFinal() != null){

				condicoes += " (im.qdra_id >= " + faturamentoSimulacaoComando.getQuadraInicial().getId().toString();
				condicoes += " and im.qdra_id <= " + faturamentoSimulacaoComando.getQuadraFinal().getId().toString() + ") and";
			}

			if(faturamentoSimulacaoComando.getRotaInicial() != null && faturamentoSimulacaoComando.getRotaFinal() != null){

				condicoes += " (im.rota_id >= " + faturamentoSimulacaoComando.getRotaInicial().getId().toString();
				condicoes += " and im.rota_id <= " + faturamentoSimulacaoComando.getRotaFinal().getId().toString() + ") and";
			}

			if(faturamentoSimulacaoComando.getLoteInicial() != null && faturamentoSimulacaoComando.getLoteFinal() != null){

				condicoes += " (im.imov_nnlote >= " + faturamentoSimulacaoComando.getLoteInicial().toString();
				condicoes += " and im.imov_nnlote <= " + faturamentoSimulacaoComando.getLoteFinal().toString() + ") and";
			}

			condicoes += " imov_icimovelcondominio <> 1 ";

			if(condicoes.substring(condicoes.length() - 3, condicoes.length()).equals("and")){

				consulta.append(" where " + condicoes.substring(0, condicoes.length() - 3));
			}else{

				consulta.append(" where " + condicoes);
			}

			retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idRota", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	/**
	 * [UC0146] Manter Conta
	 * [SB0003] - Retificar Conta
	 * 
	 * @author Anderson Italo
	 * @created 17/01/2014
	 * @throws ErroRepositorioException
	 */
	public ClienteConta pesquisarClienteContaPorTipoRelacao(Integer idConta, Integer idClienteRelacaoTipo) throws ErroRepositorioException{

		ClienteConta retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer hql = new StringBuffer();

		try{

			hql.append(" select cc ");
			hql.append(" from ClienteConta cc ");
			hql.append(" inner join fetch cc.cliente cl ");
			hql.append(" inner join fetch cc.clienteRelacaoTipo crt ");
			hql.append(" inner join cc.conta co ");
			hql.append(" where co.id = :idConta ");
			hql.append(" and crt.id = :idClienteRelacaoTipo ");

			Query query = session.createQuery(hql.toString());
			query.setInteger("idConta", idConta);
			query.setInteger("idClienteRelacaoTipo", idClienteRelacaoTipo);

			retorno = (ClienteConta) query.setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * [UC3134] Manter Comando de Simulação de Faturamento
	 * 
	 * @author Anderson Italo
	 * @date 19/01/2014
	 */
	public Collection<FaturamentoSimulacaoComando> pesquisarFaturamentoSimulacaoComando(Integer numeroPagina, Date dataInicialComando,
					Date dataFinalComando, Short indicadorExecutado) throws ErroRepositorioException{

		Collection<FaturamentoSimulacaoComando> retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		StringBuffer consultaCondicoes = new StringBuffer();

		try{

			consulta.append("select fsc ");
			consulta.append("from ");
			consulta.append("FaturamentoSimulacaoComando fsc ");
			consulta.append("left join fetch fsc.localidadeInicial locIni ");
			consulta.append("left join fetch fsc.localidadeFinal locFim ");
			consulta.append("left join fetch fsc.setorComercialInicial setIni ");
			consulta.append("left join fetch fsc.setorComercialFinal setFim ");
			consulta.append("left join fetch fsc.quadraInicial qdrIni ");
			consulta.append("left join fetch fsc.quadraFinal qdrFim ");
			consulta.append("left join fetch fsc.rotaInicial rotIni ");
			consulta.append("left join fetch fsc.rotaFinal rotFim   ");

			if(dataInicialComando != null && dataFinalComando != null){

				consultaCondicoes.append(" fsc.dataComando between :dataInicialComando and :dataFinalComando and");
			}

			if(indicadorExecutado != null && indicadorExecutado.equals(ConstantesSistema.SIM)){

				consultaCondicoes.append(" fsc.dataRealizacao is not null and");
			}else if(indicadorExecutado != null && indicadorExecutado.equals(ConstantesSistema.NAO)){

				consultaCondicoes.append(" fsc.dataRealizacao is null and");
			}

			if(consultaCondicoes.length() > 0){

				consulta.append("where " + consultaCondicoes.toString().substring(0, consultaCondicoes.toString().length() - 3));
			}

			consulta.append(" order by fsc.dataRealizacao ");

			if(dataInicialComando != null && dataFinalComando != null){

				retorno = session.createQuery(consulta.toString()).setFirstResult(10 * numeroPagina)
								.setTimestamp("dataInicialComando", Util.formatarDataInicial(dataInicialComando))
								.setTimestamp("dataFinalComando", Util.formatarDataFinal(dataFinalComando)).setMaxResults(10).list();
			}else{

				retorno = session.createQuery(consulta.toString()).setFirstResult(10 * numeroPagina).setMaxResults(10).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3134] Manter Comando de Simulação de Faturamento
	 * 
	 * @author Anderson Italo
	 * @date 19/01/2014
	 */
	public Integer pesquisarTotalRegistrosFaturamentoSimulacaoComando(Date dataInicialComando, Date dataFinalComando,
					Short indicadorExecutado) throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();
		StringBuffer consultaCondicoes = new StringBuffer();

		try{

			consulta.append(" select count(*) ");
			consulta.append(" from ");
			consulta.append(" FaturamentoSimulacaoComando fsc   ");

			if(dataInicialComando != null && dataFinalComando != null){

				consultaCondicoes.append(" fsc.dataComando between :dataInicialComando and :dataFinalComando and");
			}

			if(indicadorExecutado != null && indicadorExecutado.equals(ConstantesSistema.SIM)){

				consultaCondicoes.append(" fsc.dataRealizacao is not null and");
			}else if(indicadorExecutado != null && indicadorExecutado.equals(ConstantesSistema.NAO)){

				consultaCondicoes.append(" fsc.dataRealizacao is null and");
			}

			if(consultaCondicoes.length() > 0){

				consulta.append("where " + consultaCondicoes.toString().substring(0, consultaCondicoes.toString().length() - 3));
			}

			if(dataInicialComando != null && dataFinalComando != null){

				retorno = ((Number) session.createQuery(consulta.toString())
								.setTimestamp("dataInicialComando", Util.formatarDataInicial(dataInicialComando))
								.setTimestamp("dataFinalComando", Util.formatarDataFinal(dataFinalComando)).uniqueResult()).intValue();
			}else{

				retorno = ((Number) session.createQuery(consulta.toString()).uniqueResult()).intValue();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarIdsLigacaoEsgotoAjusteErroCalculoConsumoMedio() throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<Object>();
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append(" select lesg.lesg_id as idLigacaoEsgoto from ligacao_esgoto_pc_coleta_err lesg");
			consulta.append(" order by 1 ");

			retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idLigacaoEsgoto", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0083] Gerar Dados para Leitura
	 * 
	 * @author Hiroshi Gonçalves
	 * @date 11/02/2014
	 */
	public List<Object[]> pesquisarImoveisComContratoDemandaAVencer(Integer idGrupoFaturamento) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		List<Object[]> retorno = null;
		StringBuilder consulta = new StringBuilder();

		try{

			consulta.append(" SELECT A.IMOV_ID AS idImovel, A.CTDC_DSEMAIL AS dsEmail FROM CONTRATO_DEMANDA_CONSUMO A");
			consulta.append(" JOIN IMOVEL B ON B.IMOV_ID = A.IMOV_ID");
			consulta.append(" JOIN ROTA C ON C.ROTA_ID = B.ROTA_ID");
			consulta.append(" JOIN FATURAMENTO_GRUPO D ON D.FTGR_ID = C.FTGR_ID");
			consulta.append(" WHERE D.FTGR_ID = :idGrupoFaturamento");
			consulta.append(" AND A.CTDC_ICENCERRAMENTO = 2");
			consulta.append(" AND A.CTDC_AMFATURAMENTOFIM = (SELECT PARM_AMREFERENCIAFATURAMENTO FROM SISTEMA_PARAMETROS)");

			retorno = session.createSQLQuery(consulta.toString()).addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("dsEmail", Hibernate.STRING).setInteger("idGrupoFaturamento", idGrupoFaturamento).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}
	
	/**
	 * [UC3132] Gerar Relatório de Contratos de Demanda de Consumo
	 * 
	 * @author Vicente Zarga
	 * @created 18/01/2013
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosRelatorioContratoDemandaConsumo(Integer faturamentoGrupo, Integer[] localidades, String tipoContrato,
					Integer tarifaConsumo, Integer mesAnoFaturamentoInicial, Integer mesAnoFaturamentoFinal, Integer encerrado)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<ContratoDemandaConsumo>();
		StringBuilder consulta = new StringBuilder();
		StringBuilder condicoes = new StringBuilder();

		try{
			consulta.append("select CDC from ContratoDemandaConsumo CDC ");
			consulta.append("INNER JOIN FETCH  CDC.imovel IMOV ");
			consulta.append("LEFT JOIN FETCH IMOV.rota ROT ");
			consulta.append("LEFT JOIN FETCH ROT.faturamentoGrupo FTGR ");
			consulta.append("LEFT JOIN FETCH CDC.consumoTarifa ct ");

			if(encerrado != null && !encerrado.equals(Integer.parseInt(ConstantesSistema.AMBOS_CONTRATO))){

				condicoes.append("CDC.indicacorEncerramento= :encerrado and ");
			}

			if(faturamentoGrupo != null && !faturamentoGrupo.equals(ConstantesSistema.NUMERO_NAO_INFORMADO)){

				condicoes.append("FTGR.id= :faturamentoGrupo and ");
			}
			if(localidades != null){

				condicoes.append("IMOV.localidade.id in (:localidades) and ");
			}
			if(mesAnoFaturamentoInicial != null && !mesAnoFaturamentoInicial.equals("")){

				condicoes.append("CDC.anoMesFaturamentoFim >= :mesAnoFaturamentoInicial and ");
			}
			if(mesAnoFaturamentoFinal != null && !mesAnoFaturamentoFinal.equals("")){

				condicoes.append("CDC.anoMesFaturamentoInicio <= :mesAnoFaturamentoFinal and ");
			}
			if(tarifaConsumo != null && !tarifaConsumo.equals(ConstantesSistema.NUMERO_NAO_INFORMADO)){

				condicoes.append("CDC.consumoTarifa.id = :tarifaConsumo and");
			}
			if(tipoContrato != null && tipoContrato.equals(ConstantesSistema.NAO_CONFIRMADA)){

				condicoes.append("CDC.numeroConsumoFixo is not null and CDC.numeroConsumoFixo > 0 and ");
			}

			if(!condicoes.toString().equals("")){
				consulta.append(" where ");
				consulta.append(condicoes);
			}

			String consultarFormatada = Util.formatarHQL(consulta.toString(), 4);

			consultarFormatada = consultarFormatada + " order by CDC.id ";

			Query query = session.createQuery(consultarFormatada);

			if(encerrado != null && !encerrado.equals(Integer.parseInt(ConstantesSistema.AMBOS_CONTRATO))){

				query.setInteger("encerrado", encerrado);
			}

			if(faturamentoGrupo != null && !faturamentoGrupo.equals(ConstantesSistema.NUMERO_NAO_INFORMADO)){

				query.setInteger("faturamentoGrupo", faturamentoGrupo);
			}
			if(localidades != null){

				query.setParameterList("localidades", localidades);
			}
			if(mesAnoFaturamentoInicial != null && !mesAnoFaturamentoInicial.equals("")){

				query.setInteger("mesAnoFaturamentoInicial", mesAnoFaturamentoInicial);
			}
			if(mesAnoFaturamentoFinal != null && !mesAnoFaturamentoFinal.equals("")){

				query.setInteger("mesAnoFaturamentoFinal", mesAnoFaturamentoFinal);
			}
			if(tarifaConsumo != null && !tarifaConsumo.equals(ConstantesSistema.NUMERO_NAO_INFORMADO)){

				query.setInteger("tarifaConsumo", tarifaConsumo);
			}

			retorno = query.list();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}


		return retorno;
	}

	/**
	 * [UC3132] Gerar Relatório de Contratos de Demanda de Consumo
	 * 
	 * @author Vicente Zarga
	 * @created 18/01/2013
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDadosRelatorioContratoDemandaConsumoCount(Integer faturamentoGrupo, Integer[] localidades, String tipoContrato,
					Integer tarifaConsumo, Integer mesAnoFaturamentoInicial, Integer mesAnoFaturamentoFinal, Integer encerrado)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = 0;
		StringBuilder consulta = new StringBuilder();
		StringBuilder condicoes = new StringBuilder();

		try{
			consulta.append("select count(CDC.id) from ContratoDemandaConsumo CDC ");
			consulta.append("INNER JOIN   CDC.imovel IMOV ");
			consulta.append("LEFT JOIN  IMOV.rota ROT ");
			consulta.append("LEFT JOIN  ROT.faturamentoGrupo FTGR ");
			consulta.append("LEFT JOIN  CDC.consumoTarifa ct ");

			if(encerrado != null && !encerrado.equals(Integer.parseInt(ConstantesSistema.AMBOS_CONTRATO))){

				condicoes.append(" CDC.indicacorEncerramento= :encerrado and ");
			}

			if(faturamentoGrupo != null && !faturamentoGrupo.equals(ConstantesSistema.NUMERO_NAO_INFORMADO)){

				condicoes.append("FTGR.id= :faturamentoGrupo and ");
			}
			if(localidades != null){

				condicoes.append("IMOV.localidade.id in (:localidades) and ");
			}
			if(mesAnoFaturamentoInicial != null && !mesAnoFaturamentoInicial.equals("")){

				condicoes.append("CDC.anoMesFaturamentoFim >= :mesAnoFaturamentoInicial and ");
			}
			if(mesAnoFaturamentoFinal != null && !mesAnoFaturamentoFinal.equals("")){

				condicoes.append("CDC.anoMesFaturamentoInicio <= :mesAnoFaturamentoFinal and ");
			}
			if(tarifaConsumo != null && !tarifaConsumo.equals(ConstantesSistema.NUMERO_NAO_INFORMADO)){

				condicoes.append("CDC.consumoTarifa.id = :tarifaConsumo and");
			}
			if(tipoContrato != null && tipoContrato.equals(ConstantesSistema.NAO_CONFIRMADA)){

				condicoes.append("CDC.numeroConsumoFixo is not null and CDC.numeroConsumoFixo > 0 and ");
			}

			if(!condicoes.toString().equals("")){
				consulta.append(" where ");
				consulta.append(condicoes);
			}

			String consultarFormatada = Util.formatarHQL(consulta.toString(), 4);


			Query query = session.createQuery(consultarFormatada);

			if(encerrado != null && !encerrado.equals(Integer.parseInt(ConstantesSistema.AMBOS_CONTRATO))){

				query.setInteger("encerrado", encerrado);
			}

			if(faturamentoGrupo != null && !faturamentoGrupo.equals(ConstantesSistema.NUMERO_NAO_INFORMADO)){

				query.setInteger("faturamentoGrupo", faturamentoGrupo);
			}
			if(localidades != null){

				query.setParameterList("localidades", localidades);
			}
			if(mesAnoFaturamentoInicial != null && !mesAnoFaturamentoInicial.equals("")){

				query.setInteger("mesAnoFaturamentoInicial", mesAnoFaturamentoInicial);
			}
			if(mesAnoFaturamentoFinal != null && !mesAnoFaturamentoFinal.equals("")){

				query.setInteger("mesAnoFaturamentoFinal", mesAnoFaturamentoFinal);
			}
			if(tarifaConsumo != null && !tarifaConsumo.equals(ConstantesSistema.NUMERO_NAO_INFORMADO)){

				query.setInteger("tarifaConsumo", tarifaConsumo);
			}

			retorno = ((Number) query.uniqueResult()).intValue();
		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3055] Encerrar Faturamento
	 * [SB0007] Encerrar contratos de demanda de consumo
	 * 
	 * @author Vicente Zarga
	 * @date 27/01/2014
	 */
	public void encerrarContratoDemandaConsumo(String referencia) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		String atualizaContratoDemanda = "";

		try{

			atualizaContratoDemanda = "update contrato_demanda_consumo set ctdc_icencerramento=1 where "
							+ "ctdc_amfaturamentofim=:referencia and ctdc_icencerramento=:aberto";

			session.createSQLQuery(atualizaContratoDemanda).setString("referencia", referencia)
							.setString("aberto", ConstantesSistema.INATIVO).executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");

		}finally{

			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [XYZ] Gerar Relatório Situação Especial de Faturamento
	 * 
	 * @author Hebert Falcão
	 * @date 16/03/2014
	 */
	public Collection<FaturamentoSituacaoHistorico> consultarSituacaoEspecialDeFaturamento(RelatorioSituacaoEspecialFaturamentoHelper helper)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select ftsh ");
			consulta.append("from FaturamentoSituacaoHistorico ftsh ");
			consulta.append("inner join fetch ftsh.faturamentoSituacaoTipo ftst ");
			consulta.append("inner join fetch ftsh.faturamentoSituacaoMotivo ftsm  ");
			consulta.append("inner join fetch ftsh.imovel imov  ");
			consulta.append("inner join fetch imov.localidade loca ");
			consulta.append("inner join fetch imov.setorComercial stcm ");
			consulta.append("inner join fetch imov.quadra qdra ");
			consulta.append("inner join fetch imov.rota rota ");
			consulta.append("where ftsh.anoMesFaturamentoRetirada is null ");

			// Referência do Faturamento
			Integer anoMesFaturamento = helper.getAnoMesFaturamento();

			if(anoMesFaturamento != null){
				consulta.append("  and :anoMesFaturamento between ftsh.anoMesFaturamentoSituacaoInicio and ftsh.anoMesFaturamentoSituacaoFim ");
			}

			// Localidade
			Integer idLocalidade = helper.getIdLocalidade();

			if(idLocalidade != null){
				consulta.append("  and loca.id = :idLocalidade ");
			}

			// Setor Comercial
			Integer codigoSetorComercial = helper.getCodigoSetorComercial();

			if(codigoSetorComercial != null){
				consulta.append("  and stcm.codigo = :codigoSetorComercial ");
			}

			// Quadra
			Integer numeroQuadra = helper.getNumeroQuadra();

			if(numeroQuadra != null){
				consulta.append("  and qdra.numeroQuadra = :numeroQuadra ");
			}

			// Rota
			Short codigoRota = helper.getCodigoRota();

			if(codigoRota != null){
				consulta.append("  and rota.codigo = :codigoRota ");
			}

			// Tipo da Situação Especial de Faturamento
			Integer idFaturamentoSituacaoTipo = helper.getIdFaturamentoSituacaoTipo();

			if(idFaturamentoSituacaoTipo != null){
				consulta.append("  and ftst.id = :idFaturamentoSituacaoTipo ");
			}

			// Motivo da Situação Especial de Faturamento
			Integer idFaturamentoSituacaoMotivo = helper.getIdFaturamentoSituacaoMotivo();

			if(idFaturamentoSituacaoMotivo != null){
				consulta.append("  and ftsm.id = :idFaturamentoSituacaoMotivo ");
			}

			consulta.append("order by ftst.id, ");
			consulta.append("         ftsm.id, ");
			consulta.append("         ftsh.anoMesFaturamentoSituacaoInicio, ");
			consulta.append("         ftsh.anoMesFaturamentoSituacaoFim, ");
			consulta.append("         loca.id, ");
			consulta.append("         stcm.codigo, ");
			consulta.append("         qdra.numeroQuadra, ");
			consulta.append("         imov.lote, ");
			consulta.append("         imov.subLote ");

			Query query = session.createQuery(consulta.toString());

			// Referência do Faturamento
			if(anoMesFaturamento != null){
				query.setInteger("anoMesFaturamento", anoMesFaturamento);
			}

			// Localidade
			if(idLocalidade != null){
				query.setInteger("idLocalidade", idLocalidade);
			}

			// Setor Comercial
			if(codigoSetorComercial != null){
				query.setInteger("codigoSetorComercial", codigoSetorComercial);
			}

			// Quadra
			if(numeroQuadra != null){
				query.setInteger("numeroQuadra", numeroQuadra);
			}

			// Rota
			if(codigoRota != null){
				query.setShort("codigoRota", codigoRota);
			}

			// Tipo da Situação Especial de Faturamento
			if(idFaturamentoSituacaoTipo != null){
				query.setInteger("idFaturamentoSituacaoTipo", idFaturamentoSituacaoTipo);
			}

			// Motivo da Situação Especial de Faturamento
			if(idFaturamentoSituacaoMotivo != null){
				query.setInteger("idFaturamentoSituacaoMotivo", idFaturamentoSituacaoMotivo);
			}

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [XYZ] Gerar Relatório Situação Especial de Faturamento
	 * 
	 * @author Hebert Falcão
	 * @date 16/03/2014
	 */
	public Integer consultarSituacaoEspecialDeFaturamentoCount(RelatorioSituacaoEspecialFaturamentoHelper helper)
					throws ErroRepositorioException{

		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select count(*) as count ");
			consulta.append("from FaturamentoSituacaoHistorico ftsh ");
			consulta.append("inner join ftsh.faturamentoSituacaoTipo ftst ");
			consulta.append("inner join ftsh.faturamentoSituacaoMotivo ftsm  ");
			consulta.append("inner join ftsh.imovel imov  ");
			consulta.append("inner join imov.localidade loca ");
			consulta.append("inner join imov.setorComercial stcm ");
			consulta.append("inner join imov.quadra qdra ");
			consulta.append("inner join imov.rota rota ");
			consulta.append("where ftsh.anoMesFaturamentoRetirada is null ");

			// Referência do Faturamento
			Integer anoMesFaturamento = helper.getAnoMesFaturamento();

			if(anoMesFaturamento != null){
				consulta.append("  and :anoMesFaturamento between ftsh.anoMesFaturamentoSituacaoInicio and ftsh.anoMesFaturamentoSituacaoFim ");
			}

			// Localidade
			Integer idLocalidade = helper.getIdLocalidade();

			if(idLocalidade != null){
				consulta.append("  and loca.id = :idLocalidade ");
			}

			// Setor Comercial
			Integer codigoSetorComercial = helper.getCodigoSetorComercial();

			if(codigoSetorComercial != null){
				consulta.append("  and stcm.codigo = :codigoSetorComercial ");
			}

			// Quadra
			Integer numeroQuadra = helper.getNumeroQuadra();

			if(numeroQuadra != null){
				consulta.append("  and qdra.numeroQuadra = :numeroQuadra ");
			}

			// Rota
			Short codigoRota = helper.getCodigoRota();

			if(codigoRota != null){
				consulta.append("  and rota.codigo = :codigoRota ");
			}

			// Tipo da Situação Especial de Faturamento
			Integer idFaturamentoSituacaoTipo = helper.getIdFaturamentoSituacaoTipo();

			if(idFaturamentoSituacaoTipo != null){
				consulta.append("  and ftst.id = :idFaturamentoSituacaoTipo ");
			}

			// Motivo da Situação Especial de Faturamento
			Integer idFaturamentoSituacaoMotivo = helper.getIdFaturamentoSituacaoMotivo();

			if(idFaturamentoSituacaoMotivo != null){
				consulta.append("  and ftsm.id = :idFaturamentoSituacaoMotivo ");
			}

			Query query = session.createQuery(consulta.toString());

			// Referência do Faturamento
			if(anoMesFaturamento != null){
				query.setInteger("anoMesFaturamento", anoMesFaturamento);
			}

			// Localidade
			if(idLocalidade != null){
				query.setInteger("idLocalidade", idLocalidade);
			}

			// Setor Comercial
			if(codigoSetorComercial != null){
				query.setInteger("codigoSetorComercial", codigoSetorComercial);
			}

			// Quadra
			if(numeroQuadra != null){
				query.setInteger("numeroQuadra", numeroQuadra);
			}

			// Rota
			if(codigoRota != null){
				query.setShort("codigoRota", codigoRota);
			}

			// Tipo da Situação Especial de Faturamento
			if(idFaturamentoSituacaoTipo != null){
				query.setInteger("idFaturamentoSituacaoTipo", idFaturamentoSituacaoTipo);
			}

			// Motivo da Situação Especial de Faturamento
			if(idFaturamentoSituacaoMotivo != null){
				query.setInteger("idFaturamentoSituacaoMotivo", idFaturamentoSituacaoMotivo);
			}

			retorno = ((Number) query.setMaxResults(1).uniqueResult()).intValue();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * 
	 */

	public Collection obterContasIntervalo(Integer anoMesInicio, Integer anoMesFim, FaturamentoGrupo faturamentoGrupo)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT cnta " + "FROM Conta cnta " + "inner join cnta.imovel imov " + "inner join imov.rota rota "
							+ "inner join rota.faturamentoGrupo fatGrupo " + "inner join fetch cnta.localidade loca " + "WHERE "
							+ "cnta.referencia BETWEEN :inicio and :fim  " + " and cnta.debitoCreditoSituacaoAtual = :idSituacaoConta "
							+ " and fatGrupo.id =:idFatGrupo";

			retorno = session.createQuery(consulta).setInteger("inicio", anoMesInicio).setInteger("fim", anoMesFim)
							.setInteger("idSituacaoConta", DebitoCreditoSituacao.NORMAL).setInteger("idFatGrupo", faturamentoGrupo.getId())
							.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 */
	public Collection obterContasHistoricoIntervalo(Integer anoMesInicio, Integer anoMesFim, Integer idSituacaoConta,
					FaturamentoGrupo faturamentoGrupo) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "SELECT cnta "
							+ "FROM ContaHistorico  cnta "
							+ "inner join cnta.imovel imov "
							+ "inner join imov.rota rota "
							+ "inner join rota.faturamentoGrupo fatGrupo "
							+ "inner join fetch cnta.localidade loca "
							+ "WHERE "
							+ " cnta.anoMesReferenciaConta  BETWEEN :inicio and :fim "
							+ " and cnta.debitoCreditoSituacaoAtual = :idSituacaoConta and cnta.id in (select max(cc.id) from ContaHistorico cc where cc.imovel.id =  cnta.imovel.id and cc.anoMesReferenciaConta = cnta.anoMesReferenciaConta )"
							+ " and fatGrupo.id =:idFatGrupo";

			retorno = session.createQuery(consulta).setInteger("inicio", anoMesInicio).setInteger("fim", anoMesFim)
							.setInteger("idSituacaoConta", idSituacaoConta).setInteger("idFatGrupo", faturamentoGrupo.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * Obtém os ids das contas que estiverem com o somatório do valor das faixas diferentes do valor
	 * da conta
	 * 
	 * @author Anderson Italo
	 * @date 21/03/2014
	 * @throws ErroRepositorioException
	 */
	public List pesquisarIdsContaRegerarContaCategoriaEFaixa(Integer referencia, String idsGrupos) throws ErroRepositorioException{

		List retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();

		String anoMes = Util.formatarAnoMesParaMesAnoSemBarra(referencia);
		String dataFormatada = "01/" + anoMes.substring(0, 2) + "/" + anoMes.substring(4, 6);

		try{
			
			sql.append(" SELECT con.cnta_id as idConta, ");
			sql.append(" mov.rota_id as idRota, ");
			sql.append(" mov.ftgr_id as idFaturamentoGrupo, ");
			sql.append(" mov.imov_id as idImovel ");
			sql.append(" from conta con ");
			sql.append(" inner join movimento_roteiro_empresa mov on (mov.imov_id = con.imov_id and mov.mrem_ammovimento = con.cnta_amreferenciaconta) ");
			sql.append(" where con.cnta_amreferenciaconta = " + referencia.toString());
			sql.append(" and con.dcst_idatual = " + DebitoCreditoSituacao.NORMAL.toString());
			sql.append(" and mov.ftgr_id            in (" + idsGrupos + ") ");
			sql.append(" and mov.mrem_icfase        =  " + MovimentoRoteiroEmpresa.FASE_PROCESSADO.toString());
			sql.append(" and mov.mrem_tmgeracaotxt < to_date('" + dataFormatada + "', 'dd/mm/yy')");
			sql.append(" and exists (select 1 from conta_categoria_consumo_faixa cccf where cccf.cnta_id = con.cnta_id)");
			sql.append(" order by mov.ftgr_id, mov.rota_id, mov.imov_id ");

			retorno = session.createSQLQuery(sql.toString()).addScalar("idConta", Hibernate.INTEGER).addScalar("idRota", Hibernate.INTEGER)
							.addScalar("idFaturamentoGrupo", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtém os ids das contas que estiverem com valor total igual a zero
	 * 
	 * @author Anderson Italo
	 * @date 26/03/2014
	 * @throws ErroRepositorioException
	 */
	public List pesquisarIdsContaZeradasParaEnviarHistorico(Integer referencia) throws ErroRepositorioException{

		List retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer sql = new StringBuffer();

		try{

			sql.append(" SELECT con.cnta_id as idConta, ");
			sql.append(" mov.rota_id as idRota, ");
			sql.append(" mov.ftgr_id as idFaturamentoGrupo, ");
			sql.append(" mov.imov_id as idImovel ");
			sql.append(" from conta con ");
			sql.append(" inner join movimento_roteiro_empresa mov on (mov.imov_id = con.imov_id and mov.mrem_ammovimento = con.cnta_amreferenciaconta) ");
			sql.append(" where con.cnta_amreferenciaconta = " + referencia.toString());
			sql.append(" and con.dcst_idatual in (" + DebitoCreditoSituacao.NORMAL.toString() + ","
							+ DebitoCreditoSituacao.RETIFICADA.toString() + ")");
			sql.append(" and mov.mrem_icfase        =  " + MovimentoRoteiroEmpresa.FASE_PROCESSADO.toString());
			sql.append(" and ((nvl(con.cnta_vlagua,0) + nvl(con.cnta_vlesgoto,0) + nvl(con.cnta_vldebitos,0)) - (nvl(con.cnta_vlcreditos,0) + nvl(con.cnta_vlimpostos,0)))  = 0");
			sql.append(" order by mov.ftgr_id, mov.rota_id, mov.imov_id ");

			retorno = session.createSQLQuery(sql.toString()).addScalar("idConta", Hibernate.INTEGER).addScalar("idRota", Hibernate.INTEGER)
							.addScalar("idFaturamentoGrupo", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER).list();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa o Count dos dados necessário para a geração do relatório
	 * [UC0638] - Gerar Relatórios Anormalidade Consumo
	 * 
	 * @author Ado Rocha
	 * @created 27/03/2014
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Integer pesquisarDadosRelatorioAnormalidadeConsumoCount(Integer idGrupoFaturamento, Short codigoRota,
					Integer idGerenciaRegional, Integer idUnidadeNegocio, Integer idElo, Integer idLocalidadeInicial,
					Integer idLocalidadeFinal, Integer referencia, Integer idImovelPerfil, Integer numOcorConsecutivas,
					String indicadorOcorrenciasIguais, Integer mediaConsumoInicial, Integer mediaConsumoFinal,
					Integer idAnormalidadeConsumo, Integer idAnormalidadeLeitura) throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try{

			consulta = "SELECT count(*) as quantidade" + " FROM imovel imov " + " INNER JOIN cliente_imovel clieImovUsuario "
							+ " on clieImovUsuario.imov_id = imov.imov_id " + " and clieImovUsuario.crtp_id = "
							+ ClienteRelacaoTipo.USUARIO + " and clieImovUsuario.clim_dtrelacaofim is null "
							+ " INNER JOIN cliente clieUsuario " + " on clieUsuario.clie_id = clieImovUsuario.clie_id "
							+ " INNER JOIN consumo_historico consHist " + " on consHist.imov_id = imov.imov_id "
							+ " and ( consHist.cshi_amfaturamento = :referencia ";
			int ocorConsecutiva = 0;
			if(numOcorConsecutivas != null && numOcorConsecutivas > 0){
				ocorConsecutiva = numOcorConsecutivas;
				while(numOcorConsecutivas > 0){
					int anoMes = Util.subtrairMesDoAnoMes(referencia, numOcorConsecutivas);
					consulta = consulta + " or consHist.cshi_amfaturamento = " + anoMes + " ";
					numOcorConsecutivas--;
				}
			}

			consulta = consulta + " ) ";

			consulta = consulta + "and consHist.lgti_id = " + LigacaoTipo.LIGACAO_AGUA + " INNER JOIN localidade loc "
							+ " on loc.loca_id = imov.loca_id " + " INNER JOIN localidade elo " + " on elo.loca_id = loc.loca_cdelo "
							+ " INNER JOIN unidade_negocio unidNeg " + " on unidNeg.uneg_id = loc.uneg_id "
							+ " INNER JOIN gerencia_regional greg " + " on greg.greg_id = unidNeg.greg_id " + " INNER JOIN quadra quadra "
							+ " on quadra.qdra_id = imov.qdra_id " + " INNER JOIN rota rota " + " on rota.rota_id = imov.rota_id "
							+ " INNER JOIN faturamento_grupo grupoFat " + " on grupoFat.ftgr_id = rota.ftgr_id "
							+ " LEFT OUTER JOIN consumo_anormalidade consAnor " + " on consAnor.csan_id = consHist.csan_id "
							+ " LEFT OUTER JOIN medicao_historico medHist " + " on medHist.imov_id = imov.imov_id "
							+ " and ( medHist.mdhi_amleitura = :referencia ";
			numOcorConsecutivas = ocorConsecutiva;
			if(numOcorConsecutivas != null && numOcorConsecutivas > 0){
				while(numOcorConsecutivas > 0){
					int anoMes = Util.subtrairMesDoAnoMes(referencia, numOcorConsecutivas);
					consulta = consulta + " or medHist.mdhi_amleitura = " + anoMes + " ";
					numOcorConsecutivas--;
				}
			}

			consulta = consulta + " ) ";

			consulta = consulta + "LEFT OUTER JOIN leitura_anormalidade leitAnor "
							+ " on leitAnor.ltan_id = medHist.ltan_idleituraanormalidadefatu "
							+ " LEFT OUTER JOIN hidrometro_instalacao_hist hidrInstHistPoco "
							+ " on hidrInstHistPoco.hidi_id = imov.hidi_id " + " LEFT OUTER JOIN hidrometro hidrPoco "
							+ " on hidrPoco.hidr_id = hidrInstHistPoco.hidr_id " + " LEFT OUTER JOIN hidrometro_capacidade hidrCapPoco "
							+ " on hidrCapPoco.hicp_id = hidrPoco.hicp_id "
							+ " LEFT OUTER JOIN hidrometro_local_instalacao hidrLocInstPoco "
							+ " on hidrLocInstPoco.hili_id = hidrInstHistPoco.hili_id " + " LEFT OUTER JOIN ligacao_agua lagu "
							+ " on lagu.lagu_id = imov.imov_id " + " LEFT OUTER JOIN hidrometro_instalacao_hist hidrInstHistAgua "
							+ " on hidrInstHistAgua.hidi_id = lagu.hidi_id " + " LEFT OUTER JOIN hidrometro hidrAgua "
							+ " on hidrAgua.hidr_id = hidrInstHistAgua.hidr_id " + " LEFT OUTER JOIN hidrometro_capacidade hidrCapAgua "
							+ " on hidrCapAgua.hicp_id = hidrAgua.hicp_id "
							+ " LEFT OUTER JOIN hidrometro_local_instalacao hidrLocInstAgua "
							+ " on hidrLocInstAgua.hili_id = hidrInstHistAgua.hili_id ";

			consulta = consulta
							+ criarCondicionaisRelatorioAnormalidadesConsumo(idGrupoFaturamento, codigoRota, idGerenciaRegional,
											idUnidadeNegocio, idElo, idLocalidadeInicial, idLocalidadeFinal, referencia, idImovelPerfil,
											numOcorConsecutivas, indicadorOcorrenciasIguais, mediaConsumoInicial, mediaConsumoFinal,
											idAnormalidadeConsumo, idAnormalidadeLeitura);

			if(ocorConsecutiva > 0){
				consulta = consulta + " group by grupoFat.ftgr_id, " + " grupoFat.ftgr_dsfaturamentogrupo , " + " greg.greg_id, "
								+ "greg.greg_nmabreviado , " + " unidNeg.uneg_id , " + "unidNeg.uneg_nmabreviado , " + " elo.loca_id, "
								+ "elo.loca_nmlocalidade, " + " loc.loca_id," + " loc.loca_nmlocalidade, " + " imov.imov_id ,"
								+ " clieUsuario.clie_nmcliente, " + " imov.last_id, " + "imov.lest_id, " + " imov.imov_icdebitoconta, "
								+ " consHist.cshi_nnconsumomedio," + " consHist.cshi_nnconsumofaturadomes, "
								+ " consAnor.csan_dsabreviadaconsumoanormal, " + " leitAnor.ltan_id, " + " imov.imov_qteconomia, "
								+ " medHist.medt_id," + " hidrCapPoco.hicp_dsabreviadahidrometrocapa, "
								+ " hidrLocInstPoco.hili_dsabreviadahidrometroloca, " + " hidrCapAgua.hicp_dsabreviadahidrometrocapa, "
								+ " hidrLocInstAgua.hili_dsabreviadahidrometroloca" + " " + "having count(imov.imov_id) > "
								+ ocorConsecutiva;
			}

			Object resultadoQuery = session.createSQLQuery(consulta).addScalar("quantidade", Hibernate.INTEGER)
							.setInteger("referencia", referencia).setMaxResults(1).uniqueResult();
			if(resultadoQuery == null){
				return 0;
			}

			retorno = ((Number) resultadoQuery).intValue();


		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}


	/**
	 * @param imovel
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarExistenciaContaHistoricoPorRefEImovel(Imovel imovel, Integer anoMesReferencia)
					throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try{
			consulta = "select cth.id from ContaHistorico cth " + "inner join cth.imovel " + "inner join cth.debitoCreditoSituacaoAtual "
							+ "where cth.anoMesReferenciaConta = :referencia " + "and cth.imovel.id = :imovel  ";

			retorno = (Collection) session.createQuery(consulta).setInteger("imovel", imovel.getId().intValue())
							.setInteger("referencia", anoMesReferencia).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * pesquisa debito a cobrar historico pelo id da conta historico
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CreditoRealizadoHistorico> pesquisarCreditosRealizadosHistoricoPorCreditoTipo(Integer idConta, Integer idCreditoTipo,
					String sinal) throws ErroRepositorioException{

		Collection<CreditoRealizadoHistorico> retorno = null;

		// cria uma sessão com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a variável que vai conter o hql
		String consulta;

		try{
			// constroi o hql
			consulta = "SELECT creditoRealizadoHistorico " + "FROM CreditoRealizadoHistorico creditoRealizadoHistorico "
							+ "JOIN FETCH creditoRealizadoHistorico.creditoTipo "
							+ "JOIN FETCH creditoRealizadoHistorico.lancamentoItemContabil "
							+ "WHERE creditoRealizadoHistorico.contaHistorico.id = :idConta "
							+ "and creditoRealizadoHistorico.creditoTipo.id " + sinal + ":idCreditoTipo ";


			// executa o hql
			retorno = session.createQuery(consulta).setInteger("idConta", idConta).setInteger("idCreditoTipo", idCreditoTipo).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Método que retorna a conta_categoria maior quantidade de economias
	 * [UC0083] Gerar Dados para Leitura
	 * [SB0001] - Gerar Arquivo Convencional
	 * [SB0010] - Gerar Arquivo - Modelo 2
	 * Dados para leitura (TIPO E)
	 * 
	 * @author Anderson Italo
	 * @date 11/06/2014
	 * @throws ErroRepositorioException
	 */
	public ContaCategoria pesquisarContaCategoriaComMaiorQuantidadeEconomias(Integer idConta) throws ErroRepositorioException{

		ContaCategoria retorno = null;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select contaCateg ");
			consulta.append("from ContaCategoria contaCateg ");
			consulta.append("inner join fetch contaCateg.comp_id.categoria categ ");
			consulta.append("inner join fetch contaCateg.comp_id.subcategoria subcateg ");
			consulta.append("where contaCateg.comp_id.conta.id = :idConta ");
			consulta.append("order by contaCateg.quantidadeEconomia desc, categ.id asc ");

			retorno = (ContaCategoria) session.createQuery(consulta.toString()).setInteger("idConta", idConta).setMaxResults(1)
							.uniqueResult();

		}catch(HibernateException e){

			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados de Cliente Debito a Cobrar.
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteDebitoACobrar(DebitoACobrar debitoACobrar) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select cldc " + "from ClienteDebitoACobrar cldc " + "where cldc.debitoACobrar.id = :idDebitoACobrar";

			retorno = session.createQuery(consulta).setInteger("idDebitoACobrar", debitoACobrar.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisa os dados de Cliente Credito A Realizar.
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteCreditoARealizar(CreditoARealizar creditoARealizar) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select cldc " + "from ClienteCreditoARealizar cldc " + "where cldc.creditoARealizar.id = :idCreditoARealizarr";

			retorno = session.createQuery(consulta).setInteger("idCreditoARealizarr", creditoARealizar.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * @param debitoACobrarHistorico
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarClienteDebitoACobrarHistorico(DebitoACobrarHistorico debitoACobrarHistorico) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{
			consulta = "select cldc " + "from ClienteDebitoACobrarHistorico cldc "
							+ "where cldc.debitoACobrarHistorico.id = :idDebitoACobrarHistorico";

			retorno = session.createQuery(consulta).setInteger("idDebitoACobrarHistorico", debitoACobrarHistorico.getId()).list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Collection<FaturamentoGrupoCronogramaMensal> pesquisarFaturamentoGrupoCronogramaMensalReferenciaMaior(
					Integer idFaturamentoGrupo, Integer anoMesReferencia) throws ErroRepositorioException{

		Collection<FaturamentoGrupoCronogramaMensal> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			consulta.append("select fgcm from FaturamentoGrupoCronogramaMensal fgcm ");
			consulta.append("inner join fetch fgcm.faturamentoGrupo fg  ");
			consulta.append("where fgcm.anoMesReferencia not in(:anoMesReferencia) and fg.id = :idFaturamentoGrupo ");
			consulta.append("and exists (select 1 from FaturamentoAtividadeCronograma fac where fac.faturamentoGrupoCronogramaMensal.id = fgcm.id ");
			consulta.append("and fac.dataRealizacao is null) order by fgcm.anoMesReferencia ");

			retorno = (Collection<FaturamentoGrupoCronogramaMensal>) session.createQuery(consulta.toString())
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo.intValue())
							.setInteger("anoMesReferencia", anoMesReferencia.intValue()).list();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public FaturamentoGrupoCronogramaMensal pesquisarUltimoFaturamentoGrupoCronogramaMensal(Integer idFaturamentoGrupo)
					throws ErroRepositorioException{

		FaturamentoGrupoCronogramaMensal retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;

		try{

			consulta = "select fgcm from FaturamentoGrupoCronogramaMensal fgcm inner join fetch fgcm.faturamentoGrupo "
							+ " fg where fg.id = :idFaturamentoGrupo " + " order by fgcm.anoMesReferencia desc ";

			retorno = (FaturamentoGrupoCronogramaMensal) session.createQuery(consulta)
							.setInteger("idFaturamentoGrupo", idFaturamentoGrupo.intValue()).setMaxResults(1).uniqueResult();

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/*
	 * (non-Javadoc)
	 * @see gcom.faturamento.IRepositorioFaturamento#obterContasPorLocalidade(java.lang.Integer,
	 * java.lang.Integer, java.lang.Integer)
	 */
	public Collection<Conta> obterContasPorLocalidade(Integer idLocalidade, Integer anoMesReferencia) throws ErroRepositorioException{

		Collection<Conta> contas = null;

		Session session = HibernateUtil.getSession();
		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("SELECT ");
			consulta.append(" cnta ");
			consulta.append("FROM ");
			consulta.append("  Conta cnta ");
			consulta.append("INNER JOIN FETCH cnta.imovel i ");
			consulta.append("INNER JOIN FETCH i.quadra q ");
			consulta.append("INNER JOIN FETCH q.quadraPerfil qp ");
			consulta.append("INNER JOIN FETCH i.setorComercial sc ");
			consulta.append("WHERE ");
			consulta.append(" cnta.localidade.id = :idLocalidade ");
			consulta.append("AND cnta.referencia = :anoMesReferencia ");
			consulta.append("ORDER BY ");
			consulta.append(" cnta.referencia");

			contas = session.createQuery(consulta.toString()).setInteger("idLocalidade", idLocalidade)
							.setInteger("anoMesReferencia", anoMesReferencia).list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return contas;
	}

	/**
	 * [UC3156] Simular Cálculo da Conta Dados Reais
	 * 
	 * @author Anderson Italo
	 * @date 22/09/2014
	 */
	public Collection pesquisarContasSimularCalculoDadosReais(FiltroContaSimularCalculoHelper helper, Integer numeroPagina)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList<Object>();
		StringBuilder consulta = new StringBuilder();
		StringBuilder condicoes = new StringBuilder();

		try{

			consulta.append(" select co.cnta_id as idConta, "); // 0
			consulta.append(" co.cnta_amreferenciaconta as anoMesReferenciaConta, "); // 1
			consulta.append(" ((coalesce(co.cnta_vlagua,0) + coalesce(co.cnta_vlesgoto,0) + coalesce(co.cnta_vldebitos,0)) - (coalesce(co.cnta_vlcreditos,0) + coalesce(co.cnta_vlimpostos,0))) as valorConta,");// 2
			consulta.append(" co.dcst_idatual as idDebitoCreditoSituacaoAtual,"); // 3
			consulta.append(" co.cnta_dtvencimentoconta as dataVencimento,"); // 4
			consulta.append(" coalesce(co.cnta_vlagua,0) as valorAgua,"); // 5
			consulta.append(" coalesce(co.cnta_vlesgoto,0) as valorEsgoto,"); // 6
			consulta.append(" coalesce(co.cnta_vldebitos,0) as valorDebitos,"); // 7
			consulta.append(" coalesce(co.cnta_vlcreditos,0) as valorCreditos,"); // 8
			consulta.append(" coalesce(co.cnta_vlimpostos,0) as valorImpostos, "); // 9
			consulta.append(" co.cstf_id as idConsumoTarifa, "); // 10
			consulta.append(" co.last_id as idLigacaoAguaSituacao, "); // 11
			consulta.append(" co.lest_id as idLigacaoEsgotoSituacao, "); // 12
			consulta.append(" co.imov_id as idImovel, "); // 13
			consulta.append(" co.cnta_nnconsumoagua as consumoFaturadoAgua, "); // 14
			consulta.append(" co.cnta_nnconsumoesgoto as consumoFaturadoEsgoto, "); // 15
			consulta.append(" co.cnta_pcesgoto as percentualEsgoto, "); // 16
			consulta.append(" im.cstf_id as idConsumoTarifaImovel, "); // 17
			consulta.append(" 2 as indicadorHistorico"); // 18

			consulta.append(" from conta co");
			consulta.append(" inner join imovel im on im.imov_id = co.imov_id");

			// Período de Referência do Faturamento
			if(helper.getPeriodoReferenciaFaturamentoInicial() != null && helper.getPeriodoReferenciaFaturamentoFinal() != null){

				condicoes.append(" (co.cnta_amreferenciaconta >= " + helper.getPeriodoReferenciaFaturamentoInicial().toString()
								+ " and co.cnta_amreferenciaconta <= " + helper.getPeriodoReferenciaFaturamentoFinal().toString() + ") and");
			}

			// Imóvel
			if(helper.getIdImovel() != null){

				condicoes.append(" co.imov_id = " + helper.getIdImovel().toString() + " and");
			}

			// Situação da Ligação de Água
			if(helper.getIdLigacaoAguaSituacao() != null){

				condicoes.append(" co.last_id = " + helper.getIdLigacaoAguaSituacao().toString() + " and");
			}

			// Situação da Ligação de Esgoto
			if(helper.getIdLigacaoEsgotoSituacao() != null){

				condicoes.append(" co.lest_id = " + helper.getIdLigacaoEsgotoSituacao().toString() + " and");
			}

			// Tarifa de Consumo
			if(helper.getIdConsumoTarifa() != null){

				condicoes.append(" co.cstf_id = " + helper.getIdConsumoTarifa().toString() + " and");
			}

			// Grupo de Faturamento
			if(helper.getIdFaturamentoGrupo() != null){

				condicoes.append(" exists(select 1 from  rota ro where ro.rota_id = im.rota_id ");
				condicoes.append(" and ro.ftgr_id = " + helper.getIdFaturamentoGrupo().toString() + ") and");
			}

			// Categeoria(s)
			if(helper.getIdsCategorias() != null){

				condicoes.append(" exists (select 1 from conta_categoria cc where cc.cnta_id = co.cnta_id and cc.catg_id in ("
								+ helper.getIdsCategorias() + ")) and");
			}

			// Verificar existência de vigência válida para categoria da conta e vigência
			// selecionada
			if(helper.getIdConsumoTarifaVigenciaRecalcular() != null){

				condicoes.append(" exists (select 1 from conta_categoria cc where cc.cnta_id = co.cnta_id and cc.catg_id in (");
				condicoes.append(" select distinct(ctc.catg_id) from consumo_tarifa_categoria ctc");
				condicoes.append(" inner join consumo_tarifa_vigencia ctv on ctc.cstc_id = ctc.cstc_id");
				condicoes.append(" where  ctc.cstv_id = " + helper.getIdConsumoTarifaVigenciaRecalcular().toString() + ")) and");
			}

			condicoes.append(" co.dcst_idatual in (" + DebitoCreditoSituacao.NORMAL.toString() + ", "
							+ DebitoCreditoSituacao.INCLUIDA.toString() + ", " + DebitoCreditoSituacao.RETIFICADA.toString() + ", "
							+ DebitoCreditoSituacao.PARCELADA.toString() + ") and");

			consulta.append(" where " + condicoes.toString().substring(0, condicoes.toString().length() - 3));

			condicoes = new StringBuilder();

			// Union com resultado de pesquisa no histórico
			consulta.append(" UNION ALL ");

			consulta.append(" select ch.cnta_id as idConta, "); // 0
			consulta.append(" ch.cnhi_amreferenciaconta as anoMesReferenciaConta, "); // 1
			consulta.append(" ((coalesce(ch.cnhi_vlagua,0) + coalesce(ch.cnhi_vlesgoto,0) + coalesce(ch.cnhi_vldebitos,0)) - (coalesce(ch.cnhi_vlcreditos,0) + coalesce(ch.cnhi_vlimpostos,0))) as valorConta,");// 2
			consulta.append(" ch.dcst_idatual as idDebitoCreditoSituacaoAtual,"); // 3
			consulta.append(" ch.cnhi_dtvencimentoconta as dataVencimento,"); // 4
			consulta.append(" coalesce(ch.cnhi_vlagua,0) as valorAgua,"); // 5
			consulta.append(" coalesce(ch.cnhi_vlesgoto,0) as valorEsgoto,"); // 6
			consulta.append(" coalesce(ch.cnhi_vldebitos,0) as valorDebitos,"); // 7
			consulta.append(" coalesce(ch.cnhi_vlcreditos,0) as valorCreditos,"); // 8
			consulta.append(" coalesce(ch.cnhi_vlimpostos,0) as valorImpostos, "); // 9
			consulta.append(" ch.cstf_id as idConsumoTarifa, "); // 10
			consulta.append(" ch.last_id as idLigacaoAguaSituacao, "); // 11
			consulta.append(" ch.lest_id as idLigacaoEsgotoSituacao, "); // 12
			consulta.append(" ch.imov_id as idImovel, "); // 13
			consulta.append(" ch.cnhi_nnconsumoagua as consumoFaturadoAgua, "); // 14
			consulta.append(" ch.cnhi_nnconsumoesgoto as consumoFaturadoEsgoto, "); // 15
			consulta.append(" ch.cnhi_pcesgoto as percentualEsgoto, "); // 16
			consulta.append(" im.cstf_id as idConsumoTarifaImovel, "); // 17
			consulta.append(" 1 as indicadorHistorico"); // 18

			consulta.append(" from conta_historico ch");
			consulta.append(" inner join imovel im on im.imov_id = ch.imov_id");

			// Período de Referência do Faturamento
			if(helper.getPeriodoReferenciaFaturamentoInicial() != null && helper.getPeriodoReferenciaFaturamentoFinal() != null){

				condicoes.append(" (ch.cnhi_amreferenciaconta >= " + helper.getPeriodoReferenciaFaturamentoInicial().toString()
								+ " and ch.cnhi_amreferenciaconta <= " + helper.getPeriodoReferenciaFaturamentoFinal().toString() + ") and");
			}

			// Imóvel
			if(helper.getIdImovel() != null){

				condicoes.append(" ch.imov_id = " + helper.getIdImovel().toString() + " and");
			}

			// Situação da Ligação de Água
			if(helper.getIdLigacaoAguaSituacao() != null){

				condicoes.append(" ch.last_id = " + helper.getIdLigacaoAguaSituacao().toString() + " and");
			}

			// Situação da Ligação de Esgoto
			if(helper.getIdLigacaoEsgotoSituacao() != null){

				condicoes.append(" ch.lest_id = " + helper.getIdLigacaoEsgotoSituacao().toString() + " and");
			}

			// Tarifa de Consumo
			if(helper.getIdConsumoTarifa() != null){

				condicoes.append(" ch.cstf_id = " + helper.getIdConsumoTarifa().toString() + " and");
			}

			// Grupo de Faturamento
			if(helper.getIdFaturamentoGrupo() != null){

				condicoes.append(" exists(select 1 from rota ro where ro.rota_id = im.rota_id  ");
				condicoes.append(" and ro.ftgr_id = " + helper.getIdFaturamentoGrupo().toString() + ") and");
			}

			// Categeoria(s)
			if(helper.getIdsCategorias() != null){

				condicoes.append(" exists (select 1 from conta_categoria_historico cch where cch.cnta_id = ch.cnta_id and cch.catg_id in ("
								+ helper.getIdsCategorias() + ")) and");
			}

			// Verificar existência de vigência válida para categoria da conta e vigência
			// selecionada
			if(helper.getIdConsumoTarifaVigenciaRecalcular() != null){

				condicoes.append(" exists (select 1 from conta_categoria_historico cch where cch.cnta_id = ch.cnta_id and cch.catg_id in (");
				condicoes.append(" select distinct(ctc.catg_id) from consumo_tarifa_categoria ctc");
				condicoes.append(" inner join consumo_tarifa_vigencia ctv on ctc.cstc_id = ctc.cstc_id");
				condicoes.append(" where  ctc.cstv_id = " + helper.getIdConsumoTarifaVigenciaRecalcular().toString() + ")) and");
			}

			condicoes.append(" ch.dcst_idatual in (" + DebitoCreditoSituacao.NORMAL.toString() + ", "
							+ DebitoCreditoSituacao.INCLUIDA.toString() + ", " + DebitoCreditoSituacao.RETIFICADA.toString() + ", "
							+ DebitoCreditoSituacao.PARCELADA.toString() + ") and");

			consulta.append(" where " + condicoes.toString().substring(0, condicoes.toString().length() - 3));

			consulta.append(" order by 14 asc, 2 desc ");

			if(numeroPagina != null){

				retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.INTEGER)
							.addScalar("anoMesReferenciaConta", Hibernate.INTEGER).addScalar("valorConta", Hibernate.BIG_DECIMAL)
								.addScalar("idDebitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitos", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							.addScalar("valorImpostos", Hibernate.BIG_DECIMAL).addScalar("idConsumoTarifa", Hibernate.INTEGER)
								.addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
								.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER)
								.addScalar("consumoFaturadoAgua", Hibernate.INTEGER).addScalar("consumoFaturadoEsgoto", Hibernate.INTEGER)
								.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idConsumoTarifaImovel", Hibernate.INTEGER)
								.addScalar("indicadorHistorico", Hibernate.SHORT).setFirstResult(10 * numeroPagina).setMaxResults(10)
								.list();
			}else{

				retorno = (Collection) session.createSQLQuery(consulta.toString()).addScalar("idConta", Hibernate.INTEGER)
								.addScalar("anoMesReferenciaConta", Hibernate.INTEGER).addScalar("valorConta", Hibernate.BIG_DECIMAL)
								.addScalar("idDebitoCreditoSituacaoAtual", Hibernate.INTEGER).addScalar("dataVencimento", Hibernate.DATE)
								.addScalar("valorAgua", Hibernate.BIG_DECIMAL).addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
								.addScalar("valorDebitos", Hibernate.BIG_DECIMAL).addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
								.addScalar("valorImpostos", Hibernate.BIG_DECIMAL).addScalar("idConsumoTarifa", Hibernate.INTEGER)
								.addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
								.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER).addScalar("idImovel", Hibernate.INTEGER)
								.addScalar("consumoFaturadoAgua", Hibernate.INTEGER).addScalar("consumoFaturadoEsgoto", Hibernate.INTEGER)
								.addScalar("percentualEsgoto", Hibernate.BIG_DECIMAL).addScalar("idConsumoTarifaImovel", Hibernate.INTEGER)
								.addScalar("indicadorHistorico", Hibernate.SHORT).list();
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3156] Simular Cálculo da Conta Dados Reais
	 * 
	 * @author Anderson Italo
	 * @date 22/09/2014
	 */
	public Integer pesquisarTotalRegistrosContasSimularCalculoDadosReais(FiltroContaSimularCalculoHelper helper)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();
		Integer retorno = 0;
		StringBuilder consulta = new StringBuilder();
		StringBuilder condicoes = new StringBuilder();

		try{

			consulta.append(" select count(distinct(co.cnta_id)) as qtdConta ");
			consulta.append(" from conta co ");

			// Período de Referência do Faturamento
			if(helper.getPeriodoReferenciaFaturamentoInicial() != null && helper.getPeriodoReferenciaFaturamentoFinal() != null){

				condicoes.append(" (co.cnta_amreferenciaconta >= " + helper.getPeriodoReferenciaFaturamentoInicial().toString()
								+ " and co.cnta_amreferenciaconta <= " + helper.getPeriodoReferenciaFaturamentoFinal().toString() + ") and");
			}

			// Imóvel
			if(helper.getIdImovel() != null){

				condicoes.append(" co.imov_id = " + helper.getIdImovel().toString() + " and");
			}

			// Situação da Ligação de Água
			if(helper.getIdLigacaoAguaSituacao() != null){

				condicoes.append(" co.last_id = " + helper.getIdLigacaoAguaSituacao().toString() + " and");
			}

			// Situação da Ligação de Esgoto
			if(helper.getIdLigacaoEsgotoSituacao() != null){

				condicoes.append(" co.lest_id = " + helper.getIdLigacaoEsgotoSituacao().toString() + " and");
			}

			// Tarifa de Consumo
			if(helper.getIdConsumoTarifa() != null){

				condicoes.append(" co.cstf_id = " + helper.getIdConsumoTarifa().toString() + " and");
			}

			// Grupo de Faturamento
			if(helper.getIdFaturamentoGrupo() != null){

				condicoes.append(" exists(select 1 from  imovel im inner join rota ro on ro.rota_id = im.rota_id where co.imov_id = im.imov_id ");
				condicoes.append(" and ro.ftgr_id = " + helper.getIdFaturamentoGrupo().toString() + ") and");
			}

			// Categeoria(s)
			if(helper.getIdsCategorias() != null){

				condicoes.append(" exists (select 1 from conta_categoria cc where cc.cnta_id = co.cnta_id and cc.catg_id in ("
								+ helper.getIdsCategorias() + ")) and");
			}

			// Verificar existência de vigência válida para categoria da conta e vigência
			// selecionada
			if(helper.getIdConsumoTarifaVigenciaRecalcular() != null){

				condicoes.append(" exists (select 1 from conta_categoria cc where cc.cnta_id = co.cnta_id and cc.catg_id in (");
				condicoes.append(" select distinct(ctc.catg_id) from consumo_tarifa_categoria ctc");
				condicoes.append(" inner join consumo_tarifa_vigencia ctv on ctc.cstc_id = ctc.cstc_id");
				condicoes.append(" where  ctc.cstv_id = " + helper.getIdConsumoTarifaVigenciaRecalcular().toString() + ")) and");
			}

			condicoes.append(" co.dcst_idatual in (" + DebitoCreditoSituacao.NORMAL.toString() + ", "
							+ DebitoCreditoSituacao.INCLUIDA.toString() + ", " + DebitoCreditoSituacao.RETIFICADA.toString() + ", "
							+ DebitoCreditoSituacao.PARCELADA.toString() + ") and");

			consulta.append(" where " + condicoes.toString().substring(0, condicoes.toString().length() - 3));

			condicoes = new StringBuilder();

			// Union com resultado de pesquisa no histórico
			consulta.append(" UNION ALL ");

			consulta.append(" select count(distinct(ch.cnta_id)) as qtdConta ");
			consulta.append(" from conta_historico ch");


			// Período de Referência do Faturamento
			if(helper.getPeriodoReferenciaFaturamentoInicial() != null && helper.getPeriodoReferenciaFaturamentoFinal() != null){

				condicoes.append(" (ch.cnhi_amreferenciaconta >= " + helper.getPeriodoReferenciaFaturamentoInicial().toString()
								+ " and ch.cnhi_amreferenciaconta <= " + helper.getPeriodoReferenciaFaturamentoFinal().toString() + ") and");
			}

			// Imóvel
			if(helper.getIdImovel() != null){

				condicoes.append(" ch.imov_id = " + helper.getIdImovel().toString() + " and");
			}

			// Situação da Ligação de Água
			if(helper.getIdLigacaoAguaSituacao() != null){

				condicoes.append(" ch.last_id = " + helper.getIdLigacaoAguaSituacao().toString() + " and");
			}

			// Situação da Ligação de Esgoto
			if(helper.getIdLigacaoEsgotoSituacao() != null){

				condicoes.append(" ch.lest_id = " + helper.getIdLigacaoEsgotoSituacao().toString() + " and");
			}

			// Tarifa de Consumo
			if(helper.getIdConsumoTarifa() != null){

				condicoes.append(" ch.cstf_id = " + helper.getIdConsumoTarifa().toString() + " and");
			}

			// Grupo de Faturamento
			if(helper.getIdFaturamentoGrupo() != null){

				condicoes.append(" exists(select 1 from  imovel im inner join rota ro on ro.rota_id = im.rota_id where ch.imov_id = im.imov_id  ");
				condicoes.append(" and ro.ftgr_id = " + helper.getIdFaturamentoGrupo().toString() + ") and");
			}

			// Categeoria(s)
			if(helper.getIdsCategorias() != null){

				condicoes.append(" exists (select 1 from conta_categoria_historico cch where cch.cnta_id = ch.cnta_id and cch.catg_id in ("
								+ helper.getIdsCategorias() + ")) and");
			}

			// Verificar existência de vigência válida para categoria da conta e vigência
			// selecionada
			if(helper.getIdConsumoTarifaVigenciaRecalcular() != null){

				condicoes.append(" exists (select 1 from conta_categoria_historico cch where cch.cnta_id = ch.cnta_id and cch.catg_id in (");
				condicoes.append(" select distinct(ctc.catg_id) from consumo_tarifa_categoria ctc");
				condicoes.append(" inner join consumo_tarifa_vigencia ctv on ctc.cstc_id = ctc.cstc_id");
				condicoes.append(" where  ctc.cstv_id = " + helper.getIdConsumoTarifaVigenciaRecalcular().toString() + ")) and");
			}

			condicoes.append(" ch.dcst_idatual in (" + DebitoCreditoSituacao.NORMAL.toString() + ", "
							+ DebitoCreditoSituacao.INCLUIDA.toString() + ", " + DebitoCreditoSituacao.RETIFICADA.toString() + ", "
							+ DebitoCreditoSituacao.PARCELADA.toString() + ") and");

			consulta.append(" where " + condicoes.toString().substring(0, condicoes.toString().length() - 3));


			Collection retornoUnion = (Collection) session.createSQLQuery(consulta.toString()).addScalar("qtdConta", Hibernate.INTEGER)
							.list();

			if(!Util.isVazioOrNulo(retornoUnion)){

				for(Object totalizador : retornoUnion){

					Number dadosTotalizador = (Number) totalizador;

					if(dadosTotalizador != null){

						retorno = retorno.intValue() + dadosTotalizador.intValue();
					}
				}
			}

		}catch(HibernateException e){

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0001] - Gerar Declaração Anual Quitação Débitos
	 * O sistema seleciona as guias de pagamento quitadas ou parceladas no ano de
	 * referência (a partir da tabela GUIA_PAGAMENTO_PRESTACAO com
	 * GPAG_ID = GPAG_ID da tabela GUIA_PAGAMENTO com IMOV_ID = IMOV_ID
	 * da tabela IMOVEL e DCST_ID = DCST_ID da tabela
	 * DEBITO_CREDITO_SITUACAO com DCST_ICVALIDO com o valor
	 * correspondente a "Sim" e GPAG_ID = GPAG_ID e PGHI_NNPRESTACAO =
	 * PGHI_NNPRESTACAO da tabela PAGAMENTO_HISTORICO com PGST_IDATUAL=0
	 * e PGHI_DTPAGAMENTO menor ou igual ao último dia do ano de
	 * referência ou DCST_ID=DCST_ID da tabela DEBITO_CREDITO_SITUACAO
	 * com DCST_DSDEBITOCREDITOSITUACAO com o valor correspondente a
	 * "Cancelada por Parcelamento").
	 * 
	 * @author Yara Souza
	 * @date 29/09/2014
	 *       select * from guia_pagamento_prestacao_hist gpph
	 *       left join guia_pagamento gp on gp.gpag_id = gppH.gpag_id
	 *       inner join debito_credito_situacao dcst on dcst.dcst_id = gpph.dcst_id and
	 *       dcst.dcst_icvalido = 1
	 *       where ( exists (select 1 from pagamento_historico where gpag_id = gpph.gpag_id ) and
	 *       gpph.dcst_id = 0 )
	 *       or gpph.dcst_id = 5 ;
	 */
	public Collection<GuiaPagamentoPrestacaoHistorico> pesquisaGuiasPagamentoQuitadasAnoReferencia(Integer idImovel,
					Integer referenciaFinal, Date dataFinal) throws ErroRepositorioException{

		Collection<GuiaPagamentoPrestacaoHistorico> retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select gpph ");
			consulta.append("from GuiaPagamentoPrestacaoHistorico gpph ");
			consulta.append("left join gpph.guiaPagamento gp ");
			consulta.append("inner join gpph.debitoCreditoSituacao dcst ");
			consulta.append(" where gp.imovel.id = :idImovel ");
			consulta.append(" and dcst.indicadorValido = :indicadorValido ");
			consulta.append(" and (exists (select 1 from PagamentoHistorico ph where ph.guiaPagamentoGeral.id = gp.id and ph.numeroPrestacao = gpph.comp_id.numeroPrestacao and ph.dataPagamento <= :dataFinal ))");
			consulta.append(" or (dcst.id = :debitoCreditoSituacaoParcelada) ");
			consulta.append(" and gpph.anoMesReferenciaFaturamento = :referenciaFinal ");

			Query query = session.createQuery(consulta.toString());
			query.setShort("indicadorValido", ConstantesSistema.SIM);
			query.setInteger("idImovel", idImovel);
			query.setDate("dataFinal", dataFinal);
			query.setInteger("referenciaFinal", referenciaFinal);
			query.setInteger("debitoCreditoSituacaoParcelada", DebitoCreditoSituacao.PARCELADA);

			retorno = (Collection<GuiaPagamentoPrestacaoHistorico>) query.list();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0004 - Verificar Não Geração da Declaração para o Imóvel - Modelo Default]
	 * 
	 * @author Yara Souza
	 * @created 01/10/2014
	 */
	public boolean verificarImovelContasVencidasAnoReferenciaEmRevisao(Integer idImovel, Date ultimoDiaDoAnoDeReferencia,
					Integer pVerificarPagamentoPendente) throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{

			Number qtd = 0;

			consulta.append(" SELECT count(c.cnta_id) as qtd ");
			consulta.append(" from conta c ");
			consulta.append(" inner join debito_credito_situacao dcst on dcst.dcst_id = c.dcst_idatual ");
			consulta.append(" left join conta_motivo_revisao cmrv on cmrv.cmrv_id = c.cmrv_id ");
			consulta.append(" where c.imov_id =:idImovel ");
			consulta.append(" and dcst.DCST_ICVALIDO =:indicadorValido ");
			consulta.append(" and c.cnta_dtvencimentoconta <=:ultimoDiaDoAnoDeReferencia ");
			consulta.append(" and (cmrv.cmrv_id is null or cmrv.CMRV_ICINIBEDECLARACAOQUITACAO =:indicadorInibeDeclaracaoQuitacao)");

			if(pVerificarPagamentoPendente.equals(ConstantesSistema.SIM)){
				consulta.append(" and c.cnta_icpagamento =:indicadorPagamento or  c.cnta_icpagamento is null ");		

				qtd = (Number) session.createSQLQuery(consulta.toString()).addScalar("qtd", Hibernate.INTEGER)
								.setInteger("idImovel", idImovel).setShort("indicadorValido", ConstantesSistema.SIM)
								.setDate("ultimoDiaDoAnoDeReferencia",ultimoDiaDoAnoDeReferencia)
								.setShort("indicadorInibeDeclaracaoQuitacao", ConstantesSistema.SIM)
								.setShort("indicadorPagamento", ConstantesSistema.NAO).uniqueResult();
			}else{
				qtd = (Number) session.createSQLQuery(consulta.toString()).addScalar("qtd", Hibernate.INTEGER)
								.setInteger("idImovel", idImovel).setShort("indicadorValido", ConstantesSistema.SIM)
								.setDate("ultimoDiaDoAnoDeReferencia", ultimoDiaDoAnoDeReferencia)
								.setShort("indicadorInibeDeclaracaoQuitacao", ConstantesSistema.SIM).uniqueResult();
			}
					
			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0004 - Verificar Não Geração da Declaração para o Imóvel - Modelo Default]
	 * 
	 * @author Yara Souza
	 * @created 01/10/2014
	 */
	public boolean verificarImovelGuiasVencidasAnoReferencia(Integer idImovel, Date ultimoDiaDoAnoDeReferencia,
					Integer pVerificarPagamentoPendente) throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select count(*) as qtd ");
			consulta.append("from guia_pagamento_prestacao gppr ");
			consulta.append("inner join guia_pagamento gpag on gpag.gpag_id = gppr.gpag_id ");
			consulta.append("inner join debito_credito_situacao dcst on dcst.dcst_id = gppr.dcst_id ");
			consulta.append("where gpag.imov_id =:idImovel ");
			consulta.append("  and gppr.gppr_dtvencimento <=:ultimoDiaDoAnoDeReferencia ");
			consulta.append("  and dcst.dcst_icvalido =:indicadorValido ");

			SQLQuery query = null;

			if(pVerificarPagamentoPendente.equals(ConstantesSistema.SIM)){
				consulta.append("  and ( gppr.gppr_icpagamento =:indicadorPagamento or gppr.gppr_icpagamento is null) ");

				query = session.createSQLQuery(consulta.toString()).addScalar("qtd", Hibernate.INTEGER);

				query.setInteger("idImovel", idImovel);
				query.setDate("ultimoDiaDoAnoDeReferencia", ultimoDiaDoAnoDeReferencia);
				query.setShort("indicadorValido", ConstantesSistema.SIM);
				query.setShort("indicadorPagamento", ConstantesSistema.NAO);
			}else{
				query = session.createSQLQuery(consulta.toString()).addScalar("qtd", Hibernate.INTEGER);

				query.setInteger("idImovel", idImovel);
				query.setDate("ultimoDiaDoAnoDeReferencia", ultimoDiaDoAnoDeReferencia);
				query.setShort("indicadorValido", ConstantesSistema.SIM);

			}



			Number qtd = (Number) query.setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * [SB0004 - Verificar Não Geração da Declaração para o Imóvel - Modelo Default]
	 * 
	 * @author Yara Souza
	 * @created 01/10/2014
	 */
	public boolean verificarPagamentosHistoricoParaImovelAnoReferencia(Integer idImovel, Integer referenciaInicial,
					Integer referenciaFinal, Integer pVerificarPagamentoPendente) throws ErroRepositorioException{

		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		StringBuffer consulta = new StringBuffer();

		try{
			consulta.append("select count(*) ");
			consulta.append("from pagamento_historico pghi ");
			consulta.append("where pghi.imov_id = :idImovel ");

			if(pVerificarPagamentoPendente.equals(ConstantesSistema.SIM)){
				consulta.append("  and ( pghi.gpag_id is not null and  and pghi.pghi_amreferenciapagamento between :referenciaInicial and :referenciaFinal  ) ");

			}else{
				consulta.append("  and pghi.pghi_amreferenciapagamento between :referenciaInicial and :referenciaFinal ");
			}

			SQLQuery query = session.createSQLQuery(consulta.toString());

			query.setInteger("idImovel", idImovel);
			query.setInteger("referenciaInicial", referenciaInicial);
			query.setInteger("referenciaFinal", referenciaFinal);

			Number qtd = (Number) query.setMaxResults(1).uniqueResult();

			if(qtd != null && qtd.intValue() > 0){
				return true;
			}

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0187] Inserir Guia de Pagamento
	 * Processos das execuções especiais pendentes de cobrança do valor de sucumbência
	 */
	public Collection<Integer> pesquisarProcessosExecucaoEspeciaisPendentesCobrancaPorCliente(Integer idCliente,
					Integer idCobrancaSituacaoExecFiscal, Integer idSucumbencia) throws ErroRepositorioException{

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		StringBuilder consulta = new StringBuilder();

		try{
			consulta.append("select imovelCobSit.numeroProcessoAdministrativoExecucaoFiscal ");
			consulta.append("from ImovelCobrancaSituacao imovelCobSit ");
			consulta.append("where imovelCobSit.cliente.id = :idCliente ");
			consulta.append("  and imovelCobSit.cobrancaSituacao.id = :idCobrancaSituacao ");
			consulta.append("  and imovelCobSit.numeroProcessoAdministrativoExecucaoFiscal not in ( ");
			consulta.append("     select distinct gppe.comp_id.numeroProcessoAdministrativoExecucaoFiscal ");
			consulta.append("     from GuiaPagamentoPrestacao gppe ");
			consulta.append("     where gppe.debitoCreditoSituacao.id = " + DebitoCreditoSituacao.NORMAL);
			consulta.append("     and gppe.debitoTipo.id = :idSucumbencia) ");
			consulta.append("  and numeroProcessoAdministrativoExecucaoFiscal not in ( ");
			consulta.append("     select distinct gpph.comp_id.numeroProcessoAdministrativoExecucaoFiscal ");
			consulta.append("     from GuiaPagamentoPrestacaoHistorico gpph ");
			consulta.append("     where gpph.debitoCreditoSituacao.id =  " + DebitoCreditoSituacao.NORMAL);
			consulta.append("     and gpph.debitoTipo.id = :idSucumbencia) ");
			consulta.append("order by imovelCobSit.numeroProcessoAdministrativoExecucaoFiscal ");

			Query query = session.createQuery(consulta.toString());

			query.setInteger("idCliente", idCliente);
			query.setInteger("idCobrancaSituacao", idCobrancaSituacaoExecFiscal);
			query.setInteger("idSucumbencia", idSucumbencia);

			retorno = query.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public List<Object[]> gerarRelatorioTotalContasEmitidasLocalidade(Integer anoMesReferencia) throws ErroRepositorioException{

		List<Object[]> listaRetorno = new ArrayList<Object[]>();

		StringBuilder consulta = new StringBuilder();

		consulta.append(" SELECT TOT_LOC AS LOCAL, TOT_SFT AS SETOR, SUM(TOT_QTTOT) AS QT_CONTAS, SUM( TOT_VLTOT ) AS VALOR_CONTAS ");
		consulta.append(" , SUM(TOT_VLTOTPARTICULAR ) AS VALOR_PARTICULAR , SUM( TOT_VLTOTPUBLICO ) AS VALOR_PUBLICO ");

		consulta.append(" FROM TOT_LOCSFT GROUP BY TOT_LOC, TOT_SFT ORDER BY TOT_LOC, TOT_SFT ");

		Session session = HibernateUtil.getSession();

		try{

			SQLQuery sqlQuery = session.createSQLQuery(consulta.toString());

			listaRetorno = sqlQuery.list();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

		return listaRetorno;
	}

	public void inserirRegistrosTabelaTemporariaRelatorioTotalContasEmitidasLocalidade(Integer anoMesReferencia)
					throws ErroRepositorioException{

		StringBuilder sql = new StringBuilder();

		StringBuilder stringLancamentoContabil = new StringBuilder();

		stringLancamentoContabil.append(" JOIN LANCAMENTO_CONTABIL_SINTETICO LACS ON LACS.UNCO_ID = C.LOCA_ID ");

		stringLancamentoContabil.append(" JOIN CATEGORIA CATG ON CATG.CATG_ID = LACS.CATG_ID ");

		StringBuilder stringLancamentoContabilSelect = new StringBuilder();

		stringLancamentoContabilSelect.append(" SUM(CASE CATG.CATG_ID WHEN 1 THEN LACS.LACS_VL ELSE 0 END) + ");
		stringLancamentoContabilSelect.append(" SUM(CASE CATG.CATG_ID WHEN 2 THEN LACS.LACS_VL ELSE 0 END) + ");
		stringLancamentoContabilSelect.append(" SUM(CASE CATG.CATG_ID WHEN 3 THEN LACS.LACS_VL ELSE 0 END) AS VALOR_PARTICULAR , ");
		stringLancamentoContabilSelect.append(" SUM(CASE CATG.CATG_ID WHEN 4 THEN LACS.LACS_VL ELSE 0 END) AS VALOR_PUBLICO ");

		String stringLancamentoContabilCriterioConsulta = " AND Trunc(LACS.LACS_DTCONTABIL, 'MONTH') = TO_DATE('01- "
						+ anoMesReferencia.toString().substring(4) + " - " + anoMesReferencia.toString().substring(0, 4)
						+ "', 'dd-mm-yyyy') ";

		sql.append(" INSERT INTO  TOT_LOCSFT ");
		sql.append(" ( ");

		sql.append(" SELECT C.LOCA_ID, C.CNTA_CDSETORCOMERCIAL, 'DEBITO' ,  ( select count( * ) from conta c2 where c2.loca_id = c.loca_id  and C.CNTA_CDSETORCOMERCIAL = C2.CNTA_CDSETORCOMERCIAL and C2.CNTA_AMREFERENCIACONTA =:REFERENCIA AND C2.DCST_IDATUAL <> 9 )  , SUM(C.CNTA_VLAGUA + C.CNTA_VLESGOTO + C.CNTA_VLDEBITOS )  ");
		sql.append(" , " + stringLancamentoContabilSelect.toString());

		sql.append("  FROM CONTA C ");
		sql.append(stringLancamentoContabil.toString());
		sql.append(" WHERE C.CNTA_AMREFERENCIACONTA =:REFERENCIA AND C.DCST_IDATUAL <> 9 " + stringLancamentoContabilCriterioConsulta
						+ "  GROUP BY C.LOCA_ID, C.CNTA_CDSETORCOMERCIAL, 'DEBITO'  ");

		sql.append(" ) ");

		sql.append("  UNION ");
		sql.append("  ( ");

		sql.append(" SELECT C.LOCA_ID, C.CNHI_CDSETORCOMERCIAL,'PAGNEG', ( select count( * ) from CONTA_HISTORICO c2 where c2.loca_id = c.loca_id  and C.CNHI_CDSETORCOMERCIAL = C2.CNHI_CDSETORCOMERCIAL and C2.CNHI_AMREFERENCIACONTA =:REFERENCIA AND C2.DCST_IDATUAL IN (0,1,2,4,5) )  , SUM(C.CNHI_VLAGUA + C.CNHI_VLESGOTO + C.CNHI_VLDEBITOS ) ");
		sql.append(" , " + stringLancamentoContabilSelect.toString());

		sql.append(" FROM CONTA_HISTORICO C  ");

		sql.append(stringLancamentoContabil.toString());

		sql.append(" WHERE C.CNHI_AMREFERENCIACONTA =:REFERENCIA AND C.DCST_IDATUAL IN (0,1,2,4,5) "
						+ stringLancamentoContabilCriterioConsulta + "GROUP BY C.LOCA_ID, C.CNHI_CDSETORCOMERCIAL, 'PAGNEG' ");

		sql.append("  ) ");

		sql.append(" ORDER BY 1,2 ");

		Session session = HibernateUtil.getSession();

		try{

			SQLQuery sqlQuery = session.createSQLQuery(sql.toString());
			sqlQuery.setParameter("REFERENCIA", anoMesReferencia);

			sqlQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	public void criarTabelaTemporariaRelatorioTotalContasEmitidasLocalidade() throws ErroRepositorioException{

		StringBuilder sql = new StringBuilder();
		Session session = HibernateUtil.getSession();
		SQLQuery sqlQuery = null;

		// Drop table
		try{
			sql.append(" DROP TABLE GSAN_ADMIN.TOT_LOCSFT ");
			sqlQuery = session.createSQLQuery(sql.toString());
			sqlQuery.executeUpdate();

		}catch(HibernateException e){
		}

		// Create table
		try{
			sql = new StringBuilder();
			sql.append(" CREATE TABLE GSAN_ADMIN.TOT_LOCSFT ");
			sql.append("	  (  ");
			sql.append("	    TOT_LOC                    NUMBER(*,0)  NOT NULL ENABLE, ");
			sql.append("	    TOT_SFT                    NUMBER(*,0)  NOT NULL ENABLE, ");
			sql.append("	   TOT_TIPO                   CHAR  (6)    NOT NULL ENABLE, ");
			sql.append("	    TOT_QTTOT                  NUMBER(*,0)  NOT NULL ENABLE, ");
			sql.append("	    TOT_VLTOT                  NUMBER(13,2) NOT NULL ENABLE , ");
			sql.append("	    TOT_VLTOTPARTICULAR           NUMBER(13,2) NOT NULL ENABLE,  ");
			sql.append("	    TOT_VLTOTPUBLICO           NUMBER(13,2) NOT NULL ENABLE ");

			sql.append("	  ) ");

			sqlQuery = session.createSQLQuery(sql.toString());

			sqlQuery.executeUpdate();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}

	public Long gerarQuantidadeRelatorioTotalContasEmitidasLocalidade(Integer anoMesReferencia) throws ErroRepositorioException{

		StringBuilder consulta = new StringBuilder();

		consulta.append(" SELECT count( * ) ");

		consulta.append(" FROM TOT_LOCSFT ");

		Session session = HibernateUtil.getSession();

		try{

			SQLQuery sqlQuery = session.createSQLQuery(consulta.toString());

			return ((BigDecimal) sqlQuery.setMaxResults(1).uniqueResult()).longValue();

		}catch(HibernateException e){
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			HibernateUtil.closeSession(session);
		}

	}
	/**
	 * @author Magno Silveira <magno.silveira@procenge.com.br>
	 * @since 16/04/2015
	 * @param idImovel
	 * @param paramMotivoRetificaoOcorrenciaConsumo
	 * @return
	 */
	public int obterQtdContasRetificadasPorMotivoRetificacao(Integer idImovel, Integer paramMotivoRetificaoOcorrenciaConsumo)
					throws ErroRepositorioException{

		Session session = HibernateUtil.getSession();

		String consulta = "";

		int retorno = 0;

		try{
			consulta = "select COUNT(*) from CONTA where IMOV_ID = :idImovel and CNTA_DTRETIFICACAO is not null and TO_CHAR(CNTA_DTRETIFICACAO, 'yyyy') = TO_CHAR(current_date, 'yyyy') and CMRT_ID = :paramMotivoRetificaoOcorrenciaConsumo";
			retorno = ((Number) session.createSQLQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("paramMotivoRetificaoOcorrenciaConsumo", paramMotivoRetificaoOcorrenciaConsumo).uniqueResult())
							.intValue();

			consulta = "select COUNT(*) from CONTA_HISTORICO where IMOV_ID = :idImovel and CNHI_DTRETIFICACAO is not null and TO_CHAR(CNHI_DTRETIFICACAO, 'yyyy') = TO_CHAR(current_date, 'yyyy') and CMRT_ID = :paramMotivoRetificaoOcorrenciaConsumo";
			retorno += ((Number) session.createSQLQuery(consulta.toString()).setInteger("idImovel", idImovel)
							.setInteger("paramMotivoRetificaoOcorrenciaConsumo", paramMotivoRetificaoOcorrenciaConsumo).uniqueResult())
							.intValue();

		}catch(HibernateException e){
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}finally{
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

}