/*  
 * Copyright (C) 2007-2007 the GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 *
 * This file is part of GSAN, an integrated service management system for Sanitation
 *
 * GSAN is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * GSAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place – Suite 330, Boston, MA 02111-1307, USA
 */

/*
 * GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 * Copyright (C) <2007> 
 * Adriano Britto Siqueira
 * Alexandre Santos Cabral
 * Ana Carolina Alves Breda
 * Ana Maria Andrade Cavalcante
 * Aryed Lins de Araújo
 * Bruno Leonardo Rodrigues Barros
 * Carlos Elmano Rodrigues Ferreira
 * Cláudio de Andrade Lira
 * Denys Guimarães Guenes Tavares
 * Eduardo Breckenfeld da Rosa Borges
 * Fabíola Gomes de Araújo
 * Flávio Leonardo Cavalcanti Cordeiro
 * Francisco do Nascimento Júnior
 * Homero Sampaio Cavalcanti
 * Ivan Sérgio da Silva Júnior
 * José Edmar de Siqueira
 * José Thiago Tenório Lopes
 * Kássia Regina Silvestre de Albuquerque
 * Leonardo Luiz Vieira da Silva
 * Márcio Roberto Batista da Silva
 * Maria de Fátima Sampaio Leite
 * Micaela Maria Coelho de Araújo
 * Nelson Mendonça de Carvalho
 * Newton Morais e Silva
 * Pedro Alexandre Santos da Silva Filho
 * Rafael Corrêa Lima e Silva
 * Rafael Francisco Pinto
 * Rafael Koury Monteiro
 * Rafael Palermo de Araújo
 * Raphael Veras Rossiter
 * Roberto Sobreira Barbalho
 * Rodrigo Avellar Silveira
 * Rosana Carvalho Barbosa
 * Sávio Luiz de Andrade Cavalcante
 * Tai Mu Shih
 * Thiago Augusto Souza do Nascimento
 * Tiago Moreno Rodrigues
 * Vivianne Barbosa Sousa
 *
 * Este programa é software livre; você pode redistribuí-lo e/ou
 * modificá-lo sob os termos de Licença Pública Geral GNU, conforme
 * publicada pela Free Software Foundation; versão 2 da
 * Licença.
 * Este programa é distribuído na expectativa de ser útil, mas SEM
 * QUALQUER GARANTIA; sem mesmo a garantia implícita de
 * COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM
 * PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais
 * detalhes.
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU
 * junto com este programa; se não, escreva para Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307, USA.
 * 
 * GSANPCG
 * Eduardo Henrique Bandeira Carneiro da Silva
 * Saulo Vasconcelos de Lima
 * Virginia Santos de Melo
 * Vitor Cavalcante Hora
 * 
 */

package gcom.faturamento;

import gcom.arrecadacao.*;
import gcom.arrecadacao.aviso.AvisoBancario;
import gcom.arrecadacao.bean.OperacaoContabilHelper;
import gcom.arrecadacao.debitoautomatico.*;
import gcom.arrecadacao.pagamento.*;
import gcom.atendimentopublico.ControladorAtendimentoPublicoLocal;
import gcom.atendimentopublico.ControladorAtendimentoPublicoLocalHome;
import gcom.atendimentopublico.ligacaoagua.*;
import gcom.atendimentopublico.ligacaoesgoto.*;
import gcom.atendimentopublico.ordemservico.FiltroOrdemServico;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.atendimentopublico.ordemservico.ServicoTipo;
import gcom.atendimentopublico.registroatendimento.*;
import gcom.atendimentopublico.registroatendimento.bean.ObterIndicadorExistenciaHidrometroHelper;
import gcom.batch.*;
import gcom.batch.micromedicao.RelatorioResumoLeituraFaturamentoImediato;
import gcom.batch.micromedicao.RelatorioResumoOcorrenciasFaturamentoImediato;
import gcom.cadastro.ControladorCadastroLocal;
import gcom.cadastro.ControladorCadastroLocalHome;
import gcom.cadastro.EnvioEmail;
import gcom.cadastro.aguaparatodos.FaturamentoHistoricoAguaParaTodos;
import gcom.cadastro.aguaparatodos.FiltroImovelAguaParaTodos;
import gcom.cadastro.aguaparatodos.ImovelAguaParaTodos;
import gcom.cadastro.cliente.*;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.endereco.ControladorEnderecoLocal;
import gcom.cadastro.endereco.ControladorEnderecoLocalHome;
import gcom.cadastro.imovel.*;
import gcom.cadastro.imovel.bean.EmitirConsumoImovelCondominimoHelper;
import gcom.cadastro.imovel.bean.ImovelCobrarDoacaoHelper;
import gcom.cadastro.imovel.bean.ImovelMicromedicao;
import gcom.cadastro.localidade.*;
import gcom.cadastro.sistemaparametro.FiltroSistemaParametro;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cadastro.tarifasocial.ControladorTarifaSocialLocal;
import gcom.cadastro.tarifasocial.ControladorTarifaSocialLocalHome;
import gcom.cobranca.*;
import gcom.cobranca.ajustetarifa.AjusteTarifa;
import gcom.cobranca.ajustetarifa.FiltroAjusteTarifa;
import gcom.cobranca.bean.*;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.cobranca.parcelamento.ParcelamentoPerfil;
import gcom.contabil.*;
import gcom.fachada.Fachada;
import gcom.faturamento.bean.*;
import gcom.faturamento.consumotarifa.*;
import gcom.faturamento.conta.*;
import gcom.faturamento.credito.*;
import gcom.faturamento.debito.*;
import gcom.faturamento.faturamentosimulacaocomando.FaturamentoSimulacaoComando;
import gcom.faturamento.faturamentosimulacaocomando.FiltroFaturamentoSimulacaoComando;
import gcom.faturamento.histograma.ControladorHistogramaLocal;
import gcom.faturamento.histograma.ControladorHistogramaLocalHome;
import gcom.faturamento.histograma.IRepositorioHistograma;
import gcom.faturamento.histograma.RepositorioHistogramaHBM;
import gcom.financeiro.ControladorFinanceiroLocal;
import gcom.financeiro.ControladorFinanceiroLocalHome;
import gcom.financeiro.FinanciamentoTipo;
import gcom.financeiro.ResumoFaturamento;
import gcom.financeiro.lancamento.LancamentoItem;
import gcom.financeiro.lancamento.LancamentoItemContabil;
import gcom.financeiro.lancamento.LancamentoTipo;
import gcom.gui.ActionServletException;
import gcom.gui.GcomAction;
import gcom.gui.faturamento.bean.GuiaPagamentoPrestacaoHelper;
import gcom.gui.faturamento.bean.ListaDadosPrestacaoGuiaHelper;
import gcom.gui.faturamento.bean.ManterContaHelper;
import gcom.gui.faturamento.consumotarifa.bean.CategoriaFaixaConsumoTarifaHelper;
import gcom.interceptor.ObjetoTransacao;
import gcom.interceptor.RegistradorOperacao;
import gcom.micromedicao.*;
import gcom.micromedicao.bean.GerarDadosParaLeituraHelper;
import gcom.micromedicao.bean.RelatorioResumoLeituraFaturamentoImediatoHelper;
import gcom.micromedicao.consumo.*;
import gcom.micromedicao.hidrometro.FiltroHidrometro;
import gcom.micromedicao.hidrometro.FiltroHidrometroInstalacaoHistorico;
import gcom.micromedicao.hidrometro.Hidrometro;
import gcom.micromedicao.hidrometro.HidrometroInstalacaoHistorico;
import gcom.micromedicao.leitura.LeituraAnormalidade;
import gcom.micromedicao.leitura.LeituraAnormalidadeConsumo;
import gcom.micromedicao.leitura.LeituraSituacao;
import gcom.micromedicao.medicao.*;
import gcom.relatorio.GerenciadorExecucaoTarefaRelatorio;
import gcom.relatorio.RelatorioBean;
import gcom.relatorio.faturamento.*;
import gcom.relatorio.faturamento.conta.*;
import gcom.relatorio.micromedicao.RelatorioGerarDadosParaleitura;
import gcom.relatorio.micromedicao.RelatorioResumoOcorrenciasFaturamentoImediatoHelper;
import gcom.relatorio.ordemservico.DadosContaEmRevisaoHelper;
import gcom.seguranca.ControladorPermissaoEspecialLocal;
import gcom.seguranca.ControladorPermissaoEspecialLocalHome;
import gcom.seguranca.acesso.*;
import gcom.seguranca.acesso.usuario.FiltroUsuario;
import gcom.seguranca.acesso.usuario.Usuario;
import gcom.seguranca.acesso.usuario.UsuarioAcao;
import gcom.seguranca.acesso.usuario.UsuarioAcaoUsuarioHelper;
import gcom.seguranca.transacao.ControladorTransacaoLocal;
import gcom.seguranca.transacao.ControladorTransacaoLocalHome;
import gcom.spcserasa.ControladorSpcSerasaLocal;
import gcom.spcserasa.ControladorSpcSerasaLocalHome;
import gcom.tarefa.TarefaRelatorio;
import gcom.util.*;
import gcom.util.email.ErroEmailException;
import gcom.util.email.ServicosEmail;
import gcom.util.filtro.*;
import gcom.util.parametrizacao.ExecutorParametro;
import gcom.util.parametrizacao.Parametrizacao;
import gcom.util.parametrizacao.ParametroContabil;
import gcom.util.parametrizacao.ParametroGeral;
import gcom.util.parametrizacao.arrecadacao.ParametroArrecadacao;
import gcom.util.parametrizacao.atendimentopublico.ParametroAtendimentoPublico;
import gcom.util.parametrizacao.cadastro.ParametroCadastro;
import gcom.util.parametrizacao.cobranca.ParametroCobranca;
import gcom.util.parametrizacao.cobranca.parcelamento.ParametroParcelamento;
import gcom.util.parametrizacao.faturamento.ExecutorParametrosFaturamento;
import gcom.util.parametrizacao.faturamento.FormaCalculoConsumoExcedenteEconomia;
import gcom.util.parametrizacao.faturamento.ParametroFaturamento;
import gcom.util.parametrizacao.micromedicao.ParametroMicromedicao;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.zip.ZipOutputStream;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;

import org.apache.commons.beanutils.BeanComparator;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.collections.comparators.ComparatorChain;
import org.apache.commons.collections.keyvalue.MultiKey;
import org.apache.commons.collections.map.LinkedMap;
import org.apache.commons.collections.map.MultiKeyMap;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.apache.poi.ss.formula.functions.T;
import org.hibernate.collection.PersistentSet;

import br.com.danhil.BarCode.Interleaved2of5;
import br.com.procenge.comum.exception.NegocioException;
import br.com.procenge.parametrosistema.api.ControladorParametroSistema;
import br.com.procenge.util.SpringBeanLocator;

/**
 * Controlador Faturamento PADRÃO
 * 
 * @author Raphael Rossiter
 * @date 20/12/2006
 */
public class ControladorFaturamento
				implements SessionBean, Parametrizacao {

	private static final long serialVersionUID = 1L;

	SessionContext sessionContext;

	protected IRepositorioFaturamento repositorioFaturamento;

	protected IRepositorioCobranca repositorioCobranca;

	protected IRepositorioMicromedicao repositorioMicromedicao;

	protected IRepositorioUtil repositorioUtil;

	protected IRepositorioArrecadacao repositorioArrecadacao;

	protected IRepositorioLocalidade repositorioLocalidade;

	protected IRepositorioClienteImovel repositorioClienteImovel;

	protected IRepositorioHistograma repositorioHistograma;

	protected IRepositorioContabil repositorioContabil;

	private static Logger log = Logger.getLogger(ControladorFaturamento.class);
	

	/**
	 * [UC00084] Gerar Faturamento Imediato
	 * 
	 * @author Yara Souza
	 * @date 17/08/2011
	 * @throws ControladorException
	 */
	public void gerarFaturamentoImediato(Collection colecaoRotas, Integer anoMesReferencia, Integer idGrupoFaturamentoRota,
					FuncionalidadeIniciada funcionalidade, Collection collLeituraTipo) throws ControladorException{

		int idUnidadeIniciada = 0;
		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(funcionalidade.getId(),
						UnidadeProcessamento.FUNCIONALIDADE, 0);

		log.info("**********Início Gerar Faturamento Imediato do Grupo/Referência: " + idGrupoFaturamentoRota.toString() + "/"
						+ anoMesReferencia.toString());

		try{

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// O sistema exclui os dados de resumo faturamento simulação
			repositorioFaturamento.deletarResumoFaturamentoSimulacaoPorColecaoRotas(idGrupoFaturamentoRota, anoMesReferencia,
							this.obterColecaoIdsRotas(colecaoRotas));

			// Caso o mês de faturamento corresponda ao mês de novembro (11), o sistema exclui os
			// dados do resumo de resumo fatramento simulação do mês seguinte.
			boolean indicadorFaturamentoAntecipado = false;

			if(Util.obterMes(anoMesReferencia) == 11 && sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){

				repositorioFaturamento.deletarResumoFaturamentoSimulacaoPorColecaoRotas(idGrupoFaturamentoRota, anoMesReferencia + 1,
								this.obterColecaoIdsRotas(colecaoRotas));
				indicadorFaturamentoAntecipado = true;
			}

			Collection<FaturamentoAtividadeCriterio> colecaoFaturamentoAtividadeCriterio = this.getControladorMicromedicao()
							.pesquisarFaturamentoAtividadeCriterioPorLeituraTipo(FaturamentoAtividade.GERAR_ARQUIVO_LEITURA,
											collLeituraTipo);

			Collection<Imovel> colecaoImoveisGerarMovimentoRoteiroEmpresa = new ArrayList<Imovel>();
			Collection<Imovel> colecaoImoveisGerarPreFaturamento = new ArrayList<Imovel>();
			Collection colecaoImoveisPorRota = new ArrayList();
			Collection colecaoRelatorioResumoFaturamentoHelper = new ArrayList();
			Collection colecaoListaConsumidoresHelper = new ArrayList();

			FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) getControladorUtil().pesquisar(idGrupoFaturamentoRota,
							FaturamentoGrupo.class, false);

			ResumoFaturamentoImediatoRelatorioHelper relatorioResumoFaturamentoHelper;

			if(colecaoFaturamentoAtividadeCriterio != null && !colecaoFaturamentoAtividadeCriterio.isEmpty()){

				Integer quantidadeImoveisFaturados = 0;
				Integer quantidadeImoveisFaturadosMedidos = 0;
				Integer quantidadeImoveisFaturadosNaoMedidos = 0;
				Imovel imovel = null;
				Iterator it = colecaoRotas.iterator();
				Short indicadorImovelFaturamentoImediato = ConstantesSistema.NAO;

				while(it.hasNext()){

					Rota rota = (Rota) it.next();
					log.info("**********Gerando Dados do Faturamento Imediato da Rota: " + rota.getId().toString());

					quantidadeImoveisFaturados = 0;
					quantidadeImoveisFaturadosMedidos = 0;
					quantidadeImoveisFaturadosNaoMedidos = 0;
					relatorioResumoFaturamentoHelper = new ResumoFaturamentoImediatoRelatorioHelper();
					relatorioResumoFaturamentoHelper.setIdRota(rota.getId());

					colecaoImoveisPorRota = repositorioMicromedicao.pesquisarImoveisParaFaturamento(rota, anoMesReferencia, null);
					relatorioResumoFaturamentoHelper.setQuantidadeImoveisPorRota(colecaoImoveisPorRota.size());

					if(!Util.isVazioOrNulo(colecaoImoveisPorRota)){

						Iterator iteratorColecaoImoveis = colecaoImoveisPorRota.iterator();
						while(iteratorColecaoImoveis.hasNext()){

							Object[] arrayImovel = (Object[]) iteratorColecaoImoveis.next();
							imovel = this.getControladorMicromedicao().obterImovelParaFaturamento(arrayImovel);
							imovel.getRota().setFaturamentoGrupo(faturamentoGrupo);
							
							/*
							 * Caso P_ATUALIZACAO_CADASTRAL_LEITURA = 1 (SIM) , habilita a
							 * atualização
							 * cadastral permitindo a alteração da Categoria e da Subcategoria do
							 * imóvel
							 * pelas empresas de leittura, sendo essa alteração vigente apenas a
							 * partir
							 * da ida do faturamento do mês seguinte ao processamento do retorno.
							 */

							String pAtualizacaoCadastral = (String) ParametroFaturamento.P_ATUALIZACAO_CADASTRAL_LEITURA.executar();

							if(pAtualizacaoCadastral.equals(ConstantesSistema.SIM.toString())){

								this.atualizarImovelAlteracaoCadastral(imovel, anoMesReferencia);

							}
							
							// [FS0001 - Verificar seleção de imóveis]
							indicadorImovelFaturamentoImediato = this.selecionarImovelParaFaturamentoImediato(imovel, anoMesReferencia,
											sistemaParametro, colecaoFaturamentoAtividadeCriterio,
											Funcionalidade.GERAR_FATURAMENTO_IMEDIATO);

							if(indicadorImovelFaturamentoImediato.equals(ConstantesSistema.SIM)){

								// Verifica se imóvel é medido ou não medido
								if(verificarImovelNaoMedido(imovel)){

									quantidadeImoveisFaturadosNaoMedidos = quantidadeImoveisFaturadosNaoMedidos.intValue() + 1;
								}else{

									quantidadeImoveisFaturadosMedidos = quantidadeImoveisFaturadosMedidos.intValue() + 1;
								}

								quantidadeImoveisFaturados = quantidadeImoveisFaturados.intValue() + 1;

								// Verifica a exclusão do imóvel do imóvel do programa água para
								// todos
								if(this.verificarExclusaoImoveldoProgramaAguaParaTodos(imovel, sistemaParametro)){

									// [SB0011] - Verificar Exclusão do Programa Água para Todos
									this.excluirImoveldoProgramaAguaParaTodos(imovel, sistemaParametro);
								}

								// Caso seja para verificar permanência do imóvel na tarifa social
								String parametroValidaPermanenciaTarifaSocial = ParametroCadastro.P_VALIDA_PERMANENCIA_TARIFA_SOCIAL
												.executar();

								if(!Util.isVazioOuBranco(parametroValidaPermanenciaTarifaSocial)){

									// [UC3058 – Verificar Permanência Tarifa Social].
									this.getControladorTarifaSocial().verificarPermanenciaTarifaSocial(imovel.getId(),
													Usuario.USUARIO_BATCH);
								}

								// Caso o imóvel tenha sido selecionado para fiscalização de
								// leitura. [UC0099 - selecionar Fiscalização de Leitura]
								if(this.verificarImovelSituacaoFiscalizacaoLeituraFaturamentoImediato(imovel, sistemaParametro)
												&& getControladorMicromedicao().selecionarFiscalizacaoLeitura(imovel, sistemaParametro)){

									// Apenas gera movimento roteiro empresa e não gerar conta pois
									// está em fiscalização
									colecaoImoveisGerarMovimentoRoteiroEmpresa.add(imovel);

								}else{

									// Caso contrário, gerar conta e movimento roteiro empresa
									colecaoImoveisGerarPreFaturamento.add(imovel);
									colecaoImoveisGerarMovimentoRoteiroEmpresa.add(imovel);

								}

								// <<Inclui>> [UC0083] - GerarDadosParaLeitura – [SB0007] – Gera
								// Relação Lista de Consumidores
								String parametroGeraRelacaoUsuariosParaLeitura = ParametroFaturamento.P_GERA_RELACAO_USUARIOS_PARA_LEITURA
												.executar();
								if(parametroGeraRelacaoUsuariosParaLeitura != null
												&& parametroGeraRelacaoUsuariosParaLeitura.compareTo(ConstantesSistema.SIM.toString()) == 0){
									GerarDadosParaLeituraHelper helper = this.getControladorMicromedicao()
													.montarGerarDadosParaLeituraHelper(imovel, anoMesReferencia, sistemaParametro);
									colecaoListaConsumidoresHelper.add(helper);

								}

							}else{

								// [SB0014 – Verificar Não Seleção do Imóvel para Faturamento
								// Imediato]
								String[] idsDebitoACobrar = repositorioFaturamento.pesquisarDebitoACobrarPorDebitoTipo(imovel.getId(),
												DebitoTipo.DESPESA_POSTAL, anoMesReferencia);

								if(idsDebitoACobrar != null){

									// <<Inclui>> [UC0184 -Manter Débito A Cobrar]
									this.cancelarDebitoACobrar(idsDebitoACobrar, Usuario.USUARIO_BATCH, imovel.getId(), Boolean.FALSE);
								}
							}
						}

						relatorioResumoFaturamentoHelper.setQuantidadeImoveisFaturados(quantidadeImoveisFaturados);
						relatorioResumoFaturamentoHelper.setQuantidadeImoveisFaturadosMedidos(quantidadeImoveisFaturadosMedidos);
						relatorioResumoFaturamentoHelper.setQuantidadeImoveisFaturadosNaoMedidos(quantidadeImoveisFaturadosNaoMedidos);
						log.info("**********Quantidade de imóveis faturados: " + quantidadeImoveisFaturados.toString());
						log.info("**********Quantidade de imóveis faturados medidos: " + quantidadeImoveisFaturadosMedidos.toString());
						log.info("**********Quantidade de imóveis faturados não medidos: "
										+ quantidadeImoveisFaturadosNaoMedidos.toString());
						colecaoRelatorioResumoFaturamentoHelper.add(relatorioResumoFaturamentoHelper);
					}
				}

				if(!colecaoImoveisGerarPreFaturamento.isEmpty()){

					Collection<Imovel> colecaoOcorrenciaGeracaoPreFaturamento = new ArrayList<Imovel>();

					// [SB0001 - Gerar Dados do Pré-Faturamento ]
					this.gerarDadosPreFaturamento(colecaoImoveisGerarPreFaturamento, faturamentoGrupo, anoMesReferencia, sistemaParametro,
									indicadorFaturamentoAntecipado, colecaoOcorrenciaGeracaoPreFaturamento);

					// Data de Vencimento
					FaturamentoAtivCronRota atividadeCronogramaRota = this.obterFaturamentoAtividadeCronogramaPorGrupoFaturamentoRota(
									FaturamentoAtividade.GERAR_ARQUIVO_LEITURA, anoMesReferencia, faturamentoGrupo,
									((Rota) Util.retonarObjetoDeColecao(colecaoRotas)));

					Date dataVencimento = null;

					if(atividadeCronogramaRota != null){

						dataVencimento = atividadeCronogramaRota.getDataContaVencimento();
					}

					// Relatório de Ocorrência da Geração do Pré-Faturamento
					this.iniciarProcessamentoRelatorioOcorrenciaGeracaoPreFaturamento(faturamentoGrupo, anoMesReferencia,
									colecaoOcorrenciaGeracaoPreFaturamento, funcionalidade.getId(), dataVencimento);

				}

				if(!colecaoImoveisGerarMovimentoRoteiroEmpresa.isEmpty()){

					// [SB0007 - Gerar Movimento Roteiro Empresa]
					this.gerarMovimentoRoteiroEmpresaImoveisPreFaturamento(colecaoImoveisGerarMovimentoRoteiroEmpresa, faturamentoGrupo,
									sistemaParametro, anoMesReferencia);

				}

				// [SB0012 - Gerar Resumo do Faturamento Imediato]
				this.gerarResumoFaturamentoImediato(colecaoRelatorioResumoFaturamentoHelper, faturamentoGrupo.getId(), anoMesReferencia);

				/*
				 * Gerar Relação de Usuários para Leitura, chamar o SB0007 do UC0083.Ver Subfluxo
				 * SB0001 – item: 10. Gera a relação de usuários para leitura PDF.
				 * <<Inclui>> [UC0083] - GerarDadosParaLeitura – [SB0007] – Gera Relação Lista de
				 * Consumidores
				 */
				if(colecaoListaConsumidoresHelper != null && !colecaoListaConsumidoresHelper.isEmpty()){
					this.gerarRelacaoListaConsumidores(colecaoListaConsumidoresHelper);
				}

			}else{

				// [FS0002 - Verificar existência de critérios de seleção de imóveis]
				throw new ControladorException("erro.criterios_imoveis_nao_encontrados");
			}

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

			log.info("**********Fim Gerar Faturamento Imediato do Grupo/Referência: " + idGrupoFaturamentoRota.toString() + "/"
							+ anoMesReferencia.toString());
		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * [UC00084] Gerar Faturamento Imediato
	 * [SB0008 - Atualizar Imóvel Alteração Cadastral
	 */
	public void atualizarImovelAlteracaoCadastral(Imovel imovel, Integer anoMesReferencia) throws ControladorException{

		// Verificar se houve alteração cadastral no retorno do faturamento anterior para a
		// matrícula.

		Integer anoMesReferenciaMesAnterior = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesReferencia, 1);

		MovimentoRoteiroEmpresa mre = this.getControladorMicromedicao().obterMovimentoRoteiroPorImovel(imovel, anoMesReferenciaMesAnterior);

		if(mre != null && mre.getIdCategoriaAtualizacaoCadastral() != null && mre.getIdSubCategoriaAtualizacaoCadastral() != null){

			Collection colecao = this.getControladorImovel().pesquisarImovelSubcategorias(imovel.getId());

			// Atenção!! Só serão atualizados os imóveis que possuem apenas 1 categoria.
			if(colecao.size() == 1){

				Short quantidadeEconomia = null;

				ImovelSubcategoria imovelSubCategoriaAnterior = (ImovelSubcategoria) Util.retonarObjetoDeColecao(colecao);

				quantidadeEconomia = imovelSubCategoriaAnterior.getQuantidadeEconomias();

				// Remove a anterior
				this.getControladorUtil().remover(imovelSubCategoriaAnterior);

				FiltroCategoria filtroCategoria = new FiltroCategoria();


				// id da categoria
				filtroCategoria.adicionarParametro(new ParametroSimples(FiltroCategoria.CODIGO, mre.getIdCategoriaAtualizacaoCadastral()));

				Collection categoriasSelecionadas = this.getControladorUtil().pesquisar(filtroCategoria, Categoria.class.getName());

				Categoria categoria = (Categoria) categoriasSelecionadas.iterator().next();

				if(categoria != null){

					FiltroSubCategoria filtroSubCategoria = new FiltroSubCategoria();
					// código da subCategoria
					filtroSubCategoria.adicionarParametro(new ParametroSimples(FiltroSubCategoria.CODIGO, mre
									.getIdSubCategoriaAtualizacaoCadastral()));

					filtroSubCategoria.adicionarParametro(new ParametroSimples(FiltroSubCategoria.CATEGORIA_ID, categoria.getId()));

					Collection collSubCategorias = this.getControladorUtil().pesquisar(filtroSubCategoria, Subcategoria.class.getName());

					// Cria objeto SubCategoria
					Subcategoria subCategoria = (Subcategoria) collSubCategorias.iterator().next();

					ImovelSubcategoriaPK imovelSubcategoriaPK = new ImovelSubcategoriaPK(null, subCategoria);

					imovelSubcategoriaPK.setImovel(imovel);

					// Cria objeto ImovelSubCategoria
					ImovelSubcategoria imovelSubCategoriaNova = new ImovelSubcategoria(imovelSubcategoriaPK, quantidadeEconomia, new Date());

					imovelSubCategoriaNova.setCategoria(categoria);


					// Insere a nova, mantendo a quantidade de quantidadeEconomia da anterior.
					this.getControladorUtil().inserir(imovelSubCategoriaNova);

					FiltroImovel filtroImovel = new FiltroImovel();
					filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
					filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOCALIDADE);
					filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.QUADRA);
					filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.ROTA);
					filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.SETOR_COMERCIAL);
					filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.ROTA_FATURAMENTO_GRUPO);
					Collection colecaoImovel = (Collection) this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
					Imovel imovelAtualizar = (Imovel) Util.retonarObjetoDeColecao(colecaoImovel);

					// Atualiza o imóvel
					imovelAtualizar.setIndicadorAtualizacaoCadastral(ConstantesSistema.SIM);
					imovelAtualizar.setDataAtualizacaoCadastral(new Date());

					this.getControladorUtil().atualizar(imovelAtualizar);

				}


			}
		}

	}

	/*
	 * @param idImovel
	 * @param anoMesFaturamento
	 * @return
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */

	private String obterUltimosDozeMesesAnterioresReferenciaComContaVencida(Integer idImovel, Integer anoMesFaturamento)
					throws ControladorException, ErroRepositorioException{

		String retorno = "";

		String[] arrayRetorno = new String[12];
		arrayRetorno[0] = "J";
		arrayRetorno[1] = "F";
		arrayRetorno[2] = "M";
		arrayRetorno[3] = "A";
		arrayRetorno[4] = "M";
		arrayRetorno[5] = "J";
		arrayRetorno[6] = "J";
		arrayRetorno[7] = "A";
		arrayRetorno[8] = "S";
		arrayRetorno[9] = "O";
		arrayRetorno[10] = "N";
		arrayRetorno[11] = "D";

		Integer anoFaturamento = Util.converterStringParaInteger(anoMesFaturamento.toString().substring(0, 4));

		Collection colecaoMeses = repositorioFaturamento.obterUltimosDozeMesesAnterioresReferenciaComContaVencida(idImovel, anoFaturamento);

		if(colecaoMeses != null){

			String mesAtual;
			Iterator itMeses = colecaoMeses.iterator();

			while(itMeses.hasNext()){
				mesAtual = (String) itMeses.next();

				if(mesAtual.equals("01") || mesAtual.equals("1")){

					arrayRetorno[0] = "X";
				}

				if(mesAtual.equals("02") || mesAtual.equals("2")){

					arrayRetorno[1] = "X";
				}

				if(mesAtual.equals("03") || mesAtual.equals("3")){

					arrayRetorno[2] = "X";
				}

				if(mesAtual.equals("04") || mesAtual.equals("4")){

					arrayRetorno[3] = "X";

				}

				if(mesAtual.equals("05") || mesAtual.equals("5")){

					arrayRetorno[4] = "X";

				}

				if(mesAtual.equals("06") || mesAtual.equals("6")){

					arrayRetorno[5] = "X";
				}

				if(mesAtual.equals("07") || mesAtual.equals("7")){

					arrayRetorno[6] = "X";

				}

				if(mesAtual.equals("08") || mesAtual.equals("8")){

					arrayRetorno[7] = "X";

				}

				if(mesAtual.equals("09") || mesAtual.equals("9")){

					arrayRetorno[8] = "X";

				}

				if(mesAtual.equals("10")){

					arrayRetorno[9] = "X";

				}

				if(mesAtual.equals("11")){

					arrayRetorno[10] = "X";

				}

				if(mesAtual.equals("12")){

					arrayRetorno[11] = "X";
				}

			}

		}

		for(int i = 0; i < arrayRetorno.length; i++){
			retorno = retorno + arrayRetorno[i];
		}

		System.out.println(retorno);

		return retorno;
	}
	
	/**
	 * @author Yara Souza
	 * @date 30/08/2011
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @param consumoFaturado
	 * @param quantTotalEconomia
	 * @return
	 * @throws ControladorException
	 */
	private Object[] ajustarConsumoProjetado(Date dataLeituraAnterior, Date dataLeituraAtual, Integer consumoFaturado,
					Integer quantTotalEconomia) throws ControladorException{

		Object[] retorno = new Object[3];

		// 1.4
		Integer consumoProjetado = consumoFaturado;
		Integer consumoProjetadoExcedente = 0;
		Integer consumoProjetadoExcedentePorEconomia = 0;

		if(dataLeituraAnterior != null && dataLeituraAtual != null){
			// Obtém a quantidade de dias de consumo.
			// Diferença entre a data de leitura atual e a data de leitura anterior.
			// Ajustar data
			int quantidadeDiasConsumo = (int) Util.obterDiferencaDias(dataLeituraAnterior, dataLeituraAtual);

			// int quantidadeDiasConsumo = (int) IoUtil.diferencaEntreDatas(dataLeituraAnterior,
			// dataLeituraAtual);

			String pQuantidadeDiasProjecaoCosnumo = null;

			try{

				pQuantidadeDiasProjecaoCosnumo = (String) ParametroFaturamento.P_QUANTIDADE_DIAS_PROJECAO_CONSUMO.executar(this);
			}catch(ControladorException e){

				throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_QUANTIDADE_DIAS_PROJECAO_CONSUMO");
			}

			// Caso a quantidadeDiasConsumo for maior que o número de dias para projeção
			// parametrizado
			if(quantidadeDiasConsumo > Util.obterInteger(pQuantidadeDiasProjecaoCosnumo).intValue()){

				// Diferença de dias para projeção = Data atual de leitura – data anterior de
				// leitura;
				// Consumo projetado = consumo faturado * 30 / Diferença de dias para projeção;
				String parametroFormaCalculoConsumoExcedenteEconomia = ParametroFaturamento.P_FORMA_CALCULO_CONSUMO_EXCEDENTE_ECONOMIA
								.executar();
				if(parametroFormaCalculoConsumoExcedenteEconomia.equals(FormaCalculoConsumoExcedenteEconomia.DOIS.getValor())){
					consumoProjetado = Util.divideDepoisMultiplica(consumoFaturado.intValue(), quantidadeDiasConsumo, 30, Boolean.FALSE);
				}else{
					consumoProjetado = Util.divideDepoisMultiplica(consumoFaturado.intValue(), quantidadeDiasConsumo, 30, Boolean.TRUE);
				}

				// Excedente de consumo projetado = consumo faturado - Consumo projetado;
				consumoProjetadoExcedente = consumoFaturado.intValue() - consumoProjetado;

				// 1.6
				if(quantTotalEconomia != 0){
					consumoProjetadoExcedentePorEconomia = consumoProjetadoExcedente / quantTotalEconomia;
				}
			}
		}
		retorno[0] = consumoProjetado;
		retorno[1] = consumoProjetadoExcedente;
		retorno[2] = consumoProjetadoExcedentePorEconomia;

		return retorno;

	}

	private QuitacaoDebitoAnual gerarQuitacaoDebitoAnual(Imovel imovel, FaturamentoGrupo faturamentoGrupo,
					Integer anoBaseDeclaracaoQuitacaoDebitoAnual){

		QuitacaoDebitoAnual quitacaoDebitoAnual = null;

		// *********************************************************
		// Inclui o registro na tabela de quitação de débito anual
		try{

			// Inclui na tabela QUITACAO_DEBITO_ANUAL os seguintes valores:
			quitacaoDebitoAnual = new QuitacaoDebitoAnual();

			// IMOV_ID >> IMOV_ID da tabela IMOVEL
			quitacaoDebitoAnual.setImovel(imovel);

			// Cliente responsável
			Cliente clienteResponsavel = this.getControladorImovel().pesquisarClienteResponsavelImovel(imovel.getId());
			quitacaoDebitoAnual.setClienteResponsavel(clienteResponsavel);

			// Cliente usuário
			Cliente clienteUsuario = this.getControladorImovel().pesquisarClienteUsuarioImovel(imovel.getId());
			quitacaoDebitoAnual.setClienteUsuario(clienteUsuario);

			// QADB_AAREFERENCIA >> ano de referência
			quitacaoDebitoAnual.setAnoReferencia(anoBaseDeclaracaoQuitacaoDebitoAnual);
			// QADB_ICIMPRESSAO >> 2 (não)
			quitacaoDebitoAnual.setIndicadorImpressao(ConstantesSistema.NAO);
			// FTGR_ID >> Grupo de Faturamento
			quitacaoDebitoAnual.setFaturamentoGrupo(faturamentoGrupo);
			// QADB_AMREFERENCIAGERACAO >> ano mês de referência de faturamento grupo
			quitacaoDebitoAnual.setAnoReferenciaGeracao(faturamentoGrupo.getAnoMesReferencia());

			// QADI_TMULTIMAALTERACAO >> data e hora correntes
			quitacaoDebitoAnual.setUltimaAlteracao(new Date());

			this.getControladorUtil().inserir(quitacaoDebitoAnual);

		}catch(ControladorException e){
			// TODO Auto-generated catch block
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();

			throw new EJBException(e);
		}
		// *********************************************************

		return quitacaoDebitoAnual;
	}

	/**
	 * @param imovel
	 * @param quitacaoDebitoAnual
	 * @param anoBaseDeclaracaoQuitacaoDebitoAnual
	 */
	private void gerarQuitacaoDebitoAnualItem(Imovel imovel, QuitacaoDebitoAnual quitacaoDebitoAnual,
					Integer anoBaseDeclaracaoQuitacaoDebitoAnual){

		// Obter Último dia do ano, conforme ano base informado.
		Date dataFinal = Util.gerarDataFinalDoAnoApartirDoAnoRefencia(anoBaseDeclaracaoQuitacaoDebitoAnual);

		Integer referenciaFinal = Util.recuperaAnoMesDaData(dataFinal);

		// O sistema seleciona as contas quitadas no ano de referência
		Collection<ContaHistorico> colecaoContaHistorico;
		try{
			colecaoContaHistorico = repositorioFaturamento.pesquisaContasQuitadasAnoReferencia(imovel.getId(), referenciaFinal, dataFinal);

			if(!Util.isVazioOrNulo(colecaoContaHistorico)){

				for(ContaHistorico contaHistorico : colecaoContaHistorico){
					// Inclui na tabela QUITACAO_DEBITO_ANUAL_ITEM os seguintes
					// valores:
					QuitacaoDebitoAnualItem quitacaoDebitoAnualItem = new QuitacaoDebitoAnualItem();

					// QADB_ID >> QADB_ID da tabela QUITACAO_DEBITO_ANUAL
					quitacaoDebitoAnualItem.setQuitacaoDebitoAnual(quitacaoDebitoAnual);

					// DOTP_ID >> DOTP_ID da tabela DOCUMENTO_TIPO com
					// DOTP_DSDOCUMENTOTIPO com o valor correspondente à "CONTA"
					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.CONTA);

					quitacaoDebitoAnualItem.setDocumentoTipo(documentoTipo);

					// QADI_AMREFERENCIAITEM >> CNHI_AMREFERENCIACONTA da tabela
					// CONTA_HISTORICO
					quitacaoDebitoAnualItem.setAnoReferenciaItem(contaHistorico.getAnoMesReferenciaConta());

					// CNTA_ID >> CNTA_ID da tabela CONTA_HISTORICO
					ContaGeral contaGeral = new ContaGeral();
					contaGeral.setId(contaHistorico.getId());

					quitacaoDebitoAnualItem.setContaGeral(contaGeral);

					// DCST_ID >> DCST_IDATUAL da tabela CONTA_HISTORICO
					quitacaoDebitoAnualItem.setDebitoCreditoSituacao(contaHistorico.getDebitoCreditoSituacaoAtual());

					// QADI_VLITEM >> CNHI_VLAGUA + CNHI_VLESGOTO +
					// CNHI_VLDEBITOS - CNHI_VLCREDITOS - CNHI_VLIMPOSTOS
					quitacaoDebitoAnualItem.setValorItem(contaHistorico.getValorTotal());

					// QADI_DTPAGAMENTO >> PGHI_DTPAGAMENTO da tabela
					// PAGAMENTO_HISTORICO
					Date dataPagamento = null;

					Collection<PagamentoHistorico> colecaoPagamentoHistorico = this.getControladorArrecadacao()
									.selecionarPagamentoHistoricoPorContaHistorico(contaHistorico.getId());

					if(!Util.isVazioOrNulo(colecaoPagamentoHistorico)){
						PagamentoHistorico pagamentoHistorico = (PagamentoHistorico) Util.retonarObjetoDeColecao(colecaoPagamentoHistorico);

						dataPagamento = pagamentoHistorico.getDataPagamento();
					}

					quitacaoDebitoAnualItem.setDataPagamento(dataPagamento);

					// QADI_TMULTIMAALTERACAO >> data e hora correntes
					quitacaoDebitoAnualItem.setUltimaAlteracao(new Date());

					// **************************************************************
					// Inclui o registro na tabela de quitação de débito anual
					// item
					this.getControladorUtil().inserir(quitacaoDebitoAnualItem);
					// **************************************************************
				}
			}

			// 4.3. Caso o sistema deva considerar guias de pagamentos
			Short pConsiderarPgtoGuiaPagamento = Short
							.valueOf((String) ParametroFaturamento.P_CONSIDERA_GUIA_PAGTO_DECLARACAO_QUITACAO_ANUAL.executar());

			if(pConsiderarPgtoGuiaPagamento.equals(ConstantesSistema.SIM)){

				// O sistema seleciona as contas quitadas no ano de referência
				Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = repositorioFaturamento
								.pesquisaGuiasPagamentoQuitadasAnoReferencia(imovel.getId(), referenciaFinal, dataFinal);

				if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){

					for(GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico : colecaoGuiaPagamentoPrestacaoHistorico){

						GuiaPagamentoPrestacaoHistoricoPK guiaPagamentoPrestacaoHistoricoPK = guiaPagamentoPrestacaoHistorico.getComp_id();
						Short numeroPrestacao = guiaPagamentoPrestacaoHistoricoPK.getNumeroPrestacao();

						// Inclui na tabela QUITACAO_DEBITO_ANUAL_ITEM os
						// seguintes
						// valores:
						QuitacaoDebitoAnualItem quitacaoDebitoAnualItem = new QuitacaoDebitoAnualItem();

						// QADB_ID >> QADB_ID da tabela QUITACAO_DEBITO_ANUAL
						quitacaoDebitoAnualItem.setQuitacaoDebitoAnual(quitacaoDebitoAnual);

						// DOTP_ID >> DOTP_ID da tabela DOCUMENTO_TIPO com
						// DOTP_DSDOCUMENTOTIPO com o valor correspondente à
						// "CONTA"
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.CONTA);

						quitacaoDebitoAnualItem.setDocumentoTipo(documentoTipo);

						quitacaoDebitoAnualItem.setAnoReferenciaItem(guiaPagamentoPrestacaoHistorico.getAnoMesReferenciaFaturamento());

						GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();

						guiaPagamentoGeral.setId(guiaPagamentoPrestacaoHistorico.getGuiaPagamento().getId());

						quitacaoDebitoAnualItem.setGuiaPagamentoGeral(guiaPagamentoGeral);

						// quitacaoDebitoAnualItem.setDebitoCreditoSituacao(guiaPagamentoPrestacaoHistorico.getGuiaPagamento().getDebitoCreditoSituacaoAtual());
						quitacaoDebitoAnualItem.setDebitoCreditoSituacao(guiaPagamentoPrestacaoHistorico.getDebitoCreditoSituacao());

						quitacaoDebitoAnualItem.setValorItem(guiaPagamentoPrestacaoHistorico.getValorPrestacao());

						// QADI_DTPAGAMENTO >> PGHI_DTPAGAMENTO da tabela
						// PAGAMENTO_HISTORICO
						Date dataPagamento = null;

						Collection<PagamentoHistorico> colecaoPagamentoHistorico = this.getControladorArrecadacao()
										.selecionarPagamentoHistoricoPorGuiaPagamentoHistorico(
														guiaPagamentoPrestacaoHistorico.getGuiaPagamento().getId());

						if(!Util.isVazioOrNulo(colecaoPagamentoHistorico)){
							PagamentoHistorico pagamentoHistorico = (PagamentoHistorico) Util
											.retonarObjetoDeColecao(colecaoPagamentoHistorico);

							dataPagamento = pagamentoHistorico.getDataPagamento();
						}

						quitacaoDebitoAnualItem.setDataPagamento(dataPagamento);

						quitacaoDebitoAnualItem.setNumeroPrestacao(numeroPrestacao);

						// QADI_TMULTIMAALTERACAO >> data e hora correntes
						quitacaoDebitoAnualItem.setUltimaAlteracao(new Date());

						// **************************************************************
						// Inclui o registro na tabela de quitação de débito
						// anual
						// item
						this.getControladorUtil().inserir(quitacaoDebitoAnualItem);
						// **************************************************************
					}
				}

			}

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();

			throw new EJBException(e);
		}catch(ControladorException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * [UC3013] Gerar Declaração Anual Quitação Débitos
	 * Este caso de uso indica se o imóvel está apto a receber a declaração anual de quitação de
	 * débitos para um determinado ano de referência.
	 * O imóvel está apto a receber a declaração caso não tenha contas em débito no ano de
	 * referência e que as contas vencidas no ano de referência tenham sido pagas no ano de
	 * referência.
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 18/04/2013
	 * @throws ControladorException
	 */
	public void gerarDeclaracaoAnualQuitacaoDebitos(int idFuncionalidadeIniciada, FaturamentoGrupo faturamentoGrupo)
					throws ControladorException{

		int idUnidadeIniciada = 0;

		try{

			// Registrar o início do processamento da unidade de processamento do batch
			idUnidadeIniciada = this.getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();

			filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, faturamentoGrupo.getId()));

			Collection faturamentoGrupos = getControladorUtil().pesquisar(filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

			FaturamentoGrupo faturamentoGrupoNaBase = null;
			if(!faturamentoGrupos.isEmpty()){
				faturamentoGrupoNaBase = (FaturamentoGrupo) faturamentoGrupos.iterator().next();

			}
			// O sistema gera a declaração anual de quitação de débitos passando o id do grupo que
			// está sendo processado.

			// [SB0001 - Gerar Declaração Anual Quitação Débitos].

			// O sistema obtém o ano de referência para a geração da declaração anual de quitação de
			// débitos
			Integer anoBaseDeclaracaoQuitacaoDebitoAnual = Integer
							.valueOf((String) ParametroFaturamento.P_ANO_BASE_DECLARACAO_QUITACAO_DEBITO_ANUAL.executar());

			// Caso o ano de referência seja diferente de "-1" e NÃO tenha sido gerada a declaração
			// para o grupo no ano de referência
			if(!Util.isVazioOuBranco(anoBaseDeclaracaoQuitacaoDebitoAnual)
							&& !anoBaseDeclaracaoQuitacaoDebitoAnual
											.equals(ConstantesSistema.SEM_ANO_BASE_DECLARACAO_QUITACAO_DEBITO_ANUAL)){

				// Verifica geração da declaração para o grupo no ano de referência
				FiltroQuitacaoDebitoAnual filtroQuitacaoDebitoAnual = new FiltroQuitacaoDebitoAnual();

				filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.FATURAMENTO_GRUPO_ID,
								faturamentoGrupoNaBase.getId()));
				filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.ANO_REFERENCIA,
								anoBaseDeclaracaoQuitacaoDebitoAnual));

				// Obtém registros na tabela QUITACAO_ANUAL_DEBITO
				Collection colecaoQuitacaoDebitoAnual = this.getControladorUtil().pesquisar(filtroQuitacaoDebitoAnual,
								QuitacaoDebitoAnual.class.getName());

				// Caso o ano de referência seja diferente de "-1" e NÃO tenha sido gerada a
				// declaração para o grupo no ano de referência
				if(Util.isVazioOrNulo(colecaoQuitacaoDebitoAnual)){
					// O sistema seleciona os imóveis pertencentes ao grupo de faturamento
					// selecionado.
					FiltroImovel filtroImovel = new FiltroImovel();
					filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ROTA_FATURAMENTO_GRUPO_ID, faturamentoGrupo.getId()));

					Collection<Imovel> colecaoImoveis = this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());

					// Para cada imóvel selecionado, o sistema gera a declaração anual de quitação
					// de débitos de acordo com as seguintes regras:
					if(!Util.isVazioOrNulo(colecaoImoveis)){
						for(Imovel imovel : colecaoImoveis){
							// [SB0002] - Verificar Não Geração da Declaração para o Imóvel - Modelo
							// 1
							// O sistema obtém o parâmetro de verificação da NÃO geração da
							// declaração para o imóvel
							Boolean verificarNaoGeracaoDeclaracaoParaImovel = (Boolean) ParametroFaturamento.P_VERIFICAR_NAO_GERACAO_DECLARACAO_PARA_IMOVEL
											.executar(this, -1, idFuncionalidadeIniciada, imovel.getId(),
															anoBaseDeclaracaoQuitacaoDebitoAnual);

							if(verificarNaoGeracaoDeclaracaoParaImovel){

								// O sistema indica que o usuário está apto a obter a declaração
								// anual de quitação de débitos de acordo com os seguinte
								// procedimentos:
								//
								// Inclui na tabela QUITACAO_DEBITO_ANUAL os seguintes valores:
								QuitacaoDebitoAnual quitacaoDebitoAnual = this.gerarQuitacaoDebitoAnual(imovel, faturamentoGrupoNaBase,
												anoBaseDeclaracaoQuitacaoDebitoAnual);

								// Inclui na tabela QUITACAO_DEBITO_ANUAL_ITEM
								this.gerarQuitacaoDebitoAnualItem(imovel, quitacaoDebitoAnual, anoBaseDeclaracaoQuitacaoDebitoAnual);

							}
						}
					}
				}
			}

			// Registrar o fim do processamento da unidade de processamento do batch
			this.getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			this.getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * [UC3014] Emitir Declaração Anual Quitação Débitos
	 * [SB0001] Emitir Declaração Anual de Quitação de Débitos
	 * 
	 * @author Hebert Falcão
	 * @created 27/04/2013
	 */
	public RelatorioArquivoDeclaracaoAnualQuitacaoDebitos emitirDeclaracaoAnualQuitacaoDebitos(Integer idFuncionalidadeIniciada,
					Integer idFaturamentoGrupo, Integer idImovel, Usuario usuario, Integer anoBaseDeclaracaoInformado)
					throws ControladorException{

		int idUnidadeIniciada = 0;
		RelatorioArquivoDeclaracaoAnualQuitacaoDebitos retorno = null;

		try{

			// Caso tenha sido chamado pelo processo batch
			if(idFaturamentoGrupo != null && idFuncionalidadeIniciada != null){

				// Registrar o início do processamento da unidade de processamento do batch
				idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
								UnidadeProcessamento.FUNCIONALIDADE, 0);
			}

			Integer anoBaseDeclaracaoQuitacaoDebitoAnual = null;

			// Caso não tenha informado o ano base da declaração obtém o valor do parametro
			if(anoBaseDeclaracaoInformado == null){

				anoBaseDeclaracaoQuitacaoDebitoAnual = Integer
								.valueOf((String) ParametroFaturamento.P_ANO_BASE_DECLARACAO_QUITACAO_DEBITO_ANUAL.executar());
			}else{

				// Caso contrário
				anoBaseDeclaracaoQuitacaoDebitoAnual = anoBaseDeclaracaoInformado;
			}

			if(anoBaseDeclaracaoQuitacaoDebitoAnual != null
							&& !anoBaseDeclaracaoQuitacaoDebitoAnual
											.equals(ConstantesSistema.SEM_ANO_BASE_DECLARACAO_QUITACAO_DEBITO_ANUAL)){

				Collection<QuitacaoDebitoAnual> colecaoQuitacaoDebitoAnual = repositorioFaturamento.pesquisarQuitacaoDebitoAnualParaEmicao(
								idFaturamentoGrupo, anoBaseDeclaracaoQuitacaoDebitoAnual, idImovel);

				if(!Util.isVazioOrNulo(colecaoQuitacaoDebitoAnual)){
					Collection<Object> colecaoQuitacaoDebitoAnualAtualizar = new ArrayList<Object>();

					Integer contador = 1;

					Map<Integer, QuitacaoDebitoAnual> colecaoHashMap = new HashMap<Integer, QuitacaoDebitoAnual>();

					for(QuitacaoDebitoAnual quitacaoDebitoAnual : colecaoQuitacaoDebitoAnual){
						colecaoHashMap.put(contador, quitacaoDebitoAnual);
						contador++;

						// O sistema indica a emissão da declaração anual de quitação de débitos
						quitacaoDebitoAnual.setIndicadorImpressao(ConstantesSistema.SIM);
						quitacaoDebitoAnual.setUltimaAlteracao(new Date());

						colecaoQuitacaoDebitoAnualAtualizar.add(quitacaoDebitoAnual);
					}

					Integer metade = null;

					int resto = colecaoQuitacaoDebitoAnual.size() % 2;

					if(resto == 1){
						metade = (colecaoQuitacaoDebitoAnual.size() / 2) + 1;
					}else{
						metade = colecaoQuitacaoDebitoAnual.size() / 2;
					}

					QuitacaoDebitoAnual quitacaoDebitoAnualAux = null;

					// montar colecao
					Collection<DeclaracaoAnualQuitacaoDebitosHelper> colecaoDeclaracaoAnualQuitacaoDebitosHelper = new ArrayList<DeclaracaoAnualQuitacaoDebitosHelper>();

					DeclaracaoAnualQuitacaoDebitosHelper declaracaoAnualQuitacaoDebitosHelper = null;

					Imovel imovel = null;

					Localidade localidade = null;
					Integer idLocalidade = null;
					String idLocalidadeStr = "";

					SetorComercial setorComercial = null;
					Integer codigoSetorComercial = null;
					String codigoSetorComercialStr = "";

					Rota rota = null;
					Short codigoRota = null;
					String codigoRotaStr = "";

					Short numeroSegmento = null;
					String numeroSegmentoStr = "";

					Short lote = null;
					String loteStr = "";

					Short subLote = null;
					String subLoteStr = "";

					for(int i = 1; i <= metade; i++){
						quitacaoDebitoAnualAux = colecaoHashMap.get(i);

						declaracaoAnualQuitacaoDebitosHelper = new DeclaracaoAnualQuitacaoDebitosHelper();
						declaracaoAnualQuitacaoDebitosHelper.setInscricao(quitacaoDebitoAnualAux.getImovel().getInscricaoFormatada());
						declaracaoAnualQuitacaoDebitosHelper.setAnoBase(quitacaoDebitoAnualAux.getAnoReferencia().toString());
						declaracaoAnualQuitacaoDebitosHelper.setCiclo(quitacaoDebitoAnualAux.getFaturamentoGrupo().getId().toString());
						declaracaoAnualQuitacaoDebitosHelper
										.setCodigoResponsavel(quitacaoDebitoAnualAux.getClienteResponsavel() != null ? quitacaoDebitoAnualAux
														.getClienteResponsavel().getId().toString()
														: "");
						declaracaoAnualQuitacaoDebitosHelper.setEndereco(this.getControladorEndereco().pesquisarEndereco(
										quitacaoDebitoAnualAux.getImovel().getId()));
						declaracaoAnualQuitacaoDebitosHelper.setMatricula(Util
										.retornaMatriculaImovelFormatadaParametrizada(quitacaoDebitoAnualAux.getImovel().getId()));
						declaracaoAnualQuitacaoDebitosHelper.setSequencialImpressao(Integer.valueOf(i).toString());

						String nomeClienteUsuario = this.repositorioClienteImovel.retornaNomeCliente(quitacaoDebitoAnualAux.getImovel()
										.getId(), ClienteRelacaoTipo.USUARIO);

						if(nomeClienteUsuario == null){
							nomeClienteUsuario = "";
						}

						declaracaoAnualQuitacaoDebitosHelper.setUsuario(nomeClienteUsuario);

						// Imóvel
						imovel = quitacaoDebitoAnualAux.getImovel();

						// Local
						idLocalidadeStr = "";

						localidade = imovel.getLocalidade();

						if(localidade != null){
							idLocalidade = localidade.getId();
							idLocalidadeStr = Integer.toString(idLocalidade);
						}

						declaracaoAnualQuitacaoDebitosHelper.setLocal(idLocalidadeStr);

						// Setor Comercial
						codigoSetorComercialStr = "";

						setorComercial = imovel.getSetorComercial();

						if(setorComercial != null){
							codigoSetorComercial = setorComercial.getCodigo();
							codigoSetorComercialStr = Integer.toString(codigoSetorComercial);
						}

						declaracaoAnualQuitacaoDebitosHelper.setSetor(codigoSetorComercialStr);

						// Rota
						codigoRotaStr = "";

						rota = imovel.getRota();

						if(rota != null){
							codigoRota = rota.getCodigo();
							codigoRotaStr = Short.toString(codigoRota);
						}

						declaracaoAnualQuitacaoDebitosHelper.setRota(codigoRotaStr);

						// Segmento
						numeroSegmentoStr = "";

						numeroSegmento = imovel.getNumeroSegmento();

						if(numeroSegmento != null){
							numeroSegmentoStr = Short.toString(numeroSegmento);
						}

						declaracaoAnualQuitacaoDebitosHelper.setSegmento(numeroSegmentoStr);

						// Lote
						loteStr = "";

						lote = imovel.getLote();

						if(lote != null){
							loteStr = Short.toString(lote);
						}

						declaracaoAnualQuitacaoDebitosHelper.setLote(loteStr);

						// SubLote
						subLoteStr = "";

						subLote = imovel.getSubLote();

						if(subLote != null){
							subLoteStr = Short.toString(subLote);
						}

						String cidade = "";
						if(imovel.getLogradouroCep() != null && imovel.getLogradouroCep().getCep() != null){
							cidade = imovel.getLogradouroCep().getCep().getMunicipio();
							declaracaoAnualQuitacaoDebitosHelper.setCidade(cidade);
						}

						declaracaoAnualQuitacaoDebitosHelper.setSublote(subLoteStr);

						colecaoDeclaracaoAnualQuitacaoDebitosHelper.add(declaracaoAnualQuitacaoDebitosHelper);

						quitacaoDebitoAnualAux = colecaoHashMap.get(i + metade);

						if(quitacaoDebitoAnualAux != null){

							declaracaoAnualQuitacaoDebitosHelper = new DeclaracaoAnualQuitacaoDebitosHelper();

							declaracaoAnualQuitacaoDebitosHelper.setInscricao(quitacaoDebitoAnualAux.getImovel().getInscricaoFormatada());
							declaracaoAnualQuitacaoDebitosHelper.setAnoBase(quitacaoDebitoAnualAux.getAnoReferencia().toString());
							declaracaoAnualQuitacaoDebitosHelper.setCiclo(quitacaoDebitoAnualAux.getFaturamentoGrupo().getId().toString());
							declaracaoAnualQuitacaoDebitosHelper
											.setCodigoResponsavel(quitacaoDebitoAnualAux.getClienteResponsavel() != null ? quitacaoDebitoAnualAux
															.getClienteResponsavel().getId().toString()
															: "");
							declaracaoAnualQuitacaoDebitosHelper.setEndereco(this.getControladorEndereco().pesquisarEndereco(
											quitacaoDebitoAnualAux.getImovel().getId()));
							declaracaoAnualQuitacaoDebitosHelper.setMatricula(Util
											.retornaMatriculaImovelFormatadaParametrizada(quitacaoDebitoAnualAux.getImovel().getId()));
							declaracaoAnualQuitacaoDebitosHelper.setSequencialImpressao(Integer.valueOf(i + metade).toString());

							nomeClienteUsuario = this.repositorioClienteImovel.retornaNomeCliente(quitacaoDebitoAnualAux.getImovel()
											.getId(), ClienteRelacaoTipo.USUARIO);

							if(nomeClienteUsuario == null){
								nomeClienteUsuario = "";
							}

							declaracaoAnualQuitacaoDebitosHelper.setUsuario(nomeClienteUsuario);

							// Imóvel
							imovel = quitacaoDebitoAnualAux.getImovel();

							// Local
							idLocalidadeStr = "";

							localidade = imovel.getLocalidade();

							if(localidade != null){
								idLocalidade = localidade.getId();
								idLocalidadeStr = Integer.toString(idLocalidade);
							}

							declaracaoAnualQuitacaoDebitosHelper.setLocal(idLocalidadeStr);

							// Setor Comercial
							codigoSetorComercialStr = "";

							setorComercial = imovel.getSetorComercial();

							if(setorComercial != null){
								codigoSetorComercial = setorComercial.getCodigo();
								codigoSetorComercialStr = Integer.toString(codigoSetorComercial);
							}

							declaracaoAnualQuitacaoDebitosHelper.setSetor(codigoSetorComercialStr);

							// Rota
							codigoRotaStr = "";

							rota = imovel.getRota();

							if(rota != null){
								codigoRota = rota.getCodigo();
								codigoRotaStr = Short.toString(codigoRota);
							}

							declaracaoAnualQuitacaoDebitosHelper.setRota(codigoRotaStr);

							// Segmento
							numeroSegmentoStr = "";

							numeroSegmento = imovel.getNumeroSegmento();

							if(numeroSegmento != null){
								numeroSegmentoStr = Short.toString(numeroSegmento);
							}

							declaracaoAnualQuitacaoDebitosHelper.setSegmento(numeroSegmentoStr);

							// Lote
							loteStr = "";

							lote = imovel.getLote();

							if(lote != null){
								loteStr = Short.toString(lote);
							}

							declaracaoAnualQuitacaoDebitosHelper.setLote(loteStr);

							// SubLote
							subLoteStr = "";

							subLote = imovel.getSubLote();

							if(subLote != null){
								subLoteStr = Short.toString(subLote);
							}

							declaracaoAnualQuitacaoDebitosHelper.setSublote(subLoteStr);

							if(imovel.getLogradouroCep() != null && imovel.getLogradouroCep().getCep() != null){
								cidade = imovel.getLogradouroCep().getCep().getMunicipio();
								declaracaoAnualQuitacaoDebitosHelper.setCidade(cidade);
							}
							colecaoDeclaracaoAnualQuitacaoDebitosHelper.add(declaracaoAnualQuitacaoDebitosHelper);
						}
					}

					String nomeArquivo = "QUITACAO_ANUAL_" + anoBaseDeclaracaoQuitacaoDebitoAnual;

					if(idFaturamentoGrupo != null){

						nomeArquivo += "_G" + Util.completarStringZeroEsquerda(Integer.toString(idFaturamentoGrupo), 4);
					}

					String idImovelStr = "";

					if(idImovel != null){

						idImovelStr = "_MAT" + idImovelStr.toString();
					}

					nomeArquivo += ".pdf";

					RelatorioArquivoDeclaracaoAnualQuitacaoDebitos relatorio = null;

					if(usuario == null){

						relatorio = new RelatorioArquivoDeclaracaoAnualQuitacaoDebitos(Usuario.USUARIO_BATCH);
					}else{

						relatorio = new RelatorioArquivoDeclaracaoAnualQuitacaoDebitos(usuario);
					}

					relatorio.addParametro("colecaoDeclaracaoAnualQuitacaoDebitosHelper", colecaoDeclaracaoAnualQuitacaoDebitosHelper);

					relatorio.addParametro("anoBaseDeclaracaoQuitacaoDebitoAnual", anoBaseDeclaracaoQuitacaoDebitoAnual);

					relatorio.addParametro("nomeArquivo", nomeArquivo);

					relatorio.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);

					retorno = relatorio;

					// Caso tenha sido chamado pelo processo batch
					if(idFaturamentoGrupo != null && idFuncionalidadeIniciada != null){

						this.getControladorBatch().iniciarProcessoRelatorio(relatorio);
					}

					this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoQuitacaoDebitoAnualAtualizar);
				}
			}

			// Caso tenha sido chamado pelo processo batch
			if(idFaturamentoGrupo != null && idFuncionalidadeIniciada != null){

				// Registrar o fim do processamento da unidade de processamento do batch
				this.getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
			}

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo batch venha a
			// lançar e garantir que a unidade de processamento do batch será atualizada com o erro
			// ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();

			// Caso tenha sido chamado pelo processo batch
			if(idFaturamentoGrupo != null && idFuncionalidadeIniciada != null){

				this.getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			}

			throw new EJBException(e);
		}

		return retorno;
	}

	/**
	 * [UC3153] - Verificar Titularidade Débito/Crédito
	 * 
	 * @author Yara Souza
	 * @date 29/07/2014
	 **/
	public void verificarTitularidadeDebitoCredito(Integer idImovel, ObterDebitoImovelOuClienteHelper obterDebitoImovelOuClienteHelper,
					Collection colecaoDebitoACobrar, Collection colecaoCreditoARealizar) throws ControladorException{

		String pIndicadorFaturamentoAtualTitulaeDebitoImovel = null;

		try{

			pIndicadorFaturamentoAtualTitulaeDebitoImovel = (String) ParametroFaturamento.P_INDICADOR_FATURAMENTO_ATUAL_TITULAR_DEBITO_IMOVEL
							.executar();

			if(pIndicadorFaturamentoAtualTitulaeDebitoImovel.equals(ConstantesSistema.SIM.toString())){

				String pTipoRelacaoAtualTitularDebitoImovel = (String) ParametroFaturamento.P_TIPO_RELACAO_ATUAL_TITULAR_DEBITO_IMOVEL
								.executar();
				// Filtro TipoClienteImovel
				FiltroClienteRelacaoTipo filtroClienteRelacaoTipo = new FiltroClienteRelacaoTipo(FiltroClienteTipo.DESCRICAO);
				filtroClienteRelacaoTipo.adicionarParametro(new ParametroSimples(FiltroClienteRelacaoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));
				filtroClienteRelacaoTipo.adicionarParametro(new ParametroSimples(FiltroClienteRelacaoTipo.CLIENTE_RELACAO_TIPO_ID,
								pTipoRelacaoAtualTitularDebitoImovel));

				Collection colecaoClienteRelacaoTipo = this.getControladorUtil().pesquisar(filtroClienteRelacaoTipo,
								ClienteRelacaoTipo.class.getName());

				ClienteRelacaoTipo clienteRelacaoTipo = (ClienteRelacaoTipo) Util.retonarObjetoDeColecao(colecaoClienteRelacaoTipo);

				this.getControladorRegistroAtendimento().verificarTitularidadeDebito(idImovel,
								Util.converterStringParaShort(pIndicadorFaturamentoAtualTitulaeDebitoImovel), clienteRelacaoTipo,
								obterDebitoImovelOuClienteHelper, null, colecaoDebitoACobrar, null, colecaoCreditoARealizar);

			}

		}catch(ControladorException e){
			throw new ControladorException("atencao.sistemaparametro_inexistente", null,
							"P_INDICADOR_FATURAMENTO_ATUAL_TITULAR_DEBITO_IMOVEL");
		}

	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * [SB0001] - Cálculo Simples Cascata Para Uma Única Tarifa
	 * 
	 * @author Saulo Lima
	 * @date 20/12/2008
	 *       Ajuste na determinação de consumo de mistos considerando mínimos diferentes por
	 *       categoria.
	 * @author Virgínia Melo
	 * @date 30/12/2008
	 *       Ajuste no campo vlFaturadoCategoria para retornar com apenas 2 casas decimais
	 * @author eduardo henrique
	 * @date 07/01/2009
	 *       Alteração para truncar o valor para 2 casas decimais, no valor mínimo da categoria. (em
	 *       aprovação por ADA)
	 * @author eduardo henrique
	 * @date 27/01/2009
	 *       Correção na atribuição de Valor Mínimo da Tarifa calculada.
	 *       Correção no cálculo das Categorias_Faixa, em especial na faixa da Tarifa Mínima.
	 * @author Yara Souza
	 * @date 30/08/2011
	 *       Permitir o cálculo por cascata para consumos que não são divisíveis pelo número de
	 *       economias.
	 */
	private Collection<CalcularValoresAguaEsgotoHelper> calculoSimplesCascataUmaUnicaTarifa(Integer consumoFaturado,
					Collection categoriasImovel, BigDecimal percentualEsgoto, ConsumoTarifaVigencia consumoTarifaVigencia,
					String tipoCalculo, int consumoMinimoLigacao, Date dataLeituraAnterior, Date dataLeituraAtual, Integer idCategoriaMenor)
					throws ControladorException{

		int quantTotalEconomia = 0;
		int consumoMinimoCategoria = 0;
		int consumoExcedenteCategoria = 0;
		int consumoProjetado = 0;
		int consumoProjetadoExcedente = 0;
		int consumoProjetadoExcedentePorEconomia = 0;
		int residuoConsumoExcedente = 0;
		int residuoConsumoProjetado = 0;
		int consumoExcedenteProjetadoCategoria = 0;

		BigDecimal vlTarifaMinimaCategoria = new BigDecimal("0");
		BigDecimal vlFaturadoCategoria = new BigDecimal("0");

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		// 1.1. Calcula a quantidade total de economias do imóvel.
		quantTotalEconomia = this.obterQuantidadeTotalEconomiasImovel(categoriasImovel);

		// 1.2.
		if(consumoFaturado != null){
			consumoProjetado = consumoFaturado.intValue();
		}

		// 1.3.
		consumoProjetadoExcedente = 0;

		// 1.4. PARM_ICAJUSTETARIFALEITPROJ da tabela SISTEMA_PARAMETROS for igual a 1.
		if(sistemaParametro.getIndicadorAjusteTarifaLeituraProjetada() == ConstantesSistema.SIM.shortValue()){

			Object[] retornoAjusteConsumoProjetado = new Object[3];
			retornoAjusteConsumoProjetado = ajustarConsumoProjetado(dataLeituraAnterior, dataLeituraAtual, consumoProjetado,
							quantTotalEconomia);

			consumoProjetado = (Integer) retornoAjusteConsumoProjetado[0];
			consumoProjetadoExcedente = (Integer) retornoAjusteConsumoProjetado[1];
			consumoProjetadoExcedentePorEconomia = (Integer) retornoAjusteConsumoProjetado[2];

		}

		// 1.5.
		int consumoExcedentePorEconomia = 0;
		BigDecimal consumoExcedentePorEconomiaComCasasDecimais = BigDecimal.ZERO;
		String parametroFormaCalculoConsumoExcedenteEconomia = ParametroFaturamento.P_FORMA_CALCULO_CONSUMO_EXCEDENTE_ECONOMIA.executar();

		// 1.6. Caso o consumo projetado seja maior que o consumo mínimo da ligação,
		// calcula o consumo excedente por economia
		if(consumoProjetado > consumoMinimoLigacao){

			if(parametroFormaCalculoConsumoExcedenteEconomia != null
							&& parametroFormaCalculoConsumoExcedenteEconomia.equals(FormaCalculoConsumoExcedenteEconomia.DOIS.getValor())){

				// Consumo excedente por economia (Considerando quatro "4" casas decimais) =
				// (consumo projetado - consumo mínimo da ligação) / quantidade total de economias
				consumoExcedentePorEconomiaComCasasDecimais = Util.dividirArredondando(new BigDecimal(consumoProjetado
								- consumoMinimoLigacao), new BigDecimal(quantTotalEconomia), 4);

				// Resíduo do consumo execedente = (consumo projetado - consumo mínimo da ligação) -
				// (consumo excedente por economia(parte inteira) * quantidade total de economias)
				residuoConsumoExcedente = (consumoProjetado - consumoMinimoLigacao)
								- (consumoExcedentePorEconomiaComCasasDecimais.intValue() * quantTotalEconomia);
			}else{

				// Consumo excedente por economia (Não considerar casas decimais) = (consumo
				// projetado - consumo mínimo da ligação) / quantidade total de economias
				consumoExcedentePorEconomia = (consumoProjetado - consumoMinimoLigacao) / quantTotalEconomia;

				// Resíduo do consumo excedente = (consumo projetado - consumo mínimo da ligação) -
				// (consumo excedente por economia * quantidade total de economias)
				residuoConsumoExcedente = (consumoProjetado - consumoMinimoLigacao) - (consumoExcedentePorEconomia * quantTotalEconomia);
			}
		}

		int consumoFaturadoExcedentePorEconomia = 0;
		int residuoConsumoFaturadoExcedente = 0;

		if(consumoFaturado == null){
			consumoFaturado = 0;
		}

		// 1.7. Caso o consumo projetado seja menor ou igual ao consumo mínimo da ligação E o
		// consumo faturado seja maior ao consumo mínimo da ligação
		if(consumoProjetado <= consumoMinimoLigacao && consumoFaturado > consumoMinimoLigacao && quantTotalEconomia != 0){
			consumoFaturadoExcedentePorEconomia = (consumoFaturado - consumoMinimoLigacao) / quantTotalEconomia;

			residuoConsumoFaturadoExcedente = (consumoFaturado - consumoMinimoLigacao)
							- (consumoFaturadoExcedentePorEconomia * quantTotalEconomia);
		}

		// 1.8. Resíduo do consumo projetado = execedente do consumo projetado -
		// (excedente do consumo projetado por economia * quantidade total de economias)
		if(consumoProjetadoExcedente > 0){
			residuoConsumoProjetado = consumoProjetadoExcedente - (consumoProjetadoExcedentePorEconomia * quantTotalEconomia);
		}

		// 1.9. Seleciona as tarifas de consumo por categoria (CONSUMO_TARIFA_CATEGORIA).
		Iterator itCategoriasImovel = categoriasImovel.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoria = null;
		Collection colecaoConsumoTarifaCategoria = null;

		while(itCategoriasImovel.hasNext()){
			Categoria categoria = (Categoria) itCategoriasImovel.next();

			int consumoFaturadoCategoria = 0;

			try{

				colecaoConsumoTarifaCategoria = repositorioFaturamento.pesquisarConsumoTarifaCategoria(consumoTarifaVigencia, categoria);

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if(colecaoConsumoTarifaCategoria == null || colecaoConsumoTarifaCategoria.isEmpty()){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.categoria_nao_existe_para_tarifa_vigente");
			}

			consumoTarifaCategoria = (ConsumoTarifaCategoria) Util.retonarObjetoDeColecao(colecaoConsumoTarifaCategoria);

			// 1.10. Para cada tarifa de consumo por categoria selecionada serão calculados os
			// valores
			// (valor da tarifa mínima da categoria, consumo mínimo da categoria, valor por economia
			// da categoria, consumo excedente da categoria)

			if(parametroFormaCalculoConsumoExcedenteEconomia != null
							&& parametroFormaCalculoConsumoExcedenteEconomia.equals(FormaCalculoConsumoExcedenteEconomia.DOIS.getValor())){

				consumoExcedenteCategoria = consumoExcedentePorEconomiaComCasasDecimais.intValue()
								* categoria.getQuantidadeEconomiasCategoria();
			}else{

				consumoExcedenteCategoria = consumoExcedentePorEconomia * categoria.getQuantidadeEconomiasCategoria();
			}

			BigDecimal valorTarifaMinima = BigDecimal.ZERO;
			if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_ESGOTO)
							&& consumoTarifaVigencia.getConsumoTarifa().getIcTarifaEsgotoPropria().equals(ConstantesSistema.SIM)){

				valorTarifaMinima = consumoTarifaCategoria.getValorTarifaMinimaEsgoto();

			}else{
				valorTarifaMinima = consumoTarifaCategoria.getValorTarifaMinima();
			}

			if(valorTarifaMinima != null){
				vlTarifaMinimaCategoria = valorTarifaMinima.multiply(new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));
			}else{
				vlTarifaMinimaCategoria = null;
			}

			if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
				consumoMinimoCategoria = consumoTarifaCategoria.getNumeroConsumoMinimo().intValue()
								* categoria.getQuantidadeEconomiasCategoria();
			}

			if(valorTarifaMinima != null){

				if(parametroFormaCalculoConsumoExcedenteEconomia != null
								&& parametroFormaCalculoConsumoExcedenteEconomia.equals(FormaCalculoConsumoExcedenteEconomia.DOIS
												.getValor()) && (consumoProjetado > consumoMinimoLigacao && consumoExcedenteCategoria == 0)){

					vlFaturadoCategoria = (((valorTarifaMinima.divide(new BigDecimal(consumoMinimoCategoria), 15, BigDecimal.ROUND_HALF_UP))
									.multiply(new BigDecimal(consumoProjetado))).multiply(new BigDecimal(""
									+ categoria.getQuantidadeEconomiasCategoria()))).setScale(2, BigDecimal.ROUND_HALF_UP);
				}else{

					vlFaturadoCategoria = valorTarifaMinima.multiply(new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));
				}

			}else{
				vlFaturadoCategoria = null;
			}

			// 1.10.1.4.
			consumoFaturadoCategoria = consumoTarifaCategoria.getNumeroConsumoMinimo().intValue()
							* categoria.getQuantidadeEconomiasCategoria();

			int consumoFaturadoExcedenteCategoria = consumoFaturadoExcedentePorEconomia * categoria.getQuantidadeEconomiasCategoria();

			// 1.10.1.6.
			if(consumoProjetadoExcedentePorEconomia > 0){
				consumoExcedenteProjetadoCategoria = consumoProjetadoExcedentePorEconomia * categoria.getQuantidadeEconomiasCategoria();
			}

			if(idCategoriaMenor.equals(categoria.getId())){

				// 1.10.1.5.
				if(parametroFormaCalculoConsumoExcedenteEconomia == null
								|| !parametroFormaCalculoConsumoExcedenteEconomia.equals(FormaCalculoConsumoExcedenteEconomia.DOIS
												.getValor())){

					consumoExcedenteCategoria = consumoExcedenteCategoria + residuoConsumoExcedente;
				}

				consumoExcedenteProjetadoCategoria = consumoExcedenteProjetadoCategoria + residuoConsumoProjetado;
				consumoFaturadoExcedenteCategoria = consumoFaturadoExcedenteCategoria + residuoConsumoFaturadoExcedente;
			}

			// Objeto que irá armazenar os valores calculados referentes as faixas
			Collection<CalcularValoresAguaEsgotoFaixaHelper> colecaoCalcularValoresAguaEsgotoFaixaHelper = new ArrayList();

			if(consumoFaturadoExcedenteCategoria > 0){

				BigDecimal numeroConsumoMinimoBD = new BigDecimal(consumoTarifaCategoria.getNumeroConsumoMinimo());
				BigDecimal consumoFaturadoExcedenteCategoriaBD = new BigDecimal(consumoFaturadoExcedenteCategoria);
				BigDecimal vlFaturadoExcedente = consumoFaturadoExcedenteCategoriaBD.multiply(valorTarifaMinima.divide(
								numeroConsumoMinimoBD, 4, BigDecimal.ROUND_HALF_UP));
				vlFaturadoCategoria = vlFaturadoCategoria.add(vlFaturadoExcedente);

				consumoFaturadoCategoria = consumoFaturadoCategoria + consumoFaturadoExcedenteCategoria;

				// inicio da alteracao
				Collection<ConsumoTarifaFaixa> colecaoConsumoTarifaFaixa = null;

				try{
					colecaoConsumoTarifaFaixa = repositorioFaturamento.pesquisarConsumoTarifaFaixa(consumoTarifaCategoria);
				}catch(ErroRepositorioException ex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				if(!Util.isVazioOrNulo(colecaoConsumoTarifaFaixa)){
					ConsumoTarifaFaixa consumoTarifaFaixa = (ConsumoTarifaFaixa) Util.retonarObjetoDeColecao(colecaoConsumoTarifaFaixa);

					// Primeira Faixa
					CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = new CalcularValoresAguaEsgotoFaixaHelper();

					calcularValoresAguaEsgotoFaixaHelper.setIdConsumoTarifaFaixa(consumoTarifaFaixa.getId());
					calcularValoresAguaEsgotoFaixaHelper.setLimiteInicialConsumoFaixa(0);
					calcularValoresAguaEsgotoFaixaHelper.setLimiteFinalConsumoFaixa(consumoTarifaCategoria.getNumeroConsumoMinimo());
					calcularValoresAguaEsgotoFaixaHelper.setValorTarifaFaixa(valorTarifaMinima.divide(numeroConsumoMinimoBD, 4,
									BigDecimal.ROUND_HALF_UP));

					if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){
						calcularValoresAguaEsgotoFaixaHelper.setConsumoFaturadoAguaFaixa(0);
						calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoAguaFaixa(BigDecimal.ZERO);
					}else{
						calcularValoresAguaEsgotoFaixaHelper.setConsumoFaturadoEsgotoFaixa(0);
						calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoEsgotoFaixa(BigDecimal.ZERO);
					}

					colecaoCalcularValoresAguaEsgotoFaixaHelper.add(calcularValoresAguaEsgotoFaixaHelper);

					// Segunda Faixa
					calcularValoresAguaEsgotoFaixaHelper = new CalcularValoresAguaEsgotoFaixaHelper();

					calcularValoresAguaEsgotoFaixaHelper.setIdConsumoTarifaFaixa(consumoTarifaFaixa.getId());
					calcularValoresAguaEsgotoFaixaHelper.setLimiteInicialConsumoFaixa(1);
					calcularValoresAguaEsgotoFaixaHelper.setLimiteFinalConsumoFaixa(consumoTarifaCategoria.getNumeroConsumoMinimo());
					calcularValoresAguaEsgotoFaixaHelper.setValorTarifaFaixa(valorTarifaMinima.divide(numeroConsumoMinimoBD, 4,
									BigDecimal.ROUND_HALF_UP));

					if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){
						calcularValoresAguaEsgotoFaixaHelper.setConsumoFaturadoAguaFaixa(consumoFaturadoExcedenteCategoria);
						calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoAguaFaixa(vlFaturadoExcedente);
					}else{
						calcularValoresAguaEsgotoFaixaHelper.setConsumoFaturadoEsgotoFaixa(consumoFaturadoExcedenteCategoria);
						calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoEsgotoFaixa(vlFaturadoExcedente);
					}

					colecaoCalcularValoresAguaEsgotoFaixaHelper.add(calcularValoresAguaEsgotoFaixaHelper);
				}
				// fim da alteracao
			}

			int faixaFimAnterior = consumoMinimoCategoria;

			// 1.10.2.1.
			if(consumoExcedenteCategoria > 0){

				Collection colecaoConsumoTarifaFaixa = null;

				try{

					colecaoConsumoTarifaFaixa = repositorioFaturamento.pesquisarConsumoTarifaFaixa(consumoTarifaCategoria);

				}catch(ErroRepositorioException ex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				if(colecaoConsumoTarifaFaixa == null || colecaoConsumoTarifaFaixa.isEmpty()){
					// Nenhuma faixa foi encontrada
					sessionContext.setRollbackOnly();
					throw new ControladorException("");
				}else{

					// 1.10.2.3.1. Calcula o consumo faturado na faixa = (CSTF_NNCONSUMOFAIXAFIM –
					// faixa fim anterior) * quantidade de economias da categoria;

					Iterator itConsumoTarifaFaixa = colecaoConsumoTarifaFaixa.iterator();
					ConsumoTarifaFaixa consumoTarifaFaixa;

					int consumoFaturadoFaixa = 0;
					int limiteInicialConsumoFaixa = 0;
					int limiteFinalConsumoFaixa = 0;
					BigDecimal vlFaturadoFaixa = new BigDecimal("0");
					BigDecimal vlTarifaFaixa = new BigDecimal("0");

					while(itConsumoTarifaFaixa.hasNext() && consumoExcedenteCategoria > 0){

						consumoTarifaFaixa = (ConsumoTarifaFaixa) itConsumoTarifaFaixa.next();

						// Calcula o consumo faturado na faixa = (CSTF_NNCONSUMOFAIXAFIM – faixa fim
						// anterior) * quantidade de economias da categoria;
						consumoFaturadoFaixa = (consumoTarifaFaixa.getNumeroConsumoFaixaIFim().intValue() * categoria
										.getQuantidadeEconomiasCategoria()) - faixaFimAnterior;

						// Caso o consumo excedente da categoria seja menor que o consumo faturado
						// na faixa, consumo faturado na faixa = consumo excedente da categoria e a
						// Faixa Atual não seja 'Faixa Mínima' (faixaFimAnterior == 0)

						// 1.10.2.3.2. Caso o consumo excedente da categoria seja menor ou igual ao
						// consumo faturado na faixa (chegou a última faixa) e a faixa fim anterior
						// seja diferente de
						// zero, consumo faturado na faixa = consumo excedente da categoria.
						if((consumoExcedenteCategoria <= consumoFaturadoFaixa) && faixaFimAnterior != 0){
							consumoFaturadoFaixa = consumoExcedenteCategoria;

							// 1.10.2.3.3.
							if(parametroFormaCalculoConsumoExcedenteEconomia != null
											&& parametroFormaCalculoConsumoExcedenteEconomia
															.equals(FormaCalculoConsumoExcedenteEconomia.DOIS.getValor())){

								// Adiciona o resíduo na última faixa
								consumoFaturadoFaixa = consumoFaturadoFaixa + consumoExcedenteProjetadoCategoria + residuoConsumoExcedente;
							}else{

								// Não adiciona o resíduo pois ele vai ser incluído em uma próxima
								// faixa
								consumoFaturadoFaixa = consumoFaturadoFaixa + consumoExcedenteProjetadoCategoria;
							}


						}

						// Valor faturado na faixa = (consumo faturado na faixa
						// CSTF_VLCONSUMOTARIFA).
						if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_ESGOTO)
										&& consumoTarifaVigencia.getConsumoTarifa().getIcTarifaEsgotoPropria()
														.equals(ConstantesSistema.SIM)){

							vlFaturadoFaixa = (new BigDecimal("" + consumoFaturadoFaixa)).multiply(consumoTarifaFaixa
											.getValorUsoEsgotoTarifa());

						}else{

							vlFaturadoFaixa = (new BigDecimal("" + consumoFaturadoFaixa)).multiply(consumoTarifaFaixa
											.getValorConsumoTarifa());
						}

						// Consumo faturado da categoria = consumo faturado da categoria +
						// consumo faturado na faixa
						consumoFaturadoCategoria = consumoFaturadoCategoria + consumoFaturadoFaixa;

						// Limite inicial de consumo da faixa = CSTF_NNCONSUMOFAIXAINICIO
						limiteInicialConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaInicio().intValue();

						// Limite final de consumo da faixa = CSTF_NNCONSUMOFAIXAFIM
						limiteFinalConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaIFim().intValue();

						// Valor da tarifa na faixa = CSTF_VLCONSUMOTARIFA
						vlTarifaFaixa = consumoTarifaFaixa.getValorConsumoTarifa();

						if(faixaFimAnterior != 0){
							// Consumo excedente da categoria = consumo excedente da categoria –
							// consumo faturado na faixa
							consumoExcedenteCategoria = consumoExcedenteCategoria - consumoFaturadoFaixa;

							// Valor faturado da categoria = valor faturado da categoria +
							// valor faturado na faixa
							vlFaturadoCategoria = vlFaturadoCategoria.add(vlFaturadoFaixa);

						}

						// 1.10.2.3.10. Faixa fim anterior = CSTI_NNCONSUMOFAIXAFIM * quantidade
						// de economias da categoria;
						faixaFimAnterior = consumoTarifaFaixa.getNumeroConsumoFaixaIFim().intValue()
										* categoria.getQuantidadeEconomiasCategoria();

						/*
						 * Inseri os valores calculados no objeto de faixas
						 * -----------------------------------------------------------------
						 */
						CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = new CalcularValoresAguaEsgotoFaixaHelper();

						calcularValoresAguaEsgotoFaixaHelper.setIdConsumoTarifaFaixa(consumoTarifaFaixa.getId());
						calcularValoresAguaEsgotoFaixaHelper.setLimiteInicialConsumoFaixa(limiteInicialConsumoFaixa);
						calcularValoresAguaEsgotoFaixaHelper.setLimiteFinalConsumoFaixa(limiteFinalConsumoFaixa);
						calcularValoresAguaEsgotoFaixaHelper.setValorTarifaFaixa(vlTarifaFaixa);

						if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){
							calcularValoresAguaEsgotoFaixaHelper.setConsumoFaturadoAguaFaixa(consumoFaturadoFaixa);
							calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoAguaFaixa(vlFaturadoFaixa);
						}else{
							calcularValoresAguaEsgotoFaixaHelper.setConsumoFaturadoEsgotoFaixa(consumoFaturadoFaixa);
							calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoEsgotoFaixa(vlFaturadoFaixa);
						}
						// ------------------------------------------------------------------

						colecaoCalcularValoresAguaEsgotoFaixaHelper.add(calcularValoresAguaEsgotoFaixaHelper);

					}
				}
			}

			// Gerando o novo objeto
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = new CalcularValoresAguaEsgotoHelper();

			// Carregando o id da categoria no objeto
			calcularValoresAguaEsgotoHelper.setIdCategoria(categoria.getId());

			// Carregando a descricao da categoria no objeto
			calcularValoresAguaEsgotoHelper.setDescricaoCategoria(categoria.getDescricao());

			// Carrega a quantidade de economias da categoria
			calcularValoresAguaEsgotoHelper.setQuantidadeEconomiasCategoria(categoria.getQuantidadeEconomiasCategoria());

			// Carregando o id do consumoTarifaCategoria no objeto
			calcularValoresAguaEsgotoHelper.setIdConsumoTarifaCategoria(consumoTarifaCategoria.getId());

			if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){

				calcularValoresAguaEsgotoHelper.setValorFaturadoAguaCategoria(vlFaturadoCategoria.setScale(2, BigDecimal.ROUND_DOWN));
				calcularValoresAguaEsgotoHelper.setConsumoFaturadoAguaCategoria(consumoFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setValorTarifaMinimaAguaCategoria(vlTarifaMinimaCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoMinimoAguaCategoria(consumoMinimoCategoria);

			}else{
				// Caso o indicador CSTF_ICTARIFAESGOTOPROPRIA de CONSUMO_TARIFA para o CSTF_ID em
				// questão tenha valor 2(Não)
				if(consumoTarifaVigencia.getConsumoTarifa().getIcTarifaEsgotoPropria().equals(ConstantesSistema.NAO)){

					String truncarValorEsgoto = (String) ParametroFaturamento.P_TRUNCAR_VALOR_ESGOTO.executar();

					BigDecimal result = BigDecimal.ZERO;
					// Calculando com o percentual de esgoto
					if(percentualEsgoto != null){
						// result = percentualEsgoto.divide(new BigDecimal("100"), 2,
						// tipoArredondamento);
						result = percentualEsgoto.divide(new BigDecimal("100"));
					}

					if(truncarValorEsgoto.equals(ConstantesSistema.SIM.toString())){

						int tipoArredondamento = BigDecimal.ROUND_FLOOR;
						// Valor faturado de esgoto
						vlFaturadoCategoria = vlFaturadoCategoria.multiply(result);
						vlFaturadoCategoria = vlFaturadoCategoria.setScale(2, tipoArredondamento);

						// Valor da tarifa mínima de esgoto
						vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.multiply(result);
						vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.setScale(2, tipoArredondamento);
					}else{

						int tipoArredondamento = BigDecimal.ROUND_DOWN;
						// Valor faturado de esgoto
						vlFaturadoCategoria = vlFaturadoCategoria.multiply(result);
						vlFaturadoCategoria = vlFaturadoCategoria.setScale(2, tipoArredondamento);

						// Valor da tarifa mínima de esgoto
						vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.multiply(result);
						vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.setScale(2, tipoArredondamento);
					}

				}

				calcularValoresAguaEsgotoHelper.setValorFaturadoEsgotoCategoria(vlFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoFaturadoEsgotoCategoria(consumoFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setValorTarifaMinimaEsgotoCategoria(vlTarifaMinimaCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoMinimoEsgotoCategoria(consumoMinimoCategoria);
			}

			// Carregando a coleção com os valores referentes as faixas
			calcularValoresAguaEsgotoHelper.setFaixaTarifaConsumo(colecaoCalcularValoresAguaEsgotoFaixaHelper);

			colecaoRetorno.add(calcularValoresAguaEsgotoHelper);

		}

		return colecaoRetorno;

	}

	public void executarAjusteContaZeradasEnviarHistorico(Integer anoMesReferencia) throws ControladorException{

		try{

			log.info("-----------Início executarAjusteContaZeradasEnviarHistorico: ----------------");

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteContaZeradasEnviarHistorico(anoMesReferencia);

			log.info("-----------Fim executarAjusteContaZeradasEnviarHistorico: ----------------");

		}catch(Exception e){

			log.info("-----------Erro executarAjusteContaZeradasEnviarHistorico: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	public void executarAjusteErroGeracaoContaCategoriaConsumoFaixa(Integer anoMesReferencia, String idsGrupos) throws ControladorException{

		try{

			log.info("-----------Início executarAjusteErroGeracaoContaCategoriaConsumoFaixa: ----------------");

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteErroGeracaoContaCategoriaConsumoFaixa(anoMesReferencia, idsGrupos);

			log.info("-----------Fim executarAjusteErroGeracaoContaCategoriaConsumoFaixa: ----------------");

		}catch(Exception e){

			log.info("-----------Erro executarAjusteErroGeracaoContaCategoriaConsumoFaixa: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0352] - Emitir Contas
	 * [SB0033] – Gerar Contas Modelo 3
	 * Responsável pela geração PDF com a conta
	 * 
	 * @author Yara Souza
	 * @date 11/03/2014
	 */
	public List<RelatorioContaModelo3Bean> obterDadosRelatorioEmitirContasModelo3(FaturamentoGrupo faturamentoGrupo,
					Integer anoMesReferencia, Collection<EmitirContaTipo2Helper> colecaoEmitirContaTipo2Helper) throws ControladorException{

		List<RelatorioContaModelo3Bean> relatorioBeans = new ArrayList<RelatorioContaModelo3Bean>();

		try{

			Iterator<EmitirContaTipo2Helper> contaHelperIterator = colecaoEmitirContaTipo2Helper.iterator();
			EmitirContaTipo2Helper helper = null;
			String matriculaImovelFormatada = null;
			String referencia = null;
			String dataLeituraAnterior = "";
			String dataLeituraAtual = "";
			int pagina = 0;
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			while(contaHelperIterator.hasNext()){

				RelatorioContaModelo3Bean bean = new RelatorioContaModelo3Bean();
				helper = contaHelperIterator.next();

				// Sequencial
				bean.setSequencial(String.valueOf(helper.getSequencialImpressao()));
				log.info("............Emitindo conta imóvel: " + helper.getIdImovel().toString());

				// Matrícula
				matriculaImovelFormatada = helper.getIdImovel().toString();
				matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(10,
								"" + Util.retornaMatriculaImovelFormatada(Util.obterInteger(matriculaImovelFormatada)));
				bean.setMatricula(matriculaImovelFormatada);

				// Referência
				referencia = Util.retornaDescricaoAnoMes4Digitos(helper.getAnoMesConta().toString());
				bean.setReferencia(referencia);

				// Responsável
				if(helper.getIdClienteResponsavel() != null && helper.getClienteResponsavel() != null){

					bean.setCodigoResponsavel(helper.getIdClienteResponsavel() + " - " + helper.getClienteResponsavel().getNome());
				}

				// Nome do cliente
				bean.setNomeCliente(helper.getNomeCliente());

				// Endereço do imóvel
				bean.setEnderecoImovel(helper.getEndereco());

				// Quantidade de ecônomias
				if(helper.getEconResidencial() != null){

					bean.setQuantidadeEconomiasResidencial(helper.getEconResidencial().toString());
				}

				if(helper.getEconComercial() != null){

					bean.setQuantidadeEconomiasComercial(helper.getEconComercial().toString());
				}

				if(helper.getEconIndustrial() != null){

					bean.setQuantidadeEconomiasIndustrial(helper.getEconIndustrial().toString());
				}

				if(helper.getEconPublica() != null){

					bean.setQuantidadeEconomiasPublica(helper.getEconPublica().toString());
				}

				// Localidade
				bean.setLocalidade(helper.getDescricaoLocalidade());

				// Setor Comercial
				bean.setSetor(helper.getInscSetorComercial().toString());

				// Quadra
				bean.setQuadra(helper.getInscQuadra().toString());

				// Lote
				if(helper.getInscLote() != null){
					bean.setLote(helper.getInscLote().toString());
				}

				if(helper.getCepImovelFormatado() != null){
					bean.setCep(helper.getCepImovelFormatado());
				}

				if(helper.getHidrometro() != null){

					// Número do hidrômetro
					bean.setNumeroHidrometro(helper.getHidrometro());

					// Data de instalação hidrômetro
					if(helper.getDataInstalacaoHidrometro() != null){
						bean.setDataInstalacaoHidrometro(Util.formatarData(helper.getDataInstalacaoHidrometro()));
					}

					// Marca do hidrômetro
					if(helper.getHidrometroMarca() != null){
						bean.setMarcaHidrometro(helper.getHidrometroMarca().getDescricaoAbreviada());
					}

					// Local de instalação do hidrômetro
					if(helper.getHidrometroLocalInstalacao() != null){
						bean.setLocalInstalacaoHidrometro(helper.getHidrometroLocalInstalacao().getDescricao());
					}

					// Capacidade do hidrômetro
					if(helper.getHidrometroCapacidade() != null){
						bean.setCapacidadeHidrometro(helper.getHidrometroCapacidade().getDescricaoAbreviada());
					}

					// Situação de água
					bean.setSituacaoAgua(helper.getDescricaoLigacaoAguaSituacao());

					// Situação de esgoto
					bean.setSituacaoEsgoto(helper.getDescricaoLigacaoEsgotoSituacao());

					if(helper.getDtLeituraAtual() != null){

						// Data de leitura atual
						bean.setDataLeitura(Util.formatarData(helper.getDtLeituraAtual()));
					}
				}

				// Qualidade da água
				// [SB0031] – Obter Dados da Qualidade Água
				QualidadeAgua qualidadeAgua = repositorioFaturamento.pesquisarQualidadeAguaPorLocalidadeAnoMesFaturamento(
								sistemaParametro.getAnoMesFaturamento(), helper.getInscLocalidade());

				if(qualidadeAgua == null && helper.getCodigoElo() != null){

					qualidadeAgua = repositorioFaturamento.pesquisarQualidadeAguaPorLocalidadeAnoMesFaturamento(
									sistemaParametro.getAnoMesFaturamento(), helper.getCodigoElo());
				}

				QualidadeAguaPadrao qualidadeAguaPadrao = repositorioFaturamento.retornarQualidadeAguaPadrao();

				// Turbidez Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasTurbidez() != null){

					bean.setQualidadeTurbidezExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasTurbidez().toString());
				}

				// Turbidez Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasTurbidez() != null){

					bean.setQualidadeTurbidezRealizada(qualidadeAgua.getNumeroAmostrasRealizadasTurbidez().toString());
				}

				// Turbidez Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesTurbidez() != null){

					bean.setQualidadeTurbidezConforme(qualidadeAgua.getNumeroAmostrasConformesTurbidez().toString());
				}

				// Cor Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasCor() != null){

					bean.setQualidadeCorExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasCor().toString());
				}

				// Cor Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasCor() != null){

					bean.setQualidadeCorRealizada(qualidadeAgua.getNumeroAmostrasRealizadasCor().toString());
				}

				// Cor Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesCor() != null){

					bean.setQualidadeCorConforme(qualidadeAgua.getNumeroAmostrasConformesCor().toString());
				}

				// Cloro Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasCloro() != null){

					bean.setQualidadeCloroExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasCloro().toString());
				}

				// Cloro Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasCloro() != null){

					bean.setQualidadeCloroRealizada(qualidadeAgua.getNumeroAmostrasRealizadasCloro().toString());
				}

				// Cloro Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesCloro() != null){

					bean.setQualidadeCloroConforme(qualidadeAgua.getNumeroAmostrasConformesCloro().toString());
				}

				// Flúor Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasFluor() != null){

					bean.setQualidadeFluorExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasFluor().toString());
				}

				// Flúor Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasFluor() != null){

					bean.setQualidadeFluorRealizada(qualidadeAgua.getNumeroAmostrasRealizadasFluor().toString());
				}

				// Flúor Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesFluor() != null){

					bean.setQualidadeFluorConforme(qualidadeAgua.getNumeroAmostrasConformesFluor().toString());
				}

				// Coliformes Totais Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasColiformesTotais() != null){

					bean.setQualidadeColiformesTotaisExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasColiformesTotais().toString());
				}

				// Coliformes Totais Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasColiformesTotais() != null){

					bean.setQualidadeColiformesTotaisRealizada(qualidadeAgua.getNumeroAmostrasRealizadasColiformesTotais().toString());
				}

				// Coliformes Totais Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesColiformesTotais() != null){

					bean.setQualidadeColiformesTotaisConforme(qualidadeAgua.getNumeroAmostrasConformesColiformesTotais().toString());
				}

				// Coliformes Termotolerantes Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasColiformesTermotolerantes() != null){

					bean.setQualidadeColiformesTermotolerantesRealizada(qualidadeAgua
									.getNumeroAmostrasRealizadasColiformesTermotolerantes().toString());
				}

				// Coliformes Termotolerantes Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesColiformesTermotolerantes() != null){

					bean.setQualidadeColiformesTermotolerantesConforme(qualidadeAgua.getNumeroAmostrasConformesColiformesTermotolerantes()
									.toString());
				}

				// Qualidade Água - Conclusão
				if(qualidadeAgua != null){

					bean.setQualidadeConclusao(qualidadeAgua.getDescricaoConclusaoAnalisesRealizadas());
				}

				// Leitura Anterior
				if(helper.getLeituraAnterior() != null){

					bean.setLeituraAnterior(helper.getLeituraAnterior().toString());
				}

				// Leitura Atual
				if(helper.getLeituraAtual() != null){

					bean.setLeituraAtual(helper.getLeituraAtual().toString());
				}

				// Situação de Leitura
				if(helper.getIdLeituraSituacaoAtual() != null){

					LeituraSituacao leituraSituacao = (LeituraSituacao) getControladorUtil().pesquisar(helper.getIdLeituraSituacaoAtual(),
									LeituraSituacao.class, false);
					bean.setSituacaoLeitura(leituraSituacao.getDescricao());
				}

				// Consumo
				Integer consumoFaturado = 0;

				if(helper.getConsumoFaturado() != null){

					consumoFaturado = helper.getConsumoFaturado();

				}

				bean.setConsumo(consumoFaturado.toString());



				// Périodo Faturamento
				dataLeituraAnterior = "";
				dataLeituraAtual = "";
				if(helper.getDtLeituraAnterior() != null){

					dataLeituraAnterior = Util.formatarData(helper.getDtLeituraAnterior());
				}

				if(helper.getDtLeituraAtual() != null){

					dataLeituraAtual = Util.formatarData(helper.getDtLeituraAtual());
				}

				bean.setPeriodoFaturamento(dataLeituraAnterior + " A " + dataLeituraAtual);

				// Dias de Consumo
				if(helper.getDtLeituraAnterior() != null && helper.getDtLeituraAtual() != null){

					bean.setDiasConsumo(String.valueOf(Util.obterQuantidadeDiasEntreDuasDatas(helper.getDtLeituraAnterior(),
									helper.getDtLeituraAtual())));
				}

				// Média
				// OC - 1361366
				if(helper.getConsumoMedio() != null){

					bean.setMedia(helper.getConsumoMedio().toString());
				}


				// ***************************************************************
				// Código Auxiliar
				String codigoAuxiliar = "";
				if(helper.getIdLeituraSituacaoAtual() != null){
					codigoAuxiliar = helper.getIdLeituraSituacaoAtual().toString();
				}else{
					codigoAuxiliar = "";
				}
				if(helper.getIdConsumoTipo() != null){
					codigoAuxiliar = codigoAuxiliar + helper.getIdConsumoTipo();
				}else{
					codigoAuxiliar = codigoAuxiliar + "";
				}
				if(helper.getIdLeituraAnormalidadeFaturamento() != null){
					codigoAuxiliar = codigoAuxiliar + helper.getIdLeituraAnormalidadeFaturamento();
				}else{
					codigoAuxiliar = codigoAuxiliar + "";
				}
				if(helper.getIdTipoContrato() != null){
					codigoAuxiliar = codigoAuxiliar + helper.getIdTipoContrato();
				}else{
					codigoAuxiliar = codigoAuxiliar + "";
				}
				if(helper.getIdConsumoAnormalidade() != null){
					codigoAuxiliar = codigoAuxiliar + helper.getIdConsumoAnormalidade();
				}else{
					codigoAuxiliar = codigoAuxiliar + "";
				}


				bean.setCodigoAuxiliar(codigoAuxiliar);

				String debitosExercicio = obterUltimosDozeMesesAnterioresReferenciaComContaVencida(helper.getIdImovel(),
								helper.getAnoMesConta());

				System.out.println(debitosExercicio);

				bean.setDebitosExercicio(debitosExercicio);

				// ****************************************************************

				// Condição de Faturamento
				if(helper.getIdConsumoTipo() != null){

					ConsumoTipo consumoTipo = (ConsumoTipo) getControladorUtil().pesquisar(helper.getIdConsumoTipo(), ConsumoTipo.class,
									false);
					bean.setCondicaoFaturamento(consumoTipo.getDescricao());
				}

				// Anormalidade de Leitura
				if(helper.getIdLeituraAnormalidadeFaturamento() != null){

					LeituraAnormalidade leituraAnormalidade = (LeituraAnormalidade) getControladorUtil().pesquisar(
									helper.getIdLeituraAnormalidadeFaturamento(), LeituraAnormalidade.class, false);
					bean.setAnormalidadeLeitura(leituraAnormalidade.getId().toString());
					bean.setDescricaoAnormalidade(leituraAnormalidade.getDescricao());
				}

				/*
				 * Faturas em Atraso ([SB0102 – Obter Débitos] ordenadas por referencia
				 * decrescente
				 * da conta. O limite é de 12(doze) ocorrências, acumulando as demais para o
				 * próximo
				 * campo)
				 */
				obterFaturasEmAtrasoModelo3(anoMesReferencia, bean, helper);

				/*
				 * Últimos Consumos (Histórico de consumo dos últimos 6 meses [SB0004 – Obter
				 * Dados
				 * do Consumo e Medição Anterior])
				 */
				Collection<DadosConsumoAnteriorHelper> colecaoDadosConsumoAnterior = this.obterDadosConsumoAnteriorModelo(
								helper.getIdImovel(), faturamentoGrupo.getAnoMesReferencia(), 6, LigacaoTipo.LIGACAO_AGUA,
								helper.getIdTipoMedicao());

				int indexConsumos = 1;
				for(DadosConsumoAnteriorHelper dadosConsumoAnteriorHelper : colecaoDadosConsumoAnterior){

					Util.executarMetodo(bean, "setReferenciaConsumoMes" + indexConsumos,
									Util.retornaDescricaoAnoMes4Digitos(String.valueOf(dadosConsumoAnteriorHelper.getAnoMesReferencia())));

					if(dadosConsumoAnteriorHelper.getLeitura() != null){

						Util.executarMetodo(bean, "setLeituraMes" + indexConsumos, dadosConsumoAnteriorHelper.getLeitura().toString());
					}

					if(dadosConsumoAnteriorHelper.getIdLeituraAnormalidade() != null){

						Util.executarMetodo(bean, "setAnormalidadeMes" + indexConsumos, dadosConsumoAnteriorHelper
										.getIdLeituraAnormalidade().toString());

					}else if(dadosConsumoAnteriorHelper.getDescricaoAbreviadaConsumAnormalidade() != null){

						Util.executarMetodo(bean, "setAnormalidadeMes" + indexConsumos,
										dadosConsumoAnteriorHelper.getDescricaoAbreviadaConsumAnormalidade());
					}

					Util.executarMetodo(bean, "setConsumoFaturadoMes" + indexConsumos, dadosConsumoAnteriorHelper.getConsumoFaturado()
									.toString());

					indexConsumos++;
				}

				// Faturamento Realizado (Descrição Tarifas/Débitos/Créditos obtidos no SB0105)
				bean.setFaturamentoRealizado(this.gerarLinhasDescricaoTarifasDebitosCreditosModelo(helper));

				// Endereço de Entrega
				if(!Util.isVazioOuBranco(helper.getEnderecoClienteEntrega())){

					bean.setEnderecoClienteEntrega(helper.getEnderecoClienteEntrega());
				}else{

					bean.setEnderecoClienteEntrega(helper.getEndereco());
				}

				// Mensagem [SB0017 – Obter Mensagem da Conta em 3 Partes]
				String mensagemConta = "";
				if(!Util.isVazioOrNulo(helper.getMensagemConta())){

					Object[] mensagens = helper.getMensagemConta();

					if(mensagens[0] != null && !mensagens[0].toString().equals("")){

						if(mensagens[0].toString().length() <= 50){

							mensagemConta += Util.completaString(mensagens[0].toString(), 50);
							mensagemConta += Util.completaString("", 50);
						}else{

							mensagemConta += mensagens[0].toString().substring(0, 50);
							mensagemConta += Util.completaString(mensagens[0].toString().substring(50), 50);
						}
					}else{

						mensagemConta += Util.completaString("", 100);
					}

					if(mensagens[1] != null && !mensagens[1].toString().equals("")){

						if(mensagens[1].toString().length() <= 50){

							mensagemConta += Util.completaString(mensagens[1].toString(), 50);
						}else{

							mensagemConta += mensagens[1].toString().substring(0, 50);
						}
					}else{

						mensagemConta += Util.completaString("", 50);
					}

					if(mensagens[1] != null && !mensagens[1].toString().equals("")){

						if(mensagens[1].toString().length() <= 50){

							mensagemConta += Util.completaString("", 50);
						}else{

							mensagemConta += Util.completaString(mensagens[1].toString().substring(50), 50);
						}
					}else{

						mensagemConta += Util.completaString("", 50);
					}

					bean.setMensagemConta(mensagemConta);

				}

				// Vencimento
				bean.setVencimento(Util.formatarData(helper.getDataVencimento()));

				// Total a Pagar
				bean.setTotalAPagar(Util.formatarMoedaReal(helper.getValorTotalConta(), 2));

				// Inscrição (Local, Setor, Quadra e Lote)
				bean.setInscricao(helper.getInscricao().substring(0, helper.getInscricao().length() - 4));

				// [SB0030] - Gerar Código de Barras
				if((helper.getIndicadorDebitoAutomatico() != null && helper.getIndicadorCodigoBarras() != null)
								&& helper.getIndicadorDebitoAutomatico().equals(ConstantesSistema.NAO)
								&& helper.getIndicadorCodigoBarras().equals(ConstantesSistema.SIM)){

					gerarCodigoDeBarras(helper);
					bean.setRepresentacaoNumericaCodBarraFormatada(Util.completaString(helper.getRepresentacaoNumericaCodBarraFormatada(),
									51));
					bean.setRepresentacaoNumericaCodBarraSemDigito(helper.getRepresentacaoNumericaCodBarraSemDigito());
				}

				// VERSO DA CONTA (Segunda Página)
				RelatorioContaModelo3SubVersoBean beanVerso = new RelatorioContaModelo3SubVersoBean();

				beanVerso.setImagemVerso("imagens/DESO/VersoContaModelo3.gif");

				// beanVerso.setImagemVerso(sistemaParametro.getImagemRelatorio());

				Collection colecaoBeanSubRelatorioVerso = new ArrayList<RelatorioContaModelo3SubVersoBean>();
				colecaoBeanSubRelatorioVerso.add(beanVerso);
				bean.setarBeansSubRelatorioVerso(colecaoBeanSubRelatorioVerso);

				/*
				 * Devido o ModeloConta3.jasper não está dividido por banda
				 * e o subRelatorio está na mesma banda
				 * do relatorio não esta funcionando o contador de pagina
				 */
				pagina++;
				bean.setPagina(String.valueOf(pagina));

				relatorioBeans.add(bean);

			}
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return relatorioBeans;
	}

	/**
	 * [FS0001 - Verificar valor total da conta negativo].
	 * 
	 * @throws ControladorException
	 */

	public Object[] verificarVaorTotalContaNegativo(BigDecimal valorTotalConta, BigDecimal valorTotalCreditos,
					BigDecimal valorTotalSemCreditos, Collection colecaoCreditosRealizados, Usuario usuarioLogado,
					boolean gerarCreditoARealizar) throws ControladorException{

		Object[] retorno = new Object[4];

		Collection colecaoNovosCreditosRealizados = new ArrayList();
		BigDecimal somatorioCreditosRealizadosComCredDevConta = BigDecimal.ZERO;
		Collection colecaoCreditosRealizadosComCredDevConta = new ArrayList();
		Collection colecaoCreditosARealizarComCredDevConta = new ArrayList();

		Iterator it = colecaoCreditosRealizados.iterator();
		while(it.hasNext()){
			CreditoRealizado creditoRealizado = (CreditoRealizado) it.next();
			if(creditoRealizado.getCreditoTipo() != null){
				FiltroCreditoTipoOrigem filtroCreditoTipoOrigem = new FiltroCreditoTipoOrigem();
				filtroCreditoTipoOrigem.limparListaParametros();
				filtroCreditoTipoOrigem.adicionarParametro(new ParametroSimples(FiltroCreditoTipoOrigem.CREDITO_TIPO_ID, creditoRealizado
								.getCreditoTipo().getId()));

				CreditoTipoOrigem creditoTipoOrigem;
				try{
					creditoTipoOrigem = (CreditoTipoOrigem) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(
									filtroCreditoTipoOrigem, CreditoTipoOrigem.class.getName()));

					if(creditoTipoOrigem != null && creditoTipoOrigem.getId().equals(CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO)){
						somatorioCreditosRealizadosComCredDevConta = somatorioCreditosRealizadosComCredDevConta.add(creditoRealizado
										.getValorCredito());
						colecaoCreditosRealizadosComCredDevConta.add(creditoRealizado);
					}

				}catch(ControladorException e){
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}

		// 1. Atribuir o valor 1 (sim) ao Indicador de Comparar Credito Atual com o Anterior.
		Short indicadorCompararCreditoAtualComAnterior = 1;

		// 2. Caso o valor total da conta seja menor que zero:
		if(valorTotalConta.compareTo(BigDecimal.ZERO) < 0){
			// 2.1. Caso nao esteja indicada a geracao de creditos a realizar correspondentes
			// aos
			// creditos de devolucao da conta quando a retificacao gerar um valor de
			// faturamento
			// inferior ao valor dos creditos da conta (PASI_VLPARAMETRO com o valor 2 (nao) na
			// tabela
			// PARAMETRO_SISTEMA com
			// PASI_CDPARAMETRO="P_IND_RETIFICAR_CONTA_COM_DEVOLUCAO_CREDITO_EXCEDENTE") ou
			// [caso
			// esteja
			// indicada a geracao de creditos a realizar correspondentes aos creditos de
			// devolucao
			// da
			// conta quando a retificacao gerar um valor de faturamento inferior ao valor dos
			// creditos
			// da conta (PASI_VLPARAMETRO com o valor 1 (sim) na tabela PARAMETRO_SISTEMA com
			// PASI_CDPARAMETRO="P_IND_RETIFICAR_CONTA_COM_DEVOLUCAO_CREDITO_EXCEDENTE") e os
			// valores
			// dos creditos de devolucao da conta (somatorio dos valores dos creditos
			// realizados com
			// CRTI_ID contido em CRTI_ID da tabela CREDITO_TIPO_ORIGEM com CROG_ID=1 (um)) sejam
			// nulos
			// ou menores que a soma dos valores totais de agua, esgoto e debitos da conta]:

			Short pIndicadorRetificarContaComDevolucaoCreditoExcedente = null;

			try{
				pIndicadorRetificarContaComDevolucaoCreditoExcedente = Util
								.converterStringParaShort((String) ParametroFaturamento.P_IND_RETIFICAR_CONTA_COM_DEVOLUCAO_CREDITO_EXCEDENTE
												.executar());

			}catch(ControladorException e){

				throw new ControladorException("atencao.sistemaparametro_inexistente", null,
								"P_IND_RETIFICAR_CONTA_COM_DEVOLUCAO_CREDITO_EXCEDENTE");
			}

			if(pIndicadorRetificarContaComDevolucaoCreditoExcedente.equals(ConstantesSistema.NAO)
							|| (pIndicadorRetificarContaComDevolucaoCreditoExcedente.equals(ConstantesSistema.SIM) && (Util
											.isVazioOuBrancoOuZero(valorTotalCreditos) || somatorioCreditosRealizadosComCredDevConta
											.compareTo(valorTotalSemCreditos) < 0))){
				// 2.1.1. Gerar uma excecao com a mensagem "Valor total da conta nao pode ser
				// negativo" e
				// retornar para o caso de uso que chamou esta funcionalidade.
				throw new ControladorException("atencao.valor_conta_negativo");

			}else{
				// 2.2. Caso contrario:
				// 2.2.1. Atribuir o valor 2 (nao) ao Indicador de Comparar Credito Atual com o
				// Anterior.
				indicadorCompararCreditoAtualComAnterior = 2;

				// 2.2.2. Abater da Lista dos Creditos Realizados de devolucao (creditos
				// realizados
				// com
				// CRTI_ID contido em CRTI_ID da tabela CREDITO_TIPO_ORIGEM com CROG_ID=1 (um)) o
				// valor dos
				// creditos excedente (valor total dos creditos da conta menos a soma dos valores
				// totais de
				// agua, esgoto e debito), ate que todo o credito excedente tenha sido abatido,
				// e
				// considerar
				// os novos valores dos creditos realizados de devolucao para a conta retificada.
				BigDecimal valorParaAbater = valorTotalSemCreditos;
				BigDecimal valorParaAbaterExcesso = somatorioCreditosRealizadosComCredDevConta;

				Iterator itt = colecaoCreditosRealizadosComCredDevConta.iterator();
				while(itt.hasNext()){

					CreditoRealizado creditoRealizado = (CreditoRealizado) itt.next();

					if(valorParaAbater.compareTo(BigDecimal.ZERO) > 0){

						if(valorParaAbater.compareTo(creditoRealizado.getValorCredito()) < 0
										|| valorParaAbater.compareTo(creditoRealizado.getValorCredito()) == 0){

							valorParaAbaterExcesso = valorParaAbaterExcesso.subtract(valorParaAbater);

							if(gerarCreditoARealizar && valorParaAbater.compareTo(BigDecimal.ZERO) > 0){

								BigDecimal valorExcedente = creditoRealizado.getValorCredito().subtract(valorParaAbater);

								CreditoARealizar creditoARealizar = new CreditoARealizar();
								creditoARealizar.setCreditoTipo(creditoRealizado.getCreditoTipo());
								creditoARealizar.setCreditoOrigem(creditoRealizado.getCreditoOrigem());
								creditoARealizar.setAnoMesReferenciaCredito(creditoRealizado.getAnoMesReferenciaCredito());
								creditoARealizar.setNumeroPrestacaoCredito(new Short("1"));
								creditoARealizar.setCodigoSetorComercial(creditoRealizado.getCodigoSetorComercial());
								creditoARealizar.setNumeroQuadra(creditoRealizado.getNumeroQuadra());
								creditoARealizar.setNumeroLote(creditoRealizado.getNumeroLote());
								creditoARealizar.setNumeroSubLote(creditoRealizado.getNumeroSubLote());
								creditoARealizar.setQuadra(creditoRealizado.getQuadra());
								creditoARealizar.setLocalidade(creditoRealizado.getLocalidade());
								creditoARealizar.setValorCredito(valorExcedente);
								creditoARealizar.setPagamentoHistorico(creditoRealizado.getPagamentoHistorico());
								creditoARealizar.setUltimaAlteracao(new Date());
								creditoARealizar.setLancamentoItemContabil(creditoRealizado.getLancamentoItemContabil());

								// 2.2.3. Para cada credito realizado de devolucao que teve o
								// valor
								// abatido, gerar um
								// credito a realizar de devolucao correspondente com o valor
								// abatido - <<Inclui [UC0194 -
								// Inserir Credito A Realizar].

								colecaoCreditosARealizarComCredDevConta.add(creditoARealizar);
							}

							creditoRealizado.setValorCredito(valorParaAbater);
							creditoRealizado.setUltimaAlteracao(new Date());
							colecaoNovosCreditosRealizados.add(creditoRealizado);
							colecaoCreditosRealizados.remove(creditoRealizado);

							valorParaAbater = BigDecimal.ZERO;

						}else{
							valorParaAbater = valorParaAbater.subtract(creditoRealizado.getValorCredito());
							valorParaAbaterExcesso = valorParaAbaterExcesso.subtract(valorParaAbater);

						}
					}else{

						if(valorParaAbaterExcesso.compareTo(BigDecimal.ZERO) > 0){

							valorParaAbaterExcesso = valorParaAbaterExcesso.subtract(creditoRealizado.getValorCredito());
							if(valorParaAbaterExcesso.compareTo(BigDecimal.ZERO) < 0){
								valorParaAbaterExcesso = BigDecimal.ZERO;
							}

							if(gerarCreditoARealizar){
								CreditoARealizar creditoARealizar = new CreditoARealizar();
								creditoARealizar.setCreditoTipo(creditoRealizado.getCreditoTipo());
								creditoARealizar.setCreditoOrigem(creditoRealizado.getCreditoOrigem());
								creditoARealizar.setAnoMesReferenciaCredito(creditoRealizado.getAnoMesReferenciaCredito());
								creditoARealizar.setNumeroPrestacaoCredito(new Short("1"));
								creditoARealizar.setCodigoSetorComercial(creditoRealizado.getCodigoSetorComercial());
								creditoARealizar.setNumeroQuadra(creditoRealizado.getNumeroQuadra());
								creditoARealizar.setNumeroLote(creditoRealizado.getNumeroLote());
								creditoARealizar.setNumeroSubLote(creditoRealizado.getNumeroSubLote());
								creditoARealizar.setQuadra(creditoRealizado.getQuadra());
								creditoARealizar.setLocalidade(creditoRealizado.getLocalidade());
								creditoARealizar.setValorCredito(creditoRealizado.getValorCredito());
								creditoARealizar.setPagamentoHistorico(creditoRealizado.getPagamentoHistorico());
								creditoARealizar.setUltimaAlteracao(new Date());

								colecaoCreditosARealizarComCredDevConta.add(creditoARealizar);
							}

						}
						colecaoCreditosRealizados.remove(creditoRealizado);
					}

				}

			}

		}

		retorno[0] = indicadorCompararCreditoAtualComAnterior;
		retorno[1] = colecaoCreditosRealizados;
		retorno[2] = colecaoNovosCreditosRealizados;
		retorno[3] = colecaoCreditosARealizarComCredDevConta;

		return retorno;

	}

	public void gerarCreditoARealizarDevolucao(Integer idConta){

		// pesquisa os creditos realizados da conta cancelada
		Collection<CreditoRealizado> creditosRealizados;
		try{
			creditosRealizados = repositorioFaturamento.pesquisarCreditosRealizados(idConta);

			if(creditosRealizados != null && !creditosRealizados.isEmpty()){

				// laco para inserir todos os historicos dos creditos
				// realizados
				for(CreditoRealizado creditoRealizado : creditosRealizados){

					// ......................................................................
					// [SB0004] - Verificar Geracao de Credito A Realizar de Devolucao
					//
					// 1. Caso esteja indicada a geracao de creditos a realizar
					// correspondentes
					// aos creditos de devolucao da conta cancelada (PASI_VLPARAMETRO com o
					// valor 1 (sim) na tabela PARAMETRO_SISTEMA com
					// PASI_CDPARAMETRO="P_IND_CANCELAR_CONTA_COM_DEVOLUCAO_CREDITO"):
					// 1.1. Para cada credito realizado de devolucao excluido (CRTI_ID
					// contido
					// em CRTI_ID da tabela CREDITO_TIPO_ORIGEM com CROG_ID=1 (um)), gerar um
					// credito a realizar de devolucao correspondente - <<Inclui [UC0194 -
					// Inserir Credito A Realizar] passando:
					// ......................................................................

					Short pIndicadorCancelarContaComDevolucaoCredito = null;

					try{
						pIndicadorCancelarContaComDevolucaoCredito = Util
										.converterStringParaShort((String) ParametroFaturamento.P_IND_CANCELAR_CONTA_COM_DEVOLUCAO_CREDITO
														.executar());
					}catch(ControladorException e){
						throw new ControladorException("atencao.sistemaparametro_inexistente", null,
										"P_IND_CANCELAR_CONTA_COM_DEVOLUCAO_CREDITO");
					}

					if(pIndicadorCancelarContaComDevolucaoCredito.equals(ConstantesSistema.SIM)){

						if(creditoRealizado.getCreditoTipo() != null){
							FiltroCreditoTipoOrigem filtroCreditoTipoOrigem = new FiltroCreditoTipoOrigem();
							filtroCreditoTipoOrigem.limparListaParametros();
							filtroCreditoTipoOrigem.adicionarParametro(new ParametroSimples(FiltroCreditoTipoOrigem.CREDITO_TIPO_ID,
											creditoRealizado.getCreditoTipo().getId()));

							CreditoTipoOrigem creditoTipoOrigem;

							creditoTipoOrigem = (CreditoTipoOrigem) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(
											filtroCreditoTipoOrigem, CreditoTipoOrigem.class.getName()));

							if(creditoTipoOrigem != null
											&& creditoTipoOrigem.getId().equals(CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO)){

								// <<Inclui>> [UC0194 - Inserir Credito A Realizar]
								CreditoARealizar creditoARealizar = new CreditoARealizar();
								creditoARealizar.setCreditoTipo(creditoRealizado.getCreditoTipo());
								creditoARealizar.setCreditoOrigem(creditoRealizado.getCreditoOrigem());
								creditoARealizar.setAnoMesReferenciaCredito(creditoRealizado.getAnoMesReferenciaCredito());
								creditoARealizar.setNumeroPrestacaoCredito(new Short("1"));
								creditoARealizar.setCodigoSetorComercial(creditoRealizado.getCodigoSetorComercial());
								creditoARealizar.setNumeroQuadra(creditoRealizado.getNumeroQuadra());
								creditoARealizar.setNumeroLote(creditoRealizado.getNumeroLote());
								creditoARealizar.setNumeroSubLote(creditoRealizado.getNumeroSubLote());
								creditoARealizar.setQuadra(creditoRealizado.getQuadra());
								creditoARealizar.setLocalidade(creditoRealizado.getLocalidade());
								creditoARealizar.setImovel(creditoRealizado.getConta().getImovel());
								creditoARealizar.setValorCredito(creditoRealizado.getValorCredito());
								creditoARealizar.setPagamentoHistorico(creditoRealizado.getPagamentoHistorico());
								creditoARealizar.setUltimaAlteracao(new Date());
								creditoARealizar.setLancamentoItemContabil(creditoRealizado.getLancamentoItemContabil());

								this.inserirCreditoARealizar(creditoRealizado.getConta().getImovel(), creditoARealizar,
												Usuario.USUARIO_BATCH);
							}

						}

					}
					// ......................................................................
				}

			}

		}catch(ErroRepositorioException e1){
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}catch(ControladorException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * [UC0146] Manter Conta
	 * [SB0015] - Alterar Cliente Responsável de um Conjunto de Contas
	 * 
	 * @author Anderson Italo
	 * @date 20/01/2014
	 */
	public void alterarClienteResponsavelConjuntoContas(Collection<Conta> colecaoContas, Cliente clienteResponsavel, Usuario usuarioLogado)
					throws ControladorException{

		try{

			for(Conta conta : colecaoContas){

				ClienteConta clienteContaResponsavelAtualizar = this.pesquisarClienteContaPorTipoRelacao(conta.getId(),
								ClienteRelacaoTipo.RESPONSAVEL);

				if(clienteContaResponsavelAtualizar != null){

					RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.ALTERAR_CLIENTE_RESPONSAVEL_CONJUNTO_CONTAS,
									new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					clienteContaResponsavelAtualizar.setCliente(clienteResponsavel);

					registradorOperacao.registrarOperacao(clienteContaResponsavelAtualizar);

					getControladorUtil().atualizar(clienteContaResponsavelAtualizar);
				}else{

					ClienteConta clienteContaResponsavelInserir = new ClienteConta();

					clienteContaResponsavelInserir.setConta(conta);
					clienteContaResponsavelInserir.setCliente(clienteResponsavel);

					ClienteRelacaoTipo clienteRelacaoTipo = new ClienteRelacaoTipo();
					clienteRelacaoTipo.setId(ClienteRelacaoTipo.RESPONSAVEL);
					clienteContaResponsavelInserir.setClienteRelacaoTipo(clienteRelacaoTipo);

					clienteContaResponsavelInserir.setIndicadorNomeConta(ConstantesSistema.NAO);
					clienteContaResponsavelInserir.setUltimaAlteracao(new Date());

					getControladorUtil().inserir(clienteContaResponsavelInserir);

					RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.ALTERAR_CLIENTE_RESPONSAVEL_CONJUNTO_CONTAS,
									new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacao.registrarOperacao(clienteContaResponsavelInserir);
				}
			}

		}catch(Exception e){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0203] Consultar Débitos
	 * [FS0012] – Verifica existência de imóveis de localidades associadas a concessionárias
	 * diversas
	 * 
	 * @author Anderson Italo
	 * @date 23/02/2013
	 */
	public void verificaExistenciaLocalidadesAssociadaConcessionariasDiversas(String idsContas, String idsGuias, String idsDebitos,
					String idsCreditos) throws ControladorException{

		try{
			Collection colecaoContasAuxiliar = new ArrayList<Object>();

			if(idsContas != null){

				String[] arrayIdConta = idsContas.split(",");
				for(Object idConta : arrayIdConta){

					colecaoContasAuxiliar.add(idConta);

					if((colecaoContasAuxiliar != null && !colecaoContasAuxiliar.isEmpty()) && colecaoContasAuxiliar.size() == 1000){

						Integer quantidadeConcessionarias = repositorioFaturamento
										.verificaExistenciaLocalidadesAssociadaConcessionariasDiversas(colecaoContasAuxiliar, idsGuias,
														idsDebitos, idsCreditos);

						if(quantidadeConcessionarias != null && quantidadeConcessionarias.intValue() > 1){

							throw new ControladorException("atencao.nao_possivel_gerar_extrato_imoveis_concessionarias_diversas");
						}

						colecaoContasAuxiliar.clear();
					}

				}

				if(!colecaoContasAuxiliar.isEmpty()){
					Integer quantidadeConcessionarias = repositorioFaturamento
									.verificaExistenciaLocalidadesAssociadaConcessionariasDiversas(colecaoContasAuxiliar, idsGuias,
													idsDebitos, idsCreditos);

					if(quantidadeConcessionarias != null && quantidadeConcessionarias.intValue() > 1){

						throw new ControladorException("atencao.nao_possivel_gerar_extrato_imoveis_concessionarias_diversas");
					}
				}
			}else{

				Integer quantidadeConcessionarias = repositorioFaturamento.verificaExistenciaLocalidadesAssociadaConcessionariasDiversas(
								colecaoContasAuxiliar, idsGuias, idsDebitos, idsCreditos);

				if(quantidadeConcessionarias != null && quantidadeConcessionarias.intValue() > 1){

					throw new ControladorException("atencao.nao_possivel_gerar_extrato_imoveis_concessionarias_diversas");
				}
			}

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

	}

	// --------------

	/**
	 * [UC0213] Desfazer Parcelamento Debito
	 * Transfere para ativo as contas do histórico
	 * 
	 * @author Vitor Hora
	 * @date 22/08/2008
	 * @author Saulo Lima
	 * @date 20/08/2009
	 *       Remoção do parâmetro não utilizado ParcelamentoItem
	 * @author Saulo Lima
	 * @date 27/08/2009
	 *       Descomentado o código de Inserir a colecaoContaImpostosDeduzidosInserir
	 * @author Yara Souza
	 * @date 01/06/2010
	 *       Correção para casos com mais de uma categoria
	 * @param contasHistorico
	 * @param anoMesFaturamentoSistemaParametro
	 * @throws ControladorException
	 */
	public void transferirContasHistoricoParaConta(Collection<ContaHistorico> contasHistorico, int anoMesFaturamentoSistemaParametro,
					Integer idDebitoCreditoSituacao) throws ControladorException{

		try{
			// cria um objeto da conta
			Conta contaTemp = null;

			Collection colecaoContaInserir = new ArrayList();
			Collection colecaoContaCategoriaInserir = new ArrayList();
			Collection colecaoContaCategoriaConsumoFaixaInserir = new ArrayList();
			Collection colecaoDebitoCobradoInserir = new ArrayList();
			// Collection colecaoDebitoACobrarInserir = new ArrayList();
			Collection colecaoDebitoCobradoCategoriaInserir = new ArrayList();
			// Collection colecaoDebitoACobrarCategoriaInserir = new ArrayList();
			Collection colecaoCreditoRealizadoInserir = new ArrayList();
			Collection colecaoCreditoRealizadoCategoriaInserir = new ArrayList();
			Collection colecaoContaImpostosDeduzidosInserir = new ArrayList();
			Collection colecaoClienteContaInserir = new ArrayList();

			Collection colecaoContasHistoricoRemover = new ArrayList();
			Collection colecaoContaCategoriaHistoricoRemover = new ArrayList();
			Collection colecaoContaCategoriaConsumoFaixaHistoricoRemover = new ArrayList();
			Collection colecaoDebitoCobradoHistoricoRemover = new ArrayList();
			// Collection colecaoDebitoACobrarHistoricoRemover = new ArrayList();
			Collection colecaoDebitoCobradoCategoriaHistoricoRemover = new ArrayList();
			// Collection colecaoDebitoACobrarCategoriaHistoricoRemover = new ArrayList();
			Collection colecaoCreditoRealizadoHistoricoRemover = new ArrayList();
			Collection colecaoCreditoRealizadoCategoriaHistoricoRemover = new ArrayList();
			Collection colecaoContaImpostosDeduzidosHistoricoRemover = new ArrayList();
			Collection colecaoClienteContaHistoricoRemover = new ArrayList();

			if(contasHistorico != null && !contasHistorico.isEmpty()){

				colecaoContasHistoricoRemover.addAll(contasHistorico);
				int cont = 0;
				// laço para criar os históricos das contas canceladas
				for(ContaHistorico contaHistorico : contasHistorico){
					cont++;
					System.out.println("################### GERANDO CONTAS ATIVAS:" + cont + "#########################");

					Integer idConta = contaHistorico.getId();

					DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
					debitoCreditoSituacao.setId(idDebitoCreditoSituacao);

					// seta a conta com os dados da conta histórico
					contaTemp = new Conta();
					ContaGeral contaGeral = new ContaGeral();
					contaGeral.setId(contaHistorico.getId());
					contaTemp.setContaGeral(contaGeral);
					contaTemp.setId(idConta);
					contaTemp.setReferencia(contaHistorico.getAnoMesReferenciaConta());
					contaTemp.setUltimaAlteracao(new Date());
					contaTemp.setImovel(contaHistorico.getImovel());
					contaTemp.setLote(contaHistorico.getLote());
					contaTemp.setSubLote(contaHistorico.getSublote());
					contaTemp.setCodigoSetorComercial(contaHistorico.getSetorComercial());
					contaTemp.setQuadra(contaHistorico.getNumeroQuadra());
					contaTemp.setQuadraConta(new Quadra(contaHistorico.getQuadra().getId()));
					contaTemp.setDigitoVerificadorConta(contaHistorico.getVerificadorConta());
					contaTemp.setIndicadorCobrancaMulta(contaHistorico.getIndicadorCobrancaMulta());
					contaTemp.setIndicadorAlteracaoVencimento(contaHistorico.getIndicadorAlteracaoVencimento());
					contaTemp.setConsumoAgua(contaHistorico.getConsumoAgua());
					contaTemp.setConsumoEsgoto(contaHistorico.getConsumoEsgoto());
					contaTemp.setConsumoRateioAgua(contaHistorico.getConsumoRateioAgua());
					contaTemp.setConsumoRateioEsgoto(contaHistorico.getConsumoRateioEsgoto());
					contaTemp.setValorAgua(contaHistorico.getValorAgua());
					contaTemp.setValorEsgoto(contaHistorico.getValorEsgoto());
					contaTemp.setDebitos(contaHistorico.getValorDebitos());
					contaTemp.setValorCreditos(contaHistorico.getValorCreditos());
					contaTemp.setValorImposto(contaHistorico.getValorImposto());
					contaTemp.setPercentualEsgoto(contaHistorico.getPercentualEsgoto());
					contaTemp.setDataVencimentoConta(contaHistorico.getDataVencimentoConta());
					contaTemp.setDataValidadeConta(contaHistorico.getDataValidadeConta());
					contaTemp.setDataInclusao(contaHistorico.getDataInclusao());
					contaTemp.setDataRevisao(contaHistorico.getDataRevisao());
					contaTemp.setDataRetificacao(contaHistorico.getDataRetificacao());
					contaTemp.setDataCancelamento(contaHistorico.getDataCancelamento());
					contaTemp.setDataEmissao(contaHistorico.getDataEmissao());
					contaTemp.setReferenciaContabil(contaHistorico.getAnoMesReferenciaContabil());
					contaTemp.setReferenciaBaixaContabil(contaHistorico.getAnoMesReferenciaBaixaContabil());
					contaTemp.setLigacaoEsgotoSituacao(contaHistorico.getLigacaoEsgotoSituacao());
					contaTemp.setLigacaoAguaSituacao(contaHistorico.getLigacaoAguaSituacao());
					contaTemp.setMotivoNaoEntregaDocumento(contaHistorico.getMotivoNaoEntregaDocumento());
					contaTemp.setLocalidade(contaHistorico.getLocalidade());
					contaTemp.setContaMotivoInclusao(contaHistorico.getContaMotivoInclusao());
					contaTemp.setContaMotivoRevisao(contaHistorico.getContaMotivoRevisao());
					contaTemp.setContaMotivoRetificacao(contaHistorico.getContaMotivoRetificacao());
					contaTemp.setContaMotivoCancelamento(contaHistorico.getContaMotivoCancelamento());
					contaTemp.setFaturamentoTipo(contaHistorico.getFaturamentoTipo());
					contaTemp.setImovelPerfil(contaHistorico.getImovelPerfil());
					contaTemp.setRegistroAtendimento(contaHistorico.getRegistroAtendimento());
					contaTemp.setConsumoTarifa(contaHistorico.getConsumoTarifa());
					contaTemp.setIndicadorDebitoConta(contaHistorico.getIndicadorDebitoConta());
					contaTemp.setFuncionarioEntrega(contaHistorico.getFuncionarioEntrega());
					contaTemp.setFuncionarioLeitura(contaHistorico.getFuncionarioLeitura());
					contaTemp.setUltimaAlteracao(new Date());
					contaTemp.setUsuario(contaHistorico.getUsuario());

					// Alterado por Eduardo Henrique 09/12/2008
					contaTemp.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
					contaTemp.setDebitoCreditoSituacaoAnterior(null);
					contaTemp.setDocumentoTipo(contaHistorico.getDocumentoTipo());
					contaTemp.setContaBancaria(contaHistorico.getContaBancaria());
					contaTemp.setDataVencimentoOriginal(contaHistorico.getDataVencimentoOriginal());
					contaTemp.setRota(contaHistorico.getRota());
					contaTemp.setIndicadorCobrancaAdministrativa(contaHistorico.getIndicadorCobrancaAdministrativa());
					contaTemp.setIndicadorRemuneraCobrancaAdministrativa(contaHistorico.getIndicadorRemuneraCobrancaAdministrativa());
					contaTemp.setIndicadorDividaAtiva(contaHistorico.getIndicadorDividaAtiva());
					contaTemp.setDataDividaAtiva(contaHistorico.getDataDividaAtiva());
					contaTemp.setIndicadorExecucaoFiscal(contaHistorico.getIndicadorExecucaoFiscal());
					contaTemp.setDataExecucaoFiscal(contaHistorico.getDataExecucaoFiscal());
					contaTemp.setNumeroProcessoAdministrativoExecucaoFiscal(contaHistorico.getNumeroProcessoAdministrativoExecucaoFiscal());

					colecaoContaInserir.add(contaTemp);

					// ************CONTA CATEGORIA HISTORICO ***********************************
					Collection<ContaCategoriaHistorico> colecaoContaCategoriaHistorico = repositorioFaturamento
									.pesquisarContaCategoriaHistorico(idConta);

					ContaCategoria contaCategoriaTemp = null;

					if(colecaoContaCategoriaHistorico != null && !colecaoContaCategoriaHistorico.isEmpty()){

						colecaoContaCategoriaHistoricoRemover.addAll(colecaoContaCategoriaHistorico);

						for(ContaCategoriaHistorico contaContaCategoriaHistorico : colecaoContaCategoriaHistorico){
							contaCategoriaTemp = new ContaCategoria();
							contaCategoriaTemp.setComp_id(new ContaCategoriaPK(contaTemp, contaContaCategoriaHistorico.getComp_id()
											.getCategoria()));
							contaCategoriaTemp.getComp_id().setSubcategoria(contaContaCategoriaHistorico.getComp_id().getSubcategoria());
							contaCategoriaTemp.setConsumoAgua(contaContaCategoriaHistorico.getConsumoAgua());
							contaCategoriaTemp.setConsumoEsgoto(contaContaCategoriaHistorico.getConsumoEsgoto());
							contaCategoriaTemp.setConsumoMinimoAgua(contaContaCategoriaHistorico.getConsumoMinimoAgua());
							contaCategoriaTemp.setConsumoMinimoEsgoto(contaContaCategoriaHistorico.getConsumoMinimoEsgoto());
							contaCategoriaTemp.setQuantidadeEconomia(contaContaCategoriaHistorico.getQuantidadeEconomia());
							contaCategoriaTemp.setUltimaAlteracao(new Date());
							contaCategoriaTemp.setValorAgua(contaContaCategoriaHistorico.getValorAgua());
							contaCategoriaTemp.setValorEsgoto(contaContaCategoriaHistorico.getValorEsgoto());
							contaCategoriaTemp.setValorTarifaMinimaAgua(contaContaCategoriaHistorico.getValorTarifaMinimaAgua());
							contaCategoriaTemp.setValorTarifaMinimaEsgoto(contaContaCategoriaHistorico.getValorTarifaMinimaEsgoto());

							colecaoContaCategoriaInserir.add(contaCategoriaTemp);

							// Alterado por Yara Souza 01/06/2010 -- Correção para casos com mais de
							// 1 categoria
							// ************************CONTA CATEGORIA CONSUMO FAIXA
							// *************************************
							Collection<ContaCategoriaConsumoFaixaHistorico> colecaoContaCategoriaConsumoFaixaHistorico = this.repositorioFaturamento
											.pesquisarContaCategoriaConsumoFaixaHistorico(idConta, contaCategoriaTemp.getComp_id()
															.getCategoria().getId());

							ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixaTemp = null;

							if(colecaoContaCategoriaConsumoFaixaHistorico != null && !colecaoContaCategoriaConsumoFaixaHistorico.isEmpty()){

								colecaoContaCategoriaConsumoFaixaHistoricoRemover.addAll(colecaoContaCategoriaConsumoFaixaHistorico);

								for(ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistorico : colecaoContaCategoriaConsumoFaixaHistorico){
									contaCategoriaConsumoFaixaTemp = new ContaCategoriaConsumoFaixa();
									contaCategoriaConsumoFaixaTemp.setId(contaCategoriaConsumoFaixaHistorico.getId());
									contaCategoriaConsumoFaixaTemp.setConsumoAgua(contaCategoriaConsumoFaixaHistorico.getConsumoAgua());
									contaCategoriaConsumoFaixaTemp.setConsumoEsgoto(contaCategoriaConsumoFaixaHistorico.getConsumoEsgoto());
									contaCategoriaConsumoFaixaTemp.setConsumoFaixaFim(contaCategoriaConsumoFaixaHistorico
													.getConsumoFaixaFim());
									contaCategoriaConsumoFaixaTemp.setConsumoFaixaInicio(contaCategoriaConsumoFaixaHistorico
													.getConsumoFaixaInicio());
									contaCategoriaConsumoFaixaTemp.setContaCategoria(contaCategoriaTemp);
									contaCategoriaConsumoFaixaTemp.setUltimaAlteracao(new Date());
									contaCategoriaConsumoFaixaTemp.setValorAgua(contaCategoriaConsumoFaixaHistorico.getValorAgua());
									contaCategoriaConsumoFaixaTemp.setValorEsgoto(contaCategoriaConsumoFaixaHistorico.getValorEsgoto());
									contaCategoriaConsumoFaixaTemp.setCategoria(contaCategoriaConsumoFaixaHistorico.getCategoria());
									contaCategoriaConsumoFaixaTemp.setSubcategoria(contaCategoriaConsumoFaixaHistorico.getSubcategoria());
									contaCategoriaConsumoFaixaTemp.setValorTarifaFaixa(contaCategoriaConsumoFaixaHistorico
													.getValorTarifaFaixa());

									colecaoContaCategoriaConsumoFaixaInserir.add(contaCategoriaConsumoFaixaTemp);
								}
							}
							// ************************FIM CONTA CATEGORIA CONSUMO FAIXA
							// *********************************

						}
					}

					// ********************* FIM CONTA CATEGORIA****************************

					// ************************ DEBITO COBRADO HISTORICO
					// *********************************

					// pesquisa os débitos cobrados para a conta atual
					Collection<DebitoCobradoHistorico> debitosCobradosHistorico;

					// debitosCobradosHistorico =
					// repositorioFaturamento.pesquisarDebitosCobradosHistoricoPorMesAnoReferenciaContabil(anoMesFaturamentoSistemaParametro,
					// idConta);
					debitosCobradosHistorico = repositorioFaturamento.pesquisarDebitosCobradosHistorico(idConta);

					// cria o objeto débito cobrado histórico
					DebitoCobrado debitoCobradoTemp = null;

					if(debitosCobradosHistorico != null && !debitosCobradosHistorico.isEmpty()){

						colecaoDebitoCobradoHistoricoRemover.addAll(debitosCobradosHistorico);

						// laço para criar o histórico dos débitos cobrados da conta
						for(DebitoCobradoHistorico debitoCobradoHistorico : debitosCobradosHistorico){
							// seta os dados do débito cobrado histórico
							debitoCobradoTemp = new DebitoCobrado();
							debitoCobradoTemp.setId(debitoCobradoHistorico.getId());
							debitoCobradoTemp.setDebitoCobrado(debitoCobradoHistorico.getDebitoCobrado());
							/*
							 * debitoCobradoHistoricoTemp
							 * .setDebitoCobradoHistorico(new Date());
							 */
							debitoCobradoTemp.setCodigoSetorComercial(debitoCobradoHistorico.getCodigoSetorComercial());
							debitoCobradoTemp.setNumeroQuadra(debitoCobradoHistorico.getNumeroQuadra());
							debitoCobradoTemp.setNumeroLote(debitoCobradoHistorico.getNumeroLote());
							debitoCobradoTemp.setNumeroSubLote(debitoCobradoHistorico.getNumeroSubLote());
							debitoCobradoTemp.setAnoMesReferenciaDebito(debitoCobradoHistorico.getAnoMesReferenciaDebito());
							debitoCobradoTemp.setAnoMesCobrancaDebito(debitoCobradoHistorico.getAnoMesCobrancaDebito());
							debitoCobradoTemp.setValorPrestacao(debitoCobradoHistorico.getValorPrestacao());
							debitoCobradoTemp.setNumeroPrestacao(debitoCobradoHistorico.getNumeroPrestacao());
							debitoCobradoTemp.setNumeroPrestacaoDebito(debitoCobradoHistorico.getNumeroPrestacaoDebito());
							debitoCobradoTemp.setUltimaAlteracao(new Date());
							debitoCobradoTemp.setFinanciamentoTipo(debitoCobradoHistorico.getFinanciamentoTipo());
							debitoCobradoTemp.setQuadra(debitoCobradoHistorico.getQuadra());
							debitoCobradoTemp.setLocalidade(debitoCobradoHistorico.getLocalidade());
							debitoCobradoTemp.setConta(contaTemp);
							debitoCobradoTemp.setDebitoTipo(debitoCobradoHistorico.getDebitoTipo());
							debitoCobradoTemp.setLancamentoItemContabil(debitoCobradoHistorico.getLancamentoItemContabil());
							debitoCobradoTemp.setParcelamentoGrupo(debitoCobradoHistorico.getParcelamentoGrupo());
							debitoCobradoTemp.setIndicadorRemuneraCobrancaAdministrativa(debitoCobradoHistorico
											.getIndicadorRemuneraCobrancaAdministrativa());
							debitoCobradoTemp.setNumeroProcessoAdministrativoExecucaoFiscal(debitoCobradoHistorico
											.getNumeroProcessoAdministrativoExecucaoFiscal());

							colecaoDebitoCobradoInserir.add(debitoCobradoTemp);

							Collection<DebitoCobradoCategoriaHistorico> colecaoDebitoCobradoCategoriaHistorico = this.repositorioFaturamento
											.pesquisarDebitoCobradoCategoriaHistorico(debitoCobradoHistorico.getId());

							if(colecaoDebitoCobradoCategoriaHistorico != null && !colecaoDebitoCobradoCategoriaHistorico.isEmpty()){

								colecaoDebitoCobradoCategoriaHistoricoRemover.addAll(colecaoDebitoCobradoCategoriaHistorico);

								for(DebitoCobradoCategoriaHistorico debitoCobradoCategoriaHistorico : colecaoDebitoCobradoCategoriaHistorico){
									DebitoCobradoCategoria debitoCobradoCategoria = new DebitoCobradoCategoria();
									// Alterado por Eduardo Henrique 09/12/2008 -- Mudança para não
									// adicionar +1 no id do Débito Cobrado
									debitoCobradoCategoria.setComp_id(new DebitoCobradoCategoriaPK(debitoCobradoCategoriaHistorico
													.getCategoria(), debitoCobradoTemp));
									debitoCobradoCategoria.setCategoria(debitoCobradoCategoriaHistorico.getCategoria());
									debitoCobradoCategoria.setDebitoCobrado(debitoCobradoTemp);
									debitoCobradoCategoria.setQuantidadeEconomia(debitoCobradoCategoriaHistorico.getQuantidadeEconomia());
									debitoCobradoCategoria.setUltimaAlteracao(new Date());
									debitoCobradoCategoria.setValorCategoria(debitoCobradoCategoriaHistorico.getValorCategoria());

									colecaoDebitoCobradoCategoriaInserir.add(debitoCobradoCategoria);
								}
							}
						}
					}

					// ************************FIM DEBITO COBRADO HISTORICO
					// *********************************

					// pesquisa os créditos realizados da conta cancelada historico
					// Collection<CreditoRealizadoHistorico> creditosRealizadosHistorico =
					// repositorioFaturamento.pesquisarCreditosRealizadosCanceladosPorMesAnoReferenciaContabilHistorico(anoMesFaturamentoSistemaParametro,idConta);
					Collection<CreditoRealizadoHistorico> creditosRealizadosHistorico = repositorioFaturamento
									.pesquisarCreditosRealizadosHistorico(idConta);

					// cria o crédito realizados
					CreditoRealizado creditoRealizadoTemp = null;

					if(creditosRealizadosHistorico != null && !creditosRealizadosHistorico.isEmpty()){

						colecaoCreditoRealizadoHistoricoRemover.addAll(creditosRealizadosHistorico);

						// laço para inserir todos os históricos dos créditos realizados
						for(CreditoRealizadoHistorico creditoRealizadoHistorico : creditosRealizadosHistorico){

							// cria o histórico do crédito realizado da conta cancelada
							creditoRealizadoTemp = new CreditoRealizado();
							creditoRealizadoTemp.setId(creditoRealizadoHistorico.getId());
							creditoRealizadoTemp.setDataHoraCreditoRealizado(creditoRealizadoHistorico.getDataHoraCreditoRealizado());
							/*
							 * creditoRealizadoHistoricoTemp
							 * .setGeracaoHistoricoCredito(new Date());
							 */
							creditoRealizadoTemp.setCodigoSetorComercial(creditoRealizadoHistorico.getCodigoSetorComercial());
							creditoRealizadoTemp.setNumeroQuadra(creditoRealizadoHistorico.getNumeroQuadra());
							creditoRealizadoTemp.setNumeroLote(creditoRealizadoHistorico.getNumeroLote());
							creditoRealizadoTemp.setNumeroSubLote(creditoRealizadoHistorico.getNumeroSubLote());
							creditoRealizadoTemp.setAnoMesReferenciaCredito(creditoRealizadoHistorico.getAnoMesReferenciaCredito());
							creditoRealizadoTemp.setAnoMesCobrancaCredito(creditoRealizadoHistorico.getAnoMesCobrancaCredito());
							creditoRealizadoTemp.setValorCredito(creditoRealizadoHistorico.getValorCredito());
							creditoRealizadoTemp.setNumeroPrestacao(creditoRealizadoHistorico.getNumeroPrestacao());
							creditoRealizadoTemp.setNumeroPrestacaoCredito(creditoRealizadoHistorico.getNumeroPrestacaoCredito());
							creditoRealizadoTemp.setUltimaAlteracao(new Date());
							creditoRealizadoTemp.setQuadra(creditoRealizadoHistorico.getQuadra());
							creditoRealizadoTemp.setLocalidade(creditoRealizadoHistorico.getLocalidade());
							creditoRealizadoTemp.setCreditoTipo(creditoRealizadoHistorico.getCreditoTipo());
							creditoRealizadoTemp.setConta(contaTemp);
							creditoRealizadoTemp.setLancamentoItemContabil(creditoRealizadoHistorico.getLancamentoItemContabil());
							creditoRealizadoTemp.setCreditoOrigem(creditoRealizadoHistorico.getCreditoOrigem());
							creditoRealizadoTemp.setParcelamento(creditoRealizadoHistorico.getParcelamento());

							colecaoCreditoRealizadoInserir.add(creditoRealizadoTemp);

							Collection<CreditoRealizadoCategoriaHistorico> colecaoCreditoRealizadoCategoriaHistorico = this.repositorioFaturamento
											.pesquisarCreditoRealizadoCategoriaHistorico(creditoRealizadoHistorico.getId());

							if(colecaoCreditoRealizadoCategoriaHistorico != null && !colecaoCreditoRealizadoCategoriaHistorico.isEmpty()){

								colecaoCreditoRealizadoCategoriaHistoricoRemover.addAll(colecaoCreditoRealizadoCategoriaHistorico);

								for(CreditoRealizadoCategoriaHistorico creditoRelizadoCategoriaHistorico : colecaoCreditoRealizadoCategoriaHistorico){
									CreditoRealizadoCategoria creditoRealizadoCategoria = new CreditoRealizadoCategoria();
									creditoRealizadoCategoria.setComp_id(new CreditoRealizadoCategoriaPK(creditoRealizadoTemp,
													creditoRelizadoCategoriaHistorico.getCategoria()));
									creditoRealizadoCategoria.setCategoria(creditoRelizadoCategoriaHistorico.getCategoria());
									creditoRealizadoCategoria.setCreditoRealizado(creditoRealizadoTemp);
									creditoRealizadoCategoria.setQuantidadeEconomia(creditoRelizadoCategoriaHistorico
													.getQuantidadeEconomia());
									creditoRealizadoCategoria.setUltimaAlteracao(new Date());
									creditoRealizadoCategoria.setValorCategoria(creditoRelizadoCategoriaHistorico.getValorCategoria());

									colecaoCreditoRealizadoCategoriaInserir.add(creditoRealizadoCategoria);
								}
							}
						}
					}

					Collection<ContaImpostosDeduzidosHistorico> colecaoContaImpostosDeduzidosHistorico = this.repositorioFaturamento
									.pesquisarContaImpostosDeduzidosHistorico(idConta);

					ContaImpostosDeduzidos contaImpostosDeduzidosTemp = null;

					if(colecaoContaImpostosDeduzidosHistorico != null && !colecaoContaImpostosDeduzidosHistorico.isEmpty()){

						colecaoContaImpostosDeduzidosHistoricoRemover.addAll(colecaoContaImpostosDeduzidosHistorico);

						for(ContaImpostosDeduzidosHistorico contaImpostosDeduzidosHistorico : colecaoContaImpostosDeduzidosHistorico){
							contaImpostosDeduzidosTemp = new ContaImpostosDeduzidos();
							// contaImpostosDeduzidosTemp.setId(contaImpostosDeduzidosHistorico.getId());
							contaImpostosDeduzidosTemp.setConta(contaTemp);
							contaImpostosDeduzidosTemp.setImpostoTipo(contaImpostosDeduzidosHistorico.getImpostoTipo());
							contaImpostosDeduzidosTemp.setPercentualAliquota(contaImpostosDeduzidosHistorico.getPercentualAliquota());
							contaImpostosDeduzidosTemp.setUltimaAlteracao(new Date());
							contaImpostosDeduzidosTemp.setValorImposto(contaImpostosDeduzidosHistorico.getValorImposto());
							contaImpostosDeduzidosTemp.setValorBaseCalculo(contaImpostosDeduzidosHistorico.getValorBaseCalculo());

							colecaoContaImpostosDeduzidosInserir.add(contaImpostosDeduzidosTemp);
						}
					}
					// ************* FIM CONTA IMPOSTOS DEDUZIDOS
					// *****************************************************

					// ************ CLIENTE CONTA ***********************************
					Collection<ClienteContaHistorico> colecaoClienteContaHistorico = repositorioFaturamento
									.pesquisarClienteContaHistorico(idConta);

					ClienteConta clienteContaTemp = null;

					if(colecaoClienteContaHistorico != null && !colecaoClienteContaHistorico.isEmpty()){

						colecaoClienteContaHistoricoRemover.addAll(colecaoClienteContaHistorico);

						for(ClienteContaHistorico clienteContaHistorico : colecaoClienteContaHistorico){
							clienteContaTemp = new ClienteConta();
							clienteContaTemp.setId(clienteContaHistorico.getId());
							clienteContaTemp.setCliente(clienteContaHistorico.getCliente());
							clienteContaTemp.setClienteRelacaoTipo(clienteContaHistorico.getClienteRelacaoTipo());
							clienteContaTemp.setConta(contaTemp);
							clienteContaTemp.setIndicadorNomeConta(clienteContaHistorico.getIndicadorNomeConta());
							clienteContaTemp.setUltimaAlteracao(new Date());

							colecaoClienteContaInserir.add(clienteContaTemp);
						}
					}

					// *********************FIM CLIENTE CONTA ****************************

					// *********************DEBITO A COBRAR *******************************

					// Collection<DebitoACobrarHistorico> colecaoDebitoACobrarHistorico =
					// repositorioFaturamento.pesquisarCreditoARealizarHistorico(contaTemp.getImovel().getId(),
					// anoMesFaturamentoSistemaParametro);

					// this.transferirCreditoARealizarHistoricoParaAtivo(colecaoDebitoACobrarHistorico);

					// **********************FIM DEBTIRO A COBRAR***************************

					System.out.println("################### ATUALIZA CONTA GERAL #########################");

					// Atualiza conta geral para indicar que conta está ativa
					contaGeral.setId(contaTemp.getId());
					contaGeral.setIndicadorHistorico(Short.valueOf("2"));
					contaGeral.setUltimaAlteracao(Calendar.getInstance().getTime());
					getControladorUtil().atualizar(contaGeral);
				}// fim conta
			}

			/*
			 * Remove as contas , débitos a cobrar e créditos a realizar que
			 * iram para o histórico e remove todos os objetos relacionados com
			 * eles.
			 */

			System.out.println("################### REMOVENDO CONTAS  CATEGORIA CONSUMO FAIXA HISTORICO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoContaCategoriaConsumoFaixaHistoricoRemover);

			// System.out.println("################### REMOVENDO DEBITO A COBRAR CATEGORIA HISTORICO #########################");
			// getControladorBatch().removerColecaoObjetoParaBatch(colecaoDebitoACobrarCategoriaHistoricoRemover);
			//
			// System.out.println("################### REMOVENDO DEBITO A COBRAR HISTORICO#########################");
			// getControladorBatch().removerColecaoObjetoParaBatch(colecaoDebitoACobrarHistoricoRemover);

			System.out.println("################### REMOVENDO DEBITO COBRADO CATEGORIA HISTORICO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoDebitoCobradoCategoriaHistoricoRemover);

			System.out.println("################### REMOVENDO DEBITO COBRADO HISTORICO#########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoDebitoCobradoHistoricoRemover);

			System.out.println("################### REMOVENDO CREDITO REALIZADO CATEGORIA HISTORICO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoCreditoRealizadoCategoriaHistoricoRemover);

			System.out.println("################### REMOVENDO CREDITO REALIZADO HISTORICO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoCreditoRealizadoHistoricoRemover);

			System.out.println("################### REMOVENDO CONTAS IMPOSTOS DEDUZIDOS HISTORICO#########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoContaImpostosDeduzidosHistoricoRemover);

			System.out.println("################### REMOVENDO CONTAS CATEGORIA HISTORICO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoContaCategoriaHistoricoRemover);

			System.out.println("################### REMOVENDO CLIENTE CONTA HISTORICO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoClienteContaHistoricoRemover);

			System.out.println("################### REMOVENDO CONTAS HISTORICO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoContasHistoricoRemover);

			/*
			 * Transfere para o histórico as contas, debitos a cobrar e créditos
			 * a realizar junto com os objetos a eles relacionados.
			 */

			System.out.println("################### TRANSFERINDO CONTAS HISTORICO  PARA ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaInserir);

			System.out.println("################### TRANSFERINDO CONTAS CATEGORIA PARA O ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoriaInserir);

			System.out.println("################### TRANSFERINDO CLIENTE CONTA PARA O ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoClienteContaInserir);

			System.out.println("################### TRANSFERINDO CONTAS CATEGORIA CONSUMO FAIXA PARA O ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoriaConsumoFaixaInserir);

			System.out.println("################### TRANSFERINDO DEBITO COBRADO PARA O ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoCobradoInserir);

			System.out.println("################### TRANSFERINDO DEBITO COBRADO CATEGORIA PARA ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoCobradoCategoriaInserir);

			// System.out.println("################### TRANSFERINDO DEBITO A COBRAR PARA O ATIVO #########################");
			// getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoACobrarInserir);
			//
			// System.out.println("################### TRANSFERINDO DEBITO A COBRAR CATEGORIA PARA ATIVO #########################");
			// getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoACobrarCategoriaInserir);

			System.out.println("################### TRANSFERINDO CREDITO REALIZADO PARA O ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoRealizadoInserir);

			System.out.println("################### TRANSFERINDO CREDITO REALIZADO CATEGORIA PARA O ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoRealizadoCategoriaInserir);

			System.out.println("################### TRANSFERINDO CONTAS IMPOSTOS DEDUZIDOS PARA O ATIVO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaImpostosDeduzidosInserir);
			// fim item 6

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0146] Manter Conta
	 * [FS0035] Verificar vencimento débito automático
	 * 
	 * @author Hebert Falcão
	 * @date 08/08/2013
	 */
	public void verificarVencimentoContaDebitoAutomatico(Conta conta) throws ControladorException{

		if(conta != null){
			Short indicadorDebitoConta = conta.getIndicadorDebitoConta();

			String pValidarVencimentoDebitoAutomatico = (String) ParametroFaturamento.P_VALIDAR_VENCIMENTO_RETIFICACAO_DEBITO_AUTOMATICO
							.executar();

			String pQtdDiasVencimentoDebitoAutomaticoStr = (String) ParametroFaturamento.P_QUANTIDADE_DIAS_VENCIMENTO_DEBITO_AUTOMATICO
							.executar();

			if(indicadorDebitoConta != null && indicadorDebitoConta.equals(ConstantesSistema.SIM)
							&& !Util.isVazioOuBranco(pValidarVencimentoDebitoAutomatico)
							&& pValidarVencimentoDebitoAutomatico.equals(ConstantesSistema.SIM.toString())
							&& !Util.isVazioOuBranco(pQtdDiasVencimentoDebitoAutomaticoStr)){

				Date dataVencimentoConta = conta.getDataVencimentoConta();

				Integer pQtdDiasVencimentoDebitoAutomatico = Integer.valueOf(pQtdDiasVencimentoDebitoAutomaticoStr);

				Date dataAtual = new Date();

				Date dataCalculada = Util.adicionarNumeroDiasDeUmaData(dataAtual, pQtdDiasVencimentoDebitoAutomatico);

				if(Util.compararData(dataVencimentoConta, dataAtual) >= 0 && Util.compararData(dataVencimentoConta, dataCalculada) <= 0){
					throw new ControladorException("atencao.conta_debito_automatico_sem_tempo_habil");
				}
			}
		}
	}

	/**
	 * Este método foi criado apenas para carater de ajuste de um probelma que ocorreu na DESO e na
	 * CASAL onde algumas contas que foram faturadas no faturamento imediato ficaram com a
	 * tarifa errada.
	 * Quando o usuário tentar retificar alguma dessas contas já será exibida na tela a tarifa que
	 * seria a correta na época que ocorreu o faturamento.
	 * 
	 * @data 29/08/2013
	 */
	public void verificarContaComTarifaErradaAjusteFaturamento(Conta conta) throws ControladorException{

		// Caso a conta seja do período que ocorreu o problema das contas faturadas com tarifa
		// errada
		if(conta.getReferencia() >= 201306 && conta.getReferencia() <= 201308
						&& conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.NORMAL)){

			FiltroMovimentoRoteiroEmpresa filtroMovimentoRoteiroEmpresa = new FiltroMovimentoRoteiroEmpresa();
			filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.IMOVEL_ID, conta
							.getImovel().getId()));
			filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO, conta
							.getReferencia()));
			filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.INDICADOR_FASE,
							MovimentoRoteiroEmpresa.FASE_PROCESSADO));

			Collection colecaoMovimentoRoteiroEmpresa = getControladorUtil().pesquisar(filtroMovimentoRoteiroEmpresa,
							MovimentoRoteiroEmpresa.class.getName());
			MovimentoRoteiroEmpresa movimentoRoteiroImovel = (MovimentoRoteiroEmpresa) Util
							.retonarObjetoDeColecao(colecaoMovimentoRoteiroEmpresa);

			// Caso exista movimento roteiro empresa com a fase 2, ou seja, foi faturada pelo GSAN
			// já implantado na CASAL e na DESO
			if(movimentoRoteiroImovel != null){

				boolean houveEstouroConsumoCasal = false;
				if(movimentoRoteiroImovel.getConsumoAnormalidade() != null
								&& (movimentoRoteiroImovel.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.ESTOURO_CONSUMO) || movimentoRoteiroImovel
												.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.ESTOURO_ACUM_ACIMA_TETO))){

					if(conta.getContaMotivoRevisao() != null && conta.getContaMotivoRevisao().getId().intValue() == 30){

						houveEstouroConsumoCasal = true;
					}
				}

				// Não trata imóveis que tiverão estouro de consumo e estão com conta retida na
				// CASAl e não trata essa matrícula específica da casal que faturou o mês 07 com
				// consumo errado
				if(houveEstouroConsumoCasal == false && !(conta.getImovel().getId().intValue() == 62260)){

					Imovel imovel = getControladorImovel().pesquisarImovel(conta.getImovel().getId());

					// Caso o imóvel tivesse tarifa temporária válida no dia que rodou a volta do
					// faturamento
					if(imovel.getConsumoTarifaTemporaria() != null){
						if(!Util.isVazioOuBranco(imovel.getDataValidadeTarifaTemporaria())
								&& !Util.isVazioOuBranco(movimentoRoteiroImovel.getUltimaAlteracao())
										&& Util.compararData(imovel.getDataValidadeTarifaTemporaria(),
														movimentoRoteiroImovel.getUltimaAlteracao()) >= 0){

							// Caso a tarifa da conta esteja diferente da tarifa do movimento e a
							// tarifa
							// do movimento seja a tarifa temporária
							if(!conta.getConsumoTarifa().getId().equals(movimentoRoteiroImovel.getConsumoTarifa().getId())
											&& movimentoRoteiroImovel.getConsumoTarifa().getId()
															.equals(imovel.getConsumoTarifaTemporaria().getId())){

								// Caso o valor de água/esgoto da conta esteja igual o valor do
								// movimento
								if(movimentoRoteiroImovel.getValorAgua().equals(conta.getValorAgua())
												&& movimentoRoteiroImovel.getValorEsgoto().equals(conta.getValorEsgoto())){

									// Caso a tarifa temporária não seja social
									if(imovel.getConsumoTarifaTemporaria().getId().intValue() != 4){

										conta.setConsumoTarifa(movimentoRoteiroImovel.getConsumoTarifa());
									}else{

										int consumoMinimoLigacao = this.obterConsumoMinimoLigacaoInformadoTarifa(imovel, 4);

										if(conta.getConsumoAgua() != null && (conta.getConsumoAgua().intValue() > consumoMinimoLigacao)){

											conta.setConsumoTarifa(imovel.getConsumoTarifa());
										}else{

											conta.setConsumoTarifa(movimentoRoteiroImovel.getConsumoTarifa());
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [] - Gerar Relatório Maiores Consumidores
	 * 
	 * @author Victon Santos
	 * @created
	 * @throws ControladorException
	 */
	public Collection<RelatorioMaioresConsumidoresHelper> pesquisarDadosRelatorioMaioresConsumidores(Integer anoMes, Integer localidade,
					Integer registros) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoRelatorioMaioresConsumidores = null;

		try{
			colecaoRelatorioMaioresConsumidores = repositorioFaturamento.pesquisarDadosRelatorioMaioresConsumidores(anoMes, localidade,
							registros);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoRelatorioMaioresConsumidores != null && !colecaoRelatorioMaioresConsumidores.isEmpty()){

			Iterator colecaoMaioresConsumidoresIterator = colecaoRelatorioMaioresConsumidores.iterator();

			while(colecaoMaioresConsumidoresIterator.hasNext()){

				Object[] dadosMaioresConsumidores = (Object[]) colecaoMaioresConsumidoresIterator.next();

				RelatorioMaioresConsumidoresHelper relatorioMaioresConsumidoresHelper = new RelatorioMaioresConsumidoresHelper();

				if(dadosMaioresConsumidores[0] != null){
					relatorioMaioresConsumidoresHelper.setReferencia((BigDecimal) dadosMaioresConsumidores[0]);

				}
				if(dadosMaioresConsumidores[1] != null){
					relatorioMaioresConsumidoresHelper.setLocalidade((String) dadosMaioresConsumidores[1]);
				}
				if(dadosMaioresConsumidores[2] != null){
					relatorioMaioresConsumidoresHelper.setSetor((BigDecimal) dadosMaioresConsumidores[2]);
				}
				if(dadosMaioresConsumidores[3] != null){
					relatorioMaioresConsumidoresHelper.setQuadra((BigDecimal) dadosMaioresConsumidores[3]);
				}
				if(dadosMaioresConsumidores[4] != null){
					relatorioMaioresConsumidoresHelper.setTipo((String) dadosMaioresConsumidores[4]);
				}
				if(dadosMaioresConsumidores[5] != null){
					relatorioMaioresConsumidoresHelper.setMatricula((BigDecimal) dadosMaioresConsumidores[5]);
				}
				if(dadosMaioresConsumidores[6] != null){
					relatorioMaioresConsumidoresHelper.setNome((String) dadosMaioresConsumidores[6]);
				}
				if(dadosMaioresConsumidores[7] != null){
					relatorioMaioresConsumidoresHelper.setConsumo((BigDecimal) dadosMaioresConsumidores[7]);
				}
				if(dadosMaioresConsumidores[8] != null){
					relatorioMaioresConsumidoresHelper.setValorConta((BigDecimal) dadosMaioresConsumidores[8]);
				}

				retorno.add(relatorioMaioresConsumidoresHelper);
			}
		}

		return retorno;
	}

	public Collection<RelatorioMaioresDevedoresHelper> pesquisarDadosRelatorioMaioresDevedores(Integer localidade, Integer registros,
					Integer[] idsTipoCliente) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoRelatorioMaioresDevedores = null;

		try{
			colecaoRelatorioMaioresDevedores = repositorioFaturamento.pesquisarDadosRelatorioMaioresDevedores(localidade, registros,
							idsTipoCliente);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoRelatorioMaioresDevedores != null && !colecaoRelatorioMaioresDevedores.isEmpty()){

			Iterator colecaoMaioresDevedoresIterator = colecaoRelatorioMaioresDevedores.iterator();

			while(colecaoMaioresDevedoresIterator.hasNext()){

				Object[] dadosMaioresDevedores = (Object[]) colecaoMaioresDevedoresIterator.next();

				RelatorioMaioresDevedoresHelper relatorioMaioresDevedoresHelper = new RelatorioMaioresDevedoresHelper();

				if(dadosMaioresDevedores[0] != null){
					relatorioMaioresDevedoresHelper.setLocalidade((String) dadosMaioresDevedores[0]);
				}
				if(dadosMaioresDevedores[1] != null){

					relatorioMaioresDevedoresHelper.setSetor("" + dadosMaioresDevedores[1]);
				}
				if(dadosMaioresDevedores[2] != null){
					relatorioMaioresDevedoresHelper.setMatricula("" + dadosMaioresDevedores[2]);
				}
				if(dadosMaioresDevedores[3] != null){
					relatorioMaioresDevedoresHelper.setNome((String) dadosMaioresDevedores[3]);
				}
				if(dadosMaioresDevedores[4] != null){
					if(((String) dadosMaioresDevedores[4]).length() == 11) relatorioMaioresDevedoresHelper.setCpfCnpj(Util
									.formatarCpf((String) dadosMaioresDevedores[4]));
					else relatorioMaioresDevedoresHelper.setCpfCnpj(Util.formatarCnpj((String) dadosMaioresDevedores[4]));
				}
				if(dadosMaioresDevedores[5] != null){
					relatorioMaioresDevedoresHelper.setTipo((String) dadosMaioresDevedores[5]);
				}
				if(dadosMaioresDevedores[6] != null){
					relatorioMaioresDevedoresHelper.setEndereco((String) dadosMaioresDevedores[6]);
				}
				if(dadosMaioresDevedores[7] != null){
					relatorioMaioresDevedoresHelper.setQuantidade("" + dadosMaioresDevedores[7]);
				}
				if(dadosMaioresDevedores[8] != null){
					relatorioMaioresDevedoresHelper.setValorDebito((BigDecimal) dadosMaioresDevedores[8]);
				}

				retorno.add(relatorioMaioresDevedoresHelper);
			}
		}

		return retorno;
	}

	/**
	 * [UC0105] - Obter Consumo Mínimo da Ligação
	 */
	public int obterConsumoMinimoLigacaoInformadoTarifa(Imovel imovel, Integer idConsumoTarifa) throws ControladorException{

		int consumoMinimoLigacao = 0;
		Collection colecaoDataVigencia = null;
		Integer consumoMinimo = null;

		// Obtém o id do consumo tarifa vigência da maior data de vigência da tarifa do imóvel
		try{

			colecaoDataVigencia = repositorioMicromedicao.pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(), idConsumoTarifa);
		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém o id do array e atribui na variável
		Object[] consumoTarifaVigenciaIdArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoDataVigencia);
		Integer consumoTarifaVigenciaId = null;

		if(consumoTarifaVigenciaIdArray == null){

			throw new ControladorException("atencao.nao_cadastrada_consumo_tarifa_vigencia", null, imovel.getId().toString());
		}

		if(consumoTarifaVigenciaIdArray[0] != null){
			consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0];
		}

		// Cria o objeto consumo tarifa vigência e seta o id
		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		consumoTarifaVigencia.setId(consumoTarifaVigenciaId);

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
		Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();

		while(colecaoCategoriasIterator.hasNext()){

			Categoria categoria = (Categoria) colecaoCategoriasIterator.next();

			try{

				// Obtém o consumo mínimo da tarifa da categoria do imóvel
				Object consumoMinimoObjeto = repositorioMicromedicao.pesquisarConsumoMinimoTarifaCategoriaVigencia(categoria,
								consumoTarifaVigencia);
				consumoMinimo = (Integer) consumoMinimoObjeto;

			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if(consumoMinimo != null){

				// Multiplica a quantidade de economias da categoria pelo consumo mínimo e acumula
				consumoMinimoLigacao = consumoMinimoLigacao
								+ (categoria.getQuantidadeEconomiasCategoria().intValue() * consumoMinimo.intValue());
			}

		}

		// Retorna o consumo mínimo da ligação
		return consumoMinimoLigacao;
	}

	/**
	 * [UC0084] Gerar Faturamento Imediato
	 * [SB0007] – Gera Relação Lista de Consumidores.
	 * 
	 * @param collResumoHelper
	 */
	public void gerarRelacaoListaConsumidores(Collection collRelacaoHelper){

		try{

			// Parâmetros do relatório
			Map parametros = new HashMap();
			parametros.put("tipoFormatoRelatorio", "PDF");

			RelatorioGerarDadosParaleitura relatorioDadosParaLeitura = new RelatorioGerarDadosParaleitura(Usuario.USUARIO_BATCH);
			relatorioDadosParaLeitura.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
			relatorioDadosParaLeitura.addParametro("colecaoGerarDadosParaLeituraHelper", collRelacaoHelper);
			relatorioDadosParaLeitura.addParametro("indicadorExibirTotalizacoes",
							ParametroMicromedicao.P_EXIBIR_TOTALIZACOES_RELAT_CONSUMIDORES_LEITURA.executar());


			GerenciadorExecucaoTarefaRelatorio.analisarExecucao(relatorioDadosParaLeitura, TarefaRelatorio.TIPO_PDF);

		}catch(Exception e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}



	/***
	 * Desfazer pré faturamento por grupo e referência
	 * 
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */

	public void desfazerPreFaturamentoPorGrupoERef() throws ControladorException{

		try{
			AjusteContabilidadeDeso ajusteContabilidadeDeso = new AjusteContabilidadeDeso();
			ajusteContabilidadeDeso.desfazerPreFaturamentoPorGrupoERef();
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Tiago Moreno Data: 28/07/2007
	 * 
	 * @throws ControladorException
	 * @throws
	 * @deprecated
	 */
	public Collection<Rota> consultarRotasGrupo(Integer idFaturamentoGrupo, Integer anoMesReferencia, int tipoConsulta)
					throws ControladorException{

		Collection<Rota> retorno = new ArrayList();

		try{
			retorno = repositorioFaturamento.consultarRotasGrupo(idFaturamentoGrupo, anoMesReferencia, tipoConsulta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0183] Inserir Débito A Cobrar
	 * [UC0479] Gerar Débito Ordem de Serviço
	 * [SB0001] - Verificar Marcação do Débito A Cobrar para Remuneração da Cobrança Administrativa
	 * [UC0145] Inserir Conta
	 * [SB0007] - Verificar Marcação do Débito Cobrado para Remuneração da Cobrança Administrativa
	 */

	public Short verificarMarcacaoRemuneracaoCobAdminstrativa(Integer idImovel, Integer idDebitoTipo){

		// 1. O sistema atribui o valor 2 (não) à DBAC_ICREMUNERACOBRANCAADM.
		Short indicadorRemuneraCobrancaAdministrativa = ConstantesSistema.NAO;

		// 2. Caso o débito a cobrar gerado seja um serviço especial (DBTP_ID contido nos valores de
		// PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com PASI_CDPARAMETRO igual a
		// "P_SERVICOS_ESPECIAIS_COBRANCA_ADMINISTRATIVA"):
		try{
			String parametroServicosEspeciaisCobrancaAdministrativa = ParametroArrecadacao.P_SERVICOS_ESPECIAIS_COBRANCA_ADMINISTRATIVA
							.executar().toString();
			Collection<String> listaDebitoTipo = new ArrayList<String>();
			// Converte a lista do formato String vinda do parametro para um ArrayList
			if(!Util.isVazioOuBranco(parametroServicosEspeciaisCobrancaAdministrativa)){
				listaDebitoTipo = Arrays.asList(parametroServicosEspeciaisCobrancaAdministrativa.split(","));

				Iterator it = listaDebitoTipo.iterator();
				while(it.hasNext()){
					String idDebitoTipoLista = (String) it.next();
					if(idDebitoTipoLista.equals(idDebitoTipo.toString())){
						// 2.1. Caso a geração do débito a cobrar esteja relacionada à cobrança
						// administrativa (existe
						// ocorrência na tabela IMOVEL_COBRANCA_SITUACAO com IMOV_ID=(IMOV_ID da
						// tabela
						// DEBITO_A_COBRAR)
						// e CBST_ID=4 (cobrança administrativa) e ISCB_DTRETIRADACOBRANCA com o
						// valor
						// diferente de nulo
						// e ISCB_DTRETIRADACOBRANCA maior ou igual à data corrente menos
						// (PASI_VLPARAMETRO da tabela
						// PARAMETRO_SISTEMA com
						// PASI_CDPARAMETRO=”P_PRAZO_GERACAO_SERVICO_ESPECIAL_REMUNERAVEL_APOS_RETIRADA_COBRANCA_ADMINISTRATIVA”)):

						Integer prazoGeracao = new Integer(
										ParametroArrecadacao.P_PRAZO_GERACAO_SERVICO_ESPECIAL_REMUNERAVEL_APOS_RETIRADA_COBRANCA_ADMINISTRATIVA
														.executar().toString());
						Integer idImovelCobrancaSituacao = this.getControladorArrecadacao().pesquisarImovelCobrancaSituacao(idImovel,
										CobrancaSituacao.COBRANCA_ADMINISTRATIVA, prazoGeracao);
						if(idImovelCobrancaSituacao != null){
							// 2.1.1. O sistema atribui o valor 1 (sim) à
							// DBAC_ICREMUNERACOBRANCAADM.
							indicadorRemuneraCobrancaAdministrativa = ConstantesSistema.SIM;
						}

						break;
					}
				}

			}

		}catch(ControladorException e){
			e.printStackTrace();
		}

		return indicadorRemuneraCobrancaAdministrativa;

	}

	public void gerarResumoFaturamentoSimulacaoAjusteCasal(FaturamentoGrupo faturamentoGrupo, Integer anoMesCorrente,
					Integer idFaturamentoAtividadeCronograma) throws ControladorException{

		try{

			log.info("-----------Início ajuste gerar resumo_faturamento_simulacao grupo: " + faturamentoGrupo.getId());

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.gerarResumoFaturamentoSimulacaoAjusteCasal(faturamentoGrupo, anoMesCorrente,
							idFaturamentoAtividadeCronograma);

			log.info("-----------Fim ajuste gerar resumo_faturamento_simulacao grupo: " + faturamentoGrupo.getId());

		}catch(Exception e){

			log.info("-----------Erro ajuste gerar resumo_faturamento_simulacao grupo: " + faturamentoGrupo.getId());
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0084] - Gerar Faturamento Imediato
	 * [SB0004] – Obter os Créditos a Realizar
	 * 
	 * @author Anderson Italo
	 * @throws ControladorException
	 * @date 08/05/2013
	 */
	public Object[] obterCreditosARealizarFaturamentoImediato(Integer idImovel, Integer anoMesReferenciaFaturamento,
					boolean isRetornoFaturamento, Date dataGeracaoFaturamento) throws ControladorException{

		Object[] retorno = new Object[3];
		BigDecimal valorTotalCreditos = BigDecimal.ZERO;
		Collection<CreditoARealizar> colecaoCreditosARealizarAtualizarRetornoFaturamento = null;
		Collection<CreditoARealizarHelper> colecaoCreditosARealizarHelperEnviadosMovimento = null;

		try{

			CreditoARealizar creditoARealizar = null;

			// O sistema seleciona os créditos a realizar do imóvel classificando do mais antigo
			// para o mais novo e os de maior valor para os de menor
			Collection<CreditoARealizar> colecaoCreditosARealizar = repositorioFaturamento
							.pesquisarCreditosARealizarImovelFaturamentoImediato(idImovel, anoMesReferenciaFaturamento,
											isRetornoFaturamento, dataGeracaoFaturamento);

			// [SB0017] - Verificar Titularidade do Débito
			this.verificarTitularidadeDebitoCredito(idImovel, null, null, colecaoCreditosARealizar);

			// [FS0004 - Verificar créditos a realizar de parcelamento]
			colecaoCreditosARealizarAtualizarRetornoFaturamento = this.verificarCreditosARealizarDeParcelamento(colecaoCreditosARealizar,
							anoMesReferenciaFaturamento);


			BigDecimal valorCredito = new BigDecimal("0.00");
			BigDecimal valorResidualMesAnterior = new BigDecimal("0.00");
			Short numeroParcelaBonus = 0;
			Short numeroPrestacaoCredito = 0;
			Short numeroPrestacaoRealizada = 0;
			Short numeroPrestacaoCreditoMenosParcelaBonusMenosUm = 0;

			if(!Util.isVazioOrNulo(colecaoCreditosARealizarAtualizarRetornoFaturamento)){

				Iterator iteratorColecaoCreditosARealizar = colecaoCreditosARealizarAtualizarRetornoFaturamento.iterator();
				colecaoCreditosARealizarHelperEnviadosMovimento = new ArrayList<CreditoARealizarHelper>();

				while(iteratorColecaoCreditosARealizar.hasNext()){

					/*
					 * Para cada crédito a realizar selecionado, o sistema calcula o valor do
					 * crédito de acordo com as seguintes regras
					 */
					creditoARealizar = (CreditoARealizar) iteratorColecaoCreditosARealizar.next();
					valorCredito = new BigDecimal("0.00");
					valorResidualMesAnterior = new BigDecimal("0.00");
					numeroParcelaBonus = 0;
					numeroPrestacaoCredito = 0;
					numeroPrestacaoRealizada = 0;
					numeroPrestacaoCreditoMenosParcelaBonusMenosUm = 0;

					if(creditoARealizar.getNumeroParcelaBonus() != null){

						numeroParcelaBonus = creditoARealizar.getNumeroParcelaBonus();
					}

					if(creditoARealizar.getValorResidualMesAnterior() != null){

						valorResidualMesAnterior = creditoARealizar.getValorResidualMesAnterior();
					}

					if(creditoARealizar.getNumeroPrestacaoCredito() != null){

						numeroPrestacaoCredito = creditoARealizar.getNumeroPrestacaoCredito();
					}

					if(creditoARealizar.getNumeroPrestacaoRealizada() != null){

						numeroPrestacaoRealizada = creditoARealizar.getNumeroPrestacaoRealizada();
					}

					// Caso só exista valor residual a ser creditado
					if((numeroPrestacaoRealizada.shortValue() == numeroPrestacaoCredito.shortValue())
									&& (valorResidualMesAnterior.compareTo(BigDecimal.ZERO) == 1)){

						// Valor do crédito = CRAR_VLRESIDUALMESANTERIOR
						valorCredito = valorResidualMesAnterior;
					}else{

						BigDecimal valorCreditoCorrespParcelaMes = BigDecimal.ZERO;
						BigDecimal calculo1 = null;
						BigDecimal calculo2 = null;
						BigDecimal calculo3 = null;

						if(valorCredito != null){

							valorCredito = creditoARealizar.getValorCredito();
						}

						/*
						 * Valor do crédito correspondente a parcela do mês = CRAR_VLCREDITO /
						 * CRAR_NNPRESTACAOCREDITO
						 */
						valorCreditoCorrespParcelaMes = valorCredito.divide(new BigDecimal(numeroPrestacaoCredito), 2,
										BigDecimal.ROUND_DOWN);

						/*
						 * Caso seja a última prestação (CRAR_NNPRESTACAOREALIZADAS =
						 * (CRAR_NNPRESTACAOCREDITO – coalesce (CRAR_NNPARCELABONUS,0)) – 1)
						 */
						numeroPrestacaoCreditoMenosParcelaBonusMenosUm = Short
										.parseShort(String.valueOf((numeroPrestacaoCredito.intValue() - numeroParcelaBonus.intValue()) - 1));

						if(numeroPrestacaoRealizada.shortValue() == numeroPrestacaoCreditoMenosParcelaBonusMenosUm.shortValue()){

							/*
							 * Valor do crédito correspondente a parcela do mês = Valor do crédito
							 * correspondente a parcela do mês + (CRAR_VLCREDITO – (Valor do crédito
							 * correspondente a parcela do mês * (CRAR_NNPRESTACAOCREDITO – coalesce
							 * (CRAR_NNPARCELABONUS,0)))).
							 */
							calculo1 = BigDecimal.valueOf(numeroPrestacaoCredito - numeroParcelaBonus);
							calculo2 = valorCreditoCorrespParcelaMes.multiply(calculo1).setScale(2);
							calculo3 = valorCredito.subtract(calculo2);
							valorCreditoCorrespParcelaMes = valorCreditoCorrespParcelaMes.add(calculo3);
						}

						// Valor do crédito = Valor do crédito correspondente a parcela do mês +
						// CRAR_VLRESIDUALMESANTERIOR
						valorCredito = valorCreditoCorrespParcelaMes.add(valorResidualMesAnterior);
					}

					// Acumula o valor do crédito no valor total dos créditos
					valorTotalCreditos = valorTotalCreditos.add(valorCredito);
					CreditoARealizarHelper creditoARealizarHelper = new CreditoARealizarHelper(valorCredito, creditoARealizar);
					colecaoCreditosARealizarHelperEnviadosMovimento.add(creditoARealizarHelper);
				}
			}

		}catch(Exception ex){

			throw new ControladorException("erro.sistema", ex);
		}

		retorno[0] = valorTotalCreditos;
		retorno[1] = colecaoCreditosARealizarHelperEnviadosMovimento;
		retorno[2] = colecaoCreditosARealizarAtualizarRetornoFaturamento;

		return retorno;

	}

	/**
	 * [UC0084] - Gerar Faturamento Imediato
	 * [SB0007] - Gerar Movimento Roteiro de Empresa
	 * 
	 * @author Anderson Italo
	 * @date 12/04/2013
	 * @throws ControladorException
	 */
	public Object[] obterDadosLeituraAnterior(Integer anoMesReferenciaFaturamento, Integer idMedicaoTipo, Imovel imovel)
					throws ControladorException{

		Object[] dadosLeituraAnterior = new Object[6];
		Integer numeroLeituraAnteriorFaturada = null;
		Date dataLeituraAnterior = null;
		Integer idSituacaoLeituraAnterior = LeituraSituacao.NAO_REALIZADA;
		Integer numeroConsumoCreditoAnterior = 0;
		Integer numeroConsumoCreditoGerado = 0;
		Integer numeroLeituraAnteriorInformada = null;

		try{

			Object[] dadosUltimoMedicaoHistorico = null;
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = null;
			Date dataReligacaoOuReestabelecimento = null;

			// Histórico de instalação do hidrômetro
			if(idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)){

				hidrometroInstalacaoHistorico = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico();
			}else{

				hidrometroInstalacaoHistorico = imovel.getHidrometroInstalacaoHistorico();
			}

			// Obtém Histórico de Medição Anterior
			dadosUltimoMedicaoHistorico = repositorioMicromedicao.obterMedicaoHistoricoAnterior(imovel.getId(),
							anoMesReferenciaFaturamento, idMedicaoTipo);

			Date dataReligacao = null;
			Date dataReestabelecimento = null;
			Date dataCorte = null;
			Date dataSupressao = null;

			if(imovel.getLigacaoAgua() != null){

				if(imovel.getLigacaoAgua().getDataReligacao() != null){

					dataReligacao = imovel.getLigacaoAgua().getDataReligacao();
				}

				if(imovel.getLigacaoAgua().getDataRestabelecimentoAgua() != null){

					dataReestabelecimento = imovel.getLigacaoAgua().getDataRestabelecimentoAgua();
				}

				if(imovel.getLigacaoAgua().getDataCorte() != null){

					dataCorte = imovel.getLigacaoAgua().getDataCorte();
				}

				if(imovel.getLigacaoAgua().getDataSupressao() != null){

					dataSupressao = imovel.getLigacaoAgua().getDataSupressao();
				}
			}

			// Caso o imóvel possua último histórico de medição anterior ao mês de faturamento
			// corrente
			if(!Util.isVazioOrNulo(dadosUltimoMedicaoHistorico)){

				if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)){

					if(hidrometroInstalacaoHistorico != null){

						if(dataReligacao != null && dataReestabelecimento != null){
							
							if(dataReligacao.compareTo(dataReestabelecimento) >= 0){

								dataReligacaoOuReestabelecimento = dataReligacao;
								numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraCorte();
								numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraCorte();
							}else if(dataReligacao.compareTo(dataReestabelecimento) < 0){

								dataReligacaoOuReestabelecimento = dataReestabelecimento;
								numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraSupressao();
								numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraSupressao();
							}
						}else if(dataReligacao != null){
							
							dataReligacaoOuReestabelecimento = dataReligacao;
							numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraCorte();
							numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraCorte();
						}else if(dataReestabelecimento != null){

							dataReligacaoOuReestabelecimento = dataReestabelecimento;
							numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraSupressao();
							numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraSupressao();
						}
					}

					/*
					 * Caso o imóvel tenha sido religado ou reestabelecido e a data de
					 * religação ou reestabelecimento seja maior que a data da última
					 * leitura
					 */
					if(dataReligacaoOuReestabelecimento != null
									&& (dadosUltimoMedicaoHistorico[0] == null || (dataReligacaoOuReestabelecimento
													.compareTo((Date) dadosUltimoMedicaoHistorico[0]) > 0))){

						// Atribui a data de religação ou reestabelecimento a data da
						// leitura anterior
						dataLeituraAnterior = dataReligacaoOuReestabelecimento;

						if(numeroLeituraAnteriorFaturada == null || numeroLeituraAnteriorFaturada.intValue() == 0){

							// Atribui a data de leitura atual faturamento do último
							// histórico
							// de medição a data de leitura anterior
							dataLeituraAnterior = (Date) dadosUltimoMedicaoHistorico[0];

							// Atribui a leitura atual faturamento do último histórico de
							// medição a leitura anterior
							numeroLeituraAnteriorFaturada = (Integer) dadosUltimoMedicaoHistorico[1];
						}

						if(numeroLeituraAnteriorInformada == null || numeroLeituraAnteriorInformada.intValue() == 0){

							// Atribui a leitura atual faturamento do último histórico de
							// medição a leitura anterior
							numeroLeituraAnteriorInformada = (Integer) dadosUltimoMedicaoHistorico[2];
						}
					}else{

						// Atribui a data de leitura atual faturamento do último histórico
						// de medição a data de leitura anterior
						dataLeituraAnterior = (Date) dadosUltimoMedicaoHistorico[0];

						// Atribui a leitura atual faturamento do último histórico de
						// medição a leitura anterior
						numeroLeituraAnteriorFaturada = (Integer) dadosUltimoMedicaoHistorico[1];

						// Atribui a leitura atual faturamento do último histórico de
						// medição a leitura anterior
						numeroLeituraAnteriorInformada = (Integer) dadosUltimoMedicaoHistorico[2];
					}

				}else if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO)
								|| imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO_A_PEDIDO)
								|| imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORT_MED_INDIVIDUAL)){

					/*
					 * Caso o imóvel tenha sido cortado e a data de corte seja maior que a
					 * data da última leitura
					 */
					if(dataCorte != null
									&& (dadosUltimoMedicaoHistorico[0] == null || (dataCorte
													.compareTo((Date) dadosUltimoMedicaoHistorico[0])) > 0)){

						// Atribui a data de corte a data da leitura anterior
						dataLeituraAnterior = dataCorte;

						if(numeroLeituraAnteriorFaturada == null || numeroLeituraAnteriorFaturada.intValue() == 0){

							// Atribui a data de leitura atual faturamento do último
							// histórico
							// de medição a data de leitura anterior
							dataLeituraAnterior = (Date) dadosUltimoMedicaoHistorico[0];

							// Atribui a leitura atual faturamento do último histórico de
							// medição a leitura anterior
							numeroLeituraAnteriorFaturada = (Integer) dadosUltimoMedicaoHistorico[1];
						}

						if(numeroLeituraAnteriorInformada == null || numeroLeituraAnteriorInformada.intValue() == 0){

							// Atribui a leitura atual faturamento do último histórico de
							// medição a leitura anterior
							numeroLeituraAnteriorInformada = (Integer) dadosUltimoMedicaoHistorico[2];
						}
					}else{

						// Atribui a data de leitura atual faturamento do último
						// histórico
						// de medição a data de leitura anterior
						dataLeituraAnterior = (Date) dadosUltimoMedicaoHistorico[0];

						// Atribui a leitura atual faturamento do último histórico de
						// medição a leitura anterior
						numeroLeituraAnteriorFaturada = (Integer) dadosUltimoMedicaoHistorico[1];

						// Atribui a leitura atual faturamento do último histórico de
						// medição a leitura anterior
						numeroLeituraAnteriorInformada = (Integer) dadosUltimoMedicaoHistorico[2];
					}
				}else if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.SUPRIMIDO)
								|| imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.SUPRIMIDO_DEFINITIVO)
								|| imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.SUPR_PARC)){

					/*
					 * Caso o imóvel tenha sido suprimido e a data de supressão seja maior
					 * que a
					 * data da última leitura
					 */
					if(dataSupressao != null
									&& (dadosUltimoMedicaoHistorico[0] == null || (dataSupressao
													.compareTo((Date) dadosUltimoMedicaoHistorico[0])) > 0)){

						// Atribui a data de supressão a data da leitura anterior
						dataLeituraAnterior = dataSupressao;

						if(numeroLeituraAnteriorFaturada == null || numeroLeituraAnteriorFaturada.intValue() == 0){

							// Atribui a data de leitura atual faturamento do último
							// histórico
							// de medição a data de leitura anterior
							dataLeituraAnterior = (Date) dadosUltimoMedicaoHistorico[0];

							// Atribui a leitura atual faturamento do último histórico de
							// medição a leitura anterior
							numeroLeituraAnteriorFaturada = (Integer) dadosUltimoMedicaoHistorico[1];
						}

						if(numeroLeituraAnteriorInformada == null || numeroLeituraAnteriorInformada.intValue() == 0){

							// Atribui a leitura atual faturamento do último histórico de
							// medição a leitura anterior
							numeroLeituraAnteriorInformada = (Integer) dadosUltimoMedicaoHistorico[2];
						}
					}else{

						// Atribui a data de leitura atual faturamento do último
						// histórico
						// de medição a data de leitura anterior
						dataLeituraAnterior = (Date) dadosUltimoMedicaoHistorico[0];

						// Atribui a leitura atual faturamento do último histórico de
						// medição a leitura anterior
						numeroLeituraAnteriorFaturada = (Integer) dadosUltimoMedicaoHistorico[1];

						// Atribui a leitura atual faturamento do último histórico de
						// medição a leitura anterior
						numeroLeituraAnteriorInformada = (Integer) dadosUltimoMedicaoHistorico[2];
					}
				}

				if(dadosUltimoMedicaoHistorico[4] != null){

					numeroConsumoCreditoAnterior = (Integer) dadosUltimoMedicaoHistorico[4];
				}

				if(dadosUltimoMedicaoHistorico[5] != null){

					numeroConsumoCreditoGerado = (Integer) dadosUltimoMedicaoHistorico[5];
				}

				if(dadosUltimoMedicaoHistorico[3] != null){

					idSituacaoLeituraAnterior = (Integer) dadosUltimoMedicaoHistorico[3];
				}
			}else{

				// Caso contrário, caso o imóvel seja medido
				if(hidrometroInstalacaoHistorico != null){

					// Atribui a data de instalação do hidrômetro a data de leitura anterior
					dataLeituraAnterior = hidrometroInstalacaoHistorico.getDataInstalacao();

					// Caso o imóvel esteja cortado
					if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO)
									|| imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO_A_PEDIDO)
									|| imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORT_MED_INDIVIDUAL)){

						if(hidrometroInstalacaoHistorico.getNumeroLeituraCorte() != null){

							// Atribui a leitura de corte a leitura anterior
							numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraCorte();
							numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraCorte();
						}else if(hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao() != null){

							// Atribui a leitura de instalação
							numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao();
							numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao();
						}else{

							// Atribui zero
							numeroLeituraAnteriorFaturada = 0;
							numeroLeituraAnteriorInformada = 0;
						}
					}else if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.SUPRIMIDO)
									|| imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.SUPRIMIDO_DEFINITIVO)
									|| imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.SUPR_PARC)){

						// Caso o imóvel esteja suprimido
						if(hidrometroInstalacaoHistorico.getNumeroLeituraSupressao() != null){

							// Atribui a leitura da supressão a leitura anterior
							numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraSupressao();
							numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraSupressao();
						}else if(hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao() != null){

							// Atribui a leitura de instalação
							numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao();
							numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao();
						}else{

							// Atribui zero
							numeroLeituraAnteriorFaturada = 0;
							numeroLeituraAnteriorInformada = 0;
						}
					}else{

						// Caso contrário, nova ligação
						if(hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao() != null){

							// Atribui a leitura de instalação do hidrômetro a leitura
							// anterior
							numeroLeituraAnteriorFaturada = hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao();
							numeroLeituraAnteriorInformada = hidrometroInstalacaoHistorico.getNumeroLeituraInstalacao();
						}else{

							// Atribui zero
							numeroLeituraAnteriorFaturada = 0;
							numeroLeituraAnteriorInformada = 0;
						}
					}
				}

				numeroConsumoCreditoAnterior = 0;
				idSituacaoLeituraAnterior = LeituraSituacao.NAO_REALIZADA;
			}


			dadosLeituraAnterior[0] = numeroLeituraAnteriorFaturada;
			dadosLeituraAnterior[1] = dataLeituraAnterior;
			dadosLeituraAnterior[2] = idSituacaoLeituraAnterior;
			dadosLeituraAnterior[3] = numeroConsumoCreditoAnterior;
			dadosLeituraAnterior[4] = numeroLeituraAnteriorInformada;
			dadosLeituraAnterior[5] = numeroConsumoCreditoGerado;

		}catch(ErroRepositorioException ex){

			throw new ControladorException("", ex);
		}

		return dadosLeituraAnterior;
	}

	public Collection<DebitoCobrado> agruparDebitoCobrado(Collection<DebitoCobrado> colecaoDebitoCobrado) throws ControladorException{

		List<DebitoCobrado> colecaoDebitoCobradoOrdenada = new ArrayList<DebitoCobrado>();

		colecaoDebitoCobradoOrdenada.addAll(colecaoDebitoCobrado);

		// Ordenar a coleção por mais de um campo
		List sortFields = new ArrayList();
		sortFields.add(new BeanComparator("debitoTipo.id"));
		sortFields.add(new BeanComparator("numeroPrestacao"));
		sortFields.add(new BeanComparator("numeroPrestacaoDebito"));
		sortFields.add(new BeanComparator("anoMesCobrancaDebito"));

		ComparatorChain multiSort = new ComparatorChain(sortFields);
		Collections.sort(colecaoDebitoCobradoOrdenada, multiSort);

		BigDecimal acumularValorPrestacao = BigDecimal.ZERO;
		List<DebitoCobrado> colecaoDebitoCobradoAglutinada = new ArrayList<DebitoCobrado>();

		for(int i = 0; i < colecaoDebitoCobradoOrdenada.size(); i++){

			DebitoCobrado debitoCobrado = colecaoDebitoCobradoOrdenada.get(i);

			if(debitoCobrado.getParcelamento() != null){

				DebitoCobrado debitoCobradoProximo = null;

				if(i != (colecaoDebitoCobradoOrdenada.size() - 1)){

					debitoCobradoProximo = colecaoDebitoCobradoOrdenada.get(i + 1);
				}else{

					debitoCobradoProximo = colecaoDebitoCobradoOrdenada.get(i);
				}

				if(debitoCobrado.getDebitoTipo().getId().equals(debitoCobradoProximo.getDebitoTipo().getId())
								&& (debitoCobrado.getNumeroPrestacao() == debitoCobradoProximo.getNumeroPrestacao())
								&& (debitoCobrado.getNumeroPrestacaoDebito() == debitoCobradoProximo.getNumeroPrestacaoDebito())
								&& (debitoCobrado.getAnoMesCobrancaDebito().equals(debitoCobradoProximo.getAnoMesCobrancaDebito()))){

					acumularValorPrestacao = acumularValorPrestacao.add(debitoCobrado.getValorPrestacao());

					if(i == (colecaoDebitoCobradoOrdenada.size() - 1)){

						debitoCobrado.setValorPrestacao(acumularValorPrestacao);
						colecaoDebitoCobradoAglutinada.add(debitoCobrado);
					}
				}else{

					acumularValorPrestacao = acumularValorPrestacao.add(debitoCobrado.getValorPrestacao());
					debitoCobrado.setValorPrestacao(acumularValorPrestacao);
					colecaoDebitoCobradoAglutinada.add(debitoCobrado);
					acumularValorPrestacao = BigDecimal.ZERO;
				}
			}else{

				colecaoDebitoCobradoAglutinada.add(debitoCobrado);
				acumularValorPrestacao = BigDecimal.ZERO;
			}
		}

		// Ordenar a coleção por mais de um campo
		List sortFieldsAux = new ArrayList();
		sortFieldsAux.add(new BeanComparator("anoMesCobrancaDebito"));
		sortFieldsAux.add(new BeanComparator("debitoTipo.descricao"));
		sortFieldsAux.add(new BeanComparator("numeroPrestacao"));
		sortFieldsAux.add(new BeanComparator("numeroPrestacaoDebito"));

		ComparatorChain multiSortAux = new ComparatorChain(sortFieldsAux);
		Collections.sort(colecaoDebitoCobradoAglutinada, multiSortAux);

		return colecaoDebitoCobradoAglutinada;
	}

	public Collection<DebitoACobrar> agruparDebitoACobrar(Collection<DebitoACobrar> colecaoDebitoACobrar, Boolean usarValorTotalDebito)
					throws ControladorException{

		String valorParametro = ParametroAtendimentoPublico.P_TRATAR_DEBITO_TIPO_PARCELAMENTO_AGRUPADO.executar();

		if(valorParametro.equals(ConstantesSistema.SIM.toString())){

			Collection<DebitoACobrar> collecaoRetorno = new ArrayList<DebitoACobrar>();

			if(colecaoDebitoACobrar != null){

				List<Integer> colecaoFinanciamentosTiposParcelamento = Util
								.toListInteger(((String) ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar()).split(","));
				Integer tipoDebitoJurosParcelamento = Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_JUROS_PARCELAMENTO
								.executar());
				Integer tipoDebitoJurosParcelamentoCobrancaAdministrativa = Integer
								.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_JUROS_PARCELAMENTO_COBRANCA_ADMINISTRATIVA
												.executar());

				collecaoRetorno.addAll(this.agruparDebitosACobrarPorParcelamento(colecaoDebitoACobrar,
								colecaoFinanciamentosTiposParcelamento, tipoDebitoJurosParcelamento,
								tipoDebitoJurosParcelamentoCobrancaAdministrativa, usarValorTotalDebito));

				// collecaoRetorno.addAll(this.agruparDebitosACobrarPorTipoEReferencia(colecaoDebitoACobrar,
				// usarValorTotalDebito));

				collecaoRetorno.addAll(colecaoDebitoACobrar);

				collecaoRetorno = this.ordernarColecaoDebitosACobrar(collecaoRetorno);

			}

			return collecaoRetorno;

		}else{

			return colecaoDebitoACobrar;
		}
	}

	private Collection<DebitoACobrar> agruparDebitosACobrarPorParcelamento(Collection<DebitoACobrar> colecaoDebitoACobrar,
					List<Integer> colecaoFinanciamentosTiposParcelamento, Integer tipoDebitoJurosParcelamento,
					Integer tipoDebitoJurosParcelamentoCobrancaAdministrativa, Boolean usarValorTotalDebito){

		Collection<DebitoACobrar> collDebitoACobrar = new ArrayList<DebitoACobrar>();

		MultiKeyMap agrupamento = MultiKeyMap.decorate(new LinkedMap());

		for(DebitoACobrar debitoACobrar : colecaoDebitoACobrar){

			if(debitoACobrar.getParcelamento() != null && debitoACobrar.getDebitoTipo() != null){

				if(agrupamento.containsKey(debitoACobrar.getParcelamento().getId(), debitoACobrar.getDebitoTipo().getId())){

					((Collection<DebitoACobrar>) agrupamento.get(debitoACobrar.getParcelamento().getId(), debitoACobrar.getDebitoTipo()
									.getId())).add(debitoACobrar);

				}else{

					Collection<DebitoACobrar> coll = new ArrayList<DebitoACobrar>();
					coll.add(debitoACobrar);

					agrupamento.put(debitoACobrar.getParcelamento().getId(), debitoACobrar.getDebitoTipo().getId(), coll);

				}

			}

		}

		for(Object obj : agrupamento.keySet()){

			MultiKey key = (MultiKey) obj;

			BigDecimal valorTotalDebitoACobrar = BigDecimal.ZERO;

			Collection<DebitoACobrar> collDaC = (Collection<DebitoACobrar>) agrupamento.get(key);

			colecaoDebitoACobrar.removeAll(collDaC);

			DebitoACobrar dacExibicao = collDaC.iterator().next();

			for(DebitoACobrar dac : collDaC){

				if(usarValorTotalDebito){

					valorTotalDebitoACobrar = valorTotalDebitoACobrar.add(dac.getValorTotal());

				}else{

					valorTotalDebitoACobrar = valorTotalDebitoACobrar.add(dac.getValorDebito());

				}

				dacExibicao.addIdDebitoACobrarAgrupado(dac.getId());

			}

			Map<String, Short> dadosPrestacao = this.obterDadosPrestacaoDebitoACobrar(collDaC);

			dacExibicao.setValorDebito(valorTotalDebitoACobrar);
			dacExibicao.setNumeroPrestacaoCobradas(Short.valueOf("0"));
			dacExibicao.setNumeroPrestacaoCobradasTemp(dadosPrestacao.get("NUMERO_PRESTACAO_COBRADAS"));
			dacExibicao.setNumeroPrestacaoDebito(Short.valueOf("1"));
			dacExibicao.setNumeroPrestacaoDebitoTemp(dadosPrestacao.get("NUMERO_PRESTACAO_DEBITO"));
			dacExibicao.setQuantidadeParcelasAntecipadas(null);

			collDebitoACobrar.add(dacExibicao);

		}

		return collDebitoACobrar;

	}

	private Collection<DebitoACobrar> ordernarColecaoDebitosACobrar(Collection<DebitoACobrar> collDebitoACobrar){

		List<DebitoACobrar> list = new ArrayList<DebitoACobrar>();
		list.addAll(collDebitoACobrar);
		List sortFields = new ArrayList();

		sortFields.add(new BeanComparator("anoMesReferenciaDebito"));
		sortFields.add(new BeanComparator("debitoTipo.descricao"));

		ComparatorChain multiSort = new ComparatorChain(sortFields);
		Collections.sort((List) list, multiSort);
		Collections.reverse(list);

		return list;

	}

	private Map<String, Short> obterDadosPrestacaoDebitoACobrar(Collection<DebitoACobrar> collDaC){

		Short numeroPrestacaoDebito = 0;
		Short numeroPrestacaoCobradas = 0;

		for(DebitoACobrar debitoACobrar : collDaC){

			if(numeroPrestacaoDebito < debitoACobrar.getNumeroPrestacaoDebito()){

				numeroPrestacaoDebito = debitoACobrar.getNumeroPrestacaoDebito();

			}

			if(numeroPrestacaoCobradas < debitoACobrar.getNumeroPrestacaoCobradas()){

				numeroPrestacaoCobradas = debitoACobrar.getNumeroPrestacaoCobradas();

			}

		}

		Map<String, Short> retorno = new HashMap<String, Short>();
		retorno.put("NUMERO_PRESTACAO_DEBITO", numeroPrestacaoDebito);
		retorno.put("NUMERO_PRESTACAO_COBRADAS", numeroPrestacaoCobradas);

		return retorno;

	}

	public void executarAjusteRetificarContasRetirarDebitoRateioDuplicado() throws ControladorException{

		try{

			log.info("-----------Início ajuste retificar contas com duplicidade de rateio: ----------------");

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteRetificarContasRetirarDebitoRateioDuplicado();

			log.info("-----------Fim ajuste ajuste retificar contas com duplicidade de rateio: ----------------");

		}catch(Exception e){

			log.info("-----------Erro ajuste retificar contas com duplicidade de rateio: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	public void executarAjusteBaixarPagamentosAMaior() throws ControladorException{

		try{

			log.info("-----------INÍCIO AJUSTE PAGAMENTOS A MAIOR: ----------------");
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteBaixarPagamentosAMaior();
			log.info("-----------FIM AJUSTE PAGAMENTOS A MAIOR: ----------------");

		}catch(IOException e){

			log.info("-----------ERRO AJUSTE PAGAMENTOS A MAIOR: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}catch(Exception e){

			log.info("-----------ERRO AJUSTE PAGAMENTOS A MAIOR: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	public void executarAjusteContasRetificar(Integer idGrupo) throws ControladorException{

		try{

			log.info("-----------INÍCIO AJUSTE RETIFICAR: ----------------");
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteContasRetificar(idGrupo);
			log.info("-----------FIM AJUSTE AJUSTE RETIFICAR: ----------------");

		}catch(IOException e){

			log.info("-----------ERRO AJUSTE RETIFICAR: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}catch(Exception e){

			log.info("-----------ERRO AJUSTE RETIFICAR: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * [SB0004] - Gerar Debitos Cobrados
	 * [UC0084] - Gerar Faturamento Imediato
	 * [SB0003] - Gerar os Débitos Cobrados
	 * 
	 * @author Yara Souza
	 * @data 20/08/2011
	 * @param imovel
	 * @param anoMesFaturamento
	 * @param gerarAtividadeGrupoFaturamento
	 * @return
	 * @throws ControladorException
	 */
	private Object[] gerarDebitosCobrados(Imovel imovel, Integer anoMesFaturamento, FaturamentoSimulacaoComando faturamentoSimulacaoComando)
					throws ControladorException{

		Object[] retorno = new Object[5];

		// Pesquisa os débitos a cobrar do imóvel.
		Collection colecaoDebitosACobrar = null;
		try{
			colecaoDebitosACobrar = this.obterDebitoACobrarImovel(imovel.getId(), DebitoCreditoSituacao.NORMAL, anoMesFaturamento);
			
			// [SB0017] - Verificar Titularidade do Débito
			this.verificarTitularidadeDebitoCredito(imovel.getId(), null, colecaoDebitosACobrar, null);
			

			BigDecimal valorTotalDebitos = BigDecimal.ZERO;
			List colecaoDebitosACobrarUpdate = new ArrayList();
			Collection colecaoDebitosCobradoCategoria = null;

			// Cria o map para armazenar os débitos a cobrar junto com os débitos a cobrar por
			// categoria.
			Map<DebitoCobrado, Collection> mapDebitosCobrados = null;

			/*
			 * Caso o imóvel tenha débitos a cobrar gera os débitos cobrados [SB0004] - Gerar os
			 * Débitos Cobrados
			 */
			if(colecaoDebitosACobrar != null && !colecaoDebitosACobrar.isEmpty()){

				// Cria o iterator dos débitos a cobrar
				Iterator iteratorColecaoDebitosACobrar = colecaoDebitosACobrar.iterator();
				mapDebitosCobrados = new HashMap();
				DebitoACobrar debitoACobrar = new DebitoACobrar();
				BigDecimal valorPrestacao = BigDecimal.ZERO;

				// Laço para gerar os débitos cobrados e os débitos cobrados por categoria
				while(iteratorColecaoDebitosACobrar.hasNext()){
					// Recupera o débito a cobrar do iterator
					debitoACobrar = (DebitoACobrar) iteratorColecaoDebitosACobrar.next();

					// ****
					// **** INICIO - Lógica da campanha de parcelamento ****
					// ****

					Integer anoMesReferenciaUltimaCobranca = debitoACobrar.getAnoMesReferenciaUltimaCobranca();

					if(anoMesReferenciaUltimaCobranca != null){
						Integer numeroMesesEntreParcelas = debitoACobrar.getNumeroMesesEntreParcelas();

						if(numeroMesesEntreParcelas == null){
							// Valor default
							numeroMesesEntreParcelas = 1;
						}

						Integer anoMesReferenciaCalculada = Util.somaMesAnoMesReferencia(anoMesReferenciaUltimaCobranca,
										numeroMesesEntreParcelas);

						if(anoMesReferenciaCalculada > anoMesFaturamento){
							// Despreza o débito a cobrar
							continue;
						}
					}

					// ****
					// **** FIM - Lógica da campanha de parcelamento ****
					// ****

					// .................................................................................................................
					// Verificar para cada dpebito a lançar a partir da data de criação do débito a
					// cobrar,
					// se considerado o número de dias de suspensão a data obtida supera a data
					// corrente.
					// Nesse caso o débito a cobrar não será lançado na conta a ser faturada,
					// permanecendo até expiração do prazo.
					if(debitoACobrar.getNumeroDiasSuspensao() != null && debitoACobrar.getGeracaoDebito() != null){
						Date dataDebito = Util.adicionarNumeroDiasDeUmaData(debitoACobrar.getGeracaoDebito(),
										debitoACobrar.getNumeroDiasSuspensao());
						if(Util.compararData(dataDebito, new Date()) > 0){
							continue;
						}
					}
					// .................................................................................................................

					boolean debitoACobrarEmExtratoValido = verificarDebitoACobrarEmDocumentoCobranca(debitoACobrar);

					if(!debitoACobrarEmExtratoValido){

						// Calcula o valor da prestação
						valorPrestacao = debitoACobrar.getValorDebito().divide(new BigDecimal(debitoACobrar.getNumeroPrestacaoDebito()), 2,
										BigDecimal.ROUND_DOWN);

						// ****
						// **** INICIO - Lógica da campanha de parcelamento ****
						// ****

						Integer numeroParcelasALancar = debitoACobrar.getNumeroParcelasALancar();

						if(numeroParcelasALancar == null){
							// Valor default
							numeroParcelasALancar = 1;
						}

						// Indica se a aplicação deve ignorar o tratamento da última prestação, que
						// adiciona o valor residual à última parcela
						boolean ignorarTratamentoUltimaPrestacao = false;

						boolean indicadorUltimaPrestacao = false;

						if(BigDecimal.ZERO.compareTo(valorPrestacao) == 0){
							log.info(" ####### Valor Prestação: " + BigDecimal.ZERO.setScale(2) + " == " + valorPrestacao);

							// Como o valor da prestação ficou igual a zero, a aplicação irá gerar
							// todo o débito a cobrar em uma única parcela. Neste caso, não deve
							// ocorrer o tratamento para adição do valor residual à última parcela
							ignorarTratamentoUltimaPrestacao = true;

							valorPrestacao = debitoACobrar.getValorDebito();

							Short numeroParcelaBonus = debitoACobrar.getNumeroParcelaBonus();
							if(numeroParcelaBonus == null){
								numeroParcelaBonus = 0;
							}

							debitoACobrar.setNumeroPrestacaoCobradas((short) (debitoACobrar.getNumeroPrestacaoDebito() - numeroParcelaBonus
											.shortValue()));

							numeroParcelasALancar = 1;

						}else{

							// Atualiza o nº de prestações cobradas do débito a cobrar
							debitoACobrar.setNumeroPrestacaoCobradas(Integer.valueOf(debitoACobrar.getNumeroPrestacaoCobradas() + 1)
											.shortValue());
						}

						for(int numeroParcela = 0; numeroParcela < numeroParcelasALancar; numeroParcela++){

							// Caso a aplicação deve realizar este tratamento de última parcela
							// (conforme indicador ignorarTratamentoUltimaPrestacao), seja a última
							// prestação e exista mais de uma prestação
							if(!ignorarTratamentoUltimaPrestacao && debitoACobrar.getNumeroPrestacaoDebito() > 1
											&& (debitoACobrar.getNumeroPrestacaoCobradas() == debitoACobrar.getNumeroPrestacaoDebito())){

								indicadorUltimaPrestacao = true;

								// Obtém o número de prestação débito
								BigDecimal numeroPrestacaoDebito = new BigDecimal(debitoACobrar.getNumeroPrestacaoDebito());

								// Mutiplica o valor da prestação * número da prestação debito
								BigDecimal multiplicacao = valorPrestacao.multiply(numeroPrestacaoDebito).setScale(2);

								// Subtrai o valor do débito pelo resultado da multiplicação
								BigDecimal parte1 = debitoACobrar.getValorDebito().subtract(multiplicacao).setScale(2);

								// Calcula o valor da prestação
								valorPrestacao = valorPrestacao.add(parte1).setScale(2);
							}

							// Acumula o valor da prestação no valor total dos debitos
							valorTotalDebitos = valorTotalDebitos.add(valorPrestacao);

							// Se não for um comando de simulação de faturamento
							if(faturamentoSimulacaoComando == null){

								// Cria o débito cobrado
								DebitoCobrado debitoCobrado = new DebitoCobrado();
								debitoCobrado.setDebitoTipo(debitoACobrar.getDebitoTipo());
								debitoCobrado.setUltimaAlteracao(new Date());
								debitoCobrado.setLancamentoItemContabil(debitoACobrar.getLancamentoItemContabil());
								debitoCobrado.setLocalidade(debitoACobrar.getLocalidade());
								debitoCobrado.setQuadra(debitoACobrar.getQuadra());
								debitoCobrado.setCodigoSetorComercial(debitoACobrar.getCodigoSetorComercial());
								debitoCobrado.setNumeroQuadra(debitoACobrar.getNumeroQuadra());
								debitoCobrado.setNumeroLote(debitoACobrar.getNumeroLote());
								debitoCobrado.setNumeroSubLote(debitoACobrar.getNumeroSubLote());
								debitoCobrado.setAnoMesReferenciaDebito(debitoACobrar.getAnoMesReferenciaDebito());
								debitoCobrado.setAnoMesCobrancaDebito(debitoACobrar.getAnoMesCobrancaDebito());
								debitoCobrado.setValorPrestacao(valorPrestacao);
								debitoCobrado.setNumeroPrestacao(debitoACobrar.getNumeroPrestacaoDebito());
								debitoCobrado.setFinanciamentoTipo(debitoACobrar.getFinanciamentoTipo());
								debitoCobrado.setParcelamento(debitoACobrar.getParcelamento());
								debitoCobrado.setIndicadorRemuneraCobrancaAdministrativa(debitoACobrar
												.getIndicadorRemuneraCobrancaAdministrativa());

								// Incrementa o nº de prestação cobradas Como NumeroPrestacaoDebito
								// esta mapeado para short,
								// está se utilizando o mesmo
								debitoCobrado.setNumeroPrestacaoDebito(debitoACobrar.getNumeroPrestacaoCobradas());

								// Pesquisa os debitos a cobrar categoria do debito a cobrar
								Collection colecaoDebitoACobrarCategoria = this.obterDebitoACobrarCategoria(debitoACobrar.getId());

								// Cria o iterator para débitos a cobrar categoria
								Iterator colecaoDebitoACobrarCategoriaIterator = colecaoDebitoACobrarCategoria.iterator();

								Collection colecaoCategoriasObterValor = new ArrayList();
								// Obtém as categorias
								while(colecaoDebitoACobrarCategoriaIterator.hasNext()){
									DebitoACobrarCategoria debitoACobrarCategoria = (DebitoACobrarCategoria) colecaoDebitoACobrarCategoriaIterator
													.next();
									Categoria categoria = new Categoria();
									categoria.setId(debitoACobrarCategoria.getCategoria().getId());
									categoria.setQuantidadeEconomiasCategoria(debitoACobrarCategoria.getQuantidadeEconomia());
									colecaoCategoriasObterValor.add(categoria);
								}

								// Obter os valores por categoria do debito a cobrar
								Collection colecaoCategoriasCalculadasValor = getControladorImovel().obterValorPorCategoria(
												colecaoCategoriasObterValor, valorPrestacao);

								Iterator colecaoCategoriasCalculadasValorIterator = colecaoCategoriasCalculadasValor.iterator();
								Iterator colecaoCategoriasObterValorIterator = colecaoCategoriasObterValor.iterator();

								// Debito cobrado categoria
								DebitoCobradoCategoria debitoCobradoCategoria = null;

								colecaoDebitosCobradoCategoria = new ArrayList();

								// Laço para criar todos os débitos cobrados por categoria
								while(colecaoCategoriasCalculadasValorIterator.hasNext() && colecaoCategoriasObterValorIterator.hasNext()){

									// Cria o débito a cobrar por categoria e adiciona a coleção.
									debitoCobradoCategoria = new DebitoCobradoCategoria();

									BigDecimal valorPorCategoria = (BigDecimal) colecaoCategoriasCalculadasValorIterator.next();
									Categoria categoria = (Categoria) colecaoCategoriasObterValorIterator.next();
									debitoCobradoCategoria.setValorCategoria(valorPorCategoria);
									DebitoCobradoCategoriaPK debitoCobradoCategoriaPK = new DebitoCobradoCategoriaPK();
									debitoCobradoCategoriaPK.setCategoria(categoria);
									debitoCobradoCategoriaPK.setDebitoCobrado(debitoCobrado);
									debitoCobradoCategoria.setComp_id(debitoCobradoCategoriaPK);
									debitoCobradoCategoria.setDebitoCobrado(debitoCobrado);
									debitoCobradoCategoria.setCategoria(categoria);
									debitoCobradoCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());

									/*
									 * REGISTRAR LANCAMENTO CONTABIL
									 * --------------------------------------------------------------
									 * ----
									 */
									DebitoACobrarCategoria debitoACobrarCategoriaRegLancConta = new DebitoACobrarCategoria();
									debitoACobrarCategoriaRegLancConta.setValorCategoria(valorPorCategoria);
									debitoACobrarCategoriaRegLancConta.setCategoria(categoria);

									debitoACobrarCategoriaRegLancConta.setDebitoACobrar(debitoACobrar);

									if(debitoACobrar.getNumeroPrestacaoDebito() - debitoACobrar.getNumeroPrestacaoCobradas() > 12){
										getControladorContabil().registrarLancamentoContabil(debitoACobrarCategoriaRegLancConta,
														OperacaoContabil.TRANSFERENCIA_DEBITO_LONGO_PARA_CURTO_PRAZO);
									}
									/*
									 * --------------------------------------------------------------
									 * ----
									 */

									colecaoDebitosCobradoCategoria.add(debitoCobradoCategoria);

									// -----------------------------------------------------------------------------
									// HISTOGRAMA SERVIÇO
									// -----------------------------------------------------------------------------

									HistogramaServico histogramaServico = repositorioHistograma.pesquisarHistogramaServico(imovel
													.getLocalidade().getId(), imovel.getSetorComercial().getId(), categoria.getId(),
													debitoCobrado.getDebitoTipo().getId());

									if(histogramaServico == null){
										// cria objeto histogramaServico e adiciona a coleção.
										histogramaServico = new HistogramaServico();
										histogramaServico.setLocalidade(imovel.getLocalidade());
										histogramaServico.setSetorComercial(imovel.getSetorComercial());
										histogramaServico.setDebitoTipo(debitoCobrado.getDebitoTipo());
										histogramaServico.setCategoria(categoria);
										histogramaServico.setQtdTotalDebitoCobrado(1);
										histogramaServico.setValorTotalDebitoCobrado(valorPrestacao);

										getControladorUtil().inserir(histogramaServico);

									}else{
										// atualiza objeto histogramaServico e adiciona a coleção.
										histogramaServico.setQtdTotalDebitoCobrado(histogramaServico.getQtdTotalDebitoCobrado() + 1);
										histogramaServico.setValorTotalDebitoCobrado(histogramaServico.getValorTotalDebitoCobrado().add(
														valorPrestacao));
										getControladorUtil().atualizar(histogramaServico);
									}

									// -----------------------------------------------------------------------------

								}

								// Adiciona no map o relacionamento entre o débito a cobrar e os
								// débitos
								// a cobrar por categoria
								mapDebitosCobrados.put(debitoCobrado, colecaoDebitosCobradoCategoria);
							}

							if(indicadorUltimaPrestacao){
								break;
							}
						}

						if(faturamentoSimulacaoComando == null){

							debitoACobrar.setAnoMesReferenciaUltimaCobranca(anoMesFaturamento);

							// Adicona o objeto a coleção de débitos a cobrar que vão ser
							// atualizados
							colecaoDebitosACobrarUpdate.add(debitoACobrar);
						}
					}

					// ****
					// **** FIM - Lógica da campanha de parcelamento ****
					// ****

				}// fim do laço de debito a cobrar

			}// fim gerar debitos cobrados

			retorno[0] = valorTotalDebitos;
			retorno[1] = colecaoDebitosACobrarUpdate;
			retorno[2] = mapDebitosCobrados;

		}catch(ControladorException e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * [UC0352] [SB0103]
	 * Método responsável por formatar a descricao de um debito cobrado
	 * 
	 * @param idDebitoCobrado
	 * @return
	 * @throws ControladorException
	 */
	public String formatarDescricaoDebitoCobrado(Integer idDebitoCobrado) throws ControladorException{

		FiltroDebitoCobrado filtro = new FiltroDebitoCobrado();
		filtro.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.CODIGO, idDebitoCobrado));
		filtro.adicionarCaminhoParaCarregamentoEntidade("financiamentoTipo");
		filtro.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtro.adicionarCaminhoParaCarregamentoEntidade("parcelamento.resolucaoDiretoria");

		DebitoCobrado debitoCobrado = (DebitoCobrado) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtro,
						DebitoCobrado.class.getName()));

		String descricaoDebito = "";

		// 1. Caso o débito cobrado corresponda a um débito de parcelamento (FNTP_ID da tabela
		// DEBITO_COBRADO está contido em algum dos FNTP_ID da tabela FINANCIAMENTO_TIPO com
		// FNTP_DSFINANCIAMENTOTIPO com o valor correspondente a parcelamento de água, parcelamento
		// de esgoto, parcelamento de serviços ou juros de parcelamento):
		if(debitoCobrado.getFinanciamentoTipo() != null){

			Integer idFinancimentoTipo = debitoCobrado.getFinanciamentoTipo().getId();

			Collection<Integer> tiposParcelamento = Util
							.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar());

			if(tiposParcelamento != null && tiposParcelamento.contains(idFinancimentoTipo)){

				// 1.1. Caso exista, no débito cobrado, a identificação do parcelamento (PARC_ID com
				// o valor
				// diferente de nulo):
				if(debitoCobrado.getParcelamento() != null){

					// 1.1.1. Caso, na resolução de diretoria do débito cobrado de parcelamento,
					// esteja indicada
					// a emissão do assunto da RD (RDIR_ICEMISSAOASSUNTOCONTA=1 na tabela
					// RESOLUCAO_DIRETORIA
					// com RDIR_ID=RDIR_ID da tabela PARCELAMENTO com PARC_ID=PARC_ID da tabela
					// DEBITO_COBRADO):
					if(debitoCobrado.getParcelamento().getResolucaoDiretoria() != null
									&& debitoCobrado.getParcelamento().getResolucaoDiretoria().getIndicadorEmissaoAssuntoConta()
													.equals(ConstantesSistema.SIM)){

						// 1.1.1.1. Descrição do Débito = 10 primeiros caracteres de
						// DBTP_DSDEBITOTIPO da tabela
						// DEBITO_TIPO com DBTP_ID=DBTP_ID da tabela DEBITO_COBRADO mais um espaço
						// em branco mais
						// três primeiros caracteres do assunto da RD (RDIR_DSASSUNTO) mais o valor
						// do débito
						// correspondente ao débito cobrado de parcelamento (DBCB_VLPRESTACAO no
						// formato ZZ.ZZ9,99).
						if(debitoCobrado.getDebitoTipo() != null){

							descricaoDebito = Util.completarStringCaractereDireita(debitoCobrado.getDebitoTipo().getDescricao(), 10, ' ')
											+ " "
											+ Util.completarStringCaractereDireita(debitoCobrado.getParcelamento().getResolucaoDiretoria()
															.getDescricaoAssunto(), 3, ' ')
											+ Util.completaStringComEspacoAEsquerda(
															Util.formatarMoedaReal(debitoCobrado.getValorPrestacao()), 9);

						}

					}else{

						// 1.1.2. Caso contrário, ou seja, não há indicação de emissão do assunto da
						// RD na conta:
						// 1.1.2.1. Descrição do Débito = DBTP_DSDEBITOTIPO da tabela DEBITO_TIPO
						// com
						// DBTP_ID=DBTP_ID da tabela DEBITO_COBRADO.

						if(debitoCobrado.getDebitoTipo() != null){

							descricaoDebito = debitoCobrado.getDebitoTipo().getDescricao();

						}

					}

				}else{

					// 1.2. Caso contrário, ou seja, caso não exista, no débito cobrado, a
					// identificação do
					// parcelamento:
					// 1.2.1. Descrição do Débito = DBTP_DSDEBITOTIPO da tabela DEBITO_TIPO com
					// DBTP_ID=DBTP_ID
					// da tabela DEBITO_COBRADO.

					if(debitoCobrado.getDebitoTipo() != null){

						descricaoDebito = debitoCobrado.getDebitoTipo().getDescricao();

					}

				}

			}else{

				descricaoDebito = debitoCobrado.getDebitoTipo().getDescricao();

			}

		}else{

			descricaoDebito = debitoCobrado.getDebitoTipo().getDescricao();

		}

		return descricaoDebito;

	}

	public void ajustarFaturamentoServicosRetificarContasErradasDeso(Integer idFaturamentoGrupo, Integer anoMesReferencia)
					throws ControladorException{

		try{

			log.info("-----------AJUSTE FAT CONTA INÍCIO GRUPO: " + idFaturamentoGrupo.toString() + "----------------");
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteRetificarContasRetificadasNaPrimeiraRotinaProblemaQuantidadeRubricas(idFaturamentoGrupo,
							anoMesReferencia);
			log.info("------------AJUSTE FAT CONTA FIM GRUPO: " + idFaturamentoGrupo.toString() + "------------------");

		}catch(IOException e){

			log.error("-----------------------ERRO AJUSTE FAT CONTA GRUPO: " + idFaturamentoGrupo.toString() + "------------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}catch(Exception e){

			log.error("-----------------------ERRO AJUSTE FAT CONTA GRUPO: " + idFaturamentoGrupo.toString() + "------------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	public void verificarImoveisComErroRelacao5(Collection<FaturamentoGrupo> colecaoFaturamentoGrupo, Integer anoMesReferencia)
					throws ControladorException{

		try{

			log.error("--------INÍCIO VERIFICAR IMÓVEIS COM COBRANÇA SERVIÇO ERRADA RELAÇÃO 5--------");
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.verificarImoveisComErroRelacao5(colecaoFaturamentoGrupo, anoMesReferencia);

			log.error("--------FIM VERIFICAR IMÓVEIS COM COBRANÇA SERVIÇO ERRADA RELAÇÃO 5--------");
		}catch(IOException e){

			log.error("--------ERRO VERIFICAR IMÓVEIS COM COBRANÇA SERVIÇO ERRADA RELAÇÃO 5--------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}catch(Exception e){

			log.error("--------ERRO VERIFICAR IMÓVEIS COM COBRANÇA SERVIÇO ERRADA RELAÇÃO 5--------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	public void verificarImoveisComErroRelacao1e2(Collection<FaturamentoGrupo> colecaoFaturamentoGrupo, Integer anoMesReferencia)
					throws ControladorException{

		try{

			log.error("--------INÍCIO VERIFICAR IMÓVEIS COM COBRANÇA SERVIÇO ERRADA RELAÇÃO 1 e 2--------");
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.verificarImoveisComErroRelacao1e2(colecaoFaturamentoGrupo, anoMesReferencia);

			log.error("--------FIM VERIFICAR IMÓVEIS COM COBRANÇA SERVIÇO ERRADA RELAÇÃO 1 e 2--------");
		}catch(IOException e){

			log.error("--------ERRO VERIFICAR IMÓVEIS COM COBRANÇA SERVIÇO ERRADA RELAÇÃO 1 e 2--------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}catch(Exception e){

			log.error("--------ERRO VERIFICAR IMÓVEIS COM COBRANÇA SERVIÇO ERRADA RELAÇÃO 1 e 2--------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}


	public Integer retificarContaAjusteFaturamento(Integer anoMesConta, Conta contaAtual, Imovel imovel, Collection colecaoDebitoCobrado,
					LigacaoAguaSituacao ligacaoAguaSituacao, LigacaoEsgotoSituacao ligacaoEsgotoSituacao, String consumoAgua,
					String consumoEsgoto, String percentualEsgoto, Date dataVencimentoConta, ContaMotivoRetificacao contaMotivoRetificacao,
					Usuario usuarioLogado, ConsumoTarifa consumoTarifa, Collection colecaoCreditoRealizado) throws ControladorException{

		Integer idContaGerada = null;

		try{

			// ------------ <REGISTRAR TRANSAÇÃO>----------------------------

			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONTA_RETIFICAR, contaAtual.getImovel()
							.getId(), contaAtual.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			registradorOperacao.registrarOperacao(contaAtual);

			// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

			// A variável calcularValoresConta com valor NULL sinaliza que o método foi chamado pelo
			// processo de arrecadação. Esse tratamento foi feito para a empresa CASAL. Os valores
			// que estão checando se a variável é NULL devem ser preservados, pois a retificação é
			// realizada apenas para incluir novos débitos de serviço.

			dataVencimentoConta = contaAtual.getDataVencimentoConta();

			// guarda situacão inicial da conta q podem ser alterados no
			// retificarContaAtualizarSituacao
			// para se for levantada alguma exceção, a conta não perder seu estado
			// inicial
			DebitoCreditoSituacao debitoCreditoSituacaoAnteriorNaoAlterado = contaAtual.getDebitoCreditoSituacaoAnterior();
			DebitoCreditoSituacao debitoCreditoSituacaoAtualNaoAlterado = contaAtual.getDebitoCreditoSituacaoAtual();
			Integer referenciaContabilNaoAlterado = contaAtual.getReferenciaContabil();
			Usuario usuarioNaoAlterado = contaAtual.getUsuario();
			Date dataInclusaoContaAtual = contaAtual.getDataInclusao();

			/*
			 * [SF002] - Gerar dados da conta
			 * ======================================================================
			 */

			SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

			// Atualizar os seguintes atributos da conta a ser retificada

			// Debito Credito Situacao Atual(Com o valor correspondente a retificada na tabela)
			DebitoCreditoSituacao debitoCreditoSituacaoAtualAtualizacao = new DebitoCreditoSituacao();

			// Situação Atual
			debitoCreditoSituacaoAtualAtualizacao.setId(DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);
			contaAtual.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtualAtualizacao);

			// Ano Mês referencia contábil
			contaAtual.setReferenciaContabil(sistemaParametro.getAnoMesFaturamento());

			/*
			 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar na tabela de conta o
			 * usuário que está logado no sistema
			 */

			// Usuario
			contaAtual.setUsuario(usuarioLogado);

			// Última alteração
			contaAtual.setUltimaAlteracao(new Date());

			// UPDATE
			try{

				if(contaAtual.getDebitoCreditoSituacaoAnterior() == null){
					repositorioFaturamento.retificarContaAtualizarSituacao(contaAtual, null);
				}else{
					repositorioFaturamento.retificarContaAtualizarSituacao(contaAtual, contaAtual.getDebitoCreditoSituacaoAnterior()
									.getId());
				}

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				// conta atual volta a situação inicial
				contaAtual.setDebitoCreditoSituacaoAnterior(debitoCreditoSituacaoAnteriorNaoAlterado);
				contaAtual.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtualNaoAlterado);
				contaAtual.setReferenciaContabil(referenciaContabilNaoAlterado);

				contaAtual.setUsuario(usuarioNaoAlterado);

				throw new ControladorException("erro.sistema", ex);
			}

			ContaGeral contaGeralInserir = new ContaGeral();

			// valor fixo
			Short indicadorHistorico = 2;

			contaGeralInserir.setIndicadorHistorico(indicadorHistorico);

			// Ultima Alteração
			contaGeralInserir.setUltimaAlteracao(new Date());

			// Inserindo no BD
			Integer idGerado = (Integer) this.getControladorUtil().inserir(contaGeralInserir);

			// seta o id da Conta Geral gerada no objeto contaGeral
			contaGeralInserir.setId(idGerado);

			Conta contaInserir = new Conta();

			contaInserir.setIdAntigo(contaAtual.getId());
			registradorOperacao.registrarOperacao(contaInserir);

			// Adiciona o id do imóvel selecionado
			contaInserir.setImovel(contaAtual.getImovel());

			// Adiciona o id do contaGeral selecionado
			contaInserir.setContaGeral(contaGeralInserir);

			// Carregando o ID gerado no objeto Conta
			contaInserir.setId(idGerado);

			// Ano e mês de referência informado
			contaInserir.setReferencia(anoMesConta.intValue());

			DebitoCreditoSituacao debitoCreditoSituacaoInserir = new DebitoCreditoSituacao();

			// Situação Atual
			debitoCreditoSituacaoInserir.setId(DebitoCreditoSituacao.RETIFICADA);

			// Debito credito situacao
			contaInserir.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoInserir);

			// Debito Credito Situacao Anterior(Com o valor NULL)

			// Situação da ligação de água
			contaInserir.setLigacaoAguaSituacao(ligacaoAguaSituacao);

			// Situação da ligação de esgoto
			contaInserir.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

			// Motivo Nao Entrega Documento(Com o valor NULL)

			// Localidade
			contaInserir.setLocalidade(contaAtual.getLocalidade());

			// Quadra
			contaInserir.setQuadraConta(contaAtual.getQuadraConta());

			// Lote
			contaInserir.setLote(contaAtual.getLote());

			// Sublote
			contaInserir.setSubLote(contaAtual.getSubLote());

			// Código do setor comercial
			FiltroQuadra filtroQuadra = new FiltroQuadra();

			filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID, contaAtual.getQuadraConta().getId()));

			filtroQuadra.adicionarCaminhoParaCarregamentoEntidade(FiltroQuadra.SETOR_COMERCIAL);

			Collection colecaoQuadra = this.getControladorUtil().pesquisar(filtroQuadra, Quadra.class.getName());

			if(colecaoQuadra != null){

				Quadra quadra = (Quadra) Util.retonarObjetoDeColecao(colecaoQuadra);

				contaInserir.setCodigoSetorComercial(quadra.getSetorComercial().getCodigo());

				// Número da quadra
				contaInserir.setQuadra(Integer.valueOf(quadra.getNumeroQuadra()));

			}

			// Código comentado por não ser usado no ADA - Saulo Lima 12/09/2008
			// contaInserir.setDigitoVerificadorConta(new
			// Short(String.valueOf(Util.calculoRepresentacaoNumericaCodigoBarrasModulo10(mesAnoConta))));

			// Crédito de consumo
			contaInserir.setCreditoConsumo(contaAtual.getCreditoConsumo());

			// Indicador cobranca multa (2)
			contaInserir.setIndicadorCobrancaMulta(contaAtual.getIndicadorCobrancaMulta());

			contaInserir.setDataVencimentoConta(dataVencimentoConta);

			// Data Vencimento Original
			contaInserir.setDataVencimentoOriginal(contaAtual.getDataVencimentoOriginal());

			// Indicador alteração vencimento (2)
			contaInserir.setIndicadorAlteracaoVencimento(Short.valueOf("2"));

			// Consumo de Água
			contaInserir.setConsumoAgua(contaAtual.getConsumoAgua());

			// Consumo de Esgoto
			contaInserir.setConsumoEsgoto(contaAtual.getConsumoEsgoto());

			// Consumo Rateio Água (Com valor NULL)

			// Consumo Rateio Água (Com valor NULL)

			// Valor total de água
			BigDecimal valorTotalAgua = BigDecimal.ZERO;

			valorTotalAgua = contaAtual.getValorAgua();

			contaInserir.setValorAgua(valorTotalAgua);

			// Valor total de esgoto
			BigDecimal valorTotalEsgoto = BigDecimal.ZERO;
			valorTotalEsgoto = contaAtual.getValorEsgoto();

			contaInserir.setValorEsgoto(valorTotalEsgoto);

			// Valor total dos débitos
			BigDecimal valorTotalDebito = null;
			// Valor total dos créditos
			BigDecimal valorTotalCredito = null;

			valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado);
			valorTotalCredito = this.calcularValorTotalCreditoConta(colecaoCreditoRealizado);

			contaInserir.setDebitos(valorTotalDebito);
			contaInserir.setValorCreditos(valorTotalCredito);

			// Percentual de esgoto
			if(percentualEsgoto != null && !percentualEsgoto.equalsIgnoreCase("")){
				contaInserir.setPercentualEsgoto(Util.formatarMoedaRealparaBigDecimal(percentualEsgoto));
			}else{
				contaInserir.setPercentualEsgoto(new BigDecimal("0.00"));
			}

			// valor do imposto
			GerarImpostosDeduzidosContaHelper impostosDeduzidosConta = gerarImpostosDeduzidosConta(contaAtual.getImovel().getId(),
							anoMesConta, valorTotalAgua, valorTotalEsgoto, valorTotalDebito, valorTotalCredito);

			contaInserir.setValorImposto(impostosDeduzidosConta.getValorTotalImposto());

			// Data de validade da conta
			Date dataValidadeConta = this.retornaDataValidadeConta(dataVencimentoConta);
			contaInserir.setDataValidadeConta(dataValidadeConta);

			// Data de inclusão - A conta retificada recebe a data de inclusão da conta Atual.
			contaInserir.setDataInclusao(dataInclusaoContaAtual);

			// Data de revisão (Com valor NULL)

			// Data de retificação - data corrente
			Calendar dataRetificacaoConta = new GregorianCalendar();
			contaInserir.setDataRetificacao(dataRetificacaoConta.getTime());

			// Data de cancelamento (Com valor NULL)

			// Data de emissão - data corrente
			Calendar dataEmissaoConta = new GregorianCalendar();
			contaInserir.setDataEmissao(dataEmissaoConta.getTime());

			// Ano / Mês de referência contábil
			contaInserir.setReferenciaContabil(Util.getAnoMesComoInteger(new Date()));

			// Ano / Mês de referência baixa contábil (Com valor NULL)

			// Motivo de retificação da conta
			contaInserir.setContaMotivoRetificacao(contaMotivoRetificacao);

			// Consumo tarifa
			contaInserir.setConsumoTarifa(consumoTarifa);

			// Perfil do imóvel
			contaInserir.setImovelPerfil(contaAtual.getImovelPerfil());

			// Indicador débito conta
			contaInserir.setIndicadorDebitoConta(this.obterIndicadorDebitoConta(contaAtual.getDataVencimentoConta(),
							contaInserir.getDataVencimentoConta(), imovel.getIndicadorDebitoConta()));

			/*
			 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar na tabela de conta o
			 * usuário que está logado no sistema
			 */

			// Usuario
			contaInserir.setUsuario(usuarioLogado);

			// Ultima Alteração
			contaInserir.setUltimaAlteracao(new Date());

			// Nome Conta
			// contaInserir.setNomeConta(contaAtual.getNomeConta());

			// Montando a coleção de ContaCategoria
			Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasContaCategoria(contaAtual);
			Collection colecaoContaCategoria = montarColecaoContaCategoria(colecaoCategoria, contaInserir);

			/*
			 * Estas coleções são setadas antes de enviar o objeto conta para o controlador util,
			 * para lá, no momento de inserir ou atualizar, o
			 * interceptador consiga ter as novas coleções que serão associadas a esta conta, a fim
			 * de verificar as alterações ocorridas nos itens da
			 * coleção (inserção, remoção ou alteração)
			 */
			contaInserir.setContaCategorias(new HashSet(colecaoContaCategoria));
			contaInserir.setDebitoCobrados(new HashSet(colecaoDebitoCobrado));
			contaInserir.setCreditoRealizados(new HashSet(colecaoCreditoRealizado));

			Rota rota = imovel.getRota();
			contaInserir.setRota(rota);

			contaInserir.setIndicadorPagamento(contaAtual.getIndicadorPagamento());

			// *****************************************
			/*
			 * Collection colecaoDebitoCobradoOriginal = obterDebitosCobradosConta(contaAtual);
			 * BigDecimal valorTotalDebitoOriginal =
			 * this.calcularValorTotalDebitoConta(colecaoDebitoCobradoOriginal);
			 * BigDecimal diferenca = BigDecimal.ZERO;
			 * if(valorTotalDebito.compareTo(valorTotalDebitoOriginal) > 0){
			 * diferenca = valorTotalDebito.subtract(valorTotalDebitoOriginal);
			 * }
			 * Collection colecaoDebitoACobrar = new ArrayList();
			 * Collection collOperacaoContabilHelper = new ArrayList();
			 * if(diferenca.compareTo(BigDecimal.ZERO) > 0){
			 * Object[] retorno = obterDebitoACobrarRetificado(colecaoDebitoCobradoOriginal,
			 * colecaoDebitoCobrado, diferenca, imovel);
			 * colecaoDebitoACobrar = (Collection) retorno[0];
			 * colecaoDebitoCobrado = (Collection) retorno[1];
			 * Iterator it = colecaoDebitoACobrar.iterator();
			 * while(it.hasNext()){
			 * DebitoACobrar debitoACobrar = (DebitoACobrar) it.next();
			 * OperacaoContabilHelper operacaoContabilHelper = new OperacaoContabilHelper();
			 * operacaoContabilHelper.setOperacaoContabil(OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);
			 * operacaoContabilHelper.setObjetoOrigem(debitoACobrar);
			 * collOperacaoContabilHelper.add(operacaoContabilHelper);
			 * }
			 * }
			 */
			// *****************************************

			// Inserindo no BD
			idContaGerada = (Integer) this.getControladorUtil().inserir(contaInserir);

			/*
			 * Inserir na tabela CLIENTE_CONTA CLIENTE_CONTA ClienteConta
			 * ======================================================================
			 */

			this.inserirClienteConta(contaInserir, imovel, null);

			/*
			 * Inserir na tabela CONTA_CATEGORIA e CONTA_CATEGORIA_CONSUMO_FAIXA
			 * ====================================================================
			 */
			FiltroContaCategoria filtroContaCategoria = new FiltroContaCategoria();
			filtroContaCategoria.adicionarParametro(new ParametroSimples(FiltroContaCategoria.CONTA_ID, contaAtual.getId()));
			filtroContaCategoria.adicionarCaminhoParaCarregamentoEntidade(FiltroContaCategoria.CATEGORIA);
			filtroContaCategoria.adicionarCaminhoParaCarregamentoEntidade(FiltroContaCategoria.SUBCATEGORIA);

			Collection<ContaCategoria> colecaoContaCategoriaAux = this.getControladorUtil().pesquisar(filtroContaCategoria,
							ContaCategoria.class.getName());

			if(!Util.isVazioOrNulo(colecaoContaCategoriaAux)){
				Set<ContaCategoria> contaCategorias = new HashSet<ContaCategoria>();

				ContaCategoriaPK contaCategoriaPK = null;

				for(ContaCategoria contaCategoria : colecaoContaCategoriaAux){
					contaCategoriaPK = contaCategoria.getComp_id();
					contaCategoriaPK.setConta(contaInserir);

					contaCategoria.setUltimaAlteracao(new Date());

					contaCategorias.add(contaCategoria);
				}

				contaInserir.setContaCategorias(contaCategorias);

				this.getControladorUtil().inserirColecaoObjetos(colecaoContaCategoriaAux);

				FiltroContaCategoriaConsumoFaixa filtroContaCategoriaConsumoFaixa = new FiltroContaCategoriaConsumoFaixa();
				filtroContaCategoriaConsumoFaixa.adicionarParametro(new ParametroSimples(FiltroContaCategoriaConsumoFaixa.CONTA_ID,
								contaAtual.getId()));
				filtroContaCategoriaConsumoFaixa.adicionarCaminhoParaCarregamentoEntidade(FiltroContaCategoriaConsumoFaixa.CONTA_CATEGORIA);

				Collection<ContaCategoriaConsumoFaixa> colecaoContaCategoriaConsumoFaixaAux = this.getControladorUtil().pesquisar(
								filtroContaCategoriaConsumoFaixa, ContaCategoriaConsumoFaixa.class.getName());

				if(!Util.isVazioOrNulo(colecaoContaCategoriaConsumoFaixaAux)){
					ContaCategoria contaCategoria = null;

					for(ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa : colecaoContaCategoriaConsumoFaixaAux){
						contaCategoriaConsumoFaixa.setId(null);
						contaCategoriaConsumoFaixa.setUltimaAlteracao(new Date());

						contaCategoria = contaCategoriaConsumoFaixa.getContaCategoria();

						contaCategoriaPK = contaCategoria.getComp_id();
						contaCategoriaPK.setConta(contaInserir);
					}

					this.getControladorUtil().inserirColecaoObjetos(colecaoContaCategoriaConsumoFaixaAux);
				}
			}

			/**
			 * [UC0150] Retificar Conta
			 * [SB0002] – Gerar Dados da Conta
			 * 2. O sistema verifica se existem itens de negativação associados à conta - <<Inclui>>
			 * [UC0937 – Obter Itens de Negativação Associados à Conta] passando o identificador do
			 * imóvel (IMOV_ID da conta a ser retificada) e a referência (Ano e mês de referência da
			 * conta a ser retificada).
			 * [SB0005] – Atualizar Item da Negativação
			 */
			this.getControladorSpcSerasa().verificarHaRelacaoCancelamentoComItensNegativacaoRetificarConta(contaInserir);

			/*
			 * Gerar os débitos cobrados - DEBITO_COBRADO e DEBITO_COBRADO_CATEGORIA
			 * ======================================================================
			 */

			this.inserirDebitoCobrado(contaInserir, colecaoDebitoCobrado, imovel, colecaoCategoria, false);

			/*
			 * Gerar os créditos realizados - CREDITO_REALIZADO e CREDITO_REALIZADO_CATEGORIA
			 * ======================================================================
			 */

			this.inserirCreditoRealizado(contaInserir, colecaoCreditoRealizado, imovel, colecaoCategoria, false);

			/*
			 * incluir os impostos deduzidos da conta
			 * ======================================================================
			 */
			this.inserirImpostosDeduzidosConta(impostosDeduzidosConta, contaInserir, false);

			/*
			 * atualizar,caso existam, os pagamentos referentes a conta q foi retificada
			 * ======================================================================
			 */
			this.atualizarPagamentoContaRetificada(contaAtual.getId(), idContaGerada);

			/*
			 * Colocado por Raphael Rossiter em 03/07/2007 (Analista: Rosana Carvalho) OBJETIVO:
			 * Atualizar o id da conta na tabela
			 * DEBITO_AUTOMATICO_MOVIMENTO
			 */
			// this.atualizarDebitoAutomaticoMovimentoContaRetificada(contaAtual.getId(),
			// contaInserir, imovel);

			// [UC0566 – Gerar Histograma de Água e Esgoto]
			Collection<Conta> colecaoContaRetificada = Collections.singletonList(contaAtual);
			carregarContaParaHistograma(colecaoContaRetificada);
			getControladorHistograma().gerarHistogramaAguaEsgoto(colecaoContaRetificada, ConstantesSistema.GERACAO_HISTOGRAMA_CANCELAMENTO);

			// 8.7. Caso o indicador de débito automático da conta seja igual a “SIM”, atualiza
			// débito automático [SB0006 – Gerar Débito Automático]
			if(contaAtual.getIndicadorDebitoConta() != null && contaAtual.getIndicadorDebitoConta().equals(ConstantesSistema.SIM)){

				this.gerarDebitoAutomaticoMovimentoConta(contaAtual, contaInserir, true);

			}

			// Força a consulta a base de dados para resgatar o indicador de PDD mais recente da
			// contaAtual
			Conta contaTemp = this.repositorioArrecadacao.pesquisarConta(contaAtual.getId());

			// Atualizar os indicadores de PDD
			// 1. Setar o indicador de conta em PDD da contaInserir com o valor existente em
			// contaAtual e setar o indicar de conta em PDD da contaAtual com não (2).
			Short indicadorPDDPersistencia = new Short(contaTemp.getIndicadorPDD().shortValue());
			contaInserir.setIndicadorPDD(indicadorPDDPersistencia);
			contaAtual.setIndicadorPDD(ConstantesSistema.NAO);

			getControladorContabil().registrarLancamentoContabil(contaAtual, OperacaoContabil.CANCELAR_CONTA);

			getControladorContabil().registrarLancamentoContabil(contaInserir, OperacaoContabil.INCLUIR_CONTA);

			// if(!Util.isVazioOrNulo(collOperacaoContabilHelper)){
			// getControladorContabil().registrarLancamentoContabil(collOperacaoContabilHelper);
			// }

			// Atualizar PDD - Conta a Inserir
			// 2. Caso a conta a inserir esteja em PDD (CONTA.CNTA_ICPDD igual a "sim" (1)) e a
			// referência da inclusão da conta no PDD
			// (PROVISAO_DEVEDORES_DUVIDOSOS.PDDV_AMREFERENCIACONTABIL) seja menor ou igual a
			// referência de corte para PDD (PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com
			// PASI_CDPARAMETRO = 'P_REFERENCIA_CORTE_PDD') e a data de vencimento da conta após a
			// retificação seja maior ou igual ao primeiro dia do mês e ano da referência de corte
			ProvisaoDevedoresDuvidosos provisaoDevedoresDuvidosos = this.repositorioContabil
							.obterProvisaoDevedoresDuvidososMaisRecente(contaAtual.getId());

			// Seta novamente o indicador de persistencia caso a operação
			// registrarLancamentoContabil tenha recarregado o valor de PDD (neste caso ele já tinha
			// sido setado previamente para 2 no cancelamento)
			contaInserir.setIndicadorPDD(indicadorPDDPersistencia);

			if(contaInserir.getIndicadorPDD().equals(ConstantesSistema.SIM)
							&& provisaoDevedoresDuvidosos != null
							&& (provisaoDevedoresDuvidosos.getReferenciaContabil().intValue() <= Integer
											.parseInt(ParametroContabil.P_REFERENCIA_CORTE_PDD.executar()))
							&& Util.compararData(contaInserir.getDataVencimentoConta(), Util.gerarDataInicialApartirAnoMesRefencia(Integer
											.valueOf(ParametroContabil.P_REFERENCIA_CORTE_PDD.executar()))) >= 0){

				this.getControladorContabil().atualizarProvisaoDevedoresDuvidososLancamentoContabil(contaAtual, sistemaParametro,
								ProvisaoDevedoresDuvidososMotivoBaixa.ALTERACAO_VENCIMENTO);

				contaInserir.setIndicadorPDD(ConstantesSistema.NAO);

			}

			// 3. Caso a conta a inserir esteja em PDD (CONTA.CNTA_ICPDD igual a "sim" (1)),
			// atualizar a tabela PROVISAO_DEVEDORES_DUVIDOSOS com o Id da nova conta gerada.
			if(contaInserir.getIndicadorPDD().equals(ConstantesSistema.SIM)){
				ProvisaoDevedoresDuvidosos pdd = this.repositorioContabil.obterProvisaoDevedoresDuvidososMaisRecente(contaAtual.getId());
				ContaGeral contaGeral = new ContaGeral();
				contaGeral.setId(contaInserir.getId());
				pdd.setContaGeral(contaGeral);
				pdd.setUltimaAlteracao(new Date());

				this.repositorioUtil.atualizar(pdd);

				this.repositorioFaturamento.atualizarIndicadorPDDDeConta(contaInserir.getId(), ConstantesSistema.SIM, false);

			}

			// Inicio - Item 8
			// Transfere a conta cancelada por retificação e os seus respectivos débitos cobrados e
			// créditos realizados para histórico
			Collection<Conta> contasARemover = new ArrayList<Conta>();
			Collection<Integer> contasGeralAAtualizar = new ArrayList<Integer>();
			contasARemover.add(contaAtual);
			contasGeralAAtualizar.add(contaAtual.getId());

			if(contasARemover != null && !contasARemover.isEmpty() && contasARemover.iterator().next() != null){
				if(sistemaParametro != null && sistemaParametro.getAnoMesFaturamento() != null){
					transferirContasParaHistorico(contasARemover, sistemaParametro.getAnoMesFaturamento());
				}
			}

			// Indicador atualizado no método transferirContasParaHistorico(...)
			// atualizarIndicadorContaNoHistorico(contasGeralAAtualizar);

			// Fim - Item 8

			// 9. Caso exista pagamento para conta, classificar pagamento de conta
			// [UC0300 – ClassificarPagamentosDevolucoes]
			if(contasARemover != null && !contasARemover.isEmpty()){

				for(Conta contaClassificar : contasARemover){
					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.IMOVEL_ID, contaClassificar.getImovel().getId()));
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ANO_MES_REFERENCIA_PAGAMENTO, Integer
									.valueOf(contaClassificar.getReferencia())));

					Collection<Pagamento> colecaoPagamentos = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

					if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){
						for(Pagamento pagamento : colecaoPagamentos){
							pagamento.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAtual());
						}

						getControladorArrecadacao()
										.classificarPagamentosRegistroMovimentoArrecadadores(colecaoPagamentos.iterator().next());

						OperacaoContabilHelper helper = getControladorArrecadacao().definirOrigemOperacaoContabilPagamento(
										colecaoPagamentos.iterator().next(), true);
						if(helper.getOperacaoContabil() != null){
							getControladorContabil().registrarLancamentoContabil(helper.getObjetoOrigem(), helper.getOperacaoContabil());
						}
					}
				}

			}

			// Ajuste do histórico de consumo
			boolean atualizarConsumoMedio = false;

			Integer anoMesInicial = null;

			Integer anoMesFinal = null;

			Integer anoMesFaturamento = this.retornaAnoMesFaturamentoGrupo(imovel.getId());

			Short mesesMediaConsumo = sistemaParametro.getMesesMediaConsumo();

			Integer menorAnoMesReferencia = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesFaturamento, new Integer(mesesMediaConsumo) - 1);

			if(contaAtual.getReferencia() >= menorAnoMesReferencia){
				anoMesInicial = menorAnoMesReferencia;

				anoMesFinal = anoMesFaturamento;

				atualizarConsumoMedio = true;
			}else{
				anoMesInicial = contaAtual.getReferencia();

				anoMesFinal = contaAtual.getReferencia();

				atualizarConsumoMedio = false;
			}

			Collection<ImovelMicromedicao> colecaoImovelMicromedicao = this.getControladorMicromedicao()
							.pesquisaConsumoHistoricoSubstituirConsumo(imovel.getId(), anoMesInicial, anoMesFinal);

			if(!Util.isVazioOrNulo(colecaoImovelMicromedicao)){
				ConsumoHistorico consumoHistoricoAgua = null;
				ConsumoHistorico consumoHistoricoEsgoto = null;

				Integer consumoFaturadoMesAgua = ConstantesSistema.ZERO.intValue();

				if(!Util.isVazioOuBranco(consumoAgua)){
					consumoFaturadoMesAgua = Integer.valueOf(consumoAgua);
				}

				Integer consumoFaturadoMesEsgoto = null;

				if(!Util.isVazioOuBranco(consumoEsgoto)){
					consumoFaturadoMesEsgoto = Integer.valueOf(consumoEsgoto);
				}

				for(ImovelMicromedicao imovelMicromedicao : colecaoImovelMicromedicao){
					imovelMicromedicao.setImovel(imovel);

					consumoHistoricoAgua = imovelMicromedicao.getConsumoHistorico();
					consumoHistoricoEsgoto = imovelMicromedicao.getConsumoHistoricoEsgoto();

					if((consumoHistoricoAgua != null && consumoHistoricoAgua.getReferenciaFaturamento() == contaAtual.getReferencia())
									|| (consumoHistoricoEsgoto != null && consumoHistoricoEsgoto.getReferenciaFaturamento() == contaAtual
													.getReferencia())){
						if(consumoHistoricoAgua != null){

							if(consumoFaturadoMesAgua == consumoHistoricoAgua.getNumeroConsumoFaturadoMes()){
								// Não atualiza na base
								imovelMicromedicao.setConsumoHistorico(null);

							}else{

								ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
								consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_RETIFICADO);

								consumoHistoricoAgua.setConsumoAnormalidade(consumoAnormalidade);
								consumoHistoricoAgua.setNumeroConsumoFaturadoMes(consumoFaturadoMesAgua);

							}

						}

						if(consumoHistoricoEsgoto != null){
							if(consumoFaturadoMesEsgoto == consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes()){
								// Não atualiza na base
								imovelMicromedicao.setConsumoHistoricoEsgoto(null);

							}else{

								consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoFaturadoMesEsgoto);

							}
						}
					}
				}

				this.getControladorMicromedicao().atualizarConsumosAnterioresEConsumosMedio(colecaoImovelMicromedicao, usuarioLogado,
								atualizarConsumoMedio);

			}

			/*
			 * TODO Provavelmente entrará aqui o [UC0207 – Gerar/Atualizar Resumo de Faturamento]
			 * após as especificações.
			 */

			// [UC0566 – Gerar Histograma de Água e Esgoto]
			Collection colecaoContaInserida = Collections.singletonList(contaInserir);
			carregarContaParaHistograma(colecaoContaInserida);
			getControladorHistograma().gerarHistogramaAguaEsgoto(colecaoContaInserida, ConstantesSistema.GERACAO_HISTOGRAMA_INCLUSAO);

			// transfere a conta para o histórico juntamente com seus
			// débitos cobrados e créditos realizados
			BigDecimal valorAguaEsgotoDebitos = contaInserir.getValorAgua().add(
							contaInserir.getValorEsgoto().add(contaInserir.getDebitos()));

			valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(contaInserir.getValorCreditos());
			valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(contaInserir.getValorImposto());

			if(valorAguaEsgotoDebitos.compareTo(BigDecimal.ZERO) == 0){
				Collection<Conta> colecaoConta = new ArrayList<Conta>();
				colecaoConta.add(contaInserir);
				this.transferirContasParaHistorico(colecaoConta, sistemaParametro.getAnoMesFaturamento());
			}

			// Substituir Os ID antigos pelo novo ID da Conta nas tabelas

			// Boleto Bancário.
			this.repositorioFaturamento.alterarContaBoletoBancario(contaAtual.getId(), idContaGerada);

			// Itens do Documento de Cobrança.
			this.repositorioFaturamento.alterarContaCobrancaDocumentoItem(contaAtual.getId(), idContaGerada);

			// Itens da Administração da Cobrança do Imóvel.
			this.repositorioFaturamento.alterarContaImovelCobrancaAdministrivaItem(contaAtual.getId(), idContaGerada);

			// Documentos Não Entregues.
			this.repositorioFaturamento.alterarContaDocumentoNaoEntregue(contaAtual.getId(), idContaGerada);

			// Itens da Fatura.
			this.repositorioFaturamento.alterarContaFaturaItem(contaAtual.getId(), idContaGerada);

			// Transf. para histórico
			// if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){
			// this.transferirDebitosACobrarParaHistorico(colecaoDebitoACobrar, true);
			// }

		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception e1){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e1);
		}

		return idContaGerada;

	}

	/**
	 * Método que realiza o ajuste do faturamento de tarifas da DESO para referência 201211
	 * 
	 * @author Yara Souza
	 * @date 15/11/2012
	 */
	public void ajustarFaturamentoTarifasDeso(Integer idFaturamentoGrupo, Integer anoMesReferencia) throws ControladorException{

		EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.AJUSTE_FATURAMENTO_TARIFAS_3);
		String emailRemetente = envioEmail.getEmailRemetente();
		String tituloMensagem = envioEmail.getTituloMensagem();
		String emailReceptor = envioEmail.getEmailReceptor();

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteTarifas(idFaturamentoGrupo, anoMesReferencia);

			String corpoMensagem = envioEmail.getCorpoMensagem();
			ServicosEmail.enviarMensagem(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem);

		}catch(Exception e){

			String corpoMensagem = "ERRO NO PROCESSAMENTO";

			try{

				ServicosEmail.enviarMensagem(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem);
			}catch(ErroEmailException e1){
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC3143] Inserir Débito a Cobrar de Rateio por Macromedidor
	 * 
	 * @author Ado Rocha
	 * @date 05/03/2014
	 */
	public void inserirDebitoACobrarRateioCondominio(RegistroAtendimento registroAtendimento, Usuario usuarioLogado, String[] ids,
					Integer numeroPrestacoes, BigDecimal valorTotalServico, BigDecimal valorEntrada, BigDecimal percentualAbatimento,
					Integer anoMesCobrancaDebito, DebitoTipo debitoTipo, CobrancaForma cobrancaForma, String parametroDebitoTipoRateio)
					throws ControladorException{

		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

		for(int i = 0; i < ids.length; i++){
			String idImovel = ids[i];

			FiltroImovel filtroImovel = new FiltroImovel();
			filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovel));
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOCALIDADE);
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.QUADRA);
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.ROTA);
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.ROTA_FATURAMENTO_GRUPO);
			Collection colecaoImovel = (Collection) this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
			Imovel imovel = (Imovel) Util.retonarObjetoDeColecao(colecaoImovel);

			FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.IMOVEL);
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.DEBITO_TIPO);
			filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, imovel.getId()));
			filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.REFERENCIA_DEBITO, sistemaParametro
							.getAnoMesFaturamento()));
			filtroDebitoACobrar.adicionarParametro(new ParametroSimples("debitoTipo.id", debitoTipo.getId()));
			Collection colecaoDebitoACobrar = (Collection) this.getControladorUtil().pesquisar(filtroDebitoACobrar,
							DebitoACobrar.class.getName());

			if(colecaoDebitoACobrar != null && !Util.isVazioOrNulo(colecaoDebitoACobrar)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.ano_mes_imovel_condominio_possui_debito", null, imovel.getId().toString(),
								Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesCobrancaDebito));
			}

			DebitoACobrar debitoACobrar = new DebitoACobrar();
			debitoACobrar.setDebitoTipo(debitoTipo);
			debitoACobrar.setValorDebito(valorTotalServico);
			debitoACobrar.setImovel(imovel);
			debitoACobrar.setGeracaoDebito(new Date());
			debitoACobrar.setLocalidade(imovel.getLocalidade());
			debitoACobrar.setQuadra(imovel.getQuadra());
			debitoACobrar.setAnoMesReferenciaDebito(imovel.getRota().getFaturamentoGrupo().getAnoMesReferencia());
			debitoACobrar.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());
			debitoACobrar.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
			debitoACobrar.setCobrancaForma(cobrancaForma);
			debitoACobrar.setUltimaAlteracao(new Date());
			debitoACobrar.setAnoMesCobrancaDebito(anoMesCobrancaDebito);
			debitoACobrar.setRegistroAtendimento(registroAtendimento);
			debitoACobrar.setCodigoSetorComercial(imovel.getCodigoSetorComercial());
			debitoACobrar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
			debitoACobrar.setNumeroLote(imovel.getLote());
			debitoACobrar.setNumeroSubLote(imovel.getSubLote());
			debitoACobrar.setPercentualTaxaJurosFinanciamento(Util.formatarMoedaRealparaBigDecimal("0"));

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_DEBITO_A_COBRAR_INSERIR,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_DEBITO_A_COBRAR_INSERIR);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			debitoACobrar.setOperacaoEfetuada(operacaoEfetuada);
			debitoACobrar.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

			registradorOperacao.registrarOperacao(debitoACobrar);
			// ------------ FIM DE REGISTRAR TRANSAÇÃO ----------------

			this.inserirDebitoACobrar(numeroPrestacoes, debitoACobrar, valorTotalServico, imovel, percentualAbatimento, valorEntrada,
							usuarioLogado, false, null, null, null);
		}

	}


		/**
	 * [UC3034] Gerar Multa por Descumprimento de Parcelamento
	 * Este caso de uso tem como objetivo verificar as situações que caracterizam o descumprimento
	 * de um parcelamento e, sendo confirmado, gerar multa.
	 * 
	 * @author Anderson Italo
	 * @date 04/02/2012
	 * @throws ControladorException
	 */
	public void gerarMultaPorDescumprimentoParcelamento(int idFuncionalidadeIniciada, FaturamentoGrupo faturamentoGrupo)
					throws ControladorException{

		int idUnidadeIniciada = 0;
		try{

			// Registrar o início do processamento da unidade de processamento do batch
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			// Selecionar os perfis de parcelamento que possuem multa por descumprimento com valor
			// maior que zero
			Collection<ParcelamentoPerfil> colecaoParcelamentoPerfil = repositorioFaturamento
							.selecionarResolucaoDiretoriaComMultaDescumprimentoMaiorQueZero();

			if(!Util.isVazioOrNulo(colecaoParcelamentoPerfil)){

				// Variáveis utilizadas posteriormente no loop
				SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();
				DebitoTipo debitoTipoMulta = new DebitoTipo();
				debitoTipoMulta.setId(DebitoTipo.MULTA_POR_DESCUMPRIMENTO_PARCELAMENTO);

				for(ParcelamentoPerfil parcelamentoPerfil : colecaoParcelamentoPerfil){

					/*
					 * Consultar os parcelamentos ativos realizados com este perfil e com forma de
					 * cobrança em conta
					 */
					Collection<Parcelamento> colecaoParcelamento = repositorioFaturamento.consultarParcelamentoAtivosRealizadosPorPerfil(
									parcelamentoPerfil.getId(), faturamentoGrupo.getId());

					if(!Util.isVazioOrNulo(colecaoParcelamento)){

						for(Parcelamento parcelamento : colecaoParcelamento){

							// [SB001 – Selecionar débitos cobrados vencidos]
							List<DebitoCobrado> colecaoDebitoCobrado = repositorioFaturamento
											.selecionarDebitosCobradosVencidos(parcelamento.getId());

							if(!Util.isVazioOrNulo(colecaoDebitoCobrado)){

								/*
								 * Caso a quantidade de débitos cobrados
								 * selecionados seja maior ou igual ao número de
								 * prestações descumpridas para cobrança de multa
								 */

								if(colecaoDebitoCobrado.size() >= parcelamentoPerfil.getNumeroPretacoesDescumpridasParaCobrancaMulta()
												.intValue()){

									/*
									 * Verifica se o número de prestações consecutivas vencidas para
									 * cobrar multa é maior do que o especificado no perfil do
									 * parcelamento
									 */
									int numeroPrestacoesConsecutivas = 1;
									boolean existePrestacoesConsecutivasParaCobrarMulta = false;

									if(colecaoDebitoCobrado.size() == 1){

										existePrestacoesConsecutivasParaCobrarMulta = true;
									}else{

										for(int i = 1; i < colecaoDebitoCobrado.size(); i++){

											DebitoCobrado debitoAtual = colecaoDebitoCobrado.get(i);
											DebitoCobrado debitoAnterior = colecaoDebitoCobrado.get(i - 1);

											if(debitoAtual.getNumeroPrestacaoDebito() == (debitoAnterior.getNumeroPrestacaoDebito() - 1)){

												numeroPrestacoesConsecutivas = numeroPrestacoesConsecutivas + 1;

												if(numeroPrestacoesConsecutivas == parcelamentoPerfil
																.getNumeroPretacoesDescumpridasParaCobrancaMulta().intValue()){

													existePrestacoesConsecutivasParaCobrarMulta = true;
													break;
												}
											}
										}
									}

									/*
									 * Caso existam N ou mais prestações consecutivas na coleção de
									 * débitos cobrados
									 */
									if(existePrestacoesConsecutivasParaCobrarMulta){

										/*
										 * Obter o maior ano/mês referência das contas associadas
										 * aos
										 * débitos cobrados consecutivos encontrado
										 */
										Integer maiorAnoMesReferencia = colecaoDebitoCobrado.get(0).getConta().getReferencia();

										DebitoACobrar multaExistente = repositorioFaturamento.obterDebitoParcelamentoPorAnoMesSelecionado(
														parcelamento.getId(), maiorAnoMesReferencia);

										/*
										 * Caso não haja multa cobrada para este parcelamento com
										 * referência de cobrança igual ao ano/mês obtido no item
										 * anterior
										 */
										if(multaExistente == null){

											/*
											 * Obtém os débitos a cobrar do parcelamento para
											 * calcular o valor restante e gerar a multa
											 */
											Collection<DebitoACobrar> colecaoDebitosParaGerarMulta = repositorioFaturamento
															.obterDebitoParcelamentoParaGerarMultaPorDescumprimento(parcelamento.getId());

											BigDecimal valorRestanteParcelamento = BigDecimal.ZERO;

											for(DebitoACobrar debitoACobrar : colecaoDebitosParaGerarMulta){

												// Calcular o valor restante do parcelamento
												BigDecimal resultadoDivisao = Util.dividirArredondando(debitoACobrar.getValorDebito()
																.setScale(Parcelamento.CASAS_DECIMAIS, Parcelamento.TIPO_ARREDONDAMENTO),
																new BigDecimal(String.valueOf(debitoACobrar.getNumeroPrestacaoDebito())));

												BigDecimal resultadoMultiplicacao = resultadoDivisao.multiply(new BigDecimal(String
																.valueOf(debitoACobrar.getNumeroPrestacaoCobradas())));

												valorRestanteParcelamento = valorRestanteParcelamento.add(debitoACobrar.getValorDebito()
																.subtract(resultadoMultiplicacao));
											}

											/*
											 * Calcular o valor da multa: valor restante *
											 * percentual da
											 * multa / 100
											 */
											BigDecimal valorMulta = (valorRestanteParcelamento.multiply(parcelamentoPerfil
															.getPercentualMultaPrestacaoDescumprida())).divide(new BigDecimal("100"));

											/*
											 * [SB002 – Gerar multa por descumprimento do
											 * parcelamento] e [SB0003 - Gerar Débito a Cobrar]
											 */
											this.criarDebitoACobrar(parcelamento.getImovel(), null, sistemaParametros, debitoTipoMulta,
															valorMulta, maiorAnoMesReferencia);
										}
									}
								}
							}
						}
					}
				}
			}

			// Registrar o fim do processamento da unidade de processamento do batch
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	public void verificarBloqueioFuncionalidadeMotivoRetificacaoRevisao(Collection idsConta, Usuario usuarioLogado,
					boolean validarPermissaoEspecialNoventa, boolean criticarContasEmRevisaoMotivosNaoParametrizados, String enderecoURL)
					throws ControladorException{

		FiltroConta filtroConta = new FiltroConta();
		filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.CONTA_MOTIVO_RETIFICACAO);
		filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.CONTA_MOTIVO_REVISAO);

		String parametroMotivoRevisaoNaoPermitidaAux = null;
		String parametroMotivoRetificacaoNaoPermitidaAux = null;
		String[] parametroMotivoRevisaoNaoPermitida = null;
		String[] parametroMotivoRetificacaoNaoPermitida = null;

		parametroMotivoRevisaoNaoPermitidaAux = ((String) ParametroFaturamento.P_MOTIVO_REVISAO_NAO_PERMITIDA.executar(this));
		if(parametroMotivoRevisaoNaoPermitidaAux != null){

			parametroMotivoRevisaoNaoPermitida = parametroMotivoRevisaoNaoPermitidaAux.split(",");
		}

		parametroMotivoRetificacaoNaoPermitidaAux = ((String) ParametroFaturamento.P_MOTIVO_RETIFICACAO_NAO_PERMITIDA.executar(this));
		if(parametroMotivoRetificacaoNaoPermitidaAux != null){

			parametroMotivoRetificacaoNaoPermitida = parametroMotivoRetificacaoNaoPermitidaAux.split(",");
		}

		Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(idsConta, filtroConta, Conta.class.getName());

		if(colecaoConta != null && !colecaoConta.isEmpty()){

			Iterator colecaoContaIt = colecaoConta.iterator();
			while(colecaoContaIt.hasNext()){

				Conta conta = (Conta) colecaoContaIt.next();

				if(conta.getContaMotivoRevisao() != null){

					boolean motivoRevisaoSemValidacaoParametrizada = true;

					/*
					 * [FS0022] – Verificar bloqueio funcionalidade por motivo da
					 * retificação/revisão da conta
					 */

					if(!Util.isVazioOrNulo(parametroMotivoRevisaoNaoPermitida)){
						for(int i = 0; i < parametroMotivoRevisaoNaoPermitida.length; i++){

							String parametroMotivoRevisaoCobrancaBancaria = ((String) ParametroCobranca.P_MOTIVO_REVISAO_COBRANCA_BANCARIA
											.executar(this));

							// Caso a conta esteja com o motivo de revisão Cobrança Bancária
							if(validarPermissaoEspecialNoventa == true
											&& parametroMotivoRevisaoCobrancaBancaria.equals(conta.getContaMotivoRevisao().getId()
															.toString())){

								motivoRevisaoSemValidacaoParametrizada = false;

								/*
								 * Se o usuário logado não possua permissão especial para
								 * imprimir/cancelar
								 * conta em revisão com motivo Cobrança Bancária
								 */
								if(!getControladorPermissaoEspecial().verificarPermissaoImprimirCancelarContaEmCobrancaBancaria(
												usuarioLogado)){

									throw new ControladorException("atencao.conta_em_cobranca_bacaria_usuario_nao_autorizado_acao", null);
								}else{

									// retornar para o passo correspondente no fluxo principal
									return;
								}
							}

							/*
							 * Caso o motivo da revisão da conta (CMRV_ID)
							 * corresponda a um dos valores do parâmetro
							 */
							if(conta.getContaMotivoRevisao().getId().equals(Util.obterInteger(parametroMotivoRevisaoNaoPermitida[i]))){

								motivoRevisaoSemValidacaoParametrizada = false;
								FiltroContaMotivoRevisao filtroContaMotivoRevisao = new FiltroContaMotivoRevisao();
								filtroContaMotivoRevisao.adicionarParametro(new ParametroSimples(FiltroContaMotivoRevisao.ID,
												parametroMotivoRevisaoNaoPermitida[i]));

								Collection<ContaMotivoRevisao> colecaoContaMotivoRevisao = (ArrayList<ContaMotivoRevisao>) this
												.getControladorUtil().pesquisar(filtroContaMotivoRevisao,
																ContaMotivoRevisao.class.getName());

								String parametroPermiteManipularContaRetidaComRestricaoUsuario = "";
								try{

									parametroPermiteManipularContaRetidaComRestricaoUsuario = ((String) ParametroCobranca.P_PERMITE_MANIPULAR_CONTA_RETIDA_COM_RESTRICAO_USUARIO
													.executar());
								}catch(ControladorException e1){

									throw new ActionServletException("atencao.sistemaparametro_inexistente",
													"P_PERMITE_MANIPULAR_CONTA_RETIDA_COM_RESTRICAO_USUARIO");
								}

								if(parametroPermiteManipularContaRetidaComRestricaoUsuario.equals(ConstantesSistema.SIM.toString())){

									// Verifica se o usuário tem permisão especial para manusear
									// contas
									// retidas
									Object[] permissaoEspecialManuseioContasRetidas = verificaPermissaoUsuarioParaManusearContaRetida(
													usuarioLogado, enderecoURL);
									boolean manuseioContaPorUsuarioAcessoPermitido = (Boolean) permissaoEspecialManuseioContasRetidas[1];

									if(!manuseioContaPorUsuarioAcessoPermitido){

										throw new ControladorException("atencao.motivo.revisao.retificacao.nao.permitida", null, conta
														.getImovel().getId().toString(), conta.getReferenciaFormatada(),
														colecaoContaMotivoRevisao.iterator().next().getDescricaoMotivoRevisaoConta());
									}
								}else{

									throw new ControladorException("atencao.motivo.revisao.retificacao.nao.permitida", null, conta
													.getImovel().getId().toString(), conta.getReferenciaFormatada(),
													colecaoContaMotivoRevisao.iterator().next().getDescricaoMotivoRevisaoConta());
								}
							}
						}
					}

					// Caso esteja indicado para validar se a conta esta em revisão e o motivo não
					// seja validado por parâmetro
					if(criticarContasEmRevisaoMotivosNaoParametrizados && motivoRevisaoSemValidacaoParametrizada){

						throw new ControladorException("atencao.nao_permite_emitir_conta_em_revisao");
					}
				}

				/*
				 * Caso alguma das contas selecionadas tenha sido retificadas
				 * e o motivo da retificação das contas corresponda a um dos valores do
				 * parâmetro
				 * exiba a mensagem de erro e retornar o fluxo principal
				 */
				if(conta.getDataRetificacao() != null && !Util.isVazioOrNulo(parametroMotivoRetificacaoNaoPermitida)){

					for(int i = 0; i < parametroMotivoRetificacaoNaoPermitida.length; i++){
						if(conta.getContaMotivoRetificacao() != null
										&& conta.getContaMotivoRetificacao().getId()
														.equals(Util.obterInteger(parametroMotivoRetificacaoNaoPermitida[i]))){

							FiltroContaMotivoRetificacao filtroContaMotivoRetificacao = new FiltroContaMotivoRetificacao();
							filtroContaMotivoRetificacao.adicionarParametro(new ParametroSimples(FiltroContaMotivoRetificacao.CODIGO,
											parametroMotivoRetificacaoNaoPermitida[i]));
							Collection<ContaMotivoRetificacao> colecaoContaMotivoRetificacao = (ArrayList<ContaMotivoRetificacao>) this
											.getControladorUtil().pesquisar(filtroContaMotivoRetificacao,
															ContaMotivoRetificacao.class.getName());

							if(colecaoContaMotivoRetificacao != null && !colecaoContaMotivoRetificacao.isEmpty()){
								throw new ControladorException("atencao.motivo.revisao.retificacao.nao.permitida", null, conta.getImovel()
												.getId().toString(), conta.getReferenciaFormatada(), colecaoContaMotivoRetificacao
												.iterator().next().getDescricaoMotivoRetificacaoConta());
							}

						}
					}

				}
			}
		}
	}

	private Object[] verificaPermissaoUsuarioParaManusearContaRetida(Usuario usuarioLogado, String enderecoURL) throws ControladorException{

		Object[] retorno = new Object[2];

		Integer idFuncionalidadeCorrente = 0;

		if(FuncionalidadeCorrente.get() != null){

			idFuncionalidadeCorrente = FuncionalidadeCorrente.get().getId();
		}

		retorno[0] = idFuncionalidadeCorrente;
		retorno[1] = true;

		switch(idFuncionalidadeCorrente.intValue()){
			case Funcionalidade.CONSULTAR_CONTA:

				retorno[0] = Funcionalidade.CONSULTAR_CONTA;
				boolean temPermissaoEmitirSegundaViaDebitoContaEmRevisao = getControladorPermissaoEspecial()
								.verificarPermissaoEmitirSegundaViaContaRetida(usuarioLogado);

				if(!temPermissaoEmitirSegundaViaDebitoContaEmRevisao){

					retorno[1] = false;
				}
				break;

			case Funcionalidade.EMITIR_EXTRATO_DEBITO:

				retorno[0] = Funcionalidade.EMITIR_EXTRATO_DEBITO;
				boolean temPermissaoEmitirExtratoDebitoDebitoContaEmRevisao = getControladorPermissaoEspecial()
								.verificarPermissaoEmitirExtratoDebitoContaRetida(usuarioLogado);

				if(!temPermissaoEmitirExtratoDebitoDebitoContaEmRevisao){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.MANTER_CONTA:

				retorno[0] = Funcionalidade.MANTER_CONTA;
				boolean temPermissaoManterContaRetida = getControladorPermissaoEspecial()
								.verificarPermissaoManterContaRetida(usuarioLogado);

				if(!temPermissaoManterContaRetida){

					retorno[1] = false;
				}
				break;

			case Funcionalidade.COLOCAR_CONTA_EM_REVISAO:

				retorno[0] = Funcionalidade.COLOCAR_CONTA_EM_REVISAO;
				boolean temPermissaoColocarContaRetidaEmRevisao = getControladorPermissaoEspecial()
								.verificarPermissaoColocarContaRetidaEmRevisao(usuarioLogado);

				if(!temPermissaoColocarContaRetidaEmRevisao){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.RETIRAR_CONTA_DE_REVISAO:

				retorno[0] = Funcionalidade.RETIRAR_CONTA_DE_REVISAO;
				boolean temPermissaoRetirarContaRetidaDeRevisao = getControladorPermissaoEspecial()
								.verificarPermissaoRetirarContaRetidaDeRevisao(usuarioLogado);

				if(!temPermissaoRetirarContaRetidaDeRevisao){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.CANCELAR_CONTA:

				retorno[0] = Funcionalidade.CANCELAR_CONTA;
				boolean temPermissaoCancelarContaRetida = getControladorPermissaoEspecial().verificarPermissaoCancelarContaRetida(
								usuarioLogado);

				if(!temPermissaoCancelarContaRetida){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.RETIFICAR_CONTA:

				retorno[0] = Funcionalidade.RETIFICAR_CONTA;
				boolean temPermissaoRetificarContaRetida = getControladorPermissaoEspecial().verificarPermissaoRetificarContaRetida(
								usuarioLogado);

				if(!temPermissaoRetificarContaRetida){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.MANTER_CONJUNTO_CONTAS_IMOVEL:

				retorno[0] = Funcionalidade.MANTER_CONJUNTO_CONTAS_IMOVEL;
				boolean temPermissaoManterConjuntoContasRetida = getControladorPermissaoEspecial()
								.verificarPermissaoManterConjuntoContasRetidas(usuarioLogado);

				if(!temPermissaoManterConjuntoContasRetida){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.CANCELAR_CONJUNTO_CONTAS_IMOVEL:

				retorno[0] = Funcionalidade.CANCELAR_CONJUNTO_CONTAS_IMOVEL;
				boolean temPermissaoCancelarConjuntoContasRetida = getControladorPermissaoEspecial()
								.verificarPermissaoCancelarConjuntoContasRetidas(usuarioLogado);

				if(!temPermissaoCancelarConjuntoContasRetida){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.ALTERAR_VENCIMENTO_CONTA:

				retorno[0] = Funcionalidade.ALTERAR_VENCIMENTO_CONTA;
				boolean temPermissaoAlterarVencimentoContaRetida = getControladorPermissaoEspecial()
								.verificarPermissaoAlterarVencimentoContaRetida(usuarioLogado);

				if(!temPermissaoAlterarVencimentoContaRetida){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.ALTERAR_VENCIMENTO_CONJUNTO_CONTAS_IMOVEL:

				retorno[0] = Funcionalidade.ALTERAR_VENCIMENTO_CONJUNTO_CONTAS_IMOVEL;
				boolean temPermissaoAlterarVencimentoConjuntoContasRetida = getControladorPermissaoEspecial()
								.verificarPermissaoAlterarVencimentoConjuntoContasRetidas(usuarioLogado);

				if(!temPermissaoAlterarVencimentoConjuntoContasRetida){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.RETIRAR_DEBITO_COBRADO_CONJUNTO_CONTAS_IMOVEL:

				retorno[0] = Funcionalidade.RETIRAR_DEBITO_COBRADO_CONJUNTO_CONTAS_IMOVEL;
				boolean temPermissaoRetirarDebitoCobradoConjuntoContasRetida = getControladorPermissaoEspecial()
								.verificarPermissaoRetirarDebitoCobradoConjuntoContasRetidas(usuarioLogado);

				if(!temPermissaoRetirarDebitoCobradoConjuntoContasRetida){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.RETIRAR_VALOR_AGUA_ESGOTO_CONJUNTO_CONTAS_IMOVEL:

				retorno[0] = Funcionalidade.RETIRAR_VALOR_AGUA_ESGOTO_CONJUNTO_CONTAS_IMOVEL;
				boolean temPermissaoRetirarValorAguaEsgotoConjuntoContasRetida = getControladorPermissaoEspecial()
								.verificarPermissaoRetirarValorAguaEsgotoConjuntoContasRetidas(usuarioLogado);

				if(!temPermissaoRetirarValorAguaEsgotoConjuntoContasRetida){

					retorno[1] = false;
				}
				break;
			case Funcionalidade.RETIRAR_REVISAO_CONJUNTO_CONTAS_IMOVEL:

				retorno[0] = Funcionalidade.RETIRAR_REVISAO_CONJUNTO_CONTAS_IMOVEL;
				boolean temPermissaoRetirarRevisaoConjuntoContasRetida = getControladorPermissaoEspecial()
								.verificarPermissaoRetirarRevisaoConjuntoContasRetidas(usuarioLogado);

				if(!temPermissaoRetirarRevisaoConjuntoContasRetida){

					retorno[1] = false;
				}
				break;
			default:
				break;
		}

		if(idFuncionalidadeCorrente.equals(0) && enderecoURL != null && enderecoURL.equals("/gerarRelatorioExtratoDebitoAction.do")){
			retorno[0] = Funcionalidade.EMITIR_EXTRATO_DEBITO;
			boolean temPermissaoEmitirExtratoDebitoDebitoContaEmRevisao = getControladorPermissaoEspecial()
							.verificarPermissaoEmitirExtratoDebitoContaRetida(usuarioLogado);

			if(!temPermissaoEmitirExtratoDebitoDebitoContaEmRevisao){

				retorno[1] = false;
			}

		}

		return retorno;
	}

	/**
	 * [UC0146] Manter Conta
	 * [FS0038] - Verificar Bloqueio Colocar Conta em Revisão por Motivo de Conta Retida
	 * 
	 * @author Anderson Italo
	 * @date 20/12/2013
	 */
	public void verificarBloqueioColocarContaRevisaoMotivoContaRetida(Integer idContaMotivoRevisao, Usuario usuarioLogado)
					throws ControladorException{

		String parametroMotivoRevisaoNaoPermitidaAux = null;
		String[] parametroMotivoRevisaoNaoPermitida = null;

		parametroMotivoRevisaoNaoPermitidaAux = ((String) ParametroFaturamento.P_MOTIVO_REVISAO_NAO_PERMITIDA.executar(this));
		if(parametroMotivoRevisaoNaoPermitidaAux != null){

			parametroMotivoRevisaoNaoPermitida = parametroMotivoRevisaoNaoPermitidaAux.split(",");
		}

		if(idContaMotivoRevisao != null){

			/*
			 * [FS0022] – Verificar bloqueio funcionalidade por motivo da
			 * retificação/revisão da conta
			 */
			for(int i = 0; i < parametroMotivoRevisaoNaoPermitida.length; i++){

				/*
				 * Caso o motivo da revisão corresponda a um dos valores do parâmetro
				 */
				if(idContaMotivoRevisao.equals(Util.obterInteger(parametroMotivoRevisaoNaoPermitida[i]))){

					FiltroContaMotivoRevisao filtroContaMotivoRevisao = new FiltroContaMotivoRevisao();
					filtroContaMotivoRevisao.adicionarParametro(new ParametroSimples(FiltroContaMotivoRevisao.ID,
									parametroMotivoRevisaoNaoPermitida[i]));

					Collection<ContaMotivoRevisao> colecaoContaMotivoRevisao = (ArrayList<ContaMotivoRevisao>) this.getControladorUtil()
									.pesquisar(filtroContaMotivoRevisao, ContaMotivoRevisao.class.getName());

					String parametroPermiteManipularContaRetidaComRestricaoUsuario = "";
					try{

						parametroPermiteManipularContaRetidaComRestricaoUsuario = ((String) ParametroCobranca.P_PERMITE_MANIPULAR_CONTA_RETIDA_COM_RESTRICAO_USUARIO
										.executar());
					}catch(ControladorException e1){

						throw new ActionServletException("atencao.sistemaparametro_inexistente",
										"P_PERMITE_MANIPULAR_CONTA_RETIDA_COM_RESTRICAO_USUARIO");
					}

					if(parametroPermiteManipularContaRetidaComRestricaoUsuario.equals(ConstantesSistema.SIM.toString())){

						// Verifica se o usuário tem permisão especial para manusear contas retidas
						Object[] permissaoEspecialManuseioContasRetidas = verificaPermissaoUsuarioParaManusearContaRetida(usuarioLogado,
										null);
						boolean manuseioContaPorUsuarioAcessoPermitido = (Boolean) permissaoEspecialManuseioContasRetidas[1];

						if(!manuseioContaPorUsuarioAcessoPermitido){

							throw new ControladorException("atencao.motivo_revisao_nao_permitido_usuario", null, colecaoContaMotivoRevisao
											.iterator().next().getDescricaoMotivoRevisaoConta());
						}
					}else{

						throw new ControladorException("atencao.motivo_revisao_nao_permitido_usuario", null, colecaoContaMotivoRevisao
										.iterator().next().getDescricaoMotivoRevisaoConta());

					}
				}
			}
		}
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @exception CreateException
	 *                Descrição da exceção
	 */
	public void ejbCreate() throws CreateException{

		repositorioFaturamento = RepositorioFaturamentoHBM.getInstancia();
		repositorioCobranca = RepositorioCobrancaHBM.getInstancia();
		repositorioMicromedicao = RepositorioMicromedicaoHBM.getInstancia();
		repositorioUtil = RepositorioUtilHBM.getInstancia();
		repositorioArrecadacao = RepositorioArrecadacaoHBM.getInstancia();
		repositorioLocalidade = RepositorioLocalidadeHBM.getInstancia();
		repositorioClienteImovel = RepositorioClienteImovelHBM.getInstancia();
		repositorioHistograma = RepositorioHistogramaHBM.getInstancia();
		repositorioContabil = RepositorioContabilHBM.getInstancia();
	}

	/**
	 * < <Descrição do método>>
	 */

	/**
	 * Método chamado no momento que o bean é removido do contexto do container
	 */
	public void ejbRemove(){

	}

	/**
	 * Método chamado no momento que o bean é ativado no container
	 */
	public void ejbActivate(){

	}

	/**
	 * Método chamado no momento que o bean é passivado no container
	 */
	public void ejbPassivate(){

	}

	/**
	 * * Seta o valor de sessionContext
	 * 
	 * @param sessionContext
	 *            O novo valor de sessionContext
	 */

	public void setSessionContext(SessionContext sessionContext){

		this.sessionContext = sessionContext;
	}

	/**
	 * Retorna o valor de controladorLocalidade
	 * 
	 * @return O valor de controladorLocalidade
	 */
	private ControladorLocalidadeLocal getControladorLocalidade(){

		ControladorLocalidadeLocalHome localHome = null;
		ControladorLocalidadeLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorLocalidadeLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_LOCALIDADE_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de ControladorAtendimentoPublico
	 * 
	 * @return O valor de ControladorAtendimentoPublico
	 */
	protected ControladorAtendimentoPublicoLocal getControladorAtendimentoPublico(){

		ControladorAtendimentoPublicoLocalHome localHome = null;
		ControladorAtendimentoPublicoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorAtendimentoPublicoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_ATENDIMENTO_PUBLICO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorAcesso
	 * 
	 * @return O valor de controladorAcesso
	 */
	protected ControladorAcessoLocal getControladorAcesso(){

		ControladorAcessoLocalHome localHome = null;
		ControladorAcessoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorAcessoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_ACESSO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	protected ControladorFinanceiroLocal getControladorFinanceiro(){

		ControladorFinanceiroLocalHome localHome = null;
		ControladorFinanceiroLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorFinanceiroLocalHome) locator.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_FINANCEIRO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	protected ControladorArrecadacaoLocal getControladorArrecadacao(){

		ControladorArrecadacaoLocalHome localHome = null;
		ControladorArrecadacaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorArrecadacaoLocalHome) locator.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_ARRECADACAO_SEJB);

			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	private ControladorCobrancaLocal controladorCobranca;

	protected ControladorCobrancaLocal getControladorCobranca(){

		if(controladorCobranca == null){
			ControladorCobrancaLocalHome localHome = null;
			// ControladorCobrancaLocal local = null;

			// pega a instância do ServiceLocator.

			ServiceLocator locator = null;

			try{
				locator = ServiceLocator.getInstancia();

				localHome = (ControladorCobrancaLocalHome) locator.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_COBRANCA_SEJB);
				// guarda a referencia de um objeto capaz de fazer chamadas à
				// objetos remotamente
				controladorCobranca = localHome.create();

				return controladorCobranca;
			}catch(CreateException e){
				throw new SistemaException(e);
			}catch(ServiceLocatorException e){
				throw new SistemaException(e);
			}
		}else{
			return controladorCobranca;
		}
	}

	/**
	 * Retorna o valor de controladorEndereco
	 * 
	 * @return O valor de controladorEndereco
	 */
	protected ControladorEnderecoLocal getControladorEndereco(){

		ControladorEnderecoLocalHome localHome = null;
		ControladorEnderecoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorEnderecoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_ENDERECO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Retorna o valor de controladorCliente
	 * 
	 * @return O valor de controladorCliente
	 */
	protected ControladorClienteLocal getControladorCliente(){

		ControladorClienteLocalHome localHome = null;
		ControladorClienteLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorClienteLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_CLIENTE_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Retorna o valor de controladorLocalidade
	 * 
	 * @return O valor de controladorLocalidade
	 */
	protected ControladorFaturamentoLocal getControladorFaturamento(){

		ControladorFaturamentoLocalHome localHome = null;
		ControladorFaturamentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorFaturamentoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_FATURAMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	protected ControladorBatchLocal getControladorBatch(){

		ControladorBatchLocalHome localHome = null;
		ControladorBatchLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorBatchLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_BATCH_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o controladorCadastro
	 * 
	 * @author Thiago Tenório
	 * @date 18/08/2006
	 */
	private ControladorCadastroLocal getControladorCadastro(){

		ControladorCadastroLocalHome localHome = null;
		ControladorCadastroLocal local = null;

		ServiceLocator locator = null;
		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorCadastroLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_CADASTRO_SEJB);

			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	private ControladorLigacaoAguaLocal getControladorLigacaoAgua(){

		ControladorLigacaoAguaLocalHome localHome = null;
		ControladorLigacaoAguaLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorLigacaoAguaLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_LIGACAO_AGUA_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	private ControladorLigacaoEsgotoLocal getControladorLigacaoEsgoto(){

		ControladorLigacaoEsgotoLocalHome localHome = null;
		ControladorLigacaoEsgotoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorLigacaoEsgotoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_LIGACAO_ESGOTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorEndereco
	 * 
	 * @return O valor de controladorEndereco
	 */
	protected ControladorPermissaoEspecialLocal getControladorPermissaoEspecial(){

		ControladorPermissaoEspecialLocalHome localHome = null;
		ControladorPermissaoEspecialLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorPermissaoEspecialLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_PERMISSAO_ESPECIAL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Retorna o valor de ControladorRelaotorioFaturamentoLocal
	 * 
	 * @return O valor de ControladorRelaotorioFaturamentoLocal
	 */
	protected ControladorRelatorioFaturamentoLocal getControladorRelatorioFaturamento(){

		ControladorRelatorioFaturamentoLocalHome localHome = null;
		ControladorRelatorioFaturamentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorRelatorioFaturamentoLocalHome) locator
							.getLocalHome(ConstantesJNDI.CONTROLADOR_RELATORIO_FATURAMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Retorna o valor de controladorHistograma
	 * 
	 * @return O valor de controladorHistograma
	 */
	protected ControladorHistogramaLocal getControladorHistograma(){

		ControladorHistogramaLocalHome localHome = null;
		ControladorHistogramaLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorHistogramaLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_HISTOGRAMA_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Retorna o valor de ControladorTarifaSocial
	 * 
	 * @return O valor de ControladorTarifaSocial
	 */
	protected ControladorTarifaSocialLocal getControladorTarifaSocial(){

		ControladorTarifaSocialLocalHome localHome = null;
		ControladorTarifaSocialLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorTarifaSocialLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_TARIFA_SOCIAL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Retorna o valor de controladorContabil
	 * 
	 * @return O valor de controladorContabil
	 */
	private ControladorContabilLocal getControladorContabil(){

		ControladorContabilLocalHome localHome = null;
		ControladorContabilLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorContabilLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_CONTABIL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	public BigDecimal pesquisarValorJurosCobrados(int idConta) throws ControladorException{

		BigDecimal valorValorJurosCobrados = null;

		try{
			valorValorJurosCobrados = repositorioFaturamento.pesquisarValorJurosCobrados(idConta);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return valorValorJurosCobrados;
	}

	public BigDecimal pesquisarValorAtualizacaoCobradas(int idConta) throws ControladorException{

		BigDecimal valorAtualizacaoCobradas = null;

		try{
			valorAtualizacaoCobradas = repositorioFaturamento.pesquisarValorAtualizacaoCobradas(idConta);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return valorAtualizacaoCobradas;
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato
	 * Determina os dados do faturamento do imóvel.
	 * [SB0002 – Determinar Faturamento para o Imóvel]
	 * 
	 * @author Ailton Sousa
	 * @data 09/09/2011
	 * @param imovel
	 * @param anoMesFaturamento
	 * @param faturamentoAtivCronRta
	 * @param colecaoResumoFaturamento
	 * @param sistemaParametro
	 * @param antecipado
	 * @param faturamentoGrupo
	 * @param anoMes
	 * @param contaImovel
	 * @param colecaoHelperRelatorioOcorrenciaRegistrada
	 * @param arrayMedicaoConsumoHistorico
	 *            (Array de Tamanho 3. Possui o medicaoHistorico na primeira posição [0],
	 *            consumoHistorico de Agua na segunda posicao [1] e consumoHistorico do Esgoto na
	 *            terceira posição [2]).
	 * @return Conta [Conta gerada para imóvel, que será usada para geração de Histogramas, Resumos
	 *         e Contabilizacao]
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	private Conta determinarFaturamentoImovelParaFaturamentoImediato(Imovel imovel, int anoMesFaturamento,
					FaturamentoAtivCronRota faturamentoAtivCronRota, Collection colecaoResumoFaturamento,
					SistemaParametro sistemaParametro, boolean antecipado, FaturamentoGrupo faturamentoGrupo, Integer anoMes,
					Conta contaImovel,
					Collection<RelatorioResumoOcorrenciasFaturamentoImediatoHelper> colecaoHelperRelatorioOcorrenciaRegistrada,
					Object[] arrayMedicaoConsumoHistorico, MovimentoRoteiroEmpresa movimentoRoteiroImovel,
					Collection<RelatorioContasBloqueadasAnaliseHelper> colecaoContasBloqueadasAnaliseHelper) throws ControladorException,
					ErroRepositorioException{

		// Coleção que vai armazenar as categorias do imóvel
		Collection colecaoCategorias = null;

		// [UC0108] - Obter Quantidade de Economias por Categoria
		colecaoCategorias = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		if(movimentoRoteiroImovel.getDataVencimentoRetorno() != null
						&& movimentoRoteiroImovel.getDataVencimentoRetorno().compareTo(movimentoRoteiroImovel.getDataVencimento()) == 1){

			contaImovel.setDataVencimentoConta(movimentoRoteiroImovel.getDataVencimentoRetorno());
		}

		/*
		 * Caso haja valor de rateio(MREM_VLRATEIO em MOVIMENTO_ROTEIRO_EMPRESA) [SB0011 – Gerar
		 * Valor de Rateio]
		 */
		if(movimentoRoteiroImovel.getValorRateio() != null && movimentoRoteiroImovel.getValorRateio().compareTo(BigDecimal.ZERO) == 1
						&& !imovel.getIndicadorImovelCondominio().equals(Imovel.IMOVEL_CONDOMINIO)){

			this.gerarValorRateio(imovel, anoMesFaturamento, contaImovel, movimentoRoteiroImovel, colecaoCategorias);
		}

		/*
		 * Caso haja valor de religação ou sanção (MREM_VLRELIGACAO ou MREM_VLRELIGACAO em
		 * MOVIMENTO_ROTEIRO_EMPRESA diferente de zero)
		 */

		if((movimentoRoteiroImovel.getValorReligacao() != null && movimentoRoteiroImovel.getValorReligacao().compareTo(BigDecimal.ZERO) == 1)
						|| (movimentoRoteiroImovel.getValorSancao() != null && movimentoRoteiroImovel.getValorSancao().compareTo(
										BigDecimal.ZERO) == 1)){
			// [SB0014 – Gerar Valor de Religação e Sanção]
			this.gerarValorReligacaoESancao(imovel, anoMesFaturamento, contaImovel, movimentoRoteiroImovel, colecaoCategorias);
		}

		// [UC0120] - Calcular Valores de Água e/ou Esgoto
		BigDecimal valorTotalAgua = BigDecimal.ZERO;
		BigDecimal valorTotalEsgoto = BigDecimal.ZERO;
		Collection colecaoCalcularValoresAguaEsgotoHelper = null;

		Integer anoMesReferencia = anoMesFaturamento;
		BigDecimal percentualEsgoto = contaImovel.getPercentualEsgoto();
		if(percentualEsgoto == null){
			percentualEsgoto = BigDecimal.ZERO;
		}
		Integer consumoFaturadoMesAgua = null;
		Integer consumoFaturadoMesEsgoto = null;
		ConsumoHistorico consumoHistoricoAgua = null;
		ConsumoHistorico consumoHistoricoEsgoto = null;
		// Pesquisar consumo histórico
		MedicaoHistorico medicaoHistoricoAgua = null;
		MedicaoHistorico medicaoHistoricoPoco = null;

		// Cria o tipo de ligação para água.
		LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
		ligacaoTipoAgua.setId(LigacaoTipo.LIGACAO_AGUA);

		// Cria o tipo de ligação para esgoto.
		LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
		ligacaoTipoEsgoto.setId(LigacaoTipo.LIGACAO_ESGOTO);

		consumoHistoricoAgua = (ConsumoHistorico) arrayMedicaoConsumoHistorico[1];
		BigDecimal valorFaturadoAgua = BigDecimal.ZERO;
		BigDecimal valorFaturadoEsgoto = BigDecimal.ZERO;
		BigDecimal valorTotalCreditosConta = BigDecimal.ZERO;

		// if(idContaAnoMesReferencia == null){

		// ---------------------------------------------------------------------------------
		// [SB0002] - Determinar Valores para Faturamento de Água e/ou Esgoto - Início
		// ---------------------------------------------------------------------------------

		Integer ligacaoAguaSituacaoId = imovel.getLigacaoAguaSituacao().getId();
		Integer ligacaoEsgotoSituacaoId = imovel.getLigacaoEsgotoSituacao().getId();

		Calendar data = new GregorianCalendar();
		data.set(Calendar.YEAR, Integer.parseInt(anoMes.toString().substring(0, 4)));
		data.set(Calendar.MONTH, Integer.parseInt(anoMes.toString().substring(4, 6)) - 1);
		data.set(Calendar.DATE, 1);
		data.add(Calendar.MONTH, -1);

		String anoMesAnterior = "";
		anoMesAnterior = data.get(Calendar.YEAR) + "";
		if((data.get(Calendar.MONTH) + 1) < 10){
			anoMesAnterior = anoMesAnterior + "0" + (data.get(Calendar.MONTH) + 1);
		}else{
			anoMesAnterior = anoMesAnterior + (data.get(Calendar.MONTH) + 1);
		}

		Date dataLeituraAnteriorFaturamento = null;
		try{
			// Determina a data de leitura anterior do faturamento
			dataLeituraAnteriorFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
							faturamentoGrupo.getId(), FaturamentoAtividade.EFETUAR_LEITURA, Integer.valueOf(anoMesAnterior));

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Determina a data de leitura atual do faturamento
		Date dataLeituraAtualFaturamento = null;
		try{
			dataLeituraAtualFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
							faturamentoGrupo.getId(), FaturamentoAtividade.EFETUAR_LEITURA, anoMes);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Inicializa com zero o percentual de esgoto o consumo faturado do mês de água e de
		// esgoto
		consumoFaturadoMesAgua = Integer.valueOf("0");
		consumoFaturadoMesEsgoto = Integer.valueOf("0");

		// Seta valores iniciais para os indicadores de faturamento de água e esgoto.
		Short indicadorFaturamentoAgua = Short.valueOf("2");
		Short indicadorFaturamentoEsgoto = Short.valueOf("2");

		// Verifica se existe consumo histórico de água
		if(consumoHistoricoAgua != null){
			if((imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.FATURAMENTO_ATIVO
							.intValue())
							|| (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.NAO_FATURAVEL
											.intValue() && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null && consumoHistoricoAgua
											.getNumeroConsumoFaturadoMes().intValue() > 0)){

				indicadorFaturamentoAgua = Short.valueOf("1");
				// caso exista indicador de Faturamento no Consumo, será assumido o do
				// ConsumoHistorico.
				if(consumoHistoricoAgua.getIndicadorFaturamento() != null){
					// Seta o indicador faturamento água
					indicadorFaturamentoAgua = consumoHistoricoAgua.getIndicadorFaturamento();
				}
				consumoFaturadoMesAgua = consumoHistoricoAgua.getNumeroConsumoFaturadoMes();

			}
		}

		// Pesquisa o consumo histórico de esgoto do imóvel para o ano mês de referência
		// consumoHistoricoEsgoto =
		// getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel,
		// ligacaoTipoEsgoto,
		// anoMesReferencia.intValue());

		consumoHistoricoEsgoto = (ConsumoHistorico) arrayMedicaoConsumoHistorico[2];

		if(consumoHistoricoEsgoto != null
						&& (imovel.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue() || (imovel
										.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.FACTIVEL_FATURADA) && imovel
										.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)))){
			if(consumoHistoricoEsgoto.getIndicadorFaturamento() != null){
				// Seta o indicador faturamento esgoto
				indicadorFaturamentoEsgoto = consumoHistoricoEsgoto.getIndicadorFaturamento();
			}

			if(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null){
				consumoFaturadoMesEsgoto = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();

				// [FS0013] – Somar Consumo Rateio

				// Obter valor do Parâmetro [P_ADICIONAR_RATEIO_AO_CONSUMO_A_FATURAR]
				String pAdicionarRateioAoConsumoAFaturar = null;

				try{
					pAdicionarRateioAoConsumoAFaturar = (String) ParametroFaturamento.P_ADICIONAR_RATEIO_AO_CONSUMO_A_FATURAR.executar();
				}catch(ControladorException e){
					throw new ActionServletException("atencao.sistemaparametro_inexistente", "P_ADICIONAR_RATEIO_AO_CONSUMO_A_FATURAR");
				}

				// Caso tenha valor 1
				if(!Util.isVazioOuBranco(pAdicionarRateioAoConsumoAFaturar)
								&& pAdicionarRateioAoConsumoAFaturar.equals(ConstantesSistema.SIM.toString())){
					// adicionar ao consumo faturado a passar(CSHI_NNCONSUMOFATURADOMES)
					// o consumo rateio(CSHI_NNCONSUMORATEIO) de CONSUMO_HISTORICO caso este seja
					// diferente de nulo.
					if(!Util.isVazioOuBranco(consumoHistoricoEsgoto) && !Util.isVazioOuBranco(consumoHistoricoEsgoto.getConsumoRateio())){
						consumoFaturadoMesEsgoto = consumoFaturadoMesEsgoto + consumoHistoricoEsgoto.getConsumoRateio();
					}
				}
			}
		}

		Short pVerificarConsumoLigacaoCortada = Short.valueOf((String) ParametroFaturamento.P_VERIFICAR_CONSUMO_LIGACAO_CORTADA.executar());

		// Caso o imóvel seja (ligado) ou (cortado com ou sem consumo de água)
		if(ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.LIGADO)
						|| (ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.CORTADO) && (pVerificarConsumoLigacaoCortada
										.equals(ConstantesSistema.NAO) || (pVerificarConsumoLigacaoCortada.equals(ConstantesSistema.SIM)
										&& consumoHistoricoAgua != null && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null && consumoHistoricoAgua
										.getNumeroConsumoFaturadoMes().intValue() != 0)))){

			if(consumoHistoricoAgua != null && consumoHistoricoAgua.getIndicadorFaturamento() != null){
				indicadorFaturamentoAgua = consumoHistoricoAgua.getIndicadorFaturamento();
			}else{
				indicadorFaturamentoAgua = ConstantesSistema.NAO;
			}
		}else{
			indicadorFaturamentoAgua = ConstantesSistema.NAO;
		}

		// 2.5.1. Caso o imóvel seja ligado de esgoto:
		if(indicadorFaturamentoEsgoto != null && indicadorFaturamentoEsgoto.equals(ConstantesSistema.SIM)){

			Short pEsgotoSuprimido = Short.valueOf((String) ParametroFaturamento.P_ISENCAO_ESGOTO_SUPRIMIDO_CORTADO_SEM_CONSUMO.executar());

			// 2.5.1.1. Caso o parâmetro de isenção de esgoto para suprimido esteja ativado
			// (PASI_VLPARAMETRO = 1 na tabela PARAMETRO_SISTEMA para PASI_DSPARAMETRO
			if(pEsgotoSuprimido.equals(ConstantesSistema.SIM)){

				// 2.5.1.1.1. Caso o imóvel seja suprimido ou cortado (LAST_ID na tabela IMOVEL com
				// o valor correspondente a SUPRIMIDO ou CORTADO) e sem consumo de água
				// (CSHI_NNCONSUMOFATURADOMES = 0 da tabela CONSUMO_HISTORICO com IMOV_ID=IMOV_ID da
				// tabela IMOVEL, LGTP_ID com o valor correspondente a “ligação de água” e
				// CSHI_AMFATURAMENTO=Ano e mês de referência), atribuir o valor dois (2).

				// Boolean imovelSuprimidoCortado =
				// (ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.SUPRIMIDO) ||
				// ligacaoAguaSituacaoId
				// .equals(LigacaoAguaSituacao.CORTADO));
				// Boolean imovelSemConsumoAgua = (consumoFaturadoMesAgua.intValue() == 0);

				boolean imovelSuprimidoSemConsumo = ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.SUPRIMIDO)
								&& consumoFaturadoMesAgua.intValue() == 0;

				// Imóvel cortardo sem consumo e com o parâmetro de verificar consumo ativo
				boolean imovelCortadoSemConsumoComVerificacao = ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.CORTADO)
								&& pVerificarConsumoLigacaoCortada.equals(ConstantesSistema.SIM) && consumoFaturadoMesAgua.intValue() == 0;

				if(imovelSuprimidoSemConsumo || imovelCortadoSemConsumoComVerificacao){

					indicadorFaturamentoEsgoto = ConstantesSistema.NAO;

				}else{

					// 2.5.1.1.2. Caso contrário, atribuir CSHI_ICFATURAMENTO da tabela
					// CONSUMO_HISTORICO com IMOV_ID=IMOV_ID da tabela IMOVEL, LGTP_ID com o valor
					// correspondente a “ligação de esgoto” e CSHI_AMFATURAMENTO=Ano e mês de
					// referência.

					if(consumoHistoricoEsgoto != null && consumoHistoricoEsgoto.getIndicadorFaturamento() != null){

						indicadorFaturamentoEsgoto = consumoHistoricoEsgoto.getIndicadorFaturamento();
						consumoHistoricoEsgoto.setReferenciaFaturamento(anoMesFaturamento);

					}

				}

			}else{

				// Caso contrário, ou seja, caso o parâmetro de isenção de esgoto para suprimido
				// esteja desativado (PASI_VLPARAMETRO = 2 na tabela PARAMETRO_SISTEMA para
				// PASI_DSPARAMETRO = ” P_ISENCAO_ESGOTO_SUPRIMIDO_CORTADO_SEM_CONSUMO”),
				// atribuir CSHI_ICFATURAMENTO da tabela CONSUMO_HISTORICO com IMOV_ID=IMOV_ID da
				// tabela IMOVEL, LGTP_ID com o valor correspondente a “ligação de esgoto” e
				// CSHI_AMFATURAMENTO=Ano e mês de referência,

				if(consumoHistoricoEsgoto != null){

					indicadorFaturamentoEsgoto = consumoHistoricoEsgoto.getIndicadorFaturamento();
					consumoHistoricoEsgoto.setReferenciaFaturamento(anoMesFaturamento);

				}

			}

		}else{

			// 2.5.2. Caso contrário, ou seja, caso o imóvel não seja ligado de esgoto, atribuir o
			// valor um (2).
			indicadorFaturamentoEsgoto = ConstantesSistema.NAO;

		}

		// Verifica se existe medição histórico
		// medicaoHistoricoAgua =
		// getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(imovel.getId(),
		// anoMesReferencia);
		medicaoHistoricoAgua = (MedicaoHistorico) arrayMedicaoConsumoHistorico[0];
		if(medicaoHistoricoAgua != null){

			// Seta a data de letura anterior faturamento
			if(medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento() != null){
				dataLeituraAnteriorFaturamento = medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento();
			}

			// Seta a data de leitura atual faturamento
			if(medicaoHistoricoAgua.getDataLeituraAtualFaturamento() != null){
				dataLeituraAtualFaturamento = medicaoHistoricoAgua.getDataLeituraAtualFaturamento();
			}
		}

		// Caso o imóvel seja ligado de esgoto
		if(imovel.getLigacaoEsgoto() != null
						&& imovel.getLigacaoEsgotoSituacao() != null
						&& (imovel.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue() || (imovel
										.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.FACTIVEL_FATURADA) && imovel
										.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)))){
			// consultar medicao hisotrico tipo poco
			medicaoHistoricoPoco = this.getControladorMicromedicao().pesquisarMedicaoHistoricoTipoPoco(imovel.getId(), anoMesReferencia);

			// Verifica se existe medição histórico para poço
			if(medicaoHistoricoPoco != null){

				// Seta a data de leitura anterior faturamento
				if(medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento() != null){
					dataLeituraAnteriorFaturamento = medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento();
				}

				// Seta a data atual de faturamento
				if(medicaoHistoricoPoco.getDataLeituraAtualFaturamento() != null){
					dataLeituraAtualFaturamento = medicaoHistoricoPoco.getDataLeituraAtualFaturamento();
				}
			}
			// Recupera o percentual de esgoto.
			// percentualEsgoto = this.obterPercentualLigacaoEsgotoImovel(imovel.getId());
		}

		// [UC0105] - Obter Consumo Mínimo da Ligação
		int consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, colecaoCategorias);

		if(dataLeituraAnteriorFaturamento == null || dataLeituraAtualFaturamento == null){

			Date periodoLeitura[] = gerarPeriodoLeituraFaturamento(dataLeituraAtualFaturamento, dataLeituraAnteriorFaturamento,
							faturamentoAtivCronRota, Integer.valueOf(anoMesAnterior), anoMesReferencia);
			dataLeituraAnteriorFaturamento = periodoLeitura[0];
			dataLeituraAtualFaturamento = periodoLeitura[1];
		}

		// Tarifa para o imóvel (Caso exista tarifa temporária para o imóvel
		// (CSTF_IDTEMPORARIA com o valor diferente de nulo na tabela IMOVEL)
		// e a tarifa temporária esteja vigente (IMOV_DTVALIDADETARIFATEMP maior ou igual à data
		// corrente), atribuir CSTF_IDTEMPORARIA;
		// Caso contrário, atribuir CSTF_ID da tabela IMOVEL).
		ConsumoTarifa consumoTarifaConta = null;
		boolean possuiTarifaTemporariaValida = false;

		// Caso exista contrato de demanda de consumo vigente para o imóvel e tarifa de
		// consumo não esteja vazia
		// atribuir CSTF_ID da tabela CONTRATO_DEMANDA_CONSUMO
		ContratoDemandaConsumo contratoDemandaConsumo = this.pesquisarContratoDemandaConsumoVigenteComTarifa(imovel.getId(),
						sistemaParametro.getAnoMesFaturamento());

		if(contratoDemandaConsumo != null){

			consumoTarifaConta = contratoDemandaConsumo.getConsumoTarifa();

		}else if(imovel.getConsumoTarifaTemporaria() != null && imovel.getDataValidadeTarifaTemporaria() != null
						&& Util.compararData(imovel.getDataValidadeTarifaTemporaria(), new Date()) >= 0){

			log.info("Imovel[" + imovel.getId() + "] possue tarifa [" + imovel.getConsumoTarifaTemporaria().getId().toString()
							+ "] temporária válida.");
			consumoTarifaConta = imovel.getConsumoTarifaTemporaria();
			possuiTarifaTemporariaValida = true;

			log.info("Avaliar perda de benefícios");
			// [FS0011] E [FS0014]
			consumoTarifaConta = verificarPerdaBeneficioDaTarifaSocialParaFaturamento(consumoFaturadoMesAgua, consumoMinimoLigacao, imovel);
			consumoTarifaConta = verificarPerdaBeneficioDaTarifaParaPequenoNegocio(imovel, consumoFaturadoMesAgua);

		}else{

			// Obtém a tarifa do imóvel
			consumoTarifaConta = imovel.getConsumoTarifa();
			log.info("Imovel[" + imovel.getId() + "] tarifa padrão [" + imovel.getConsumoTarifa().getId().toString() + "].");
		}

		// Caso o imóvel esteja incluso no programa água para todos(iapt_id diferente de Null)
		if(imovel.getImovelAguaParaTodos() != null){

			// Verificar Exclusão do Programa Água para Todos
			if(this.verificarExclusaoImoveldoProgramaAguaParaTodos(imovel, sistemaParametro)){

				this.excluirImoveldoProgramaAguaParaTodos(imovel, sistemaParametro);
			}

			// Caso o imóvel esteja incluso no programa água para todos e o consumo seja
			// maior que [PARÂMETRO – PARM_NNCONSUMOMINIMOAPT], assumir a tarifa padrão do
			// imóvel para faturamento desconsiderando a atual
			if(sistemaParametro.getNumeroConsumoMinAguaParaTodos() != null
							&& consumoFaturadoMesAgua > sistemaParametro.getNumeroConsumoMinAguaParaTodos()){

				// consumoTarifaConta = imovel.getConsumoTarifa();

				if(isNumeroConsumoConsecutivoMaiorQueMinimo(imovel, ligacaoTipoAgua, anoMesReferencia.intValue(), sistemaParametro)){

					this.excluirImoveldoProgramaAguaParaTodos(imovel, sistemaParametro);
				}
			}
		}

		// Caso tenha o imóvel tenha tarifa temporária válida e ela tenha sido perdida por alguma
		// regra anterior
		if(possuiTarifaTemporariaValida && consumoTarifaConta.getId().equals(imovel.getConsumoTarifa().getId())){

			log.info("Imovel[" + imovel.getId() + "] tinha tarifa temporária válida mas faturou com tarifa padrão ["
							+ imovel.getConsumoTarifa().getId().toString() + "].");
			// [UC0105] - Obter Consumo Mínimo da Ligação baseado na tarifa padrão do imóvel
			Imovel imovelAux = new Imovel();
			imovelAux.setConsumoTarifa(imovel.getConsumoTarifa());
			consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovelAux, colecaoCategorias);
		}

		// ---------------------------------------------------------------------------------
		// [SB0003] - Determinar Valores para Faturamento de Água e/ou Esgoto - Início
		// ---------------------------------------------------------------------------------


		Integer consumoFaturadoMesAguaAux = null;

		String indicadorEmissaoCampo = null;

		if(movimentoRoteiroImovel != null){
			indicadorEmissaoCampo = movimentoRoteiroImovel.getIndicadorEmissaoCampo();
		}

		Short indicadorImovelNaoLidoFaturarMedia = ConstantesSistema.NAO;

		if(movimentoRoteiroImovel.getIndicadorStatusRegistSistLegado() != null
						&& movimentoRoteiroImovel.getIndicadorStatusRegistSistLegado().equals(
										MovimentoRoteiroEmpresa.INDICADOR_STATUS_REGISTRO_NAO_LIDO)
						&& movimentoRoteiroImovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)){

			indicadorImovelNaoLidoFaturarMedia = ConstantesSistema.SIM;
		}

		// 2.7. Consumo faturado de água do mês
		if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
						|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){

			consumoFaturadoMesAguaAux = movimentoRoteiroImovel.getNumeroConsumoMedio();
		}else{
			consumoFaturadoMesAguaAux = consumoFaturadoMesAgua;

			// [FS0013] – Somar Consumo Rateio

			// Obter valor do Parâmetro [P_ADICIONAR_RATEIO_AO_CONSUMO_A_FATURAR]
			String pAdicionarRateioAoConsumoAFaturar = null;

			try{
				pAdicionarRateioAoConsumoAFaturar = (String) ParametroFaturamento.P_ADICIONAR_RATEIO_AO_CONSUMO_A_FATURAR.executar();
			}catch(ControladorException e){
				throw new ActionServletException("atencao.sistemaparametro_inexistente", "P_ADICIONAR_RATEIO_AO_CONSUMO_A_FATURAR");
			}

			// Caso tenha valor 1
			if(!Util.isVazioOuBranco(pAdicionarRateioAoConsumoAFaturar)
							&& pAdicionarRateioAoConsumoAFaturar.equals(ConstantesSistema.SIM.toString())){
				// adicionar ao consumo faturado a passar(CSHI_NNCONSUMOFATURADOMES)
				// o consumo rateio(CSHI_NNCONSUMORATEIO) de CONSUMO_HISTORICO caso este seja
				// diferente de nulo.
				if(!Util.isVazioOuBranco(consumoHistoricoAgua) && !Util.isVazioOuBranco(consumoHistoricoAgua.getConsumoRateio())){
					consumoFaturadoMesAguaAux = consumoFaturadoMesAguaAux + consumoHistoricoAgua.getConsumoRateio();
				}
			}
		}

		// Situação da ligação de água (LAST_ID da tabela imóvel).
		// (Caso o indicador MREM_ICRELIGACAOAGUA tenha valor 1(um), atribuir a situação(LAST_ID)
		// correspondente a “Ligado” da tabela LIGACAO_AGUA_SITUACAO(LAST_CDCONSTANTE = ‘LIGADO’)
		if(movimentoRoteiroImovel.getIndicadorReligacaoAgua().equals(ConstantesSistema.SIM)){
			ligacaoAguaSituacaoId = LigacaoAguaSituacao.LIGADO;
		}

		// [UC0120] - Calcular Valores de Água e/ou Esgoto
		colecaoCalcularValoresAguaEsgotoHelper = calcularValoresAguaEsgoto(anoMesReferencia, ligacaoAguaSituacaoId,
						ligacaoEsgotoSituacaoId, indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategorias,
						consumoFaturadoMesAguaAux, consumoFaturadoMesEsgoto, consumoMinimoLigacao, dataLeituraAnteriorFaturamento,
						dataLeituraAtualFaturamento, percentualEsgoto, consumoTarifaConta.getId(), imovel.getId(), null);

		for(Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper.iterator(); iteratorColecaoCalcularValoresAguaEsgotoHelper
						.hasNext();){

			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
							.next();
			/*
			 * Caso tenha valor de água faturado para categoria adiciona o valor de água ao
			 * valor total de água.
			 */
			if(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria() != null){
				valorTotalAgua = valorTotalAgua.add(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria());
			}

			if(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria() != null){
				valorTotalEsgoto = valorTotalEsgoto.add(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria());
			}
		}

		// ---------------------------------------------------------------------------------
		// [SB0003] - Determinar Valores para Faturamento de Água e/ou Esgoto - Fim
		// ---------------------------------------------------------------------------------

		// }

		boolean gerouDivergencia = false;
		if(movimentoRoteiroImovel != null){
			// Confronta os Valores de Água e Esgoto gerados
			if(movimentoRoteiroImovel.getValorAgua() != null && !movimentoRoteiroImovel.getValorAgua().equals(new BigDecimal(0))){
				valorFaturadoAgua = movimentoRoteiroImovel.getValorAgua();
			}

			if(movimentoRoteiroImovel.getValorEsgoto() != null && !movimentoRoteiroImovel.getValorEsgoto().equals(new BigDecimal(0))){
				valorFaturadoEsgoto = movimentoRoteiroImovel.getValorEsgoto();
			}

			if(valorTotalAgua.compareTo(valorFaturadoAgua) != 0 || valorTotalEsgoto.compareTo(valorFaturadoEsgoto) != 0){

				// Relatar erro de valor Incorreto
				String nomeClienteImovel = getControladorImovel().consultarClienteUsuarioImovel(imovel.getId());
				colecaoHelperRelatorioOcorrenciaRegistrada
								.add(this.criarHelperRelatorioOcorrenciaRegistroFaturamentoImediato(imovel, nomeClienteImovel,
												movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua(), movimentoRoteiroImovel
																.getNumeroConsumoFaturadoEsgoto(),
												"Erro de Divergência entre Valores de Água e Esgoto Faturados em Campo e Sistema.",
												!valorTotalAgua.equals(BigDecimal.ZERO) ? valorTotalAgua.toString() : null,
												movimentoRoteiroImovel.getValorAgua() != null ? movimentoRoteiroImovel.getValorAgua()
																.toString() : null,
												!valorTotalEsgoto.equals(BigDecimal.ZERO) ? valorTotalEsgoto.toString() : null,
												movimentoRoteiroImovel.getValorEsgoto() != null ? movimentoRoteiroImovel.getValorEsgoto()
																.toString() : null,
												movimentoRoteiroImovel.getNumeroConsumoMedio() != null ? movimentoRoteiroImovel
																.getNumeroConsumoMedio().toString() : null, true));
				gerouDivergencia = true;
			}
		}

		// 1) Obtem os dabitos e o valor Total da conta
		BigDecimal valorTotalDebitosConta = BigDecimal.ZERO;
		Collection<DebitoCobrado> colecaoDebitosConta = this.obterDebitosCobradosConta(contaImovel);
		for(Iterator iteratorDebitosConta = colecaoDebitosConta.iterator(); iteratorDebitosConta.hasNext();){
			DebitoCobrado debitoConta = (DebitoCobrado) iteratorDebitosConta.next();
			if(debitoConta.getValorPrestacao() != null){
				valorTotalDebitosConta = valorTotalDebitosConta.add(debitoConta.getValorPrestacao());
			}
		}

		// ---------------------------------------------------------------------------------
		// [SB0005] - Atualizar Dados da Conta - Início
		// ---------------------------------------------------------------------------------

		/*
		 * 1. Caso o valor de água e o valor de esgoto e o valor e débitos seja igual a zero, exclui
		 * a conta das tabelas CONTA_GERAL e CONTA. Verificar se é macromedidor
		 * 3. Caso o valor total da conta seja zero(CNTA_VLAGUA + CNTA_VLESGOTO + CNTA_VLDEBITOS -
		 * CNTA_VLCREDITOS - CNTA_VLIMPOSTOS = 0), transferir conta para histórico:
		 */

		log.info("MOVIMENTOROTEIROEMPRESA[" + movimentoRoteiroImovel.getId() + "] => getValorAgua = " + valorFaturadoAgua);
		log.info("MOVIMENTOROTEIROEMPRESA[" + movimentoRoteiroImovel.getId() + "] => getValorEsgoto = " + valorFaturadoEsgoto);
		log.info("MOVIMENTOROTEIROEMPRESA[" + movimentoRoteiroImovel.getId() + "] => getValorDébitos = " + valorTotalDebitosConta);


		// Se o imóvel for condomínio exclui a conta
		if(imovel.getIndicadorImovelCondominio().equals(ConstantesSistema.SIM)){

			log.info("Imóvel Condomínio[" + imovel.getId() + "]");
			log.info("CNTA_ID para Excluir ----------------> " + contaImovel.getId());
			getControladorUtil().remover(new String[] {"" + contaImovel.getId().toString()}, Conta.class.getName(), null, null);

			if(contaImovel.getContaGeral() != null && contaImovel.getContaGeral().getId() != null){

				getControladorUtil().remover(new String[] {"" + contaImovel.getContaGeral().getId().toString()},
								ContaGeral.class.getName(), null, null);
			}else{

				ContaGeral contaGeralParaExcluir = (ContaGeral) getControladorUtil()
								.pesquisar(contaImovel.getId(), ContaGeral.class, false);

				if(contaGeralParaExcluir != null){

					getControladorUtil().remover(new String[] {"" + contaGeralParaExcluir.getId().toString()}, ContaGeral.class.getName(),
									null, null);
				}
			}

			contaImovel = null;

		}else if((valorFaturadoAgua != null && valorFaturadoAgua.equals(BigDecimal.ZERO))
						&& (valorFaturadoEsgoto != null && valorFaturadoEsgoto.equals(BigDecimal.ZERO))
						&& (valorTotalDebitosConta != null && valorTotalDebitosConta.equals(BigDecimal.ZERO))
						&& !indicadorEmissaoCampo.equals(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA)
						&& indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.NAO)){

			// 2) se o valor de água, esgoto e débitos da conta = ZERO -> Enviar conta pro histórico
			log.info("Transferindo para Historico => CONTA PRE-FATURADA[" + contaImovel.getId() + "]");

			transferirContasParaHistorico(Arrays.asList(contaImovel), 0);
			ContaGeral contaGeral = (ContaGeral) getControladorUtil().pesquisar(contaImovel.getContaGeral().getId(), ContaGeral.class,
							false);
			contaGeral.setIndicadorHistorico(ConstantesSistema.SIM);

			this.getControladorUtil().atualizar(contaGeral);

			contaImovel = null;

		}else if((valorTotalAgua != null && valorTotalAgua.equals(BigDecimal.ZERO))
						&& (valorTotalEsgoto != null && valorTotalEsgoto.equals(BigDecimal.ZERO))
						&& (valorTotalDebitosConta != null && valorTotalDebitosConta.equals(BigDecimal.ZERO))
						&& (indicadorEmissaoCampo.equals(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA) || indicadorImovelNaoLidoFaturarMedia
										.equals(ConstantesSistema.SIM))){

			// 2) se o valor de água, esgoto e débitos da conta = ZERO -> Enviar conta pro histórico
			log.info("Transferindo para Historico => CONTA RETIDA PRE-FATURADA[" + contaImovel.getId() + "]");

			transferirContasParaHistorico(Arrays.asList(contaImovel), 0);
			ContaGeral contaGeral = (ContaGeral) getControladorUtil().pesquisar(contaImovel.getContaGeral().getId(), ContaGeral.class,
							false);
			contaGeral.setIndicadorHistorico(ConstantesSistema.SIM);

			this.getControladorUtil().atualizar(contaGeral);

			contaImovel = null;

		}else{

			log.info("Atualiza a Conta Pré-Faturada para Conta 'Normal' => CONTA[" + contaImovel.getId() + "]");

			// Atualiza a Conta Pré-Faturada para Conta 'Normal'
			contaImovel.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));

			Integer consumoAguaAux = 0;
			Integer consumoEsgotoAux = 0;
			BigDecimal valorAgua = null;
			BigDecimal valorEsgoto = null;
			ContaMotivoRevisao contaMotivoRevisao = null;
			Short indicadorImpressao = ConstantesSistema.SIM;
			boolean houveAnormalidadeConsumoEstouro = false;

			if(movimentoRoteiroImovel.getConsumoAnormalidade() != null
							&& (movimentoRoteiroImovel.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.ESTOURO_CONSUMO) || movimentoRoteiroImovel
											.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.ESTOURO_ACUM_ACIMA_TETO))){

				houveAnormalidadeConsumoEstouro = true;
			}

			if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
							|| MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_NAO_IMPRESSA.equals(indicadorEmissaoCampo)
							|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){

				indicadorImpressao = ConstantesSistema.NAO;
			}

			String pIdMotivoRetencaoContaPreFaturada = null;

			try{

				pIdMotivoRetencaoContaPreFaturada = (String) ParametroFaturamento.P_MOTIVO_RETENCAO_CONTA_PREFAT.executar();
			}catch(ControladorException e){

				throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_MOTIVO_RETENCAO_CONTA_PREFAT");
			}

			// Verifica se o grupo de faturamento possui motivos de revisão associados no periodo de
			// referencia
			Collection colecaoMotivosRevisaoFaturamentoGrupo = this.repositorioFaturamento.pesquisarContasMotivoRevisaoGrupoFaturamento(
							faturamentoGrupo.getId(), contaImovel.getReferencia());

			boolean acatarValorFaturadoEmCampo = false;

			// **** ATENÇÃO **** Qualquer Alteração no "if" abaixo deve ser replicada na chamada do
			// método ajustarValoresPorCategoriaEFaixa
			if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
							|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)
							|| !Util.isVazioOrNulo(colecaoMotivosRevisaoFaturamentoGrupo)){

				if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
								|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){

					// Valores retornados pelo UC0120
					valorAgua = valorTotalAgua;
					valorEsgoto = valorTotalEsgoto;
				}else{

					valorAgua = valorFaturadoAgua;
					valorEsgoto = valorFaturadoEsgoto;
					acatarValorFaturadoEmCampo = true;
				}

				Integer idContaMotivoRevisao = null;
				FaturamentoGrupoRevisao faturamentoGrupoRevisao = null;

				// Seta o motivo de revisao para o valor do parametro caso o indicador de emissao
				// for conta retida (3)
				if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)){
					idContaMotivoRevisao = new Integer(pIdMotivoRetencaoContaPreFaturada);
				}

				// Caso seja encontrado um motivo de revisão associado ao grupo de faturamento seta
				// o mesmo na conta, independente da conta possuir ou não o indicador de emissao
				// para conta retida
				if(!Util.isVazioOrNulo(colecaoMotivosRevisaoFaturamentoGrupo)){

					faturamentoGrupoRevisao = (FaturamentoGrupoRevisao) Util.retonarObjetoDeColecao(colecaoMotivosRevisaoFaturamentoGrupo);

					if(faturamentoGrupoRevisao.getContaMotivoRevisao() != null){

						idContaMotivoRevisao = faturamentoGrupoRevisao.getContaMotivoRevisao().getId();
					}

					if(faturamentoGrupoRevisao.getIndicadorImpressao().equals(ConstantesSistema.SIM)){

						indicadorImpressao = ConstantesSistema.NAO;
					}

				}

				if(idContaMotivoRevisao != null && idContaMotivoRevisao.intValue() != ConstantesSistema.ZERO.intValue()){

					contaMotivoRevisao = new ContaMotivoRevisao();
					contaMotivoRevisao.setId(idContaMotivoRevisao);
					contaImovel.setContaMotivoRevisao(contaMotivoRevisao);
					contaImovel.setDataRevisao(new Date());
				}

				contaImovel.setUsuario(Usuario.USUARIO_BATCH);

				if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
								|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){

					if(movimentoRoteiroImovel.getNumeroConsumoMedio() != null){

						consumoAguaAux = movimentoRoteiroImovel.getNumeroConsumoMedio();
						consumoEsgotoAux = movimentoRoteiroImovel.getNumeroConsumoMedio();
					}
				}else{

					if(movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua() != null){

						consumoAguaAux = movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua();
					}

					if(movimentoRoteiroImovel.getNumeroConsumoFaturadoEsgoto() != null){

						consumoEsgotoAux = movimentoRoteiroImovel.getNumeroConsumoFaturadoEsgoto();
					}
				}
			}else{
				valorAgua = valorFaturadoAgua;
				valorEsgoto = valorFaturadoEsgoto;
				acatarValorFaturadoEmCampo = true;

				if(movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua() != null){
					consumoAguaAux = movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua();
				}

				if(movimentoRoteiroImovel.getNumeroConsumoFaturadoEsgoto() != null){
					consumoEsgotoAux = movimentoRoteiroImovel.getNumeroConsumoFaturadoEsgoto();
				}

				Integer idContaMotivoRevisao = null;

				if(houveAnormalidadeConsumoEstouro){

					idContaMotivoRevisao = new Integer((String) ParametroFaturamento.P_MOTIVO_RETENCAO_CONTA_FATUR_CONV.executar(this));
				}

				if(idContaMotivoRevisao != null && idContaMotivoRevisao.intValue() != ConstantesSistema.ZERO.intValue()){

					contaMotivoRevisao = new ContaMotivoRevisao();
					contaMotivoRevisao.setId(idContaMotivoRevisao);
					contaImovel.setContaMotivoRevisao(contaMotivoRevisao);
					contaImovel.setDataRevisao(new Date());
				}
			}

			contaImovel.setValorAgua(valorAgua);
			contaImovel.setValorEsgoto(valorEsgoto);
			contaImovel.setConsumoAgua(consumoAguaAux);
			contaImovel.setConsumoEsgoto(consumoEsgotoAux);
			contaImovel.setPercentualEsgoto(percentualEsgoto);

			// É necessário definir uma data de emissão na conta. Essa data é utilizada no processo
			// de arrecadação.
			Date dataEmissao = movimentoRoteiroImovel.getDataEmissao();

			if(dataEmissao == null){
				dataEmissao = movimentoRoteiroImovel.getDataLeitura();

				if(dataEmissao == null){
					dataEmissao = new Date();
				}
			}

			contaImovel.setDataEmissao(dataEmissao);
			contaImovel.setCreditoConsumo(movimentoRoteiroImovel.getNumeroConsumoCreditoFaturado());

			valorTotalCreditosConta = gerarCreditosRealizadosFaturamentoImediato(imovel, anoMesFaturamento, contaImovel,
							movimentoRoteiroImovel);

			contaImovel.setValorCreditos(valorTotalCreditosConta);

			// Consumo Rateio Água
			if(!Util.isVazioOuBranco(consumoHistoricoAgua) && !Util.isVazioOuBranco(consumoHistoricoAgua.getConsumoRateio())){
				contaImovel.setConsumoRateioAgua(consumoHistoricoAgua.getConsumoRateio());
			}else{
				contaImovel.setConsumoRateioAgua(ConstantesSistema.ZERO.intValue());
			}

			// Consumo Rateio Esgoto
			if(!Util.isVazioOuBranco(consumoHistoricoEsgoto) && !Util.isVazioOuBranco(consumoHistoricoEsgoto.getConsumoRateio())){
				contaImovel.setConsumoRateioEsgoto(consumoHistoricoEsgoto.getConsumoRateio());
			}else{
				contaImovel.setConsumoRateioEsgoto(ConstantesSistema.ZERO.intValue());
			}

			contaImovel.setConsumoTarifa(consumoTarifaConta);

			if(indicadorEmissaoCampo.equals(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_NAO_IMPRESSA)){

				String pColocarContasBloqueadasEmRevisao = null;

				try{

					pColocarContasBloqueadasEmRevisao = (String) ParametroFaturamento.P_COLOCAR_CONTAS_BLOQUEADAS_EM_REVISAO.executar();
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_COLOCAR_CONTAS_BLOQUEADAS_EM_REVISAO");
				}

				if(!Util.isVazioOuBranco(pColocarContasBloqueadasEmRevisao)
								&& pColocarContasBloqueadasEmRevisao.toString().equals(ConstantesSistema.SIM.toString())
								&& !Util.isVazioOuBrancoOuZero(pIdMotivoRetencaoContaPreFaturada)){

					contaMotivoRevisao = new ContaMotivoRevisao();
					contaMotivoRevisao.setId(Util.obterInteger(pIdMotivoRetencaoContaPreFaturada));
					contaImovel.setContaMotivoRevisao(contaMotivoRevisao);
					contaImovel.setDataRevisao(new Date());
				}

				// [SB0015 - Gera Relatório de Contas Bloqueadas para análise]
				gerarDadosRelatorioContasBloqueadasParaAnalise(movimentoRoteiroImovel, colecaoCategorias,
								colecaoContasBloqueadasAnaliseHelper);
			}

			// Altera a conta
			this.atualizarConta(contaImovel);

			if(gerouDivergencia){

				if(indicadorFaturamentoAgua.equals(ConstantesSistema.NAO) && indicadorFaturamentoEsgoto.equals(ConstantesSistema.NAO)){

					indicadorFaturamentoAgua = ConstantesSistema.SIM;

					// [UC0120] - Calcular Valores de Água e/ou Esgoto
					colecaoCalcularValoresAguaEsgotoHelper = calcularValoresAguaEsgoto(anoMesReferencia, ligacaoAguaSituacaoId,
									ligacaoEsgotoSituacaoId, indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategorias,
									consumoFaturadoMesAguaAux, consumoFaturadoMesEsgoto, consumoMinimoLigacao,
									dataLeituraAnteriorFaturamento, dataLeituraAtualFaturamento, percentualEsgoto,
									consumoTarifaConta.getId(), imovel.getId(), null);
				}

			}

			Object[] retornoDadosContaCategoriaEContaCategoriaConsumoFaixa = this
							.gerarDadosAtualizarContaCategoriaEInserirContaCategoriaConsumoFaixa(colecaoCategorias,
											colecaoCalcularValoresAguaEsgotoHelper, contaImovel);

			Collection colecaoContaCategoriaAtualizar = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixa[0];
			Collection colecaoContaCategoriaConsumoFaixaInserir = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixa[1];

			/*
			 * Caso tenha acontecido divergência entre os valores de água ou esgoto faturados em
			 * campo e os valores de água ou esgoto calculados pelo GSAN ajusta os valores por
			 * categoria e faixa baseado no valores faturados em campo, para não haver problema
			 * contábil
			 */
			if(gerouDivergencia && acatarValorFaturadoEmCampo){

				Object[] retornoDadosContaCategoriaEContaCategoriaConsumoFaixaAjustado = this.ajustarValoresPorCategoriaEFaixa(
								valorTotalAgua, valorFaturadoAgua, valorTotalEsgoto, valorFaturadoEsgoto,
								colecaoContaCategoriaConsumoFaixaInserir, colecaoContaCategoriaAtualizar, imovel, contaImovel);
				colecaoContaCategoriaAtualizar = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixaAjustado[0];
				colecaoContaCategoriaConsumoFaixaInserir = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixaAjustado[1];

			}

			// 2.2 Atualiza a conta categoria
			if(colecaoContaCategoriaAtualizar != null && !colecaoContaCategoriaAtualizar.isEmpty()){
				this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoContaCategoriaAtualizar);

				colecaoContaCategoriaAtualizar.clear();
				colecaoContaCategoriaAtualizar = null;
			}

			// 2.3 Incluir as conta categoria consumo faixa
			if(colecaoContaCategoriaConsumoFaixaInserir != null && !colecaoContaCategoriaConsumoFaixaInserir.isEmpty()){
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoriaConsumoFaixaInserir);

				colecaoContaCategoriaConsumoFaixaInserir.clear();
				colecaoContaCategoriaConsumoFaixaInserir = null;
			}

			// -------------------------------

			// 2.4 Incluir os clientes imovel em ClienteConta
			// this.inserirClienteConta(contaImovel, imovel);

			// 2.5 Incluir Conta impostos deduzidos
			// [UC0351] - Gerar Impostos Deduzidos da Conta
			// GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper =
			// this.gerarImpostosDeduzidosConta(contaImovel.getImovel()
			// .getId(), anoMesFaturamento, valorFaturadoAgua, valorFaturadoEsgoto,
			// valorTotalDebitosConta,
			// valorTotalCreditosConta);

			GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper = this.gerarImpostosDeduzidosConta(contaImovel.getImovel()
							.getId(), anoMesFaturamento, contaImovel.getValorAgua(), contaImovel.getValorEsgoto(), valorTotalDebitosConta,
							valorTotalCreditosConta);

			if(gerarImpostosDeduzidosContaHelper.getValorTotalImposto() != null){
				contaImovel.setValorImposto(gerarImpostosDeduzidosContaHelper.getValorTotalImposto());
			}else{
				contaImovel.setValorImposto(new BigDecimal("0.00"));
			}

			this.inserirContaImpostosDeduzidos(contaImovel, gerarImpostosDeduzidosContaHelper);

			// Incluir Conta Impressão
			ContaImpressao contaImpressao = this.gerarDadosContaImpressao(imovel, contaImovel, anoMesFaturamento, faturamentoGrupo,
							faturamentoAtivCronRota.getRota());
			contaImpressao.setIndicadorImpressao(indicadorImpressao);

			//
			// contaImpressao.setIndicadorImpressao(ConstantesSistema.SIM);
			//
			// if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
			// ||
			// MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_COLETA_DE_DADOS.equals(indicadorEmissaoCampo)
			// ||
			// MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_USUARIO_NAO_LOCALIZADO.equals(indicadorEmissaoCampo)
			// ||
			// MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_ESPECIAL.equals(indicadorEmissaoCampo)){
			// contaImpressao.setIndicadorImpressao(ConstantesSistema.NAO);
			// }

			// Inserir conta impressao
			getControladorUtil().inserir(contaImpressao);

			// ---------------------------------------------------------------------------------
			// [SB0005] - Atualizar Dados da Conta - Fim
			// ---------------------------------------------------------------------------------

			// ---------------------------------------------------------------------------------
			// [SB0006] - Gerar Movimento de Débito Automático - Início
			// ---------------------------------------------------------------------------------
			// DAMV_VLDEBITO
			// Valor total de água + Valor total de esgoto + Valor total dos débitos - Valor total
			// dos créditos – Valor dos impostos
			BigDecimal valorTotalConta = BigDecimal.ZERO;
			valorTotalConta = valorTotalConta.add(contaImovel.getValorAgua());
			valorTotalConta = valorTotalConta.add(contaImovel.getValorEsgoto());

			if(contaImovel.getDebitos() != null){
				valorTotalConta = valorTotalConta.add(contaImovel.getDebitos());
			}else{
				valorTotalConta = valorTotalConta.add(valorTotalDebitosConta);
			}

			if(contaImovel.getValorCreditos() != null){
				valorTotalConta = valorTotalConta.subtract(contaImovel.getValorCreditos());
			}

			if(contaImovel.getValorImposto() != null){
				valorTotalConta = valorTotalConta.subtract(contaImovel.getValorImposto());
			}

			String motivoRevisaoPermiteGerarMovimentoDebitoAutomatico = (String) ParametroFaturamento.P_MOTIVO_REVISAO_PERMITE_GERAR_MOV_DEBITO_AUTOMATICO
							.executar();

			/*
			 * Caso no imóvel esteja indicado que o pagamento será efetuado mediante débito em conta
			 * corrente, e a conta não esteja em revisão, ou o motivo da revisão permita gerar
			 * movimento de débito automático
			 */
			if((imovel.getIndicadorDebitoConta().equals(ConstantesSistema.SIM))
							&& (contaImovel.getContaMotivoRevisao() == null || (contaImovel.getContaMotivoRevisao() != null
											&& contaImovel.getContaMotivoRevisao().getId() != null
											&& motivoRevisaoPermiteGerarMovimentoDebitoAutomatico != null && motivoRevisaoPermiteGerarMovimentoDebitoAutomatico
												.contains(contaImovel.getContaMotivoRevisao().getId().toString())))){

				DebitoAutomaticoMovimentoCancelamentoMotivo debitoAutomaticoMovimentoMotivoCancelamento = null;

				if(contaImovel.getContaMotivoRevisao() != null
								&& contaImovel.getContaMotivoRevisao().getId() != null
								&& motivoRevisaoPermiteGerarMovimentoDebitoAutomatico != null
								&& motivoRevisaoPermiteGerarMovimentoDebitoAutomatico.contains(contaImovel.getContaMotivoRevisao().getId()
												.toString())){
					debitoAutomaticoMovimentoMotivoCancelamento = new DebitoAutomaticoMovimentoCancelamentoMotivo();
					debitoAutomaticoMovimentoMotivoCancelamento.setId(DebitoAutomaticoMovimentoCancelamentoMotivo.INCLUSAO_CONTA_REVISAO);
				}

				// [SF0006] - Gerar Movimento De Débito Automático
				this.gerarMovimentoDebitoAutomatico(imovel, contaImovel, valorTotalConta, faturamentoAtivCronRota, null,
								debitoAutomaticoMovimentoMotivoCancelamento);
			}

			// ---------------------------------------------------------------------------------
			// [SB0006] - Gerar Movimento de Débito Automático - Fim
			// ---------------------------------------------------------------------------------

			// ---------------------------------------------------------------------------------
			// [SB0007] - Gerar Resumo da Simulação do Faturamento - Início
			// ---------------------------------------------------------------------------------

			Imovel imovelBase = this.getControladorCliente().obterClienteImovelResponsavel(imovel.getId());
			if(imovelBase != null){
				if(imovelBase.getClienteImoveis() != null){
					imovel.setClienteImoveis(imovelBase.getClienteImoveis());
				}
			}else{
				imovel.setClienteImoveis(null);
			}

			this.gerarResumoSimulacaoFaturamento(colecaoCategorias, valorTotalDebitosConta, valorTotalCreditosConta,
							colecaoCalcularValoresAguaEsgotoHelper, colecaoResumoFaturamento, faturamentoAtivCronRota, imovel,
							anoMesReferencia, null, faturamentoGrupo);

			// ---------------------------------------------------------------------------------
			// [SB0007] - Gerar Resumo da Simulação do Faturamento - Fim
			// ---------------------------------------------------------------------------------

			// Transfere a conta para o histórico juntamente com seus
			// débitos cobrados e créditos realizados
			// if(valorTotalConta.compareTo(BigDecimal.ZERO) == 0){
			// Collection<Conta> colecaoConta = new ArrayList<Conta>();
			// colecaoConta.add(contaImovel);
			// this.transferirContasParaHistorico(colecaoConta, anoMesFaturamento);
			// }

			// Caso o imóvel esteja incluso no programa água para todos gerar
			// histórico de faturamento
			if(imovel.getImovelAguaParaTodos() != null){

				FaturamentoHistoricoAguaParaTodos faturamentoHistoricoAguaParaTodos = new FaturamentoHistoricoAguaParaTodos();

				faturamentoHistoricoAguaParaTodos.setDataHabilitacao(imovel.getImovelAguaParaTodos().getDataHabilitacao());
				faturamentoHistoricoAguaParaTodos.setAnoMesReferencia(contaImovel.getReferencia());
				faturamentoHistoricoAguaParaTodos.setTarifa(contaImovel.getConsumoTarifa().getId());

				BigDecimal consumoAgua = new BigDecimal(contaImovel.getConsumoAgua());
				faturamentoHistoricoAguaParaTodos.setConsumoMes(consumoAgua);

				faturamentoHistoricoAguaParaTodos.setValorConsumo(valorTotalConta);

				this.getControladorUtil().inserir(faturamentoHistoricoAguaParaTodos);
			}

			// ---------------------------------------------------------------------------------
			// [SB0002] - Determinar Valores para Faturamento de Água e/ou Esgoto - Fim
			// ---------------------------------------------------------------------------------
		}

		return contaImovel;
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato
	 * [SB0002] - Determinar Faturamento para o Imóvel
	 * [SB0015] - Gera Relatório de Contas Bloqueadas para análise
	 * 
	 * @author Anderson Italo
	 * @date 23/09/2013
	 */
	private void gerarDadosRelatorioContasBloqueadasParaAnalise(MovimentoRoteiroEmpresa movimentoRoteiroEmpresa,
					Collection colecaoCategorias, Collection<RelatorioContasBloqueadasAnaliseHelper> colecaoContasBloqueadasAnaliseHelper){

		RelatorioContasBloqueadasAnaliseHelper relatorioContasBloqueadasAnaliseHelper = new RelatorioContasBloqueadasAnaliseHelper();
		relatorioContasBloqueadasAnaliseHelper.setIdLocalidade(movimentoRoteiroEmpresa.getLocalidade().getId());
		relatorioContasBloqueadasAnaliseHelper.setDescricaoLocalidade(movimentoRoteiroEmpresa.getLocalidade().getDescricao());
		relatorioContasBloqueadasAnaliseHelper.setCodigoSetorComercial(movimentoRoteiroEmpresa.getCodigoSetorComercial());
		relatorioContasBloqueadasAnaliseHelper.setNumeroQuadra(movimentoRoteiroEmpresa.getNumeroQuadra().toString());
		relatorioContasBloqueadasAnaliseHelper.setNumeroLote(movimentoRoteiroEmpresa.getNumeroLoteImovel().toString());
		relatorioContasBloqueadasAnaliseHelper.setMatriculaImovel(movimentoRoteiroEmpresa.getImovel().getId());

		if(movimentoRoteiroEmpresa.getDataLeitura() != null){

			relatorioContasBloqueadasAnaliseHelper.setDataLeitura(Util.formatarData(movimentoRoteiroEmpresa.getDataLeitura()));
		}

		if(movimentoRoteiroEmpresa.getNumeroConsumo1() != null){

			relatorioContasBloqueadasAnaliseHelper.setConsumoMesUm(movimentoRoteiroEmpresa.getNumeroConsumo1().toString());
		}

		if(movimentoRoteiroEmpresa.getNumeroConsumo2() != null){

			relatorioContasBloqueadasAnaliseHelper.setConsumoMesDois(movimentoRoteiroEmpresa.getNumeroConsumo2().toString());
		}

		if(movimentoRoteiroEmpresa.getNumeroConsumo3() != null){

			relatorioContasBloqueadasAnaliseHelper.setConsumoMesTres(movimentoRoteiroEmpresa.getNumeroConsumo3().toString());
		}

		if(movimentoRoteiroEmpresa.getNumeroConsumo4() != null){

			relatorioContasBloqueadasAnaliseHelper.setConsumoMesQuatro(movimentoRoteiroEmpresa.getNumeroConsumo4().toString());
		}

		if(movimentoRoteiroEmpresa.getNumeroConsumo5() != null){

			relatorioContasBloqueadasAnaliseHelper.setConsumoMesCinco(movimentoRoteiroEmpresa.getNumeroConsumo5().toString());
		}

		if(movimentoRoteiroEmpresa.getNumeroConsumo6() != null){

			relatorioContasBloqueadasAnaliseHelper.setConsumoMesSeis(movimentoRoteiroEmpresa.getNumeroConsumo6().toString());
		}

		if(movimentoRoteiroEmpresa.getLeituraFaturada1() != null){

			relatorioContasBloqueadasAnaliseHelper.setLeituraMesUm(movimentoRoteiroEmpresa.getLeituraFaturada1().toString());
		}

		if(movimentoRoteiroEmpresa.getLeituraFaturada2() != null){

			relatorioContasBloqueadasAnaliseHelper.setLeituraMesDois(movimentoRoteiroEmpresa.getLeituraFaturada2().toString());
		}

		if(movimentoRoteiroEmpresa.getLeituraFaturada3() != null){

			relatorioContasBloqueadasAnaliseHelper.setLeituraMesTres(movimentoRoteiroEmpresa.getLeituraFaturada3().toString());
		}

		if(movimentoRoteiroEmpresa.getLeituraFaturada4() != null){

			relatorioContasBloqueadasAnaliseHelper.setLeituraMesQuatro(movimentoRoteiroEmpresa.getLeituraFaturada4().toString());
		}

		if(movimentoRoteiroEmpresa.getLeituraFaturada5() != null){

			relatorioContasBloqueadasAnaliseHelper.setLeituraMesCinco(movimentoRoteiroEmpresa.getLeituraFaturada5().toString());
		}

		if(movimentoRoteiroEmpresa.getLeituraFaturada6() != null){

			relatorioContasBloqueadasAnaliseHelper.setLeituraMesSeis(movimentoRoteiroEmpresa.getLeituraFaturada6().toString());
		}

		String economias = "";
		String descricaoCategorias = "";
		Iterator colecaoCategoriaIterator = colecaoCategorias.iterator();

		while(colecaoCategoriaIterator.hasNext()){

			Categoria categoria = (Categoria) colecaoCategoriaIterator.next();
			String quantidadeEconomias = categoria.getQuantidadeEconomiasCategoria().toString();

			if(categoria.getId().intValue() == Categoria.COMERCIAL_INT){

				descricaoCategorias += " COM";
				economias += " " + Util.completarStringZeroEsquerda(quantidadeEconomias, 3);
			}else if(categoria.getId().intValue() == Categoria.PUBLICO_INT){

				descricaoCategorias += " PUB";
				economias += " " + Util.completarStringZeroEsquerda(quantidadeEconomias, 3);
			}else if(categoria.getId().intValue() == Categoria.RESIDENCIAL_INT){

				descricaoCategorias += " RES";
				economias += " " + Util.completarStringZeroEsquerda(quantidadeEconomias, 3);
			}else if(categoria.getId().intValue() == Categoria.INDUSTRIAL_INT){

				descricaoCategorias += " IND";
				economias += " " + Util.completarStringZeroEsquerda(quantidadeEconomias, 3);
			}
		}

		relatorioContasBloqueadasAnaliseHelper.setDescricaoCategoria(descricaoCategorias);
		relatorioContasBloqueadasAnaliseHelper.setQuantidadeEconomias(economias);
		relatorioContasBloqueadasAnaliseHelper
						.setIdSituacaoLigacaoAgua(movimentoRoteiroEmpresa.getLigacaoAguaSituacao().getId().toString());
		relatorioContasBloqueadasAnaliseHelper.setIdSituacaoLigacaoEsgoto(movimentoRoteiroEmpresa.getLigacaoEsgotoSituacao().getId()
						.toString());

		Integer numeroConsumoFaturadoAgua = 0;
		if(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoAgua() != null){

			relatorioContasBloqueadasAnaliseHelper
							.setConsumoFaturadoAgua(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoAgua().toString());
			numeroConsumoFaturadoAgua = movimentoRoteiroEmpresa.getNumeroConsumoFaturadoAgua();
		}

		Integer numeroConsumoMedio = 0;
		if(movimentoRoteiroEmpresa.getNumeroConsumoMedio() != null){

			relatorioContasBloqueadasAnaliseHelper.setConsumoMedio(movimentoRoteiroEmpresa.getNumeroConsumoMedio().toString());
			numeroConsumoMedio = movimentoRoteiroEmpresa.getNumeroConsumoMedio();
		}

		Integer variacao = (numeroConsumoFaturadoAgua.intValue() - numeroConsumoMedio.intValue()) * 100;

		if(numeroConsumoMedio.intValue() > 0){

			variacao = Util.dividirArredondarResultado(variacao, numeroConsumoMedio);
		}

		relatorioContasBloqueadasAnaliseHelper.setVariacao(variacao.toString());

		if(movimentoRoteiroEmpresa.getNumeroConsumoMinimo() != null){

			relatorioContasBloqueadasAnaliseHelper.setConsumoMinimo(movimentoRoteiroEmpresa.getNumeroConsumoMinimo().toString());
		}

		if(movimentoRoteiroEmpresa.getPercentualEsgoto() != null){

			relatorioContasBloqueadasAnaliseHelper.setPercentualEsgoto(Util.formatarMoedaReal(
							movimentoRoteiroEmpresa.getPercentualEsgoto(), 2));
		}

		if(movimentoRoteiroEmpresa.getNumeroLeituraAnterior() != null){

			relatorioContasBloqueadasAnaliseHelper.setLeituraAnterior(movimentoRoteiroEmpresa.getNumeroLeituraAnterior().toString());
		}

		if(movimentoRoteiroEmpresa.getNumeroLeitura() != null){

			relatorioContasBloqueadasAnaliseHelper.setLeituraAtual(movimentoRoteiroEmpresa.getNumeroLeitura().toString());
		}

		if(movimentoRoteiroEmpresa.getLeituraAnormalidade() != null){

			relatorioContasBloqueadasAnaliseHelper.setIdLeituraAnormalidade(movimentoRoteiroEmpresa.getLeituraAnormalidade().getId()
							.toString());
		}

		if(movimentoRoteiroEmpresa.getConsumoTipo() != null
						&& movimentoRoteiroEmpresa.getConsumoTipo().getId().equals(ConsumoTipo.MEDIA_IMOVEL)){

			relatorioContasBloqueadasAnaliseHelper.setCobrouMedia("SIM");
		}else{

			relatorioContasBloqueadasAnaliseHelper.setCobrouMedia("NÃO");
		}

		if(movimentoRoteiroEmpresa.getNumeroDiasConsumo() != null){

			relatorioContasBloqueadasAnaliseHelper.setDiasConsumo(movimentoRoteiroEmpresa.getNumeroDiasConsumo().toString());
		}

		colecaoContasBloqueadasAnaliseHelper.add(relatorioContasBloqueadasAnaliseHelper);
	}
	
	public void retirarValorAguaEsgotoConjuntoContas(Collection colecaoContasSelecionadas, int cdValorARetirar,
					ContaMotivoRetificacao contaMotivoRetificacao, ContaMotivoCancelamento contaMotivoCancelamento, Usuario usuarioLogado)
					throws ControladorException{

		if(colecaoContasSelecionadas != null && !colecaoContasSelecionadas.isEmpty()){

			Iterator colecaoContasManutencaoIterator = colecaoContasSelecionadas.iterator();

			boolean icVaiCancelar;
			Collection<DebitoCobrado> colecaoDebitosCobrados = new ArrayList<DebitoCobrado>();
			Collection<Conta> colecaoContasParaCancelar = new ArrayList<Conta>();

			while(colecaoContasManutencaoIterator.hasNext()){
				icVaiCancelar = false;

				// Obtém os dados do crédito realizado
				Conta conta = (Conta) colecaoContasManutencaoIterator.next();

				// Zerar o Valor de Água e/ou Esgoto
				// icContaZerada => Indica se a conta está zerada (Valor de Àgua e Esgoto zerados)
				boolean icContaZerada = this.zerarValorAguaEsgotoConta(conta, cdValorARetirar);

				// Se a conta ficou zerada(Valor de Àgua e Esgoto zerados) e ela não possuir Débitos
				// Cobrados,
				// a conta deve ser cancelada, caso contrário, a conta deve ser retificada
				if(icContaZerada){

					colecaoDebitosCobrados = this.obterDebitosCobradosConta(conta);

					if(Util.isVazioOrNulo(colecaoDebitosCobrados)){

		colecaoContasParaCancelar.add(conta);
						icVaiCancelar = true;

					}

				}
				if(!icVaiCancelar){

					// ==================
					// Retificar a conta
					// ==================
					Collection colecaoCreditoRealizado = this.obterCreditosRealizadosConta(conta);
					Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasContaCategoria(conta);

					String consumoAgua = null;
					if(conta.getConsumoAgua() != null){
						consumoAgua = conta.getConsumoAgua().toString();
					}

					String consumoEsgoto = null;
					if(conta.getConsumoEsgoto() != null){
						consumoEsgoto = conta.getConsumoEsgoto().toString();
					}

					String percentualEsgoto = null;
					if(conta.getPercentualEsgoto() != null){
						percentualEsgoto = conta.getPercentualEsgoto().toString();
					}

					// Retificar conta
					this.retificarConta(conta.getReferencia(), conta, conta.getImovel(), colecaoDebitosCobrados, colecaoCreditoRealizado,
									conta.getLigacaoAguaSituacao(), conta.getLigacaoEsgotoSituacao(), colecaoCategoria, consumoAgua,
									consumoEsgoto, percentualEsgoto, conta.getDataVencimentoConta(), null, contaMotivoRetificacao, null,
									usuarioLogado, null, conta.getConsumoTarifa(), null);
				}


			}

			// ==================
			// Cancelar a conta
			// ==================
			if(!Util.isVazioOrNulo(colecaoContasParaCancelar)){
				cancelarConjuntoConta(colecaoContasParaCancelar, contaMotivoCancelamento, usuarioLogado, null);
			}
		}
	}

	/**
	 * Zera o(s) valor(es) de Àgua e/ou Esgoto da conta de acordo com parâmetro passado
	 * O método retorna um boolean que indica se a conta está "totalmente" zerada
	 * (Valor de Àgua e Esgoto zerados)
	 * 
	 * @author Hiroshi Gonçalves
	 * @date 07/11/2013
	 */
	private boolean zerarValorAguaEsgotoConta(Conta conta, int cdValorARetirar) throws ControladorException{

		boolean icContaZerada = false;

		// Zerar o Valor de Água e/ou Esgoto
		switch(cdValorARetirar){
			case ConstantesSistema.CD_VALOR_A_RETIRAR_AGUA:
				conta.setValorAgua(BigDecimal.ZERO);
				if(conta.getValorEsgoto() == null || conta.getValorEsgoto().equals(BigDecimal.ZERO)){
					icContaZerada = true;
				}
				break;

			case ConstantesSistema.CD_VALOR_A_RETIRAR_ESGOTO:
				conta.setValorEsgoto(BigDecimal.ZERO);
				if(conta.getValorAgua() == null || conta.getValorAgua().equals(BigDecimal.ZERO)){
					icContaZerada = true;
				}
				break;

			case ConstantesSistema.CD_VALOR_A_RETIRAR_AMBOS:
				conta.setValorAgua(BigDecimal.ZERO);
				conta.setValorEsgoto(BigDecimal.ZERO);
				icContaZerada = true;
				break;

			default:
				break;
		}
		return icContaZerada;
	}

	/**
	 * [UC0084] - Gerar Faturamento Imediato
	 * [SB0007] - Gerar Movimento Roteiro de Empresa
	 * [SB0004] – Obter os Créditos a Realizar
	 * 
	 * @author Anderson Italo
	 * @date 27/06/2013
	 */
	private void tratarCreditosARealizarEnvioFaturamentoImediato(Integer idImovel, MovimentoRoteiroEmpresa movimentoRoteiroEmpresa,
					Integer anoMesReferenciaFaturamento, boolean isRetornoFaturamento, Date dataGeracaoFaturamento)
					throws ControladorException{

		// [SB0004] – Obter os Créditos a Realizar
		Object[] creditosARealizarFaturaveis = this.obterCreditosARealizarFaturamentoImediato(idImovel, anoMesReferenciaFaturamento,
						isRetornoFaturamento, dataGeracaoFaturamento);

		Collection<CreditoARealizarHelper> colecaoCreditosARealizarHelper = (Collection<CreditoARealizarHelper>) creditosARealizarFaturaveis[1];
		BigDecimal valorTotalCreditos = (BigDecimal) creditosARealizarFaturaveis[0];

		int contadorCreditos = 1;
		BigDecimal valorCredito = BigDecimal.ZERO;
		String idCreditoTipo = "";
		String descricaoCreditoTipo = "";
		String dadosTextoCredito = "";

		if(valorTotalCreditos.compareTo(BigDecimal.ZERO) == 1){

			for(Iterator iteratorCreditosARealizarHelper = colecaoCreditosARealizarHelper.iterator(); iteratorCreditosARealizarHelper
							.hasNext();){

				CreditoARealizarHelper creditoARealizarHelper = (CreditoARealizarHelper) iteratorCreditosARealizarHelper.next();
				CreditoARealizar creditoARealizar = creditoARealizarHelper.getCreditoARealizar();
				idCreditoTipo = creditoARealizar.getCreditoTipo().getId().toString();
				idCreditoTipo = Util.adicionarZerosEsqueda(3, idCreditoTipo);
				descricaoCreditoTipo = creditoARealizar.getCreditoTipo().getDescricao();

				dadosTextoCredito = (Util.completaString(idCreditoTipo + descricaoCreditoTipo, 20)).substring(0, 20);

				if(contadorCreditos <= 5){

					Util.executarMetodo(movimentoRoteiroEmpresa, "setNumeroPrestacaoCredito" + contadorCreditos,
									creditoARealizar.getNumeroPrestacaoCredito());
					Util.executarMetodo(movimentoRoteiroEmpresa, "setNumeroPrestacaoCobradaCredito" + contadorCreditos,
									creditoARealizar.getNumeroPrestacaoRealizada());
					Util.executarMetodo(movimentoRoteiroEmpresa, "setDescricaoCredito" + contadorCreditos, dadosTextoCredito);

					if(creditoARealizar.getAnoMesReferenciaCredito() != null){

						Util.executarMetodo(movimentoRoteiroEmpresa, "setReferenciaCredito" + contadorCreditos,
										creditoARealizar.getAnoMesReferenciaCredito());
					}

					Util.executarMetodo(movimentoRoteiroEmpresa, "setValorCredito" + contadorCreditos,
									creditoARealizarHelper.getValorParcelaCredito());
				}else{

					movimentoRoteiroEmpresa.setNumeroPrestacaoCredito5(null);
					movimentoRoteiroEmpresa.setNumeroPrestacaoCobradaCredito5(null);
					movimentoRoteiroEmpresa.setDescricaoCredito5("Demais Créditos");
					movimentoRoteiroEmpresa.setReferenciaCredito5(null);

					valorCredito = creditoARealizarHelper.getValorParcelaCredito().add(movimentoRoteiroEmpresa.getValorCredito5());
					movimentoRoteiroEmpresa.setValorCredito5(valorCredito);
				}

				contadorCreditos++;
			}
		}

		movimentoRoteiroEmpresa.setValorCreditos(valorTotalCreditos);
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato
	 * [SB0004] - Gerar os Créditos Realizados
	 * 
	 * @author Anderson Italo
	 * @data 25/06/2013
	 */
	private BigDecimal gerarCreditosRealizadosFaturamentoImediato(Imovel imovel, int anoMesFaturamento, Conta contaImovel,
					MovimentoRoteiroEmpresa movimentoRoteiroImovel) throws ControladorException{

		Map<CreditoRealizado, Collection> mapCreditoRealizado = new HashMap();
		Collection<CreditoRealizado> colecaoCreditoRealizado = new ArrayList<CreditoRealizado>();
		BigDecimal valorTotalCreditosConta = BigDecimal.ZERO;

		// [FS0015 - Verificar créditos a realizar de parcelamento].
		Object[] creditosARealizarFaturaveis = this.obterCreditosARealizarFaturamentoImediato(imovel.getId(), anoMesFaturamento, true,
						movimentoRoteiroImovel.getTempoGeracaoArquivoTexto());


		Collection<CreditoARealizarHelper> colecaoCreditosARealizarHelper = (Collection<CreditoARealizarHelper>) creditosARealizarFaturaveis[1];
		Collection<CreditoARealizar> colecaoCreditosARealizarParaAtualizar = (Collection<CreditoARealizar>) creditosARealizarFaturaveis[2];
		Short numeroPrestacaoCreditoMovimento = null;
		Short numeroPrestacaoCobradaCreditoMovimento = null;
		Integer referenciaCreditoMovimento = null;
		Integer idCreditoTipoMovimento = null;
		BigDecimal valorCreditoMovimento = BigDecimal.ZERO;
		BigDecimal valorParcelaCreditado = BigDecimal.ZERO;
		HashMap<Integer, BigDecimal> mapValorResidualMesAnteriorCredito = new HashMap<Integer, BigDecimal>();
		HashMap<Integer, BigDecimal> mapValorPrestacaoCredito = new HashMap<Integer, BigDecimal>();
		boolean primeiroCreditoColunaOutros = true;
		int contadorCreditos = 1;
		boolean creditouTodoValorRetornadoMovimento = false;

		if(!Util.isVazioOrNulo(colecaoCreditosARealizarHelper)){

			for(Iterator iteratorCreditosARealizarHelper = colecaoCreditosARealizarHelper.iterator(); iteratorCreditosARealizarHelper
							.hasNext();){

				CreditoARealizarHelper creditoARealizarHelper = (CreditoARealizarHelper) iteratorCreditosARealizarHelper.next();
				CreditoARealizar creditoARealizar = creditoARealizarHelper.getCreditoARealizar();

				// Caso tenha havido credito lançado
				if(!creditouTodoValorRetornadoMovimento
								&& Util.executarMetodo(movimentoRoteiroImovel, "getValorCreditado" + contadorCreditos) != null
								&& new BigDecimal(Util.executarMetodo(movimentoRoteiroImovel, "getValorCreditado" + contadorCreditos)
												.toString()).compareTo(BigDecimal.ZERO) == 1){

					// Para cada crédito a realizar “creditado” o sistema deverá gerar um crédito
					// realizado correspondente, levando em conta o valor lançado e calculando o
					// saldo residual caso exista
					if(contadorCreditos <= 5
									&& Util.executarMetodo(movimentoRoteiroImovel, "getNumeroPrestacaoCredito" + contadorCreditos) != null){

						// Entra aqui caso tenha sido enviados até 5 ocorrências de crédito e na
						// última ocorrência não tenha mais de um crédito("Demais Créditos")
						numeroPrestacaoCreditoMovimento = (Short) Util.executarMetodo(movimentoRoteiroImovel, "getNumeroPrestacaoCredito"
										+ contadorCreditos);
						numeroPrestacaoCobradaCreditoMovimento = (Short) Util.executarMetodo(movimentoRoteiroImovel,
										"getNumeroPrestacaoCobradaCredito" + contadorCreditos);
						idCreditoTipoMovimento = Util.obterInteger((Util.executarMetodo(movimentoRoteiroImovel, "getDescricaoCredito"
										+ contadorCreditos)).toString().substring(0, 3));

						if(creditoARealizar.getAnoMesReferenciaCredito() != null){

							if(Util.executarMetodo(movimentoRoteiroImovel, "getReferenciaCredito" + contadorCreditos) != null){

								referenciaCreditoMovimento = Util.obterInteger(Util.executarMetodo(movimentoRoteiroImovel,
										"getReferenciaCredito" + contadorCreditos).toString());
							}
						}

						valorCreditoMovimento = new BigDecimal(Util.executarMetodo(movimentoRoteiroImovel,
										"getValorCreditado" + contadorCreditos).toString());

						if((creditoARealizar.getAnoMesReferenciaCredito() == null || referenciaCreditoMovimento.equals(creditoARealizar
										.getAnoMesReferenciaCredito()))
										&& idCreditoTipoMovimento.equals(creditoARealizar.getCreditoTipo().getId())
										&& numeroPrestacaoCreditoMovimento.equals(creditoARealizar.getNumeroPrestacaoCredito())
										&& numeroPrestacaoCobradaCreditoMovimento.equals(creditoARealizar.getNumeroPrestacaoRealizada())){

							// Caso o valor do crédito seja maior que zero
							if(valorCreditoMovimento.compareTo(BigDecimal.ZERO) == 1){

								// Calcula o valor da parcela
								valorParcelaCreditado = valorCreditoMovimento;

								// Caso o Valor do crédito seja maior que o valor do crédito
								// realizado
								if(creditoARealizarHelper.getValorParcelaCredito().compareTo(valorParcelaCreditado) == 1){

									mapValorResidualMesAnteriorCredito.put(creditoARealizar.getId(), creditoARealizarHelper
													.getValorParcelaCredito().subtract(valorParcelaCreditado));
								}

								mapValorPrestacaoCredito.put(creditoARealizar.getId(), valorParcelaCreditado);
							}
						}

						// A partir da quarta ocorrência de crédito para o contador em 5 para que no
						// próximo teste verifique se a última ocorrência é apenas um crédito ou os
						// "Demais Créditos"
						if(contadorCreditos < 5){

							contadorCreditos++;
						}else{

							creditouTodoValorRetornadoMovimento = true;
						}
					}else{

						// Acumulou mais de um crédito na última coluna de
						// créditos("Demais Créditos")
						if(primeiroCreditoColunaOutros){

							valorCreditoMovimento = movimentoRoteiroImovel.getValorCreditado5();
							primeiroCreditoColunaOutros = false;
						}

						// Caso o valor do crédito seja maior que zero
						if(valorCreditoMovimento != null && valorCreditoMovimento.compareTo(BigDecimal.ZERO) == 1){

							// Calcula o valor da parcela
							if(valorCreditoMovimento.compareTo(creditoARealizarHelper.getValorParcelaCredito()) == 1){

								valorParcelaCreditado = creditoARealizarHelper.getValorParcelaCredito();
								valorCreditoMovimento = valorCreditoMovimento.subtract(valorParcelaCreditado);
							}else{

								valorParcelaCreditado = valorCreditoMovimento;

								// Caso o Valor do crédito seja maior que o valor do crédito
								// realizado
								if(creditoARealizarHelper.getValorParcelaCredito().compareTo(valorParcelaCreditado) == 1){

									mapValorResidualMesAnteriorCredito.put(creditoARealizar.getId(), creditoARealizarHelper
													.getValorParcelaCredito().subtract(valorParcelaCreditado));

								}

								creditouTodoValorRetornadoMovimento = true;
							}

							mapValorPrestacaoCredito.put(creditoARealizar.getId(), valorParcelaCreditado);
						}
					}
				}
			}

			Collection<CreditoARealizar> colecaoCreditosARealizar = new ArrayList<CreditoARealizar>();

			for(CreditoARealizar creditoARealizarConsultado : colecaoCreditosARealizarParaAtualizar){

				CreditoARealizar creditoARealizar = (CreditoARealizar) getControladorUtil().pesquisar(creditoARealizarConsultado.getId(),
								CreditoARealizar.class, true);

				// Caso tenha créditos que foram cobrados na conta
				if(mapValorPrestacaoCredito.get(creditoARealizar.getId()) != null){

					// Inclui o crédito realizado na tabela CREDITO_REALIZADO com os seguintes
					// valores
					CreditoRealizado creditoRealizado = new CreditoRealizado();
					creditoRealizado.setCreditoTipo(creditoARealizar.getCreditoTipo());
					creditoRealizado.setDataHoraCreditoRealizado(new Date());
					creditoRealizado.setConta(contaImovel);
					creditoRealizado.setLancamentoItemContabil(creditoARealizar.getLancamentoItemContabil());
					creditoRealizado.setLocalidade(creditoARealizar.getLocalidade());
					creditoRealizado.setQuadra(creditoARealizar.getQuadra());
					creditoRealizado.setCodigoSetorComercial(creditoARealizar.getCodigoSetorComercial());
					creditoRealizado.setNumeroQuadra(creditoARealizar.getNumeroQuadra());
					creditoRealizado.setNumeroLote(creditoARealizar.getNumeroLote());
					creditoRealizado.setNumeroSubLote(creditoARealizar.getNumeroSubLote());
					creditoRealizado.setAnoMesReferenciaCredito(creditoARealizar.getAnoMesReferenciaCredito());
					creditoRealizado.setAnoMesCobrancaCredito(creditoARealizar.getAnoMesCobrancaCredito());
					creditoRealizado.setValorCredito(mapValorPrestacaoCredito.get(creditoARealizar.getId()));
					creditoRealizado.setCreditoOrigem(creditoARealizar.getCreditoOrigem());
					creditoRealizado.setNumeroPrestacao(creditoARealizar.getNumeroPrestacaoCredito());
					creditoRealizado.setParcelamento(creditoARealizar.getParcelamento());

					/*
					 * Caso o nº de prestações realizadas seja menor que o nº de prestação dos
					 * créditos calcula o valor correspondente da parcela do
					 * mês.
					 */
					if(creditoARealizar.getNumeroPrestacaoRealizada().intValue() < creditoARealizar.getNumeroPrestacaoCredito().intValue()){

						creditoRealizado.setNumeroPrestacaoCredito(Util.obterShort(String.valueOf(creditoARealizar
										.getNumeroPrestacaoRealizada().intValue() + 1)));
						creditoARealizar.setNumeroPrestacaoRealizada(creditoRealizado.getNumeroPrestacaoCredito());
					}else{

						creditoRealizado.setNumeroPrestacaoCredito(creditoARealizar.getNumeroPrestacaoRealizada());
					}

					creditoRealizado.setUltimaAlteracao(new Date());
					colecaoCreditoRealizado.add(creditoRealizado);

					// Obtém os créditos a realizar categoria
					Collection colecaoCreditoARealizarCategoria = this.obterCreditoRealizarCategoria(creditoARealizar.getId());
					Iterator colecaoCreditoARealizarCategoriaIterator = colecaoCreditoARealizarCategoria.iterator();

					// Crédito a realizar categoria
					CreditoARealizarCategoria creditoARealizarCategoria = null;

					Collection colecaoCategoriasObterValor = new ArrayList();

					// Laço para recuperar as categorias do crédito a realizar
					while(colecaoCreditoARealizarCategoriaIterator.hasNext()){

						creditoARealizarCategoria = (CreditoARealizarCategoria) colecaoCreditoARealizarCategoriaIterator.next();
						Categoria categoria = new Categoria();
						categoria.setId(creditoARealizarCategoria.getCategoria().getId());
						categoria.setQuantidadeEconomiasCategoria(creditoARealizarCategoria.getQuantidadeEconomia());
						colecaoCategoriasObterValor.add(categoria);
					}

					// Obter os valores do credito realizado por categoria
					Collection colecaoCategoriasCalculadasValor = getControladorImovel().obterValorPorCategoria(
									colecaoCategoriasObterValor, mapValorPrestacaoCredito.get(creditoARealizar.getId()));

					Iterator colecaoCategoriasCalculadasValorIterator = colecaoCategoriasCalculadasValor.iterator();
					Iterator colecaoCategoriasObterValorIterator = colecaoCategoriasObterValor.iterator();
					CreditoRealizadoCategoria creditoRealizadoCategoria = null;
					Collection colecaoCreditosRealizadoCategoria = new ArrayList();

					while(colecaoCategoriasCalculadasValorIterator.hasNext() && colecaoCategoriasObterValorIterator.hasNext()){

						// Obtém o valor por categoria
						BigDecimal valorPorCategoria = (BigDecimal) colecaoCategoriasCalculadasValorIterator.next();

						// Obtém a categoria
						Categoria categoria = (Categoria) colecaoCategoriasObterValorIterator.next();

						// Cria o crédito realizado por categoria
						creditoRealizadoCategoria = new CreditoRealizadoCategoria();
						CreditoRealizadoCategoriaPK creditoRealizadoCategoriaPk = new CreditoRealizadoCategoriaPK();
						creditoRealizadoCategoriaPk.setCategoria(categoria);
						creditoRealizadoCategoriaPk.setCreditoRealizado(creditoRealizado);
						creditoRealizadoCategoria.setComp_id(creditoRealizadoCategoriaPk);
						creditoRealizadoCategoria.setValorCategoria(valorPorCategoria);
						creditoRealizadoCategoria.setCreditoRealizado(creditoRealizado);
						creditoRealizadoCategoria.setCategoria(categoria);
						creditoRealizadoCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
						colecaoCreditosRealizadoCategoria.add(creditoRealizadoCategoria);

						CreditoARealizarCategoria creditoARealizarCategoriaRegLancConta = new CreditoARealizarCategoria();
						creditoARealizarCategoriaRegLancConta.setValorCategoria(valorPorCategoria);
						creditoARealizarCategoriaRegLancConta.setCategoria(categoria);
						creditoARealizarCategoriaRegLancConta.setCreditoARealizar(creditoARealizar);

						if(creditoARealizar.getNumeroPrestacaoCredito() - creditoARealizar.getNumeroPrestacaoRealizada() > 12){

							getControladorContabil().registrarLancamentoContabil(creditoARealizarCategoriaRegLancConta,
											OperacaoContabil.TRANSFERENCIA_CREDITO_LONGO_PARA_CURTO_PRAZO);
						}
					}

					// Armazena o credito realizado junto com os créditos realizados por categoria
					mapCreditoRealizado.put(creditoRealizado, colecaoCreditosRealizadoCategoria);
					colecaoCategoriasCalculadasValor = null;
					valorTotalCreditosConta = valorTotalCreditosConta.add(mapValorPrestacaoCredito.get(creditoARealizar.getId()));

					if(mapValorResidualMesAnteriorCredito.get(creditoARealizar.getId()) != null){

						creditoARealizar.setValorResidualMesAnterior(mapValorResidualMesAnteriorCredito.get(creditoARealizar.getId()));
					}else{

						creditoARealizar.setValorResidualMesAnterior(BigDecimal.ZERO);
					}

					colecaoCreditosARealizar.add(creditoARealizar);
				}
			}

			// inserir os creditos realizados e creditos realizados categoria
			if(mapCreditoRealizado != null){

				this.inserirCreditoRealizado(mapCreditoRealizado, contaImovel);
			}

			// atualizar os creditos a realizar e transfere pro histórico se for a última prestação
			if(!Util.isVazioOrNulo(colecaoCreditosARealizar)){

				this.atualizarCreditoARealizar(colecaoCreditosARealizar);
			}
		}

		return valorTotalCreditosConta;
	}

	/**
	 * [UC0088] Registrar Faturamento Imediato
	 * [SB0011] – Gerar Valor de Rateio
	 * 
	 * @author Anderson Italo
	 * @date 26/06/2012
	 */
	private void gerarValorRateio(Imovel imovel, int anoMesFaturamento, Conta conta, MovimentoRoteiroEmpresa movimentoRoteiroEmpresa,
					Collection colecaoCategorias) throws ControladorException{

		/*
		 * Caso o modo de incorporação do rateio tenha valor 0(zero)(MREM_ICMODOFATURRATEIO com
		 * valor 0 - cobrança em debito a cobrar – em MOVIMENTO_ROTEIRO_EMPRESA)
		 */
		if(movimentoRoteiroEmpresa.getIndicadorModoFaturarRateio().equals(MovimentoRoteiroEmpresa.COBRANCA_EM_DEBITO_A_COBRAR)){

			/*
			 * Gerar débito a cobrar de rateio para valor rateado obtido e
			 * o tipo de débito(DBTP_ID de DEBITO_TIPO) com valor em [Parâmetro =
			 * P_DEBITO_TIPO_RATEIO] <<Inclui>>[UC0183] Inserir Débito A Cobrar]
			 */
			String parametroDebitoTipoRateio = (String) ParametroMicromedicao.P_DEBITO_TIPO_RATEIO.executar(this, 0);

			DebitoTipo debitoTipo = (DebitoTipo) getControladorUtil().pesquisar(Util.obterInteger(parametroDebitoTipoRateio),
							DebitoTipo.class, true);
			CobrancaForma cobrancaForma = new CobrancaForma();
			cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

			DebitoACobrar debitoACobrar = new DebitoACobrar();
			debitoACobrar.setDebitoTipo(debitoTipo);
			debitoACobrar.setValorDebito(movimentoRoteiroEmpresa.getValorRateio());
			debitoACobrar.setImovel(imovel);
			debitoACobrar.setGeracaoDebito(new Date());
			debitoACobrar.setLocalidade(imovel.getLocalidade());
			debitoACobrar.setQuadra(imovel.getQuadra());
			debitoACobrar.setAnoMesReferenciaDebito(anoMesFaturamento);
			debitoACobrar.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());
			debitoACobrar.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
			debitoACobrar.setCobrancaForma(cobrancaForma);
			debitoACobrar.setUltimaAlteracao(new Date());
			debitoACobrar.setAnoMesCobrancaDebito(Util.somaMesAnoMesReferencia(anoMesFaturamento, 1));

			this.inserirDebitoACobrar(1, debitoACobrar, null, imovel, null, null, Usuario.USUARIO_BATCH, false, null, null, null);

		}else if(movimentoRoteiroEmpresa.getIndicadorModoFaturarRateio().equals(MovimentoRoteiroEmpresa.COBRANCA_NA_CONTA_ATUAL)){

			/*
			 * Caso o modo de incorporação do rateio tenha valor 1(um) (MREM_ICMODOFATURRATEIO
			 * com valor 1 - cobrança na conta atual – em MOVIMENTO_ROTEIRO_EMPRESA);
			 * inclui o débito cobrado na tabela DEBITO_COBRADO com os seguintes valores
			 */
			String parametroDebitoTipoRateio = (String) ParametroMicromedicao.P_DEBITO_TIPO_RATEIO.executar(this, 0);

			DebitoTipo debitoTipo = (DebitoTipo) getControladorUtil().pesquisar(Util.obterInteger(parametroDebitoTipoRateio),
							DebitoTipo.class, true);
			CobrancaForma cobrancaForma = new CobrancaForma();
			cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);
			Collection<DebitoCobrado> colecaoDebitoCobrado = new ArrayList<DebitoCobrado>();

			DebitoCobrado debitoCobrado = new DebitoCobrado();
			debitoCobrado.setDebitoTipo(debitoTipo);
			debitoCobrado.setValorPrestacao(movimentoRoteiroEmpresa.getValorRateio());
			debitoCobrado.setAnoMesReferenciaDebito(conta.getReferencia());
			debitoCobrado.setAnoMesCobrancaDebito(conta.getReferencia());
			debitoCobrado.setNumeroPrestacao(Util.obterShort("1"));
			debitoCobrado.setNumeroPrestacaoDebito(Util.obterShort("1"));
			debitoCobrado.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
			debitoCobrado.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());
			colecaoDebitoCobrado.add(debitoCobrado);

			this.inserirDebitoCobrado(conta, colecaoDebitoCobrado, imovel, colecaoCategorias, false);

			BigDecimal valorDebitosConta = conta.getDebitos();
			BigDecimal valorDebitosMovimento = movimentoRoteiroEmpresa.getValorDebitos();

			if(valorDebitosConta != null){

				valorDebitosConta = valorDebitosConta.add(movimentoRoteiroEmpresa.getValorRateio());
			}else{

				valorDebitosConta = movimentoRoteiroEmpresa.getValorRateio();
			}

			if(valorDebitosMovimento != null){

				valorDebitosMovimento = valorDebitosMovimento.add(movimentoRoteiroEmpresa.getValorRateio());
			}else{

				valorDebitosMovimento = movimentoRoteiroEmpresa.getValorRateio();
			}

			conta.setDebitos(valorDebitosConta);
			movimentoRoteiroEmpresa.setValorDebitos(valorDebitosMovimento);
		}
	}

	/**
	 * [UC0088] Registrar Faturamento Imediato
	 * [SB0014 – Gerar Valor de Religação e Sanção]
	 * 
	 * @author Yara Souza
	 * @date 22/07/2013
	 */
	private void gerarValorReligacaoESancao(Imovel imovel, int anoMesFaturamento, Conta conta,
					MovimentoRoteiroEmpresa movimentoRoteiroEmpresa, Collection colecaoCategorias) throws ControladorException{

	
		DebitoTipo debitoTipo = null;
			Integer idServicoTipo = null;
			BigDecimal valor = BigDecimal.ZERO;
			BigDecimal valorDebitosConta = conta.getDebitos();
			BigDecimal valorDebitosMovimento = movimentoRoteiroEmpresa.getValorDebitos();
			
		// MREM_IDSERVICORELIGACAO (para MREM_VLRELIGACAO > 0) e/ou MREM_IDSERVICOSANCAO (para
		// MREM_VLSANCAO > 0)
		if(movimentoRoteiroEmpresa.getValorReligacao() != null
						&& movimentoRoteiroEmpresa.getValorReligacao().compareTo(BigDecimal.ZERO) > 0){
				idServicoTipo = movimentoRoteiroEmpresa.getIdServicoReligacao();
				valor = movimentoRoteiroEmpresa.getValorReligacao();
			}
			
		if(movimentoRoteiroEmpresa.getValorSancao() != null && movimentoRoteiroEmpresa.getValorSancao().compareTo(BigDecimal.ZERO) > 0){
				idServicoTipo = movimentoRoteiroEmpresa.getIdServicoSancao();
				valor = movimentoRoteiroEmpresa.getValorSancao();
			}
			
		if(idServicoTipo != null){

			ServicoTipo servicoTipo = (ServicoTipo) getControladorUtil().pesquisar(idServicoTipo, ServicoTipo.class, true);
			if(servicoTipo != null && servicoTipo.getDebitoTipo() != null){
				debitoTipo = (DebitoTipo) getControladorUtil().pesquisar(servicoTipo.getDebitoTipo().getId(), DebitoTipo.class, true);
			}

			}
			
			

			CobrancaForma cobrancaForma = new CobrancaForma();
			cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);
			Collection<DebitoCobrado> colecaoDebitoCobrado = new ArrayList<DebitoCobrado>();

			DebitoCobrado debitoCobrado = new DebitoCobrado();
			debitoCobrado.setDebitoTipo(debitoTipo);
			debitoCobrado.setValorPrestacao(valor);
			debitoCobrado.setAnoMesReferenciaDebito(conta.getReferencia());
			debitoCobrado.setAnoMesCobrancaDebito(conta.getReferencia());
			debitoCobrado.setNumeroPrestacao(Util.obterShort("1"));
			debitoCobrado.setNumeroPrestacaoDebito(Util.obterShort("1"));
			debitoCobrado.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
			debitoCobrado.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());
			colecaoDebitoCobrado.add(debitoCobrado);

			this.inserirDebitoCobrado(conta, colecaoDebitoCobrado, imovel, colecaoCategorias, false);

			

			if(valorDebitosConta != null){

				valorDebitosConta = valorDebitosConta.add(valor);
			}else{

				valorDebitosConta = valor;
			}

			if(valorDebitosMovimento != null){

				valorDebitosMovimento = valorDebitosMovimento.add(valor);
			}else{

				valorDebitosMovimento = valor;
			}

			conta.setDebitos(valorDebitosConta);
			movimentoRoteiroEmpresa.setValorDebitos(valorDebitosMovimento);
		}

	/**
	 * [UC0088] Registrar Faturamento Imediato
	 * [SB0013 – Atualizar Dados do Imóvel]
	 * 
	 * @author Yara Souza
	 * @date 22/07/2013
	 */
	private void atualizarDadosImovel(MovimentoRoteiroEmpresa movimentoRoteiroEmpresa) throws ControladorException{

		// Caso MREM_ICRELIGACAOAGUA de MOVIMENTO_ROTEIRO_EMPRESA tenha valor 1(um), efetuar as
		// seguintes atualizações:
		Imovel imovel = movimentoRoteiroEmpresa.getImovel();
		boolean atualizarImovel = false;

		if(movimentoRoteiroEmpresa.getIndicadorReligacaoAgua().equals(ConstantesSistema.SIM)){

			LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
			ligacaoAguaSituacao.setId(LigacaoAguaSituacao.LIGADO);
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
			atualizarImovel = true;

			LigacaoAgua ligacaoAgua = imovel.getLigacaoAgua();

			if(ligacaoAgua != null){
				ligacaoAgua.setDataReligacao(movimentoRoteiroEmpresa.getDataLeitura());
				ligacaoAgua.setFuncionarioReligacaoAgua(null);
				ligacaoAgua.setUltimaAlteracao(new Date());
				ligacaoAgua.setNumeroReligacao(ligacaoAgua.getNumeroReligacao() + 1);

				this.getControladorUtil().atualizar(ligacaoAgua);
			}

		}

		if(!Util.isVazioOuBranco(movimentoRoteiroEmpresa.getNumeroImovelAlteracao())){
			imovel.setNumeroImovel(movimentoRoteiroEmpresa.getNumeroImovelAlteracao());
			atualizarImovel = true;
		}

		if(atualizarImovel){
			imovel.setUltimaAlteracao(new Date());
			this.getControladorUtil().atualizar(imovel);
		}

	}


	/**
	 * [UC0088] - Registrar Faturamento Imediato.
	 * [SB0002] - Determinar Faturamento para o Imóvel.
	 * 
	 * @author Ailton Sousa
	 * @data 16/09/2011
	 * @param colecaoCategorias
	 * @param colecaoCalcularValoresAguaEsgotoHelper
	 * @param conta
	 * @return
	 * @throws ControladorException
	 */
	public Object[] gerarDadosAtualizarContaCategoriaEInserirContaCategoriaConsumoFaixa(Collection colecaoCategorias,
					Collection colecaoCalcularValoresAguaEsgotoHelper, Conta conta) throws ControladorException{

		Object[] retorno = new Object[2];
		Collection colecaoContaCategoriaAtualizar = null;
		ContaCategoria contaCategoria = null;
		ContaCategoriaPK contaCategoriaPK = null;
		Categoria categoria = null;

		// incluir as faixas de consumo por categoria em
		ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = null;
		Collection colecaoContaCategoriaConsumoFaixaInserir = null;

		if((colecaoCategorias != null && !colecaoCategorias.isEmpty())
						&& (colecaoCalcularValoresAguaEsgotoHelper != null && !colecaoCalcularValoresAguaEsgotoHelper.isEmpty())){

			colecaoContaCategoriaAtualizar = new ArrayList();
			colecaoContaCategoriaConsumoFaixaInserir = new ArrayList();
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = null;
			FiltroContaCategoria filtroContaCategoria = null;
			Collection colecaoContaCategoria = null;

			// colecao de categorias
			Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();

			// colecao com os valores para ser usados em conta categoria
			Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper.iterator();

			while(iteratorColecaoCategorias.hasNext() && iteratorColecaoCalcularValoresAguaEsgotoHelper.hasNext()){
				categoria = (Categoria) iteratorColecaoCategorias.next();
				calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper.next();

				contaCategoria = new ContaCategoria();
				contaCategoriaPK = new ContaCategoriaPK();

				contaCategoriaPK.setConta(conta);
				contaCategoriaPK.setCategoria(categoria);
				contaCategoriaPK.setSubcategoria(this.getControladorImovel()
								.obterPrincipalSubcategoria(categoria.getId(), conta.getImovel().getId()).getComp_id().getSubcategoria());

				filtroContaCategoria = new FiltroContaCategoria();
				filtroContaCategoria.adicionarParametro(new ParametroSimples(FiltroContaCategoria.CONTA_ID, conta.getId()));
				filtroContaCategoria.adicionarParametro(new ParametroSimples(FiltroContaCategoria.CATEGORIA_ID, categoria.getId()));
				filtroContaCategoria.adicionarParametro(new ParametroSimples(FiltroContaCategoria.SUBCATEGORIA_ID,
								Subcategoria.SUBCATEGORIA_ZERO.getId()));

				colecaoContaCategoria = getControladorUtil().pesquisar(filtroContaCategoria, ContaCategoria.class.getName());

				if(colecaoContaCategoria != null && !colecaoContaCategoria.isEmpty()){
					contaCategoria = (ContaCategoria) Util.retonarObjetoDeColecao(colecaoContaCategoria);

					System.out.println("conta;categoria;qtdEconomia " + conta.getId() + ";" + categoria.getId() + ";"
									+ contaCategoria.getQuantidadeEconomia());

					// Preenche os dados que vão ser atualizados.
					if(contaCategoria != null){
						contaCategoria.setComp_id(contaCategoriaPK);
						contaCategoria.setValorAgua(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria());
						contaCategoria.setConsumoAgua(calcularValoresAguaEsgotoHelper.getConsumoFaturadoAguaCategoria());
						contaCategoria.setValorEsgoto(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria());
						contaCategoria.setConsumoEsgoto(calcularValoresAguaEsgotoHelper.getConsumoFaturadoEsgotoCategoria());
						contaCategoria.setValorTarifaMinimaAgua(calcularValoresAguaEsgotoHelper.getValorTarifaMinimaAguaCategoria());
						contaCategoria.setConsumoMinimoAgua(calcularValoresAguaEsgotoHelper.getConsumoMinimoAguaCategoria());
						contaCategoria.setValorTarifaMinimaEsgoto(calcularValoresAguaEsgotoHelper.getValorTarifaMinimaEsgotoCategoria());
						contaCategoria.setConsumoMinimoEsgoto(calcularValoresAguaEsgotoHelper.getConsumoMinimoEsgotoCategoria());
						contaCategoria.setUltimaAlteracao(new Date());

						if(contaCategoria.getQuantidadeEconomia() == null){
							System.out.println("conta s/ QuantidadeEconomia = " + conta.getId());
						}

						colecaoContaCategoriaAtualizar.add(contaCategoria);

						Collection colecaoFaixaTarifaConsumo = calcularValoresAguaEsgotoHelper.getFaixaTarifaConsumo();

						if(colecaoFaixaTarifaConsumo != null && !colecaoFaixaTarifaConsumo.isEmpty()){
							Iterator iteratorColecaoFaixaTarifaConsumo = colecaoFaixaTarifaConsumo.iterator();

							CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = null;

							while(iteratorColecaoFaixaTarifaConsumo.hasNext()){
								calcularValoresAguaEsgotoFaixaHelper = (CalcularValoresAguaEsgotoFaixaHelper) iteratorColecaoFaixaTarifaConsumo
												.next();

								// conta categoria consumo faixa
								contaCategoriaConsumoFaixa = new ContaCategoriaConsumoFaixa();
								contaCategoriaConsumoFaixa.setContaCategoria(contaCategoria);
								contaCategoriaConsumoFaixa.setValorAgua(calcularValoresAguaEsgotoFaixaHelper.getValorFaturadoAguaFaixa());
								contaCategoriaConsumoFaixa.setConsumoAgua(calcularValoresAguaEsgotoFaixaHelper
												.getConsumoFaturadoAguaFaixa());
								contaCategoriaConsumoFaixa.setValorEsgoto(calcularValoresAguaEsgotoFaixaHelper
												.getValorFaturadoEsgotoFaixa());
								contaCategoriaConsumoFaixa.setConsumoEsgoto(calcularValoresAguaEsgotoFaixaHelper
												.getConsumoFaturadoEsgotoFaixa());
								contaCategoriaConsumoFaixa.setConsumoFaixaInicio(calcularValoresAguaEsgotoFaixaHelper
												.getLimiteInicialConsumoFaixa());
								contaCategoriaConsumoFaixa.setConsumoFaixaFim(calcularValoresAguaEsgotoFaixaHelper
												.getLimiteFinalConsumoFaixa());
								contaCategoriaConsumoFaixa.setValorTarifaFaixa(calcularValoresAguaEsgotoFaixaHelper.getValorTarifaFaixa());
								contaCategoriaConsumoFaixa.setUltimaAlteracao(new Date());

								colecaoContaCategoriaConsumoFaixaInserir.add(contaCategoriaConsumoFaixa);

							}
						}
					}

				}

			}
		}

		retorno[0] = colecaoContaCategoriaAtualizar;
		retorno[1] = colecaoContaCategoriaConsumoFaixaInserir;

		return retorno;

	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Determina os dados do faturamento do imóvel.
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * 
	 * @author Yara Souza
	 * @data 19/08/2011
	 * @param imovel
	 * @param anoMesFaturamento
	 * @param faturamentoAtivCronRta
	 * @param colecaoResumoFaturamento
	 * @param sistemaParametro
	 * @param antecipado
	 * @param faturamentoGrupo
	 * @param anoMes
	 * @return Conta [Conta gerada para imóvel, que será usada para geração de Histogramas, Resumos
	 *         e Contabilizacao]
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	private Conta determinarFaturamentoImovelParaFaturamento(Imovel imovel, int anoMesFaturamento,
					FaturamentoAtivCronRota faturamentoAtivCronRota, Collection colecaoResumoFaturamento,
					SistemaParametro sistemaParametro, boolean antecipado, FaturamentoGrupo faturamentoGrupo, Integer anoMes,
					Collection<Imovel> colecaoOcorrenciaGeracaoPreFaturamento, FaturamentoSimulacaoComando faturamentoSimulacaoComando)
					throws ControladorException, ErroRepositorioException{

		Conta contaGerada = null;

		// Coleção que vai armazenar as categorias do imóvel
		Collection colecaoCategorias = null;

		// [UC0108] - Obter Quantidade de Economias por Categoria
		colecaoCategorias = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		// [UC0120] - Calcular Valores de Água e/ou Esgoto
		BigDecimal valorTotalAgua = new BigDecimal("0.00");
		BigDecimal valorTotalEsgoto = new BigDecimal("0.00");
		Collection colecaoCalcularValoresAguaEsgotoHelper = null;

		Integer anoMesReferencia = anoMesFaturamento;
		BigDecimal percentualEsgoto = BigDecimal.ZERO;
		Integer consumoFaturadoMesAgua = null;
		Integer consumoFaturadoMesEsgoto = null;
		ConsumoHistorico consumoHistoricoAgua = null;
		ConsumoHistorico consumoHistoricoEsgoto = null;
		// Pesquisar consumo histórico
		MedicaoHistorico medicaoHistoricoAgua = null;
		MedicaoHistorico medicaoHistoricoPoco = null;
		ConsumoTarifa consumoTarifaConta = null;

		// Cria o tipo de ligação para água.
		LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
		ligacaoTipoAgua.setId(LigacaoTipo.LIGACAO_AGUA);

		// Cria o tipo de ligação para esgoto.
		LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
		ligacaoTipoEsgoto.setId(LigacaoTipo.LIGACAO_ESGOTO);

		Integer idContaAnoMesReferencia = null;

		try{
			idContaAnoMesReferencia = repositorioFaturamento.pesquisarExistenciaConta(imovel, anoMesReferencia.intValue());
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}


		// Seta valores iniciais para os indicadores de faturamento de água e esgoto.
		Short indicadorFaturamentoAgua = Short.valueOf("2");
		Short indicadorFaturamentoEsgoto = Short.valueOf("2");
		int consumoMinimoLigacao = 0;
		Date dataLeituraAnteriorFaturamento = null;
		Date dataLeituraAtualFaturamento = null;

		if(idContaAnoMesReferencia == null){

			// ---------------------------------------------------------------------------------
			// [SB0002] - Determinar Valores para Faturamento de Água e/ou Esgoto - Início
			// ---------------------------------------------------------------------------------

			Integer ligacaoAguaSituacaoId = imovel.getLigacaoAguaSituacao().getId();
			Integer ligacaoEsgotoSituacaoId = imovel.getLigacaoEsgotoSituacao().getId();

			Calendar data = new GregorianCalendar();
			data.set(Calendar.YEAR, Integer.parseInt(anoMes.toString().substring(0, 4)));
			data.set(Calendar.MONTH, Integer.parseInt(anoMes.toString().substring(4, 6)) - 1);
			data.set(Calendar.DATE, 1);
			data.add(Calendar.MONTH, -1);

			String anoMesAnterior = "";
			anoMesAnterior = data.get(Calendar.YEAR) + "";
			if((data.get(Calendar.MONTH) + 1) < 10){
				anoMesAnterior = anoMesAnterior + "0" + (data.get(Calendar.MONTH) + 1);
			}else{
				anoMesAnterior = anoMesAnterior + (data.get(Calendar.MONTH) + 1);
			}


			try{
				// Determina a data de leitura anterior do faturamento

				dataLeituraAnteriorFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
								faturamentoGrupo.getId(), FaturamentoAtividade.EFETUAR_LEITURA, Integer.valueOf(anoMesAnterior));

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			// Determina a data de leitura atual do faturamento
			try{
				dataLeituraAtualFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
								faturamentoGrupo.getId(), FaturamentoAtividade.EFETUAR_LEITURA, anoMes);

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			// Inicializa com zero o percentual de esgoto o consumo faturado do mês de água e de
			// esgoto
			percentualEsgoto = new BigDecimal(0);
			consumoFaturadoMesAgua = Integer.valueOf("0");
			consumoFaturadoMesEsgoto = Integer.valueOf("0");

			// Caso não tenha sido informado um comando de simulação de faturamento
			if(faturamentoSimulacaoComando == null){

				consumoHistoricoAgua = getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipoAgua,
								anoMesReferencia.intValue());

			// Verifica se existe consumo histórico de água
			if(consumoHistoricoAgua != null){
				if((imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.FATURAMENTO_ATIVO
								.intValue())
								|| (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.NAO_FATURAVEL
												.intValue() && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null && consumoHistoricoAgua
												.getNumeroConsumoFaturadoMes().intValue() > 0)){
					indicadorFaturamentoAgua = Short.valueOf("1");

						// Caso exista indicador de faturamento no consumo histórico, será assumido
						// o do consumo histórico.
					if(consumoHistoricoAgua.getIndicadorFaturamento() != null){

						indicadorFaturamentoAgua = consumoHistoricoAgua.getIndicadorFaturamento();
					}
					consumoFaturadoMesAgua = consumoHistoricoAgua.getNumeroConsumoFaturadoMes();
					}
				}

				// Obtém o consumo histórico de esgoto do imóvel para o ano mês de referência
				consumoHistoricoEsgoto = getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel,
								ligacaoTipoEsgoto, anoMesReferencia.intValue());
			}else{

				Object[] dadosConsumoHistoricoAnteriorAgua = repositorioMicromedicao.obterConsumoHistoricoAnterior(imovel.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_AGUA);

				if(!Util.isVazioOrNulo(dadosConsumoHistoricoAnteriorAgua)){

					consumoHistoricoAgua = (ConsumoHistorico) getControladorUtil().pesquisar(
									Util.obterInteger(dadosConsumoHistoricoAnteriorAgua[0].toString()), ConsumoHistorico.class, false);
				}

				// Consumo faturado de água do mês
				if(faturamentoSimulacaoComando.getCodigoTipoConsumoAgua().equals(FaturamentoSimulacaoComando.CONSUMO_ANTERIOR)){

					// Caso o tipo de consumo selecionado tenha sido Consumo anterior
					if(consumoHistoricoAgua != null
									&& imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
													.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

						if(dadosConsumoHistoricoAnteriorAgua[1] != null){

							// Utilizar o consumo faturado no mês anterior ao mês de referência
							consumoFaturadoMesAgua = Util.obterInteger(dadosConsumoHistoricoAnteriorAgua[1].toString());
						}
					}
				}else if(faturamentoSimulacaoComando.getCodigoTipoConsumoAgua().equals(FaturamentoSimulacaoComando.CONSUMO_MEDIO)){

					// Caso o tipo de consumo selecionado tenha sido Consumo médio
					if(consumoHistoricoAgua != null
									&& imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
													.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

						if(dadosConsumoHistoricoAnteriorAgua[2] != null){

							// Utilizar o consumo médio do mês anterior ao mês de referência
							consumoFaturadoMesAgua = Util.obterInteger(dadosConsumoHistoricoAnteriorAgua[2].toString());
						}
					}
				}else if(faturamentoSimulacaoComando.getCodigoTipoConsumoAgua().equals(FaturamentoSimulacaoComando.CONSUMO_MINIMO)){

					// Caso o tipo de consumo selecionado tenha sido Consumo mínimo
					if(consumoHistoricoAgua != null
									&& imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
													.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

						if(dadosConsumoHistoricoAnteriorAgua[3] != null){

							// Utilizar o consumo mínimo do mês anterior ao mês de referência
							consumoFaturadoMesAgua = Util.obterInteger(dadosConsumoHistoricoAnteriorAgua[3].toString());
						}
					}
				}

				Object[] dadosConsumoHistoricoAnteriorEsgoto = repositorioMicromedicao.obterConsumoHistoricoAnterior(imovel.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_ESGOTO);

				if(!Util.isVazioOrNulo(dadosConsumoHistoricoAnteriorEsgoto)){

					consumoHistoricoEsgoto = (ConsumoHistorico) getControladorUtil().pesquisar(
									Util.obterInteger(dadosConsumoHistoricoAnteriorEsgoto[0].toString()), ConsumoHistorico.class, false);
				}

				// Consumo faturado de esgoto do mês
				if(faturamentoSimulacaoComando.getCodigoTipoConsumoEsgoto().equals(FaturamentoSimulacaoComando.CONSUMO_ANTERIOR)){

					// Caso o tipo de consumo selecionado tenha sido Consumo anterior
					if(consumoHistoricoEsgoto != null
									&& imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao()
													.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)){

						if(dadosConsumoHistoricoAnteriorEsgoto[1] != null){

							// Utilizar o consumo faturado no mês anterior ao mês de referência
							consumoFaturadoMesEsgoto = Util.obterInteger(dadosConsumoHistoricoAnteriorEsgoto[1].toString());
						}
					}
				}else if(faturamentoSimulacaoComando.getCodigoTipoConsumoEsgoto().equals(FaturamentoSimulacaoComando.CONSUMO_MEDIO)){

					// Caso o tipo de consumo selecionado tenha sido Consumo médio
					if(consumoHistoricoEsgoto != null
									&& imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao()
													.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)){

						if(dadosConsumoHistoricoAnteriorEsgoto[2] != null){

							// Utilizar o consumo médio do mês anterior ao mês de referência
							consumoFaturadoMesEsgoto = Util.obterInteger(dadosConsumoHistoricoAnteriorEsgoto[2].toString());
						}
					}
				}else if(faturamentoSimulacaoComando.getCodigoTipoConsumoEsgoto().equals(FaturamentoSimulacaoComando.CONSUMO_MINIMO)){

					// Caso o tipo de consumo selecionado tenha sido Consumo mínimo
					if(consumoHistoricoEsgoto != null
									&& imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao()
													.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)){

						if(dadosConsumoHistoricoAnteriorEsgoto[3] != null){

							// Utilizar o consumo mínimo do mês anterior ao mês de referência
							consumoFaturadoMesEsgoto = Util.obterInteger(dadosConsumoHistoricoAnteriorEsgoto[3].toString());
						}
					}
				}
			}

			Integer consumoFixoPoco = null;

			if(consumoHistoricoEsgoto != null
							&& (imovel.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue() || imovel
											.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.TAMPONADO.intValue())){
				if(consumoHistoricoEsgoto.getIndicadorFaturamento() != null){
					// Seta o indicador faturamento esgoto
					indicadorFaturamentoEsgoto = consumoHistoricoEsgoto.getIndicadorFaturamento();
				}

				if(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null){
					consumoFaturadoMesEsgoto = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
				}

				if(consumoHistoricoEsgoto.getConsumoPoco() != null){

					consumoFixoPoco = consumoHistoricoEsgoto.getConsumoPoco();
				}
			}

			// Verifica se existe medição histórico
			medicaoHistoricoAgua = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(imovel.getId(), anoMesReferencia);
			if(medicaoHistoricoAgua != null){

				// Seta a data de letura anterior faturamento
				if(medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento() != null){
					dataLeituraAnteriorFaturamento = medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento();
				}

				// Seta a data de leitura atual faturamento
				if(medicaoHistoricoAgua.getDataLeituraAtualFaturamento() != null){
					dataLeituraAtualFaturamento = medicaoHistoricoAgua.getDataLeituraAtualFaturamento();
				}
			}

			// Caso o imóvel seja ligado de esgoto
			if(imovel.getLigacaoEsgoto() != null
							&& imovel.getLigacaoEsgotoSituacao() != null
							&& (imovel.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue() || imovel
											.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.TAMPONADO.intValue())){
				// consultar medicao hisotrico tipo poco
				medicaoHistoricoPoco = this.getControladorMicromedicao()
								.pesquisarMedicaoHistoricoTipoPoco(imovel.getId(), anoMesReferencia);

				// Verifica se existe medição histórico para poço
				if(medicaoHistoricoPoco != null){

					// Seta a data de leitura anterior faturamento
					if(medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento() != null){
						dataLeituraAnteriorFaturamento = medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento();
					}

					// Seta a data atual de faturamento
					if(medicaoHistoricoPoco.getDataLeituraAtualFaturamento() != null){
						dataLeituraAtualFaturamento = medicaoHistoricoPoco.getDataLeituraAtualFaturamento();
					}
				}
				// Recupera o percentual de esgoto.
				percentualEsgoto = this.obterPercentualLigacaoEsgotoImovel(imovel.getId());
			}

			// [UC0105] - Obter Consumo Mínimo da Ligação
			consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, colecaoCategorias);

			boolean usarTarifaComandoSimulacao = false;

			// Caso tenha sido informado um comando de simulação de faturamento e a tarifa do
			// comando tenha sido selecionada
			if(faturamentoSimulacaoComando != null && faturamentoSimulacaoComando.getConsumoTarifa() != null){

				// Utilizar esta tarifa do comando
				usarTarifaComandoSimulacao = true;
				consumoTarifaConta = faturamentoSimulacaoComando.getConsumoTarifa();

				// [UC0105] - Obter Consumo Mínimo da Ligação baseado na tarifa do comando de
				// simulação
				Imovel imovelAux = new Imovel();
				imovelAux.setConsumoTarifa(consumoTarifaConta);
				consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovelAux, colecaoCategorias);
			}

			if(!usarTarifaComandoSimulacao){

			// Tarifa para o imóvel (Caso exista tarifa temporária para o imóvel
			// (CSTF_IDTEMPORARIA com o valor diferente de nulo na tabela IMOVEL)
				// e a tarifa temporária esteja vigente (IMOV_DTVALIDADETARIFATEMP maior ou igual à
				// data
			// corrente), atribuir CSTF_IDTEMPORARIA;
			// Caso contrário, atribuir CSTF_ID da tabela IMOVEL).
			boolean possuiTarifaTemporariaValida = false;

				// Caso exista contrato de demanda de consumo vigente para o imóvel e tarifa de
				// consumo não esteja vazia
				// atribuir CSTF_ID da tabela CONTRATO_DEMANDA_CONSUMO
				ContratoDemandaConsumo contratoDemandaConsumo = this.pesquisarContratoDemandaConsumoVigenteComTarifa(imovel.getId(),
								sistemaParametro.getAnoMesFaturamento());

				if(contratoDemandaConsumo != null){

					consumoTarifaConta = contratoDemandaConsumo.getConsumoTarifa();

				}else if(imovel.getConsumoTarifaTemporaria() != null && imovel.getDataValidadeTarifaTemporaria() != null
							&& Util.compararData(imovel.getDataValidadeTarifaTemporaria(), new Date()) >= 0){

				consumoTarifaConta = imovel.getConsumoTarifaTemporaria();
				possuiTarifaTemporariaValida = true;
				log.info("Imovel[" + imovel.getId() + "] possue tarifa [" + imovel.getConsumoTarifaTemporaria().getId().toString()
								+ "] temporária válida.");

				log.info("Avaliar perda de benefícios");
				// [FS0011] E [FS0014]
				consumoTarifaConta = verificarPerdaBeneficioDaTarifaSocialParaFaturamento(consumoFaturadoMesAgua, consumoMinimoLigacao,
								imovel);
				consumoTarifaConta = verificarPerdaBeneficioDaTarifaParaPequenoNegocio(imovel, consumoFaturadoMesAgua);
			}else{

				// Obtém a tarifa do imóvel
				consumoTarifaConta = imovel.getConsumoTarifa();
				log.info("Imovel[" + imovel.getId() + "] tarifa padrão [" + imovel.getConsumoTarifa().getId().toString() + "].");
			}

				// Caso o imóvel esteja incluso no programa água para todos(iapt_id diferente de
				// Null)
			if(imovel.getImovelAguaParaTodos() != null){

				// [SB0011] - Verificar Exclusão do Programa Água para Todos
					if(this.verificarExclusaoImoveldoProgramaAguaParaTodos(imovel, sistemaParametro) && faturamentoSimulacaoComando == null){
					this.excluirImoveldoProgramaAguaParaTodos(imovel, sistemaParametro);
				}

				// Caso o imóvel esteja incluso no programa água para todos e o consumo seja
					// maior que [PARÂMETRO – PARM_NNCONSUMOMINIMOAPT], assumir a tarifa padrão do
				// imóvel para faturamento desconsiderando a atual
				if(sistemaParametro.getNumeroConsumoMinAguaParaTodos() != null
								&& consumoFaturadoMesAgua > sistemaParametro.getNumeroConsumoMinAguaParaTodos()){

					consumoTarifaConta = imovel.getConsumoTarifa();

						if(isNumeroConsumoConsecutivoMaiorQueMinimo(imovel, ligacaoTipoAgua, anoMesReferencia.intValue(), sistemaParametro)
										&& faturamentoSimulacaoComando == null){
						this.excluirImoveldoProgramaAguaParaTodos(imovel, sistemaParametro);
					}
				}
			}

			// Caso tenha o imóvel tenha tarifa temporária válida e ela tenha sido perdida por
			// alguma regra anterior
			if(possuiTarifaTemporariaValida && !consumoTarifaConta.getId().equals(imovel.getConsumoTarifaTemporaria().getId())){

				// [UC0105] - Obter Consumo Mínimo da Ligação baseado na tarifa padrão do imóvel
				Imovel imovelAux = new Imovel();
				imovelAux.setConsumoTarifa(imovel.getConsumoTarifa());
				consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovelAux, colecaoCategorias);
			}

			// ############# Alterado por Luciano - OC1034808 ############# - Fim

			// 2.3. Caso seja para verificar permanência do imóvel na tarifa social
				// [UC3058 – Verificar Permanência Tarifa Social].
			String parametroValidaPermanenciaTarifaSocial = ParametroCadastro.P_VALIDA_PERMANENCIA_TARIFA_SOCIAL.executar();

				if(!Util.isVazioOuBranco(parametroValidaPermanenciaTarifaSocial) && faturamentoSimulacaoComando == null){

				this.getControladorTarifaSocial().verificarPermanenciaTarifaSocial(imovel.getId(), Usuario.USUARIO_BATCH);
			}
			}

			// 2.4. O sistema verifica a ocorrência de situação especial de faturamento
			// para o imóvel [SB0016 – Verificar Situação Especial de Faturamento]
			// 1. Caso o imóvel possua situação especial de faturamento
			if(!Util.isVazioOuBranco(imovel.getFaturamentoSituacaoTipo())
							&& !Util.isVazioOuBranco(imovel.getFaturamentoSituacaoTipo().getId())){
				// 1.1. O sistema verifica as situações especiais de faturamento do imóvel
				Collection<FaturamentoSituacaoHistorico> colecaoSituacaoEspecialFaturamento = repositorioFaturamento
								.pesquisarFaturamentoSituacaoHistoricoImovel(imovel.getId(), anoMesReferencia);
				// 1.2. O sistema identifica o critério de faturamento configurado
				if(!Util.isVazioOrNulo(colecaoSituacaoEspecialFaturamento)){
					FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = (FaturamentoSituacaoHistorico) Util
									.retonarObjetoDeColecao(colecaoSituacaoEspecialFaturamento);
					if(!Util.isVazioOuBranco(faturamentoSituacaoHistorico)
									&& !Util.isVazioOuBranco(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo())){
						// 1.2.1. Percentual de esgoto informado(FTST_ICPERCENTUALESGOTO com o valor
						// 1 (um)),
						// atribuir o percentual de esgoto acordado para ser faturado
						// ao percentual de esgoto.
						if(!Util.isVazioOuBranco(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo().getIndicadorPercentualEsgoto())
										&& faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo().getIndicadorPercentualEsgoto()
														.intValue() == 1){
							if(!Util.isVazioOuBranco(faturamentoSituacaoHistorico.getPercentualEsgoto())){
								percentualEsgoto = faturamentoSituacaoHistorico.getPercentualEsgoto();
							}
						}
					}
				}
			}

			if(dataLeituraAnteriorFaturamento == null || dataLeituraAtualFaturamento == null){

				Date periodoLeitura[] = gerarPeriodoLeituraFaturamento(dataLeituraAtualFaturamento, dataLeituraAnteriorFaturamento,
								faturamentoAtivCronRota, Integer.valueOf(anoMesAnterior), anoMesReferencia);
				dataLeituraAnteriorFaturamento = periodoLeitura[0];
				dataLeituraAtualFaturamento = periodoLeitura[1];
			}

			Short pVerificarConsumoLigacaoCortada = Short.valueOf((String) ParametroFaturamento.P_VERIFICAR_CONSUMO_LIGACAO_CORTADA
							.executar());

			// Caso o imóvel seja (ligado) ou (cortado com ou sem consumo de água)
			if(ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.LIGADO)
							|| (ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.CORTADO) && (pVerificarConsumoLigacaoCortada
											.equals(ConstantesSistema.NAO) || (pVerificarConsumoLigacaoCortada
											.equals(ConstantesSistema.SIM)
											&& consumoHistoricoAgua != null
											&& consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null && consumoHistoricoAgua
											.getNumeroConsumoFaturadoMes().intValue() != 0)))){

				if(consumoHistoricoAgua != null && consumoHistoricoAgua.getIndicadorFaturamento() != null){
					indicadorFaturamentoAgua = consumoHistoricoAgua.getIndicadorFaturamento();
				}else{
					indicadorFaturamentoAgua = ConstantesSistema.NAO;
				}
			}else{
				indicadorFaturamentoAgua = ConstantesSistema.NAO;
			}

			// 1.5.1. Caso o imóvel seja ligado de esgoto:
			if(indicadorFaturamentoEsgoto != null && indicadorFaturamentoEsgoto.equals(ConstantesSistema.SIM)){

				Short pEsgotoSuprimido = Short.valueOf((String) ParametroFaturamento.P_ISENCAO_ESGOTO_SUPRIMIDO_CORTADO_SEM_CONSUMO
								.executar());

				// 1.5.1.1. Caso o parâmetro de isenção de esgoto para suprimido esteja ativado
				// (PASI_VLPARAMETRO = 1 na tabela PARAMETRO_SISTEMA para PASI_DSPARAMETRO = ”
				// P_ISENCAO_ESGOTO_SUPRIMIDO_CORTADO_SEM_CONSUMO”)
				if(pEsgotoSuprimido.equals(ConstantesSistema.SIM)){

					// 1.5.1.1.1. Caso o imóvel seja suprimido ou cortado (LAST_ID na tabela IMOVEL
					// com
					// o valor correspondente a SUPRIMIDO ou CORTADO) e sem consumo de água
					// (CSHI_NNCONSUMOFATURADOMES = 0 da tabela CONSUMO_HISTORICO com
					// IMOV_ID=IMOV_ID da tabela IMOVEL, LGTP_ID com o valor correspondente a
					// “ligação de água” e
					// CSHI_AMFATURAMENTO=Ano e mês de referência), atribuir o valor dois (2).

					// Boolean imovelSuprimidoCortado =
					// (ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.SUPRIMIDO) ||
					// ligacaoAguaSituacaoId
					// .equals(LigacaoAguaSituacao.CORTADO));
					// Boolean imovelSemConsumoAgua = (consumoFaturadoMesAgua.intValue() == 0);

					boolean imovelSuprimidoSemConsumo = ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.SUPRIMIDO)
									&& consumoFaturadoMesAgua.intValue() == 0;

					// Imóvel cortardo sem consumo e com o parâmetro de verificar consumo ativo
					boolean imovelCortadoSemConsumoComVerificacao = ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.CORTADO)
									&& pVerificarConsumoLigacaoCortada.equals(ConstantesSistema.SIM)
									&& consumoFaturadoMesAgua.intValue() == 0;

					if(imovelSuprimidoSemConsumo || imovelCortadoSemConsumoComVerificacao){

						indicadorFaturamentoEsgoto = ConstantesSistema.NAO;

					}else{

						// 1.5.1.1.2. Caso contrário, atribuir CSHI_ICFATURAMENTO da tabela
						// CONSUMO_HISTORICO com IMOV_ID=IMOV_ID da tabela IMOVEL, LGTP_ID com o
						// valor correspondente a “ligação de esgoto” e CSHI_AMFATURAMENTO=Ano e mês
						// de referência.

						if(consumoHistoricoEsgoto != null && consumoHistoricoEsgoto.getIndicadorFaturamento() != null){

							indicadorFaturamentoEsgoto = consumoHistoricoEsgoto.getIndicadorFaturamento();
							consumoHistoricoEsgoto.setReferenciaFaturamento(anoMesFaturamento);

						}

					}

				}else{

					// 1.5.1.2. Caso contrário, ou seja, caso o parâmetro de isenção de esgoto para
					// suprimido
					// esteja desativado (PASI_VLPARAMETRO = 2 na tabela PARAMETRO_SISTEMA para
					// PASI_DSPARAMETRO = ” P_ISENCAO_ESGOTO_SUPRIMIDO_CORTADO_SEM_CONSUMO”),
					// atribuir CSHI_ICFATURAMENTO da tabela CONSUMO_HISTORICO com IMOV_ID=IMOV_ID
					// da tabela IMOVEL, LGTP_ID com o valor correspondente a “ligação de esgoto” e
					// CSHI_AMFATURAMENTO=Ano e mês de referência,

					if(consumoHistoricoEsgoto != null){

						indicadorFaturamentoEsgoto = consumoHistoricoEsgoto.getIndicadorFaturamento();
						consumoHistoricoEsgoto.setReferenciaFaturamento(anoMesFaturamento);

					}

				}
				
				if(!ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.LIGADO)
								&& (!ligacaoAguaSituacaoId.equals(LigacaoAguaSituacao.CORTADO))){
					
					indicadorFaturamentoEsgoto = ConstantesSistema.NAO;
				}

			}else{

				// 2.5.2. Caso contrário, ou seja, caso o imóvel não seja ligado de esgoto, atribuir
				// o
				// valor um (2).
				indicadorFaturamentoEsgoto = ConstantesSistema.NAO;

			}

			// [UC0120] - Calcular Valores de Água e/ou Esgoto
			colecaoCalcularValoresAguaEsgotoHelper = calcularValoresAguaEsgoto(anoMesReferencia, ligacaoAguaSituacaoId,
							ligacaoEsgotoSituacaoId, indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategorias,
							consumoFaturadoMesAgua, consumoFaturadoMesEsgoto, consumoMinimoLigacao, dataLeituraAnteriorFaturamento,
							dataLeituraAtualFaturamento, percentualEsgoto, consumoTarifaConta.getId(), imovel.getId(), null);

			for(Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper.iterator(); iteratorColecaoCalcularValoresAguaEsgotoHelper
							.hasNext();){

				CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
								.next();
				/*
				 * Caso tenha valor de água faturado para categoria adiciona o valor de água ao
				 * valor total de água. Caso contrário soma zero.
				 */
				if(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria() != null){
					valorTotalAgua = valorTotalAgua.add(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria());
				}else{
					valorTotalAgua = valorTotalAgua.add(new BigDecimal("0.00"));
				}

				if(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria() != null){
					valorTotalEsgoto = valorTotalEsgoto.add(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria());
				}else{
					valorTotalEsgoto = valorTotalEsgoto.add(new BigDecimal("0.00"));
				}
			}
			// ---------------------------------------------------------------------------------
			// [SB0002] - Determinar Valores para Faturamento de Água e/ou Esgoto - Fim
			// ---------------------------------------------------------------------------------

			String pAcumulaConsumoEsgotoPoco = null;

			try{

				pAcumulaConsumoEsgotoPoco = ((String) ParametroMicromedicao.P_ACUMULA_CONSUMO_ESGOTO_POCO.executar(this));

			}catch(ControladorException e){

				throw new ActionServletException("atencao.sistemaparametro_inexistente", "P_ACUMULA_CONSUMO_ESGOTO_POCO");
			}

			// Caso a empresa calcule o valor de esgoto de poço em separado
			if(pAcumulaConsumoEsgotoPoco.equals(ConstantesSistema.NAO.toString()) && consumoFixoPoco != null){


				Collection colecaoCalcularValoresAguaEsgotoHelperPoco = calcularValoresAguaEsgoto(anoMesReferencia, ligacaoAguaSituacaoId,
								ligacaoEsgotoSituacaoId, ConstantesSistema.NAO, ConstantesSistema.SIM, colecaoCategorias, 0,
								consumoFixoPoco, consumoMinimoLigacao, dataLeituraAnteriorFaturamento, dataLeituraAtualFaturamento,
								percentualEsgoto, consumoTarifaConta.getId(), imovel.getId(), null);

				BigDecimal valorDebitoPoco = BigDecimal.ZERO;
				
				if (!Util.isVazioOrNulo(colecaoCalcularValoresAguaEsgotoHelperPoco)){
					
					for(Iterator iteratorValores = colecaoCalcularValoresAguaEsgotoHelperPoco.iterator(); iteratorValores.hasNext();){
						
						CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelperPoco = (CalcularValoresAguaEsgotoHelper) iteratorValores
										.next();
						
						if (calcularValoresAguaEsgotoHelperPoco.getValorFaturadoEsgotoCategoria() != null){
							
							valorDebitoPoco = valorDebitoPoco.add(calcularValoresAguaEsgotoHelperPoco.getValorFaturadoEsgotoCategoria());
						}
					}
				}

				if (valorDebitoPoco.compareTo(BigDecimal.ZERO) == 1){
					
					// O sistema gera o valor relativo à tarifa especial de esgoto (TEE) como um
					// débito
					// a cobrar para o tipo de débito esgoto especial
					// e ano/mês de faturamento atual. <<Inclui>>[UC0183] Inserir Débito A Cobrar]
					DebitoACobrar debitoACobrar = null;
					DebitoTipo debitoTipo = (DebitoTipo) getControladorUtil().pesquisar(DebitoTipo.ESGOTO_ESPECIAL, DebitoTipo.class, true);
					CobrancaForma cobrancaForma = new CobrancaForma();
					cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

					Collection<OperacaoContabilHelper> collHelper = new ArrayList<OperacaoContabilHelper>();

					debitoACobrar = new DebitoACobrar();
					debitoACobrar.setDebitoTipo(debitoTipo);
					debitoACobrar.setValorDebito(valorDebitoPoco);
					debitoACobrar.setImovel(imovel);
					debitoACobrar.setGeracaoDebito(new Date());
					debitoACobrar.setLocalidade(imovel.getLocalidade());
					debitoACobrar.setQuadra(imovel.getQuadra());
					debitoACobrar.setAnoMesReferenciaDebito(anoMesFaturamento);
					debitoACobrar.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());
					debitoACobrar.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
					debitoACobrar.setCobrancaForma(cobrancaForma);
					debitoACobrar.setUltimaAlteracao(new Date());
					debitoACobrar.setAnoMesCobrancaDebito(anoMesFaturamento);

					OperacaoContabilHelper helper = new OperacaoContabilHelper();

					helper.setObjetoOrigem(this.inserirDebitoACobrarSemRegistrarLancamentoContabil(1, debitoACobrar, null, imovel, null,
									null, Usuario.USUARIO_BATCH, false, null, null, null));
					helper.setOperacaoContabil(OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);

					collHelper.add(helper);

					this.getControladorContabil().registrarLancamentoContabil(collHelper);
				}
			}
		}

		// [SB0003] - Verificar Não Geração da Conta
		boolean gerarConta = this.verificarNaoGeracaoConta(imovel, valorTotalAgua, valorTotalEsgoto, anoMesFaturamento);

		if(faturamentoSimulacaoComando == null && (gerarConta == false || idContaAnoMesReferencia != null)){

			// 1. Caso o imóvel não tenha sido selecionado para o faturamento
			// ou já possua conta gerada para a referência.
			// 1.1.1. O sistema cancela o débito a cobrar correspondente à taxa
			// de entrega de conta em outro endereço - <<Inclui>> [UC0184 -
			// Manter Débito A Cobrar] e registra a transação de cancelar débito
			// a cobrar <<Inclui>> [UC0107 – Registrar Transação].

			String[] idsDebitoACobrar = repositorioFaturamento.pesquisarDebitoACobrarPorDebitoTipo(imovel.getId(),
							DebitoTipo.DESPESA_POSTAL, anoMesReferencia);

			if(idsDebitoACobrar != null){
				this.cancelarDebitoACobrar(idsDebitoACobrar, Usuario.USUARIO_BATCH, imovel.getId(), Boolean.FALSE);
			}

		}

		/*
		 * Caso gere conta.
		 */
		// Collection<ObjetoTransacao> colecaoContasContabilizar = new ArrayList<ObjetoTransacao>();
		if(gerarConta){

			Object[] retornoArrasto = null;
			BigDecimal valorTotalDebitosArrasto = BigDecimal.ZERO;
			Map<DebitoCobrado, Collection> mapDebitosCobradosArrasto = null;

			// Caso seja uma atividade de "faturar grupo" (No caso da atividade de simulação não
			// totaliza os débitos de arrasto)
			if(faturamentoSimulacaoComando == null){

				// [UC3042] – Realizar Arrasto de Parcelamento
				Integer idImovel = imovel.getId();

				retornoArrasto = this.getControladorCobranca().realizarArrastoDeParcelamento(idImovel);
				valorTotalDebitosArrasto = (BigDecimal) retornoArrasto[0];
				mapDebitosCobradosArrasto = (Map<DebitoCobrado, Collection>) retornoArrasto[1];
				boolean indicadorArrasto = (Boolean) retornoArrasto[2];

				if(indicadorArrasto){

					System.out.println("Imovel = " + idImovel + " Arrasto = " + valorTotalDebitosArrasto);
					colecaoOcorrenciaGeracaoPreFaturamento.add(imovel);
				}
			}

			// ---------------------------------------------------------------------------------
			// [SB0004] - Gerar Débitos Cobrados - Início
			// ---------------------------------------------------------------------------------

			BigDecimal valorTotalDebitos = new BigDecimal("0.00");
			List colecaoDebitosACobrarUpdate = new ArrayList();
			// Cria o map para armazenar os débitos a cobrar junto com os débitos a cobrar por
			// categoria.
			Map<DebitoCobrado, Collection> mapDebitosCobrados = null;

			Object[] retornoDebitosCobrados = this.gerarDebitosCobrados(imovel, anoMesFaturamento, faturamentoSimulacaoComando);
			valorTotalDebitos = (BigDecimal) retornoDebitosCobrados[0];
			colecaoDebitosACobrarUpdate = (List) retornoDebitosCobrados[1];

			if(retornoDebitosCobrados[2] != null){

			mapDebitosCobrados = (Map<DebitoCobrado, Collection>) retornoDebitosCobrados[2];
			}

			valorTotalDebitos = valorTotalDebitos.add(valorTotalDebitosArrasto);

			if(mapDebitosCobrados != null && !mapDebitosCobrados.isEmpty()){
				if(mapDebitosCobradosArrasto != null && !mapDebitosCobradosArrasto.isEmpty()){
					Iterator iteratorColecaoDebitosCobrados = mapDebitosCobradosArrasto.keySet().iterator();

					DebitoCobrado debitoCobrado = null;
					Collection colecaoDebitoCobradoCategoriaDebitoCobrado = null;

					while(iteratorColecaoDebitosCobrados.hasNext()){
						debitoCobrado = (DebitoCobrado) iteratorColecaoDebitosCobrados.next();
						colecaoDebitoCobradoCategoriaDebitoCobrado = mapDebitosCobradosArrasto.get(debitoCobrado);

						mapDebitosCobrados.put(debitoCobrado, colecaoDebitoCobradoCategoriaDebitoCobrado);
					}
				}
			}else{
				mapDebitosCobrados = mapDebitosCobradosArrasto;
			}

			// ---------------------------------------------------------------------------------
			// [SB0004] - Gerar Débitos Cobrados - Fim
			// ---------------------------------------------------------------------------------

			// Não deve ser gerada uma conta com os valores de água, esgoto e débito zero
			// Essa situação pode ocorrer devido a campanha de parcelamento, quando o número de
			// meses entre parcelas é maior que 1
			if(valorTotalAgua.compareTo(BigDecimal.ZERO) == 1 || valorTotalEsgoto.compareTo(BigDecimal.ZERO) == 1
							|| valorTotalDebitos.compareTo(BigDecimal.ZERO) == 1){

				// ---------------------------------------------------------------------------------
				// [SB0005] - Gerar Creditos Realizados - Início
				// ---------------------------------------------------------------------------------
				BigDecimal valorTotalCreditos = new BigDecimal("0.00");
				Collection colecaoCreditosARealizarUpdate = new ArrayList();
				// Cria o map para armazenar os créditos realizados junto com os créditos ralizados
				// por
				// categoria
				Map<CreditoRealizado, Collection> mapCreditoRealizado = null;

				Object[] retornoCreditosRealizados = this.gerarCreditosRealizadosFaturamentoConvencional(imovel, anoMesFaturamento,
								valorTotalAgua, valorTotalEsgoto, valorTotalDebitos, faturamentoSimulacaoComando, indicadorFaturamentoAgua,
								indicadorFaturamentoEsgoto, colecaoCategorias, consumoMinimoLigacao, dataLeituraAnteriorFaturamento,
								dataLeituraAtualFaturamento, percentualEsgoto, consumoTarifaConta.getId());
				valorTotalCreditos = (BigDecimal) retornoCreditosRealizados[0];
				colecaoCreditosARealizarUpdate = (Collection) retornoCreditosRealizados[1];

				if(retornoCreditosRealizados[2] != null){

				mapCreditoRealizado = (Map<CreditoRealizado, Collection>) retornoCreditosRealizados[2];
				}

				// ---------------------------------------------------------------------------------
				// [SB0005] - Gerar Creditos Realizados - Fim
				// ---------------------------------------------------------------------------------

				if(faturamentoSimulacaoComando == null){

					// ---------------------------------------------------------------------------------
					// [SB0006] - Gerar Dados da Conta - Início
					// ---------------------------------------------------------------------------------

					Conta conta = this.gerarDadosConta(imovel, anoMesReferencia, true, antecipado, faturamentoAtivCronRota,
									sistemaParametro, valorTotalAgua, valorTotalEsgoto, valorTotalDebitos, valorTotalCreditos,
									percentualEsgoto, consumoTarifaConta, colecaoCategorias);

					ContaImpressao contaImpressao = this.gerarDadosContaImpressao(imovel, conta, anoMesFaturamento, faturamentoGrupo,
									faturamentoAtivCronRota.getRota());

					contaImpressao.setIndicadorImpressao(ConstantesSistema.NAO);

					// inserir conta impressao
					getControladorUtil().inserir(contaImpressao);

					// Caso a anormalidade de consumo seja estouro de consumo ou estouro acumulado
					// acima
					// do teto
					// (CSAN_ID da tabela CONSUMO_ANORMALIDADE com CSAN_CDCONSTANTE com valor
					// correspondente a ‘ESTOURO_CONSUMO’ ou ‘ESTOURO_ACUM_ACIMA_TETO’),
					// atribuir valor do parâmetro (PASI_VLPARAMETRO na tabela PARAMETRO_SISTEMA
					// para
					// PASI_DSPARAMETRO = ‘P_MOTIVO_RETENCAO_CONTA_ESTOURO_CONSUMO’)
					// se diferente de nulo ou zero;

					if(consumoHistoricoAgua != null && consumoHistoricoAgua.getConsumoAnormalidade() != null){

						Integer idConAnormalidade = consumoHistoricoAgua.getConsumoAnormalidade().getId();

						if(idConAnormalidade.equals(ConsumoAnormalidade.ESTOURO_CONSUMO)
										|| idConAnormalidade.equals(ConsumoAnormalidade.ESTOURO_ACUM_ACIMA_TETO)){

							String valorParametro = ParametroFaturamento.P_MOTIVO_RETENCAO_CONTA_FATUR_CONV.executar();

							if(valorParametro != null && !valorParametro.equals("0")){

								conta.setDataRevisao(new Date());
								conta.setContaMotivoRevisao((ContaMotivoRevisao) getControladorUtil().pesquisar(
												Integer.valueOf(valorParametro), ContaMotivoRevisao.class, false));

							}
						}
					}
					
					String pModeloArquivoLeitura = null;

					try{

						pModeloArquivoLeitura = ((String) ParametroMicromedicao.P_MODELO_ARQUIVO_LEITURA.executar(this));

					}catch(ControladorException e){

						throw new ActionServletException("atencao.sistemaparametro_inexistente", "P_MODELO_ARQUIVO_LEITURA");
					}
					
					// Caso o modelo de geração de dados indique emissão junto com a leitura do mês
					// posterior (P_MODELO_ARQUIVO_LEITURA=2)
					if(pModeloArquivoLeitura.equals(ConstantesSistema.DOIS.toString())){
						
						// Atribuir o motivo de revisão que indica a conta como em processo de
						// emissão
						conta.setDataRevisao(new Date());
						conta.setContaMotivoRevisao((ContaMotivoRevisao) getControladorUtil().pesquisar(
										ContaMotivoRevisao.FATURA_EM_PROCESSO_EMISSAO, ContaMotivoRevisao.class, false));
					}

					// caso o grupo de faturamento em questão(FTGR_ID) conste em
					// FATURAMENTO_GRUPO_REVISAO para a referência de faturamento
					// (CNTA_AMREFERENCIACONTA) entre a referencia FGRV_AMREFERENCIAFATURINICIAL e a
					// referencia FGRV_AMREFERENCIAFATURFINAL,
					// atribuir o motivo de revisão indicado em CMRV_ID de
					// FATURAMENTO_GRUPO_REVISAO;
					// caso contrário Nulo.

					if(faturamentoGrupo != null && conta.getReferenciaContabil() != null){

						Collection collMotivosRevisaoFaturGrupo = this.repositorioFaturamento.pesquisarContasMotivoRevisaoGrupoFaturamento(
										faturamentoGrupo.getId(), conta.getReferenciaContabil());

						FaturamentoGrupoRevisao faturamentoGrupoRevisao = (FaturamentoGrupoRevisao) Util
										.retonarObjetoDeColecao(collMotivosRevisaoFaturGrupo);

						if(faturamentoGrupoRevisao != null && faturamentoGrupoRevisao.getContaMotivoRevisao() != null){

							conta.setContaMotivoRevisao((ContaMotivoRevisao) getControladorUtil().pesquisar(
											faturamentoGrupoRevisao.getContaMotivoRevisao().getId(), ContaMotivoRevisao.class, false));
						}

					}

					// inserir a conta
					this.getControladorUtil().inserir(conta);
					log.info("Conta Inserida: cnta_id[" + conta.getId().toString() + "]");

					Object[] retornoDadosContaCategoriaEContaCategoriaConsumoFaixa = this
									.gerarDadosContaCategoriaEContaCategoriaConsumoFaixa(colecaoCategorias,
													colecaoCalcularValoresAguaEsgotoHelper, conta);
					Collection colecaoContaCategoria = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixa[0];
					Collection colecaoContaCategoriaConsumoFaixa = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixa[1];

					// [SF0006] 2.
					// incluir a conta categoria
					if(colecaoContaCategoria != null && !colecaoContaCategoria.isEmpty()){
						this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoria);

						// Incluir a colecao de categorias no objeto conta, que será utilizado na
						// Contabilização
						conta.setContaCategorias(new HashSet());
						for(Iterator iterator = colecaoContaCategoria.iterator(); iterator.hasNext();){
							ContaCategoria categoriaConta = (ContaCategoria) iterator.next();
							conta.getContaCategorias().add(categoriaConta);
						}

						colecaoContaCategoria.clear();
						colecaoContaCategoria = null;
					}

					// [SF0006] 3.
					// incluir as conta categoria consumo faixa
					if(colecaoContaCategoriaConsumoFaixa != null && !colecaoContaCategoriaConsumoFaixa.isEmpty()){
						this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoriaConsumoFaixa);

						colecaoContaCategoriaConsumoFaixa.clear();
						colecaoContaCategoriaConsumoFaixa = null;
					}

					// [SB0006] Item 6
					// incluir os clientes imovel em ClienteConta
					this.inserirClienteConta(conta, imovel, null);

					// [SF0006] Item 7
					// Incluir conta impostos deduzidos
					// [UC0351]-Gerar Impostos Deduzidos da Conta
					GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper = this.gerarImpostosDeduzidosConta(imovel.getId(),
									anoMesReferencia, conta.getValorAgua(), conta.getValorEsgoto(), valorTotalDebitos, valorTotalCreditos);

					this.inserirContaImpostosDeduzidos(conta, gerarImpostosDeduzidosContaHelper);

					// Gravar os Dados refernte ao ID da Conta inserir debito
					// cobrado
					this.inserirDebitoCobrado(mapDebitosCobrados, conta);

					// atualizar debito a cobrar
					this.atualizarDebitoACobrarFaturamento(colecaoDebitosACobrarUpdate);

					// inserir credito realizado
					this.inserirCreditoRealizado(mapCreditoRealizado, conta);

					// atualizar credito a realizar
					this.atualizarCreditoARealizar(colecaoCreditosARealizarUpdate);

					String motivoRevisaoPermiteGerarMovimentoDebitoAutomatico = (String) ParametroFaturamento.P_MOTIVO_REVISAO_PERMITE_GERAR_MOV_DEBITO_AUTOMATICO
									.executar();

					/*
					 * Caso no imóvel esteja indicado que o pagamento será efetuado mediante débito
					 * em
					 * conta
					 * corrente, e a conta não esteja em revisão, ou o motivo da revisão permita
					 * gerar
					 * movimento de débito automático
					 */
					if((imovel.getIndicadorDebitoConta().equals(ConstantesSistema.SIM))
									&& (conta.getContaMotivoRevisao() == null || (motivoRevisaoPermiteGerarMovimentoDebitoAutomatico != null && motivoRevisaoPermiteGerarMovimentoDebitoAutomatico
													.contains(conta.getContaMotivoRevisao().getId().toString())))){

						DebitoAutomaticoMovimentoCancelamentoMotivo debitoAutomaticoMovimentoMotivoCancelamento = null;

						if(conta.getContaMotivoRevisao() != null
										&& conta.getContaMotivoRevisao().getId() != null
										&& motivoRevisaoPermiteGerarMovimentoDebitoAutomatico != null
										&& motivoRevisaoPermiteGerarMovimentoDebitoAutomatico.contains(conta.getContaMotivoRevisao()
														.getId().toString())){
							debitoAutomaticoMovimentoMotivoCancelamento = new DebitoAutomaticoMovimentoCancelamentoMotivo();
							debitoAutomaticoMovimentoMotivoCancelamento
											.setId(DebitoAutomaticoMovimentoCancelamentoMotivo.INCLUSAO_CONTA_REVISAO);
						}

						// [SF0008] - Gerar Movimento De Débito Automático
						this.gerarMovimentoDebitoAutomatico(imovel, conta, conta.getValorTotalContaBigDecimal(), faturamentoAtivCronRota,
										null, debitoAutomaticoMovimentoMotivoCancelamento);
					}

					// [SF0006] Item 9
					// Caso o imóvel esteja incluso no programa água para todos gerar
					// histórico de faturamento
					if(imovel.getImovelAguaParaTodos() != null){

						FaturamentoHistoricoAguaParaTodos faturamentoHistoricoAguaParaTodos = new FaturamentoHistoricoAguaParaTodos();

						faturamentoHistoricoAguaParaTodos.setDataHabilitacao(imovel.getImovelAguaParaTodos().getDataHabilitacao());
						faturamentoHistoricoAguaParaTodos.setAnoMesReferencia(conta.getReferencia());
						faturamentoHistoricoAguaParaTodos.setTarifa(conta.getConsumoTarifa().getId());

						BigDecimal consumoAgua = new BigDecimal(conta.getConsumoAgua());
						faturamentoHistoricoAguaParaTodos.setConsumoMes(consumoAgua);

						BigDecimal valorAguaEsgotoDebitos = conta.getValorAgua().add(conta.getValorEsgoto().add(conta.getDebitos()));
						valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(conta.getValorCreditos());
						valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(conta.getValorImposto());

						faturamentoHistoricoAguaParaTodos.setValorConsumo(valorAguaEsgotoDebitos);
					}

					// ---------------------------------------------------------------------------------
					// [SB0006] - Gerar Dados da Conta - Fim
					// ---------------------------------------------------------------------------------

					contaGerada = conta;
				}

				// [SF0001] - Determinar Faturamento para o Imóvel
				// 6.2. Gerar resumo de ligações e economias.
				// [UC0275 – Gerar Resumo das Ligações/Economias]
				// this.getControladorMicromedicao().gerarResumoLigacoesEconomias(imovel.getId());

				// ---------------------------------------------------------------------------------
				// [SB0009] - Gerar Resumo da Simulação do Faturamento - Início
				// ---------------------------------------------------------------------------------
				this.gerarResumoSimulacaoFaturamento(colecaoCategorias, valorTotalDebitos, valorTotalCreditos,
								colecaoCalcularValoresAguaEsgotoHelper, colecaoResumoFaturamento, faturamentoAtivCronRota, imovel,
								anoMesReferencia, faturamentoSimulacaoComando, faturamentoGrupo);
				// ---------------------------------------------------------------------------------
				// [SB0009] - Gerar Resumo da Simulação do Faturamento - Fim
				// ---------------------------------------------------------------------------------
			} // fim do gerar conta
		}

		return contaGerada;
	}


	/**
	 * [UC3037] Filtrar Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 10/02/2012
	 *          Exibir Contas Pré-Faturadas.
	 */
	public Collection pesquisarContasPreFaturadas(FaturaContasPreFaturadasHelper faturaContasPreFaturadasHelper, Integer pageOffset,
					boolean indicadorRelatorio) throws ControladorException{

		Collection<Conta> retornoColecaoConta = new ArrayList<Conta>();
		Collection<Object[]> consulta = null;
		try{

			consulta = this.repositorioFaturamento.pesquisarContasPreFaturadas(faturaContasPreFaturadasHelper, pageOffset,
							indicadorRelatorio);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		if(!Util.isVazioOrNulo(consulta)){

			for(Object[] colunaArrayConta : consulta){

				Conta conta = new Conta();
				conta.setRota(new Rota());
				conta.getRota().setFaturamentoGrupo(new FaturamentoGrupo());
				conta.setImovel(new Imovel());
				conta.getImovel().setSetorComercial(new SetorComercial());
				conta.getImovel().setQuadra(new Quadra());
				conta.setLocalidade(new Localidade());
				conta.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao());
				conta.setLigacaoAguaSituacao(new LigacaoAguaSituacao());
				conta.setLigacaoEsgotoSituacao(new LigacaoEsgotoSituacao());
				conta.setImovelPerfil(new ImovelPerfil());
				conta.setConsumoTarifa(new ConsumoTarifa());

				int i = 0;
				// 00 - conta.id
				conta.setId((Integer) colunaArrayConta[i++]);
				// 01 - conta.referencia
				conta.setReferencia(((Integer) colunaArrayConta[i++]).intValue());
				// 02 - conta.dataVencimentoConta
				conta.setDataVencimentoConta((Date) colunaArrayConta[i++]);
				// 03 - conta.codigoSetorComercial
				conta.setCodigoSetorComercial((Integer) colunaArrayConta[i++]);
				// 04 - conta.valorAgua
				conta.setValorAgua((BigDecimal) colunaArrayConta[i++]);
				// 05 - conta.valorEsgoto
				conta.setValorEsgoto((BigDecimal) colunaArrayConta[i++]);
				// 06 - conta.debitos
				conta.setDebitos((BigDecimal) colunaArrayConta[i++]);
				// 07 - conta.valorCreditos
				conta.setValorCreditos((BigDecimal) colunaArrayConta[i++]);
				// 08 - conta.valorImposto
				conta.setValorImposto((BigDecimal) colunaArrayConta[i++]);
				// 09 - imovel.id
				conta.getImovel().setId((Integer) colunaArrayConta[i++]);
				// 10 - loca.id
				conta.getLocalidade().setId((Integer) colunaArrayConta[i++]);
				conta.getImovel().setLocalidade(conta.getLocalidade());
				// 11 - dcsa.id
				conta.getDebitoCreditoSituacaoAtual().setId((Integer) colunaArrayConta[i++]);
				// 12 - dcsa.descricaoAbreviada
				conta.getDebitoCreditoSituacaoAtual().setDescricaoAbreviada((String) colunaArrayConta[i++]);
				// 13 - rota.id
				conta.getRota().setId((Integer) colunaArrayConta[i++]);
				// 14 - ftgr.id
				conta.getRota().getFaturamentoGrupo().setId((Integer) colunaArrayConta[i++]);
				// 15 - ftgr.descricaoAbreviada
				conta.getRota().getFaturamentoGrupo().setDescricaoAbreviada((String) colunaArrayConta[i++]);
				// 16 - ftgr.anoMesReferencia
				conta.getRota().getFaturamentoGrupo().setAnoMesReferencia((Integer) colunaArrayConta[i++]);
				// 17 - ftgr.descricao
				conta.getRota().getFaturamentoGrupo().setDescricao((String) colunaArrayConta[i++]);
				// 18 - conta.quadra
				conta.setQuadra((Integer) colunaArrayConta[i++]);
				conta.getImovel().getQuadra().setNumeroQuadra(conta.getQuadra());
				// 19 - conta.lote
				conta.setLote((Short) colunaArrayConta[i++]);
				conta.getImovel().setLote(conta.getLote());
				// 20 - conta.subLote
				conta.setSubLote((Short) colunaArrayConta[i++]);
				conta.getImovel().setSubLote(conta.getSubLote());
				// 21 - conta.ligacaoAguaSituacao.descricao
				conta.getLigacaoAguaSituacao().setDescricao((String) colunaArrayConta[i++]);
				// 22 - conta.ligacaoEsgotoSituacao.descricao
				conta.getLigacaoEsgotoSituacao().setDescricao((String) colunaArrayConta[i++]);
				// 23 - conta.imovelPerfl.descricao
				conta.getImovelPerfil().setDescricao((String) colunaArrayConta[i++]);
				// 24 - conta.dataVencimento
				conta.setDataVencimentoConta((Date) colunaArrayConta[i++]);
				// 25 - conta.consumoTarifa.descricao
				conta.getConsumoTarifa().setDescricao((String) colunaArrayConta[i++]);
				// 26 - conta.codigoSetorcomercial
				conta.setCodigoSetorComercial((Integer) colunaArrayConta[i++]);
				conta.getImovel().getSetorComercial().setCodigo(conta.getCodigoSetorComercial());
				// 27 - conta.refereciaContabil
				conta.setReferenciaContabil(((Integer) colunaArrayConta[i++]).intValue());

				retornoColecaoConta.add(conta);
			}
		}

		return retornoColecaoConta;
	}

	/**
	 * [UC3035] Concluir Faturamento Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 16/02/2012
	 */
	public Conta pesquisarContaPeloID(Integer idConta) throws ControladorException{

		Conta retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarContaPeloID(idConta);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Permite atualizar as contas Pré-Faturadas
	 * [UC3035] Concluir Faturamento Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 23/02/2012
	 */
	public void atualizarSituacaoConta(Conta conta, Usuario usuarioLogado) throws ControladorException{

		// 2.6. Atualizar Situação da Conta:
		Date dataCorrente = new Date();

		// 2.6.1. O sistema efetua a alteração
		// [FS0001 – Atualização realizada por outro usuário]
		Integer idConta = conta.getId();

		// Pesquisando o Conta na base
		FiltroConta filtroConta = new FiltroConta();
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, idConta));

		Collection<Conta> colecaoConta = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

		if(Util.isVazioOrNulo(colecaoConta)){
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		Conta contaNaBase = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

		if(contaNaBase.getUltimaAlteracao().after(conta.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.atualizacao_situacao_conta_pre_faturada", null, conta.getImovel().getId().toString(),
							Util.formatarMesAnoReferencia(conta.getReferencia()));
		}

		//
		// Efetuando as alteraçõs
		//

		// ------------ <REGISTRAR TRANSAÇÃO>----------------------------

		if(usuarioLogado != null){
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONTA_MENSAGEM_ATUALIZAR, conta.getImovel()
							.getId(), conta.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			registradorOperacao.registrarOperacao(conta);

			getControladorTransacao().registrarTransacao(conta);
		}
		// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

		// 2.6.1.1. Atualiza a tabela CONTA com os seguintes dados:
		// DCST_IDANTERIOR >> DCST_IDATUAL
		Integer situacaoAnterior = conta.getDebitoCreditoSituacaoAtual().getId();

		DebitoCreditoSituacao debitoCreditoSituacaoAnterior = new DebitoCreditoSituacao();
		debitoCreditoSituacaoAnterior.setId(situacaoAnterior);

		conta.setDebitoCreditoSituacaoAnterior(debitoCreditoSituacaoAnterior);

		// DCST_IDATUAL >> DCST_ID da tabela DEBITO_CREDITO_SITUACAO com o valor correspondente a
		// “NORMAL”
		conta.getDebitoCreditoSituacaoAtual().setId(DebitoCreditoSituacao.NORMAL);
		// CNTA_TMULTIMAALTERACAO >> Data/Hora corrente
		conta.setUltimaAlteracao(dataCorrente);

		conta.setDataEmissao(dataCorrente);

		// Atualizar
		getControladorUtil().atualizar(conta);
	}

	/**
	 * [UC3037] Filtrar Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 10/02/2012
	 *          Exibir Contas Pré-Faturadas.
	 */
	public Collection<Integer> pesquisarQuantidadeContasPreFaturadas(FaturaContasPreFaturadasHelper faturaContasPreFaturadasHelper)
					throws ControladorException{

		Collection<Integer> retorno = null;
		try{

			Short permiteFaturarContaPreFaturadaZero = new Short(ParametroFaturamento.P_PERMITE_PRE_FATURAR_CONTA_ZERADA.executar());
			retorno = this.repositorioFaturamento.pesquisarQuantidadeContasPreFaturadas(faturaContasPreFaturadasHelper,
							permiteFaturarContaPreFaturadaZero);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato
	 * 
	 * @author eduardo henrique
	 * @date 08/10/2008
	 * @author eduardo henrique
	 * @date 08/01/2009 Alteração no método para não realizar mais a paginação do hibernate na
	 *       consulta inicial, pois da forma como é realizada é
	 *       inadequada para o Cache do Oracle.
	 * @author Ailton Sousa
	 * @date 09/09/2011 Alteração do Método de acordo com as novas Regras que foram solicitadas pela
	 *       Deso.
	 * @param colecaoRotas
	 *            (Coleção de Rotas que tiveram Faturamento Imediato gerado)
	 * @param faturamentoGrupo
	 *            (Grupo de Faturamento a ser Faturado)
	 * @param anoMesReferencia
	 *            (Ano/Mês referente ao Faturamento)
	 *            TODO Contabilização por Evento, Histograma de Água e Esgoto, Faturamento
	 *            Antecipado
	 *            p/ Orgãos Públicos
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public void registrarFaturamentoImediatoGrupoFaturamento(Collection<Rota> colecaoRotas, FaturamentoGrupo faturamentoGrupo,
					Integer anoMesCorrente, Integer idFuncionalidadeIniciada, Integer atividade) throws ControladorException{

		int idUnidadeIniciada = 0;

		try{

			log.info("**********Início Registrar Imediato do Grupo/Referência: " + faturamentoGrupo.getId().toString() + "/"
							+ anoMesCorrente.toString());

			if(faturamentoGrupo == null || anoMesCorrente == null){

				throw new ControladorException("erro.parametros_obrigatorios_faturamento_nao_informados");
			}

			if(faturamentoGrupo.getId() == null){

				throw new ControladorException("erro.parametros_obrigatorios_faturamento_nao_informados");
			}

			if(idFuncionalidadeIniciada != null){

				idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada.intValue(),
								FaturamentoAtividade.REGISTRAR_FATURAMENTO_IMEDIATO, 0);
			}

			Object[] arrayMedicaoConsumoHistorico = null;

			SistemaParametro sistemaParametro = null;
			sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			Collection collOperacaoContabilHelper = null;
			ConsumoHistorico consumoHistoricoAguaImovelNaoMedido = null;
			ConsumoHistorico consumoHistoricoEsgotoImovelNaoMedido = null;
			CobrancaDocumento cobrancaDocumento = null;
			boolean imovelNaoMedido = false;

			Collection<RelatorioResumoLeituraFaturamentoImediatoHelper> colecaoHelperRelatorioLeituraAnormalidadeRegistrada = new ArrayList<RelatorioResumoLeituraFaturamentoImediatoHelper>();
			Collection<RelatorioResumoOcorrenciasFaturamentoImediatoHelper> colecaoHelperRelatorioOcorrenciaRegistrada = new ArrayList<RelatorioResumoOcorrenciasFaturamentoImediatoHelper>();
			Collection<RelatorioContasBloqueadasAnaliseHelper> colecaoContasBloqueadasAnaliseHelper = new ArrayList<RelatorioContasBloqueadasAnaliseHelper>();

			if(colecaoRotas != null && !colecaoRotas.isEmpty()){

				// [FS0001 - Verificar existência de dados]
				if(!getControladorImovel().isImovelPorColecaoRotas(colecaoRotas)){

					throw new ControladorException("atencao.nao_ha_contas_prefaturadas_para_rotas");
				}
			}

			for(Iterator iterator = colecaoRotas.iterator(); iterator.hasNext();){

				collOperacaoContabilHelper = new ArrayList();

				Rota rotaFaturamento = (Rota) iterator.next();

				log.info("**********Rota a processar: " + rotaFaturamento.getId());

				// Será utilizado na Atualização da Conta Pré-Faturada
				FaturamentoAtivCronRota faturamentoAtivCronRota = this.obterFaturamentoAtividadeCronogramaPorGrupoFaturamentoRota(
								FaturamentoAtividade.REGISTRAR_FATURAMENTO_IMEDIATO, anoMesCorrente, faturamentoGrupo, rotaFaturamento);

				Collection colecaoMovimentosRoteiroEmpresa = new ArrayList<MovimentoRoteiroEmpresa>();
				Collection colecaoImoveisLeituraAnormalidade = new ArrayList<Imovel>();
				Collection<MedicaoHistorico> colecaoMedicaoHistoricoImovel = new ArrayList<MedicaoHistorico>();
				Collection<ConsumoHistorico> colecaoConsumoHistoricoImovel = new ArrayList<ConsumoHistorico>();

				Collection colecaoResumoFaturamento = repositorioFaturamento.pesquisarResumoFaturamentoSimulacao(faturamentoGrupo.getId(),
								anoMesCorrente, rotaFaturamento.getId());

				if(Util.isVazioOrNulo(colecaoResumoFaturamento)){

					colecaoResumoFaturamento = new ArrayList<ResumoFaturamentoSimulacao>();
				}

				Collection colecaoContasAtualizar = new ArrayList<Conta>();

				// Filtro que será usado nas pesquisas do Movimento_Roteiro
				FiltroMovimentoRoteiroEmpresa filtroMovimentoRoteiroEmpresa = new FiltroMovimentoRoteiroEmpresa();
				filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade("leituraAnormalidade");
				filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade("consumoAnormalidade");
				filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade("medicaoTipo");
				filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade("consumoTipo");
				filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade("leiturista.funcionario");
				filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade("ligacaoAguaSituacao");
				filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade("ligacaoEsgotoSituacao");
				filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade("localidade");

				Collection<Imovel> colecaoImovel = getControladorImovel().pesquisarImoveisPorRotaComLocalidade(rotaFaturamento.getId());

				if(colecaoImovel != null && !colecaoImovel.isEmpty()){

					log.info("**********Quantidade de imóveis da rota : " + colecaoImovel.size());

					Collection colecaoContasImoveisRota = repositorioFaturamento.pesquisarContasPreFaturadasImoveisFaturamentoImediato(
									colecaoImovel, anoMesCorrente);

					if(!Util.isVazioOrNulo(colecaoContasImoveisRota)){

						log.info("**********Quantidade de Contas dos imóveis da rota: " + colecaoContasImoveisRota.size());
					}

					for(Iterator iteratorContasImoveisRota = colecaoContasImoveisRota.iterator(); iteratorContasImoveisRota.hasNext();){

						Conta contaImovel = (Conta) getControladorUtil().pesquisar(//
										((Conta) iteratorContasImoveisRota.next()).getId(),//
										Conta.class, true);

						Imovel imovel = this.getControladorImovel().pesquisarImovel(contaImovel.getImovel().getId());
						if(imovel != null){

							contaImovel.setImovel(imovel);
						}

						// Obtém o MovimentoRoteiroEmpresa do Imóvel e Ano/Mês Referência da Conta
						filtroMovimentoRoteiroEmpresa.limparListaParametros();

						filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.IMOVEL_ID,
										contaImovel.getImovel().getId()));
						filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(
										FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO, anoMesCorrente));
						filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.INDICADOR_FASE,
										MovimentoRoteiroEmpresa.FASE_LEITURA_RETORNADA));

						filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.IMOVEL);
						filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.LIGACAO_AGUA);

						Collection colecaoMovimentoRoteiroEmpresa = getControladorUtil().pesquisar(filtroMovimentoRoteiroEmpresa,
										MovimentoRoteiroEmpresa.class.getName());
						MovimentoRoteiroEmpresa movimentoRoteiroImovel = (MovimentoRoteiroEmpresa) Util
										.retonarObjetoDeColecao(colecaoMovimentoRoteiroEmpresa);

						if(movimentoRoteiroImovel != null){

							arrayMedicaoConsumoHistorico = new Object[3];

							if(verificarImovelNaoMedido(imovel)){

								imovelNaoMedido = true;
							}else{

								imovelNaoMedido = false;
							}

							Short indicadorImovelNaoLidoFaturarMedia = ConstantesSistema.NAO;

							if(movimentoRoteiroImovel.getIndicadorStatusRegistSistLegado() != null
											&& movimentoRoteiroImovel.getIndicadorStatusRegistSistLegado().equals(
															MovimentoRoteiroEmpresa.INDICADOR_STATUS_REGISTRO_NAO_LIDO)
											&& movimentoRoteiroImovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)){

								indicadorImovelNaoLidoFaturarMedia = ConstantesSistema.SIM;
							}

							// Caso o imóvel seja não medido ou seja medido porém o hidrômetro foi
							// instalado após o envio do arquivo de remessa, tendo assim o tipo de
							// medição sido enviado como nulo.
							if(imovelNaoMedido || (imovelNaoMedido == false && movimentoRoteiroImovel.getMedicaoTipo() == null)){

								log.info("********** Processando Imóvel Não Medido: "
												+ movimentoRoteiroImovel.getImovel().getId().toString());
								// Verifica se o imovel tem alguma irregularidade.
								if(movimentoRoteiroImovel.getLeituraAnormalidade() != null){
									contaImovel.getImovel().setLeituraAnormalidade(movimentoRoteiroImovel.getLeituraAnormalidade());

									colecaoImoveisLeituraAnormalidade.add(contaImovel.getImovel());

									// Inclui no Report de Anormalidades e Leituras
									colecaoHelperRelatorioLeituraAnormalidadeRegistrada.add(this
													.criarHelperRelatorioAnormalidadeRegistroFaturamentoImediato(imovel,
																	movimentoRoteiroImovel.getLeituraAnormalidade(),
																	movimentoRoteiroImovel.getNumeroLeitura()));

								}

								// 2.3.2. Atualizar na tabela MOVIMENTO_ROTEIRO_EMPRESA
								movimentoRoteiroImovel.setIndicadorFase(MovimentoRoteiroEmpresa.FASE_PROCESSADO);
								movimentoRoteiroImovel.setUltimaAlteracao(new Date());

								// Preenche com MedicaoHistorico que vai ser usado no [SB0002]
								arrayMedicaoConsumoHistorico[0] = new MedicaoHistorico();

								/*
								 * Prepara os dados de Medição Histórico e Consumo Histórico para
								 * determinar os dados do faturamento do imóvel não medido
								 */
								consumoHistoricoAguaImovelNaoMedido = new ConsumoHistorico();
								String indicadorEmissaoCampo = movimentoRoteiroImovel.getIndicadorEmissaoCampo();

								// Determina o Consumo da Ligação de Água
								if(movimentoRoteiroImovel.getLigacaoAguaSituacao() != null
												&& (movimentoRoteiroImovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
																.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO) || (movimentoRoteiroImovel
																.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
																.equals(LigacaoAguaSituacao.NAO_FATURAVEL)
																&& movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua() != null && !movimentoRoteiroImovel
																.getNumeroConsumoFaturadoAgua().equals(Integer.valueOf(0))))){

									if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
													|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){

										consumoHistoricoAguaImovelNaoMedido.setNumeroConsumoFaturadoMes(movimentoRoteiroImovel
														.getNumeroConsumoMedio());
										consumoHistoricoAguaImovelNaoMedido.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));
									}else{

										consumoHistoricoAguaImovelNaoMedido.setNumeroConsumoFaturadoMes(movimentoRoteiroImovel
														.getNumeroConsumoFaturadoAgua());
									}
								}else{

									consumoHistoricoAguaImovelNaoMedido.setNumeroConsumoFaturadoMes(0);
								}

								// Indicador de Faturamento Consumo Água
								if(movimentoRoteiroImovel.getIndicadorIsencaoAgua() == null
												|| movimentoRoteiroImovel.getIndicadorIsencaoAgua().equals(ConstantesSistema.NAO)){

									consumoHistoricoAguaImovelNaoMedido.setIndicadorFaturamento(ConstantesSistema.SIM);
								}else if(movimentoRoteiroImovel.getIndicadorIsencaoAgua().equals(ConstantesSistema.SIM)){

									consumoHistoricoAguaImovelNaoMedido.setIndicadorFaturamento(ConstantesSistema.NAO);
								}

								arrayMedicaoConsumoHistorico[1] = consumoHistoricoAguaImovelNaoMedido;

								// Determina o Consumo da Ligação de Esgoto
								consumoHistoricoEsgotoImovelNaoMedido = new ConsumoHistorico();

								if(movimentoRoteiroImovel.getLigacaoEsgotoSituacao() != null
												&& (movimentoRoteiroImovel.getLigacaoEsgotoSituacao().getId()
																.equals(LigacaoEsgotoSituacao.LIGADO) || (movimentoRoteiroImovel
																.getLigacaoEsgotoSituacao().getId()
																.equals(LigacaoEsgotoSituacao.FACTIVEL_FATURADA) && movimentoRoteiroImovel
																.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)))){

									if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
													|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){

										consumoHistoricoEsgotoImovelNaoMedido.setNumeroConsumoFaturadoMes(movimentoRoteiroImovel
														.getNumeroConsumoMedio());
										consumoHistoricoAguaImovelNaoMedido.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));
									}else{

										consumoHistoricoEsgotoImovelNaoMedido.setNumeroConsumoFaturadoMes(movimentoRoteiroImovel
														.getNumeroConsumoFaturadoEsgoto());
									}
								}else{

									consumoHistoricoEsgotoImovelNaoMedido.setNumeroConsumoFaturadoMes(0);
								}

								// Indicador de Faturamento Consumo Esgoto
								if(movimentoRoteiroImovel.getIndicadorIsencaoEsgoto() == null
												|| movimentoRoteiroImovel.getIndicadorIsencaoEsgoto().equals(ConstantesSistema.NAO)){

									consumoHistoricoEsgotoImovelNaoMedido.setIndicadorFaturamento(ConstantesSistema.SIM);
								}else if(movimentoRoteiroImovel.getIndicadorIsencaoEsgoto().equals(ConstantesSistema.SIM)){

									consumoHistoricoEsgotoImovelNaoMedido.setIndicadorFaturamento(ConstantesSistema.NAO);
								}

								arrayMedicaoConsumoHistorico[2] = consumoHistoricoEsgotoImovelNaoMedido;

								// ---------------------------------------------------------
								// [SB0002 – Determinar Faturamento para o Imóvel] - Inicio
								// ---------------------------------------------------------

								contaImovel = determinarFaturamentoImovel(imovel, anoMesCorrente, faturamentoAtivCronRota,
												colecaoResumoFaturamento, sistemaParametro, false, faturamentoGrupo, anoMesCorrente, true,
												contaImovel, colecaoHelperRelatorioOcorrenciaRegistrada, arrayMedicaoConsumoHistorico,
												null, movimentoRoteiroImovel, colecaoContasBloqueadasAnaliseHelper, null);

								// Altera a conta com as atualizações sofridas no [SB0002]
								// Caso a conta tenha sido Excluída no [SB0002], ela é
								// retornada
								// como null, então é feita a verificação para so adicionar
								// as
								// contas que tiverem valores.
								if(contaImovel != null){

									contaImovel.setConsumoRateioAgua(0);
									contaImovel.setConsumoRateioEsgoto(0);
									colecaoContasAtualizar.add(contaImovel);

									// -------------------------------------------------------------------------
									// Prepara Operação para: [Registra o Lançamento Contábil].
									// -------------------------------------------------------------------------
									OperacaoContabilHelper operacaoContabilHelper = new OperacaoContabilHelper();
									operacaoContabilHelper.setOperacaoContabil(OperacaoContabil.INCLUIR_CONTA_BATCH);
									operacaoContabilHelper.setObjetoOrigem(contaImovel);
									collOperacaoContabilHelper.add(operacaoContabilHelper);
									// -------------------------------------------------------------------------

									// Inclui no Report de Anormalidades e Leituras
									colecaoHelperRelatorioLeituraAnormalidadeRegistrada.add(this
													.criarHelperRelatorioAnormalidadeRegistroFaturamentoImediato(imovel,
																	movimentoRoteiroImovel.getLeituraAnormalidade(),
																	movimentoRoteiroImovel.getNumeroLeitura()));
								}

								colecaoMovimentosRoteiroEmpresa.add(movimentoRoteiroImovel);

								// [SB0013 – Atualizar Dados do Imóvel]
								this.atualizarDadosImovel(movimentoRoteiroImovel);

								if(movimentoRoteiroImovel.getNumeroDocumentoCobranca() != null
												&& movimentoRoteiroImovel.getIndicadorEmissaoCampo() != null
												&& movimentoRoteiroImovel.getIndicadorEmissaoCampo().equals(
																MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_IMPRESSA)){

									cobrancaDocumento = (CobrancaDocumento) this.getControladorUtil().pesquisar(
													movimentoRoteiroImovel.getNumeroDocumentoCobranca(), CobrancaDocumento.class, false);

									CobrancaAcaoSituacao cobrancaAcaoSituacao = new CobrancaAcaoSituacao();
									cobrancaAcaoSituacao.setId(CobrancaAcaoSituacao.ENTREGUE);
									cobrancaDocumento.setCobrancaAcaoSituacao(cobrancaAcaoSituacao);

									cobrancaDocumento.setDataSituacaoAcao(movimentoRoteiroImovel.getDataLeitura());
									cobrancaDocumento.setUltimaAlteracao(new Date());

									this.getControladorUtil().atualizar(cobrancaDocumento);
								}
							}else{

								log.info("********** Processando Imóvel Medido: " + movimentoRoteiroImovel.getImovel().getId().toString());

								// [SB0001] - Gera o Histórico de Medição e o Histórico de Consumo
								MedicaoHistorico medicaoHistoricoImovel = new MedicaoHistorico();

								medicaoHistoricoImovel.setMedicaoTipo(movimentoRoteiroImovel.getMedicaoTipo());

								// Verifica se já existe MediçãoHistórico para Imóvel no
								// AnoMêsReferência
								MedicaoHistorico medicaoHistoricoBase = null;
								// Será utilizado no cálculo do Crédito de Consumo
								Integer numeroConsumoFaturado = null;
								if(movimentoRoteiroImovel.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){

									medicaoHistoricoBase = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(
													movimentoRoteiroImovel.getImovel().getId(), anoMesCorrente);
									if(medicaoHistoricoBase != null){
										medicaoHistoricoImovel.setId(medicaoHistoricoBase.getId());
									}

									medicaoHistoricoImovel.setImovel(null);
									medicaoHistoricoImovel.setLigacaoAgua(contaImovel.getImovel().getLigacaoAgua());

									// HidrometroInstacao Historico
									if(contaImovel.getImovel().getLigacaoAgua() != null
													&& contaImovel.getImovel().getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){
										medicaoHistoricoImovel.setHidrometroInstalacaoHistorico(contaImovel.getImovel().getLigacaoAgua()
														.getHidrometroInstalacaoHistorico());
									}

									numeroConsumoFaturado = movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua();
									if(numeroConsumoFaturado == null){
										numeroConsumoFaturado = Integer.valueOf("0");
									}

								}else if(movimentoRoteiroImovel.getMedicaoTipo().getId().equals(MedicaoTipo.POCO)){
									medicaoHistoricoBase = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoPoco(
													contaImovel.getImovel().getId(), anoMesCorrente);
									if(medicaoHistoricoBase != null){
										medicaoHistoricoImovel.setId(medicaoHistoricoBase.getId());
									}

									medicaoHistoricoImovel.setImovel(contaImovel.getImovel());
									medicaoHistoricoImovel.setLigacaoAgua(null);

									// HidrometroInstacao Historico
									medicaoHistoricoImovel.setHidrometroInstalacaoHistorico(contaImovel.getImovel()
													.getHidrometroInstalacaoHistorico());

									numeroConsumoFaturado = movimentoRoteiroImovel.getNumeroConsumoFaturadoEsgoto();
									if(numeroConsumoFaturado == null){
										numeroConsumoFaturado = Integer.valueOf("0");
									}
								}

								// Seta os Atributos comuns para Inserção e Atualização
								medicaoHistoricoImovel.setAnoMesReferencia(anoMesCorrente);
								medicaoHistoricoImovel.setDataLeituraAtualInformada(movimentoRoteiroImovel.getDataLeitura());
								medicaoHistoricoImovel.setDataLeituraAtualFaturamento(movimentoRoteiroImovel.getDataLeitura());

								if(movimentoRoteiroImovel.getNumeroLeituraFaturada() != null
												&& movimentoRoteiroImovel.getNumeroLeituraFaturada() != 0){
									medicaoHistoricoImovel.setLeituraAtualInformada(movimentoRoteiroImovel.getNumeroLeituraFaturada());
									medicaoHistoricoImovel.setLeituraAtualFaturamento(movimentoRoteiroImovel.getNumeroLeituraFaturada());
								}else{
									medicaoHistoricoImovel.setLeituraAtualInformada(movimentoRoteiroImovel.getNumeroLeitura());
									medicaoHistoricoImovel.setLeituraAtualFaturamento(movimentoRoteiroImovel.getNumeroLeitura());
								}

								// Verificar se Funcionario existe
								if(movimentoRoteiroImovel.getLeiturista() != null
												&& movimentoRoteiroImovel.getLeiturista().getFuncionario() != null){
									medicaoHistoricoImovel.setFuncionario(movimentoRoteiroImovel.getLeiturista().getFuncionario());
								}

								// Verificar se Anormalidade Leitura existe
								if(movimentoRoteiroImovel.getLeituraAnormalidade() != null){
									medicaoHistoricoImovel.setLeituraAnormalidadeInformada(movimentoRoteiroImovel.getLeituraAnormalidade());
									medicaoHistoricoImovel.setLeituraAnormalidadeFaturamento(movimentoRoteiroImovel
													.getLeituraAnormalidade());
								}

								// Indicador de Situação de Leitura
								LeituraSituacao leituraSituacaoMovimento = new LeituraSituacao();
								if(movimentoRoteiroImovel.getIndicadorConfirmacaoLeitura() != null
												&& movimentoRoteiroImovel.getIndicadorConfirmacaoLeitura().intValue() > 0){

									leituraSituacaoMovimento.setId(movimentoRoteiroImovel.getIndicadorConfirmacaoLeitura().intValue());
								}else{

									leituraSituacaoMovimento.setId(LeituraSituacao.NAO_REALIZADA);
								}

								medicaoHistoricoImovel.setLeituraSituacaoAtual(leituraSituacaoMovimento);

								// Busca os Dados da leitura anterior
								Object[] dadosUltimoMedicaoHistorico = this.obterDadosLeituraAnterior(anoMesCorrente,
												movimentoRoteiroImovel.getMedicaoTipo().getId(), contaImovel.getImovel());

								medicaoHistoricoImovel.setNumeroVezesConsecutivasOcorrenciaAnormalidade(null);
								Integer numeroConsumoCreditoAnterior = 0;
								Integer numeroConsumoCreditoGerado = 0;
								LeituraSituacao leituraSituacaoAnterior = new LeituraSituacao();

								if(!Util.isVazioOrNulo(dadosUltimoMedicaoHistorico)){

									if(dadosUltimoMedicaoHistorico[4] != null){

										medicaoHistoricoImovel.setLeituraAnteriorInformada((Integer) dadosUltimoMedicaoHistorico[4]);
									}

									if(dadosUltimoMedicaoHistorico[2] != null){

										leituraSituacaoAnterior.setId((Integer) dadosUltimoMedicaoHistorico[2]);
									}else{

										leituraSituacaoAnterior.setId(LeituraSituacao.NAO_REALIZADA);
									}

									if(dadosUltimoMedicaoHistorico[3] != null){

										numeroConsumoCreditoAnterior = (Integer) dadosUltimoMedicaoHistorico[3];
									}

									if(dadosUltimoMedicaoHistorico[5] != null){

										numeroConsumoCreditoGerado = (Integer) dadosUltimoMedicaoHistorico[5];
									}
								}else{
									
									if(dadosUltimoMedicaoHistorico[4] != null){

										medicaoHistoricoImovel.setLeituraAnteriorInformada((Integer) dadosUltimoMedicaoHistorico[4]);
									}

									leituraSituacaoAnterior.setId(LeituraSituacao.NAO_REALIZADA);
								}

								int consumoCreditoConsumoHistoricoAnterior = 0;

								Object[] dadosConsumoHistoricoAnterior = repositorioMicromedicao.obterConsumoHistoricoAnterior(
												imovel.getId(), anoMesCorrente, LigacaoTipo.LIGACAO_AGUA);

								if(!Util.isVazioOrNulo(dadosConsumoHistoricoAnterior)){

									if(dadosConsumoHistoricoAnterior[4] != null){

										consumoCreditoConsumoHistoricoAnterior = (Integer) dadosConsumoHistoricoAnterior[4];
									}
								}

								medicaoHistoricoImovel.setDataLeituraAnteriorFaturamento(movimentoRoteiroImovel.getDataLeituraAnterior());
								medicaoHistoricoImovel.setLeituraAnteriorFaturamento(movimentoRoteiroImovel.getNumeroLeituraAnterior());
								medicaoHistoricoImovel.setLeituraSituacaoAnterior(leituraSituacaoAnterior);
								medicaoHistoricoImovel.setConsumoMedioHidrometro(null);
								medicaoHistoricoImovel.setConsumoMedioMedido(null);
								medicaoHistoricoImovel.setLeituraProcessamentoMovimento(new Date());
								medicaoHistoricoImovel.setNumeroConsumoMes(movimentoRoteiroImovel.getNumeroConsumoMedido());

								// Crédito de Consumo Anterior
								Integer saldoConsumoCreditoAnterior = (numeroConsumoCreditoAnterior.intValue() + numeroConsumoCreditoGerado
												.intValue()) - consumoCreditoConsumoHistoricoAnterior;
								medicaoHistoricoImovel.setConsumoCreditoAnterior(saldoConsumoCreditoAnterior);

								// Crédito de Consumo Enviado / Retornado
								Integer consumoCreditoEnviadoRetornado = 0;
								if(movimentoRoteiroImovel.getNumeroConsumoCredito() != null){

									consumoCreditoEnviadoRetornado = movimentoRoteiroImovel.getNumeroConsumoCredito();
								}

								// Crédito de Gerado
								medicaoHistoricoImovel.setConsumoCreditoGerado(consumoCreditoEnviadoRetornado.intValue()
												- saldoConsumoCreditoAnterior.intValue());

								medicaoHistoricoImovel.setUltimaAlteracao(new Date());

								// Preenche com MedicaoHistorico que vai ser usado no [SB0002]
								arrayMedicaoConsumoHistorico[0] = medicaoHistoricoImovel;

								if(medicaoHistoricoImovel.getLigacaoAgua() != null || medicaoHistoricoImovel.getImovel() != null){

									colecaoMedicaoHistoricoImovel.add(medicaoHistoricoImovel);
								}

								// Gera o Histórico Consumo do Imóvel
								ConsumoHistorico consumoHistoricoImovel = new ConsumoHistorico();

								consumoHistoricoImovel.setImovel(contaImovel.getImovel());
								consumoHistoricoImovel.setReferenciaFaturamento(anoMesCorrente);
								consumoHistoricoImovel.setIndicadorAlteracaoUltimosConsumos(ConstantesSistema.NAO);
								consumoHistoricoImovel.setConsumoRateio(Integer.valueOf("0"));
								consumoHistoricoImovel.setConsumoImovelCondominio(null);
								consumoHistoricoImovel.setIndicadorImovelCondominio(contaImovel.getImovel().getIndicadorImovelCondominio());

								// Crédito de Consumo Faturado
								Integer numeroCreditoConsumoFaturadoEmCampo = 0;
								if(movimentoRoteiroImovel.getNumeroConsumoCreditoFaturado() != null){

									numeroCreditoConsumoFaturadoEmCampo = movimentoRoteiroImovel.getNumeroConsumoCreditoFaturado();
								}

								consumoHistoricoImovel.setConsumoMinimoCreditado(numeroCreditoConsumoFaturadoEmCampo);

								if(contaImovel.getImovel() != null){
									Integer idLigacaoEsgoto = contaImovel.getImovel().getId();
									BigDecimal percentualColeta = this.getControladorLigacaoEsgoto().recuperarPercentualColetaEsgoto(
													idLigacaoEsgoto);
									if(percentualColeta != null){
										consumoHistoricoImovel.setPercentualColeta(percentualColeta);
									}else{
										consumoHistoricoImovel.setPercentualColeta(Util.formatarMoedaRealparaBigDecimal("100"));
									}

								}else{
									consumoHistoricoImovel.setPercentualColeta(Util.formatarMoedaRealparaBigDecimal("100"));
								}

								consumoHistoricoImovel.setUltimaAlteracao(new Date());
								consumoHistoricoImovel.setRateioTipo(null);
								consumoHistoricoImovel.setIndicadorAjuste(rotaFaturamento.getIndicadorAjusteConsumo());

								// ConsumoTipo
								if(movimentoRoteiroImovel.getConsumoTipo() != null){
									consumoHistoricoImovel.setConsumoTipo(movimentoRoteiroImovel.getConsumoTipo());
								}

								// Consumo Anormalidade TODO ehc verificar se Anormalidade de
								// Consumo existe
								if(movimentoRoteiroImovel.getConsumoAnormalidade() != null){
									consumoHistoricoImovel.setConsumoAnormalidade(movimentoRoteiroImovel.getConsumoAnormalidade());
								}

								// Consumo Médio do Imóvel
								int[] consumoMedioImovel = getControladorMicromedicao().obterConsumoMedioImovel(contaImovel.getImovel(),
												sistemaParametro);

								if(consumoMedioImovel != null){

									consumoHistoricoImovel.setConsumoMedio(Integer.valueOf(consumoMedioImovel[0]));
								}

								// Seta o consumo mínimo de água
								consumoHistoricoImovel.setConsumoMinimo(imovel.getLigacaoAgua() != null ? imovel.getLigacaoAgua()
												.getNumeroConsumoMinimoAgua() : null);

								if(movimentoRoteiroImovel.getRota() != null){
									consumoHistoricoImovel.setRota(movimentoRoteiroImovel.getRota());
								}

								if(movimentoRoteiroImovel.getIndicadorPoco() != null
												&& movimentoRoteiroImovel.getIndicadorPoco().equals(ConstantesSistema.SIM)){
									consumoHistoricoImovel.setPocoTipo(imovel.getPocoTipo());
								}

								// Serão utilizados no [SB0002]
								Integer numeroConsumoRateioAgua = Integer.valueOf("0");
								Integer numeroConsumoRateioEsgoto = Integer.valueOf("0");

								if(movimentoRoteiroImovel.getLigacaoAguaSituacao() != null
												&& (movimentoRoteiroImovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
																.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO) || (movimentoRoteiroImovel
																.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
																.equals(LigacaoAguaSituacao.NAO_FATURAVEL)
																&& movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua() != null && !movimentoRoteiroImovel
																.getNumeroConsumoFaturadoAgua().equals(Integer.valueOf(0))))){

									ConsumoHistorico consumoHistoricoAguaImovel = new ConsumoHistorico();

									try{
										PropertyUtils.copyProperties(consumoHistoricoAguaImovel, consumoHistoricoImovel);
									}catch(IllegalAccessException e){
										e.printStackTrace();
										sessionContext.setRollbackOnly();
										throw new ControladorException("erro.sistema", e);
									}catch(InvocationTargetException e){
										e.printStackTrace();
										sessionContext.setRollbackOnly();
										throw new ControladorException("erro.sistema", e);
									}

									// LigaçãoTipo
									LigacaoTipo ligacaoTipoImovel = new LigacaoTipo();
									ligacaoTipoImovel.setId(LigacaoTipo.LIGACAO_AGUA);
									consumoHistoricoAguaImovel.setLigacaoTipo(ligacaoTipoImovel);

									// Verifica se já existe Consumo_Histórico na base
									Collection colecaoDadosConsumoHistoricoBase = getControladorMicromedicao().pesquisarConsumoHistorico(
													contaImovel.getImovel(), ligacaoTipoImovel, anoMesCorrente);
									if(colecaoDadosConsumoHistoricoBase != null && !colecaoDadosConsumoHistoricoBase.isEmpty()){
										Object[] dadosConsumoHistoricoBase = (Object[]) colecaoDadosConsumoHistoricoBase.iterator().next();
										if(dadosConsumoHistoricoBase != null){
											consumoHistoricoAguaImovel.setId((Integer) dadosConsumoHistoricoBase[0]);
										}
									}else{
										consumoHistoricoAguaImovel.setId(null);
									}

									// Indicador de Faturamento
									if(movimentoRoteiroImovel.getIndicadorIsencaoAgua() == null
													|| movimentoRoteiroImovel.getIndicadorIsencaoAgua().equals(new Short("2"))){
										consumoHistoricoAguaImovel.setIndicadorFaturamento(ConstantesSistema.SIM);
									}else if(movimentoRoteiroImovel.getIndicadorIsencaoAgua().equals(new Short("1"))){
										consumoHistoricoAguaImovel.setIndicadorFaturamento(ConstantesSistema.NAO);
									}

									if(consumoHistoricoAguaImovel.getConsumoRateio() != null){
										numeroConsumoRateioAgua = consumoHistoricoAguaImovel.getConsumoRateio();
									}

									if(movimentoRoteiroImovel.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)
													&& movimentoRoteiroImovel.getNumeroConsumoCreditoFaturado() != null){
										consumoHistoricoAguaImovel.setConsumoMinimoCreditado(movimentoRoteiroImovel
														.getNumeroConsumoCreditoFaturado());
									}

									if(movimentoRoteiroImovel.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)
													&& movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua() != null){

										Integer numeroConsumoFaturadoMes = null;

										String indicadorEmissaoCampo = movimentoRoteiroImovel.getIndicadorEmissaoCampo();

										if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
														|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){

											numeroConsumoFaturadoMes = movimentoRoteiroImovel.getNumeroConsumoMedio();
										}else{

											numeroConsumoFaturadoMes = movimentoRoteiroImovel.getNumeroConsumoFaturadoAgua();
										}

										consumoHistoricoAguaImovel.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
									}

									consumoHistoricoAguaImovel.setConsumoImovelCondominio(null);

									// Seta o consumo mínimo de esgoto
									consumoHistoricoImovel.setConsumoMinimo(imovel.getLigacaoEsgoto() != null ? imovel.getLigacaoEsgoto()
													.getConsumoMinimo() : null);

									// [SB0012] – Gerar Consumo Rateio

									// 1. Caso haja consumo de rateio
									// retornado(MREM_NNCONSUMORATEIO diferente de nulo em
									// MOVIMENTO_ROTEIRO_EMPRESA)
									// atualizar volumes de rateio a seguir em CONSUMO_HISTORICO
									if(!Util.isVazioOuBranco(movimentoRoteiroImovel.getNumeroConsumoRateio())){

										// a. Caso o imóvel seja o macro(CSHI_ICIMOVELCONDOMINIO
										// igual 1)
										// atribuir MREM_NNCOSNUMOFATURADO de
										// MOVIMENTO_ROTEIRO_EMPRESA a
										// CSHI_IDCONSUMOIMOVELCONDOMINIO de COSNUMO_HISTORICO)
										if(consumoHistoricoAguaImovel.getIndicadorImovelCondominio().equals(ConstantesSistema.SIM)){
											consumoHistoricoAguaImovel.setConsumoImovelCondominio(movimentoRoteiroImovel
															.getNumeroConsumoFaturadoAgua());
										}

										// b. Caso MREM_NNCONSUMORATEIO seja diferente de nulo,
										// atribuir a CSHI_NNCONSUMORATEIO de CONSUMO_HISTORICO)
										if(!Util.isVazioOuBranco(movimentoRoteiroImovel.getNumeroConsumoRateio())){
											consumoHistoricoAguaImovel.setConsumoRateio(movimentoRoteiroImovel.getNumeroConsumoRateio());
										}
									}

									// Preenche com ConsumoHistorico da Agua que vai ser usado
									// no [SB0002]
									arrayMedicaoConsumoHistorico[1] = consumoHistoricoAguaImovel;

									colecaoConsumoHistoricoImovel.add(consumoHistoricoAguaImovel);
								}

								if(movimentoRoteiroImovel.getLigacaoEsgotoSituacao() != null
												&& (movimentoRoteiroImovel.getLigacaoEsgotoSituacao().getId()
																.equals(LigacaoEsgotoSituacao.LIGADO) || (movimentoRoteiroImovel
																.getLigacaoEsgotoSituacao().getId()
																.equals(LigacaoEsgotoSituacao.FACTIVEL_FATURADA) && movimentoRoteiroImovel
																.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)))){
									ConsumoHistorico consumoHistoricoEsgotoImovel = new ConsumoHistorico();
									try{
										PropertyUtils.copyProperties(consumoHistoricoEsgotoImovel, consumoHistoricoImovel);
									}catch(IllegalAccessException iaex){
										iaex.printStackTrace();
										sessionContext.setRollbackOnly();
										throw new ControladorException("erro.sistema");
									}catch(InvocationTargetException itex){
										itex.printStackTrace();
										sessionContext.setRollbackOnly();
										throw new ControladorException("erro.sistema");
									}

									// LigaçãoTipo
									LigacaoTipo ligacaoTipoImovel = new LigacaoTipo();
									ligacaoTipoImovel.setId(LigacaoTipo.LIGACAO_ESGOTO);
									consumoHistoricoEsgotoImovel.setLigacaoTipo(ligacaoTipoImovel);

									// Verifica se já existe Consumo_Histórico na base
									Collection colecaoDadosConsumoHistoricoBase = getControladorMicromedicao().pesquisarConsumoHistorico(
													contaImovel.getImovel(), ligacaoTipoImovel, anoMesCorrente);
									if(colecaoDadosConsumoHistoricoBase != null && !colecaoDadosConsumoHistoricoBase.isEmpty()){
										Object[] dadosConsumoHistoricoBase = (Object[]) colecaoDadosConsumoHistoricoBase.iterator().next();
										if(dadosConsumoHistoricoBase != null){
											consumoHistoricoEsgotoImovel.setId((Integer) dadosConsumoHistoricoBase[0]);
										}
									}else{
										consumoHistoricoEsgotoImovel.setId(null);
									}

									if(movimentoRoteiroImovel.getIndicadorIsencaoEsgoto() == null
													|| movimentoRoteiroImovel.getIndicadorIsencaoEsgoto().equals(new Short("2"))){
										consumoHistoricoEsgotoImovel.setIndicadorFaturamento(ConstantesSistema.SIM);
									}else if(movimentoRoteiroImovel.getIndicadorIsencaoEsgoto().equals(new Short("1"))){
										consumoHistoricoEsgotoImovel.setIndicadorFaturamento(ConstantesSistema.NAO);
									}

									if(consumoHistoricoEsgotoImovel.getConsumoRateio() != null){
										numeroConsumoRateioEsgoto = consumoHistoricoEsgotoImovel.getConsumoRateio();
									}

									if(movimentoRoteiroImovel.getNumeroConsumoCreditoFaturado() != null){
										consumoHistoricoEsgotoImovel.setConsumoMinimoCreditado(movimentoRoteiroImovel
														.getNumeroConsumoCreditoFaturado());
									}

									if(movimentoRoteiroImovel.getNumeroConsumoFaturadoEsgoto() != null){
										Integer numeroConsumoFaturadoMes = null;

										String indicadorEmissaoCampo = movimentoRoteiroImovel.getIndicadorEmissaoCampo();

										if(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA.equals(indicadorEmissaoCampo)
														|| indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){
											numeroConsumoFaturadoMes = movimentoRoteiroImovel.getNumeroConsumoMedio();
										}else{
											numeroConsumoFaturadoMes = movimentoRoteiroImovel.getNumeroConsumoFaturadoEsgoto();
										}

										consumoHistoricoEsgotoImovel.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
									}

									consumoHistoricoEsgotoImovel.setConsumoImovelCondominio(null);

									// [SB0012] – Gerar Consumo Rateio

									// 1. Caso haja consumo de rateio
									// retornado(MREM_NNCONSUMORATEIO diferente de nulo em
									// MOVIMENTO_ROTEIRO_EMPRESA)
									// atualizar volumes de rateio a seguir em CONSUMO_HISTORICO
									if(!Util.isVazioOuBranco(movimentoRoteiroImovel.getNumeroConsumoRateio())){

										// a. Caso o imóvel seja o macro(CSHI_ICIMOVELCONDOMINIO
										// igual 1)
										// atribuir MREM_NNCOSNUMOFATURADO de
										// MOVIMENTO_ROTEIRO_EMPRESA a
										// CSHI_IDCONSUMOIMOVELCONDOMINIO de COSNUMO_HISTORICO)
										if(consumoHistoricoEsgotoImovel.getIndicadorImovelCondominio().equals(ConstantesSistema.SIM)){
											consumoHistoricoEsgotoImovel.setConsumoImovelCondominio(movimentoRoteiroImovel
															.getNumeroConsumoFaturadoEsgoto());
										}

										// b. Caso MREM_NNCONSUMORATEIO seja diferente de nulo,
										// atribuir a CSHI_NNCONSUMORATEIO de CONSUMO_HISTORICO)
										if(!Util.isVazioOuBranco(movimentoRoteiroImovel.getNumeroConsumoRateio())){
											consumoHistoricoEsgotoImovel.setConsumoRateio(movimentoRoteiroImovel.getNumeroConsumoRateio());
										}
									}

									// Preenche com ConsumoHistorico o Esgoto que vai ser usado
									// no [SB0002]
									arrayMedicaoConsumoHistorico[2] = consumoHistoricoEsgotoImovel;

									colecaoConsumoHistoricoImovel.add(consumoHistoricoEsgotoImovel);
								}


								// 2.3.2. Atualizar na tabela MOVIMENTO_ROTEIRO_EMPRESA
								movimentoRoteiroImovel.setIndicadorFase(MovimentoRoteiroEmpresa.FASE_PROCESSADO);
								movimentoRoteiroImovel.setUltimaAlteracao(new Date());

								colecaoMovimentosRoteiroEmpresa.add(movimentoRoteiroImovel);

								// [SB0013 – Atualizar Dados do Imóvel]
								this.atualizarDadosImovel(movimentoRoteiroImovel);

								/*
								 * Caso exista aviso de débito gerado para o imóvel em
								 * questão(MREM_NNDOCUMENTOCOBRANCA <> nulo em
								 * MOVIMENTO_ROTEIRO_EMPRESA) e a conta tenha sido
								 * emitida(MREM_ICEMISSAOCAMPO tenha valor 1-Um), atualizar a
								 * situação de entrega do aviso em COBRANCA_DOCUMENTO
								 */
								if(movimentoRoteiroImovel.getNumeroDocumentoCobranca() != null
												&& movimentoRoteiroImovel.getIndicadorEmissaoCampo().equals(
																MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_IMPRESSA)){

									cobrancaDocumento = (CobrancaDocumento) getControladorUtil().pesquisar(
													movimentoRoteiroImovel.getNumeroDocumentoCobranca(), CobrancaDocumento.class, false);

									CobrancaAcaoSituacao cobrancaAcaoSituacao = new CobrancaAcaoSituacao();
									cobrancaAcaoSituacao.setId(CobrancaAcaoSituacao.ENTREGUE);
									cobrancaDocumento.setCobrancaAcaoSituacao(cobrancaAcaoSituacao);

									cobrancaDocumento.setDataSituacaoAcao(movimentoRoteiroImovel.getDataLeitura());
									cobrancaDocumento.setUltimaAlteracao(new Date());

									this.getControladorUtil().atualizar(cobrancaDocumento);
								}

								// ---------------------------------------------------------
								// [SB0002 – Determinar Faturamento para o Imóvel] - Inicio
								// ---------------------------------------------------------

								contaImovel = determinarFaturamentoImovel(imovel, anoMesCorrente, faturamentoAtivCronRota,
												colecaoResumoFaturamento, sistemaParametro, false, faturamentoGrupo, anoMesCorrente, true,
												contaImovel, colecaoHelperRelatorioOcorrenciaRegistrada, arrayMedicaoConsumoHistorico,
												null, movimentoRoteiroImovel, colecaoContasBloqueadasAnaliseHelper, null);

								if(contaImovel != null){

									contaImovel.setConsumoRateioAgua(numeroConsumoRateioAgua);
									contaImovel.setConsumoRateioEsgoto(numeroConsumoRateioEsgoto);

									// Altera a conta com as atualizações sofridas no [SB0002]
									// Caso a conta tenha sido Excluída no [SB0002], ela é
									// retornada
									// como null, então é feita a verificação para so adicionar
									// as
									// contas que tiverem valores.
									if(contaImovel != null){
										colecaoContasAtualizar.add(contaImovel);
									}

									// -------------------------------------------------------------------------
									// Prepara Operação para: [Registra o Lançamento Contábil].
									// -------------------------------------------------------------------------
									OperacaoContabilHelper operacaoContabilHelper = new OperacaoContabilHelper();
									operacaoContabilHelper.setOperacaoContabil(OperacaoContabil.INCLUIR_CONTA_BATCH);
									operacaoContabilHelper.setObjetoOrigem(contaImovel);
									collOperacaoContabilHelper.add(operacaoContabilHelper);
									// -------------------------------------------------------------------------

									// Inclui no Report de Anormalidades e Leituras
									colecaoHelperRelatorioLeituraAnormalidadeRegistrada.add(this
													.criarHelperRelatorioAnormalidadeRegistroFaturamentoImediato(imovel,
																	movimentoRoteiroImovel.getLeituraAnormalidade(),
																	movimentoRoteiroImovel.getNumeroLeitura()));

									// // Registra o Lançamento Contábil.
									// getControladorContabil().registrarLancamentoContabil(contaImovel,
									// OperacaoContabil.INCLUIR_CONTA_BATCH);

									// ---------------------------------------------------------
									// [SB0002 – Determinar Faturamento para o Imóvel] - Fim
									// ---------------------------------------------------------
								}
							}
						}else{
							String nomeClienteImovel = getControladorImovel()
											.consultarClienteUsuarioImovel(contaImovel.getImovel().getId());
							colecaoHelperRelatorioOcorrenciaRegistrada.add(this.criarHelperRelatorioOcorrenciaRegistroFaturamentoImediato(
											contaImovel.getImovel(), nomeClienteImovel, null, null,
											"Imóvel com Movimento Roteiro Empresa sem dados para ser processado.", null, null, null, null,
											null, false));
						}

						arrayMedicaoConsumoHistorico = null;
					}

					// Deleta os resumos de ligações economias existente para rota e referencia
					this.repositorioMicromedicao.deletarResumoLigacoesEconomia(rotaFaturamento.getId(), anoMesCorrente);

					// [SF0001] - Determinar Faturamento para o Imóvel
					// 6.2. Gerar resumo de ligações e economias.
					// [UC0275 – Gerar Resumo das Ligações/Economias]
					for(Imovel imovel : colecaoImovel){
						this.getControladorMicromedicao().gerarResumoLigacoesEconomias(imovel.getId(), null, null, false);
					}

				}

				// Altera a conta com as atualizações sofridas no [SB0002]
				if(!colecaoContasAtualizar.isEmpty()){

					log.info("**********Atualizando as contas na base: " + colecaoContasAtualizar.size());
					// getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoContasAtualizar);
					this.getControladorUtil().atualizarColecaoObjetos(colecaoContasAtualizar);
				}

				// Inclui as Medições e Atualiza os LeituraSituacaoImóveis com Anormalidades do
				// 'Bloco' atual
				if(colecaoMedicaoHistoricoImovel != null && !colecaoMedicaoHistoricoImovel.isEmpty()){

					log.info("**********Atualizando os históricos de medição na base: " + colecaoMedicaoHistoricoImovel.size());
					getControladorMicromedicao().inserirOuAtualizarMedicaoHistorico(colecaoMedicaoHistoricoImovel);
				}

				if(colecaoConsumoHistoricoImovel != null && !colecaoConsumoHistoricoImovel.isEmpty()){

					log.info("**********Atualizando os históricos de consumo na base: " + colecaoConsumoHistoricoImovel.size());
					getControladorMicromedicao().inserirOuAtualizarConsumoHistorico(colecaoConsumoHistoricoImovel);
				}

				// 2.3.1
				if(!colecaoImoveisLeituraAnormalidade.isEmpty()){

					log.info("**********Atualizando  os imóveis com anormalidade de leitura na base: "
									+ colecaoImoveisLeituraAnormalidade.size());
					this.getControladorUtil().atualizarColecaoObjetos(colecaoImoveisLeituraAnormalidade);
				}

				// 2.3.2
				if(!colecaoMovimentosRoteiroEmpresa.isEmpty()){

					log.info("**********Atualizando os movimentos roteiro empresa na base: " + colecaoMovimentosRoteiroEmpresa.size());
					this.getControladorUtil().atualizarColecaoObjetos(colecaoMovimentosRoteiroEmpresa);
				}


				// -------------------------------------------------------------------------

				// [SB0007] - Gerar Resumo da Simulação do Faturamento
				// Inserer na Base.
				if(colecaoResumoFaturamento != null && !colecaoResumoFaturamento.isEmpty()){

					log.info("**********Inserindo resumo simulação faturamento na base: " + colecaoResumoFaturamento.size());
					inserirResumoSimulacaoFaturamento(colecaoResumoFaturamento);
				}

				if(collOperacaoContabilHelper != null && !collOperacaoContabilHelper.isEmpty()){
					// -------------------------------------------------------------------------
					// Registra o Lançamento Contábil.
					// -------------------------------------------------------------------------
					log.info("**********Início do Registrar o Lançamento Contábil [FATURAMENTO IMEDIATO].");

					getControladorContabil().registrarLancamentoContabil(collOperacaoContabilHelper);

					log.info("**********Fim Registrar o Lançamento Contábil [FATURAMENTO IMEDIATO].");
				}

				// Itera a Coleção de Contas para poder chamar o classificar pagamento com as contas
				// já atualizadas.
				if(!colecaoContasAtualizar.isEmpty()){

					log.info("**********Classificando o pagamento (caso exista) das contas. Quantidade: " + colecaoContasAtualizar.size());
					Iterator itConta = colecaoContasAtualizar.iterator();
					Conta contaAtualizada;
					AvisoBancario avisoBancario = null;

					while(itConta.hasNext()){

						contaAtualizada = (Conta) itConta.next();

						// Gerar resumo de ligações e economias.
						// [UC0275 - Gerar Resumo das Ligações/Economias]
						// this.getControladorMicromedicao().gerarResumoLigacoesEconomias(imovel.getId());

						// [UC0566 - Gerar Histograma de Água e Esgoto]
						// Está sendo gerado por quem chama esse método
						Collection<Conta> colecaoContaInserir = Collections.singletonList(contaAtualizada);
						carregarContaParaHistograma(colecaoContaInserir);

						this.getControladorHistograma().gerarHistogramaAguaEsgoto(colecaoContaInserir,
										ConstantesSistema.GERACAO_HISTOGRAMA_FATURAMENTO);

						// Caso exista pagamento para conta, classificar pagamento de conta
						FiltroPagamento filtroPagamento = new FiltroPagamento();
						filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.IMOVEL_ID, contaAtualizada.getImovel()
										.getId()));
						filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ANO_MES_REFERENCIA_PAGAMENTO,
										anoMesCorrente));
						filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.AVISO_BANCARIO);

						Collection<Pagamento> colecaoPagamentos = getControladorUtil()
										.pesquisar(filtroPagamento, Pagamento.class.getName());

						if(!Util.isVazioOrNulo(colecaoPagamentos)){

							Pagamento pagamento = colecaoPagamentos.iterator().next();

							// [UC0300 – ClassificarPagamentosDevolucoes]
							getControladorArrecadacao().classificarPagamentosRegistroMovimentoArrecadadores(pagamento);

							avisoBancario = pagamento.getAvisoBancario();
						}

						if(avisoBancario != null){
							// Atualiza Valores do Aviso Bancário
							getControladorArrecadacao().atualizarValoresAvisoBancario(avisoBancario, false);
						}



						// Se o ((valor de água + valor de esgoto + valor débitos) - (valor de
						// créditos + valor de impostos)) da conta = ZERO -> Enviar conta pro
						// histórico
						if(contaAtualizada.getValorTotalContaBigDecimal().compareTo(BigDecimal.ZERO) == 0){

							ContaGeral contaGeral = (ContaGeral) getControladorUtil().pesquisar(contaAtualizada.getContaGeral().getId(),
											ContaGeral.class, false);

							// Caso a conta não tenha sido baixada por pagamento classificado
							if(contaGeral.getIndicadorHistorico() == ConstantesSistema.NAO){

								log.info("Transferindo para Historico => CONTA NORMAL ZERADA E SEM PAGAMENTO CLASSIFICADO["
												+ contaAtualizada.getId() + "]");

								transferirContasParaHistorico(Arrays.asList(contaAtualizada), 0);

								contaGeral.setIndicadorHistorico(ConstantesSistema.SIM);

								this.getControladorUtil().atualizar(contaGeral);
							}
						}
					}

				}
			}


			// Gera os Relatórios de Processamento
			Usuario usuarioProcessamento;
			if(idFuncionalidadeIniciada != null){
				usuarioProcessamento = getControladorBatch().obterUsuarioFuncionalidadeIniciada(idFuncionalidadeIniciada);
			}else{
				usuarioProcessamento = Usuario.USUARIO_BATCH;
			}

			this.iniciarProcessamentoRelatoriosFaturamentoImediato(colecaoHelperRelatorioLeituraAnormalidadeRegistrada,
							colecaoHelperRelatorioOcorrenciaRegistrada, usuarioProcessamento, faturamentoGrupo, anoMesCorrente,
							sistemaParametro, colecaoContasBloqueadasAnaliseHelper);

			// 6. O sistema verifica se foi processado o último arquivo do MOVIMENTO_ROTEIRO_EMPRESA
			// para o grupo de faturamento em processamento.
			Integer quantidadeMovimentoRoteiroAProcessar = repositorioFaturamento
							.pesquisarQuantidadeMovimentosRoteiroEmpresaSemProcessamento(faturamentoGrupo.getId(), anoMesCorrente,
											MovimentoRoteiroEmpresa.FASE_PROCESSADO);

			// 6.1. Caso não encontre nenhum registro, o sistema atualiza o cronograma de atividades
			// do grupo de faturamento na tabela FATURAMENTO_ATIVIDADE_ CRONOGRAMA
			if(quantidadeMovimentoRoteiroAProcessar == null || quantidadeMovimentoRoteiroAProcessar.equals(Integer.valueOf("0"))){
				Integer idFaturamentoAtividadeCronogramaFaturamento = null;
				Integer idFaturamentoGrupoCronogramaMensal = null;
				try{
					idFaturamentoGrupoCronogramaMensal = repositorioFaturamento.pesquisarFaturamentoGrupoCronogramaMensal(
									faturamentoGrupo.getId(), anoMesCorrente);

					if(idFaturamentoGrupoCronogramaMensal != null){
						// Atualiza Registrar Leitura
						idFaturamentoAtividadeCronogramaFaturamento = repositorioFaturamento.pesquisarFaturamentoAtividadeCronograma(
										idFaturamentoGrupoCronogramaMensal, FaturamentoAtividade.REGISTRAR_LEITURA_ANORMALIDADE);
						if(idFaturamentoAtividadeCronogramaFaturamento != null){
							repositorioFaturamento.atualizarFaturamentoAtividadeCronograma(idFaturamentoAtividadeCronogramaFaturamento,
											new Date());
						}

						// Atualiza Efetuar Leitura
						idFaturamentoAtividadeCronogramaFaturamento = repositorioFaturamento.pesquisarFaturamentoAtividadeCronograma(
										idFaturamentoGrupoCronogramaMensal, FaturamentoAtividade.EFETUAR_LEITURA);
						if(idFaturamentoAtividadeCronogramaFaturamento != null){
							repositorioFaturamento.atualizarFaturamentoAtividadeCronograma(idFaturamentoAtividadeCronogramaFaturamento,
											new Date());
						}

						// Atualiza Consistir Leitura
						idFaturamentoAtividadeCronogramaFaturamento = repositorioFaturamento.pesquisarFaturamentoAtividadeCronograma(
										idFaturamentoGrupoCronogramaMensal, FaturamentoAtividade.CONSISTIR_LEITURAS_E_CALCULAR_CONSUMOS);
						if(idFaturamentoAtividadeCronogramaFaturamento != null){
							repositorioFaturamento.atualizarFaturamentoAtividadeCronograma(idFaturamentoAtividadeCronogramaFaturamento,
											new Date());
						}

						// Atualiza Registro do Faturamento Imediato
						idFaturamentoAtividadeCronogramaFaturamento = repositorioFaturamento.pesquisarFaturamentoAtividadeCronograma(
										idFaturamentoGrupoCronogramaMensal, FaturamentoAtividade.REGISTRAR_FATURAMENTO_IMEDIATO);
						if(idFaturamentoAtividadeCronogramaFaturamento != null){
							repositorioFaturamento.atualizarFaturamentoAtividadeCronograma(idFaturamentoAtividadeCronogramaFaturamento,
											new Date());
						}

						// 6.1.5. Atualizar o ano/mês de referência do faturamento para o mês
						// seguinte (FTGR_AMREFERENCIA + 1 mês da tabela FATURAMENTO_GRUPO).
						this.atualizarAnoMesReferenciaFaturamentoGrupo(faturamentoGrupo, anoMesCorrente,
										FaturamentoAtividade.REGISTRAR_FATURAMENTO_IMEDIATO);

						log.info("**********Atualizada a data de realização do comando de faturamento e incrementada a referência do grupo para o próximo mês: "
										+ anoMesCorrente.toString() + "+ 1");
					}

				}catch(ErroRepositorioException e){

					e.printStackTrace();
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.atualizacao_execucao_comando_faturamento_imediato", e, faturamentoGrupo.getId()
									.toString(), anoMesCorrente.toString());
				}
			}else{

				log.info("**********Atenção referência do grupo não mudou pois ainda existe movimento pedente na fase 1 ou 4. ");
				log.info("**********Quantidade de movimento roteiro empresa pendente ainda nas fases 1 ou 4: "
								+ quantidadeMovimentoRoteiroAProcessar.toString());
			}

			if(idUnidadeIniciada != 0){
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
			}

			log.info("**********Fim Registrar Imediato do Grupo/Referência: " + faturamentoGrupo.getId().toString() + "/"
							+ anoMesCorrente.toString());
		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			if(idUnidadeIniciada != 0){

				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			}

			throw new EJBException(e);
		}
	}

	// ***************************************************************
	/**
	 * Início - Atenção método provisório apenas para correção do faturamento imediato 08/05/2012
	 */

	public Collection<Object[]> selecionarContasCorrigirFaturamentoImediato() throws ControladorException{

		Collection<Object[]> colecaoAux = null;
		try{
			colecaoAux = repositorioFaturamento.selecionarContasCorrigirFaturamentoImediato();
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return colecaoAux;
	}

	public void corrigirFaturamentoImediato(Collection<Object[]> colecaoAux) throws ControladorException{

		Imovel imovel = null;
		Conta conta = null;
		Integer ligacaoAguaSituacaoId = null;
		Integer ligacaoEsgotoSituacaoId = null;
		ConsumoTarifa consumoTarifa = null;
		// Inicializa com zero o percentual de esgoto o consumo faturado do mês de água e de
		// esgoto
		BigDecimal percentualEsgoto = new BigDecimal(0);
		Integer consumoFaturadoMesAgua = Integer.valueOf("0");
		Integer consumoFaturadoMesEsgoto = Integer.valueOf("0");

		// Seta valores iniciais para os indicadores de faturamento de água e esgoto.
		Short indicadorFaturamentoAgua = Short.valueOf("2");
		Short indicadorFaturamentoEsgoto = Short.valueOf("2");

		// Pesquisar consumo histórico

		MedicaoHistorico medicaoHistoricoPoco = null;

		Date dataLeituraAnteriorFaturamento = null;
		// Determina a data de leitura atual do faturamento
		Date dataLeituraAtualFaturamento = null;
		int i = 0;

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		if(!Util.isVazioOrNulo(colecaoAux)){

			for(Object[] objeto : colecaoAux){

				if(objeto[0] != null && objeto[1] != null && objeto[2] != null){

					i++;

					conta = new Conta();
					conta.setId((Integer) objeto[0]);

					System.out.println("CONTA = " + conta.getId());

					imovel = this.getControladorImovel().pesquisarImovel((Integer) objeto[1]);

					conta.setImovel(imovel);

					conta.setReferencia((Integer) objeto[2]);

					ligacaoAguaSituacaoId = imovel.getLigacaoAguaSituacao().getId();
					ligacaoEsgotoSituacaoId = imovel.getLigacaoEsgotoSituacao().getId();
					// Recupera o percentual de esgoto.
					// percentualEsgoto = this.obterPercentualLigacaoEsgotoImovel(imovel.getId());

					// ----------------------------------------------------------------
					FiltroConsumoHistorico filtroCH = new FiltroConsumoHistorico();
					filtroCH.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, imovel.getId()));
					filtroCH.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANO_MES_FATURAMENTO, conta.getReferencia()));
					filtroCH.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.LIGACAO_TIPO_ID, LigacaoTipo.LIGACAO_ESGOTO));

					Collection colecaoConsumoHistoricoEsgoto = getControladorUtil().pesquisar(filtroCH, ConsumoHistorico.class.getName());

					ConsumoHistorico consumoHistoricoEsgoto = (ConsumoHistorico) Util.retonarObjetoDeColecao(colecaoConsumoHistoricoEsgoto);

					if(consumoHistoricoEsgoto != null
									&& imovel.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue()){
						if(consumoHistoricoEsgoto.getIndicadorFaturamento() != null){
							// Seta o indicador faturamento esgoto
							indicadorFaturamentoEsgoto = consumoHistoricoEsgoto.getIndicadorFaturamento();
						}

						if(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null){
							consumoFaturadoMesEsgoto = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
						}
					}

					filtroCH = new FiltroConsumoHistorico();
					filtroCH.limparListaParametros();
					filtroCH.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, imovel.getId()));
					filtroCH.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANO_MES_FATURAMENTO, conta.getReferencia()));
					filtroCH.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.LIGACAO_TIPO_ID, LigacaoTipo.LIGACAO_AGUA));

					Collection colecaoConsumoHistoricoAgua = getControladorUtil().pesquisar(filtroCH, ConsumoHistorico.class.getName());

					ConsumoHistorico consumoHistoricoAgua = (ConsumoHistorico) Util.retonarObjetoDeColecao(colecaoConsumoHistoricoAgua);
					if((imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.FATURAMENTO_ATIVO
									.intValue())
									|| (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.NAO_FATURAVEL
													.intValue() && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null && consumoHistoricoAgua
													.getNumeroConsumoFaturadoMes().intValue() > 0)){
						indicadorFaturamentoAgua = Short.valueOf("1");
						// caso exista indicador de Faturamento no Consumo, será assumido o do
						// ConsumoHistorico.
						if(consumoHistoricoAgua.getIndicadorFaturamento() != null){
							// Seta o indicador faturamento água
							indicadorFaturamentoAgua = consumoHistoricoAgua.getIndicadorFaturamento();
						}
						consumoFaturadoMesAgua = consumoHistoricoAgua.getNumeroConsumoFaturadoMes();

					}

				}

				FiltroMedicaoHistorico filtroMH = new FiltroMedicaoHistorico();
				filtroMH.limparListaParametros();
				filtroMH.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.LIGACAO_AGUA_ID, imovel.getId()));
				filtroMH.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO, conta
								.getReferencia()));
				filtroMH.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.MEDICAO_TIPO_ID, MedicaoTipo.LIGACAO_AGUA));
				Collection colecaoMedicaoHistoricoAgua = getControladorUtil().pesquisar(filtroMH, MedicaoHistorico.class.getName());

				MedicaoHistorico medicaoHistoricoAgua = (MedicaoHistorico) Util.retonarObjetoDeColecao(colecaoMedicaoHistoricoAgua);

				if(medicaoHistoricoAgua != null){

					// Seta a data de letura anterior faturamento
					if(medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento() != null){
						dataLeituraAnteriorFaturamento = medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento();
					}

					// Seta a data de leitura atual faturamento
					if(medicaoHistoricoAgua.getDataLeituraAtualFaturamento() != null){
						dataLeituraAtualFaturamento = medicaoHistoricoAgua.getDataLeituraAtualFaturamento();
					}
				}

				// Caso o imóvel seja ligado de esgoto
				if(imovel.getLigacaoEsgoto() != null && imovel.getLigacaoEsgotoSituacao() != null
								&& imovel.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue()){
					// consultar medicao hisotrico tipo poco
					medicaoHistoricoPoco = this.getControladorMicromedicao().pesquisarMedicaoHistoricoTipoPoco(imovel.getId(),
									conta.getReferencia());

					// Verifica se existe medição histórico para poço
					if(medicaoHistoricoPoco != null){

						// Seta a data de leitura anterior faturamento
						if(medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento() != null){
							dataLeituraAnteriorFaturamento = medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento();
						}

						// Seta a data atual de faturamento
						if(medicaoHistoricoPoco.getDataLeituraAtualFaturamento() != null){
							dataLeituraAtualFaturamento = medicaoHistoricoPoco.getDataLeituraAtualFaturamento();
						}
					}
					// Recupera o percentual de esgoto.
					percentualEsgoto = this.obterPercentualLigacaoEsgotoImovel(imovel.getId());
				}

				// Coleção que vai armazenar as categorias do imóvel
				Collection colecaoCategorias = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

				// ---------------------------------------------------------------------------------
				// [SB0003] - Determinar Valores para Faturamento de Água e/ou Esgoto - Início
				// ---------------------------------------------------------------------------------
				// [UC0105] - Obter Consumo Mínimo da Ligação
				int consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, null);

				// Obtém a tarifa do imóvel
				Integer consumoTarifaId = imovel.getConsumoTarifa().getId();
				consumoTarifa = imovel.getConsumoTarifa();

				// 2.1. Caso o imóvel esteja incluso no programa água para todos(iapt_id diferente
				// de
				// Null)
				if(imovel.getImovelAguaParaTodos() != null){

					// 2.2. Caso o imóvel esteja incluso no programa água para todos e o consumo
					// seja
					// maior que [PARÂMETRO – PARM_NNCONSUMOMINIMOAPT], assumir a tarifa padrão do
					// imóvel para faturamento desconsiderando a atual
					if(sistemaParametro.getNumeroConsumoMinAguaParaTodos() != null
									&& consumoFaturadoMesAgua <= sistemaParametro.getNumeroConsumoMinAguaParaTodos()){
						if(imovel.getConsumoTarifaTemporaria() != null && imovel.getConsumoTarifaTemporaria().getId() != null
										&& imovel.getDataValidadeTarifaTemporaria() != null
										&& Util.compararData(imovel.getDataValidadeTarifaTemporaria(), new Date()) >= 0){
							consumoTarifaId = imovel.getConsumoTarifaTemporaria().getId();
							consumoTarifa = imovel.getConsumoTarifaTemporaria();
						}
					}
				}

				// [UC0120] - Calcular Valores de Água e/ou Esgoto
				Collection colecaoCalcularValoresAguaEsgotoHelper = calcularValoresAguaEsgoto(conta.getReferencia(), ligacaoAguaSituacaoId,
								ligacaoEsgotoSituacaoId, indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategorias,
								consumoFaturadoMesAgua, consumoFaturadoMesEsgoto, consumoMinimoLigacao, dataLeituraAnteriorFaturamento,
								dataLeituraAtualFaturamento, percentualEsgoto, consumoTarifaId, imovel.getId(), null);

				Object[] retornoDadosContaCategoriaEContaCategoriaConsumoFaixa = this
								.gerarDadosAtualizarContaCategoriaEInserirContaCategoriaConsumoFaixa(colecaoCategorias,
												colecaoCalcularValoresAguaEsgotoHelper, conta);
				Collection colecaoContaCategoriaAtualizar = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixa[0];
				Collection colecaoContaCategoriaConsumoFaixaInserir = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixa[1];

				// 2.2 Atualiza a conta categoria
				if(colecaoContaCategoriaAtualizar != null && !colecaoContaCategoriaAtualizar.isEmpty()){
					this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoContaCategoriaAtualizar);

					colecaoContaCategoriaAtualizar.clear();
					colecaoContaCategoriaAtualizar = null;
				}

				if(colecaoContaCategoriaConsumoFaixaInserir != null && !colecaoContaCategoriaConsumoFaixaInserir.isEmpty()){
					this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoriaConsumoFaixaInserir);

					colecaoContaCategoriaConsumoFaixaInserir.clear();
					colecaoContaCategoriaConsumoFaixaInserir = null;
				}

				System.out.println("----------------> contas processadas  = " + i);

			}

			System.out.println("----------------> Total contas processadas  = " + i);

		}

	}

	/**
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Carlos Chrystian
	 * @date 14/08/2012
	 *       Emitir Contas Caucionadas
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Collection<EmitirContaHelper> emitir2ViaContasCaucionadas(Collection colecaoContaCaucionamento, boolean cobrarTaxaEmissaoConta,
					Short contaSemCodigoBarras, Collection<MedicaoHistorico> colecaoDadosMedicaoLeitura,
					Collection<Collection<ContaCategoriaConsumoFaixa>> colecaoContaCategoriaConsumoFaixa) throws ControladorException{

		Collection<EmitirContaHelper> colecaoEmitirContaHelper = new ArrayList();

		Iterator iter = colecaoContaCaucionamento.iterator();

		while(iter.hasNext()){
			Conta contaCaucionada = (Conta) iter.next();

			Collection colectionConta;
			try{
				colectionConta = this.repositorioFaturamento.pesquisarConta(contaCaucionada.getId());
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) colectionConta.iterator().next();

			// --------------------------------------------------------------
			// Recupera os valores da Conta Caucionada(Dados da Tela)
			// Conta
			emitirContaHelper.setDataVencimentoConta(contaCaucionada.getDataVencimentoConta());
			emitirContaHelper.setDebitos(contaCaucionada.getDebitos());
			emitirContaHelper.setValorCreditos(contaCaucionada.getValorCreditos());
			emitirContaHelper.setValorImpostos(contaCaucionada.getValorImposto());
			// Água

			emitirContaHelper.setIdLigacaoAguaSituacao(contaCaucionada.getLigacaoAguaSituacao().getId());
			emitirContaHelper.setConsumoAgua(contaCaucionada.getConsumoAgua());
			emitirContaHelper.setValorAgua(contaCaucionada.getValorAgua());
			// Esgoto

			emitirContaHelper.setIdLigacaoEsgotoSituacao(contaCaucionada.getLigacaoEsgotoSituacao().getId());
			emitirContaHelper.setConsumoEsgoto(contaCaucionada.getConsumoEsgoto());
			emitirContaHelper.setValorEsgoto(contaCaucionada.getValorEsgoto());
			emitirContaHelper.setPercentualEsgotoConta(contaCaucionada.getPercentualEsgoto());
			// --------------------------------------------------------------
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			String tipoDocCliente = "";
			String cpfCnpj = "";

			if(emitirContaHelper.getTipoDocCliente() != null && emitirContaHelper.getTipoDocCliente().equals("CPF")){
				tipoDocCliente = emitirContaHelper.getTipoDocCliente();
				cpfCnpj = Util.formatarCpf(emitirContaHelper.getCpfCnpjCliente());

			}else if(emitirContaHelper.getTipoDocCliente() != null && emitirContaHelper.getTipoDocCliente().equals("CNPJ")){

				tipoDocCliente = emitirContaHelper.getTipoDocCliente();
				cpfCnpj = Util.formatarCnpj(emitirContaHelper.getCpfCnpjCliente());
			}

			emitirContaHelper.setTipoDocCliente(tipoDocCliente);
			emitirContaHelper.setCpfCnpjCliente(cpfCnpj);

			// Linha 5
			// --------------------------------------------------------------
			// recupera endereco do imóvel
			String enderecoImovel = "";
			try{
				enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(emitirContaHelper.getIdImovel());
			}catch(ControladorException e1){
				e1.printStackTrace();
			}
			emitirContaHelper.setEnderecoImovel(enderecoImovel);

			// Linha 6
			// --------------------------------------------------------------
			// instância um imovel com os dados da conta para recuperar a
			// inscrição que está no objeto imovel
			Imovel imovel = new Imovel();
			Localidade localidade = new Localidade();
			localidade.setId(emitirContaHelper.getIdLocalidade());
			imovel.setLocalidade(localidade);
			SetorComercial setorComercial = new SetorComercial();
			setorComercial.setCodigo(emitirContaHelper.getCodigoSetorComercialConta());
			imovel.setSetorComercial(setorComercial);
			Quadra quadra = new Quadra();
			quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
			imovel.setQuadra(quadra);
			if(emitirContaHelper.getLoteConta() != null){
				imovel.setLote(emitirContaHelper.getLoteConta());
			}
			if(emitirContaHelper.getSubLoteConta() != null){
				imovel.setSubLote(emitirContaHelper.getSubLoteConta());
			}
			// Inscrição do imóvel
			emitirContaHelper.setInscricaoImovel(imovel.getInscricaoFormatada());

			// Linha 7
			// --------------------------------------------------------------
			String enderecoEntrega = "";
			// Endereço de entrega
			Integer idImovelContaEnvio = emitirContaHelper.getIdImovelContaEnvio();
			if(idImovelContaEnvio != null){

				if(idImovelContaEnvio.intValue() != ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_PAGAVEL_PARA_RESPONSAVEL
								&& idImovelContaEnvio.intValue() != ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_NAO_PAGAVEL_PARA_RESPOSAVEL
								&& idImovelContaEnvio.intValue() != ImovelContaEnvio.ENVIAR_IMOVEL){

					// Obter Endereço
					imovel.setId(emitirContaHelper.getIdImovel());
					Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
					enderecoEntrega = (String) arrayDadosEndereco[0];
				}
			}
			emitirContaHelper.setEnderecoClienteEntrega(enderecoEntrega);

			// Linha 8
			// --------------------------------------------------------------

			// [SB0002] - Determinar tipo de ligação e tipo de Medição
			Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
			Integer tipoLigacao = parmSituacao[0];
			Integer tipoMedicao = parmSituacao[1];

			// Linha 9
			// --------------------------------------------------------------
			// cria uma stringBuilder para recuperar o resultado do [SB0003]
			// o tamanho da string que vem como resultado é de 20 posições
			StringBuilder obterDadosConsumoMedicaoAnterior = null;

			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 1
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 1, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes1(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 4
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 4, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes4(obterDadosConsumoMedicaoAnterior.toString());

			// Linha 10
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 2
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 2, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes2(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 5
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 5, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes5(obterDadosConsumoMedicaoAnterior.toString());
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros da medição historico do
			// [SB0004] - Obter Dados da Medição da Conta
			Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(emitirContaHelper, tipoMedicao);
			// Leitura Anterior
			String leituraAnterior = "";
			// Leitura Atual
			String leituraAtual = "";
			// Data Leitura Anterior
			String dataLeituraAnterior = "";
			// Leitura Anterior
			String dataLeituraAtual = "";
			// Leitura Anormalidade Faturamento
			String leituraAnormalidadeFaturamento = "";
			if(parmsMedicaoHistorico != null){

				if(parmsMedicaoHistorico[0] != null){
					leituraAnterior = "" + (Integer) parmsMedicaoHistorico[0];
				}

				if(parmsMedicaoHistorico[3] != null){
					dataLeituraAnterior = Util.formatarData((Date) parmsMedicaoHistorico[3]);
				}

				if(parmsMedicaoHistorico[5] != null){
					leituraAnormalidadeFaturamento = "" + (Integer) parmsMedicaoHistorico[5];
				}
			}

			// Valores informados na tela
			if(!Util.isVazioOrNulo(colecaoDadosMedicaoLeitura)){
				MedicaoHistorico medicaoHistorico = (MedicaoHistorico) Util.retonarObjetoDeColecao(colecaoDadosMedicaoLeitura);
				dataLeituraAtual = Util.formatarData(medicaoHistorico.getDataLeituraAtualFaturamento());
				leituraAtual = medicaoHistorico.getLeituraAtualFaturamento().toString();

			}

			emitirContaHelper.setDataLeituraAnterior(dataLeituraAnterior);
			emitirContaHelper.setDataLeituraAtual(dataLeituraAtual);

			String diasConsumo = "";
			if(!dataLeituraAnterior.equals("") && !dataLeituraAtual.equals("")){
				// calcula a quantidade de dias de consumo que é a
				// quantidade de dias
				// entre a data de leitura
				// anterior(parmsMedicaoHistorico[2]) e a data de leitura
				// atual(parmsMedicaoHistorico[3])
				diasConsumo = "" + Util.obterQuantidadeDiasEntreDuasDatas((Date) parmsMedicaoHistorico[3], (Date) parmsMedicaoHistorico[2]);
			}
			// recupera os parametros de consumo faturamento e consumo médio
			// diário
			// [SB0005] - Obter Consumo Faturado e Consumo Médio Diário
			String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(emitirContaHelper, tipoMedicao, diasConsumo);
			String consumoFaturamento = parmsConsumo[0];
			emitirContaHelper.setConsumoFaturamento(consumoFaturamento);

			String consumoMedioDiario = parmsConsumo[1];
			emitirContaHelper.setConsumoMedioDiario(consumoMedioDiario);
			// Fim Chamar Sub-Fluxo
			// Leitura Anterior
			leituraAnterior = Util.completaString(leituraAnterior, 7);
			emitirContaHelper.setLeituraAnterior(leituraAnterior);
			// Leitura Atual
			leituraAtual = Util.completaString(leituraAtual, 7);
			emitirContaHelper.setLeituraAtual(leituraAtual);
			// Dias de consumo
			diasConsumo = Util.completaString(diasConsumo, 2);
			emitirContaHelper.setDiasConsumo(diasConsumo);

			// Linha 11
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 3
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 3, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes3(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 6
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 6, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes6(obterDadosConsumoMedicaoAnterior.toString());

			// Linha 12
			// --------------------------------------------------------------
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros do consumo historico da conta
			// [SB0006] - Obter Dados de Consumo da Conta
			Object[] parmsConsumoHistorico = null;
			String descricaoAbreviadaTipoConsumo = "";
			String descricaoTipoConsumo = "";
			String consumoMedio = "";
			String descricaoAbreviadaAnormalidadeConsumo = "";
			String descricaoAnormalidadeConsumo = "";
			String consumoRateio = "";
			// caso o tipo de ligacao for diferente de nulo
			if(tipoLigacao != null){
				try{
					parmsConsumoHistorico = getControladorMicromedicao().obterDadosConsumoConta(emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia(), tipoLigacao);
				}catch(ControladorException e){
					e.printStackTrace();
				}

				if(parmsConsumoHistorico != null){
					// descrição abreviada tipo de consumo
					if(parmsConsumoHistorico[0] != null){
						descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
					}
					// descrição tipo de consumo
					if(parmsConsumoHistorico[1] != null){
						descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
					}
					// Consumo médio
					if(parmsConsumoHistorico[2] != null){
						consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
					}
					// descrição abreviada anormalidade de consumo
					if(parmsConsumoHistorico[3] != null){
						descricaoAbreviadaAnormalidadeConsumo = (String) parmsConsumoHistorico[3];
					}
					// descrição anormalidade de consumo
					if(parmsConsumoHistorico[4] != null){
						descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
					}
					// Consumo médio
					if(parmsConsumoHistorico[5] != null){
						consumoRateio = "" + (Integer) parmsConsumoHistorico[5];
					}
				}
			}

			emitirContaHelper.setDescricaoTipoConsumo(descricaoTipoConsumo);
			emitirContaHelper.setDescricaoAnormalidadeConsumo(descricaoAnormalidadeConsumo);

			// Fim Chamar Sub-Fluxo

			// Linha 13
			// --------------------------------------------------------------

			// Inicio Chamar Sub-Fluxo
			// soma a quantidades de economias da tabela contaCategoria
			// [SB0007] - Obter Dados da Medição da Conta
			Short quantidadeEconomiaConta = 0;
			quantidadeEconomiaConta = obterQuantidadeEconomiasConta(emitirContaHelper.getIdConta(), false);
			emitirContaHelper.setQuantidadeEconomiaConta("" + quantidadeEconomiaConta);
			// Fim Chamar Sub-Fluxo

			// Consumo por Economia
			// transforma o consumoFaturamento para um bigDecimal
			BigDecimal consumoFaturadoBigDecimal = null;
			if(consumoFaturamento != null && !consumoFaturamento.equals("")){
				consumoFaturadoBigDecimal = Util.formatarMoedaRealparaBigDecimal(consumoFaturamento);

			}
			// transforma a quantidade de economias da conta para um
			// bigDecimal
			BigDecimal qtdEconomiasBigDecimal = null;
			if(quantidadeEconomiaConta != null && !quantidadeEconomiaConta.equals("")){
				qtdEconomiasBigDecimal = Util.formatarMoedaRealparaBigDecimal("" + quantidadeEconomiaConta);
			}
			String consumoEconomia = "";
			if(consumoFaturadoBigDecimal != null && qtdEconomiasBigDecimal != null){
				BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal.divide(qtdEconomiasBigDecimal, 2, RoundingMode.UP);
				consumoEconomia = Util.formatarMoedaReal(consumoEconomiaBigDecimal);
				emitirContaHelper.setConsumoEconomia(consumoEconomia.substring(0, (consumoEconomia.length() - 3)));
			}

			// Inicio Chamar Sub-Fluxo
			// concatena os campos dos sub-fluxos anteriores
			// [SB0008] - Obter Dados da Medição da Conta
			StringBuilder codigoAuxiliar = new StringBuilder();
			// leitura situação atual
			// tipo de consumo
			codigoAuxiliar.append(Util.completaString(descricaoAbreviadaTipoConsumo, 1));
			// tipo de contrato
			codigoAuxiliar.append(Util.completaString("", 1));
			// anormalidade de leitura
			codigoAuxiliar.append(Util.completaString(leituraAnormalidadeFaturamento, 2));
			// anormalidade de consumo
			codigoAuxiliar.append(Util.completaString(descricaoAbreviadaAnormalidadeConsumo, 2));

			// perfil do imóvel
			if(emitirContaHelper.getIdImovelPerfil() != null){
				codigoAuxiliar.append(Util.completaString("" + emitirContaHelper.getIdImovelPerfil(), 1));
			}else{
				codigoAuxiliar.append(Util.completaString("", 1));
			}
			// dias do consumo
			codigoAuxiliar.append(Util.completaString(diasConsumo, 2));
			// Consumo medio do imóvel
			codigoAuxiliar.append(Util.completaString(consumoMedio, 6));
			// Fim Chamar Sub-Fluxo
			emitirContaHelper.setCodigoAuxiliarString(codigoAuxiliar.toString());

			// chama o [SB0009] - Obter Mensagem de Rateio de Consumo Fixo
			// de Esgoto
			StringBuilder mesagemConsumo = obterMensagemRateioConsumo(emitirContaHelper, consumoRateio, parmsMedicaoHistorico, tipoMedicao);
			// mensagem de rateio de consumo ou consumo fixo de esgoto
			emitirContaHelper.setMensagemConsumoString(mesagemConsumo.toString());

			// Linha 16
			// --------------------------------------------------------------
			// chama o [SB0010] - Gerar Linhas da Descrição dos Serviços e
			// Tarifas

			Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = gerarLinhasDescricaoServicoTarifasRelatorio(
							emitirContaHelper, consumoRateio, parmsMedicaoHistorico, tipoMedicao, false, contaCaucionada,
							colecaoContaCategoriaConsumoFaixa, true);
			emitirContaHelper
							.setColecaoContaLinhasDescricaoServicosTarifasTotalHelper(colecaoContaLinhasDescricaoServicosTarifasTotalHelper);

			// Linha 17
			// --------------------------------------------------------------
			// cria um objeto conta para calcular o valor da conta
			Conta conta = new Conta();
			conta.setValorAgua(emitirContaHelper.getValorAgua());
			conta.setValorEsgoto(emitirContaHelper.getValorEsgoto());
			conta.setValorCreditos(emitirContaHelper.getValorCreditos());
			conta.setDebitos(emitirContaHelper.getDebitos());
			conta.setValorImposto(emitirContaHelper.getValorImpostos());
			BigDecimal valorConta = conta.getValorTotalContaBigDecimal();

			emitirContaHelper.setValorContaString(Util.formatarMoedaReal(valorConta));

			if(contaSemCodigoBarras.equals(ConstantesSistema.SIM) || valorConta.compareTo(new BigDecimal("0.00")) == 0){
				emitirContaHelper.setContaSemCodigoBarras("1");
			}else{
				emitirContaHelper.setContaSemCodigoBarras("2");
			}

			// chama o [SB0016] - Obter Mensagem da Conta em 3 Partes
			String[] parmsPartesConta = obterMensagemConta3Partes(emitirContaHelper, sistemaParametro);

			// Linha 18
			// --------------------------------------------------------------
			emitirContaHelper.setPrimeiraParte(parmsPartesConta[0]);

			// Linha 19
			// --------------------------------------------------------------
			emitirContaHelper.setSegundaParte(parmsPartesConta[1]);

			// Linha 20
			// --------------------------------------------------------------
			emitirContaHelper.setTerceiraParte(parmsPartesConta[2]);

			// Linha 21
			// --------------------------------------------------------------
			emitirContaHelper.setMesAnoFormatado(Util.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia()));

			// Linha 22
			Object[] parmsQualidadeAgua = null;
			parmsQualidadeAgua = pesquisarParmsQualidadeAgua(emitirContaHelper);

			String numeroAmostrasMediaTurbidez = "";
			String numeroAmostrasMediaCloro = "";
			String numeroAmostrasMediaCor = "";
			String numeroAmostrasMediaPH = "";
			String numeroAmostrasMediaBacteriasHeterotroficas = "";
			String numeroAmostrasMediaColiformesTermotolerantes = "";
			String numeroAmostrasMediaColiformesTotais = "";

			if(parmsQualidadeAgua != null){

				if(parmsQualidadeAgua[0] != null){
					numeroAmostrasMediaTurbidez = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]);
				}

				if(parmsQualidadeAgua[1] != null){
					numeroAmostrasMediaCloro = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]);
				}

				if(parmsQualidadeAgua[2] != null){
					numeroAmostrasMediaCor = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[2]);
				}

				if(parmsQualidadeAgua[3] != null){
					numeroAmostrasMediaPH = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[3]);
				}

				if(parmsQualidadeAgua[4] != null){
					numeroAmostrasMediaBacteriasHeterotroficas = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[4]);
				}

				if(parmsQualidadeAgua[5] != null){
					numeroAmostrasMediaColiformesTermotolerantes = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[5]);
				}

				if(parmsQualidadeAgua[6] != null){
					numeroAmostrasMediaColiformesTotais = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[6]);
				}
			}

			emitirContaHelper.setNumeroAmostrasMediaTurbidez(numeroAmostrasMediaTurbidez);
			emitirContaHelper.setNumeroAmostrasMediaCloro(numeroAmostrasMediaCloro);
			emitirContaHelper.setNumeroAmostrasMediaCor(numeroAmostrasMediaCor);
			emitirContaHelper.setNumeroAmostrasMediaPH(numeroAmostrasMediaPH);
			emitirContaHelper.setNumeroAmostrasMediaBacteriasHeterotroficas(numeroAmostrasMediaBacteriasHeterotroficas);
			emitirContaHelper.setNumeroAmostrasMediaColiformesTermotolerantes(numeroAmostrasMediaColiformesTermotolerantes);
			emitirContaHelper.setNumeroAmostrasMediaColiformesTotais(numeroAmostrasMediaColiformesTotais);

			// Linha 23
			// --------------------------------------------------------------
			// Considerar as contas do tipo débito automático como tipo de conta
			// normal
			// [SB0018 - Gerar Linhas das DemaisContas]
			Integer digitoVerificadorConta = Integer.valueOf("" + emitirContaHelper.getDigitoVerificadorConta());
			// formata ano mes para mes ano
			String anoMes = "" + emitirContaHelper.getAmReferencia();
			String mesAno = anoMes.substring(4, 6) + anoMes.substring(0, 4);

			String representacaoNumericaCodBarra = "";

			if(contaSemCodigoBarras.equals(ConstantesSistema.NAO) || valorConta.compareTo(new BigDecimal("0.00")) != 0){

				representacaoNumericaCodBarra = this.getControladorArrecadacao().obterRepresentacaoNumericaCodigoBarra(3, valorConta,
								emitirContaHelper.getIdLocalidade(), emitirContaHelper.getIdImovel(), mesAno, digitoVerificadorConta, null,
								null, null, DocumentoTipo.CONTA, null, null, null, null, null, null);

				// Linha 24
				// Formata a representação númerica do código de barras
				String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11) + "-"
								+ representacaoNumericaCodBarra.substring(11, 12) + " " + representacaoNumericaCodBarra.substring(12, 23)
								+ "-" + representacaoNumericaCodBarra.substring(23, 24) + " "
								+ representacaoNumericaCodBarra.substring(24, 35) + "-" + representacaoNumericaCodBarra.substring(35, 36)
								+ " " + representacaoNumericaCodBarra.substring(36, 47) + "-"
								+ representacaoNumericaCodBarra.substring(47, 48);
				emitirContaHelper.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

				// Linha 25
				String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra.substring(0, 11)
								+ representacaoNumericaCodBarra.substring(12, 23) + representacaoNumericaCodBarra.substring(24, 35)
								+ representacaoNumericaCodBarra.substring(36, 47);
				emitirContaHelper.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);

			}

			// Linha28
			if(emitirContaHelper.getDataValidadeConta() != null && emitirContaHelper.getDataValidadeConta().compareTo(new Date()) == 1){
				emitirContaHelper.setDataValidade(Util.formatarData(emitirContaHelper.getDataValidadeConta()));

			}else{
				// soma 60 dias a data atual
				Date dataValidadeConta = Util.adicionarNumeroDiasDeUmaData(new Date(), 60);

				int ano = Util.getAno(dataValidadeConta);
				int mes = Util.getMes(dataValidadeConta);
				Calendar calendar = new GregorianCalendar();
				calendar.set(Calendar.MONTH, mes - 1);
				calendar.set(Calendar.YEAR, ano);

				Collection colecaoNacionalFeriado = getControladorUtil().pesquisarFeriadosNacionais();

				Collection colecaoDatasFeriados = new ArrayList();
				Iterator iterNacionalFeriado = colecaoNacionalFeriado.iterator();
				while(iterNacionalFeriado.hasNext()){
					NacionalFeriado nacionalFeriado = (NacionalFeriado) iterNacionalFeriado.next();
					colecaoDatasFeriados.add(nacionalFeriado.getData());
				}

				calendar.set(Calendar.DAY_OF_MONTH, Util.obterUltimoDiaUtilMes(mes, ano, colecaoDatasFeriados));

				dataValidadeConta = calendar.getTime();

				emitirContaHelper.setDataValidade(Util.formatarData(dataValidadeConta));

			}

			try{

				// Recuperando número do hidrômetro
				Integer idHistoricoInstalacaoHidr = null;
				String numeroHidrometro = null;
				BigDecimal valorAgua = emitirContaHelper.getValorAgua();
				BigDecimal valorEsgoto = emitirContaHelper.getValorEsgoto();

				// Se valor agua da conta for maior que zero
				if(valorAgua != null && valorAgua.compareTo(new BigDecimal(0.0)) > 0){
					idHistoricoInstalacaoHidr = this.repositorioFaturamento.pesquisarMedicaoAgua(emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia());
				}

				// Se valor esgoto da conta for maior que zero
				if(idHistoricoInstalacaoHidr == null && valorEsgoto != null && valorEsgoto.compareTo(new BigDecimal(0.0)) > 0){
					idHistoricoInstalacaoHidr = this.repositorioFaturamento.pesquisarMedicaoPoco(emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia());
				}

				if(idHistoricoInstalacaoHidr != null){
					numeroHidrometro = this.repositorioFaturamento.pesquisarNumeroHidrometro(idHistoricoInstalacaoHidr);
					emitirContaHelper.setNumeroHidrometro(numeroHidrometro);
				}

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			/**
			 * [UC0482] Na emissão de 2ª via de conta, emitir a mensagem de quitação de débito anual
			 * 
			 * @author Gicevalter Couto
			 * @created 12/08/2014
			 */
			String mesBaseEmissaoQuitacaoDebitoAnual = (String) ParametroFaturamento.P_MES_BASE_EMISSAO_QUITACAO_DEBITO_ANUAL.executar();
			if(mesBaseEmissaoQuitacaoDebitoAnual != null
							&& Short.valueOf(String.valueOf(emitirContaHelper.getAmReferencia()).substring(4, 6)).equals(
											Short.valueOf(mesBaseEmissaoQuitacaoDebitoAnual))){
				Integer anoAnteriorConta = Integer.valueOf(String.valueOf(emitirContaHelper.getAmReferencia()).substring(0, 4)) - 1;

				FiltroQuitacaoDebitoAnual filtroQuitacaoDebitoAnual = new FiltroQuitacaoDebitoAnual();
				filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.IMOVEL_ID, emitirContaHelper
								.getIdImovel()));
				filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.ANO_REFERENCIA,
								anoAnteriorConta));
				Collection<QuitacaoDebitoAnual> colecaoQuitacaoDebitoAnual = this.getControladorUtil().pesquisar(filtroQuitacaoDebitoAnual,
								QuitacaoDebitoAnual.class.getName());
				if(colecaoQuitacaoDebitoAnual.size() > 0){
					emitirContaHelper.setAnoQuitacaoDebitoAnual(anoAnteriorConta);
				}
			}

			colecaoEmitirContaHelper.add(emitirContaHelper);

			if(cobrarTaxaEmissaoConta){
				this.gerarDebitoACobrar(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(), DebitoTipo.TAXA_2_VIA_CONTA,
								null);
			}

		}

		return colecaoEmitirContaHelper;
	}

	public void enviarEmailImoveisContratoDemandaConsumoAVencer(Integer idGrupoFaturamento, Integer anoMesFaturamentoCorrente)
					throws ControladorException{

		try{
			List<Object[]> colImoveisContratoAVencer = repositorioFaturamento.pesquisarImoveisComContratoDemandaAVencer(idGrupoFaturamento);

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.NOTIFICACAO_CONTRATO_DEMANDA_CONSUMO_A_VENCER);

			String dsMensagem = "";

			if(envioEmail != null){

				String dsAssunto = envioEmail.getTituloMensagem();
				String dsRemetente = envioEmail.getEmailRemetente();
				String dsDestinatario = "";
				for(Object[] objeto : colImoveisContratoAVencer){
					dsMensagem = envioEmail.getCorpoMensagem();
					dsMensagem = dsMensagem.replace("{0}", Util.formatarAnoMesParaMesAno(anoMesFaturamentoCorrente));
					dsMensagem = dsMensagem.replace("{1}", (Integer) objeto[0] + "");
					dsDestinatario = (String) objeto[1];

					ServicosEmail.enviarMensagem(dsRemetente, dsDestinatario, dsAssunto, dsMensagem);
				}
			}
		}catch(Exception e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Fim - Atenção método provisório apenas para correção do faturamento imediato 08/05/2012
	 */

	// [SB0010] – Ajustar Valores por Categoria/Faixa
	public Object[] ajustarValoresPorCategoriaEFaixa(BigDecimal valorTotalAgua, BigDecimal valorFaturadoAgua, BigDecimal valorTotalEsgoto,
					BigDecimal valorFaturadoEsgoto, Collection colecaoContaCategoriaConsumoFaixaInserir,
					Collection colecaoContaCategoriaAtualizar, Imovel imovel, Conta conta){

		Object[] retorno = new Object[2];

		BigDecimal totaValorAguaCCCF = BigDecimal.ZERO;
		BigDecimal totaValorEsgotoCCCF = BigDecimal.ZERO;

		BigDecimal valorAguaCCCF = BigDecimal.ZERO;
		BigDecimal valorEsgotoCCCF = BigDecimal.ZERO;

		BigDecimal diferencaValorFaturadoAgua = BigDecimal.ZERO;
		BigDecimal diferencaValorFaturadoEsgoto = BigDecimal.ZERO;

		Categoria categoria = null;
		Integer idCategoria = null;

		if(!Util.isVazioOrNulo(colecaoContaCategoriaConsumoFaixaInserir)){

			Iterator it = colecaoContaCategoriaConsumoFaixaInserir.iterator();
			while(it.hasNext()){

				ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) it.next();

				// Caso seja a primeira faixa
				if(contaCategoriaConsumoFaixa.getConsumoFaixaInicio().intValue() == 0){

					// Água
					valorAguaCCCF = new BigDecimal(contaCategoriaConsumoFaixa.getConsumoFaixaFim()).multiply(contaCategoriaConsumoFaixa
									.getValorTarifaFaixa());

					// Esgoto
					valorEsgotoCCCF = (new BigDecimal(contaCategoriaConsumoFaixa.getConsumoFaixaFim()).multiply(contaCategoriaConsumoFaixa
									.getValorTarifaFaixa())).multiply(conta.getPercentualEsgoto());
					valorEsgotoCCCF = valorEsgotoCCCF.divide(new BigDecimal("100"), BigDecimal.ROUND_DOWN);
				}else{

					// Água
					if(contaCategoriaConsumoFaixa.getValorAgua() != null
									&& contaCategoriaConsumoFaixa.getValorAgua().compareTo(BigDecimal.ZERO) > 0){

						valorAguaCCCF = contaCategoriaConsumoFaixa.getValorAgua();

						if(valorTotalAgua != null && valorTotalAgua.compareTo(BigDecimal.ZERO) > 0){

							valorAguaCCCF = valorAguaCCCF.divide(valorTotalAgua, BigDecimal.ROUND_DOWN);
						}
					}

					if(valorFaturadoAgua != null){

						valorAguaCCCF = valorAguaCCCF.multiply(valorFaturadoAgua);
					}

					// Esgoto
					if(contaCategoriaConsumoFaixa.getValorEsgoto() != null
									&& contaCategoriaConsumoFaixa.getValorEsgoto().compareTo(BigDecimal.ZERO) > 0){

						valorEsgotoCCCF = contaCategoriaConsumoFaixa.getValorEsgoto();
					}

					if(valorTotalEsgoto != null && valorTotalEsgoto.compareTo(BigDecimal.ZERO) > 0){

						valorEsgotoCCCF = valorEsgotoCCCF.divide(valorTotalEsgoto, BigDecimal.ROUND_DOWN);
					}

					if(valorFaturadoEsgoto != null){

						valorEsgotoCCCF = valorEsgotoCCCF.multiply(valorFaturadoEsgoto);
					}
				}

				contaCategoriaConsumoFaixa.setValorAgua(valorAguaCCCF);
				contaCategoriaConsumoFaixa.setValorEsgoto(valorEsgotoCCCF);

				// Total
				totaValorAguaCCCF = totaValorAguaCCCF.add(valorAguaCCCF);
				totaValorEsgotoCCCF = totaValorEsgotoCCCF.add(valorEsgotoCCCF);

				valorAguaCCCF = BigDecimal.ZERO;
				valorEsgotoCCCF = BigDecimal.ZERO;
			}

			if(totaValorAguaCCCF.compareTo(valorFaturadoAgua) != 0){

				diferencaValorFaturadoAgua = valorFaturadoAgua.subtract(totaValorAguaCCCF);
			}else{

				diferencaValorFaturadoAgua = BigDecimal.ZERO;
			}

			if(totaValorEsgotoCCCF.compareTo(valorFaturadoEsgoto) != 0){

				diferencaValorFaturadoEsgoto = valorFaturadoEsgoto.subtract(totaValorEsgotoCCCF);
			}else{

				diferencaValorFaturadoEsgoto = BigDecimal.ZERO;
			}

			// Caso o somatório dos valores água e de esgoto por categoria/faixa esteja
			// diferente do valor total de água e de esgoto
			if(diferencaValorFaturadoAgua.compareTo(BigDecimal.ZERO) != 0 || diferencaValorFaturadoEsgoto.compareTo(BigDecimal.ZERO) != 0){

				ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixaAnterior = null;
				Iterator itColecaoContaCategoriaConsumoFaixaInserir = colecaoContaCategoriaConsumoFaixaInserir.iterator();

				while(itColecaoContaCategoriaConsumoFaixaInserir.hasNext()){

					ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) itColecaoContaCategoriaConsumoFaixaInserir
									.next();

					categoria = contaCategoriaConsumoFaixa.getContaCategoria().getComp_id().getCategoria();
					idCategoria = categoria.getId();

					if(contaCategoriaConsumoFaixaAnterior != null
									&& !contaCategoriaConsumoFaixaAnterior.getContaCategoria().getComp_id().getCategoria().getId()
													.equals(idCategoria)){

						// Faz o ajuste ao final da primeira categoria quando é categoria mista
						contaCategoriaConsumoFaixaAnterior.setValorAgua(contaCategoriaConsumoFaixaAnterior.getValorAgua().add(
										diferencaValorFaturadoAgua));
						contaCategoriaConsumoFaixaAnterior.setValorEsgoto(contaCategoriaConsumoFaixaAnterior.getValorEsgoto().add(
										diferencaValorFaturadoEsgoto));
						break;
					}else if(itColecaoContaCategoriaConsumoFaixaInserir.hasNext() == false){

						// Faz o ajuste ao final da categoria quando tem apenas uma categoria
						contaCategoriaConsumoFaixa.setValorAgua(contaCategoriaConsumoFaixa.getValorAgua().add(diferencaValorFaturadoAgua));
						contaCategoriaConsumoFaixa.setValorEsgoto(contaCategoriaConsumoFaixa.getValorEsgoto().add(
										diferencaValorFaturadoEsgoto));
					}

					contaCategoriaConsumoFaixaAnterior = contaCategoriaConsumoFaixa;
				}
			}

			// Faz o ajuste de Conta Categoria
			if(!Util.isVazioOrNulo(colecaoContaCategoriaAtualizar)){

				BigDecimal valorAguaCC = BigDecimal.ZERO;
				BigDecimal valorEsgotoCC = BigDecimal.ZERO;

				Short quantidadeEconomiasImovel = imovel.getQuantidadeEconomias();
				BigDecimal quantidadeEconomiasImovelBD = null;

				if(quantidadeEconomiasImovel != null){
					quantidadeEconomiasImovelBD = new BigDecimal(quantidadeEconomiasImovel);
				}

				Short quantidadeEconomiaCategoria = null;
				BigDecimal quantidadeEconomiaCategoriaBD = null;

				// Caso o somatório dos valores água e de esgoto por categoria esteja
				// diferente do valor total de água ou de esgoto adicionar a diferença
				// na primeira categoria
				BigDecimal valorAguaResiduo = BigDecimal.ZERO;
				if(valorFaturadoAgua != null){

					valorAguaResiduo = valorFaturadoAgua.subtract((valorFaturadoAgua.divide(quantidadeEconomiasImovelBD,
									BigDecimal.ROUND_FLOOR)).multiply(quantidadeEconomiasImovelBD));
				}

				BigDecimal valorEsgotoResiduo = BigDecimal.ZERO;
				if(valorFaturadoEsgoto != null){

					valorEsgotoResiduo = valorFaturadoEsgoto.subtract((valorFaturadoEsgoto.divide(quantidadeEconomiasImovelBD,
									BigDecimal.ROUND_FLOOR)).multiply(quantidadeEconomiasImovelBD));
				}

				for(ContaCategoria contaCategoria : (Collection<ContaCategoria>) colecaoContaCategoriaAtualizar){

					quantidadeEconomiaCategoria = contaCategoria.getQuantidadeEconomia();

					valorAguaCC = BigDecimal.ZERO;
					valorEsgotoCC = BigDecimal.ZERO;

					if(quantidadeEconomiasImovelBD != null && quantidadeEconomiasImovelBD.compareTo(BigDecimal.ZERO) == 1
									&& quantidadeEconomiaCategoria != null && !quantidadeEconomiaCategoria.equals(new Short("0"))){

						quantidadeEconomiaCategoriaBD = new BigDecimal(quantidadeEconomiaCategoria);

						if(valorFaturadoAgua != null){

							valorAguaCC = valorFaturadoAgua.divide(quantidadeEconomiasImovelBD, BigDecimal.ROUND_DOWN);
							valorAguaCC = (valorAguaCC.multiply(quantidadeEconomiaCategoriaBD)).add(valorAguaResiduo);
							valorAguaResiduo = BigDecimal.ZERO;
						}

						if(valorFaturadoEsgoto != null){

							valorEsgotoCC = valorFaturadoEsgoto.divide(quantidadeEconomiasImovelBD, BigDecimal.ROUND_DOWN);
							valorEsgotoCC = (valorEsgotoCC.multiply(quantidadeEconomiaCategoriaBD)).add(valorEsgotoResiduo);
							valorEsgotoResiduo = BigDecimal.ZERO;
						}
					}

					contaCategoria.setValorAgua(valorAguaCC);
					contaCategoria.setValorEsgoto(valorEsgotoCC);

				}
			}

		}else if(!Util.isVazioOrNulo(colecaoContaCategoriaAtualizar)){

			BigDecimal valorAguaCC = BigDecimal.ZERO;
			BigDecimal valorEsgotoCC = BigDecimal.ZERO;

			Short quantidadeEconomiasImovel = imovel.getQuantidadeEconomias();
			BigDecimal quantidadeEconomiasImovelBD = null;

			if(quantidadeEconomiasImovel != null){
				quantidadeEconomiasImovelBD = new BigDecimal(quantidadeEconomiasImovel);
			}

			Short quantidadeEconomiaCategoria = null;
			BigDecimal quantidadeEconomiaCategoriaBD = null;

			// Caso o somatório dos valores água e de esgoto por categoria esteja
			// diferente do valor total de água ou de esgoto adicionar a diferença
			// na primeira categoria
			BigDecimal valorAguaResiduo = BigDecimal.ZERO;
			if(valorFaturadoAgua != null){

				valorAguaResiduo = valorFaturadoAgua.subtract((valorFaturadoAgua
								.divide(quantidadeEconomiasImovelBD, BigDecimal.ROUND_FLOOR)).multiply(quantidadeEconomiasImovelBD));
			}

			BigDecimal valorEsgotoResiduo = BigDecimal.ZERO;
			if(valorFaturadoEsgoto != null){

				valorEsgotoResiduo = valorFaturadoEsgoto.subtract((valorFaturadoEsgoto.divide(quantidadeEconomiasImovelBD,
								BigDecimal.ROUND_FLOOR)).multiply(quantidadeEconomiasImovelBD));
			}

			for(ContaCategoria contaCategoria : (Collection<ContaCategoria>) colecaoContaCategoriaAtualizar){

				quantidadeEconomiaCategoria = contaCategoria.getQuantidadeEconomia();

				valorAguaCC = BigDecimal.ZERO;
				valorEsgotoCC = BigDecimal.ZERO;

				if(quantidadeEconomiasImovelBD != null && quantidadeEconomiasImovelBD.compareTo(BigDecimal.ZERO) == 1
								&& quantidadeEconomiaCategoria != null && !quantidadeEconomiaCategoria.equals(new Short("0"))){

					quantidadeEconomiaCategoriaBD = new BigDecimal(quantidadeEconomiaCategoria);

					if(valorFaturadoAgua != null){

						valorAguaCC = valorFaturadoAgua.divide(quantidadeEconomiasImovelBD, BigDecimal.ROUND_DOWN);
						valorAguaCC = (valorAguaCC.multiply(quantidadeEconomiaCategoriaBD)).add(valorAguaResiduo);
						valorAguaResiduo = BigDecimal.ZERO;
					}

					if(valorFaturadoEsgoto != null){

						valorEsgotoCC = valorFaturadoEsgoto.divide(quantidadeEconomiasImovelBD, BigDecimal.ROUND_DOWN);
						valorEsgotoCC = (valorEsgotoCC.multiply(quantidadeEconomiaCategoriaBD)).add(valorEsgotoResiduo);
						valorEsgotoResiduo = BigDecimal.ZERO;
					}
				}

				contaCategoria.setValorAgua(valorAguaCC);
				contaCategoria.setValorEsgoto(valorEsgotoCC);

			}
		}

		retorno[0] = colecaoContaCategoriaAtualizar;
		retorno[1] = colecaoContaCategoriaConsumoFaixaInserir;

		return retorno;

	}

	/**
	 * Remove todas as rotas da tabela faturamentoAtivCronRota
	 */
	public void removerRotasFaturamentoCronograma(FaturamentoGrupo faturamentoGrupo, RegistradorOperacao registradorOperacao,
					FaturamentoAtividadeCronograma faturamentoAtividadeCronograma){

		// o objeto FaturamentoGrupo vem so com id, aki preenchemos o resto dos
		// atributos
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, faturamentoGrupo.getId()));
		Collection colecaoFaturamentoGrupo;
		try{
			colecaoFaturamentoGrupo = getControladorUtil().pesquisar(filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

			faturamentoGrupo = (FaturamentoGrupo) Util.retonarObjetoDeColecao(colecaoFaturamentoGrupo);

			// remove as rotas da tabela FATURAMENTO_ATIV_CRON_ROTA
			FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();
			filtroFaturamentoAtivCronRota
							.adicionarCaminhoParaCarregamentoEntidade("faturamentoAtividadeCronograma.faturamentoGrupoCronogramaMensal.faturamentoGrupo");
			filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtivCronRota.FATURAMENTO_GRUPO_ID,
							faturamentoGrupo.getId()));
			filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_ID, faturamentoAtividadeCronograma
											.getId()));
			filtroFaturamentoAtivCronRota.setConsultaSemLimites(true);
			Collection colecaoRotasRemover = getControladorUtil().pesquisar(filtroFaturamentoAtivCronRota,
							FaturamentoAtivCronRota.class.getName());
			// FaturamentoAtivCronRota faturamentoAtivCronRotaTeste =
			// (FaturamentoAtivCronRota)
			// Util.retonarObjetoDeColecao(colecaoRotasRemover);

			Iterator iteratorRotaRemover = colecaoRotasRemover.iterator();
			FaturamentoAtivCronRota faturamentoAtivCronRota = null;
			// FaturamentoAtivCronRotaPK faturamentoAtivCronRotaPK = null;
			while(iteratorRotaRemover.hasNext()){
				faturamentoAtivCronRota = (FaturamentoAtivCronRota) iteratorRotaRemover.next();
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				registradorOperacao.registrarOperacao(faturamentoAtivCronRota);
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				getControladorUtil().remover(faturamentoAtivCronRota);
			}
		}catch(ControladorException e){
			e.printStackTrace();
		}
	}

	/**
	 * Método para auxiliar a inserção e atualização de faturamento cronograma ele é responsável por
	 * carregar uma coleção com as rotas do grupo remove
	 * as rotas da tabela FATURAMENTO_ATIV_CRON_ROTA e depois inseri as rotas habilitadas para cada
	 * atividade do grupo
	 * Para carregar a coleção de rotas habilitadas para a atividade é chamdo o método
	 * VerificarSituacaoAtividadeRota() que retorna a coleção
	 * desejada.
	 * 
	 * @throws ControladorException
	 */
	private void insercaoRotasFaturamentoCronogama(FaturamentoGrupo faturamentoGrupo, Collection faturamentoAtividadeCronogramas,
					RegistradorOperacao registradorOperacao, Integer anoMesReferencia) throws ControladorException{

		// carrega todas as rotas do grupo em uma coleção
		FiltroRota filtroRota = new FiltroRota();
		filtroRota.setConsultaSemLimites(true);
		filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.FATURAMENTO_GRUPO_ID, faturamentoGrupo.getId()));
		filtroRota.adicionarCaminhoParaCarregamentoEntidade(FiltroRota.SETOR_COMERCIAL);
		Collection colecaoRotasFaturamentoGrupo = getControladorUtil().pesquisar(filtroRota, Rota.class.getName());

		// intera a coleção de faturamentoAtividadeCronogramas para achar as
		// rotas habilitadas para cada atividade
		Iterator iteratorAtividades = faturamentoAtividadeCronogramas.iterator();
		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = null;
		while(iteratorAtividades.hasNext()){
			faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iteratorAtividades.next();
			if(faturamentoAtividadeCronograma.getComando() != null){
				Collection colecaoRotasHabilitadas = verificarSituacaoAtividadeRota(colecaoRotasFaturamentoGrupo,
								faturamentoAtividadeCronograma.getFaturamentoAtividade(), anoMesReferencia, true);

				if(!colecaoRotasHabilitadas.isEmpty()){
					Iterator iteratorAtividadesInserir = colecaoRotasHabilitadas.iterator();

					Rota rotaInserir = null;
					FaturamentoAtivCronRotaPK faturamentoAtivCronRotaPKInserir = null;
					FaturamentoAtivCronRota faturamentoAtivCronRotaInserir = null;
					while(iteratorAtividadesInserir.hasNext()){
						rotaInserir = (Rota) iteratorAtividadesInserir.next();

						faturamentoAtivCronRotaPKInserir = new FaturamentoAtivCronRotaPK();
						faturamentoAtivCronRotaPKInserir.setFaturamentoAtividadeCronogramaId(faturamentoAtividadeCronograma.getId());
						faturamentoAtivCronRotaPKInserir.setRotaId(rotaInserir.getId());

						faturamentoAtivCronRotaInserir = new FaturamentoAtivCronRota();
						faturamentoAtivCronRotaInserir.setComp_id(faturamentoAtivCronRotaPKInserir);
						faturamentoAtivCronRotaInserir.setUltimaAlteracao(new Date());
						faturamentoAtivCronRotaInserir.setFaturamentoAtividadeCronograma(faturamentoAtividadeCronograma);
						faturamentoAtivCronRotaInserir.setRota(rotaInserir);

						if(faturamentoAtividadeCronograma.getFaturamentoAtividade().getId().equals(FaturamentoAtividade.FATURAR_GRUPO)
										|| faturamentoAtividadeCronograma.getFaturamentoAtividade().getId()
														.equals(FaturamentoAtividade.GERAR_ARQUIVO_LEITURA)){

							/** alterado por pedro alexandre dia 27/06/2007 */
							/*
							 * String dataVencimentoGrupo = faturamentoGrupo.getDiaVencimento() +
							 * "/" + faturamentoGrupo.getMesAno();
							 * faturamentoAtivCronRotaInserir.setDataContaVencimento(Util.
							 * converteStringParaDate(dataVencimentoGrupo));
							 */
							// [UC0618] Obter data de vencimento do grupo.
							Date dataVencimentoGrupo = this.obterDataVencimentoGrupo(faturamentoGrupo.getId(), anoMesReferencia);
							Calendar calendarVencimentoGrupo = GregorianCalendar.getInstance();
							calendarVencimentoGrupo.setTime(dataVencimentoGrupo);
							dataVencimentoGrupo = Util.zerarHoraMinutoSegundo(calendarVencimentoGrupo.getTime());

							String parametroModeloArquivoLeiturasMicroletor = null;

							try{

								parametroModeloArquivoLeiturasMicroletor = ParametroMicromedicao.P_MODELO_ARQUIVO_LEITURA.executar();
							}catch(ControladorException e){

								throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_MODELO_ARQUIVO_LEITURA");
							}

							Calendar dataVencimentoAtual = Calendar.getInstance();
							dataVencimentoAtual.setTime(dataVencimentoGrupo);

							if(parametroModeloArquivoLeiturasMicroletor.equals(ConstantesSistema.DOIS.toString())){
								Calendar dataPrevistaCronograma = Calendar.getInstance();
								dataPrevistaCronograma.setTime(faturamentoAtividadeCronograma.getDataPrevista());
								dataPrevistaCronograma.add(Calendar.DAY_OF_YEAR, 40);

								if(dataVencimentoAtual.before(dataPrevistaCronograma)){
									dataVencimentoAtual.add(Calendar.MONTH, 1);
								}
							}

							faturamentoAtivCronRotaInserir.setDataContaVencimento(dataVencimentoAtual.getTime());
						}

						/** fim alteração */

						// Se já existe não precisa inserir
						FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();
						filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_ID,
										faturamentoAtividadeCronograma.getId()));
						filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtivCronRota.COMP_ID_ROTA,
										rotaInserir.getId()));

						Collection colFaturamentoAtivCronRota = this.getControladorUtil().pesquisar(filtroFaturamentoAtivCronRota,
										FaturamentoAtivCronRota.class.getName());

						if(colFaturamentoAtivCronRota == null || colFaturamentoAtivCronRota.isEmpty()){
							// ------------ REGISTRAR TRANSAÇÃO ----------------
							registradorOperacao.registrarOperacao(faturamentoAtivCronRotaInserir);
							// ------------ REGISTRAR TRANSAÇÃO ----------------
							getControladorUtil().inserir(faturamentoAtivCronRotaInserir);
						}
					}
				}else{
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.pesquisa.nenhuma.rota_habilitada_grupo");
				}
			}
		}
	}

	/**
	 * Metodo para validar: Caso usuário informe uma data prevista, de qualquer atividade, com o
	 * mês/ano maior que o mês ]/ano do cronograma+1, exibir
	 * a mensagem: "A data prevista da atividade nã pode ser superior a <<mês/ano do cronograma+1>>"
	 * 
	 * @param faturamentoAtividadeCronogramas
	 *            Descrição do parâmetro
	 * @param mesAno
	 * @throws ControladorException
	 */
	public void validarFaturamentoCronogramaAtividadeMaiorQueMesAnoCronograma(int anoMes, Collection faturamentoAtividadeCronogramas)
					throws ControladorException{

		Iterator iteratorFaturamentoAtividadeCronograma = faturamentoAtividadeCronogramas.iterator();

		int anoMesMenosDois = (Util.subtrairMesDoAnoMes(anoMes, 2));

		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = null;
		// String mesAnoAtividade = null;
		String mes = null;
		String ano = null;
		// Cria objeto
		String dataAtividade = null;
		int anoMesAtividade = 0;
		while(iteratorFaturamentoAtividadeCronograma.hasNext()){
			faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iteratorFaturamentoAtividadeCronograma.next();

			if(faturamentoAtividadeCronograma.getDataPrevista() != null){
				dataAtividade = Util.formatarDataComHora(faturamentoAtividadeCronograma.getDataPrevista());

				// mesAnoAtividade = dataAtividade.substring(3, 10);
				// Concatena ano mes
				mes = dataAtividade.substring(3, 5);
				ano = dataAtividade.substring(6, 10);
				anoMesAtividade = Integer.parseInt((ano + mes));

				if(anoMesAtividade < anoMesMenosDois){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.faturamento.mes_ano_atividade_menor_mes_ano_cronograma", null,
									Util.formatarAnoMesParaMesAno(anoMesMenosDois));
				}
			}
		}

	}

	/**
	 * O método recebe uma coleção de faturamento atividades acha as que tem atividade predecessora
	 * e compara a data desta com a data da sua
	 * predecessora.
	 * 
	 * @param faturamentoAtividadeCronogramas
	 *            Descrição do parâmetro
	 * @param faturamentoGrupoCronogramaMensal
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public void validarFaturamentoCronograma(Collection faturamentoAtividadeCronogramas) throws ControladorException{

		// ----------Parte de validação de datas em seguência -----------//
		Iterator iteratorFaturamentoAtividadeSequencia = faturamentoAtividadeCronogramas.iterator();
		Collection colecaoDatasPreenchidas = new ArrayList();

		FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaSegundo = null;
		FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaPrimeiro = null;
		// monta uma coleção com as datas obrigatorias e/ou não
		// obrigatoria(essas quando preenchidas)
		while(iteratorFaturamentoAtividadeSequencia.hasNext()){
			faturamentoAtividadeCronogramaPrimeiro = (FaturamentoAtividadeCronograma) iteratorFaturamentoAtividadeSequencia.next();
			// teste para saber se atividade é obrigatoria, se não for, se ela
			// está preenchida
			if(faturamentoAtividadeCronogramaPrimeiro.getFaturamentoAtividade().getIndicadorObrigatoriedadeAtividade()
							.equals(ConstantesSistema.INDICADOR_USO_ATIVO)){
				colecaoDatasPreenchidas.add(faturamentoAtividadeCronogramaPrimeiro);
			}else if(faturamentoAtividadeCronogramaPrimeiro.getDataPrevista() != null){
				colecaoDatasPreenchidas.add(faturamentoAtividadeCronogramaPrimeiro);
			}

		}
		// Aqui começa o teste se as datas estão em seguencia
		Iterator iteratorTesteSeguenciaDatas = colecaoDatasPreenchidas.iterator();

		faturamentoAtividadeCronogramaPrimeiro = (FaturamentoAtividadeCronograma) iteratorTesteSeguenciaDatas.next();
		while(iteratorTesteSeguenciaDatas.hasNext()){
			faturamentoAtividadeCronogramaSegundo = (FaturamentoAtividadeCronograma) iteratorTesteSeguenciaDatas.next();
			if(faturamentoAtividadeCronogramaPrimeiro.getDataPrevista().after(faturamentoAtividadeCronogramaSegundo.getDataPrevista())){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.faturamento_ordem_datas");
			}
			faturamentoAtividadeCronogramaPrimeiro = faturamentoAtividadeCronogramaSegundo;
		}

		// -----------Parte de validação de
		// predecessora--------------------------//
		// iterator principal em qual procuro se a atividade tem predecessora
		Iterator iteratorFaturamentoAtividadeCronogramaPrincipal = faturamentoAtividadeCronogramas.iterator();
		// objeto principal
		FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaPrincipal = null;
		// objeto de teste(secundario)
		FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaTeste = null;
		while(iteratorFaturamentoAtividadeCronogramaPrincipal.hasNext()){
			faturamentoAtividadeCronogramaPrincipal = (FaturamentoAtividadeCronograma) iteratorFaturamentoAtividadeCronogramaPrincipal
							.next();
			// testa se a atividade Principal tem predecessora
			if(faturamentoAtividadeCronogramaPrincipal.getFaturamentoAtividade().getFaturamentoAtividadePrecedente() != null){
				Iterator iteratorFaturamentoAtividadeCronogramaTestado = faturamentoAtividadeCronogramas.iterator();
				// roda a coleção a procura da predecessora da principal
				while(iteratorFaturamentoAtividadeCronogramaTestado.hasNext()){
					faturamentoAtividadeCronogramaTeste = (FaturamentoAtividadeCronograma) iteratorFaturamentoAtividadeCronogramaTestado
									.next();
					// testa se o objeto corrente teste é o predecessor da
					// principal
					// caso seja testa se a atividade predecessora é inferior ou
					// igual a principal
					// se não for causa uma exceção
					if(faturamentoAtividadeCronogramaPrincipal.getFaturamentoAtividade().getFaturamentoAtividadePrecedente().getId()
									.equals(faturamentoAtividadeCronogramaTeste.getFaturamentoAtividade().getId())
									&& faturamentoAtividadeCronogramaTeste.getFaturamentoAtividade().getIndicadorObrigatoriedadeAtividade()
													.equals(ConstantesSistema.SIM)){

						if(faturamentoAtividadeCronogramaTeste.getDataPrevista() == null){
							sessionContext.setRollbackOnly();
							throw new ControladorException("atencao.faturamento.data_predecessora_nula");
						}

						if(faturamentoAtividadeCronogramaTeste.getDataPrevista().after(
										faturamentoAtividadeCronogramaPrincipal.getDataPrevista())){
							sessionContext.setRollbackOnly();
							throw new ControladorException("atencao.data_invalida.atividade_predecessora");
						}
						break;
					}
				}
			}
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param faturamentoAtividadeCronogramas
	 *            Descrição do parâmetro
	 * @param faturamentoGrupoCronogramaMensal
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	private void inserirFaturamentoAtividadeCronograma(Collection faturamentoAtividadeCronogramas,
					FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal, RegistradorOperacao registradorOperacao)
					throws ControladorException{

		// Prepara iterator para percorrer a coleçao de Faturamento
		// Atividade
		// Cronograma
		Iterator iteratorFaturamentoCronograma = faturamentoAtividadeCronogramas.iterator();
		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = new FaturamentoAtividadeCronograma();
		// FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaVelho =
		// null;

		Collection faturamentoAtividadeCronogramasNovas = new ArrayList();
		while(iteratorFaturamentoCronograma.hasNext()){
			faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iteratorFaturamentoCronograma.next();
			faturamentoAtividadeCronograma.setFaturamentoGrupoCronogramaMensal(faturamentoGrupoCronogramaMensal);

			// Testa se data prevista é maior ou igual a data atual
			// Comparar atraves do mes ano do cronograma mensal
			Calendar dataPrevistaTeste = Calendar.getInstance();

			dataPrevistaTeste.setTime(faturamentoAtividadeCronograma.getDataPrevista());

			/*
			 * int ano = dataPrevistaTeste.get(Calendar.YEAR); int mes =
			 * dataPrevistaTeste.get(Calendar.MONTH) + 1; String anoMes = null; if (mes <
			 * 10) { anoMes = ano + "0" + mes; } else { anoMes = ano + "" + mes; }
			 * int mesMenoUm = dataPrevistaTeste.get(Calendar.MONTH) - 1; String anoMesMenosUm =
			 * null; if (mes < 10) { anoMesMenosUm = ano + "0" +
			 * mesMenoUm; } else { anoMesMenosUm = ano + "" + mesMenoUm; }
			 */

			// if (faturamentoGrupoCronogramaMensal.getAnoMesReferencia()
			// .intValue() <= Integer.parseInt(anoMes)) {
			faturamentoAtividadeCronograma.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			registradorOperacao.registrarOperacao(faturamentoAtividadeCronograma);
			// ------------ REGISTRAR TRANSAÇÃO ----------------
			if(faturamentoAtividadeCronograma.getId() != null
							&& !faturamentoAtividadeCronograma.getId().toString().trim().equalsIgnoreCase("")){
				getControladorUtil().atualizar(faturamentoAtividadeCronograma);

			}else{
				faturamentoAtividadeCronograma.setId((Integer) getControladorUtil().inserir(faturamentoAtividadeCronograma));
				faturamentoAtividadeCronogramasNovas.add(faturamentoAtividadeCronograma);
			}

			// Pega id e guarda numa colecao p necessidade de ser
			// removido
			// por alguma falha no processo.
			// faturamentoAtividadeCronogramaVelho =
			// faturamentoAtividadeCronograma;

			// } else {
			// throw new
			// ControladorException("atencao.nao_cadastrado.consumo_cronograma_anterior");
			// sessionContext.setRollbackOnly();
			// throw new ControladorException(
			// "atencao.faturamento_atividade_menor");
			// }
			if(faturamentoAtividadeCronograma.getComando() == null){
				removerRotasFaturamentoCronograma(faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(), registradorOperacao,
								faturamentoAtividadeCronograma);
			}
		}

		insercaoRotasFaturamentoCronogama(faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(), faturamentoAtividadeCronogramas,
						registradorOperacao, faturamentoGrupoCronogramaMensal.getAnoMesReferencia());
	}

	public String atualizarFaturamentoGrupoCronogramaMensal(FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal,
					Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaAtualizar, Usuario usuarioLogado)
					throws ControladorException{

		String referenciasAtualizadas = "";
		try{

			Collection<NacionalFeriado> colecaoNacionalFeriado = getControladorUtil().pesquisarFeriadosNacionais();
			Collection<MunicipioFeriado> colecaoMunicipioFeriado = getControladorUtil().pesquisarFeriadosMunicipais();

			// [SB0003] - Definir período de flutuação da data prevista
			// da atividade
			for(FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaAtual : colecaoFaturamentoAtividadeCronogramaAtualizar){

				FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronogramaAnterior = new FiltroFaturamentoAtividadeCronograma();
				filtroFaturamentoAtividadeCronogramaAnterior.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA, Util
												.subtrairMesDoAnoMes(faturamentoGrupoCronogramaMensal.getAnoMesReferencia(), 1)));
				filtroFaturamentoAtividadeCronogramaAnterior.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
								faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getId()));

				filtroFaturamentoAtividadeCronogramaAnterior.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, faturamentoAtividadeCronogramaAtual
												.getFaturamentoAtividade().getId()));

				Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaRefenciaAnterior = getControladorUtil()
								.pesquisar(filtroFaturamentoAtividadeCronogramaAnterior, FaturamentoAtividadeCronograma.class.getName());

				Date dataMinimaPermitida = null;
				Date dataMaximaPermitida = null;

				String pQuantidadeMinimaDiasCicloFaturamento = null;
				try{

					pQuantidadeMinimaDiasCicloFaturamento = ((String) ParametroFaturamento.P_QUANTIDADE_MINIMA_DIAS_CICLO_FATURAMENTO
									.executar(this));
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null,
									"P_QUANTIDADE_MINIMA_DIAS_CICLO_FATURAMENTO");
				}

				String pQuantidadeMaximaDiasCicloFaturamento = null;
				try{

					pQuantidadeMaximaDiasCicloFaturamento = ((String) ParametroFaturamento.P_QUANTIDADE_MAXIMA_DIAS_CICLO_FATURAMENTO
									.executar(this));
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null,
									"P_QUANTIDADE_MAXIMA_DIAS_CICLO_FATURAMENTO");
				}

				if(!Util.isVazioOrNulo(colecaoFaturamentoAtividadeCronogramaRefenciaAnterior)){

					FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaAnterior = (FaturamentoAtividadeCronograma) Util
									.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRefenciaAnterior);

					if(faturamentoAtividadeCronogramaAnterior.getDataRealizacao() != null){

						dataMinimaPermitida = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaAnterior.getDataRealizacao(),
										Util.obterInteger(pQuantidadeMinimaDiasCicloFaturamento));
						dataMaximaPermitida = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaAnterior.getDataRealizacao(),
										Util.obterInteger(pQuantidadeMaximaDiasCicloFaturamento));

					}else if(faturamentoAtividadeCronogramaAnterior.getDataPrevista() != null){

						dataMinimaPermitida = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaAnterior.getDataPrevista(),
										Util.obterInteger(pQuantidadeMinimaDiasCicloFaturamento));
						dataMaximaPermitida = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaAnterior.getDataPrevista(),
										Util.obterInteger(pQuantidadeMaximaDiasCicloFaturamento));
					}
				}

				if(dataMinimaPermitida == null || dataMaximaPermitida == null){

					dataMinimaPermitida = new Date();
					dataMinimaPermitida = Util.zerarHoraMinutoSegundo(dataMinimaPermitida);

					Integer referenciaSeguinte = null;

					Integer referenciaDataCorrente = Util.recuperaAnoMesDaData(dataMinimaPermitida);

					if(Util.compararAnoMesReferencia(faturamentoGrupoCronogramaMensal.getAnoMesReferencia(), referenciaDataCorrente, ">")
									|| Util.compararAnoMesReferencia(faturamentoGrupoCronogramaMensal.getAnoMesReferencia(),
													referenciaDataCorrente, "=")){

						referenciaSeguinte = Util.somaMesAnoMesReferencia(faturamentoGrupoCronogramaMensal.getAnoMesReferencia(), 1);
					}else{

						referenciaSeguinte = Util.somaMesAnoMesReferencia(referenciaDataCorrente, 1);
					}

					Calendar calendarUltimoDiaMesReferenciaSeguinte = new GregorianCalendar();
					calendarUltimoDiaMesReferenciaSeguinte.set(Calendar.MONTH, Util.obterMes(referenciaSeguinte) - 1);
					calendarUltimoDiaMesReferenciaSeguinte.set(Calendar.YEAR, Util.obterAno(referenciaSeguinte));
					calendarUltimoDiaMesReferenciaSeguinte.set(Calendar.DATE,
									calendarUltimoDiaMesReferenciaSeguinte.getActualMaximum(Calendar.DAY_OF_MONTH));
					dataMaximaPermitida = Util.zerarHoraMinutoSegundo(calendarUltimoDiaMesReferenciaSeguinte.getTime());
				}

				if(!Util.ehDiaUtil(dataMinimaPermitida, colecaoNacionalFeriado, colecaoMunicipioFeriado)){

					dataMinimaPermitida = Util.obterProximoDiaUtil(dataMinimaPermitida, colecaoNacionalFeriado, colecaoMunicipioFeriado);
				}

				if(!Util.ehDiaUtil(dataMaximaPermitida, colecaoNacionalFeriado, colecaoMunicipioFeriado)){

					dataMaximaPermitida = Util.obterProximoDiaUtil(dataMaximaPermitida, colecaoNacionalFeriado, colecaoMunicipioFeriado);
				}

				// [FS0005] - Validar Datas Previstas
				if(faturamentoAtividadeCronogramaAtual.getDataPrevista().compareTo(dataMinimaPermitida) == -1
								|| faturamentoAtividadeCronogramaAtual.getDataPrevista().compareTo(dataMaximaPermitida) == 1){

					throw new ControladorException("atencao.data_prevista_atividade_periodo_nao_permitido", null,
									faturamentoAtividadeCronogramaAtual.getFaturamentoAtividade().getDescricao(),
									Util.formatarData(dataMinimaPermitida), Util.formatarData(dataMaximaPermitida));
				}
			}

			Integer id = null;

			// ------------ REGISTRAR TRANSAÇÃO ----------------------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ATUALIZAR_CRONOGRAMA_FATURAMENTO,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
			// ------------ REGISTRAR TRANSAÇÃO ----------------------------

			// Procura o último registro, do grupo informado, salvo na tabela.
			/* int idMaximo = */getControladorUtil().valorMaximo(FaturamentoGrupoCronogramaMensal.class,
							FiltroFaturamentoGrupoCronogramaMensal.ID, FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO,
							faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getId().toString());

			// Procura se ja existe alguma FaturaGrupoCronogramaMensal com o
			// mesmo mes ano
			FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA, faturamentoGrupoCronogramaMensal
											.getAnoMesReferencia()));

			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO, faturamentoGrupoCronogramaMensal
											.getFaturamentoGrupo().getId()));

			Collection faturamentoGrupoCronogramaMensais = getControladorUtil().pesquisar(filtroFaturamentoGrupoCronogramaMensal,
							FaturamentoGrupoCronogramaMensal.class.getName());

			// faz o controle de concorrencia
			if(!faturamentoGrupoCronogramaMensais.isEmpty()){
				FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensalNaBase = (FaturamentoGrupoCronogramaMensal) faturamentoGrupoCronogramaMensais
								.iterator().next();

				if((faturamentoGrupoCronogramaMensalNaBase.getUltimaAlteracao()
								.after(faturamentoGrupoCronogramaMensal.getUltimaAlteracao()))){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");
				}

			}
			// faz o controle de concorrencia

			// Pega o último objeto FaturamentoGrupo para comparação de datas.
			FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();

			filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, faturamentoGrupoCronogramaMensal
							.getFaturamentoGrupo().getId()));

			Collection faturamentoGrupos = getControladorUtil().pesquisar(filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

			if(!faturamentoGrupos.isEmpty()){
				FaturamentoGrupo faturamentoGrupoNaBase = (FaturamentoGrupo) faturamentoGrupos.iterator().next();

				// Inicio teste de datas para validação da inserçao
				if(faturamentoGrupoNaBase.getAnoMesReferencia().compareTo(faturamentoGrupoCronogramaMensal.getAnoMesReferencia()) == 1){
					// || faturamentoGrupoNaBase.getAnoMesReferencia().compareTo(
					// faturamentoGrupoCronogramaMensal
					// .getAnoMesReferencia()) == 0) {
					// criar um erro de data (data informada tem q ser superior
					// a data ##/####)
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.data_invalida.ano_mes_inferior", null,
									Util.formatarAnoMesParaMesAno(faturamentoGrupoNaBase.getAnoMesReferencia().toString()));
				}
			}
			faturamentoGrupoCronogramaMensal.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			registradorOperacao.registrarOperacao(faturamentoGrupoCronogramaMensal);
			faturamentoGrupoCronogramaMensal.getOperacaoEfetuada().setArgumentoValor(faturamentoGrupoCronogramaMensal.getId());
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			if(faturamentoGrupoCronogramaMensal.getId() == null){
				// Grave o faturamentoGrupoCronogramaMensal na base e retorna o
				// id
				FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensalid = (FaturamentoGrupoCronogramaMensal) getControladorUtil()
								.inserir(faturamentoGrupoCronogramaMensal);
				id = faturamentoGrupoCronogramaMensalid.getId();
				// Seta um objeto com o id retornado
				faturamentoGrupoCronogramaMensal.setId(id);
			}else{

				getControladorUtil().atualizar(faturamentoGrupoCronogramaMensal);
				referenciasAtualizadas = Util.formatarAnoMesParaMesAno(faturamentoGrupoCronogramaMensal.getAnoMesReferencia());
			}

			// chama o metodo que remove as rotas
			// this.removerRotasFaturamentoCronograma(faturamentoGrupoCronogramaMensal
			// .getFaturamentoGrupo(), registradorOperacao);

			// se vinher do atualizar remove todos os regitros da tabela para a
			// re-inserção
			// Iterator iteratorFaturamentoAtividadeCronogramaRemocao =
			// colecaoTodasAtividades
			// .iterator();
			// FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaRemocao
			// = null;
			// while (iteratorFaturamentoAtividadeCronogramaRemocao.hasNext()) {
			// faturamentoAtividadeCronogramaRemocao =
			// (FaturamentoAtividadeCronograma)
			// iteratorFaturamentoAtividadeCronogramaRemocao
			// .next();
			// // ------------ REGISTRAR TRANSAÇÃO ----------------
			// registradorOperacao
			// .registrarOperacao(faturamentoAtividadeCronogramaRemocao);
			// // ------------ REGISTRAR TRANSAÇÃO ----------------
			// if (faturamentoAtividadeCronogramaRemocao.getId() != null) {
			// getControladorUtil().remover(
			// faturamentoAtividadeCronogramaRemocao);
			// }
			// faturamentoAtividadeCronogramaRemocao.setId(null);
			// }

			String pAjustarCronogramaAutomaticamente = null;
			try{

				pAjustarCronogramaAutomaticamente = ((String) ParametroFaturamento.P_AJUSTA_CRONOGRAMA_AUTOMATICAMENTE.executar(this));
			}catch(ControladorException e){

				throw new ActionServletException("atencao.sistemaparametro_inexistente", "P_AJUSTA_CRONOGRAMA_AUTOMATICAMENTE");
			}

			if(pAjustarCronogramaAutomaticamente.equals(ConstantesSistema.SIM.toString())){

				List<FaturamentoGrupoCronogramaMensal> colecaoFaturamentoGrupoCronogramaMensalAbertosGrupo = (List<FaturamentoGrupoCronogramaMensal>) repositorioFaturamento
								.pesquisarFaturamentoGrupoCronogramaMensalReferenciaMaior(faturamentoGrupoCronogramaMensal
												.getFaturamentoGrupo().getId(), faturamentoGrupoCronogramaMensal.getFaturamentoGrupo()
												.getAnoMesReferencia());

				if(!Util.isVazioOrNulo(colecaoFaturamentoGrupoCronogramaMensalAbertosGrupo)){

					this.inserirFaturamentoAtividadeCronograma(colecaoFaturamentoAtividadeCronogramaAtualizar,
									faturamentoGrupoCronogramaMensal, registradorOperacao);

					/*
					 * Para definição das datas previstas das atividades dos cronogramas
					 * subsequentes, o sistema calcula o número de dias entre a data prevista da
					 * atividade do cronograma alterado antes e após a alteração e prorroga/antecipa
					 * as datas previstas dos cronogramas subsequentes com base nesta diferença.
					 */
					int indexLista = 0;
					for(int i = 1; i <= colecaoFaturamentoGrupoCronogramaMensalAbertosGrupo.size(); i++){

						FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensalAberto = colecaoFaturamentoGrupoCronogramaMensalAbertosGrupo
										.get(indexLista);

						// Atualiza o cronograma mensal
						// ------------ REGISTRAR TRANSAÇÃO ----------------------------
						RegistradorOperacao registradorOperacaoCronogramaAberto = new RegistradorOperacao(
										Operacao.OPERACAO_ATUALIZAR_CRONOGRAMA_FATURAMENTO, new UsuarioAcaoUsuarioHelper(usuarioLogado,
														UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						faturamentoGrupoCronogramaMensalAberto.setUltimaAlteracao(new Date());

						registradorOperacaoCronogramaAberto.registrarOperacao(faturamentoGrupoCronogramaMensalAberto);
						faturamentoGrupoCronogramaMensalAberto.getOperacaoEfetuada().setArgumentoValor(
										faturamentoGrupoCronogramaMensalAberto.getId());
						getControladorUtil().atualizar(faturamentoGrupoCronogramaMensalAberto);

						referenciasAtualizadas += ", "
										+ Util.formatarAnoMesParaMesAno(faturamentoGrupoCronogramaMensalAberto.getAnoMesReferencia());

						FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronogramaNaoRealizados = new FiltroFaturamentoAtividadeCronograma();
						filtroFaturamentoAtividadeCronogramaNaoRealizados.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID,
										faturamentoGrupoCronogramaMensalAberto.getId()));
						filtroFaturamentoAtividadeCronogramaNaoRealizados.adicionarParametro(new ParametroNulo(
										FiltroFaturamentoAtividadeCronograma.DATA_REALIZADA));
						filtroFaturamentoAtividadeCronogramaNaoRealizados
										.setCampoOrderBy(FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID);
						filtroFaturamentoAtividadeCronogramaNaoRealizados
										.adicionarCaminhoParaCarregamentoEntidade(FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE);

						Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaAbertosGrupos = getControladorUtil()
										.pesquisar(filtroFaturamentoAtividadeCronogramaNaoRealizados,
														FaturamentoAtividadeCronograma.class.getName());

						if(!Util.isVazioOrNulo(colecaoFaturamentoAtividadeCronogramaAtualizar)){

							for(FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaAberto : colecaoFaturamentoAtividadeCronogramaAbertosGrupos){

								for(FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaAtualizadoTela : colecaoFaturamentoAtividadeCronogramaAtualizar){

									if(faturamentoAtividadeCronogramaAtualizadoTela.getFaturamentoAtividade().getId()
													.equals(faturamentoAtividadeCronogramaAberto.getFaturamentoAtividade().getId())){

										Date dataProjetada = null;
										Integer quantidadeMesesDiferenca = Util.subtrairReferenciasAnoMes(
														faturamentoGrupoCronogramaMensal.getAnoMesReferencia(),
														faturamentoGrupoCronogramaMensalAberto.getAnoMesReferencia());


										Integer quantidadeDias = quantidadeMesesDiferenca.intValue() * 30;

										if(faturamentoGrupoCronogramaMensal.getAnoMesReferencia().intValue() < faturamentoGrupoCronogramaMensalAberto
														.getAnoMesReferencia()){


											dataProjetada = Util.adicionarNumeroDiasDeUmaData(
															faturamentoAtividadeCronogramaAtualizadoTela.getDataPrevista(), quantidadeDias);
										}else{

											dataProjetada = Util.subtrairNumeroDiasDeUmaData(
															faturamentoAtividadeCronogramaAtualizadoTela.getDataPrevista(), quantidadeDias);
										}

										// Caso a data projetada seja um dia não útil, a data
										// prevista será o próximo dia útil
										if(!Util.ehDiaUtil(dataProjetada, colecaoNacionalFeriado, colecaoMunicipioFeriado)){

											dataProjetada = Util.obterProximoDiaUtil(dataProjetada, colecaoNacionalFeriado,
															colecaoMunicipioFeriado);
										}

										faturamentoAtividadeCronogramaAberto.setDataPrevista(dataProjetada);

										if(faturamentoAtividadeCronogramaAberto.getComando() != null){

											faturamentoAtividadeCronogramaAberto.setComando(dataProjetada);
										}

										break;
									}
								}
							}

							if(!Util.isVazioOrNulo(colecaoFaturamentoAtividadeCronogramaAbertosGrupos)){

								// Inclui as atividades do cronograma
								this.inserirFaturamentoAtividadeCronograma(colecaoFaturamentoAtividadeCronogramaAbertosGrupos,
											faturamentoGrupoCronogramaMensalAberto, registradorOperacaoCronogramaAberto);
							}
						}

						indexLista++;
					}
				}
			}else{

				this.inserirFaturamentoAtividadeCronograma(colecaoFaturamentoAtividadeCronogramaAtualizar,
								faturamentoGrupoCronogramaMensal, registradorOperacao);
			}

		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return referenciasAtualizadas;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param usuarioLogado
	 * @param localidade
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public void atualizarFaturamentoAtividadeCronograma(FaturamentoAtividadeCronograma faturamentoAtividadeCronograma,
					RegistradorOperacao registradorOperacao) throws ControladorException{

		// -----VALIDAÇÃO DOS TIMESTAMP PARA ATUALIZAÇÃO DE CADASTRO

		// Validação para Setor Comercial
		if(faturamentoAtividadeCronograma != null){
			// Cria o filtro
			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = FaturamentoAtividadeCronograma.class.getName();

			// Seta os parametros do filtro
			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtividadeCronograma.ID,
							faturamentoAtividadeCronograma.getId()));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection faturamentoAtividadeCronogramas = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
							nomePacoteObjeto);

			FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaNaBase = (FaturamentoAtividadeCronograma) Util
							.retonarObjetoDeColecao(faturamentoAtividadeCronogramas);

			// Verifica se a data de alteração do objeto gravado na base é
			// maior que a na instancia
			if((faturamentoAtividadeCronogramaNaBase.getUltimaAlteracao().after(faturamentoAtividadeCronograma.getUltimaAlteracao()))){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.atualizacao.timestamp");
			}

			// Seta a data/hora
			faturamentoAtividadeCronograma.setUltimaAlteracao(new Date());

		}

		registradorOperacao.registrarOperacao(faturamentoAtividadeCronograma);
		// Atualiza objeto
		getControladorUtil().atualizar(faturamentoAtividadeCronograma);
	}

	/**
	 * [UC0187] Inserir Guia de Pagamento
	 * Processos das execuções especiais pendentes de cobrança do valor de sucumbência
	 * 
	 * @date 08/09/2014
	 * @author Gicevalter Couto
	 */
	public Collection<Integer> pesquisarProcessosExecucaoEspeciaisPendentesCobranca(Integer idImovel) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarProcessosExecucaoEspeciaisPendentesCobranca(idImovel, CobrancaSituacao.EXECUCAO_FISCAL,
							DebitoTipo.SUCUMBENCIA);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * [SB0002] - Excluir Comando de Atividade de Faturamento
	 * 
	 * @throws ControladorException
	 */
	public void removerComandoAtividadeFaturamento(String[] ids, Usuario usuarioLogado) throws ControladorException{

		int indexArray = 0;
		String idsConcatenados = "";

		while(indexArray < ids.length){
			if(idsConcatenados.equalsIgnoreCase("")){
				idsConcatenados = ids[indexArray];
			}else{
				idsConcatenados = idsConcatenados + ", " + ids[indexArray];
			}
			indexArray++;
		}

		Collection colecaoFaturamentoAtividadeCronograma;

		try{

			colecaoFaturamentoAtividadeCronograma = this.repositorioFaturamento.buscarFaturamentoAtividadeCronograma(idsConcatenados);

			/*
			 * Atualiza a data e hora do comando (FTAC_TMCOMANDO=Null) na tabela
			 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=Id da Atividade e
			 * FTCM_ID=FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL para FTGR_ID=Id do
			 * Grupo de Faturamento e FTCM_AMREFERENCIA=Referência
			 */

			Iterator colecaoFaturamentoAtividadeCronogramaIterator = colecaoFaturamentoAtividadeCronograma.iterator();
			FaturamentoAtividadeCronograma faturamentoAtividadeCronograma;

			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_REMOVER_COMANDO_ATIVIDADE_FATURAMENTO,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			while(colecaoFaturamentoAtividadeCronogramaIterator.hasNext()){
				faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) colecaoFaturamentoAtividadeCronogramaIterator.next();

				faturamentoAtividadeCronograma.setComando(null);
				faturamentoAtividadeCronograma.setUltimaAlteracao(new Date());

				this.atualizarFaturamentoAtividadeCronograma(faturamentoAtividadeCronograma, registradorOperacao);

				// this.repositorioFaturamento.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma.getId());
				this.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma.getId(), registradorOperacao);
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0116] Inserir Cronograma Faturamento
	 */
	public String inserirFaturamentoGrupoCronogramaMensal(FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal,
					Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaInserir, Usuario usuarioLogado,
					Integer quantidadeCronogramas) throws ControladorException{

		String referenciasInseridas = "";

		try{

			// [FS0002] - Validar referência do cronograma
			if(faturamentoGrupoCronogramaMensal.getAnoMesReferencia().compareTo(
							faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getAnoMesReferencia()) == -1){

				throw new ControladorException("atencao.data_invalida.ano_mes_inferior", null,
								Util.formatarAnoMesParaMesAno(faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getAnoMesReferencia()
												.toString()));
			}

			// [FS0008] - Validar Quantidade de Cronogramas
			String pQuantidadeMaximaCronogramaFaturamento = null;
			try{

				pQuantidadeMaximaCronogramaFaturamento = ((String) ParametroFaturamento.P_QUANTIDADE_MAXIMA_CRONOGRAMA_FATURAMENTO
								.executar(this));
			}catch(ControladorException e){

				throw new ActionServletException("atencao.sistemaparametro_inexistente", "P_QUANTIDADE_MAXIMA_CRONOGRAMA_FATURAMENTO");
			}

			Collection<FaturamentoGrupoCronogramaMensal> colecaoFaturamentoGrupoCronogramaMensalAbertosGrupo = repositorioFaturamento
							.pesquisarFaturamentoGrupoCronogramaMensalReferenciaMaior(faturamentoGrupoCronogramaMensal
											.getFaturamentoGrupo().getId(), faturamentoGrupoCronogramaMensal.getFaturamentoGrupo()
											.getAnoMesReferencia());

			if(quantidadeCronogramas.intValue() > (Util.obterInteger(pQuantidadeMaximaCronogramaFaturamento).intValue() - colecaoFaturamentoGrupoCronogramaMensalAbertosGrupo
							.size())){

				throw new ControladorException("atencao.quantidade_cronogramas_maior_quantidade_permitida", null,
								String.valueOf(quantidadeCronogramas.intValue()
												- colecaoFaturamentoGrupoCronogramaMensalAbertosGrupo.size()));
			}


			Collection<NacionalFeriado> colecaoNacionalFeriado = getControladorUtil().pesquisarFeriadosNacionais();
			Collection<MunicipioFeriado> colecaoMunicipioFeriado = getControladorUtil().pesquisarFeriadosMunicipais();

			// [SB0001] - Definir período de flutuação da data prevista
			// da atividade
			for(FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaAtual : colecaoFaturamentoAtividadeCronogramaInserir){

				FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronogramaAnterior = new FiltroFaturamentoAtividadeCronograma();
				filtroFaturamentoAtividadeCronogramaAnterior.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA, Util
												.subtrairMesDoAnoMes(faturamentoGrupoCronogramaMensal.getAnoMesReferencia(), 1)));
				filtroFaturamentoAtividadeCronogramaAnterior.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
								faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getId()));

				filtroFaturamentoAtividadeCronogramaAnterior.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, faturamentoAtividadeCronogramaAtual
												.getFaturamentoAtividade().getId()));

				Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaRefenciaAnterior = getControladorUtil()
								.pesquisar(filtroFaturamentoAtividadeCronogramaAnterior, FaturamentoAtividadeCronograma.class.getName());

				Date dataMinimaPermitida = null;
				Date dataMaximaPermitida = null;

				String pQuantidadeMinimaDiasCicloFaturamento = null;
				try{

					pQuantidadeMinimaDiasCicloFaturamento = ((String) ParametroFaturamento.P_QUANTIDADE_MINIMA_DIAS_CICLO_FATURAMENTO
									.executar(this));
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null,
									"P_QUANTIDADE_MINIMA_DIAS_CICLO_FATURAMENTO");
				}

				String pQuantidadeMaximaDiasCicloFaturamento = null;
				try{

					pQuantidadeMaximaDiasCicloFaturamento = ((String) ParametroFaturamento.P_QUANTIDADE_MAXIMA_DIAS_CICLO_FATURAMENTO
									.executar(this));
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null,
									"P_QUANTIDADE_MAXIMA_DIAS_CICLO_FATURAMENTO");
				}

				if(!Util.isVazioOrNulo(colecaoFaturamentoAtividadeCronogramaRefenciaAnterior)){

					FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaAnterior = (FaturamentoAtividadeCronograma) Util
									.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRefenciaAnterior);

					if(faturamentoAtividadeCronogramaAnterior.getDataRealizacao() != null){

						dataMinimaPermitida = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaAnterior.getDataRealizacao(),
										Util.obterInteger(pQuantidadeMinimaDiasCicloFaturamento));
						dataMaximaPermitida = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaAnterior.getDataRealizacao(),
										Util.obterInteger(pQuantidadeMaximaDiasCicloFaturamento));

					}else if(faturamentoAtividadeCronogramaAnterior.getDataPrevista() != null){

						dataMinimaPermitida = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaAnterior.getDataPrevista(),
										Util.obterInteger(pQuantidadeMinimaDiasCicloFaturamento));
						dataMaximaPermitida = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaAnterior.getDataPrevista(),
										Util.obterInteger(pQuantidadeMaximaDiasCicloFaturamento));
					}
				}

				if(dataMinimaPermitida == null || dataMaximaPermitida == null){

					dataMinimaPermitida = new Date();
					dataMinimaPermitida = Util.zerarHoraMinutoSegundo(dataMinimaPermitida);
					Integer referenciaSeguinte = null;

					Integer referenciaDataCorrente = Util.recuperaAnoMesDaData(dataMinimaPermitida);

					if(Util.compararAnoMesReferencia(faturamentoGrupoCronogramaMensal.getAnoMesReferencia(), referenciaDataCorrente, ">")
									|| Util.compararAnoMesReferencia(faturamentoGrupoCronogramaMensal.getAnoMesReferencia(),
													referenciaDataCorrente, "=")){

						referenciaSeguinte = Util.somaMesAnoMesReferencia(faturamentoGrupoCronogramaMensal.getAnoMesReferencia(), 1);
					}else{

						referenciaSeguinte = Util.somaMesAnoMesReferencia(referenciaDataCorrente, 1);
					}

					Calendar calendarUltimoDiaMesReferenciaSeguinte = new GregorianCalendar();
					calendarUltimoDiaMesReferenciaSeguinte.set(Calendar.MONTH, Util.obterMes(referenciaSeguinte) - 1);
					calendarUltimoDiaMesReferenciaSeguinte.set(Calendar.YEAR, Util.obterAno(referenciaSeguinte));
					calendarUltimoDiaMesReferenciaSeguinte.set(Calendar.DATE,
									calendarUltimoDiaMesReferenciaSeguinte.getActualMaximum(Calendar.DAY_OF_MONTH));
					dataMaximaPermitida = Util.zerarHoraMinutoSegundo(calendarUltimoDiaMesReferenciaSeguinte.getTime());
				}

				if(!Util.ehDiaUtil(dataMinimaPermitida, colecaoNacionalFeriado, colecaoMunicipioFeriado)){

					dataMinimaPermitida = Util.obterProximoDiaUtil(dataMinimaPermitida, colecaoNacionalFeriado, colecaoMunicipioFeriado);
				}

				if(!Util.ehDiaUtil(dataMaximaPermitida, colecaoNacionalFeriado, colecaoMunicipioFeriado)){

					dataMaximaPermitida = Util.obterProximoDiaUtil(dataMaximaPermitida, colecaoNacionalFeriado, colecaoMunicipioFeriado);
				}

				// [FS0007] - Validar Datas Previstas
				if(faturamentoAtividadeCronogramaAtual.getDataPrevista().compareTo(dataMinimaPermitida) == -1
								|| faturamentoAtividadeCronogramaAtual.getDataPrevista().compareTo(dataMaximaPermitida) == 1){

					// throw new
					// ControladorException("atencao.data_prevista_atividade_periodo_nao_permitido",
					// null,
					// faturamentoAtividadeCronogramaAtual.getFaturamentoAtividade().getDescricao(),
					// Util.formatarData(dataMinimaPermitida),
					// Util.formatarData(dataMaximaPermitida));
				}
			}

			// [FS0003] - Verificar existência do cronograma para o grupo
			FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();
			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA, faturamentoGrupoCronogramaMensal
											.getAnoMesReferencia()));
			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO, faturamentoGrupoCronogramaMensal
											.getFaturamentoGrupo().getId()));
			Collection colecaoFaturamentoGrupoCronogramaMensalExistente = getControladorUtil().pesquisar(
							filtroFaturamentoGrupoCronogramaMensal, FaturamentoGrupoCronogramaMensal.class.getName());

			if(!Util.isVazioOrNulo(colecaoFaturamentoGrupoCronogramaMensalExistente)){

				throw new ControladorException("atencao.cronogama_mes_ja_gerado", null);
			}

			// Inclui o cronograma mensal
			// ------------ REGISTRAR TRANSAÇÃO ----------------------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_INSERIR_CRONOGRAMA_FATURAMENTO,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			faturamentoGrupoCronogramaMensal.setUltimaAlteracao(new Date());
			registradorOperacao.registrarOperacao(faturamentoGrupoCronogramaMensal);
			Integer idFaturamentoGrupoCronogramaMensalInserido = (Integer) getControladorUtil().inserir(faturamentoGrupoCronogramaMensal);
			faturamentoGrupoCronogramaMensal.setId(idFaturamentoGrupoCronogramaMensalInserido);
			referenciasInseridas = Util.formatarAnoMesParaMesAno(faturamentoGrupoCronogramaMensal.getAnoMesReferencia());

			// Inclui as atividades do cronograma
			this.inserirFaturamentoAtividadeCronograma(colecaoFaturamentoAtividadeCronogramaInserir, faturamentoGrupoCronogramaMensal,
							registradorOperacao);

			// [SB0002] - Gerar ocorrências de cronograma
			// Caso a quantidade de cronogramas seja maior que 1 (um)
			if(quantidadeCronogramas.intValue() > 1){

				// Projeta os novos cronogramas com base no cronograma imediatamente anterior
				// limitando
				// a quantidade informada menos 1 (um)
				for(int i = 1; i <= (quantidadeCronogramas - 1); i++){

					// [FS0003] - Verificar existência do cronograma para o grupo
					filtroFaturamentoGrupoCronogramaMensal.limparListaParametros();
					filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA, Util.somaMesAnoMesReferencia(
													faturamentoGrupoCronogramaMensal.getAnoMesReferencia(), i)));
					filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO, faturamentoGrupoCronogramaMensal
													.getFaturamentoGrupo().getId()));
					colecaoFaturamentoGrupoCronogramaMensalExistente = getControladorUtil().pesquisar(
									filtroFaturamentoGrupoCronogramaMensal, FaturamentoGrupoCronogramaMensal.class.getName());

					if(!Util.isVazioOrNulo(colecaoFaturamentoGrupoCronogramaMensalExistente)){

						// Caso já exista cronograma para a referência, repetir os procedimentos do
						// item
						// anterior para uma nova referência
						continue;
					}

					// Inclui o cronograma mensal
					// ------------ REGISTRAR TRANSAÇÃO ----------------------------
					RegistradorOperacao registradorOperacaoCronogramaNovo = new RegistradorOperacao(
									Operacao.OPERACAO_INSERIR_CRONOGRAMA_FATURAMENTO, new UsuarioAcaoUsuarioHelper(usuarioLogado,
													UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensalNovo = new FaturamentoGrupoCronogramaMensal();
					faturamentoGrupoCronogramaMensalNovo.setUltimaAlteracao(new Date());
					faturamentoGrupoCronogramaMensalNovo.setAnoMesReferencia(Util.somaMesAnoMesReferencia(
									faturamentoGrupoCronogramaMensal.getAnoMesReferencia(), i));
					faturamentoGrupoCronogramaMensalNovo.setFaturamentoGrupo(faturamentoGrupoCronogramaMensal.getFaturamentoGrupo());

					registradorOperacaoCronogramaNovo.registrarOperacao(faturamentoGrupoCronogramaMensalNovo);
					idFaturamentoGrupoCronogramaMensalInserido = (Integer) getControladorUtil().inserir(
									faturamentoGrupoCronogramaMensalNovo);
					faturamentoGrupoCronogramaMensalNovo.setId(idFaturamentoGrupoCronogramaMensalInserido);
					referenciasInseridas += ", "
									+ Util.formatarAnoMesParaMesAno(faturamentoGrupoCronogramaMensalNovo.getAnoMesReferencia());

					if(!Util.isVazioOrNulo(colecaoFaturamentoAtividadeCronogramaInserir)){

						Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaNova = new ArrayList<FaturamentoAtividadeCronograma>();

						for(FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaInserido : colecaoFaturamentoAtividadeCronogramaInserir){

							FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaNovo = new FaturamentoAtividadeCronograma();
							faturamentoAtividadeCronogramaNovo.setComando(faturamentoAtividadeCronogramaInserido.getComando());
							faturamentoAtividadeCronogramaNovo.setDataPrevista(faturamentoAtividadeCronogramaInserido.getDataPrevista());
							faturamentoAtividadeCronogramaNovo.setDataRealizacao(null);
							faturamentoAtividadeCronogramaNovo.setFaturamentoAtividade(faturamentoAtividadeCronogramaInserido
											.getFaturamentoAtividade());
							faturamentoAtividadeCronogramaNovo.setFaturamentoGrupoCronogramaMensal(faturamentoGrupoCronogramaMensalNovo);

							// Define a data projetada pela soma de 30 dias à data projetada do
							// cronograma
							// anterior
							Date dataProjetada = Util.adicionarNumeroDiasDeUmaData(faturamentoAtividadeCronogramaNovo.getDataPrevista(),
											i * 30);

							// Caso a data projetada seja um dia não útil, a data prevista será o
							// próximo
							// dia útil
							if(!Util.ehDiaUtil(dataProjetada, colecaoNacionalFeriado, colecaoMunicipioFeriado)){

								dataProjetada = Util.obterProximoDiaUtil(dataProjetada, colecaoNacionalFeriado, colecaoMunicipioFeriado);
							}

							faturamentoAtividadeCronogramaNovo.setDataPrevista(dataProjetada);

							if(faturamentoAtividadeCronogramaNovo.getComando() != null){

								faturamentoAtividadeCronogramaNovo.setComando(dataProjetada);
							}

							faturamentoAtividadeCronogramaNovo
											.setFaturamentoAtividadeCronogramaRotas(faturamentoAtividadeCronogramaInserido
															.getFaturamentoAtividadeCronogramaRotas());
							colecaoFaturamentoAtividadeCronogramaNova.add(faturamentoAtividadeCronogramaNovo);
						}

						// Inclui as atividades do cronograma
						this.inserirFaturamentoAtividadeCronograma(colecaoFaturamentoAtividadeCronogramaNova,
										faturamentoGrupoCronogramaMensalNovo, registradorOperacaoCronogramaNovo);
					}
				}
			}
		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return referenciasInseridas;
	}


	/**
	 * Este caso de uso permite faturar um conjunto de rotas de um grupo de faturamento.
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Leonardo Vieira, Raphael Rossiter,Rafael Santos, Pedro Alexandre, Raphael Rossiter
	 * @date 15/12/2005,13/09/2006,17/09/2007
	 * @param colecaoFaturamentoAtividadeCronogramaRota
	 * @param faturamentoGrupo
	 * @param sistemaParametro
	 * @param atividade
	 * @throws ControladorException
	 */
	public void faturarGrupoFaturamento(Collection<FaturamentoAtivCronRota> colecaoFaturamentoAtividadeCronogramaRota,
					FaturamentoGrupo faturamentoGrupo, Integer anoMesReferenciaFaturamento, int atividade, int idFuncionalidadeIniciada,
					FaturamentoSimulacaoComando faturamentoSimulacaoComando) throws ControladorException{

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de Processamento do Batch
		//
		// -------------------------
		int idUnidadeIniciada = 0;

		if(!Util.isVazioOrNulo(colecaoFaturamentoAtividadeCronogramaRota)){

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(
						idFuncionalidadeIniciada,
						UnidadeProcessamento.ROTA,
						((FaturamentoAtivCronRota) Util.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRota)).getRota()
										.getId());
		}

		try{

			String anoMesFaturamento = String.valueOf(anoMesReferenciaFaturamento);
			Collection<Imovel> colecaoOcorrenciaGeracaoPreFaturamento = new ArrayList<Imovel>();
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			Collection<Rota> colecaoRotasExecucao = new ArrayList<Rota>();
			HashMap<Integer, FaturamentoAtivCronRota> mapFaturamentoAtividadeCronPorRota = new HashMap<Integer, FaturamentoAtivCronRota>();
			Collection<Integer> colecaoMatriculasComandoSimulacaoFaturamento = null;

			// Caso a atividade que esteja sendo executada, corresponda a "faturar grupo"
			if(atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()){

				for(FaturamentoAtivCronRota faturamentoAtivCronRota : colecaoFaturamentoAtividadeCronogramaRota){

					colecaoRotasExecucao.add(faturamentoAtivCronRota.getRota());
					mapFaturamentoAtividadeCronPorRota.put(faturamentoAtivCronRota.getRota().getId(), faturamentoAtivCronRota);
				}
			}else{

				// Caso contrário e caso tenha sido passado um comando de simulação de faturamento
				Collection<Integer> colecaoIdsRotasComandoSimulacaoFaturamento = repositorioFaturamento
								.pesquisarIdsRotasComandoSimulacaoFaturamento(faturamentoSimulacaoComando);
				FiltroRota filtroRota = null;

				colecaoMatriculasComandoSimulacaoFaturamento = repositorioFaturamento
								.pesquisarMatriculasImoveisComandoSimulacaoFaturamento(faturamentoSimulacaoComando);

				if(atividade == FaturamentoAtividade.SIMULAR_FATURAMENTO){

					HashSet<Imovel> colecaoImoveis = new HashSet<Imovel>();

					Collection<Integer> colecaoidsConsulta = new ArrayList<Integer>();
					for(int i = 0; i < colecaoIdsRotasComandoSimulacaoFaturamento.size(); i++){
						colecaoidsConsulta.add(((ArrayList<Integer>) colecaoIdsRotasComandoSimulacaoFaturamento).get(i));

						if(colecaoidsConsulta.size() == 1000 || i + 1 == colecaoIdsRotasComandoSimulacaoFaturamento.size()){

							colecaoImoveis.addAll(repositorioFaturamento.pesquisarImoveisGrupoFaturamento(colecaoidsConsulta,
											colecaoMatriculasComandoSimulacaoFaturamento));
							colecaoidsConsulta.clear();
						}
					}

					// Alteração realizada para prevenir erro de estou de tempo limite da transação
					// no batch
					// O processo foi "rodado" na máquina de homologação e após ser observado a
					// quantidade
					// de imóveis processados estimou-se que um filtro que retorasse mais de 530000
					// imóveis para processar poderia fazer com que o tempo limite da transação do
					// processo
					// estourasse.
					if(colecaoImoveis.size() > ConstantesSistema.QUANTIDADE_LIMITE_REGISTROS_SIMULACAO_FATURAMENTO){

						EnvioEmail envioEmial = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.SIMULAR_FATURAMENTO_FALHA);

						String emailRemetente = envioEmial.getEmailRemetente();
						String tituloMensagem = envioEmial.getTituloMensagem();
						String corpoMensagem = envioEmial.getCorpoMensagem();
						String emailReceptor = envioEmial.getEmailReceptor();

						ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, corpoMensagem);

						throw new ControladorException("erro.sistema");
					}

				}

				for(Integer idRotaComando : colecaoIdsRotasComandoSimulacaoFaturamento){

					filtroRota = new FiltroRota();
					filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.ID_ROTA, idRotaComando));
					filtroRota.adicionarCaminhoParaCarregamentoEntidade(FiltroRota.FATURAMENTO_GRUPO);

					colecaoRotasExecucao.add((Rota) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroRota,
									Rota.class.getName())));
				}

			}

			if(!Util.isVazioOrNulo(colecaoRotasExecucao)){

				// Data de Vencimento
				Date dataVencimento = null;
				boolean deletouResumoComando = false;
				
				// Lista de rotas para faturar ou simular faturamento
				for(Rota rota : colecaoRotasExecucao){

					FaturamentoAtivCronRota faturamentoAtivCronRota = null;
					Collection colecaoResumoFaturamento = null;
					Collection colecaoContabilizar = new ArrayList();
					OperacaoContabilHelper operacaoContabilContaHelper = null;
					Collection<Conta> colecaoContasGeradas = new ArrayList<Conta>();
					Collection<Conta> colecaoContasParaHistorico = new ArrayList<Conta>();

					Conta contaGerada = null;

					// Caso a atividade que esteja sendo executada, corresponda a "faturar grupo"
					if(atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()){

						faturamentoAtivCronRota = mapFaturamentoAtividadeCronPorRota.get(rota.getId());

						// Data de Vencimento
						if(faturamentoAtivCronRota.getDataContaVencimento() != null){

							dataVencimento = faturamentoAtivCronRota.getDataContaVencimento();
						}

						try{

							this.repositorioMicromedicao.deletarResumoLigacoesEconomia(faturamentoAtivCronRota.getRota().getId(),
											anoMesReferenciaFaturamento);

						}catch(ErroRepositorioException ex){

							throw new ControladorException("erro.sistema", ex);
						}

						/*
						 * Caso o mês de faturamento corresponda ao mês de novembro, o sistema
						 * exclui os
						 * dados do resumo da simulação do faturamento do
						 * mês de dezembro e também o mês de novembro.
						 */
						if(anoMesFaturamento.substring(4, 6).equals("11")){

							// Cria o ano/mês de referência para dezembro do ano
							// informado
							String anoMesDezembro = anoMesFaturamento.substring(0, 4) + "12";

							// APAGAR DADOS GERADOS PARA A ROTA NO MES DE DEZEMBRO
							// DO ANO DE FATURAMENTO
							// Comentado por Sávio Luiz Analista:Aryed Lins
							// this.apagarDadosGeradosFaturarGrupoFaturamento(
							// anoMesDezembro, faturamentoAtivCronRota
							// .getRota().getId());

							try{

								this.repositorioMicromedicao.deletarResumoLigacoesEconomia(faturamentoAtivCronRota.getRota().getId(),
												Integer.parseInt(anoMesDezembro));

							}catch(ErroRepositorioException ex){

								throw new ControladorException("erro.sistema", ex);
							}
						}

						colecaoResumoFaturamento = repositorioFaturamento.pesquisarResumoFaturamentoSimulacao(faturamentoGrupo.getId(),
										Util.obterInteger(anoMesFaturamento), faturamentoAtivCronRota.getRota().getId());

					}else{

						// Caso contrário e caso tenha sido passado um comando de simulação de
						// faturamento
						if(!deletouResumoComando){

							repositorioFaturamento.deletarResumoFaturamentoSimulacaoPorComando(faturamentoSimulacaoComando.getId());
							deletouResumoComando = true;
						}

						faturamentoGrupo = rota.getFaturamentoGrupo();
					}

					if(Util.isVazioOrNulo(colecaoResumoFaturamento)){

						colecaoResumoFaturamento = new ArrayList<ResumoFaturamentoSimulacao>();
					}

					Collection colecaoImovel = this.pesquisarImovelGrupoFaturamento(rota.getId(),
									colecaoMatriculasComandoSimulacaoFaturamento);

					/*
					 * Caso exista ids de imóveis para a rota atual determina o faturamento para
					 * cada imóvel retornado.
					 */
					if(colecaoImovel != null && !colecaoImovel.isEmpty()){
						Iterator iteratorColecaoImoveis = colecaoImovel.iterator();
						Imovel imovel = null;

						while(iteratorColecaoImoveis.hasNext()){

							imovel = (Imovel) iteratorColecaoImoveis.next();

							// [SF0001] - Determinar Faturamento para o Imóvel
							contaGerada = faturarImovel(faturamentoGrupo, sistemaParametro, faturamentoAtivCronRota, anoMesFaturamento,
											colecaoResumoFaturamento, imovel, colecaoOcorrenciaGeracaoPreFaturamento,
											faturamentoSimulacaoComando);

							if(atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()){

								// [UC0275 – Gerar Resumo das Ligações/Economias]
								this.getControladorMicromedicao().gerarResumoLigacoesEconomias(imovel.getId(), null, null, false);

								if(contaGerada != null){

									operacaoContabilContaHelper = obterOperacaoContabilContaHelper(contaGerada);
									colecaoContabilizar.add(operacaoContabilContaHelper);

									colecaoContasGeradas.add(contaGerada);

									BigDecimal valorAguaEsgotoDebitos = contaGerada.getValorAgua().add(
													contaGerada.getValorEsgoto().add(contaGerada.getDebitos()));
									valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(contaGerada.getValorCreditos());
									valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(contaGerada.getValorImposto());

									// Caso o valor de crédito + impostos anule o valor da conta
									// (água +
									// esgoto + débitos), adiciona a conta à coleção que será
									// transferida
									// para histórico
									if(valorAguaEsgotoDebitos.compareTo(BigDecimal.ZERO) == 0){

										colecaoContasParaHistorico.add(contaGerada);
									}

								}
							}

							// Alterado por Sávio Luiz Data:08/11/2007
							// Analista:Rosana
							// Verifica se o mes de faturamento corresponde
							// ao mes de novembro e
							// verifica se haverá faturamento antecipado
							// para o imóvel
							if(anoMesFaturamento.substring(4, 6).equals("11")
											&& sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){

								Integer anoMesFaturamentoMaisUm = Util.somaUmMesAnoMesReferencia(anoMesReferenciaFaturamento);

								Integer idConsumoHistorico = getControladorMicromedicao().pesquisarConsumoHistoricoAntecipado(
												imovel.getId(), anoMesFaturamentoMaisUm);
								if(idConsumoHistorico != null){

									// [SF0001] - Determinar Faturamento para o Imóvel
									contaGerada = faturarImovel(faturamentoGrupo, sistemaParametro, faturamentoAtivCronRota,
													anoMesFaturamentoMaisUm.toString(), colecaoResumoFaturamento, imovel,
													colecaoOcorrenciaGeracaoPreFaturamento, faturamentoSimulacaoComando);

									if(atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()){

										// [UC0275 – Gerar Resumo das Ligações/Economias]
										this.getControladorMicromedicao().gerarResumoLigacoesEconomias(imovel.getId(),
														anoMesFaturamentoMaisUm, null, false);

										if(contaGerada != null){

											operacaoContabilContaHelper = obterOperacaoContabilContaHelper(contaGerada);
											colecaoContabilizar.add(operacaoContabilContaHelper);

											colecaoContasGeradas.add(contaGerada);

											BigDecimal valorAguaEsgotoDebitos = contaGerada.getValorAgua().add(
															contaGerada.getValorEsgoto().add(contaGerada.getDebitos()));
											valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(contaGerada.getValorCreditos());
											valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(contaGerada.getValorImposto());

											// Caso o valor de crédito + impostos anule o valor da
											// conta (água +
											// esgoto + débitos), adiciona a conta à coleção que
											// será
											// transferida
											// para histórico
											if(valorAguaEsgotoDebitos.compareTo(BigDecimal.ZERO) == 0){

												colecaoContasParaHistorico.add(contaGerada);
											}

										}
									}
								}
							}
						}
					}

					/*
					 * Caso a coleção de resumo de faturamento não esteja vazia ou nula inseri os
					 * resumos na base de dados.
					 */
					if(colecaoResumoFaturamento != null && !colecaoResumoFaturamento.isEmpty()){

						this.inserirResumoSimulacaoFaturamento(colecaoResumoFaturamento);

						if(colecaoResumoFaturamento != null){

							colecaoResumoFaturamento.clear();
							colecaoResumoFaturamento = null;
						}
					}

					if(colecaoImovel != null){
						colecaoImovel.clear();
						colecaoImovel = null;
					}

					if(atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()){

						// [UC0566 – Gerar Histograma de Água e Esgoto]
						getControladorHistograma().gerarHistogramaAguaEsgoto(colecaoContasGeradas,
										ConstantesSistema.GERACAO_HISTOGRAMA_FATURAMENTO);

						if(colecaoContabilizar != null && !colecaoContabilizar.isEmpty()){

							// -------------------------------------------------------------------------
							// Registra o Lançamento Contábil.
							// -------------------------------------------------------------------------
							System.out.println("***********************Início Registra o Lançamento Contábil.[FATURAMENTO CONVENCIONAL]*********************************");

							getControladorContabil().registrarLancamentoContabil(colecaoContabilizar);

							System.out.println("***********************Fim Registra o Lançamento Contábil.[FATURAMENTO CONVENCIONAL]************************************");
							// -------------------------------------------------------------------------
						}

						// [SF0006] Item 8
						// transfere a conta para o histórico juntamente com seus
						// débitos cobrados e créditos realizados
						if(!Util.isVazioOrNulo(colecaoContasGeradas)){

							Collection<Conta> colecaoContasParaHistoricoTemp = new ArrayList<Conta>();

							Calendar tempoInicio = Calendar.getInstance();
							System.out.println(" *** Início da geração da colecaoContasParaHistorico ***");

							for(Conta conta : colecaoContasGeradas){

								BigDecimal valorAguaEsgotoDebitos = conta.getValorAgua()
												.add(conta.getValorEsgoto().add(conta.getDebitos()));
								valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(conta.getValorCreditos());
								valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(conta.getValorImposto());

								// Caso o valor de crédito + impostos anule o valor da conta (água +
								// esgoto + débitos), adiciona a conta à coleção que será
								// transferida
								// para histórico
								if(valorAguaEsgotoDebitos.compareTo(BigDecimal.ZERO) == 0){

									colecaoContasParaHistoricoTemp.add(conta);
								}
							}
							System.out.println(" *** Fim da geração da colecaoContasParaHistorico *** :: "
											+ Util.calcularDiferencaTempo(tempoInicio));

							// Verifica se há contas a serem transferidas para histórico
							if(!Util.isVazioOrNulo(colecaoContasParaHistorico)){

								this.transferirContasParaHistorico(colecaoContasParaHistorico, anoMesReferenciaFaturamento);
							}
						}
					}
				}

				if(atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()){
					
					this.iniciarProcessamentoRelatorioOcorrenciaGeracaoPreFaturamento(faturamentoGrupo, anoMesReferenciaFaturamento,
								colecaoOcorrenciaGeracaoPreFaturamento, idFuncionalidadeIniciada, dataVencimento);
				}
			}

			// Caso seja uma atividade de "faturar grupo"
			if(atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()){


				// Registrar o fim da execução da Unidade de Processamento
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
			}else{

				/*
				 * Caso contrário, caso seja um comando de simulação de faturamento. O sistema
				 * atualiza a data e hora da realização do comando de simulação de faturamento com a
				 * data e hora correntes
				 */
				faturamentoSimulacaoComando.setDataRealizacao(new Date());
				getControladorUtil().atualizar(faturamentoSimulacaoComando);
			}

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o
			// processo
			// batch venha a lançar e garantir que a unidade de
			// processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();

			if(atividade == FaturamentoAtividade.FATURAR_GRUPO.intValue()){

				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
				throw new EJBException(e);
			}else{

				throw new ControladorException("erro.sistema", e);
			}
		}

	}

	/**
	 * @param colecaoContasGeradas
	 * @return
	 */

	private OperacaoContabilHelper obterOperacaoContabilContaHelper(Conta conta){

		// -------------------------------------------------------------------------
		// Prepara Operação para: [Registra o Lançamento Contábil].
		// -------------------------------------------------------------------------
		OperacaoContabilHelper operacaoContabilHelper = new OperacaoContabilHelper();
		operacaoContabilHelper.setOperacaoContabil(OperacaoContabil.INCLUIR_CONTA_BATCH);
		operacaoContabilHelper.setObjetoOrigem(conta);

		// -------------------------------------------------------------------------

		return operacaoContabilHelper;
	}

	/**
	 * [UC0148] - Colocar Conta em Revisão
	 * [FS0016] - Verificar contas que estejam em revisão
	 * 
	 * @author Anderson Italo
	 * @date 18/10/2011
	 * @throws ControladorException
	 */
	public void verificarContasRevisao(Collection<Conta> colecaoContas, String idsContasSelecionadas) throws ControladorException{

		if(!Util.isVazioOrNulo(colecaoContas)){

			Iterator colecaoContasIt = colecaoContas.iterator();
			Conta conta;
			String[] arrayIdentificadores = new String[] {};

			// Verifica se irá validar todas ou uma seleção das contas da coleção
			if(!Util.isVazioOuBranco(idsContasSelecionadas)){

				arrayIdentificadores = idsContasSelecionadas.split(",");
			}

			while(colecaoContasIt.hasNext()){

				conta = (Conta) colecaoContasIt.next();

				if(arrayIdentificadores.length > 0){

					for(int index = 0; index < arrayIdentificadores.length; index++){

						String dadosConta = arrayIdentificadores[index];
						String[] idContaSelecionada = dadosConta.split("-");

						// Caso a conta da coleção esteja selecionada
						if(conta.getId().equals(Integer.valueOf(idContaSelecionada[0]))){

							// Caso a conta já esteja em revisão
							if(conta.getDataRevisao() != null){

								throw new ControladorException("atencao.data_revisao_existente");
							}
						}
					}
				}else{

					// Caso a conta já esteja em revisão
					if(conta.getDataRevisao() != null){

						throw new ControladorException("atencao.data_revisao_existente");
					}
				}

			}
		}
	}

	/**
	 * Este caso de uso permite faturar um conjunto de rotas de um grupo de faturamento.
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Faturar um Imovel
	 * 
	 * @author Rafael Santos
	 * @date 29/12/2006
	 * @author eduardo henrique
	 * @date 06/10/2008 Customizações no UC para a v0.05
	 * @param colecaoFaturamentoAtividadeCronogramaRota
	 * @param faturamentoGrupo
	 * @param sistemaParametro
	 * @param atividade
	 * @return Conta [Conta gerada para imóvel, que será usada para geração de Histogramas, Resumos
	 *         e Contabilizacao]
	 * @throws ControladorException
	 * @throws NumberFormatException
	 * @throws ErroRepositorioException
	 */

	private Conta faturarImovel(FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro,
					FaturamentoAtivCronRota faturamentoAtivCronRota, String anoMesFaturamento, Collection colecaoResumoFaturamento,
					Imovel imovel, Collection<Imovel> colecaoOcorrenciaGeracaoPreFaturamento,
					FaturamentoSimulacaoComando faturamentoSimulacaoComando) throws ControladorException, NumberFormatException,
					ErroRepositorioException{

		/*
		 * Verifica se existe conta para o imóvel para o ano/mês de faturamento atual.
		 */
		Integer existeImovelConta = (Integer) getControladorImovel().pesquisarImovelIdComConta(imovel.getId(),
						Integer.valueOf(anoMesFaturamento));

		/*
		 * Verifica se existe conta histórico para o imóvel para o ano/mês de faturamento atual.
		 */
		Integer existeImovelContaHistorico = null;

		if(existeImovelConta == null){
			existeImovelContaHistorico = (Integer) getControladorImovel().pesquisarImovelIdComContaHistorico(imovel.getId(),
							Integer.valueOf(anoMesFaturamento));
		}

		/*
		 * Verifica se existe conta no histórico como parcelada para o imóvel para o ano/mês de
		 * faturamento atual.
		 */
		Integer existeImovelContaHistoricoParcelado = (Integer) getControladorImovel().pesquisarImovelIdComContaHistoricoParcelado(
						imovel.getId(), Integer.valueOf(anoMesFaturamento));

		// CASO NÃO EXISTA CONTA PARA O IMOVEL NO ANO/MES DE REFERENCIA
		// E CASO NÂO EXISTA CONTA HISTÒRICO COMO PARCELADA PARA O IMÒVEL NO ANO/MES DE REFERENCIA
		// E CASO NÃO EXISTA CONTA HISTÓRICO PARA O IMÓVEL NO ANO/MES DE REFERENCIA
		Conta contaGerada = null;
		if(existeImovelConta == null && existeImovelContaHistoricoParcelado == null && existeImovelContaHistorico == null){

			// [SF0001] - Determinar Faturamento para o Imóvel
			contaGerada = this.determinarFaturamentoImovel(imovel, Integer.valueOf(anoMesFaturamento), faturamentoAtivCronRota,
							colecaoResumoFaturamento, sistemaParametro, false, faturamentoGrupo, Integer.valueOf(anoMesFaturamento), false,
							null, null, null, colecaoOcorrenciaGeracaoPreFaturamento, null, null, faturamentoSimulacaoComando);
		}
		return contaGerada;
	}

	public void atualizarAnoMesReferenciaFaturamentoGrupo(FaturamentoGrupo faturamentoGrupo, Integer anoMesReferenciaFaturamento,
					int atividade) throws ControladorException{

		try{
			this.repositorioFaturamento.atualizarAnoMesReferenciaFaturamentoGrupo(faturamentoGrupo.getId(), anoMesReferenciaFaturamento);

			this.repositorioFaturamento.atualizarDataHoraRealizacaoAtividade(atividade, anoMesReferenciaFaturamento,
							faturamentoGrupo.getId());

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Determina o tipo de conta que será associado na impressão da conta.
	 * [SB0006 - ]
	 * 
	 * @author Raphael Rossiter
	 * @date 09/12/2005
	 * @param imovel
	 * @throws ControladorException
	 */
	protected ContaTipo obterContaTipoParaContaImpressao(Conta conta, Integer idClienteResponsavel, Imovel imovel){

		ContaTipo contaTipo = new ContaTipo();

		contaTipo.setId(ContaTipo.CONTA_NORMAL);

		if(conta.getContaMotivoRevisao() != null
						&& conta.getContaMotivoRevisao().getId().equals(ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO)){

			contaTipo.setId(ContaTipo.CONTA_RETIDA_POR_EC);
		}

		else if(conta.getContaMotivoRevisao() != null
						&& conta.getContaMotivoRevisao().getId().equals(ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO)){

			contaTipo.setId(ContaTipo.CONTA_RETIDA_POR_BC);
		}

		else if(idClienteResponsavel != null && imovel.getIndicadorDebitoConta().shortValue() == ConstantesSistema.NAO.shortValue()){

			contaTipo.setId(ContaTipo.CONTA_CLIENTE_RESPONSAVEL);
		}

		else if(idClienteResponsavel != null && imovel.getIndicadorDebitoConta().shortValue() == ConstantesSistema.SIM.shortValue()){

			contaTipo.setId(ContaTipo.CONTA_DEBITO_AUTO_COM_CLIENTE_RESP);
		}

		else if(idClienteResponsavel == null && imovel.getIndicadorDebitoConta().shortValue() == ConstantesSistema.SIM.shortValue()){

			contaTipo.setId(ContaTipo.CONTA_DEBITO_AUTOMATICO);
		}

		return contaTipo;
	}

	/**
	 * Verifica se existe debito a cobrar pronto para transferir para histórico.
	 * 
	 * @param collDebitoACobrar
	 * @throws ControladorException
	 */

	private void verificarDebitoACobrarParaHistorico(Collection collDebitoACobrar) throws ControladorException{

		Collection collDebitoACobrarTransferirParaHistorico = new ArrayList();
		Iterator it = collDebitoACobrar.iterator();

		while(it.hasNext()){
			DebitoACobrar debitoACobrar = (DebitoACobrar) it.next();
			if(debitoACobrar.getNumeroPrestacaoCobradas() == debitoACobrar.getNumeroPrestacaoDebito()){
				collDebitoACobrarTransferirParaHistorico.add(debitoACobrar);
			}
		}

		if(collDebitoACobrarTransferirParaHistorico != null && collDebitoACobrarTransferirParaHistorico.size() > 0){
			try{
				this.transferirDebitosACobrarParaHistorico(collDebitoACobrarTransferirParaHistorico, Boolean.FALSE);
				this.atualizarIndicadorDebitoACobrarNoHistorico(collDebitoACobrarTransferirParaHistorico);
			}catch(ControladorException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

	}

	private void verificarCreditoARealizarParaHistorico(Collection collCreditoARealizar) throws ControladorException{

		Collection collCreditoARealizarTransferirParaHistorico = new ArrayList();
		// Collection collCreditoARealizarTransferirParaHistoricoIds = new ArrayList();
		Iterator it = collCreditoARealizar.iterator();

		while(it.hasNext()){
			CreditoARealizar creditoARealizar = (CreditoARealizar) it.next();
			if(creditoARealizar.getNumeroPrestacaoRealizada().intValue() == creditoARealizar.getNumeroPrestacaoCredito().intValue()
							&& (creditoARealizar.getValorResidualMesAnterior() == null || creditoARealizar.getValorResidualMesAnterior()
											.compareTo(BigDecimal.ZERO) == 0)){
				// collCreditoARealizarTransferirParaHistoricoIds.add(creditoARealizar.getId());
				collCreditoARealizarTransferirParaHistorico.add(creditoARealizar);
			}
		}

		if(collCreditoARealizarTransferirParaHistorico != null && collCreditoARealizarTransferirParaHistorico.size() > 0){
			try{
				this.transferirCreditoARealizarParaHistorico(collCreditoARealizarTransferirParaHistorico);
				this.atualizarIndicadorCreditosARealizarNoHistorico(collCreditoARealizarTransferirParaHistorico);
			}catch(ControladorException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

	}

	/**
	 * Método que verifica se o Debito a Cobrar que será cobrado em conta não existe em algum
	 * documento de cobrança válido
	 * 
	 * @param debitoACobrar
	 *            [obrigatorio]
	 * @return boolean [false, se não existir em Documento de Cobranca válido e for para cobrança em
	 *         conta, ou se ainda tem parcelas a cobrar]
	 */
	private boolean verificarDebitoACobrarEmDocumentoCobranca(DebitoACobrar debitoACobrar) throws ControladorException{

		boolean debitoACobrarEmExtratoValido = false;
		int quantidadeDiasEspera = 0;

		if(debitoACobrar == null){
			throw new IllegalArgumentException("erro.sistema_debito_a_cobrar_nulo");
		}

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		if(sistemaParametro == null){
			throw new IllegalStateException("erro.sistema_sistema_parametro_nulo");
		}

		if(sistemaParametro.getNumeroDiasEsperaExtratoDebito() != null){
			quantidadeDiasEspera = sistemaParametro.getNumeroDiasEsperaExtratoDebito();
		}

		if(debitoACobrar.getDataAntecipacao() != null && debitoACobrar.getQuantidadeParcelasAntecipadas() != null){
			Date antecipaVencimento = Util.adicionarNumeroDiasDeUmaData(debitoACobrar.getDataAntecipacao(), quantidadeDiasEspera);

			Calendar calendar = GregorianCalendar.getInstance();
			calendar.setTime(antecipaVencimento);
			calendar.set(Calendar.HOUR_OF_DAY, 23);
			calendar.set(Calendar.MINUTE, 59);
			calendar.set(Calendar.SECOND, 59);
			antecipaVencimento = calendar.getTime();

			calendar.setTime(new Date());
			calendar.set(Calendar.HOUR_OF_DAY, 0);
			calendar.set(Calendar.MINUTE, 0);
			calendar.set(Calendar.SECOND, 0);
			Date dataAtual = calendar.getTime();

			// comparando se tem extrato de debito válido
			if(dataAtual.getTime() <= antecipaVencimento.getTime()){
				// caso tenha verifica se ele ta tentando pagar tudo
				if(debitoACobrar.getNumeroPrestacaoCobradas() + debitoACobrar.getQuantidadeParcelasAntecipadas().shortValue() < debitoACobrar
								.getNumeroPrestacaoDebito()){
					debitoACobrarEmExtratoValido = false;
				}else{
					debitoACobrarEmExtratoValido = true;
				}
			}
		}
		return debitoACobrarEmExtratoValido;
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * Atualizar os Credito a Realizar
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * @param colecaoCreditosARealizarUpdate
	 * @throws ControladorException
	 */
	protected void atualizarCreditoARealizar(Collection colecaoCreditosARealizarUpdate) throws ControladorException{

		// atualizar creditoARealizar
		if(colecaoCreditosARealizarUpdate != null && !colecaoCreditosARealizarUpdate.isEmpty()){

			Iterator iteratorColecaoCreditosARealizarUpdate = colecaoCreditosARealizarUpdate.iterator();
			CreditoARealizar creditoARealizar = null;
			while(iteratorColecaoCreditosARealizarUpdate.hasNext()){
				creditoARealizar = (CreditoARealizar) iteratorColecaoCreditosARealizarUpdate.next();
				try{
					repositorioFaturamento.atualizarCreditoARealizar(creditoARealizar.getId(),
									creditoARealizar.getNumeroPrestacaoRealizada(), creditoARealizar.getValorResidualMesAnterior());
				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
			}

			this.verificarCreditoARealizarParaHistorico(colecaoCreditosARealizarUpdate);

			colecaoCreditosARealizarUpdate.clear();
			colecaoCreditosARealizarUpdate = null;

		}
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * Atualizar os Debitos a Cobrar
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * @param colecaoDebitosACobrarUpdate
	 * @throws ControladorException
	 */
	protected void atualizarDebitoACobrarFaturamento(List colecaoDebitosACobrarUpdate) throws ControladorException{

		if(colecaoDebitosACobrarUpdate != null && !colecaoDebitosACobrarUpdate.isEmpty()){

			Iterator iteratorColecaoDebitosACobrarUpdate = colecaoDebitosACobrarUpdate.iterator();

			DebitoACobrar debitoACobrar = null;

			while(iteratorColecaoDebitosACobrarUpdate.hasNext()){
				debitoACobrar = (DebitoACobrar) iteratorColecaoDebitosACobrarUpdate.next();
				try{
					repositorioFaturamento.atualizarDebitoAcobrar(debitoACobrar.getId(),
									Short.valueOf(debitoACobrar.getNumeroPrestacaoCobradas()),
									debitoACobrar.getAnoMesReferenciaUltimaCobranca());
				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
			}

			this.verificarDebitoACobrarParaHistorico(colecaoDebitosACobrarUpdate);

			colecaoDebitosACobrarUpdate.clear();
			colecaoDebitosACobrarUpdate = null;

		}
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * Inserir credito realizado e credito realizado categoria
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * @author eduardo henrique
	 * @date 30/10/2008 Alteração no método para adicionar ao objeto conta, a coleção de
	 *       CreditoRealizado (e seus CreditoRealizadoCategoria).
	 * @param mapCreditoRealizado
	 * @param conta
	 * @throws ControladorException
	 */
	protected void inserirCreditoRealizado(Map<CreditoRealizado, Collection> mapCreditoRealizado, Conta conta) throws ControladorException{

		// inserir credito realizado
		// inserir credito realizado categoria
		conta.setCreditoRealizados(new HashSet<CreditoRealizado>());
		if(mapCreditoRealizado != null && !mapCreditoRealizado.isEmpty()){

			Collection colecaoCreditoRealizadoCategoria = new ArrayList();

			Iterator iteratorColecaoCreditosRealizadosCreditosARealizar = mapCreditoRealizado.keySet().iterator();

			CreditoRealizado creditoRealizado = null;

			while(iteratorColecaoCreditosRealizadosCreditosARealizar.hasNext()){

				creditoRealizado = (CreditoRealizado) iteratorColecaoCreditosRealizadosCreditosARealizar.next();

				// para posterior uso na Contabilização
				creditoRealizado.setCreditoRealizadoCategorias(new HashSet<CreditoRealizadoCategoria>());

				Collection colecaoCreditosRealizadosCategoriaCreditoRealizado = mapCreditoRealizado.get(creditoRealizado);

				creditoRealizado.setConta(conta);
				creditoRealizado.setUltimaAlteracao(new Date());
				Integer idCreditoRealizado = (Integer) this.getControladorUtil().inserir(creditoRealizado);
				creditoRealizado.setId(idCreditoRealizado);

				Iterator iteratorColecaoCreditosRealizadosCategoriaCreditoRealizado = colecaoCreditosRealizadosCategoriaCreditoRealizado
								.iterator();

				CreditoRealizadoCategoria creditoRealizadoCategoria = null;

				while(iteratorColecaoCreditosRealizadosCategoriaCreditoRealizado.hasNext()){
					creditoRealizadoCategoria = (CreditoRealizadoCategoria) iteratorColecaoCreditosRealizadosCategoriaCreditoRealizado
									.next();
					creditoRealizadoCategoria.setUltimaAlteracao(new Date());
					creditoRealizadoCategoria.getComp_id().setCreditoRealizado(creditoRealizado);
					colecaoCreditoRealizadoCategoria.add(creditoRealizadoCategoria);

					creditoRealizado.getCreditoRealizadoCategorias().add(creditoRealizadoCategoria);
				}

				conta.getCreditoRealizados().add(creditoRealizado);
			}

			this.getControladorUtil().inserirColecaoObjetos(colecaoCreditoRealizadoCategoria);

			if(colecaoCreditoRealizadoCategoria != null){
				colecaoCreditoRealizadoCategoria.clear();
				colecaoCreditoRealizadoCategoria = null;
			}

			mapCreditoRealizado.clear();
			mapCreditoRealizado = null;
		}
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * Gravar os Dados refernte ao ID da Conta inserir debito cobrado
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * @author eduardo henrique
	 * @date 29/10/2008 Alteração no método para adicionar ao objeto conta, a coleção de
	 *       debitoCobrado (e seus debitosCobradosCategoria).
	 * @param mapDebitosCobrados
	 * @param conta
	 * @throws ControladorException
	 */
	protected void inserirDebitoCobrado(Map<DebitoCobrado, Collection> mapDebitosCobrados, Conta conta) throws ControladorException{

		conta.setDebitoCobrados(new HashSet<DebitoCobrado>());
		if(mapDebitosCobrados != null && !mapDebitosCobrados.isEmpty()){

			Collection colecaoDebitosCobradosCategoriaInserir = new ArrayList();

			Iterator iteratorColecaoDebitosCobrados = mapDebitosCobrados.keySet().iterator();

			DebitoCobrado debitoCobrado = null;

			Collection colecaoDebitoCobradoCategoriaDebitoCobrado = null;

			while(iteratorColecaoDebitosCobrados.hasNext()){

				debitoCobrado = (DebitoCobrado) iteratorColecaoDebitosCobrados.next();

				colecaoDebitoCobradoCategoriaDebitoCobrado = mapDebitosCobrados.get(debitoCobrado);

				debitoCobrado.setConta(conta);
				debitoCobrado.setDebitoCobrado(new Date());
				debitoCobrado.setUltimaAlteracao(new Date());

				try{
					this.getControladorUtil().inserir(debitoCobrado);
				}catch(Exception e){
					e.printStackTrace();
				}

				Iterator iteratorColecaoDebitosCobradoCategoria = colecaoDebitoCobradoCategoriaDebitoCobrado.iterator();

				debitoCobrado.setDebitoCobradoCategorias(new HashSet<DebitoCobradoCategoria>());
				while(iteratorColecaoDebitosCobradoCategoria.hasNext()){
					DebitoCobradoCategoria debitoCobradoCategoria = (DebitoCobradoCategoria) iteratorColecaoDebitosCobradoCategoria.next();

					debitoCobradoCategoria.getComp_id().setDebitoCobrado(debitoCobrado);
					debitoCobradoCategoria.setUltimaAlteracao(new Date());
					colecaoDebitosCobradosCategoriaInserir.add(debitoCobradoCategoria);
					// debitoCobrado.getDebitoCobradoCategorias().add(debitoCobradoCategoria);
				}

				// para posterior utilização na Contabilização do evento
				// conta.getDebitoCobrados().add(debitoCobrado);
			}

			try{
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitosCobradosCategoriaInserir);
				conta.getDebitoCobrados().addAll(colecaoDebitosCobradosCategoriaInserir);
			}catch(Exception e){
				e.printStackTrace();
			}

		}
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * [SF0006] Item 7
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * @author eduardo henrique
	 * @date 30/10/2008 Alteração no método para adicionar ao objeto conta, a coleção de
	 *       ContaImpostoDeduzido .
	 * @param conta
	 * @param gerarImpostosDeduzidosContaHelper
	 * @throws ControladorException
	 */
	protected void inserirContaImpostosDeduzidos(Conta conta, GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper)
					throws ControladorException{

		// Incluir conta impostos deduzidos
		conta.setContaImpostosDeduzidos(new HashSet<ContaImpostosDeduzidos>());
		Collection colecaoImpostosDeduzidosHelper = gerarImpostosDeduzidosContaHelper.getListaImpostosDeduzidos();
		if(colecaoImpostosDeduzidosHelper != null && !colecaoImpostosDeduzidosHelper.isEmpty()){

			Collection colecaoContaImpostosDeduzidosInserir = new ArrayList();

			Iterator iteratorColecaoImpostosDeduzidosHelper = colecaoImpostosDeduzidosHelper.iterator();

			ImpostoDeduzidoHelper impostoDeduzidoHelper = null;

			while(iteratorColecaoImpostosDeduzidosHelper.hasNext()){
				impostoDeduzidoHelper = (ImpostoDeduzidoHelper) iteratorColecaoImpostosDeduzidosHelper.next();
				ContaImpostosDeduzidos contaImpostosDeduzidos = new ContaImpostosDeduzidos();
				contaImpostosDeduzidos.setConta(conta);
				ImpostoTipo impostoTipo = new ImpostoTipo();
				impostoTipo.setId(impostoDeduzidoHelper.getIdImpostoTipo());
				contaImpostosDeduzidos.setImpostoTipo(impostoTipo);
				contaImpostosDeduzidos.setValorImposto(impostoDeduzidoHelper.getValor());
				contaImpostosDeduzidos.setPercentualAliquota(impostoDeduzidoHelper.getPercentualAliquota());
				contaImpostosDeduzidos.setUltimaAlteracao(new Date());

				BigDecimal valorBase = conta.getValorAgua().add(conta.getValorEsgoto());
				valorBase = valorBase.add(conta.getDebitos());
				valorBase = valorBase.subtract(conta.getValorCreditos());
				contaImpostosDeduzidos.setValorBaseCalculo(valorBase);

				colecaoContaImpostosDeduzidosInserir.add(contaImpostosDeduzidos);

				conta.getContaImpostosDeduzidos().add(contaImpostosDeduzidos);
			}

			if(colecaoContaImpostosDeduzidosInserir != null && !colecaoContaImpostosDeduzidosInserir.isEmpty()){
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaImpostosDeduzidosInserir);

				colecaoContaImpostosDeduzidosInserir.clear();
				colecaoContaImpostosDeduzidosInserir = null;
			}

		}

		if(colecaoImpostosDeduzidosHelper != null){
			colecaoImpostosDeduzidosHelper.clear();
			colecaoImpostosDeduzidosHelper = null;
		}
	}

	/**
	 * [UC0113] - Fatuar Grupo Faturamento [SF009] - Adiconar na coleção para gerar o resumo
	 * faturamento simulação Author: Rafael Santos Data:
	 * 17/02/2006
	 * 
	 * @param colecaoResumoFaturamentoSimulacao
	 * @param categoria
	 * @param calcularValoresAguaEsgotoHelper
	 * @param imovel
	 * @param gerarAtiviadadeGrupoFaturamento
	 * @param valorTotalDebitos
	 * @param valorTotalCreditos
	 * @param rota
	 * @param anoMesReferencia
	 */
	private void adicionarColecaoResumoFaturamentoSimulacao(Collection colecaoResumoFaturamentoSimulacao, Categoria categoria,
					Subcategoria subCategoria, CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper, Imovel imovel,
					BigDecimal valorTotalDebitos, BigDecimal valorTotalCreditos, FaturamentoAtivCronRota faturamentoAtivCronRota,
					int anoMesReferencia, boolean primeiraCategoria, FaturamentoSimulacaoComando faturamentoSimulacaoComando,
					FaturamentoGrupo faturamentoGrupo){

		// se tiver categoria e valores agua e esgoto, para os dados de
		// quantidades e valores faturado de agua e esgoto
		ResumoFaturamentoSimulacao resumoFaturamentoSimulacaoNaColecao = null;

		Integer indicadorSimulacao = ConstantesSistema.NAO.intValue();

		if(faturamentoSimulacaoComando != null){

			indicadorSimulacao = ConstantesSistema.SIM.intValue();
		}

		if(categoria != null && calcularValoresAguaEsgotoHelper != null){

			// SF009 - Adiconar na coleção para gerar o resumo faturamento
			// simulação
			boolean adcionar = true;
			if(colecaoResumoFaturamentoSimulacao != null && !colecaoResumoFaturamentoSimulacao.isEmpty()){

				Iterator iteratorColecaoResumoFaturamento = colecaoResumoFaturamentoSimulacao.iterator();

				boolean achou = true;

				while(iteratorColecaoResumoFaturamento.hasNext() && achou){

					// resumo faturamento simulçao na coleção
					resumoFaturamentoSimulacaoNaColecao = (ResumoFaturamentoSimulacao) iteratorColecaoResumoFaturamento.next();

					if(resumoFaturamentoSimulacaoNaColecao.getAnoMesReferencia().intValue() == anoMesReferencia
									&& resumoFaturamentoSimulacaoNaColecao.getFaturamentoGrupo().getId().intValue() == faturamentoGrupo
													.getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getLocalidade().getId().intValue() == imovel.getLocalidade()
													.getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getQuadra().getId().intValue() == imovel.getQuadra().getId()
													.intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getLigacaoAguaSituacao().getId().intValue() == imovel
													.getLigacaoAguaSituacao().getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getLigacaoEsgotoSituacao().getId().intValue() == imovel
													.getLigacaoEsgotoSituacao().getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getCategoria().getId().intValue() == categoria.getId()
													.intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getImovelPerfil().getId().intValue() == imovel.getImovelPerfil()
													.getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getIndicadorDebitoConta().shortValue() == imovel
													.getIndicadorDebitoConta().shortValue()
									&& resumoFaturamentoSimulacaoNaColecao.getGerenciaRegional().getId().intValue() == imovel
													.getLocalidade().getGerenciaRegional().getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getSetorComercial().getId().intValue() == imovel
													.getSetorComercial().getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getRota().getId().intValue() == imovel.getRota().getId()
													.intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getIndicadorSimulacao().equals(indicadorSimulacao)

					){
						EsferaPoder esferaPoder = null;

						if(imovel.getClienteImoveis() != null && !imovel.getClienteImoveis().isEmpty()){

							ClienteImovel clienteImovel = (ClienteImovel) imovel.getClienteImoveis().iterator().next();

							if(clienteImovel.getCliente() != null && clienteImovel.getCliente().getClienteTipo() != null){
								esferaPoder = clienteImovel.getCliente().getClienteTipo().getEsferaPoder();
							}
						}

						if(resumoFaturamentoSimulacaoNaColecao.getEsferaPoder() != null && esferaPoder != null){

							if(resumoFaturamentoSimulacaoNaColecao.getEsferaPoder().getId().intValue() == esferaPoder.getId().intValue()){

								if(primeiraCategoria){

									// ATUALIZA A QUANTIDADE DE CONTAS ****
									resumoFaturamentoSimulacaoNaColecao.setQuantidadeContas(resumoFaturamentoSimulacaoNaColecao
													.getQuantidadeContas() + 1);
								}
								achou = false;
								adcionar = false;
							}
						}

						if(resumoFaturamentoSimulacaoNaColecao.getEsferaPoder() == null && esferaPoder == null){

							if(primeiraCategoria){
								// ATUALIZA A QUANTIDADE DE CONTAS ****
								resumoFaturamentoSimulacaoNaColecao.setQuantidadeContas(resumoFaturamentoSimulacaoNaColecao
												.getQuantidadeContas() + 1);
							}
							achou = false;
							adcionar = false;
						}
					}
				}

				// se é para acumular ou para inserir na coleção
				// acumula se tiver algum igual
				if(!adcionar){

					int qtdEconomias = resumoFaturamentoSimulacaoNaColecao.getQuantidadeEconomia().intValue();

					if(subCategoria.getId().intValue() != Subcategoria.SUBCATEGORIA_ZERO.getId().intValue()){
						qtdEconomias = qtdEconomias + subCategoria.getQuantidadeEconomias().intValue();
					}else{
						qtdEconomias = qtdEconomias + categoria.getQuantidadeEconomiasCategoria().intValue();
					}

					// acumula os dados dos dados do resumo ja existente
					// quantidade economia
					resumoFaturamentoSimulacaoNaColecao.setQuantidadeEconomia((short) qtdEconomias);

					// valor agua
					if(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria() != null){
						resumoFaturamentoSimulacaoNaColecao.setValorAgua(resumoFaturamentoSimulacaoNaColecao.getValorAgua().add(
										calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria()));
					}

					// consumo agua
					if(calcularValoresAguaEsgotoHelper.getConsumoFaturadoAguaCategoria() != null){

						resumoFaturamentoSimulacaoNaColecao.setConsumoAgua(Integer.valueOf(resumoFaturamentoSimulacaoNaColecao
										.getConsumoAgua().intValue()
										+ calcularValoresAguaEsgotoHelper.getConsumoFaturadoAguaCategoria().intValue()));
					}

					// valor esgoto
					if(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria() != null){

						resumoFaturamentoSimulacaoNaColecao.setValorEsgoto(resumoFaturamentoSimulacaoNaColecao.getValorEsgoto().add(
										calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria()));
					}

					// consumo esgoto
					if(calcularValoresAguaEsgotoHelper.getConsumoFaturadoEsgotoCategoria() != null){

						resumoFaturamentoSimulacaoNaColecao.setConsumoEsgoto(Integer.valueOf(resumoFaturamentoSimulacaoNaColecao
										.getConsumoEsgoto().intValue()
										+ calcularValoresAguaEsgotoHelper.getConsumoFaturadoEsgotoCategoria().intValue()));
					}

					// valor debitos
					if(valorTotalDebitos != null){
						resumoFaturamentoSimulacaoNaColecao.setValorDebitos(resumoFaturamentoSimulacaoNaColecao.getValorDebitos().add(
										valorTotalDebitos));
					}
					// valor creditos
					if(valorTotalCreditos != null){
						resumoFaturamentoSimulacaoNaColecao.setValorCreditos(resumoFaturamentoSimulacaoNaColecao.getValorCreditos().add(
										valorTotalCreditos));
					}

					resumoFaturamentoSimulacaoNaColecao.setUltimaAlteracao(new Date());
				}else{
					ResumoFaturamentoSimulacao resumoFaturamentoSimulacao = criarObjetoResumoFaturamentoSimulacao(anoMesReferencia, imovel,
									categoria, subCategoria, calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria(),
									calcularValoresAguaEsgotoHelper.getConsumoFaturadoAguaCategoria(),
									calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria(),
									calcularValoresAguaEsgotoHelper.getConsumoFaturadoEsgotoCategoria(), valorTotalDebitos,
									valorTotalCreditos, primeiraCategoria, faturamentoSimulacaoComando, faturamentoGrupo);

					// adiciona
					colecaoResumoFaturamentoSimulacao.add(resumoFaturamentoSimulacao);

				}
				// se a coleção vazia
				// caso for a primeira vez e tenha os valores de agua e esgoto e
				// categoria, será adicionado um resumo faturamento
			}else{
				adcionar = true;
				ResumoFaturamentoSimulacao resumoFaturamentoSimulacao = criarObjetoResumoFaturamentoSimulacao(anoMesReferencia, imovel,
								categoria, subCategoria, calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria(),
								calcularValoresAguaEsgotoHelper.getConsumoFaturadoAguaCategoria(),
								calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria(),
								calcularValoresAguaEsgotoHelper.getConsumoFaturadoEsgotoCategoria(), valorTotalDebitos, valorTotalCreditos,
								primeiraCategoria, faturamentoSimulacaoComando, faturamentoGrupo);
				// adiciona
				colecaoResumoFaturamentoSimulacao.add(resumoFaturamentoSimulacao);
			}

			// se so tiver categoria e não tiver valores de agua e esgoto
		}else if(categoria != null){

			boolean adcionar = true;
			// se existe dados na coleção
			if(!colecaoResumoFaturamentoSimulacao.isEmpty()){

				Iterator iteratorColecaoResumoFaturamento = colecaoResumoFaturamentoSimulacao.iterator();
				boolean achou = true;
				while(iteratorColecaoResumoFaturamento.hasNext() && achou){

					resumoFaturamentoSimulacaoNaColecao = (ResumoFaturamentoSimulacao) iteratorColecaoResumoFaturamento.next();

					if(resumoFaturamentoSimulacaoNaColecao.getAnoMesReferencia().intValue() == anoMesReferencia
									&& resumoFaturamentoSimulacaoNaColecao.getFaturamentoGrupo().getId().intValue() == faturamentoGrupo
													.getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getLocalidade().getId().intValue() == imovel.getLocalidade()
													.getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getQuadra().getId().intValue() == imovel.getQuadra().getId()
													.intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getLigacaoAguaSituacao().getId().intValue() == imovel
													.getLigacaoAguaSituacao().getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getLigacaoEsgotoSituacao().getId().intValue() == imovel
													.getLigacaoEsgotoSituacao().getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getCategoria().getId().intValue() == categoria.getId()
													.intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getImovelPerfil().getId().intValue() == imovel.getImovelPerfil()
													.getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getIndicadorDebitoConta().shortValue() == imovel
													.getIndicadorDebitoConta().shortValue()
									&& resumoFaturamentoSimulacaoNaColecao.getGerenciaRegional().getId().intValue() == imovel
													.getLocalidade().getGerenciaRegional().getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getSetorComercial().getId().intValue() == imovel
													.getSetorComercial().getId().intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getRota().getId().intValue() == imovel.getRota().getId()
													.intValue()
									&& resumoFaturamentoSimulacaoNaColecao.getIndicadorSimulacao().equals(indicadorSimulacao)){
						EsferaPoder esferaPoder = null;

						if(imovel.getClienteImoveis() != null && !imovel.getClienteImoveis().isEmpty()){

							ClienteImovel clienteImovel = (ClienteImovel) imovel.getClienteImoveis().iterator().next();

							if(clienteImovel.getCliente() != null && clienteImovel.getCliente().getClienteTipo() != null){
								esferaPoder = clienteImovel.getCliente().getClienteTipo().getEsferaPoder();
							}
						}

						if(resumoFaturamentoSimulacaoNaColecao.getEsferaPoder() != null && esferaPoder != null){

							if(resumoFaturamentoSimulacaoNaColecao.getEsferaPoder().getId().intValue() == esferaPoder.getId().intValue()){

								if(primeiraCategoria){
									// ATUALIZA A QUANTIDADE DE CONTAS ****
									resumoFaturamentoSimulacaoNaColecao.setQuantidadeContas(resumoFaturamentoSimulacaoNaColecao
													.getQuantidadeContas() + 1);
								}
								achou = false;
								adcionar = false;
							}
						}
						if(resumoFaturamentoSimulacaoNaColecao.getEsferaPoder() == null && esferaPoder == null){

							if(primeiraCategoria){
								// ATUALIZA A QUANTIDADE DE CONTAS ****
								resumoFaturamentoSimulacaoNaColecao.setQuantidadeContas(resumoFaturamentoSimulacaoNaColecao
												.getQuantidadeContas() + 1);
							}
							achou = false;
							adcionar = false;
						}
					}
				}

				// verifica se é para acumular ou para inserir na coleção
				if(!adcionar){

					int qtdEconomias = resumoFaturamentoSimulacaoNaColecao.getQuantidadeEconomia().intValue();

					if(subCategoria.getId().intValue() != Subcategoria.SUBCATEGORIA_ZERO.getId().intValue()){
						qtdEconomias = qtdEconomias + subCategoria.getQuantidadeEconomias().intValue();
					}else{
						qtdEconomias = qtdEconomias + categoria.getQuantidadeEconomiasCategoria().intValue();
					}

					// caso necessário acumulado no faturamento simulação
					// if (indicePosicaoParaAcumular != -1) {
					// acumula os dados dos dados do resumo ja existente
					resumoFaturamentoSimulacaoNaColecao.setQuantidadeEconomia((short) qtdEconomias);

					// valor total debitos
					if(valorTotalDebitos != null){
						resumoFaturamentoSimulacaoNaColecao.setValorDebitos(resumoFaturamentoSimulacaoNaColecao.getValorDebitos().add(
										valorTotalDebitos));
					}

					// valor total creditos
					if(valorTotalCreditos != null){
						resumoFaturamentoSimulacaoNaColecao.setValorCreditos(resumoFaturamentoSimulacaoNaColecao.getValorCreditos().add(
										valorTotalCreditos));
					}

					resumoFaturamentoSimulacaoNaColecao.setUltimaAlteracao(new Date());

				}else{
					ResumoFaturamentoSimulacao resumoFaturamentoSimulacaoInserir = criarObjetoResumoFaturamentoSimulacao(anoMesReferencia,
									imovel, categoria, subCategoria, new BigDecimal(0), Integer.valueOf(0), new BigDecimal(0),
									Integer.valueOf(0), valorTotalDebitos, valorTotalCreditos, primeiraCategoria,
									faturamentoSimulacaoComando, faturamentoGrupo);

					colecaoResumoFaturamentoSimulacao.add(resumoFaturamentoSimulacaoInserir);
				}

				// se não tiver dados o primeiro resumo tem os valores zerados
				// COLECAO VAZIA
			}else{// adiciona se não tiver dados na coleção

				adcionar = true;

				ResumoFaturamentoSimulacao resumoFaturamentoSimulacaoInserir = criarObjetoResumoFaturamentoSimulacao(anoMesReferencia,
								imovel, categoria, subCategoria, new BigDecimal(0), Integer.valueOf(0), new BigDecimal(0),
								Integer.valueOf(0), valorTotalDebitos, valorTotalCreditos, primeiraCategoria, faturamentoSimulacaoComando,
								faturamentoGrupo);

				colecaoResumoFaturamentoSimulacao.add(resumoFaturamentoSimulacaoInserir);
			}

		}
	}

	/**
	 * [UC0113] - Faturar Grupo Faturamento
	 * Cria um Objeto ResumoFaturamentoSimulacao com os valores passados
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 28/04/2006, 07/09/2006
	 * @param anoMesReferencia
	 * @param faturamentoAtivCronRota
	 * @param imovel
	 * @param categoria
	 * @param gerarAtiviadadeGrupoFaturamento
	 * @param valorAgua
	 * @param consumoAgua
	 * @param valorEsgoto
	 * @param valorTotalDebitos
	 * @param valorTotalCreditos
	 * @return
	 */
	private ResumoFaturamentoSimulacao criarObjetoResumoFaturamentoSimulacao(Integer anoMesReferencia, Imovel imovel, Categoria categoria,
					Subcategoria subCategoria, BigDecimal valorAgua, Integer consumoAgua, BigDecimal valorEsgoto, Integer consumoEsgoto,
					BigDecimal valorTotalDebitos, BigDecimal valorTotalCreditos, boolean primeiraCategoria,
					FaturamentoSimulacaoComando faturamentoSimulacaoComando, FaturamentoGrupo faturamentoGrupo){

		ResumoFaturamentoSimulacao resumoFaturamentoSimulacao = new ResumoFaturamentoSimulacao();

		resumoFaturamentoSimulacao.setAnoMesReferencia(anoMesReferencia);
		resumoFaturamentoSimulacao.setFaturamentoGrupo(faturamentoGrupo);
		resumoFaturamentoSimulacao.setLocalidade(imovel.getLocalidade());
		resumoFaturamentoSimulacao.setQuadra(imovel.getQuadra());
		resumoFaturamentoSimulacao.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
		resumoFaturamentoSimulacao.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
		resumoFaturamentoSimulacao.setLigacaoAguaSituacao(imovel.getLigacaoAguaSituacao());
		resumoFaturamentoSimulacao.setLigacaoEsgotoSituacao(imovel.getLigacaoEsgotoSituacao());
		resumoFaturamentoSimulacao.setCategoria(categoria);
		resumoFaturamentoSimulacao.setImovelPerfil(imovel.getImovelPerfil());
		resumoFaturamentoSimulacao.setIndicadorDebitoConta(imovel.getIndicadorDebitoConta());
		resumoFaturamentoSimulacao.setUnidadeNegocio(imovel.getLocalidade().getUnidadeNegocio());

		if(primeiraCategoria){
			resumoFaturamentoSimulacao.setQuantidadeContas(1);
		}else{
			resumoFaturamentoSimulacao.setQuantidadeContas(0);
		}

		resumoFaturamentoSimulacao.setGerenciaRegional(imovel.getLocalidade().getGerenciaRegional());
		resumoFaturamentoSimulacao.setSetorComercial(imovel.getSetorComercial());
		if(imovel.getQuadra() != null){
			resumoFaturamentoSimulacao.setRota(imovel.getRota());
		}

		resumoFaturamentoSimulacao.setUltimaAlteracao(new Date());

		if(faturamentoSimulacaoComando == null){

			resumoFaturamentoSimulacao.setIndicadorSimulacao(ConstantesSistema.NAO.intValue());
		}else{
			resumoFaturamentoSimulacao.setIndicadorSimulacao(ConstantesSistema.SIM.intValue());
		}

		// esfera do poder
		if(imovel.getClienteImoveis() != null && !imovel.getClienteImoveis().isEmpty()){

			ClienteImovel clienteImovel = (ClienteImovel) imovel.getClienteImoveis().iterator().next();
			Cliente cliente = clienteImovel.getCliente();
			if(cliente != null && cliente.getClienteTipo() != null){
				EsferaPoder esferaPoder = cliente.getClienteTipo().getEsferaPoder();
				resumoFaturamentoSimulacao.setEsferaPoder(esferaPoder);
			}
		}

		resumoFaturamentoSimulacao.setSubCategoria(subCategoria);

		// Caso seja subcategoria zero pega a quantidade da categoria.
		if(subCategoria.getId().intValue() == Subcategoria.SUBCATEGORIA_ZERO.getId().intValue()){
			resumoFaturamentoSimulacao.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria().shortValue());
		}else{
			resumoFaturamentoSimulacao.setQuantidadeEconomia(subCategoria.getQuantidadeEconomias().shortValue());
		}

		// valor agua
		if(valorAgua != null){
			resumoFaturamentoSimulacao.setValorAgua(valorAgua);
		}else{
			resumoFaturamentoSimulacao.setValorAgua(new BigDecimal("0.00"));

		}
		// consumo agua
		if(consumoAgua != null){
			resumoFaturamentoSimulacao.setConsumoAgua(consumoAgua);
		}else{
			resumoFaturamentoSimulacao.setConsumoAgua(Integer.valueOf("0"));
		}
		// valor esgoto
		if(valorEsgoto != null){
			resumoFaturamentoSimulacao.setValorEsgoto(valorEsgoto);
		}else{
			resumoFaturamentoSimulacao.setValorEsgoto(new BigDecimal("0.00"));
		}
		// consumo esgoto
		if(consumoEsgoto != null){
			resumoFaturamentoSimulacao.setConsumoEsgoto(consumoEsgoto);
		}else{
			resumoFaturamentoSimulacao.setConsumoEsgoto(Integer.valueOf("0"));

		}
		// valor total debitos
		if(valorTotalDebitos != null){
			resumoFaturamentoSimulacao.setValorDebitos(valorTotalDebitos);
		}else{
			resumoFaturamentoSimulacao.setValorDebitos(new BigDecimal("0.00"));
		}
		// valor toral creditos
		if(valorTotalCreditos != null){
			resumoFaturamentoSimulacao.setValorCreditos(valorTotalCreditos);
		}else{
			resumoFaturamentoSimulacao.setValorCreditos(new BigDecimal("0.00"));
		}

		if(faturamentoSimulacaoComando != null){

			resumoFaturamentoSimulacao.setFaturamentoSimulacaoComando(faturamentoSimulacaoComando);
		}

		return resumoFaturamentoSimulacao;
	}

	/**
	 * Verifica se o imóvel gera conta ou não.
	 * [UC0113] - Faturar Grupo de Faturamento [SF0003] - Verificar Não Geração da Conta
	 * 
	 * @author Leonardo Vieira, Pedro Alexandre
	 * @date 17/01/2006,13/09/2006
	 * @author eduardo henrique
	 * @date 22/09/2008 Alterações no [SB0003] para a v0.05
	 * @author Saulo Lima, eduardo henrique
	 * @date 15/09/2009 Alteração para não emitir contas com valor inferior ao determinado em
	 *       Sistema Parametros Alteração para método não considerar
	 *       Débitos a Cobrar que tiverem adiantamentos válidos para cobrança
	 * @param imovel
	 * @param valorTotalAgua
	 * @param valorTotalEsgoto
	 * @param anoMesFaturamento
	 * @return <true> se for para gerar conta, <false> caso contrário
	 * @throws ControladorException
	 */
	public boolean verificarNaoGeracaoConta(Imovel imovel, BigDecimal valorTotalAgua, BigDecimal valorTotalEsgoto, int anoMesFaturamento)
					throws ControladorException{

		BigDecimal zeroValor = BigDecimal.ZERO;
		boolean retorno = true;
		boolean primeiraCondicao = false;
		boolean segundaCondicao = true;

		/*
		 * Caso o valor total da água e o valor total do esgoto seja igual a zero.
		 */
		if(valorTotalAgua.compareTo(zeroValor) == 0 && valorTotalEsgoto.compareTo(zeroValor) == 0){
			primeiraCondicao = true;
		}

		Collection<DebitoACobrar> colecaoDebitosACobrar = null;
		Collection<CreditoARealizar> colecaoCreditosARealizar = null;

		colecaoDebitosACobrar = this.obterDebitoACobrarImovel(imovel.getId(), DebitoCreditoSituacao.NORMAL, anoMesFaturamento);
		// valida que débitos a cobrar serão "realmente válidos" para a cobrança
		if(colecaoDebitosACobrar != null){
			for(Iterator<DebitoACobrar> iterator = colecaoDebitosACobrar.iterator(); iterator.hasNext();){
				DebitoACobrar debitoACobrar = iterator.next();

				boolean debitoACobrarEmExtratoValido = verificarDebitoACobrarEmDocumentoCobranca(debitoACobrar);
				if(debitoACobrarEmExtratoValido){
					iterator.remove();
				}
			}
		}

		// [SB0017] - Verificar Titularidade do Débito
		this.verificarTitularidadeDebitoCredito(imovel.getId(), null, colecaoDebitosACobrar, null);

		/*
		 * Não existam débitos a cobrar (não existem débitos na tabela DEBITO_A_COBRAR com
		 * IMOV_ID=IMOV_ID e DCST_IDATUAL com o valor correspondente a
		 * normal (valor=0) e DBAC_NNPRESTACAOCOBRADAS menor que DBAC_NNPRESTACAODEBITO)
		 * [FS0005] - Verificar Débitos a cobrar de parcelamento OBS - O [FS0005] já está
		 * incorporado no método obterDebitoACobrarImovel
		 */
		if(colecaoDebitosACobrar == null || colecaoDebitosACobrar.isEmpty()){
			segundaCondicao = true;
		}else if(primeiraCondicao){

			/*
			 * e os débitos a cobrar sejam todos correspondentes a tipo de debito com indicador de
			 * geração de conta igual a NÃO (DBTP_ICGERACAOCONTA=2
			 * da tabela DEBITO_TIPO com DBTP_ID da tabela DEBITO_A_COBRAR)
			 */
			Iterator<DebitoACobrar> iteratorColecaoDebitosACobrar = colecaoDebitosACobrar.iterator();
			BigDecimal valorDebitos = BigDecimal.ZERO;

			while(iteratorColecaoDebitosACobrar.hasNext()){

				DebitoACobrar debitoACobrar = iteratorColecaoDebitosACobrar.next();
				valorDebitos = valorDebitos.add(debitoACobrar.getValorTotal());
			}

			SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();
			BigDecimal valorMinimoEmissaoConta = sistemaParametros.getValorMinimoEmissaoConta();

			if(valorDebitos.compareTo(valorMinimoEmissaoConta) == -1){
				segundaCondicao = true;
			}else{

				Collection<CreditoARealizar> colecaoCreditosARealizarTemp = this.obterCreditoARealizarImovel(imovel.getId());
				colecaoCreditosARealizar = this.verificarCreditosARealizarDeParcelamento(colecaoCreditosARealizarTemp, anoMesFaturamento);

				// [SB0018] - Verificar Titularidade do Crédito
				this.verificarTitularidadeDebitoCredito(imovel.getId(), null, null, colecaoCreditosARealizar);

				/*
				 * ... ou, caso existam, não existam créditos a realizar (não existem créditos na
				 * tabela CREDITO_A_REALIZAR com IMOV_ID=IMOV_ID do
				 * imóvel e DCST_IDATUAL com o valor correspondente a normal (valor=0) e
				 * (CRAR_NNPRESTACAOREALIZADAS menor que CRAR_NNPRESTACAOCREDITO
				 * ou CRAR_VLRESIDUALMESANTERIOR maior que zero))
				 */
				if(colecaoCreditosARealizar != null && !colecaoCreditosARealizar.isEmpty()){

					Iterator<CreditoARealizar> iteratorCreditosARealizar = colecaoCreditosARealizar.iterator();
					BigDecimal valorCreditos = BigDecimal.ZERO;

					while(iteratorCreditosARealizar.hasNext()){

						CreditoARealizar creditosARealizar = iteratorCreditosARealizar.next();
						valorCreditos = valorCreditos.add(creditosARealizar.getValorTotal());
					}

					if(valorDebitos.subtract(valorCreditos).compareTo(valorMinimoEmissaoConta) == -1){
						segundaCondicao = true;
					}else{
						segundaCondicao = false;
					}

				}else{
					segundaCondicao = false;
				}
			}
		}

		if(colecaoDebitosACobrar != null){
			colecaoDebitosACobrar.clear();
			colecaoDebitosACobrar = null;
		}

		if(colecaoCreditosARealizar != null){
			colecaoCreditosARealizar.clear();
			colecaoCreditosARealizar = null;
		}

		// Caso as duas condições sejam verdadeiras não gera a conta.
		if(primeiraCondicao && segundaCondicao){
			retorno = false;
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Inclui o movimento de débito automático no sistema.
	 * [SB0008] - Gerar Movimento de Débito Automático
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 17/01/2006, 18/09/2006
	 * @param imovel
	 * @param conta
	 * @param valorDebito
	 * @param faturamentoAtivCronRota
	 * @throws ControladorException
	 */
	public void gerarMovimentoDebitoAutomatico(Imovel imovel, Conta conta, BigDecimal valorDebito,
					FaturamentoAtivCronRota faturamentoAtivCronRota, Short indicadorExclusao,
					DebitoAutomaticoMovimentoCancelamentoMotivo debitoAutomaticoMovimentoMotivoCancelamento) throws ControladorException{

		try{

			if(repositorioFaturamento.verificarExistenciaDebitoAutomaticoMovimentoConta(conta.getId()) == null){

				DebitoAutomaticoMovimento debitoAutomaticoMovimento = new DebitoAutomaticoMovimento();

				debitoAutomaticoMovimento.setDataVencimento(conta.getDataVencimentoConta());
				Integer idDebitoAutomatico = null;

				DebitoAutomatico debitoAutomatico = new DebitoAutomatico();
				idDebitoAutomatico = repositorioFaturamento.obterDebitoAutomatico(imovel.getId());
				debitoAutomatico.setId(idDebitoAutomatico);
				debitoAutomaticoMovimento.setDebitoAutomatico(debitoAutomatico);

				FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
				filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, conta.getId()));

				Collection colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral, ContaGeral.class.getName());

				ContaGeral contaGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);

				debitoAutomaticoMovimento.setContaGeral(contaGeral);

				debitoAutomaticoMovimento.setDebitoAutomaticoRetornoCodigo(null);
				debitoAutomaticoMovimento.setFaturamentoGrupo(faturamentoAtivCronRota.getRota().getFaturamentoGrupo());
				debitoAutomaticoMovimento.setProcessamento(new Date());
				debitoAutomaticoMovimento.setEnvioBanco(null);
				debitoAutomaticoMovimento.setRetornoBanco(null);
				debitoAutomaticoMovimento.setUltimaAlteracao(new Date());
				debitoAutomaticoMovimento.setNumeroSequenciaArquivoEnviado(null);
				debitoAutomaticoMovimento.setNumeroSequenciaArquivoRecebido(null);
				debitoAutomaticoMovimento.setValorDebito(valorDebito);
				debitoAutomaticoMovimento.setIndicadorExclusao(indicadorExclusao);
				debitoAutomaticoMovimento.setDebitoAutomaticoMovimentoCancelamentoMotivo(debitoAutomaticoMovimentoMotivoCancelamento);

				this.repositorioFaturamento.inserirDebitoAutomaticoMovimento(debitoAutomaticoMovimento);

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0113] - Gerar Faturamento Grupo
	 * [SF007] - Determinar Vencimento da Conta Determina o Vencimento da Conta
	 * 
	 * @Auhor: Rafael Santos
	 * @Date:17/02/2006
	 * @return Data do Vencimento da Conta
	 */
	private Date determinarVencimentoConta(Imovel imovel, FaturamentoAtivCronRota faturamentoAtivCronRota, SistemaParametro sistemaParametro)
					throws ControladorException{

		try{

			Date dataVencimentoConta = null;
			Short diaVencimentoAlternativo = null;
			Short diaVencimentoClienteResponsavel = null;

			// Verifica se o grupo tem vencimento informado para débito automático e se o imóvel é
			// débito automático
			boolean imovelDebitoAutomaticoVencGrupo = false;

			if(faturamentoAtivCronRota.getRota().getFaturamentoGrupo().getDiaVencimentoDebitoAutomatico() != null
							&& imovel.getIndicadorDebitoConta().equals(ConstantesSistema.SIM)){

				imovelDebitoAutomaticoVencGrupo = true;
			}

			// Verifica se o grupo tem vencimento informado para entraga em enderço alternativo e se
			// o imóvel atende a uma das condições de entrega em emdereço alternativo
			boolean imovelEntregaAlternativaVencGrupo = false;

			if(faturamentoAtivCronRota.getRota().getFaturamentoGrupo().getDiaVencimentoEntregaAlternativa() != null
							&& (imovel.getImovelContaEnvio().getId().equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL)
											|| imovel.getImovelContaEnvio().getId().equals(ImovelContaEnvio.ENVIAR_PARA_CLIENTE_USUARIO) || imovel
											.getImovelContaEnvio().getId().equals(ImovelContaEnvio.ENVIAR_PARA_CLIENTE_PROPRIETARIO))){

				imovelEntregaAlternativaVencGrupo = true;
			}

			/*
			 * Se o imóvel possuir vencimento cadastrado ou o grupo de faturamento da rota do imóvel
			 * tenha dia de vencimento para débito automático informado e o imóvel seja débito
			 * automático ou o grupo de faturamento da rota do imóvel tenha dia de vencimento para
			 * endereço de entrega alternativa informado e o imóvel possua entrega em endereço
			 * alternativo
			 */
			if(imovel.getDiaVencimento() != null || imovelDebitoAutomaticoVencGrupo || imovelEntregaAlternativaVencGrupo){

				if(imovelDebitoAutomaticoVencGrupo){

					/*
					 * Se o grupo de faturamento da rota do imóvel tenha dia de vencimento para
					 * débito automático informado e o imóvel for débito automático, atribui-se o
					 * dia de vencimento para débito automático do grupo ao dia de vencimento
					 * alternativo
					 */
					diaVencimentoAlternativo = faturamentoAtivCronRota.getRota().getFaturamentoGrupo().getDiaVencimentoDebitoAutomatico();

				}else if(imovelEntregaAlternativaVencGrupo){

					/*
					 * Se Não, Se o grupo de faturamento da rota do imóvel tenha dia de vencimento
					 * para endereço de entrega alternativa informado e o imóvel possua entrega em
					 * endereço alternativo, atribui-se o dia de vencimento para endereço de entrega
					 * alternativa do grupo ao dia vencimento alternativo
					 */
					diaVencimentoAlternativo = faturamentoAtivCronRota.getRota().getFaturamentoGrupo().getDiaVencimentoEntregaAlternativa();
				}else if(imovel.getIndicadorEmissaoExtratoFaturamento() == null
								|| imovel.getIndicadorEmissaoExtratoFaturamento().shortValue() == (Short.parseShort("2"))){

					/*
					 * Se Não, Se o indicador emissão extrato faturamento do imóvel estiver com
					 * valor 2 ou nulo, atribui-se o dia vencimento cadastrado ao dia de vencimento
					 * alternativo
					 */
					diaVencimentoAlternativo = imovel.getDiaVencimento();
				}else{

					diaVencimentoClienteResponsavel = repositorioFaturamento.pesquisarClienteImovelGrupoFaturamento(imovel.getId(),
									ClienteRelacaoTipo.RESPONSAVEL);

					// Se possuir dia vencimento cadastrado para o cliente responsável
					if(diaVencimentoClienteResponsavel != null){

						// atribui-se o dia de vencimento do cliente ao dia de vencimento
						// alternativo
						diaVencimentoAlternativo = diaVencimentoClienteResponsavel;
					}else{

						// Se Não, atribui-se o último dia do mês de vencimento do cronograma ao dia
						// de vencimento alternativo
						Calendar calendar = new GregorianCalendar();

						calendar.setTime(faturamentoAtivCronRota.getDataContaVencimento());
						diaVencimentoAlternativo = new Short(calendar.getMaximum(Calendar.DAY_OF_MONTH) + "");
					}
				}

			}else{

				diaVencimentoClienteResponsavel = repositorioFaturamento.pesquisarClienteImovelGrupoFaturamento(imovel.getId(),
								ClienteRelacaoTipo.RESPONSAVEL);

				// Se possuir dia vencimento cadastrado para o cliente responsável
				if(diaVencimentoClienteResponsavel != null){

					// atribui-se o dia de vencimento do cliente ao dia de vencimento alternativo
					diaVencimentoAlternativo = diaVencimentoClienteResponsavel;
				}else{

					// atribui-se nulo ao dia de vencimento alternativo
					diaVencimentoAlternativo = null;
				}
			}

			/*
			 * Se o dia de vencimento alternativo for diferente de nulo (Se o imóvel tem vencimento
			 * alternativo)
			 */
			if(diaVencimentoAlternativo != null){

				Calendar diaVencimentoRotaCalendar = new GregorianCalendar();
				diaVencimentoRotaCalendar.setTime(faturamentoAtivCronRota.getDataContaVencimento());

				/*
				 * Se o dia de vencimento do cronograma for menor ou igual ao dia de vencimento
				 * alternativo
				 */
				if(diaVencimentoRotaCalendar.get(Calendar.DAY_OF_MONTH) <= diaVencimentoAlternativo.intValue()){

					String anteciparDataVencimentoFevereiroMaior28 = ((String) ParametroFaturamento.P_ANTECIPAR_DATA_VENCIMENTO_FEVEREIRO_MAIOR_28
									.executar(this));

					/*
					 * Se o mês do vencimento do cronograma for fevereiro e o dia de vencimento
					 * alternativo seja maior que 28 e o parâmetro
					 * P_ANTECIPAR_DATA_VENCIMENTO_FEVEREIRO_MAIOR_28 esteja com valor igual a 1
					 */
					if(diaVencimentoRotaCalendar.get(Calendar.MONTH) == Calendar.FEBRUARY && diaVencimentoAlternativo.intValue() > 28
									&& anteciparDataVencimentoFevereiroMaior28.equals(ConstantesSistema.SIM.toString())){

						/*
						 * Atribui-se ao dia de vencimento alternativo o último dia do mês de
						 * vencimento do cronograma
						 */
						diaVencimentoAlternativo = Short.valueOf(Util.obterUltimoDiaMes(diaVencimentoRotaCalendar.get(Calendar.MONTH) + 1,
										diaVencimentoRotaCalendar.get(Calendar.YEAR)));
					}


					/*
					 * É determinado o vencimento da conta com o dia de vencimento alternativo e o
					 * mês/ano do cronograma
					 */
					Calendar data = new GregorianCalendar();
					data.set(Calendar.DAY_OF_MONTH, diaVencimentoAlternativo.intValue());
					data.set(Calendar.MONTH, diaVencimentoRotaCalendar.get(Calendar.MONTH));
					data.set(Calendar.YEAR, diaVencimentoRotaCalendar.get(Calendar.YEAR));
					dataVencimentoConta = data.getTime();

				}else{

					String testarRelacaoAlternativoCronograma = ((String) ParametroFaturamento.P_TESTAR_VENCIMENTO_ALTERNATIVO_VERSUS_VENCIMENTO_CRONOGRAMA
									.executar(this));

					String numeroDiasEntreVencAlternativoVencCronogramaStr = ((String) ParametroFaturamento.P_NUMERO_DIAS_ENTRE_VENCIMENTO_ALTERNATIVO_VENCIMENTO_CRONOGRAMA
									.executar(this));

					int numeroDiasEntreVencAlternativoVencCronograma = 0;

					if(Util.isInteger(numeroDiasEntreVencAlternativoVencCronogramaStr)){
						numeroDiasEntreVencAlternativoVencCronograma = Integer.parseInt(numeroDiasEntreVencAlternativoVencCronogramaStr);
					}

					/*
					 * Se P_TESTAR_VENCIMENTO_ALTERNATIVO_VERSUS_VENCIMENTO_CRONOGRAMA for igual a 1
					 * e o dia de vencimento do cronograma menos o dia de vencimento alternativo for
					 * maior que o valor do parâmetro
					 * P_NUMERO_DIAS_ENTRE_VENCIMENTO_ALTERNATIVO_VENCIMENTO_CRONOGRAMA
					 */
					if(testarRelacaoAlternativoCronograma.equals(ConstantesSistema.SIM.toString())
									&& (diaVencimentoRotaCalendar.get(Calendar.DAY_OF_MONTH) - diaVencimentoAlternativo.intValue()) > numeroDiasEntreVencAlternativoVencCronograma){

						/*
						 * É determinado o vencimento da conta com o dia de vencimento alternativo,
						 * sendo o mês do vencimento do cronograma mais um mês
						 */
						Calendar data = new GregorianCalendar();
						data.set(Calendar.DAY_OF_MONTH, diaVencimentoAlternativo.intValue());
						data.set(Calendar.MONTH, diaVencimentoRotaCalendar.get(Calendar.MONTH));
						data.set(Calendar.YEAR, diaVencimentoRotaCalendar.get(Calendar.YEAR));

						// Soma um mês à data, verificando o último dia do mês
						dataVencimentoConta = Util.somaMesData(data.getTime(), 1, true);
					}else{

						Calendar data1 = new GregorianCalendar();
						data1.set(Calendar.DAY_OF_MONTH, diaVencimentoAlternativo.intValue());
						data1.set(Calendar.MONTH, diaVencimentoRotaCalendar.get(Calendar.MONTH));
						data1.set(Calendar.YEAR, diaVencimentoRotaCalendar.get(Calendar.YEAR));

						Calendar data2 = new GregorianCalendar();
						data2.setTime(new Date());
						data2.add(Calendar.DAY_OF_MONTH, sistemaParametro.getNumeroMinimoDiasEmissaoVencimento());

						/*
						 * Se Não, Se a data composta pelo dia de vencimento alternativo e o mês de
						 * vencimento do cronograma for menor que a data composta pelo dia de hoje
						 * mais quantidade de dias indicada em sistema parâmetros
						 * (parm_nnminimodiasemissaovencim)
						 */
						if(data1.compareTo(data2) < 0){

							String somarDiasProximoFaturamentoAoVencimento = ((String) ParametroFaturamento.P_SOMAR_DIAS_PROXIMO_FATURAMENTO_VENCIMENTO
											.executar(this));

							/*
							 * Se o parâmetro P_SOMAR_DIAS_PROXIMO_FATURAMENTO_VENCIMENTO estiver
							 * com valor igual a 1
							 */
							if(somarDiasProximoFaturamentoAoVencimento.equals(ConstantesSistema.SIM.toString())){

								/*
								 * É determinado o vencimento da conta com a data composta pelo dia
								 * de hoje mais quantidade de dias indicada em sistema parâmetros
								 * (parm_nnminimodiasemissaovencim)
								 */
								dataVencimentoConta = data2.getTime();
							}else{

								/*
								 * Se Não, é determinado o vencimento pela data composta pelo dia de
								 * vencimento alternativo e o mês posterior ao mês de vencimento do
								 * cronograma;
								 */
								dataVencimentoConta = Util.somaMesData(data1.getTime(), 1, true);
							}
						}else{

							/*
							 * Se Não, é determinado o vencimento da conta pela data composta pelo
							 * dia de vencimento alternativo e o mês/ano de vencimento do
							 * cronograma;
							 */
							dataVencimentoConta = data1.getTime();
						}
					}
				}

				String testarRelacaoAlternativoCronograma = ((String) ParametroFaturamento.P_TESTAR_VENCIMENTO_ALTERNATIVO_VERSUS_VENCIMENTO_CRONOGRAMA
								.executar(this));

				/*
				 * Se P_TESTAR_VENCIMENTO_ALTERNATIVO_VERSUS_VENCIMENTO_CRONOGRAMA estiver com valor
				 * igual a 1 e o imóvel não seja débito em conta
				 */
				if(testarRelacaoAlternativoCronograma.equals(ConstantesSistema.SIM.toString())
								&& imovel.getIndicadorDebitoConta().equals(ConstantesSistema.NAO)){

					// Se a data do vencimento do cronograma for diferente de nula
					if(faturamentoAtivCronRota.getDataContaVencimento() != null){

						Calendar dataVencimentoRotaCalendar = Calendar.getInstance();
						dataVencimentoRotaCalendar.setTime(faturamentoAtivCronRota.getDataContaVencimento());

						Calendar dataVencimentoAlternativo = Calendar.getInstance();
						dataVencimentoAlternativo.set(Calendar.DAY_OF_MONTH, diaVencimentoAlternativo.intValue());
						dataVencimentoAlternativo.set(Calendar.MONTH, dataVencimentoRotaCalendar.get(Calendar.MONTH));
						dataVencimentoAlternativo.set(Calendar.YEAR, dataVencimentoRotaCalendar.get(Calendar.YEAR));

						/*
						 * Obtém-se a quantidade de dias entre o vencimento alternativo (dia do
						 * vencimento alternativo com mês do cronograma) e o vencimento do
						 * cronograma
						 */
						int qtdDiasEntreDatas = 0;

						if(dataVencimentoAlternativo.getTime().compareTo(dataVencimentoRotaCalendar.getTime()) == -1){

							qtdDiasEntreDatas = Util.obterQuantidadeDiasEntreDuasDatas(dataVencimentoAlternativo.getTime(),
											dataVencimentoRotaCalendar.getTime());
						}else{

							qtdDiasEntreDatas = Util.obterQuantidadeDiasEntreDuasDatas(dataVencimentoRotaCalendar.getTime(),
											dataVencimentoAlternativo.getTime());
						}

						/*
						 * Se a quantidade de dias seja maior que zero e menor que
						 * parm_nndiasadicionaiscorreios de sistema parâmetro
						 */
						if((qtdDiasEntreDatas > 0) && (qtdDiasEntreDatas < sistemaParametro.getNumeroDiasAdicionaisCorreios().intValue())){

							/*
							 * Se já tiver sido determinado o vencimento da conta é adicionado ao
							 * vencimento à quantidade de dias parametrizada
							 * (parm_nndiasadicionaiscorreios)
							 */
							if(dataVencimentoConta != null){

								dataVencimentoConta = Util.adicionarNumeroDiasDeUmaData(dataVencimentoConta,
												sistemaParametro.getNumeroDiasAdicionaisCorreios());
							}
						}
					}
				}

				String parametroModeloArquivoLeiturasMicroletor = null;
				try{

					parametroModeloArquivoLeiturasMicroletor = ParametroMicromedicao.P_MODELO_ARQUIVO_LEITURA.executar();
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_MODELO_ARQUIVO_LEITURA");
				}

				Calendar dataVencimentoAtual = Calendar.getInstance();
				dataVencimentoAtual.setTime(dataVencimentoConta);

				if(parametroModeloArquivoLeiturasMicroletor.equals(ConstantesSistema.DOIS.toString())){
					Calendar dataPrevistaCronograma = Calendar.getInstance();
					dataPrevistaCronograma.setTime(faturamentoAtivCronRota.getDataContaVencimento());

					if(dataVencimentoAtual.before(dataPrevistaCronograma)){
						dataVencimentoAtual.add(Calendar.MONTH, 1);
					}
				}

				dataVencimentoConta = dataVencimentoAtual.getTime();

			}else{

				/*
				 * Se Não, (O imóvel não tem dia de vencimento alternativo); Atribui-se ao
				 * vencimento da conta o vencimento do cronograma
				 */
				dataVencimentoConta = faturamentoAtivCronRota.getDataContaVencimento();

				// Estas regras de vencimento público só se aplicam se o imóvel não possuir um dia
				// de
				// vencimento definido (Ver OC 910220, de Dez/2012)
				String P_VENCIMENTO_PUBLICO = (String) ParametroFaturamento.P_VENCIMENTO_PUBLICO.executar();
				Categoria categoriaImovel = getControladorImovel().obterPrincipalCategoriaImovel(imovel.getId());

				// Se o imóvel for público
				if(categoriaImovel != null && categoriaImovel.getId().equals(Categoria.PUBLICO)){

					/*
					 * Se P_VENCIMENTO_PUBLICO for estiver com valor igual a 1
					 * "dia vencimento parametrizado"
					 */
					if(P_VENCIMENTO_PUBLICO.equals(ConstantesSistema.DIA_VENCIMENTO_PARAMETRIZADO)
									&& sistemaParametro.getDiaVencimentoPublico() != null && faturamentoAtivCronRota != null){

						/*
						 * É determinado o vencimento da conta com a data composta pelo ano/mês do
						 * cronograma, e o dia de vencimento para públicos parametrizado
						 * parm_nndiavencimentopublico mais dois meses
						 */
						Calendar diaVencimentoRotaCalendar = new GregorianCalendar();
						diaVencimentoRotaCalendar.setTime(faturamentoAtivCronRota.getDataContaVencimento());
						diaVencimentoRotaCalendar.set(Calendar.DAY_OF_MONTH, sistemaParametro.getDiaVencimentoPublico().intValue());
						dataVencimentoConta = Util.somaMesData(diaVencimentoRotaCalendar.getTime(), 2, true);

					}else if((P_VENCIMENTO_PUBLICO.equals(ConstantesSistema.QUINTO_DIA_UTIL))){

						/*
						 * Se Não, Se P_VENCIMENTO_PUBLICO for igual a 2, é determinado o vencimento
						 * da conta que será o quinto dia útil do mês posterior ao mês da data
						 * composta pelo primeiro dia do mês/ano do cronograma
						 */
						Collection colecaoNacionalFeriado = getControladorUtil().pesquisarFeriadosNacionais();

						Calendar dataQuintoDiaUtilMesSeguinteFaturamentoCalendar = new GregorianCalendar();

						dataQuintoDiaUtilMesSeguinteFaturamentoCalendar.setTime(Util
										.gerarDataInicialApartirAnoMesRefencia(faturamentoAtivCronRota.getFaturamentoAtividadeCronograma()
														.getFaturamentoGrupoCronogramaMensal().getAnoMesReferencia()));

						Date dataMesFaturamentoMaisUmMes = Util.somaMesData(dataQuintoDiaUtilMesSeguinteFaturamentoCalendar.getTime(), 1,
										true);

						dataQuintoDiaUtilMesSeguinteFaturamentoCalendar.setTime(dataMesFaturamentoMaisUmMes);

						dataQuintoDiaUtilMesSeguinteFaturamentoCalendar.set(Calendar.DAY_OF_MONTH, Util.obterQuintoDiaUtilMes(
										dataQuintoDiaUtilMesSeguinteFaturamentoCalendar.get(Calendar.MONTH) + 1,
										dataQuintoDiaUtilMesSeguinteFaturamentoCalendar.get(Calendar.YEAR), colecaoNacionalFeriado, null));

						dataVencimentoConta = dataQuintoDiaUtilMesSeguinteFaturamentoCalendar.getTime();

					}
				}

				/*
				 * Se o indicador de imóvel conta envio da tabela imóvel for igual a 1 ou 3, e o
				 * indicador débito em conta for igual a 2
				 */
				if((imovel.getImovelContaEnvio().getId().intValue() == 1 || imovel.getImovelContaEnvio().getId().intValue() == 3)
								&& (imovel.getIndicadorDebitoConta().shortValue() == ConstantesSistema.NAO.shortValue())){

					/*
					 * É determinada a data de vencimento da conta que será composta pela data de
					 * vencimento já determinada anteriormente mais o número de dias adicionais do
					 * correio parm_nndiasadicionaiscorreios
					 */
					Calendar data = new GregorianCalendar();
					data.setTime(dataVencimentoConta);
					data.add(Calendar.DAY_OF_MONTH, sistemaParametro.getNumeroDiasAdicionaisCorreios());
					dataVencimentoConta = data.getTime();
				}
			}

			/*
			 * Se o vencimento da conta tiver sido definido com valor diferente de nulo, valida
			 * regra do parâmetro P_VERIFICAR_VENCIMENTO_CONTA_NO_MES_CORRENTE para determinar
			 * vencimento
			 */
			if(dataVencimentoConta != null){

				String parametroVerificarDataVencimentoContaNoMes = null;

				try{

					parametroVerificarDataVencimentoContaNoMes = ((String) ParametroFaturamento.P_VERIFICAR_DATA_VENCIMENTO_CONTA_NO_MES
								.executar(this));
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_MODELO_ARQUIVO_LEITURA");
				}

				// Se o valor do parâmetro P_VERIFICAR_VENCIMENTO_CONTA_NO_MES_CORRENTE for 1
				if(parametroVerificarDataVencimentoContaNoMes.equals("1")){

					// Se existir conta pro imóvel de referência anterior a referência de
					/*
					 * Se existir conta pro imóvel de referência anterior a referência de
					 * faturamento com a data de vencimento igual ou superior ao mês de vencimento
					 * da conta definido, então é somado 1 mês a data de da conta definido para cada
					 * conta existente
					 */
					while(this.repositorioFaturamento.verificarExistenciaContaComMesmoMesVencimento(imovel.getId(), faturamentoAtivCronRota
									.getFaturamentoAtividadeCronograma().getFaturamentoGrupoCronogramaMensal().getAnoMesReferencia(),
									Util.formataAnoMes(dataVencimentoConta))){


						dataVencimentoConta = Util.somaMesData(dataVencimentoConta, 1, true);
					}

				}else if(parametroVerificarDataVencimentoContaNoMes.equals("2")){

					// Se o valor do parâmetro P_VERIFICAR_VENCIMENTO_CONTA_NO_MES_CORRENTE for 2

					/*
					 * 5.2.1. Se existir conta pro imóvel de referência anterior a referência de
					 * faturamento com a data de vencimento igual ou superior ao mês de vencimento
					 * da conta definido e com data de vencimento igual ao vencimento da conta
					 * original então é somado 1 mês a data de vencimento da conta definido para
					 * cada conta existente
					 */
					while(this.repositorioFaturamento.verificarExistenciaContaComMesmoMesVencimentoOriginal(imovel.getId(),
									faturamentoAtivCronRota.getFaturamentoAtividadeCronograma().getFaturamentoGrupoCronogramaMensal()
													.getAnoMesReferencia(), Util.formataAnoMes(dataVencimentoConta))){

						dataVencimentoConta = Util.somaMesData(dataVencimentoConta, 1, true);
					}
				}
			}

			return dataVencimentoConta;

		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Inserir o Resumo Simulção Faturamento
	 * 
	 * @author eduardo henrique
	 * @date 15/10/2008 Alteração no método para chamar o método de inserção/Atualização por Sessão
	 *       Stateless (v0.05)
	 * @param colecaoResumoSimulacaoFaturamento
	 * @throws ControladorException
	 */
	public synchronized void inserirResumoSimulacaoFaturamento(Collection colecaoResumoSimulacaoFaturamento) throws ControladorException{

		// Ao fim, manda a coleção para atualização
		try{
			repositorioFaturamento.inserirOuAtualizarResumoFaturamentoSimulacao(colecaoResumoSimulacaoFaturamento);
		}catch(ErroRepositorioException erx){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", erx);
		}

	}

	/***************************************************************************
	 * // [UC0120] - Calcular Valores de Água e/ou Esgoto /
	 * Short indicadorFaturamentoEsgoto = null; Integer consumoFaturadoEsgotoMes = null;
	 * if (imovel.getLigacaoEsgotoSituacao().getId().equals( LigacaoEsgotoSituacao.LIGADO)) {
	 * filtroConsumoHistorico = new FiltroConsumoHistorico(); // ID do imóvel tem que ser igual ao
	 * ID do imóvel na tabela // Consumo_Historico
	 * filtroConsumoHistorico.adicionarParametro(new ParametroSimples(
	 * FiltroConsumoHistorico.IMOVEL_ID, imovel.getId())); // O tipo da ligação com
	 * valor correpondente a ligação de esgoto filtroConsumoHistorico.adicionarParametro(new
	 * ParametroSimples( FiltroConsumoHistorico.LIGACAO_TIPO_ID,
	 * LigacaoTipo.LIGACAO_ESGOTO)); // O ano/mês de referencia tem que ser o mesmo do grupo de //
	 * faturamento
	 * filtroConsumoHistorico.adicionarParametro(new ParametroSimples(
	 * FiltroConsumoHistorico.ANO_MES_FATURAMENTO, imovel
	 * .getQuadra().getRota().getFaturamentoGrupo() .getAnoMesReferencia()));
	 * colecaoConsumoHistorico = getControladorUtil().pesquisar( filtroConsumoHistorico,
	 * ConsumoHistorico.class.getName());
	 * if (colecaoConsumoHistorico == null || colecaoConsumoHistorico.isEmpty()) {
	 * indicadorFaturamentoEsgoto =
	 * ConsumoHistorico.INDICADOR_FATURAMENTO_FATURAR_ESGOTO; consumoFaturadoEsgotoMes =
	 * ConsumoHistorico.NUMERO_CONSUMO_FATURADO_MES_PADRAO; } else {
	 * consumoHistorico = (ConsumoHistorico) Util .retonarObjetoDeColecao(colecaoConsumoHistorico);
	 * if (consumoHistorico.getIndicadorFaturamento() == null) { indicadorFaturamentoEsgoto =
	 * ConsumoHistorico.INDICADOR_FATURAMENTO_FATURAR_ESGOTO; }
	 * else { indicadorFaturamentoEsgoto = consumoHistorico .getIndicadorFaturamento(); } if
	 * (consumoHistorico.getNumeroConsumoFaturadoMes() == null)
	 * { consumoFaturadoEsgotoMes = ConsumoHistorico.NUMERO_CONSUMO_FATURADO_MES_PADRAO; } else {
	 * consumoFaturadoEsgotoMes = consumoHistorico
	 * .getNumeroConsumoFaturadoMes(); } }
	 * int consumoMinimoLigacao = 0;
	 * FiltroMedicaoHistorico filtroMedicaoHistorico; MedicaoHistorico medicaoHistorico = null;
	 * Collection colecaoMedicaoHistorico; Date
	 * dataLeituraAnterior = null; Date dataLeituraAtual = null; // MEDIÇÃO // DO TIPO LIGAÇÃO DE
	 * ÁGUA if
	 * (imovel.getLigacaoAguaSituacao().getId().equals( LigacaoAguaSituacao.LIGADO) ||
	 * imovel.getLigacaoAguaSituacao().getId().equals(
	 * LigacaoAguaSituacao.CORTADO)) {
	 * filtroMedicaoHistorico = new FiltroMedicaoHistorico(); // ID do imóvel tem que ser igual ao
	 * ID do imóvel na tabela // Medicao_Historico
	 * filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
	 * FiltroMedicaoHistorico.IMOVEL_ID, imovel.getId())); // O tipo da medição com
	 * valor correspondente a medição de // água filtroMedicaoHistorico.adicionarParametro(new
	 * ParametroSimples(
	 * FiltroMedicaoHistorico.MEDICAO_TIPO_ID, MedicaoTipo.LIGACAO_AGUA)); // O ano/mês de
	 * referencia tem que ser o mesmo do grupo de // faturamento
	 * filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
	 * FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO,
	 * imovel.getQuadra().getRota().getFaturamentoGrupo() .getAnoMesReferencia()));
	 * colecaoMedicaoHistorico = getControladorUtil().pesquisar( filtroMedicaoHistorico,
	 * MedicaoHistorico.class.getName());
	 * if (colecaoMedicaoHistorico == null || colecaoMedicaoHistorico.isEmpty()) {
	 * dataLeituraAnterior = buscarDataLeituraCronograma(imovel, true,
	 * anoMesReferencia); dataLeituraAtual = buscarDataLeituraCronograma(imovel, false,
	 * anoMesReferencia); } else {
	 * medicaoHistorico = (MedicaoHistorico) Util .retonarObjetoDeColecao(colecaoMedicaoHistorico);
	 * if (medicaoHistorico.getDataLeituraAnteriorFaturamento() == null) { dataLeituraAnterior =
	 * buscarDataLeituraCronograma( imovel, true,
	 * anoMesReferencia); dataLeituraAtual = buscarDataLeituraCronograma(imovel, false,
	 * anoMesReferencia); } else { dataLeituraAnterior =
	 * medicaoHistorico .getDataLeituraAnteriorFaturamento(); dataLeituraAtual = medicaoHistorico
	 * .getDataLeituraAtualFaturamento(); } } } // MEDIÇÃO
	 * DO TIPO LIGAÇÃO DE ESGOTO else if (imovel.getLigacaoEsgotoSituacao().getId().equals(
	 * LigacaoEsgotoSituacao.LIGADO)) {
	 * filtroMedicaoHistorico = new FiltroMedicaoHistorico(); // ID do imóvel tem que ser igual ao
	 * ID do imóvel na tabela // Medicao_Historico
	 * filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
	 * FiltroMedicaoHistorico.IMOVEL_ID, imovel.getId())); // O tipo da medição com
	 * valor correspondente a medição de // poço filtroMedicaoHistorico.adicionarParametro(new
	 * ParametroSimples(
	 * FiltroMedicaoHistorico.MEDICAO_TIPO_ID, MedicaoTipo.POCO)); // O ano/mês de referencia tem
	 * que ser o mesmo do grupo de // faturamento
	 * filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
	 * FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO,
	 * imovel.getQuadra().getRota().getFaturamentoGrupo() .getAnoMesReferencia()));
	 * colecaoMedicaoHistorico = getControladorUtil().pesquisar( filtroMedicaoHistorico,
	 * MedicaoHistorico.class.getName());
	 * if (colecaoMedicaoHistorico == null || colecaoMedicaoHistorico.isEmpty()) {
	 * dataLeituraAnterior = buscarDataLeituraCronograma(imovel, true,
	 * anoMesReferencia); dataLeituraAtual = buscarDataLeituraCronograma(imovel, false,
	 * anoMesReferencia); } else { medicaoHistorico =
	 * (MedicaoHistorico) Util .retonarObjetoDeColecao(colecaoMedicaoHistorico);
	 * if (medicaoHistorico.getDataLeituraAnteriorFaturamento() == null) { dataLeituraAnterior =
	 * buscarDataLeituraCronograma( imovel, true,
	 * anoMesReferencia); dataLeituraAtual = buscarDataLeituraCronograma(imovel, false,
	 * anoMesReferencia); } else { dataLeituraAnterior =
	 * medicaoHistorico .getDataLeituraAnteriorFaturamento(); dataLeituraAtual = medicaoHistorico
	 * .getDataLeituraAtualFaturamento(); } } } else {
	 * dataLeituraAnterior = buscarDataLeituraCronograma(imovel, true, anoMesReferencia);
	 * dataLeituraAtual = buscarDataLeituraCronograma(imovel,
	 * false, anoMesReferencia); } // Percentual de esgoto // //
	 * ************************************************************************** /*
	 * LESG_PCESGOTO da tabela LIGACAO_ESGOTO com LESG_ID=IMOV_ID da tabela IMOVEL, caso o imóvel
	 * seja ligado de esgoto ou zero caso contrário)
	 */
	/*
	 * BigDecimal percentualEsgoto = new BigDecimal(0);
	 * if (imovel.getLigacaoEsgotoSituacao().getId().equals( LigacaoEsgotoSituacao.LIGADO)) { if
	 * (imovel.getLigacaoEsgoto().getPercentual() != null) {
	 * percentualEsgoto = imovel.getLigacaoEsgoto() .getPercentual(); } } //
	 * ************************************************************************** // Tarifa para o
	 * imóvel - CSTF_ID da tabela IMOVEL //
	 * **************************************************************************
	 * Integer tarifaImovel = null; if (imovel.getConsumoTarifa() != null) { tarifaImovel =
	 * imovel.getConsumoTarifa().getId(); } //
	 * ************************************************************************** // [UC0120 -
	 * Calcular Valores de Água e/ou Esgoto] Object[][]
	 * valoresCalculadosAguaEsgoto = calcularValoresAguaEsgoto(
	 * imovel.getQuadra().getRota().getFaturamentoGrupo() .getAnoMesReferencia(), imovel
	 * .getLigacaoAguaSituacao().getId(), imovel .getLigacaoEsgotoSituacao().getId(),
	 * indicadorFaturamentoAgua, indicadorFaturamentoEsgoto,
	 * colecaoCategoriasImovel, consumoFaturadoAguaMes, consumoFaturadoEsgotoMes,
	 * consumoMinimoLigacao, dataLeituraAnterior, dataLeituraAtual,
	 * percentualEsgoto, tarifaImovel); } } /** [UC0120 - Calcular Valores de Água e/ou Esgoto]
	 * @param anoMesReferencia @param ligacaoSituacaoAguaId @param ligacaoSituacaoEsgotoId @param
	 * indicadorFaturamentoAgua @param
	 * indicadorFaturamentoEsgoto @param categoriasImovel @param consumoFaturadoAguaMes @param
	 * consumoFaturadoEsgotoMes @param consumoMinimoLigacao
	 * @param dataLeituraAnterior @param dataLeituraAtual
	 * @param percentualEsgoto @param tarifaImovel @throws ControladorException
	 */

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * @author Saulo Lima
	 * @date 20/12/2008
	 * @author eduardo henrique
	 * @date 03/02/2009
	 *       Alteração no método para utilizar a data de Leitura Atual para busca da Tarifa em
	 *       Vigencia
	 */
	public Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgoto(Integer anoMesReferencia, Integer ligacaoSituacaoAguaId,
					Integer ligacaoSituacaoEsgotoId, Short indicadorFaturamentoAgua, Short indicadorFaturamentoEsgoto,
					Collection categoriasImovel, Integer consumoFaturadoAguaMes, Integer consumoFaturadoEsgotoMes,
					int consumoMinimoLigacao, Date dataLeituraAnterior, Date dataLeituraAtual, BigDecimal percentualEsgoto,
					Integer tarifaImovel, Integer idImovel, ConsumoTarifaVigencia consumoTarifaVigencia) throws ControladorException{

		if(idImovel != null){

			// Consultar Contrato Demanda Consumo
			// Caso exista contrato de demanda de consumo vigente para o imóvel
			FiltroContratoDemandaConsumo filtroContratoDemandaConsumo = new FiltroContratoDemandaConsumo();
			filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.IMOVEL_ID, idImovel));
			filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.INDICADORENCERRAMENTO,
							ConstantesSistema.NAO));
			filtroContratoDemandaConsumo.adicionarParametro(new MenorQue(FiltroContratoDemandaConsumo.ANOMESFATURAMENTOINICIO,
							anoMesReferencia));
			filtroContratoDemandaConsumo.adicionarParametro(new MaiorQue(FiltroContratoDemandaConsumo.ANOMESFATURAMENTOFIM,
							anoMesReferencia));

			try{
				Collection<ContratoDemandaConsumo> colContratoDemandaConsumo = repositorioUtil.pesquisar(filtroContratoDemandaConsumo,
								ContratoDemandaConsumo.class.getName());

				if(!colContratoDemandaConsumo.isEmpty()){

					ContratoDemandaConsumo contratoDemandaConsumo = (ContratoDemandaConsumo) Util
									.retonarObjetoDeColecao(colContratoDemandaConsumo);

					if(contratoDemandaConsumo.getConsumoTarifa() != null){
						tarifaImovel = contratoDemandaConsumo.getConsumoTarifa().getId();
					}else{
						consumoMinimoLigacao = contratoDemandaConsumo.getNumeroConsumoFixo();
					}
				}

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}


		/* Seleciona a tarifa em vigor para data de faturamento */
		/* Os cálculos serão efetuados com apenas uma tarifa */

		if(consumoTarifaVigencia == null){

			consumoTarifaVigencia = this.pesquisarConsumoTarifaVigenciaMenorOUIgualDataFaturamento(tarifaImovel, dataLeituraAtual);
		}

		if(consumoTarifaVigencia == null){
			try{
				sessionContext.setRollbackOnly();
			}catch(IllegalStateException e){
				// Nesse caso o metodo não esta usando transação
				// Por isso ele não consegue dar roll back
			}
			throw new ControladorException("atencao.nao_cadastrada_data_vigencia");
		}

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();
		Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresAgua = new ArrayList();
		Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresEsgoto = new ArrayList();

		if(consumoTarifaVigencia.getId() != null && consumoTarifaVigencia.getDataVigencia() != null){

			List<Categoria> colecaoCategororiasOrdenar = (List<Categoria>) categoriasImovel;
			List sortFields = new ArrayList();
			sortFields.add(new BeanComparator("id"));

			ComparatorChain multiSort = new ComparatorChain(sortFields);
			Collections.sort(colecaoCategororiasOrdenar, multiSort);
			Categoria catgeoriaComMenorId = (Categoria) Util.retonarObjetoDeColecao(colecaoCategororiasOrdenar);

			// Caso a ligacao seja faturável ou não faturável com consumo , realiza o cálculo
			if(indicadorFaturamentoAgua.equals(ConsumoHistorico.FATURAR_AGUA)){

				if(consumoTarifaVigencia.getCalculoTipo().getId().equals(CalculoTipo.CALCULO_SIMPLES_CASCATA)){
					colecaoValoresAgua = this.calculoSimplesCascataUmaUnicaTarifa(consumoFaturadoAguaMes, categoriasImovel,
									percentualEsgoto, consumoTarifaVigencia, ConstantesSistema.CALCULAR_AGUA, consumoMinimoLigacao,
									dataLeituraAnterior, dataLeituraAtual, catgeoriaComMenorId.getId());
				}else{
					colecaoValoresAgua = this.calculoSimplesFaixaUmaUnicaTarifa(consumoFaturadoAguaMes, categoriasImovel, percentualEsgoto,
									consumoTarifaVigencia, ConstantesSistema.CALCULAR_AGUA, consumoMinimoLigacao, dataLeituraAnterior,
									dataLeituraAtual);
				}

			}

			if(indicadorFaturamentoEsgoto.equals(ConsumoHistorico.FATURAR_ESGOTO)){

				if(consumoTarifaVigencia.getCalculoTipo().getId().equals(CalculoTipo.CALCULO_SIMPLES_CASCATA)){
					colecaoValoresEsgoto = this.calculoSimplesCascataUmaUnicaTarifa(consumoFaturadoEsgotoMes, categoriasImovel,
									percentualEsgoto, consumoTarifaVigencia, ConstantesSistema.CALCULAR_ESGOTO, consumoMinimoLigacao,
									dataLeituraAnterior, dataLeituraAtual, catgeoriaComMenorId.getId());
				}else{
					colecaoValoresEsgoto = this.calculoSimplesFaixaUmaUnicaTarifa(consumoFaturadoEsgotoMes, categoriasImovel,
									percentualEsgoto, consumoTarifaVigencia, ConstantesSistema.CALCULAR_ESGOTO, consumoMinimoLigacao,
									dataLeituraAnterior, dataLeituraAtual);
				}

				// Ajustando o valor de esgoto para que a diferença do valor total de agua apos
				// aplicar o percentual de esgoto, seja distribuido em alguma das categorias
				if(!Util.isVazioOrNulo(colecaoValoresAgua) && !Util.isVazioOrNulo(colecaoValoresEsgoto)){
					BigDecimal valorAux = BigDecimal.ZERO;
					BigDecimal valorTotalFaturadoAgua = BigDecimal.ZERO;

					for(CalcularValoresAguaEsgotoHelper helper : colecaoValoresAgua){
						valorAux = helper.getValorFaturadoAguaCategoria();
						valorTotalFaturadoAgua = valorTotalFaturadoAgua.add(valorAux);
					}

					valorAux = BigDecimal.ZERO;
					BigDecimal valorTotalEsgoto = BigDecimal.ZERO;

					for(CalcularValoresAguaEsgotoHelper helper : colecaoValoresEsgoto){
						valorAux = helper.getValorFaturadoEsgotoCategoria();
						valorTotalEsgoto = valorTotalEsgoto.add(valorAux);
					}

					BigDecimal fatorPercentual = percentualEsgoto.divide(new BigDecimal("100"), 2, BigDecimal.ROUND_DOWN);

					// Valor faturado de esgoto
					BigDecimal valorTotalEsgotoCalculado = valorTotalFaturadoAgua.multiply(fatorPercentual);
					valorTotalEsgotoCalculado = valorTotalEsgotoCalculado.setScale(2, BigDecimal.ROUND_DOWN);

					if(valorTotalEsgotoCalculado.compareTo(valorTotalEsgoto) > 0){
						BigDecimal diferencaEsgoto = valorTotalEsgotoCalculado.subtract(valorTotalEsgoto);

						// Precisa ordenar as duas coleções igualmente.
						Collections.sort((List) colecaoValoresAgua, new Comparator() {

							public int compare(Object o1, Object o2){

								CalcularValoresAguaEsgotoHelper cd1 = (CalcularValoresAguaEsgotoHelper) o1;
								CalcularValoresAguaEsgotoHelper cd2 = (CalcularValoresAguaEsgotoHelper) o2;
								return cd1.getIdCategoria().compareTo(cd2.getIdCategoria());
							}
						});

						Collections.sort((List) colecaoValoresEsgoto, new Comparator() {

							public int compare(Object o1, Object o2){

								CalcularValoresAguaEsgotoHelper cd1 = (CalcularValoresAguaEsgotoHelper) o1;
								CalcularValoresAguaEsgotoHelper cd2 = (CalcularValoresAguaEsgotoHelper) o2;
								return cd1.getIdCategoria().compareTo(cd2.getIdCategoria());
							}
						});

						BigDecimal valorFaturadoEsgotoCategoria = BigDecimal.ZERO;

						for(CalcularValoresAguaEsgotoHelper helper : colecaoValoresEsgoto){
							valorFaturadoEsgotoCategoria = helper.getValorFaturadoEsgotoCategoria();
							valorFaturadoEsgotoCategoria = valorFaturadoEsgotoCategoria.add(diferencaEsgoto);

							helper.setValorFaturadoEsgotoCategoria(valorFaturadoEsgotoCategoria);

							break;
						}
					}

				}

			}

		}else{
			// A lista com as tarifas vigentes está nula ou vazia
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.nao_cadastrada_data_vigencia");
		}

		// Unificando os valores de água e esgoto em apenas uma coleção

		// O calculo foi realizado apenas para água
		if((colecaoValoresAgua != null && !colecaoValoresAgua.isEmpty())
						&& (colecaoValoresEsgoto == null || colecaoValoresEsgoto.isEmpty())){
			colecaoRetorno.addAll(colecaoValoresAgua);

			// O calculo foi realizado apenas para esgoto
		}else if((colecaoValoresEsgoto != null && !colecaoValoresEsgoto.isEmpty())
						&& (colecaoValoresAgua == null || colecaoValoresAgua.isEmpty())){
			colecaoRetorno.addAll(colecaoValoresEsgoto);

			// O calculo foi realizado para ambos
		}else{

			Iterator colecaoValoresAguaIt = colecaoValoresAgua.iterator();
			Iterator colecaoValoresEsgotoIt;
			Iterator colecaoValoresAguaFaixaIt;
			Iterator colecaoValoresEsgotoFaixaIt;

			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelperAgua, calcularValoresAguaEsgotoHelperEsgoto;
			CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelperAgua, calcularValoresAguaEsgotoFaixaHelperEsgoto;

			int esgotoParada = 0;

			while(colecaoValoresAguaIt.hasNext()){

				calcularValoresAguaEsgotoHelperAgua = (CalcularValoresAguaEsgotoHelper) colecaoValoresAguaIt.next();

				colecaoValoresEsgotoIt = colecaoValoresEsgoto.iterator();

				int contadorEsgoto = 0;

				while(colecaoValoresEsgotoIt.hasNext()){

					calcularValoresAguaEsgotoHelperEsgoto = (CalcularValoresAguaEsgotoHelper) colecaoValoresEsgotoIt.next();

					// Carregando os valores de esgoto na coleção que contém os valores calculados
					// de água
					if(calcularValoresAguaEsgotoHelperAgua.getIdCategoria().equals(calcularValoresAguaEsgotoHelperEsgoto.getIdCategoria())
									&& esgotoParada == contadorEsgoto){

						// Carregando o valor faturado de esgoto na coleção de água
						calcularValoresAguaEsgotoHelperAgua.setValorFaturadoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
										.getValorFaturadoEsgotoCategoria());

						// Carregando o consumo faturado de esgoto na coleção de água
						calcularValoresAguaEsgotoHelperAgua.setConsumoFaturadoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
										.getConsumoFaturadoEsgotoCategoria());

						// Carregando o valor da tarifa mínima de esgoto na coleção de água
						calcularValoresAguaEsgotoHelperAgua.setValorTarifaMinimaEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
										.getValorTarifaMinimaEsgotoCategoria());

						// Carregando o consumo mínimo de esgoto na coleção de água
						calcularValoresAguaEsgotoHelperAgua.setConsumoMinimoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
										.getConsumoMinimoEsgotoCategoria());

						// -------------------------------------------------------------------------------
						// Carregando os valores calculados de esgoto para cada faixa da tarifa de
						// consumo
						// -------------------------------------------------------------------------------

						colecaoValoresAguaFaixaIt = calcularValoresAguaEsgotoHelperAgua.getFaixaTarifaConsumo().iterator();

						int faixaParada = 0;

						while(colecaoValoresAguaFaixaIt.hasNext()){

							calcularValoresAguaEsgotoFaixaHelperAgua = (CalcularValoresAguaEsgotoFaixaHelper) colecaoValoresAguaFaixaIt
											.next();

							colecaoValoresEsgotoFaixaIt = calcularValoresAguaEsgotoHelperEsgoto.getFaixaTarifaConsumo().iterator();

							int contadorFaixa = 0;

							while(colecaoValoresEsgotoFaixaIt.hasNext()){

								calcularValoresAguaEsgotoFaixaHelperEsgoto = (CalcularValoresAguaEsgotoFaixaHelper) colecaoValoresEsgotoFaixaIt
												.next();

								if(calcularValoresAguaEsgotoFaixaHelperAgua.getIdConsumoTarifaFaixa().equals(
												calcularValoresAguaEsgotoFaixaHelperEsgoto.getIdConsumoTarifaFaixa())
												&& faixaParada == contadorFaixa){

									// Carregando o valor faturado de esgoto na faixa para coleção
									// de água
									calcularValoresAguaEsgotoFaixaHelperAgua
													.setValorFaturadoEsgotoFaixa(calcularValoresAguaEsgotoFaixaHelperEsgoto
																	.getValorFaturadoEsgotoFaixa());

									// Carregando o consumo faturado de esgoto na faixa para coleção
									// de água
									calcularValoresAguaEsgotoFaixaHelperAgua
													.setConsumoFaturadoEsgotoFaixa(calcularValoresAguaEsgotoFaixaHelperEsgoto
																	.getConsumoFaturadoEsgotoFaixa());

									contadorFaixa++;
									faixaParada = contadorFaixa;
									break;
								}

								contadorFaixa++;
							}
						}

						contadorEsgoto++;
						esgotoParada = contadorEsgoto;
						break;
					}

					contadorEsgoto++;
				}
				colecaoRetorno.add(calcularValoresAguaEsgotoHelperAgua);
			}
		}

		return calcularValoresAguaEsgotoTotalizandoPorCategoria(colecaoRetorno);
	}

	public Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgotoTotalizandoPorCategoria(
					Collection colecaoCalcularValoresAguaEsgotoHelper) throws ControladorException{

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		Iterator colecaoCalcularValoresAguaEsgotoHelperIt = colecaoCalcularValoresAguaEsgotoHelper.iterator();
		CalcularValoresAguaEsgotoHelper objetoTotalizacao;
		CalcularValoresAguaEsgotoHelper objetoColecao;

		Integer qtdCategoria = (Integer) this.getControladorImovel().pesquisarObterQuantidadeCategoria();

		Object[][] categoriasTotalizacao = new Object[qtdCategoria.intValue()][12];
		Integer idCategoria;
		BigDecimal valorAgua, valorEsgoto, valorTarifaMinimaAgua, valorTarifaMinimaEsgoto;
		Collection faixaHelper = null;
		Collection faixaHelperObjetoColecao = null;
		boolean categoriaDentroArray = false;
		int controleCategoria = 0;
		// Integer consumoAgua = 0;
		// Integer consumoEsgoto = 0;

		while(colecaoCalcularValoresAguaEsgotoHelperIt.hasNext()){

			objetoColecao = (CalcularValoresAguaEsgotoHelper) colecaoCalcularValoresAguaEsgotoHelperIt.next();

			if(categoriasTotalizacao[0][0] == null){
				categoriasTotalizacao[0][0] = objetoColecao.getIdCategoria();
				categoriasTotalizacao[0][1] = objetoColecao.getDescricaoCategoria();
				categoriasTotalizacao[0][2] = objetoColecao.getValorFaturadoAguaCategoria();
				categoriasTotalizacao[0][3] = objetoColecao.getValorFaturadoEsgotoCategoria();
				categoriasTotalizacao[0][4] = objetoColecao.getQuantidadeEconomiasCategoria();
				categoriasTotalizacao[0][5] = objetoColecao.getConsumoFaturadoAguaCategoria();
				categoriasTotalizacao[0][6] = objetoColecao.getConsumoFaturadoEsgotoCategoria();
				categoriasTotalizacao[0][7] = objetoColecao.getFaixaTarifaConsumo();

				categoriasTotalizacao[0][8] = objetoColecao.getValorTarifaMinimaAguaCategoria();
				categoriasTotalizacao[0][9] = objetoColecao.getConsumoMinimoAguaCategoria();
				categoriasTotalizacao[0][10] = objetoColecao.getValorTarifaMinimaEsgotoCategoria();
				categoriasTotalizacao[0][11] = objetoColecao.getConsumoMinimoEsgotoCategoria();

				controleCategoria++;
			}else{

				categoriaDentroArray = false;

				for(int index = 0; index < categoriasTotalizacao.length; index++){

					if(categoriasTotalizacao[index][0] != null){

						idCategoria = (Integer) categoriasTotalizacao[index][0];

						if(idCategoria.intValue() == objetoColecao.getIdCategoria().intValue()){

							valorAgua = (BigDecimal) categoriasTotalizacao[index][2];
							if(valorAgua != null){
								valorAgua = valorAgua.add(objetoColecao.getValorFaturadoAguaCategoria());
							}
							valorEsgoto = (BigDecimal) categoriasTotalizacao[index][3];

							if(valorEsgoto != null){

								valorEsgoto = valorEsgoto.add(objetoColecao.getValorFaturadoEsgotoCategoria());
							}
							categoriasTotalizacao[index][2] = valorAgua;
							categoriasTotalizacao[index][3] = valorEsgoto;

							/*
							 * Colocado por Raphael Rossiter em 09/07/2007
							 */
							valorTarifaMinimaAgua = (BigDecimal) categoriasTotalizacao[index][8];
							if(valorTarifaMinimaAgua != null){
								valorTarifaMinimaAgua = valorTarifaMinimaAgua.add(objetoColecao.getValorTarifaMinimaAguaCategoria());
							}
							categoriasTotalizacao[index][8] = valorTarifaMinimaAgua;

							valorTarifaMinimaEsgoto = (BigDecimal) categoriasTotalizacao[index][10];
							if(valorTarifaMinimaEsgoto != null){
								valorTarifaMinimaEsgoto = valorTarifaMinimaEsgoto.add(objetoColecao.getValorTarifaMinimaEsgotoCategoria());
							}
							categoriasTotalizacao[index][10] = valorTarifaMinimaEsgoto;

							faixaHelper = (Collection) categoriasTotalizacao[index][7];
							faixaHelperObjetoColecao = objetoColecao.getFaixaTarifaConsumo();

							if(faixaHelper != null && !faixaHelper.isEmpty()){

								if(faixaHelperObjetoColecao != null && !faixaHelperObjetoColecao.isEmpty()){

									Iterator itFaixaHelper = faixaHelper.iterator();
									Iterator itFaixaHelperObjetoColecao = faixaHelperObjetoColecao.iterator();

									while(itFaixaHelper.hasNext() && itFaixaHelperObjetoColecao.hasNext()){

										CalcularValoresAguaEsgotoFaixaHelper objetoFaixaHelper = (CalcularValoresAguaEsgotoFaixaHelper) itFaixaHelper
														.next();

										CalcularValoresAguaEsgotoFaixaHelper objetoFaixaHelperObjetoColecao = (CalcularValoresAguaEsgotoFaixaHelper) itFaixaHelperObjetoColecao
														.next();

										if(objetoFaixaHelper.getValorFaturadoAguaFaixa() != null){

											objetoFaixaHelper.setValorFaturadoAguaFaixa(objetoFaixaHelper.getValorFaturadoAguaFaixa().add(
															objetoFaixaHelperObjetoColecao.getValorFaturadoAguaFaixa()));
										}

										if(objetoFaixaHelper.getValorFaturadoEsgotoFaixa() != null){

											objetoFaixaHelper.setValorFaturadoEsgotoFaixa(objetoFaixaHelper.getValorFaturadoEsgotoFaixa()
															.add(objetoFaixaHelperObjetoColecao.getValorFaturadoEsgotoFaixa()));
										}

										objetoFaixaHelper.setValorTarifaFaixa(objetoFaixaHelper.getValorTarifaFaixa().add(
														objetoFaixaHelperObjetoColecao.getValorTarifaFaixa()));

									}
								}
							}else if(faixaHelperObjetoColecao != null && !faixaHelperObjetoColecao.isEmpty()){

								categoriasTotalizacao[index][7] = faixaHelperObjetoColecao;
							}

							/*
							 * consumoAgua = (Integer) categoriasTotalizacao[index][5];
							 * if(consumoAgua != null){
							 * consumoAgua = consumoAgua + objetoColecao
							 * .getConsumoFaturadoAguaCategoria(); } categoriasTotalizacao[index][5]
							 * =
							 * consumoAgua;
							 * consumoEsgoto = (Integer) categoriasTotalizacao[index][6];
							 * if(consumoEsgoto != null){
							 * consumoEsgoto = consumoEsgoto + objetoColecao
							 * .getConsumoFaturadoEsgotoCategoria(); }
							 * categoriasTotalizacao[index][6] =
							 * consumoEsgoto;
							 */

							categoriaDentroArray = true;

							break;
						}
					}else{
						break;
					}
				}

				if(!categoriaDentroArray){
					categoriasTotalizacao[controleCategoria][0] = objetoColecao.getIdCategoria();
					categoriasTotalizacao[controleCategoria][1] = objetoColecao.getDescricaoCategoria();
					categoriasTotalizacao[controleCategoria][2] = objetoColecao.getValorFaturadoAguaCategoria();
					categoriasTotalizacao[controleCategoria][3] = objetoColecao.getValorFaturadoEsgotoCategoria();
					categoriasTotalizacao[controleCategoria][4] = objetoColecao.getQuantidadeEconomiasCategoria();
					categoriasTotalizacao[controleCategoria][5] = objetoColecao.getConsumoFaturadoAguaCategoria();
					categoriasTotalizacao[controleCategoria][6] = objetoColecao.getConsumoFaturadoEsgotoCategoria();
					categoriasTotalizacao[controleCategoria][7] = objetoColecao.getFaixaTarifaConsumo();

					categoriasTotalizacao[controleCategoria][8] = objetoColecao.getValorTarifaMinimaAguaCategoria();
					categoriasTotalizacao[controleCategoria][9] = objetoColecao.getConsumoMinimoAguaCategoria();
					categoriasTotalizacao[controleCategoria][10] = objetoColecao.getValorTarifaMinimaEsgotoCategoria();
					categoriasTotalizacao[controleCategoria][11] = objetoColecao.getConsumoMinimoEsgotoCategoria();

					controleCategoria++;
				}
			}
		}

		for(int indexArray = 0; indexArray < categoriasTotalizacao.length; indexArray++){

			if(categoriasTotalizacao[indexArray][0] != null){

				objetoTotalizacao = new CalcularValoresAguaEsgotoHelper();

				objetoTotalizacao.setIdCategoria((Integer) categoriasTotalizacao[indexArray][0]);
				objetoTotalizacao.setDescricaoCategoria((String) categoriasTotalizacao[indexArray][1]);
				objetoTotalizacao.setValorFaturadoAguaCategoria((BigDecimal) categoriasTotalizacao[indexArray][2]);
				objetoTotalizacao.setValorFaturadoEsgotoCategoria((BigDecimal) categoriasTotalizacao[indexArray][3]);
				objetoTotalizacao.setQuantidadeEconomiasCategoria((Integer) categoriasTotalizacao[indexArray][4]);
				objetoTotalizacao.setConsumoFaturadoAguaCategoria((Integer) categoriasTotalizacao[indexArray][5]);
				objetoTotalizacao.setConsumoFaturadoEsgotoCategoria((Integer) categoriasTotalizacao[indexArray][6]);
				objetoTotalizacao.setFaixaTarifaConsumo((Collection) categoriasTotalizacao[indexArray][7]);

				if(categoriasTotalizacao[indexArray][8] != null){
					objetoTotalizacao.setValorTarifaMinimaAguaCategoria((BigDecimal) categoriasTotalizacao[indexArray][8]);
				}

				if(categoriasTotalizacao[indexArray][9] != null){
					objetoTotalizacao.setConsumoMinimoAguaCategoria((Integer) categoriasTotalizacao[indexArray][9]);
				}

				if(categoriasTotalizacao[indexArray][10] != null){
					objetoTotalizacao.setValorTarifaMinimaEsgotoCategoria((BigDecimal) categoriasTotalizacao[indexArray][10]);
				}

				if(categoriasTotalizacao[indexArray][11] != null){
					objetoTotalizacao.setConsumoMinimoEsgotoCategoria((Integer) categoriasTotalizacao[indexArray][11]);
				}

				colecaoRetorno.add(objetoTotalizacao);
			}

		}

		return colecaoRetorno;
	}
	
	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * [FS0011] - Verificar créditos a realizar de CREDTAC
	 * 
	 * @author Anderson Italo
	 * @date 25/09/2014
	 */
	private Object[] verificarCreditosARealizarCREDTAC(Collection<CreditoARealizar> colecaoCredito, Imovel imovel)
					throws ControladorException{

		Object[] retorno = new Object[2];
		Collection<CreditoARealizar> colecaoCreditosARealizarRetorno = new ArrayList<CreditoARealizar>();
		colecaoCreditosARealizarRetorno.addAll(colecaoCredito);
		Collection<CreditoARealizar> colecaoCreditosARealizarCREDTAC = new ArrayList<CreditoARealizar>();
		boolean faturarCREDTAC = false;

		if(!Util.isVazioOrNulo(colecaoCredito)){

			// Seta valores constantes para chamar o metodo que consulta debitos do imovel
			Integer tipoImovel = Integer.valueOf(1);
			Integer indicadorPagamento = Integer.valueOf(2);
			Integer indicadorConta = Integer.valueOf(1);
			Integer indicadorDebito = Integer.valueOf(2);
			Integer indicadorCredito = Integer.valueOf(2);
			Integer indicadorNotas = Integer.valueOf(2);
			Integer indicadorGuias = Integer.valueOf(2);
			Integer indicadorAtualizar = Integer.valueOf(1);

			// <<Inclui>> [UC0067 - Obter Débito do Imóvel ou Cliente]
			ObterDebitoImovelOuClienteHelper colecaoDebitoImovel = getControladorCobranca().obterDebitoImovelOuCliente(
							tipoImovel.intValue(), imovel.getId().toString(), null, null, "000001", "999912",
							Util.gerarDataInicialDoAnoApartirDoAnoRefencia(0001), Util.gerarDataInicialDoAnoApartirDoAnoRefencia(9999),
							indicadorPagamento.intValue(), indicadorConta.intValue(), indicadorDebito.intValue(),
							indicadorCredito.intValue(), indicadorNotas.intValue(), indicadorGuias.intValue(),
							indicadorAtualizar.intValue(), null, null, new Date(), ConstantesSistema.SIM, null, ConstantesSistema.SIM,
							ConstantesSistema.SIM, ConstantesSistema.SIM, 2, null);

			Collection<ContaValoresHelper> colecaoContaValores = colecaoDebitoImovel.getColecaoContasValores();

			ContaValoresHelper dadosConta = null;
			boolean possuiContasEmDebito = false;

			if(!Util.isVazioOrNulo(colecaoContaValores)){

				Iterator<ContaValoresHelper> colecaoContaValoresIterator = colecaoContaValores.iterator();

				while(colecaoContaValoresIterator.hasNext()){

					dadosConta = (ContaValoresHelper) colecaoContaValoresIterator.next();

					if(dadosConta.getConta().getDataVencimentoConta() != null
									&& Util.compararData(dadosConta.getConta().getDataVencimentoConta(), new Date()) == -1){

						possuiContasEmDebito = true;
						break;
					}
				}
			}

			// Caso o imóvel possua débitos vencidos, não considerar estes créditos a realizar para
			// o faturamento
			if(possuiContasEmDebito){

				for(CreditoARealizar creditoARealizar : colecaoCreditosARealizarRetorno){

					if(creditoARealizar.getCreditoTipo().getId().equals(CreditoTipo.CREDTAC)){

						colecaoCreditosARealizarCREDTAC.add(creditoARealizar);
					}
				}

				if(!Util.isVazioOrNulo(colecaoCreditosARealizarCREDTAC)){

					colecaoCreditosARealizarRetorno.removeAll(colecaoCreditosARealizarCREDTAC);
				}
			}else{

				Collection<CreditoARealizar> colecaoCreditosARealizarOutrosTipos = new ArrayList<CreditoARealizar>();

				// Caso o imóvel não possua débitos vencidos, considerar estes créditos colocando-os
				// como últimas ocorrências de créditos a serem lançados na conta
				for(CreditoARealizar creditoARealizar : colecaoCreditosARealizarRetorno){

					if(creditoARealizar.getCreditoTipo().getId().equals(CreditoTipo.CREDTAC)){

						colecaoCreditosARealizarCREDTAC.add(creditoARealizar);
					}else{

						colecaoCreditosARealizarOutrosTipos.add(creditoARealizar);
					}
				}

				colecaoCreditosARealizarRetorno.clear();

				if(!Util.isVazioOrNulo(colecaoCreditosARealizarOutrosTipos)){

					colecaoCreditosARealizarRetorno.addAll(colecaoCreditosARealizarOutrosTipos);
					faturarCREDTAC = true;
				}

				if(!Util.isVazioOrNulo(colecaoCreditosARealizarCREDTAC)){

					colecaoCreditosARealizarRetorno.addAll(colecaoCreditosARealizarCREDTAC);
					faturarCREDTAC = true;
				}
			}
		}

		retorno[0] = colecaoCreditosARealizarRetorno;
		retorno[1] = faturarCREDTAC;

		return retorno;
	}	

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto [SF0001] - Cálculo Simples Para Uma Única
	 * Tarifa
	 * 
	 * @author Raphael Rossiter
	 * @date 21/12/2005
	 * @deprecated
	 */
	protected Collection<CalcularValoresAguaEsgotoHelper> calculoSimplesUmaTarifa(Integer consumoFaturado, Collection categoriasImovel,
					BigDecimal percentualEsgoto, ConsumoTarifaVigencia consumoTarifaVigencia, String tipoCalculo)
					throws ControladorException{

		/*
		 * Para campos relacionados a consumo serão atribuídos valores inteiros, já com os campos
		 * monetários serão atribuídos valores com duas casas
		 * decimais (BigDecimal).
		 * -------------------------------------------------------------------------
		 */

		int quantTotalEconomia = 0;
		int consumoPorEconomia = 0;
		int consumoMinimoCategoria = 0;
		int consumoExcedenteCategoria = 0;
		int consumoEconomiaCategoria = 0;
		int consumoFaturadoCategoria = 0;
		BigDecimal vlTarifaMinimaCategoria = BigDecimal.ZERO;
		BigDecimal vlEconomiaCategoria = BigDecimal.ZERO;
		BigDecimal vlFaturadoCategoria = BigDecimal.ZERO;

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		// --------------------------------------------------------------------------

		Iterator itCategoriasImovel = categoriasImovel.iterator();
		Categoria categoria;

		// Calcula a quantidade total de economias do imóvel.
		// --------------------------------------------------------------------------
		while(itCategoriasImovel.hasNext()){
			categoria = (Categoria) itCategoriasImovel.next();

			quantTotalEconomia = quantTotalEconomia + categoria.getQuantidadeEconomiasCategoria().intValue();
		}

		// Calcula o consumo por economia (consumo faturado / quantidade total de economias).
		// consumoPorEconomia = Util.dividirArredondarResultado(consumoFaturado.intValue(),
		// quantTotalEconomia);

		// Pega o menor valor da divisão para o consumo de água ser o menor multiplo das economias
		// Roberta Costa - 27/07/2006
		if(quantTotalEconomia != 0){
			consumoPorEconomia = consumoFaturado.intValue() / quantTotalEconomia;
		}

		// --------------------------------------------------------------------------
		// Seleciona as tarifas de consumo por categoria
		// (CONSUMO_TARIFA_CATEGORIA).
		// --------------------------------------------------------------------------
		itCategoriasImovel = categoriasImovel.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoria;
		Collection colecaoConsumoTarifaCategoria = null;

		while(itCategoriasImovel.hasNext()){
			categoria = (Categoria) itCategoriasImovel.next();

			try{

				colecaoConsumoTarifaCategoria = repositorioFaturamento.pesquisarConsumoTarifaCategoria(consumoTarifaVigencia, categoria);

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if(colecaoConsumoTarifaCategoria == null || colecaoConsumoTarifaCategoria.isEmpty()){
				sessionContext.setRollbackOnly();
				// ////*****//////
				throw new ControladorException("atencao.categoria_nao_existe_para_tarifa_vigente");
			}

			consumoTarifaCategoria = (ConsumoTarifaCategoria) Util.retonarObjetoDeColecao(colecaoConsumoTarifaCategoria);

			/*
			 * Para cada tarifa de consumo por categoria selecionada serão calculados os valores
			 * (valor da tarifa mínima da categoria, consumo mínimo
			 * da categoria, valor por economia da categoria, consumo excedente da categoria)
			 * OBS - Cada categoria só possuirá uma tarifa de consumo (Analista 15/08/2005)
			 * -----------------------------------------------------------------------
			 */

			// ValorTarifaMinimaCategoria (CSTC_VLTARIFAMINIMA * quantidade de economias)
			if(consumoTarifaCategoria.getValorTarifaMinima() != null){
				vlTarifaMinimaCategoria = consumoTarifaCategoria.getValorTarifaMinima().multiply(
								new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));
			}else{
				vlTarifaMinimaCategoria = null;
			}

			// ConsumoMinimoCategoria (CSTC_NNCONSUMOMINIMO * quantidade de economias)
			if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
				consumoMinimoCategoria = consumoTarifaCategoria.getNumeroConsumoMinimo().intValue()
								* categoria.getQuantidadeEconomiasCategoria();
			}

			// ValorEconomiaCategoria (CSTC_VLTARIFAMINIMA)
			if(consumoTarifaCategoria.getValorTarifaMinima() != null){
				vlEconomiaCategoria = consumoTarifaCategoria.getValorTarifaMinima();
			}else{
				vlEconomiaCategoria = null;
			}

			/*
			 * Caso o consumo por economia seja maior que o CSTC_NNCONSUMOMINIMO então consumo por
			 * economia da categoria = CSTC_NNCONSUMOMINIMO, caso
			 * contrário consumo por economia da categoria = consumo por economia
			 */
			if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
				if(consumoPorEconomia > consumoTarifaCategoria.getNumeroConsumoMinimo().intValue()){

					consumoEconomiaCategoria = consumoTarifaCategoria.getNumeroConsumoMinimo().intValue();

				}else{

					consumoEconomiaCategoria = consumoPorEconomia;

				}
			}

			// Consumo excedente da categoria = consumo por economia – CSTC_NNCONSUMOMINIMO
			if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
				consumoExcedenteCategoria = consumoPorEconomia - consumoTarifaCategoria.getNumeroConsumoMinimo().intValue();
			}

			// Objeto que irá armazenar os valores calculados referentes as faixas
			Collection<CalcularValoresAguaEsgotoFaixaHelper> colecaoCalcularValoresAguaEsgotoFaixaHelper = new ArrayList();

			// Caso o consumo excedente da categoria seja maior que zero
			if(consumoExcedenteCategoria > 0){

				int faixaFimAnterior = 0;

				// Calcula a faixa fim anterior = CSTC_NNCONSUMOMINIMO
				if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
					faixaFimAnterior = consumoTarifaCategoria.getNumeroConsumoMinimo().intValue();
				}

				/*
				 * Seleciona as faixas para cálculo do valor faturado, classificadas pela faixa
				 * inicial de consumo (CSTI_NNCONSUMOFAIXAINICIO), (a
				 * partir da tabela CONSUMO_TARIFA_FAIXA com CSTC_ID=CSTC_ID da tabela
				 * CONSUMO_TARIFA_CATEGORIA)
				 */

				Collection colecaoConsumoTarifaFaixa = null;

				try{

					colecaoConsumoTarifaFaixa = repositorioFaturamento.pesquisarConsumoTarifaFaixa(consumoTarifaCategoria);

				}catch(ErroRepositorioException ex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				if(colecaoConsumoTarifaFaixa == null || colecaoConsumoTarifaFaixa.isEmpty()){
					// Nenhuma faixa foi encontrada
					sessionContext.setRollbackOnly();
					throw new ControladorException("");
				}else{
					Iterator itConsumoTarifaFaixa = colecaoConsumoTarifaFaixa.iterator();
					ConsumoTarifaFaixa consumoTarifaFaixa;

					// int consumoFaturadoFaixa = 0;
					// int limiteInicialConsumoFaixa = 0;
					// int limiteFinalConsumoFaixa = 0;
					// BigDecimal vlFaturadoFaixa = new BigDecimal("0");
					// BigDecimal vlTarifaFaixa = new BigDecimal("0");

					while(itConsumoTarifaFaixa.hasNext() && consumoExcedenteCategoria > 0){

						consumoTarifaFaixa = (ConsumoTarifaFaixa) itConsumoTarifaFaixa.next();

						// Calcula o consumo faturado na faixa = CSTF_NNCONSUMOFAIXAFIM – faixa fim
						// anterior
						int consumoFaturadoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaIFim().intValue() - faixaFimAnterior;

						/*
						 * Caso o consumo excedente da categoria seja menor que o consumo faturado
						 * na faixa, consumo faturado na faixa = consumo
						 * excedente da categoria
						 */
						if(consumoExcedenteCategoria < consumoFaturadoFaixa){
							consumoFaturadoFaixa = consumoExcedenteCategoria;
						}

						/*******************************************************
						 * Valor faturado na faixa = (consumo faturado na faixa
						 * CSTF_VLCONSUMOTARIFA).
						 */
						BigDecimal vlFaturadoFaixa = (new BigDecimal("" + consumoFaturadoFaixa)).multiply(consumoTarifaFaixa
										.getValorConsumoTarifa());

						// Valor por economia da categoria = valor por economia da categoria + valor
						// faturado na faixa
						vlEconomiaCategoria = vlEconomiaCategoria.add(vlFaturadoFaixa);

						// Consumo por economia da categoria = consumo por economia da categoria +
						// consumo faturado na faixa
						consumoEconomiaCategoria = consumoEconomiaCategoria + consumoFaturadoFaixa;

						// Limite inicial de consumo da faixa = CSTF_NNCONSUMOFAIXAINICIO
						int limiteInicialConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaInicio().intValue();

						// Limite final de consumo da faixa = CSTF_NNCONSUMOFAIXAFIM
						int limiteFinalConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaIFim().intValue();

						// Valor da tarifa na faixa = CSTF_VLCONSUMOTARIFA
						BigDecimal vlTarifaFaixa = consumoTarifaFaixa.getValorConsumoTarifa();

						// Consumo excedente da categoria = consumo excedente da categoria – consumo
						// faturado na faixa
						consumoExcedenteCategoria = consumoExcedenteCategoria - consumoFaturadoFaixa;

						// Faixa fim anterior = CSTI_NNCONSUMOFAIXAFIM
						faixaFimAnterior = consumoTarifaFaixa.getNumeroConsumoFaixaIFim().intValue();

						/*
						 * Inseri os valores calculados no objeto de faixas
						 * -----------------------------------------------------------------
						 */

						CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = new CalcularValoresAguaEsgotoFaixaHelper();

						calcularValoresAguaEsgotoFaixaHelper.setIdConsumoTarifaFaixa(consumoTarifaFaixa.getId());
						calcularValoresAguaEsgotoFaixaHelper.setLimiteInicialConsumoFaixa(limiteInicialConsumoFaixa);
						calcularValoresAguaEsgotoFaixaHelper.setLimiteFinalConsumoFaixa(limiteFinalConsumoFaixa);
						calcularValoresAguaEsgotoFaixaHelper.setValorTarifaFaixa(vlTarifaFaixa);

						if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){

							calcularValoresAguaEsgotoFaixaHelper.setConsumoFaturadoAguaFaixa(consumoFaturadoFaixa);
							calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoAguaFaixa(vlFaturadoFaixa);

						}else{

							calcularValoresAguaEsgotoFaixaHelper.setConsumoFaturadoEsgotoFaixa(consumoFaturadoFaixa);
							calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoEsgotoFaixa(vlFaturadoFaixa);

						}

						// ------------------------------------------------------------------

						colecaoCalcularValoresAguaEsgotoFaixaHelper.add(calcularValoresAguaEsgotoFaixaHelper);

					}
				}
			}

			// Calcula o valor faturado na categoria = valor por economia da categoria quantidade de
			// economias da categoria
			vlFaturadoCategoria = vlEconomiaCategoria.multiply(new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));

			// Calcula o consumo faturado na categoria = consumo por economia da categoria *
			// quantidade de economias da categoria
			consumoFaturadoCategoria = consumoEconomiaCategoria * categoria.getQuantidadeEconomiasCategoria().intValue();

			// --------------------------------------------------------
			// Gerando o novo objeto
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = new CalcularValoresAguaEsgotoHelper();

			// Carregando o id da categoria no objeto
			calcularValoresAguaEsgotoHelper.setIdCategoria(categoria.getId());

			// Carregando a descricao da categoria no objeto
			calcularValoresAguaEsgotoHelper.setDescricaoCategoria(categoria.getDescricao());

			// Carrega a quantidade de economias da categoria
			calcularValoresAguaEsgotoHelper.setQuantidadeEconomiasCategoria(categoria.getQuantidadeEconomiasCategoria());

			// Carregando o id do consumoTarifaCategoria no objeto
			calcularValoresAguaEsgotoHelper.setIdConsumoTarifaCategoria(consumoTarifaCategoria.getId());

			if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){

				calcularValoresAguaEsgotoHelper.setValorFaturadoAguaCategoria(vlFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoFaturadoAguaCategoria(consumoFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setValorTarifaMinimaAguaCategoria(vlTarifaMinimaCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoMinimoAguaCategoria(consumoMinimoCategoria);

			}else{

				// Calculando com o percentual de esgoto
				BigDecimal result = percentualEsgoto.divide(new BigDecimal("100"), 2, BigDecimal.ROUND_HALF_UP);

				// Valor faturado de esgoto
				vlFaturadoCategoria = vlFaturadoCategoria.multiply(result);
				vlFaturadoCategoria = vlFaturadoCategoria.setScale(2, BigDecimal.ROUND_HALF_UP);

				// Valor da tarifa mínima de esgoto
				vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.multiply(result);
				vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.setScale(2, BigDecimal.ROUND_HALF_UP);

				calcularValoresAguaEsgotoHelper.setValorFaturadoEsgotoCategoria(vlFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoFaturadoEsgotoCategoria(consumoFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setValorTarifaMinimaEsgotoCategoria(vlTarifaMinimaCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoMinimoEsgotoCategoria(consumoMinimoCategoria);
			}

			// Carregando a coleção com os valores referentes as faixas
			calcularValoresAguaEsgotoHelper.setFaixaTarifaConsumo(colecaoCalcularValoresAguaEsgotoFaixaHelper);

			colecaoRetorno.add(calcularValoresAguaEsgotoHelper);
		}

		return colecaoRetorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto [SF0002] - Cálculo Proporcional Para Mais de
	 * Uma Tarifa Autor: Raphael Rossiter Data:
	 * 09/01/2006
	 * 
	 * @author eduardo henrique
	 * @date 08/07/2008 Alteração das casas decimais dos Valores de Tarifa para 4 casas.
	 */
	protected Collection<CalcularValoresAguaEsgotoHelper> calculoProporcionalMaisDeUmaTarifa(Date dataLeituraAtual,
					Date dataLeituraAnterior, Collection<ConsumoTarifaVigencia> colecaoConsumoTarifaVigencia, Integer consumoFaturado,
					Collection categoriasImovel, BigDecimal percentualEsgoto, String tipoCalculo) throws ControladorException{

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		// 1 - Calcula a quantidade de dias entre as leituras = data de leitura
		// atual - data de leitura anterior
		long qtdDiasLeitura = IoUtil.diferencaEntreDatas(dataLeituraAnterior, dataLeituraAtual);

		// 2 - Data da vigência inicial
		Date dataVigenciaInicial = dataLeituraAnterior;

		// 3 - Para cada tarifa vigente para o período de leitura
		List colecaoConsumoTarifaVigenciaList = new ArrayList();
		colecaoConsumoTarifaVigenciaList.addAll(colecaoConsumoTarifaVigencia);

		ListIterator colecaoConsumoTarifaVigenciaListIt = colecaoConsumoTarifaVigenciaList.listIterator();

		ConsumoTarifaVigencia consumoTarifaVigenciaColecao;
		Collection<CalcularValoresAguaEsgotoHelper> calculoSimplesUmaTarifaColecao;

		Date dataVigenciaFinal = null;
		// ConsumoTarifaVigencia consumoTarifaVigenciaColecaoPrevious = null;

		boolean acrescentarDia = false;

		while(colecaoConsumoTarifaVigenciaListIt.hasNext()){

			consumoTarifaVigenciaColecao = (ConsumoTarifaVigencia) colecaoConsumoTarifaVigenciaListIt.next();

			// Cálculo Simples Para Uma Única Tarifa

			if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){

				calculoSimplesUmaTarifaColecao = calculoSimplesUmaTarifa(consumoFaturado, categoriasImovel, percentualEsgoto,
								consumoTarifaVigenciaColecao, ConstantesSistema.CALCULAR_AGUA);

			}else{

				calculoSimplesUmaTarifaColecao = calculoSimplesUmaTarifa(consumoFaturado, categoriasImovel, percentualEsgoto,
								consumoTarifaVigenciaColecao, ConstantesSistema.CALCULAR_ESGOTO);

			}

			// Caso exista próxima tarifa vigente então data da vigência final =
			// CSTV_DTVIGENCIA da próxima
			// tarifa vigente menos um dia, caso contrário, data da vigência
			// final = data de leitura atual

			if(colecaoConsumoTarifaVigenciaListIt.hasNext()){

				consumoTarifaVigenciaColecao = (ConsumoTarifaVigencia) colecaoConsumoTarifaVigenciaListIt.next();
				/*
				 * consumoTarifaVigenciaColecaoPrevious = (ConsumoTarifaVigencia)
				 */colecaoConsumoTarifaVigenciaListIt.previous();

				dataVigenciaFinal = consumoTarifaVigenciaColecao.getDataVigencia();

				// Subtraindo um dia
				Calendar dataVigenciaFinalMenosUmDia = new GregorianCalendar();
				dataVigenciaFinalMenosUmDia.setTime(dataVigenciaFinal);
				dataVigenciaFinalMenosUmDia.add(Calendar.DATE, -1);

				dataVigenciaFinal = dataVigenciaFinalMenosUmDia.getTime();

			}else{

				dataVigenciaFinal = dataLeituraAtual;

			}

			// Calcula a quantidade de dias de vigência da tarifa dentro do
			// perído de leitura =
			// data da vigência final - data da vigência inicial + 1 dia
			long qtdDiasVigenciaDentroPeriodo = IoUtil.diferencaEntreDatas(dataVigenciaInicial, dataVigenciaFinal);

			// Adiciona 1 dia
			if(acrescentarDia){
				qtdDiasVigenciaDentroPeriodo += 1;
			}

			acrescentarDia = true;

			// Calcula o fator de vigência da tarifa =
			// qtdDiasVigenciaDentroPeriodo / qtdDiasLeitura
			// O BigDecimal será arredondado para 4 casas decimais
			BigDecimal qtdDiasVigenciaDentroPeriodoBigDecimal = new BigDecimal(qtdDiasVigenciaDentroPeriodo);
			BigDecimal qtdDiasLeituraBigDecimal = new BigDecimal(qtdDiasLeitura);

			BigDecimal fatorVigenciaTarifa = qtdDiasVigenciaDentroPeriodoBigDecimal.divide(qtdDiasLeituraBigDecimal, 4,
							BigDecimal.ROUND_HALF_UP);

			// Para cada Categoria, aplica o fator de vigência da tarifa.

			Iterator calculoSimplesUmaTarifaColecaoIt = calculoSimplesUmaTarifaColecao.iterator();
			CalcularValoresAguaEsgotoHelper calculoSimplesUmaTarifaColecaoObjeto;
			BigDecimal valorFaturadoNew, valorTarifaMinimaNew;

			while(calculoSimplesUmaTarifaColecaoIt.hasNext()){

				calculoSimplesUmaTarifaColecaoObjeto = (CalcularValoresAguaEsgotoHelper) calculoSimplesUmaTarifaColecaoIt.next();

				if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){

					// Aplicando o fator de vigência da tarifa no valor faturado
					// de água da categoria
					// -----------------------------------------------------------------------------------
					valorFaturadoNew = calculoSimplesUmaTarifaColecaoObjeto.getValorFaturadoAguaCategoria().multiply(fatorVigenciaTarifa);

					// Arredondando para duas casas decimais
					valorFaturadoNew = valorFaturadoNew.setScale(2, BigDecimal.ROUND_HALF_UP);

					calculoSimplesUmaTarifaColecaoObjeto.setValorFaturadoAguaCategoria(valorFaturadoNew);
					// ------------------------------------------------------------------------------------

					// Aplicando o fator de vigência da tarifa no valor da
					// tarifa mínima de água da categoria
					// ------------------------------------------------------------------------------------
					valorTarifaMinimaNew = calculoSimplesUmaTarifaColecaoObjeto.getValorTarifaMinimaAguaCategoria().multiply(
									fatorVigenciaTarifa);

					// Arredondando para duas casas decimais
					valorTarifaMinimaNew = valorTarifaMinimaNew.setScale(4, BigDecimal.ROUND_HALF_UP);

					calculoSimplesUmaTarifaColecaoObjeto.setValorTarifaMinimaAguaCategoria(valorTarifaMinimaNew);
					// ------------------------------------------------------------------------------------

					// Para cada faixa da tarifa de consumo
					BigDecimal valorFaturadoFaixaNew, valorTarifaFaixaNew;

					Collection calculoSimplesUmaTarifaFaixaColecao = calculoSimplesUmaTarifaColecaoObjeto.getFaixaTarifaConsumo();
					Iterator calculoSimplesUmaTarifaFaixaIt = calculoSimplesUmaTarifaFaixaColecao.iterator();
					CalcularValoresAguaEsgotoFaixaHelper calculoSimplesUmaTarifaFaixaColecaoObjeto;

					while(calculoSimplesUmaTarifaFaixaIt.hasNext()){

						calculoSimplesUmaTarifaFaixaColecaoObjeto = (CalcularValoresAguaEsgotoFaixaHelper) calculoSimplesUmaTarifaFaixaIt
										.next();

						// Aplicando o fator de vigência da tarifa no valor
						// faturado de água na faixa
						// -----------------------------------------------------------------------------------
						valorFaturadoFaixaNew = calculoSimplesUmaTarifaFaixaColecaoObjeto.getValorFaturadoAguaFaixa().multiply(
										fatorVigenciaTarifa);

						// Arredondando para duas casas decimais
						valorFaturadoFaixaNew = valorFaturadoFaixaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

						calculoSimplesUmaTarifaFaixaColecaoObjeto.setValorFaturadoAguaFaixa(valorFaturadoFaixaNew);
						// ------------------------------------------------------------------------------------

						// Aplicando o fator de vigência da tarifa no valor da
						// tarifa na faixa
						// ------------------------------------------------------------------------------------

						valorTarifaFaixaNew = calculoSimplesUmaTarifaFaixaColecaoObjeto.getValorTarifaFaixa().multiply(fatorVigenciaTarifa);

						// Arredondando para duas casas decimais
						valorTarifaFaixaNew = valorTarifaFaixaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

						calculoSimplesUmaTarifaFaixaColecaoObjeto.setValorTarifaFaixa(valorTarifaFaixaNew);
						// ------------------------------------------------------------------------------------

					}
				}else{

					// Aplicando o fator de vigência da tarifa no valor faturado
					// de esgoto da categoria
					// -----------------------------------------------------------------------------------
					valorFaturadoNew = calculoSimplesUmaTarifaColecaoObjeto.getValorFaturadoEsgotoCategoria().multiply(fatorVigenciaTarifa);

					// Arredondando para duas casas decimais
					valorFaturadoNew = valorFaturadoNew.setScale(2, BigDecimal.ROUND_HALF_UP);

					calculoSimplesUmaTarifaColecaoObjeto.setValorFaturadoEsgotoCategoria(valorFaturadoNew);
					// ------------------------------------------------------------------------------------

					// Aplicando o fator de vigência da tarifa no valor da
					// tarifa mínima de esgoto da categoria
					// ------------------------------------------------------------------------------------
					valorTarifaMinimaNew = calculoSimplesUmaTarifaColecaoObjeto.getValorTarifaMinimaEsgotoCategoria().multiply(
									fatorVigenciaTarifa);

					// Arredondando para duas casas decimais
					valorTarifaMinimaNew = valorTarifaMinimaNew.setScale(4, BigDecimal.ROUND_HALF_UP);

					calculoSimplesUmaTarifaColecaoObjeto.setValorTarifaMinimaEsgotoCategoria(valorTarifaMinimaNew);
					// ------------------------------------------------------------------------------------

					// Para cada faixa da tarifa de consumo
					BigDecimal valorFaturadoFaixaNew, valorTarifaFaixaNew;

					Collection calculoSimplesUmaTarifaFaixaColecao = calculoSimplesUmaTarifaColecaoObjeto.getFaixaTarifaConsumo();
					Iterator calculoSimplesUmaTarifaFaixaIt = calculoSimplesUmaTarifaFaixaColecao.iterator();
					CalcularValoresAguaEsgotoFaixaHelper calculoSimplesUmaTarifaFaixaColecaoObjeto;

					while(calculoSimplesUmaTarifaFaixaIt.hasNext()){

						calculoSimplesUmaTarifaFaixaColecaoObjeto = (CalcularValoresAguaEsgotoFaixaHelper) calculoSimplesUmaTarifaFaixaIt
										.next();

						// Aplicando o fator de vigência da tarifa no valor
						// faturado de esgoto na faixa
						// -----------------------------------------------------------------------------------
						valorFaturadoFaixaNew = calculoSimplesUmaTarifaFaixaColecaoObjeto.getValorFaturadoEsgotoFaixa().multiply(
										fatorVigenciaTarifa);

						// Arredondando para duas casas decimais
						valorFaturadoFaixaNew = valorFaturadoFaixaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

						calculoSimplesUmaTarifaFaixaColecaoObjeto.setValorFaturadoEsgotoFaixa(valorFaturadoFaixaNew);
						// ------------------------------------------------------------------------------------

						// Aplicando o fator de vigência da tarifa no valor da
						// tarifa na faixa
						// ------------------------------------------------------------------------------------
						valorTarifaFaixaNew = calculoSimplesUmaTarifaFaixaColecaoObjeto.getValorTarifaFaixa().multiply(fatorVigenciaTarifa);

						// Arredondando para duas casas decimais
						valorTarifaFaixaNew = valorTarifaFaixaNew.setScale(2, BigDecimal.ROUND_HALF_UP);

						calculoSimplesUmaTarifaFaixaColecaoObjeto.setValorTarifaFaixa(valorTarifaFaixaNew);
						// ------------------------------------------------------------------------------------

					}
				}

			}

			// Calcula data de vigência inicial = data da vigência final + 1 dia

			// Adicionando um dia para data da vigência final
			Calendar dataVigenciaFinalMaisUmDia = new GregorianCalendar();
			dataVigenciaFinalMaisUmDia.setTime(dataVigenciaFinal);
			dataVigenciaFinalMaisUmDia.add(Calendar.DATE, 1);

			// Data de vigência inicial = data da vigência final + 1 dia
			dataVigenciaInicial = dataVigenciaFinalMaisUmDia.getTime();

			// Acumulando os valores calculados
			colecaoRetorno.addAll(calculoSimplesUmaTarifaColecao);

		}

		return colecaoRetorno;

	}

	/**
	 * Método utilizada para facilitar a implementação do [UC0120 - Calcular Valores de Água e/ou
	 * Esgoto]. Seleciona as tarifas vigentes para o imóvel
	 * no período de leitura. OBS - O campo tipoConsulta será utilizada para distinguir de que forma
	 * será realiza a consulta, ou seja, quais os
	 * parâmetros que serão utilizados. Legenda: Parcial = true , Final = false
	 * 
	 * @param tarifaImovel
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @param tipoConsulta
	 * @return
	 */
	protected Collection selecionaTarifasVigentesPeriodoLeituraImovel(Integer tarifaImovel, Date dataLeituraAnterior,
					Date dataLeituraAtual, boolean tipoConsulta) throws ControladorException{

		Collection retorno = new ArrayList();

		ConsumoTarifa consumoTarifa = new ConsumoTarifa();
		consumoTarifa.setId(tarifaImovel);

		/*
		 * Seleciona todas as ocorrências da tabela CONSUMO_TARIFA_VIGENCIA com CSTF_ID=Id da tarifa
		 * para o imóvel e com CSTV_DTVIGENCIA entre as
		 * datas de leitura anterior e atual, inclusive
		 */
		if(tipoConsulta){

			try{

				// Pesquisar pela data de vigência ordenada com parametro
				// conforme descritivo acima
				Collection colecaoConsumoTarifaVigencia = repositorioFaturamento
								.pesquisarConsumoTarifaVigenciaEntreDataLeituraAnterioreDataLeituraAtual(consumoTarifa,
												dataLeituraAnterior, dataLeituraAtual);
				retorno = colecaoConsumoTarifaVigencia;
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/*
		 * Seleciona a ocorrência da tabela CONSUMO_TARIFA_VIGENCIA com CSTF_ID=Id da tarifa para o
		 * imóvel e com a maior CSTV_DTVIGENCIA que seja
		 * menor que a data de leitura anterior
		 */
		else{

			Collection colecaoConsumoTarifaVigencia = null;

			try{
				colecaoConsumoTarifaVigencia = repositorioFaturamento.pesquisarConsumoTarifaVigenciaMenorDataLeituraAnterior(consumoTarifa,
								dataLeituraAnterior);
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			ConsumoTarifaVigencia consumoTarifaVigencia = obterConsumoTarifaVigencia(colecaoConsumoTarifaVigencia);

			if(consumoTarifaVigencia != null){
				retorno.add(consumoTarifaVigencia);
			}

		}

		return retorno;
	}

	/*
	 * Recebe uma coleção e retorna o objeto ConsumoTarifaVigência com id e data de vigência setados
	 * Autor: Leonardo Vieira Data: 27/12/2005
	 */

	public ConsumoTarifaVigencia obterConsumoTarifaVigencia(Collection colecaoConsumoTarifaVigencia){

		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		boolean parametrNulo = true;

		if(colecaoConsumoTarifaVigencia != null && !colecaoConsumoTarifaVigencia.isEmpty()){

			Object[] consumoTarifaVigenciaArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoConsumoTarifaVigencia);

			// Seta o id do consumo tarifa vigência
			if(consumoTarifaVigenciaArray[0] != null){
				consumoTarifaVigencia.setId((Integer) consumoTarifaVigenciaArray[0]);
				parametrNulo = false;
			}

			// Seta a data de vigência
			if(consumoTarifaVigenciaArray[1] != null){
				consumoTarifaVigencia.setDataVigencia((Date) consumoTarifaVigenciaArray[1]);
				parametrNulo = false;
			}

		}

		if(parametrNulo){
			consumoTarifaVigencia = null;
		}

		return consumoTarifaVigencia;

	}

	public Date buscarDataLeituraCronograma(Imovel imovel, boolean situacao, Integer anoMesReferencia) throws ControladorException{

		Date retorno = null;
		Collection colecaoFaturamentoAtividadeCronograma;

		FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

		/*
		 * Vai buscar o objeto FaturamentoGrupoCronogramaMensal com as características do imóvel
		 * recebido e o anoMes da Conta - Fernanda Paiva -
		 * 19/08/2006
		 */
		FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal = buscarFaturamentoGrupoCronogramaMensal(anoMesReferencia,
						imovel.getRota(), situacao, null);

		if(faturamentoGrupoCronogramaMensal != null){

			// Comentado por Raphael Rossiter em 09/05/2007
			/*
			 * throw new ControladorException( "atencao.nao_realizada_atividade_leitura", null,
			 * imovel .getQuadra().getRota().getFaturamentoGrupo()
			 * .getId().toString());
			 */

			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID, faturamentoGrupoCronogramaMensal
											.getId()));

			/*
			 * FTAT_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA com o valor correspondente a
			 * leitura
			 */
			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, FaturamentoAtividade.EFETUAR_LEITURA));

			colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
							FaturamentoAtividadeCronograma.class.getName());

			if(colecaoFaturamentoAtividadeCronograma != null && !colecaoFaturamentoAtividadeCronograma.isEmpty()){
				FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
								.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

				if(faturamentoAtividadeCronograma.getDataRealizacao() != null){
					retorno = faturamentoAtividadeCronograma.getDataRealizacao();
				}
			}
		}

		return retorno;
	}

	/**
	 * Realiza uma pesquisa na tabela Faturamento_Grupo_Cronograma_Mensal de acordo com os dados
	 * recebidos (mês e ano de referencia anterior).
	 * 
	 * @param anoMesReferencia
	 * @param rota
	 * @return um objeto do tipo FaturamentoGrupoCronogramaMensal
	 */
	protected FaturamentoGrupoCronogramaMensal buscarFaturamentoGrupoCronogramaMensal(Integer anoMesReferencia, Rota rota,
					boolean situacao, Integer grupoFaturamentoID) throws ControladorException{

		Collection colecaoFaturamentoGrupoCronogramaMensal;
		FaturamentoGrupoCronogramaMensal retorno = null;

		FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

		/* Passa como parâmetro o id do objeto FaturamentoGrupo que está na Rota */
		if(rota != null){
			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO, rota.getFaturamentoGrupo().getId()));
		}else{
			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO, grupoFaturamentoID));
		}

		// Ano e mês de referência – 1 MÊS (Testar este método)
		if(situacao){
			int anoMesReferenciaAnterior = Util.subtrairData(anoMesReferencia.intValue());

			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA, Integer.valueOf(anoMesReferenciaAnterior)));
		}else{
			filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA, anoMesReferencia));
		}

		colecaoFaturamentoGrupoCronogramaMensal = getControladorUtil().pesquisar(filtroFaturamentoGrupoCronogramaMensal,
						FaturamentoGrupoCronogramaMensal.class.getName());

		if(colecaoFaturamentoGrupoCronogramaMensal != null && !colecaoFaturamentoGrupoCronogramaMensal.isEmpty()){
			retorno = (FaturamentoGrupoCronogramaMensal) Util.retonarObjetoDeColecao(colecaoFaturamentoGrupoCronogramaMensal);
		}

		return retorno;
	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [FS0003] – Verificar existência do
	 * cronograma para o grupo Verifica a existência de
	 * cronograma para o grupo de faturamento
	 * 
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	public void verificarExistenciaCronogramaGrupo(FaturamentoGrupo faturamentoGrupo) throws ControladorException{

		Collection colecaoPesquisa;

		FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

		filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO, faturamentoGrupo.getId()));

		filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA, faturamentoGrupo.getAnoMesReferencia()));

		colecaoPesquisa = getControladorUtil().pesquisar(filtroFaturamentoGrupoCronogramaMensal,
						FaturamentoGrupoCronogramaMensal.class.getName());

		if(colecaoPesquisa == null || colecaoPesquisa.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.pesquisa.cronograma_mensal_grupo_inexistente");
		}
	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [FS0008] – Verificar existência da
	 * atividade no cronograma do grupo do mês corrente
	 * 
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	public boolean verificarExistenciaCronogramaAtividadeGrupo(FaturamentoAtividade faturamentoAtividade, FaturamentoGrupo faturamentoGrupo)
					throws ControladorException{

		boolean retorno = false;

		Collection colecaoPesquisa;

		FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

		filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, faturamentoAtividade.getId()));

		filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID, faturamentoGrupo
										.getId()));

		filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA, faturamentoGrupo
										.getAnoMesReferencia()));

		colecaoPesquisa = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
						FaturamentoAtividadeCronograma.class.getName());

		/*
		 * if (colecaoPesquisa == null || colecaoPesquisa.isEmpty()) {
		 * sessionContext.setRollbackOnly(); throw new ControladorException(
		 * "atencao.pesquisa.cronograma_atividade_mensal_grupo_inexistente"); }
		 */

		if(colecaoPesquisa != null && !colecaoPesquisa.isEmpty()){
			retorno = true;
		}

		return retorno;

	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [SB0001] – Selecionar Atividade de
	 * Faturamento O sistema seleciona as atividades que podem
	 * ser comandadas
	 * 
	 * @return uma coleção de atividades de faturamento
	 * @throws ControladorException
	 */
	public Collection selecionarAtividadeFaturamentoQuePodeSerComandada(FaturamentoGrupo faturamentoGrupo) throws ControladorException{

		Collection retorno = new Vector();

		FiltroFaturamentoAtividade filtroFaturamentoAtividade = new FiltroFaturamentoAtividade(FiltroFaturamentoAtividade.DESCRICAO);

		filtroFaturamentoAtividade.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividade.INDICADOR_POSSIBILIDADE_COMANDO_ATIVIDADE,
						FaturamentoAtividade.ATIVIDADE_POSSIVEL_COMANDO));

		filtroFaturamentoAtividade.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtividade.INDICADOR_USO,
						ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection colecaoFaturamentoAtividade;

		colecaoFaturamentoAtividade = getControladorUtil().pesquisar(filtroFaturamentoAtividade, FaturamentoAtividade.class.getName());

		// [FS0001] – Verificar existência de dados
		if(colecaoFaturamentoAtividade == null || colecaoFaturamentoAtividade.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.pesquisa.nenhum_registro_tabela", null, "FATURAMENTO_ATIVIDADE");
		}else{
			FaturamentoAtividade faturamentoAtividade;
			Iterator colecaoFaturamentoAtividadeIterator = colecaoFaturamentoAtividade.iterator();

			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
			Collection colecaoFaturamentoAtividadeCronograma;
			FaturamentoAtividadeCronograma faturamentoAtividadeCronograma;

			boolean atividadeSelecao;
			while(colecaoFaturamentoAtividadeIterator.hasNext()){
				atividadeSelecao = false;
				faturamentoAtividade = (FaturamentoAtividade) colecaoFaturamentoAtividadeIterator.next();

				// 1º Etapa
				// ==========================================================
				/*
				 * Possa ser repetida (FTAT_ICREPETICAO=1) ou não tenha sido realizada no cronograma
				 * do mês de faturamento (FTAC_DTREALIZADA com o
				 * valor nulo na tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=FTAT_ID da
				 * tabela FATURAMENTO_ATIVIDADE e FTCM_ID=FTCM_ID da
				 * tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com
				 * FTCM_AMREFERENCIA=FTGR_AMREFERENCIA e FTGR_ID= Grupo de faturamento selecionado).
				 * ==========================================================
				 */

				if(faturamentoAtividade.getIndicadorPossibilidadeRepeticaoAtividade() != null
								&& faturamentoAtividade.getIndicadorPossibilidadeRepeticaoAtividade().equals(
												FaturamentoAtividade.ATIVIDADE_POSSIVEL_REPETICAO)){
					atividadeSelecao = true;
				}else{
					filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, faturamentoAtividade.getId()));

					filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
									faturamentoGrupo.getId()));

					filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
									faturamentoGrupo.getAnoMesReferencia()));

					colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
									FaturamentoAtividadeCronograma.class.getName());

					if(colecaoFaturamentoAtividadeCronograma != null && !colecaoFaturamentoAtividadeCronograma.isEmpty()){
						faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
										.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

						if(faturamentoAtividadeCronograma.getDataRealizacao() == null){
							atividadeSelecao = true;
						}

						colecaoFaturamentoAtividadeCronograma.clear();
					}

					filtroFaturamentoAtividadeCronograma.limparListaParametros();
				}

				// 2º Etapa
				// ==========================================================
				/*
				 * Não tenha atividade predecessora (FTAT_IDATIVIDADEPRECEDENTE=nulo) ou tenha
				 * predecessora já realizada (FTAC_DTREALIZADA com o valor
				 * preenchido na tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=
				 * FTAT_IDATIVIDADEPRECEDENTE e FTCM_ID=FTCM_ID da tabela
				 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com FTCM_AMREFERENCIA=FTGR_AMREFERENCIA e
				 * FTGR_ID= Grupo de faturamento selecionado).
				 * ===================================================================
				 */

				if(atividadeSelecao){
					atividadeSelecao = false;

					if(faturamentoAtividade.getFaturamentoAtividadePrecedente() == null){
						atividadeSelecao = true;
					}else{
						filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, faturamentoAtividade
														.getFaturamentoAtividadePrecedente().getId()));

						filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID,
										faturamentoGrupo.getId()));

						filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
										faturamentoGrupo.getAnoMesReferencia()));

						colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
										FaturamentoAtividadeCronograma.class.getName());

						if(colecaoFaturamentoAtividadeCronograma != null && !colecaoFaturamentoAtividadeCronograma.isEmpty()){
							faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
											.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

							if(faturamentoAtividadeCronograma.getDataRealizacao() != null){
								atividadeSelecao = true;
							}

							colecaoFaturamentoAtividadeCronograma.clear();
						}

						filtroFaturamentoAtividadeCronograma.limparListaParametros();
					}

					// 3º Etapa
					// ===================================================================
					/*
					 * A atividade de faturamento esteja no cronograma de faturamento para o grupo
					 * no mês corrente (existe
					 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID = FTAT_ID da tabela
					 * FATURAMENTO_ATIVIDADE e FTCM_ID = FTCM_ID da tabela
					 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL)
					 * ===================================================================
					 */
					if(atividadeSelecao){
						atividadeSelecao = false;

						if(this.verificarExistenciaCronogramaAtividadeGrupo(faturamentoAtividade, faturamentoGrupo)){
							atividadeSelecao = true;
						}

					}

					/*
					 * Adiciona o objeto do tipo FaturamentoAtividade na coleção de retorno, caso o
					 * mesmo tenha passado pelas duas etapas
					 */
					if(atividadeSelecao){
						retorno.add(faturamentoAtividade);
					}

				}

				// FIM DO LOOP

			}

		}

		// [FS0002] – Verificar seleção de pelo menos uma Atividade de
		// Faturamento
		if(retorno == null || retorno.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.pesquisa.nenhuma.atividade_faturamento_grupo");
		}

		return retorno;
	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [FS0006] – Verificar existência de rotas
	 * para o grupo Verifica a existência de rotas para o
	 * grupo de faturamento
	 * 
	 * @param faturamentoGrupo
	 * @return uma coleção de rotas pertencentes ao grupo selecionado
	 * @throws ControladorException
	 */
	public Collection verificarExistenciaRotaGrupo(FaturamentoGrupo faturamentoGrupo) throws ControladorException{

		Collection colecaoPesquisa = null;

		FiltroRota filtroRota = new FiltroRota();

		// Retornará todas as ocorrências encontradas
		filtroRota.setConsultaSemLimites(true);

		filtroRota.setCampoOrderBy(FiltroRota.FATURAMENTO_GRUPO_ID, FiltroRota.GERENCIA_REGIONAL_NOME_ABREVIADO,
						FiltroRota.LOCALIDADE_DESCRICAO, FiltroRota.SETOR_COMERCIAL_CODIGO, FiltroRota.ID_ROTA);

		/**
		 * alterado por pedro alexandre dia 22/01/2007
		 */
		filtroRota.adicionarCaminhoParaCarregamentoEntidade(FiltroRota.UNIDADE_NEGOCIO);
		/*
		 * filtroRota
		 * .adicionarCaminhoParaCarregamentoEntidade(FiltroRota.UNIDADE_NEGOCIO_NOME_ABREVIADO);
		 */

		// Objetos que serão retornados pelo hibernate
		filtroRota.adicionarCaminhoParaCarregamentoEntidade("setorComercial.localidade.gerenciaRegional");

		filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.FATURAMENTO_GRUPO_ID, faturamentoGrupo.getId()));

		filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.INDICADOR_USO, ConstantesSistema.INDICADOR_USO_ATIVO));

		colecaoPesquisa = getControladorUtil().pesquisar(filtroRota, Rota.class.getName());

		if(colecaoPesquisa == null || colecaoPesquisa.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.pesquisa.rota_grupo_inexistente");
		}

		return colecaoPesquisa;
	}

	/**
	 * [UC0144] - Inserir Comando Atividade de Faturamento [SB0002] – Verificar Situação da
	 * Atividade para a Rota
	 * 
	 * @return uma coleção de rotas
	 */
	public Collection verificarSituacaoAtividadeRota(Collection colecaoRotasGrupo, FaturamentoAtividade faturamentoAtividade,
					Integer anoMesReferencia, boolean habilitada) throws ControladorException{

		Collection retorno = new Vector();

		Collection rotasHabilitadas = new Vector();
		Collection rotasNaoHabilitadas = new Vector();

		Rota rota;
		Iterator colecaoRotasGrupoIterator = colecaoRotasGrupo.iterator();

		FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();

		filtroFaturamentoAtivCronRota.setCampoOrderBy(FiltroFaturamentoAtivCronRota.FATURAMENTO_GRUPO_ID,
						FiltroFaturamentoAtivCronRota.GERENCIA_REGIONAL_NOME_ABREVIADO, FiltroFaturamentoAtivCronRota.LOCALIDADE_DESCRICAO,
						FiltroFaturamentoAtivCronRota.SETOR_COMERCIAL_CODIGO, FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_ID);

		filtroFaturamentoAtivCronRota.adicionarCaminhoParaCarregamentoEntidade(FiltroFaturamentoAtivCronRota.UNIDADE_NEGOCIO);

		filtroFaturamentoAtivCronRota.setConsultaSemLimites(true);

		Collection colecaoFaturamentoAtividadeCronogramaRota;

		boolean rotaHabilitada;
		while(colecaoRotasGrupoIterator.hasNext()){
			rotaHabilitada = false;
			rota = (Rota) colecaoRotasGrupoIterator.next();

			/*
			 * 1º Etapa ===================================================================
			 * Caso a atividade possa ser repetida (FTAT_ICREPETICAO=1) ou não tenha sido realizada
			 * no mês de faturamento para a rota (inexiste
			 * ROTA_ID=rota selecionada na tabela FATURAMENTO_ATIV_CRON_ROTA para FTAC_ID=FTAC_ID da
			 * tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA com
			 * FTAT_ID=Atividade a ser comandada para FTCM_ID=FTCM_ID da tabela
			 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com FTCM_AMREFERENCIA=
			 * FTGR_AMREFERENCIA)
			 * ===================================================================
			 */

			if(faturamentoAtividade.getIndicadorPossibilidadeRepeticaoAtividade() != null
							&& faturamentoAtividade.getIndicadorPossibilidadeRepeticaoAtividade().equals(
											FaturamentoAtividade.ATIVIDADE_POSSIVEL_REPETICAO)){
				rotaHabilitada = true;
			}else{
				filtroFaturamentoAtivCronRota.adicionarCaminhoParaCarregamentoEntidade("faturamentoAtividadeCronograma");
				filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_ID, rota
								.getId()));
				filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_ATIVIDADE_ID,
								faturamentoAtividade.getId()));
				filtroFaturamentoAtivCronRota
								.adicionarParametro(new ParametroSimples(
												FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
												anoMesReferencia));

				colecaoFaturamentoAtividadeCronogramaRota = getControladorUtil().pesquisar(filtroFaturamentoAtivCronRota,
								FaturamentoAtivCronRota.class.getName());

				if(colecaoFaturamentoAtividadeCronogramaRota == null || colecaoFaturamentoAtividadeCronogramaRota.isEmpty()){
					rotaHabilitada = true;
					// colecaoFaturamentoAtividadeCronogramaRota.clear(); //se for nula pode dar
					// exceçao ponteiro nulo
				}else{
					// Verifica se a atividade já foi realizada
					FaturamentoAtivCronRota faturamentoAtivCronRota = (FaturamentoAtivCronRota) Util
									.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRota);

					if(faturamentoAtivCronRota.getFaturamentoAtividadeCronograma().getDataRealizacao() == null){
						rotaHabilitada = true;
					}
				}

				filtroFaturamentoAtivCronRota.limparListaParametros();

			}

			// 2º Etapa
			// ==========================================================
			/*
			 * Não tenha atividade predecessora (FTAT_IDATIVIDADEPRECEDENTE=nulo) ou tenha
			 * predecessora já realizada (FTAC_DTREALIZADA com o valor
			 * preenchido na tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=
			 * FTAT_IDATIVIDADEPRECEDENTE e FTCM_ID=FTCM_ID da tabela
			 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com FTCM_AMREFERENCIA=FTGR_AMREFERENCIA e
			 * FTGR_ID= Grupo de faturamento selecionado).
			 * ===================================================================
			 */

			if(rotaHabilitada){
				rotaHabilitada = false;

				if(faturamentoAtividade.getFaturamentoAtividadePrecedente() == null){
					rotaHabilitada = true;
				}else{

					// Objeto que será retornado pelo hibernate
					filtroFaturamentoAtivCronRota.adicionarCaminhoParaCarregamentoEntidade("faturamentoAtividadeCronograma");
					filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_ID,
									rota.getId()));
					filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_ATIVIDADE_ID,
									faturamentoAtividade.getFaturamentoAtividadePrecedente().getId()));
					filtroFaturamentoAtivCronRota
									.adicionarParametro(new ParametroSimples(
													FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
													anoMesReferencia));
					colecaoFaturamentoAtividadeCronogramaRota = getControladorUtil().pesquisar(filtroFaturamentoAtivCronRota,
									FaturamentoAtivCronRota.class.getName());

					if(colecaoFaturamentoAtividadeCronogramaRota != null && !colecaoFaturamentoAtividadeCronogramaRota.isEmpty()){
						FaturamentoAtivCronRota faturamentoAtivCronRota = (FaturamentoAtivCronRota) Util
										.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronogramaRota);

						if(faturamentoAtivCronRota.getFaturamentoAtividadeCronograma().getDataRealizacao() != null){
							rotaHabilitada = true;
						}
						colecaoFaturamentoAtividadeCronogramaRota.clear();
					}
					filtroFaturamentoAtivCronRota.limparListaParametros();
				}

				// Adiciona o objeto do tipo Rota na coleção de retorno e de acordo com a sua
				// situação
				if(rotaHabilitada){
					rotasHabilitadas.add(rota);
				}else{
					rotasNaoHabilitadas.add(rota);
				}
			}else{
				// Adiciona a rota na coleção das não habilitadas
				rotasNaoHabilitadas.add(rota);
			}

			// FIM DO LOOP
		}

		// Define a coleção de retorno (rotas habilitadas ou rotas não habilitadas)
		if(habilitada){
			retorno.addAll(rotasHabilitadas);
		}else{
			retorno.addAll(rotasNaoHabilitadas);
		}

		return retorno;
	}

	/**
	 * @param faturamentoGrupo
	 * @param faturamentoAtividade
	 * @param colecaoRotas
	 * @param dataVencimentoGrupo
	 * @throws ControladorException
	 */
	public Integer inserirComandoAtividadeFaturamento(FaturamentoGrupo faturamentoGrupo, FaturamentoAtividade faturamentoAtividade,
					Collection colecaoRotas, Date dataVencimentoGrupo, Usuario usuarioLogado) throws ControladorException{

		// [FS0010] - Verificar Referência do Grupo de Faturamento
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		String pVerificarReferencia = ParametroFaturamento.P_VERIFICAR_REFERENCIA_GRUPO_FATURAMENTO.executar();
		if(pVerificarReferencia != null){
			Short verificarReferencia = new Short(pVerificarReferencia);

			if(verificarReferencia != null && verificarReferencia.equals(ConstantesSistema.SIM)
							&& faturamentoGrupo.getAnoMesReferencia() != null && sistemaParametro.getAnoMesFaturamento() != null
							&& (faturamentoGrupo.getAnoMesReferencia().compareTo(sistemaParametro.getAnoMesFaturamento()) > 0)){
				throw new ControladorException("atencao.faturamento.comando.referencia.invalida", null,
								Util.formatarAnoMesParaMesAno(sistemaParametro.getAnoMesFaturamento()));
			}
		}

		/*
		 * Atualiza a data e hora do comando (FTAC_TMCOMANDO=CURRENT TIMESTAMP) na tabela
		 * FATURAMENTO_ATIVIDADE_CRONOGRAMA para FTAT_ID=Atividade a
		 * ser comandada e FTCM_ID=FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL para
		 * FTGR_ID=Grupo selecionado e
		 * FTCM_AMREFERENCIA=FTGR_AMREFERENCIA da tabela FATURAMENTO_GRUPO para FTGR_ID=Grupo
		 * selecionado
		 * =====================================================================
		 */
		Collection colecaoFaturamentoAtividadeCronograma;

		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma;

		Integer faturamentoAtividadeCronogramaId = null;

		FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

		filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, faturamentoAtividade.getId()));

		filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID, faturamentoGrupo
										.getId()));

		filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
						FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA, faturamentoGrupo
										.getAnoMesReferencia()));

		colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
						FaturamentoAtividadeCronograma.class.getName());

		if(colecaoFaturamentoAtividadeCronograma != null && !colecaoFaturamentoAtividadeCronograma.isEmpty()){

			faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
							.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

			String pVerificarExistencia = ParametroFaturamento.P_VERIFICAR_EXISTENCIA_COMANDO_FATUAMENTO.executar();

			if(ConstantesSistema.SIM.toString().equals(pVerificarExistencia)){
				Date comando = faturamentoAtividadeCronograma.getComando();

				if(comando != null){
					throw new ControladorException("atencao.faturamento.comando.ja.existente");
				}
			}

			faturamentoAtividadeCronograma.setComando(new Date());

			faturamentoAtividadeCronogramaId = faturamentoAtividadeCronograma.getId();

			faturamentoAtividadeCronograma.setDataRealizacao(null);
			
			//REGISTRAR TRANSAÇÂO
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_INSERIR_COMANDO_ATIVIDADE_FATURAMENTO,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
			
			//REGISTRAR TRANSAÇÂO
			

			this.atualizarFaturamentoAtividadeCronograma(faturamentoAtividadeCronograma, registradorOperacao);

			/*
			 * Exclui todas as rotas na tabela FATURAMENTO_ATIV_CRON_ROTA para F TAC_ID=FTAC_ID da
			 * tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA atualizada
			 */
			try{
				// repositorioFaturamento.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma.getId());
				this.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma.getId(), registradorOperacao);
			}catch(ControladorException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
			// ====================================================================

			/*
			 * Inclui as rotas “habilitadas do grupo” na tabela FATURAMENTO_ATIV_CRON_ROTA para
			 * FTAC_ID=FTAC_ID da tabela
			 * FATURAMENTO_ATIVIDADE_CRONOGRAMA atualizada , ROTA_ID=Rota selecionada e
			 * FACR_DTCONTAVENCIMENTO com a data de vencimento do grupo caso
			 * a atividade de faturamento selecionada corresponda à atividade faturar grupo; caso
			 * contrário, com o valor null.
			 */
			FaturamentoAtivCronRotaPK faturamentoAtividadeCronogramaRotaPK = new FaturamentoAtivCronRotaPK();

			faturamentoAtividadeCronogramaRotaPK.setFaturamentoAtividadeCronogramaId(faturamentoAtividadeCronograma.getId());

			Iterator colecaoRotasIterator = colecaoRotas.iterator();
			Rota rotaColecao;

			FaturamentoAtivCronRota faturamentoAtividadeCronogramaRota = new FaturamentoAtivCronRota();

			faturamentoAtividadeCronogramaRota.setDataContaVencimento(dataVencimentoGrupo);

			while(colecaoRotasIterator.hasNext()){
				rotaColecao = (Rota) colecaoRotasIterator.next();
				faturamentoAtividadeCronogramaRotaPK.setRotaId(rotaColecao.getId());

				faturamentoAtividadeCronogramaRota.setComp_id(faturamentoAtividadeCronogramaRotaPK);

				faturamentoAtividadeCronogramaRota.setUltimaAlteracao(new Date());

				registradorOperacao.registrarOperacao(faturamentoAtividadeCronogramaRota);

				getControladorUtil().inserir(faturamentoAtividadeCronogramaRota);
			}

		}

		return faturamentoAtividadeCronogramaId;
	}

	public void atualizarComandoAtividadeFaturamento(FaturamentoAtividadeCronograma faturamentoAtividadeCronograma,
					Collection colecaoFaturamentoAtividadeCronogramaRota, Usuario usuarioLogado) throws ControladorException{

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ATUALIZAR_COMANDO_ATIVIDADE_FATURAMENTO,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		/*
		 * Exclui todas as rotas na tabela FATURAMENTO_ATIV_CRON_ROTA para F TAC_ID=FTAC_ID da
		 * tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA atualizada
		 * ====================================================================
		 */
		try{
			// repositorioFaturamento.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma.getId());
			this.removerTodasRotasPorCronogramaFaturamento(faturamentoAtividadeCronograma.getId(), registradorOperacao);
		}catch(ControladorException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		// ====================================================================

		/*
		 * Inclui as rotas “habilitadas do grupo” na tabela FATURAMENTO_ATIV_CRON_ROTA para
		 * FTAC_ID=FTAC_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA
		 * atualizada , ROTA_ID=Rota selecionada e FACR_DTCONTAVENCIMENTO com a data de vencimento
		 * do grupo caso a atividade de faturamento
		 * selecionada corresponda à atividade faturar grupo; caso contrário, com o valor null.
		 */

		Iterator colecaoFaturamentoAtividadeCronogramaRotaIterator = colecaoFaturamentoAtividadeCronogramaRota.iterator();

		FaturamentoAtivCronRota faturamentoAtividadeCronogramaRota = null;

		while(colecaoFaturamentoAtividadeCronogramaRotaIterator.hasNext()){
			faturamentoAtividadeCronogramaRota = (FaturamentoAtivCronRota) colecaoFaturamentoAtividadeCronogramaRotaIterator.next();
			faturamentoAtividadeCronogramaRota.setUltimaAlteracao(new Date());

			registradorOperacao.registrarOperacao(faturamentoAtividadeCronogramaRota);
			getControladorUtil().inserir(faturamentoAtividadeCronogramaRota);
		}

	}

	/**
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * Retorna uma lista de atividades de faturamento comandadas e ainda não realizadas
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection buscarAtividadeComandadaNaoRealizada(Integer numeroPagina, Integer idFaturamentoGrupo, Integer anoMesReferencia)
					throws ControladorException{

		Collection retorno;

		try{
			retorno = this.repositorioFaturamento.buscarAtividadeComandadaNaoRealizada(numeroPagina, idFaturamentoGrupo, anoMesReferencia);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(retorno == null || retorno.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.pesquisa.nenhuma.atividade_faturamento_para_atualizacao");
		}

		return retorno;
	}

	private void removerTodasRotasPorCronogramaFaturamento(Integer idFaturamentoAtividadeCronograma, RegistradorOperacao registradorOperacao)
					throws ControladorException{

		FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();
		filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples("comp_id.faturamentoAtividadeCronogramaId",
						idFaturamentoAtividadeCronograma));

		try{
			Collection<FaturamentoAtivCronRota> colecaoFaturamentoAtivCronRotas = repositorioUtil.pesquisar(filtroFaturamentoAtivCronRota,
							FaturamentoAtivCronRota.class.getName());

			for(FaturamentoAtivCronRota faturamentoAtivCronRota : colecaoFaturamentoAtivCronRotas){
				registradorOperacao.registrarOperacao(faturamentoAtivCronRota);
				repositorioUtil.remover(faturamentoAtivCronRota);
			}

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Este caso de uso permite alterar ou excluir um comando de atividade de faturamento
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * Retorna o count do resultado da pesquisa de Faturamento Atividade Cronograma não realizadas
	 * buscarAtividadeComandadaNaoRealizadaCount
	 * 
	 * @author Roberta Costa
	 * @date 18/07/2006
	 * @param filtroFaturamentoAtividadeCronograma
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer buscarAtividadeComandadaNaoRealizadaCount(Integer idFaturamentoGrupo, Integer anoMesReferencia)
					throws ControladorException{

		Integer retorno = null;

		try{
			retorno = this.repositorioFaturamento.buscarAtividadeComandadaNaoRealizadaCount(idFaturamentoGrupo, anoMesReferencia);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Retorna o valor de controladorImovel
	 * 
	 * @return O valor de controladorImovel
	 */
	protected ControladorImovelLocal getControladorImovel(){

		ControladorImovelLocalHome localHome = null;
		ControladorImovelLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorImovelLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_IMOVEL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorMicromedicao
	 * 
	 * @return O valor de controladorMicromedicao
	 */
	protected ControladorMicromedicaoLocal getControladorMicromedicao(){

		ControladorMicromedicaoLocalHome localHome = null;
		ControladorMicromedicaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorMicromedicaoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_MICROMEDICAO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorUtil
	 * 
	 * @return O valor de controladorUtil
	 */
	protected ControladorUtilLocal getControladorUtil(){

		ControladorUtilLocalHome localHome = null;
		ControladorUtilLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorUtilLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_UTIL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Retorna o valor de controladorSpcSerasaSEJB
	 * 
	 * @return O valor de controladorSpcSerasa
	 */
	private ControladorSpcSerasaLocal getControladorSpcSerasa(){

		ControladorSpcSerasaLocalHome localHome = null;
		ControladorSpcSerasaLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorSpcSerasaLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_SPC_SERASA_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * [UC0183 - Inserir Débito A Cobrar]
	 * 
	 * @author Rafael Santos, Pedro Alexandre
	 * @date 23/12/2005, 21/11/2006
	 * @author eduardo henrique
	 * @date 31/10/2008 Alteração no método para adicionar ao objeto debitoACobra, a coleção de
	 *       DebitoACobrarCategoria.
	 * @author Saulo Lima
	 * @date 29/11/2008 Alteração no método para chamar a Classificação de Pagamento e Devoluções
	 *       [UC0300]
	 * @author eduardo henrique
	 * @date 22/04/2009 Alteração no método para desabilitar a Contabilização por Evento. Alteração
	 *       para atribuir ao Debito a Cobrar gerado o Nr. de
	 *       Prestações passadas por Parametro
	 * @author Isaac Silva
	 * @date 22/08/2011
	 * @param numeroPrestacoes
	 * @param debitoACobrar
	 * @param valorTotalServico
	 * @param imovel
	 * @param percentualAbatimento
	 * @param valorEntrada
	 * @param usuarioLogado
	 * @param efetuarParcelamento
	 *            se true atualiza os atributos: numeroMesesEntreParcelas, numeroParcelasALancar,
	 *            numeroMesesInicioCobranca que serão usados no faturamento;
	 * @param numeroMesesEntreParcelas
	 * @param numeroParcelasALancar
	 * @param numeroMesesInicioCobranca
	 * @return
	 * @throws ControladorException
	 */
	public Integer inserirDebitoACobrar(Integer numeroPrestacoes, DebitoACobrar debitoACobrar, BigDecimal valorTotalServico, Imovel imovel,
					BigDecimal percentualAbatimento, BigDecimal valorEntrada, Usuario usuarioLogado, boolean efetuarParcelamento,
					Integer numeroMesesEntreParcelas, Integer numeroParcelasALancar, Integer numeroMesesInicioCobranca)
					throws ControladorException{

		this.inserirDebitoACobrarSemRegistrarLancamentoContabil(numeroPrestacoes, debitoACobrar, valorTotalServico, imovel,
						percentualAbatimento, valorEntrada, usuarioLogado, efetuarParcelamento, numeroMesesEntreParcelas,
						numeroParcelasALancar, numeroMesesInicioCobranca);

		getControladorContabil().registrarLancamentoContabil(debitoACobrar, OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);

		return debitoACobrar.getId();

	}

	public DebitoACobrar inserirDebitoACobrarSemRegistrarLancamentoContabil(Integer numeroPrestacoes, DebitoACobrar debitoACobrar,
					BigDecimal valorTotalServico, Imovel imovel, BigDecimal percentualAbatimento, BigDecimal valorEntrada,
					Usuario usuarioLogado, boolean efetuarParcelamento, Integer numeroMesesEntreParcelas, Integer numeroParcelasALancar,
					Integer numeroMesesInicioCobranca) throws ControladorException{

		// -----------------------------------------------------------
		// Verificar permissão especial
		boolean temPermissaoDebitoACobrar = getControladorPermissaoEspecial().verificarPermissaoInserirDebitoACobrarSemEntradaSemJuros(
						usuarioLogado);
		// -----------------------------------------------------------

		// validar taxa de juros
		if(!temPermissaoDebitoACobrar){
			if(debitoACobrar.getPercentualTaxaJurosFinanciamento() != null){

				BigDecimal percentualTaxaJurosFinanciamento = this.getControladorUtil().pesquisarParametrosDoSistema()
								.getPercentualTaxaJurosFinanciamento();

				// no caso de numero de prestacões == 1 , permitir juros = 0
				if(numeroPrestacoes.intValue() != 1
								|| (debitoACobrar.getPercentualTaxaJurosFinanciamento().compareTo(new BigDecimal(0)) != 0 && numeroPrestacoes
												.intValue() == 1)){
					if(debitoACobrar.getPercentualTaxaJurosFinanciamento().compareTo(percentualTaxaJurosFinanciamento) == -1){
						// Taxa de Juros mínima permitida é de XX%
						throw new ControladorException("atencao.taxa_juros.nao.permitida", null, (this.getControladorUtil()
										.pesquisarParametrosDoSistema().getPercentualTaxaJurosFinanciamento().toString()).replace(".", ","));
					}
				}
			}
		}

		// [FS0009] - Validar número de prestações
		if(numeroPrestacoes.shortValue() > getControladorUtil().pesquisarParametrosDoSistema().getNumeroMaximoParcelasFinanciamento()
						.shortValue()){
			throw new ControladorException("atencao.valor_prestacoes", null, getControladorUtil().pesquisarParametrosDoSistema()
							.getNumeroMaximoParcelasFinanciamento().toString());
		}

		if(!temPermissaoDebitoACobrar){

			// [FS0010] - Validar valor total do serviço
			FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();

			filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, debitoACobrar.getDebitoTipo().getId()));
			Collection colecaoDebitosTipos = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

			DebitoTipo debitoTipo = (DebitoTipo) colecaoDebitosTipos.iterator().next();

			if(debitoACobrar.getValorDebito().compareTo(debitoTipo.getValorLimite()) == 1){
				throw new ControladorException("atencao.debito_a_cobrar.valor_total_servico", null, debitoTipo.getValorLimite().toString()
								.replace(".", ","));
			}

		}

		if(percentualAbatimento != null && !(percentualAbatimento.compareTo(new BigDecimal("0.00")) == 0)){
			// [FS0011] - Validar percentual de abatimento
			if((imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPRIMIDO)
							| (imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPR_PARC)
							| (imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPR_PARC_PEDIDO)){

				// [UC0108] - Obter Quantidade de Economias por Categoria
				Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

				Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();

				while(colecaoCategoriasIterator.hasNext()){
					Categoria categoria = (Categoria) colecaoCategoriasIterator.next();
					if(categoria.getId().compareTo(Categoria.RESIDENCIAL) != 0){
						throw new ControladorException("atencao.imovel.nao_suprimido.categoria.nao_residencial");
					}
				}
			}else{
				throw new ControladorException("atencao.imovel.nao_suprimido.categoria.nao_residencial");
			}

			// [FS0011] - Validar percentual de abatimento
			if(percentualAbatimento.compareTo(getControladorUtil().pesquisarParametrosDoSistema().getPercentualMaximoAbatimento()) == 1){
				throw new ControladorException("atencao.imovel.percentual_abatimento", null, getControladorUtil()
								.pesquisarParametrosDoSistema().getPercentualMaximoAbatimento().toString().replace(".", ","));
			}
		}

		// [FS0012] - Verificar preenchimento dos campos
		if(valorEntrada != null && valorEntrada.compareTo(valorTotalServico) == 1){
			throw new ControladorException("atencao.debito_a_cobrar.valor_entrada.valor_total_servico");
		}

		if(!temPermissaoDebitoACobrar){
			// [FS0012] - Verificar preenchimento dos campos
			if(valorEntrada != null && numeroPrestacoes.intValue() > 1){

				BigDecimal parte1 = getControladorUtil().pesquisarParametrosDoSistema().getPercentualFinanciamentoEntradaMinima()
								.divide(new BigDecimal(100));

				if((valorEntrada.compareTo(valorTotalServico.multiply(parte1)) == -1)){
					throw new ControladorException("atencao.debito_a_cobrar.valor_entrada", null, getControladorUtil()
									.pesquisarParametrosDoSistema().getPercentualFinanciamentoEntradaMinima().toString().replace(".", ",")
									+ "");
				}

			}
		}

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		// Alterado por: Saulo Lima 30/07/2008
		// Analista responsavel: Luciene Bezerra
		// debitoACobrar.setAnoMesCobrancaDebito(sistemaParametro
		// .getAnoMesArrecadacao());
		Integer anoMesGrupoFaturamento = null;
		if(imovel.getRota() != null){

			Rota rota = null;
			FiltroRota filtroRota = new FiltroRota();
			filtroRota.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, imovel.getRota().getId()));
			Collection colecaoRota = getControladorUtil().pesquisar(filtroRota, Rota.class.getName());

			if(colecaoRota != null && !colecaoRota.isEmpty()){

				rota = (Rota) colecaoRota.iterator().next();
			}

			if(rota != null){
				FaturamentoGrupo faturamentoGrupo = null;
				FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
				filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, rota.getFaturamentoGrupo()
								.getId()));
				Collection colecaoFaturamentoGrupo = getControladorUtil().pesquisar(filtroFaturamentoGrupo,
								FaturamentoGrupo.class.getName());
				if(colecaoFaturamentoGrupo != null && !colecaoFaturamentoGrupo.isEmpty()){
					faturamentoGrupo = (FaturamentoGrupo) colecaoFaturamentoGrupo.iterator().next();
				}

				if(faturamentoGrupo != null){
					anoMesGrupoFaturamento = faturamentoGrupo.getAnoMesReferencia();
				}
			}
		}
		// if(debitoACobrar.getAnoMesCobrancaDebito() != null){
		// if(anoMesGrupoFaturamento != null && anoMesGrupoFaturamento >
		// debitoACobrar.getAnoMesCobrancaDebito()){
		// throw new ControladorException("atencao.cobranca.mes_ano_cobranca_debito", null, Util
		// .formatarMesAnoReferencia(anoMesGrupoFaturamento));
		// }
		// }else{
		// debitoACobrar.setAnoMesCobrancaDebito(sistemaParametro.getAnoMesArrecadacao());
		// }

		// ******* Campanha Parcelamento date 22/08/2011 ******************
		if(efetuarParcelamento){
			Integer numeroMesesInicioCobrancaParcela = null;

			if(numeroMesesInicioCobranca == null){
				numeroMesesInicioCobrancaParcela = 1;
			}else{
				numeroMesesInicioCobrancaParcela = numeroMesesInicioCobranca;
			}

			Integer anoMesCobrancaDebito = Util.somaMesAnoMesReferencia(sistemaParametro.getAnoMesFaturamento(),
							numeroMesesInicioCobrancaParcela);

			debitoACobrar.setAnoMesCobrancaDebito(anoMesCobrancaDebito);

			debitoACobrar.setNumeroMesesEntreParcelas(numeroMesesEntreParcelas);
			debitoACobrar.setNumeroParcelasALancar(numeroParcelasALancar);
			debitoACobrar.setAnoMesReferenciaUltimaCobranca(null);
		}else{
			if(debitoACobrar.getAnoMesCobrancaDebito() != null){
				if(anoMesGrupoFaturamento != null && anoMesGrupoFaturamento > debitoACobrar.getAnoMesCobrancaDebito()){
					throw new ControladorException("atencao.cobranca.mes_ano_cobranca_debito", null,
									Util.formatarMesAnoReferencia(anoMesGrupoFaturamento));
				}
			}else{
				debitoACobrar.setAnoMesCobrancaDebito(sistemaParametro.getAnoMesArrecadacao());
			}
		}
		// *********** date 22/08/2011 ******************

		// Collection<ObjetoTransacao> colecaoDebitoACobrarContabilizar = new
		// ArrayList<ObjetoTransacao>();

		// alterado por: Vivianne Sousa 17/10/2007
		// analista responsavel: Aryed
		// debitoACobrar.setAnoMesReferenciaDebito(sistemaParametro
		// .getAnoMesFaturamento());
		debitoACobrar.setAnoMesReferenciaDebito(debitoACobrar.getAnoMesReferenciaDebito());

		debitoACobrar.setAnoMesReferenciaContabil(sistemaParametro.getAnoMesFaturamento());
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
		debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
		debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
		debitoACobrar.setParcelamentoGrupo(null);
		debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacoes.shortValue());
		// debitoACobrar.getCobrancaForma().setId(CobrancaForma. );

		// Inseri a DebitoACobrarGeral na tabela debito_a_cobrar_geral
		DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();

		// valor fixo
		Short indicadorHistorico = 2;

		debitoACobrarGeral.setIndicadorHistorico(indicadorHistorico);

		// Ultima Alteração
		debitoACobrarGeral.setUltimaAlteracao(new Date());


		Integer idDebitoGerado = null;

		/**
		 * alterado por pedro alexandre dia 21/11/2006 alteração feita para acoplar o controle de
		 * abrangência de usuário
		 */
		// ------------ CONTROLE DE ABRANGENCIA ----------------
		Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

		if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.acesso.negado.abrangencia");
		}else{
			idDebitoGerado = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
		}
		// ------------ FIM CONTROLE DE ABRANGENCIA ----------------

		debitoACobrarGeral.setId(idDebitoGerado);

		debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);

		debitoACobrar.setId(idDebitoGerado);

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_DEBITO_A_COBRAR_INSERIR, imovel.getId(),
						debitoACobrar.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		registradorOperacao.registrarOperacao(debitoACobrar);
		// registradorOperacao.registrarOperacao(debitoACobrarGeral);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// [SB0001] - Verificar Marcação do Débito A Cobrar para Remuneração da Cobrança
		// Administrativa
		debitoACobrar.setIndicadorRemuneraCobrancaAdministrativa(this.verificarMarcacaoRemuneracaoCobAdminstrativa(debitoACobrar
						.getImovel().getId(), debitoACobrar.getDebitoTipo().getId()));

		getControladorUtil().inserir(debitoACobrar);

		inserirDebitoACobrarCategoria(debitoACobrar, imovel);

		// INSERIR_CLIENTE_DEBITO_A_COBRAR
		this.getControladorCobranca().inserirClienteDebitoACobrar(debitoACobrar);

		// 6.6. Caso exista pagamento para o DebitoACobrar, classificar o pagamento do Debito
		// [UC0300 – ClassificarPagamentosDevolucoes]
		if(debitoACobrar != null){
			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.DEBITO_A_COBRAR_ID, debitoACobrar.getId()));

			Collection<Pagamento> colecaoPagamentos = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

			if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){
				// ** Alteração do Classificar **
				// getControladorArrecadacao().classificarPagamentos(colecaoPagamentos.iterator().next());
				getControladorArrecadacao().classificarPagamentosRegistroMovimentoArrecadadores(colecaoPagamentos.iterator().next());
				// ** Alteração do Classificar **
			}

		}


		// colecaoDebitoACobrarContabilizar.add(debitoACobrar);
		// Contabiliza o Débito a Cobrar Incluído
		// getControladorFinanceiro().contabilizarEventoFaturamento(colecaoDebitoACobrarContabilizar,
		// EventoContabil.INCLUSAO_DEBITO_A_COBRAR);

		return debitoACobrar;

	}



	/**
	 * [UC0186 - Calcular Prestação] Author: Rafael Santos Data: 23/12/2005
	 * 
	 * @param taxaJurosFinanciamento
	 *            Taxa de Juros do Financiamento
	 * @param numeroPrestacoes
	 *            Numero de Prestacoes
	 * @param valorTotalServico
	 *            Valor Total de Servico
	 * @param valorEntrada
	 *            Valor de Entrada
	 * @return O valor da Prestacao
	 */
	public ArrayList calcularValorPrestacao(BigDecimal taxaJurosFinanciamento, Integer numeroPrestacoes, BigDecimal valorTotalServico,
					BigDecimal valorEntrada, BigDecimal percentualAbatimento, String idTipoDebito, BigDecimal valorTotalServicoAParcelar,
					Imovel imovel, Usuario usuario) throws ControladorException{

		ArrayList valores = new ArrayList();

		// -----------------------------------------------------------
		// Verificar permissão especial
		boolean temPermissaoDebitoACobrar = getControladorPermissaoEspecial().verificarPermissaoInserirDebitoACobrarSemEntradaSemJuros(
						usuario);
		// -----------------------------------------------------------

		if(percentualAbatimento != null && !(percentualAbatimento.compareTo(new BigDecimal("0.00")) == 0)){
			// [FS0011] - Validar percentual de abatimento
			if((imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPRIMIDO)
							| (imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPR_PARC)
							| (imovel.getLigacaoAguaSituacao().getId().intValue() == LigacaoAguaSituacao.SUPR_PARC_PEDIDO)){

				// [UC0108] - Obter Quantidade de Economias por Categoria
				Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

				Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();

				while(colecaoCategoriasIterator.hasNext()){
					Categoria categoria = (Categoria) colecaoCategoriasIterator.next();
					if(categoria.getId().compareTo(Categoria.RESIDENCIAL) != 0){
						throw new ControladorException("atencao.imovel.nao_suprimido.categoria.nao_residencial");
					}
				}
			}else{
				throw new ControladorException("atencao.imovel.nao_suprimido.categoria.nao_residencial");
			}

			// [FS0011] - Validar percentual de abatimento
			if(percentualAbatimento.compareTo(getControladorUtil().pesquisarParametrosDoSistema().getPercentualMaximoAbatimento()) == 1){
				throw new ControladorException("atencao.imovel.percentual_abatimento", null, getControladorUtil()
								.pesquisarParametrosDoSistema().getPercentualMaximoAbatimento().toString().replace(".", ","));
			}
		}

		// validar taxa de juros
		if(!temPermissaoDebitoACobrar){
			if(taxaJurosFinanciamento != null){
				BigDecimal percentualTaxaJurosFinanciamento = this.getControladorUtil().pesquisarParametrosDoSistema()
								.getPercentualTaxaJurosFinanciamento();

				// permitir juros = 0
				if(taxaJurosFinanciamento.compareTo(new BigDecimal(0)) != 0){
					if(taxaJurosFinanciamento.compareTo(percentualTaxaJurosFinanciamento) == -1){
						// Taxa de Juros mínima permitida é de 3 casas%
						throw new ControladorException("atencao.taxa_juros.nao.permitida", null, (this.getControladorUtil()
										.pesquisarParametrosDoSistema().getPercentualTaxaJurosFinanciamento().toString()).replace(".", ","));
					}
				}
			}
		}

		if(!temPermissaoDebitoACobrar){
			if(valorEntrada != null && numeroPrestacoes.intValue() > 1){
				BigDecimal parte1 = getControladorUtil().pesquisarParametrosDoSistema().getPercentualFinanciamentoEntradaMinima()
								.divide(new BigDecimal(100));

				if((valorEntrada.compareTo(valorTotalServico.multiply(parte1)) == -1)){
					throw new ControladorException("atencao.debito_a_cobrar.valor_entrada", null, (getControladorUtil()
									.pesquisarParametrosDoSistema().getPercentualFinanciamentoEntradaMinima().toString()).replace(".", ",")
									+ "");
				}

			}
		}
		BigDecimal novoValorTotalServico = valorTotalServico;

		if(percentualAbatimento != null && !percentualAbatimento.equals("")){
			BigDecimal parte1 = Util.dividirArredondando(percentualAbatimento, new BigDecimal(100));
			BigDecimal parte2 = parte1.multiply(valorTotalServico);
			novoValorTotalServico = valorTotalServico.subtract(parte2);
		}

		valores.add(valorTotalServico.setScale(2, BigDecimal.ROUND_HALF_UP));

		valorTotalServico = novoValorTotalServico;

		BigDecimal valorPrestacao = this.calcularPrestacao(taxaJurosFinanciamento, numeroPrestacoes, valorTotalServico, valorEntrada);
		valores.add(valorPrestacao.setScale(2, BigDecimal.ROUND_HALF_UP));

		BigDecimal parte3 = valorTotalServico.subtract(valorEntrada);
		BigDecimal valorPrestacaoNormal = null;
		if(numeroPrestacoes > 0){
			valorPrestacaoNormal = Util.dividirArredondando(parte3, new BigDecimal(numeroPrestacoes));
		}else{
			valorPrestacaoNormal = parte3;
		}

		BigDecimal parte4 = valorPrestacao.subtract(valorPrestacaoNormal);

		BigDecimal parte5 = parte4.multiply(new BigDecimal(numeroPrestacoes));

		BigDecimal valorJuros = parte5;
		valores.add(valorJuros.setScale(2, BigDecimal.ROUND_HALF_UP));

		BigDecimal parte6 = valorTotalServico.subtract(valorEntrada);

		BigDecimal parte7 = parte6.add(valorJuros.setScale(2, BigDecimal.ROUND_HALF_UP));

		BigDecimal valorAParcelar = parte7;

		valores.add(valorAParcelar.setScale(2, BigDecimal.ROUND_HALF_UP));

		if(!temPermissaoDebitoACobrar){

			// [FS0010] - Validar valor total do serviço
			FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();

			filtroDebitoTipo.adicionarParametro(new ParametroSimples(

			FiltroDebitoTipo.ID, idTipoDebito));
			Collection colecaoDebitosTipos = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

			DebitoTipo debitoTipo = (DebitoTipo) colecaoDebitosTipos.iterator().next();

			if(valorAParcelar.compareTo(debitoTipo.getValorLimite()) == 1){
				throw new ControladorException("atencao.debito_a_cobrar.valor_total_servico", null, debitoTipo.getValorLimite().toString()
								.replace(".", ","));
			}

		}

		return valores;
	}

	/**
	 * [UC0186 - Calcular Prestação] Author: Rafael Santos Data: 03/04/2006
	 * 
	 * @param taxaJurosFinanciamento
	 *            Taxa de Juros do Financiamento
	 * @param numeroPrestacoes
	 *            Numero de Prestacoes
	 * @param valorTotalServico
	 *            Valor Total de Servico
	 * @param valorEntrada
	 *            Valor de Entrada
	 * @return O valor da Prestacao
	 */
	public BigDecimal calcularPrestacao(BigDecimal taxaJurosFinanciamento, Integer numeroPrestacoes, BigDecimal valorTotalServico,
					BigDecimal valorEntrada) throws ControladorException{

		BigDecimal fatorCorrecao = null;
		BigDecimal valorPrestacao = null;

		if(taxaJurosFinanciamento.compareTo(new BigDecimal("0.00")) == 1){
			BigDecimal parte1 = Util.dividirArredondando(taxaJurosFinanciamento, new BigDecimal(100));

			BigDecimal parte2 = parte1.add(new BigDecimal(1));

			BigDecimal parte3 = parte2.pow(numeroPrestacoes);

			BigDecimal parte4 = Util.dividirArredondando(new BigDecimal(1), parte3);

			BigDecimal parte5 = new BigDecimal(1).subtract(parte4);

			BigDecimal parte6 = Util.dividirArredondando(taxaJurosFinanciamento, new BigDecimal(100));

			fatorCorrecao = Util.dividirArredondando(parte5, parte6);

			BigDecimal parte7 = valorTotalServico.subtract(valorEntrada);

			valorPrestacao = Util.dividirArredondando(parte7, fatorCorrecao);

		}else{

			BigDecimal parte7 = valorTotalServico.subtract(valorEntrada);

			valorPrestacao = Util.dividirArredondando(parte7, new BigDecimal(numeroPrestacoes));
		}

		return valorPrestacao;
	}

	/**
	 * [UC0183 - Inserir Débito A Cobrar] Author: Rafael Santos Data: 29/12/2005 Inserir Debito A
	 * Cobrar por Categoria
	 * 
	 * @author eduardo henrique
	 * @date 31/10/2008 Alteração no método para adicionar ao objeto debitoACobrar, a coleção de
	 *       debitoACobrarCategoria .
	 * @param debitoACobrar
	 *            Debito A Cobrar
	 */
	public void inserirDebitoACobrarCategoria(DebitoACobrar debitoACobrar, Imovel imovel) throws ControladorException{

		debitoACobrar.setDebitoACobrarCategorias(new HashSet<DebitoACobrarCategoria>());

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		Collection colecaoValoresPorCategoria = getControladorImovel().obterValorPorCategoria(colecaoCategorias,
						debitoACobrar.getValorDebito());
		Iterator icolecaoCategorias = colecaoCategorias.iterator();
		Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria.iterator();

		while(icolecaoValoresPorCategoria.hasNext() && icolecaoCategorias.hasNext()){

			DebitoACobrarCategoria debitoACobrarCategoria = new DebitoACobrarCategoria();
			Categoria categoria = (Categoria) icolecaoCategorias.next();
			BigDecimal valorPorCategoria = (BigDecimal) icolecaoValoresPorCategoria.next();

			debitoACobrarCategoria.setComp_id(new DebitoACobrarCategoriaPK(debitoACobrar, categoria));
			debitoACobrarCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
			debitoACobrarCategoria.setUltimaAlteracao(new Date());
			debitoACobrarCategoria.setValorCategoria(valorPorCategoria);
			getControladorUtil().inserir(debitoACobrarCategoria);

			debitoACobrar.getDebitoACobrarCategorias().add(debitoACobrarCategoria);
		}

	}

	/**
	 * [UC0183 - Inserir Débito A Cobrar] Author: Rafael Corrêa e Leonardo Vieira Data: 29/12/2005
	 * Inserir Debito A Cobrar por Categoria
	 * 
	 * @param debitoACobrar
	 *            Debito A Cobrar
	 */
	public Collection inserirDebitoACobrarCategoriaBatch(DebitoACobrar debitoACobrar, Imovel imovel) throws ControladorException{

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		Collection colecaoValoresPorCategoria = getControladorImovel().obterValorPorCategoria(colecaoCategorias,
						debitoACobrar.getValorDebito());
		Iterator icolecaoCategorias = colecaoCategorias.iterator();
		Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria.iterator();

		Collection colecaoDebitosACobrarCategorias = new ArrayList();

		while(icolecaoValoresPorCategoria.hasNext() && icolecaoCategorias.hasNext()){

			DebitoACobrarCategoria debitoACobrarCategoria = new DebitoACobrarCategoria();
			Categoria categoria = (Categoria) icolecaoCategorias.next();
			BigDecimal valorPorCategoria = (BigDecimal) icolecaoValoresPorCategoria.next();

			debitoACobrarCategoria.setComp_id(new DebitoACobrarCategoriaPK(debitoACobrar, categoria));
			debitoACobrarCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
			debitoACobrarCategoria.setUltimaAlteracao(new Date());
			debitoACobrarCategoria.setValorCategoria(valorPorCategoria);

			colecaoDebitosACobrarCategorias.add(debitoACobrarCategoria);
			// getControladorUtil().inserir(debitoACobrarCategoria);
		}

		return colecaoDebitosACobrarCategorias;

	}

	/**
	 * Calcula os valores da conta de acordo com os parâmetros passados
	 * [UC0145] - Inserir Conta [SF0001] - Determinar Valores para Faturamento
	 * de Água e/ou Esgoto
	 * 
	 * @author eduardo henrique
	 * @date 03/02/2009
	 *       Reescrita do método para mudança na obtenção do período da tarifa,
	 *       pois ADA realiza o faturamento 'antecipado'. Como não existem cronogramas de todos os
	 *       períoodos
	 *       anteriores, é necessário 'diminuir' 1 mes na refererência, caso não existam
	 *       cronogramas.
	 * @author eduardo henrique
	 * @date 11/02/2009
	 *       Alteração da verificação de Esgoto para o cálculo em Inclusão ou Retificação de Conta.
	 * @author eduardo henrique
	 * @date 04/03/2009
	 *       Correção na verificação de situação de agua e consumo para calculo da Agua.
	 * @author Virgínia Melo
	 * @date 19/03/2009
	 *       Alteração para passar a usar o método obterConsumoMinimoLigacaoPeriodo
	 *       que obtém o consumo mínimo de acordo com o período informado.
	 * @author Ailton Sousa
	 * @date 22/07/2011
	 *       Alteração da chamada do método para receber as duas datas:
	 *       dataLeituraAnteriorFaturada e dataLeituraAtualFaturada.
	 * @param mesAnoConta
	 * @param imovelID
	 * @param situacaoAguaConta
	 * @param situacaoEsgotoConta
	 * @param colecaoCategoria
	 * @param consumoAgua
	 * @param consumoEsgoto
	 * @param percentualEsgoto
	 * @return Collection<CalcularValoresAguaEsgotoHelper>
	 * @throws ControladorException
	 */
	public Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta(String mesAnoConta, String imovelID, Integer situacaoAguaConta,
					Integer situacaoEsgotoConta, Collection colecaoCategoria, String consumoAgua, String consumoEsgoto,
					String percentualEsgoto, Integer idConsumoTarifaConta, Usuario usuarioLogado, Date dataLeituraAnteriorFaturada,
					Date dataLeituraAtualFaturada) throws ControladorException{

		Collection<CalcularValoresAguaEsgotoHelper> valoresCalculadosAguaEsgoto = new ArrayList();

		// [FS0002] - Validar ano e mês de referência
		if(!Util.validarMesAno(mesAnoConta)){
			throw new ControladorException("atencao.adicionar_debito_ano_mes_referencia_invalido");
		}

		// Quando o ano for menor que 1985 (ANO_LIMITE) exibir a mensagem,
		// "Ano de referência não deve ser menor que 1985".
		if(Integer.valueOf(mesAnoConta.substring(3, 7)).intValue() < ConstantesSistema.ANO_LIMITE.intValue()){
			throw new ControladorException("atencao.ano_mes_referencia_menor", null,
							String.valueOf(ConstantesSistema.ANO_LIMITE.intValue()));
		}

		// Invertendo o formato para yyyyMM (sem a barra)
		mesAnoConta = Util.formatarMesAnoParaAnoMesSemBarra(mesAnoConta);

		// [FS0004] - Verifica ano e mês do faturamento
		FiltroImovel filtroImovel = new FiltroImovel();

		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("rota.faturamentoGrupo");
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("consumoTarifa");

		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovelID));

		Collection colecaoImovel = this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());

		if(colecaoImovel == null || colecaoImovel.isEmpty()){
			throw new ControladorException("atencao.adicionar_debito_ano_mes_debito_invalido");
		}

		Imovel objImovel = (Imovel) Util.retonarObjetoDeColecao(colecaoImovel);
		Integer mesAnoFaturamentoImovel = objImovel.getRota().getFaturamentoGrupo().getAnoMesReferencia();

		/*
		 * Colocado por Raphael Rossiter em 02/04/2007
		 * [UC0157] - Simular Cálculo da Conta [FS0003] - Verificar ConsumoMínimo
		 */
		Integer consumoAguaInteger = null;
		if(consumoAgua != null && !consumoAgua.equalsIgnoreCase("")){
			consumoAguaInteger = Integer.valueOf(consumoAgua);
		}

		this.verificarConsumoFaturadoAgua(situacaoAguaConta, consumoAguaInteger);

		/*
		 * Colocado por Raphael Rossiter em 02/04/2007
		 * [UC0157] - Simular Cálculo da Conta [FS0004] - Verificar Volume Mínimo
		 */
		Integer consumoEsgotoInteger = null;
		if(consumoEsgoto != null && !consumoEsgoto.equalsIgnoreCase("")){
			consumoEsgotoInteger = Integer.valueOf(consumoEsgoto);
		}else{
			consumoEsgotoInteger = consumoAguaInteger;
		}

		this.verificarConsumoFaturadoEsgoto(situacaoEsgotoConta, consumoEsgotoInteger);

		// [SF0001] – Determinar Valores para Faturamento de Água e/ou Esgoto.
		if(colecaoCategoria != null && !colecaoCategoria.isEmpty()){

			// Indicador de faturamento de água com o valor igual a dois (2)
			Short indicadorFaturamentoAgua = Short.valueOf("2");

			// Indicador de faturamento de esgoto com o valor igual a um (2)
			Short indicadorFaturamentoEsgoto = Short.valueOf("2");

			// Consumo de água informado pelo usuário
			Integer objConsumoAgua = Integer.valueOf("0");

			FiltroLigacaoAguaSituacao filtroLigacaoAguaSituacao = new FiltroLigacaoAguaSituacao();
			filtroLigacaoAguaSituacao.adicionarParametro(new ParametroSimples(FiltroLigacaoAguaSituacao.ID, situacaoAguaConta));

			Collection<LigacaoAguaSituacao> colecaoLigacaoAguaSituacao = getControladorUtil().pesquisar(filtroLigacaoAguaSituacao,
							LigacaoAguaSituacao.class.getName());

			LigacaoAguaSituacao ligacaoAguaSituacao = null;
			if(colecaoLigacaoAguaSituacao != null && !colecaoLigacaoAguaSituacao.isEmpty()){
				ligacaoAguaSituacao = (LigacaoAguaSituacao) Util.retonarObjetoDeColecao(colecaoLigacaoAguaSituacao);
			}

			if(ligacaoAguaSituacao != null){
				if(ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.FATURAMENTO_ATIVO.intValue()
								&& (consumoAgua == null || consumoAgua.equalsIgnoreCase(""))){

					throw new ControladorException("atencao.campo_texto.obrigatorio", null, "Consumo de Água");

				}
				if((ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.FATURAMENTO_ATIVO.intValue())
								|| (ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.NAO_FATURAVEL
												.intValue() && consumoAguaInteger != null && !consumoAguaInteger.equals(Integer.valueOf(0)))){

					objConsumoAgua = consumoAguaInteger;
					indicadorFaturamentoAgua = Short.valueOf("1");

				}

			}else{
				throw new ControladorException("atencao.pesquisa_inexistente", null, "Situação da Ligação de Água");
			}

			// realiza a verificação da Situação Esgoto
			FiltroLigacaoEsgotoSituacao filtroLigacaoEsgotoSituacao = new FiltroLigacaoEsgotoSituacao();
			filtroLigacaoEsgotoSituacao.adicionarParametro(new ParametroSimples(FiltroLigacaoEsgotoSituacao.ID, situacaoEsgotoConta));

			Collection<LigacaoEsgotoSituacao> colecaoLigacaoEsgotoSituacao = getControladorUtil().pesquisar(filtroLigacaoEsgotoSituacao,
							LigacaoEsgotoSituacao.class.getName());

			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = null;
			if(colecaoLigacaoEsgotoSituacao != null && !colecaoLigacaoEsgotoSituacao.isEmpty()){
				ligacaoEsgotoSituacao = (LigacaoEsgotoSituacao) Util.retonarObjetoDeColecao(colecaoLigacaoEsgotoSituacao);
			}
			if(ligacaoEsgotoSituacao != null){
				if(ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao().intValue() == LigacaoEsgotoSituacao.FATURAMENTO_ATIVO.intValue()){
					indicadorFaturamentoEsgoto = Short.valueOf("1");
				}
			}else{
				throw new ControladorException("atencao.pesquisa_inexistente", null, "Situação de Ligação de Esgoto");
			}

			// Consumo de esgoto informado pelo usuário
			// Integer objConsumoEsgoto = Integer.valueOf("0");
			//
			// if(situacaoEsgotoConta.equals(LigacaoEsgotoSituacao.LIGADO) && (consumoEsgoto == null
			// || consumoEsgoto.equalsIgnoreCase(""))){
			//
			// throw new ControladorException("atencao.campo_texto.obrigatorio", null,
			// "Consumo de Esgoto");
			//
			// }else if(consumoEsgoto != null && !consumoEsgoto.equalsIgnoreCase("")){
			//
			// objConsumoEsgoto = Integer.valueOf(consumoEsgoto);
			// }

			// [UC0105] – Obter Consumo Mínimo da Ligação por Subcategoria
			// int consumoMinimoLigacao =
			// this.getControladorMicromedicao().obterConsumoMinimoLigacao(objImovel,
			// colecaoCategoria);
			int consumoMinimoLigacao = this.getControladorMicromedicao().obterConsumoMinimoLigacaoPeriodo(objImovel, colecaoCategoria,
							mesAnoConta, idConsumoTarifaConta);

			/*
			 * Colocado por Raphael Rossiter em 08/05/2007 Verificar permissão especial -
			 * FATURAMENTO ANTECIPADO
			 */
			boolean temPermissaoFaturamentoAntecipado = this.getControladorPermissaoEspecial()
							.verificarPermissaoInserirContaFaturamentoAntecipado(usuarioLogado);

			Date dataLeituraAtual = null;
			Date dataLeituraAnterior = null;
			int referenciaConta = Integer.parseInt(mesAnoConta);

			if(ConstantesSistema.SIM.toString().equals(ParametroFaturamento.P_TRATA_REFERENCIA_ADIANTADA.executar())){
				// diminui em 1 mes a referencia pelo fat. antecipado de ADA
				referenciaConta = Util.subtrairMesDoAnoMes(referenciaConta, 1);
			}

			/*
			 * Caso o usuário tenha permissão especial (FATURAMENTO ANTECIPADO)
			 * e o anoMes informado seja maior que o anoMes do faturamento do imóvel.
			 */
			if(temPermissaoFaturamentoAntecipado
							&& Util.compararAnoMesReferencia(Integer.valueOf(mesAnoConta), mesAnoFaturamentoImovel, ">")){

				int mesConta = Util.obterMes(referenciaConta);
				int anoConta = Util.obterAno(referenciaConta);
				int ultimoDiaMes = Integer.valueOf(Util.obterUltimoDiaMes(mesConta, anoConta));

				dataLeituraAtual = Util.criarData(ultimoDiaMes, mesConta, anoConta);
				dataLeituraAnterior = Util.criarData(1, mesConta, anoConta);

			}else{

				if(Util.compararAnoMesReferencia(Integer.valueOf(mesAnoConta), mesAnoFaturamentoImovel, ">")){
					throw new ControladorException("atencao.adicionar_debito_ano_mes_debito_invalido");
				}

				// Caso exista cronograma para o anoMes informado

				// Data de leitura anterior
				if(dataLeituraAnteriorFaturada != null){
					dataLeituraAnterior = dataLeituraAnteriorFaturada;
				}else{
					dataLeituraAnterior = this.buscarDataLeituraCronograma(objImovel, true, Integer.valueOf(mesAnoConta));
				}

				// Data de leitura atual
				if(dataLeituraAtualFaturada != null){
					dataLeituraAtual = dataLeituraAtualFaturada;
				}else{
					dataLeituraAtual = this.buscarDataLeituraCronograma(objImovel, false, Integer.valueOf(mesAnoConta));
				}

				// Caso NÃO exista cronograma para o anoMes informado
				if(dataLeituraAnterior == null || dataLeituraAtual == null){

					int mesConta = Util.obterMes(referenciaConta);
					int anoConta = Util.obterAno(referenciaConta);
					int ultimoDiaMes = Integer.valueOf(Util.obterUltimoDiaMes(mesConta, anoConta));

					dataLeituraAtual = Util.criarData(ultimoDiaMes, mesConta, anoConta);
					dataLeituraAnterior = Util.criarData(1, mesConta, anoConta);
				}
			}

			// Percentual de esgoto
			BigDecimal objPercentualEsgoto = new BigDecimal("0");
			if(situacaoEsgotoConta.equals(LigacaoEsgotoSituacao.LIGADO)
							&& (percentualEsgoto == null || percentualEsgoto.equalsIgnoreCase(""))){

				throw new ControladorException("atencao.campo_texto.obrigatorio", null, "Percentual de Esgoto");

			}else if(percentualEsgoto != null && !percentualEsgoto.equalsIgnoreCase("")){

				objPercentualEsgoto = Util.formatarMoedaRealparaBigDecimal(percentualEsgoto);
			}

			if(idConsumoTarifaConta != null){

				valoresCalculadosAguaEsgoto = this.calcularValoresAguaEsgoto(Integer.valueOf(mesAnoConta), situacaoAguaConta,
								situacaoEsgotoConta, indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategoria,
								objConsumoAgua, consumoEsgotoInteger, consumoMinimoLigacao, dataLeituraAnterior, dataLeituraAtual,
								objPercentualEsgoto, idConsumoTarifaConta, objImovel.getId(), null);
			}else{

				valoresCalculadosAguaEsgoto = this.calcularValoresAguaEsgoto(Integer.valueOf(mesAnoConta), situacaoAguaConta,
								situacaoEsgotoConta, indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategoria,
								objConsumoAgua, consumoEsgotoInteger, consumoMinimoLigacao, dataLeituraAnterior, dataLeituraAtual,
								objPercentualEsgoto, objImovel.getConsumoTarifa().getId(), objImovel.getId(), null);
			}
		}
		return valoresCalculadosAguaEsgoto;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 10/01/2006 Cálcula o valor total dos
	 * débitos de uma conta de acordo com o informado
	 * pelo usuário
	 * 
	 * @param colecaoDebitoCobrado
	 * @param requestMap
	 * @return BigDecimal valorTotalDebitoConta
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorTotalDebitoConta(Collection<DebitoCobrado> colecaoDebitoCobrado, Map<String, String[]> requestMap)
					throws ControladorException{

		BigDecimal valorTotalDebitoConta = new BigDecimal("0");

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if(colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()){

			// Atualizando os valores dos débitos de acordo com os dados
			// informados pelo usuário
			DebitoCobrado debitoCobradoColecao;
			Iterator colecaoDebitoCobradoIt = colecaoDebitoCobrado.iterator();
			String valorDebitoColecao;

			while(colecaoDebitoCobradoIt.hasNext()){
				debitoCobradoColecao = (DebitoCobrado) colecaoDebitoCobradoIt.next();

				if(requestMap.get("debitoCobrado" + GcomAction.obterTimestampIdObjeto(debitoCobradoColecao)) != null){

					valorDebitoColecao = (requestMap.get("debitoCobrado" + GcomAction.obterTimestampIdObjeto(debitoCobradoColecao)))[0];

					if(valorDebitoColecao == null || valorDebitoColecao.equalsIgnoreCase("")){
						throw new ControladorException("atencao.campo_texto.obrigatorio", null, "Valor do Débito");
					}

					debitoCobradoColecao.setValorPrestacao(Util.formatarMoedaRealparaBigDecimal(valorDebitoColecao));
				}

				valorTotalDebitoConta = valorTotalDebitoConta.add(debitoCobradoColecao.getValorPrestacao());
			}
		}

		return valorTotalDebitoConta;

	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 10/01/2006 Cálcula o valor total
	 * dos créditos de uma conta de acordo com o informado
	 * pelo usuário
	 * 
	 * @param colecaoCreditoRealizado
	 * @param requestMap
	 * @return BigDecimal valorTotalCreditoConta
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorTotalCreditoConta(Collection<CreditoRealizado> colecaoCreditoRealizado, Map<String, String[]> requestMap)
					throws ControladorException{

		BigDecimal valorTotalCreditoConta = new BigDecimal("0.00");

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if(colecaoCreditoRealizado != null && !colecaoCreditoRealizado.isEmpty()){

			// Atualizando os valores dos créditos de acordo com os dados
			// informados pelo usuário
			CreditoRealizado creditoRealizadoColecao;
			Iterator colecaoCreditoRealizadoIt = colecaoCreditoRealizado.iterator();
			String valorCreditoColecao;

			while(colecaoCreditoRealizadoIt.hasNext()){
				creditoRealizadoColecao = (CreditoRealizado) colecaoCreditoRealizadoIt.next();

				if(requestMap.get("creditoRealizado" + GcomAction.obterTimestampIdObjeto(creditoRealizadoColecao)) != null){

					valorCreditoColecao = (requestMap.get("creditoRealizado" + GcomAction.obterTimestampIdObjeto(creditoRealizadoColecao)))[0];

					if(valorCreditoColecao == null || valorCreditoColecao.equalsIgnoreCase("")){
						throw new ControladorException("atencao.campo_texto.obrigatorio", null, "Valor do Crédito");
					}

					creditoRealizadoColecao.setValorCredito(Util.formatarMoedaRealparaBigDecimal(valorCreditoColecao));
				}

				valorTotalCreditoConta = valorTotalCreditoConta.add(creditoRealizadoColecao.getValorCredito());
			}
		}

		return valorTotalCreditoConta;

	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 10/01/2006 Cálcula o valor total
	 * dos créditos de uma conta de acordo com o informado
	 * pelo usuário
	 * 
	 * @param colecaoCreditoRealizado
	 * @param requestMap
	 * @return BigDecimal valorTotalCreditoConta
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorTotalCreditoConta(Collection<CreditoRealizado> colecaoCreditoRealizado) throws ControladorException{

		BigDecimal valorTotalCreditoConta = new BigDecimal("0.00");

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if(colecaoCreditoRealizado != null && !colecaoCreditoRealizado.isEmpty()){

			// Atualizando os valores dos créditos de acordo com os dados
			// informados pelo usuário
			CreditoRealizado creditoRealizadoColecao;
			Iterator colecaoCreditoRealizadoIt = colecaoCreditoRealizado.iterator();

			while(colecaoCreditoRealizadoIt.hasNext()){
				creditoRealizadoColecao = (CreditoRealizado) colecaoCreditoRealizadoIt.next();

				valorTotalCreditoConta = valorTotalCreditoConta.add(creditoRealizadoColecao.getValorCredito());
			}
		}

		return valorTotalCreditoConta;

	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 10/01/2006 Cálcula o valor total dos
	 * débitos de uma conta de acordo com o informado
	 * pelo usuário
	 * 
	 * @param colecaoDebitoCobrado
	 * @param requestMap
	 * @return BigDecimal valorTotalDebitoConta
	 * @throws ControladorException
	 */
	public BigDecimal calcularValorTotalDebitoConta(Collection<DebitoCobrado> colecaoDebitoCobrado) throws ControladorException{

		BigDecimal valorTotalDebitoConta = new BigDecimal("0");

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if(colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()){

			// Atualizando os valores dos débitos de acordo com os dados
			// informados pelo usuário
			DebitoCobrado debitoCobradoColecao;
			Iterator colecaoDebitoCobradoIt = colecaoDebitoCobrado.iterator();

			while(colecaoDebitoCobradoIt.hasNext()){
				debitoCobradoColecao = (DebitoCobrado) colecaoDebitoCobradoIt.next();

				valorTotalDebitoConta = valorTotalDebitoConta.add(debitoCobradoColecao.getValorPrestacao());
			}
		}

		return valorTotalDebitoConta;

	}

	/**
	 * [UC0216 – Calcular Acréscimos por Impontualidade] passando os seguintes parâmetros: 4.5.4.5.
	 * Valor das multas cobradas (SUM(DBCB_VLPRESTACAO)
	 * da tabela DEBITO_COBRADO com CNTA_ID da tabela CONTA e DBTP_ID com o valor correspondente a
	 * multa por impontualidade da tabela DEBITO_TIPO);
	 * 
	 * @param colecaoDebitoCobrado
	 *            [obrigatorio] (populada relativa à uma determinada conta. Tipos de Débito e valor
	 *            do debito devem estar atribuídos)
	 * @return BigDecimal valorTotalDebitoConta
	 * @throws ControladorException
	 *             ,
	 */
	public BigDecimal calcularValorTotalMultasCobradasConta(Collection<DebitoCobrado> colecaoDebitoCobrado) throws ControladorException{

		BigDecimal valorDebitosCalculoAcrescimosImpontualidade = BigDecimal.ZERO;

		// Calculando o valor total dos débitos selecionados pelo usuário
		// ===============================================================
		if(colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()){

			for(DebitoCobrado debitoCobrado : colecaoDebitoCobrado){
				if(debitoCobrado.getDebitoTipo() != null && DebitoTipo.MULTA_IMPONTUALIDADE.equals(debitoCobrado.getDebitoTipo().getId())){
					valorDebitosCalculoAcrescimosImpontualidade = valorDebitosCalculoAcrescimosImpontualidade.add(debitoCobrado
									.getValorPrestacao());
				}
			}
		}

		return valorDebitosCalculoAcrescimosImpontualidade;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 12/01/2006 Cálcula o valor total de
	 * água ou esgoto
	 * 
	 * @param calcularValoresAguaEsgotoHelper
	 * @param tipoRetorno
	 * @return valorTotalAguaOuEsgoto
	 */
	public BigDecimal calcularValorTotalAguaOuEsgotoPorCategoria(
					Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgotoHelper, String tipoRetorno){

		BigDecimal retorno = new BigDecimal("0.00");

		if(calcularValoresAguaEsgotoHelper != null && !calcularValoresAguaEsgotoHelper.isEmpty()){

			Iterator calcularValoresAguaEsgotoHelperIt = calcularValoresAguaEsgotoHelper.iterator();
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelperObjeto = null;

			while(calcularValoresAguaEsgotoHelperIt.hasNext()){

				calcularValoresAguaEsgotoHelperObjeto = (CalcularValoresAguaEsgotoHelper) calcularValoresAguaEsgotoHelperIt.next();

				// Valor Faturado de Água
				if(tipoRetorno.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){
					if(calcularValoresAguaEsgotoHelperObjeto.getValorFaturadoAguaCategoria() != null){
						retorno = retorno.add(calcularValoresAguaEsgotoHelperObjeto.getValorFaturadoAguaCategoria());
					}
				}
				// Valor Faturado de Esgoto
				else{
					if(calcularValoresAguaEsgotoHelperObjeto.getValorFaturadoEsgotoCategoria() != null){
						retorno = retorno.add(calcularValoresAguaEsgotoHelperObjeto.getValorFaturadoEsgotoCategoria());
					}
				}
			}
		}

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 12/01/2006 Cálcula o consumo total de
	 * água ou esgoto
	 * 
	 * @param calcularValoresAguaEsgotoHelper
	 * @param tipoRetorno
	 * @return consumoTotalAguaOuEsgoto
	 */
	public Integer calcularConsumoTotalAguaOuEsgotoPorCategoria(
					Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgotoHelper, String tipoRetorno){

		Integer retorno = Integer.valueOf("0");

		/*
		 * Parâmetro para indicar se o consumo deverá ser ajustado para múltiplo da quantidade de
		 * economias
		 */
		String parametroAjustarConsumoMultiploQuantidadeEconomias;
		try{
			parametroAjustarConsumoMultiploQuantidadeEconomias = (String) ParametroFaturamento.P_AJUSTAR_CONSUMO.executar(this);

			if(parametroAjustarConsumoMultiploQuantidadeEconomias.equals(ConstantesSistema.SIM.toString())){
				if(calcularValoresAguaEsgotoHelper != null && !calcularValoresAguaEsgotoHelper.isEmpty()){

					Iterator calcularValoresAguaEsgotoHelperIt = calcularValoresAguaEsgotoHelper.iterator();
					CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelperObjeto = null;

					while(calcularValoresAguaEsgotoHelperIt.hasNext()){

						calcularValoresAguaEsgotoHelperObjeto = (CalcularValoresAguaEsgotoHelper) calcularValoresAguaEsgotoHelperIt.next();

						// Consumo Faturado de Água
						if(tipoRetorno.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){
							if(calcularValoresAguaEsgotoHelperObjeto.getConsumoFaturadoAguaCategoria() != null){
								retorno = retorno + calcularValoresAguaEsgotoHelperObjeto.getConsumoFaturadoAguaCategoria();
							}
						}
						// Consumo Faturado de Esgoto
						else{
							if(calcularValoresAguaEsgotoHelperObjeto.getConsumoFaturadoEsgotoCategoria() != null){
								retorno = retorno + calcularValoresAguaEsgotoHelperObjeto.getConsumoFaturadoEsgotoCategoria();
							}
						}
					}
				}
			}

		}catch(ControladorException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta [SF002] - Gerar dados da conta [SF003] - Gerar os débitos cobrados
	 * Author: Raphael Rossiter, Pedro Alexandre Data
	 * 05/12/2005, 20/11/2006
	 * 
	 * @author eduardo henrique
	 * @date 26/11/2008 Alteração no método para a adequação do objeto conta efetuar contabilização
	 *       do evento Inserir Conta.
	 * @author Saulo Lima
	 * @date 26/11/2008 Alteração no método para chamar a Classificação de Pagamento e Devoluções
	 *       [UC0300]
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desativação da contabilização da conta.
	 * @param mesAnoConta
	 * @param imovel
	 * @param colecaoDebitoCobrado
	 * @param ligacaoAguaSituacao
	 * @param ligacaoEsgotoSituacao
	 * @param colecaoCategoria
	 * @param consumoAgua
	 * @param consumoEsgoto
	 * @param percentualEsgoto
	 * @param dataVencimentoConta
	 * @param calcularValoresConta
	 * @param motivoInclusaoConta
	 * @throws ControladorException
	 */
	public Integer inserirConta(Integer mesAnoConta, Imovel imovel, Collection colecaoDebitoCobrado,
					LigacaoAguaSituacao ligacaoAguaSituacao, LigacaoEsgotoSituacao ligacaoEsgotoSituacao, Collection colecaoCategoria,
					String consumoAgua, String consumoEsgoto, String percentualEsgoto, Date dataVencimentoConta,
					Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta, ContaMotivoInclusao contaMotivoInclusao,
					Map<String, String[]> requestMap, Usuario usuarioLogado, Integer consumoPoco) throws ControladorException{

		Integer retorno = Integer.valueOf("0");

		try{

			/*
			 * Legenda: calcularValoresConta 1 - Valor total de água 2 - Valor total de esgoto 3 -
			 * Valor total dos débitos 4 - Valor total da conta 5
			 * - Array de objetos [UC0120] - Calcular valores de água e esgoto
			 */

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_INSERIR_CONTA, imovel.getId(),
							imovel.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_INSERIR_CONTA);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			// [FS0003] – Verificar existência da conta
			// =========================================
			FiltroConta filtroConta = new FiltroConta();

			filtroConta.adicionarCaminhoParaCarregamentoEntidade("debitoCreditoSituacaoAtual");
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, imovel.getId()));
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, mesAnoConta));

			Collection colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

			if(colecaoConta != null && !colecaoConta.isEmpty()){

				Conta conta = (Conta) colecaoConta.iterator().next();

				if(conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.CANCELADA)
								|| conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)){
					throw new ControladorException("atencao.conta_ja_existente_cancelada", null, Util.formatarMesAnoReferencia(mesAnoConta));
				}else{
					throw new ControladorException("atencao.conta_ja_existente_imovel_anomesreferencia", null, imovel.getId()
									+ " já possui a conta com a referência " + Util.formatarMesAnoReferencia(mesAnoConta) + ".");
				}

			}

			FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();

			filtroContaHistorico.adicionarCaminhoParaCarregamentoEntidade("debitoCreditoSituacaoAtual");
			filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.IMOVEL_ID, imovel.getId()));
			filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ANO_MES_REFERENCIA, mesAnoConta));

			Collection colecaoContaHistorico = this.getControladorUtil().pesquisar(filtroContaHistorico, ContaHistorico.class.getName());

			if(colecaoContaHistorico != null && !colecaoContaHistorico.isEmpty()){

				ContaHistorico contaHistorico = (ContaHistorico) colecaoContaHistorico.iterator().next();

				if(!contaHistorico.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.CANCELADA)
								&& !contaHistorico.getDebitoCreditoSituacaoAtual().getId()
												.equals(DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)){
					throw new ControladorException("atencao.conta_ja_existente_imovel_anomesreferencia", null, imovel.getId()
									+ " já possui a conta com a referência " + Util.formatarMesAnoReferencia(mesAnoConta)
									+ " que já está baixada" + ".");
				}

			}

			FaturamentoGrupo faturamentoGrupo = getControladorImovel().pesquisarGrupoImovel(imovel.getId());

			// [FS0022] Valida Referência da Conta
			if(Util.compararAnoMesReferencia(mesAnoConta, faturamentoGrupo.getAnoMesReferencia(), ">")){
				throw new ControladorException("atencao.mesano_ref_conta_maior_mesano_faturamento");
			}

			FiltroImovel filtroImovel = new FiltroImovel();
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("faturamentoSituacaoTipo");
			filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));

			Imovel imovelFaturamentoSituacaoTipo = (Imovel) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroImovel,
							Imovel.class.getName()));

			if(imovelFaturamentoSituacaoTipo.getFaturamentoSituacaoTipo() != null
							&& imovelFaturamentoSituacaoTipo.getFaturamentoSituacaoTipo().getIndicadorFaturamentoParalisacaoEsgoto()
											.equals(ConstantesSistema.SIM)){
				throw new ControladorException("atencao.inclusao_conta_indevido_faturamento_suspenso");
			}

			/*
			 * [SF002] - Gerar dados da conta
			 * ======================================================================
			 */

			// Inseri a conta na tabela Conta_Geral
			ContaGeral contaGeralInserir = new ContaGeral();

			// valor fixo
			Short indicadorHistorico = 2;

			contaGeralInserir.setIndicadorHistorico(indicadorHistorico);

			// Ultima Alteração
			contaGeralInserir.setUltimaAlteracao(new Date());

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para acoplar o controle
			 * de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Integer idGerado = null;
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{
				// Inserindo no BD
				idGerado = (Integer) this.getControladorUtil().inserir(contaGeralInserir);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------

			// seta o id da Conta Geral gerada no objeto contaGeral
			contaGeralInserir.setId(idGerado);

			Conta contaInserir = new Conta();

			// Adiciona o idGerado da tabela Conta Geral
			contaInserir.setId(idGerado);

			// setando a conta geral na conta
			contaInserir.setContaGeral(contaGeralInserir);

			// Adiciona o id do imóvel selecionado
			contaInserir.setImovel(imovel);

			// Ano e mês de referência informado
			contaInserir.setReferencia(mesAnoConta.intValue());

			// Debito Credito Situacao Atual(Com o valor correspondente a incluída
			// na tabela)
			DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao();
			debitoCreditoSituacaoAtual.setId(DebitoCreditoSituacao.INCLUIDA);
			contaInserir.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);

			// Debito Credito Situacao Anterior(Com o valor NULL)

			// Situação da ligação de água
			contaInserir.setLigacaoAguaSituacao(ligacaoAguaSituacao);

			// Situação da ligação de esgoto
			contaInserir.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

			// Motivo Nao Entrega Documento(Com o valor NULL)

			// Localidade do imóvel
			contaInserir.setLocalidade(imovel.getLocalidade());

			// Quadra do imóvel
			contaInserir.setQuadraConta(imovel.getQuadra());

			// Lote do imóvel
			contaInserir.setLote(imovel.getLote());

			// Sublote do imóvel
			contaInserir.setSubLote(imovel.getSubLote());

			// Código do setor comercial do imóvel
			contaInserir.setCodigoSetorComercial(imovel.getQuadra().getSetorComercial().getCodigo());

			// Número da quadra do imóvel
			contaInserir.setQuadra(Integer.valueOf(imovel.getQuadra().getNumeroQuadra()));

			// Dígito verificador (Implementar cálculo)
			contaInserir.setDigitoVerificadorConta(new Short(String.valueOf(Util
							.calculoRepresentacaoNumericaCodigoBarrasModulo10(mesAnoConta))));

			// Indicador cobranca multa (2)
			contaInserir.setIndicadorCobrancaMulta(Integer.valueOf(2).shortValue());

			// Data de vencimento informada

			contaInserir.setDataVencimentoConta(dataVencimentoConta);

			// Data de vencimento Original = Data de vencimento
			contaInserir.setDataVencimentoOriginal(dataVencimentoConta);

			// Indicador alteração vencimento (2)
			contaInserir.setIndicadorAlteracaoVencimento(new Short("2"));

			// Consumo de Água
			Integer consumoTotalAgua = this.calcularConsumoTotalAguaOuEsgotoPorCategoria(calcularValoresConta,
							ConstantesSistema.CALCULAR_AGUA);

			// Colocado para teste
			if(consumoTotalAgua.equals(Integer.valueOf("0"))){
				if(consumoAgua != null){
					contaInserir.setConsumoAgua(Integer.valueOf(consumoAgua));
				}else{
					contaInserir.setConsumoAgua(Integer.valueOf("0"));
				}
			}else{
				contaInserir.setConsumoAgua(consumoTotalAgua);
			}

			// Consumo de Esgoto
			Integer consumoTotalEsgoto = this.calcularConsumoTotalAguaOuEsgotoPorCategoria(calcularValoresConta,
							ConstantesSistema.CALCULAR_ESGOTO);

			// Colocado para teste
			if(consumoTotalEsgoto.equals(Integer.valueOf("0"))){
				if(consumoEsgoto != null){
					contaInserir.setConsumoEsgoto(Integer.valueOf(consumoEsgoto));
				}else{
					contaInserir.setConsumoEsgoto(Integer.valueOf("0"));
				}
			}else{
				contaInserir.setConsumoEsgoto(consumoTotalEsgoto);
			}

			// Consumo Poço
			if(consumoPoco != null){

				contaInserir.setConsumoPoco(consumoPoco);
			}

			// Consumo Rateio Água (Com valor NULL)

			// Consumo Rateio Água (Com valor NULL)

			// Valor total de água
			BigDecimal valorTotalAgua = this.calcularValorTotalAguaOuEsgotoPorCategoria(calcularValoresConta,
							ConstantesSistema.CALCULAR_AGUA);

			contaInserir.setValorAgua(valorTotalAgua);

			// Valor total de esgoto
			BigDecimal valorTotalEsgoto = this.calcularValorTotalAguaOuEsgotoPorCategoria(calcularValoresConta,
							ConstantesSistema.CALCULAR_ESGOTO);

			contaInserir.setValorEsgoto(valorTotalEsgoto);

			// Valor total dos débitos
			BigDecimal valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado, requestMap);
			contaInserir.setDebitos(valorTotalDebito);

			// Valor total dos créditos (Com valor 0)
			BigDecimal valorTotalCreditos = new BigDecimal("0.00");
			contaInserir.setValorCreditos(valorTotalCreditos);

			// Percentual de esgoto
			if(percentualEsgoto != null && !percentualEsgoto.equalsIgnoreCase("")){
				contaInserir.setPercentualEsgoto(new BigDecimal(percentualEsgoto));
			}else{
				contaInserir.setPercentualEsgoto(new BigDecimal("0.00"));
			}

			// Data de validade da conta
			Date dataValidadeConta = this.retornaDataValidadeConta(dataVencimentoConta);
			contaInserir.setDataValidadeConta(dataValidadeConta);

			// Data de inclusão - data corrente
			Calendar dataInclusaoConta = new GregorianCalendar();
			contaInserir.setDataInclusao(dataInclusaoConta.getTime());

			// Data de revisão (Com valor NULL)

			// Data de retificação (Com valor NULL)

			// Data de cancelamento (Com valor NULL)

			// Data de emissão - data corrente
			Calendar dataEmissaoConta = new GregorianCalendar();
			contaInserir.setDataEmissao(dataEmissaoConta.getTime());

			// /*
			// * Alterado por Raphael Rossiter em 30/07/2007 (Analista: Rosana
			// * Carvalho)
			// *
			// * OBJETIVO: Quando o mes/ano de faturamento for maior que o mes/ano de
			// * faturamento atual, colocar o mes/ano contábil para a data do mes/ano
			// * de faturamento informado
			// */
			// // Ano / Mês de referência contábil
			// SistemaParametro sistemaParametro =
			// this.getControladorUtil().pesquisarParametrosDoSistema();
			//
			// if (mesAnoConta.intValue() > sistemaParametro.getAnoMesFaturamento().intValue()) {
			//
			// contaInserir.setReferenciaContabil(mesAnoConta);
			// } else {
			//
			// contaInserir.setReferenciaContabil(sistemaParametro.getAnoMesFaturamento());
			// }

			/*
			 * Alterado por : Yara Souza Date : 11/05/2010
			 * Caso o ano/mês de referência informado, não seja maior que o ano/mês do faturamento
			 * do grupo ao qual o imóvel pertence.
			 */

			SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
			if(mesAnoConta.intValue() > sistemaParametro.getAnoMesFaturamento().intValue()){
				throw new ControladorException("atencao.data_emissao_conta_superior_data_faturamento", null,
								Util.formatarAnoMesParaMesAno(sistemaParametro.getAnoMesFaturamento().intValue()));
			}else{
				contaInserir.setReferenciaContabil(mesAnoConta);
			}

			// Ano / Mês de referência baixa contábil (Com valor NULL)

			// Motivo de inclusão da conta
			contaInserir.setContaMotivoInclusao(contaMotivoInclusao);

			// Consumo tarifa
			contaInserir.setConsumoTarifa(imovel.getConsumoTarifa());

			// Perfil do imóvel
			contaInserir.setImovelPerfil(imovel.getImovelPerfil());

			// Indicador débito conta
			contaInserir.setIndicadorDebitoConta(new Short("2"));

			// NomeConta
			// contaInserir.setNomeConta(imovel.getNomeConta());

			/*
			 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar na tabela de conta o
			 * usuário que está logado no sistema
			 */

			// Usuario
			contaInserir.setUsuario(usuarioLogado);

			Rota rota = imovel.getRota();
			contaInserir.setRota(rota);

			/*
			 * Colocado por Raphael Rossiter em 30/10/2007 OBJ: Gerar o valor dos impostos
			 */
			GerarImpostosDeduzidosContaHelper impostosDeduzidosConta = this.gerarImpostosDeduzidosConta(contaInserir.getImovel().getId(),
							mesAnoConta, valorTotalAgua, valorTotalEsgoto, valorTotalDebito, valorTotalCreditos);

			// Valor Impostos
			contaInserir.setValorImposto(impostosDeduzidosConta.getValorTotalImposto());

			// Ultima Alteração
			contaInserir.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			contaInserir.setOperacaoEfetuada(operacaoEfetuada);
			contaInserir.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(contaInserir);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			// Inserindo no BD
			Integer idContaGerado = (Integer) this.getControladorUtil().inserir(contaInserir);

			// setando o id da conta gerada no retorno - Tiago Moreno
			retorno = idContaGerado;

			// Carregando o ID gerado no objeto Conta
			// contaInserir.setId(idContaGerado);

			/*
			 * Inserir na tabela CONTA_CATEGORIA e CONTA_CATEGORIA_CONSUMO_FAIXA
			 * ====================================================================
			 */

			this.inserirContaCategoria(calcularValoresConta, colecaoCategoria, contaInserir, false);

			/*
			 * Inserir na tabela CLIENTE_CONTA CLIENTE_CONTA ClienteConta
			 * ======================================================================
			 */

			this.inserirClienteConta(contaInserir, imovel, null);

			/*
			 * Gerar os débitos cobrados - DEBITO_COBRADO e DEBITO_COBRADO_CATEGORIA
			 * ======================================================================
			 */

			this.inserirDebitoCobrado(contaInserir, colecaoDebitoCobrado, imovel, colecaoCategoria, false);

			/*
			 * incluir os impostos deduzidos da conta
			 * ======================================================================
			 */

			this.inserirImpostosDeduzidosConta(impostosDeduzidosConta, contaInserir, false);

			// [UC0566 – Gerar Histograma de Água e Esgoto]
			Collection<Conta> colecaoContaInserir = Collections.singletonList(contaInserir);
			carregarContaParaHistograma(colecaoContaInserir);
			getControladorHistograma().gerarHistogramaAguaEsgoto(colecaoContaInserir, ConstantesSistema.GERACAO_HISTOGRAMA_INCLUSAO);

			getControladorContabil().registrarLancamentoContabil(contaInserir, OperacaoContabil.INCLUIR_CONTA);

			// 7. Caso exista pagamento para conta, classificar pagamento de conta [UC0300 –
			// ClassificarPagamentosDevolucoes]
			if(retorno != null && !retorno.equals(Integer.valueOf(0))){
				FiltroPagamento filtroPagamento = new FiltroPagamento();
				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.IMOVEL_ID, imovel.getId()));
				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ANO_MES_REFERENCIA_PAGAMENTO, mesAnoConta));

				Collection<Pagamento> colecaoPagamentos = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

				if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){

					// ** Alteração do Classificar **
					// getControladorArrecadacao().classificarPagamentos(colecaoPagamentos.iterator().next());
					getControladorArrecadacao().classificarPagamentosRegistroMovimentoArrecadadores(colecaoPagamentos.iterator().next());
					// ** Alteração do Classificar **

				}
			}

		}catch(ControladorException e){
			sessionContext.setRollbackOnly();
			throw e;
		}catch(Exception e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * Inclui, na tabela CONTA_CATEGORIA, a(s) categoria(s) e sua(s) respectiva(s) quantidade(s) de
	 * economia da lista do passo 5.8 do fluxo principal
	 * e os atributos retornados pelo [UC0120] para cada categoria, caso o [UC0120] não tenha sido
	 * chamado, os valores correspondentes devem ser
	 * nulos.
	 * Caso o [UC0120] não tenha sido chamado não gravar a tabela CONTA_CATEGORIA_CONSUMO_FAIXA
	 * 
	 * @author eduardo henrique
	 * @date 26/11/2008 Alteração no método para a adequação do objeto conta efetuar contabilização
	 *       do evento Inserir Conta.
	 * @param calcularValoresConta
	 * @param colecaoCategoria
	 * @param conta
	 * @throws ControladorException
	 */
	public Collection<Collection<ContaCategoriaConsumoFaixa>> inserirContaCategoria(
					Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta, Collection colecaoCategoria, Conta conta,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		Collection<Collection<ContaCategoriaConsumoFaixa>> colecaocontaCategoriaConsumoFaixa = new HashSet<Collection<ContaCategoriaConsumoFaixa>>();

		conta.setContaCategorias(new HashSet<ContaCategoria>());

		Categoria categoria = new Categoria();

		ContaCategoria contaCategoriaInsert = null;
		calcularValoresConta = calcularValoresAguaEsgotoTotalizandoPorCategoria(calcularValoresConta);

		// O [UC0120] não foi invocado, inserir apenas o ID da conta, ID da
		// categoria e qtd de economias da categoria
		if(calcularValoresConta == null || calcularValoresConta.isEmpty()){

			Iterator colecaoCategoriaIt = colecaoCategoria.iterator();

			while(colecaoCategoriaIt.hasNext()){

				categoria = (Categoria) colecaoCategoriaIt.next();

				// Adicionando a categoria no objeto ContaCategoriaPK
				ContaCategoriaPK contaCategoriaPK = new ContaCategoriaPK();
				contaCategoriaPK.setConta(conta);
				contaCategoriaPK.setSubcategoria(this.getControladorImovel()
								.obterPrincipalSubcategoria(categoria.getId(), conta.getImovel().getId()).getComp_id().getSubcategoria());
				contaCategoriaPK.setCategoria(categoria);

				// Gerando o objeto ContaCategoria
				contaCategoriaInsert = new ContaCategoria();

				// Comp_id
				contaCategoriaInsert.setComp_id(contaCategoriaPK);

				// Qtd economias da categoria
				contaCategoriaInsert
								.setQuantidadeEconomia(new Short(String.valueOf(categoria.getQuantidadeEconomiasCategoria().intValue()))
												.shortValue());

				// Ultima Alteração
				contaCategoriaInsert.setUltimaAlteracao(new Date());
				if(!indicadorOperacaoCaucionamento){
					this.getControladorUtil().inserir(contaCategoriaInsert);
				}

				conta.getContaCategorias().add(contaCategoriaInsert);
			}
		}else{

			Iterator calcularValoresContaIt = calcularValoresConta.iterator();
			CalcularValoresAguaEsgotoHelper calcularValoresContaObjeto = null;

			// Integer idContaCategoriaGerado = null;

			while(calcularValoresContaIt.hasNext()){

				calcularValoresContaObjeto = (CalcularValoresAguaEsgotoHelper) calcularValoresContaIt.next();

				for(Iterator iter = colecaoCategoria.iterator(); iter.hasNext();){
					Categoria categoriaPreenchida = (Categoria) iter.next();
					if(categoriaPreenchida.getId().intValue() == calcularValoresContaObjeto.getIdCategoria()){
						categoria = categoriaPreenchida;
						break;
					}
				}
				categoria.setId(calcularValoresContaObjeto.getIdCategoria());

				// Adicionando a categoria no objeto ContaCategoriaPK
				ContaCategoriaPK contaCategoriaPK = new ContaCategoriaPK();
				contaCategoriaPK.setConta(conta);

				ImovelSubcategoria imovelSubcategoria = this.getControladorImovel().obterPrincipalSubcategoria(categoria.getId(),
								conta.getImovel().getId());
				if(imovelSubcategoria != null){
					contaCategoriaPK.setSubcategoria(imovelSubcategoria.getComp_id().getSubcategoria());
				}else{
					contaCategoriaPK.setSubcategoria(Subcategoria.SUBCATEGORIA_ZERO);
				}

				contaCategoriaPK.setCategoria(categoria);

				// Gerando o objeto ContaCategoria
				contaCategoriaInsert = new ContaCategoria();

				// Comp_id
				contaCategoriaInsert.setComp_id(contaCategoriaPK);

				// Qtd economias da categoria
				contaCategoriaInsert.setQuantidadeEconomia(new Short(String.valueOf(calcularValoresContaObjeto
								.getQuantidadeEconomiasCategoria().intValue())).shortValue());

				// Valores relacionados aos cálculos de água

				contaCategoriaInsert.setValorAgua(calcularValoresContaObjeto.getValorFaturadoAguaCategoria());
				contaCategoriaInsert.setConsumoAgua(calcularValoresContaObjeto.getConsumoFaturadoAguaCategoria());
				contaCategoriaInsert.setValorTarifaMinimaAgua(calcularValoresContaObjeto.getValorTarifaMinimaAguaCategoria());
				contaCategoriaInsert.setConsumoMinimoAgua(calcularValoresContaObjeto.getConsumoMinimoAguaCategoria());

				// Valores relacionados aos cálculos de esgoto

				contaCategoriaInsert.setValorEsgoto(calcularValoresContaObjeto.getValorFaturadoEsgotoCategoria());
				contaCategoriaInsert.setConsumoEsgoto(calcularValoresContaObjeto.getConsumoFaturadoEsgotoCategoria());
				contaCategoriaInsert.setValorTarifaMinimaEsgoto(calcularValoresContaObjeto.getValorTarifaMinimaEsgotoCategoria());
				contaCategoriaInsert.setConsumoMinimoEsgoto(calcularValoresContaObjeto.getConsumoMinimoEsgotoCategoria());

				// Ultima Alteração
				contaCategoriaInsert.setUltimaAlteracao(new Date());

				if(!indicadorOperacaoCaucionamento){
					this.getControladorUtil().inserir(contaCategoriaInsert);
				}

				conta.getContaCategorias().add(contaCategoriaInsert);

				// Inserindo na tabela CONTA_CATEGORIA_CONSUMO_FAIXA
				colecaocontaCategoriaConsumoFaixa.add(this.inserirContaCategoriaConsumoFaixa(contaCategoriaInsert,
								calcularValoresContaObjeto.getFaixaTarifaConsumo(), indicadorOperacaoCaucionamento));

			}
		}
		return colecaocontaCategoriaConsumoFaixa;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * Inclui a(s) faixa(s) de consumo por categoria na tabela CONTA_CATEGORIA_CONSUMO_FAIXA com os
	 * atributos retornados pelo [UC0120] por categoria e
	 * para cada faixa da categoria, caso o [UC0120] não tenha sido chamado não gravar a tabela.
	 * 
	 * @param contaCategoria
	 * @param calcularValoresContaFaixa
	 * @throws ControladorException
	 */
	public Collection<ContaCategoriaConsumoFaixa> inserirContaCategoriaConsumoFaixa(ContaCategoria contaCategoria,
					Collection<CalcularValoresAguaEsgotoFaixaHelper> calcularValoresContaFaixa, boolean indicadorOperacaoCaucionamento)
					throws ControladorException{

		Collection<ContaCategoriaConsumoFaixa> colecaoContaCategoriaConsumoFaixa = new HashSet<ContaCategoriaConsumoFaixa>();

		CalcularValoresAguaEsgotoFaixaHelper calcularValoresContaFaixaObjeto = null;
		ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixaInsert = null;

		if(calcularValoresContaFaixa != null && !calcularValoresContaFaixa.isEmpty()){
			Iterator calcularValoresContaFaixaIt = calcularValoresContaFaixa.iterator();
			while(calcularValoresContaFaixaIt.hasNext()){

				calcularValoresContaFaixaObjeto = (CalcularValoresAguaEsgotoFaixaHelper) calcularValoresContaFaixaIt.next();

				contaCategoriaConsumoFaixaInsert = new ContaCategoriaConsumoFaixa();

				// Conta Categoria
				contaCategoriaConsumoFaixaInsert.setContaCategoria(contaCategoria);

				// Valores relacionados aos cálculos de água

				contaCategoriaConsumoFaixaInsert.setValorAgua(calcularValoresContaFaixaObjeto.getValorFaturadoAguaFaixa());
				contaCategoriaConsumoFaixaInsert.setConsumoAgua(calcularValoresContaFaixaObjeto.getConsumoFaturadoAguaFaixa());

				// Valores relacionados aos cálculos de esgoto

				contaCategoriaConsumoFaixaInsert.setValorEsgoto(calcularValoresContaFaixaObjeto.getValorFaturadoEsgotoFaixa());
				contaCategoriaConsumoFaixaInsert.setConsumoEsgoto(calcularValoresContaFaixaObjeto.getConsumoFaturadoEsgotoFaixa());

				// ConsumoFaixaInicio
				contaCategoriaConsumoFaixaInsert.setConsumoFaixaInicio(calcularValoresContaFaixaObjeto.getLimiteInicialConsumoFaixa());

				// ConsumoFaixaFinal
				contaCategoriaConsumoFaixaInsert.setConsumoFaixaFim(calcularValoresContaFaixaObjeto.getLimiteFinalConsumoFaixa());

				// valorTarifaFaixa
				contaCategoriaConsumoFaixaInsert.setValorTarifaFaixa(calcularValoresContaFaixaObjeto.getValorTarifaFaixa());

				// Ultima Alteração
				contaCategoriaConsumoFaixaInsert.setUltimaAlteracao(new Date());

				if(contaCategoriaConsumoFaixaInsert != null && !contaCategoriaConsumoFaixaInsert.equals("")
								&& !indicadorOperacaoCaucionamento){
					this.getControladorUtil().inserir(contaCategoriaConsumoFaixaInsert);
				}

				colecaoContaCategoriaConsumoFaixa.add(contaCategoriaConsumoFaixaInsert);
			}
		}
		return colecaoContaCategoriaConsumoFaixa;
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * Seleciona a partir da tabela CLIENTE_IMOVEL para IMOV_ID=Id do imóvel e CLIM_DTRELACAOFIM com
	 * o valor correspondente a nulo
	 * 
	 * @param IMOVEL
	 * @throws ControladorException
	 */
	public void inserirClienteConta(Conta conta, Imovel imovel, Cliente clienteResponsavelConta) throws ControladorException{

		Collection colecaoClienteImovel = null;

		try{

			colecaoClienteImovel = this.repositorioFaturamento.pesquisarClienteImovelDataRelacaoFimNull(imovel);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		Iterator colecaoClienteImovelIt = colecaoClienteImovel.iterator();
		Object[] colecaoClienteImovelObjeto = null;
		ClienteConta clienteContaInsert = null;
		boolean possuiResponsavel = false;

		while(colecaoClienteImovelIt.hasNext()){

			colecaoClienteImovelObjeto = (Object[]) colecaoClienteImovelIt.next();
			
			ClienteRelacaoTipo clienteRelacaoTipo = (ClienteRelacaoTipo) colecaoClienteImovelObjeto[1];

			if(clienteRelacaoTipo.getId().equals(ClienteRelacaoTipo.RESPONSAVEL)){

				possuiResponsavel = true;
				clienteContaInsert = new ClienteConta();
				clienteContaInsert.setConta(conta);

				if(clienteResponsavelConta == null){

					clienteContaInsert.setCliente((Cliente) colecaoClienteImovelObjeto[0]);
				}else{

					clienteContaInsert.setCliente(clienteResponsavelConta);
				}

				clienteContaInsert.setClienteRelacaoTipo((ClienteRelacaoTipo) colecaoClienteImovelObjeto[1]);
				clienteContaInsert.setIndicadorNomeConta((Short) colecaoClienteImovelObjeto[2]);
				clienteContaInsert.setUltimaAlteracao(new Date());
			}else{
			
			clienteContaInsert = new ClienteConta();
			clienteContaInsert.setConta(conta);
			clienteContaInsert.setCliente((Cliente) colecaoClienteImovelObjeto[0]);
			clienteContaInsert.setClienteRelacaoTipo((ClienteRelacaoTipo) colecaoClienteImovelObjeto[1]);
			clienteContaInsert.setIndicadorNomeConta((Short) colecaoClienteImovelObjeto[2]);
			clienteContaInsert.setUltimaAlteracao(new Date());
			}

			this.getControladorUtil().inserir(clienteContaInsert);
		}

		if(!possuiResponsavel && clienteResponsavelConta != null){

			ClienteConta clienteContaResponsavel = new ClienteConta();
			clienteContaResponsavel.setConta(conta);
			clienteContaResponsavel.setCliente(clienteResponsavelConta);

			ClienteRelacaoTipo clienteRelacaoTipo = new ClienteRelacaoTipo();
			clienteRelacaoTipo.setId(ClienteRelacaoTipo.RESPONSAVEL);
			clienteContaResponsavel.setClienteRelacaoTipo(clienteRelacaoTipo);

			clienteContaResponsavel.setIndicadorNomeConta(ConstantesSistema.NAO);
			clienteContaResponsavel.setUltimaAlteracao(new Date());

			this.getControladorUtil().inserir(clienteContaResponsavel);
		}

	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * Inseri na tabela DEBITO_COBRADO os dados referentes aos débitos da conta
	 * 
	 * @author eduardo henrique
	 * @date 26/11/2008 Alteração no método para a adequação do objeto conta efetuar contabilização
	 *       do evento Inserir Conta.
	 * @param conta
	 * @param colecaoDebitoCobrado
	 * @param imovel
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirDebitoCobrado(Conta conta, Collection colecaoDebitoCobrado, Imovel imovel, Collection colecaoCategoria,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		conta.setDebitoCobrados(new HashSet<DebitoCobrado>());

		if(colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()){

			Iterator colecaoDebitoCobradoIt = colecaoDebitoCobrado.iterator();

			while(colecaoDebitoCobradoIt.hasNext()){

				DebitoCobrado debitoCobradoColecao = (DebitoCobrado) colecaoDebitoCobradoIt.next();

				DebitoCobrado debitoCobradoInserir = new DebitoCobrado();

				debitoCobradoInserir.setIdAntigo(debitoCobradoColecao.getId());

				// Tipo do débito selecionado
				debitoCobradoInserir.setDebitoTipo(debitoCobradoColecao.getDebitoTipo());

				// Débito cobrado - data corrente
				debitoCobradoInserir.setDebitoCobrado(new Date());

				// Conta
				debitoCobradoInserir.setConta(conta);

				// Lançamento Item Contábil
				debitoCobradoInserir.setLancamentoItemContabil(debitoCobradoColecao.getDebitoTipo().getLancamentoItemContabil());

				// Localidade
				debitoCobradoInserir.setLocalidade(imovel.getLocalidade());

				// Quadra
				debitoCobradoInserir.setQuadra(imovel.getQuadra());

				// Código do setor comercial
				debitoCobradoInserir.setCodigoSetorComercial(Integer.valueOf(imovel.getSetorComercial().getCodigo()));

				// Número da quadra
				debitoCobradoInserir.setNumeroQuadra(Integer.valueOf(imovel.getQuadra().getNumeroQuadra()));

				// Lote
				debitoCobradoInserir.setNumeroLote(new Short(imovel.getLote()));

				// Sublote
				debitoCobradoInserir.setNumeroSubLote(new Short(imovel.getSubLote()));

				// Ano Mês referência do débito
				if(debitoCobradoColecao.getAnoMesReferenciaDebito() != null){
					debitoCobradoInserir.setAnoMesReferenciaDebito(debitoCobradoColecao.getAnoMesReferenciaDebito());
				}

				// Ano Mês referência da cobrança
				if(debitoCobradoColecao.getAnoMesCobrancaDebito() != null){
					debitoCobradoInserir.setAnoMesCobrancaDebito(debitoCobradoColecao.getAnoMesCobrancaDebito());
				}

				// Valor da prestação
				debitoCobradoInserir.setValorPrestacao(debitoCobradoColecao.getValorPrestacao());

				// Número de prestações
				if(debitoCobradoColecao.getNumeroPrestacao() == 0){
					debitoCobradoInserir.setNumeroPrestacao(new Short("1").shortValue());
				}else{
					debitoCobradoInserir.setNumeroPrestacao(debitoCobradoColecao.getNumeroPrestacao());
				}

				// Número de prestações do débito
				if(debitoCobradoColecao.getNumeroPrestacaoDebito() == 0){
					debitoCobradoInserir.setNumeroPrestacaoDebito(new Short("1").shortValue());
				}else{
					debitoCobradoInserir.setNumeroPrestacaoDebito(debitoCobradoColecao.getNumeroPrestacaoDebito());
				}

				// FinanciamentoTipo
				debitoCobradoInserir.setFinanciamentoTipo(debitoCobradoColecao.getDebitoTipo().getFinanciamentoTipo());
				
				// Parcelamento
				debitoCobradoInserir.setParcelamento(debitoCobradoColecao.getParcelamento());
				
				
				// Ultima alteração
				debitoCobradoInserir.setUltimaAlteracao(new Date());

				// [SB0001] - Verificar Marcação do Débito A Cobrar para Remuneração da Cobrança
				// Administrativa
				debitoCobradoInserir.setIndicadorRemuneraCobrancaAdministrativa(this.verificarMarcacaoRemuneracaoCobAdminstrativa(
								debitoCobradoInserir.getConta().getImovel().getId(), debitoCobradoInserir.getDebitoTipo().getId()));

				// Inserindo no BD
				if(!indicadorOperacaoCaucionamento){
					Integer idDebitoCobradoGerado = (Integer) this.getControladorUtil().inserir(debitoCobradoInserir);

					debitoCobradoInserir.setId(idDebitoCobradoGerado);

					// Inclui a quantidade de economias por categoria do débito
					// cobrado na tabela DEBITO_COBRADO_CATEGORIA

					this.inserirDebitoCobradoCategoria(debitoCobradoInserir, colecaoCategoria);
				}


				conta.getDebitoCobrados().add(debitoCobradoInserir);
			}
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 13/01/2006
	 * Inseri na tabela CREDITO_REALIZADO os dados referentes aos créditos da conta
	 * 
	 * @param conta
	 * @param colecaoCreditoRealizado
	 * @param imovel
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirCreditoRealizado(Conta conta, Collection colecaoCreditoRealizado, Imovel imovel, Collection colecaoCategoria,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		conta.setCreditoRealizados(new HashSet<CreditoRealizado>());

		if(colecaoCreditoRealizado != null && !colecaoCreditoRealizado.isEmpty()){

			Iterator colecaoCreditoRealizadoIt = colecaoCreditoRealizado.iterator();

			while(colecaoCreditoRealizadoIt.hasNext()){

				CreditoRealizado creditoRealizadoColecao = (CreditoRealizado) colecaoCreditoRealizadoIt.next();

				CreditoRealizado creditoRealizadoInserir = new CreditoRealizado();

				// Tipo do crédito selecionado
				creditoRealizadoInserir.setCreditoTipo(creditoRealizadoColecao.getCreditoTipo());

				// Crédito realizado - data corrente
				creditoRealizadoInserir.setDataHoraCreditoRealizado(new Date());

				// Conta
				creditoRealizadoInserir.setConta(conta);

				// Lançamento Item Contábil
				creditoRealizadoInserir.setLancamentoItemContabil(creditoRealizadoColecao.getCreditoTipo().getLancamentoItemContabil());

				// Localidade
				creditoRealizadoInserir.setLocalidade(imovel.getLocalidade());

				// Quadra
				creditoRealizadoInserir.setQuadra(imovel.getQuadra());

				// Código do setor comercial
				creditoRealizadoInserir.setCodigoSetorComercial(Integer.valueOf(imovel.getSetorComercial().getCodigo()));

				// Número da quadra
				creditoRealizadoInserir.setNumeroQuadra(Integer.valueOf(imovel.getQuadra().getNumeroQuadra()));

				// Lote
				creditoRealizadoInserir.setNumeroLote(new Short(imovel.getLote()));

				// Sublote
				creditoRealizadoInserir.setNumeroSubLote(new Short(imovel.getSubLote()));

				// Ano Mês referência do crédito
				if(creditoRealizadoColecao.getAnoMesReferenciaCredito() != null){
					creditoRealizadoInserir.setAnoMesReferenciaCredito(creditoRealizadoColecao.getAnoMesReferenciaCredito());
				}

				// Ano Mês referência da cobrança
				if(creditoRealizadoColecao.getAnoMesCobrancaCredito() != null){
					creditoRealizadoInserir.setAnoMesCobrancaCredito(creditoRealizadoColecao.getAnoMesCobrancaCredito());
				}

				// Valor da prestação
				creditoRealizadoInserir.setValorCredito(creditoRealizadoColecao.getValorCredito());

				// Número de prestações
				if(creditoRealizadoColecao.getNumeroPrestacao() == 0){
					creditoRealizadoInserir.setNumeroPrestacao(new Short("1").shortValue());
				}else{
					creditoRealizadoInserir.setNumeroPrestacao(creditoRealizadoColecao.getNumeroPrestacao());
				}

				// Número de prestações do crédito
				if(creditoRealizadoColecao.getNumeroPrestacaoCredito() == 0){
					creditoRealizadoInserir.setNumeroPrestacaoCredito(new Short("1").shortValue());
				}else{
					creditoRealizadoInserir.setNumeroPrestacaoCredito(creditoRealizadoColecao.getNumeroPrestacaoCredito());
				}

				// Credito Origem
				creditoRealizadoInserir.setCreditoOrigem(creditoRealizadoColecao.getCreditoOrigem());

				// Ultima alteração
				creditoRealizadoInserir.setUltimaAlteracao(new Date());

				// Colocado para realização dos testes (Retirar após os testes)
				// -------------------------------------------------------
				/*
				 * CreditoOrigem creditoOrigem = new CreditoOrigem(); creditoOrigem.setId(new
				 * Integer("1"));
				 * reditoRealizadoInserir.setCreditoOrigem(creditoOrigem);
				 */

				creditoRealizadoInserir.setParcelamento(creditoRealizadoColecao.getParcelamento());

				creditoRealizadoInserir.setCreditoARealizarGeral(creditoRealizadoColecao.getCreditoARealizarGeral());

				conta.getCreditoRealizados().add(creditoRealizadoInserir);

				// -------------------------------------------------------
				// Inserindo no BD
				if(!indicadorOperacaoCaucionamento){
					Integer idCreditoRealizadoGerado = (Integer) this.getControladorUtil().inserir(creditoRealizadoInserir);

					creditoRealizadoInserir.setId(idCreditoRealizadoGerado);

					// Inclui a quantidade de economias por categoria do crédito
					// cobrado na tabela CREDITO_REALIZADO_CATEGORIA
					this.inserirCreditoRealizadoCategoria(creditoRealizadoInserir, colecaoCategoria);
				}
			}
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * Inclui a quantidade de economias por categoria do débito cobrado na tabela
	 * DEBITO_COBRADO_CATEGORIA
	 * 
	 * @author eduardo henrique
	 * @date 26/11/2008 Alteração no método para a adequação do objeto conta efetuar contabilização
	 *       do evento Inserir Conta.
	 * @param debitoCobrado
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirDebitoCobradoCategoria(DebitoCobrado debitoCobrado, Collection colecaoCategoria) throws ControladorException{

		debitoCobrado.setDebitoCobradoCategorias(new HashSet<DebitoCobradoCategoria>());

		Collections.sort((List<T>) colecaoCategoria, new Comparator() {

			public int compare(Object o1, Object o2){

				Categoria cd1 = (Categoria) o1;
				Categoria cd2 = (Categoria) o2;
				return cd1.getId().compareTo(cd2.getId());
			}
		});

		// [UC0185] - Obter Valor Por Categoria
		Object[][] valorPorCategoria = obterValorPorCategoria(colecaoCategoria, debitoCobrado.getValorPrestacao());

		Iterator colecaoCategoriaIt = colecaoCategoria.iterator();
		Categoria categoriaColecao;
		Categoria categoriaArray;

		while(colecaoCategoriaIt.hasNext()){
			categoriaColecao = (Categoria) colecaoCategoriaIt.next();

			// Gerando o objeto DebitoCobradoCategoriaPK
			DebitoCobradoCategoriaPK debitoCobradoCategoriaPKInserir = new DebitoCobradoCategoriaPK();
			// Categoria
			// debitoCobradoCategoriaPKInserir.setCategoria(categoriaColecao);
			debitoCobradoCategoriaPKInserir.setCategoria(categoriaColecao);

			// Debito Cobrado
			// debitoCobradoCategoriaPKInserir.setDebitoCobrado(debitoCobrado);
			debitoCobradoCategoriaPKInserir.setDebitoCobrado(debitoCobrado);

			// Gerando o objeto que será inserido no BD
			DebitoCobradoCategoria debitoCobradoCategoriaInserir = new DebitoCobradoCategoria();

			// Comp_ID
			debitoCobradoCategoriaInserir.setComp_id(debitoCobradoCategoriaPKInserir);

			// Categoria
			debitoCobradoCategoriaInserir.setCategoria(categoriaColecao);

			// Quantidade de economias da categoria
			debitoCobradoCategoriaInserir.setQuantidadeEconomia(categoriaColecao.getQuantidadeEconomiasCategoria());

			// Última alteração
			debitoCobradoCategoriaInserir.setUltimaAlteracao(new Date());

			// Resgatando o valor por categoria do array retornado pelo
			// [UC0185] - Obter Valor Por Categoria
			for(int index = 0; index < valorPorCategoria.length; index++){
				categoriaArray = (Categoria) valorPorCategoria[index][0];

				if(categoriaArray.getId().equals(categoriaColecao.getId())){

					// Valor categoria
					debitoCobradoCategoriaInserir.setValorCategoria((BigDecimal) valorPorCategoria[index][1]);

					this.getControladorUtil().inserir(debitoCobradoCategoriaInserir);

					debitoCobrado.getDebitoCobradoCategorias().add(debitoCobradoCategoriaInserir);
					break;
				}
			}
		}
	}

	/**
	 * [UC0145] - Inserir Conta Author: Raphael Rossiter Data: 13/01/2006
	 * Inclui a quantidade de economias por categoria do crédito realizado na tabela
	 * CREDITO_REALIZADO_CATEGORIA
	 * 
	 * @param creditoRealizado
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirCreditoRealizadoCategoria(CreditoRealizado creditoRealizado, Collection colecaoCategoria)
					throws ControladorException{

		// [UC0185] - Obter Valor Por Categoria
		Object[][] valorPorCategoria = obterValorPorCategoria(colecaoCategoria, creditoRealizado.getValorCredito());

		Iterator colecaoCategoriaIt = colecaoCategoria.iterator();
		Categoria categoriaColecao;
		Categoria categoriaArray;

		while(colecaoCategoriaIt.hasNext()){
			categoriaColecao = (Categoria) colecaoCategoriaIt.next();

			// Gerando o objeto CreditoRealizadoCategoriaPK
			CreditoRealizadoCategoriaPK creditoRealizadoCategoriaPKInserir = new CreditoRealizadoCategoriaPK();
			// Categoria
			creditoRealizadoCategoriaPKInserir.setCategoria(categoriaColecao);
			// Crédito Realizado
			creditoRealizadoCategoriaPKInserir.setCreditoRealizado(creditoRealizado);

			// Gerando o objeto que será inserido no BD
			CreditoRealizadoCategoria creditoRealizadoCategoriaInserir = new CreditoRealizadoCategoria();

			// Comp_ID
			creditoRealizadoCategoriaInserir.setComp_id(creditoRealizadoCategoriaPKInserir);

			// Quantidade de economias da categoria
			creditoRealizadoCategoriaInserir.setQuantidadeEconomia(categoriaColecao.getQuantidadeEconomiasCategoria());

			// Última alteração
			creditoRealizadoCategoriaInserir.setUltimaAlteracao(new Date());

			// Resgatando o valor por categoria do array retornado pelo
			// [UC0185] - Obter Valor Por Categoria
			for(int index = 0; index < valorPorCategoria.length; index++){
				categoriaArray = (Categoria) valorPorCategoria[index][0];

				if(categoriaArray.getId().equals(categoriaColecao.getId())){

					// Valor categoria
					creditoRealizadoCategoriaInserir.setValorCategoria((BigDecimal) valorPorCategoria[index][1]);

					this.getControladorUtil().inserir(creditoRealizadoCategoriaInserir);
					break;
				}
			}
		}
	}

	/**
	 * @author eduardo henrique
	 * @date 13/02/2009 Retirada da validação de Ano da Conta ser o mesmo do Ano da Referencia de
	 *       Faturamento.
	 * @author eduardo henrique
	 * @date 15/02/2009 Alteração na assinatura do método para receber a instância da Conta criada
	 *       na Retificação , para atualizar dados de debito
	 *       automatico corretamente. Solicitada a Inclusão de possibilidade de alteração de Dados
	 *       de Leitura na Retificação de Conta.
	 * @param anoMesConta
	 * @param contaAtual
	 * @param imovel
	 * @param colecaoDebitoCobrado
	 * @param colecaoCreditoRealizado
	 * @param ligacaoAguaSituacao
	 * @param ligacaoEsgotoSituacao
	 * @param colecaoCategoria
	 * @param consumoAgua
	 * @param consumoEsgoto
	 * @param percentualEsgoto
	 * @param dataVencimentoConta
	 * @param calcularValoresConta
	 * @param contaMotivoRetificacao
	 * @param requestMap
	 * @param colecaoMedicaoHistorico
	 *            Colecao de MedicoesHistorico(Leituras) que serao alteradas, referentes à conta
	 *            retificada.
	 * @throws ControladorException
	 */
	public Integer retificarConta(Integer anoMesConta, Conta contaAtual, Imovel imovel, Collection colecaoDebitoCobrado,
					Collection colecaoCreditoRealizado, LigacaoAguaSituacao ligacaoAguaSituacao,
					LigacaoEsgotoSituacao ligacaoEsgotoSituacao, Collection colecaoCategoria, String consumoAgua, String consumoEsgoto,
					String percentualEsgoto, Date dataVencimentoConta, Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta,
					ContaMotivoRetificacao contaMotivoRetificacao, Map<String, String[]> requestMap, Usuario usuarioLogado,
					Collection<MedicaoHistorico> colecaoMedicaoHistorico, ConsumoTarifa consumoTarifa, Cliente clienteResponsavelConta)
					throws ControladorException{
		
		return this.retificarConta(anoMesConta, contaAtual, imovel, colecaoDebitoCobrado, colecaoCreditoRealizado, ligacaoAguaSituacao,
						ligacaoEsgotoSituacao, colecaoCategoria, consumoAgua, consumoEsgoto, percentualEsgoto, dataVencimentoConta,
						calcularValoresConta, contaMotivoRetificacao, requestMap, usuarioLogado, colecaoMedicaoHistorico, consumoTarifa,
						true, clienteResponsavelConta);
	}

	/**
	 * @author Hiroshi Goncalves
	 * @date 26/11/2013 Adicionado a flag inRegistrarLancamentoContabilOrigem ao método original
	 *       para indicar se deverá ser registrado o lançamento contábil da Origem do Pagamento.
	 * @param anoMesConta
	 * @param contaAtual
	 * @param imovel
	 * @param colecaoDebitoCobrado
	 * @param colecaoCreditoRealizado
	 * @param ligacaoAguaSituacao
	 * @param ligacaoEsgotoSituacao
	 * @param colecaoCategoria
	 * @param consumoAgua
	 * @param consumoEsgoto
	 * @param percentualEsgoto
	 * @param dataVencimentoConta
	 * @param calcularValoresConta
	 * @param contaMotivoRetificacao
	 * @param requestMap
	 * @param colecaoMedicaoHistorico
	 * @param inRegistrarLancamentoContabilOrigem
	 *            Colecao de MedicoesHistorico(Leituras) que serao alteradas, referentes à conta
	 *            retificada.
	 * @throws ControladorException
	 */
	public Integer retificarConta(Integer anoMesConta, Conta contaAtual, Imovel imovel, Collection colecaoDebitoCobrado,
					Collection colecaoCreditoRealizado, LigacaoAguaSituacao ligacaoAguaSituacao,
					LigacaoEsgotoSituacao ligacaoEsgotoSituacao, Collection colecaoCategoria, String consumoAgua, String consumoEsgoto,
					String percentualEsgoto, Date dataVencimentoConta, Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta,
					ContaMotivoRetificacao contaMotivoRetificacao, Map<String, String[]> requestMap, Usuario usuarioLogado,
					Collection<MedicaoHistorico> colecaoMedicaoHistorico, ConsumoTarifa consumoTarifa,
					boolean inRegistrarLancamentoContabilOrigem, Cliente clienteResponsavelConta) throws ControladorException{


		Integer idContaGerada = null;
		Collection<CreditoRealizado> collCreditoRealizadoAtualizada = new ArrayList<CreditoRealizado>();

		try{

			// ------------ <REGISTRAR TRANSAÇÃO>----------------------------
			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_CONTA_RETIFICAR);

			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONTA_RETIFICAR, contaAtual.getImovel()
							.getId(), contaAtual.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);
			operacaoEfetuada.setArgumentoValor(contaAtual.getImovel().getId());

			contaAtual.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			contaAtual.setOperacaoEfetuada(operacaoEfetuada);

			registradorOperacao.registrarOperacao(contaAtual);
			getControladorTransacao().registrarTransacao(contaAtual);
			// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

			// A variável calcularValoresConta com valor NULL sinaliza que o método foi chamado pelo
			// processo de arrecadação. Esse tratamento foi feito para a empresa CASAL. Os valores
			// que estão checando se a variável é NULL devem ser preservados, pois a retificação é
			// realizada apenas para incluir novos débitos de serviço.

			if(calcularValoresConta != null){
				// Verifica se a data de vencimento é um dia útil. Se não for, pega a data posterior
				// útil.
				Collection<NacionalFeriado> colecaoferiadoNacional = getControladorUtil().pesquisarFeriadosNacionais();

				boolean adiarData = true;

				while(adiarData){

					if(Util.ehDiaUtil(dataVencimentoConta, colecaoferiadoNacional, null)){

						adiarData = false;
					}else{

						dataVencimentoConta = Util.adicionarNumeroDiasDeUmaData(dataVencimentoConta, 1);
					}
				}
			}else{
				dataVencimentoConta = contaAtual.getDataVencimentoConta();
			}

			// guarda situacão inicial da conta q podem ser alterados no
			// retificarContaAtualizarSituacao
			// para se for levantada alguma exceção, a conta não perder seu estado
			// inicial
			DebitoCreditoSituacao debitoCreditoSituacaoAnteriorNaoAlterado = contaAtual.getDebitoCreditoSituacaoAnterior();
			DebitoCreditoSituacao debitoCreditoSituacaoAtualNaoAlterado = contaAtual.getDebitoCreditoSituacaoAtual();
			Integer referenciaContabilNaoAlterado = contaAtual.getReferenciaContabil();
			Usuario usuarioNaoAlterado = contaAtual.getUsuario();
			Date dataInclusaoContaAtual = contaAtual.getDataInclusao();

			/*
			 * [SF002] - Gerar dados da conta
			 * ======================================================================
			 */

			SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

			// Atualizar os seguintes atributos da conta a ser retificada

			// Debito Credito Situacao Atual(Com o valor correspondente a retificada na tabela)
			DebitoCreditoSituacao debitoCreditoSituacaoAtualAtualizacao = new DebitoCreditoSituacao();

			// Situação Atual
			debitoCreditoSituacaoAtualAtualizacao.setId(DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);
			contaAtual.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtualAtualizacao);

			// Ano Mês referencia contábil
			contaAtual.setReferenciaContabil(sistemaParametro.getAnoMesFaturamento());

			/*
			 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar na tabela de conta o
			 * usuário que está logado no sistema
			 */

			// Usuario
			contaAtual.setUsuario(usuarioLogado);

			// Última alteração
			contaAtual.setUltimaAlteracao(new Date());

			// UPDATE
			try{

				if(contaAtual.getDebitoCreditoSituacaoAnterior() == null){
					repositorioFaturamento.retificarContaAtualizarSituacao(contaAtual, null);
				}else{
					repositorioFaturamento.retificarContaAtualizarSituacao(contaAtual, contaAtual.getDebitoCreditoSituacaoAnterior()
									.getId());
				}

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				// conta atual volta a situação inicial
				contaAtual.setDebitoCreditoSituacaoAnterior(debitoCreditoSituacaoAnteriorNaoAlterado);
				contaAtual.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtualNaoAlterado);
				contaAtual.setReferenciaContabil(referenciaContabilNaoAlterado);

				contaAtual.setUsuario(usuarioNaoAlterado);

				throw new ControladorException("erro.sistema", ex);
			}

			ContaGeral contaGeralInserir = new ContaGeral();

			// valor fixo
			Short indicadorHistorico = 2;

			contaGeralInserir.setIndicadorHistorico(indicadorHistorico);

			// Ultima Alteração
			contaGeralInserir.setUltimaAlteracao(new Date());

			// Inserindo no BD
			Integer idGerado = (Integer) this.getControladorUtil().inserir(contaGeralInserir);

			// seta o id da Conta Geral gerada no objeto contaGeral
			contaGeralInserir.setId(idGerado);

			Conta contaInserir = new Conta();

			contaInserir.setIdAntigo(contaAtual.getId());
			registradorOperacao.registrarOperacao(contaInserir);

			// Adiciona o id do imóvel selecionado
			contaInserir.setImovel(contaAtual.getImovel());

			// Adiciona o id do contaGeral selecionado
			contaInserir.setContaGeral(contaGeralInserir);

			// Carregando o ID gerado no objeto Conta
			contaInserir.setId(idGerado);

			// Ano e mês de referência informado
			contaInserir.setReferencia(anoMesConta.intValue());

			DebitoCreditoSituacao debitoCreditoSituacaoInserir = new DebitoCreditoSituacao();

			// Situação Atual
			debitoCreditoSituacaoInserir.setId(DebitoCreditoSituacao.RETIFICADA);

			// Debito credito situacao
			contaInserir.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoInserir);

			// Debito Credito Situacao Anterior(Com o valor NULL)

			// Situação da ligação de água
			contaInserir.setLigacaoAguaSituacao(ligacaoAguaSituacao);

			// Situação da ligação de esgoto
			contaInserir.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

			// Motivo Nao Entrega Documento(Com o valor NULL)

			// Localidade
			contaInserir.setLocalidade(contaAtual.getLocalidade());

			// Quadra
			contaInserir.setQuadraConta(contaAtual.getQuadraConta());

			// Lote
			contaInserir.setLote(contaAtual.getLote());

			// Sublote
			contaInserir.setSubLote(contaAtual.getSubLote());

			// Código do setor comercial
			FiltroQuadra filtroQuadra = new FiltroQuadra();

			filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID, contaAtual.getQuadraConta().getId()));

			filtroQuadra.adicionarCaminhoParaCarregamentoEntidade(FiltroQuadra.SETOR_COMERCIAL);

			Collection colecaoQuadra = this.getControladorUtil().pesquisar(filtroQuadra, Quadra.class.getName());

			if(colecaoQuadra != null){

				Quadra quadra = (Quadra) Util.retonarObjetoDeColecao(colecaoQuadra);

				contaInserir.setCodigoSetorComercial(quadra.getSetorComercial().getCodigo());

				// Número da quadra
				contaInserir.setQuadra(Integer.valueOf(quadra.getNumeroQuadra()));

			}

			// Código comentado por não ser usado no ADA - Saulo Lima 12/09/2008
			// contaInserir.setDigitoVerificadorConta(new
			// Short(String.valueOf(Util.calculoRepresentacaoNumericaCodigoBarrasModulo10(mesAnoConta))));

			// Crédito de consumo
			contaInserir.setCreditoConsumo(contaAtual.getCreditoConsumo());

			// Indicador cobranca multa (2)
			contaInserir.setIndicadorCobrancaMulta(contaAtual.getIndicadorCobrancaMulta());

			contaInserir.setDataVencimentoConta(dataVencimentoConta);

			contaInserir.setIndicadorDebitoConta(contaAtual.getIndicadorDebitoConta());

			this.verificarVencimentoContaDebitoAutomatico(contaInserir);

			// Data Vencimento Original
			contaInserir.setDataVencimentoOriginal(contaAtual.getDataVencimentoOriginal());

			// Indicador alteração vencimento (2)
			contaInserir.setIndicadorAlteracaoVencimento(Short.valueOf("2"));

			// Consumo de Água
			if(calcularValoresConta != null){
				Integer consumoTotalAgua = this.calcularConsumoTotalAguaOuEsgotoPorCategoria(calcularValoresConta,
								ConstantesSistema.CALCULAR_AGUA);

				// Colocado para teste
				if(consumoTotalAgua.equals(Integer.valueOf("0"))){
					if(consumoAgua != null){
						contaInserir.setConsumoAgua(Integer.valueOf(consumoAgua));
					}else{
						contaInserir.setConsumoAgua(Integer.valueOf("0"));
					}
				}else{
					contaInserir.setConsumoAgua(consumoTotalAgua);
				}
			}else{
				contaInserir.setConsumoAgua(contaAtual.getConsumoAgua());
			}

			// Consumo de Esgoto
			if(calcularValoresConta != null){
				Integer consumoTotalEsgoto = this.calcularConsumoTotalAguaOuEsgotoPorCategoria(calcularValoresConta,
								ConstantesSistema.CALCULAR_ESGOTO);

				// Colocado para teste
				if(consumoTotalEsgoto.equals(Integer.valueOf("0"))){
					if(consumoEsgoto != null && !consumoEsgoto.equals("")){
						contaInserir.setConsumoEsgoto(Integer.valueOf(consumoEsgoto));
					}else{
						contaInserir.setConsumoEsgoto(contaAtual.getConsumoEsgoto());
					}
				}else{
					contaInserir.setConsumoEsgoto(consumoTotalEsgoto);
				}
			}else{
				contaInserir.setConsumoEsgoto(contaAtual.getConsumoEsgoto());
			}

			// Consumo Poço
			if(contaAtual.getConsumoPoco() != null){

				contaInserir.setConsumoPoco(contaAtual.getConsumoPoco());
			}

			// Consumo Rateio Água (Com valor NULL)

			// Consumo Rateio Água (Com valor NULL)

			// Valor total de água
			BigDecimal valorTotalAgua = BigDecimal.ZERO;

			if(calcularValoresConta != null){
				valorTotalAgua = this.calcularValorTotalAguaOuEsgotoPorCategoria(calcularValoresConta, ConstantesSistema.CALCULAR_AGUA);
			}else{
				valorTotalAgua = contaAtual.getValorAgua();
			}

			contaInserir.setValorAgua(valorTotalAgua);

			// Valor total de esgoto
			BigDecimal valorTotalEsgoto = BigDecimal.ZERO;

			if(calcularValoresConta != null){
				valorTotalEsgoto = this.calcularValorTotalAguaOuEsgotoPorCategoria(calcularValoresConta, ConstantesSistema.CALCULAR_ESGOTO);
			}else{
				valorTotalEsgoto = contaAtual.getValorEsgoto();
			}

			contaInserir.setValorEsgoto(valorTotalEsgoto);

			// Valor total dos debitos
			BigDecimal valorTotalDebito = null;
			// Valor total dos creditos
			BigDecimal valorTotalCredito = null;

			if(requestMap != null){
				valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado, requestMap);
				valorTotalCredito = this.calcularValorTotalCreditoConta(colecaoCreditoRealizado, requestMap);
			}else{
				valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado);
				valorTotalCredito = this.calcularValorTotalCreditoConta(colecaoCreditoRealizado);
			}

			contaInserir.setDebitos(valorTotalDebito);
			contaInserir.setValorCreditos(valorTotalCredito);

			BigDecimal valorTotalConta = valorTotalAgua.add(valorTotalEsgoto).add(valorTotalDebito).subtract(valorTotalCredito);
			BigDecimal valorTotalContaSemCredito = valorTotalAgua.add(valorTotalEsgoto).add(valorTotalDebito);

			Object[] retornoValorContaNegativo = verificarVaorTotalContaNegativo(valorTotalConta, valorTotalCredito,
							valorTotalContaSemCredito, colecaoCreditoRealizado, usuarioLogado, true);

			Short indicadorCompararCreditoAtualComAnterior = null;
			Collection colecaoNovosCreditosRealizados = null;
			Collection colecaoNovosCreditosARealizar = null;

			if(retornoValorContaNegativo != null){
				indicadorCompararCreditoAtualComAnterior = (Short) retornoValorContaNegativo[0];
				colecaoCreditoRealizado = (Collection) retornoValorContaNegativo[1];
				colecaoNovosCreditosRealizados = (Collection) retornoValorContaNegativo[2];
				colecaoCreditoRealizado.addAll(colecaoNovosCreditosRealizados);
				collCreditoRealizadoAtualizada = colecaoCreditoRealizado;
				colecaoNovosCreditosARealizar = (Collection) retornoValorContaNegativo[3];

			}

			if(!Util.isVazioOrNulo(colecaoNovosCreditosARealizar)){
				Iterator it = colecaoNovosCreditosARealizar.iterator();
				while(it.hasNext()){
					CreditoARealizar creditoARealizar = (CreditoARealizar) it.next();
					this.inserirCreditoARealizar(imovel, creditoARealizar, usuarioLogado);
				}
			}

			if(requestMap != null){
				valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado, requestMap);
				valorTotalCredito = this.calcularValorTotalCreditoConta(colecaoCreditoRealizado, requestMap);
			}else{
				valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado);
				valorTotalCredito = this.calcularValorTotalCreditoConta(colecaoCreditoRealizado);
			}

			contaInserir.setDebitos(valorTotalDebito);
			contaInserir.setValorCreditos(valorTotalCredito);

			// Percentual de esgoto
			if(percentualEsgoto != null && !percentualEsgoto.equalsIgnoreCase("")){
				contaInserir.setPercentualEsgoto(Util.formatarMoedaRealparaBigDecimal(percentualEsgoto));
			}else{
				contaInserir.setPercentualEsgoto(new BigDecimal("0.00"));
			}

			// valor do imposto
			GerarImpostosDeduzidosContaHelper impostosDeduzidosConta = gerarImpostosDeduzidosConta(contaAtual.getImovel().getId(),
							anoMesConta, valorTotalAgua, valorTotalEsgoto, valorTotalDebito, valorTotalCredito);

			contaInserir.setValorImposto(impostosDeduzidosConta.getValorTotalImposto());

			// Data de validade da conta
			Date dataValidadeConta = this.retornaDataValidadeConta(dataVencimentoConta);
			contaInserir.setDataValidadeConta(dataValidadeConta);

			// Data de inclusão - A conta retificada recebe a data de inclusão da conta Atual.
			contaInserir.setDataInclusao(dataInclusaoContaAtual);

			// Data de revisão (Com valor NULL)

			// Data de retificação - data corrente
			Calendar dataRetificacaoConta = new GregorianCalendar();
			contaInserir.setDataRetificacao(dataRetificacaoConta.getTime());

			// Data de cancelamento (Com valor NULL)

			// Data de emissão - data corrente
			Calendar dataEmissaoConta = new GregorianCalendar();
			contaInserir.setDataEmissao(dataEmissaoConta.getTime());

			// Ano / Mês de referência contábil
			contaInserir.setReferenciaContabil(Util.getAnoMesComoInteger(new Date()));

			// Ano / Mês de referência baixa contábil (Com valor NULL)

			// Motivo de retificação da conta
			contaInserir.setContaMotivoRetificacao(contaMotivoRetificacao);

			// Consumo tarifa
			contaInserir.setConsumoTarifa(consumoTarifa);

			// Perfil do imóvel
			contaInserir.setImovelPerfil(contaAtual.getImovelPerfil());


			// Indicador débito conta
			contaInserir.setIndicadorDebitoConta(this.obterIndicadorDebitoConta(contaInserir.getDataVencimentoConta(),
							contaAtual.getDataVencimentoConta(), imovel.getIndicadorDebitoConta()));

			/*
			 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar na tabela de conta o
			 * usuário que está logado no sistema
			 */

			// Usuario
			contaInserir.setUsuario(usuarioLogado);

			// Ultima Alteração
			contaInserir.setUltimaAlteracao(new Date());

			// Nome Conta
			// contaInserir.setNomeConta(contaAtual.getNomeConta());

			// Montando a coleção de ContaCategoria

			Collection colecaoContaCategoria = montarColecaoContaCategoria(colecaoCategoria, contaInserir);

			/*
			 * Estas coleções são setadas antes de enviar o objeto conta para o controlador util,
			 * para lá, no momento de inserir ou atualizar, o
			 * interceptador consiga ter as novas coleções que serão associadas a esta conta, a fim
			 * de verificar as alterações ocorridas nos itens da
			 * coleção (inserção, remoção ou alteração)
			 */
			contaInserir.setContaCategorias(new HashSet(colecaoContaCategoria));
			contaInserir.setDebitoCobrados(new HashSet(colecaoDebitoCobrado));
			contaInserir.setCreditoRealizados(new HashSet(colecaoCreditoRealizado));

			Rota rota = imovel.getRota();
			contaInserir.setRota(rota);

			contaInserir.setIndicadorPagamento(contaAtual.getIndicadorPagamento());

			contaInserir.setIndicadorCobrancaAdministrativa(contaAtual.getIndicadorCobrancaAdministrativa());
			contaInserir.setIndicadorRemuneraCobrancaAdministrativa(contaAtual.getIndicadorRemuneraCobrancaAdministrativa());


			// Inserindo no BD
			idContaGerada = (Integer) this.getControladorUtil().inserir(contaInserir);

			/*
			 * Inserir na tabela CLIENTE_CONTA CLIENTE_CONTA ClienteConta
			 * ======================================================================
			 */

			this.inserirClienteConta(contaInserir, imovel, clienteResponsavelConta);

			/*
			 * Inserir na tabela CONTA_CATEGORIA e CONTA_CATEGORIA_CONSUMO_FAIXA
			 * ====================================================================
			 */
			if(calcularValoresConta != null){
				this.inserirContaCategoria(calcularValoresConta, colecaoCategoria, contaInserir, false);
			}else{
				FiltroContaCategoria filtroContaCategoria = new FiltroContaCategoria();
				filtroContaCategoria.adicionarParametro(new ParametroSimples(FiltroContaCategoria.CONTA_ID, contaAtual.getId()));
				filtroContaCategoria.adicionarCaminhoParaCarregamentoEntidade(FiltroContaCategoria.CATEGORIA);
				filtroContaCategoria.adicionarCaminhoParaCarregamentoEntidade(FiltroContaCategoria.SUBCATEGORIA);

				Collection<ContaCategoria> colecaoContaCategoriaAux = this.getControladorUtil().pesquisar(filtroContaCategoria,
								ContaCategoria.class.getName());

				if(!Util.isVazioOrNulo(colecaoContaCategoriaAux)){
					Set<ContaCategoria> contaCategorias = new HashSet<ContaCategoria>();

					ContaCategoriaPK contaCategoriaPK = null;

					for(ContaCategoria contaCategoria : colecaoContaCategoriaAux){
						contaCategoriaPK = contaCategoria.getComp_id();
						contaCategoriaPK.setConta(contaInserir);

						// Se o valor de água da conta foi zerado, o valor de água em
						// conta_categoria também deve ser zerado
						if(contaInserir.getValorAgua() == null || contaInserir.getValorAgua().equals(BigDecimal.ZERO)){
							contaCategoria.setValorAgua(contaInserir.getValorAgua());
						}

						// Se o valor de esgoto da conta foi zerado, o valor de esgoto em
						// conta_categoria também deve ser zerado
						if(contaInserir.getValorEsgoto() == null || contaInserir.getValorEsgoto().equals(BigDecimal.ZERO)){
							contaCategoria.setValorEsgoto(contaInserir.getValorEsgoto());
						}

						contaCategoria.setUltimaAlteracao(new Date());

						contaCategorias.add(contaCategoria);
					}

					contaInserir.setContaCategorias(contaCategorias);

					this.getControladorUtil().inserirColecaoObjetos(colecaoContaCategoriaAux);

					FiltroContaCategoriaConsumoFaixa filtroContaCategoriaConsumoFaixa = new FiltroContaCategoriaConsumoFaixa();
					filtroContaCategoriaConsumoFaixa.adicionarParametro(new ParametroSimples(FiltroContaCategoriaConsumoFaixa.CONTA_ID,
									contaAtual.getId()));
					filtroContaCategoriaConsumoFaixa
									.adicionarCaminhoParaCarregamentoEntidade(FiltroContaCategoriaConsumoFaixa.CONTA_CATEGORIA);

					Collection<ContaCategoriaConsumoFaixa> colecaoContaCategoriaConsumoFaixaAux = this.getControladorUtil().pesquisar(
									filtroContaCategoriaConsumoFaixa, ContaCategoriaConsumoFaixa.class.getName());

					if(!Util.isVazioOrNulo(colecaoContaCategoriaConsumoFaixaAux)){
						ContaCategoria contaCategoria = null;

						for(ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa : colecaoContaCategoriaConsumoFaixaAux){
							contaCategoriaConsumoFaixa.setId(null);
							contaCategoriaConsumoFaixa.setUltimaAlteracao(new Date());

							contaCategoria = contaCategoriaConsumoFaixa.getContaCategoria();

							contaCategoriaPK = contaCategoria.getComp_id();
							contaCategoriaPK.setConta(contaInserir);
						}

						this.getControladorUtil().inserirColecaoObjetos(colecaoContaCategoriaConsumoFaixaAux);
					}
				}

			}

			/*
			 * [UC0150] Retificar Conta
			 * [SB0002] – Gerar Dados da Conta
			 * 2. O sistema verifica se existem itens de negativação associados à conta - <<Inclui>>
			 * [UC0937 – Obter Itens de Negativação Associados à Conta] passando o identificador do
			 * imóvel (IMOV_ID da conta a ser retificada) e a referência (Ano e mês de referência da
			 * conta a ser retificada).
			 * [SB0005] – Atualizar Item da Negativação
			 */
			this.getControladorSpcSerasa().verificarHaRelacaoCancelamentoComItensNegativacaoRetificarConta(contaInserir);

			/*
			 * Gerar os débitos cobrados - DEBITO_COBRADO e DEBITO_COBRADO_CATEGORIA
			 * ======================================================================
			 */

			this.inserirDebitoCobrado(contaInserir, colecaoDebitoCobrado, imovel, colecaoCategoria, false);



			// [SB0010] – Comparar Crédito Atual com o Anterior
			if(indicadorCompararCreditoAtualComAnterior.compareTo(ConstantesSistema.SIM) == 0 && colecaoCreditoRealizado != null){

				FiltroCreditoRealizado filtro = new FiltroCreditoRealizado();
				filtro.adicionarParametro(new ParametroSimples(FiltroCreditoRealizado.CONTA_ID, contaAtual.getId()));
				filtro.adicionarParametro(new ParametroSimples(FiltroCreditoRealizado.CREDITO_ORIGEM_ID,
								CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO));
				filtro.adicionarParametro(new ParametroSimples(FiltroCreditoRealizado.CREDITO_ORIGEM_IC_USO_LIVRE, ConstantesSistema.NAO));
				filtro.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoRealizado.CREDITO_ORIGEM);

				Collection<CreditoRealizado> collCreditosAAgrupar = new ArrayList<CreditoRealizado>();
				Collection<CreditoRealizado> collBd = this.getControladorUtil().pesquisar(filtro, CreditoRealizado.class.getName());

				CreditoRealizado creditoRealizado = null;

				for(Object obj : colecaoCreditoRealizado){

					creditoRealizado = (CreditoRealizado) obj;

					CreditoOrigem creditoOrigem = creditoRealizado.getCreditoOrigem();

					// 1.1. Para cada crédito atual/anterior: Caso a origem do crédito seja
					// “Documentos
					// Pagos em Duplicidade / Excesso” e o indicador de utilização livre seja “Não”
					// (CROG_ID = 1 e CROG_ICUSOLIVRE = 2 em CREDITO_ORIGEM)
					if(creditoOrigem != null && creditoOrigem.getId().equals(CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO)
									&& creditoOrigem.getIndicadorUsoLivre().equals(ConstantesSistema.NAO)){

						collCreditosAAgrupar.add(creditoRealizado);

					}

				}

				// 1.1.1. Comparar valor/existência atual com a anterior:
				Map<String, Collection<CreditoRealizado>> creditosAgrupados = this.agruparCreditosRealizados(collBd, collCreditosAAgrupar);
				Map<Integer, Collection<CreditoRealizado>> creditosTratados = new HashMap<Integer, Collection<CreditoRealizado>>();

				// 1.1.1.4. Caso seja um crédito excluído: Estornar crédito ou atualizar valor
				// residual (CRAR_VLRESIDUALMESANTERIOR)
				for(CreditoRealizado cr : creditosAgrupados.get("CREDITOS_EXCLUIDOS")){

					this.tratarCreditoARealizarExcluidoEMenor(cr, Boolean.TRUE, collBd);

				}

				// 1.1.1.2. Caso seja um crédito menor: Estornar crédito ou atualizar valor residual
				// (CRAR_VLRESIDUALMESANTERIOR)
				for(CreditoRealizado cr : creditosAgrupados.get("CREDITOS_MENOR")){

					this.tratarCreditoARealizarExcluidoEMenor(cr, Boolean.FALSE, collBd);
					this.agruparCreditosRealizadosTratados(creditosTratados, cr, null);

				}

				// 1.1.1.1. Caso seja um valor novo: Transferir crédito para histórico ou atualizar
				// valor residual (CRAR_VLRESIDUALMESANTERIOR)
				for(CreditoRealizado cr : creditosAgrupados.get("CREDITOS_NOVOS")){

					this.agruparCreditosRealizadosTratados(creditosTratados, null, this.tratarCreditoARealizarNovos(imovel.getId(), cr));

				}

				// 1.1.1.3. Caso seja um crédito maior: Transferir crédito para histórico ou
				// atualizar valor residual (CRAR_VLRESIDUALMESANTERIOR)
				for(CreditoRealizado cr : creditosAgrupados.get("CREDITOS_MAIOR")){

					this.agruparCreditosRealizadosTratados(creditosTratados, null, this.tratarCreditoARealizarAMaior(imovel.getId(), cr));

				}

				// 1.1.1.3. Caso seja um crédito maior: Transferir crédito para histórico ou
				// atualizar valor residual (CRAR_VLRESIDUALMESANTERIOR)
				for(CreditoRealizado cr : creditosAgrupados.get("CREDITOS_SEM_ALTERACAO")){

					this.agruparCreditosRealizadosTratados(creditosTratados, cr, null);

				}

				// Gera apenas um credito realizado
				if(!creditosTratados.isEmpty()){
					
					collCreditoRealizadoAtualizada.clear();

					for(Integer key : creditosTratados.keySet()){

						Collection<CreditoRealizado> collCreditosTratados = creditosTratados.get(key);
						CreditoRealizado crGerado = this.gerarCreditoRealizado(collCreditosTratados.iterator().next());
						BigDecimal vlTotal = BigDecimal.ZERO;

						for(CreditoRealizado creditoRealido : collCreditosTratados){

							vlTotal = vlTotal.add(creditoRealido.getValorCredito());

						}

						crGerado.setValorCredito(vlTotal);
						collCreditoRealizadoAtualizada.add(crGerado);


					}

				}

			}

			/*
			 * Gerar os créditos realizados - CREDITO_REALIZADO e CREDITO_REALIZADO_CATEGORIA
			 * ======================================================================
			 */
			this.inserirCreditoRealizado(contaInserir, collCreditoRealizadoAtualizada, imovel, colecaoCategoria, false);

			/*
			 * incluir os impostos deduzidos da conta
			 * ======================================================================
			 */
			this.inserirImpostosDeduzidosConta(impostosDeduzidosConta, contaInserir, false);

			/*
			 * atualizar,caso existam, os pagamentos referentes a conta q foi retificada
			 * ======================================================================
			 */
			if(calcularValoresConta != null){
				this.atualizarPagamentoContaRetificada(contaAtual.getId(), idContaGerada);
			}

			/*
			 * Colocado por Raphael Rossiter em 03/07/2007 (Analista: Rosana Carvalho) OBJETIVO:
			 * Atualizar o id da conta na tabela
			 * DEBITO_AUTOMATICO_MOVIMENTO
			 */
			// this.atualizarDebitoAutomaticoMovimentoContaRetificada(contaAtual.getId(),
			// contaInserir, imovel);

			// [UC0566 – Gerar Histograma de Água e Esgoto]
			Collection<Conta> colecaoContaRetificada = Collections.singletonList(contaAtual);
			carregarContaParaHistograma(colecaoContaRetificada);
			getControladorHistograma().gerarHistogramaAguaEsgoto(colecaoContaRetificada, ConstantesSistema.GERACAO_HISTOGRAMA_CANCELAMENTO);

			// 8.7. Caso o indicador de débito automático da conta seja igual a “SIM”, atualiza
			// débito automático [SB0006 – Gerar Débito Automático]
			if(contaAtual.getIndicadorDebitoConta() != null && contaAtual.getIndicadorDebitoConta().equals(ConstantesSistema.SIM)){

				this.gerarDebitoAutomaticoMovimentoConta(contaAtual, contaInserir, true);

			}

			// Força a consulta a base de dados para resgatar o indicador de PDD mais recente da
			// contaAtual
			Conta contaTemp = this.repositorioArrecadacao.pesquisarConta(contaAtual.getId());

			// Atualizar os indicadores de PDD
			// 1. Setar o indicador de conta em PDD da contaInserir com o valor existente em
			// contaAtual e setar o indicar de conta em PDD da contaAtual com não (2).
			Short indicadorPDDPersistencia = new Short(contaTemp.getIndicadorPDD().shortValue());
			contaInserir.setIndicadorPDD(indicadorPDDPersistencia);
			contaAtual.setIndicadorPDD(ConstantesSistema.NAO);

			getControladorContabil().registrarLancamentoContabil(contaAtual, OperacaoContabil.CANCELAR_CONTA);

			getControladorContabil().registrarLancamentoContabil(contaInserir, OperacaoContabil.INCLUIR_CONTA);

			// if(!Util.isVazioOrNulo(collOperacaoContabilHelper)){
			// getControladorContabil().registrarLancamentoContabil(collOperacaoContabilHelper);
			// }

			// Atualizar PDD - Conta a Inserir
			// 2. Caso a conta a inserir esteja em PDD (CONTA.CNTA_ICPDD igual a "sim" (1)) e a
			// referência da inclusão da conta no PDD
			// (PROVISAO_DEVEDORES_DUVIDOSOS.PDDV_AMREFERENCIACONTABIL) seja menor ou igual a
			// referência de corte para PDD (PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com
			// PASI_CDPARAMETRO = 'P_REFERENCIA_CORTE_PDD') e a data de vencimento da conta após a
			// retificação seja maior ou igual ao primeiro dia do mês e ano da referência de corte
			ProvisaoDevedoresDuvidosos provisaoDevedoresDuvidosos = this.repositorioContabil
							.obterProvisaoDevedoresDuvidososMaisRecente(contaAtual.getId());

			// Seta novamente o indicador de persistencia caso a operação
			// registrarLancamentoContabil tenha recarregado o valor de PDD (neste caso ele já tinha
			// sido setado previamente para 2 no cancelamento)
			contaInserir.setIndicadorPDD(indicadorPDDPersistencia);

			if(contaInserir.getIndicadorPDD().equals(ConstantesSistema.SIM)
							&& provisaoDevedoresDuvidosos != null
							&& (provisaoDevedoresDuvidosos.getReferenciaContabil().intValue() <= Integer
											.parseInt(ParametroContabil.P_REFERENCIA_CORTE_PDD.executar()))
							&& Util.compararData(contaInserir.getDataVencimentoConta(), Util.gerarDataInicialApartirAnoMesRefencia(Integer
											.valueOf(ParametroContabil.P_REFERENCIA_CORTE_PDD.executar()))) >= 0){

				this.getControladorContabil().atualizarProvisaoDevedoresDuvidososLancamentoContabil(contaAtual, sistemaParametro,
								ProvisaoDevedoresDuvidososMotivoBaixa.ALTERACAO_VENCIMENTO);

				contaInserir.setIndicadorPDD(ConstantesSistema.NAO);

			}

			// 3. Caso a conta a inserir esteja em PDD (CONTA.CNTA_ICPDD igual a "sim" (1)),
			// atualizar a tabela PROVISAO_DEVEDORES_DUVIDOSOS com o Id da nova conta gerada.
			if(contaInserir.getIndicadorPDD().equals(ConstantesSistema.SIM)){
				ProvisaoDevedoresDuvidosos pdd = this.repositorioContabil.obterProvisaoDevedoresDuvidososMaisRecente(contaAtual.getId());
				ContaGeral contaGeral = new ContaGeral();
				contaGeral.setId(contaInserir.getId());
				pdd.setContaGeral(contaGeral);
				pdd.setUltimaAlteracao(new Date());

				this.repositorioUtil.atualizar(pdd);

				this.repositorioFaturamento.atualizarIndicadorPDDDeConta(contaInserir.getId(), ConstantesSistema.SIM, false);

			}

			// Inicio - Item 8
			// Transfere a conta cancelada por retificação e os seus respectivos débitos cobrados e
			// créditos realizados para histórico
			Collection<Conta> contasARemover = new ArrayList<Conta>();
			Collection<Integer> contasGeralAAtualizar = new ArrayList<Integer>();
			contasARemover.add(contaAtual);
			contasGeralAAtualizar.add(contaAtual.getId());

			if(contasARemover != null && !contasARemover.isEmpty() && contasARemover.iterator().next() != null){
				if(sistemaParametro != null && sistemaParametro.getAnoMesFaturamento() != null){
					transferirContasParaHistorico(contasARemover, sistemaParametro.getAnoMesFaturamento());
				}
			}

			// Indicador atualizado no método transferirContasParaHistorico(...)
			// atualizarIndicadorContaNoHistorico(contasGeralAAtualizar);

			// Fim - Item 8

			// 9. Caso exista pagamento para conta, classificar pagamento de conta
			// [UC0300 – ClassificarPagamentosDevolucoes]
			if(contasARemover != null && !contasARemover.isEmpty()){

				for(Conta contaClassificar : contasARemover){
					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.IMOVEL_ID, contaClassificar.getImovel().getId()));
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ANO_MES_REFERENCIA_PAGAMENTO, Integer
									.valueOf(contaClassificar.getReferencia())));

					Collection<Pagamento> colecaoPagamentos = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

					if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){
						for(Pagamento pagamento : colecaoPagamentos){
							pagamento.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAtual());
						}

						if(calcularValoresConta != null){
							getControladorArrecadacao().classificarPagamentosRegistroMovimentoArrecadadores(
											colecaoPagamentos.iterator().next());
						}

						if(inRegistrarLancamentoContabilOrigem){
							OperacaoContabilHelper helper = getControladorArrecadacao().definirOrigemOperacaoContabilPagamento(
											colecaoPagamentos.iterator().next(), true);
							if(helper.getOperacaoContabil() != null){
								getControladorContabil()
												.registrarLancamentoContabil(helper.getObjetoOrigem(), helper.getOperacaoContabil());
							}
						}
					}
				}

			}

			String pExibirCampoLeituraAnteriorRetificarConta = null;

			try{

				pExibirCampoLeituraAnteriorRetificarConta = (String) ParametroFaturamento.P_EXIBIR_CAMPO_LEITURA_ANTERIOR_RETIFICAR_CONTA
								.executar(this);
			}catch(ControladorException e){

				throw new ActionServletException(e.getMessage(), e.getParametroMensagem().toArray(
								new String[e.getParametroMensagem().size()]));
			}

			// verifica se há dados de Leitura para serem Atualizados
			if(colecaoMedicaoHistorico != null && !colecaoMedicaoHistorico.isEmpty()){
				for(MedicaoHistorico medicaoHistorico : colecaoMedicaoHistorico){
					MedicaoHistorico medicaoHistoricoReferencia = null;
					if(medicaoHistorico.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){
						// busca a medicaoHistorico de Água ou de Esgoto do Imovel, na referencia,
						// para realizar a atualização
						medicaoHistoricoReferencia = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(
										medicaoHistorico.getLigacaoAgua().getId(), medicaoHistorico.getAnoMesReferencia());

					}else{
						medicaoHistoricoReferencia = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoPoco(
										medicaoHistorico.getImovel().getId(), medicaoHistorico.getAnoMesReferencia());

					}

					if(medicaoHistoricoReferencia != null){

						// caso a Leitura atual ou Anormalidade seja modificada, a situaçao da
						// Medicao será alterada para Confirmada
						if((!medicaoHistorico.getLeituraAtualFaturamento().equals(
										medicaoHistoricoReferencia.getLeituraAnteriorFaturamento()))
										|| (medicaoHistorico.getLeituraAnormalidadeFaturamento() == null && medicaoHistoricoReferencia
														.getLeituraAnormalidadeFaturamento() != null)
										|| (medicaoHistorico.getLeituraAnormalidadeFaturamento() != null && medicaoHistoricoReferencia
														.getLeituraAnormalidadeFaturamento() == null)
										|| (medicaoHistorico.getLeituraAnormalidadeFaturamento() != null
														&& medicaoHistoricoReferencia.getLeituraAnormalidadeFaturamento() != null && !medicaoHistorico
														.getLeituraAnormalidadeFaturamento().getId()
														.equals(medicaoHistoricoReferencia.getLeituraAnormalidadeFaturamento().getId()))){
							LeituraSituacao leituraSituacao = new LeituraSituacao();
							leituraSituacao.setId(LeituraSituacao.CONFIRMADA);
							medicaoHistoricoReferencia.setLeituraSituacaoAtual(leituraSituacao);
						}

						medicaoHistoricoReferencia.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualFaturamento());
						medicaoHistoricoReferencia.setDataLeituraAtualFaturamento(medicaoHistorico.getDataLeituraAtualFaturamento());
						medicaoHistoricoReferencia.setLeituraAnormalidadeFaturamento(medicaoHistorico.getLeituraAnormalidadeFaturamento());

						if(Util.isNaoNuloBrancoZero(pExibirCampoLeituraAnteriorRetificarConta)
										&& pExibirCampoLeituraAnteriorRetificarConta.equals(ConstantesSistema.SIM.toString())){

							medicaoHistoricoReferencia.setLeituraAnteriorFaturamento(medicaoHistorico.getLeituraAnteriorFaturamento());

							MedicaoHistorico medicaoHistoricoAnterior = repositorioMicromedicao.consultarMedicaoHistoricoAnterior(
											contaAtual.getImovel().getId(), medicaoHistoricoReferencia.getAnoMesReferencia(),
											medicaoHistoricoReferencia.getMedicaoTipo().getId());

							if(medicaoHistoricoAnterior != null){

								medicaoHistoricoAnterior.setLeituraAtualFaturamento(medicaoHistoricoReferencia
												.getLeituraAnteriorFaturamento());
								getControladorMicromedicao().atualizarMedicaoHistorico(medicaoHistoricoAnterior);
							}
						}

						getControladorMicromedicao().atualizarMedicaoHistorico(medicaoHistoricoReferencia);
					}
				}
			}

			// Ajuste do histórico de consumo
			boolean atualizarConsumoMedio = false;

			Integer anoMesInicial = null;

			Integer anoMesFinal = null;

			Integer anoMesFaturamento = this.retornaAnoMesFaturamentoGrupo(imovel.getId());

			Short mesesMediaConsumo = sistemaParametro.getMesesMediaConsumo();

			Integer menorAnoMesReferencia = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesFaturamento, new Integer(mesesMediaConsumo) - 1);

			if(contaAtual.getReferencia() >= menorAnoMesReferencia){
				anoMesInicial = menorAnoMesReferencia;

				anoMesFinal = anoMesFaturamento;

				atualizarConsumoMedio = true;
			}else{
				anoMesInicial = contaAtual.getReferencia();

				anoMesFinal = contaAtual.getReferencia();

				atualizarConsumoMedio = false;
			}

			Collection<ImovelMicromedicao> colecaoImovelMicromedicao = this.getControladorMicromedicao()
							.pesquisaConsumoHistoricoSubstituirConsumo(imovel.getId(), anoMesInicial, anoMesFinal);

			if(!Util.isVazioOrNulo(colecaoImovelMicromedicao)){
				ConsumoHistorico consumoHistoricoAgua = null;
				ConsumoHistorico consumoHistoricoEsgoto = null;

				Integer consumoFaturadoMesAgua = ConstantesSistema.ZERO.intValue();

				if(!Util.isVazioOuBranco(consumoAgua)){
					consumoFaturadoMesAgua = Integer.valueOf(consumoAgua);
				}

				Integer consumoFaturadoMesEsgoto = null;

				if(!Util.isVazioOuBranco(consumoEsgoto)){
					consumoFaturadoMesEsgoto = Integer.valueOf(consumoEsgoto);
				}

				for(ImovelMicromedicao imovelMicromedicao : colecaoImovelMicromedicao){
					imovelMicromedicao.setImovel(imovel);

					consumoHistoricoAgua = imovelMicromedicao.getConsumoHistorico();
					consumoHistoricoEsgoto = imovelMicromedicao.getConsumoHistoricoEsgoto();

					if((consumoHistoricoAgua != null && consumoHistoricoAgua.getReferenciaFaturamento() == contaAtual.getReferencia())
									|| (consumoHistoricoEsgoto != null && consumoHistoricoEsgoto.getReferenciaFaturamento() == contaAtual
													.getReferencia())){
						if(consumoHistoricoAgua != null){

							if(consumoFaturadoMesAgua == consumoHistoricoAgua.getNumeroConsumoFaturadoMes()){
								// Não atualiza na base
								imovelMicromedicao.setConsumoHistorico(null);

							}else{

								ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
								consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_RETIFICADO);

								consumoHistoricoAgua.setConsumoAnormalidade(consumoAnormalidade);
								consumoHistoricoAgua.setNumeroConsumoFaturadoMes(consumoFaturadoMesAgua);

							}

						}

						if(consumoHistoricoEsgoto != null){
							if(consumoFaturadoMesEsgoto == consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes()){
								// Não atualiza na base
								imovelMicromedicao.setConsumoHistoricoEsgoto(null);

							}else{

								consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoFaturadoMesEsgoto);

							}
						}
					}
				}

				this.getControladorMicromedicao().atualizarConsumosAnterioresEConsumosMedio(colecaoImovelMicromedicao, usuarioLogado,
								atualizarConsumoMedio);

			}

			/*
			 * TODO Provavelmente entrará aqui o [UC0207 – Gerar/Atualizar Resumo de Faturamento]
			 * após as especificações.
			 */

			// [UC0566 – Gerar Histograma de Água e Esgoto]
			Collection colecaoContaInserida = Collections.singletonList(contaInserir);
			carregarContaParaHistograma(colecaoContaInserida);
			getControladorHistograma().gerarHistogramaAguaEsgoto(colecaoContaInserida, ConstantesSistema.GERACAO_HISTOGRAMA_INCLUSAO);

			// transfere a conta para o histórico juntamente com seus
			// débitos cobrados e créditos realizados
			BigDecimal valorAguaEsgotoDebitos = contaInserir.getValorAgua().add(
							contaInserir.getValorEsgoto().add(contaInserir.getDebitos()));

			valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(contaInserir.getValorCreditos());
			valorAguaEsgotoDebitos = valorAguaEsgotoDebitos.subtract(contaInserir.getValorImposto());

			if(valorAguaEsgotoDebitos.compareTo(BigDecimal.ZERO) == 0){
				Collection<Conta> colecaoConta = new ArrayList<Conta>();
				colecaoConta.add(contaInserir);
				this.transferirContasParaHistorico(colecaoConta, sistemaParametro.getAnoMesFaturamento());

			}

			// Substituir Os ID antigos pelo novo ID da Conta nas tabelas

			// Boleto Bancário.
			this.repositorioFaturamento.alterarContaBoletoBancario(contaAtual.getId(), idContaGerada);

			// Itens do Documento de Cobrança.
			this.repositorioFaturamento.alterarContaCobrancaDocumentoItem(contaAtual.getId(), idContaGerada);

			// Itens da Administração da Cobrança do Imóvel.
			this.repositorioFaturamento.alterarContaImovelCobrancaAdministrivaItem(contaAtual.getId(), idContaGerada);

			// Documentos Não Entregues.
			this.repositorioFaturamento.alterarContaDocumentoNaoEntregue(contaAtual.getId(), idContaGerada);

			// Itens da Fatura.
			this.repositorioFaturamento.alterarContaFaturaItem(contaAtual.getId(), idContaGerada);


			/**
			 * [UC0150] Retificar Conta
			 * Atualizar itens da execução fiscal.
			 * 
			 * @author Gicevalter Couto
			 * @date 10/08/2014
			 */
			// Itens Situacao Cobrancas Imovel
			this.repositorioFaturamento.alterarContaExecucaoFiscalItem(contaAtual.getId(), idContaGerada);			

			// Transf. para histórico
			// if(!Util.isVazioOrNulo(colecaoDebitoACobrar)){
			// this.transferirDebitosACobrarParaHistorico(colecaoDebitoACobrar, true);
			// }

			if(valorTotalAgua.compareTo(BigDecimal.ZERO) == 1 || valorTotalEsgoto.compareTo(BigDecimal.ZERO) == 1
							|| valorTotalDebito.compareTo(BigDecimal.ZERO) == 1){


				FiltroContaImpressao filtroContaImpressao = new FiltroContaImpressao();
				filtroContaImpressao.adicionarParametro(new ParametroSimples(FiltroContaImpressao.ID, contaAtual.getId()));
				Collection<ContaImpressao> colecaoContaImpressao = getControladorUtil().pesquisar(filtroContaImpressao,
								ContaImpressao.class.getName());

				if(!Util.isVazioOrNulo(colecaoContaImpressao)){

					ContaImpressao contaImpressaoAtual = (ContaImpressao) Util.retonarObjetoDeColecao(colecaoContaImpressao);

					rota = (Rota) getControladorUtil().pesquisar(rota.getId(), Rota.class, false);

					// Gera os dados da nova conta impressão
					FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) getControladorUtil().pesquisar(
									rota.getFaturamentoGrupo().getId(), FaturamentoGrupo.class, false);

					ContaImpressao contaImpressao = this.gerarDadosContaImpressao(imovel, contaInserir, contaAtual.getReferencia(),
									faturamentoGrupo, rota);

					contaImpressao.setIndicadorImpressao(contaImpressaoAtual.getIndicadorImpressao());

					// Remove a conta impressão atual
					getControladorUtil().remover(contaImpressaoAtual);

					// Insere conta impressão nova
					getControladorUtil().inserir(contaImpressao);
				}
			}
		}catch(ControladorException ce){
			sessionContext.setRollbackOnly();
			throw ce;
		}catch(Exception e1){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e1);
		}

		return idContaGerada;

	}


	private Short obterIndicadorDebitoConta(Date dataVencimentoContaOriginal, Date dataVencimentoNovaConta, Short icDebitoContaImovel)
					throws ControladorException{

		Short indicador = null;

		Integer qtdDiasVencimento = Integer
						.valueOf((String) ParametroFaturamento.P_QUANTIDADE_DIAS_VENCIMENTO_DEBITO_AUTOMATICO.executar());

		// Caso a data de vencimento da conta ORIGINAL e da NOVA seja maior que a data atual mais a
		// quantidade de dias estabelecida no parâmetro (data de vencimento da conta ORIGINAL maior
		// que data atual + P_QUANTIDADE_DIAS_VENCIMENTO_DEBITO_AUTOMATICO e data de vencimento da
		// conta NOVA maior que data atual + P_QUANTIDADE_DIAS_VENCIMENTO_DEBITO_AUTOMATICO),
		// IMOVEL.IMOV_ICDEBITOCONTA; Caso contrário, 2.

		Date dataAtual = Util.adicionarNumeroDiasDeUmaData(new Date(), qtdDiasVencimento);
		Boolean usarIcImovel = Boolean.FALSE;

		if(dataVencimentoContaOriginal != null){

			if(dataVencimentoContaOriginal.compareTo(dataAtual) == 1){

				usarIcImovel = Boolean.TRUE;

			}

		}

		if(dataVencimentoNovaConta != null){

			if(dataVencimentoNovaConta.compareTo(dataAtual) == 1){

				usarIcImovel = Boolean.TRUE;

			}

		}

		if(usarIcImovel){

			indicador = icDebitoContaImovel;

		}else{

			indicador = Short.valueOf("2");

		}

		return indicador;

	}

	/**
	 * @author Carlos Chrystian
	 * @date 31/07/2012
	 *       [UC0146 - ManterConta]
	 *       [SB0003] - Retificar Conta
	 *       Caucionar Conta
	 * @throws ControladorException
	 */
	public Map<Conta, Collection<Collection<ContaCategoriaConsumoFaixa>>> caucionarConta(Integer anoMesConta, Conta contaAtual,
					Imovel imovel, Collection colecaoDebitoCobrado, Collection colecaoCreditoRealizado,
					LigacaoAguaSituacao ligacaoAguaSituacao, LigacaoEsgotoSituacao ligacaoEsgotoSituacao, Collection colecaoCategoria,
					String consumoAgua, String consumoEsgoto, String percentualEsgoto, Date dataVencimentoConta,
					Collection<CalcularValoresAguaEsgotoHelper> calcularValoresConta, ContaMotivoRevisao contaMotivoRevisao,
					Map<String, String[]> requestMap, Usuario usuarioLogado, Collection<MedicaoHistorico> colecaoMedicaoHistorico,
					ConsumoTarifa consumoTarifa, Collection<Conta> colecaoContaImovel) throws ControladorException{

		Map<Conta, Collection<Collection<ContaCategoriaConsumoFaixa>>> mapContaCategoria = new HashMap<Conta, Collection<Collection<ContaCategoriaConsumoFaixa>>>();

		// 6.2. Caso a função seja “caucionamento”:
		// Coloca a conta em revisão [UC0148 – Colocar Conta em Revisão]
		if(!Util.isVazioOuBranco(colecaoContaImovel) && !Util.isVazioOuBranco(contaMotivoRevisao)){
			this.colocarRevisaoConta(colecaoContaImovel, contaAtual.getId().toString(), contaMotivoRevisao, usuarioLogado);
		}

		Conta contaInserir = new Conta();

		contaInserir.setIdAntigo(contaAtual.getIdAntigo());

		// Adiciona o id do imóvel selecionado
		contaInserir.setImovel(contaAtual.getImovel());

		// Adiciona o id do contaGeral selecionado
		contaInserir.setContaGeral(contaAtual.getContaGeral());

		// Carregando o ID gerado no objeto Conta
		contaInserir.setId(contaAtual.getId());

		// Ano e mês de referência informado
		contaInserir.setReferencia(anoMesConta.intValue());

		DebitoCreditoSituacao debitoCreditoSituacaoInserir = new DebitoCreditoSituacao();

		// Situação Atual
		debitoCreditoSituacaoInserir.setId(contaAtual.getDebitoCreditoSituacaoAtual().getId());

		// Debito credito situacao
		contaInserir.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoInserir);

		// Debito Credito Situacao Anterior(Com o valor NULL)

		// Situação da ligação de água
		contaInserir.setLigacaoAguaSituacao(ligacaoAguaSituacao);

		// Situação da ligação de esgoto
		contaInserir.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

		// Motivo Nao Entrega Documento(Com o valor NULL)

		// Localidade
		contaInserir.setLocalidade(contaAtual.getLocalidade());

		// Quadra
		contaInserir.setQuadraConta(contaAtual.getQuadraConta());

		// Lote
		contaInserir.setLote(contaAtual.getLote());

		// Sublote
		contaInserir.setSubLote(contaAtual.getSubLote());

		// Código do setor comercial
		contaInserir.setCodigoSetorComercial(contaAtual.getQuadraConta().getSetorComercial().getCodigo());

		// Número da quadra
		contaInserir.setQuadra(Integer.valueOf(contaAtual.getQuadraConta().getNumeroQuadra()));

		// Código comentado por não ser usado no ADA - Saulo Lima 12/09/2008
		// contaInserir.setDigitoVerificadorConta(new
		// Short(String.valueOf(Util.calculoRepresentacaoNumericaCodigoBarrasModulo10(mesAnoConta))));

		// Crédito de consumo
		contaInserir.setCreditoConsumo(contaAtual.getCreditoConsumo());

		// Indicador cobranca multa (2)
		contaInserir.setIndicadorCobrancaMulta(contaAtual.getIndicadorCobrancaMulta());

		contaInserir.setDataVencimentoConta(dataVencimentoConta);

		// Data Vencimento Original
		contaInserir.setDataVencimentoOriginal(contaAtual.getDataVencimentoOriginal());

		// Indicador alteração vencimento (2)
		contaInserir.setIndicadorAlteracaoVencimento(Short.valueOf("2"));

		// Consumo de Água
		Integer consumoTotalAgua = this.calcularConsumoTotalAguaOuEsgotoPorCategoria(calcularValoresConta, ConstantesSistema.CALCULAR_AGUA);

		// Colocado para teste
		if(consumoTotalAgua.equals(Integer.valueOf("0"))){
			if(consumoAgua != null){
				contaInserir.setConsumoAgua(Integer.valueOf(consumoAgua));
			}else{
				contaInserir.setConsumoAgua(Integer.valueOf("0"));
			}
		}else{
			contaInserir.setConsumoAgua(consumoTotalAgua);
		}

		// Consumo de Esgoto
		Integer consumoTotalEsgoto = this.calcularConsumoTotalAguaOuEsgotoPorCategoria(calcularValoresConta,
						ConstantesSistema.CALCULAR_ESGOTO);

		// Colocado para teste
		if(consumoTotalEsgoto.equals(Integer.valueOf("0"))){
			if(consumoEsgoto != null && !consumoEsgoto.equals("")){
				contaInserir.setConsumoEsgoto(Integer.valueOf(consumoEsgoto));
			}else{
				contaInserir.setConsumoEsgoto(contaAtual.getConsumoEsgoto());
			}
		}else{
			contaInserir.setConsumoEsgoto(consumoTotalEsgoto);
		}

		// Consumo Rateio Água (Com valor NULL)

		// Valor total de água
		BigDecimal valorTotalAgua = this.calcularValorTotalAguaOuEsgotoPorCategoria(calcularValoresConta, ConstantesSistema.CALCULAR_AGUA);

		contaInserir.setValorAgua(valorTotalAgua);

		// Valor total de esgoto
		BigDecimal valorTotalEsgoto = this.calcularValorTotalAguaOuEsgotoPorCategoria(calcularValoresConta,
						ConstantesSistema.CALCULAR_ESGOTO);

		contaInserir.setValorEsgoto(valorTotalEsgoto);

		// Valor total dos débitos
		BigDecimal valorTotalDebito = null;
		// Valor total dos créditos
		BigDecimal valorTotalCredito = null;

		if(requestMap != null){
			valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado, requestMap);
			valorTotalCredito = this.calcularValorTotalCreditoConta(colecaoCreditoRealizado, requestMap);
		}else{
			valorTotalDebito = this.calcularValorTotalDebitoConta(colecaoDebitoCobrado);
			valorTotalCredito = this.calcularValorTotalCreditoConta(colecaoCreditoRealizado);
		}

		contaInserir.setDebitos(valorTotalDebito);
		contaInserir.setValorCreditos(valorTotalCredito);

		// Percentual de esgoto
		if(percentualEsgoto != null && !percentualEsgoto.equalsIgnoreCase("")){
			contaInserir.setPercentualEsgoto(Util.formatarMoedaRealparaBigDecimal(percentualEsgoto));
		}else{
			contaInserir.setPercentualEsgoto(new BigDecimal("0.00"));
		}

		// valor do imposto
		GerarImpostosDeduzidosContaHelper impostosDeduzidosConta = gerarImpostosDeduzidosConta(contaAtual.getImovel().getId(), anoMesConta,
						valorTotalAgua, valorTotalEsgoto, valorTotalDebito, valorTotalCredito);

		contaInserir.setValorImposto(impostosDeduzidosConta.getValorTotalImposto());

		// Data de validade da conta
		Date dataValidadeConta = this.retornaDataValidadeConta(dataVencimentoConta);
		contaInserir.setDataValidadeConta(dataValidadeConta);

		// Data de inclusão - A conta retificada recebe a data de inclusão da conta Atual.
		contaInserir.setDataInclusao(contaAtual.getDataInclusao());

		// Data de revisão (Com valor NULL)

		// Data de retificação - data corrente
		Calendar dataRetificacaoConta = new GregorianCalendar();
		contaInserir.setDataRetificacao(dataRetificacaoConta.getTime());

		// Data de cancelamento (Com valor NULL)

		// Data de emissão - data corrente
		Calendar dataEmissaoConta = new GregorianCalendar();
		contaInserir.setDataEmissao(dataEmissaoConta.getTime());

		// Ano / Mês de referência contábil
		contaInserir.setReferenciaContabil(Util.getAnoMesComoInteger(new Date()));

		// Ano / Mês de referência baixa contábil (Com valor NULL)

		// Motivo de retificação da conta
		contaInserir.setContaMotivoRevisao(contaMotivoRevisao);

		// Consumo tarifa
		contaInserir.setConsumoTarifa(consumoTarifa);

		// Perfil do imóvel
		contaInserir.setImovelPerfil(contaAtual.getImovelPerfil());

		// Indicador débito conta
		contaInserir.setIndicadorDebitoConta(Short.valueOf("2"));

		/*
		 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar na tabela de conta o
		 * usuário que está logado no sistema
		 */

		// Usuario
		contaInserir.setUsuario(usuarioLogado);

		// Ultima Alteração
		contaInserir.setUltimaAlteracao(new Date());

		// Nome Conta
		// contaInserir.setNomeConta(contaAtual.getNomeConta());

		// Montando a coleção de ContaCategoria

		Collection colecaoContaCategoria = montarColecaoContaCategoria(colecaoCategoria, contaInserir);

		/*
		 * Estas coleções são setadas antes de enviar o objeto conta para o controlador util,
		 * para lá, no momento de inserir ou atualizar, o
		 * interceptador consiga ter as novas coleções que serão associadas a esta conta, a fim
		 * de verificar as alterações ocorridas nos itens da
		 * coleção (inserção, remoção ou alteração)
		 */
		contaInserir.setContaCategorias(new HashSet(colecaoContaCategoria));
		contaInserir.setDebitoCobrados(new HashSet(colecaoDebitoCobrado));
		contaInserir.setCreditoRealizados(new HashSet(colecaoCreditoRealizado));

		Rota rota = imovel.getRota();
		contaInserir.setRota(rota);

		/*
		 * Inserir na tabela CONTA_CATEGORIA e CONTA_CATEGORIA_CONSUMO_FAIXA
		 * ====================================================================
		 */

		Collection<Collection<ContaCategoriaConsumoFaixa>> colecaoContaCategoriaConsumoFaixa = this.inserirContaCategoria(
						calcularValoresConta, colecaoCategoria, contaInserir, true);

		/*
		 * Gerar os débitos cobrados - DEBITO_COBRADO e DEBITO_COBRADO_CATEGORIA
		 * ======================================================================
		 */

		this.inserirDebitoCobrado(contaInserir, colecaoDebitoCobrado, imovel, colecaoCategoria, true);

		/*
		 * Gerar os créditos realizados - CREDITO_REALIZADO e CREDITO_REALIZADO_CATEGORIA
		 * ======================================================================
		 */

		this.inserirCreditoRealizado(contaInserir, colecaoCreditoRealizado, imovel, colecaoCategoria, true);

		/*
		 * incluir os impostos deduzidos da conta
		 * ======================================================================
		 */
		this.inserirImpostosDeduzidosConta(impostosDeduzidosConta, contaInserir, true);

		// ------------ <REGISTRAR TRANSAÇÃO>----------------------------

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONTA_CAUCIONAR, contaInserir.getImovel()
						.getId(), contaInserir.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		registradorOperacao.registrarOperacao(contaInserir);

		// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

		mapContaCategoria.put(contaInserir, colecaoContaCategoriaConsumoFaixa);

		return mapContaCategoria;

	}

	/**
	 * Monta uma coleção de contas categoria a partir de uma coleção de categoria recebidaeti
	 * 
	 * @param colecaoCategoria
	 * @param conta
	 * @return
	 * @throws ControladorException
	 */
	public Collection montarColecaoContaCategoria(Collection colecaoCategoria, Conta conta) throws ControladorException{

		Iterator colecaoCategoriaIt = colecaoCategoria.iterator();
		Collection<ContaCategoria> colecaoContaCategoria = new ArrayList();

		while(colecaoCategoriaIt.hasNext()){

			Categoria categoria = new Categoria();

			ContaCategoriaPK contaCategoriaPK = new ContaCategoriaPK();
			contaCategoriaPK.setConta(conta);

			categoria = (Categoria) colecaoCategoriaIt.next();

			// Adicionando a categoria no objeto ContaCategoriaPK
			contaCategoriaPK.setCategoria(categoria);

			ImovelSubcategoria imovelSubcategoria = this.getControladorImovel().obterPrincipalSubcategoria(categoria.getId(),
							conta.getImovel().getId());

			if(imovelSubcategoria != null){
				contaCategoriaPK.setSubcategoria(imovelSubcategoria.getComp_id().getSubcategoria());
			}else{
				contaCategoriaPK.setSubcategoria(Subcategoria.SUBCATEGORIA_ZERO);
			}

			// Gerando o objeto ContaCategoria
			ContaCategoria contaCategoriaInsert = new ContaCategoria();

			// Comp_id
			contaCategoriaInsert.setComp_id(contaCategoriaPK);

			// Qtd economias da categoria
			contaCategoriaInsert.setQuantidadeEconomia(new Short(String.valueOf(categoria.getQuantidadeEconomiasCategoria().intValue()))
							.shortValue());

			// Ultima Alteração
			contaCategoriaInsert.setUltimaAlteracao(new Date());

			colecaoContaCategoria.add(contaCategoriaInsert);
		}
		return colecaoContaCategoria;
	}

	/**
	 * [UC0185] - Obter Valor Por Categoria Author: Raphael Rossiter 05/12/2005
	 * 
	 * @param colecaoCategorias
	 * @param valorDebitoCobrado
	 * @return um Array de objetos Object [Categoria] [valorPorCategoria]
	 */
	public Object[][] obterValorPorCategoria(Collection colecaoCategorias, BigDecimal valorDebitoCobrado){

		Object[][] retorno = new Object[colecaoCategorias.size()][2];

		// O sistema acumula a quantidade total de economias das categorias
		int qtdTotalEconomias = 0;
		Iterator colecaoCategoriasIt = colecaoCategorias.iterator();
		Categoria categoria;

		while(colecaoCategoriasIt.hasNext()){
			categoria = (Categoria) colecaoCategoriasIt.next();
			qtdTotalEconomias = qtdTotalEconomias + categoria.getQuantidadeEconomiasCategoria().intValue();
		}

		// Fator de multiplicação para rateio do valor
		BigDecimal fatorMultiplicacao = valorDebitoCobrado.divide(new BigDecimal(qtdTotalEconomias), 2, BigDecimal.ROUND_DOWN);

		// Para cada categoria, o sistema calcula o valor por categoria
		BigDecimal valorPorCategoria = new BigDecimal("0.00");
		// Acumula o valor de todas as categorias
		BigDecimal valorPorCategoriaAcumulado = new BigDecimal("0.00");

		colecaoCategoriasIt = colecaoCategorias.iterator();
		int indexArray = 0;

		while(colecaoCategoriasIt.hasNext()){
			categoria = (Categoria) colecaoCategoriasIt.next();

			valorPorCategoria = fatorMultiplicacao.multiply(new BigDecimal(categoria.getQuantidadeEconomiasCategoria()));
			valorPorCategoriaAcumulado = valorPorCategoriaAcumulado.add(valorPorCategoria);

			retorno[indexArray][0] = categoria;
			retorno[indexArray][1] = valorPorCategoria;

			indexArray++;
		}

		/*
		 * Caso o Valor Por Categoria Acumulado seja menor que o ValorDebitoCobrado, o sistema
		 * acumula a diferença no Valor Por Categoria da primeira
		 * categoria
		 */
		int comparacao = valorPorCategoriaAcumulado.compareTo(valorDebitoCobrado);

		if(comparacao != 0){
			BigDecimal diferenca = valorDebitoCobrado.subtract(valorPorCategoriaAcumulado);
			BigDecimal valorPrimeiraCategoria = (BigDecimal) retorno[0][1];
			retorno[0][1] = valorPrimeiraCategoria.add(diferenca);
		}

		return retorno;
	}

	/**
	 * [UC0147] - Cancelar Conta Cancela uma lista de Contas recebidas.
	 * 
	 * @author Raphael Rossiter, Saulo Lima
	 * @date 10/12/2005, 11/09/2008
	 * @author Saulo Lima
	 * @date 26/11/2008 Alteração no método para chamar a Classificação de Pagamento e Devoluções
	 *       [UC0300]
	 * @vsm Controle de transação
	 * @param colecaoContas
	 * @param identificadores
	 * @param contaMotivoCancelamento
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void cancelarConta(Collection<Conta> colecaoContas, String identificadores, ContaMotivoCancelamento contaMotivoCancelamento,
					Usuario usuarioLogado, String numeroRA) throws ControladorException{

		try{

			Iterator colecaoContasIt = colecaoContas.iterator();
			Conta conta = null;
			// Conta contaNaBase = null;
			String[] arrayIdentificadores = identificadores.split(",");
			FiltroConta filtroConta = new FiltroConta();
			Collection colecaoContaNaBase = null;
			Collection<Conta> contasARemover = new ArrayList<Conta>();
			Collection<Integer> contasGeralAAtualizar = new ArrayList<Integer>();
			SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

			while(colecaoContasIt.hasNext()){
				conta = (Conta) colecaoContasIt.next();

				// Carregando a conta que está na base
				filtroConta = (FiltroConta) conta.retornaFiltro();
				filtroConta.adicionarCaminhoParaCarregamentoEntidade("imovel.quadra");
				filtroConta.adicionarCaminhoParaCarregamentoEntidade("imovel.rota");
				filtroConta.adicionarCaminhoParaCarregamentoEntidade("imovel");
				colecaoContaNaBase = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());
				filtroConta.limparListaParametros();

				conta = (Conta) Util.retonarObjetoDeColecao(colecaoContaNaBase);

				boolean verificarConta = false;
				for(int i = 0; i < arrayIdentificadores.length; i++){
					Integer contaVerificacao = Util.obterInteger(arrayIdentificadores[i].split("-")[0]);
					if(contaVerificacao != null && conta.getId().equals(contaVerificacao)){
						verificarConta = true;
					}
				}

				if(verificarConta){
					String qtdDiasVencimento = (String) ParametroFaturamento.P_QUANTIDADE_DIAS_VENCIMENTO_DEBITO_AUTOMATICO.executar();

					Date dataParamentro = null;
					if(!qtdDiasVencimento.equals("") && qtdDiasVencimento != null){
						dataParamentro = Util.adicionarNumeroDiasDeUmaData(new Date(), Util.obterInteger(qtdDiasVencimento).intValue());
						if(Util.compararData(conta.getDataVencimentoConta(), dataParamentro) > 0){
							// [SB0002] - Trata Movimento Débito Automático.
							this.gerarDebitoAutomaticoMovimentoCancelarConta(conta);
						}
					}

				}
				for(int index = 0; index < arrayIdentificadores.length; index++){

					String dadosConta = arrayIdentificadores[index];
					String[] idUltimaAlteracao = dadosConta.split("-");

					// Contas que serão canceladas pelo sistema
					if(conta.getId().equals(Integer.valueOf(idUltimaAlteracao[0]))){
						Conta contaTemp = new Conta();
						// Faz-se uma cópia da conta
						try{
							// Para se fazer uma cópia usando BeanUtils é nesserário que os
							// BigDecimal estam inicializados.
							if(conta.getValorAgua() == null){
								conta.setValorAgua(new BigDecimal("0.00"));
							}
							if(conta.getValorCreditos() == null){
								conta.setValorCreditos(new BigDecimal("0.00"));
							}
							if(conta.getDebitos() == null){
								conta.setDebitos(new BigDecimal("0.00"));
							}
							if(conta.getValorEsgoto() == null){
								conta.setValorEsgoto(new BigDecimal("0.00"));
							}
							if(conta.getValorImposto() == null){
								conta.setValorImposto(new BigDecimal("0.00"));
							}
							if(conta.getPercentualEsgoto() == null){
								conta.setPercentualEsgoto(new BigDecimal("0.00"));
							}
							PropertyUtils.copyProperties(contaTemp, conta);
						}catch(IllegalAccessException e){
							throw new ControladorException("erro.sistema", e);
						}catch(InvocationTargetException e){
							throw new ControladorException("erro.sistema", e);
						}

						// Atualiza os dados do objeto
						contaTemp.setDataCancelamento(new Date());
						contaTemp.setContaMotivoCancelamento(contaMotivoCancelamento);
						contaTemp.setDebitoCreditoSituacaoAnterior(null);
						DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao();
						debitoCreditoSituacaoAtual.setId(DebitoCreditoSituacao.CANCELADA);
						contaTemp.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);
						contaTemp.setReferenciaContabil(sistemaParametro.getAnoMesFaturamento());
						contaTemp.setUsuario(usuarioLogado);

						// RA informado
						if(!Util.isVazioOuBranco(numeroRA)){
							RegistroAtendimento registroAtendimento = new RegistroAtendimento();

							registroAtendimento.setId(Integer.valueOf(numeroRA));

							contaTemp.setRegistroAtendimento(registroAtendimento);
						}

						// ---- REGISTRAR TRANSAÇÃO - CANCELAR CONTA ----
						RegistradorOperacao registradorOperacaoConta = new RegistradorOperacao(Operacao.OPERACAO_CANCELAR_CONTA, contaTemp
										.getImovel().getId(), contaTemp.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
										UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						registradorOperacaoConta.registrarOperacao(contaTemp);
						getControladorTransacao().registrarTransacao(contaTemp);
						// ------------ REGISTRAR TRANSAÇÃO - CANCELAR CONTA ----------------

						// Adiciona na Collection

						contasARemover.add(contaTemp);

						// Registrar Lançamento Contabil
						if(contaMotivoCancelamento.getId().equals(ConstantesSistema.CANCELAR_CONTA_PREFEITURA)){
							getControladorContabil().registrarLancamentoContabil(conta, OperacaoContabil.CANCELAR_CONTA_PREFEITURA);
						}else if(contaMotivoCancelamento.getId().equals(ConstantesSistema.CANCELAR_CONTA_APT)){
							getControladorContabil().registrarLancamentoContabil(conta, OperacaoContabil.CANCELAR_CONTA_APT);
						}else if(contaMotivoCancelamento.getId().equals(ConstantesSistema.CANCELAR_CONTA_PRESCRICAO)){
							getControladorContabil().registrarLancamentoContabil(conta, OperacaoContabil.CANCELAR_CONTA_PRESCRICAO);
						}else{
							getControladorContabil().registrarLancamentoContabil(conta, OperacaoContabil.CANCELAR_CONTA);
						}

						// Adiciona na Collection contasGeralAAtualizar os IDs dos objetos
						// ContaGeral que devem ser atualizados
						contasGeralAAtualizar.add(contaTemp.getId());

						// TODO Cancelar Conta
						/*
						 * Alterações solicitadas em 05/08/2011 para:
						 * - Atualizar os itens de Negativação;
						 * - NMRI_ICSITDEFINITIVA = 1
						 */
						this.getControladorSpcSerasa().verificarHaRelacaoCancelamentoComItensNegativacaoCancelarConta(contaTemp);

						// [SB0004] - Verificar Geracao de Credito A Realizar de Devolucao
						this.gerarCreditoARealizarDevolucao(contaTemp.getId());
					}
				}
			}

			// [UC0566 – Gerar Histograma de Água e Esgoto]
			carregarContaParaHistograma(contasARemover);
			getControladorHistograma().gerarHistogramaAguaEsgoto(contasARemover, ConstantesSistema.GERACAO_HISTOGRAMA_CANCELAMENTO);

			if(contasARemover != null && !contasARemover.isEmpty() && contasARemover.iterator().next() != null){
				if(sistemaParametro != null && sistemaParametro.getAnoMesFaturamento() != null){
					transferirContasParaHistorico(contasARemover, sistemaParametro.getAnoMesFaturamento());
				}
			}

			// Indicador atualizado no método transferirContasParaHistorico(...)
			// atualizarIndicadorContaNoHistorico(contasGeralAAtualizar);

			// 7. Caso exista pagamento para conta, classificar pagamento de conta
			// [UC0300 – ClassificarPagamentosDevolucoes]
			if(contasARemover != null && !contasARemover.isEmpty()){

				for(Conta contaClassificar : contasARemover){
					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.IMOVEL_ID, contaClassificar.getImovel().getId()));
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ANO_MES_REFERENCIA_PAGAMENTO, Integer
									.valueOf(contaClassificar.getReferencia())));

					Collection<Pagamento> colecaoPagamentos = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

					if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){
						// ** Alteração do Classificar **
						// getControladorArrecadacao().classificarPagamentos(colecaoPagamentos.iterator().next());
						getControladorArrecadacao()
										.classificarPagamentosRegistroMovimentoArrecadadores(colecaoPagamentos.iterator().next());
						// ** Alteração do Classificar **
					}

					/**
					 * Chamar metodo para realizar Contra-ação
					 * Andre Nishimura 26/04/2010
					 */
					getControladorCobranca().validaDocumentoCobrancaPagamentoParaContraAcao(contaClassificar.getId());
				}

			}

			/*
			 * TODO Provavelmente entrará aqui o [UC0207 – Gerar/Atualizar Resumo de Faturamento]
			 * após as especificações.
			 */

			// Verificar e Atualizar Itens Documento de Cobrança e da Cobrança Administrativa
			if(!Util.isVazioOrNulo(contasGeralAAtualizar)){
				for(Integer idContaAux : contasGeralAAtualizar){
					// Verifica se há relação entre a conta cancelada e algum item de documento de
					// cobrança - [UC3082] Atualizar Item Documento Cobrança
					this.getControladorCobranca().atualizarItemDocumentoCobranca(idContaAux, null, null, null,
									CobrancaDebitoSituacao.CANCELADO, new Date(), CobrancaDebitoSituacao.PENDENTE);
				}

				this.atualizarCobrancaDocumentoItemContaCobrancaAdministrativa(contasGeralAAtualizar);
			}

			// Encerrar o registro de atendimento - [UC0435 - Encerrar Registro de Atendimento]
			if(!Util.isVazioOuBranco(numeroRA)){
				Collection colecaoRegistroAtendimento = null;
				ClienteImovel clienteImovel = null;

				// Recuperda dados do RA informado
				FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();
				filtroRegistroAtendimento.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimento.ID, numeroRA));

				filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade(FiltroRegistroAtendimento.IMOVEL);

				colecaoRegistroAtendimento = Fachada.getInstancia().pesquisar(filtroRegistroAtendimento,
								RegistroAtendimento.class.getName());

				// Caso o registro de atendimento informado exista
				if(!Util.isVazioOrNulo(colecaoRegistroAtendimento)){
					RegistroAtendimento ra = (RegistroAtendimento) Util.retonarObjetoDeColecao(colecaoRegistroAtendimento);

					// Consulta o cliente do imóvel
					FiltroClienteImovel filtroClienteImovel = new FiltroClienteImovel();

					filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.IMOVEL_ID, ra.getImovel().getId()));
					filtroClienteImovel.adicionarParametro(new ParametroNulo(FiltroClienteImovel.DATA_FIM_RELACAO));
					filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.CLIENTE_RELACAO_TIPO_DESCRICAO,
									ClienteRelacaoTipo.DESCRICAO_RESPONSAVEL));
					filtroClienteImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroClienteImovel.CLIENTE);

					Collection colecaoClienteImovel = Fachada.getInstancia().pesquisar(filtroClienteImovel, ClienteImovel.class.getName());

					if(!Util.isVazioOrNulo(colecaoClienteImovel)){
						clienteImovel = (ClienteImovel) Util.retonarObjetoDeColecao(colecaoClienteImovel);
					}

				}

				this.encerrarRegistroAtendimento(numeroRA, clienteImovel, usuarioLogado);
			}

		}catch(ControladorException e){
			sessionContext.setRollbackOnly();
			throw e;
		}catch(Exception e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Atualiza um objeto do tipo conta no BD
	 * 
	 * @param conta
	 * @throws ControladorException
	 */
	public void atualizarConta(Conta conta) throws ControladorException{

		// -----VALIDAÇÃO DOS TIMESTAMP PARA ATUALIZAÇÃO DE CADASTRO

		// Validação para conta
		if(conta != null){
			// Cria o filtro
			FiltroConta filtroConta = new FiltroConta();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = Conta.class.getName();

			// Seta os parametros do filtro
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, conta.getId()));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection contas = getControladorUtil().pesquisar(filtroConta, nomePacoteObjeto);
			Conta contaNaBase = (Conta) Util.retonarObjetoDeColecao(contas);

			// Verifica se a data de alteração do objeto gravado na base é
			// maior que a na instancia
			if((contaNaBase.getUltimaAlteracao().after(conta.getUltimaAlteracao()))){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.atualizacao.timestamp");
			}

			// Seta a data/hora
			conta.setUltimaAlteracao(new Date());

		}

		// Atualiza objeto
		getControladorUtil().atualizar(conta);

	}

	public void colocarRevisaoConta(Collection<Conta> colecaoContas, String identificadores, ContaMotivoRevisao contaMotivoRevisao,
					Usuario usuarioLogado) throws ControladorException{

		colocarRevisaoConta(colecaoContas, identificadores, contaMotivoRevisao, usuarioLogado, false);
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * [UC0148] - Colocar Conta em Revisão
	 * 
	 * @author Raphael Rossiter, Vivianne Sousa
	 * @date 21/12/2005,19/10/2006
	 * @param colecaoContas
	 * @param identificadores
	 * @param contaMotivoRevisao
	 * @throws ControladorException
	 */
	public void colocarRevisaoConta(Collection<Conta> colecaoContas, String identificadores, ContaMotivoRevisao contaMotivoRevisao,
					Usuario usuarioLogado, boolean considerarContasRevisao) throws ControladorException{

		Iterator colecaoContasIt = colecaoContas.iterator();
		Conta contaColecao;
		Conta contaNaBase;
		String[] arrayIdentificadores = new String[] {};

		// Verifica se retirará todas ou uma seleção das contas da coleção de
		// revisão
		if(identificadores != null){
			arrayIdentificadores = identificadores.split(",");
		}

		while(colecaoContasIt.hasNext()){
			contaColecao = (Conta) colecaoContasIt.next();
			contaNaBase = contaColecao;

			if(identificadores != null){
				for(int index = 0; index < arrayIdentificadores.length; index++){

					String dadosConta = arrayIdentificadores[index];
					String[] idUltimaAlteracao = dadosConta.split("-");

					// Contas que serão colocadas em revisão pelo sistema
					if(contaColecao.getId().equals(Integer.valueOf(idUltimaAlteracao[0]))){

						// Ultima alteração
						contaColecao.setUltimaAlteracao(new Date());

						// Data da revisão
						contaColecao.setDataRevisao(new Date());

						// Motivo da revisão
						contaColecao.setContaMotivoRevisao(contaMotivoRevisao);

						/*
						 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar na tabela de
						 * conta o usuário que está logado no sistema
						 */

						// Usuario
						contaColecao.setUsuario(usuarioLogado);

						// Verificar atualização realizada por outro usuário
						if((contaNaBase.getUltimaAlteracao().after(contaColecao.getUltimaAlteracao()))){
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.atualizacao.timestamp");
						}

						// ------------ <REGISTRAR
						// TRANSAÇÃO>----------------------------

						RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_COLOCAR_CONTA_REVISAO,
										contaColecao.getImovel().getId(), contaColecao.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
														UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						registradorOperacao.registrarOperacao(contaColecao);

						getControladorTransacao().registrarTransacao(contaColecao);

						// ------------ </REGISTRAR
						// TRANSAÇÃO>----------------------------

						try{
							repositorioFaturamento.colocarContaRevisao(contaColecao);
						}catch(ErroRepositorioException ex){
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", ex);
						}
					}
				}
			}else{

				// Ultima alteração
				contaColecao.setUltimaAlteracao(new Date());

				// Data da revisão
				contaColecao.setDataRevisao(new Date());

				// Motivo da revisão
				contaColecao.setContaMotivoRevisao(contaMotivoRevisao);

				/*
				 * Colocado por Raphael Rossiter em 09/08/2007 OBJETIVO: Gravar na tabela de conta o
				 * usuário que está logado no sistema
				 */

				// Usuario
				contaColecao.setUsuario(usuarioLogado);

				// Verificar atualização realizada por outro usuário
				if((contaNaBase.getUltimaAlteracao().after(contaColecao.getUltimaAlteracao()))){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.atualizacao.timestamp");
				}

				// ------------ <REGISTRAR
				// TRANSAÇÃO>----------------------------

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONTA_RETIFICAR, contaColecao
								.getImovel().getId(), contaColecao.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(contaColecao);

				getControladorTransacao().registrarTransacao(contaColecao);

				// ------------ </REGISTRAR
				// TRANSAÇÃO>----------------------------

				try{
					repositorioFaturamento.colocarContaRevisao(contaColecao);
				}catch(ErroRepositorioException ex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}
			}
		}
		// [UC0148][SB0001] Gerar Débito Automático
		gerarDebitoAutomaticoMovimentoColocarRevisaoConta(arrayIdentificadores, colecaoContas);
	}

	/**
	 * @author Bruno Ferreira dos Santos
	 * @date 19/08/2011
	 * @param arrayIdentificadores
	 * @param colecaoContaImovel
	 * @throws ControladorException
	 *             Correção!!!
	 * @author Yara T. Souza
	 * @date 02/11/2011
	 */
	private void gerarDebitoAutomaticoMovimentoColocarRevisaoConta(String[] arrayIdentificadores, Collection<Conta> colecaoContaImovel)
					throws ControladorException{

		Iterator it;
		it = colecaoContaImovel.iterator();

		FiltroConta filtroConta = new FiltroConta();
		while(it.hasNext()){
			Conta conta = (Conta) it.next();

			boolean atualizarMovimentoDebitoAutomatico = false;
			for(int i = 0; i < arrayIdentificadores.length; i++){
				Integer contaVerificacao = Util.obterInteger(arrayIdentificadores[i].split("-")[0]);
				if(conta.getId().equals(contaVerificacao)){
					atualizarMovimentoDebitoAutomatico = true;
				}
			}

			if(atualizarMovimentoDebitoAutomatico){

				filtroConta.limparListaParametros();
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, conta.getId()));
				filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.IMOVEL);

				conta = (Conta) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroConta, Conta.class.getName()));

				if(conta.getIndicadorDebitoConta() != null && conta.getIndicadorDebitoConta().equals(ConstantesSistema.SIM)){

					String qtdDiasVencimento = (String) ParametroFaturamento.P_QUANTIDADE_DIAS_VENCIMENTO_DEBITO_AUTOMATICO.executar();

					Date dataParamentro = null;
					if(!qtdDiasVencimento.equals("") && qtdDiasVencimento != null){
						dataParamentro = Util.adicionarNumeroDiasDeUmaData(new Date(), Util.obterInteger(qtdDiasVencimento).intValue());

						if(Util.compararData(conta.getDataVencimentoConta(), dataParamentro) > 0){

							DebitoAutomaticoMovimento debitoAutomaticoMovimento = this.getControladorArrecadacao()
											.pesquisarUltimoDebitoAutomaticoMovimentoConta(conta.getId());

							if(debitoAutomaticoMovimento != null){

								Boolean gerarMovCancelamento = Boolean.FALSE;
								Boolean gerarMovExclusao = Boolean.FALSE;

								if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
												&& debitoAutomaticoMovimento.getIndicadorExclusao() == null
												&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() == null){

									gerarMovCancelamento = Boolean.TRUE;

								}else if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
												&& debitoAutomaticoMovimento.getIndicadorExclusao() != null
												&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() != null){

									gerarMovExclusao = Boolean.TRUE;

								}else if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() != null
												&& debitoAutomaticoMovimento.getIndicadorExclusao() == null){

									gerarMovExclusao = Boolean.TRUE;

								}

								if(gerarMovCancelamento){

									DebitoAutomaticoMovimentoCancelamentoMotivo damc = new DebitoAutomaticoMovimentoCancelamentoMotivo();
									damc.setId(DebitoAutomaticoMovimentoCancelamentoMotivo.INCLUSAO_CONTA_REVISAO);
									debitoAutomaticoMovimento.setDebitoAutomaticoMovimentoCancelamentoMotivo(damc);
									debitoAutomaticoMovimento.setUltimaAlteracao(new Date());

									this.getControladorUtil().atualizar(debitoAutomaticoMovimento);

								}else if(gerarMovExclusao){

									FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
									filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, conta.getId()));

									Collection colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral,
													ContaGeral.class.getName());

									ContaGeral contaGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);

									// Gera movimento de exclusão.
									DebitoAutomaticoMovimento debitoAutomaticoMovimentoNovo = new DebitoAutomaticoMovimento();
									debitoAutomaticoMovimentoNovo.setDebitoAutomatico(debitoAutomaticoMovimento.getDebitoAutomatico());
									debitoAutomaticoMovimentoNovo.setValorDebito(debitoAutomaticoMovimento.getValorDebito());
									debitoAutomaticoMovimentoNovo.setContaGeral(contaGeral);
									debitoAutomaticoMovimentoNovo.setDataVencimento(debitoAutomaticoMovimento.getDataVencimento());
									debitoAutomaticoMovimentoNovo.setFaturamentoGrupo(debitoAutomaticoMovimento.getFaturamentoGrupo());
									debitoAutomaticoMovimentoNovo.setProcessamento(new Date());
									debitoAutomaticoMovimentoNovo.setUltimaAlteracao(new Date());
									debitoAutomaticoMovimentoNovo.setIndicadorExclusao(ConstantesSistema.SIM);

									this.getControladorUtil().inserir(debitoAutomaticoMovimentoNovo);

								}

							}

						}else{

							throw new ControladorException("atencao.conta_colocada_revisao_porem_debito_automatico_nao_cancelado");

						}

					}

				}

			}

		}

	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * [UC0149] - Retirar Conta de Revisão
	 * 
	 * @author Raphael Rossiter ,Vivianne Sousa
	 * @date 22/12/2005, 19/10/2006
	 * @param colecaoContas
	 * @param identificadores
	 * @throws ControladorException
	 */
	public Collection<ContaRetiradaRevisaoHelper> retirarRevisaoConta(Collection<Conta> colecaoContas, String identificadores,
					Usuario usuarioLogado) throws ControladorException{

		Iterator colecaoContasIt = colecaoContas.iterator();
		Collection<ContaRetiradaRevisaoHelper> colecaoContasParaRelatorio = new ArrayList<ContaRetiradaRevisaoHelper>();
		Conta contaColecao;
		Collection colecaoContaNaBase;
		Conta contaNaBase;

		String[] arrayIdentificadores = null;
		FiltroConta filtroConta = new FiltroConta();

		// Verifica se retirará todas ou uma seleção das contas da coleção de
		// revisão
		if(identificadores != null){
			arrayIdentificadores = identificadores.split(",");
		}

		while(colecaoContasIt.hasNext()){
			contaColecao = (Conta) colecaoContasIt.next();

			// Carregando a conta que está na base
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, contaColecao.getId()));
			filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.CONTA_MOTIVO_REVISAO);

			colecaoContaNaBase = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());
			contaNaBase = (Conta) Util.retonarObjetoDeColecao(colecaoContaNaBase);
			
			if(contaNaBase.getContaMotivoRevisao() != null){
				// Preenche o Helper e adiciona na collection para enviar para o relatorio
				ContaRetiradaRevisaoHelper contaRetiradaRevisaoHelper = new ContaRetiradaRevisaoHelper();
				contaRetiradaRevisaoHelper
								.setDataRevisao(Util.formatarDataComTracoAAAAMMDD(contaNaBase.getDataRevisao()).replace("-", "/"));
				contaRetiradaRevisaoHelper.setDataVencimento(Util.formatarDataComTracoAAAAMMDD(contaNaBase.getDataVencimentoConta())
								.replace("-", "/"));
				contaRetiradaRevisaoHelper.setDescricaoMotivo(contaNaBase.getContaMotivoRevisao().getDescricaoMotivoRevisaoConta());
				contaRetiradaRevisaoHelper.setMatricula(contaNaBase.getImovel().getId().toString());
				contaRetiradaRevisaoHelper.setMotivo(contaNaBase.getContaMotivoRevisao().getId().toString());
				contaRetiradaRevisaoHelper.setReferencia(Util.formatarMesAnoParaAnoMesComBarra(contaNaBase.getReferenciaFormatada()));
				contaRetiradaRevisaoHelper.setQtdDiasRevisao(Integer.toString((int) Math.ceil(Util.calcularDiferencaEntreDatas(
								contaNaBase.getDataRevisao(), new Date(), ConstantesSistema.DIFERENCA_DIAS).doubleValue())));

				colecaoContasParaRelatorio.add(contaRetiradaRevisaoHelper);
			}

			filtroConta.limparListaParametros();

			if(identificadores != null){

				for(int index = 0; index < arrayIdentificadores.length; index++){

					String dadosConta = arrayIdentificadores[index];
					String[] idUltimaAlteracao = dadosConta.split("-");

					// Contas que serão retiradas de revisão pelo sistema
					if(contaColecao.getId().equals(Integer.valueOf(idUltimaAlteracao[0]))){

						// [FS0015] - Verificar contas que não estejam em
						// revisão
						if(contaNaBase.getContaMotivoRevisao() == null){
							throw new ControladorException("atencao.data_revisao_nao_existente");
						}

						// Data da revisão (NULL)
						contaColecao.setDataRevisao(null);

						// Motivo da revisão (NULL)
						contaColecao.setContaMotivoRevisao(null);

						// Verificar atualização realizada por outro usuário
						if((contaNaBase.getUltimaAlteracao().after(contaColecao.getUltimaAlteracao()))){
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.atualizacao.timestamp");
						}

						// Ultima alteração
						contaColecao.setUltimaAlteracao(new Date());

						// ------------ <REGISTRAR
						// TRANSAÇÃO>----------------------------

						RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_RETIRAR_CONTA_REVISAO,
										contaColecao.getImovel().getId(), contaColecao.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
														UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						registradorOperacao.registrarOperacao(contaColecao);

						getControladorTransacao().registrarTransacao(contaColecao);

						// ------------ </REGISTRAR
						// TRANSAÇÃO>----------------------------

						// UPDATE
						try{
							repositorioFaturamento.retirarContaRevisao(contaColecao);
						}catch(ErroRepositorioException ex){
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", ex);
						}
					}
				}
			}else{

				// [FS0015] - Verificar contas que não estejam em revisão
				if(contaColecao.getDataRevisao() == null){
					throw new ControladorException("atencao.data_revisao_nao_existente");
				}

				// Data da revisão (NULL)
				contaColecao.setDataRevisao(null);

				// Motivo da revisão (NULL)
				contaColecao.setContaMotivoRevisao(null);

				// Verificar atualização realizada por outro usuário
				if((contaNaBase.getUltimaAlteracao().after(contaColecao.getUltimaAlteracao()))){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.atualizacao.timestamp");
				}

				// Ultima alteração
				contaColecao.setUltimaAlteracao(new Date());

				// ------------ <REGISTRAR
				// TRANSAÇÃO>----------------------------

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_RETIRAR_CONTA_REVISAO, contaColecao
								.getImovel().getId(), contaColecao.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(contaColecao);

				getControladorTransacao().registrarTransacao(contaColecao);

				// ------------ </REGISTRAR
				// TRANSAÇÃO>----------------------------

				// UPDATE
				try{
					repositorioFaturamento.retirarContaRevisao(contaColecao);
				}catch(ErroRepositorioException ex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}
			}
		}
		// [UC0149][SB0001] Gerar Débito Automático
		 this.gerarDebitoAutomaticoMovimentoRetirarRevisaoConta(arrayIdentificadores, colecaoContas);
		
		return colecaoContasParaRelatorio;

	}

	/**
	 * @author Bruno Ferreira dos Santos
	 * @date 19/08/2011
	 * @param arrayIdentificadores
	 * @param colecaoContaImovel
	 * @throws ControladorException
	 *             Correção!!!
	 * @author Yara T. Souza
	 * @date 02/11/2011
	 */
	private void gerarDebitoAutomaticoMovimentoRetirarRevisaoConta(String[] arrayIdentificadores, Collection<Conta> colecaoContaImovel)
					throws ControladorException{

		Iterator it;
		it = colecaoContaImovel.iterator();

		FiltroConta filtroConta = new FiltroConta();
		while(it.hasNext()){
			Conta conta = (Conta) it.next();

			boolean atualizarMovimentoDebitoAutomatico = false;
			if(arrayIdentificadores == null){
				atualizarMovimentoDebitoAutomatico = true;
			}else{
				for(int i = 0; i < arrayIdentificadores.length; i++){
					Integer contaVerificacao = Util.obterInteger(arrayIdentificadores[i].split("-")[0]);
					if(conta.getId().equals(contaVerificacao)){
						atualizarMovimentoDebitoAutomatico = true;
					}
				}
			}

			if(atualizarMovimentoDebitoAutomatico){

				filtroConta.limparListaParametros();
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, conta.getId()));
				filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.IMOVEL);

				conta = (Conta) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroConta, Conta.class.getName()));

				if(conta.getIndicadorDebitoConta() != null && conta.getIndicadorDebitoConta().equals(ConstantesSistema.SIM)){

					String qtdDiasVencimento = (String) ParametroFaturamento.P_QUANTIDADE_DIAS_VENCIMENTO_DEBITO_AUTOMATICO.executar();

					Date dataParamentro = null;

					if(!qtdDiasVencimento.equals("") && qtdDiasVencimento != null){

						dataParamentro = Util.adicionarNumeroDiasDeUmaData(new Date(), Util.obterInteger(qtdDiasVencimento).intValue());

						if(Util.compararData(conta.getDataVencimentoConta(), dataParamentro) > 0){

							DebitoAutomaticoMovimento debitoAutomaticoMovimento = this.getControladorArrecadacao()
											.pesquisarUltimoDebitoAutomaticoMovimentoConta(conta.getId());

							if(debitoAutomaticoMovimento != null){

								Boolean gerarMovInclusao = Boolean.FALSE;
								Boolean gerarMovCancelamento = Boolean.FALSE;

								if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
												&& debitoAutomaticoMovimento.getIndicadorExclusao() == null
												&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() != null){

									gerarMovInclusao = Boolean.TRUE;

								}else if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
												&& debitoAutomaticoMovimento.getIndicadorExclusao() != null
												&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() == null){

									gerarMovCancelamento = Boolean.TRUE;

								}else if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() != null
												&& debitoAutomaticoMovimento.getIndicadorExclusao() != null){

									gerarMovInclusao = Boolean.TRUE;

								}

								if(gerarMovInclusao){

									FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
									filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, conta.getId()));

									Collection colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral,
													ContaGeral.class.getName());

									ContaGeral contaGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);

									DebitoAutomaticoMovimento debitoAutomaticoMovimentoNovo = new DebitoAutomaticoMovimento();
									debitoAutomaticoMovimentoNovo.setDebitoAutomatico(debitoAutomaticoMovimento.getDebitoAutomatico());
									debitoAutomaticoMovimentoNovo.setValorDebito(debitoAutomaticoMovimento.getValorDebito());
									debitoAutomaticoMovimentoNovo.setContaGeral(contaGeral);
									debitoAutomaticoMovimentoNovo.setDataVencimento(conta.getDataVencimentoConta());
									debitoAutomaticoMovimentoNovo.setFaturamentoGrupo(this.obterFaturamentoGrupoImovel(conta.getImovel()
													.getId()));
									debitoAutomaticoMovimentoNovo.setProcessamento(new Date());
									debitoAutomaticoMovimentoNovo.setUltimaAlteracao(new Date());

									this.getControladorUtil().inserir(debitoAutomaticoMovimentoNovo);

								}else if(gerarMovCancelamento){

									// Cancela o movimento de débito automático.
									DebitoAutomaticoMovimentoCancelamentoMotivo damc = new DebitoAutomaticoMovimentoCancelamentoMotivo();
									damc.setId(DebitoAutomaticoMovimentoCancelamentoMotivo.RETIRADA_CONTA_REVISAO);
									debitoAutomaticoMovimento.setDebitoAutomaticoMovimentoCancelamentoMotivo(damc);
									debitoAutomaticoMovimento.setUltimaAlteracao(new Date());

									this.getControladorUtil().atualizar(debitoAutomaticoMovimento);

								}

							}else{

								// Código comentado para atender OC0774598
								// essa mensagem não pode impedir a conclusão do processo
								// a forma de tratamento para essa situação será tratada
								// posteriormente.

								// throw new
								// ControladorException("atencao.conta_retirada_revisao_porem_debito_automatico_nao_cancelado");
								System.out.println("Conta: "
												+ conta.getId()
												+ " retirada de revisão com sucesso,porém não existe tempo hábil para envio, cancelamento ou exclusão do movimento de débito automático.");

							}

						}

					}

				}

			}

		}

	}

	/**
	 * Método responsável por realizar a alteração da data de vencimento da conta. [UC0151] -
	 * Alterar Vencimento de Conta
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 22/12/2005, 22/11/2006
	 * @author Virgínia Melo
	 * @date 18/02/2009 Troca da mensagem de exceção.
	 * @param colecaoContas
	 * @param identificadores
	 * @param dataVencimento
	 * @throws ControladorException
	 */
	public void alterarVencimentoConta(Collection<Conta> colecaoContas, String identificadores, Date dataVencimento, Usuario usuarioLogado)
					throws ControladorException{

		Iterator colecaoContasIt = colecaoContas.iterator();
		Conta contaColecao;
		Conta contaNaBase = null;
		String[] arrayIdentificadores = null;

		// Verifica se retirará todas ou uma seleção das contas da coleção de revisão
		if(identificadores != null){
			arrayIdentificadores = identificadores.split(",");
		}

		// Verifica se a data de vencimento é um dia útil. Se não for, pega a data posterior
		// útil.
		Collection<NacionalFeriado> colecaoferiadoNacional = getControladorUtil().pesquisarFeriadosNacionais();
		boolean adiarData = true;

		while(adiarData){

			if(Util.ehDiaUtil(dataVencimento, colecaoferiadoNacional, null)){

				adiarData = false;
			}else{

				dataVencimento = Util.adicionarNumeroDiasDeUmaData(dataVencimento, 1);
			}
		}

		while(colecaoContasIt.hasNext()){
			contaColecao = (Conta) colecaoContasIt.next();

			FiltroConta filtroConta = new FiltroConta();
			filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, contaColecao.getId()));
			Collection<Conta> colecaoTemp = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

			if(colecaoTemp != null && !colecaoTemp.isEmpty()){
				contaNaBase = colecaoTemp.iterator().next();
			}

			if(identificadores != null){

				for(int index = 0; index < arrayIdentificadores.length; index++){

					String dadosConta = arrayIdentificadores[index];
					String[] idUltimaAlteracao = dadosConta.split("-");

					// Contas que sofrerão alteração na sua data de vencimento
					if(contaColecao.getId().equals(Integer.valueOf(idUltimaAlteracao[0]))){

						// Data de Vencimento
						contaColecao.setDataVencimentoConta(dataVencimento);



						// Data de validade
						Date dataValidadeConta = this.retornaDataValidadeConta(dataVencimento);
						contaColecao.setDataValidadeConta(dataValidadeConta);

						// Indicador de alteração de vencimento da conta
						contaColecao.setIndicadorAlteracaoVencimento(Conta.INDICADOR_ALTERACAO_VENCIMENTO_ATIVO);

						// Última alteraçao
						contaColecao.setUltimaAlteracao(new Date());

						// Verificar atualização realizada por outro usuário
						if(contaNaBase != null && (contaNaBase.getUltimaAlteracao().after(contaColecao.getUltimaAlteracao()))){
							sessionContext.setRollbackOnly();
							throw new ControladorException("atencao.atualizacao.timestamp");
						}

						contaNaBase.setDataVencimentoConta(dataVencimento);

						verificarVencimentoContaDebitoAutomatico(contaNaBase);

						// ------------ <REGISTRAR TRANSAÇÃO>----------------------------

						if(usuarioLogado != null){
							RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ALTERAR_VENCIMENTO_CONTA,
											contaColecao.getImovel().getId(), contaColecao.getId(), new UsuarioAcaoUsuarioHelper(
															usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

							registradorOperacao.registrarOperacao(contaColecao);

							getControladorTransacao().registrarTransacao(contaColecao);
						}
						// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

						// UPDATE
						try{
							repositorioFaturamento.alterarVencimentoConta(contaColecao);
						}catch(ErroRepositorioException ex){
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", ex);
						}

						if(contaNaBase.getIndicadorDebitoConta() != null
										&& contaNaBase.getIndicadorDebitoConta().equals(ConstantesSistema.SIM)){

							this.gerarDebitoAutomaticoMovimentoConta(contaNaBase, contaColecao, false);

						}

					}

				}

			}else{

				// Data de Vencimento
				contaColecao.setDataVencimentoConta(dataVencimento);

				// Data de validade
				Date dataValidadeConta = this.retornaDataValidadeConta(dataVencimento);
				contaColecao.setDataValidadeConta(dataValidadeConta);

				// Indicador de alteração de vencimento da conta
				contaColecao.setIndicadorAlteracaoVencimento(Conta.INDICADOR_ALTERACAO_VENCIMENTO_ATIVO);

				// Última alteraçao
				contaColecao.setUltimaAlteracao(new Date());

				// Verificar atualização realizada por outro usuário
				if((contaNaBase.getUltimaAlteracao().after(contaColecao.getUltimaAlteracao()))){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");
				}

				// ------------ <REGISTRAR TRANSAÇÃO>----------------------------
				if(usuarioLogado != null){
					RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONTA_RETIFICAR,
									contaColecao.getImovel() != null ? contaColecao.getImovel().getId() : contaColecao.getId(),
									contaColecao.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
													UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacao.registrarOperacao(contaColecao);

					getControladorTransacao().registrarTransacao(contaColecao);
				}
				// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

				// UPDATE

				try{

					repositorioFaturamento.alterarVencimentoConta(contaColecao);

				}catch(ErroRepositorioException ex){

					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);

				}

				if(contaNaBase.getIndicadorDebitoConta() != null && contaNaBase.getIndicadorDebitoConta().equals(ConstantesSistema.SIM)){

					this.gerarDebitoAutomaticoMovimentoConta(contaNaBase, contaColecao, false);

				}

			}

		}

	}

	/**
	 * Author: Raphael Rossiter
	 * 
	 * @param dataVencimento
	 * @return data de validade da conta de acordo com a date de vencimento recebida
	 * @throws ControladorException
	 */
	protected Date retornaDataValidadeConta(Date dataVencimento) throws ControladorException{

		Date retorno = null;

		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

		Calendar dataValidadeConta = new GregorianCalendar();
		dataValidadeConta.setTime(dataVencimento);

		// Último dia do mês correspondente ao mês da data de vencimento da
		// conta
		dataValidadeConta.set(Calendar.DATE, 1);
		dataValidadeConta.add(Calendar.MONTH, 1);
		dataValidadeConta.add(Calendar.DATE, -1);

		// Acrescenta o número de meses de validade da conta
		dataValidadeConta.add(Calendar.MONTH, sistemaParametro.getNumeroMesesValidadeConta().intValue());

		retorno = dataValidadeConta.getTime();

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Raphael Rossiter Data: 26/12/2005
	 * 
	 * @param conta
	 * @return uma coleção com os débitos cobrados de uma conta
	 * @throws ControladorException
	 * @throws
	 */
	public Collection<DebitoCobrado> obterDebitosCobradosConta(Conta conta) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDebitoCobradoArray = null;

		try{
			colecaoDebitoCobradoArray = repositorioFaturamento.buscarDebitosCobradosConta(conta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDebitoCobradoArray != null && !colecaoDebitoCobradoArray.isEmpty()){

			Iterator colecaoDebitoCobradoArrayIterator = colecaoDebitoCobradoArray.iterator();

			while(colecaoDebitoCobradoArrayIterator.hasNext()){

				// Obtém os dados do débito cobrado
				Object[] debitoCobradoArray = (Object[]) colecaoDebitoCobradoArrayIterator.next();

				DebitoCobrado debitoCobrado = new DebitoCobrado();

				// ID do débito
				debitoCobrado.setId((Integer) debitoCobradoArray[0]);

				// Tipo do débito
				FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
				financiamentoTipo.setId((Integer) debitoCobradoArray[10]);
				LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
				lancamentoItemContabil.setId((Integer) debitoCobradoArray[11]);

				DebitoTipo debitoTipo = new DebitoTipo();

				debitoTipo.setId((Integer) debitoCobradoArray[1]);
				debitoTipo.setDescricao(String.valueOf(debitoCobradoArray[2]));
				debitoTipo.setDescricaoAbreviada(String.valueOf(debitoCobradoArray[9]));
				debitoTipo.setFinanciamentoTipo(financiamentoTipo);
				debitoTipo.setLancamentoItemContabil(lancamentoItemContabil);

				debitoCobrado.setDebitoTipo(debitoTipo);

				// Ano e Mês do débito
				if(debitoCobradoArray[3] != null){
					debitoCobrado.setAnoMesReferenciaDebito((Integer) debitoCobradoArray[3]);
				}

				// Ano e Mês de cobrança do débito
				if(debitoCobradoArray[4] != null){
					debitoCobrado.setAnoMesCobrancaDebito((Integer) debitoCobradoArray[4]);
				}

				// Número de prestações
				debitoCobrado.setNumeroPrestacao((Short) debitoCobradoArray[5]);

				// Número da prestação
				debitoCobrado.setNumeroPrestacaoDebito((Short) debitoCobradoArray[6]);

				// Valor do débito
				debitoCobrado.setValorPrestacao((BigDecimal) debitoCobradoArray[7]);

				// Ultima alteração
				String ultimaAlteracao = String.valueOf(debitoCobradoArray[8]);

				SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

				Date dataUltimaAlteracao;

				try{
					dataUltimaAlteracao = formatoData.parse(ultimaAlteracao);
				}catch(java.text.ParseException e){
					dataUltimaAlteracao = null;
				}

				debitoCobrado.setUltimaAlteracao(dataUltimaAlteracao);

				debitoCobrado.setIndicadorRemuneraCobrancaAdministrativa((Short) debitoCobradoArray[12]);
				
				Parcelamento parcelamento = null;
				if(debitoCobradoArray[13] != null){
					parcelamento = new Parcelamento();
					parcelamento.setId((Integer) debitoCobradoArray[13]);
				}

				debitoCobrado.setParcelamento(parcelamento);
				
				retorno.add(debitoCobrado);
			}
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Tiago Moreno Data: 28/07/2007
	 * 
	 * @throws ControladorException
	 * @throws
	 * @deprecated
	 */
	public Collection<DebitoCobradoAgrupadoHelper> obterDebitosCobradosContaCAERN(Conta conta) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDebitoCobradoArray = null;

		try{
			colecaoDebitoCobradoArray = repositorioFaturamento.buscarDebitosCobradosEmitirContaCaern(conta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDebitoCobradoArray != null && !colecaoDebitoCobradoArray.isEmpty()){

			Iterator colecaoDebitoCobradoArrayIterator = colecaoDebitoCobradoArray.iterator();

			while(colecaoDebitoCobradoArrayIterator.hasNext()){

				// Obtém os dados do débito cobrado
				Object[] debitoCobradoArray = (Object[]) colecaoDebitoCobradoArrayIterator.next();

				DebitoCobradoAgrupadoHelper debitoCobrado = new DebitoCobradoAgrupadoHelper();

				// ID do débito
				debitoCobrado.setIdDebitoTipo((Integer) debitoCobradoArray[0]);

				DebitoTipo debitoTipo = new DebitoTipo();

				debitoCobrado.setDescricaoDebitoTipo((String) debitoCobradoArray[1]);
				debitoCobrado.setNumeroPrestacao(Integer.valueOf((Short) debitoCobradoArray[2]));
				debitoCobrado.setNumeroPrestacaoDebito(Integer.valueOf((Short) debitoCobradoArray[3]));
				debitoCobrado.setValorDebito((BigDecimal) debitoCobradoArray[4]);

				retorno.add(debitoCobrado);
			}
		}

		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta
	 * 
	 * @author: Raphael Rossiter
	 * @date: 28/12/2005
	 * @author Virgínia Melo
	 * @date 13/01/2009 Trecho de código com erro retirado.
	 * @param conta
	 * @return uma coleção com os créditoa realizados de uma conta
	 * @throws ControladorException
	 */
	public Collection<CreditoRealizado> obterCreditosRealizadosConta(Conta conta) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoCreditoRealizadoArray = null;

		try{
			colecaoCreditoRealizadoArray = repositorioFaturamento.buscarCreditosRealizadosConta(conta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoCreditoRealizadoArray != null && !colecaoCreditoRealizadoArray.isEmpty()){

			Iterator colecaoCreditoRealizadoArrayIterator = colecaoCreditoRealizadoArray.iterator();

			while(colecaoCreditoRealizadoArrayIterator.hasNext()){

				// Obtém os dados do crédito realizado
				Object[] creditoRealizadoArray = (Object[]) colecaoCreditoRealizadoArrayIterator.next();

				CreditoRealizado creditoRealizado = new CreditoRealizado();

				// ID do crédito
				creditoRealizado.setId((Integer) creditoRealizadoArray[0]);

				// Tipo do crédito
				LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
				lancamentoItemContabil.setId((Integer) creditoRealizadoArray[10]);

				CreditoTipo creditoTipo = new CreditoTipo();
				creditoTipo.setId((Integer) creditoRealizadoArray[1]);
				creditoTipo.setDescricao(String.valueOf(creditoRealizadoArray[2]));
				creditoTipo.setDescricaoAbreviada(String.valueOf(creditoRealizadoArray[3]));
				creditoRealizado.setCreditoTipo(creditoTipo);

				creditoTipo.setLancamentoItemContabil(lancamentoItemContabil);

				// LancamentoItemContabil do Credito Realizado
				LancamentoItemContabil lancamentoItemContabilDoCredito = new LancamentoItemContabil();
				lancamentoItemContabilDoCredito.setId((Integer) creditoRealizadoArray[15]);

				creditoRealizado.setLancamentoItemContabil(lancamentoItemContabilDoCredito);

				// Ano e Mês do crédito
				if(creditoRealizadoArray[4] != null){
					creditoRealizado.setAnoMesReferenciaCredito((Integer) creditoRealizadoArray[4]);
				}

				// Ano e Mês de cobrança do crédito
				if(creditoRealizadoArray[5] != null){
					creditoRealizado.setAnoMesCobrancaCredito((Integer) creditoRealizadoArray[5]);
				}

				// Número de prestações
				creditoRealizado.setNumeroPrestacao((Short) creditoRealizadoArray[6]);

				// Número da prestação
				creditoRealizado.setNumeroPrestacaoCredito((Short) creditoRealizadoArray[7]);

				// Valor do crédito
				creditoRealizado.setValorCredito((BigDecimal) creditoRealizadoArray[8]);

				// Ultima alteração
				String ultimaAlteracao = String.valueOf(creditoRealizadoArray[9]);

				// Origem do Crédito
				if(creditoRealizadoArray[11] != null && creditoRealizadoArray[12] != null){
					CreditoOrigem creditoOrigem = new CreditoOrigem();
					creditoOrigem.setId((Integer) creditoRealizadoArray[11]);
					creditoOrigem.setDescricao((String) creditoRealizadoArray[12]);
					creditoOrigem.setIndicadorUsoLivre((Short) creditoRealizadoArray[13]);
					creditoRealizado.setCreditoOrigem(creditoOrigem);
				}

				if(creditoRealizadoArray[14] != null){

					CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
					creditoARealizarGeral.setId((Integer) creditoRealizadoArray[14]);
					creditoRealizado.setCreditoARealizarGeral(creditoARealizarGeral);

				}

				SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

				Date dataUltimaAlteracao;

				try{
					dataUltimaAlteracao = formatoData.parse(ultimaAlteracao);
				}catch(java.text.ParseException e){
					dataUltimaAlteracao = null;
				}

				creditoRealizado.setUltimaAlteracao(dataUltimaAlteracao);

				/*
				 * Retirado por Virgínia - 13/01/2009 if (creditoRealizadoArray[10] != null) {
				 * CreditoOrigem creditoOrigem = new CreditoOrigem();
				 * creditoOrigem.setId((Integer) creditoRealizadoArray[10]);
				 * creditoRealizado.setCreditoOrigem(creditoOrigem); }
				 */

				retorno.add(creditoRealizado);
			}
		}

		return retorno;
	}

	/**
	 * [US0184] Manter Débito A Cobrar Author: Rafael Santos Data: 30/12/2005
	 * 
	 * @author eduardo henrique
	 * @data 03/11/2008 Alteração no Método para Contabilização dos Débitos a Cobrar cancelados.
	 * @author Saulo Lima
	 * @date 29/11/2008 Customização + Alteração no método para chamar a Classificação de Pagamento
	 *       e Devoluções [UC0300]
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desabilitar a Contabilização por Evento.
	 * @param idsLista
	 *            de Id de Débito a Cobrar
	 * @throws ControladorException
	 */
	public void cancelarDebitoACobrar(String[] ids, Usuario usuarioLogado, Integer matriculaImovel, Boolean registrarTransacao)
					throws ControladorException{

		// -----------------------------------------------------------
		// Verificar permissão especial
		boolean temPermissaoDebitoACobrar = getControladorPermissaoEspecial().verificarPermissaoInserirDebitoACobrarSemEntradaSemJuros(
						usuarioLogado);
		// -----------------------------------------------------------

		Collection<Pagamento> colecaoPagamentos = new ArrayList<Pagamento>();
		Collection<DebitoACobrar> colecaoDebitosCancelar = new ArrayList<DebitoACobrar>();
		Collection<ObjetoTransacao> colecaoDebitoACobrarContabilizacao = new ArrayList<ObjetoTransacao>();
		Collection<DebitoTipo> colecaoDebitosTipos = new ArrayList<DebitoTipo>();
		try{

			for(int i = 0; i < ids.length; i++){
				String id = ids[i];

				DebitoACobrar debitoACobrar = repositorioFaturamento.pesquisarDebitoACobrar(Integer.valueOf(id));

				FiltroPagamento filtroPagamento = new FiltroPagamento();
				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.DEBITO_A_COBRAR_ID, debitoACobrar.getId()));
				Collection<Pagamento> colecaoPagamentosTemp = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());
				if(colecaoPagamentosTemp != null && !colecaoPagamentosTemp.isEmpty()){
					colecaoPagamentos.addAll(colecaoPagamentosTemp);
				}

				if(!temPermissaoDebitoACobrar){

					if(debitoACobrar != null && debitoACobrar.getDebitoTipo() != null){
						FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, debitoACobrar.getDebitoTipo().getId()));
						colecaoDebitosTipos = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

						if(colecaoDebitosTipos != null && !colecaoDebitosTipos.isEmpty()){
							DebitoTipo debitoTipo = (DebitoTipo) colecaoDebitosTipos.iterator().next();

							if(debitoACobrar.getValorDebito().compareTo(debitoTipo.getValorLimite()) == 1){
								throw new ControladorException("atencao.debito_a_cobrar.valor_total_servico.cancelamento", null,
												Util.formatarMoedaReal(debitoTipo.getValorLimite()));
							}
						}
					}

				}

				// falta setar a situação como CANCELADO.
				// -----------------------------------------------------------------------
				debitoACobrar.setDebitoCreditoSituacaoAnterior(debitoACobrar.getDebitoCreditoSituacaoAtual());
				DebitoCreditoSituacao dcst = new DebitoCreditoSituacao();
				dcst.setId(DebitoCreditoSituacao.CANCELADA);
				debitoACobrar.setDebitoCreditoSituacaoAtual(dcst);
				// -----------------------------------------------------------------------

				colecaoDebitosCancelar.add(debitoACobrar);

				FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
				filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, debitoACobrar.getId()));
				filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.DEBITO_CREDITO_SITUACAO);
				filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.FINANCIAMENTO_TIPO);
				filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.LOCALIDADE);
				filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.IMOVEL);
				filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoACobrar.COLECAO_DEBITOS_A_COBRAR_CATEGORIA);
				Collection colecaoDebitosACobrar = getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());
				DebitoACobrar debitoACobrarTemp = (DebitoACobrar) colecaoDebitosACobrar.iterator().next();
				colecaoDebitoACobrarContabilizacao.add(debitoACobrarTemp);
			}

			if(colecaoDebitosCancelar != null && !colecaoDebitosCancelar.isEmpty()){

				// Registrando contabilidade do cancelamento de débito.
				for(DebitoACobrar debitoACobrar : colecaoDebitosCancelar){
					getControladorContabil().registrarLancamentoContabil(debitoACobrar, OperacaoContabil.CANCELAR_DEBITO_A_COBRAR);
				}

				/*
				 * 7.1.5. O sistema registra a transação de cancelar débitos a cobrar <<Inclui>>
				 * [UC0107 – Registrar Transação].
				 */
				for(DebitoACobrar debitoACobrar : colecaoDebitosCancelar){
					// ------------ REGISTRAR TRANSAÇÃO ----------------
					RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_DEBITO_A_COBRAR_CANCELAR,
									matriculaImovel, matriculaImovel, new UsuarioAcaoUsuarioHelper(usuarioLogado,
													UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					Operacao operacao = new Operacao();
					operacao.setId(Operacao.OPERACAO_DEBITO_A_COBRAR_CANCELAR);

					OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
					operacaoEfetuada.setOperacao(operacao);
					operacaoEfetuada.setArgumentoValor(matriculaImovel);
					debitoACobrar.setOperacaoEfetuada(operacaoEfetuada);
					debitoACobrar.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

					registradorOperacao.registrarOperacao(debitoACobrar);

					// ------------ REGISTRAR TRANSAÇÃO ----------------
				}

				/*
				 * 7.1.3. O sistema transfere para o histórico de débitos a cobrar, os débitos a
				 * cobrar que foram cancelados. Na transferência, as
				 * chaves primárias das tabelas (ID’s) devem ser preservadas, a situação do débito
				 * deve ser atualizada com o valor correspondente a
				 * cancelada.
				 */
				this.transferirDebitosACobrarParaHistorico(colecaoDebitosCancelar, registrarTransacao);

				/*
				 * 7.1.4. Para cada débito a cobrar transferido, atualiza o indicador de que o
				 * débito a cobrar está no histórico (DAGE_ICHISTORICO =1
				 * na tabela DEBITO_A_COBRAR_GERAL).
				 */
				this.atualizarIndicadorDebitoACobrarNoHistorico(colecaoDebitosCancelar);

			}

			/*
			 * 7.1.1. Caso exista pagamento para o débito (existe na tabela PAGAMENTO para DBAC_ID =
			 * DBAC_ID da tabela DEBITO_A_COBRAR), classificar o
			 * pagamento do débito a cobrar <<Inclui>> [UC0300 – ClassificarPagamentosDevolucoes]
			 */
			if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){

				// ** Alteração do Classificar **
				// getControladorArrecadacao().classificarPagamentos(colecaoPagamentos.iterator().next());
				getControladorArrecadacao().classificarPagamentosRegistroMovimentoArrecadadores(colecaoPagamentos.iterator().next());
				// ** Alteração do Classificar **
			}

			/*
			 * 7.1.2. Contabiliza o cancelamento do débito a cobrar <<Inclui>> [UC0207 –
			 * Gerar/Atualizar Resumo de Faturamento].
			 */
			// getControladorFinanceiro().contabilizarEventoFaturamento(colecaoDebitoACobrarContabilizacao,
			// EventoContabil.CANCELAMENTO_DEBITO_A_COBRAR);
		}catch(ControladorException ex){
			sessionContext.setRollbackOnly();

			if(ex.getParametroMensagem().size() != 0){

				throw new ControladorException(ex.getMessage(), ex, ex.getParametroMensagem().get(0));

			}else{

				throw new ControladorException(ex.getMessage(), ex);

			}

		}catch(Exception e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Remover Vigencias [UC0169] Manter Tarifa de Consumo
	 * [SB0002] Excluir Tarifa de Consumo
	 * 
	 * @param ids
	 *            []String
	 * @author tiago moreno, Rafael Santos
	 * @date 04/04/2006,20/07/2006
	 */
	public void removerTarifaConsumo(String[] ids) throws ControladorException{

		ConsumoTarifaVigencia consumoTarifaVigencia;
		ConsumoTarifa consumoTarifa = null;
		Integer idConsumoTarifa = null;

		// recebe os ids das vigencias a ser excluídas do action e faz um
		// interator para fazer a verificacao de vigencia por vigencia
		for(int i = 0; i < ids.length; i++){

			// monta o filtro pra recuperar a data da vigencia
			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.ID, ids[i]));
			filtroConsumoTarifaVigencia.adicionarCaminhoParaCarregamentoEntidade(FiltroConsumoTarifaVigencia.CONSUMO_TARIFA);
			Collection<ConsumoTarifaVigencia> colecaoConsumoTarifaVigencia = getControladorUtil().pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());

			if(!Util.isVazioOrNulo(colecaoConsumoTarifaVigencia)){

				consumoTarifaVigencia = colecaoConsumoTarifaVigencia.iterator().next();
				consumoTarifa = consumoTarifaVigencia.getConsumoTarifa();

				// jogaa a data em nessa variável
				Date dataVigencia = consumoTarifaVigencia.getDataVigencia();

				// monta o filtro para pegar todas os FaturamentoAtividadeCronograma
				// a data de realizacao tem que ser maior ou igual a data da
				// vigencia o id da atividade tem q ser igual a 2 (EFETUAR LEITURA)

				FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
				filtroFaturamentoAtividadeCronograma.adicionarParametro(new MaiorQue(FiltroFaturamentoAtividadeCronograma.DATA_REALIZADA,
								dataVigencia));
				// valor correspondente a EFETUAR LEITURA
				filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, FaturamentoAtividade.EFETUAR_LEITURA
												.toString()));
				filtroFaturamentoAtividadeCronograma.adicionarCaminhoParaCarregamentoEntidade("faturamentoAtividade");
				filtroFaturamentoAtividadeCronograma.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupoCronogramaMensal");
				Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(
								filtroFaturamentoAtividadeCronograma, FaturamentoAtividadeCronograma.class.getName());

				// verifica se há dados na colecao e faz um iterator pra recuperar
				// todos que tem o id da atividade igual a 5 que a data de
				// realização
				// seja diferente de null e que o id do cronograma grupo mensal seja
				// igual a da colecao de FatAtvCronograma vigente no iterator
				// anterior
				if(colecaoFaturamentoAtividadeCronograma != null && !colecaoFaturamentoAtividadeCronograma.isEmpty()){

					for(Iterator it = colecaoFaturamentoAtividadeCronograma.iterator(); it.hasNext();){

						FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) it.next();

						FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma2 = new FiltroFaturamentoAtividadeCronograma();
						// valor correspondente a FATURAR GRUPO
						filtroFaturamentoAtividadeCronograma2.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, FaturamentoAtividade.FATURAR_GRUPO
														.toString()));
						filtroFaturamentoAtividadeCronograma2.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID,
										faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal().getId()));
						filtroFaturamentoAtividadeCronograma2.adicionarParametro(new ParametroNaoNulo(
										FiltroFaturamentoAtividadeCronograma.DATA_REALIZADA));
						filtroFaturamentoAtividadeCronograma2.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupoCronogramaMensal");

						Collection<FaturamentoAtividadeCronograma> colecaoRetornoFaturamentoAtividadeCronograma = getControladorUtil()
										.pesquisar(filtroFaturamentoAtividadeCronograma2, FaturamentoAtividadeCronograma.class.getName());

						// se a colecao retornar dados, jogasse a excessão
						if(colecaoRetornoFaturamentoAtividadeCronograma != null && !colecaoRetornoFaturamentoAtividadeCronograma.isEmpty()){

							throw new ControladorException("atencao.data_vigencia_usada", null, Util.formatarData(dataVigencia));
						}
					}
				}
			}
		}

		this.getControladorUtil().remover(ids, ConsumoTarifaVigencia.class.getName(), null, null);

		if(consumoTarifa != null){
			idConsumoTarifa = consumoTarifa.getId();

			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.CONSUMO_TARIFA_ID,
							idConsumoTarifa));
			Collection<ConsumoTarifaVigencia> colecaoConsumoTarifaVigencia = getControladorUtil().pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());

			if(Util.isVazioOrNulo(colecaoConsumoTarifaVigencia)){
				consumoTarifa.setIndicadorUso(ConstantesSistema.INDICADOR_USO_DESATIVO);
				consumoTarifa.setUltimaAlteracao(new Date());

				this.getControladorUtil().atualizar(consumoTarifa);
			}
		}
	}

	/**
	 * Reajustar os dados de consumo tarifa UC169
	 * 
	 * @author tiago moreno,Rafel Santos
	 * @date 04/04/2006,11/07/2006
	 */

	public void reajustarTarifaConsumo(Map<ConsumoTarifaVigencia, Map<ConsumoTarifaCategoria, BigDecimal>> mapReajuste,
					Usuario usuarioLogado) throws ControladorException{

		String pQuantidadeDecimaisValorTarifa = null;

		try{

			pQuantidadeDecimaisValorTarifa = (String) ParametroFaturamento.P_QUANTIDADE_DECIMAIS_VALOR_TARIFA.executar();
		}catch(ControladorException e){
			throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_QUANTIDADE_DECIMAIS_VALOR_TARIFA");
		}

		verificarDataVigencia(mapReajuste);

		Iterator<ConsumoTarifaVigencia> iteratorTarifaVigencia = mapReajuste.keySet().iterator();
		Collection<ConsumoTarifaCategoria> colecaoConsumoTarifaCategoriaAtualizar = new ArrayList<ConsumoTarifaCategoria>();

		while(iteratorTarifaVigencia.hasNext()){
			ConsumoTarifaVigencia consumoTarifaVigencia = iteratorTarifaVigencia.next();

			ConsumoTarifaVigencia consumoTarifaVigenciaNova = new ConsumoTarifaVigencia();

			// Início Registrar Transação
			RegistradorOperacao registradorOperacaoTarifa = new RegistradorOperacao(Operacao.OPERACAO_ATUALIZAR_CONSUMO_TARIFA,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacaoTarifa = new Operacao();
			operacaoTarifa.setId(Operacao.OPERACAO_ATUALIZAR_CONSUMO_TARIFA);

			OperacaoEfetuada operacaoEfetuadaTarifa = new OperacaoEfetuada();
			operacaoEfetuadaTarifa.setOperacao(operacaoTarifa);

			// setando os valores para inserir uma nova Tarifa de Consumo
			// Vigencia.
			consumoTarifaVigenciaNova.setConsumoTarifa(consumoTarifaVigencia.getConsumoTarifa());
			consumoTarifaVigenciaNova.setDataVigencia(consumoTarifaVigencia.getDataVigencia());

			if(consumoTarifaVigencia.getDescricaoAtoAdministrativo() != null){

				consumoTarifaVigenciaNova.setDescricaoAtoAdministrativo(consumoTarifaVigencia.getDescricaoAtoAdministrativo());
			}

			consumoTarifaVigenciaNova.setUltimaAlteracao(new Date());
			consumoTarifaVigenciaNova.setCalculoTipo(consumoTarifaVigencia.getCalculoTipo());

			consumoTarifaVigenciaNova.setOperacaoEfetuada(operacaoEfetuadaTarifa);
			consumoTarifaVigenciaNova.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacaoTarifa.registrarOperacao(consumoTarifaVigenciaNova);

			Integer idConsumoTarifaVigencia = (Integer) getControladorUtil().inserir(consumoTarifaVigenciaNova);

			// setando o novo id para ser utilizado nas categorias
			consumoTarifaVigenciaNova.setId(idConsumoTarifaVigencia);

			Iterator iteratorConsumoTarifaCategoria = consumoTarifaVigencia.getConsumoTarifaCategorias().iterator();

			while(iteratorConsumoTarifaCategoria.hasNext()){
				ConsumoTarifaCategoria consumoTarifaCategoria = (ConsumoTarifaCategoria) iteratorConsumoTarifaCategoria.next();

				BigDecimal percentualReajuste = ((mapReajuste.get(consumoTarifaVigencia)).get(consumoTarifaCategoria));

				BigDecimal cem = new BigDecimal("100");

				ConsumoTarifaCategoria consumoTarifaCategoriaNova = new ConsumoTarifaCategoria();

				BigDecimal resultadoReajusteTarifaCategoria = consumoTarifaCategoria.getValorTarifaMinima();
				BigDecimal resultadoReajusteTarifaEsgotoCategoria = consumoTarifaCategoria.getValorTarifaMinimaEsgoto();

				resultadoReajusteTarifaCategoria = resultadoReajusteTarifaCategoria.multiply(percentualReajuste.divide(cem));
				resultadoReajusteTarifaCategoria = resultadoReajusteTarifaCategoria.add(consumoTarifaCategoria.getValorTarifaMinima());

				if(resultadoReajusteTarifaEsgotoCategoria != null){

					resultadoReajusteTarifaEsgotoCategoria = resultadoReajusteTarifaEsgotoCategoria
									.multiply(percentualReajuste.divide(cem));
					resultadoReajusteTarifaEsgotoCategoria = resultadoReajusteTarifaEsgotoCategoria.add(consumoTarifaCategoria
									.getValorTarifaMinimaEsgoto());

					consumoTarifaCategoriaNova.setValorTarifaMinimaEsgoto(Util.truncar(resultadoReajusteTarifaEsgotoCategoria,
									Util.obterInteger(pQuantidadeDecimaisValorTarifa)));

				}

				// setando os valores para inserir uma nova Tarifa de Consumo
				// Categoria.
				consumoTarifaCategoriaNova.setConsumoTarifaVigencia(consumoTarifaVigenciaNova);
				consumoTarifaCategoriaNova.setCategoria(consumoTarifaCategoria.getCategoria());
				consumoTarifaCategoriaNova.setNumeroConsumoMinimo(consumoTarifaCategoria.getNumeroConsumoMinimo());

				if(resultadoReajusteTarifaCategoria != null){

					consumoTarifaCategoriaNova.setValorTarifaMinima(Util.truncar(resultadoReajusteTarifaCategoria,
									Util.obterInteger(pQuantidadeDecimaisValorTarifa)));
				}

				consumoTarifaCategoriaNova.setUltimaAlteracao(new Date());

				consumoTarifaCategoriaNova.setOperacaoEfetuada(operacaoEfetuadaTarifa);
				consumoTarifaCategoriaNova.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacaoTarifa.registrarOperacao(consumoTarifaCategoriaNova);

				Integer idConsumoTarifaCategoria = (Integer) getControladorUtil().inserir(consumoTarifaCategoriaNova);

				// setando o novo id para ser utilizado nas faixas
				consumoTarifaCategoriaNova.setId(idConsumoTarifaCategoria);

				FiltroConsumoTarifaFaixa filtroConsumoTarifaFaixa = new FiltroConsumoTarifaFaixa();

				filtroConsumoTarifaFaixa.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaFaixa.CONSUMO_TARIFA_CATEGORIA_ID,
								consumoTarifaCategoria.getId()));

				Collection<ConsumoTarifaFaixa> colecaoConsumoTarifaFaixa = getControladorUtil().pesquisar(filtroConsumoTarifaFaixa,
								ConsumoTarifaFaixa.class.getName());

				Iterator iteratorConsumoTarifaFaixa = colecaoConsumoTarifaFaixa.iterator();

				while(iteratorConsumoTarifaFaixa.hasNext()){
					ConsumoTarifaFaixa consumoTarifaFaixa = (ConsumoTarifaFaixa) iteratorConsumoTarifaFaixa.next();

					BigDecimal percentual = new BigDecimal("100");
					boolean adicionarConsumoTarifaCategoriaAtualizar = false;

					ConsumoTarifaFaixa consumoTarifaFaixaNova = new ConsumoTarifaFaixa();

					// setando os valores para inserir uma nova Tarifa de
					// Consumo Faixa.
					consumoTarifaFaixaNova.setConsumoTarifaCategoria(consumoTarifaCategoriaNova);
					consumoTarifaFaixaNova.setNumeroConsumoFaixaIFim(consumoTarifaFaixa.getNumeroConsumoFaixaIFim());
					consumoTarifaFaixaNova.setNumeroConsumoFaixaInicio(consumoTarifaFaixa.getNumeroConsumoFaixaInicio());
					consumoTarifaFaixaNova.setUltimaAlteracao(new Date());

					BigDecimal resultadoReajusteTarifaFaixa = consumoTarifaFaixa.getValorConsumoTarifa();
					resultadoReajusteTarifaFaixa = resultadoReajusteTarifaFaixa.multiply(percentualReajuste.divide(percentual));
					resultadoReajusteTarifaFaixa = resultadoReajusteTarifaFaixa.add(consumoTarifaFaixa.getValorConsumoTarifa());
					
					BigDecimal resultadoReajusteTarifaFaixaEsgoto = consumoTarifaFaixa.getValorUsoEsgotoTarifa();
					
					if(resultadoReajusteTarifaFaixaEsgoto != null){

						resultadoReajusteTarifaFaixaEsgoto = resultadoReajusteTarifaFaixaEsgoto.multiply(percentualReajuste
										.divide(percentual));
						resultadoReajusteTarifaFaixaEsgoto = resultadoReajusteTarifaFaixaEsgoto.add(consumoTarifaFaixa
										.getValorUsoEsgotoTarifa());

						if(consumoTarifaFaixaNova.getNumeroConsumoFaixaInicio().intValue() == 0){

							// Atualiza o valor mínimo da categoria com valor da primeira faixa X
							// limite superior da faixa
							consumoTarifaCategoriaNova.setValorTarifaMinimaEsgoto(Util.truncar(resultadoReajusteTarifaFaixaEsgoto,
											Util.obterInteger(pQuantidadeDecimaisValorTarifa)).multiply(
											new BigDecimal(consumoTarifaFaixaNova.getNumeroConsumoFaixaIFim().intValue())));

							adicionarConsumoTarifaCategoriaAtualizar = true;
						}

						consumoTarifaFaixaNova.setValorUsoEsgotoTarifa(Util.truncar(resultadoReajusteTarifaFaixaEsgoto,
										Util.obterInteger(pQuantidadeDecimaisValorTarifa)));

					}

					/*
					 * BigDecimal resultadoReajusteTarifaFaixa = consumoTarifaFaixa
					 * .getValorConsumoTarifa().multiply(
					 * percentualReajuste.divide(cem).add( consumoTarifaFaixa
					 * .getValorConsumoTarifa()));
					 */

					if(resultadoReajusteTarifaFaixa != null){

						consumoTarifaFaixaNova.setValorConsumoTarifa(Util.truncar(resultadoReajusteTarifaFaixa,
										Util.obterInteger(pQuantidadeDecimaisValorTarifa)));

						if(consumoTarifaFaixaNova.getNumeroConsumoFaixaInicio().intValue() == 0){

							// Atualiza o valor mínimo da categoria com valor da primeira faixa X
							// limite superior da faixa
							consumoTarifaCategoriaNova.setValorTarifaMinima(Util.truncar(resultadoReajusteTarifaFaixa,
											Util.obterInteger(pQuantidadeDecimaisValorTarifa)).multiply(
											new BigDecimal(consumoTarifaFaixaNova.getNumeroConsumoFaixaIFim().intValue())));

							adicionarConsumoTarifaCategoriaAtualizar = true;
						}
					}

					if(adicionarConsumoTarifaCategoriaAtualizar){

						colecaoConsumoTarifaCategoriaAtualizar.add(consumoTarifaCategoriaNova);
					}

					consumoTarifaFaixaNova.setOperacaoEfetuada(operacaoEfetuadaTarifa);
					consumoTarifaFaixaNova.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					registradorOperacaoTarifa.registrarOperacao(consumoTarifaFaixaNova);

					getControladorUtil().inserir(consumoTarifaFaixaNova);
				}
			}
		}

		// Atualiza o valor mínimo da categoria com valor da primeira faixa X limite superior da
		// faixa já calculado anteriormente
		// e atribuído na colecaoConsumoTarifaCategoriaAtualizar
		if(!Util.isVazioOrNulo(colecaoConsumoTarifaCategoriaAtualizar)){

			for(ConsumoTarifaCategoria consumoTarifaCategoriaAtualizar : colecaoConsumoTarifaCategoriaAtualizar){

				ConsumoTarifaCategoria consumoTarifaCategoriaNova = (ConsumoTarifaCategoria) getControladorUtil().pesquisar(
								consumoTarifaCategoriaAtualizar.getId(), ConsumoTarifaCategoria.class, true);

				consumoTarifaCategoriaNova.setValorTarifaMinima(consumoTarifaCategoriaAtualizar.getValorTarifaMinima());

				if(consumoTarifaCategoriaNova.getValorTarifaMinimaEsgoto() != null){

					consumoTarifaCategoriaNova.setValorTarifaMinimaEsgoto(consumoTarifaCategoriaAtualizar.getValorTarifaMinimaEsgoto());
				}

				getControladorUtil().atualizar(consumoTarifaCategoriaNova);
			}
		}
	}

	/**
	 * Atualiza os dados de consumo tarifa UC169
	 * 
	 * @author tiago moreno
	 * @date 04/04/2006
	 * @param consumoTarifaVigencia
	 */

	public void atualizarConsumoTarifa(ConsumoTarifaVigencia consumoTarifaVigencia,
					Collection<CategoriaFaixaConsumoTarifaHelper> colecaoCategoriaFaixaConsumoTarifaHelper, Usuario usuarioLogado)
					throws ControladorException{

		// filtro ConsumoTarifaVigencia
		FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();

		// Parte de Validacao com Timestamp

		filtroConsumoTarifaVigencia.limparListaParametros();

		// Seta o ConsumoTarifaVigencia
		filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.ID, consumoTarifaVigencia.getId()));

		// Procura o ConsumoTarifaVigencia
		Collection<ConsumoTarifaVigencia> colecaoVigenciaBase = getControladorUtil().pesquisar(filtroConsumoTarifaVigencia,
						ConsumoTarifaVigencia.class.getName());

		if(!Util.isVazioOrNulo(colecaoVigenciaBase)){

			ConsumoTarifaVigencia consumoTarifaVigenciaNaBase = (ConsumoTarifaVigencia) Util.retonarObjetoDeColecao(colecaoVigenciaBase);

			// Verificar se o ConsumoTarifaVigencia já foi atualizado por outro
			// usuário
			// durante
			// esta atualização
			if(consumoTarifaVigenciaNaBase.getUltimaAlteracao().after(consumoTarifaVigencia.getUltimaAlteracao())){

				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}
		}

		filtroConsumoTarifaVigencia.limparListaParametros();

		int idConsumoTarifa = consumoTarifaVigencia.getConsumoTarifa().getId();
		int idConsumoTarifaVigencia = consumoTarifaVigencia.getId();

		FiltroConsumoTarifa filtroConsumoTarifa = new FiltroConsumoTarifa();

		filtroConsumoTarifa.adicionarParametro(new ParametroSimples(FiltroConsumoTarifa.ID, idConsumoTarifa));
		Collection colecaoConsumoTarifa = getControladorUtil().pesquisar(filtroConsumoTarifa, ConsumoTarifa.class.getName());

		for(Iterator iter = colecaoConsumoTarifa.iterator(); iter.hasNext();){
			ConsumoTarifa consumoTarifa = (ConsumoTarifa) iter.next();

			Collection colecaoDataVigenciaEmVigorArray = null;
			Collection colecaoDataVigenciaEmVigorArrayMaior = null;
			Calendar dataExistente = new GregorianCalendar();
			dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());

			try{
				colecaoDataVigenciaEmVigorArray = repositorioFaturamento.pesquisarMenorDataConsumoTarifaVigenciaEmVigor(consumoTarifa,
								idConsumoTarifaVigencia);
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			try{
				colecaoDataVigenciaEmVigorArrayMaior = repositorioFaturamento.pesquisarMaiorDataConsumoTarifaVigenciaEmVigor(consumoTarifa,
								idConsumoTarifaVigencia);
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			Date dataVigenciaEmVigor = null;
			// verifica se a data é maior que a data menor existente
			if(colecaoDataVigenciaEmVigorArray != null && !colecaoDataVigenciaEmVigorArray.isEmpty()){
				Iterator colecaoDataVigenciaEmVigorArrayIt = colecaoDataVigenciaEmVigorArray.iterator();
				dataVigenciaEmVigor = ((Date) colecaoDataVigenciaEmVigorArrayIt.next());
			}

			Date dataVigenciaEmVigorMaior = null;
			// verifica se a data é menor que a data informada da maior
			// existente
			if(colecaoDataVigenciaEmVigorArrayMaior != null && !colecaoDataVigenciaEmVigorArrayMaior.isEmpty()){
				Iterator colecaoDataVigenciaEmVigorArrayIt = colecaoDataVigenciaEmVigorArrayMaior.iterator();
				dataVigenciaEmVigorMaior = ((Date) colecaoDataVigenciaEmVigorArrayIt.next());
			}

			// verifica se a data é maior que a data menor existente
			if(dataVigenciaEmVigor != null){
				Calendar dataVigenciaSerInserida = new GregorianCalendar();
				dataVigenciaSerInserida.setTime(dataVigenciaEmVigor);

				if((dataExistente.compareTo(dataVigenciaSerInserida)) <= 0){
					throw new ControladorException("atencao.data_vigencia.menor.anterior_data", null,
									Util.formatarData(dataVigenciaEmVigor));
				}
			}

			// verifica se a data é menor que a data informada da maior
			// existente
			if(dataVigenciaEmVigorMaior != null){
				Calendar dataVigenciaSerInserida = new GregorianCalendar();
				dataVigenciaSerInserida.setTime(dataVigenciaEmVigorMaior);

				if((dataExistente.compareTo(dataVigenciaSerInserida)) >= 0){
					throw new ControladorException("atencao.data_vigencia.maior.anterior_data", null,
									Util.formatarData(dataVigenciaEmVigorMaior));
				}
			}

			// verifica a Data de Vigencia com a Ano Mes de Faturamento
			Integer anoMesFaturamento = getControladorUtil().pesquisarParametrosDoSistema().getAnoMesFaturamento();

			dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());
			String anoMesDataVigenciaTarifa = null;
			if((dataExistente.get(Calendar.MONTH) + 1) < 10){
				anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR) + "0" + (dataExistente.get(Calendar.MONTH) + 1);
			}else{
				anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR) + "" + (dataExistente.get(Calendar.MONTH) + 1);
			}

			Integer anoMesVigencia = Integer.valueOf(anoMesDataVigenciaTarifa);

			if(anoMesVigencia.intValue() < anoMesFaturamento.intValue()){
				throw new ControladorException("atencao.data_vigencia.posterior.ano_mes_faturamento", null,
								Util.formatarAnoMesParaMesAno(anoMesFaturamento.intValue()));
			}

			// verificar se a Data de Vigencia é mario que 90 dias

			Calendar dataCorrente = new GregorianCalendar();
			dataCorrente.add(Calendar.DAY_OF_MONTH, 90);

			if((dataExistente.compareTo(dataCorrente)) > 0){
				throw new ControladorException("atencao.data_vigencia.maior_que.90_dias");
			}

		}

		// Pesquisa o ConsumoTarifaVigencia por descrição e data
		// filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
		// filtroConsumoTarifaVigencia.limparListaParametros();
		//
		// filtroConsumoTarifaVigencia.adicionarCaminhoParaCarregamentoEntidade("consumoTarifa");
		//
		// filtroConsumoTarifaVigencia.adicionarParametro(new
		// ParametroSimples(FiltroConsumoTarifaVigencia.ID, consumoTarifaVigencia.getId()));
		//
		// Collection colecaoConsumoTarifaVigencia =
		// getControladorUtil().pesquisar(filtroConsumoTarifaVigencia,
		// ConsumoTarifaVigencia.class.getName());
		//
		// ConsumoTarifaVigencia consumoTarifaVigenciaColecao = (ConsumoTarifaVigencia) Util
		// .retonarObjetoDeColecao(colecaoConsumoTarifaVigencia);
		//
		// // Atualizar o consumoTarifaVigencia no sistema
		// consumoTarifaVigenciaColecao.setDataVigencia(consumoTarifaVigencia.getDataVigencia());
		// consumoTarifaVigenciaColecao.setUltimaAlteracao(new Date());
		// consumoTarifaVigenciaColecao.setCalculoTipo(consumoTarifaVigencia.getCalculoTipo());
		// consumoTarifaVigenciaColecao.getConsumoTarifa().setDescricao(consumoTarifaVigencia.getConsumoTarifa().getDescricao());
		// consumoTarifaVigenciaColecao.setDescricaoAtoAdministrativo(consumoTarifaVigencia.getDescricaoAtoAdministrativo());
		// consumoTarifaVigenciaColecao.getConsumoTarifa().setUltimaAlteracao(new Date());
		//
		// getControladorUtil().atualizar(consumoTarifaVigenciaColecao);

		// Início Registrar Transação
		RegistradorOperacao registradorOperacaoTarifa = new RegistradorOperacao(Operacao.OPERACAO_ATUALIZAR_CONSUMO_TARIFA,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacaoTarifa = new Operacao();
		operacaoTarifa.setId(Operacao.OPERACAO_ATUALIZAR_CONSUMO_TARIFA);

		OperacaoEfetuada operacaoEfetuadaTarifa = new OperacaoEfetuada();
		operacaoEfetuadaTarifa.setOperacao(operacaoTarifa);

		consumoTarifaVigencia.setUltimaAlteracao(new Date());

		// Remover todas Categorias e Faixas relacionadas com o Consumo Tarifa
		// sendo atualizado, a remoção de Faixa acontece por cascata no banco
		FiltroConsumoTarifaCategoria filtroConsumoTarifaCategoria = new FiltroConsumoTarifaCategoria();
		filtroConsumoTarifaCategoria.setConsultaSemLimites(true);
		filtroConsumoTarifaCategoria.adicionarCaminhoParaCarregamentoEntidade("consumoTarifaFaixas");

		filtroConsumoTarifaCategoria.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaCategoria.CONSUMO_VIGENCIA_ID,
						consumoTarifaVigencia.getId()));

		Collection colecaoConsumoTarifaCategoria = getControladorUtil().pesquisar(filtroConsumoTarifaCategoria,
						ConsumoTarifaCategoria.class.getName());

		ArrayList<ConsumoTarifaCategoria> listaDuplicada = new ArrayList<ConsumoTarifaCategoria>();
		ArrayList<ConsumoTarifaCategoria> colecaoConsumoTarifaCategoriaFormatada = new ArrayList<ConsumoTarifaCategoria>();

		listaDuplicada = (ArrayList<ConsumoTarifaCategoria>) colecaoConsumoTarifaCategoria;

		for(ConsumoTarifaCategoria consumoCategoria : listaDuplicada){

			if(colecaoConsumoTarifaCategoriaFormatada.contains(consumoCategoria) == false){

				colecaoConsumoTarifaCategoriaFormatada.add(consumoCategoria);

			}

		}

		Iterator iteratorColecaoConsumoTarifaCategoria = colecaoConsumoTarifaCategoriaFormatada.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoria = null;

		while(iteratorColecaoConsumoTarifaCategoria.hasNext()){
			consumoTarifaCategoria = (ConsumoTarifaCategoria) iteratorColecaoConsumoTarifaCategoria.next();

			consumoTarifaCategoria.setOperacaoEfetuada(operacaoEfetuadaTarifa);
			consumoTarifaCategoria.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacaoTarifa.registrarOperacao(consumoTarifaCategoria);

			getControladorUtil().remover(new String[] {consumoTarifaCategoria.getId().toString()}, ConsumoTarifaCategoria.class.getName(),
							null, null);
		}

		// Inserir as novas Categorias e Faixas
		for(CategoriaFaixaConsumoTarifaHelper helper : colecaoCategoriaFaixaConsumoTarifaHelper){

			ConsumoTarifaCategoria tarifaCategoria = new ConsumoTarifaCategoria();
			tarifaCategoria.setConsumoTarifaVigencia(consumoTarifaVigencia);
			tarifaCategoria.setCategoria(helper.getConsumoTarifaCategoria().getCategoria());
			tarifaCategoria.setNumeroConsumoMinimo(helper.getConsumoTarifaCategoria().getNumeroConsumoMinimo());
			tarifaCategoria.setValorTarifaMinima(helper.getConsumoTarifaCategoria().getValorTarifaMinima());
			tarifaCategoria.setValorTarifaMinimaEsgoto(helper.getConsumoTarifaCategoria().getValorTarifaMinimaEsgoto());
			tarifaCategoria.setSubCategoria(helper.getConsumoTarifaCategoria().getSubCategoria());
			tarifaCategoria.setUltimaAlteracao(new Date());

			tarifaCategoria.setOperacaoEfetuada(operacaoEfetuadaTarifa);
			tarifaCategoria.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacaoTarifa.registrarOperacao(tarifaCategoria);

			tarifaCategoria.setId((Integer) getControladorUtil().inserir(tarifaCategoria));

			/*
			 * Collections.sort((List) helper.getColecaoFaixas(), new Comparator() { public int
			 * compare(Object a, Object b) { Integer
			 * numeroConsumoFaixaInicio1 = ((ConsumoTarifaFaixa) a) .getNumeroConsumoFaixaInicio();
			 * Integer numeroConsumoFaixaInicio2 =
			 * ((ConsumoTarifaFaixa) b) .getNumeroConsumoFaixaInicio();
			 * return numeroConsumoFaixaInicio1 .compareTo(numeroConsumoFaixaInicio2); } });
			 */

			for(ConsumoTarifaFaixa faixa : helper.getColecaoFaixas()){

				faixa.setConsumoTarifaCategoria(tarifaCategoria);

				faixa.setOperacaoEfetuada(operacaoEfetuadaTarifa);
				faixa.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacaoTarifa.registrarOperacao(faixa);

				getControladorUtil().inserir(faixa);
			}

		}

		// Altera Consumo Tarifa Vigência
		consumoTarifaVigencia.setUltimaAlteracao(new Date());

		consumoTarifaVigencia.setOperacaoEfetuada(operacaoEfetuadaTarifa);
		consumoTarifaVigencia.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacaoTarifa.registrarOperacao(consumoTarifaVigencia);

		getControladorUtil().atualizar(consumoTarifaVigencia);

		// Altera Consumo Tarifa
		ConsumoTarifa consumoTarifaAlterado = consumoTarifaVigencia.getConsumoTarifa();
		consumoTarifaAlterado.setUltimaAlteracao(new Date());

		consumoTarifaAlterado.setOperacaoEfetuada(operacaoEfetuadaTarifa);
		consumoTarifaAlterado.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacaoTarifa.registrarOperacao(consumoTarifaAlterado);

		getControladorUtil().atualizar(consumoTarifaAlterado);

		// Fim Registrar Transação
	}

	/**
	 * [UC0168] - Inserir Tarifa de Consumo
	 * 
	 * @autor Tiago Moreno
	 * @date 05/01/2006
	 * @param consumoTarifa
	 * @param consumoTarifaVigencia
	 * @param colecaoConsumoTarifaCategoria
	 * @param colecaoConsumoTarifaFaixa
	 * @throws ControladorException
	 */
	public void inserirConsumoTarifa(ConsumoTarifa consumoTarifa, ConsumoTarifaVigencia consumoTarifaVigencia,
					Collection<ConsumoTarifaCategoria> colecaoConsumoTarifaCategoria, Usuario usuarioLogado) throws ControladorException{

		// Início Registrar Transação
		RegistradorOperacao registradorOperacaoTarifa = new RegistradorOperacao(Operacao.OPERACAO_INSERIR_CONSUMO_TARIFA,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacaoTarifa = new Operacao();
		operacaoTarifa.setId(Operacao.OPERACAO_INSERIR_CONSUMO_TARIFA);

		OperacaoEfetuada operacaoEfetuadaTarifa = new OperacaoEfetuada();
		operacaoEfetuadaTarifa.setOperacao(operacaoTarifa);

		// Caso o objeto ConsumoTarifa já exista na base
		if(consumoTarifa.getId() != null){

			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.CONSUMO_TARIFA_ID,
							consumoTarifa.getId()));
			Collection colecaoConsumoVigenciaExistente = getControladorUtil().pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());

			if(colecaoConsumoVigenciaExistente != null && !colecaoConsumoVigenciaExistente.isEmpty()){
				consumoTarifaVigencia.setConsumoTarifa(consumoTarifa);

				// [FS0002] - Verificar data de vigência

				// Pesquisando a data de vigência em vigor
				Collection colecaoDataVigenciaEmVigorArray = null;

				try{
					colecaoDataVigenciaEmVigorArray = repositorioFaturamento.pesquisarConsumoTarifaVigenciaEmVigor(consumoTarifa);
				}catch(ErroRepositorioException ex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				Iterator colecaoDataVigenciaEmVigorArrayIt = colecaoDataVigenciaEmVigorArray.iterator();

				Date dataVigenciaEmVigor = ((Date) colecaoDataVigenciaEmVigorArrayIt.next());

				Calendar dataVigenciaSerInserida = new GregorianCalendar();
				dataVigenciaSerInserida.setTime(dataVigenciaEmVigor);

				Calendar dataExistente = new GregorianCalendar();
				dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());

				if((dataExistente.compareTo(dataVigenciaSerInserida)) <= 0){
					throw new ControladorException("atencao.data_vigencia_errada", null, Util.formatarData(dataVigenciaEmVigor));
				}

				// verifica a Data de Vigencia com a Ano Mes de Faturamento
				Integer anoMesFaturamento = getControladorUtil().pesquisarParametrosDoSistema().getAnoMesFaturamento();

				dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());
				String anoMesDataVigenciaTarifa = null;
				if((dataExistente.get(Calendar.MONTH) + 1) < 10){
					anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR) + "0" + (dataExistente.get(Calendar.MONTH) + 1);
				}else{
					anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR) + "" + (dataExistente.get(Calendar.MONTH) + 1);
				}

				Integer anoMesVigencia = Integer.valueOf(anoMesDataVigenciaTarifa);

				if(anoMesVigencia.intValue() < anoMesFaturamento.intValue()){
					throw new ControladorException("atencao.data_vigencia.posterior.ano_mes_faturamento", null,
									Util.formatarAnoMesParaMesAno(anoMesFaturamento.intValue()));
				}

				// verificar se a Data de Vigencia é mario que 90 dias
				Calendar dataHjNoventaDias = new GregorianCalendar();
				dataHjNoventaDias.add(Calendar.DAY_OF_MONTH, 90);

				if((dataExistente.compareTo(dataHjNoventaDias)) > 0){
					throw new ControladorException("atencao.data_vigencia.maior_que.90_dias", null, Util.formatarData(dataVigenciaEmVigor));
				}

				// Inserindo o objeto ConsumoTarifaVigencia no BD
				consumoTarifaVigencia.setOperacaoEfetuada(operacaoEfetuadaTarifa);
				consumoTarifaVigencia.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacaoTarifa.registrarOperacao(consumoTarifaVigencia);
				this.getControladorUtil().inserir(consumoTarifaVigencia);
			}else{
				// Inserindo o objeto ConsumoTarifaVigencia no BD

				consumoTarifaVigencia.setOperacaoEfetuada(operacaoEfetuadaTarifa);
				consumoTarifaVigencia.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacaoTarifa.registrarOperacao(consumoTarifaVigencia);

				Integer i = (Integer) this.getControladorUtil().inserir(consumoTarifaVigencia);
				consumoTarifaVigencia.setId(i);
			}
		}else{

			// Obtendo o ID gerado pelo BD
			consumoTarifa.setOperacaoEfetuada(operacaoEfetuadaTarifa);
			consumoTarifa.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacaoTarifa.registrarOperacao(consumoTarifa);

			Integer idConsumoTarifaGerado = (Integer) this.getControladorUtil().inserir(consumoTarifa);

			// Carregando o novo objeto ConsumoTarifa
			consumoTarifa.setId(idConsumoTarifaGerado);
			consumoTarifaVigencia.setConsumoTarifa(consumoTarifa);

			// Inserindo o objeto ConsumoTarifaVigencia no BD
			consumoTarifaVigencia.setOperacaoEfetuada(operacaoEfetuadaTarifa);
			consumoTarifaVigencia.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacaoTarifa.registrarOperacao(consumoTarifaVigencia);

			Integer i = (Integer) this.getControladorUtil().inserir(consumoTarifaVigencia);
			consumoTarifaVigencia.setId(i);
		}

		// Para cada categoria: O sistema inserir um objeto do tipo
		// ConsumoTarifaCategoria

		Iterator colecaoConsumoTarifaCategoriaIt = colecaoConsumoTarifaCategoria.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoriaColecao = null;

		while(colecaoConsumoTarifaCategoriaIt.hasNext()){
			consumoTarifaCategoriaColecao = (ConsumoTarifaCategoria) colecaoConsumoTarifaCategoriaIt.next();

			consumoTarifaCategoriaColecao.setConsumoTarifaVigencia(consumoTarifaVigencia);

			if(consumoTarifaCategoriaColecao.getSubCategoria() == null){
				Subcategoria subcategoria = new Subcategoria();
				subcategoria.setId(0);
				consumoTarifaCategoriaColecao.setSubCategoria(subcategoria);
			}

			Integer codigoConsumoTarifaCategoriaColecao = (Integer) this.getControladorUtil().inserir(consumoTarifaCategoriaColecao);
			consumoTarifaCategoriaColecao.setId(codigoConsumoTarifaCategoriaColecao);

			Collection consumoTarifaFaixa = new ArrayList(consumoTarifaCategoriaColecao.getConsumoTarifaFaixas());
			Collections.sort((List) consumoTarifaFaixa, new Comparator() {

				public int compare(Object a, Object b){

					Integer numeroConsumoFaixaInicio1 = ((ConsumoTarifaFaixa) a).getNumeroConsumoFaixaInicio();
					Integer numeroConsumoFaixaInicio2 = ((ConsumoTarifaFaixa) b).getNumeroConsumoFaixaInicio();

					return numeroConsumoFaixaInicio1.compareTo(numeroConsumoFaixaInicio2);

				}
			});

			Iterator colecaoConsumoTarifaFaixaIt = consumoTarifaFaixa.iterator();

			while(colecaoConsumoTarifaFaixaIt.hasNext()){
				ConsumoTarifaFaixa consumoTarifaFaixaColecao = (ConsumoTarifaFaixa) colecaoConsumoTarifaFaixaIt.next();

				consumoTarifaFaixaColecao.setConsumoTarifaCategoria(consumoTarifaCategoriaColecao);

				consumoTarifaFaixaColecao.setOperacaoEfetuada(operacaoEfetuadaTarifa);
				consumoTarifaFaixaColecao.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacaoTarifa.registrarOperacao(consumoTarifaFaixaColecao);

				this.getControladorUtil().inserir(consumoTarifaFaixaColecao);
			}

		}

		// Para cada faixa informada para categori: O sistema inserir um objeto
		// do tipo ConsumoTarifaFaixa

	}

	/**
	 * OC1213341 - Verificar se existe valor do Debito Tipo para a Localidade informada
	 * 
	 * @author Ado Rocha
	 * @date 23/04/2014
	 **/
	public BigDecimal verificarDebitoTipoValorLocalidade(Integer idImovel, Integer idDebitoTipo){

		BigDecimal valorDebitoLocalidade = null;

		try{

			FiltroImovel filtroImovel = new FiltroImovel();
			filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovel));
			Collection colecaoImovel = (Collection) getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
			Imovel imovelNaBase = (Imovel) Util.retonarObjetoDeColecao(colecaoImovel);


			if(imovelNaBase != null && idDebitoTipo != null){
				FiltroDebitoTipoValorLocalidade filtroValorLocalidade = new FiltroDebitoTipoValorLocalidade();
				filtroValorLocalidade.adicionarParametro(new ParametroSimples(FiltroDebitoTipoValorLocalidade.LOCALIDADE_ID, imovelNaBase
								.getLocalidade().getId()));
				filtroValorLocalidade
								.adicionarParametro(new ParametroSimples(FiltroDebitoTipoValorLocalidade.DEBITO_TIPO_ID, idDebitoTipo));
				filtroValorLocalidade.adicionarParametro(new ParametroSimples(FiltroDebitoTipoValorLocalidade.INDICADOR_USO,
								ConstantesSistema.SIM));

				Collection colecaoDebitoTipoValorLocalidade = (Collection) getControladorUtil().pesquisar(filtroValorLocalidade,
								DebitoTipoValorLocalidade.class.getName());
				DebitoTipoValorLocalidade valorLocalidadeNaBase = (DebitoTipoValorLocalidade) Util
								.retonarObjetoDeColecao(colecaoDebitoTipoValorLocalidade);

				if(valorLocalidadeNaBase != null){
					valorDebitoLocalidade = valorLocalidadeNaBase.getValorDebitoTipo();
				}
			}
		}catch(Exception e){
			e.printStackTrace();
		}

		return valorDebitoLocalidade;
	}


	/**
	 * [UC0187] - Inserir Guia de Pagamento
	 * 
	 * @author Rafael Corrêa, Pedro Alexandre, Ivan Sérgio
	 * @since 16/01/2006, 23/11/2006, 05/07/2007
	 * @author eduardo henrique
	 * @date 04/08/2008 Alterações realizadas no UC, basicamente incluído o conceito de Prestações
	 *       de Guia de Pagamento
	 * @author Saulo Lima
	 * @date 29/11/2008 Alteração no método para chamar a Classificação de Pagamento e Devoluções
	 *       [UC0300]
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desabilitar a Contabilização por Evento.
	 * @author Saulo Lima
	 * @date 09/02/2009 Validação se o ID do imóvel é nulo antes de Registrar Operação
	 * @author Eduardo henrique
	 * @date 11/02/2009 Tratamento definitivo para dados de Localidade da Guia
	 * @author Saulo Lima
	 * @date 12/02/2009 Correção para processar Imóvel ou Cliente (caso venham os 2 a prioridade é
	 *       do imovel) Correção na validação com o
	 *       filtroRegistroAtendimentoSolicitante (adicionados os parâmetros corretos)
	 * @param guiaPagamento
	 *            GuiaPagamento
	 * @param usuarioLogado
	 * @param dataVencimento
	 *            TODO
	 * @param colecaoPrestacoesGuiaPagamento
	 * @throws ControladorException
	 */
	public Integer inserirGuiaPagamento(GuiaPagamento guiaPagamento, Usuario usuarioLogado, String dataVencimento,
					Integer qtdeDiasVencimento, Collection<GuiaPagamentoPrestacaoHelper> colecaoPrestacoesGuiaPagamento,
					Collection<ListaDadosPrestacaoGuiaHelper> colecaoListaDadosPrestacoesGuia, String numeroContratoParcelOrgaoPublico)
					throws ControladorException{

		// valida se pelo menos um Tipo de Débito foi informado e se não excedeu
		// o número máximo definido em Parâmetro
		if(colecaoPrestacoesGuiaPagamento == null || colecaoPrestacoesGuiaPagamento.isEmpty()){
			throw new ControladorException("atencao.sem_prestacoes_guia_informado");
		}

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		if(sistemaParametro != null){
			Short maximoTiposDebitoGuia = sistemaParametro.getNumeroMaximoTiposDebitoEmissaoDocumento();

			if((maximoTiposDebitoGuia == null) || (colecaoPrestacoesGuiaPagamento.size() > maximoTiposDebitoGuia.intValue())){
				throw new ControladorException("atencao.tipos_debito_guia_superior_parametro", null, (maximoTiposDebitoGuia == null ? "0"
								: maximoTiposDebitoGuia.toString()));
			}
		}else{
			throw new ControladorException("erro.sistema");

		}

		// Verifica se o AnoMesFaturamento está Definido, caso contrário aborta
		if(sistemaParametro.getAnoMesFaturamento() == null){
			throw new ControladorException("atencao.parametros_sistema_ano_mes_faturamento_guia");
		}

		// Verifica Data de Vencimento (FS005), Nr. de Prestações (FS015) e Qtde
		// de Dias entre Venc.
		Date dataVencimentoPrestacao = null;
		try{
			dataVencimentoPrestacao = Util.converteStringParaDate(dataVencimento);
		}catch(IllegalArgumentException e){
			throw new ControladorException("atencao.data_vencimento_prestacoes_guia_invalida");
		}

		boolean inserirGuiaPagamentoSemValidarNumeroPrestacoes = getControladorPermissaoEspecial().verificarPermissaoEspecial(
						PermissaoEspecial.INCLUIR_GUIA_DE_PAGAMENTO_SEM_NUMERO_PARCELAS_MAXIMO, usuarioLogado);
		if(guiaPagamento.getNumeroPrestacaoTotal() != null){

			// [FS0015]-Validar número de prestações
			if((sistemaParametro.getNumeroMaximoParcelasFinanciamento() != null && sistemaParametro.getNumeroMaximoParcelasFinanciamento()
							.compareTo(guiaPagamento.getNumeroPrestacaoTotal()) < 0) && !inserirGuiaPagamentoSemValidarNumeroPrestacoes){

				throw new ControladorException("atencao.valor_prestacoes", null, sistemaParametro.getNumeroMaximoParcelasFinanciamento()
								.toString());
			}
		}else{
			throw new ControladorException("atencao.valor_prestacoes");
		}

		if(qtdeDiasVencimento == null || (guiaPagamento.getNumeroPrestacaoTotal().intValue() > 1 && qtdeDiasVencimento.intValue() <= 0)){
			throw new ControladorException("atencao.quantidade_de_dias_entre_vencimentos_guia_invalido");
		}

		// Verifica se o usuário tem permissão especial para inserir Guia de
		// Pagamento sem RA(38)
		// boolean inserirGuiaPagamentoSemRa =
		// getControladorPermissaoEspecial().verificarPermissaoEspecial(PermissaoEspecial.INSERIR_GUIA_DE_PAGAMENTO_SEM_RA,
		// usuarioLogado);

		String idImovel = "";
		if(guiaPagamento.getImovel() != null && guiaPagamento.getImovel().getId() != null){
			idImovel = guiaPagamento.getImovel().getId().toString();
		}

		String codigoCliente = "";
		if(guiaPagamento.getCliente() != null && guiaPagamento.getCliente().getId() != null){
			codigoCliente = guiaPagamento.getCliente().getId().toString();
		}

		// Alterado para o caso em que o usuário tem permissão especial para
		// inserir Guia de Pagamento sem RA(38)
		String idRegistroAtendimento = "";
		if (guiaPagamento.getRegistroAtendimento() != null && guiaPagamento.getRegistroAtendimento().getId() != null ) {
			idRegistroAtendimento = guiaPagamento.getRegistroAtendimento().getId().toString();
		}
		
		String idOrdemServico = "";
		if(guiaPagamento.getOrdemServico() != null && guiaPagamento.getOrdemServico().getId() != null){
			idOrdemServico = guiaPagamento.getOrdemServico().getId().toString();
		}
		// String idDebitoTipo =
		// guiaPagamento.getDebitoTipo().getId().toString();
		// String idDebitoTipo = "";
		// Date dataVencimentoFormatada = guiaPagamento.getDataVencimento();
		Date dataVencimentoFormatada = new Date();

		GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();

		Imovel imovel = null;

		if(idImovel != null && !idImovel.trim().equals("") && Integer.parseInt(idImovel) > 0){
			FiltroImovel filtroImovel = new FiltroImovel();
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("quadra");
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("ligacaoAguaSituacao");
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("ligacaoEsgotoSituacao");

			filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovel));

			Collection imovelEncontrado = getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
			// Verifica a existência do imóvel
			if(imovelEncontrado != null && !imovelEncontrado.isEmpty()){
				imovel = (Imovel) imovelEncontrado.iterator().next();

				guiaPagamento.setImovel(imovel);

				guiaPagamento.setLocalidade(imovel.getLocalidade());

				FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();

				filtroImovelCobrancaSituacao.adicionarCaminhoParaCarregamentoEntidade("cobrancaSituacao");
				filtroImovelCobrancaSituacao
								.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, imovel.getId()));

				Collection imovelCobrancaSituacaoEncontrada = getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
								ImovelCobrancaSituacao.class.getName());

				// Verifica se o imóvel foi excluído
				if(imovel.getIndicadorExclusao() == null ? false : imovel.getIndicadorExclusao().equals(Imovel.IMOVEL_EXCLUIDO)){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.imovel.excluido");
				}

				// Verifica se o imóvel tem débito em cobrança administrativa
				if(imovelCobrancaSituacaoEncontrada != null && !imovelCobrancaSituacaoEncontrada.isEmpty()){
					if(((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao() != null){
						if(((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao().getId()
										.equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
										&& ((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0))
														.getDataRetiradaCobranca() == null){

							// Código comentado para a customização da cobrança administrativa CASAL
							// sessionContext.setRollbackOnly();
							// throw new
							// ControladorException("atencao.pesquisa.imovel.cobranca_administrativa");
						}
					}
				}

			}else{
				throw new ControladorException("atencao.pesquisa.imovel.inexistente.guia");
			}

		}

		// Alterado para o caso em que o usuário tem permissão especial para
		// inserir Guia de Pagamento sem RA(38)
		RegistroAtendimento registroAtendimento = null;
		if(idRegistroAtendimento != null && !idRegistroAtendimento.trim().equals("")){
			FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();

			filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
			filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("solicitacaoTipoEspecificacao");

			filtroRegistroAtendimento.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimento.ID, idRegistroAtendimento));

			Collection registrosAtendimentos = getControladorUtil().pesquisar(filtroRegistroAtendimento,
							RegistroAtendimento.class.getName());

			if(registrosAtendimentos != null && !registrosAtendimentos.isEmpty()){
				Iterator registroAtendimentoIterator = registrosAtendimentos.iterator();
				registroAtendimento = (RegistroAtendimento) registroAtendimentoIterator.next();
			}else{
				throw new ControladorException("atencao.registro_atendimento.inexistente");
			}

			// Validações [FS0003]
			if(registroAtendimento.getAtendimentoMotivoEncerramento() != null){
				throw new ControladorException("atencao.registro_atendimento_guia_pagamento_encerrado");
			}

			if(registroAtendimento.getSolicitacaoTipoEspecificacao().getIndicadorGeracaoDebito().equals(new Short("2"))){
				throw new ControladorException("atencao.registro_atendimento_guia_pagamento_nao_permite_geracao_debito");
			}

			if(idImovel != null && !idImovel.trim().equals("") && Integer.parseInt(idImovel) > 0){

				if(registroAtendimento.getImovel() == null){
					throw new ControladorException("atencao.registro_atendimento_guia_pagamento_sem_imovel");
				}

				if(!registroAtendimento.getImovel().getId().equals(imovel.getId())){
					throw new ControladorException("atencao.registro_atendimento_guia_pagamento_imovel_diferente", null,
									registroAtendimento.getImovel().getId().toString());
				}
			}

			if(codigoCliente != null && !codigoCliente.trim().equalsIgnoreCase("")){
				FiltroRegistroAtendimentoSolicitante filtroRegistroAtendimentoSolicitante = new FiltroRegistroAtendimentoSolicitante();

				filtroRegistroAtendimentoSolicitante.adicionarParametro(new ParametroSimples(
								FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID, registroAtendimento.getId()));
				filtroRegistroAtendimentoSolicitante.adicionarParametro(new ParametroSimples(
								FiltroRegistroAtendimentoSolicitante.CLIENTE_ID, codigoCliente));

				Collection colecaoClienteRegistroAtendimento = getControladorUtil().pesquisar(filtroRegistroAtendimentoSolicitante,
								RegistroAtendimentoSolicitante.class.getName());
				if(colecaoClienteRegistroAtendimento == null || colecaoClienteRegistroAtendimento.isEmpty()){
					throw new ControladorException("atencao.registro_atendimento_guia_pagamento_cliente_diferente");
				}
			}

			// Validação [FS0008]
			FiltroGuiaPagamento filtro = new FiltroGuiaPagamento();
			filtro.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.REGISTRO_ATENDIMENTO_ID, Integer.valueOf(registroAtendimento
							.getId())));

			Collection colecao = getControladorUtil().pesquisar(filtro, GuiaPagamento.class.getName());

			if(colecao != null && !colecao.isEmpty()){
				throw new ControladorException("atencao.guia_pagamento.ja.cadastrado");
			}

		}

		if(idOrdemServico != null && !idOrdemServico.equals("")){
			FiltroOrdemServico filtroOrdemServico = new FiltroOrdemServico();

			filtroOrdemServico.adicionarParametro(new ParametroSimples(FiltroOrdemServico.ID, idOrdemServico));

			Collection ordensServicos = getControladorUtil().pesquisar(filtroOrdemServico, OrdemServico.class.getName());

			OrdemServico ordemServico = null;
			if(ordensServicos != null && !(ordensServicos.isEmpty())){
				ordemServico = (OrdemServico) ordensServicos.iterator().next();
			}else{
				throw new ControladorException("atencao.ordem_servico.inexistente");
			}

			guiaPagamento.setOrdemServico(ordemServico);

		}else{

			guiaPagamento.setOrdemServico(null);

		}

		guiaPagamento.setRegistroAtendimento(registroAtendimento);

		// TODO implementaaar FS0013
		// Início da Geração das Prestações
		// Map mapValorPorItemLancamentoContabil = new HashMap(); // Map
		// utilizado para verificar se a soma dos valores por Tipo de Débito foi
		// ultrapassada

		// Situação Débito
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

		guiaPagamento.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

		// Tipo Documento
		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);

		guiaPagamento.setDocumentoTipo(documentoTipo);

		// Localidade e Setor Comercial
		this.validarLocalidadeSetorComercialGuiaPagamento(guiaPagamento);

		if(guiaPagamento.getLocalidade() == null || guiaPagamento.getSetorComercial() == null){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.faturamento.inserir_guia_pagamento_localidade_ou_setor_padrao_indefinido");
		}

		// Obtém o valor pela coleção Helper, que representam as Prestações
		BigDecimal valorTotalDebito = new BigDecimal(0.00);

		for(Iterator iterator = colecaoPrestacoesGuiaPagamento.iterator(); iterator.hasNext();){
			GuiaPagamentoPrestacaoHelper prestacaoHelper = (GuiaPagamentoPrestacaoHelper) iterator.next();

			valorTotalDebito = valorTotalDebito.add(prestacaoHelper.getValorTipoDebito());
		}

		guiaPagamento.setValorDebito(valorTotalDebito);

		Integer idGuiaPagamentoGerado = null;

		try{
			// Inclui a Guia Pagamento Geral e a Guia Pagamento
			guiaPagamentoGeral.setIndicadorHistorico(new Short("2"));
			guiaPagamentoGeral.setUltimaAlteracao(new Date());

			idGuiaPagamentoGerado = (Integer) getControladorUtil().inserir(guiaPagamentoGeral);

			guiaPagamentoGeral.setId(idGuiaPagamentoGerado);
			guiaPagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
			guiaPagamento.setId(idGuiaPagamentoGerado);
			guiaPagamento.setDataInclusao(new Date());
			guiaPagamento.setUltimaAlteracao(new Date());

			// Inclui o número do contrato de parcelamento do orgão público
			Integer numeroContratoParcelamentoOrgaoPublico = null;

			if(!Util.isVazioOuBranco(numeroContratoParcelOrgaoPublico)){

				numeroContratoParcelamentoOrgaoPublico = Integer.valueOf(numeroContratoParcelOrgaoPublico);

				guiaPagamento.setNumeroContratoParcelOrgaoPublico(numeroContratoParcelamentoOrgaoPublico);
			}

			if(guiaPagamento.getImovel() != null && guiaPagamento.getImovel().getId() != null){
				/**
				 * alterado por pedro alexandre dia 23/11/2006 alteração feita para acoplar o
				 * controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, guiaPagamento.getImovel());

				if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				}else{
					getControladorUtil().inserir(guiaPagamento);
				}
				// ------------ FIM CONTROLE DE ABRANGENCIA ------------
			}else{
				getControladorUtil().inserir(guiaPagamento);
			}

			// Map que servirá de base para a geração do Guia_Pagamento_Categoria
			Map mapValorPorItemLancamentoContabilPrestacao = new HashMap();

			// 10.4. O sistema inclui as prestações da guia de pagamento a partir dos dados da lista
			// dos dados das prestações da guia:
			if(!Util.isVazioOrNulo(colecaoListaDadosPrestacoesGuia)){
				// 10.4.1. Atribui o valor 1 ao Número da Prestação.
				Integer numeroPrestacao = 1;

				int numeroTotalPrestacoes = guiaPagamento.getNumeroPrestacaoTotal().intValue();

				for(ListaDadosPrestacaoGuiaHelper listaDadosPrestacaoGuiaHelper : colecaoListaDadosPrestacoesGuia){
					// 10.4.2. Enquanto o Número da Prestação for menor ou igual ao “Número de
					// Prestações”:
					if(numeroPrestacao.intValue() <= numeroTotalPrestacoes){
						// 10.4.2.1. Para cada tipo de débito da prestação,
						// inclui os dados do tipo de débito na prestação
						// (inclui na tabela GUIA_PAGAMENTO_PRESTACAO):
						Map<Integer, BigDecimal> mapalistaDadosPrestacoesGuia = listaDadosPrestacaoGuiaHelper
										.getMapValorDebitoNaPrestacaoPorTipoDebito();
						
						Map<Integer, Integer> mapalistaProcessoPrestacoesGuia = listaDadosPrestacaoGuiaHelper
										.getMapNumeroProcessoAdministrativoExecucaoFiscalNaPrestacaoPorTipoDebito();

						for(Integer chaveDebitoTipo : mapalistaDadosPrestacoesGuia.keySet()){
							DebitoTipo debitoTipo = filtrarDebitoTipo(chaveDebitoTipo);

							GuiaPagamentoPrestacaoPK guiaPagamentoPrestacaoPK = new GuiaPagamentoPrestacaoPK();
							guiaPagamentoPrestacaoPK.setGuiaPagamentoId(guiaPagamento.getId());
							guiaPagamentoPrestacaoPK.setNumeroPrestacao(listaDadosPrestacaoGuiaHelper.getPrestacao().shortValue());
							guiaPagamentoPrestacaoPK.setDebitoTipoId(chaveDebitoTipo);
							guiaPagamentoPrestacaoPK.setItemLancamentoContabilId(debitoTipo.getLancamentoItemContabil().getId());

							Integer numeroProcessoAdministrativo = ConstantesSistema.NUMERO_PROCESSO_ADM_EXEC_FISCAL_ZERO;
							if(mapalistaProcessoPrestacoesGuia != null){
								if(mapalistaProcessoPrestacoesGuia.get(chaveDebitoTipo) != null){
									numeroProcessoAdministrativo = mapalistaProcessoPrestacoesGuia.get(chaveDebitoTipo);
								}
							}

							guiaPagamentoPrestacaoPK.setNumeroProcessoAdministrativoExecucaoFiscal(numeroProcessoAdministrativo);


							GuiaPagamentoPrestacao guiaPagamentoPrestacaoInserir = new GuiaPagamentoPrestacao();
							guiaPagamentoPrestacaoInserir.setComp_id(guiaPagamentoPrestacaoPK);
							guiaPagamentoPrestacaoInserir.setDebitoTipo(debitoTipo);
							guiaPagamentoPrestacaoInserir.setDebitoCreditoSituacao(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));
							guiaPagamentoPrestacaoInserir.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
							guiaPagamentoPrestacaoInserir.setIndicadorPagamentoPendente(new Short("2"));
							guiaPagamentoPrestacaoInserir.setIndicadorCobrancaMulta(new Short("2"));
							guiaPagamentoPrestacaoInserir.setValorPrestacao(mapalistaDadosPrestacoesGuia.get(chaveDebitoTipo));
							guiaPagamentoPrestacaoInserir.setAnoMesReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
							guiaPagamentoPrestacaoInserir.setDataEmissao(new Date());
							guiaPagamentoPrestacaoInserir.setUltimaAlteracao(new Date());
							guiaPagamentoPrestacaoInserir.setDataVencimento(listaDadosPrestacaoGuiaHelper.getDataVencimentoPrestacao());

							guiaPagamentoPrestacaoInserir.setIndicadorDividaAtiva(ConstantesSistema.NAO);
							guiaPagamentoPrestacaoInserir.setDataDividaAtiva(null);
							guiaPagamentoPrestacaoInserir.setIndicadorExecucaoFiscal(ConstantesSistema.NAO);
							guiaPagamentoPrestacaoInserir.setDataExecucaoFiscal(null);

							getControladorUtil().inserir(guiaPagamentoPrestacaoInserir);

							// Adiciona ao objeto principal (GuiaPagamento, que será passado
							// no final para Geração de Resumo Faturamento
							if(guiaPagamento.getGuiasPagamentoPrestacao() == null){
								guiaPagamento.setGuiasPagamentoPrestacao(new TreeSet(new Comparator() {

									public int compare(Object a, Object b){

										String chave1 = ((GuiaPagamentoPrestacao) a).getComp_id().toString();
										String chave2 = ((GuiaPagamentoPrestacao) b).getComp_id().toString();

										return chave1.compareTo(chave2);

									}
								}));
							}

							guiaPagamento.getGuiasPagamentoPrestacao().add(guiaPagamentoPrestacaoInserir);

							GuiaPagamentoCategoriaHelper beanGuiaPagamentoCategoria = new GuiaPagamentoCategoriaHelper();
							beanGuiaPagamentoCategoria.setIdLancamentoItemContabil(guiaPagamentoPrestacaoInserir.getComp_id()
											.getItemLancamentoContabilId());
							beanGuiaPagamentoCategoria.setNumeroPrestacao(guiaPagamentoPrestacaoInserir.getComp_id().getNumeroPrestacao());

							// Acumula no Map que será usado na Categoria
							if(!mapValorPorItemLancamentoContabilPrestacao
											.containsKey(String.valueOf(beanGuiaPagamentoCategoria.hashCode()))){
								beanGuiaPagamentoCategoria.setValorAcumulado(guiaPagamentoPrestacaoInserir.getValorPrestacao());

								mapValorPorItemLancamentoContabilPrestacao.put(String.valueOf(beanGuiaPagamentoCategoria.hashCode()),
												beanGuiaPagamentoCategoria);
							}else{ // Ja possui valor para o Item Contabil e Prestação
								GuiaPagamentoCategoriaHelper beanMap = (GuiaPagamentoCategoriaHelper) mapValorPorItemLancamentoContabilPrestacao
												.get(String.valueOf(beanGuiaPagamentoCategoria.hashCode()));
								beanMap.setValorAcumulado(beanMap.getValorAcumulado()
												.add(guiaPagamentoPrestacaoInserir.getValorPrestacao()));

							}
						}
					}

					// 10.4.2.2. Número da Prestação = Número da Prestação mais 1 (um).
					numeroPrestacao++;
				}
			}

			if(idImovel != null && !idImovel.equals("")){

				// [UC0108] - Obter Quantidade de Economias por Categoria
				Collection colecaoCategoriasImovel = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

				// Alteração no UC - Ponto 8.5
				Iterator iterator = mapValorPorItemLancamentoContabilPrestacao.values().iterator();
				while(iterator.hasNext()){
					GuiaPagamentoCategoriaHelper beanCategoriaHelper = (GuiaPagamentoCategoriaHelper) iterator.next();

					// [UC0185] - Obter Valor por Categoria
					Collection colecaoValoresPorCategoria = getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
									beanCategoriaHelper.getValorAcumulado());

					Iterator icolecaoCategorias = colecaoCategoriasImovel.iterator();
					Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria.iterator();

					while(icolecaoValoresPorCategoria.hasNext() && icolecaoCategorias.hasNext()){
						Categoria categoria = (Categoria) icolecaoCategorias.next();
						BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria.next();

						GuiaPagamentoCategoria guiaPagamentoCategoriaInserir = new GuiaPagamentoCategoria();
						guiaPagamentoCategoriaInserir.setComp_id(new GuiaPagamentoCategoriaPK(categoria.getId(), guiaPagamento.getId(),
										beanCategoriaHelper.getIdLancamentoItemContabil(), beanCategoriaHelper.getNumeroPrestacao()));
						guiaPagamentoCategoriaInserir.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
						guiaPagamentoCategoriaInserir.setValorCategoria(valor);
						guiaPagamentoCategoriaInserir.setUltimaAlteracao(new Date());

						// ------------ REGISTRAR TRANSAÇÃO ----------------
						// registradorOperacao.registrarOperacao(guiaPagamentoCategoria);
						// ------------ REGISTRAR TRANSAÇÃO ----------------

						getControladorUtil().inserir(guiaPagamentoCategoriaInserir);

						// Adiciona ao objeto principal (GuiaPagamento, que será
						// passado no final para Geração de Resumo Faturamento
						if(guiaPagamento.getGuiasPagamentoCategoria() == null){
							guiaPagamento.setGuiasPagamentoCategoria(new TreeSet(new Comparator() {

								public int compare(Object a, Object b){

									String chave1 = ((GuiaPagamentoCategoria) a).getComp_id().toString();
									String chave2 = ((GuiaPagamentoCategoria) b).getComp_id().toString();

									return chave1.compareTo(chave2);

								}
							}));
						}
						guiaPagamento.getGuiasPagamentoCategoria().add(guiaPagamentoCategoriaInserir);
					}
				}

				FiltroClienteImovel filtroClienteImovel = new FiltroClienteImovel();

				filtroClienteImovel.adicionarCaminhoParaCarregamentoEntidade("cliente");
				filtroClienteImovel.adicionarCaminhoParaCarregamentoEntidade("clienteRelacaoTipo");
				filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.IMOVEL_ID, idImovel));
				filtroClienteImovel.adicionarParametro(new ParametroNulo(FiltroClienteImovel.DATA_FIM_RELACAO));

				Collection clientesImovel = getControladorUtil().pesquisar(filtroClienteImovel, ClienteImovel.class.getName());

				if(clientesImovel != null && !clientesImovel.isEmpty()){

					Iterator clienteImovelIterator = clientesImovel.iterator();

					while(clienteImovelIterator.hasNext()){

						ClienteImovel clienteImovel = (ClienteImovel) clienteImovelIterator.next();

						ClienteGuiaPagamento clienteGuiaPagamento = new ClienteGuiaPagamento();
						clienteGuiaPagamento.setGuiaPagamento(guiaPagamento);
						clienteGuiaPagamento.setCliente(clienteImovel.getCliente());
						clienteGuiaPagamento.setClienteRelacaoTipo(clienteImovel.getClienteRelacaoTipo());
						clienteGuiaPagamento.setUltimaAlteracao(new Date());

						// ------------ REGISTRAR TRANSAÇÃO ----------------
						// registradorOperacao.registrarOperacao(clienteGuiaPagamento);
						// ------------ REGISTRAR TRANSAÇÃO ----------------

						getControladorUtil().inserir(clienteGuiaPagamento);
					}

				}
			}else{
				// Pega os dados do cliente
				// Altreração no ponto 8.4 do UC

				Collection colecaoCategorias = new ArrayList();
				Categoria categoria = new Categoria();

				FiltroCliente filtroCliente = new FiltroCliente();

				filtroCliente.adicionarCaminhoParaCarregamentoEntidade("clienteTipo");
				filtroCliente.adicionarParametro(new ParametroSimples(FiltroCliente.ID, codigoCliente));
				filtroCliente.adicionarParametro(new ParametroSimples(FiltroCliente.INDICADOR_USO, ConstantesSistema.INDICADOR_USO_ATIVO));

				Collection colecaoCliente = getControladorUtil().pesquisar(filtroCliente, Cliente.class.getName());
				if(colecaoCliente != null && !colecaoCliente.isEmpty()){
					Cliente cliente = (Cliente) colecaoCliente.iterator().next();

					if(cliente.getClienteTipo().getId().equals(Integer.valueOf(ClienteTipo.INDICADOR_PESSOA_FISICA.intValue()))){
						categoria.setId(Categoria.RESIDENCIAL);
					}else{
						categoria.setId(Categoria.COMERCIAL);
					}
				}else{
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.pesquisa.cliente.inexistente.guia");
				}

				categoria.setQuantidadeEconomiasCategoria(Integer.valueOf("1"));
				colecaoCategorias.add(categoria);
				// Alteração no UC - Ponto 8.5

				Iterator iterator = mapValorPorItemLancamentoContabilPrestacao.values().iterator();
				while(iterator.hasNext()){
					GuiaPagamentoCategoriaHelper beanCategoriaHelper = (GuiaPagamentoCategoriaHelper) iterator.next();

					// [UC0185] - Obter Valor por Categoria
					Collection colecaoValoresPorCategoria = getControladorImovel().obterValorPorCategoria(colecaoCategorias,
									beanCategoriaHelper.getValorAcumulado());

					Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria.iterator();
					while(icolecaoValoresPorCategoria.hasNext()){
						GuiaPagamentoCategoria guiaPagamentoCategoriaInserir = new GuiaPagamentoCategoria(); // Só
						// existirá
						// 1
						// categoria
						// neste
						// caso.

						BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria.next();

						guiaPagamentoCategoriaInserir.setComp_id(new GuiaPagamentoCategoriaPK(categoria.getId(), guiaPagamento.getId(),
										beanCategoriaHelper.getIdLancamentoItemContabil(), beanCategoriaHelper.getNumeroPrestacao()));
						guiaPagamentoCategoriaInserir.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
						guiaPagamentoCategoriaInserir.setValorCategoria(valor);
						guiaPagamentoCategoriaInserir.setUltimaAlteracao(new Date());

						// ------------ REGISTRAR TRANSAÇÃO ----------------
						// registradorOperacao.registrarOperacao(guiaPagamentoCategoria);
						// ------------ REGISTRAR TRANSAÇÃO ----------------

						getControladorUtil().inserir(guiaPagamentoCategoriaInserir);

						// Adiciona ao objeto principal (GuiaPagamento, que será
						// passado no final para Geração de Resumo Faturamento
						if(guiaPagamento.getGuiasPagamentoCategoria() == null){
							guiaPagamento.setGuiasPagamentoCategoria(new TreeSet(new Comparator() {

								public int compare(Object a, Object b){

									String chave1 = ((GuiaPagamentoCategoria) a).getComp_id().toString();
									String chave2 = ((GuiaPagamentoCategoria) b).getComp_id().toString();

									return chave1.compareTo(chave2);

								}
							}));
						}
						guiaPagamento.getGuiasPagamentoCategoria().add(guiaPagamentoCategoriaInserir);

					}
				}

				if(codigoCliente != null){
					ClienteGuiaPagamento clienteGuiaPagamento = new ClienteGuiaPagamento();
					clienteGuiaPagamento.setGuiaPagamento(guiaPagamento);

					Cliente clienteAux = new Cliente();
					clienteAux.setId(Integer.valueOf(codigoCliente));

					clienteGuiaPagamento.setCliente(clienteAux);

					ClienteRelacaoTipo clienteRelacaoTipoAux = new ClienteRelacaoTipo();
					clienteRelacaoTipoAux
									.setId(Integer.valueOf(ParametroFaturamento.P_TIPO_RELACAO_ATUAL_TITULAR_DEBITO_IMOVEL.executar()));

					clienteGuiaPagamento.setClienteRelacaoTipo(clienteRelacaoTipoAux);
					clienteGuiaPagamento.setUltimaAlteracao(new Date());

					// ------------ REGISTRAR TRANSAÇÃO ----------------
					// registradorOperacao.registrarOperacao(clienteGuiaPagamento);
					// ------------ REGISTRAR TRANSAÇÃO ----------------

					getControladorUtil().inserir(clienteGuiaPagamento);
				}
			}

			// Registrando lançamento contábil de guia de pagamento.
			getControladorContabil().registrarLancamentoContabil(guiaPagamento, OperacaoContabil.INCLUIR_GUIA_PAGAMENTO);

			dataVencimentoFormatada = Util.adicionarNumeroDiasDeUmaData(dataVencimentoFormatada, qtdeDiasVencimento);

			// 8.8. Caso exista pagamento para a guia, classificar o pagamento da guia
			// [UC0300 – ClassificarPagamentosDevolucoes]
			if(guiaPagamento != null){
				Integer idGuia = guiaPagamento.getId();
				if(guiaPagamento.getNumeroPrestacaoTotal() != null){
					int qtdPrestacoes = guiaPagamento.getNumeroPrestacaoTotal().intValue();

					for(int i = 1; i <= qtdPrestacoes; i++){
						FiltroPagamento filtroPagamento = new FiltroPagamento();
						filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.GUIA_PAGAMENTO_ID, idGuia));
						filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.NUMERO_PRESTACAO, Integer.valueOf(i)));

						Collection<Pagamento> colecaoPagamentos = getControladorUtil()
										.pesquisar(filtroPagamento, Pagamento.class.getName());

						if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){
							// ** Alteração do Classificar **
							// getControladorArrecadacao().classificarPagamentos(colecaoPagamentos.iterator().next());
							getControladorArrecadacao().classificarPagamentosRegistroMovimentoArrecadadores(
											colecaoPagamentos.iterator().next());
							// ** Alteração do Classificar **
						}
					}
				}
			}
			// Realiza o Registro do ResumoFaturamento
			Collection colecaoGuiaPagamentoResumo = new ArrayList();
			colecaoGuiaPagamentoResumo.add(guiaPagamento);
			// this.gerarResumoFaturamento(colecaoGuiaPagamentoResumo);
			// getControladorFinanceiro().contabilizarEventoFaturamento(colecaoGuiaPagamentoResumo,
			// EventoContabil.INCLUSAO_GUIA_PAGAMENTO);

			// ------------ REGISTRAR TRANSAÇÃO ----------------

			Integer valorArgumento = null;
			if(guiaPagamento.getImovel() != null && guiaPagamento.getImovel().getId() != null){
				valorArgumento = guiaPagamento.getImovel().getId();
			}else if(guiaPagamento.getCliente() != null){
				valorArgumento = guiaPagamento.getCliente().getId();
			}

			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_GUIA_PAGAMENTO_INSERIR, valorArgumento,
							idGuiaPagamentoGerado, new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			registradorOperacao.registrarOperacao(guiaPagamento);
			// ------------ REGISTRAR TRANSAÇÃO ----------------
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return idGuiaPagamentoGerado;
	}


	/**
	 * [UC0187] Inserir Guia de Pagamento
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 21/05/2013
	 * @param debitoTipo
	 */
	public DebitoTipo filtrarDebitoTipo(Integer idTipoDebito) throws ControladorException{

		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();

		filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade("financiamentoTipo");
		filtroDebitoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");

		filtroDebitoTipo.limparListaParametros();
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idTipoDebito));
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO, ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection debitoTipoEncontrado = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

		DebitoTipo debitoTipo = null;

		if(debitoTipoEncontrado != null && !debitoTipoEncontrado.isEmpty()){
			debitoTipo = (DebitoTipo) debitoTipoEncontrado.iterator().next();
		}else{
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.faturamento.inserir_guia_pagamento_debito_invalido");
		}

		return debitoTipo;
	}

	/**
	 * Método que valida a Localidade antes de inserir a Guia de Pagamento
	 * 
	 * @author Saulo Lima
	 * @since 13/02/2009
	 * @param guiaPagamento
	 * @throws ControladorException
	 */
	private void validarLocalidadeSetorComercialGuiaPagamento(GuiaPagamento guiaPagamento) throws ControladorException{

		if(guiaPagamento.getImovel() != null && guiaPagamento.getImovel().getId() != null){
			// Localidade e Setor foram carregadas no Filtro
			guiaPagamento.setLocalidade(guiaPagamento.getImovel().getLocalidade());
			guiaPagamento.setSetorComercial(guiaPagamento.getImovel().getSetorComercial());
		}else if(guiaPagamento.getCliente() != null && guiaPagamento.getRegistroAtendimento() != null){
			guiaPagamento.setLocalidade(guiaPagamento.getRegistroAtendimento().getLocalidade());
			guiaPagamento.setSetorComercial(guiaPagamento.getRegistroAtendimento().getSetorComercial());
			// Setor não é obrigatório na RA
			try{
				if(guiaPagamento.getSetorComercial() == null){
					String codigoPadraoSetorComercial = ParametroCadastro.P_STCM_ID_SETOR_COMERCIAL_PADRAO.executar();
					if(codigoPadraoSetorComercial != null){
						SetorComercial setorComercialGuia = new SetorComercial();
						setorComercialGuia.setId(Integer.valueOf(codigoPadraoSetorComercial));
						guiaPagamento.setSetorComercial(setorComercialGuia);
					}
				}
			}catch(NumberFormatException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.faturamento.inserir_guia_pagamento_localidade_ou_setor_padrao_invalido");
			}
		}else{ // define os dados de localidade 'padrao' , no caso de não-identificação
			try{
				String codigoPadraoLocalidade = ParametroCadastro.P_LOCA_ID_LOCALIDADE_PADRAO.executar();
				if(codigoPadraoLocalidade != null){
					Localidade localidadeGuia = new Localidade();
					localidadeGuia.setId(Integer.valueOf(codigoPadraoLocalidade));
					guiaPagamento.setLocalidade(localidadeGuia);
				}

				String codigoPadraoSetorComercial = ParametroCadastro.P_STCM_ID_SETOR_COMERCIAL_PADRAO.executar();
				if(codigoPadraoSetorComercial != null){
					SetorComercial setorComercialGuia = new SetorComercial();
					setorComercialGuia.setId(Integer.valueOf(codigoPadraoSetorComercial));
					guiaPagamento.setSetorComercial(setorComercialGuia);
				}
			}catch(NumberFormatException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.faturamento.inserir_guia_pagamento_localidade_ou_setor_padrao_invalido");
			}
		}
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras [SB0005] - Processar Recebimento de
	 * Acrescimos por Impontualidade
	 * 
	 * @author Sávio Luiz
	 * @since 07/10/2006
	 * @author Saulo Lima
	 * @date 12/01/2009 Adicionar a GuiaPagamentoPrestacao
	 * @author Saulo Lima
	 * @date 16/03/2009, 02/04/2009 Adicionar o documentoTipo Remoção de objetos desnecessários
	 * @param guiaPagamento
	 * @param idDebitoTipo
	 * @param dataPagamento
	 * @return idGuiaPagamentoGerado (Integer)
	 * @throws ControladorException
	 */
	public Integer inserirGuiaPagamentoCodigoBarras(GuiaPagamento guiaPagamento, Integer idDebitoTipo, Date dataPagamento)
					throws ControladorException{

		String valorDebito = guiaPagamento.getValorDebito().toString();
		Date dataVencimentoFormatada = new Date();

		GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();

		// valor fixo
		Short indicadorHistorico = 2;
		guiaPagamentoGeral.setIndicadorHistorico(indicadorHistorico);

		// Ultima Alteração
		guiaPagamentoGeral.setUltimaAlteracao(new Date());

		Integer idGuiaPagamentoGerado = (Integer) getControladorUtil().inserir(guiaPagamentoGeral);
		guiaPagamentoGeral.setId(idGuiaPagamentoGerado);
		guiaPagamento.setGuiaPagamentoGeral(guiaPagamentoGeral);
		guiaPagamento.setId(idGuiaPagamentoGerado);

		if(guiaPagamento.getImovel() != null){

			Imovel imovel = getControladorImovel().pesquisarImovel(guiaPagamento.getImovel().getId());
			guiaPagamento.setLocalidade(imovel.getLocalidade());
			guiaPagamento.setImovel(imovel);
			guiaPagamento.setCliente(null);

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			if(sistemaParametro == null){
				throw new ControladorException("erro.sistema");
			}

			DebitoTipo debitoTipo = this.getDebitoTipoHql(idDebitoTipo);
			if(debitoTipo == null){
				throw new ControladorException("erro.sistema");
			}

			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

			guiaPagamento.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
			guiaPagamento.setValorDebito(new BigDecimal(valorDebito));
			guiaPagamento.setRegistroAtendimento(null);
			guiaPagamento.setOrdemServico(null);
			guiaPagamento.setDataInclusao(new Date());
			guiaPagamento.setUltimaAlteracao(new Date());
			guiaPagamento.setNumeroPrestacaoTotal(new Short("1"));

			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
			guiaPagamento.setDocumentoTipo(documentoTipo);

			// Localidade e Setor Comercial
			this.validarLocalidadeSetorComercialGuiaPagamento(guiaPagamento);

			getControladorUtil().inserir(guiaPagamento);

			// Inclui as prestações da guia de pagamento na tabela GUIA_PAGAMENTO_PRESTACAO
			GuiaPagamentoPrestacaoPK comp_id = new GuiaPagamentoPrestacaoPK();
			comp_id.setGuiaPagamentoId(guiaPagamento.getId());
			comp_id.setNumeroPrestacao(new Short("1"));
			comp_id.setDebitoTipoId(idDebitoTipo);
			comp_id.setItemLancamentoContabilId(LancamentoItemContabil.ACRESCIMOS_POR_IMPONTUALIDADE);
			comp_id.setNumeroProcessoAdministrativoExecucaoFiscal(ConstantesSistema.NUMERO_PROCESSO_ADM_EXEC_FISCAL_ZERO);

			GuiaPagamentoPrestacao guiaPagamentoPrestacao = new GuiaPagamentoPrestacao();
			guiaPagamentoPrestacao.setComp_id(comp_id);
			guiaPagamentoPrestacao.setGuiaPagamento(guiaPagamento);
			guiaPagamentoPrestacao.setDebitoCreditoSituacao(debitoCreditoSituacao);
			guiaPagamentoPrestacao.setDebitoTipo(debitoTipo);
			LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil(LancamentoItemContabil.ACRESCIMOS_POR_IMPONTUALIDADE);
			guiaPagamentoPrestacao.setLancamentoItemContabil(lancamentoItemContabil);
			guiaPagamentoPrestacao.setValorPrestacao(guiaPagamento.getValorDebito());
			guiaPagamentoPrestacao.setDataVencimento(dataPagamento);
			guiaPagamentoPrestacao.setIndicadorCobrancaMulta(new Short("1"));
			guiaPagamentoPrestacao.setIndicadorPagamentoPendente(new Short("1"));
			guiaPagamentoPrestacao.setAnoMesReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
			guiaPagamentoPrestacao.setDataEmissao(new Date());
			guiaPagamentoPrestacao.setUltimaAlteracao(new Date());
			guiaPagamentoPrestacao.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());

			guiaPagamentoPrestacao.setIndicadorDividaAtiva(ConstantesSistema.NAO);
			guiaPagamentoPrestacao.setDataDividaAtiva(null);
			guiaPagamentoPrestacao.setIndicadorExecucaoFiscal(ConstantesSistema.NAO);
			guiaPagamentoPrestacao.setDataExecucaoFiscal(null);

			Set<GuiaPagamentoPrestacao> setGuiaPagamentoPrestacao = new HashSet<GuiaPagamentoPrestacao>();
			setGuiaPagamentoPrestacao.add(guiaPagamentoPrestacao);
			guiaPagamento.setGuiasPagamentoPrestacao(setGuiaPagamentoPrestacao);
			for(GuiaPagamentoPrestacao prestacao : setGuiaPagamentoPrestacao){
				this.getControladorUtil().inserir(prestacao);
			}

			GuiaPagamentoCategoria guiaPagamentoCategoria = new GuiaPagamentoCategoria();

			// [UC0108] - Obter Quantidade de Economias por Categoria
			Collection colecaoCategoriasImovel = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

			// [UC0185] - Obter Valor por Categoria
			Collection colecaoValoresPorCategoria = getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
							guiaPagamento.getValorDebito());

			HashSet colecaoGuiaPagamentoCategoria = new HashSet();

			Iterator icolecaoCategorias = colecaoCategoriasImovel.iterator();
			Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria.iterator();
			while(icolecaoValoresPorCategoria.hasNext() && icolecaoCategorias.hasNext()){
				Categoria categoria = (Categoria) icolecaoCategorias.next();
				BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria.next();

				guiaPagamentoCategoria.setComp_id(new GuiaPagamentoCategoriaPK(categoria.getId(), guiaPagamento.getId(), debitoTipo
								.getLancamentoItemContabil().getId(), new Short("1")));
				guiaPagamentoCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
				guiaPagamentoCategoria.setValorCategoria(valor);
				guiaPagamentoCategoria.setUltimaAlteracao(new Date());
				guiaPagamentoCategoria.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());

				getControladorUtil().inserir(guiaPagamentoCategoria);
				colecaoGuiaPagamentoCategoria.add(guiaPagamentoCategoria);
			}
			if(!Util.isVazioOrNulo(colecaoGuiaPagamentoCategoria)){
				guiaPagamento.setGuiasPagamentoCategoria(colecaoGuiaPagamentoCategoria);
			}
			// Registrando lançamento contábil de guia de pagamento.
			getControladorContabil().registrarLancamentoContabil(guiaPagamento, OperacaoContabil.INCLUIR_GUIA_PAGAMENTO);

			Collection colecaoParmsClienteImovel = null;
			try{
				colecaoParmsClienteImovel = repositorioClienteImovel.pesquisarParmsClienteImovel(guiaPagamento.getImovel().getId());

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			if(colecaoParmsClienteImovel != null && !colecaoParmsClienteImovel.isEmpty()){

				Iterator clienteImovelIterator = colecaoParmsClienteImovel.iterator();

				while(clienteImovelIterator.hasNext()){

					Object[] parmsClienteImovel = (Object[]) clienteImovelIterator.next();

					if(parmsClienteImovel != null){
						Cliente cliente = null;
						ClienteRelacaoTipo clienteRelacaoTipo = null;
						if(parmsClienteImovel[0] != null){
							cliente = new Cliente();
							cliente.setId((Integer) parmsClienteImovel[0]);
						}
						if(parmsClienteImovel[1] != null){
							clienteRelacaoTipo = new ClienteRelacaoTipo();
							clienteRelacaoTipo.setId((Integer) parmsClienteImovel[1]);
						}

						ClienteGuiaPagamento clienteGuiaPagamento = new ClienteGuiaPagamento();
						clienteGuiaPagamento.setGuiaPagamento(guiaPagamento);
						clienteGuiaPagamento.setCliente(cliente);
						clienteGuiaPagamento.setClienteRelacaoTipo(clienteRelacaoTipo);
						clienteGuiaPagamento.setUltimaAlteracao(new Date());

						getControladorUtil().inserir(clienteGuiaPagamento);
					}
				}
			}
		}

		return idGuiaPagamentoGerado;
	}

	/**
	 * [UC0188] - Manter Guia de Pagamento
	 * 
	 * @author Rafael Corrêa, Pedro Alexandre
	 * @param usuarioLogado
	 * @since 16/01/2006, 23/11/2006
	 * @author eduardo henrique
	 * @date 07/08/2008 Alterações no UC, [SB0001] - Cancelar Guia Pagamento para a v0.04.
	 * @author Saulo Lima
	 * @date 29/11/2008 Alteração no método para chamar a Classificação de Pagamento e Devoluções
	 *       [UC0300]
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desabilitar a Contabilização por Evento.
	 * @throws ControladorException
	 */
	// FIXME FRC
	public void cancelarGuiaPagamento(Collection<GuiaPagamentoPrestacaoHelper> guiasPagamento, String[] registrosRemocao,
					boolean indicadorContabilizar, Usuario usuarioLogado) throws ControladorException{

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		if(sistemaParametro == null){
			throw new ControladorException("erro.sistema"); // TODO Cadastrar
			// Mensagem
		}

		if(guiasPagamento == null || guiasPagamento.isEmpty() || registrosRemocao == null || (registrosRemocao.length == 0)){
			throw new ControladorException("atencao.nenhuma.guia.selecionada");
		}

		try{
			// Verifica o que foi 'marcado' para cancelamento e monta a coleção
			Map mapPrestacoesGuiaPagamentoCancelar = new HashMap<Integer, GuiaPagamento>();

			FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = null;

			for(int i = 0; i < registrosRemocao.length; i++){

				for(GuiaPagamentoPrestacaoHelper beanGuiaPagamentoHelper : guiasPagamento){

					if(registrosRemocao[i].equals(beanGuiaPagamentoHelper.getId().toString())){
						Collection colecaoGuiasPagamentoPrestacaoCancelar = new ArrayList();

						GuiaPagamentoPrestacao guiaPagamentoPrestacaoCancelar = null;

						FiltroGuiaPagamentoPrestacao filtroGuiaPagamentoPrestacao = new FiltroGuiaPagamentoPrestacao();
						filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento");
						filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento.imovel");
						filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento.imovel.cobrancaSituacao");
						filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento.cliente");
						filtroGuiaPagamentoPrestacao.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento.localidade");

						filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(
										FiltroGuiaPagamentoPrestacao.GUIA_PAGAMENTO_ID, beanGuiaPagamentoHelper.getIdGuiaPagamento()));
						filtroGuiaPagamentoPrestacao.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoPrestacao.NUMERO_PRESTACAO,
										beanGuiaPagamentoHelper.getNumeroPrestacao()));

						// Consulta todos os 'tipos' de Prestações para cada Nr. de
						// Prestação
						Collection colecaoGuiaPagamentoPrestacao = getControladorUtil().pesquisar(filtroGuiaPagamentoPrestacao,
										GuiaPagamentoPrestacao.class.getName());
						if(colecaoGuiaPagamentoPrestacao == null || colecaoGuiaPagamentoPrestacao.isEmpty()){
							System.out.println("Indentificação do objeto não localizado 'GuiaPagamentoPrestacao': Guia e Prestação "
											+ beanGuiaPagamentoHelper.getIdGuiaPagamento() + " "
											+ beanGuiaPagamentoHelper.getNumeroPrestacao());
							throw new ControladorException("atencao.atualizacao.removido");
						}

						for(Iterator iteratorGuiaPrestacao = colecaoGuiaPagamentoPrestacao.iterator(); iteratorGuiaPrestacao.hasNext();){
							guiaPagamentoPrestacaoCancelar = (GuiaPagamentoPrestacao) iteratorGuiaPrestacao.next();

							if(guiaPagamentoPrestacaoCancelar.getGuiaPagamento().getImovel() != null){ // [FS0004]

								// filtroImovelCobrancaSituacao = new
								// FiltroImovelCobrancaSituacao();
								//
								// filtroImovelCobrancaSituacao.adicionarCaminhoParaCarregamentoEntidade("cobrancaSituacao");
								// filtroImovelCobrancaSituacao.adicionarParametro(new
								// ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID,
								// guiaPagamentoPrestacaoCancelar.getGuiaPagamento().getImovel().getId()));
								//
								// Collection imovelCobrancaSituacaoEncontrada =
								// getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,ImovelCobrancaSituacao.class.getName());

								// Verifica se o imóvel foi excluído
								if(guiaPagamentoPrestacaoCancelar.getGuiaPagamento().getImovel().getIndicadorExclusao() == null ? false
												: guiaPagamentoPrestacaoCancelar.getGuiaPagamento().getImovel().getIndicadorExclusao()
																.equals(Imovel.IMOVEL_EXCLUIDO)){
									sessionContext.setRollbackOnly();
									throw new ControladorException("atencao.imovel.excluido");
								}

								// Código comentado para a customização da cobrança administrativa
								// CASAL

								// Verifica se o imóvel tem débito em cobrança administrativa

								// if(imovelCobrancaSituacaoEncontrada != null &&
								// !imovelCobrancaSituacaoEncontrada.isEmpty()){
								// if(((ImovelCobrancaSituacao) ((List)
								// imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao()
								// != null){
								// if(((ImovelCobrancaSituacao) ((List)
								// imovelCobrancaSituacaoEncontrada).get(0))
								// .getCobrancaSituacao().getId().equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
								// && ((ImovelCobrancaSituacao) ((List)
								// imovelCobrancaSituacaoEncontrada).get(0))
								// .getDataRetiradaCobranca() == null){
								// sessionContext.setRollbackOnly();
								// throw new
								// ControladorException("atencao.pesquisa.imovel.cobranca_administrativa");
								// }
								// }
								// }

								Abrangencia abrangencia = new Abrangencia(usuarioLogado, guiaPagamentoPrestacaoCancelar.getGuiaPagamento()
												.getImovel());

								if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
									sessionContext.setRollbackOnly();
									throw new ControladorException("atencao.acesso.negado.abrangencia");
								}

							}
							if(guiaPagamentoPrestacaoCancelar.getGuiaPagamento().getCliente() != null){ // [FS0005]
								filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();

								filtroImovelCobrancaSituacao.adicionarCaminhoParaCarregamentoEntidade("cobrancaSituacao");
								filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(
												FiltroImovelCobrancaSituacao.CLIENTE_ID, guiaPagamentoPrestacaoCancelar.getGuiaPagamento()
																.getCliente().getId()));

								// Código comentado para a customização da cobrança administrativa
								// CASAL

								// Collection imovelCobrancaSituacaoEncontrada =
								// getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
								// ImovelCobrancaSituacao.class.getName());

								// Verifica se o cliente tem débito em cobrança administrativa

								// if(imovelCobrancaSituacaoEncontrada != null &&
								// !imovelCobrancaSituacaoEncontrada.isEmpty()){
								// if(((ImovelCobrancaSituacao) ((List)
								// imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao()
								// != null){
								// if(((ImovelCobrancaSituacao) ((List)
								// imovelCobrancaSituacaoEncontrada).get(0))
								// .getCobrancaSituacao().getId().equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
								// && ((ImovelCobrancaSituacao) ((List)
								// imovelCobrancaSituacaoEncontrada).get(0))
								// .getDataRetiradaCobranca() == null){
								// sessionContext.setRollbackOnly();
								// throw new
								// ControladorException("atencao.pesquisa.imovel.cobranca_administrativa");
								// }
								// }
								// }
							}
							// Seta a situação da Prestação como Cancelada
							guiaPagamentoPrestacaoCancelar.setDebitoCreditoSituacao(new DebitoCreditoSituacao(
											DebitoCreditoSituacao.CANCELADA));

							colecaoGuiasPagamentoPrestacaoCancelar.add(guiaPagamentoPrestacaoCancelar); // será

							// utilizada na Geração do Resumo de Fat. (Contabil. por Evento)

							// Verifica se são prestações de uma guia já adicionada
							// ao Map
							if(!mapPrestacoesGuiaPagamentoCancelar.containsKey(beanGuiaPagamentoHelper.getIdGuiaPagamento())){
								GuiaPagamento guiaPagamentoCancelar = new GuiaPagamento();
								guiaPagamentoCancelar.setId(beanGuiaPagamentoHelper.getIdGuiaPagamento());
								guiaPagamentoCancelar.setLocalidade(guiaPagamentoPrestacaoCancelar.getGuiaPagamento().getLocalidade());
								guiaPagamentoCancelar.setImovel(guiaPagamentoPrestacaoCancelar.getGuiaPagamento().getImovel());
								guiaPagamentoCancelar.setSetorComercial(guiaPagamentoPrestacaoCancelar.getGuiaPagamento()
												.getSetorComercial());

								guiaPagamentoCancelar.setGuiasPagamentoPrestacao(new HashSet());
								guiaPagamentoCancelar.getGuiasPagamentoPrestacao().add(guiaPagamentoPrestacaoCancelar);

								// Pesquisa as categorias da Guia Pagamento, que será utilizada na
								// Contabilização
								guiaPagamentoCancelar.setGuiasPagamentoCategoria(new HashSet());
								FiltroGuiaPagamentoCategoria filtroGuiaPagamentoCategoria = new FiltroGuiaPagamentoCategoria();
								filtroGuiaPagamentoCategoria.adicionarParametro(new ParametroSimples(
												FiltroGuiaPagamentoCategoria.GUIA_PAGAMENTO_ID, beanGuiaPagamentoHelper
																.getIdGuiaPagamento()));

								Collection colecaoCategoriasGuiaPagamento = getControladorUtil().pesquisar(filtroGuiaPagamentoCategoria,
												GuiaPagamentoCategoria.class.getName());
								guiaPagamentoCancelar.getGuiasPagamentoCategoria().addAll(colecaoCategoriasGuiaPagamento);

								// Consulta a Guia para recuperar o Parcelamento (PARC_ID), caso
								// exista
								FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
								filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.PARCELAMENTO);
								filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, beanGuiaPagamentoHelper
												.getIdGuiaPagamento()));

								GuiaPagamento guiaPagamentoBase = (GuiaPagamento) Util.retonarObjetoDeColecao((Collection) this
												.getControladorUtil().pesquisar(filtroGuiaPagamento, GuiaPagamento.class.getName()));

								if(guiaPagamentoBase.getParcelamento() != null){
									guiaPagamentoCancelar.setParcelamento(guiaPagamentoBase.getParcelamento());
								}
								
								if(guiaPagamentoBase.getRegistroAtendimento() != null){
									guiaPagamentoCancelar.setRegistroAtendimento(guiaPagamentoBase.getRegistroAtendimento());
								}								

								mapPrestacoesGuiaPagamentoCancelar.put(beanGuiaPagamentoHelper.getIdGuiaPagamento(), guiaPagamentoCancelar);
							}else{
								GuiaPagamento guiaPagamentoMap = (GuiaPagamento) mapPrestacoesGuiaPagamentoCancelar
												.get(beanGuiaPagamentoHelper.getIdGuiaPagamento());

								guiaPagamentoMap.getGuiasPagamentoPrestacao().add(guiaPagamentoPrestacaoCancelar);
							}
						}
					}
				}
			}

			// Passa a coleção de Guias para Contabilização
			// getControladorFinanceiro().contabilizarEventoFaturamento(mapPrestacoesGuiaPagamentoCancelar.values(),
			// EventoContabil.CANCELAMENTO_GUIA_PAGAMENTO);

			// PARTE 1 - Caso exista pagamento para a guia, classificar o pagamento da guia
			// [UC0300 – ClassificarPagamentosDevolucoes]
			Collection<Collection<Pagamento>> colecaoDeColecoes = new ArrayList<Collection<Pagamento>>();
			if(mapPrestacoesGuiaPagamentoCancelar.values() != null && !mapPrestacoesGuiaPagamentoCancelar.values().isEmpty()){
				Iterator<GuiaPagamento> guiaIterator = mapPrestacoesGuiaPagamentoCancelar.values().iterator();
				while(guiaIterator.hasNext()){
					GuiaPagamento guiaPagamento = guiaIterator.next();
					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.GUIA_PAGAMENTO_ID, guiaPagamento.getId()));

					Collection<Pagamento> colecaoPagamentos = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());
					if(colecaoPagamentos != null && !colecaoPagamentos.isEmpty()){
						colecaoDeColecoes.add(colecaoPagamentos);
					}
				}
			}

			// Contabiliza o cancelamento do pagamento
			if(indicadorContabilizar){		
				// Registro de lançamento contábil de guia de pagamento.
				for(GuiaPagamento guiaPagamento : (Collection<GuiaPagamento>) mapPrestacoesGuiaPagamentoCancelar.values()){
					if(guiaPagamento.getParcelamento() != null && guiaPagamento.getParcelamento().getId() != null){
						getControladorContabil().registrarLancamentoContabil(guiaPagamento,
										OperacaoContabil.CANCELAR_PARCELAMENTO_SALDO_CURTO_PRAZO);
					}else{
						getControladorContabil().registrarLancamentoContabil(guiaPagamento, OperacaoContabil.CANCELAR_GUIA_PAGAMENTO);
					}
				}
			}

			boolean indicadorParcelamento = false;

			// Transfere as informações das Prestações para o histórico (Prestação e Categoria)
			getControladorArrecadacao().transferirGuiaPagamentoParaHistorico(mapPrestacoesGuiaPagamentoCancelar.values(), usuarioLogado,
							Operacao.OPERACAO_GUIA_PAGAMENTO_CANCELAR, indicadorParcelamento);

			// PARTE 2 - Caso exista pagamento para a guia, classificar o pagamento da guia
			// [UC0300 – ClassificarPagamentosDevolucoes]
			if(colecaoDeColecoes != null && !colecaoDeColecoes.isEmpty()){
				Iterator<Collection<Pagamento>> colecaoDeColecoesIterator = colecaoDeColecoes.iterator();

				while(colecaoDeColecoesIterator.hasNext()){
					Collection<Pagamento> colecaoPagamentos = colecaoDeColecoesIterator.next();
					for(Pagamento pagamento : colecaoPagamentos){
						// ** Alteração do Classificar **
						// getControladorArrecadacao().classificarPagamentos(pagamento);
						getControladorArrecadacao().classificarPagamentosRegistroMovimentoArrecadadores(pagamento);
						// ** Alteração do Classificar **
					}
				}
			}

			if(mapPrestacoesGuiaPagamentoCancelar != null){
				// Verificar e Atualizar Itens Documento de Cobrança e da Cobrança Administrativa
				Collection<GuiaPagamento> colecaoGuiaPagamento = mapPrestacoesGuiaPagamentoCancelar.values();

				if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){
					Short numeroPrestacao = null;

					Integer idGuiaPagamento = null;

					GuiaPagamentoPrestacaoPK compId = null;

					Set<GuiaPagamentoPrestacao> guiasPagamentoPrestacao = null;

					for(GuiaPagamento guiaPagamento : colecaoGuiaPagamento){
						idGuiaPagamento = guiaPagamento.getId();

						guiasPagamentoPrestacao = guiaPagamento.getGuiasPagamentoPrestacao();

						if(guiasPagamentoPrestacao != null){
							for(GuiaPagamentoPrestacao guiaPagamentoPrestacao : guiasPagamentoPrestacao){
								compId = guiaPagamentoPrestacao.getComp_id();
								numeroPrestacao = compId.getNumeroPrestacao();

								this.getControladorCobranca().atualizarItemDocumentoCobranca(null, idGuiaPagamento, numeroPrestacao, null,
												CobrancaDebitoSituacao.CANCELADO, new Date(), CobrancaDebitoSituacao.PENDENTE);
							}
						}

					}

					this.atualizarCobrancaDocumentoItemGuiaCobrancaAdministrativa(mapPrestacoesGuiaPagamentoCancelar.values());
				}
			}
		}catch(Exception e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Verifica se o Mês/Ano informado é inferior ao Mês/Ano do Sistema
	 * 
	 * @param anoMesFaturamento
	 * @return
	 * @throws ControladorException
	 */
	public boolean verificarReferenciaFaturamentoCorrente(String anoMesFaturamento) throws ControladorException{

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		boolean verificacao = Util.compararAnoMesReferencia(anoMesFaturamento.substring(3, 7) + anoMesFaturamento.substring(0, 2),
						sistemaParametro.getAnoMesFaturamento().toString(), ">");

		if(verificacao){
			String anoMesSistema = sistemaParametro.toString();

			throw new ControladorException("atencao.faturamento.ano_mes.inferior", null, anoMesSistema.substring(0, 2) + "/"
							+ anoMesSistema.substring(3, 7));

		}

		return true;

	}

/**
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author Rhawi Dantas
	 * @created 18/01/2006
	 */
	public void inserirFaturamentoSituacaoHistorico(Collection collectionFaturamentoSituacaoHistorico,
					RegistradorOperacao registradorOperacao) throws ControladorException{

		try{

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			Operacao operacao = new Operacao(Operacao.OPERACAO_VALIDAR_SITUACAO_ESPECIAL_FATURAMENTO);
			operacaoEfetuada.setOperacao(operacao);

			Iterator iteratorFSH = collectionFaturamentoSituacaoHistorico.iterator();
			while(iteratorFSH.hasNext()){
				FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = (FaturamentoSituacaoHistorico) iteratorFSH.next();

				faturamentoSituacaoHistorico.setOperacaoEfetuada(operacaoEfetuada);
				registradorOperacao.registrarOperacao(faturamentoSituacaoHistorico);

				Collection<FaturamentoSituacaoHistorico> colecao = this.repositorioFaturamento
								.pesquisarFaturamentoSituacaoHistoricoAtivoImovel(faturamentoSituacaoHistorico.getImovel().getId());

				if(!Util.isVazioOrNulo(colecao)){
					Iterator iterator = colecao.iterator();
					while(iterator.hasNext()){
						FaturamentoSituacaoHistorico fsh = (FaturamentoSituacaoHistorico) iterator.next();

						FaturamentoGrupo faturamentoGrupo = this.getControladorImovel().pesquisarGrupoImovel(fsh.getImovel().getId());

						fsh.setAnoMesFaturamentoRetirada(faturamentoGrupo.getAnoMesReferencia());
						fsh.setUltimaAlteracao(new Date());

						fsh.setOperacaoEfetuada(operacaoEfetuada);
						registradorOperacao.registrarOperacao(fsh);

						this.getControladorUtil().atualizar(fsh);
					}
				}else{
					this.getControladorUtil().inserir(faturamentoSituacaoHistorico);
				}
			}



		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}


	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar Relatório de Resumo
	 * Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Rodrigo Silveira,Vivianne Sousa
	 * @created 18/01/2006 , 18/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorio(String opcaoTotalizacao, int mesAnoReferencia, Integer gerenciaRegional,
					Integer localidade, Integer unidadeNegocio) throws ControladorException{

		Collection retorno = new ArrayList();
		Collection colecaoResumoFaturamentoRelatorio = null;

		// Converter de mesAno para anoMes para que funcione nas consultas
		int anoMesReferencia = Util.formatarMesAnoParaAnoMes(mesAnoReferencia);
		boolean consultarResumoFaturamentoRelatorio = true;

		try{

			if(opcaoTotalizacao.equals("estado")){
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento.consultarResumoFaturamentoRelatorioPorEstado(anoMesReferencia);

			}else if(opcaoTotalizacao.equals("estadoGerencia")){
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento
								.consultarResumoFaturamentoRelatorioPorEstadoPorGerenciaRegional(anoMesReferencia);

			}else if(opcaoTotalizacao.equals("estadoLocalidade")){

				consultarResumoFaturamentoRelatorio = false;

				retorno = consultarResumoFaturamentoRelatorioPorEstadoPorLocalidade(anoMesReferencia);

			}else if(opcaoTotalizacao.equals("gerenciaRegional")){
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento.consultarResumoFaturamentoRelatorioPorGerenciaRegional(
								anoMesReferencia, gerenciaRegional);

			}else if(opcaoTotalizacao.equals("gerenciaRegionalLocalidade")){
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento
								.consultarResumoFaturamentoRelatorioPorGerenciaRegionalPorLocalidade(anoMesReferencia, gerenciaRegional);

			}else if(opcaoTotalizacao.equals("localidade")){
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento.consultarResumoFaturamentoRelatorioPorLocalidade(
								anoMesReferencia, localidade);

			}else if(opcaoTotalizacao.equals("estadoUnidadeNegocio")){

				consultarResumoFaturamentoRelatorio = false;

				retorno = consultarResumoFaturamentoRelatorioEstadoPorUnidadeNegocio(anoMesReferencia);

			}else if(opcaoTotalizacao.equals("unidadeNegocio")){
				colecaoResumoFaturamentoRelatorio = repositorioFaturamento.consultarResumoFaturamentoRelatorioPorUnidadeNegocio(
								anoMesReferencia, unidadeNegocio);

			}

			if(consultarResumoFaturamentoRelatorio){

				Iterator iterator = colecaoResumoFaturamentoRelatorio.iterator();

				// Prepara cada linha do relatório

				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String idLocalidadeAnterior = null;
				String descLancamentoTipoSuperior = "";

				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				Boolean agrupaPorGerencia = false;
				if(opcaoTotalizacao.equalsIgnoreCase("estadoGerencia") || opcaoTotalizacao.equalsIgnoreCase("gerenciaRegional")){
					agrupaPorGerencia = true;
				}

				Boolean agrupaPorLocalidade = false;
				if(opcaoTotalizacao.equalsIgnoreCase("estadoLocalidade") || opcaoTotalizacao.equalsIgnoreCase("gerenciaRegionalLocalidade")
								|| opcaoTotalizacao.equalsIgnoreCase("localidade")){
					agrupaPorLocalidade = true;
				}

				Boolean agrupaPorUnidadeNegocio = false;
				if(opcaoTotalizacao.equalsIgnoreCase("unidadeNegocio") || opcaoTotalizacao.equalsIgnoreCase("estadoUnidadeNegocio")){
					agrupaPorUnidadeNegocio = true;
				}

				while(iterator.hasNext()){
					Object[] element = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;

					element = (Object[]) iterator.next();

					if(tipoLancamento == null){
						tipoLancamento = (String) element[1];
						itemLancamento = (String) element[2];
						itemContabel = (String) element[3];
					}

					tempTipoLancamento = (String) element[1];
					tempItemLancamento = (String) element[2];
					tempItemContabel = (String) element[3];

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if(tipoLancamento.equals(tempTipoLancamento) && itemLancamento.equals(tempItemLancamento)){

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if(itemContabel == null && tempItemContabel == null
										|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

							// se for agrupado por gerencia
							// compara se o registro atual eh da
							// mesma gerencia regional do registro anterior
							if(!agrupaPorGerencia || descGerenciaRegionalAnterior == null
											|| (agrupaPorGerencia && descGerenciaRegionalAnterior.equalsIgnoreCase((String) element[9]))){

								switch(((Integer) element[8]).intValue()){
									case 1:
										arrayValores[0] = (BigDecimal) element[0];
										break;
									case 2:
										arrayValores[1] = (BigDecimal) element[0];
										break;
									case 3:
										arrayValores[2] = (BigDecimal) element[0];
										break;
									case 4:
										arrayValores[4] = (BigDecimal) element[0];
										break;
								}
							}else{
								condicaoIgual = false;
							}

						}else{

							condicaoIgual = false;
						}

					}else{

						condicaoIgual = false;

					}

					if(!condicaoIgual){

						ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
										(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
										(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
										(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
										idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior,
										descLancamentoTipoSuperior, descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

						retorno.add(resumoFaturamentoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch(((Integer) element[8]).intValue()){
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
						}

					}

					elementAnterior[1] = element[1]; // descricaoTipoLancamento
					if(((String) element[1]).equalsIgnoreCase((String) element[2])){
						elementAnterior[2] = null; // descricaoItemLancamento
					}else{
						elementAnterior[2] = element[2]; // descricaoItemLancamento
					}

					elementAnterior[3] = element[3]; // descricaoItemContabil
					elementAnterior[4] = element[4]; // indicadorImpressao
					elementAnterior[5] = element[5]; // indicadorTotal
					elementAnterior[6] = element[6]; // lancamentoTipo
					elementAnterior[7] = element[7]; // lancamentoTipoSuperior

					// identifica pelo que vai ser "quebrado" o relátorio
					if(agrupaPorGerencia){
						// quebra página por Gerência Regional e não mostra a
						// Localidade
						descGerenciaRegionalAnterior = "" + element[9];
						idGerenciaRegionalAnterior = "" + element[10];
					}
					if(agrupaPorLocalidade){
						if(opcaoTotalizacao.equalsIgnoreCase("estadoLocalidade")
										|| opcaoTotalizacao.equalsIgnoreCase("gerenciaRegionalLocalidade")){
							// quebra a página por Localidade e mostra a
							// Gerência
							// Regional
							descGerenciaRegionalAnterior = "" + element[9];
							idGerenciaRegionalAnterior = "" + element[10];
							descLocalidadeAnterior = "" + element[11];
							idLocalidadeAnterior = "" + element[12];
						}else{
							// quebra a página por Localidade e não mostra a
							// Gerência
							// Regional
							descLocalidadeAnterior = "" + element[9];
							idLocalidadeAnterior = "" + element[10];
						}
					}

					if(agrupaPorUnidadeNegocio){
						descUnidadeNegocioAnterior = "" + element[9];
						idUnidadeNegocioAnterior = "" + element[10];

					}

					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;

				}

				if(colecaoResumoFaturamentoRelatorio != null && !colecaoResumoFaturamentoRelatorio.isEmpty()){
					// adiciona a ultima linha

					ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
									(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
									(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
									(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
									idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
									descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

					retorno.add(resumoFaturamentoRelatorioHelper);
				}

			}

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0194] - Inserir Crédito a Realizar
	 * 
	 * @author Roberta Costa
	 * @since 12/01/2006
	 * @author eduardo henrique
	 * @date 31/10/2008 Alteração no método, para adicionar ao CreditoARealizar, seus respectivos
	 *       CreditoARealizarCategoria.
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desabilitar a Contabilização por Evento.
	 * @param imovel
	 *            Imovel
	 * @param creditoARealizar
	 *            CreditoARealizar
	 * @param usuario
	 *            Usuário Logado no Sistema
	 * @throws ControladorException
	 */
	public void inserirCreditoARealizar(Imovel imovel, CreditoARealizar creditoARealizar, Usuario usuarioLogado)
					throws ControladorException{

		try{

			this.inserirCreditoARealizar(imovel, creditoARealizar, usuarioLogado, true);

		}catch(ControladorException cex){
			sessionContext.setRollbackOnly();
			throw cex;
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * @author Roberta Costa
	 * @since 12/01/2006
	 * @author eduardo henrique
	 * @date 31/10/2008 Alteração no método, para adicionar ao CreditoARealizar, seus respectivos
	 *       CreditoARealizarCategoria.
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desabilitar a Contabilização por Evento.
	 * @param imovel
	 *            Imovel
	 * @param creditoARealizar
	 *            CreditoARealizar
	 * @param usuario
	 *            Usuário Logado no Sistema
	 * @throws ControladorException
	 */
	public void inserirCreditoARealizar(Imovel imovel, CreditoARealizar creditoARealizar, Usuario usuarioLogado, Boolean gerarErro)
					throws ControladorException{

		boolean flagInserirCreditoARealizar = true;

		// [FS0010] - Verifica usuário com débito em cobrança administrativa
		boolean permissaoInserirCreditoImovelDebito = getControladorPermissaoEspecial()
						.verificarPermissaoInserirCreditoARealizarImovelComDebito(usuarioLogado);

		if(!permissaoInserirCreditoImovelDebito){
			FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();

			filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, imovel.getId()));

			Collection imovelCobrancaSituacaoEncontrada = getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
							ImovelCobrancaSituacao.class.getName());

			if(imovelCobrancaSituacaoEncontrada != null && !imovelCobrancaSituacaoEncontrada.isEmpty()){

				if(((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao() != null){

					if(((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao().getId()
									.equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
									&& ((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0))
													.getDataRetiradaCobranca() == null){

						// Código comentado para a customização da cobrança administrativa CASAL
						// throw new
						// ControladorException("atencao.pesquisa.imovel.cobranca_administrativa");
					}
				}
			}
		}

		// [FS0001] - Verifica Existência da Matrícula
		FiltroClienteImovel filtroClienteImovel = new FiltroClienteImovel();

		filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.INDICADOR_IMOVEL_EXCLUIDO, Imovel.IMOVEL_EXCLUIDO));

		filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.IMOVEL_ID, imovel.getId()));

		Collection imovelExcluido = getControladorUtil().pesquisar(filtroClienteImovel, ClienteImovel.class.getName());

		if(imovelExcluido != null && !(imovelExcluido.isEmpty())){
			if(gerarErro){
				throw new ControladorException("atencao.imovel.excluido");
			}else{
				flagInserirCreditoARealizar = false;
			}
		}

		if(creditoARealizar.getRegistroAtendimento() != null){
			// [FS0003] - Verifica Existência do Registro de Atendimento
			FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();
			filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("solicitacaoTipoEspecificacao");
			filtroRegistroAtendimento.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimento.ID, creditoARealizar
							.getRegistroAtendimento().getId()));
			Collection registrosAtendimentos = getControladorUtil().pesquisar(filtroRegistroAtendimento,
							RegistroAtendimento.class.getName());

			RegistroAtendimento registroAtendimento = null;
			if(registrosAtendimentos == null || registrosAtendimentos.isEmpty()){
				if(gerarErro){
					throw new ControladorException("atencao.registro_atendimento.inexistente");
				}else{
					flagInserirCreditoARealizar = false;
				}
			}else{
				registroAtendimento = (RegistroAtendimento) registrosAtendimentos.iterator().next();
			}

			// [FS0002] - Validar Registro de Atendimento
			if(registroAtendimento.getImovel() == null){
				if(gerarErro){
					throw new ControladorException("atencao.registro_atendimento.nao_associado_imovel");
				}else{
					flagInserirCreditoARealizar = false;
				}
			}
			if(registroAtendimento.getDescricaoSituacao().equals(RegistroAtendimento.SITUACAO_DESCRICAO_ENCERRADO)
							|| registroAtendimento.getCodigoSituacao() == RegistroAtendimento.SITUACAO_ENCERRADO){
				if(gerarErro){
					throw new ControladorException("atencao.registro_atendimento.encerrado");
				}else{
					flagInserirCreditoARealizar = false;
				}
			}
			if(registroAtendimento.getSolicitacaoTipoEspecificacao().getIndicadorGeracaoCredito()
							.equals(SolicitacaoTipoEspecificacao.INDICADOR_GERACAO_CREDITO_NAO)){
				if(gerarErro){
					throw new ControladorException("atencao.registro_atendimento.nao_permite_credito");
				}else{
					flagInserirCreditoARealizar = false;
				}
			}
		}

		// [FS0004] - Verifica Existência da Ordem de Serviço
		if(creditoARealizar.getOrdemServico() != null){
			FiltroOrdemServico filtroOrdemServico = new FiltroOrdemServico();

			filtroOrdemServico.adicionarParametro(new ParametroSimples(FiltroOrdemServico.ID, creditoARealizar.getOrdemServico()));

			Collection ordensServicos = getControladorUtil().pesquisar(filtroOrdemServico, OrdemServico.class.getName());

			OrdemServico ordemServico = null;
			if(ordensServicos != null && !(ordensServicos.isEmpty())){
				ordemServico = (OrdemServico) ordensServicos.iterator().next();
			}else{
				if(gerarErro){
					throw new ControladorException("atencao.ordem_servico.inexistente");
				}else{
					flagInserirCreditoARealizar = false;
				}
			}

			// [FS0005] - Validar Ordem de serviço
			if(ordemServico.getRegistroAtendimento() == null){
				if(gerarErro){
					throw new ControladorException("atencao.ordem_servico.sem_registro_atendimento");
				}else{
					flagInserirCreditoARealizar = false;
				}
			}
			if(ordemServico.getRegistroAtendimento().getImovel() == null){
				if(gerarErro){
					throw new ControladorException("atencao.ordem_servico.registro_atendimento.sem_imovel");
				}else{
					flagInserirCreditoARealizar = false;
				}
			}
		}

		// [FS0006] - Verificar existência de crédito a realizar para o registro
		// de atendimento
		FiltroCreditoARealizar filtroCredito = new FiltroCreditoARealizar();
		filtroCredito.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.REGISTRO_ATENDIMENTO, creditoARealizar
						.getRegistroAtendimento()));
		Collection creditos = getControladorUtil().pesquisar(filtroCredito, CreditoARealizar.class.getName());
		if(creditos != null && !creditos.isEmpty()){
			if(gerarErro){
				throw new ControladorException("atencao.existe.credito_a_realizar.para.registro_atendimento");
			}else{
				flagInserirCreditoARealizar = false;
			}
		}

		// [FS0007] - Validar número de prestações
		boolean permissaoQuantidadeParcelas = getControladorPermissaoEspecial()
						.verificarPermissaoIcluirCreditoARealizarQuantidadeParcelasMaximo(usuarioLogado);
		if(!permissaoQuantidadeParcelas){
			if(creditoARealizar.getNumeroPrestacaoCredito() > getControladorUtil().pesquisarParametrosDoSistema()
							.getNumeroMaximoParcelasFinanciamento()){
				if(gerarErro){
					throw new ControladorException("atencao.valor_prestacoes", null, ""
									+ getControladorUtil().pesquisarParametrosDoSistema().getNumeroMaximoParcelasFinanciamento());
				}else{
					flagInserirCreditoARealizar = false;
				}
			}
		}

		FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();

		filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, creditoARealizar.getCreditoTipo().getId()));

		filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoTipo.LANCAMENTO_ITEM_CONTABIL);

		Collection creditoTiposValor = getControladorUtil().pesquisar(filtroCreditoTipo, CreditoTipo.class.getName());

		CreditoTipo creditoTipo = (CreditoTipo) Util.retonarObjetoDeColecao(creditoTiposValor);

		creditoARealizar.setCreditoTipo(creditoTipo);

		// [FS0008] - Validar valor do crédito
		boolean permissaoValorLimite = getControladorPermissaoEspecial().verificarPermissaoIcluirCreditoARealizarValorMaximo(usuarioLogado);
		if(!permissaoValorLimite){
			if(creditoTiposValor != null && !(creditoTiposValor.isEmpty())){
				CreditoTipo creditoTipoValorNaBase = (CreditoTipo) ((List) creditoTiposValor).get(0);
				if(creditoTipoValorNaBase.getValorLimite() != null){
					// Verifica se o valor do crédito é mairo que o valor limite
					// da tabela crédito tipo
					if(creditoARealizar.getValorCredito().compareTo(creditoTipoValorNaBase.getValorLimite()) == 1){
						if(gerarErro){
							throw new ControladorException("atencao.credito_a_realizar.valor_limite", null, ""
											+ Util.formatarMoedaReal(creditoTipoValorNaBase.getValorLimite()));
						}else{
							flagInserirCreditoARealizar = false;
						}
					}
				}else{
					if(gerarErro){
						throw new ControladorException("atencao.credito_tipo.valor_limite_inexistente");
					}else{
						flagInserirCreditoARealizar = false;
					}
				}
			}
		}

		// [FS0011] - Validar Referencia do Credito
		if(creditoARealizar.getAnoMesReferenciaCredito() != null){
			// Valida se o desconto ja existe para essa ocorrencia.
			FiltroCreditoARealizar filtroCreditoARealizar = new FiltroCreditoARealizar();
			filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ANO_MES_REFERENCIA_CREDITO,
							creditoARealizar.getAnoMesReferenciaCredito()));
			filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID_CREDITO_ORIGEM, creditoARealizar
							.getCreditoOrigem().getId()));
			filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID_CREDITO_TIPO, creditoARealizar
							.getCreditoTipo().getId()));

			if(creditoARealizar.getImovel() != null){
				filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.IMOVEL_ID, creditoARealizar
								.getImovel().getId()));
			}else{
				filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.IMOVEL_ID, imovel.getId()));
			}

			if(creditoARealizar.getPagamentoHistorico() != null){
				filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID_PAGAMENTO_HISTORICO,
								creditoARealizar.getPagamentoHistorico().getId()));
				Collection colecaoCreditosBase = getControladorUtil().pesquisar(filtroCreditoARealizar, CreditoARealizar.class.getName());

				if(colecaoCreditosBase != null && !colecaoCreditosBase.isEmpty()){
					if(gerarErro){
						throw new ControladorException("atencao.pagamento.credito_a_realizar.ja.existente");
					}else{
						flagInserirCreditoARealizar = false;
					}
				}

			}



			// Valida se a Referencia do Credito e superior à Referencia de
			// Faturamento do sistema
			FiltroImovel filtroImovel = new FiltroImovel(); // Pesquisa o imovel
			// na base
			filtroImovel.adicionarCaminhoParaCarregamentoEntidade("rota.faturamentoGrupo");
			filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
			Collection imoveisEncontrados = getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());

			if(imoveisEncontrados != null && !imoveisEncontrados.isEmpty()){
				Imovel imovelPesquisado = ((Imovel) ((List) imoveisEncontrados).get(0));

				Integer referenciaFaturamento = imovelPesquisado.getRota().getFaturamentoGrupo().getAnoMesReferencia();
				if(creditoARealizar.getAnoMesReferenciaCredito() > referenciaFaturamento){
					if(gerarErro){
						throw new ControladorException("atencao.referencia.credito_a_realizar.data_superior", null,
										Util.formatarAnoMesParaMesAno("" + referenciaFaturamento));
					}else{
						flagInserirCreditoARealizar = false;
					}
				}
			}
		}

		// Data de Geração do Crédito
		creditoARealizar.setGeracaoCredito(new Date());

		// Parâmetros do sistema
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		// creditoARealizar.setAnoMesReferenciaCredito(sistemaParametro
		// .getAnoMesFaturamento());
		creditoARealizar.setAnoMesReferenciaContabil(sistemaParametro.getAnoMesFaturamento());
		creditoARealizar.setAnoMesCobrancaCredito(sistemaParametro.getAnoMesArrecadacao());

		// Valor Residual Mes Anterior
		creditoARealizar.setValorResidualMesAnterior(BigDecimal.ZERO);

		// Prestacao Credito
		creditoARealizar.setNumeroPrestacaoCredito(creditoARealizar.getNumeroPrestacaoCredito());

		// Prestacao Realizada
		creditoARealizar.setNumeroPrestacaoRealizada(Short.parseShort("0"));

		// Imovel
		creditoARealizar.setImovel(imovel);
		creditoARealizar.setLocalidade(imovel.getLocalidade());
		creditoARealizar.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
		creditoARealizar.setNumeroLote(imovel.getLote());
		creditoARealizar.setNumeroSubLote(imovel.getSubLote());
		creditoARealizar.setQuadra(imovel.getQuadra());
		creditoARealizar.setNumeroQuadra(Integer.valueOf(imovel.getQuadra().getNumeroQuadra()));

		// Registro de Atendimento
		creditoARealizar.setRegistroAtendimento(creditoARealizar.getRegistroAtendimento());

		// Ordem de Servico
		creditoARealizar.setOrdemServico(creditoARealizar.getOrdemServico());

		// Crédito Tipo
		creditoARealizar.setCreditoTipo(creditoARealizar.getCreditoTipo());

		// Crédito Origem
		creditoARealizar.setCreditoOrigem(creditoARealizar.getCreditoOrigem());

		// Lancamento Item Contabil
		filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, creditoARealizar.getCreditoTipo().getId()));

		if(creditoARealizar.getLancamentoItemContabil() == null){
			// Lancamento Item Contabil
			filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, creditoARealizar.getCreditoTipo().getId()));

			Collection creditoTipos = getControladorUtil().pesquisar(filtroCreditoTipo, CreditoTipo.class.getName());

			if(creditoTipos != null && !(creditoTipos.isEmpty())){
				CreditoTipo creditoTipoNaBase = (CreditoTipo) creditoTipos.iterator().next();

				if(creditoTipoNaBase.getLancamentoItemContabil() == null){
					if(gerarErro){
						throw new ControladorException("atencao.lancamento_item_contabil.inexistente");
					}else{
						flagInserirCreditoARealizar = false;
					}
				}else{
					creditoARealizar.setLancamentoItemContabil(creditoTipoNaBase.getLancamentoItemContabil());
				}
			}else{
				if(gerarErro){
					throw new ControladorException("atencao.credito_tipo.inexistente");
				}else{
					flagInserirCreditoARealizar = false;
				}
			}

		}

		if(flagInserirCreditoARealizar){
			// Debito Credito Situacao Atual
			DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao();
			debitoCreditoSituacaoAtual.setId(DebitoCreditoSituacao.NORMAL);
			creditoARealizar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);

			// Debito Credito Situacao Anterior
			creditoARealizar.setDebitoCreditoSituacaoAnterior(null);

			// Data de Ultima Alteracao
			creditoARealizar.setUltimaAlteracao(new Date());

			// Inseri a conta na tabela Conta_Geral
			CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();

			// valor fixo
			Short indicadorHistorico = 2;

			creditoARealizarGeral.setIndicadorHistorico(indicadorHistorico);

			// Ultima Alteração
			creditoARealizarGeral.setUltimaAlteracao(new Date());

			try{
				// Inserindo no BD
				Integer idGerado = (Integer) this.getControladorUtil().inserir(creditoARealizarGeral);

				// seta o id da Conta Geral gerada no objeto contaGeral
				creditoARealizarGeral.setId(idGerado);

				creditoARealizar.setCreditoARealizarGeral(creditoARealizarGeral);

				creditoARealizar.setId(idGerado);

				// ------------ REGISTRAR TRANSAÇÃO ----------------
				RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CREDITO_A_REALIZAR_INSERIR,
								imovel.getId(), idGerado, new UsuarioAcaoUsuarioHelper(usuarioLogado,
												UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
				registradorOperacao.registrarOperacao(creditoARealizar);
				// ------------ REGISTRAR TRANSAÇÃO ----------------

				// Inserido o objeto Crédito a Realizar
				getControladorUtil().inserir(creditoARealizar);

				Collection<ObjetoTransacao> colecaoCreditoARealizarContabilizacao = new ArrayList<ObjetoTransacao>();

				// [UC0108] - Obter Quantidade de Economias por Categoria
				Collection colecaoCategoriasImovel = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

				// [UC0185] - Obter Valor por Categoria
				Collection colecaoValoresPorCategoria = getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
								creditoARealizar.getValorCredito());

				Iterator icolecaoCategorias = colecaoCategoriasImovel.iterator();
				Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria.iterator();
				creditoARealizar.setCreditoARealizarCategoria(new HashSet<CreditoARealizarCategoria>());
				while(icolecaoValoresPorCategoria.hasNext() && icolecaoCategorias.hasNext()){
					// Criando um objeto creditoARealizarCategoria
					CreditoARealizarCategoria creditoARealizarCategoria = new CreditoARealizarCategoria();

					// Setando as variáveis de categoria e valor de acordo com as
					// coleções
					Categoria categoria = (Categoria) icolecaoCategorias.next();
					BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria.next();

					// Informando os campos da tabela
					creditoARealizarCategoria.setComp_id(new CreditoARealizarCategoriaPK(creditoARealizar, categoria));
					creditoARealizarCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
					creditoARealizarCategoria.setValorCategoria(valor);
					creditoARealizarCategoria.setUltimaAlteracao(new Date());
					creditoARealizarCategoria.setCategoria(categoria);

					// Inserindo os campos na tabela creditoARealizarCategoria
					getControladorUtil().inserir(creditoARealizarCategoria);
					creditoARealizar.getCreditoARealizarCategoria().add(creditoARealizarCategoria);
				}

				// CLIENTE_CREDITO_A_REALIZAR
				this.getControladorCobranca().inserirClienteCreditoARealizar(creditoARealizar);

				colecaoCreditoARealizarContabilizacao.add(creditoARealizar);

				// Registrando lançamento contábil de crédito a realizar
				getControladorContabil().registrarLancamentoContabil(creditoARealizar, OperacaoContabil.INCLUIR_CREDITO_A_REALIZAR);

			}catch(ControladorException cex){
				sessionContext.setRollbackOnly();
				throw cex;
			}catch(Exception ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}
		/*
		 * [UC0207 – Gerar/Atualizar Resumo de Faturamento] após as especificações.
		 * Saulo Lima 08/08/2008
		 */
		// getControladorFinanceiro().contabilizarEventoFaturamento(colecaoCreditoARealizarContabilizacao,
		// EventoContabil.INCLUSAO_CREDITO_A_REALIZAR);
	}

	/**
	 * [UC0195] - Manter Crédito a Realizar
	 * 
	 * @author Roberta Costa
	 * @since 18/01/2006
	 * @author eduardo henrique
	 * @date 04/11/2008 Alteração no método para contabilização do Cancelamento da Crédito a
	 *       Realizar.
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desabilitar a Contabilização por Evento.
	 * @param ids
	 *            - Lista de Id de Crédito a Realizar
	 * @param imovel
	 *            - Imóvel
	 * @param usuário
	 *            - Usuário logado no sistema
	 * @throws ControladorException
	 */
	public void cancelarCreditoARealizar(String[] ids, Imovel imovel, Usuario usuarioLogado, boolean ignorarValidacaoPermissaoEspecial)
					throws ControladorException{

		// [FS0001] - Verifica Existência da Matrícula
		FiltroClienteImovel filtroClienteImovel = new FiltroClienteImovel();

		filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.INDICADOR_IMOVEL_EXCLUIDO, Imovel.IMOVEL_EXCLUIDO));

		filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.IMOVEL_ID, imovel.getId()));

		Collection imovelExcluido = getControladorUtil().pesquisar(filtroClienteImovel, ClienteImovel.class.getName());

		if(imovelExcluido != null && !(imovelExcluido.isEmpty())){
			throw new ControladorException("atencao.imovel.excluido");
		}

		Collection<ObjetoTransacao> colecaoCreditoARealizarContabilizacao = new ArrayList<ObjetoTransacao>();

		// Para cada credito a realizar
		for(int i = 0; i < ids.length; i++){

			String id = ids[i];

			FiltroCreditoARealizar filtroCreditoARealizar = new FiltroCreditoARealizar();

			filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID, id));

			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoARealizar.CREDITO_TIPO);
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoARealizar.LOCALIDADE);
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoARealizar.IMOVEL);
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoARealizar.CREDITO_A_REALIZAR_CATEGORIA);
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoARealizar.PAGAMENTO_HISTORICO);

			Collection colecaoCreditoARealizar = getControladorUtil().pesquisar(filtroCreditoARealizar, CreditoARealizar.class.getName());

			CreditoARealizar creditoARealizar = (CreditoARealizar) colecaoCreditoARealizar.iterator().next();

			this.estornarPagamento(creditoARealizar, usuarioLogado);

			// [FS0003] - Verifica usuário com débito em cobrança administrativa
			boolean permissaoCancelarCreditoImovelComDebito = getControladorPermissaoEspecial()
							.verificarPermissaoCancelarCreditoARealizarImovelComDebito(usuarioLogado);

			if(!ignorarValidacaoPermissaoEspecial && !permissaoCancelarCreditoImovelComDebito){

				FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();

				filtroImovelCobrancaSituacao
								.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, imovel.getId()));

				Collection imovelCobrancaSituacaoEncontrada = getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
								ImovelCobrancaSituacao.class.getName());

				if(imovelCobrancaSituacaoEncontrada != null && !imovelCobrancaSituacaoEncontrada.isEmpty()){

					if(((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao() != null){

						if(((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0)).getCobrancaSituacao().getId()
										.equals(CobrancaSituacao.COBRANCA_ADMINISTRATIVA)
										&& ((ImovelCobrancaSituacao) ((List) imovelCobrancaSituacaoEncontrada).get(0))
														.getDataRetiradaCobranca() == null){

							// Código comentado para a customização da cobrança administrativa CASAL
							// throw new
							// ControladorException("atencao.pesquisa.imovel.cobranca_administrativa");
						}
					}
				}
			}

			// [FS0004] - Validar valor do crédito
			boolean permissaoCancelarCreditoValorSuperir = getControladorPermissaoEspecial()
							.verificarPermissaoCancelarCreditoARealizarValorSuperirLimite(usuarioLogado);

			if(!ignorarValidacaoPermissaoEspecial && !permissaoCancelarCreditoValorSuperir){
				CreditoARealizar creditoARealizarPesquisado = (CreditoARealizar) colecaoCreditoARealizar.iterator().next();

				FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();

				filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, creditoARealizarPesquisado.getCreditoTipo()
								.getId()));

				Collection creditoTiposValor = getControladorUtil().pesquisar(filtroCreditoTipo, CreditoTipo.class.getName());

				if(creditoTiposValor != null && !(creditoTiposValor.isEmpty())){
					CreditoTipo creditoTipoValorNaBase = (CreditoTipo) ((List) creditoTiposValor).get(0);
					if(creditoTipoValorNaBase.getValorLimite() != null){
						// Verifica se o valor do crédito é mairo que o valor limite da tabela
						// crédito tipo
						if(creditoARealizarPesquisado.getValorCredito().compareTo(creditoTipoValorNaBase.getValorLimite()) == 1){
							throw new ControladorException("atencao.credito_a_realizar.valor.senha_especial");
						}
					}
				}
			}

			// [FS0005] - Validar número de prestações
			boolean permissaoQuantidadeParcelas = getControladorPermissaoEspecial()
							.verificarPermissaoCancelarCreditoARealizarParcelasSuperirLimite(usuarioLogado);

			if(!permissaoQuantidadeParcelas){
				if(getControladorUtil().pesquisarParametrosDoSistema().getNumeroMaximoParcelaCredito() != null){
					if(creditoARealizar.getNumeroPrestacaoCredito() > getControladorUtil().pesquisarParametrosDoSistema()
									.getNumeroMaximoParcelaCredito()){
						throw new ControladorException("atencao.credito_a_realizar.parcelas.senha_especial");
					}
				}
			}

			SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();
			if(sistemaParametros == null || sistemaParametros.getAnoMesFaturamento() == null){
				throw new ControladorException("atencao.naocadastrado", null, "Ano/Mês Faturamento Parametros Sistema");
			}

			/*
			 * O sistema transfere para o histórico de créditos a realizar que foram cancelados. Na
			 * transferência, as chaves primárias das tabelas
			 * (ID’s) devem ser preservadas, a situação do crédito deve ser atualizada com o valor
			 * correspondente a cancelada (DCST_ID da tabela
			 * DEBITO_CREDITO_SITUACAO) e a referência contábil deve ser atualizada com
			 * PARM_AMREFERENCIAFATURAMENTO da tabela SISTEMA_PARAMETROS.
			 */
			CreditoARealizarHistorico creditoARealizarHistorico = new CreditoARealizarHistorico();

			creditoARealizarHistorico.setAnoMesCobrancaCredito(creditoARealizar.getAnoMesCobrancaCredito());
			creditoARealizarHistorico.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
			creditoARealizarHistorico.setAnoMesReferenciaCredito(creditoARealizar.getAnoMesReferenciaCredito());
			creditoARealizarHistorico.setCodigoSetorComercial(creditoARealizar.getCodigoSetorComercial());
			creditoARealizarHistorico.setCreditoOrigem(creditoARealizar.getCreditoOrigem());
			creditoARealizarHistorico.setCreditoTipo(creditoARealizar.getCreditoTipo());
			creditoARealizarHistorico.setDebitoCreditoSituacaoAnterior(creditoARealizar.getDebitoCreditoSituacaoAtual());
			DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao();
			debitoCreditoSituacaoAtual.setId(DebitoCreditoSituacao.CANCELADA);
			creditoARealizarHistorico.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);
			creditoARealizarHistorico.setDocumentoTipo(creditoARealizar.getDocumentoTipo());
			creditoARealizarHistorico.setGeracaoCreditoARealizar(creditoARealizar.getGeracaoCredito());
			creditoARealizarHistorico.setId(creditoARealizar.getId());
			creditoARealizarHistorico.setImovel(creditoARealizar.getImovel());
			creditoARealizarHistorico.setLancamentoItemContabil(creditoARealizar.getLancamentoItemContabil());
			creditoARealizarHistorico.setLocalidade(creditoARealizar.getLocalidade());
			creditoARealizarHistorico.setLote(creditoARealizar.getNumeroLote());
			creditoARealizarHistorico.setNumeroQuadra(creditoARealizar.getNumeroQuadra());
			creditoARealizarHistorico.setOrdemServico(creditoARealizar.getOrdemServico());
			creditoARealizarHistorico.setOrigem(creditoARealizar.getOrigem());
			creditoARealizarHistorico.setParcelamento(creditoARealizar.getParcelamento());
			creditoARealizarHistorico.setPrestacaoCredito(creditoARealizar.getNumeroPrestacaoCredito());
			creditoARealizarHistorico.setPrestacaoRealizadas(creditoARealizar.getNumeroPrestacaoRealizada());
			creditoARealizarHistorico.setQuadra(creditoARealizar.getQuadra());
			creditoARealizarHistorico.setRegistroAtendimento(creditoARealizar.getRegistroAtendimento());
			creditoARealizarHistorico.setSubLote(creditoARealizar.getNumeroSubLote());
			creditoARealizarHistorico.setUltimaAlteracao(new Date());
			creditoARealizarHistorico.setValorCredito(creditoARealizar.getValorCredito());
			creditoARealizarHistorico.setValorResidualMesAnterior(creditoARealizar.getValorResidualMesAnterior());
			creditoARealizarHistorico.setCreditoARealizarGeral(creditoARealizar.getCreditoARealizarGeral());
			creditoARealizarHistorico.setPagamentoHistorico(creditoARealizar.getPagamentoHistorico());

			getControladorUtil().inserir(creditoARealizarHistorico);

			// INÍCIO - Transferir para o histório o CreditoARealizarCategoria

			// [UC0108] - Obter Quantidade de Economias por Categoria
			Collection colecaoCategoriasImovel = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

			// [UC0185] - Obter Valor por Categoria
			Collection colecaoValoresPorCategoria = getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
							creditoARealizar.getValorCredito());

			Iterator icolecaoCategorias = colecaoCategoriasImovel.iterator();
			Iterator icolecaoValoresPorCategoria = colecaoValoresPorCategoria.iterator();

			while(icolecaoValoresPorCategoria.hasNext() && icolecaoCategorias.hasNext()){

				Categoria categoria = (Categoria) icolecaoCategorias.next();
				BigDecimal valor = (BigDecimal) icolecaoValoresPorCategoria.next();

				CreditoARealizarCategoriaHistorico creditoARealizarCategoriaHistorico = new CreditoARealizarCategoriaHistorico();
				CreditoARealizarHistorico carh = new CreditoARealizarHistorico();
				carh.setId(creditoARealizar.getId());
				CreditoARealizarCategoriaHistoricoPK creditoARealizarCategoriaHistoricoPK = new CreditoARealizarCategoriaHistoricoPK(carh,
								categoria);
				creditoARealizarCategoriaHistorico.setComp_id(creditoARealizarCategoriaHistoricoPK);
				creditoARealizarCategoriaHistorico.setCategoria(categoria);
				creditoARealizarCategoriaHistorico.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
				creditoARealizarCategoriaHistorico.setValorCategoria(valor);
				creditoARealizarCategoriaHistorico.setUltimaAlteracao(new Date());
				creditoARealizarCategoriaHistorico.setCreditoARealizarHistorico(creditoARealizarHistorico);

				getControladorUtil().inserir(creditoARealizarCategoriaHistorico);
			}
			// FIM - Transferir para o histório o CreditoARealizarCategoria
			

			// Atualizar na Tabela CREDITO_A_REALIZAR_GERAL
			FiltroCreditoARealizarGeral filtroCreditoARealizarGeral = new FiltroCreditoARealizarGeral();
			filtroCreditoARealizarGeral.adicionarParametro(new ParametroSimples(FiltroCreditoARealizarGeral.ID, creditoARealizar.getId()));
			Collection colecaoCreditoARealizarGeral = getControladorUtil().pesquisar(filtroCreditoARealizarGeral,
							CreditoARealizarGeral.class.getName());

			if(colecaoCreditoARealizarGeral != null && !colecaoCreditoARealizarGeral.isEmpty()){
				CreditoARealizarGeral creditoARealizarGeral = (CreditoARealizarGeral) colecaoCreditoARealizarGeral.iterator().next();
				creditoARealizarGeral.setIndicadorHistorico(CreditoARealizarGeral.INDICADOR_HISTORICO_SIM);
				getControladorUtil().atualizar(creditoARealizarGeral);
			}

			colecaoCreditoARealizarContabilizacao.add(creditoARealizar);

			// ..................................................................................................
			// cliente_credito_a_realizar
			// ..................................................................................................
			Collection colecaoClienteCreditoARealizar = this.pesquisarClienteCreditoARealizar(creditoARealizar);

			this.getControladorCobranca().transferirParaClienteCreditoARealizarHistorico(colecaoClienteCreditoARealizar,
							creditoARealizarHistorico);
			// ..................................................................................................

			// Registrando lançamento contábil de crédito a realizar
			getControladorContabil().registrarLancamentoContabil(creditoARealizar, OperacaoContabil.CANCELAR_CREDITO_A_REALIZAR);

			/*
			 * Caso o crédito (CRTI_CDCONSTANTE = "CREDTAC") corresponda ao crédito gerado pelo
			 * termo de ajuste de conduta de realinhamento de tarifas (CREDTAC)
			 */
			if(creditoARealizar.getCreditoTipo().getId().equals(CreditoTipo.CREDTAC)){

				// Para cada crédito a realizar transferido, atualiza a tabela AJUSTE_TARIFA para o
				// imóvel e crédito a realizar
				FiltroAjusteTarifa filtroAjusteTarifa = new FiltroAjusteTarifa();
				filtroAjusteTarifa.adicionarParametro(new ParametroSimples(FiltroAjusteTarifa.IMOVEL_ID, imovel.getId()));
				filtroAjusteTarifa.adicionarParametro(new ParametroSimples(FiltroAjusteTarifa.CREDITO_A_REALIZAR_ID, creditoARealizar
								.getId()));
				filtroAjusteTarifa.setCampoOrderByDesc(FiltroAjusteTarifa.DATA_CALCULO);

				Collection<AjusteTarifa> colecaoAjusteTarifa = getControladorUtil().pesquisar(filtroAjusteTarifa,
								AjusteTarifa.class.getName());

				AjusteTarifa ajusteTarifa = (AjusteTarifa) Util.retonarObjetoDeColecao(colecaoAjusteTarifa);

				if(ajusteTarifa != null){

					StringBuilder builderLog = new StringBuilder();

					if(ajusteTarifa.getDescricaoLog() != null){

						builderLog.append(ajusteTarifa.getDescricaoLog());
					}

					builderLog.append(System.getProperty("line.separator"));
					builderLog.append("******************************************************************************************************************");
					builderLog.append(System.getProperty("line.separator"));
					builderLog.append("Cancelamento do Crédito (CREDTAC) no valor de R$ ");
					builderLog.append(Util.formatarMoedaReal(creditoARealizar.getValorCredito(), 2) + ".");
					builderLog.append(System.getProperty("line.separator"));
					builderLog.append("Efetuado por " + usuarioLogado.getNomeUsuario());
					builderLog.append(" em " + Util.formatarDataComHoraSemSegundos(new Date()));

					ajusteTarifa.setDescricaoLog(builderLog.toString());

					getControladorUtil().atualizar(ajusteTarifa);
				}
			}


			// Remove da Tabela CREDITO_A_REALIZAR
			getControladorUtil().remover(creditoARealizar);

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CREDITO_A_REALIZAR_CANCELAR,
							imovel.getId(), Integer.parseInt(id), new UsuarioAcaoUsuarioHelper(usuarioLogado,
											UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			registradorOperacao.registrarOperacao(creditoARealizar);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

		}
		// Contabilizar Creditos Removidos
		// getControladorFinanceiro().contabilizarEventoFaturamento(colecaoCreditoARealizarContabilizacao,
		// EventoContabil.CANCELAMENTO_CREDITO_A_REALIZAR);
	}

	/**
	 * [UC0146] - Manter Conta Author: Raphael Rossiter Data: 21/01/2006
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @author Saulo Lima
	 * @date 10/09/2008 Alteração na chamada do método pra satifazer as especificações do UC0146
	 *       (ADA): Remover os parâmetros: situacaoNormal,
	 *       situacaoIncluida e situacaoRetificada
	 * @param imovel
	 * @return Collection<Conta>
	 * @throws ControladorException
	 */
	public Collection<Conta> obterContasImovelManter(Imovel imovel) throws ControladorException{

		Collection<Conta> retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoContasManutencaoArray = null;

		try{

			colecaoContasManutencaoArray = repositorioFaturamento.obterContasImovelManter(imovel);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoContasManutencaoArray != null && !colecaoContasManutencaoArray.isEmpty()){
			retorno = this.obterDadosContas(imovel, colecaoContasManutencaoArray);
		}
		return retorno;
	}

	/**
	 * [UC0146] - Manter Conta
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @author Hugo Lima
	 * @date 09/05/2012
	 * @param manterContaHelper
	 * @return Collection<Conta>
	 * @throws ControladorException
	 */
	public Collection<Conta> obterContasImovelManterParametros(ManterContaHelper manterContaHelper) throws ControladorException{

		Collection<Conta> retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoContasManutencaoArray = null;

		try{

			colecaoContasManutencaoArray = repositorioFaturamento.obterContasImovelManterParametros(manterContaHelper);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoContasManutencaoArray != null && !colecaoContasManutencaoArray.isEmpty()){
			retorno = this.obterDadosContas(manterContaHelper.getImovel(), colecaoContasManutencaoArray);
		}
		return retorno;
	}

	/**
	 * [UC0146] - Manter Conta
	 * Monta uma coleção com contas cujos dados são passados a partir de uma coleção passada como
	 * parametro
	 * 
	 * @author Hugo Lima
	 * @date 09/05/2012
	 * @param colecaoContasManutencaoArray
	 * @return
	 */
	private Collection<Conta> obterDadosContas(Imovel imovel, Collection colecaoContasManutencaoArray){

		Collection<Conta> retorno = new ArrayList();

		Iterator colecaoContasManutencaoArrayIterator = colecaoContasManutencaoArray.iterator();

		while(colecaoContasManutencaoArrayIterator.hasNext()){

			// Obtém os dados do crédito realizado
			Object[] contaArray = (Object[]) colecaoContasManutencaoArrayIterator.next();

			Conta conta = new Conta();

			// ID da conta
			conta.setId((Integer) contaArray[0]);

			// Ano Mês referencia
			conta.setReferencia((Integer) contaArray[1]);

			// Data de vencimento
			String vencimento = String.valueOf(contaArray[2]);

			SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd");

			Date dataVencimento;

			try{
				dataVencimento = formatoData.parse(vencimento);
			}catch(java.text.ParseException e){
				dataVencimento = null;
			}

			conta.setDataVencimentoConta(dataVencimento);

			// Valor de água
			conta.setValorAgua((BigDecimal) contaArray[3]);

			// Valor de esgoto
			conta.setValorEsgoto((BigDecimal) contaArray[4]);

			// Valor dos débitos
			conta.setDebitos((BigDecimal) contaArray[5]);

			// Valor dos créditos
			conta.setValorCreditos((BigDecimal) contaArray[6]);

			// Consumo de água
			conta.setConsumoAgua((Integer) contaArray[7]);

			// Consumo de esgoto
			conta.setConsumoEsgoto((Integer) contaArray[8]);

			// Data de validade
			String validade = String.valueOf(contaArray[9]);

			Date dataValidade;

			try{
				dataValidade = formatoData.parse(validade);
			}catch(java.text.ParseException e){
				dataValidade = null;
			}

			conta.setDataValidadeConta(dataValidade);

			// Data de revisao
			String revisao = String.valueOf(contaArray[10]);

			Date dataRevisao;

			try{
				dataRevisao = formatoData.parse(revisao);
			}catch(java.text.ParseException e){
				dataRevisao = null;
			}

			conta.setDataRevisao(dataRevisao);

			// DebitoCreditoSituacaoAtual
			conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);

			// Ano Mês referencia contábil
			conta.setReferenciaContabil((Integer) contaArray[12]);

			// ultima Alteracao

			SimpleDateFormat formatoDataEspecifico = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

			String ultimaAlteracao = String.valueOf(contaArray[13]);

			Date dataUltimaAlteracao;

			try{
				dataUltimaAlteracao = formatoDataEspecifico.parse(ultimaAlteracao);
			}catch(java.text.ParseException e){
				dataUltimaAlteracao = null;
			}

			conta.setUltimaAlteracao(dataUltimaAlteracao);

			// CodigoSetorComercial
			conta.setCodigoSetorComercial((Integer) contaArray[14]);

			// Quadra
			conta.setQuadra((Integer) contaArray[15]);

			// IndicadorAlteracaoVencimento
			conta.setIndicadorAlteracaoVencimento((Short) contaArray[16]);

			// DataRetificacao
			String retificacao = String.valueOf(contaArray[17]);

			Date dataRetificacao;

			try{
				dataRetificacao = formatoData.parse(retificacao);
			}catch(java.text.ParseException e){
				dataRetificacao = null;
			}

			conta.setDataRetificacao(dataRetificacao);

			// DataEmissao
			String emissao = String.valueOf(contaArray[18]);

			Date dataEmissao;

			try{
				dataEmissao = formatoData.parse(emissao);
			}catch(java.text.ParseException e){
				dataEmissao = null;
			}

			conta.setDataEmissao(dataEmissao);

			// indicadorExecucaoFiscal
			if(contaArray[19] != null){
				conta.setIndicadorExecucaoFiscal((Short) contaArray[19]);
			}

			conta.setImovel(imovel);

			retorno.add(conta);
		}

		return retorno;
	}

	/**
	 * Encerra o faturamento do mês
	 * [UC0155] - Encerrar Faturamento do Mês
	 * 
	 * @author Pedro Alexandre, Raphael Rossiter, Pedro Alexandre
	 * @date 07/10/2006, 30/05/2007, 17/10/2007
	 * @throws ControladorException
	 */
	public void encerrarFaturamentoMes(Collection<Integer> colecaoIdsLocalidades, int idFuncionalidadeIniciada) throws ControladorException{

		System.out.println("HORA INICIO:" + new Date());

		// Pesquisar nos parâmetros do sistema AnoMesFaturamento
		SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

		final Short ZERO = 0;
		BigDecimal menosUm = new BigDecimal("-1");

		// recupera o ano/mês de referência
		int anoMesFaturamentoSistemaParametro = sistemaParametros.getAnoMesFaturamento();

		int idUnidadeIniciada = 0;

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.LOCALIDADE, ((Integer) Util.retonarObjetoDeColecao(colecaoIdsLocalidades)));

		try{

			Short maxSequencialImpressaoMais10 = repositorioFaturamento.recuperarValorMaximoSequencialImpressaoMais10();

			// pesquisa os grupos de faturamentos
			Collection<FaturamentoGrupo> colecaoFaturamentoGrupoNaoFaturados = this.repositorioFaturamento
							.pesquisarFaturamentoGrupoNaoFaturados(anoMesFaturamentoSistemaParametro);

			// se não existir nenhum grupo de faturamento cadastrado
			if(colecaoFaturamentoGrupoNaoFaturados != null && !colecaoFaturamentoGrupoNaoFaturados.isEmpty()){
				// [FS0001 - Verificar existência de dados]
				throw new ControladorException("atencao.naocadastrado", null, "Grupo de Faturamento");
			}

			// cria um objetode resumo de faturamento temporario
			ResumoFaturamento resumoFaturamentoTemporario = null;

			// constante utilizada para recuperar o valor de curto prazo
			final int indiceCurtoPrazo = 0;

			// constante utilizada para recuperar o valor de curto longo
			final int indiceLongoPrazo = 1;

			// constante utilizada para recuperar o valor de água
			final int indiceValorAgua = 0;

			// array que vai armazenar os valores de água e esgosto
			Object[] arrayValoresAguaEsgoto = null;

			BigDecimal valorAgua = null;

			BigDecimal valorEsgoto = null;

			Integer[] idsSituacaoAtual = null;

			Integer[] idsCreditosOrigem = null;

			Integer[] idsTipoFinanciamento = null;

			// constante utilizada para recuperar o valor de esgoto
			final int indiceValorEsgoto = 1;

			BigDecimal valorItemFaturamento = null;

			// variável que vai acumular o valor de curto prazo
			BigDecimal somaValorCurtoPrazo = BigDecimal.ZERO;

			// variável que vai acumular o valor de longo prazo
			BigDecimal somaValorLongoPrazo = BigDecimal.ZERO;

			// array que vai armazenar os valores de curto e longo prazo
			BigDecimal[] valoresCurtoPrazoLongoPrazo = null;

			// variável que vai armazenar a diferença entre os valores de
			// debito
			// das contas canceladas por retificação menos o valor das
			// contas retificada
			BigDecimal diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada = null;

			// coleção que vai armazenar os resumos de faturamento
			// temporariamente
			Collection<ResumoFaturamento> colecaoTemporaria = null;

			// coleção que vai armazenar os debitos a cobrar temporariamente
			Collection<DebitoACobrar> colecaoTemporariaDebitoACobrar = null;

			// coleção que vai armazenar os dados dos créditos a realizar
			// temporariamente
			Collection<Object[]> colecaoTemporariaCreditoARealizar = null;

			// cria os objetos que seram utilizados para criar os resumos de
			// faturamento
			LancamentoTipo lancamentoTipo = new LancamentoTipo();
			LancamentoItem lancamentoItem = new LancamentoItem();

			// pesquisa a coleção de lançamentos de itens contábeis
			Collection<LancamentoItemContabil> colecaoLancamentosItemContabil = getControladorFinanceiro()
							.pesquisarLancamentoItemContabil();

			// pesquisa as categorias no sistema
			Collection<Categoria> colecaoCategorias = getControladorImovel().pesquisarCategoria();

			// laço para construir os resumos de faturamento por
			// localidade
			for(Integer idLocalidade : colecaoIdsLocalidades){

				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);

				Integer idGerenciaRegional = this.getControladorLocalidade().pesquisarIdGerenciaParaLocalidade(idLocalidade);
				GerenciaRegional gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setId(idGerenciaRegional);

				/*
				 * Colocado por Raphael Rossiter em 30/05/2007 Obj: Implementar quebra por Unidade
				 * de Negocio
				 */
				Integer idUnidadeNegocio = this.getControladorLocalidade().pesquisarIdUnidadeNegocioParaLocalidade(idLocalidade);
				UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(idUnidadeNegocio);

				// pesquisa se já existe resumo de faturamento para o ano/mês de
				// referência
				Collection<ResumoFaturamento> colecaoResumoFaturamento = repositorioFaturamento.pesquisarResumoFaturamentoPorAnoMes(
								anoMesFaturamentoSistemaParametro, idLocalidade);

				// se a pesquisa retornar algum resumo de faturamento já
				// cadastrado
				if(!colecaoResumoFaturamento.isEmpty()){
					// [FS0003 - Verificar a existência do resumo do faturamento
					// dados]
					throw new ControladorException("atencao.resumofaturamento_ja_existente");
				}

				/*
				 * declaração das variáveis que serão utilizadas nos sequencias 560 e 1050
				 */
				Collection<Object[]> colecaoDadosGuiaDevolucao = null;
				Map<Integer, BigDecimal> mapValorGuiaDevolucaoPorCategoriaSequencial560 = null;
				Map<Integer, BigDecimal> mapValorGuiaDevolucaoPorCategoriaSequencial1050 = null;
				Categoria principalCategoriaImovel = null;
				BigDecimal valorGuiaTemp = null;
				Collection<Integer> colecaoCategoriaTemp = null;

				// map vai armazenar o somatorio por categoria
				// para ser utilizado na receita bruta.
				Map<Integer, BigDecimal> mapAcumularValorPorCategoriaReceitaBruta = new HashMap();

				// map vai armazenar o somatorio por categoria
				// para ser utilizado na receita cancelada.
				Map<Integer, BigDecimal> mapAcumularValorPorCategoriaReceitaCancelada = new HashMap();

				for(LancamentoItemContabil lancamentoItemContabilTemp : colecaoLancamentosItemContabil){

					mapValorGuiaDevolucaoPorCategoriaSequencial560 = new HashMap();
					mapValorGuiaDevolucaoPorCategoriaSequencial1050 = new HashMap();

					// Linha 15
					/*
					 * Acumula o valor da guia de devolução para situação da guia igual a cancelada
					 */
					colecaoDadosGuiaDevolucao = repositorioFaturamento.acumularValorGuiaDevolucaoPorLancamentoItemContabil(
									anoMesFaturamentoSistemaParametro, idLocalidade, DebitoCreditoSituacao.CANCELADA,
									lancamentoItemContabilTemp.getId());

					/*
					 * caso a coleção de dados não esteja nula acumula o valor da guia pela
					 * principal categoria do imóvel.
					 */
					if(colecaoDadosGuiaDevolucao != null && !colecaoDadosGuiaDevolucao.isEmpty()){
						for(Object[] dadosGuiaDevolucao : colecaoDadosGuiaDevolucao){
							Integer idImovel = (Integer) dadosGuiaDevolucao[0];
							BigDecimal valorGuiaDevolucao = (BigDecimal) dadosGuiaDevolucao[1];

							principalCategoriaImovel = this.getControladorImovel().obterPrincipalCategoriaImovel(idImovel);

							Integer idCategoria = principalCategoriaImovel.getId();
							if(mapValorGuiaDevolucaoPorCategoriaSequencial560.containsKey(idCategoria)){
								mapValorGuiaDevolucaoPorCategoriaSequencial560.put(idCategoria,
												((BigDecimal) mapValorGuiaDevolucaoPorCategoriaSequencial560.get(idCategoria))
																.add(valorGuiaDevolucao));

							}else{
								mapValorGuiaDevolucaoPorCategoriaSequencial560.put(idCategoria, valorGuiaDevolucao);
							}
						}
					}

					// recupera todas as categorias que foram geradas
					colecaoCategoriaTemp = mapValorGuiaDevolucaoPorCategoriaSequencial560.keySet();

					/* laço para gerar os resumos por categoria */
					for(Integer idCategoria : colecaoCategoriaTemp){

						Categoria categoria = new Categoria();
						categoria.setId(idCategoria);

						BigDecimal valorGuiaDevolucao = mapValorGuiaDevolucaoPorCategoriaSequencial560.get(idCategoria);

						if(mapAcumularValorPorCategoriaReceitaBruta.containsKey(idCategoria)){
							mapAcumularValorPorCategoriaReceitaBruta.put(idCategoria,
											((BigDecimal) mapAcumularValorPorCategoriaReceitaBruta.get(idCategoria))
															.add(valorGuiaDevolucao));
						}else{
							mapAcumularValorPorCategoriaReceitaBruta.put(idCategoria, valorGuiaDevolucao);
						}

						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorGuiaDevolucao);
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.GUIAS_DEVOLUCAO_VALORES_COBRADOS_INDEVIDAMENTE_CANCELADOS);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("560"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// Fim Linha 15

					// Linha 38
					/*
					 * Acumula o valor da guia de devolução para situação da guia igual a normal.
					 */
					colecaoDadosGuiaDevolucao = repositorioFaturamento.acumularValorGuiaDevolucaoPorLancamentoItemContabil(
									anoMesFaturamentoSistemaParametro, idLocalidade, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, lancamentoItemContabilTemp.getId());

					/*
					 * caso a coleção de dados não esteja nula acumula o valor da guia pela
					 * principal categoria do imóvel.
					 */
					if(colecaoDadosGuiaDevolucao != null && !colecaoDadosGuiaDevolucao.isEmpty()){
						for(Object[] dadosGuiaDevolucao : colecaoDadosGuiaDevolucao){
							Integer idImovel = (Integer) dadosGuiaDevolucao[0];
							BigDecimal valorGuiaDevolucao = (BigDecimal) dadosGuiaDevolucao[1];

							principalCategoriaImovel = this.getControladorImovel().obterPrincipalCategoriaImovel(idImovel);

							Integer idCategoria = principalCategoriaImovel.getId();
							if(mapValorGuiaDevolucaoPorCategoriaSequencial1050.containsKey(idCategoria)){
								mapValorGuiaDevolucaoPorCategoriaSequencial1050.put(idCategoria,
												((BigDecimal) mapValorGuiaDevolucaoPorCategoriaSequencial1050.get(idCategoria))
																.add(valorGuiaDevolucao));
							}else{
								mapValorGuiaDevolucaoPorCategoriaSequencial1050.put(idCategoria, valorGuiaDevolucao);
							}
						}
					}

					// recupera todas as categorias que foram geradas
					colecaoCategoriaTemp = mapValorGuiaDevolucaoPorCategoriaSequencial1050.keySet();

					/* laço para gerar os resumos por categoria */
					for(Integer idCategoria : colecaoCategoriaTemp){

						Categoria categoria = new Categoria();
						categoria.setId(idCategoria);

						BigDecimal valorGuiaDevolucao = mapValorGuiaDevolucaoPorCategoriaSequencial1050.get(idCategoria);

						if(mapAcumularValorPorCategoriaReceitaCancelada.containsKey(idCategoria)){
							mapAcumularValorPorCategoriaReceitaCancelada.put(idCategoria,
											((BigDecimal) mapAcumularValorPorCategoriaReceitaCancelada.get(idCategoria))
															.add(valorGuiaDevolucao));
						}else{
							mapAcumularValorPorCategoriaReceitaCancelada.put(idCategoria, valorGuiaDevolucao);
						}

						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorGuiaDevolucao);
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.GUIAS_DEVOLUCAO_VALORES_COBRADOS_INDEVIDAMENTE_INCLUIDOS);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1050"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// Fim Linha 38

				}

				// laço para construir os resumos de faturamento por
				// categoria
				for(Categoria categoria : colecaoCategorias){

					// receita bruta
					ResumoFaturamento resumoFaturamentoReceitaBruta = new ResumoFaturamento();
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.RECEITA_BRUTA);
					resumoFaturamentoReceitaBruta.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.RECEITA_BRUTA);
					resumoFaturamentoReceitaBruta.setLancamentoItem(lancamentoItem);
					resumoFaturamentoReceitaBruta.setLancamentoItemContabil(null);
					resumoFaturamentoReceitaBruta.setSequenciaTipoLancamento(new Short("600"));
					resumoFaturamentoReceitaBruta.setSequenciaItemTipoLancamento(ZERO);
					resumoFaturamentoReceitaBruta.setValorItemFaturamento(BigDecimal.ZERO);
					resumoFaturamentoReceitaBruta.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);

					// receita liquida
					ResumoFaturamento resumoFaturamentoReceitaLiquida = new ResumoFaturamento();
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.RECEITA_LIQUIDA);
					resumoFaturamentoReceitaLiquida.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.RECEITA_LIQUIDA);
					resumoFaturamentoReceitaLiquida.setLancamentoItem(lancamentoItem);
					resumoFaturamentoReceitaLiquida.setLancamentoItemContabil(null);
					resumoFaturamentoReceitaLiquida.setSequenciaTipoLancamento(new Short("1200"));
					resumoFaturamentoReceitaLiquida.setSequenciaItemTipoLancamento(ZERO);
					resumoFaturamentoReceitaLiquida.setValorItemFaturamento(BigDecimal.ZERO);
					resumoFaturamentoReceitaLiquida.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);

					// receita cancelada
					ResumoFaturamento resumoFaturamentoReceitaCancelada = new ResumoFaturamento();
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.TOTAL_RECEITA_CANCELADA);
					resumoFaturamentoReceitaCancelada.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.TOTAL_RECEITA_CANCELADA);
					resumoFaturamentoReceitaCancelada.setLancamentoItem(lancamentoItem);
					resumoFaturamentoReceitaCancelada.setLancamentoItemContabil(null);
					resumoFaturamentoReceitaCancelada.setSequenciaTipoLancamento(new Short("1100"));
					resumoFaturamentoReceitaCancelada.setSequenciaItemTipoLancamento(ZERO);
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(BigDecimal.ZERO);
					resumoFaturamentoReceitaCancelada.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);

					// total cobrado nas contas
					ResumoFaturamento resumoFaturamentoTotalCobradoNasContas = new ResumoFaturamento();
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.TOTAL_COBRADO_NAS_CONTAS);
					resumoFaturamentoTotalCobradoNasContas.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.TOTAL_COBRADO_CONTAS);
					resumoFaturamentoTotalCobradoNasContas.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTotalCobradoNasContas.setLancamentoItemContabil(null);
					resumoFaturamentoTotalCobradoNasContas.setSequenciaTipoLancamento(new Short("2700"));
					resumoFaturamentoTotalCobradoNasContas.setSequenciaItemTipoLancamento(ZERO);
					resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(BigDecimal.ZERO);
					resumoFaturamentoTotalCobradoNasContas.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);

					// total valores devolvidos nas contas
					ResumoFaturamento resumoFaturamentoValoresDevolvidosNasContas = new ResumoFaturamento();
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.TOTAL_VALORES_DEVOLVIDOS_NAS_CONTAS);
					resumoFaturamentoValoresDevolvidosNasContas.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.TOTAL_VALORES_DEVOLVIDOS_NAS_CONTAS);
					resumoFaturamentoValoresDevolvidosNasContas.setLancamentoItem(lancamentoItem);
					resumoFaturamentoValoresDevolvidosNasContas.setLancamentoItemContabil(null);
					resumoFaturamentoValoresDevolvidosNasContas.setSequenciaTipoLancamento(new Short("2400"));
					resumoFaturamentoValoresDevolvidosNasContas.setSequenciaItemTipoLancamento(ZERO);
					resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(BigDecimal.ZERO);
					resumoFaturamentoValoresDevolvidosNasContas.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);

					// total débitos cancelados por prescrição
					ResumoFaturamento resumoFaturamentoTotalDebitosCanceladosPrescricao = new ResumoFaturamento();
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.TOTAL_DEBITOS_CANCELADOS_POR_PRESCRICAO);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.TOTAL_DEBITOS_CANCELADOS_POR_PRESCRICAO);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setLancamentoItemContabil(null);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setSequenciaTipoLancamento(new Short("4200"));
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setSequenciaItemTipoLancamento(ZERO);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setValorItemFaturamento(BigDecimal.ZERO);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);

					Integer idCategoria = categoria.getId();

					// Linha 01
					// acumula os valores de água com situação da conta
					// igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento.acumularValorAguaSituacaoContaNormal(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se a pesquisa não retornar um objeto nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// monta o resumo de faturamento que vai ser
						// inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.AGUA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AGUA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("100"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(ZERO);

						// soma o valor do resumo de faturamento para
						// sequência igual 100
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										resumoFaturamentoTemporario.getValorItemFaturamento()));

						// subtrai o valor do resumo de faturamento para
						// sequência igual 100
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 01

					// Linha 02
					// acumula os valores de esgoto para situação de
					// conta igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento.acumularValorEsgotoSituacaoContaNormal(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se a pesquisa não retornar um objeto nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// monta o resumo de faturamento que vai ser
						// inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("200"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(ZERO);

						// soma o valor do resumo de faturamento para
						// sequência igual 200
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										resumoFaturamentoTemporario.getValorItemFaturamento()));

						// soma o sequência igual 200 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 02

					// Linha 05 e 06
					// pesquisa a coleção de débitos a cobrar com
					// situação igual a normal e grupo de parcelamento
					// igual a juros cobrados
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoJurosCobrados(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// obtém os valores de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										ZERO, debitoACobrar.getValorDebito());

						// se o array não estiver nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula o valor de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula o valor de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento de curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.JUROS_COBRADOS);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setSequenciaTipoLancamento(new Short("410"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setSequenciaItemTipoLancamento(new Short("0"));

					// acumula o valor do sequencial 410 a receita bruta
					resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
									somaValorCurtoPrazo));

					colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento de longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.JUROS_COBRADOS);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setSequenciaTipoLancamento(new Short("420"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados
									.setSequenciaItemTipoLancamento(new Short("0"));

					// acumula o valor do sequencial 420 a receita bruta
					resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
									somaValorLongoPrazo));

					colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoJurosCobrados);
					// fim longo prazo
					// fim Linha 05 e 06

					// laço para criar resumo de faturamento por
					// lançamento de item contábil
					for(LancamentoItemContabil lancamentoItemContabilTemp : colecaoLancamentosItemContabil){

						// Linha 03 e 04
						// pesquisa a coleção de débitos a cobrar com
						// situação normal e tipo de financiamento igual
						// a serviço
						colecaoTemporariaDebitoACobrar = repositorioFaturamento.pesquisarDebitoACobrarSituacaoNormalFinanciamentoServico(
										anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, lancamentoItemContabilTemp.getId());

						// inicializa as somas de curto e longo prazo
						somaValorCurtoPrazo = BigDecimal.ZERO;
						somaValorLongoPrazo = BigDecimal.ZERO;

						// atribui para null o array que vai armazenar o
						// valor de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = null;

						// laço para acumular os valores de curto e
						// longo prazo
						for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

							// obtém os valores de curto e longo prazo
							valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(
											debitoACobrar.getNumeroPrestacaoDebito(), new Short("0"), debitoACobrar.getValorDebito());

							// se o array não estiver nulo
							if(valoresCurtoPrazoLongoPrazo != null){
								// acumula o valor de curto prazo
								somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

								// acumula o valor de longo prazo
								somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
							}
						}

						// cria os resumos de faturamento para curto e
						// longo prazo
						ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal = new ResumoFaturamento();
						ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal = new ResumoFaturamento();

						// inicio curto prazo
						// cria o resumo de faturamento de curto prazo
						// que vai ser inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();

						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setLocalidade(localidade);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setCategoria(categoria);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setValorItemFaturamento(somaValorCurtoPrazo);
						lancamentoTipo.setId(LancamentoTipo.FINANCIAMENTOS_INCLUIDOS_CURTO_PRAZO);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setLancamentoItem(lancamentoItem);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setSequenciaTipoLancamento(new Short("300"));
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp
										.getSequenciaImpressao());

						// soma o valor do resumo de faturamento para
						// sequência igual 300
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										somaValorCurtoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormal);
						// fim curto prazo

						// inicio longo prazo
						// cria o resumo de faturamento de longo prazo
						// que vai ser inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setLocalidade(localidade);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setCategoria(categoria);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setValorItemFaturamento(somaValorLongoPrazo);
						lancamentoTipo.setId(LancamentoTipo.FINANCIAMENTOS_INCLUIDOS_LONGO_PRAZO);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setLancamentoItem(lancamentoItem);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setSequenciaTipoLancamento(new Short("400"));
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp
										.getSequenciaImpressao());

						// soma o valor do resumo de faturamento para
						// sequência igual 400 a receita bruta
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										somaValorLongoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormal);
						// fim longo prazo
						// fim Linha 03 e 04

						// Linha 10
						// acumular o valor de débito para tipo de
						// financiamento igual a serviço e para situação
						// igual a incluída
						valorItemFaturamento = repositorioFaturamento.acumularValorDebitoTipoFinanciamentoServicoSituacaoIncluida(
										anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, lancamentoItemContabilTemp.getId());

						if(valorItemFaturamento == null){
							valorItemFaturamento = BigDecimal.ZERO;
						}

						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("510"));

						// calcula a diferença entre as contas
						// canceladas por retificação e retificadas
						diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada = this
										.obterDiferencaValoresServicoIndiretosContaRetificada(anoMesFaturamentoSistemaParametro,
														idLocalidade, idCategoria, FinanciamentoTipo.SERVICO_NORMAL,
														resumoFaturamentoTemporario.getLancamentoItemContabil().getId());

						// se a diferença for negativa
						if(diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() < 0.0){
							// adiciona o valor da diferença ao valor do
							// resumo de faturamento
							resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
											diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada.multiply(menosUm)));
						}

						// soma o valor do resumo de faturamento para
						// sequência igual 510 a receita bruta
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						// fim Linha 10

						// Linha 11
						idsCreditosOrigem = new Integer[4];
						idsCreditosOrigem[0] = CreditoOrigem.DEVOLUCAO_TARIFA_AGUA;
						idsCreditosOrigem[1] = CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO;
						idsCreditosOrigem[2] = CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE;
						idsCreditosOrigem[3] = CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO;

						// acumula o valor por categoria do credito realizado
						// com origem do credito igual a
						// devolução de tarifa de água, devolução de tarifa de
						// esgoto,
						// serviços indiretos pagos indevidamente ou devolução
						// de juros de parcelamento e
						// com situação atual da conta igual cancelada
						// e com ano/mês de referência contábil da conta
						// igual ao ano/mês do faturamento de sistema parâmetro.
						BigDecimal valorCreditoRealizadoOrigemCreditoSituacaoCancelada = repositorioFaturamento
										.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsCreditosOrigem,
														DebitoCreditoSituacao.CANCELADA, lancamentoItemContabilTemp.getId());

						// [SB0003 - Obter diferenças de valores de créditos
						// realizados de conta retificada]
						BigDecimal diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada = this
										.obterDiferencaValoresCreditosRealizadosContaRetificada(anoMesFaturamentoSistemaParametro,
														idLocalidade, idCategoria, idsCreditosOrigem, lancamentoItemContabilTemp.getId());

						/*
						 * Acumula, quando positiva, a diferença entre o valor dos créditos
						 * realizados com origem do crédito igual a devolução de
						 * tarifa de água, devolução de tarifa de esgoto, serviços indiretos pagos
						 * indevidamente ou devolução de juros de parcelamento
						 * e situação atual da conta igual a cancelada por retificação e o valor do
						 * crédito realizado com situação atual ou anterior
						 * da conta igual a retificada.
						 */
						if(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
							valorCreditoRealizadoOrigemCreditoSituacaoCancelada = valorCreditoRealizadoOrigemCreditoSituacaoCancelada
											.add(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada);
						}

						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoSituacaoCancelada);
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.CREDITOS_PARA_COBRANCA_INDEVIDA_CANCELADOS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("520"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());

						// soma o valor do resumo de faturamento para
						// sequência igual 520 a receita bruta
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						// fim Linha 11

						// Linha 34
						// acumula o valor por categoria do credito realizado
						// com origem do credito igual a
						// devolução de tarifa de água, devolução de tarifa de
						// esgoto,
						// serviços indiretos pagos indevidamente ou devolução
						// de juros de parcelamento e
						// com situação atual da conta igual incluída
						// e com ano/mês de referência contábil da conta
						// igual ao ano/mês do faturamento de sistema parâmetro.
						BigDecimal valorCreditoRealizadoOrigemCreditoSituacaoIncluida = repositorioFaturamento
										.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsCreditosOrigem,
														DebitoCreditoSituacao.INCLUIDA, lancamentoItemContabilTemp.getId());

						/*
						 * Acumula, quando negativa, a diferença entre o valor dos créditos
						 * realizados com origem do crédito igual a devolução de
						 * tarifa de água, devolução de tarifa de esgoto, serviços indiretos pagos
						 * indevidamente ou devolução de juros de parcelamento
						 * e situação atual da conta igual a cancelada por retificação e o valor do
						 * crédito realizado com situação atual ou anterior
						 * da conta igual a retificada.
						 */
						if(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1){
							valorCreditoRealizadoOrigemCreditoSituacaoIncluida = valorCreditoRealizadoOrigemCreditoSituacaoIncluida
											.add(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada.multiply(menosUm));
						}

						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoSituacaoIncluida);
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CANCELAMENTO_POR_REFATURAMENTO);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.CREDITOS_PARA_COBRANCA_INDEVIDA_INCLUIDOS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1010"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());

						// adiciona o sequencial 1010 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						// fim Linha 34

						// Linha 17 e 18
						// pesquisa a coleção de débitos a cobrar com
						// situação cancelado e tipo de financiamento
						// igual a serviço
						colecaoTemporariaDebitoACobrar = repositorioFaturamento
										.pesquisarDebitoACobrarSituacaoCanceladoFinanciamentoServico(anoMesFaturamentoSistemaParametro,
														idLocalidade, idCategoria, lancamentoItemContabilTemp.getId());

						// inicializa as somas de curto e longo prazo
						somaValorCurtoPrazo = BigDecimal.ZERO;
						somaValorLongoPrazo = BigDecimal.ZERO;

						// atribui para null o array que vai armazenar o
						// valor de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = null;

						// laço para acumular os valores de curto e
						// longo prazo
						for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

							// obtém os valores de curto e longo prazo
							valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(
											debitoACobrar.getNumeroPrestacaoDebito(), debitoACobrar.getNumeroPrestacaoCobradas(),
											debitoACobrar.getValorDebito());

							// se o array não estiver nulo
							if(valoresCurtoPrazoLongoPrazo != null){
								// acumula o valor de curto prazo
								somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

								// acumula o valor de longo prazo
								somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
							}
						}

						// cria os resumos de faturamento para curto e
						// longo prazo
						ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado = new ResumoFaturamento();
						ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado = new ResumoFaturamento();

						// inicio curto prazo
						// cria o resumo de faturamento de curto prazo
						// que vai ser inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setLocalidade(localidade);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setCategoria(categoria);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setValorItemFaturamento(somaValorCurtoPrazo);
						lancamentoTipo.setId(LancamentoTipo.FINANCIAMENTOS_CANCELADOS_CURTO_PRAZO);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setLancamentoItem(lancamentoItem);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setSequenciaTipoLancamento(new Short("700"));
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp
										.getSequenciaImpressao());

						// adiciona o sequencial 700 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(somaValorCurtoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCancelado);
						// fim curto prazo

						// inicio longo prazo
						// cria o resumo de faturamento de longo prazo
						// que vai ser inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();

						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setLocalidade(localidade);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setCategoria(categoria);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setValorItemFaturamento(somaValorLongoPrazo);
						lancamentoTipo.setId(LancamentoTipo.FINANCIAMENTOS_CANCELADOS_LONGO_PRAZO);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setLancamentoItem(lancamentoItem);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setSequenciaTipoLancamento(new Short("800"));
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp
										.getSequenciaImpressao());

						// adiciona o sequencial 800 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(somaValorLongoPrazo));

						colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCancelado);
						// fim longo prazo
						// fim Linha 17 e 18

						// Linha 23 e 24
						// pesquisa a coleção de débitos a cobrar com
						// situação cancelado e tipo de financiamento
						// igual a parcelamento de serviço
						colecaoTemporariaDebitoACobrar = repositorioFaturamento
										.pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoServico(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
														lancamentoItemContabilTemp.getId());

						// inicializa as somas de curto e longo prazo
						somaValorCurtoPrazo = BigDecimal.ZERO;
						somaValorLongoPrazo = BigDecimal.ZERO;

						// atribui para null o array que vai armazenar o
						// valor de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = null;

						// laço para acumular os valores de curto e
						// longo prazo
						for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

							// obtém os valores de curto e longo prazo
							valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(
											debitoACobrar.getNumeroPrestacaoDebito(), debitoACobrar.getNumeroPrestacaoCobradas(),
											debitoACobrar.getValorDebito());

							// se o array não estiver nulo
							if(valoresCurtoPrazoLongoPrazo != null){
								// acumula o valor de curto prazo
								somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

								// acumula o valor de longo prazo
								somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
							}
						}

						// cria os resumos de faturamento para curto e
						// longo prazo
						ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico = new ResumoFaturamento();
						ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico = new ResumoFaturamento();

						// inicio curto prazo
						// cria o resumo de faturamento de curto prazo
						// que vai ser inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setLocalidade(localidade);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setCategoria(categoria);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setValorItemFaturamento(somaValorCurtoPrazo);
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_CANCELADOS_CURTO_PRAZO);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setLancamentoItem(lancamentoItem);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setSequenciaTipoLancamento(new Short("810"));
						resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());

						// adiciona o sequencial 810 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(somaValorCurtoPrazo));

						colecaoResumoFaturamento
										.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico);
						// fim curto prazo

						// inicio longo prazo
						// cria o resumo de faturamento de longo prazo
						// que vai ser inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();

						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setLocalidade(localidade);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setCategoria(categoria);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setValorItemFaturamento(somaValorLongoPrazo);
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_CANCELADOS_LONGO_PRAZO);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setLancamentoItem(lancamentoItem);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setSequenciaTipoLancamento(new Short("820"));
						resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico
										.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());

						// adiciona o sequencial 820 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(somaValorLongoPrazo));

						colecaoResumoFaturamento
										.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoServico);
						// fim longo prazo
						// fim Linha 23 e 24

						// Linha 29
						// acumula os valores do débito para tipo de
						// financiamento igual a serviço e situação igual a
						// cancelada
						valorItemFaturamento = repositorioFaturamento.acumularValorDebitoTipoFinanciamentoServicoSituacaoCancelada(
										anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, lancamentoItemContabilTemp.getId());

						if(valorItemFaturamento == null){
							valorItemFaturamento = BigDecimal.ZERO;
						}

						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CANCELAMENTOS_POR_REFATURAMENTO);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("900"));

						// obtém o valor da guia de pagamento para
						// situação igual a cancelada
						BigDecimal valorGuiaPagamentoSituacaoCancelada = repositorioFaturamento
										.acumularValorGuiaPagamentoSituacaoCancelada(anoMesFaturamentoSistemaParametro, idLocalidade,
														idCategoria, FinanciamentoTipo.SERVICO_NORMAL, resumoFaturamentoTemporario
																		.getLancamentoItemContabil().getId());

						if(valorGuiaPagamentoSituacaoCancelada == null){
							valorGuiaPagamentoSituacaoCancelada = BigDecimal.ZERO;
						}

						// soma o valor da guia
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										valorGuiaPagamentoSituacaoCancelada));

						// calcula a diferença entre as contas
						// canceladas por retificação e retificadas
						diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada = this
										.obterDiferencaValoresServicoIndiretosContaRetificada(anoMesFaturamentoSistemaParametro,
														idLocalidade, idCategoria, FinanciamentoTipo.SERVICO_NORMAL,
														resumoFaturamentoTemporario.getLancamentoItemContabil().getId());

						// se a diferença for negativa
						if(diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() > 0.0){
							// adiciona o valor da diferença ao valor do
							// resumo de faturamento
							resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
											diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada));
						}

						// adiciona o sequencial 900 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						// fim Linha 29

						// Linha 32
						// acumular o valor de débito para tipo de
						// financiamento igual a parcelamento de serviço e
						// para situação igual a cancelada
						valorItemFaturamento = repositorioFaturamento
										.acumularValorDebitoTipoFinanciamentoParcelamentoServicoSituacaoCancelada(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
														lancamentoItemContabilTemp.getId());

						if(valorItemFaturamento == null){
							valorItemFaturamento = BigDecimal.ZERO;
						}

						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTOS_POR_REFATURAMENTO);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1000"));

						// calcula a diferença entre as contas
						// canceladas por retificação e retificadas
						diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada = this
										.obterDiferencaValoresServicoIndiretosContaRetificada(anoMesFaturamentoSistemaParametro,
														idLocalidade, idCategoria, FinanciamentoTipo.PARCELAMENTO_SERVICO,
														resumoFaturamentoTemporario.getLancamentoItemContabil().getId());

						// se a diferença for positiva
						if(diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() > 0.0){
							// adiciona o valor da diferença ao valor do
							// resumo de faturamento
							resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
											diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada));
						}

						// adiciona o sequencial 1000 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						// fim Linha 32

						// Linha 106
						// acumula o valor por categoria do débito cobrado
						// com tipo de financiamento igual a
						// serviço e situação atual da conta igual a
						// débito prescrito
						// e com ano/mês de referência contábil da conta
						// preenchido.

						idsTipoFinanciamento = new Integer[4];
						idsTipoFinanciamento[0] = FinanciamentoTipo.SERVICO_NORMAL;
						idsTipoFinanciamento[1] = FinanciamentoTipo.ARRASTO_AGUA;
						idsTipoFinanciamento[2] = FinanciamentoTipo.ARRASTO_ESGOTO;
						idsTipoFinanciamento[3] = FinanciamentoTipo.ARRASTO_SERVICO;

						colecaoTemporaria = repositorioFaturamento
										.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsTipoFinanciamento,
														DebitoCreditoSituacao.PRESCRITA, lancamentoItemContabilTemp.getId());

						// se o objeto retornado não for nulo
						for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
							// cria o resumo de faturamento
							lancamentoTipo = new LancamentoTipo();
							lancamentoItem = new LancamentoItem();
							lancamentoTipo.setId(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
							resumoFaturamento.setLancamentoTipo(lancamentoTipo);
							lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
							resumoFaturamento.setLancamentoItem(lancamentoItem);
							resumoFaturamento.setSequenciaTipoLancamento(new Short("3400"));

							// acumula o valor do sequencial 3400 ao total de
							// débitos cancelados por prescrição
							resumoFaturamentoTotalDebitosCanceladosPrescricao
											.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
															.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
						// fim Linha 106

						// Linha 109
						// acumula o valor por categoria do débito cobrado
						// com tipo de financiamento igual a
						// parcelamento de serviço e situação atual da conta
						// igual a
						// débito prescrito
						// e com ano/mês de referência contábil da conta
						// preenchido.
						colecaoTemporaria = repositorioFaturamento
										.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
														FinanciamentoTipo.PARCELAMENTO_SERVICO, DebitoCreditoSituacao.PRESCRITA,
														lancamentoItemContabilTemp.getId());

						// se o objeto retornado não for nulo
						for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
							// cria o resumo de faturamento
							lancamentoTipo = new LancamentoTipo();
							lancamentoItem = new LancamentoItem();
							lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_EXC_INADIMPLENCIA);
							resumoFaturamento.setLancamentoTipo(lancamentoTipo);
							lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
							resumoFaturamento.setLancamentoItem(lancamentoItem);
							resumoFaturamento.setSequenciaTipoLancamento(new Short("3500"));

							// acumula o valor do sequencial 3500 ao total de
							// débitos cancelados por prescrição
							resumoFaturamentoTotalDebitosCanceladosPrescricao
											.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
															.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
						// fim Linha 109

						// Linha 112
						// acumula o valor por categoria do crédito
						// realizado com origem do crédito igual a
						// devolução de tarifa de água ou devolução de
						// tarifa de esgoto ou serviços indiretos pagos
						// indevidamente
						// ou devolução de juros de parcelamento
						// e situação atual da conta igual a débito prescrito
						// com ano/mês da baixa contábil da conta preenchido
						Integer[] idsOrigemCreditos = {CreditoOrigem.DEVOLUCAO_TARIFA_AGUA, CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO, CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE, CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO};

						resumoFaturamentoTemporario = repositorioFaturamento
										.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsOrigemCreditos,
														DebitoCreditoSituacao.PRESCRITA, lancamentoItemContabilTemp.getId());

						// se o objeto retornado não for nulo
						if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
							// cria o resumo de faturamento
							lancamentoTipo = new LancamentoTipo();
							lancamentoItem = new LancamentoItem();
							lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
							resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
							lancamentoItem.setId(LancamentoItem.CREDITOS_PARA_COBRANCA_INDEVIDA);
							resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
							resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
							resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3600"));
							resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());

							// subtrai o valor do sequencial 3600 ao total de
							// débitos cancelados por prescrição
							resumoFaturamentoTotalDebitosCanceladosPrescricao
											.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
															.getValorItemFaturamento().subtract(
																			resumoFaturamentoTemporario.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}
						// fim Linha 112

						// Linha 122

						idsTipoFinanciamento = new Integer[4];
						idsTipoFinanciamento[0] = FinanciamentoTipo.SERVICO_NORMAL;
						idsTipoFinanciamento[1] = FinanciamentoTipo.ARRASTO_AGUA;
						idsTipoFinanciamento[2] = FinanciamentoTipo.ARRASTO_ESGOTO;
						idsTipoFinanciamento[3] = FinanciamentoTipo.ARRASTO_SERVICO;

						// acumula o valor por categoria do débito cobrado
						// com tipo de financiamento igual a
						// serviço e situação atual da conta igual a
						// débito prescrito
						// e com ano/mês de referência contábil da conta não
						// preenchido.
						colecaoTemporaria = repositorioFaturamento
										.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsTipoFinanciamento,
														DebitoCreditoSituacao.PRESCRITA, lancamentoItemContabilTemp.getId());

						// se o objeto retornado não for nulo
						for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
							// cria o resumo de faturamento
							lancamentoTipo = new LancamentoTipo();
							lancamentoItem = new LancamentoItem();
							lancamentoTipo.setId(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
							resumoFaturamento.setLancamentoTipo(lancamentoTipo);
							lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
							resumoFaturamento.setLancamentoItem(lancamentoItem);
							resumoFaturamento.setSequenciaTipoLancamento(new Short("3800"));

							// acumula o valor do sequencial 3800 ao total de
							// débitos cancelados por prescrição
							resumoFaturamentoTotalDebitosCanceladosPrescricao
											.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
															.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
						// fim Linha 122

						// Linha 125
						// acumula o valor por categoria do débito cobrado
						// com tipo de financiamento igual a
						// parcelamento de serviço e situação atual da conta
						// igual a
						// débito prescrito
						// e com ano/mês de referência contábil da conta não
						// preenchido.

						// laço para criar todos os resumos de faturamento

						colecaoTemporaria = repositorioFaturamento
										.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
														FinanciamentoTipo.PARCELAMENTO_SERVICO, DebitoCreditoSituacao.PRESCRITA,
														lancamentoItemContabilTemp.getId());

						// se o objeto retornado não for nulo
						for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
							// cria o resumo de faturamento
							lancamentoTipo = new LancamentoTipo();
							lancamentoItem = new LancamentoItem();
							lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
							resumoFaturamento.setLancamentoTipo(lancamentoTipo);
							lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
							resumoFaturamento.setLancamentoItem(lancamentoItem);
							resumoFaturamento.setSequenciaTipoLancamento(new Short("3900"));

							// acumula o valor do sequencial 3900 ao total de
							// débitos cancelados por prescrição
							resumoFaturamentoTotalDebitosCanceladosPrescricao
											.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
															.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamento);
						}
						// fim Linha 125

						// Linha 128
						// acumula o valor por categoria do crédito
						// realizado com origem do crédito igual a
						// devolução de tarifa de água ou devolução de
						// tarifa de esgoto ou serviços indiretos pagos
						// indevidamente
						// ou devolução de juros de parcelamento
						// e situação atual da conta igual a débito prescrito
						// com ano/mês da baixa contábil da conta não preenchido
						resumoFaturamentoTemporario = repositorioFaturamento
										.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
														anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsOrigemCreditos,
														DebitoCreditoSituacao.PRESCRITA, lancamentoItemContabilTemp.getId());

						// se o objeto retornado não for nulo
						if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
							// cria o resumo de faturamento
							lancamentoTipo = new LancamentoTipo();
							lancamentoItem = new LancamentoItem();
							lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
							resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
							lancamentoItem.setId(LancamentoItem.CREDITOS_PARA_COBRANCA_INDEVIDA);
							resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
							resumoFaturamentoTemporario.setLancamentoItemContabil(lancamentoItemContabilTemp);
							resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("4000"));
							resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(lancamentoItemContabilTemp.getSequenciaImpressao());

							// subtrai o valor do sequencial 4000 ao total de
							// débitos cancelados por prescrição
							resumoFaturamentoTotalDebitosCanceladosPrescricao
											.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
															.getValorItemFaturamento().subtract(
																			resumoFaturamentoTemporario.getValorItemFaturamento()));

							colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
						}
						// fim Linha 128

					}// FIM DO LAÇO DE LANÇAMENTO DE ITEM CONTÁBIL

					// Linha 07
					// acumular o valor de guia de pagamento
					// parasituação normal e tipo de financiamento igual
					// a serviço
					colecaoTemporaria = repositorioFaturamento.acumularValorGuiaPagamentoSituacaoNormalFinanciamentoServico(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.FATURAMENTO_ADICIONAL_GUIA_PAGAMENTO);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("500"));

						// acumula o valor do sequencial 500 a receita bruta
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 07

					// Linha 27
					// acumular o valor de água para situação igual a
					// cancelada

					valorItemFaturamento = repositorioFaturamento.acumularValorAguaSituacaoCancelada(anoMesFaturamentoSistemaParametro,
									idLocalidade, idCategoria);

					if(valorItemFaturamento == null){
						valorItemFaturamento = BigDecimal.ZERO;
					}
					// inicializa a variável que vai armazenar a
					// diferença dos valores de água entre as contas
					// canceladas
					// por retificação e as contas retificadas
					BigDecimal diferencaEntreValorAguaSituacaoCanceladaPorRetificacaoESituacaoRetificada = BigDecimal.ZERO;

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.CANCELAMENTOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AGUA);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("900"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

					// cria as variáveis que vai armazenar os
					// valores de água das contas
					// canceladas por retificação e retificada
					BigDecimal somaValorAguaSituacaoCanceladaPorRetificacao = null;
					BigDecimal somaValorAguaSituacaoRetificada = null;

					// recupera a soma do valor de água para conta
					// canceladas por retificação
					somaValorAguaSituacaoCanceladaPorRetificacao = repositorioFaturamento
									.pesquisarSomaValorAguaSituacaoCanceladaPorRetificacao(anoMesFaturamentoSistemaParametro, idLocalidade,
													idCategoria);

					// recupera a soma do valor de água para conta
					// retificada
					somaValorAguaSituacaoRetificada = repositorioFaturamento.pesquisarSomaValorAguaSituacaoRetificada(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					if(somaValorAguaSituacaoCanceladaPorRetificacao != null){
						// obtém a diferença entre os valores
						diferencaEntreValorAguaSituacaoCanceladaPorRetificacaoESituacaoRetificada = (somaValorAguaSituacaoCanceladaPorRetificacao
										.subtract(somaValorAguaSituacaoRetificada));
					}

					// se a diferença for positiva
					if(diferencaEntreValorAguaSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() > 0.0){
						// adiciona a diferença ao valor do resumo
						// de faturamento
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										diferencaEntreValorAguaSituacaoCanceladaPorRetificacaoESituacaoRetificada));
					}

					// adiciona o sequencial 900 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 27

					// Linha 08
					// acumular o valor de água para situação igual a
					// incluída
					valorItemFaturamento = repositorioFaturamento.acumularValorAguaSituacaoIncluida(anoMesFaturamentoSistemaParametro,
									idLocalidade, idCategoria);

					if(valorItemFaturamento == null){
						valorItemFaturamento = BigDecimal.ZERO;
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AGUA);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("510"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

					// usa a mesma diferença obtida na linha 27
					// se a diferença for negativa
					if(diferencaEntreValorAguaSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() < 0.0){
						// adiciona o valor da diferença ao valor do
						// resumo de faturamento
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										diferencaEntreValorAguaSituacaoCanceladaPorRetificacaoESituacaoRetificada.multiply(menosUm)));
					}

					// acumula o valor do sequencial 510 a receita bruta
					resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
									resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 08

					// Linha 28
					// acumula os valores de esgoto para situação
					// cancelada
					valorItemFaturamento = repositorioFaturamento.acumularValorEsgotoSituacaoCancelada(anoMesFaturamentoSistemaParametro,
									idLocalidade, idCategoria);

					if(valorItemFaturamento == null){
						valorItemFaturamento = BigDecimal.ZERO;
					}

					// inicializa a variável que vai armazenar a
					// diferença dos valores de esgoto entre as contas
					// canceladas
					// por retificação e as contas retificadas
					BigDecimal diferencaEntreValorEsgotoSituacaoCanceladaPorRetificacaoESituacaoRetificada = BigDecimal.ZERO;

					// cria o resumo de faturamento
					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.CANCELAMENTOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.ESGOTO);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("900"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

					// cria as variáveis que vai armazenar os
					// valores de esgoto das contas
					// canceladas por retificação e retificada
					BigDecimal somaValorEsgotoSituacaoCanceladaPorRetificacao = null;
					BigDecimal somaValorEsgotoSituacaoRetificada = null;

					// recupera a soma de valor de esgoto para conta
					// canceladas por retificação
					somaValorEsgotoSituacaoCanceladaPorRetificacao = repositorioFaturamento
									.pesquisarSomaValorEsgotoSituacaoCanceladaPorRetificacao(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria);

					// recupera a soma do valor de esgoto para conta
					// retificada
					somaValorEsgotoSituacaoRetificada = repositorioFaturamento.pesquisarSomaValorEsgotoSituacaoRetificada(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// obtém a diferença entre os valores
					diferencaEntreValorEsgotoSituacaoCanceladaPorRetificacaoESituacaoRetificada = (somaValorEsgotoSituacaoCanceladaPorRetificacao
									.subtract(somaValorEsgotoSituacaoRetificada));

					// se a diferença for positiva
					if(diferencaEntreValorEsgotoSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() > 0.0){
						// adiciona o valor da diferença no valor do
						// resumo de faturamento
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										diferencaEntreValorEsgotoSituacaoCanceladaPorRetificacaoESituacaoRetificada));
					}

					// adiciona o sequencial 900 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 28

					// Linha 09
					// acumular o valor de esgoto para situação atual
					// ou anterior igual a incluída
					valorItemFaturamento = repositorioFaturamento.acumularValorEsgotoSituacaoIncluida(anoMesFaturamentoSistemaParametro,
									idLocalidade, idCategoria);

					if(valorItemFaturamento == null){
						valorItemFaturamento = BigDecimal.ZERO;
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.ESGOTO);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("510"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

					// usa a mesma diferença obtida na linha 28
					// se a diferença for negativa
					if(diferencaEntreValorEsgotoSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() < 0.0){
						// adiciona negativamente o valor da
						// diferença ao valor do resumo de
						// faturamento
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										diferencaEntreValorEsgotoSituacaoCanceladaPorRetificacaoESituacaoRetificada.multiply(menosUm)));
					}

					// acumula o valor do sequencial 510 a receita bruta
					resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
									resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 09

					// Linha 12
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_INCONDICIONAIS;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// descontos incondicionais
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosIncondicionais = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.CANCELADA);

					// [SB0003 - Obter diferenças de valores de créditos
					// realizados de conta retificada]
					BigDecimal diferencaCreditoOrigemDescontosIncondicionaisCanceladaPorRetificacaoeERetificada = this
									.obterDiferencaValoresCreditosRealizadosContaRetificada(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem);

					/*
					 * Acumula, quando positiva, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a descontos
					 * incondicionais e situação atual da conta igual a cancelada por retificação e
					 * o valor do crédito realizado com situação atual ou
					 * anterior da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemDescontosIncondicionaisCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						valorCreditoRealizadoOrigemCreditoDescontosIncondicionais = valorCreditoRealizadoOrigemCreditoDescontosIncondicionais
										.add(diferencaCreditoOrigemDescontosIncondicionaisCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoDescontosIncondicionais);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.INCLUSOES_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS_CANCELADOS);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("530"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("0"));

					// acumula o valor do sequencial 530 a receita bruta
					resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
									resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 12

					// Linha 35
					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// descontos incondicionais
					// com situação atual da conta igual incluída
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosIncondicionaisSituacaoIncluida = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.INCLUIDA);

					/*
					 * Acumula, quando negativa, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a descontos
					 * incondicionais e situação atual da conta igual a cancelada por retificação e
					 * o valor do crédito realizado com situação atual ou
					 * anterior da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemDescontosIncondicionaisCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1){
						valorCreditoRealizadoOrigemCreditoDescontosIncondicionaisSituacaoIncluida = valorCreditoRealizadoOrigemCreditoDescontosIncondicionaisSituacaoIncluida
										.add(diferencaCreditoOrigemDescontosIncondicionaisCanceladaPorRetificacaoeERetificada
														.multiply(menosUm));
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario
									.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoDescontosIncondicionaisSituacaoIncluida);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CANCELAMENTO_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS_INCLUIDOS);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1020"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("0"));

					// adiciona o sequencial 1020 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 35

					// Linha 19 e 20
					// pesquisa a coleção de débitos a cobrar com
					// situação igual a cancelado e tipo de
					// financiamento igual a parcelamento de água
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoAgua(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// obtém os valores de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										debitoACobrar.getNumeroPrestacaoCobradas(), debitoACobrar.getValorDebito());

						// se o array não for nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula o valor de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula o valor de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento de curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_CANCELADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AGUA);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setSequenciaTipoLancamento(new Short("810"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setSequenciaItemTipoLancamento(new Short("10"));

					// adiciona o sequencial 810 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(somaValorCurtoPrazo));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua);
					// fim curto prazo

					// longo prazo
					// cria o resumo de faturamento de longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_CANCELADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AGUA);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setSequenciaTipoLancamento(new Short("820"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua
									.setSequenciaItemTipoLancamento(new Short("10"));

					// adiciona o sequencial 820 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(somaValorLongoPrazo));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoAgua);
					// fim longo prazo
					// fim Linha 19 e 20

					// Linha 21 e 22
					// pesquisa a coleção de débitos a cobrar com
					// situação igual a cancelado e tipo de
					// financiamento igual a parcelamento de esgoto
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// obtém os valores de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										debitoACobrar.getNumeroPrestacaoCobradas(), debitoACobrar.getValorDebito());

						// se o array não estiver nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula o valor de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula o valor de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento de curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_CANCELADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.ESGOTO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setSequenciaTipoLancamento(new Short("810"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setSequenciaItemTipoLancamento(new Short("20"));

					// adiciona o sequencial 810 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(somaValorCurtoPrazo));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento de longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_CANCELADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.ESGOTO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setSequenciaTipoLancamento(new Short("820"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto
									.setSequenciaItemTipoLancamento(new Short("20"));

					// adiciona o sequencial 820 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(somaValorLongoPrazo));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoParcelamentoEsgoto);
					// fim longo prazo
					// fim Linha 21 e 22

					// Linha 25 e 26
					// pesquisa a coleção de débitos a cobrar com
					// situação igual a cancelado e tipo de
					// financiamento igual a juros de parcelamento
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoCanceladoTipoFinanciamentoJurosParcelamento(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// obtém os valores de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obté os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										debitoACobrar.getNumeroPrestacaoCobradas(), debitoACobrar.getValorDebito());

						// se o array não estiver nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acuma o valor de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula o valor de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento de curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_CANCELADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.JUROS);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setSequenciaTipoLancamento(new Short("810"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

					// adiciona o sequencial 810 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(somaValorCurtoPrazo));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento de longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_CANCELADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.JUROS);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setSequenciaTipoLancamento(new Short("820"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento
									.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

					// adiciona o sequencial 810 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(somaValorLongoPrazo));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoCanceladoTipoFinanciamentoJurosParcelamento);
					// fim longo prazo
					// fim Linha 25 e 26

					// Linha 30
					// acumular o valor de débito para tipo de
					// financiamento igual a parcelamento de água e para
					// situação igual a cancelada
					valorItemFaturamento = repositorioFaturamento.acumularValorDebitoTipoFinanciamentoParcelamentoAguaSituacaoCancelada(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					if(valorItemFaturamento == null){
						valorItemFaturamento = BigDecimal.ZERO;
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AGUA);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1000"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

					// calcula a diferença entre as contas
					// canceladas por retificação e retificadas
					diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada = this
									.obterDiferencaValoresParcelamentoIndiretosContaRetificada(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, FinanciamentoTipo.PARCELAMENTO_AGUA);

					// se a diferença for positiva
					if(diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() > 0.0){
						// adiciona o valor da diferença ao valor do
						// resumo de faturamento
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada));
					}

					// adiciona o sequencial 1000 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 30

					// Linha 31
					// acumular o valor de débito para tipo de
					// financiamento igual a parcelamento de esgoto e
					// para situação igual a cancelada
					valorItemFaturamento = repositorioFaturamento.acumularValorDebitoTipoFinanciamentoParcelamentoEsgotoSituacaoCancelada(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					if(valorItemFaturamento == null){
						valorItemFaturamento = BigDecimal.ZERO;
					}

					// se o objeto retornado não for nullo
					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.ESGOTO);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1000"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

					// calcula a diferença entre as contas
					// canceladas por retificação e retificadas
					diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada = this
									.obterDiferencaValoresParcelamentoIndiretosContaRetificada(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, FinanciamentoTipo.PARCELAMENTO_ESGOTO);

					// se a diferença for positiva
					if(diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() > 0.0){
						// adiciona o valor da diferença ao valor do
						// resumo de faturamento
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada));
					}

					// adiciona o sequencial 1000 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 31

					// Linha 33
					// acumular o valor de débito para tipo de
					// financiamento igual a juros de parcelamento e
					// para situação igual a cancelada
					valorItemFaturamento = repositorioFaturamento.acumularValorDebitoTipoFinanciamentoJurosParcelamentoSituacaoCancelada(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					if(valorItemFaturamento == null){
						valorItemFaturamento = BigDecimal.ZERO;
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setValorItemFaturamento(valorItemFaturamento);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.JUROS);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1000"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

					// calcula a diferença entre as contas
					// canceladas por retificação e retificadas
					diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada = this
									.obterDiferencaValoresParcelamentoIndiretosContaRetificada(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, FinanciamentoTipo.JUROS_PARCELAMENTO);

					// se a diferença for positiva
					if(diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada.doubleValue() > 0.0){
						// adiciona o valor da diferença ao valor do
						// resumo de faturamento
						resumoFaturamentoTemporario.getValorItemFaturamento().add(
										diferencaEntreValorDebitoSituacaoCanceladaPorRetificacaoESituacaoRetificada);
					}

					// adiciona o sequencial 1000 a receita cancelada
					resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()
									.add(resumoFaturamentoTemporario.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 33

					// Linha 41
					// acumular o valor da categoria do débito para tipo
					// de financiamento igual a serviço e para situação
					// igual a normal e o nº de prestações cobradas for
					// maior que 11(onze)
					colecaoTemporaria = repositorioFaturamento
									.acumularValorCategoriaDebitoTipoFinanciamentoServicoSituacaoNormalNumeroPrestacoesCobradasMaiorQue11(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.FINANCIAMENTOS_TRANSFERIDOS_CURTO_PRAZO);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.FINANCIAMENTOS_TRANSFERIDOS_CURTO_PRAZO);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("1400"));
						resumoFaturamento.setSequenciaItemTipoLancamento(ZERO);

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 41

					// Linha 42
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a juros de
					// parcelamento e situação de igual a normal e a
					// diferença entre as prestações for maior que
					// 11(onze)
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoJurosParcelamentoSituacaoNormalDiferencaPrestacoesMaiorQue11(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_TRASFERIDOS_PARA_CURTO_PRAZO);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.PARCELAMENTOS_TRANSFERIDOS_PARA_CURTO_PRAZO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1450"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(ZERO);

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 42

					// Linha 43 e 44
					// pesquisa a coleção de débitos a cobrar com
					// situação normal e grupo de parcelamento igual a
					// documentos emitidos
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoDocumentosEmitidos(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// atribui para null o array que vai armazenar o
					// valor de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										ZERO, debitoACobrar.getValorDebito());

						// se o array não estiver nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula o valor de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula o valor de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento para curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DOCUMENTOS_EMITIDOS);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setSequenciaTipoLancamento(new Short("1500"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setSequenciaItemTipoLancamento(new Short("10"));

					colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento para longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DOCUMENTOS_EMITIDOS);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setSequenciaTipoLancamento(new Short("1600"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos
									.setSequenciaItemTipoLancamento(new Short("10"));

					colecaoResumoFaturamento.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoDocumentosEmitidos);
					// fim longo prazo
					// fim Linha 43 e 44

					// Linha 45 e 46
					// pesquisa a coleção de débitos a cobrar com
					// situação normal e grupo de parcelamento igual a
					// financiamentos a cobrar de curto prazo
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// atribui para null o array que vai armazenar o
					// valor de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										ZERO, debitoACobrar.getValorDebito());

						// se o array não estiver nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula o valor de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula o valor de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento de curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.FINANCIAMENTOS_A_COBRAR_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setSequenciaTipoLancamento(new Short("1500"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setSequenciaItemTipoLancamento(new Short("20"));

					// inseri o resumo de faturamento a coleção
					// principal
					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento de longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.FINANCIAMENTOS_A_COBRAR_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setSequenciaTipoLancamento(new Short("1600"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo
									.setSequenciaItemTipoLancamento(new Short("20"));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarCurtoPrazo);
					// fim longo prazo
					// fim Linha 45 e 46

					// Linha 47 e 48
					// pesquisa a coleção de débitos a cobrar com
					// situação igual a normal e grupo de parcelamento
					// igual a financiamentos a cobrar de longo prazo
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// atribui para null o array que vai armazenar o
					// valor de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										ZERO, debitoACobrar.getValorDebito());

						// se o array não estiver nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula o valor de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula o valor de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento para curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.FINANCIAMENTOS_A_COBRAR_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setSequenciaTipoLancamento(new Short("1500"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setSequenciaItemTipoLancamento(new Short("30"));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento para longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.FINANCIAMENTOS_A_COBRAR_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setSequenciaTipoLancamento(new Short("1600"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo
									.setSequenciaItemTipoLancamento(new Short("30"));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoFinanciamentosACobrarLongoPrazo);
					// fim longo prazo
					// fim Linha 47 e 48

					// Linha 49 e 50
					// pesquisa a coleção de débitos a cobrar com
					// situação igual a normal e grupo de parcelamento
					// igual a parcelamentos a cobrar de curto prazo
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// atribui para null o array que vai armazenar o
					// valor de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										ZERO, debitoACobrar.getValorDebito());

						// se o array não for nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula o valor de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula o valor de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento para curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.PARCELAMENTOS_A_COBRAR_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setSequenciaTipoLancamento(new Short("1500"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setSequenciaItemTipoLancamento(new Short("40"));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento para longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.PARCELAMENTOS_A_COBRAR_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setSequenciaTipoLancamento(new Short("1600"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo
									.setSequenciaItemTipoLancamento(new Short("40"));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarCurtoPrazo);
					// fim longo prazo
					// fim Linha 49 e 50

					// Linha 51 e 52
					// pesquisa a coleção de débitos a cobrar com
					// situação igual a normal e grupo de parcelamento
					// igual a parcelamentos a cobrar de longo prazo
					colecaoTemporariaDebitoACobrar = repositorioFaturamento
									.pesquisarDebitoACobrarSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// obtém os valores de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(DebitoACobrar debitoACobrar : colecaoTemporariaDebitoACobrar){

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(debitoACobrar.getNumeroPrestacaoDebito(),
										ZERO, debitoACobrar.getValorDebito());

						// se o array não for nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula os valores de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula os valores de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento de curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.PARCELAMENTOS_A_COBRAR_CURTO_PRAZO);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setSequenciaTipoLancamento(new Short("1500"));
					resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setSequenciaItemTipoLancamento(new Short("50"));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarCurtoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento de longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setLocalidade(localidade);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setCategoria(categoria);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.PARCELAMENTOS_A_COBRAR_LONGO_PRAZO);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setLancamentoItem(lancamentoItem);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setLancamentoItemContabil(null);
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setSequenciaTipoLancamento(new Short("1600"));
					resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo
									.setSequenciaItemTipoLancamento(new Short("50"));

					colecaoResumoFaturamento
									.add(resumoFaturamentoDebitoACobrarLongoPrazoSituacaoNormalGrupoParcelamentoParcelamentosACobrarLongoPrazo);
					// fim longo prazo
					// fim Linha 51 e 52

					// Linha 54 e 55
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO;

					// pesquisa a coleção dos dados de crédito a realizar com
					// situação atual ou anterior igual a normal
					// e origem do crédito igual a descontos concedidos
					colecaoTemporariaCreditoARealizar = repositorioFaturamento.pesquisarCreditoARealizarPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsCreditosOrigem,
									DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.NORMAL);

					// inicializa as somas de curto e longo prazo
					somaValorCurtoPrazo = BigDecimal.ZERO;
					somaValorLongoPrazo = BigDecimal.ZERO;

					// obtém os valores de curto e longo prazo
					valoresCurtoPrazoLongoPrazo = null;

					// laço para acumular os valores de curto e longo
					// prazo
					for(Object[] dadosCreditoACobrar : colecaoTemporariaCreditoARealizar){

						BigDecimal valor = (BigDecimal) dadosCreditoACobrar[0];

						Short numeroPrestacaoCredito = (Short) dadosCreditoACobrar[1];

						// obtém os valores de curto e longo prazo
						valoresCurtoPrazoLongoPrazo = this.obterValorACobrarDeCurtoELongoPrazo(numeroPrestacaoCredito, ZERO, valor);

						// se o array não for nulo
						if(valoresCurtoPrazoLongoPrazo != null){
							// acumula os valores de curto prazo
							somaValorCurtoPrazo = somaValorCurtoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);

							// acumula os valores de longo prazo
							somaValorLongoPrazo = somaValorLongoPrazo.add(valoresCurtoPrazoLongoPrazo[indiceLongoPrazo]);
						}
					}

					// cria os resumos de faturamento para curto e longo
					// prazo
					ResumoFaturamento resumoFaturamentoCreditoARealizarCurtoPrazo = new ResumoFaturamento();
					ResumoFaturamento resumoFaturamentoCreditoARealizarLongoPrazo = new ResumoFaturamento();

					// inicio curto prazo
					// cria o resumo de faturamento de curto prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoCreditoARealizarCurtoPrazo.setLocalidade(localidade);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setCategoria(categoria);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setValorItemFaturamento(somaValorCurtoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_CONCEDIDOS);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setLancamentoItem(lancamentoItem);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setLancamentoItemContabil(null);
					resumoFaturamentoCreditoARealizarCurtoPrazo.setSequenciaTipoLancamento(new Short("1500"));
					resumoFaturamentoCreditoARealizarCurtoPrazo.setSequenciaItemTipoLancamento(new Short("90"));

					colecaoResumoFaturamento.add(resumoFaturamentoCreditoARealizarCurtoPrazo);
					// fim curto prazo

					// inicio longo prazo
					// cria o resumo de faturamento de longo prazo
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();

					resumoFaturamentoCreditoARealizarLongoPrazo.setLocalidade(localidade);
					resumoFaturamentoCreditoARealizarLongoPrazo.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoCreditoARealizarLongoPrazo.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoCreditoARealizarLongoPrazo.setCategoria(categoria);
					resumoFaturamentoCreditoARealizarLongoPrazo.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoCreditoARealizarLongoPrazo.setValorItemFaturamento(somaValorLongoPrazo);
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_LONGO_PRAZO);
					resumoFaturamentoCreditoARealizarLongoPrazo.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_CONCEDIDOS);
					resumoFaturamentoCreditoARealizarLongoPrazo.setLancamentoItem(lancamentoItem);
					resumoFaturamentoCreditoARealizarLongoPrazo.setLancamentoItemContabil(null);
					resumoFaturamentoCreditoARealizarLongoPrazo.setSequenciaTipoLancamento(new Short("1600"));
					resumoFaturamentoCreditoARealizarLongoPrazo.setSequenciaItemTipoLancamento(new Short("90"));

					colecaoResumoFaturamento.add(resumoFaturamentoCreditoARealizarLongoPrazo);
					// fim longo prazo
					// fim Linha 54 e 55

					// Linha 62
					// acumular o valor da categoria do débito para tipo
					// de financiamento igual a serviço e para situação
					// igual a normal
					colecaoTemporaria = repositorioFaturamento.acumularValorCategoriaDebitoTipoFinanciamentoServicoSituacaoNormal(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.FINANCIAMENTOS_COBRADOS);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("1700"));

						// soma o sequência igual 1700 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 62

					// Linha 63
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual doações
					// e situação atual ou normal da conta igual a normal
					colecaoTemporaria = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoDoacoesSituacaoNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DOACOES_COBRADAS_EM_CONTA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("1800"));

						colecaoResumoFaturamento.add(resumoFaturamento);

						// soma o sequência igual 1800 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));
					}
					// fim Linha 63

					// Linha 64
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a parcelamento de
					// água e situação atual ou anteriror da conta igual a
					// normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoAguaSituacaoNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AGUA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1900"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// soma o sequência igual 1900 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 64

					// Linha 65
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a parcelamento de
					// esgoto e situação de igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoEsgotoSituacaoNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1900"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

						// soma o sequência igual 1900 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 65

					// Linha 66
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a parcelamento de
					// serviços e situação de igual a normal
					colecaoTemporaria = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoParcelamentoServicosSituacaoNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("1900"));

						// soma o sequência igual 1900 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção
						// principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 66

					// Linha 67
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a juros de
					// parcelamento e situação de igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoJurosParcelamentoSituacaoNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.JUROS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("1900"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

						// soma o sequência igual 1900 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 67

					// Linha 68
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a arrasto de água
					// e situação de igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoAguaSituacaoNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DEBITOS_ANTERIORES_COBRADOS);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AGUA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2100"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// soma o sequência igual 2100 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 68

					// Linha 69
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a arrasto de
					// esgoto e situação de igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoEsgotoSituacaoNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DEBITOS_ANTERIORES_COBRADOS);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2100"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

						// soma o sequência igual 1900 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 69

					// Linha 70
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a arrasto de
					// serviço e situação de igual a normal
					colecaoTemporaria = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaTipoFinanciamentoArrastoServicoSituacaoNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DEBITOS_ANTERIORES_COBRADOS);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("2100"));

						// soma o sequência igual 2100 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 70

					// Linha 71
					// acumula o valor do IR(imposto de renda) para situação de
					// conta igual a normal e categoria igual a pública
					colecaoTemporaria = repositorioFaturamento.acumularValorIRSituacaoContaNormalCategoriaPublica(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_DEDUZIDOS_EM_CONTA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.IMPOSTO_RENDA);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("2150"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("10"));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);

						// subtrai o sequência igual 2150 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));
					}
					// fim Linha 71

					// Linha 72
					// acumula o valor do COFINS para situação de conta igual a
					// normal e categoria igual a pública
					colecaoTemporaria = repositorioFaturamento.acumularValorCOFINSSituacaoContaNormalCategoriaPublica(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_DEDUZIDOS_EM_CONTA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.COFINS);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("2150"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("20"));

						// subtrai o sequência igual 2150 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 72

					// Linha 73
					// acumula o valor do CSLL para situação de conta igual a
					// normal
					// e categoria igual a pública
					colecaoTemporaria = repositorioFaturamento.acumularValorCSLLSituacaoContaNormalCategoriaPublica(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_DEDUZIDOS_EM_CONTA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.CSLL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("2150"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("30"));

						// subtrai o sequência igual 2150 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 73

					// Linha 74
					// acumula o valor do PIS/PASEP para situação de conta igual
					// a
					// normal e categoria igual a pública
					colecaoTemporaria = repositorioFaturamento.acumularValorPISPASEPSituacaoContaNormalCategoriaPublica(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_DEDUZIDOS_EM_CONTA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.PIS_PASEP);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("2150"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("40"));

						// subtrai o sequência igual 2150 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 74

					// Linha 75
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a contas
					// pagas em duplicidade ou em excesso e situação da
					// conta igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoContasPagasEmDuplicidadeEmExcessoSituacaoContaNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2200"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// subtrai o sequência igual 2200 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 75

					// Linha 76
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// descontos concedidos no parcelamento
					// e situação atual ou anterior da conta igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
									CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_CONCEDIDOS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2200"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

						// subtrai o sequência igual 2200 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 76

					// Linha 77
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// descontos condicionais
					// e situação atual ou anterior da conta igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, CreditoOrigem.DESCONTOS_CONDICIONAIS,
									DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.NORMAL);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2200"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("30"));

						// subtrai o sequência igual 2200 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 77

					// Linha 78
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// descontos incondicionais
					// e situação atual ou anterior da conta igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, CreditoOrigem.DESCONTOS_INCONDICIONAIS,
									DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.NORMAL);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2200"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("40"));

						// subtrai o sequência igual 2200 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 78

					// Linha 79
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// ajustes para zerar a conta
					// e situação atual ou anterior da conta igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA,
									DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.NORMAL);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DEVOLUCAO__VALORES_EM_CONTA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2200"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("50"));

						// subtrai o sequência igual 2200 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 79

					// Linha 80
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a devolução
					// de tarifas de água e situação da conta igual a
					// normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoTarifaAguaSituacaoContaNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AGUA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2300"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// subtrai o sequência igual 2300 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 80

					// Linha 81
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a devolução
					// de tarifas de esgoto e situação da conta igual a
					// normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoTarifaEsgotoSituacaoContaNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2300"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

						// subtrai o sequência igual 2300 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 81

					// Linha 82
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a serviços
					// indiretos pagos indevidamente e situação da conta
					// igual a normal
					colecaoTemporaria = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoServicosIndiretosPagosIndevidamenteSituacaoContaNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// laço para criar tosdos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento que vai ser
						// inserido
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("2300"));

						// subtrai o sequência igual 2300 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 82

					// Linha 83
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a serviços
					// devolução de juros de parcelamento e situação da
					// conta igual a normal
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaOrigemCreditoDevolucaoJurosParcelamentoSituacaoContaNormal(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.JUROS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2300"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

						// subtrai o sequência igual 2300 ao total cobrado nas
						// contas
						resumoFaturamentoTotalCobradoNasContas.setValorItemFaturamento(resumoFaturamentoTotalCobradoNasContas
										.getValorItemFaturamento().subtract(resumoFaturamentoTemporario.getValorItemFaturamento()));

						// adiciona o sequência igual 2200 ao total devolvidos
						// nas contas
						resumoFaturamentoValoresDevolvidosNasContas.setValorItemFaturamento(resumoFaturamentoValoresDevolvidosNasContas
										.getValorItemFaturamento().add(resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 83

					// Linha 86

					// acumula o valor por categoria do imposto deduzido
					// com tipo de imposto igual a IR
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorIRSituacaoCancelada = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.IR,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal valorIRSituacaoCanceladaPorRetificacao = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(anoMesFaturamentoSistemaParametro, idLocalidade,
													idCategoria, ImpostoTipo.IR, DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

					BigDecimal valorIRSituacaoRetificada = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.IR,
									DebitoCreditoSituacao.RETIFICADA, DebitoCreditoSituacao.RETIFICADA);

					BigDecimal diferencaIRSituacaoCanceladaPorRetificacaoeERetificada = valorIRSituacaoCanceladaPorRetificacao
									.subtract(valorIRSituacaoRetificada);

					BigDecimal totalIRSituacaoCanceladaDiferencaPositiva = BigDecimal.ZERO;

					/*
					 * Acumula, quando positiva, a diferença entre o valor do imposto de renda com
					 * tipo de imposto igual a IR e situação atual da
					 * conta igual a cancelada por retificação e o valor do imposto de renda com
					 * situação atual ou anterior da conta igual a
					 * retificada.
					 */
					if(diferencaIRSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						totalIRSituacaoCanceladaDiferencaPositiva = valorIRSituacaoCancelada
										.add(diferencaIRSituacaoCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(totalIRSituacaoCanceladaDiferencaPositiva);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_CANCELADOS_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.IMPOSTO_RENDA);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2800"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 86

					// Linha 90

					BigDecimal totalIRSituacaoCanceladaDiferencaNegativa = BigDecimal.ZERO;

					/*
					 * Acumula, quando negativa, a diferença entre o valor do imposto de renda com
					 * tipo de imposto igual a IR e situação atual da
					 * conta igual a cancelada por retificação e o valor do imposto de renda com
					 * situação atual ou anterior da conta igual a
					 * retificada.
					 */
					if(diferencaIRSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1){
						totalIRSituacaoCanceladaDiferencaNegativa = valorIRSituacaoCancelada
										.add(diferencaIRSituacaoCanceladaPorRetificacaoeERetificada.multiply(menosUm));
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(totalIRSituacaoCanceladaDiferencaNegativa);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_INCLUIDOS_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.IMPOSTO_RENDA);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2900"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 90

					// Linha 87

					// acumula o valor por categoria do imposto deduzido
					// com tipo de imposto igual a COFINS
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCOFINSSituacaoCancelada = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.COFINS,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal valorCOFINSSituacaoCanceladaPorRetificacao = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(anoMesFaturamentoSistemaParametro, idLocalidade,
													idCategoria, ImpostoTipo.COFINS, DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

					BigDecimal valorCOFINSSituacaoRetificada = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(anoMesFaturamentoSistemaParametro, idLocalidade,
													idCategoria, ImpostoTipo.COFINS, DebitoCreditoSituacao.RETIFICADA,
													DebitoCreditoSituacao.RETIFICADA);

					BigDecimal diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada = valorCOFINSSituacaoCanceladaPorRetificacao
									.subtract(valorCOFINSSituacaoRetificada);

					BigDecimal totalCOFINSSituacaoCanceladaDiferencaPositiva = BigDecimal.ZERO;

					/*
					 * Acumula, quando positiva, a diferença entre o valor do imposto de renda com
					 * tipo de imposto igual a COFINS e situação atual da
					 * conta igual a cancelada por retificação e o valor do imposto de renda com
					 * situação atual ou anterior da conta igual a
					 * retificada.
					 */
					if(diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						totalCOFINSSituacaoCanceladaDiferencaPositiva = valorCOFINSSituacaoCancelada
										.add(diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(totalCOFINSSituacaoCanceladaDiferencaPositiva);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_CANCELADOS_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.COFINS);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2800"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 87

					// Linha 91

					BigDecimal totalCOFINSSituacaoCanceladaDiferencaNegativa = BigDecimal.ZERO;

					/*
					 * Acumula, quando negativa, a diferença entre o valor do imposto de renda com
					 * tipo de imposto igual a COFINS e situação atual da
					 * conta igual a cancelada por retificação e o valor do imposto de renda com
					 * situação atual ou anterior da conta igual a
					 * retificada.
					 */
					if(diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1){
						totalCOFINSSituacaoCanceladaDiferencaNegativa = valorCOFINSSituacaoCancelada
										.add(diferencaCOFINSSituacaoCanceladaPorRetificacaoeERetificada.multiply(menosUm));
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(totalCOFINSSituacaoCanceladaDiferencaNegativa);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_INCLUIDOS_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.COFINS);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2900"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					// fim Linha 91

					// Linha 88

					// acumula o valor por categoria do imposto deduzido
					// com tipo de imposto igual a CSLL
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCSLLSituacaoCancelada = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.CSLL,
									DebitoCreditoSituacao.CANCELADA);

					BigDecimal valorCSLLSituacaoCanceladaPorRetificacao = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(anoMesFaturamentoSistemaParametro, idLocalidade,
													idCategoria, ImpostoTipo.CSLL, DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

					BigDecimal valorCSLLSituacaoRetificada = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.CSLL,
									DebitoCreditoSituacao.RETIFICADA, DebitoCreditoSituacao.RETIFICADA);

					BigDecimal diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada = valorCSLLSituacaoCanceladaPorRetificacao
									.subtract(valorCSLLSituacaoRetificada);

					BigDecimal totalCSLLSituacaoCanceladaDiferencaPositiva = BigDecimal.ZERO;

					/*
					 * Acumula, quando positiva, a diferença entre o valor do imposto de renda com
					 * tipo de imposto igual a CSLL e situação atual da
					 * conta igual a cancelada por retificação e o valor do imposto de renda com
					 * situação atual ou anterior da conta igual a
					 * retificada.
					 */
					if(diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						totalCSLLSituacaoCanceladaDiferencaPositiva = valorCSLLSituacaoCancelada
										.add(diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(totalCSLLSituacaoCanceladaDiferencaPositiva);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_CANCELADOS_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.CSLL);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2800"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("30"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 88

					// Linha 92

					BigDecimal totalCSLLSituacaoCanceladaDiferencaNegativa = BigDecimal.ZERO;

					/*
					 * Acumula, quando negativa, a diferença entre o valor do imposto de renda com
					 * tipo de imposto igual a CSLL e situação atual da
					 * conta igual a cancelada por retificação e o valor do imposto de renda com
					 * situação atual ou anterior da conta igual a
					 * retificada.
					 */
					if(diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1){
						totalCSLLSituacaoCanceladaDiferencaNegativa = valorCSLLSituacaoCancelada
										.add(diferencaCSLLSituacaoCanceladaPorRetificacaoeERetificada.multiply(menosUm));
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(totalCSLLSituacaoCanceladaDiferencaNegativa);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_INCLUIDOS_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.CSLL);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2900"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("30"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 92

					// Linha 89

					// acumula o valor por categoria do imposto deduzido
					// com tipo de imposto igual a PIS/PASEP
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorPIS_PASEPSituacaoCancelada = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(anoMesFaturamentoSistemaParametro, idLocalidade,
													idCategoria, ImpostoTipo.PIS_PASEP, DebitoCreditoSituacao.CANCELADA);

					BigDecimal valorPIS_PASEPSituacaoCanceladaPorRetificacao = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(anoMesFaturamentoSistemaParametro, idLocalidade,
													idCategoria, ImpostoTipo.PIS_PASEP, DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

					BigDecimal valorPIS_PASEPSituacaoRetificada = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoAtualConta(anoMesFaturamentoSistemaParametro, idLocalidade,
													idCategoria, ImpostoTipo.PIS_PASEP, DebitoCreditoSituacao.RETIFICADA,
													DebitoCreditoSituacao.RETIFICADA);

					BigDecimal diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada = valorPIS_PASEPSituacaoCanceladaPorRetificacao
									.subtract(valorPIS_PASEPSituacaoRetificada);

					BigDecimal totalPIS_PASEPSituacaoCanceladaDiferencaPositiva = BigDecimal.ZERO;

					/*
					 * Acumula, quando positiva, a diferença entre o valor do imposto de renda com
					 * tipo de imposto igual a PIS/PASEP e situação atual
					 * da conta igual a cancelada por retificação e o valor do imposto de renda com
					 * situação atual ou anterior da conta igual a
					 * retificada.
					 */
					if(diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						totalPIS_PASEPSituacaoCanceladaDiferencaPositiva = valorPIS_PASEPSituacaoCancelada
										.add(diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(totalPIS_PASEPSituacaoCanceladaDiferencaPositiva);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_CANCELADOS_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.PIS_PASEP);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2800"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("40"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 89

					// Linha 93

					BigDecimal totalPIS_PASEPSituacaoCanceladaDiferencaNegativa = BigDecimal.ZERO;

					/*
					 * Acumula, quando negativa, a diferença entre o valor do imposto de renda com
					 * tipo de imposto igual a PIS/PASEP e situação atual
					 * da conta igual a cancelada por retificação e o valor do imposto de renda com
					 * situação atual ou anterior da conta igual a
					 * retificada.
					 */
					if(diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1){
						totalPIS_PASEPSituacaoCanceladaDiferencaNegativa = valorPIS_PASEPSituacaoCancelada
										.add(diferencaPIS_PASEPSituacaoCanceladaPorRetificacaoeERetificada.multiply(menosUm));
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(totalPIS_PASEPSituacaoCanceladaDiferencaNegativa);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_INCLUIDOS_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.PIS_PASEP);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("2900"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("40"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 93

					// Linha 94
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// contas pagas em duplicidade ou excesso
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.CANCELADA);

					// [SB0003 - Obter diferenças de valores de créditos
					// realizados de conta retificada]
					BigDecimal diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada = this
									.obterDiferencaValoresCreditosRealizadosContaRetificada(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem);

					/*
					 * Acumula, quando positiva, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a contas pagas em
					 * duplicidade ou excesso e situação atual da conta igual a cancelada por
					 * retificação e o valor do crédito realizado com situação
					 * atual ou anterior da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso = valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso
										.add(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcesso);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3000"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 94

					// Linha 95
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// descontos concedidos no parcelamento
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.CANCELADA);

					// [SB0003 - Obter diferenças de valores de créditos
					// realizados de conta retificada]
					BigDecimal diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada = this
									.obterDiferencaValoresCreditosRealizadosContaRetificada(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem);

					/*
					 * Acumula, quando positiva, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a descontos concedidos
					 * no parcelamento e situação atual da conta igual a cancelada por retificação e
					 * o valor do crédito realizado com situação atual
					 * ou anterior da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento = valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento
										.add(diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamento);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3000"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 95

					// Linha 96
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONDICIONAIS;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// descontos condicionais
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosCondicionais = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.CANCELADA);

					// [SB0003 - Obter diferenças de valores de créditos
					// realizados de conta retificada]
					BigDecimal diferencaCreditoOrigemDescontosCondicionaisCanceladaPorRetificacaoeERetificada = this
									.obterDiferencaValoresCreditosRealizadosContaRetificada(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem);

					/*
					 * Acumula, quando positiva, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a descontos
					 * condicionais e situação atual da conta igual a cancelada por retificação e o
					 * valor do crédito realizado com situação atual ou
					 * anterior da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemDescontosCondicionaisCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						valorCreditoRealizadoOrigemCreditoDescontosCondicionais = valorCreditoRealizadoOrigemCreditoDescontosCondicionais
										.add(diferencaCreditoOrigemDescontosCondicionaisCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoDescontosCondicionais);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3000"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("30"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 96

					// Linha 97
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// ajustes para zerar a conta
					// com situação atual da conta igual cancelada
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoAjustesParaZerarConta = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.CANCELADA);

					// [SB0003 - Obter diferenças de valores de créditos
					// realizados de conta retificada]
					BigDecimal diferencaCreditoOrigemAjustesParaZerarContaCanceladaPorRetificacaoeERetificada = this
									.obterDiferencaValoresCreditosRealizadosContaRetificada(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem);

					/*
					 * Acumula, quando positiva, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a ajustes para zerar a
					 * conta e situação atual da conta igual a cancelada por retificação e o valor
					 * do crédito realizado com situação atual ou anterior
					 * da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemAjustesParaZerarContaCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						valorCreditoRealizadoOrigemCreditoAjustesParaZerarConta = valorCreditoRealizadoOrigemCreditoDescontosCondicionais
										.add(diferencaCreditoOrigemAjustesParaZerarContaCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoAjustesParaZerarConta);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_CANCELADOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3000"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("40"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 97

					// Linha 98
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// contas pagas em duplicidade ou excesso
					// com situação atual da conta igual incluida
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.INCLUIDA);

					/*
					 * Acumula, quando negativa, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a contas pagas em
					 * duplicidade ou excesso e situação atual da conta igual a cancelada por
					 * retificação e o valor do crédito realizado com situação
					 * atual ou anterior da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1){
						valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida = valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida
										.add(diferencaCreditoOrigemCanceladaPorRetificacaoeERetificada.multiply(menosUm));
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario
									.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoContasPagasEmDuplicidadeExcessoSituacaoIncluida);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3100"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 98

					// Linha 99
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// descontos concedidos no parcelamento
					// com situação atual da conta igual incluída
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.INCLUIDA);

					/*
					 * Acumula, quando negativa, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a descontos concedidos
					 * no parcelamento e situação atual da conta igual a cancelada por retificação e
					 * o valor do crédito realizado com situação atual
					 * ou anterior da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) == -1){
						valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida = valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida
										.add(diferencaCreditoOrigemDescontosConcedidosParcelamentoCanceladaPorRetificacaoeERetificada
														.multiply(menosUm));
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario
									.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoDescontosConcedidosParcelamentoSituacaoIncluida);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3100"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 99

					// Linha 100
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.DESCONTOS_CONDICIONAIS;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// descontos condicionais
					// com situação atual da conta igual incluida
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.INCLUIDA);

					/*
					 * Acumula, quando negativa, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a descontos
					 * condicionais e situação atual da conta igual a cancelada por retificação e o
					 * valor do crédito realizado com situação atual ou
					 * anterior da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemDescontosCondicionaisCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida = valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida
										.add(diferencaCreditoOrigemDescontosCondicionaisCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario
									.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3100"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("30"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 100

					// Linha 101
					idsCreditosOrigem = new Integer[1];
					idsCreditosOrigem[0] = CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA;

					// acumula o valor por categoria do credito realizado
					// com origem do credito igual a
					// ajustes para zerar a conta
					// com situação atual da conta igual incluída
					// e com ano/mês de referência contábil da conta
					// igual ao ano/mês do faturamento de sistema parâmetro.
					BigDecimal valorCreditoRealizadoOrigemCreditoAjustesParaZerarContaSituacaoIncluida = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesFaturamentoSistemaParametro,
													idLocalidade, idCategoria, idsCreditosOrigem, DebitoCreditoSituacao.INCLUIDA);

					/*
					 * Acumula, quando negativa, a diferença entre o valor dos créditos realizados
					 * com origem do crédito igual a ajustes para zerar a
					 * conta e situação atual da conta igual a cancelada por retificação e o valor
					 * do crédito realizado com situação atual ou anterior
					 * da conta igual a retificada.
					 */
					if(diferencaCreditoOrigemAjustesParaZerarContaCanceladaPorRetificacaoeERetificada.compareTo(BigDecimal.ZERO) != -1){
						valorCreditoRealizadoOrigemCreditoAjustesParaZerarContaSituacaoIncluida = valorCreditoRealizadoOrigemCreditoDescontosCondicionaisSituacaoIncluida
										.add(diferencaCreditoOrigemAjustesParaZerarContaCanceladaPorRetificacaoeERetificada);
					}

					resumoFaturamentoTemporario = new ResumoFaturamento();
					resumoFaturamentoTemporario
									.setValorItemFaturamento(valorCreditoRealizadoOrigemCreditoAjustesParaZerarContaSituacaoIncluida);
					resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
					resumoFaturamentoTemporario.setCategoria(categoria);
					resumoFaturamentoTemporario.setLocalidade(localidade);
					resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_CONCEDIDOS_POR_REFATURAMENTO);
					resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
					resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
					resumoFaturamentoTemporario.setLancamentoItemContabil(null);
					resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3100"));
					resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("40"));

					colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					// fim Linha 101

					// Linha 102
					// Acumula valor de água, valor esgoto
					// com situação atual da tabela conta igual a
					// cancelada ou cancelada por retificação
					// e com ano/mês da baixa contábil preenchida.
					idsSituacaoAtual = new Integer[2];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.CANCELADA;
					idsSituacaoAtual[1] = DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO;

					arrayValoresAguaEsgoto = repositorioFaturamento.acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsSituacaoAtual);

					valorAgua = (BigDecimal) arrayValoresAguaEsgoto[indiceValorAgua];

					valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[indiceValorEsgoto];

					if(valorAgua == null){
						valorAgua = BigDecimal.ZERO;
					}

					if(valorEsgoto == null){
						valorEsgoto = BigDecimal.ZERO;
					}

					// acumula o valor por categoria do débito cobrado
					// com situação atual da conta igual a
					// cancelada ou cancelada por retificação
					// e com ano/mês de referência contábil da conta preenchido.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsSituacaoAtual);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										valorAgua));
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										valorEsgoto));
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.EXCLUSAO_INADIMPLENCIA_RECUPERADA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.POR_REFATURAMENTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3300"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}else{
						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorAgua.add(valorEsgoto));
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.EXCLUSAO_INADIMPLENCIA_RECUPERADA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.POR_REFATURAMENTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3300"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					}
					// fim Linha 102

					// Linha 103
					// Acumula valor de água, valor esgoto
					// com situação atual da tabela conta igual a
					// parcelada
					// e com ano/mês da baixa contábil preenchida.
					idsSituacaoAtual = new Integer[1];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.PARCELADA;

					arrayValoresAguaEsgoto = repositorioFaturamento.acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsSituacaoAtual);

					valorAgua = (BigDecimal) arrayValoresAguaEsgoto[indiceValorAgua];

					valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[indiceValorEsgoto];

					if(valorAgua == null){
						valorAgua = BigDecimal.ZERO;
					}

					if(valorEsgoto == null){
						valorEsgoto = BigDecimal.ZERO;
					}

					// acumula o valor por categoria do débito cobrado
					// com situação atual da conta igual a
					// parcelada
					// e com ano/mês de referência contábil da conta preenchido.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsSituacaoAtual);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										valorAgua));
						resumoFaturamentoTemporario.setValorItemFaturamento(resumoFaturamentoTemporario.getValorItemFaturamento().add(
										valorEsgoto));
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.EXCLUSAO_INADIMPLENCIA_RECUPERADA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.POR_PARCELAMENTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3300"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}else{
						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorAgua.add(valorEsgoto));
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.EXCLUSAO_INADIMPLENCIA_RECUPERADA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.POR_PARCELAMENTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3300"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);

					}
					// fim Linha 103

					// Linha 104 e 105
					// acumula os valores de água e esgoto
					// com situação atual da conta com o valor correspondente a
					// débito precrito e com ano/mês da baixa contábil
					// preenchida
					idsSituacaoAtual = new Integer[1];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.PRESCRITA;

					arrayValoresAguaEsgoto = repositorioFaturamento.acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsSituacaoAtual);

					valorAgua = (BigDecimal) arrayValoresAguaEsgoto[indiceValorAgua];

					valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[indiceValorEsgoto];

					if(valorAgua == null){
						valorAgua = BigDecimal.ZERO;
					}

					if(valorEsgoto == null){
						valorEsgoto = BigDecimal.ZERO;
					}

					// se existir valor agua
					if(valorAgua != null && valorAgua != null){
						// monta o resumo de faturamento que vai ser
						// inserido
						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorAgua);
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);

						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AGUA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3400"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// acumula o valor do sequencial 3400 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					// se existir valor esgoto
					if(valorEsgoto != null && valorEsgoto != null){
						// monta o resumo de faturamento que vai ser
						// inserido
						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorEsgoto);
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);

						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3400"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// acumula o valor do sequencial 3400 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 104 e 105

					// Linha 120 e 121
					// acumula os valores de água e esgoto
					// com situação atual da conta com o valor correspondente a
					// débito precrito e com ano/mês da baixa contábil não
					// preenchida
					idsSituacaoAtual = new Integer[1];
					idsSituacaoAtual[0] = DebitoCreditoSituacao.PRESCRITA;

					arrayValoresAguaEsgoto = repositorioFaturamento.acumularValorAguaEsgotoPorSituacaoContaComBaixaContabilNaoPreenchida(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, idsSituacaoAtual);

					valorAgua = (BigDecimal) arrayValoresAguaEsgoto[indiceValorAgua];

					valorEsgoto = (BigDecimal) arrayValoresAguaEsgoto[indiceValorEsgoto];

					if(valorAgua == null){
						valorAgua = BigDecimal.ZERO;
					}

					if(valorEsgoto == null){
						valorEsgoto = BigDecimal.ZERO;
					}

					// se a pesquisa não retornar um objeto nulo
					if(valorAgua != null && valorAgua != null){
						// monta o resumo de faturamento que vai ser
						// inserido
						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorAgua);
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);

						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AGUA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3800"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// acumula o valor do sequencial 3800 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}

					// se a pesquisa não retornar um objeto nulo
					if(valorEsgoto != null && valorEsgoto != null){
						// monta o resumo de faturamento que vai ser
						// inserido
						resumoFaturamentoTemporario = new ResumoFaturamento();
						resumoFaturamentoTemporario.setValorItemFaturamento(valorEsgoto);
						resumoFaturamentoTemporario.setAnoMesReferencia(anoMesFaturamentoSistemaParametro);
						resumoFaturamentoTemporario.setCategoria(categoria);
						resumoFaturamentoTemporario.setLocalidade(localidade);
						resumoFaturamentoTemporario.setUnidadeNegocio(unidadeNegocio);
						resumoFaturamentoTemporario.setGerenciaRegional(gerenciaRegional);

						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3800"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// acumula o valor do sequencial 3800 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 120 e 121

					// Linha 107
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a
					// parcelamento de água e situação atual da conta igual a
					// débito prescrito
					// e com ano/mês de referência contábil da conta preenchido.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													FinanciamentoTipo.PARCELAMENTO_AGUA, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AGUA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3500"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// acumula o valor do sequencial 3500 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 107

					// Linha 108
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a
					// parcelamento de esgoto e situação atual da conta igual a
					// débito prescrito
					// e com ano/mês de referência contábil da conta preenchido.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													FinanciamentoTipo.PARCELAMENTO_ESGOTO, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3500"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

						// acumula o valor do sequencial 3500 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 108

					// Linha 110
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a
					// juros de parcelamento e situação atual da conta igual a
					// débito prescrito
					// e com ano/mês de referência contábil da conta preenchido.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													FinanciamentoTipo.JUROS_PARCELAMENTO, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.JUROS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3500"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

						// acumula o valor do sequencial 3500 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 110

					// Linha 111
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// contas pagas em duplicidade ou excesso
					// e situação atual da conta igual a débito prescrito
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3600"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// subtrai o valor do sequencial 3600 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 111

					// Linha 113
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// descontos condicionais
					// e situação atual da conta igual a débito prescrito
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													CreditoOrigem.DESCONTOS_CONDICIONAIS, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3600"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

						// subtrai o valor do sequencial 3600 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 113

					// Linha 114
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// descontos incondicionais
					// e situação atual da conta igual a débito prescrito
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													CreditoOrigem.DESCONTOS_INCONDICIONAIS, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3600"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento((short) (maxSequencialImpressaoMais10 + 10));

						// subtrai o valor do sequencial 3600 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 114

					// Linha 115
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// ajustes para zerar a conta
					// e situação atual da conta igual a débito prescrito
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3600"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento((short) (maxSequencialImpressaoMais10 + 20));

						// subtrai o valor do sequencial 3600 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 115

					// Linha 116
					// acumula o valor do imposto deduzido
					// para situação atual de conta igual a débito prescrito
					// e tipo de imposto igual a IR
					// e com ano/mês da baixa contábil preenchida
					colecaoTemporaria = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.IR,
									DebitoCreditoSituacao.PRESCRITA);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.IMPOSTO_RENDA);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("3700"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("10"));

						// subtrai o valor do sequencial 3700 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);

					}
					// fim Linha 116

					// Linha 117
					// acumula o valor do imposto deduzido
					// para situação atual de conta igual a débito prescrito
					// e tipo de imposto igual a COFINS
					// e com ano/mês da baixa contábil preenchida
					colecaoTemporaria = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.COFINS,
									DebitoCreditoSituacao.PRESCRITA);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.COFINS);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("3700"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("20"));

						// subtrai o valor do sequencial 3700 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);

					}
					// fim Linha 117

					// Linha 118
					// acumula o valor do imposto deduzido
					// para situação atual de conta igual a débito prescrito
					// e tipo de imposto igual a CSLL
					// e com ano/mês da baixa contábil preenchida
					colecaoTemporaria = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.CSLL,
									DebitoCreditoSituacao.PRESCRITA);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.CSLL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("3700"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("30"));

						// subtrai o valor do sequencial 3700 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);

					}
					// fim Linha 118

					// Linha 119
					// acumula o valor do imposto deduzido
					// para situação atual de conta igual a débito prescrito
					// e tipo de imposto igual a PIS/PASEP
					// e com ano/mês da baixa contábil preenchida
					colecaoTemporaria = repositorioFaturamento.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilPreenchida(
									anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.PIS_PASEP,
									DebitoCreditoSituacao.PRESCRITA);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_JA_EXC_INADIMPLENCIA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.PIS_PASEP);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("3700"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("40"));

						// subtrai o valor do sequencial 3700 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 119

					// Linha 123
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a
					// parcelamento de água e situação atual da conta igual a
					// débito prescrito e com ano/mês de
					// referência da baixa contábil da conta não preenchido.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													FinanciamentoTipo.PARCELAMENTO_AGUA, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AGUA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3900"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// acumula o valor do sequencial 3900 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 123

					// Linha 124
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a
					// parcelamento de esgoto e situação atual da conta igual a
					// débito prescrito e com ano/mês de
					// referência da baixa contábil da conta não preenchido.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													FinanciamentoTipo.PARCELAMENTO_ESGOTO, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3900"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("20"));

						// acumula o valor do sequencial 3900 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 124

					// Linha 126
					// acumula o valor por categoria do débito cobrado
					// com tipo de financiamento igual a
					// juros de parcelamento e situação atual da conta igual a
					// débito prescrito e com ano/mês de
					// referência da baixa contábil da conta não preenchido.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaDebitoCobradoCategoriaPorTipoFinanciamentoComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													FinanciamentoTipo.JUROS_PARCELAMENTO, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.ESGOTO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("3900"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

						// acumula o valor do sequencial 3900 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().add(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 126

					// Linha 127
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// contas pagas em duplicidade ou excesso
					// e situação atual da conta igual a débito prescrito
					// e com ano/mês da baixa contábil não preenchida.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("4000"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(new Short("10"));

						// subtrai o valor do sequencial 4000 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 127

					// Linha 129
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// descontos condicionais
					// e situação atual da conta igual a débito prescrito
					// e com ano/mês da baixa contábil não preenchida.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													CreditoOrigem.DESCONTOS_CONDICIONAIS, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("4000"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento(maxSequencialImpressaoMais10);

						// subtrai o valor do sequencial 4000 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 129

					// Linha 130
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// descontos incondicionais
					// e situação atual da conta igual a débito prescrito
					// e com ano/mês da baixa contábil não preenchida.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													CreditoOrigem.DESCONTOS_INCONDICIONAIS, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(new Short("4000"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento((short) (maxSequencialImpressaoMais10 + 10));

						// subtrai o valor do sequencial 4000 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 130

					// Linha 131
					// acumula o valor por categoria do crédito
					// realizado com origem do crédito igual a
					// ajustes para zerar conta
					// e situação atual da conta igual a débito prescrito
					// e com ano/mês da baixa contábil não preenchida.
					resumoFaturamentoTemporario = repositorioFaturamento
									.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria,
													CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA, DebitoCreditoSituacao.PRESCRITA);

					// se o objeto retornado não for nulo
					if(resumoFaturamentoTemporario != null && resumoFaturamentoTemporario.getValorItemFaturamento() != null){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_CONCEDIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamentoTemporario.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
						resumoFaturamentoTemporario.setLancamentoItem(lancamentoItem);
						resumoFaturamentoTemporario.setLancamentoItemContabil(null);
						resumoFaturamentoTemporario.setSequenciaTipoLancamento(Short.valueOf("4000"));
						resumoFaturamentoTemporario.setSequenciaItemTipoLancamento((short) (maxSequencialImpressaoMais10 + 20));

						// subtrai o valor do sequencial 4000 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(
																		resumoFaturamentoTemporario.getValorItemFaturamento()));

						colecaoResumoFaturamento.add(resumoFaturamentoTemporario);
					}
					// fim Linha 131

					// Linha 132
					// acumula o valor do imposto deduzido
					// para situação atual de conta igual a débito prescrito
					// e tipo de imposto igual a IR
					// e com ano/mês da baixa contábil não preenchida
					colecaoTemporaria = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.IR,
													DebitoCreditoSituacao.PRESCRITA);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.IMPOSTO_RENDA);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("4100"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("10"));

						// subtrai o valor do sequencial 4100 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 132

					// Linha 133
					// acumula o valor do imposto deduzido
					// para situação atual de conta igual a débito prescrito
					// e tipo de imposto igual a COFINS
					// e com ano/mês da baixa contábil não preenchida
					colecaoTemporaria = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.COFINS,
													DebitoCreditoSituacao.PRESCRITA);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.COFINS);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("4100"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("20"));

						// subtrai o valor do sequencial 4100 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 133

					// Linha 134
					// acumula o valor do imposto deduzido
					// para situação atual de conta igual a débito prescrito
					// e tipo de imposto igual a CSSL
					// e com ano/mês da baixa contábil não preenchida
					colecaoTemporaria = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.CSLL,
													DebitoCreditoSituacao.PRESCRITA);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.CSLL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("4100"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("30"));

						// subtrai o valor do sequencial 4100 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);

					}
					// fim Linha 134

					// Linha 135
					// acumula o valor do imposto deduzido
					// para situação atual de conta igual a débito prescrito
					// e tipo de imposto igual a PIS/PASEP
					// e com ano/mês da baixa contábil não preenchida
					colecaoTemporaria = repositorioFaturamento
									.acumularValorImpostoPorTipoImpostoESituacaoContaComBaixaContabilNaoPreenchida(
													anoMesFaturamentoSistemaParametro, idLocalidade, idCategoria, ImpostoTipo.PIS_PASEP,
													DebitoCreditoSituacao.PRESCRITA);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.IMPOSTOS_RETIDOS_SUP_CANCELAMENTO_POR_PRESCRICAO_DEB_NAO_EXC_INADIMPLENCIA);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.PIS_PASEP);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("4100"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("40"));

						// subtrai o valor do sequencial 4100 ao total de
						// débitos cancelados por prescrição
						resumoFaturamentoTotalDebitosCanceladosPrescricao
										.setValorItemFaturamento(resumoFaturamentoTotalDebitosCanceladosPrescricao
														.getValorItemFaturamento().subtract(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 135

					// Linha 13
					idsCreditosOrigem = new Integer[4];
					idsCreditosOrigem[0] = CreditoOrigem.DEVOLUCAO_TARIFA_AGUA;
					idsCreditosOrigem[1] = CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO;
					idsCreditosOrigem[2] = CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE;
					idsCreditosOrigem[3] = CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO;

					/*
					 * acumula o valor do crédito a realizar com situação atual igual a cancelada e
					 * origem de crédito igual a devolução de tarifa de
					 * água, devolução de tarifa de esgoto, serviços indiretos pagos indevidamente
					 * ou devolução de juros de parcelamento.
					 */
					colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, localidade.getId(), idsCreditosOrigem,
									DebitoCreditoSituacao.CANCELADA, categoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_A_REALIZAR_POR_COBRANCA_INDEVIDA_CANCELADO);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("540"));

						// adiciona o valor do sequencial 540 a receita bruta
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 13

					// Linha 14
					// acumula o valor do crédito a realizar com situação atual
					// igual a cancelada e origem de crédito igual a
					// descontos incondicionais.
					colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, localidade.getId(), CreditoOrigem.DESCONTOS_INCONDICIONAIS,
									DebitoCreditoSituacao.CANCELADA, categoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DESCONTOS_INCONDICIONAIS_A_REALIZAR_CANCELADOS);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS_CANCELADOS);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("550"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("0"));

						// adiciona o valor do sequencial 550 a receita bruta
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 14

					// Linha 36
					idsCreditosOrigem = new Integer[4];
					idsCreditosOrigem[0] = CreditoOrigem.DEVOLUCAO_TARIFA_AGUA;
					idsCreditosOrigem[1] = CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO;
					idsCreditosOrigem[2] = CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE;
					idsCreditosOrigem[3] = CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO;

					/*
					 * acumula o valor do crédito a realizar com situação atual ou anterior igual a
					 * normal e origem de crédito igual a devolução de
					 * tarifa de água, devolução de tarifa de esgoto, serviços indiretos pagos
					 * indevidamente ou devolução de juros de parcelamento.
					 */
					colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, localidade.getId(), idsCreditosOrigem, DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.NORMAL, categoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.CREDITOS_A_REALIZAR_POR_COBRANCA_INDEVIDA_INCLUIDOS);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.GRUPO_CONTABIL);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("1030"));

						// adiciona o sequencial 1030 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 36

					// Linha 37
					// acumula o valor do crédito a realizar com situação atual
					// ou anterior
					// igual a normal e origem de crédito igual a
					// descontos incondicionais.
					colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(
									anoMesFaturamentoSistemaParametro, localidade.getId(), CreditoOrigem.DESCONTOS_INCONDICIONAIS,
									DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.NORMAL, categoria);

					// laço para criar todos os resumos de faturamento
					for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
						// cria o resumo de faturamento
						lancamentoTipo = new LancamentoTipo();
						lancamentoItem = new LancamentoItem();
						lancamentoTipo.setId(LancamentoTipo.DESCONTOS_INCONDICIONAIS_INCLUIDOS);
						resumoFaturamento.setLancamentoTipo(lancamentoTipo);
						lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS_INCLUIDOS);
						resumoFaturamento.setLancamentoItem(lancamentoItem);
						resumoFaturamento.setLancamentoItemContabil(null);
						resumoFaturamento.setSequenciaTipoLancamento(new Short("1040"));
						resumoFaturamento.setSequenciaItemTipoLancamento(new Short("0"));

						// adiciona o sequencial 1040 a receita cancelada
						resumoFaturamentoReceitaCancelada.setValorItemFaturamento(resumoFaturamentoReceitaCancelada
										.getValorItemFaturamento().add(resumoFaturamento.getValorItemFaturamento()));

						// inseri o resumo de faturamento a coleção principal
						colecaoResumoFaturamento.add(resumoFaturamento);
					}
					// fim Linha 37

					// acumula o valor do sequencial 560 a receita bruta
					// linha 15
					if(mapAcumularValorPorCategoriaReceitaBruta.containsKey(categoria.getId())){
						resumoFaturamentoReceitaBruta.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento().add(
										mapAcumularValorPorCategoriaReceitaBruta.get(categoria.getId())));
					}

					// Linha 16
					// receita bruta
					resumoFaturamentoReceitaBruta.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoReceitaBruta.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoReceitaBruta.setLocalidade(localidade);
					resumoFaturamentoReceitaBruta.setCategoria(categoria);

					colecaoResumoFaturamento.add(resumoFaturamentoReceitaBruta);
					// fim Linha 16

					// acumula o valor do sequencial 1050 a receita cancelada
					// linha 38
					if(mapAcumularValorPorCategoriaReceitaCancelada.containsKey(categoria.getId())){
						resumoFaturamentoReceitaCancelada
										.setValorItemFaturamento(resumoFaturamentoReceitaCancelada.getValorItemFaturamento().add(
														mapAcumularValorPorCategoriaReceitaCancelada.get(categoria.getId())));
					}

					// Linha 39
					// receita cancelada
					resumoFaturamentoReceitaCancelada.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoReceitaCancelada.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoReceitaCancelada.setLocalidade(localidade);
					resumoFaturamentoReceitaCancelada.setCategoria(categoria);

					colecaoResumoFaturamento.add(resumoFaturamentoReceitaCancelada);
					// fim Linha 39

					// Linha 40
					// receita liquida
					resumoFaturamentoReceitaLiquida.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoReceitaLiquida.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoReceitaLiquida.setLocalidade(localidade);
					resumoFaturamentoReceitaLiquida.setCategoria(categoria);

					// adiciona a (receita bruta - receita cancelada) na receita
					// liquida
					resumoFaturamentoReceitaLiquida.setValorItemFaturamento(resumoFaturamentoReceitaBruta.getValorItemFaturamento()
									.subtract(resumoFaturamentoReceitaCancelada.getValorItemFaturamento()));

					colecaoResumoFaturamento.add(resumoFaturamentoReceitaLiquida);
					// fim Linha 40

					// Linha 84
					// total valores devolvidos nas contas
					resumoFaturamentoValoresDevolvidosNasContas.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoValoresDevolvidosNasContas.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoValoresDevolvidosNasContas.setLocalidade(localidade);
					resumoFaturamentoValoresDevolvidosNasContas.setCategoria(categoria);
					colecaoResumoFaturamento.add(resumoFaturamentoValoresDevolvidosNasContas);
					// fim linha 84

					// Linha 85
					// total cobrado nas contas
					resumoFaturamentoTotalCobradoNasContas.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTotalCobradoNasContas.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTotalCobradoNasContas.setLocalidade(localidade);
					resumoFaturamentoTotalCobradoNasContas.setCategoria(categoria);
					colecaoResumoFaturamento.add(resumoFaturamentoTotalCobradoNasContas);
					// fim Linha 85

					// Linha 136
					// total dos débitos cancelados por prescrição
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setGerenciaRegional(gerenciaRegional);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setUnidadeNegocio(unidadeNegocio);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setLocalidade(localidade);
					resumoFaturamentoTotalDebitosCanceladosPrescricao.setCategoria(categoria);
					colecaoResumoFaturamento.add(resumoFaturamentoTotalDebitosCanceladosPrescricao);
					// fim linha 136

				}// fim CATEGORIA

				// Linha 53
				// acumula o valor do débito com situação igual a normal e tipo
				// de financiamento igual a arrasto de água ou arrasto de esgoto
				// ou arrasto de serviço
				colecaoTemporaria = repositorioFaturamento
								.acumularValorDebitoSituacaoNormalTipoFinanciamentoArrastoAguaArrastoEsgotoArrastoServico(
												anoMesFaturamentoSistemaParametro, localidade.getId());

				// laço para criar todos os resumos de faturamento
				for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
					// cria o resumo de faturamento
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.PARCELAMENTOS_REALIZADOS_CURTO_PRAZO);
					resumoFaturamento.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DEBITOS_ANTERIORES_PARA_RECOBRANCA);
					resumoFaturamento.setLancamentoItem(lancamentoItem);
					resumoFaturamento.setLancamentoItemContabil(null);
					resumoFaturamento.setSequenciaTipoLancamento(new Short("1500"));
					resumoFaturamento.setSequenciaItemTipoLancamento(new Short("80"));

					// inseri o resumo de faturamento a coleção principal
					colecaoResumoFaturamento.add(resumoFaturamento);
				}
				// fim Linha 53

				// Linha 56
				// acumula o valor do crédito a realizar com situação atual ou
				// anterior
				// igual a normal e origem de crédito igual a
				// contas pagas em duplicidade ou em excesso.
				colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(anoMesFaturamentoSistemaParametro,
								localidade.getId(), CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO, DebitoCreditoSituacao.NORMAL,
								DebitoCreditoSituacao.NORMAL);

				// laço para criar todos os resumos de faturamento
				for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
					// cria o resumo de faturamento
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS);
					resumoFaturamento.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO);
					resumoFaturamento.setLancamentoItem(lancamentoItem);
					resumoFaturamento.setLancamentoItemContabil(null);
					resumoFaturamento.setSequenciaTipoLancamento(new Short("1610"));
					resumoFaturamento.setSequenciaItemTipoLancamento(new Short("10"));

					// inseri o resumo de faturamento a coleção principal
					colecaoResumoFaturamento.add(resumoFaturamento);
				}
				// fim Linha 56

				// Linha 57
				// acumula o valor do crédito a realizar com situação atual ou
				// anterior
				// igual a normal e origem de crédito igual a
				// descontos incondicionais.
				colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(anoMesFaturamentoSistemaParametro,
								localidade.getId(), CreditoOrigem.DESCONTOS_INCONDICIONAIS, DebitoCreditoSituacao.NORMAL,
								DebitoCreditoSituacao.NORMAL);

				// laço para criar todos os resumos de faturamento
				for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
					// cria o resumo de faturamento
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS);
					resumoFaturamento.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
					resumoFaturamento.setLancamentoItem(lancamentoItem);
					resumoFaturamento.setLancamentoItemContabil(null);
					resumoFaturamento.setSequenciaTipoLancamento(new Short("1610"));
					resumoFaturamento.setSequenciaItemTipoLancamento(new Short("20"));

					// inseri o resumo de faturamento a coleção principal
					colecaoResumoFaturamento.add(resumoFaturamento);
				}
				// fim Linha 57

				// Linha 58
				// acumula o valor do crédito a realizar com situação atual ou
				// anterior
				// igual a normal e origem de crédito igual a
				// ajustes para zerar a conta.
				colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(anoMesFaturamentoSistemaParametro,
								localidade.getId(), CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA, DebitoCreditoSituacao.NORMAL,
								DebitoCreditoSituacao.NORMAL);

				// laço para criar todos os resumos de faturamento
				for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
					// cria o resumo de faturamento
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_INCLUIDOS);
					resumoFaturamento.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
					resumoFaturamento.setLancamentoItem(lancamentoItem);
					resumoFaturamento.setLancamentoItemContabil(null);
					resumoFaturamento.setSequenciaTipoLancamento(new Short("1610"));
					resumoFaturamento.setSequenciaItemTipoLancamento(new Short("30"));

					// inseri o resumo de faturamento a coleção principal
					colecaoResumoFaturamento.add(resumoFaturamento);
				}
				// fim Linha 58

				// Linha 59
				// acumula o valor do crédito a realizar com situação atual
				// igual a cancelada e origem de crédito igual a
				// contas pagas em duplicidade ou em excesso.
				colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(anoMesFaturamentoSistemaParametro,
								localidade.getId(), CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO, DebitoCreditoSituacao.CANCELADA);

				// laço para criar todos os resumos de faturamento
				for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
					// cria o resumo de faturamento
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_CANCELADOS);
					resumoFaturamento.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.CONTAS_PAGA_EM_DUPLICIDADE_EXCESSO);
					resumoFaturamento.setLancamentoItem(lancamentoItem);
					resumoFaturamento.setLancamentoItemContabil(null);
					resumoFaturamento.setSequenciaTipoLancamento(new Short("1620"));
					resumoFaturamento.setSequenciaItemTipoLancamento(new Short("10"));

					// inseri o resumo de faturamento a coleção principal
					colecaoResumoFaturamento.add(resumoFaturamento);
				}
				// fim Linha 59

				// Linha 60
				// acumula o valor do crédito a realizar com situação atual
				// igual a cancelada e origem de crédito igual a
				// descontos incondicionais.
				colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(anoMesFaturamentoSistemaParametro,
								localidade.getId(), CreditoOrigem.DESCONTOS_INCONDICIONAIS, DebitoCreditoSituacao.CANCELADA);

				// laço para criar todos os resumos de faturamento
				for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
					// cria o resumo de faturamento
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_CANCELADOS);
					resumoFaturamento.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
					resumoFaturamento.setLancamentoItem(lancamentoItem);
					resumoFaturamento.setLancamentoItemContabil(null);
					resumoFaturamento.setSequenciaTipoLancamento(new Short("1620"));
					resumoFaturamento.setSequenciaItemTipoLancamento(new Short("20"));

					// inseri o resumo de faturamento a coleção principal
					colecaoResumoFaturamento.add(resumoFaturamento);
				}
				// fim Linha 60

				// Linha 61
				// acumula o valor do crédito a realizar com situação atual
				// igual a cancelada e origem de crédito igual a
				// ajustes para zerar conta.
				colecaoTemporaria = repositorioFaturamento.acumularValorCreditoARealizarPorOrigemCredito(anoMesFaturamentoSistemaParametro,
								localidade.getId(), CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA, DebitoCreditoSituacao.CANCELADA);

				// laço para criar todos os resumos de faturamento
				for(ResumoFaturamento resumoFaturamento : colecaoTemporaria){
					// cria o resumo de faturamento
					lancamentoTipo = new LancamentoTipo();
					lancamentoItem = new LancamentoItem();
					lancamentoTipo.setId(LancamentoTipo.OUTROS_CREDITOS_A_REALIZAR_CANCELADOS);
					resumoFaturamento.setLancamentoTipo(lancamentoTipo);
					lancamentoItem.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
					resumoFaturamento.setLancamentoItem(lancamentoItem);
					resumoFaturamento.setLancamentoItemContabil(null);
					resumoFaturamento.setSequenciaTipoLancamento(new Short("1620"));
					resumoFaturamento.setSequenciaItemTipoLancamento(new Short("30"));

					// inseri o resumo de faturamento a coleção principal
					colecaoResumoFaturamento.add(resumoFaturamento);
				}
				// fim Linha 61

				// Cria a coleção que vai armazenar os resumos de faturamento
				// com
				// valor maior que zero.
				Collection colecaoResumoFaturamentoInserir = new ArrayList();

				/*
				 * Caso a coleção de resumo de faturamento não esteja vazia verifica se o valor do
				 * item é maior que zero e adiciona o resumo do
				 * faturamento a coleção de inserção.
				 */
				if(colecaoResumoFaturamento != null && !colecaoResumoFaturamento.isEmpty()){
					for(ResumoFaturamento resumoFaturamento : colecaoResumoFaturamento){
						if(resumoFaturamento.getValorItemFaturamento().doubleValue() > 0.0){
							resumoFaturamento.setUltimaAlteracao(new Date());
							colecaoResumoFaturamentoInserir.add(resumoFaturamento);
						}
					}
				}

				/*
				 * Caso a coleção de resumo de faturamento para inserção não esteja vazia manda
				 * inserir todos os resumo de faturamento.
				 */
				if(colecaoResumoFaturamentoInserir != null && !colecaoResumoFaturamentoInserir.isEmpty()){
					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoResumoFaturamentoInserir);
				}
			}// fim LOCALIDADE

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

			// erro no hibernate
		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}
		System.out.println("HORA FIM:" + new Date());
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Metodo responsável pela transferência das contas, débito a cobrar e crédito a realizar para o
	 * histórico, assim com a atualizaçaõ dos imóveis.
	 * 
	 * @author Pedro Alexandre
	 * @date 06/02/2007
	 * @param anoMesFaturamentoSistemaParametro
	 * @param idSetorComercial
	 * @throws ControladorException
	 */
	public void gerarHistoricoParaEncerrarFaturamento(int anoMesFaturamentoSistemaParametro, Integer idSetorComercial,
					int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		// idUnidadeIniciada =
		// getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
		// UnidadeProcessamento.SETOR_COMERCIAL,
		// idSetorComercial);
		try{
			// item 4
			// atualiza os imóveis com situação especial de faturamento
			// finalizada
			repositorioFaturamento.atualizarImoveisSituacaoEspecialFaturamentoFinalizada(anoMesFaturamentoSistemaParametro,
							idSetorComercial);
			// fim item 4

			// item 5
			// atualiza os imóveis com situação especial de cobrança
			// finalizada
			repositorioFaturamento.atualizarImoveisSituacaoEspecialCobrancaFinalizada(anoMesFaturamentoSistemaParametro, idSetorComercial);
			// fim item 5

			boolean flagTerminou = false;
			final int quantidadeRegistros = 1000;
			int numeroIndice = 0;

			while(!flagTerminou){
				// item 6
				// cria os históricos das contas canceladas,assim como seus
				// débitos cobrados e seus créditos realizados
				// pesquisa a coleção de contas canceladas
				List contasCanceladas = (List) repositorioFaturamento.pesquisarContasCanceladasPorMesAnoReferenciaContabil(
								anoMesFaturamentoSistemaParametro, idSetorComercial, numeroIndice, quantidadeRegistros);

				if(contasCanceladas == null || contasCanceladas.size() < quantidadeRegistros){
					flagTerminou = true;
				}

				Iterator iteratorContasCanceladas = contasCanceladas.iterator();
				while(iteratorContasCanceladas.hasNext()){
					Conta conta = (Conta) iteratorContasCanceladas.next();

					this.transferirContasParaHistorico(Collections.singletonList(conta), anoMesFaturamentoSistemaParametro);

					// item 7
					// Indicador atualizado no método transferirContasParaHistorico(...)
					// this.atualizarIndicadorContaNoHistorico(Collections.singletonList(conta));
					// fim item 7

					iteratorContasCanceladas.remove();
					conta = null;
				}

				contasCanceladas = null;
			}

			// criar os histórico dos débitos a cobrar cancelados
			List debitosACobrar = (List) repositorioFaturamento.pesquisarDebitosACobrarCanceladosPorMesAnoReferenciaContabil(
							anoMesFaturamentoSistemaParametro, idSetorComercial);

			int limiteSuperiorDebito;
			int limiteInferiorDebito;
			int limiteMaximoDebito = debitosACobrar.size();
			int quantidadeMaximaPorColecaoDebito = 50;

			for(int i = 0; i < limiteMaximoDebito; i = i + quantidadeMaximaPorColecaoDebito){

				if(limiteMaximoDebito < quantidadeMaximaPorColecaoDebito){
					limiteInferiorDebito = 0;
					limiteSuperiorDebito = limiteMaximoDebito;
				}else{
					limiteInferiorDebito = i;
					limiteSuperiorDebito = i + quantidadeMaximaPorColecaoDebito;

					if(limiteSuperiorDebito > limiteMaximoDebito){
						limiteSuperiorDebito = limiteMaximoDebito;
					}
				}

				List colecaoDebitosTemporaria = new ArrayList();
				colecaoDebitosTemporaria.addAll(debitosACobrar.subList(limiteInferiorDebito, limiteSuperiorDebito));

				if(colecaoDebitosTemporaria != null && !colecaoDebitosTemporaria.isEmpty()){
					this.transferirDebitosACobrarParaHistorico(colecaoDebitosTemporaria, Boolean.FALSE);
					// fim item 8

					// item 9
					this.atualizarIndicadorDebitoACobrarNoHistorico(colecaoDebitosTemporaria);
					// fim item 9
				}

				colecaoDebitosTemporaria = null;
			}
			debitosACobrar = null;

			// item 8

			// item 10
			// cria os histórico dos créditos a realizar cancelados
			List creditosARealizar = (List) repositorioFaturamento.pesquisarCreditosARealizarCanceladosPorMesAnoReferenciaContabil(
							anoMesFaturamentoSistemaParametro, idSetorComercial);

			int limiteSuperiorCredito;
			int limiteInferiorCredito;
			int limiteMaximoCredito = creditosARealizar.size();
			int quantidadeMaximaPorColecaoCredito = 50;

			for(int i = 0; i < limiteMaximoCredito; i = i + quantidadeMaximaPorColecaoCredito){

				if(limiteMaximoCredito < quantidadeMaximaPorColecaoCredito){
					limiteInferiorCredito = 0;
					limiteSuperiorCredito = limiteMaximoCredito;
				}else{
					limiteInferiorCredito = i;
					limiteSuperiorCredito = i + quantidadeMaximaPorColecaoCredito;

					if(limiteSuperiorCredito > limiteMaximoCredito){
						limiteSuperiorCredito = limiteMaximoCredito;
					}
				}

				List colecaoCreditosTemporaria = new ArrayList();
				colecaoCreditosTemporaria.addAll(creditosARealizar.subList(limiteInferiorCredito, limiteSuperiorCredito));

				if(colecaoCreditosTemporaria != null && !colecaoCreditosTemporaria.isEmpty()){
					this.transferirCreditoARealizarParaHistorico(colecaoCreditosTemporaria);
					// fim item 10

					// item 11
					// this.atualizarIndicadorCreditosARealizarNoHistorico(colecaoCreditosTemporaria);
					// fim item 11
				}

				colecaoCreditosTemporaria = null;
			}
			creditosARealizar = null;

			// getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			// getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0167] - Obter Valor a Cobrar de Curto e Longo Prazo Author: Pedro Alexandre Data:
	 * 10/01/2006
	 * 
	 * @param numeroPrestacoes
	 *            nº de prestações
	 * @param numeroPrestacoesCobradas
	 *            nº de prestações cobradas
	 * @param valorCategoria
	 *            valor da categoria
	 * @throws ControladorException
	 */
	public BigDecimal[] obterValorACobrarDeCurtoELongoPrazo(short numeroPrestacoes, short numeroPrestacoesCobradas,
					BigDecimal valorCategoria) throws ControladorException{

		// cria as constantes que vai indicar os índices do array com os valores
		// de curto e longo prazo
		final int indiceCurtoPrazo = 0;
		final int indiceLongoPrazo = 1;

		// variável que vai armazenar o valor da prestação
		BigDecimal valorPrestacao = null;

		// cria o array que vai armazenar os valores de curto e longo prazo
		BigDecimal[] valoresCurtoPrazoLongoPrazo = new BigDecimal[2];

		// se o nº de prestações for menor que o nº de prestações cobradas
		if(numeroPrestacoes < numeroPrestacoesCobradas){
			// retorna nulo
			return null;
		}else{
			// se o nº de prestações for igual a 0(zero)
			if(numeroPrestacoes == 0){
				// retorna nulo
				return null;
			}else{
				// se o nº de prestações menos o nº de prestações cobradas for
				// menor que 13(treze)
				if((numeroPrestacoes - numeroPrestacoesCobradas) < 13){
					// atribui o valor da categoria ao valor de curto prazo
					valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo] = valorCategoria;

					// atribui 0(zero) ao valor de longo prazo
					valoresCurtoPrazoLongoPrazo[indiceLongoPrazo] = new BigDecimal(0.0);
				}else{
					// calcula o valor da prestação
					// valorPrestacao = valorCategoria.divide(new BigDecimal(
					// numeroPrestacoes));

					valorPrestacao = Util.dividirArredondando(valorCategoria, new BigDecimal(numeroPrestacoes));

					// atribui o valor da prestação multiplicado por 12(doze) ao
					// valor de curto prazo
					valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo] = valorPrestacao.multiply(new BigDecimal("12"));

					// atribui o valor da categoria subtraido do valor de curto
					// prazo ao valor de longo prazo
					valoresCurtoPrazoLongoPrazo[indiceLongoPrazo] = valorCategoria.subtract(valoresCurtoPrazoLongoPrazo[indiceCurtoPrazo]);
				}

				if(valoresCurtoPrazoLongoPrazo[0] == null){
					valoresCurtoPrazoLongoPrazo[0] = BigDecimal.ZERO;
				}

				if(valoresCurtoPrazoLongoPrazo[1] == null){
					valoresCurtoPrazoLongoPrazo[1] = BigDecimal.ZERO;
				}

				// retorna um array com os valores de curto e longo prazo
				return valoresCurtoPrazoLongoPrazo;
			}
		}
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0002] - Obter Diferenças de Valores de
	 * Parcelamentos de Conta Retificada Author: Pedro Alexandre
	 * Data: 20/01/2006
	 * 
	 * @param anoMesReferencia
	 *            ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            código da localidade
	 * @param idCategoria
	 *            código da categoria
	 * @param tipoFinaciamento
	 *            tipo de financiamento
	 * @throws ControladorException
	 */
	public BigDecimal obterDiferencaValoresParcelamentoIndiretosContaRetificada(int anoMesReferencia, int idLocalidade, int idCategoria,
					Integer tipoFinaciamento) throws ControladorException{

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal diferenca = BigDecimal.ZERO;
		BigDecimal valorDebitoCobradoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorDebitoCobradoSituacaoRetificado = null;

		try{
			// obtém o valor dos débitos cobrados cancelados do retificação
			valorDebitoCobradoSituacaoCanceladoPorRetificacao = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaCanceladaPorRetificacao(anoMesReferencia,
											idLocalidade, idCategoria, tipoFinaciamento);

			// obtém o valor dos débitos cobrados retificados
			valorDebitoCobradoSituacaoRetificado = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaRetificada(anoMesReferencia, idLocalidade,
											idCategoria, tipoFinaciamento);

			// erro no hibernate
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(valorDebitoCobradoSituacaoCanceladoPorRetificacao != null && valorDebitoCobradoSituacaoRetificado != null){
			diferenca = valorDebitoCobradoSituacaoCanceladoPorRetificacao.subtract(valorDebitoCobradoSituacaoRetificado);
		}
		// retorna a diferença entre os valores dos débitos cobrados
		return diferenca;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0001] - Obter Diferenças de Valores de Serviços
	 * Indiretos de Conta Retificada Author: Pedro Alexandre
	 * Data: 20/01/2006
	 * 
	 * @param anoMesReferencia
	 *            ano e mês de referência do faturamento
	 * @param idLocalidade
	 *            código da localidade
	 * @param idCategoria
	 *            código da categoria
	 * @param tipoFinaciamento
	 *            tipo de financiamento
	 * @throws ControladorException
	 */
	public BigDecimal obterDiferencaValoresServicoIndiretosContaRetificada(int anoMesReferencia, int idLocalidade, int idCategoria,
					Integer tipoFinaciamento, Integer itemContabil) throws ControladorException{

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal diferenca = BigDecimal.ZERO;
		BigDecimal valorDebitoCobradoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorDebitoCobradoSituacaoRetificado = null;

		try{
			// obtém o valor dos débitos cobrados cancelados do retificação
			valorDebitoCobradoSituacaoCanceladoPorRetificacao = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaCanceladaPorRetificacao(anoMesReferencia,
											idLocalidade, idCategoria, tipoFinaciamento, itemContabil);

			// obtém o valor dos débitos cobrados retificados
			valorDebitoCobradoSituacaoRetificado = repositorioFaturamento
							.acumularValorDebitoCobradoPorTipoFinanciamentoSituacaoContaRetificada(anoMesReferencia, idLocalidade,
											idCategoria, tipoFinaciamento, itemContabil);

			if(valorDebitoCobradoSituacaoCanceladoPorRetificacao == null){
				valorDebitoCobradoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
			}
			if(valorDebitoCobradoSituacaoRetificado == null){
				valorDebitoCobradoSituacaoRetificado = BigDecimal.ZERO;
			}
			// erro no hibernate
		}catch(ErroRepositorioException ex){
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(valorDebitoCobradoSituacaoCanceladoPorRetificacao != null){
			diferenca = valorDebitoCobradoSituacaoCanceladoPorRetificacao.subtract(valorDebitoCobradoSituacaoRetificado);
		}
		// retorna a diferença entre os valores dos débitos cobrados
		return diferenca;
	}

	/**
	 * Obtem os Debitos A Cobrar do Imovel
	 * 
	 * @param imovelID
	 *            Id do Imovel
	 * @param debitoCreditoSituacaoAtualID
	 *            ID do Debito Credito Situação
	 * @return Coleção de Debitos a Cobrar
	 */
	public Collection<DebitoACobrar> obterDebitoACobrarImovel(Integer imovelID, Integer debitoCreditoSituacaoAtualID, int anoMesFaturamento)
					throws ControladorException{

		// lista de debitos a cobrar
		Collection<DebitoACobrar> debitosACobrar = null;
		Collection colecaoDebitosACobrar = null;

		// Pesquisa débitos a cobrar
		try{
			colecaoDebitosACobrar = repositorioFaturamento.pesquisarDebitosACobrar(imovelID, debitoCreditoSituacaoAtualID,
							Integer.valueOf(anoMesFaturamento));



		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe débitos a cobrar
		if(colecaoDebitosACobrar != null && !colecaoDebitosACobrar.isEmpty()){

			debitosACobrar = new ArrayList<DebitoACobrar>();

			Iterator iteratorColecaoDebitosACobrar = colecaoDebitosACobrar.iterator();

			while(iteratorColecaoDebitosACobrar.hasNext()){

				DebitoACobrar debitoACobrar = (DebitoACobrar) iteratorColecaoDebitosACobrar.next();

				/*
				 * [UC0113] - Faturar Grupo de Faturamento [FS0007] - Verificar pagamentos para
				 * débitos a cobrar
				 */
				Integer qtdPagamentos = this.getControladorArrecadacao().pesquisarQuantidadePagamentosPorDebitoACobrar(
								debitoACobrar.getId());

				if(qtdPagamentos == null || qtdPagamentos.intValue() == 0){
					debitosACobrar.add(debitoACobrar);
				}

			}
		}

		return debitosACobrar;
	}

	/**
	 * Obtem os Debitos A Cobrar Categoria do Debito a Cobrar
	 * 
	 * @param debitoACobrarID
	 *            Id do Debito A Cobrar
	 * @return Coleção de Debitos a Cobrar Categoria
	 */
	public Collection obterDebitoACobrarCategoria(Integer debitoACobrarID) throws ControladorException{

		Collection debitosACobrarCategoria = null;
		Collection colecaoCreditosACobrarCategoria = null;

		// Pesquisa créditos a cobrar categoria
		try{
			colecaoCreditosACobrarCategoria = repositorioFaturamento.pesquisarDebitosACobrarCategoria(debitoACobrarID);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe débitos a cobrar
		if(colecaoCreditosACobrarCategoria != null && !colecaoCreditosACobrarCategoria.isEmpty()){

			Iterator iteratorColecaoCreditosACobrarCategoria = colecaoCreditosACobrarCategoria.iterator();
			DebitoACobrarCategoria debitoACobrarCategoria = null;
			debitosACobrarCategoria = new ArrayList();
			while(iteratorColecaoCreditosACobrarCategoria.hasNext()){

				Object[] arrayDebitosACobrarCategoria = (Object[]) iteratorColecaoCreditosACobrarCategoria.next();

				debitoACobrarCategoria = new DebitoACobrarCategoria();

				// id da categoria - tem 0
				if(arrayDebitosACobrarCategoria[0] != null){
					Categoria categoria = new Categoria();
					categoria.setId((Integer) arrayDebitosACobrarCategoria[0]);
					debitoACobrarCategoria.setCategoria(categoria);
				}

				// Quantidade de Economias - Item 1
				if(arrayDebitosACobrarCategoria[1] != null){
					debitoACobrarCategoria.setQuantidadeEconomia((Integer) arrayDebitosACobrarCategoria[1]);
				}

				debitosACobrarCategoria.add(debitoACobrarCategoria);
			}

		}
		return debitosACobrarCategoria;
	}

	/**
	 * Obtem os Credito A Realizar do Imovel
	 * 
	 * @param imovelID
	 *            Id do Imovel
	 * @return Coleção de Creditos a Realizar
	 */
	public Collection<CreditoARealizar> obterCreditoARealizarImovel(Integer imovelID) throws ControladorException{

		// lista de credito a realizar
		Collection<CreditoARealizar> creditosARealizar = null;
		Collection<Object> colecaoCreditosARealizar = null;

		// Pesquisa créditos a cobrar
		try{
			colecaoCreditosARealizar = repositorioFaturamento.pesquisarCreditoARealizar(imovelID);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe débitos a realizar
		if(colecaoCreditosARealizar != null && !colecaoCreditosARealizar.isEmpty()){

			creditosARealizar = new ArrayList();

			Iterator iteratorColecaoCreditosARealizar = colecaoCreditosARealizar.iterator();
			CreditoARealizar creditoARealizar = null;
			while(iteratorColecaoCreditosARealizar.hasNext()){

				Object[] arrayCreditosACobrar = (Object[]) iteratorColecaoCreditosARealizar.next();

				creditoARealizar = new CreditoARealizar();
				// id do Credito a Realizar - Item 0
				if(arrayCreditosACobrar[0] != null){
					creditoARealizar.setId((Integer) arrayCreditosACobrar[0]);
				}

				// numero de prestacoes realizadas - item 1
				if(arrayCreditosACobrar[1] != null){
					creditoARealizar.setNumeroPrestacaoRealizada((Short) arrayCreditosACobrar[1]);
				}

				// numero de prestacoes credito - item 2
				if(arrayCreditosACobrar[2] != null){
					creditoARealizar.setNumeroPrestacaoCredito((Short) arrayCreditosACobrar[2]);
				}

				// valor de credito - item 3
				if(arrayCreditosACobrar[3] != null){
					creditoARealizar.setValorCredito((BigDecimal) arrayCreditosACobrar[3]);
				}

				// valor residual mes anterior - item 4
				if(arrayCreditosACobrar[4] != null){
					creditoARealizar.setValorResidualMesAnterior((BigDecimal) arrayCreditosACobrar[4]);
				}

				// credito tipo - item 5
				if(arrayCreditosACobrar[5] != null){
					CreditoTipo creditoTipo = new CreditoTipo();
					creditoTipo.setId((Integer) arrayCreditosACobrar[5]);
					creditoARealizar.setCreditoTipo(creditoTipo);
				}

				// lancamento item contabil - item 6
				if(arrayCreditosACobrar[6] != null){
					LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
					lancamentoItemContabil.setId((Integer) arrayCreditosACobrar[6]);
					creditoARealizar.setLancamentoItemContabil(lancamentoItemContabil);
				}

				// lancamento - item 7
				if(arrayCreditosACobrar[7] != null){
					Localidade localidade = new Localidade();
					localidade.setId((Integer) arrayCreditosACobrar[7]);
					creditoARealizar.setLocalidade(localidade);
				}

				// quadra - item 8
				if(arrayCreditosACobrar[8] != null){
					Quadra quadra = new Quadra();
					quadra.setId((Integer) arrayCreditosACobrar[8]);
					creditoARealizar.setQuadra(quadra);
				}

				// codigo setor comercial - item 9
				if(arrayCreditosACobrar[9] != null){
					creditoARealizar.setCodigoSetorComercial((Integer) arrayCreditosACobrar[9]);
				}

				// numero quadra - item 10
				if(arrayCreditosACobrar[10] != null){
					creditoARealizar.setNumeroQuadra((Integer) arrayCreditosACobrar[10]);
				}

				// numero lote - item 11
				if(arrayCreditosACobrar[11] != null){
					creditoARealizar.setNumeroLote((Short) arrayCreditosACobrar[11]);
				}

				// numero sublote - item 12
				if(arrayCreditosACobrar[12] != null){
					creditoARealizar.setNumeroSubLote((Short) arrayCreditosACobrar[12]);
				}

				// ano mes referencia credito - item 13
				if(arrayCreditosACobrar[13] != null){
					creditoARealizar.setAnoMesReferenciaCredito((Integer) arrayCreditosACobrar[13]);
				}

				// ano mes cobranca credito - item 14
				if(arrayCreditosACobrar[14] != null){
					creditoARealizar.setAnoMesCobrancaCredito((Integer) arrayCreditosACobrar[14]);
				}

				// numero de rpestacao realizadas - item 15
				if(arrayCreditosACobrar[15] != null){
					creditoARealizar.setNumeroPrestacaoRealizada((Short) arrayCreditosACobrar[15]);
				}

				// numero de prestacao credito - item 16
				if(arrayCreditosACobrar[16] != null){
					creditoARealizar.setNumeroPrestacaoCredito((Short) arrayCreditosACobrar[16]);
				}

				// CreditoOrigem - item 17
				if(arrayCreditosACobrar[17] != null){
					CreditoOrigem creditoOrigem = new CreditoOrigem();
					creditoOrigem.setId((Integer) arrayCreditosACobrar[17]);
					creditoARealizar.setCreditoOrigem(creditoOrigem);
				}

				// Ano mês referencia do Parcelamento - item 18
				if(arrayCreditosACobrar[18] != null){
					Parcelamento parcelamento = new Parcelamento();
					parcelamento.setAnoMesReferenciaFaturamento((Integer) arrayCreditosACobrar[18]);
					creditoARealizar.setParcelamento(parcelamento);
				}

				// Situacao Atual - item 19
				if(arrayCreditosACobrar[19] != null){
					DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao();
					debitoCreditoSituacaoAtual.setId((Integer) arrayCreditosACobrar[19]);
					creditoARealizar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);
				}

				// Parcelamento - item 20
				if(arrayCreditosACobrar[20] != null){
					Parcelamento parcelamento = creditoARealizar.getParcelamento();

					if(parcelamento == null){
						parcelamento = new Parcelamento();
					}

					parcelamento.setId((Integer) arrayCreditosACobrar[20]);
					creditoARealizar.setParcelamento(parcelamento);
				}

				creditosARealizar.add(creditoARealizar);
			}
		}
		return creditosARealizar;
	}

	/**
	 * Obtem os Credito A Realizar do Imovel
	 * 
	 * @param imovelID
	 *            Id do Imovel
	 * @return Coleção de Creditos a Realizar
	 *         O método foi reescrito para que o crédito a realizar possa ser transferido para
	 *         histórico.
	 */
	public Collection<CreditoARealizar> obterCreditoARealizarImovelObjeto(Integer imovelID) throws ControladorException{

		// lista de credito a realizar
		Collection colecaoCreditosARealizar = null;

		// Pesquisa créditos a cobrar
		try{
			colecaoCreditosARealizar = repositorioFaturamento.pesquisarCreditoARealizarObjeto(imovelID);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return colecaoCreditosARealizar;
	}

	private Collection<CreditoARealizar> verificarCreditosARealizarDeParcelamento(Collection<CreditoARealizar> colecaoCredito,
					Integer anoMesFaturamento) throws ControladorException{

		Collection<CreditoARealizar> retorno = new ArrayList<CreditoARealizar>();

		if(!Util.isVazioOrNulo(colecaoCredito)){

			// retorno.addAll(colecaoCredito);

			for(CreditoARealizar creditoARealizar : colecaoCredito){

				if(creditoARealizar.getDebitoCreditoSituacaoAtual() != null
								&& creditoARealizar.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.NORMAL)){

					if(creditoARealizar.getParcelamento() != null
									&& creditoARealizar.getNumeroPrestacaoRealizada().intValue() == 0
									&& creditoARealizar.getParcelamento().getAnoMesReferenciaFaturamento().intValue() > anoMesFaturamento
													.intValue()){
						
						// retorno.remove(creditoARealizar);
					}else{
						retorno.add(creditoARealizar);
					}
				}
			}
		}

		return retorno;
	}

	/**
	 * Obtem os Creditos Realizado Categoria
	 * 
	 * @param creditoARealizarID
	 *            Id do Creditoa A Realizar
	 * @return Coleção de Creditos Realizados Categoria
	 */
	public Collection obterCreditoRealizarCategoria(Integer creditoARealizarID) throws ControladorException{

		Collection creditosARealizarCategoria = null;
		Collection colecaoCreditoRealizarCategoria = null;

		// Pesquisa credito realizar categoria
		try{
			colecaoCreditoRealizarCategoria = repositorioFaturamento.pesquisarCreditoRealizarCategoria(creditoARealizarID);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe credito realizar categoria
		if(colecaoCreditoRealizarCategoria != null && !colecaoCreditoRealizarCategoria.isEmpty()){

			Iterator iteratorColecaoCreditoRealizarCategoria = colecaoCreditoRealizarCategoria.iterator();

			CreditoARealizarCategoria creditoARealizarCategoria = null;
			creditosARealizarCategoria = new ArrayList();
			while(iteratorColecaoCreditoRealizarCategoria.hasNext()){

				Object[] arrayDebitosACobrarCategoria = (Object[]) iteratorColecaoCreditoRealizarCategoria.next();

				creditoARealizarCategoria = new CreditoARealizarCategoria();

				// id da categoria - item 0
				if(arrayDebitosACobrarCategoria[0] != null){

					Categoria categoria = new Categoria();
					categoria.setId((Integer) arrayDebitosACobrarCategoria[0]);
					creditoARealizarCategoria.setCategoria(categoria);

				}
				// id do Credito A Realizar - item 1
				if(arrayDebitosACobrarCategoria[1] != null){
					CreditoARealizar creditoARealizar = new CreditoARealizar();
					creditoARealizar.setId((Integer) arrayDebitosACobrarCategoria[1]);

					creditoARealizarCategoria.setCreditoARealizar(creditoARealizar);
				}

				// quantidade de economia - item 2
				if(arrayDebitosACobrarCategoria[2] != null){
					creditoARealizarCategoria.setQuantidadeEconomia((Integer) arrayDebitosACobrarCategoria[2]);

				}

				creditosARealizarCategoria.add(creditoARealizarCategoria);
			}
		}

		return creditosARealizarCategoria;
	}

	/**
	 * [UC0113] - Gerar Faturamento Grupo Author: Rafael Santos Data: 16/02/2006
	 * Dados do Imovel para o caso de Uso
	 * 
	 * @author eduardo henrique
	 * @date 22/11/2008 Alteração no método para popular Coleção ClienteImovel corretamente.
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	private Collection pesquisarImovelGrupoFaturamento(Integer idRota, Collection<Integer> colecaoMatriculasComandoSimulacaoFaturamento)
					throws ControladorException{

		Collection colecaoImoveis = null;
		Collection imoveis;

		// Pesquisa imovel
		try{
			imoveis = repositorioFaturamento.pesquisarImovelGrupoFaturamento(idRota, colecaoMatriculasComandoSimulacaoFaturamento);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se imovel
		if(imoveis != null && !imoveis.isEmpty()){

			Iterator iteratorImoveis = imoveis.iterator();

			colecaoImoveis = new ArrayList();

			Imovel imovel = null;

			while(iteratorImoveis.hasNext()){

				Object[] arrayImovel = (Object[]) iteratorImoveis.next();

				imovel = new Imovel();

				// ligacaoAguaSituacao.id
				if(arrayImovel[0] != null){
					LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
					ligacaoAguaSituacao.setId((Integer) arrayImovel[0]);
					ligacaoAguaSituacao.setIndicadorFaturamentoSituacao((Short) arrayImovel[20]);
					imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);

					LigacaoAgua ligacaoAgua = new LigacaoAgua();
					if(arrayImovel[29] != null) ligacaoAgua.setId((Integer) arrayImovel[29]);
					if(arrayImovel[30] != null) ligacaoAgua.setNumeroConsumoMinimoAgua((Integer) arrayImovel[30]);
					if(arrayImovel[27] != null){
						HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoLigacaoAgua = (HidrometroInstalacaoHistorico) arrayImovel[25];
						MedicaoTipo medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId((Integer) arrayImovel[27]);
						hidrometroInstalacaoHistoricoLigacaoAgua.setMedicaoTipo(medicaoTipo);
						ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoLigacaoAgua);
					}
					if(arrayImovel[35] != null){
						ligacaoAgua.setDataCorte((Date) arrayImovel[35]);
					}
					imovel.setLigacaoAgua(ligacaoAgua);
				}

				// ligacaoEsgotoSituacao.id
				if(arrayImovel[1] != null){
					LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
					ligacaoEsgotoSituacao.setId((Integer) arrayImovel[1]);
					ligacaoEsgotoSituacao.setIndicadorFaturamentoSituacao((Short) arrayImovel[21]);
					imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

					if(arrayImovel[31] != null || arrayImovel[33] != null){
						LigacaoEsgoto ligacaoEsgoto = new LigacaoEsgoto();
						if(arrayImovel[31] != null){
							ligacaoEsgoto.setConsumoMinimo((Integer) arrayImovel[31]);
						}
						// perc. de Coleta
						if(arrayImovel[33] != null){
							ligacaoEsgoto.setPercentualAguaConsumidaColetada((BigDecimal) arrayImovel[33]);
						}

						if(arrayImovel[36] != null){
							LigacaoEsgotoPerfil ligacaoEsgotoPerfil = new LigacaoEsgotoPerfil();
							ligacaoEsgotoPerfil.setPercentualEsgotoConsumidaColetada((BigDecimal) arrayImovel[36]);
							ligacaoEsgoto.setLigacaoEsgotoPerfil(ligacaoEsgotoPerfil);
						}

						imovel.setLigacaoEsgoto(ligacaoEsgoto);
					}
				}

				if(arrayImovel[28] != null){
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel = (HidrometroInstalacaoHistorico) arrayImovel[26];
					MedicaoTipo medicaoTipo = new MedicaoTipo();
					medicaoTipo.setId((Integer) arrayImovel[28]);
					hidrometroInstalacaoHistoricoImovel.setMedicaoTipo(medicaoTipo);
					imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoImovel);
				}

				// consumoTarifa.id
				if(arrayImovel[2] != null){
					ConsumoTarifa consumoTarifa = new ConsumoTarifa();
					consumoTarifa.setId((Integer) arrayImovel[2]);
					imovel.setConsumoTarifa(consumoTarifa);
				}

				// localidade.id
				Localidade localidade = null;
				if(arrayImovel[3] != null){
					localidade = new Localidade();
					localidade.setId((Integer) arrayImovel[3]);
					imovel.setLocalidade(localidade);

				}

				Quadra quadra = null;

				// quadra.id
				if(arrayImovel[4] != null){
					quadra = new Quadra();
					quadra.setId((Integer) arrayImovel[4]);
					imovel.setQuadra(quadra);
				}

				// quadra.numeroQuadra
				if(arrayImovel[5] != null){
					quadra.setNumeroQuadra(((Integer) arrayImovel[5]).intValue());
					imovel.setQuadra(quadra);
				}

				// imovel.lote
				if(arrayImovel[6] != null){
					imovel.setLote(((Short) arrayImovel[6]).shortValue());
				}

				// setorComercial.codigo
				SetorComercial setorComercial = null;
				if(arrayImovel[7] != null){
					setorComercial = new SetorComercial();
					setorComercial.setCodigo(((Integer) arrayImovel[7]).intValue());
					imovel.setSetorComercial(setorComercial);

				}

				// faturamentoTipo.id
				if(arrayImovel[8] != null){
					FaturamentoTipo faturamentoTipo = new FaturamentoTipo();
					faturamentoTipo.setId((Integer) arrayImovel[8]);
					imovel.setFaturamentoTipo(faturamentoTipo);
				}

				// imovelPerfil.id
				if(arrayImovel[9] != null){
					ImovelPerfil imovelPerfil = new ImovelPerfil();
					imovelPerfil.setId((Integer) arrayImovel[9]);
					imovel.setImovelPerfil(imovelPerfil);
				}

				// imovel.indicadorDebitoConta
				if(arrayImovel[10] != null){
					imovel.setIndicadorDebitoConta(((Short) arrayImovel[10]).shortValue());
				}

				// imovel.indicadorConta
				if(arrayImovel[11] != null){
					ImovelContaEnvio imovelContaEnvio = new ImovelContaEnvio();
					imovelContaEnvio.setId((Integer) arrayImovel[11]);
					imovel.setImovelContaEnvio(imovelContaEnvio);
				}

				// imovel.subLote
				if(arrayImovel[12] != null){
					imovel.setSubLote(((Short) arrayImovel[12]).shortValue());
				}

				// imovel.indicadorEmissaoExtratoFaturamento
				if(arrayImovel[13] != null){
					imovel.setIndicadorEmissaoExtratoFaturamento((Short) arrayImovel[13]);
				}

				// imovel.localidade.gerenciaRegional
				if(arrayImovel[14] != null){
					if(localidade == null){
						localidade = new Localidade();
					}
					GerenciaRegional gerenciaRegional = new GerenciaRegional();
					gerenciaRegional.setId((Integer) arrayImovel[14]);
					localidade.setGerenciaRegional(gerenciaRegional);
					imovel.setLocalidade(localidade);
				}

				// imovel.setorComercial
				if(arrayImovel[15] != null){
					if(setorComercial == null){
						setorComercial = new SetorComercial();
					}
					setorComercial.setId((Integer) arrayImovel[15]);
					imovel.setSetorComercial(setorComercial);
				}

				// imovel.quadra.rota
				if(arrayImovel[16] != null){
					if(quadra == null){
						quadra = new Quadra();
					}
					Rota rota = new Rota();
					rota.setId((Integer) arrayImovel[16]);

					if(arrayImovel[34] != null){
						rota.setCodigo((Short) arrayImovel[34]);
					}

					Leiturista leiturista = new Leiturista();
					if(arrayImovel[22] != null){
						leiturista.setId((Integer) arrayImovel[22]);
					}
					rota.setLeiturista(leiturista);
					if(arrayImovel[23] != null){
						Empresa empresa = new Empresa();
						empresa.setId((Integer) arrayImovel[23]);
						rota.setEmpresa(empresa);
					}

					AreaTipo areaTipo = new AreaTipo();
					if(arrayImovel[24] != null){
						areaTipo.setDescricao((String) arrayImovel[24]);
						quadra.setAreaTipo(areaTipo);
					}
					quadra.setRota(rota);
					imovel.setQuadra(quadra);
					imovel.setRota(rota);

				}

				if(arrayImovel[17] != null){

					HashSet clientes = new HashSet();

					EsferaPoder esferaPoder = new EsferaPoder();
					esferaPoder.setId((Integer) arrayImovel[17]);
					ClienteTipo clienteTipo = new ClienteTipo();
					clienteTipo.setEsferaPoder(esferaPoder);
					Cliente cliente = new Cliente();
					cliente.setClienteTipo(clienteTipo);

					ClienteImovel clienteImovel = new ClienteImovel();
					clienteImovel.setCliente(cliente);
					clienteImovel.setImovel(imovel);

					clientes.add(clienteImovel);
					imovel.setClienteImoveis(clientes);

				}

				// id do imovel
				if(arrayImovel[18] != null){
					imovel.setId((Integer) arrayImovel[18]);
				}

				// dia vencimento
				if(arrayImovel[19] != null){
					imovel.setDiaVencimento((Short) arrayImovel[19]);
				}

				if(arrayImovel[0] != null && arrayImovel[20] != null){
					imovel.getLigacaoAguaSituacao().setIndicadorFaturamentoSituacao((Short) arrayImovel[20]);
				}
				if(arrayImovel[1] != null && arrayImovel[21] != null){
					imovel.getLigacaoEsgotoSituacao().setIndicadorFaturamentoSituacao((Short) arrayImovel[21]);
				}

				if(arrayImovel[32] != null){
					imovel.setQuantidadeEconomias((Short) arrayImovel[32]);
				}

				// imovel.localidade.unidadeNegocio
				if(arrayImovel[37] != null){
					if(localidade == null){
						localidade = new Localidade();
					}
					UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId((Integer) arrayImovel[37]);
					localidade.setUnidadeNegocio(unidadeNegocio);
					imovel.setLocalidade(localidade);
				}

				if(arrayImovel[38] != null){
					ConsumoTarifa consumoTarifa = new ConsumoTarifa();
					consumoTarifa.setId((Integer) arrayImovel[38]);
					imovel.setConsumoTarifaTemporaria(consumoTarifa);
				}

				if(arrayImovel[39] != null){
					imovel.setDataValidadeTarifaTemporaria((Date) arrayImovel[39]);
				}

				// adiciona o imovel
				if(!colecaoImoveis.contains(imovel)){
					colecaoImoveis.add(imovel);
				}
			}
		}

		return colecaoImoveis;
	}

	public void removerFaturamentoCronograma(String[] ids, String pacoteNomeObjeto, Usuario usuarioLogado) throws ControladorException{

		// se for selecionado alguma unidade executora pelo usuário
		if(ids != null && ids.length != 0){

			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
			Collection colecaoFaturamentoAtividadeCronograma = null;
			// remove todas as unidade executoras informadas
			for(int i = 0; i < ids.length; i++){
				// atribui a variável "id" o código da unidade executora para
				// remoção
				int id = Integer.parseInt(ids[i]);

				filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID, ids[i]));
				filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroNaoNulo(
								FiltroFaturamentoAtividadeCronograma.DATA_REALIZADA));

				colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
								FaturamentoAtividadeCronograma.class.getName());
				if(!colecaoFaturamentoAtividadeCronograma.isEmpty()){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.faturamento.exclusao_nao_permitida");
				}else{
					// chama o metódo de remover do util
					try{
						repositorioFaturamento.removerFaturamentoGrupoAtividades(id, usuarioLogado);
					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						e.printStackTrace();
					}

					/*
					 * FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal = new
					 * FaturamentoGrupoCronogramaMensal();
					 * faturamentoGrupoCronogramaMensal.setFaturamentoAtividadeCronogramas(Collections
					 * .EMPTY_SET);
					 * faturamentoGrupoCronogramaMensal.setId(id);
					 * getControladorUtil().remover(faturamentoGrupoCronogramaMensal);
					 */
				}
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Pesquisa a conta do imóvel com a referência informada pelo usuário
	 * [FS0012] - Verificar existência da conta
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param idImovel
	 * @param referenciaConta
	 * @return
	 * @throws ControladorException
	 */
	public Conta pesquisarContaDigitada(String idImovel, String referenciaConta) throws ControladorException{

		// Variável que vai armazenar a conta pesquisada
		Conta contaDigitada = null;
		Object[] dadosConta = null;

		// Formata a referência da conta informada para o formato (AAAAMM) sem a
		// barra
		String anoMesConta = Util.formatarMesAnoParaAnoMesSemBarra(referenciaConta);

		// Cria o filtro de conta e seta todos os parâmetros para pesquisar a
		// conta do imóvel
		// Pesquisa imovel
		try{
			dadosConta = repositorioFaturamento.pesquisarContaDigitada(idImovel, anoMesConta);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(dadosConta != null){

			contaDigitada = new Conta();

			// Id da Conta
			if(dadosConta[0] != null){
				contaDigitada.setId((Integer) dadosConta[0]);
			}

			// Referência
			if(dadosConta[1] != null){
				contaDigitada.setReferencia((Integer) dadosConta[1]);
			}

			// Valor da Água
			if(dadosConta[2] != null){
				contaDigitada.setValorAgua((BigDecimal) dadosConta[2]);
			}

			// Valor de Esgoto
			if(dadosConta[3] != null){
				contaDigitada.setValorEsgoto((BigDecimal) dadosConta[3]);
			}

			// Débitos
			if(dadosConta[4] != null){
				contaDigitada.setDebitos((BigDecimal) dadosConta[4]);
			}

			// Valor Créditos
			if(dadosConta[5] != null){
				contaDigitada.setValorCreditos((BigDecimal) dadosConta[5]);
			}

			// Valor Imposto
			if(dadosConta[6] != null){
				contaDigitada.setValorImposto((BigDecimal) dadosConta[6]);
			}

		}

		// FiltroConta filtroConta = new FiltroConta();
		// filtroConta.adicionarParametro(new ParametroSimples(
		// FiltroConta.IMOVEL_ID, idImovel));
		// filtroConta.adicionarParametro(new ParametroSimples(
		// FiltroConta.REFERENCIA, anoMesConta));
		// filtroConta.adicionarParametro(new ParametroSimples(
		// FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL,
		// DebitoCreditoSituacao.NORMAL, ParametroSimples.CONECTOR_OR, 3));
		// filtroConta
		// .adicionarParametro(new ParametroSimples(
		// FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL,
		// DebitoCreditoSituacao.RETIFICADA,
		// ParametroSimples.CONECTOR_OR));
		// filtroConta.adicionarParametro(new ParametroSimples(
		// FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL,
		// DebitoCreditoSituacao.INCLUIDA));
		// Collection colecaoContas =
		// getControladorUtil().pesquisar(filtroConta,
		// Conta.class.getName());
		//
		// // Caso exista a conta para a referência informada cadastrada no
		// sistema
		// // Retorna para o usuário a conta retornada pela pesquisa
		// // Caso contrário retorna um objeto nulo
		// if (colecaoContas != null && !colecaoContas.isEmpty()) {
		// contaDigitada = (Conta) Util.retonarObjetoDeColecao(colecaoContas);
		// }

		// Retorna a conta encontrada ou nulo se não existir a conta
		return contaDigitada;
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Pesquisa o tipo de débito informado pelo usuário
	 * [FS0020] - Verificar existência do tipo de débito
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * @param idTipoDebitoDigitado
	 * @return
	 * @throws ControladorException
	 */
	public DebitoTipo pesquisarTipoDebitoDigitado(Integer idTipoDebitoDigitado) throws ControladorException{

		// Cria a variável que vai armazenar o tipo de débito pesquisado
		DebitoTipo tipoDebitoDigitado = null;

		// Pesquisa o tipo de débito informado pelo usuário no sistema
		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idTipoDebitoDigitado));
		Collection<DebitoTipo> colecaoDebitoTipo = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

		// Caso exista o tipo de débito no sistema
		// Retorna para o usuário o tipo de débito retornado pela pesquisa
		// Caso contrário retorna um objeto nulo
		if(colecaoDebitoTipo != null && !colecaoDebitoTipo.isEmpty()){
			tipoDebitoDigitado = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
		}

		// Retorna o cliente encontrado ou nulo se não existir
		return tipoDebitoDigitado;
	}

	/**
	 * Permite executar as atividades do faturamento previamente comandadas
	 * [UC0111] Executar Atividade do Faturamento
	 * Lista as atividades de faturamento do cronograma que foram comandadas
	 * obterAtividadesFaturamentoCronogramaComandada
	 * 
	 * @author Raphael Rossiter, Roberta Costa
	 * @date 29/03/2006, 29/04/20004
	 * @return Collection<ExecutarAtividadeFaturamentoHelper>
	 * @throws ControladorException
	 */
	public Collection<ExecutarAtividadeFaturamentoHelper> obterAtividadesFaturamentoCronogramaComandada(Integer numeroPagina)
					throws ControladorException{

		Collection retorno = new ArrayList();

		/*
		 * 2. Para cada grupo de faturamento (a partir da tabela FATURAMENTO_GRUPO) o sistema
		 * seleciona o cronograma de faturamento do mês corrente (a
		 * partir da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com FTCM_AMREFERENCIA =
		 * FTGR_AMREFERENCIA e FTGR_ID = FTGR_ID da tabela
		 * FATURAMENTO_GRUPO)
		 */
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo(FiltroFaturamentoGrupo.ID);
		filtroFaturamentoGrupo.setConsultaSemLimites(true);

		Collection colecaoFaturamentoGrupo = getControladorUtil().pesquisar(filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

		// [FS0001] - Verificar existência de dados
		/*
		 * if (colecaoFaturamentoGrupo == null || colecaoFaturamentoGrupo.isEmpty()) { throw new
		 * ControladorException(
		 * "atencao.pesquisa.nenhum_registro_tabela", null, "FATURAMENTO_GRUPO"); }
		 */
		// [FS0002] - Verificar existência do cronograma
		if(colecaoFaturamentoGrupo == null || colecaoFaturamentoGrupo.isEmpty()){
			throw new ControladorException("atencao.pesquisa.cronograma_mensal_grupo_mes_corrente_inexistente", null);
		}

		// Faz a consulta das Atividades
		Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada = null;
		boolean existeAtividadeFaturamentoComandada = false;
		ExecutarAtividadeFaturamentoHelper executarAtividadeFaturamentoHelper = null;
		FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = null;
		try{
			colecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada = repositorioFaturamento
							.pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizada(numeroPagina);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		// A partir da consulta montar a coleção de Atividades não realizadas
		if(colecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada != null){
			existeAtividadeFaturamentoComandada = true;
			Iterator iteratorColecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada = colecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada
							.iterator();

			while(iteratorColecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada.hasNext()){

				faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) iteratorColecaoFaturamentoAtividadeCronogramaComandadaNaoRealizada
								.next();

				executarAtividadeFaturamentoHelper = new ExecutarAtividadeFaturamentoHelper();

				executarAtividadeFaturamentoHelper.setIdFaturamentoAtividadeCronograma(faturamentoAtividadeCronograma.getId());
				executarAtividadeFaturamentoHelper.setIdGrupoFaturamento(faturamentoAtividadeCronograma
								.getFaturamentoGrupoCronogramaMensal().getFaturamentoGrupo().getId());
				executarAtividadeFaturamentoHelper.setAnoMesFaturamento(faturamentoAtividadeCronograma
								.getFaturamentoGrupoCronogramaMensal().getFaturamentoGrupo().getAnoMesReferencia());
				executarAtividadeFaturamentoHelper.setDescricaoAtividade(faturamentoAtividadeCronograma.getFaturamentoAtividade()
								.getDescricao());
				executarAtividadeFaturamentoHelper.setDataPrevista(faturamentoAtividadeCronograma.getDataPrevista());
				executarAtividadeFaturamentoHelper.setComando(faturamentoAtividadeCronograma.getComando());

				retorno.add(executarAtividadeFaturamentoHelper);
			}
		}

		// [FS0003] - Verificar existência de atividade comandada
		if(!existeAtividadeFaturamentoComandada){
			throw new ControladorException("atencao.pesquisa.cronograma_atividade_mes_corrente_inexistente", null,
							String.valueOf(faturamentoAtividadeCronograma.getFaturamentoGrupoCronogramaMensal().getFaturamentoGrupo()
											.getId()));
		}

		return retorno;
	}

	/**
	 * Retorna o count do resultado da pesquisa de Faturamento Atividade Cronograma
	 * pesquisarFaturamentoAtividadeCronogramaCount
	 * 
	 * @author Roberta Costa
	 * @date 05/05/2006
	 * @param FaturamentoGrupoCronogramaMensal
	 *            faturamentoGrupoCronogramaMensal
	 * @param Integer
	 *            numeroPagina
	 * @return Integer retorno
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizadaCount() throws ControladorException{

		Integer totalRegistros = null;
		try{
			totalRegistros = repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaComandadaNaoRealizadaCount();
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return totalRegistros;
	}

	/**
	 * Permite executar as atividades do faturamento previamente comandadas
	 * [UC0111] Executar Atividade do Faturamento
	 * Executa as atividade do Faturamento
	 * executarAtividadeFaturamento
	 * 
	 * @author Roberta Costa
	 * @date 03/05/20006
	 * @param idsFaturamentoAtividadeCronograma
	 * @throws ControladorException
	 */
	public void executarAtividadeFaturamento(String[] idsFaturamentoAtividadeCronograma) throws ControladorException{

		// Caso alguma atividade de faturamento tenha sido maracada
		if(idsFaturamentoAtividadeCronograma != null){

			// SistemaParametro sistemaParametros = null;
			/* sistemaParametros = */getControladorUtil().pesquisarParametrosDoSistema();

			// 6. Para cada atividade de faturamento do cronograma selecionada
			for(int i = 0; idsFaturamentoAtividadeCronograma.length > i; i++){
				// 6.1. Seleciona as rotas que foram comandadas para esta
				// atividade ( a partir
				// da tabela FATURAMENTO_ATIV_CRON_ROTA com FTAC_ID = FTAC_ID da
				// tabela
				// FATURAMENTO_ATIVIDADE_CRONOGRAMA
				FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();

				filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(
								FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_ID,
								idsFaturamentoAtividadeCronograma[i]));
				Collection<FaturamentoAtivCronRota> colecaoFaturamentoAtivCronRota = getControladorUtil().pesquisar(
								filtroFaturamentoAtivCronRota, FaturamentoAtivCronRota.class.getName());

				Collection<Rota> colecaoRotasFaturamento = new ArrayList();
				if(colecaoFaturamentoAtivCronRota != null && !colecaoFaturamentoAtivCronRota.equals("")){
					Iterator faturamentoAtivCronRotaValores = colecaoFaturamentoAtivCronRota.iterator();

					while(faturamentoAtivCronRotaValores.hasNext()){
						FaturamentoAtivCronRota faturamentoAtivCronRota = (FaturamentoAtivCronRota) faturamentoAtivCronRotaValores.next();
						FiltroRota filtroRota = new FiltroRota();

						filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.ID_ROTA, faturamentoAtivCronRota.getRota().getId()));

						Collection<Rota> colecaoRotas = getControladorUtil().pesquisar(filtroRota, Rota.class.getName());
						if(colecaoRotas != null && !colecaoRotas.equals("")){
							Rota rota = (Rota) Util.retonarObjetoDeColecao(colecaoRotas);
							colecaoRotasFaturamento.add(rota);
						}
					}
				}

				FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

				filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtividadeCronograma.ID,
								idsFaturamentoAtividadeCronograma[i]));

				Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(
								filtroFaturamentoAtividadeCronograma, FaturamentoAtividadeCronograma.class.getName());

				if(colecaoFaturamentoAtividadeCronograma != null && !colecaoFaturamentoAtividadeCronograma.isEmpty()){
					Iterator faturamentoAtividadeCronogramaValores = colecaoFaturamentoAtividadeCronograma.iterator();

					while(faturamentoAtividadeCronogramaValores.hasNext()){

						FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) faturamentoAtividadeCronogramaValores
										.next();

						// Faturamento Grupo Cronograma Mensal
						FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

						filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoGrupoCronogramaMensal.ID, faturamentoAtividadeCronograma
														.getFaturamentoGrupoCronogramaMensal().getId()));

						Collection<FaturamentoGrupoCronogramaMensal> colecaoFaturamentoGrupoCronogramaMensal = getControladorUtil()
										.pesquisar(filtroFaturamentoGrupoCronogramaMensal, FaturamentoGrupoCronogramaMensal.class.getName());

						FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal = null;

						if(colecaoFaturamentoGrupoCronogramaMensal != null && !colecaoFaturamentoGrupoCronogramaMensal.isEmpty()){
							faturamentoGrupoCronogramaMensal = (FaturamentoGrupoCronogramaMensal) Util
											.retonarObjetoDeColecao(colecaoFaturamentoGrupoCronogramaMensal);
						}

						// 6.2. Chama o Caso de Uso responsável pela atividade e
						// passando os parâmetros de
						// acordo com as atividades abaixo, passando a lista de
						// rotas selecionadas, ano/mês
						// do faturamento corrente (FTCM_AMREFERENCIA), grupo de
						// faturamento e atividade a
						// ser executada
						if(faturamentoAtividadeCronograma.getFaturamentoAtividade().getId()
										.equals(FaturamentoAtividade.GERAR_ARQUIVO_LEITURA)){
							// [UC0083] Gerar Dados para Leitura

							FuncionalidadeIniciada funcionalidade = new FuncionalidadeIniciada();
							funcionalidade.setId(FaturamentoAtividade.GERAR_ARQUIVO_LEITURA);

							if(SistemaParametro.INDICADOR_EMPRESA_ADA.equals(Short.valueOf(ConstantesConfig.getIdEmpresa()))){
								getControladorMicromedicao().gerarDadosPorLeituraConvencionalPdf(colecaoRotasFaturamento,
												faturamentoGrupoCronogramaMensal.getAnoMesReferencia(),
												faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getId(), funcionalidade,
												faturamentoAtividadeCronograma.getDataPrevista(), null);
							}else{
								getControladorMicromedicao().gerarDadosPorLeituraConvencional(colecaoRotasFaturamento,
												faturamentoGrupoCronogramaMensal.getAnoMesReferencia(),
												faturamentoGrupoCronogramaMensal.getFaturamentoGrupo().getId(), funcionalidade,
												faturamentoAtividadeCronograma.getDataPrevista(), null);
							}

							// Atualiza a Atividade do Faturamento
							atualizarDataHoraRealizacaoAtividadeFaturamento(faturamentoAtividadeCronograma,
											faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
											FaturamentoAtividade.GERAR_ARQUIVO_LEITURA);
						}else if(faturamentoAtividadeCronograma.getFaturamentoAtividade().getId()
										.equals(FaturamentoAtividade.CONSISTIR_LEITURAS_E_CALCULAR_CONSUMOS)){
							// [UC0101] Consistir Leituras e Calcular Consumos
							// getControladorMicromedicao()
							// .consistirLeiturasCalcularConsumos(
							// faturamentoGrupoCronogramaMensal
							// .getFaturamentoGrupo(),
							// sistemaParametros,
							// colecaoRotasFaturamento);

							// [UC0103] Efetuar Rateio de Consumo
							// getControladorMicromedicao()
							// .efetuarRateioDeConsumo(
							// colecaoRotasFaturamento,
							// faturamentoGrupoCronogramaMensal
							// .getAnoMesReferencia());
							// Atualiza a Atividade do Faturamento
							atualizarDataHoraRealizacaoAtividadeFaturamento(faturamentoAtividadeCronograma,
											faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
											FaturamentoAtividade.CONSISTIR_LEITURAS_E_CALCULAR_CONSUMOS);
						}else if(faturamentoAtividadeCronograma.getFaturamentoAtividade().getId()
										.equals(FaturamentoAtividade.SIMULAR_FATURAMENTO)){
							// [UC0113] Faturar Grupo de Faturamento
							// faturarGrupoFaturamento(colecaoRotasFaturamento,
							// faturamentoGrupoCronogramaMensal
							// .getFaturamentoGrupo(),
							// sistemaParametros,
							// faturamentoAtividadeCronograma
							// .getFaturamentoAtividade().getId());

							// Atualiza a Atividade do Faturamento
							atualizarDataHoraRealizacaoAtividadeFaturamento(faturamentoAtividadeCronograma,
											faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(),
											FaturamentoAtividade.SIMULAR_FATURAMENTO);
						}else if(faturamentoAtividadeCronograma.getFaturamentoAtividade().getId()
										.equals(FaturamentoAtividade.FATURAR_GRUPO)){
							// [UC0101] Consistir Leituras e Calcular Consumos
							// getControladorMicromedicao()
							// .consistirLeiturasCalcularConsumos(
							// faturamentoGrupoCronogramaMensal
							// .getFaturamentoGrupo(),
							// sistemaParametros,
							// colecaoRotasFaturamento);

							// [UC0103] Efetuar Rateio de Consumo
							// getControladorMicromedicao()
							// .efetuarRateioDeConsumo(
							// colecaoRotasFaturamento,
							// faturamentoGrupoCronogramaMensal
							// .getAnoMesReferencia());

							// [UC0209] Gerar Taxa de Entrega em Conta em outro
							// Endereço
							// gerarTaxaEntregaDeContaEmOutroEndereco(
							// colecaoRotasFaturamento,
							// faturamentoGrupoCronogramaMensal
							// .getAnoMesReferencia());

							// [UC0302] Gerar Débitos a Cobrar de Acréscimos por
							// Impontualidade
							// gerarDebitosACobrarDeAcrescimosPorImpontualidade(
							// colecaoRotasFaturamento, 1, // indicador de
							// // geração de
							// // multa com
							// // valor 1-SIM
							// 2, // indicador de geração dos juros com
							// // valor 2-NÃO
							// 2); // indicador de geração da atualização
							// monetária com valor 2-NÃO

							// [UC0113] Faturar Grupo de Faturamento
							// faturarGrupoFaturamento(colecaoRotasFaturamento,
							// faturamentoGrupoCronogramaMensal
							// .getFaturamentoGrupo(),
							// sistemaParametros,
							// faturamentoAtividadeCronograma
							// .getFaturamentoAtividade().getId());

							// Atualiza a Atividade do Faturamento
							atualizarDataHoraRealizacaoAtividadeFaturamento(faturamentoAtividadeCronograma,
											faturamentoGrupoCronogramaMensal.getFaturamentoGrupo(), FaturamentoAtividade.FATURAR_GRUPO);
						}
					}
				}
			}
		}
	}

	/**
	 * Permite executar as atividades do faturamento previamente comandadas
	 * [UC0111] Executar Atividade do Faturamento
	 * Atualiza Data Hora da Realização da Atividade de Faturamento
	 * atualizarDataHoraRealizacaoAtividadeFaturamento
	 * 
	 * @author Roberta Costa
	 * @date 03/05/20006
	 * @param faturamentoAtividadeCronograma
	 * @param faturamentoAtividadeId
	 * @throws ControladorException
	 */
	public void atualizarDataHoraRealizacaoAtividadeFaturamento(FaturamentoAtividadeCronograma faturamentoAtividadeCronograma,
					FaturamentoGrupo faturamentoGrupo, Integer faturamentoAtividadeId) throws ControladorException{

		faturamentoAtividadeCronograma.setDataRealizacao(new Date());
		faturamentoAtividadeCronograma.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(faturamentoAtividadeCronograma);

		if(faturamentoAtividadeId.equals(FaturamentoAtividade.FATURAR_GRUPO)){
			// Util.obterMes()
			faturamentoGrupo.setAnoMesReferencia(faturamentoGrupo.getAnoMesReferencia());
			faturamentoGrupo.setUltimaAlteracao(new Date());

			getControladorUtil().atualizar(Util.somaUmMesAnoMesReferencia(faturamentoGrupo.getAnoMesReferencia()));
		}
	}

	/**
	 * Inserir Debito A Cobrar para o Imovel
	 * [UC0183] - Inserir Debito a Cobrar
	 * 
	 * @author Rafael Santos
	 * @date 01/04/2006
	 * @param idDebitoTipo
	 * @return
	 */
	public DebitoTipo pesquisarDebitoTipo(String idDebitoTipo) throws ControladorException{

		DebitoTipo debitoTipo = null;
		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO, ConstantesSistema.SIM));
		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));

		Collection colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());
		if(colecaoDebitoTipo != null && !colecaoDebitoTipo.isEmpty()){
			debitoTipo = (DebitoTipo) colecaoDebitoTipo.iterator().next();
		}

		return debitoTipo;
	}

	/**
	 * O sistema seleciona os grupos de faturamento que possuem cronograma para o mês corrente *
	 * [UC0144] Inserir Comando Atividade de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 03/03/2006
	 * @return Collection<FaturamentoGrupo>
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoGrupo> pesquisarFaturamentoGrupoComCronogramaMensalParaMesCorrente() throws ControladorException{

		Collection<FaturamentoGrupo> retorno = new ArrayList();

		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo(FiltroFaturamentoGrupo.DESCRICAO);

		filtroFaturamentoGrupo.setConsultaSemLimites(true);

		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.INDICADOR_USO,
						ConstantesSistema.INDICADOR_USO_ATIVO));
		filtroFaturamentoGrupo.setCampoOrderBy(FiltroFaturamentoGrupo.ID);

		Collection colecaoFaturamentoGrupo = this.getControladorUtil().pesquisar(filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

		// [FS0001] - Verificar existência de dados
		if(colecaoFaturamentoGrupo == null || colecaoFaturamentoGrupo.isEmpty()){
			throw new ControladorException("atencao.pesquisa.nenhum_registro_tabela", null, "FATURAMENTO_GRUPO");
		}

		Iterator iteratorColecaoFaturamentoGrupo = colecaoFaturamentoGrupo.iterator();
		FaturamentoGrupo faturamentoGrupo = null;
		Integer idFaturamentoGrupoCronogramaMensal;

		while(iteratorColecaoFaturamentoGrupo.hasNext()){

			faturamentoGrupo = (FaturamentoGrupo) iteratorColecaoFaturamentoGrupo.next();
			idFaturamentoGrupoCronogramaMensal = null;

			try{

				idFaturamentoGrupoCronogramaMensal = repositorioFaturamento.pesquisarFaturamentoGrupoCronogramaMensal(
								faturamentoGrupo.getId(), faturamentoGrupo.getAnoMesReferencia());

			}catch(ErroRepositorioException ex){
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}

			if(idFaturamentoGrupoCronogramaMensal != null){
				retorno.add(faturamentoGrupo);
			}

		}

		// [FS0003] - Verificar seleção de pelo menos um grupo de faturamento
		if(retorno == null || retorno.isEmpty()){
			throw new ControladorException("atencao.pesquisa.nenhum.faturamento_grupo_com_cronograma_mensal");
		}

		return retorno;
	}

	/**
	 * Este caso de uso inicia um processo para o mecanismo batch
	 * [UC0111] - Iniciar Processo
	 * Este subfluxo tem o papel de iniciar um processo de faturamento comandado, neste método é
	 * feita uma busca para obter as atividades comandadas e
	 * não realizadas
	 * [SB0001] - Iniciar Processo de Faturamento Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 14/08/2006
	 * @return
	 * @throws ControladorException
	 */

	public Collection<FaturamentoAtividadeCronograma> pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadas(int numeroPagina)
					throws ControladorException{

		Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramas = null;
		try{
			colecaoFaturamentoAtividadeCronogramas = this.repositorioFaturamento
							.pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadas(numeroPagina);

			FiltroFaturamentoSimulacaoComando filtroFaturamentoSimulacaoComando = new FiltroFaturamentoSimulacaoComando();
			filtroFaturamentoSimulacaoComando.adicionarParametro(new ParametroNulo(FiltroFaturamentoSimulacaoComando.DATA_REALIZACAO));

			Collection<FaturamentoSimulacaoComando> colecaoFaturamentoSimulacaoComando = this.getControladorUtil().pesquisar(
							filtroFaturamentoSimulacaoComando, FaturamentoSimulacaoComando.class.getName());

			// [FS0003] - Verificar existência de Atividade Comandada
			if((colecaoFaturamentoAtividadeCronogramas == null || colecaoFaturamentoAtividadeCronogramas.isEmpty())
							&& (colecaoFaturamentoSimulacaoComando == null || colecaoFaturamentoSimulacaoComando.isEmpty())){
				throw new ControladorException("atencao.pesquisa.atividade_comandada_inexistente");
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoFaturamentoAtividadeCronogramas;
	}

	/**
	 * Este caso de uso inicia um processo para o mecanismo batch
	 * [UC0111] - Iniciar Processo
	 * Este subfluxo tem o papel de iniciar um processo de faturamento comandado, neste método é
	 * feita uma busca para obter as atividades comandadas e
	 * não realizadas
	 * [SB0001] - Iniciar Processo de Faturamento Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 14/08/2006
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadasCount() throws ControladorException{

		int retorno = 0;
		try{
			retorno = this.repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaComandadasNaoRealizadasCount();

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * O sistema seleciona os grupos de faturamento que possuem cronograma para o mês corrente
	 * [UC0104] Manter Comando Atividade de Faturamento
	 * Caso esteja no atualizar pode escolher todos os grupos exceto o selecionado para atualização
	 * pesquisarFaturamentoGrupoComCronogramaMensalParaMesCorrenteSemGupoSelecionado
	 * 
	 * @author Roberta Costa
	 * @date 20/07/2006
	 * @return Collection<FaturamentoGrupo>
	 * @throws ControladorException
	 */
	public Collection<FaturamentoGrupo> pesquisarFaturamentoGrupoComCronogramaMensalParaMesCorrenteSemGupoSelecionado(
					Integer grupoSelecionado) throws ControladorException{

		Collection<FaturamentoGrupo> retorno = new ArrayList();

		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo(FiltroFaturamentoGrupo.DESCRICAO);

		filtroFaturamentoGrupo.setConsultaSemLimites(true);

		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroFaturamentoGrupo.ID, grupoSelecionado));

		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.INDICADOR_USO,
						ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection colecaoFaturamentoGrupo = this.getControladorUtil().pesquisar(filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());

		// [FS0001] - Verificar existência de dados
		if(colecaoFaturamentoGrupo == null || colecaoFaturamentoGrupo.isEmpty()){
			throw new ControladorException("atencao.pesquisa.nenhum_registro_tabela", null, "FATURAMENTO_GRUPO");
		}

		Iterator iteratorColecaoFaturamentoGrupo = colecaoFaturamentoGrupo.iterator();
		FaturamentoGrupo faturamentoGrupo = null;
		Integer idFaturamentoGrupoCronogramaMensal;

		while(iteratorColecaoFaturamentoGrupo.hasNext()){

			faturamentoGrupo = (FaturamentoGrupo) iteratorColecaoFaturamentoGrupo.next();
			idFaturamentoGrupoCronogramaMensal = null;

			try{

				idFaturamentoGrupoCronogramaMensal = repositorioFaturamento.pesquisarFaturamentoGrupoCronogramaMensal(
								faturamentoGrupo.getId(), faturamentoGrupo.getAnoMesReferencia());

			}catch(ErroRepositorioException ex){
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}

			if(idFaturamentoGrupoCronogramaMensal != null){
				retorno.add(faturamentoGrupo);
			}

		}

		// [FS0003] - Verificar seleção de pelo menos um grupo de faturamento
		if(retorno == null || retorno.isEmpty()){
			throw new ControladorException("atencao.pesquisa.nenhum.faturamento_grupo_com_cronograma_mensal");
		}

		return retorno;
	}

	/**
	 * [UC0209] Gerar Taxa de Entrega de Conta em Outro Endereço
	 * <Breve descrição sobre o subfluxo>
	 * 
	 * @author Pedro Alexandre
	 * @date 12/02/2007
	 * @param idRota
	 * @return
	 * @throws ControladorException
	 */
	public Collection obterImoveisPorRotasComContaEntregaEmOutroEndereco(Integer idRota) throws ControladorException{

		Collection colecaoImoveis = null;
		try{

			colecaoImoveis = this.repositorioFaturamento.obterImoveisPorRotasComContaEntregaEmOutroEndereco(idRota);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		Collection imoveis = null;

		if(colecaoImoveis != null && !colecaoImoveis.isEmpty()){

			Iterator iteratorColecaoImoveis = colecaoImoveis.iterator();
			imoveis = new ArrayList();

			Imovel imovel = null;
			// GerarRelacaoDebitosHelper gerarRelacaoDebitosHelper = null;
			while(iteratorColecaoImoveis.hasNext()){

				Object[] dados = (Object[]) iteratorColecaoImoveis.next();

				imovel = new Imovel();

				// Id Localidade
				if(dados[0] != null){ // 0
					Localidade localidade = new Localidade();
					localidade.setId(((Integer) dados[0]));
					imovel.setLocalidade(localidade);
				}

				// Código Setor Comercial
				if(dados[1] != null){ // 1
					SetorComercial setorComercial = new SetorComercial();
					setorComercial.setCodigo(((Integer) dados[1]));
					imovel.setSetorComercial(setorComercial);
				}

				Quadra quadra = new Quadra();
				// Número da Quadra
				if(dados[2] != null){ // 2
					quadra.setNumeroQuadra(((Integer) dados[2]));
				}

				// Id Quadra
				if(dados[3] != null){ // 3
					quadra.setId(((Integer) dados[3]));
				}

				imovel.setQuadra(quadra);

				// Id Imóvel
				if(dados[4] != null){ // 4
					imovel.setId(((Integer) dados[4]));
				}

				// Lote
				if(dados[5] != null){ // 5
					imovel.setLote(((Short) dados[5]));
				}

				// Sublote
				if(dados[6] != null){ // 6
					imovel.setSubLote(((Short) dados[6]));
				}

				// Id Imóvel Perfil
				if(dados[7] != null){ // 7
					ImovelPerfil imovelPerfil = new ImovelPerfil();
					imovelPerfil.setId(((Integer) dados[7]));
					imovel.setImovelPerfil(imovelPerfil);
				}

				imoveis.add(imovel);

			}
		}

		return imoveis;
	}

	public DebitoTipo getDebitoTipoHql(Integer idDebitoTipo) throws ControladorException{

		Object[] dados = null;

		try{

			dados = this.repositorioFaturamento.getDebitoTipoHql(idDebitoTipo);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		DebitoTipo debitoTipo = null;

		if(dados != null){

			debitoTipo = new DebitoTipo();

			// Id Débito Tipo
			if(dados[0] != null){ // 0
				debitoTipo.setId(((Integer) dados[0]));
			}

			// Id Financiamento Tipo
			if(dados[1] != null){ // 1
				FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
				financiamentoTipo.setId(((Integer) dados[1]));
				debitoTipo.setFinanciamentoTipo(financiamentoTipo);
			}

			// Id Lançamento Item Contábil
			if(dados[2] != null){ // 2
				LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
				lancamentoItemContabil.setId(((Integer) dados[2]));
				debitoTipo.setLancamentoItemContabil(lancamentoItemContabil);
			}

			if(dados[3] != null){
				BigDecimal valorPadrao = (BigDecimal) dados[3];
				debitoTipo.setValorPadrao(valorPadrao);
			}
		}

		return debitoTipo;
	}

	/**
	 * Este caso de uso permite gerar taxa de entrega de conta em outro endereço para os imóveis das
	 * quadras pertencentes às rotas de um grupo de
	 * faturamento.
	 * [UC0209] Gerar Taxa de Entrega de Conta em Outro Endereço
	 * 
	 * @author Thiago Toscano, Pedro Alexandre
	 * @date 03/04/2006, 30/08/2006
	 * @author eduardo henrique
	 * @date 05/11/2008 alteração no método para Contabilização do Debito a Cobrar gerado.
	 * @param rotas
	 * @throws ControladorException
	 */
	public void gerarTaxaEntregaDeContaEmOutroEndereco(Collection<Rota> rotas, Integer anoMesFaturamento, int idFuncionalidadeIniciada)
					throws ControladorException{

		int idUnidadeIniciada = 0;
		try{
			// -------------------------
			//
			// Registrar o início do processamento da Unidade de
			// Processamento
			// do Batch
			//
			// -------------------------
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
							((Rota) Util.retonarObjetoDeColecao(rotas)).getId());

			Short paramFormaCalculoTaxaEntregaOutroEndereco = new Short(
							(String) ParametroFaturamento.P_FORMA_CALCULO_TAXA_ENTREGA_CONTA_OUTRO_ENDERECO.executar(this));

			if(paramFormaCalculoTaxaEntregaOutroEndereco != null){

				if(!paramFormaCalculoTaxaEntregaOutroEndereco.equals(ConstantesSistema.INDICADOR_PERCENTUAL_VALOR_REF_TAXA)
								&& !paramFormaCalculoTaxaEntregaOutroEndereco.equals(ConstantesSistema.INDICADOR_VALOR_REF_TAXA)){

					throw new ControladorException("atencao.parametro_valor_invalido", null,
									paramFormaCalculoTaxaEntregaOutroEndereco.toString());
				}

			}else{
				throw new ControladorException("atencao.calculo_taxa_entrega_sem_parametrizacao");
			}

			// Recupera o tipo de débito referente a despesa postal
			DebitoTipo debitoTipo = this.getDebitoTipoHql(DebitoTipo.DESPESA_POSTAL);
			if(debitoTipo == null){
				// throw new ControladorException("atencao.tipo_debito_DESPESA_POSTAL_inexistente");
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
				return;
			}

			BigDecimal valorReferenciaTaxa = BigDecimal.ZERO;
			BigDecimal paramPercentualTarifaEntregaOutroEndereco = BigDecimal.ZERO;
			BigDecimal valorMinimaTarifaNormal = null;
			BigDecimal valorMinimaTarifaSocial = null;

			if(paramFormaCalculoTaxaEntregaOutroEndereco.equals(ConstantesSistema.INDICADOR_PERCENTUAL_VALOR_REF_TAXA)){
				paramPercentualTarifaEntregaOutroEndereco = new BigDecimal(
								(String) ParametroFaturamento.P_PERCENTUAL_TARIFA_TAXA_ENTREGA_CONTA_OUTRO_ENDERECO.executar(this));

				// Obtém o valor da Tarifa Normal
				valorMinimaTarifaNormal = this.repositorioFaturamento.obterValorTarifa(ConsumoTarifa.CONSUMO_NORMAL);

				// Caso o valor da tarifa normal esteja nulo seta o valor para zero
				if(valorMinimaTarifaNormal == null){
					valorMinimaTarifaNormal = BigDecimal.ZERO;
				}

				// Obtém o valor da Tarifa Social
				valorMinimaTarifaSocial = this.repositorioFaturamento.obterValorTarifa(ConsumoTarifa.CONSUMO_SOCIAL);

				// Caso o valor da tarifa social esteja nulo seta o valor para zero
				if(valorMinimaTarifaSocial == null){
					valorMinimaTarifaSocial = BigDecimal.ZERO;
				}

			}else{
				paramPercentualTarifaEntregaOutroEndereco = new BigDecimal("100");
				if(debitoTipo.getValorPadrao() != null){
					valorReferenciaTaxa = debitoTipo.getValorPadrao();
				}

			}

			// Cria o iterator para rotas
			Iterator colecaoRotaIterator = rotas.iterator();

			// Recupera os parametros do sistema
			SistemaParametro sistema = getControladorUtil().pesquisarParametrosDoSistema();

			// Instância a forma de cobrança para cobrança em conta
			CobrancaForma cobrancaForma = new CobrancaForma();
			cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

			// Instância a situação do débito para normal
			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

			// Cria as coleções que iram armazenar os débitos a cobrar e os
			// débitos a cobrar por categoria
			Collection colecaoDebitosACobrarAtualizar = new ArrayList();
			Collection colecaoDebitosACobrarInserir = new ArrayList();
			Collection colecaoDebitosACobrarCategoriasInserir = new ArrayList();

			// Laço para recuperar todos os imóveis de cada rota informada
			while(colecaoRotaIterator.hasNext()){

				// Recupera a rota
				Rota rota = (Rota) colecaoRotaIterator.next();

				// Obtém os imóveis pertencentes a rota
				Collection colecaoImoveis = this.obterImoveisPorRotasComContaEntregaEmOutroEndereco(rota.getId());

				/*
				 * Caso exista algum imóvel com entrega em outro endereço cadastrado para a rota
				 * cria o débito para o imóvel. Caso contrário verifica
				 * a próxima rota.
				 */
				if(colecaoImoveis != null && !colecaoImoveis.isEmpty()){

					// Recupera a data atual
					Date dataAtual = new Date(System.currentTimeMillis());

					// Cria o iterator para imóveis da rota
					Iterator colecaoImoveisIterator = colecaoImoveis.iterator();

					// Recupera valores de Sistemas Parâmetros
					SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

					Integer anoMesReferenciaFaturamento = sistemaParametro.getAnoMesFaturamento();

					BigDecimal valorMinimoEmissaoConta = sistemaParametro.getValorMinimoEmissaoConta();

					// Laço para gerar os débitos para os imóveis da rota
					while(colecaoImoveisIterator.hasNext()){
						// Recupera o imóvel do iterator
						Imovel imovel = (Imovel) colecaoImoveisIterator.next();

						// Verifica se o imovel é faturável de água
						LigacaoAguaSituacao ligacaoAguaSituacao = this.getControladorImovel().pesquisarLigacaoAguaSituacao(imovel.getId());

						Short indicadorFaturamentoSituacaoAgua = null;
						boolean isImovelFaturavelAgua = false;

						if(ligacaoAguaSituacao != null && ligacaoAguaSituacao.getIndicadorFaturamentoSituacao() != null){
							// Indicador de Faturamento Situação Água
							indicadorFaturamentoSituacaoAgua = ligacaoAguaSituacao.getIndicadorFaturamentoSituacao();

							if(indicadorFaturamentoSituacaoAgua.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){
								isImovelFaturavelAgua = true;
							}
						}

						// Verifica se o imovel é faturável de esgoto
						LigacaoEsgotoSituacao ligacaoEsgotoSituacao = this.getControladorImovel().pesquisarLigacaoEsgotoSituacao(
										imovel.getId());

						Short indicadorFaturamentoSituacaoEsgoto = null;
						boolean isImovelFaturavelEsgoto = false;

						if(ligacaoEsgotoSituacao != null && ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao() != null){
							// Indicador de Faturamento Situação Esgoto
							indicadorFaturamentoSituacaoEsgoto = ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao();

							if(indicadorFaturamentoSituacaoEsgoto.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)){
								isImovelFaturavelEsgoto = true;
							}
						}

						// Verifica Imóvel com situação de ligação água “cortado a pedido” ou
						// “suprimido”
						boolean isImovelSituacaoLigacaoAguaCortadoAPedidoSuprimido = false;

						if(ligacaoAguaSituacao != null && ligacaoAguaSituacao.getId().equals(LigacaoAguaSituacao.CORTADO_PEDIDO)
										|| ligacaoAguaSituacao.getId().equals(LigacaoAguaSituacao.SUPRIMIDO)){
							isImovelSituacaoLigacaoAguaCortadoAPedidoSuprimido = true;
						}

						// Verifica a soma de todos os débitos a cobrar do imóvel
						BigDecimal somaValorDebitoACobrarImovel = BigDecimal.ZERO;

						somaValorDebitoACobrarImovel = repositorioFaturamento.somaValorDebitoACobrarImovel(imovel.getId(),
										anoMesReferenciaFaturamento);

						// O somatório dos débito a cobrar deve ser maior que o
						// PARM_VLMINIMOEMISSAOCONTA da tabela SISTEMA_PARAMETROS
						boolean isSomaDebitoACobrarMaiorMinimoEmissaoConta = false;

						if(!Util.isVazioOuBranco(somaValorDebitoACobrarImovel)
										&& (somaValorDebitoACobrarImovel.compareTo(BigDecimal.ZERO) == 1)
										&& (somaValorDebitoACobrarImovel.compareTo(valorMinimoEmissaoConta) == 1)){
							isSomaDebitoACobrarMaiorMinimoEmissaoConta = true;
						}

						// 2. Só gerar débito de taxa de entrega se:
						// 2.1. Imóvel faturável de água ou
						// 2.2. Imóvel faturável de esgoto ou
						// 2.3. Imóvel com situação de ligação água “cortado a pedido” ou
						// “suprimido”
						// e somatório de todos os débitos a cobrar com referência de cobrança menor
						// ou
						// igual a referência do faturamento com valor maior que o mínimo da conta.
						if(isImovelFaturavelAgua
										|| isImovelFaturavelEsgoto
										|| (isImovelSituacaoLigacaoAguaCortadoAPedidoSuprimido && isSomaDebitoACobrarMaiorMinimoEmissaoConta)){

							if(paramFormaCalculoTaxaEntregaOutroEndereco.equals(ConstantesSistema.INDICADOR_PERCENTUAL_VALOR_REF_TAXA)){

								/*
								 * Caso o perfil do imóvel seja tarifa social o valor vai ser o
								 * valor da
								 * tarifa social Caso contrário o valor da tarifa vai
								 * ser o normal.
								 */
								if(imovel.getImovelPerfil().getId().equals(ImovelPerfil.TARIFA_SOCIAL)){
									// Item 4.1
									valorReferenciaTaxa = valorMinimaTarifaSocial;
								}else{
									// Item 4.2
									valorReferenciaTaxa = valorMinimaTarifaNormal;
								}

							}

							// Verifica se já existe débito para este imóvel
							Object[] dadoDebitoACobrar = this.repositorioFaturamento.pesquisarDebitoACobrar(imovel.getId(),
											debitoTipo.getId(), anoMesFaturamento);

							// Seta Valor do Débito
							BigDecimal valorDebito = paramPercentualTarifaEntregaOutroEndereco.divide(new BigDecimal("100")).multiply(
											valorReferenciaTaxa);

							// [OC1213341] - Verificar se existe valor do Serviço Tipo para a
							// Localidade se
							// positivo substituir o valor padrão pelo valor encontrado.

							if(imovel != null && debitoTipo != null){
								BigDecimal valorServicoLocalidade = verificarDebitoTipoValorLocalidade(imovel.getId(), debitoTipo.getId());

								if(valorServicoLocalidade != null){
									valorDebito = valorServicoLocalidade;
								}
							}

							if(valorDebito.compareTo(BigDecimal.ZERO) > 0){

								// Cria uma instância de débito a cobrar
								DebitoACobrar debitoACobrar = new DebitoACobrar();

								// Seta o Imóvel
								debitoACobrar.setImovel(imovel);

								// Seta o Débito Tipo
								debitoACobrar.setDebitoTipo(debitoTipo);

								// Seta Data e Hora Atual
								debitoACobrar.setGeracaoDebito(dataAtual);

								// Seta Ano/Mês do Faturamento Corrente
								debitoACobrar.setAnoMesReferenciaDebito(anoMesFaturamento);

								// Seta Ano/Mês de Cobrança
								debitoACobrar.setAnoMesCobrancaDebito(sistema.getAnoMesArrecadacao());

								// Seta Ano/Mês Referência do Faturamento
								debitoACobrar.setAnoMesReferenciaContabil(sistema.getAnoMesFaturamento());

								// Seta Valor do Débito
								// BigDecimal valorMultiplicado = valor.multiply(new
								// BigDecimal("10"));
								// BigDecimal valorFinal = valorMultiplicado.divide(new
								// BigDecimal("100"),
								// 2, BigDecimal.ROUND_HALF_UP);
								debitoACobrar.setValorDebito(valorDebito);

								// Seta Número de Prestações do Débito
								debitoACobrar.setNumeroPrestacaoDebito(new Short("1"));

								// Seta Número de Prestações Cobradas
								debitoACobrar.setNumeroPrestacaoCobradas(new Short("0"));

								// Seta Localidade
								debitoACobrar.setLocalidade(imovel.getLocalidade());

								// Seta Quadra
								debitoACobrar.setQuadra(imovel.getQuadra());

								// Seta Código do Setor Comercial
								debitoACobrar.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());

								// Seta Número Quadra
								debitoACobrar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());

								// Seta Lote
								debitoACobrar.setNumeroLote(imovel.getLote());

								// Seta SubLote
								debitoACobrar.setNumeroSubLote(imovel.getSubLote());

								// Seta Taxa de Juros do Financiamento
								debitoACobrar.setPercentualTaxaJurosFinanciamento(new BigDecimal("0"));

								// Seta Financiamento Tipo
								debitoACobrar.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());

								// Seta Lançamento Item Contábil
								debitoACobrar.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());

								// Seta Débito Crédito Situação
								debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

								// Seta Cobrança Forma
								debitoACobrar.setCobrancaForma(cobrancaForma);

								// Seta a data de ultima alteração
								debitoACobrar.setUltimaAlteracao(new Date());

								/*
								 * Caso já exista o débito a cobrar para o imóvel recupera o id do
								 * débito a
								 * cobrar e deleta todos os débitos a cobrar por
								 * categoria e adiciona o débito a coleção de atualização Caso
								 * contrário
								 * adiciona o débito a cobrar geral e o débito a cobrar
								 * a coleção de inserir.
								 */
								if(dadoDebitoACobrar != null && dadoDebitoACobrar[0] != null){
									debitoACobrar.setId(((Integer) dadoDebitoACobrar[0]));
									this.repositorioFaturamento.deletarDebitoACobrarCategoria(debitoACobrar.getId());
									colecaoDebitosACobrarAtualizar.add(debitoACobrar);
									colecaoDebitosACobrarCategoriasInserir.addAll(inserirDebitoACobrarCategoriaBatch(debitoACobrar,
													debitoACobrar.getImovel()));
								}else{
									/*
									 * Inserir o débito a cobrar geral na base de dados e recupera o
									 * id
									 * gerado para setar no débito a cobrar.
									 */
									DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
									debitoACobrarGeral.setIndicadorHistorico(ConstantesSistema.NAO);
									debitoACobrarGeral.setUltimaAlteracao(new Date());
									Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
									debitoACobrarGeral.setId(idDebitoACobrarGeral);
									debitoACobrar.setId(idDebitoACobrarGeral);
									debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);

									colecaoDebitosACobrarInserir.add(debitoACobrar);
									colecaoDebitosACobrarCategoriasInserir.addAll(inserirDebitoACobrarCategoriaBatch(debitoACobrar,
													debitoACobrar.getImovel()));
								}
							}
						}
					}
				}// if imóveis

			}// laço rotas

			/*
			 * Caso tenha gerado débito a cobrar para inserir para algum imóvel cria os débitos a
			 * cobrar por na base de dados.
			 */
			if(colecaoDebitosACobrarInserir != null && !colecaoDebitosACobrarInserir.isEmpty()){
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitosACobrarInserir);
			}

			/*
			 * Caso tenha gerado débito a cobrar para atualizar para algum imóvel atualiza os dados
			 * dos débitos a cobrar na base de dados e a data de
			 * última alteração do débito a cobrar geral.
			 */
			if(colecaoDebitosACobrarAtualizar != null && !colecaoDebitosACobrarAtualizar.isEmpty()){
				this.repositorioFaturamento.atualizaDebitoACobrar(colecaoDebitosACobrarAtualizar);
			}

			/*
			 * Caso gere algum débito a cobrar por categoria inserir todos de uma vez na base de
			 * dados
			 */
			if(!colecaoDebitosACobrarCategoriasInserir.isEmpty()){
				this.repositorioFaturamento.inserirDebitoACobrarCategoria(colecaoDebitosACobrarCategoriasInserir);
			}

			if(!Util.isVazioOrNulo(colecaoDebitosACobrarInserir)){
				Collection<Integer> idsDebitoACobrar = new ArrayList<Integer>();

				Integer idDebitoACobrar = null;

				for(DebitoACobrar debitoACobrar : (Collection<DebitoACobrar>) colecaoDebitosACobrarInserir){

					// INSERIR CLIENTE_DEBITO_A_COBRAR
					this.getControladorCobranca().inserirClienteDebitoACobrar(debitoACobrar);

					idDebitoACobrar = debitoACobrar.getId();

					idsDebitoACobrar.add(idDebitoACobrar);
				}

				this.registrarLancamentoContabilDebitoACobrar(idsDebitoACobrar);
			}


			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			sessionContext.setRollbackOnly();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	/**
	 * [UC0302] - Gerar Debitos A Cobrar de Acrescimos por Impontualidade Author: Fernanda Paiva
	 * Data: 24/04/2006
	 * Obtém as contas de um imóvel com ano/mes da data de vencimento menor ou igual ao ano/mes de
	 * referencia da arrecadacao corrente e com situacao
	 * atual correspondente a normal, retificada ou incluida.
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection obterContasImovel(Integer imovel, Integer situacaoNormal, Integer situacaoIncluida, Integer situacaoRetificada,
					Integer anoMesReferenciaArrecadacao) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoContasManutencaoArray = null;

		try{

			colecaoContasManutencaoArray = repositorioFaturamento.obterContasImovel(imovel, situacaoNormal, situacaoIncluida,
							situacaoRetificada, anoMesReferenciaArrecadacao);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoContasManutencaoArray != null && !colecaoContasManutencaoArray.isEmpty()){

			Iterator colecaoContasManutencaoArrayIterator = colecaoContasManutencaoArray.iterator();

			while(colecaoContasManutencaoArrayIterator.hasNext()){

				// Obtém os dados do crédito realizado
				Object[] contaArray = (Object[]) colecaoContasManutencaoArrayIterator.next();

				Conta conta = new Conta();

				// ID da conta
				conta.setId((Integer) contaArray[0]);

				// Ano Mês referencia
				conta.setReferencia((Integer) contaArray[1]);

				// Data de vencimento
				String vencimento = String.valueOf(contaArray[2]);

				SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd");

				Date dataVencimento;

				try{
					dataVencimento = formatoData.parse(vencimento);
				}catch(java.text.ParseException e){
					dataVencimento = null;
				}

				conta.setDataVencimentoConta(dataVencimento);

				// Valor de água
				conta.setValorAgua((BigDecimal) contaArray[3]);

				// Valor de esgoto
				conta.setValorEsgoto((BigDecimal) contaArray[4]);

				// Valor dos débitos
				conta.setDebitos((BigDecimal) contaArray[5]);

				// Valor dos créditos
				conta.setValorCreditos((BigDecimal) contaArray[6]);

				// Consumo de água
				conta.setConsumoAgua((Integer) contaArray[7]);

				// Consumo de esgoto
				conta.setConsumoEsgoto((Integer) contaArray[8]);

				// Data de validade
				String validade = String.valueOf(contaArray[9]);

				Date dataValidade;

				try{
					dataValidade = formatoData.parse(validade);
				}catch(java.text.ParseException e){
					dataValidade = null;
				}

				conta.setDataValidadeConta(dataValidade);

				// Data de revisao
				String revisao = String.valueOf(contaArray[10]);

				Date dataRevisao;

				try{
					dataRevisao = formatoData.parse(revisao);
				}catch(java.text.ParseException e){
					dataRevisao = null;
				}

				conta.setDataRevisao(dataRevisao);

				// DebitoCreditoSituacaoAtual
				conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);

				// Ano Mês referencia contábil
				conta.setReferenciaContabil((Integer) contaArray[12]);

				// ultima Alteracao

				SimpleDateFormat formatoDataEspecifico = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

				String ultimaAlteracao = String.valueOf(contaArray[13]);

				Date dataUltimaAlteracao;

				try{
					dataUltimaAlteracao = formatoDataEspecifico.parse(ultimaAlteracao);
				}catch(java.text.ParseException e){
					dataUltimaAlteracao = null;
				}

				conta.setUltimaAlteracao(dataUltimaAlteracao);

				retorno.add(conta);
			}
		}

		return retorno;
	}

	/**
	 * [UC0302] - Gerar Debitos A Cobrar de Acrescimos por Impontualidade Author: Fernanda Paiva
	 * Data: 24/04/2006
	 * Obtém as contas de um imóvel com ano/mes da data de vencimento menor ou igual ao ano/mes de
	 * referencia da arrecadacao corrente e com situacao
	 * atual correspondente a normal, retificada ou incluida.
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @param anoMesReferenciaArrecadacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection obterGuiasPagamentoImovel(Integer imovel, Integer situacaoNormal, Integer situacaoIncluida,
					Integer situacaoRetificada, Integer anoMesReferenciaArrecadacao) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoGuiasManutencaoArray = null;

		try{

			colecaoGuiasManutencaoArray = repositorioFaturamento.obterGuiasPagamentoImovel(imovel, situacaoNormal, situacaoIncluida,
							situacaoRetificada, anoMesReferenciaArrecadacao);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoGuiasManutencaoArray != null && !colecaoGuiasManutencaoArray.isEmpty()){

			Iterator colecaoGuiasManutencaoArrayIterator = colecaoGuiasManutencaoArray.iterator();

			while(colecaoGuiasManutencaoArrayIterator.hasNext()){

				// Obtém os dados do crédito realizado
				Object[] guiaArray = (Object[]) colecaoGuiasManutencaoArrayIterator.next();

				GuiaPagamento guiaPagamento = new GuiaPagamento();

				// ID da conta
				guiaPagamento.setId((Integer) guiaArray[0]);

				// Ano Mês referencia
				// guiaPagamento
				// .setAnoMesReferenciaContabil((Integer) guiaArray[1]);

				// Data de vencimento
				String vencimento = String.valueOf(guiaArray[2]);

				SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd");

				Date dataVencimento;

				try{
					dataVencimento = formatoData.parse(vencimento);
				}catch(java.text.ParseException e){
					dataVencimento = null;
				}

				// guiaPagamento.setDataVencimento(dataVencimento);

				// Valor dos débitos
				guiaPagamento.setValorDebito((BigDecimal) guiaArray[3]);

				retorno.add(guiaPagamento);
			}
		}

		return retorno;
	}

	/**
	 * Este caso de uso gera os débitos a cobrar referentes aos acréscimos por impontualidade
	 * (multa, juros de mora e atualização monetária)
	 * [UC0302] - Gerar Débitos a Cobrar de Acréscimos por Impontualidade Autor:
	 * 
	 * @author Fernanda Paiva, Pedro Alexandre
	 * @date 20/04/2006, 31/08/2006
	 * @param rotas
	 * @param indicadorGeracaoMulta
	 * @param indicadorGeracaoJuros
	 * @param indicadorGeracaoAtualizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection gerarDebitosACobrarDeAcrescimosPorImpontualidade(Collection rotas, int idFuncionalidadeIniciada,
					boolean indicadorEncerrandoArrecadacao) throws ControladorException{

		int idUnidadeIniciada = 0;

		try{

			// -------------------------
			//
			// Registrar o início do processamento da Unidade de
			// Processamento
			// do Batch
			//
			// -------------------------
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
							((Rota) Util.retonarObjetoDeColecao(rotas)).getId());

			// cria uma coleção de imóvel por rota
			Collection imoveisPorRota = null;
			Collection colecaoDebitoACobrarInserir = new ArrayList();
			Collection colecaoDebitoACobrarCategoriaInserir = new ArrayList();
			Collection colecaoClienteDebitoACobrarInserir = new ArrayList();

			Integer indicadorGeracaoMulta = Integer.valueOf(ParametroCobranca.P_COBRAR_MULTA_POR_IMPONTUALIDADE.executar());
			Integer indicadorGeracaoJuros = Integer.valueOf(ParametroCobranca.P_COBRAR_JUROS_POR_IMPONTUALIDADE.executar());
			Integer indicadorGeracaoAtualizacao = Integer.valueOf(ParametroCobranca.P_COBRAR_CORRECAO_POR_IMPONTUALIDADE.executar());

			// recupera todos os imóveis da coleção de rotas
			imoveisPorRota = repositorioFaturamento.pesquisarImoveisDasQuadrasPorRota(rotas);

			SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

			Integer anoMesReferenciaArrecadacao = sistemaParametros.getAnoMesArrecadacao();

			Iterator imovelPorRotaIterator = imoveisPorRota.iterator();

			while(imovelPorRotaIterator.hasNext()){
				// cria um array de objetos para pegar os parametros de
				// retorno da pesquisa
				Object[] arrayImoveisPorRota = (Object[]) imovelPorRotaIterator.next();

				// instancia um imóvel
				Imovel imovel = new Imovel();
				if(arrayImoveisPorRota[0] != null){
					// seta o id no imovel
					imovel.setId((Integer) arrayImoveisPorRota[0]);
				}

				if(arrayImoveisPorRota[4] != null){
					// seta o lote no imovel
					imovel.setLote((Short) arrayImoveisPorRota[4]);
				}

				if(arrayImoveisPorRota[5] != null){
					// seta o sublote no imovel
					imovel.setSubLote((Short) arrayImoveisPorRota[5]);
				}

				Localidade localidade = new Localidade();
				if(arrayImoveisPorRota[1] != null){
					// instancia uma localidade para ser setado no imóvel
					localidade.setId((Integer) arrayImoveisPorRota[1]);
					imovel.setLocalidade(localidade);
				}

				Quadra quadra = new Quadra();
				if(arrayImoveisPorRota[3] != null){
					// instancia uma quadra para ser setado no imóvel
					Integer numeroQuadra = (Integer) arrayImoveisPorRota[3];
					Integer idQuadra = (Integer) arrayImoveisPorRota[7];
					quadra.setId(idQuadra);
					quadra.setNumeroQuadra(numeroQuadra);
					imovel.setQuadra(quadra);
				}

				Integer setorComercial = null;
				if(arrayImoveisPorRota[2] != null){
					// instancia um setor comercial para ser setado no imóvel
					setorComercial = (Integer) arrayImoveisPorRota[2];
				}

				/**
				 * Item 5.1 [UC0306] - Obter Principal Categoria do Imóvel
				 */
				Categoria principalCategoria = getControladorImovel().obterPrincipalCategoriaImovel(imovel.getId());

				boolean flagProximoImovel = false;

				/**
				 * Item 5.2 Caso a principal categoria do imóvel esteja indicando que não deve ser
				 * gerado acréscimos por impontualidade para a
				 * categoria (catg_icgeracaoacrescimos=ENCERRAMENTO_ARRECADACAO) da principal
				 * categoria do imóvel e esteja indicando que não está
				 * sendo encerrada a arrecadação , passa para o próximo imóvel.
				 */
				if(principalCategoria.getIndicadorCobrancaAcrescimos().equals(ConstantesSistema.NAO)){
					flagProximoImovel = true;
				}
				/**
				 * Item 5.3 Caso a principal categoria do imóvel esteja indicando que somente deve
				 * ser gerado acréscimos por impontualidade para a
				 * categoria (catg_icgeracaoacrescimos=NAO) da principal categoria do imóvel, passa
				 * para o próximo imóvel.
				 */
				if((principalCategoria.getIndicadorCobrancaAcrescimos().equals(ConstantesSistema.ENCERRAMENTO_ARRECADACAO))
								&& !indicadorEncerrandoArrecadacao){
					flagProximoImovel = true;
				}
				/**
				 * Item 5.4 Caso o imóvel possua cliente responsável, recupera o indicador de
				 * cobrança de acrécimos do cliente responsável
				 * (CLIE_ICCOBRANCAACRESCIMOS)
				 */
				Short indicadorCobrancaAcrescimos = getControladorImovel().obterIndicadorGeracaoAcrescimosClienteImovel(imovel.getId());

				/**
				 * Item 5.4.1 Caso esteja indicado que não de ve ser gerado acrécimos por
				 * impontualidade para o cliente
				 * (CLIE_ICCOBRANCAACRESCIMOS=NAO) , passar para o próximo imóvel
				 */
				if(indicadorCobrancaAcrescimos != null && indicadorCobrancaAcrescimos.equals(ConstantesSistema.NAO)){
					flagProximoImovel = true;
				}

				if(indicadorCobrancaAcrescimos != null
								&& (indicadorCobrancaAcrescimos.equals(ConstantesSistema.NAO) && !indicadorEncerrandoArrecadacao)){
					flagProximoImovel = true;
				}

				if(!flagProximoImovel){

					Date dataAnoMesReferenciaUltimoDia = Util.gerarDataApartirAnoMesRefencia(anoMesReferenciaArrecadacao);

					Collection<Integer> colecaoIdsContasAtualizarIndicadorMulta = new ArrayList();

					// cria uma coleção de contas do imovel
					Collection colecaoContaImovel = null;

					// recupera todas as contas dos imóveis da coleção
					// de rotas
					colecaoContaImovel = repositorioFaturamento.obterContasImovel(imovel.getId(), DebitoCreditoSituacao.NORMAL,
									DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.RETIFICADA, dataAnoMesReferenciaUltimoDia);

					// DEBITO A COBRAR GERAL
					DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
					debitoACobrarGeral.setIndicadorHistorico(ConstantesSistema.NAO);
					debitoACobrarGeral.setUltimaAlteracao(new Date());
					// ************************************************************

					DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
					debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
					CobrancaForma cobrancaForma = new CobrancaForma();
					cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

					Short numeroPrestacaoDebito = 1;
					Short numeroPrestacaoCobradas = 0;

					if(colecaoContaImovel != null && !colecaoContaImovel.isEmpty()){

						Iterator contasIterator = colecaoContaImovel.iterator();

						while(contasIterator.hasNext()){
							// cria um array de objetos para pegar os
							// parametros de
							// retorno da pesquisa
							Object[] dadosConta = (Object[]) contasIterator.next();

							Integer anoMes = Util.recuperaAnoMesDaData((Date) dadosConta[2]);

							if(anoMes <= anoMesReferenciaArrecadacao){

								Integer idConta = (Integer) dadosConta[0];
								Conta conta = new Conta();
								if(dadosConta[0] != null){
									// seta o id da conta
									conta.setId((Integer) dadosConta[0]);
								}
								if(dadosConta[1] != null){
									// seta o ano/mes referencia da
									// conta
									conta.setReferencia((Integer) dadosConta[1]);
								}
								if(dadosConta[2] != null){
									// seta a data de vencimento da
									// conta
									conta.setDataVencimentoConta((Date) dadosConta[2]);
								}
								if(dadosConta[3] != null){
									// seta o valor da água
									conta.setValorAgua((BigDecimal) dadosConta[3]);
								}
								if(dadosConta[4] != null){
									// seta o valor do esgoto
									conta.setValorEsgoto((BigDecimal) dadosConta[4]);
								}
								if(dadosConta[5] != null){
									// seta o valor dos debitos
									conta.setDebitos((BigDecimal) dadosConta[5]);
								}
								if(dadosConta[6] != null){
									// seta o valor dos creditos
									conta.setValorCreditos((BigDecimal) dadosConta[6]);
								}
								if(dadosConta[7] != null){
									// seta o indicador de cobranca da
									// multa
									conta.setIndicadorCobrancaMulta((Short) dadosConta[7]);
								}

								// cria uma coleção dos pagamentos da
								// conta
								// com
								// menor
								// data de pagamento
								Date pagamentoContasMenorData = null;

								// recupera todos os pagamentos da conta
								// com
								// menor
								// data de pagamento
								pagamentoContasMenorData = repositorioFaturamento.obterPagamentoContasMenorData(idConta, imovel.getId(),
												conta.getReferencia());

								boolean indicadorExistePagamentoClassificadoConta = repositorioFaturamento
												.obterIndicadorPagamentosClassificadosContaReferenciaMenorIgualAtual(idConta,
																imovel.getId(), conta.getReferencia(), anoMesReferenciaArrecadacao);

								CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidade = new CalcularAcrescimoPorImpontualidadeHelper();

								BigDecimal valorConta = conta.getValorAgua().add(conta.getValorEsgoto()).add(conta.getDebitos())
												.subtract(conta.getValorCreditos());

								// Calcula o valor das multas cobradas
								// para
								// a conta
								BigDecimal valorMultasCobradas = repositorioFaturamento.pesquisarValorMultasCobradas(idConta);

								/**
								 * Item 5.6.2 Calcular os acrescimos por impontualidade
								 */
								calcularAcrescimoPorImpontualidade = this.getControladorCobranca()
												.calcularAcrescimoPorImpontualidadeBancoDeDados(conta.getReferencia(),
																conta.getDataVencimentoConta(), pagamentoContasMenorData, valorConta,
																valorMultasCobradas, conta.getIndicadorCobrancaMulta(),
																"" + sistemaParametros.getAnoMesArrecadacao(), conta.getId(), null, null,
																ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM);

								DebitoTipo debitoTipo = null;

								Object[] obterDebitoTipo = null;

								/**
								 * Item 5.6.3 Caso o indicador de geração de multa corresponda a
								 * sim(1) e o valor da multa seja maior que que zero.
								 * Gera o débito a cobrar referente a multa.
								 */
								if(indicadorGeracaoMulta.intValue() == ConstantesSistema.SIM.intValue()
												&& calcularAcrescimoPorImpontualidade.getValorMulta().compareTo(new BigDecimal("0.00")) == 1){
									debitoTipo = new DebitoTipo();
									debitoTipo.setId(DebitoTipo.MULTA_IMPONTUALIDADE);

									obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo.getId());

									FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
									LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
									if(obterDebitoTipo[0] != null){
										financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
									}

									if(obterDebitoTipo[1] != null){
										lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
									}

									DebitoACobrar debitoACobrar = new DebitoACobrar();
									debitoACobrar.setImovel(imovel);
									// SB0003 - Formatar Referência da Cobrança do Débito
									formatarReferenciaDeCobrancaDebito(debitoACobrar, sistemaParametros, imovel.getId());
									debitoACobrar.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
									debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
									debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
									debitoACobrar.setLocalidade(localidade);
									debitoACobrar.setQuadra(quadra);
									debitoACobrar.setCodigoSetorComercial(setorComercial);
									debitoACobrar.setNumeroQuadra(quadra.getNumeroQuadra());
									debitoACobrar.setNumeroLote(imovel.getLote());
									debitoACobrar.setNumeroSubLote(imovel.getSubLote());
									debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
									debitoACobrar.setRegistroAtendimento(null);
									debitoACobrar.setOrdemServico(null);
									debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
									debitoACobrar.setParcelamentoGrupo(null);
									debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
									debitoACobrar.setCobrancaForma(cobrancaForma);
									debitoACobrar.setDebitoTipo(debitoTipo);
									debitoACobrar.setUltimaAlteracao(new Date());
									debitoACobrar.setGeracaoDebito(new Date());
									debitoACobrar.setAnoMesReferenciaDebito(conta.getReferencia());
									debitoACobrar.setFinanciamentoTipo(financiamentoTipo);
									debitoACobrar.setLancamentoItemContabil(lancamentoItemContabil);
									debitoACobrar.setValorDebito(calcularAcrescimoPorImpontualidade.getValorMulta());

									// Inseri o débito a cobra geral e
									// recupera o id
									Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
									debitoACobrarGeral.setId(idDebitoACobrarGeral);

									colecaoIdsContasAtualizarIndicadorMulta.add(conta.getId());

									debitoACobrar.setId(idDebitoACobrarGeral);
									debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);
									colecaoDebitoACobrarInserir.add(debitoACobrar);
									colecaoClienteDebitoACobrarInserir.addAll(this.getControladorCobranca()
													.obterColecaoClienteDebitoACobrar(debitoACobrar));
									colecaoDebitoACobrarCategoriaInserir.addAll(inserirDebitoACobrarCategoriaBatch(debitoACobrar,
													debitoACobrar.getImovel()));
								}// if indicador de geração de multa

								/**
								 * Item 5.6.4 Caso o indicador de geração dos juros de mora
								 * corresponda a sim(1) e o valor dos juros de mora seja
								 * maior que zero Gera o débito a cobrar referente a juros de mora e
								 * exista pagamento para a conta com data de
								 * pagamento diferente de nulo e ano/mês referência da arrecadação
								 * do pagamento seja menor ou igual ao ano/mês de
								 * arrecadação corente.
								 */
								if(indicadorGeracaoJuros.intValue() == ConstantesSistema.SIM.intValue()
												&& calcularAcrescimoPorImpontualidade.getValorJurosMora().compareTo(new BigDecimal("0.00")) == 1
												&& indicadorExistePagamentoClassificadoConta){

									debitoTipo = new DebitoTipo();
									debitoTipo.setId(DebitoTipo.JUROS_MORA);

									obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo.getId());

									FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
									LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
									if(obterDebitoTipo[0] != null){
										financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
									}
									if(obterDebitoTipo[1] != null){
										lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
									}

									DebitoACobrar debitoACobrar = new DebitoACobrar();
									debitoACobrar.setImovel(imovel);
									// SB0003 - Formatar Referência da Cobrança do Débito
									formatarReferenciaDeCobrancaDebito(debitoACobrar, sistemaParametros, imovel.getId());
									debitoACobrar.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
									debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
									debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
									debitoACobrar.setLocalidade(localidade);
									debitoACobrar.setQuadra(quadra);
									debitoACobrar.setCodigoSetorComercial(setorComercial);
									debitoACobrar.setNumeroQuadra(quadra.getNumeroQuadra());
									debitoACobrar.setNumeroLote(imovel.getLote());
									debitoACobrar.setNumeroSubLote(imovel.getSubLote());
									debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
									debitoACobrar.setRegistroAtendimento(null);
									debitoACobrar.setOrdemServico(null);
									debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
									debitoACobrar.setParcelamentoGrupo(null);
									debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
									debitoACobrar.setCobrancaForma(cobrancaForma);
									debitoACobrar.setDebitoTipo(debitoTipo);
									debitoACobrar.setUltimaAlteracao(new Date());
									debitoACobrar.setGeracaoDebito(new Date());
									debitoACobrar.setAnoMesReferenciaDebito(conta.getReferencia());
									debitoACobrar.setFinanciamentoTipo(financiamentoTipo);
									debitoACobrar.setLancamentoItemContabil(lancamentoItemContabil);
									debitoACobrar.setValorDebito(calcularAcrescimoPorImpontualidade.getValorJurosMora());

									colecaoIdsContasAtualizarIndicadorMulta.add(conta.getId());

									// Inseri o débito a cobra geral e
									// recupera o id
									Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
									debitoACobrarGeral.setId(idDebitoACobrarGeral);

									debitoACobrar.setId(idDebitoACobrarGeral);
									debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);
									colecaoDebitoACobrarInserir.add(debitoACobrar);
									colecaoClienteDebitoACobrarInserir.addAll(this.getControladorCobranca()
													.obterColecaoClienteDebitoACobrar(debitoACobrar));
									colecaoDebitoACobrarCategoriaInserir.addAll(inserirDebitoACobrarCategoriaBatch(debitoACobrar,
													debitoACobrar.getImovel()));
								}

								/*
								 * 5.6.5 Caso o indicador de geração de atualização monetária
								 * corresponda a sim(1) e o valor da atualização monetária
								 * seja maior que zero Gera o débito a cobrar referente a
								 * atualização monetária e
								 */
								if(indicadorGeracaoAtualizacao.intValue() == ConstantesSistema.SIM.intValue()
												&& calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria().compareTo(
																new BigDecimal("0.00")) == 1 && indicadorExistePagamentoClassificadoConta){

									debitoTipo = new DebitoTipo();
									debitoTipo.setId(DebitoTipo.ATUALIZACAO_MONETARIA);

									obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo.getId());

									FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
									LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
									if(obterDebitoTipo[0] != null){
										financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
									}
									if(obterDebitoTipo[1] != null){
										lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
									}

									DebitoACobrar debitoACobrar = new DebitoACobrar();
									debitoACobrar.setImovel(imovel);
									// SB0003 - Formatar Referência da Cobrança do Débito
									formatarReferenciaDeCobrancaDebito(debitoACobrar, sistemaParametros, imovel.getId());
									debitoACobrar.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
									debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
									debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
									debitoACobrar.setLocalidade(localidade);
									debitoACobrar.setQuadra(quadra);
									debitoACobrar.setCodigoSetorComercial(setorComercial);
									debitoACobrar.setNumeroQuadra(quadra.getNumeroQuadra());
									debitoACobrar.setNumeroLote(imovel.getLote());
									debitoACobrar.setNumeroSubLote(imovel.getSubLote());
									debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
									debitoACobrar.setRegistroAtendimento(null);
									debitoACobrar.setOrdemServico(null);
									debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
									debitoACobrar.setParcelamentoGrupo(null);
									debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
									debitoACobrar.setCobrancaForma(cobrancaForma);
									debitoACobrar.setDebitoTipo(debitoTipo);
									debitoACobrar.setUltimaAlteracao(new Date());
									debitoACobrar.setGeracaoDebito(new Date());
									debitoACobrar.setAnoMesReferenciaDebito(conta.getReferencia());
									debitoACobrar.setFinanciamentoTipo(financiamentoTipo);
									debitoACobrar.setLancamentoItemContabil(lancamentoItemContabil);
									debitoACobrar.setValorDebito(calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria());

									colecaoIdsContasAtualizarIndicadorMulta.add(conta.getId());

									// Inseri o débito a cobra geral e
									// recupera o id
									Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
									debitoACobrarGeral.setId(idDebitoACobrarGeral);

									debitoACobrar.setId(idDebitoACobrarGeral);
									debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);
									colecaoDebitoACobrarInserir.add(debitoACobrar);
									colecaoClienteDebitoACobrarInserir.addAll(this.getControladorCobranca()
													.obterColecaoClienteDebitoACobrar(debitoACobrar));
									colecaoDebitoACobrarCategoriaInserir.addAll(inserirDebitoACobrarCategoriaBatch(debitoACobrar,
													debitoACobrar.getImovel()));
								}
							} // fim if da comparacao da data de
								// pagamento
						} // fim while contasiterator
					} // fim if colecaoconta

					/*
					 * Item 5.6.3.2 Atualiza o indicador de que já cobrou multa da conta com o valor
					 * igual a SIM (CNTA_ICCOBRANCAMULTA=1)
					 */
					if(colecaoIdsContasAtualizarIndicadorMulta != null && !colecaoIdsContasAtualizarIndicadorMulta.isEmpty()){
						repositorioFaturamento.atualizarIndicadorMultaDeConta(colecaoIdsContasAtualizarIndicadorMulta);
					}

					// cria uma coleção de guias do imovel
					Collection colecaoGuiasPagamentoImovel = null;

					Collection<Integer> colecaoIdsGuiasPagamentosAtualizarIndicadorMulta = new ArrayList();

					// recupera todas as guias dos imóveis da coleção de
					// rotas
					colecaoGuiasPagamentoImovel = repositorioFaturamento.obterGuiasPagamentoImovel(imovel.getId(),
									DebitoCreditoSituacao.NORMAL, DebitoCreditoSituacao.INCLUIDA, DebitoCreditoSituacao.RETIFICADA,
									anoMesReferenciaArrecadacao);

					if(colecaoGuiasPagamentoImovel != null && !colecaoGuiasPagamentoImovel.isEmpty()){

						Iterator guiasPagamentoIterator = colecaoGuiasPagamentoImovel.iterator();

						while(guiasPagamentoIterator.hasNext()){
							// cria um array de objetos para pegar os
							// parametros de
							// retorno da pesquisa
							Object[] dadosGuiasPagamento = (Object[]) guiasPagamentoIterator.next();

							Integer anoMes = Util.recuperaAnoMesDaData((Date) dadosGuiasPagamento[2]);

							if(anoMes <= anoMesReferenciaArrecadacao){

								GuiaPagamento guiaPagamento = new GuiaPagamento();
								if(dadosGuiasPagamento[0] != null){
									// seta o id da guia
									guiaPagamento.setId((Integer) dadosGuiasPagamento[0]);
								}
								if(dadosGuiasPagamento[1] != null){
									// seta o ano/mes referencia da guia
									// guiaPagamento
									// .setAnoMesReferenciaContabil((Integer)
									// dadosGuiasPagamento[1]);
								}
								if(dadosGuiasPagamento[2] != null){
									// seta a data de vencimento da
									// conta
									// guiaPagamento
									// .setDataVencimento((Date)
									// dadosGuiasPagamento[2]);
								}
								if(dadosGuiasPagamento[3] != null){
									// seta o valor dos debitos
									guiaPagamento.setValorDebito((BigDecimal) dadosGuiasPagamento[3]);
								}
								if(dadosGuiasPagamento[4] != null){
									// seta o indicador de cobranca da
									// multa
									// guiaPagamento
									// .setIndicadoCobrancaMulta((Short)
									// dadosGuiasPagamento[4]);
								}

								DebitoTipo debitoTipoGuiaPagamento = new DebitoTipo();
								if(dadosGuiasPagamento[5] != null){
									debitoTipoGuiaPagamento.setId((Integer) dadosGuiasPagamento[5]);
									// guiaPagamento
									// .setDebitoTipo(debitoTipoGuiaPagamento);
								}

								Date menorDataPagamento = repositorioCobranca.pesquisarMenorDataPagamentoGuiaPagamento(
												guiaPagamento.getId(), imovel.getId(), null); // guiaPagamento
								// .getDebitoTipo()
								// .getId());

								boolean indicadorExistePagamentoClassificadoGuiaPagamento = repositorioFaturamento
												.obterIndicadorPagamentosClassificadosGuiaPagamentoReferenciaMenorIgualAtual(
																guiaPagamento.getId(), imovel.getId(), null, // guiaPagamento
																// .getDebitoTipo()
																// .getId(),
																anoMesReferenciaArrecadacao);

								// [UC0216] Calcular Acréscimos por
								// Impontualidade
								CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidade = new CalcularAcrescimoPorImpontualidadeHelper();
								calcularAcrescimoPorImpontualidade = this.getControladorCobranca()
												.calcularAcrescimoPorImpontualidadeBancoDeDados(0, null, menorDataPagamento,
																guiaPagamento.getValorDebito(), BigDecimal.ZERO, Short.parseShort("0"),
																"" + sistemaParametros.getAnoMesArrecadacao(), null, null, null,
																ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM);

								DebitoTipo debitoTipo = null;

								Object[] obterDebitoTipo = null;

								/*
								 * Item 5.8.3 Caso o indicador de geração de multa corresponda a
								 * sim(1) e o valor da multa seja maior que que zero.
								 * Gera o débito a cobrar referente a multa.
								 */
								if(indicadorGeracaoMulta.intValue() == ConstantesSistema.SIM.intValue()
												&& calcularAcrescimoPorImpontualidade.getValorMulta().compareTo(new BigDecimal("0.00")) == 1){

									debitoTipo = new DebitoTipo();

									debitoTipo.setId(DebitoTipo.MULTA_IMPONTUALIDADE);

									obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo.getId());

									FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
									LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
									if(obterDebitoTipo[0] != null){
										financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
									}
									if(obterDebitoTipo[1] != null){
										lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
									}

									DebitoACobrar debitoACobrar = new DebitoACobrar();
									debitoACobrar.setImovel(imovel);
									// SB0003 - Formatar Referência da Cobrança do Débito
									formatarReferenciaDeCobrancaDebito(debitoACobrar, sistemaParametros, imovel.getId());
									debitoACobrar.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
									debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
									debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
									debitoACobrar.setLocalidade(localidade);
									debitoACobrar.setQuadra(quadra);
									debitoACobrar.setCodigoSetorComercial(setorComercial);
									debitoACobrar.setNumeroQuadra(quadra.getNumeroQuadra());
									debitoACobrar.setNumeroLote(imovel.getLote());
									debitoACobrar.setNumeroSubLote(imovel.getSubLote());
									debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
									debitoACobrar.setRegistroAtendimento(null);
									debitoACobrar.setOrdemServico(null);
									debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
									debitoACobrar.setParcelamentoGrupo(null);
									debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
									debitoACobrar.setCobrancaForma(cobrancaForma);
									debitoACobrar.setDebitoTipo(debitoTipo);
									debitoACobrar.setUltimaAlteracao(new Date());
									debitoACobrar.setGeracaoDebito(new Date());
									// debitoACobrar
									// .setAnoMesReferenciaDebito(guiaPagamento
									// .getAnoMesReferenciaContabil());
									// debitoACobrar
									// .setFinanciamentoTipo(financiamentoTipo);
									// debitoACobrar
									// .setLancamentoItemContabil(lancamentoItemContabil);
									debitoACobrar.setValorDebito(calcularAcrescimoPorImpontualidade.getValorMulta());

									// repositorioFaturamento.atualizarIndicadorMultaDeGuiaPagamento(guiaPagamento.getId());
									colecaoIdsGuiasPagamentosAtualizarIndicadorMulta.add(guiaPagamento.getId());

									// Inseri o débito a cobra geral e
									// recupera o id
									Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
									debitoACobrarGeral.setId(idDebitoACobrarGeral);

									debitoACobrar.setId(idDebitoACobrarGeral);
									debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);
									colecaoDebitoACobrarInserir.add(debitoACobrar);
									colecaoClienteDebitoACobrarInserir.addAll(this.getControladorCobranca()
													.obterColecaoClienteDebitoACobrar(debitoACobrar));
									colecaoDebitoACobrarCategoriaInserir.addAll(inserirDebitoACobrarCategoriaBatch(debitoACobrar,
													debitoACobrar.getImovel()));
								}

								/*
								 * Item 5.8.4 Caso o indicador de geração dos juros de mora
								 * corresponda a sim(1) e o valor dos juros de mora seja
								 * maior que zero e exista pagamento para a guia de pagamento com
								 * situação atual igual a classificado. Gera o débito a
								 * cobrar referente a juros de mora.
								 */
								if(indicadorGeracaoJuros.intValue() == ConstantesSistema.SIM.intValue()
												&& calcularAcrescimoPorImpontualidade.getValorJurosMora().compareTo(new BigDecimal("0.00")) == 1
												&& indicadorExistePagamentoClassificadoGuiaPagamento){

									debitoTipo = new DebitoTipo();
									debitoTipo.setId(DebitoTipo.JUROS_MORA);

									obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo.getId());

									FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
									LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
									if(obterDebitoTipo[0] != null){
										financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
									}
									if(obterDebitoTipo[1] != null){
										lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
									}

									DebitoACobrar debitoACobrar = new DebitoACobrar();
									debitoACobrar.setImovel(imovel);
									// SB0003 - Formatar Referência da Cobrança do Débito
									formatarReferenciaDeCobrancaDebito(debitoACobrar, sistemaParametros, imovel.getId());
									debitoACobrar.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
									debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
									debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
									debitoACobrar.setLocalidade(localidade);
									debitoACobrar.setQuadra(quadra);
									debitoACobrar.setCodigoSetorComercial(setorComercial);
									debitoACobrar.setNumeroQuadra(quadra.getNumeroQuadra());
									debitoACobrar.setNumeroLote(imovel.getLote());
									debitoACobrar.setNumeroSubLote(imovel.getSubLote());
									debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
									debitoACobrar.setRegistroAtendimento(null);
									debitoACobrar.setOrdemServico(null);
									debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
									debitoACobrar.setParcelamentoGrupo(null);
									debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
									debitoACobrar.setCobrancaForma(cobrancaForma);
									debitoACobrar.setDebitoTipo(debitoTipo);
									debitoACobrar.setUltimaAlteracao(new Date());
									debitoACobrar.setGeracaoDebito(new Date());
									// debitoACobrar
									// .setAnoMesReferenciaDebito(guiaPagamento
									// .getAnoMesReferenciaContabil());
									// debitoACobrar
									// .setFinanciamentoTipo(financiamentoTipo);
									// debitoACobrar
									// .setLancamentoItemContabil(lancamentoItemContabil);
									debitoTipo.setId(DebitoTipo.JUROS_MORA);
									debitoACobrar.setValorDebito(calcularAcrescimoPorImpontualidade.getValorJurosMora());

									// repositorioFaturamento.atualizarIndicadorMultaDeGuiaPagamento(guiaPagamento.getId());
									colecaoIdsGuiasPagamentosAtualizarIndicadorMulta.add(guiaPagamento.getId());

									// Inseri o débito a cobra geral e
									// recupera o id
									Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
									debitoACobrarGeral.setId(idDebitoACobrarGeral);

									// debitoACobrar.setId(idDebitoACobrar);
									debitoACobrar.setId(idDebitoACobrarGeral);
									debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);
									colecaoDebitoACobrarInserir.add(debitoACobrar);
									colecaoClienteDebitoACobrarInserir.addAll(this.getControladorCobranca()
													.obterColecaoClienteDebitoACobrar(debitoACobrar));
									colecaoDebitoACobrarCategoriaInserir.addAll(inserirDebitoACobrarCategoriaBatch(debitoACobrar,
													debitoACobrar.getImovel()));
								}

								/*
								 * Item 5.8.5 Caso o indicador de geração de atualização monetária
								 * corresponda a sim(1) e o valor da atualização
								 * monetária seja maior que zero e exista pagamento para a guia de
								 * pagamento com situação atual igual a classificado.
								 * Gera o débito a cobrar referente a atualização monetária.
								 */
								if(indicadorGeracaoAtualizacao.intValue() == ConstantesSistema.SIM.intValue()
												&& calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria().compareTo(
																new BigDecimal("0.00")) == 1
												&& indicadorExistePagamentoClassificadoGuiaPagamento){

									debitoTipo = new DebitoTipo();
									debitoTipo.setId(DebitoTipo.ATUALIZACAO_MONETARIA);

									obterDebitoTipo = repositorioFaturamento.obterDebitoTipo(debitoTipo.getId());

									FinanciamentoTipo financiamentoTipo = new FinanciamentoTipo();
									LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
									if(obterDebitoTipo[0] != null){
										financiamentoTipo.setId((Integer) obterDebitoTipo[0]);
									}
									if(obterDebitoTipo[1] != null){
										lancamentoItemContabil.setId((Integer) obterDebitoTipo[1]);
									}

									DebitoACobrar debitoACobrar = new DebitoACobrar();
									debitoACobrar.setImovel(imovel);
									// SB0003 - Formatar Referência da Cobrança do Débito
									formatarReferenciaDeCobrancaDebito(debitoACobrar, sistemaParametros, imovel.getId());
									debitoACobrar.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
									debitoACobrar.setNumeroPrestacaoDebito(numeroPrestacaoDebito);
									debitoACobrar.setNumeroPrestacaoCobradas(numeroPrestacaoCobradas);
									debitoACobrar.setLocalidade(localidade);
									debitoACobrar.setQuadra(quadra);
									debitoACobrar.setCodigoSetorComercial(setorComercial);
									debitoACobrar.setNumeroQuadra(quadra.getNumeroQuadra());
									debitoACobrar.setNumeroLote(imovel.getLote());
									debitoACobrar.setNumeroSubLote(imovel.getSubLote());
									debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
									debitoACobrar.setRegistroAtendimento(null);
									debitoACobrar.setOrdemServico(null);
									debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
									debitoACobrar.setParcelamentoGrupo(null);
									debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
									debitoACobrar.setCobrancaForma(cobrancaForma);
									debitoACobrar.setDebitoTipo(debitoTipo);
									debitoACobrar.setUltimaAlteracao(new Date());
									debitoACobrar.setGeracaoDebito(new Date());
									// debitoACobrar
									// .setAnoMesReferenciaDebito(guiaPagamento
									// .getAnoMesReferenciaContabil());
									// debitoACobrar
									// .setFinanciamentoTipo(financiamentoTipo);
									// debitoACobrar
									// .setLancamentoItemContabil(lancamentoItemContabil);

									// gerar debito a cobrar
									debitoACobrar.setValorDebito(calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria());

									// repositorioFaturamento.atualizarIndicadorMultaDeGuiaPagamento(guiaPagamento.getId());
									colecaoIdsGuiasPagamentosAtualizarIndicadorMulta.add(guiaPagamento.getId());

									// Inseri o débito a cobra geral e
									// recupera o id
									Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoACobrarGeral);
									debitoACobrarGeral.setId(idDebitoACobrarGeral);

									debitoACobrar.setId(idDebitoACobrarGeral);
									debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);
									colecaoDebitoACobrarInserir.add(debitoACobrar);
									colecaoClienteDebitoACobrarInserir.addAll(this.getControladorCobranca()
													.obterColecaoClienteDebitoACobrar(debitoACobrar));
									colecaoDebitoACobrarCategoriaInserir.addAll(inserirDebitoACobrarCategoriaBatch(debitoACobrar,
													debitoACobrar.getImovel()));
								}
							} // fim if da comparacao da data de
								// pagamento
						} // fim while contasiterator
					} // fim if colecaoguia

					if(colecaoIdsGuiasPagamentosAtualizarIndicadorMulta != null
									&& !colecaoIdsGuiasPagamentosAtualizarIndicadorMulta.isEmpty()){
						repositorioFaturamento.atualizarIndicadorMultaDeGuiaPagamento(colecaoIdsGuiasPagamentosAtualizarIndicadorMulta);
					}
				}
			}// fim while imovelporrotaiterator

			// Inserir os débitos a cobrar
			if(colecaoDebitoACobrarInserir != null && !colecaoDebitoACobrarInserir.isEmpty()){
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoACobrarInserir);
			}

			// Inseri os débitos a cobrar por categoria
			if(colecaoDebitoACobrarCategoriaInserir != null && !colecaoDebitoACobrarCategoriaInserir.isEmpty()){
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoACobrarCategoriaInserir);
			}

			// Inseri cliente débito a cobrar
			if(colecaoClienteDebitoACobrarInserir != null && !colecaoClienteDebitoACobrarInserir.isEmpty()){
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoClienteDebitoACobrarInserir);
			}

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

			return null;

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}

	}

	private void formatarReferenciaDeCobrancaDebito(DebitoACobrar debitoACobrar, SistemaParametro sistemaParametros, Integer idImovel)
					throws ErroRepositorioException{

		if(repositorioFaturamento.verificarExistenciaDeGrupoFaturamentoParaImovel(idImovel)){
			Integer mesFaturamento = sistemaParametros.getAnoMesFaturamento();
			debitoACobrar.setAnoMesCobrancaDebito(Util.somaMesAnoMesReferencia(mesFaturamento, 1));
		}else{
			debitoACobrar.setAnoMesCobrancaDebito(sistemaParametros.getAnoMesFaturamento());
		}

	}

	/**
	 * Este caso de uso gera os débitos a cobrar referentes aos acréscimos por impontualidade
	 * (multa, juros de mora e atualização monetária).
	 * [UC0302] – Gerar Débitos a Cobrar de Acréscimos por Impontualidade.
	 * 
	 * @author Leonardo Maranhão
	 * @date 20/04/2006, 31/08/2006
	 * @author eduardo henrique
	 * @date 07/07/2009 Alteração no mapeamento do pagamento e pagamentoGeral para apontamento para
	 *       GuiaPagamentoGeral. Alteracao para geração de
	 *       Débitos de Acréscimos, apenas para Pagamentos com identificação de Imóvel. Alteração
	 *       para definição correta de valor de débitos já
	 *       cobrados, para considerar somente débitos de tipo MULTA_IMPONTUALIDADE.
	 * @param idPagamento
	 *            Id do pagamento [obrigatório];
	 * @param indicadorGeracaoMulta
	 *            Indicador de geração da multa (indica deve ser gerado débito a cobrar para multa,
	 *            1-SIM, 2-NÃO);
	 * @param indicadorGeracaoJuros
	 *            Indicador de geração dos juros de mora (indica deve ser gerado débito a cobrar
	 *            para juros de mora, 1-SIM, 2-NÃO);
	 * @param indicadorGeracaoAtualizacao
	 *            Indicador de geração da atualização monetária (indica deve ser gerado débito a
	 *            cobrar para atualização, 1-SIM, 2-NÃO);
	 * @throws ControladorException
	 */
	@Deprecated
	public boolean gerarDebitosACobrarDeAcrescimosPorImpontualidadeOLD(Pagamento pagamento) throws ControladorException{

		// Utilizar: gerarDebitosACobrarDeAcrescimosPorImpontualidadeBancoDeDados

		try{
			pagamento = this.repositorioFaturamento.consultarPagamento(pagamento.getId());
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		// 2. Atribuir aos indicadores de geração da multa, de geração de juros de mora e de geração
		// da atualização monetária, os valores dos parâmetros da tabela PARAMETRO_SISTEMA para
		// PASI_CDPARAMETRO = ‘P_COBRAR_MULTA_POR_IMPONTUALIDADE’,
		// ‘P_COBRAR_JUROS_POR_IMPONTUALIDADE’ e ’P_COBRAR_CORRECAO_POR_IMPONTUALIDADE’,
		// respectivamente
		Short indicadorGeracaoMulta = Short.valueOf(ParametroCobranca.P_COBRAR_MULTA_POR_IMPONTUALIDADE.executar());
		Short indicadorGeracaoJuros = Short.valueOf(ParametroCobranca.P_COBRAR_JUROS_POR_IMPONTUALIDADE.executar());
		Short indicadorGeracaoAtualizacao = Short.valueOf(ParametroCobranca.P_COBRAR_CORRECAO_POR_IMPONTUALIDADE.executar());

		// 3. O sistema identifica o imóvel através do Id do pagamento, a partir
		// da tabela IMOVEL, QUADRA e ROTA.
		Imovel imovel = pagamento.getImovel();

		// Caso Imóvel seja nulo, trata-se de documento gerado para o cliente
		if(imovel == null){
			return false;
		}

		// 4. Para o imóvel selecionado o sistema:
		// 4.1. Obtém a principal categoria do imóvel, <<Inclui>> [UC0306 -
		// Obter Principal Categoria do Imóvel];
		Categoria principalCategoria = getControladorImovel().obterPrincipalCategoriaImovel(imovel.getId());

		/**
		 * 4.2. Caso na principal categoria do imóvel esteja indicado que não deve ser gerado
		 * acréscimos por impontualidade para a categoria
		 * (CATG_ICCOBRANCAACRESCIMOS=2 (NÃO) da tabela CATEGORIA), retornar para o caso de uso que
		 * chamou esta funcionalidade
		 */
		if(principalCategoria.getIndicadorCobrancaAcrescimos().equals(ConstantesSistema.NAO)){
			return false;
		}
		/**
		 * 4.3. Caso na principal categoria do imóvel esteja indicado que somente deve ser gerado
		 * acréscimos por impontualidade para a categoria no
		 * encerramento da arrecadação (CATG_ICCOBRANCAACRESCIMOS=3 (Encerramento da Arrecadação) da
		 * tabela CATEGORIA), retornar para o caso de uso
		 * que chamou esta funcionalidade;
		 */
		// Retirado do caso de uso
		//
		// if(principalCategoria.getIndicadorCobrancaAcrescimos().equals(ConstantesSistema.ENCERRAMENTO_ARRECADACAO)){
		// return false;
		// }
		/**
		 * 4.4. Caso o imóvel possua cliente responsável (existe ocorrência na tabela CLIENTE_IMOVEL
		 * com IMOV_ID da tabela IMOVEL com CRTP_ID com o
		 * valor correspondente a responsável e CLIM_DTRELACAOFIM com o valor nulo):
		 */
		Short indicadorCobrancaAcrescimos = getControladorImovel().obterIndicadorGeracaoAcrescimosClienteImovel(imovel.getId());

		/**
		 * 4.4.1. Caso esteja indicado que não deve ser gerado acréscimos por impontualidade para o
		 * cliente (CLIE_ICCOBRANCAACRESCIMOS=2 (NÃO) da
		 * tabela CLIENTE com CLIE_ID da tabela CLIENTE_MOVEL), retornar para o caso de uso que
		 * chamou esta funcionalidade;
		 */
		if(indicadorCobrancaAcrescimos != null && indicadorCobrancaAcrescimos.equals(ConstantesSistema.NAO)){
			return false;
		}

		/**
		 * 4.4.2. Caso esteja indicado que somente deve ser gerado acréscimos por impontualidade
		 * para o cliente no encerramento da arrecadação
		 * (CLIE_ICCOBRANCAACRESCIMOS=3 (Encerramento da Arrecadação) da tabela CLIENTE com CLIE_ID
		 * da tabela CLIENTE_MOVEL), retornar para o caso de
		 * uso que chamou esta funcionalidade;
		 */
		// Retirado do caso de uso
		//
		// if(indicadorCobrancaAcrescimos != null &&
		// (indicadorCobrancaAcrescimos.equals(ConstantesSistema.ENCERRAMENTO_ARRECADACAO))){
		// return false;
		// }

		/**
		 * 4.5. Caso o pagamento seja referente a uma conta (CNTA_ID da tabela PAGAMENTO diferente
		 * de nulo), o sistema seleciona a conta:
		 */
		if(pagamento.getConta() != null){
			Conta conta = pagamento.getConta();
			/**
			 * 4.5.1. Caso a conta esteja em revisão (CNTA_DTREVISAO com o valor diferente de nulo),
			 * retornar para o caso de uso que chamou esta
			 * funcionalidade;
			 */
			if(conta.getDataRevisao() != null){
				return false;
			}

			/**
			 * 4.5.2. Seleciona os pagamentos para a conta e guarda a menor data de pagamento
			 * (PGMT_DTPAGAMENTO) dentre as linhas selecionadas, o
			 * ano/mês de referência da arrecadação do pagamento selecionado
			 * (PGMT_AMREFERENCIAARRECADACAO) e a situação atual do pagamento
			 * (PGST_IDATUAL) (a partir da tabela PAGAMENTO com CNTA_ID=CNTA_ID da tabela CONTA ou
			 * com IMOV_ID=IMOV_ID e
			 * PGMT_AMREFERENCIAPAGAMENTO=CNTA_AMREFERENCIACONTA da tabela CONTA), [FS0001 –
			 * Verificar existência de pagamentos];
			 */
			Set<Pagamento> pagamentos = conta.getPagamentos();
			Date dataPagamentoSelecionada = null;
			int anoMesReferenciaArrecadacao = -1;
			Pagamento pagamentoSelecionado = null;
			for(Pagamento pagamento2 : pagamentos){
				Date dataPag = pagamento2.getDataPagamento();
				if(dataPagamentoSelecionada == null || dataPag.before(dataPagamentoSelecionada)){
					dataPagamentoSelecionada = dataPag;
					anoMesReferenciaArrecadacao = pagamento2.getAnoMesReferenciaArrecadacao();
					pagamentoSelecionado = pagamento2;
				}
			}

			/**
			 * 4.5.3. Caso a forma de arrecadação do pagamento da conta tenha sido “Débito
			 * Automático” (ARFM_ID da tabela PAGAMENTO), retornar para o
			 * caso de uso que chamou esta funcionalidade.
			 */
			if(pagamentoSelecionado.getArrecadacaoForma().getId() != null
							&& pagamentoSelecionado.getArrecadacaoForma().getId().equals(ArrecadacaoForma.DEBITO_AUTOMATICO)){
				return false;
			}

			/**
			 * 4.5.4. Calcula os acréscimos por impontualidade <<Inclui>> [UC0216 – Calcular
			 * Acréscimos por Impontualidade] passando os seguintes
			 * parâmetros: 4.5.4.1. Ano/mês de referência da conta (CNTA_AMREFERENCIACONTA);
			 * 4.5.4.2. Data de vencimento (CNTA_DTVENCIMENTOCONTA);
			 * 4.5.4.3. Data de pagamento; 4.5.4.4. Valor da conta (CNTA_VLAGUA + CNTA_VLESGOTO +
			 * CNTA_VLDEBITOS - CNTA_VLCREDITOS); 4.5.4.5. Valor
			 * das multas cobradas (SUM(DBCB_VLPRESTACAO) da tabela DEBITO_COBRADO com CNTA_ID da
			 * tabela CONTA e DBTP_ID com o valor correspondente a
			 * multa por impontualidade da tabela DEBITO_TIPO); 4.5.4.6. Indicador de que já cobrou
			 * multa (CNTA_ICCOBRANCAMULTA).
			 */

			SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

			BigDecimal valorDebitosConta = calcularValorTotalMultasCobradasConta(conta.getDebitoCobrados());
			CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidadeHelper = getControladorCobranca()
							.calcularAcrescimoPorImpontualidadeBancoDeDados(conta.getReferencia(), conta.getDataVencimentoConta(),
											dataPagamentoSelecionada, conta.getValorTotalContaBigDecimal(), valorDebitosConta,
											conta.getIndicadorCobrancaMulta(),
											Integer.toString(pagamentoSelecionado.getAnoMesReferenciaArrecadacao()), conta.getId(), null,
											null, ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM);

			/**
			 * 4.5.5. Caso o indicador de geração da multa corresponda a 1 (SIM) e o valor da multa
			 * retornado pelo [UC0216] seja maior que zero, o
			 * sistema:
			 */
			if(indicadorGeracaoMulta.intValue() == ConstantesSistema.SIM.intValue()
							&& calcularAcrescimoPorImpontualidadeHelper.getValorMulta().compareTo(BigDecimal.ZERO) > 0){
				DebitoTipo debitoTipo = new DebitoTipo();
				debitoTipo.setId(DebitoTipo.MULTA_IMPONTUALIDADE);
				/**
				 * 4.5.5.1. Gera o débito a cobrar referente a multa [SB0001 – Gerar Débito a
				 * Cobrar] passando o valor da multa, o ano/mês de
				 * referência do débito a cobrar (CNTA_AMREFERENCIACONTA) e o tipo do débito com o
				 * valor correspondente a “multa” da tabela
				 * DEBITO_TIPO;
				 */
				criarDebitoACobrar(imovel, calcularAcrescimoPorImpontualidadeHelper, sistemaParametros, debitoTipo,
								calcularAcrescimoPorImpontualidadeHelper.getValorMulta(), conta.getReferencia());
				/**
				 * 4.5.5.2. Atualiza o indicador de que já cobrou multa da conta com o valor 1 (SIM)
				 * (CNTA_ICCOBRANCAMULTA=1 na tabela CONTA).
				 */
				Collection<Integer> colecaoIdsContas = new ArrayList<Integer>();
				colecaoIdsContas.add(conta.getId());
				try{
					repositorioFaturamento.atualizarIndicadorMultaDeConta(colecaoIdsContas);
				}catch(ErroRepositorioException e){
					// LEO como tratar essa excecao?
					throw new ControladorException(e.getMessage());
				}
			}
			/**
			 * 4.5.6. Caso o indicador de geração dos juros de mora corresponda a 1 (SIM) e o valor
			 * dos juros de mora retornado pelo [UC0216] seja
			 * maior que zero, o sistema gera o débito a cobrar referente a juros de mora [SB0001 –
			 * Gerar Débito a Cobrar] passando o valor dos juros
			 * de mora, o ano/mês de referência do débito a cobrar (CNTA_AMREFERENCIACONTA) e o tipo
			 * do débito com o valor correspondente a “juros de
			 * mora” da tabela DEBITO_TIPO;
			 */
			if(indicadorGeracaoJuros.intValue() == ConstantesSistema.SIM.intValue()
							&& calcularAcrescimoPorImpontualidadeHelper.getValorJurosMora().compareTo(BigDecimal.ZERO) > 0){
				DebitoTipo debitoTipo = new DebitoTipo();
				debitoTipo.setId(DebitoTipo.JUROS_MORA);

				criarDebitoACobrar(imovel, calcularAcrescimoPorImpontualidadeHelper, sistemaParametros, debitoTipo,
								calcularAcrescimoPorImpontualidadeHelper.getValorJurosMora(), conta.getReferencia());
			}

			/**
			 * 4.5.7. Caso o indicador de geração de atualização monetária ou tarifária corresponda
			 * a 1 (SIM) e o valor da atualização monetária ou
			 * tarifária retornado pelo [UC0216] seja maior que zero, o sistema gera o débito a
			 * cobrar referente a atualização monetária [SB0001 –
			 * Gerar Débito a Cobrar] passando o valor da atualização monetária, o ano/mês de
			 * referência do débito a cobrar (CNTA_AMREFERENCIACONTA) e
			 * o tipo do débito com o valor correspondente a “atualização monetária ou tarifária” da
			 * tabela DEBITO_TIPO;
			 */
			if(indicadorGeracaoAtualizacao.intValue() == ConstantesSistema.SIM.intValue()
							&& calcularAcrescimoPorImpontualidadeHelper.getValorAtualizacaoMonetaria().compareTo(BigDecimal.ZERO) > 0){
				DebitoTipo debitoTipo = new DebitoTipo();
				debitoTipo.setId(DebitoTipo.ATUALIZACAO_MONETARIA);

				criarDebitoACobrar(imovel, calcularAcrescimoPorImpontualidadeHelper, sistemaParametros, debitoTipo,
								calcularAcrescimoPorImpontualidadeHelper.getValorAtualizacaoMonetaria(), conta.getReferencia());
			}

			/**
			 * 4.6. Caso contrário, caso o pagamento seja referente a uma guia de pagamento (GPAG_ID
			 * da tabela PAGAMENTO diferente de nulo), o sistema
			 * seleciona a prestação paga da guia de pagamento:
			 */
		}else if(pagamento.getGuiaPagamentoGeral() != null && pagamento.getGuiaPagamentoGeral().getGuiaPagamento() != null){
			GuiaPagamento guiaPagamento = pagamento.getGuiaPagamentoGeral().getGuiaPagamento();
			Set<GuiaPagamentoPrestacao> guiasPrest = guiaPagamento.getGuiasPagamentoPrestacao();

			for(GuiaPagamentoPrestacao guiaPrest : guiasPrest){

				/**
				 * 4.6.1. Caso a guia de pagamento seja entrada de parcelamento (DBTP_ID
				 * corrspondente a “entrada de parcelamento”), retornar para o
				 * caso de uso que chamou esta funcionalidade;
				 */
				if(guiaPrest.getDebitoTipo().getId().intValue() == DebitoTipo.ENTRADA_PARCELAMENTO){
					return false;
				}

				if(pagamento.getNumeroPrestacao().intValue() != guiaPrest.getComp_id().getNumeroPrestacao().intValue()){
					continue;
				}

				/**
				 * 4.6.2. Selecionar os pagamentos para a guia de pagamento e guardar a menor data
				 * de pagamento (PGMT_DTPAGAMENTO) dentre as linhas
				 * selecionadas, o ano/mês de referência da arrecadação do pagamento selecionado
				 * (PGMT_AMREFERENCIAARRECADACAO) e a situação atual do
				 * pagamento (PGST_IDATUAL) (a partir da tabela PAGAMENTO com GPAG_ID=GPAG_ID e
				 * PGMT_NNPRESTACAO = GPPR_NNPRESTACAO da tabela
				 * GUIA_PAGAMENTO_PRESTACAO) [FS0001 – Verificar existência de pagamentos];
				 */
				Set<Pagamento> pagamentos = guiaPagamento.getPagamentos();
				Date dataPagamentoSelecionada = null;
				int anoMesReferenciaArrecadacao = -1;
				Pagamento pagamentoSelecionado = null;
				for(Pagamento pagamento2 : pagamentos){
					Date dataPag = pagamento2.getDataPagamento();
					if(dataPagamentoSelecionada == null || dataPag.before(dataPagamentoSelecionada)){
						dataPagamentoSelecionada = dataPag;
						anoMesReferenciaArrecadacao = pagamento2.getAnoMesReferenciaArrecadacao();
						pagamentoSelecionado = pagamento2;
					}
				}

				/**
				 * 4.6.3. Calcula os acréscimos por impontualidade <<Inclui>> [UC0216 – Calcular
				 * Acréscimos por Impontualidade] passando os seguintes
				 * parâmetros: 4.6.3.1. Ano/mês de referência da guia de pagamento
				 * (GPPR_AMREFERENCIAFATURAMENTO); 4.6.3.2. Data de vencimento
				 * (GPPR_DTVENCIMENTO); 4.6.3.3. Data de pagamento; 4.6.3.4. Valor da guia de
				 * pagamento (GPPR_VLPRESTACAO); 4.6.3.5. Valor das multas
				 * com o valor zero; 4.6.3.6. Indicador de que já cobrou multa
				 * (GPPR_ICCOBRANCAMULTA).
				 */
				CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidadeHelper = getControladorCobranca()
								.calcularAcrescimoPorImpontualidadeBancoDeDados(guiaPrest.getAnoMesReferenciaFaturamento(),
												guiaPrest.getDataVencimento(), dataPagamentoSelecionada, guiaPrest.getValorPrestacao(),
												BigDecimal.ZERO, guiaPrest.getIndicadorCobrancaMulta(),
												Integer.toString(pagamentoSelecionado.getAnoMesReferenciaArrecadacao()), null, null, null,
												ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM);

				SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

				/**
				 * 4.6.4. Caso o indicador de geração da multa corresponda a 1 (SIM) e o valor da
				 * multa retornado pelo [UC0216] seja maior que zero, o
				 * sistema:
				 */
				if(indicadorGeracaoMulta.intValue() == ConstantesSistema.SIM.intValue()
								&& calcularAcrescimoPorImpontualidadeHelper.getValorMulta().compareTo(BigDecimal.ZERO) > 0){
					DebitoTipo debitoTipo = new DebitoTipo();
					debitoTipo.setId(DebitoTipo.MULTA_IMPONTUALIDADE);
					/**
					 * 4.6.4.1. Gera o débito a cobrar referente a multa [SB0001 – Gerar Débito a
					 * Cobrar] passando o valor da multa, o ano/mês de
					 * referência do débito a cobrar (GPPR_AMREFERENCIAFATURAMENTO) e o tipo do
					 * débito com o valor correspondente a multa da tabela
					 * DEBITO_TIPO;
					 */
					criarDebitoACobrar(imovel, calcularAcrescimoPorImpontualidadeHelper, sistemaParametros, debitoTipo,
									calcularAcrescimoPorImpontualidadeHelper.getValorMulta(), guiaPrest.getAnoMesReferenciaFaturamento());
					/**
					 * 4.6.4.2. Atualiza o indicador de que já cobrou multa da guia de pagamento com
					 * o valor 1 (SIM) (GPPR_ICCOBRANCAMULTA=1 na tabela
					 * GUIA_PAGAMENTO_PRESTACAO).
					 */
					Collection<GuiaPagamentoPrestacaoPK> colecaoIdsGuiasPagamentosAtualizarIndicadorMulta = new ArrayList<GuiaPagamentoPrestacaoPK>();
					colecaoIdsGuiasPagamentosAtualizarIndicadorMulta.add(guiaPrest.getComp_id());
					try{
						repositorioFaturamento
										.atualizarIndicadorMultaDeGuiaPagamentoPrestacao(colecaoIdsGuiasPagamentosAtualizarIndicadorMulta);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}

				/**
				 * 4.6.5. Caso o indicador de geração dos juros de mora corresponda a 1 (SIM) e o
				 * valor dos juros de mora retornado pelo [UC0216] seja
				 * maior que zero, o sistema gera o débito a cobrar referente a juros de mora
				 * [SB0001 – Gerar Débito a Cobrar] passando o valor dos
				 * juros de mora, o ano/mês de referência do débito a cobrar
				 * (GPPR_AMREFERENCIACONTABIL) e o tipo do débito com o valor correspondente
				 * a juros de mora da tabela DEBITO_TIPO;
				 * GPPR_AMREFERENCIACONTABIL nao existe nao tabela guia_pagamento_prestacao - usando
				 * gppr_amreferenciafaturamento
				 */
				if(indicadorGeracaoJuros.intValue() == ConstantesSistema.SIM.intValue()
								&& calcularAcrescimoPorImpontualidadeHelper.getValorJurosMora().compareTo(BigDecimal.ZERO) > 0){
					DebitoTipo debitoTipo = new DebitoTipo();
					debitoTipo.setId(DebitoTipo.JUROS_MORA);

					criarDebitoACobrar(imovel, calcularAcrescimoPorImpontualidadeHelper, sistemaParametros, debitoTipo,
									calcularAcrescimoPorImpontualidadeHelper.getValorJurosMora(),
									guiaPrest.getAnoMesReferenciaFaturamento());
				}

				/**
				 * 4.6.6. Caso o indicador de geração de atualização monetária corresponda a 1 (SIM)
				 * e o valor da atualização monetária retornado pelo
				 * [UC0216] seja maior que zero, o sistema gera o débito a cobrar referente a
				 * atualização monetária [SB0001 – Gerar Débito a Cobrar]
				 * passando o valor da atualização monetária, o ano/mês de referência do débito a
				 * cobrar (GPPR_AMREFERENCIACONTABIL) e o tipo do
				 * débito com o valor correspondente a atualização monetária da tabela DEBITO_TIPO;
				 * GPPR_AMREFERENCIACONTABIL nao existe nao tabela guia_pagamento_prestacao - usando
				 * gppr_amreferenciafaturamento
				 */
				if(indicadorGeracaoAtualizacao.intValue() == ConstantesSistema.SIM.intValue()
								&& calcularAcrescimoPorImpontualidadeHelper.getValorAtualizacaoMonetaria().compareTo(BigDecimal.ZERO) > 0){
					DebitoTipo debitoTipo = new DebitoTipo();
					debitoTipo.setId(DebitoTipo.ATUALIZACAO_MONETARIA);

					criarDebitoACobrar(imovel, calcularAcrescimoPorImpontualidadeHelper, sistemaParametros, debitoTipo,
									calcularAcrescimoPorImpontualidadeHelper.getValorAtualizacaoMonetaria(),
									guiaPrest.getAnoMesReferenciaFaturamento());
				}
			}
		}
		return true;

	}

	/**
	 * @author Saulo Lima
	 * @date 22/08/2012
	 *       Método criado para chamar a Function do Banco de Dados.
	 * @param pagamento
	 * @throws ControladorException
	 */
	public Collection<Integer> gerarDebitosACobrarDeAcrescimosPorImpontualidadeBancoDeDados(Pagamento pagamento, Date dataEmissaoDocumento)
					throws ControladorException{

		// Calendar tempo = Calendar.getInstance();

		Object[] resultado = null;

		try{
			resultado = repositorioFaturamento
							.gerarDebitosACobrarDeAcrescimosPorImpontualidadeBancoDeDados(pagamento, dataEmissaoDocumento);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		Collection<Integer> idsDebitosACobrar = new ArrayList<Integer>();

		if(resultado[4] != null){
			sessionContext.setRollbackOnly();
			String mensagemErro = (String) resultado[4];
			throw new ControladorException(mensagemErro);
		}

		if(resultado[0] != null){
			// Retorno não utilizado
		}

		if(resultado[1] != null){
			Integer idDebitoMulta = (Integer) resultado[1];
			idsDebitosACobrar.add(idDebitoMulta);
		}

		if(resultado[2] != null){
			Integer idDebitoJuros = (Integer) resultado[2];
			idsDebitosACobrar.add(idDebitoJuros);
		}

		if(resultado[3] != null){
			Integer idDebitoAtualizacao = (Integer) resultado[3];
			idsDebitosACobrar.add(idDebitoAtualizacao);
		}

		// System.out.println("### Performance ### :::::       gerarDebitos_Parte1111  :: " +
		// Util.calcularDiferencaTempo(tempo));

		return idsDebitosACobrar;
	}

	/**
	 * @param idsDebitosACobrar
	 * @throws ControladorException
	 */
	public void registrarLancamentoContabilDebitoACobrar(Collection<Integer> idsDebitosACobrar) throws ControladorException{

		try{

			if(!Util.isVazioOrNulo(idsDebitosACobrar)){

				Collection<DebitoACobrar> colecao = repositorioFaturamento.pesquisarDebitoACobrar(idsDebitosACobrar);

				for(DebitoACobrar debitoACobrar : colecao){

					this.getControladorContabil().registrarLancamentoContabil(debitoACobrar, OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);

				}

			}

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);

		}

	}

	/**
	 * @author Leonardo Maranhão
	 * @param imovel
	 * @param calcularAcrescimoPorImpontualidadeHelper
	 * @param sistemaParametros
	 * @param debitoTipo
	 * @param valorDebito
	 * @param referencia
	 * @throws ControladorException
	 */
	public void criarDebitoACobrar(Imovel imovel, CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidadeHelper,
					SistemaParametro sistemaParametros, DebitoTipo debitoTipo, BigDecimal valorDebito, Integer referencia)
					throws ControladorException{

		/**
		 * [SB0001] - Gerar Débito a Cobrar
		 * 1. Inclui o débito a cobrar na tabela DEBITO_A_COBRAR_GERAL com os seguintes valores:
		 */
		DebitoACobrarGeral debitoGeral = new DebitoACobrarGeral();
		debitoGeral.setIndicadorHistorico(DebitoACobrarGeral.INDICADOR_NAO_POSSUI_HISTORICO);
		debitoGeral.setUltimaAlteracao(new Date());

		/**
		 * 2. Inclui o débito a cobrar na tabela DEBITO_A_COBRAR com os seguintes valores:
		 */
		DebitoACobrar debitoACobrar = new DebitoACobrar();
		debitoGeral.setDebitoACobrar(debitoACobrar);
		debitoACobrar.setImovel(imovel);
		debitoACobrar.setDebitoTipo(debitoTipo);
		debitoACobrar.setGeracaoDebito(new Date());
		debitoACobrar.setAnoMesReferenciaDebito(referencia);
		debitoACobrar.setAnoMesCobrancaDebito(sistemaParametros.getAnoMesArrecadacao());
		debitoACobrar.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
		debitoACobrar.setValorDebito(valorDebito);
		debitoACobrar.setNumeroPrestacaoDebito(Short.parseShort("1"));
		debitoACobrar.setNumeroPrestacaoCobradas(Short.parseShort("0"));
		debitoACobrar.setLocalidade(imovel.getLocalidade());
		debitoACobrar.setQuadra(imovel.getQuadra());
		debitoACobrar.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
		debitoACobrar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
		debitoACobrar.setNumeroLote(imovel.getLote());
		debitoACobrar.setNumeroSubLote(imovel.getSubLote());
		debitoACobrar.setPercentualTaxaJurosFinanciamento(BigDecimal.ZERO);
		debitoACobrar.setRegistroAtendimento(null);
		debitoACobrar.setOrdemServico(null);

		// pesquisa dados do DebitoTipo
		try{
			debitoTipo = repositorioCobranca.pesquisarDebitoTipo(debitoTipo.getId());
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		debitoACobrar.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
		debitoACobrar.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());

		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
		debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

		debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
		debitoACobrar.setParcelamentoGrupo(null);

		CobrancaForma cobrancaForma = new CobrancaForma();
		cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);
		debitoACobrar.setCobrancaForma(cobrancaForma);

		Integer idDebitoACobrarGeral = (Integer) getControladorUtil().inserir(debitoGeral);
		debitoGeral.setId(idDebitoACobrarGeral);

		debitoACobrar.setId(idDebitoACobrarGeral);
		debitoACobrar.setDebitoACobrarGeral(debitoGeral);
		debitoACobrar.setUltimaAlteracao(new Date());
		getControladorUtil().inserir(debitoACobrar);

		// Recupera Categorias por Imóvel
		Collection<Categoria> colecaoCategoria = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
		// Recupera Valores por Categorias
		/**
		 * 2.2. <<Inclui>> [UC0185 – Obter Valor por Categoria].
		 */
		Collection<BigDecimal> colecaoValoresCategorias = this.getControladorImovel().obterValorPorCategoria(colecaoCategoria,
						debitoACobrar.getValorTotal());
		// Insere débito a cobrar por categoria
		/**
		 * 2.3. Inclui, na tabela DEBITO_A_COBRAR_CATEGORIA, a(s) categoria(s) e sua(s)
		 * respectiva(s) quantidade(s) de economia da lista retornada
		 * pelo [UC0108] e os valores retornados pelo [UC0185] para cada categoria:
		 */
		inserirDebitoACobrarCategoria(colecaoCategoria, colecaoValoresCategorias, debitoACobrar);

		// INSERIR CLIENTE_DEBITO_A_COBRAR
		this.getControladorCobranca().inserirClienteDebitoACobrar(debitoACobrar);

		/**
		 * 3. Contabilizar o débito a cobrar para cada acréscimo gerado. <<Inclui>> [UC0207 -
		 * Gerar/Atualizar Resumo de Faturamento];
		 */
		try{
			DebitoACobrar debitoACobrarBD;
			debitoACobrarBD = repositorioFaturamento.pesquisarDebitoACobrar(debitoACobrar.getId());
			getControladorContabil().registrarLancamentoContabil(debitoACobrarBD, OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Insere Mensagem na Conta
	 * [UC0330] Inserir Mensagem da Conta
	 * 
	 * @author Tiago Moreno
	 * @date 03/05/2006
	 * @throws ControladorException
	 */

	public void atualizarMensagemConta(ContaMensagem contaMensagem) throws ControladorException{

		FiltroContaMensagem filtroContaMensagem = new FiltroContaMensagem();

		filtroContaMensagem.adicionarParametro(new ParametroSimples(FiltroContaMensagem.ID, contaMensagem.getId()));
		Collection colecaoContaMensagem = getControladorUtil().pesquisar(filtroContaMensagem, ContaMensagem.class.getName());

		ContaMensagem contaMensagemNaBase = (ContaMensagem) Util.retonarObjetoDeColecao(colecaoContaMensagem);

		if(contaMensagemNaBase.getUltimaAlteracao().after(contaMensagem.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		contaMensagem.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(contaMensagem);

	}

	public void inserirMensagemConta(ContaMensagem contaMensagem, String[] setorComercial) throws ControladorException{

		if(contaMensagem != null){

			FiltroSistemaParametro filtroSistemaParametro = new FiltroSistemaParametro();
			filtroSistemaParametro.adicionarParametro(new MenorQue(FiltroSistemaParametro.ANO_MES_REFERECIA_ARRECADACAO, contaMensagem
							.getAnoMesRreferenciaFaturamento()));
			Collection colecaoSistemaParametro = getControladorUtil().pesquisar(filtroSistemaParametro, SistemaParametro.class.getName());

			if(colecaoSistemaParametro != null && !colecaoSistemaParametro.isEmpty()){

				FiltroContaMensagem filtroContaMensagem = new FiltroContaMensagem();

				if(contaMensagem.getAnoMesRreferenciaFaturamento() != null && !contaMensagem.getAnoMesRreferenciaFaturamento().equals("")){

					filtroContaMensagem.adicionarParametro(new ParametroSimples(FiltroContaMensagem.ANO_MES_REFERECIA_FATURAMENTO,
									contaMensagem.getAnoMesRreferenciaFaturamento()));
				}

				if(contaMensagem.getFaturamentoGrupo() != null && !contaMensagem.getFaturamentoGrupo().getId().equals("")){

					filtroContaMensagem.adicionarParametro(new ParametroSimples(FiltroContaMensagem.GRUPO_FATURAMENTO_ID, contaMensagem
									.getFaturamentoGrupo().getId()));
					filtroContaMensagem.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupo");
				}else{

					filtroContaMensagem.adicionarParametro(new ParametroNulo(FiltroContaMensagem.GRUPO_FATURAMENTO_ID));
					filtroContaMensagem.adicionarCaminhoParaCarregamentoEntidade("faturamentoGrupo");
				}

				if(contaMensagem.getGerenciaRegional() != null && !contaMensagem.getGerenciaRegional().getId().equals("")){

					filtroContaMensagem.adicionarParametro(new ParametroSimples(FiltroContaMensagem.GERENCIA_REGIONAL_ID, contaMensagem
									.getGerenciaRegional().getId()));
					filtroContaMensagem.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				}else{

					filtroContaMensagem.adicionarParametro(new ParametroNulo(FiltroContaMensagem.GERENCIA_REGIONAL_ID));
					filtroContaMensagem.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				}

				if(contaMensagem.getLocalidade() != null && !contaMensagem.getLocalidade().getId().equals("")){

					filtroContaMensagem.adicionarParametro(new ParametroSimples(FiltroContaMensagem.LOCALIDADE_ID, contaMensagem
									.getLocalidade().getId()));
					filtroContaMensagem.adicionarCaminhoParaCarregamentoEntidade("localidade");
				}else{

					filtroContaMensagem.adicionarParametro(new ParametroNulo(FiltroContaMensagem.LOCALIDADE_ID));
					filtroContaMensagem.adicionarCaminhoParaCarregamentoEntidade("localidade");
				}

				if(setorComercial != null){

					for(int i = 0; i < setorComercial.length; i++){

						if(!setorComercial[i].equals("")){
							filtroContaMensagem.adicionarParametro(new ParametroSimples(FiltroContaMensagem.SETOR_COMERCIAL_ID,
											setorComercial[i]));
							filtroContaMensagem.adicionarCaminhoParaCarregamentoEntidade("setorComercial");

							Collection colecaoContaMenssagem = getControladorUtil().pesquisar(filtroContaMensagem,
											ContaMensagem.class.getName());

							if(colecaoContaMenssagem != null && !colecaoContaMenssagem.isEmpty()){

								String descricaoSetor = "";

								FiltroSetorComercial filtroSetorComercial = new FiltroSetorComercial();
								filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.ID, Integer
												.valueOf(setorComercial[i])));
								Collection colecaoSetorComercial = getControladorUtil().pesquisar(filtroSetorComercial,
												SetorComercial.class.getName());

								descricaoSetor = ((SetorComercial) Util.retonarObjetoDeColecao(colecaoSetorComercial)).getDescricao();
								throw new ControladorException("atencao.mensagem_setor_ja_existe", null, descricaoSetor);
							}else{
								SetorComercial setor = new SetorComercial();
								setor.setId(Integer.valueOf(setorComercial[i]));
								contaMensagem.setSetorComercial(setor);
								getControladorUtil().inserir(contaMensagem);
							}
						}

					}

				}else{

					filtroContaMensagem.adicionarParametro(new ParametroNulo(FiltroContaMensagem.SETOR_COMERCIAL_ID));
					filtroContaMensagem.adicionarCaminhoParaCarregamentoEntidade("setorComercial");

					Collection colecaoContaMenssagem = getControladorUtil().pesquisar(filtroContaMensagem, ContaMensagem.class.getName());

					if(colecaoContaMenssagem != null && !colecaoContaMenssagem.isEmpty()){
						throw new ControladorException("atencao.mensagem_ja_existe");
					}else{
						getControladorUtil().inserir(contaMensagem);
					}

				}

			}else{

				FiltroSistemaParametro filtroSistemaParametro2 = new FiltroSistemaParametro();

				Collection colecaoSistemaParametro2 = getControladorUtil().pesquisar(filtroSistemaParametro2,
								SistemaParametro.class.getName());
				SistemaParametro sistemaParametro = (SistemaParametro) colecaoSistemaParametro2.iterator().next();

				String referenciaMinima = (String) Util.formatarAnoMesParaMesAno(sistemaParametro.getAnoMesFaturamento());

				throw new ControladorException("atencao.referencia_faturamento_inferior", null, referenciaMinima);
			}
		}
	}

	/**
	 * Consulta as contas por cliente para geração de fatura do cliente responsável
	 * 
	 * @author Luciano Galvao
	 * @date 26/06/2013
	 */
	public Map<Cliente, Collection<Conta>> consultarContasParaGerarFaturaClienteResponsavel(Collection<Cliente> clientes,
					GerarFaturaClienteResponsavelHelper gerarFaturaClienteResponsavelHelper) throws ControladorException{

		Map<Cliente, Collection<Conta>> mapClienteContas = new HashMap<Cliente, Collection<Conta>>();
		Collection<Conta> contasDoCliente = null;
		FiltroClienteImovel filtroClienteImovel = null;
		Collection<ClienteImovel> clientesImoveis = null;

		try{

			if(!Util.isVazioOrNulo(clientes)){

				// Percorre a listagem dos clienteSelecionados
				for(Cliente cliente : clientes){

					filtroClienteImovel = new FiltroClienteImovel();
					filtroClienteImovel.adicionarParametro(new ParametroSimples(
									FiltroClienteImovel.IMOVEL_INDICADOR_EMISSAO_EXTRATO_FATURAMENTO, ConstantesSistema.SIM));
					filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.CLIENTE_ID, cliente.getId()));
					filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.CLIENTE_RELACAO_TIPO_ID,
									ClienteRelacaoTipo.RESPONSAVEL.intValue()));
					filtroClienteImovel.adicionarParametro(new ParametroNulo(FiltroClienteImovel.DATA_FIM_RELACAO));
					filtroClienteImovel.setCampoOrderBy(FiltroClienteImovel.CLIENTE_ID, FiltroClienteImovel.IMOVEL_ID);

					clientesImoveis = this.getControladorUtil().pesquisar(filtroClienteImovel, ClienteImovel.class.getName());

					if(!Util.isVazioOrNulo(clientesImoveis)){

						contasDoCliente = new ArrayList<Conta>();

						for(ClienteImovel clienteImovel : clientesImoveis){
							Imovel imovel = clienteImovel.getImovel();

							// [FS0006] – Verifica existência de imóveis de localidades associadas a
							// concessionárias diversas
							Integer quantidadeConcessionarias = repositorioFaturamento
											.verificaExistenciaLocalidadesAssociadaConcessionariasDiversas(
															gerarFaturaClienteResponsavelHelper.getPeriodoReferenciaContasInicial(),
															gerarFaturaClienteResponsavelHelper.getPeriodoReferenciaContasFinal(),
															imovel.getId());

							if(quantidadeConcessionarias != null && quantidadeConcessionarias.intValue() > 1){
								throw new ControladorException("atencao.nao_possivel_gerar_fatura_imoveis_concessionarias_diversas");
							}

							// Seleciona as contas dos imóveis de responsabilidade do cliente
							Collection<Conta> contas = consultarContasParaGerarFaturaClienteResponsavelPorImovel(
											gerarFaturaClienteResponsavelHelper, imovel);

							if(!Util.isVazioOrNulo(contas)){
								contasDoCliente.addAll(contas);
							}
						}

						// [FS0002 – Verificar existência de contas]
						if(!Util.isVazioOrNulo(contasDoCliente)){
							mapClienteContas.put(cliente, contasDoCliente);
						}

					}else{
						// [FS0001 – Verificar existência clientes responsáveis]
						throw new ControladorException("atencao.nao.existe.cliente.responsavel");
					}
				}
			}else{
				throw new ControladorException("atencao.cliente.nao.selecionado");
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return mapClienteContas;
	}

	/**
	 * [UC0320] - Gerar Fatura Cliente Responsável
	 * Gera fatura para os clientes e respectivas contas selecionadas pelo usuário
	 * 
	 * @author Saulo Lima
	 * @date 17/09/2008
	 * @author Luciano Galvao
	 * @date 28/06/2013
	 */
	public Collection<Fatura> gerarFaturaClienteResponsavel(Map<Cliente, Collection<Conta>> mapClienteContas, Date dataVencimento)
					throws ControladorException{

		Collection<Fatura> faturas = new ArrayList<Fatura>();

		if(mapClienteContas != null && !mapClienteContas.isEmpty()){

			Collection<Cliente> clientes = mapClienteContas.keySet();

			// Percorre a listagem dos clientes selecionados
			for(Cliente cliente : clientes){
				Collection<Conta> contas = mapClienteContas.get(cliente);
				Fatura fatura = inserirFaturaClienteResponsavel(cliente, contas, dataVencimento);
				if(fatura != null){
					faturas.add(fatura);
				}
			}
		}else{
			throw new ControladorException("atencao.cliente.nao.selecionado");
		}

		return faturas;
	}

	/**
	 * [UC0320] - Gerar Fatura Cliente Responsável
	 * Gera fatura para um cliente a partir das contas selecionadas pelo usuário
	 * 
	 * @author Saulo Lima
	 * @date 17/09/2008
	 * @author Luciano Galvao
	 * @date 28/06/2013
	 */
	private Fatura inserirFaturaClienteResponsavel(Cliente cliente, Collection<Conta> contas, Date dataVencimento)
					throws ControladorException{

		// Para cada cliente retornado, o sistema gera a fatura
		Fatura fatura = null;

		if(!Util.isVazioOrNulo(contas)){

			// Constroi e Insere a fatura
			fatura = new Fatura();
			fatura.setEmissao(new Date());
			fatura.setVencimento(dataVencimento);
			fatura.setTaxa(null);
			fatura.setCliente(cliente);
			fatura.setUltimaAlteracao(new Date());
			fatura.setDebito(BigDecimal.ZERO);

			Integer idFatura = (Integer) this.getControladorUtil().inserir(fatura);

			// Informações que serão capturadas ao varrer as contas selecionadas
			Integer maiorReferencia = 0;
			Date maiorDataValidade = null;
			BigDecimal somaValorTotalContas = BigDecimal.ZERO;

			// Controle do Item da Fatura
			short itemSequencial = Short.parseShort("1");

			for(Conta conta : contas){
				// obtém a maior referência entre as contas selecionadas
				if(conta.getReferencia() > maiorReferencia){
					maiorReferencia = conta.getReferencia();
				}
				// obtém a maior data de validade entre as contas selecionadas
				if(maiorDataValidade == null
								|| (conta.getDataValidadeConta() != null && Util.compararDataTime(conta.getDataValidadeConta(),
												maiorDataValidade) > 0)){
					maiorDataValidade = conta.getDataValidadeConta();
				}

				// Obtém a soma do valor total das contas selecionadas
				somaValorTotalContas = somaValorTotalContas.add(conta.getValorTotalContaBigDecimal());

				// Define o Consumo que será considerado para o Item da Fatura
				Integer numeroConsumo = 0;
				if(conta.getLigacaoAguaSituacao() != null){
					if(conta.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){
						numeroConsumo = conta.getConsumoAgua();
					}
				}else if(conta.getLigacaoEsgotoSituacao() != null){
					if(conta.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue()){
						numeroConsumo = conta.getConsumoEsgoto();
					}
				}

				// Inserindo o Item da Fatura relativo a Conta
				FaturaItem faturaItem = new FaturaItem();
				faturaItem.setFatura(fatura);
				faturaItem.setItemSequencia(itemSequencial);
				faturaItem.setImovel(conta.getImovel());
				ContaGeral contaGeral = new ContaGeral();
				contaGeral.setId(conta.getId());
				faturaItem.setContaGeral(contaGeral);
				faturaItem.setValorConta(conta.getValorTotalContaBigDecimal());
				faturaItem.setValorImposto(conta.getValorImposto());
				faturaItem.setNumeroConsumo(numeroConsumo);
				faturaItem.setUltimaAlteracao(new Date());

				// Gera o item da fatura
				getControladorUtil().inserir(faturaItem);

				// Incrementa o sequêncial do item
				itemSequencial++;
			}

			// Atualiza a fatura com as informações complementares, como o sequencial, a maior
			// referência e data de validade entre as contas selecionadas e a soma do valor total
			// delas
			fatura.setId(idFatura);
			fatura.setSequencial(idFatura);
			fatura.setAnoMesReferencia(maiorReferencia);
			fatura.setValidade(maiorDataValidade);
			fatura.setDebito(somaValorTotalContas);

			this.getControladorUtil().atualizar(fatura);
		}

		return fatura;
	}

	/**
	 * [UC0320] Gerar Fatura de Cliente Responsável
	 * Pesquisa as contas dos imóveis de responsabilidade do cliente, utilizadas no processo de
	 * Gerar Fatura do Cliente Responsável
	 * 
	 * @author Luciano Galvao
	 * @date 26/06/2013
	 */
	private Collection<Conta> consultarContasParaGerarFaturaClienteResponsavelPorImovel(
					GerarFaturaClienteResponsavelHelper gerarFaturaClienteResponsavelHelper, Imovel imovel) throws ControladorException{

		FiltroConta filtroConta = new FiltroConta();

		// Condições da consulta de contas
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, imovel.getId()));

		if(gerarFaturaClienteResponsavelHelper.getPeriodoReferenciaContasInicial() != null){
			filtroConta.adicionarParametro(new MaiorQue(FiltroConta.REFERENCIA, gerarFaturaClienteResponsavelHelper
							.getPeriodoReferenciaContasInicial()));
		}

		if(gerarFaturaClienteResponsavelHelper.getPeriodoReferenciaContasFinal() != null){
			filtroConta.adicionarParametro(new MenorQue(FiltroConta.REFERENCIA, gerarFaturaClienteResponsavelHelper
							.getPeriodoReferenciaContasFinal()));
		}

		if(gerarFaturaClienteResponsavelHelper.getPeriodoVencimentoContasInicial() != null){
			filtroConta.adicionarParametro(new MaiorQue(FiltroConta.DATA_VENCIMENTO, gerarFaturaClienteResponsavelHelper
							.getPeriodoVencimentoContasInicial()));
		}

		if(gerarFaturaClienteResponsavelHelper.getPeriodoVencimentoContasFinal() != null){
			filtroConta.adicionarParametro(new MenorQue(FiltroConta.DATA_VENCIMENTO, gerarFaturaClienteResponsavelHelper
							.getPeriodoVencimentoContasFinal()));
		}

		if(gerarFaturaClienteResponsavelHelper.getIndicadorContasRevisao() != null
						&& gerarFaturaClienteResponsavelHelper.getIndicadorContasRevisao().equals(ConstantesSistema.CONTAS_EM_REVISAO)){

			filtroConta.adicionarParametro(new ParametroNaoNulo(FiltroConta.CONTA_MOTIVO_REVISAO_ID));

			if(!Util.isVazioOrNulo(gerarFaturaClienteResponsavelHelper.getMotivosRevisao())){
				filtroConta.adicionarParametro(new ParametroSimplesColecao(FiltroConta.CONTA_MOTIVO_REVISAO_ID,
								gerarFaturaClienteResponsavelHelper.getMotivosRevisaoIds()));
			}
		}

		filtroConta.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
						DebitoCreditoSituacao.PRE_FATURADA));

		// Ordenação crescente por IMOV_ID e CNTA_AMREFERENCIACONTA
		filtroConta.setCampoOrderBy(FiltroConta.IMOVEL_ID, FiltroConta.REFERENCIA);

		// Carregamento de entidades
		filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.LIGACAO_AGUA_SITUACAO);
		filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.LIGACAO_ESGOTO_SITUACAO);
		filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL);
		filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.CONTA_MOTIVO_REVISAO);
		filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.IMOVEL);

		Collection<Conta> contas = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

		// Construindo descrição completa do imóvel, composta do nome do cliente usuário e do
		// endereço do imóvel
		String descricaoCompletaImovel = "";

		FiltroClienteImovel filtroClienteImovel = new FiltroClienteImovel();
		filtroClienteImovel.adicionarParametro(new ParametroSimples(FiltroClienteImovel.IMOVEL_ID, imovel.getId()));
		filtroClienteImovel
						.adicionarParametro(new ParametroSimples(FiltroClienteImovel.CLIENTE_RELACAO_TIPO_ID, ClienteRelacaoTipo.USUARIO));
		filtroClienteImovel.adicionarParametro(new ParametroNulo(FiltroClienteImovel.DATA_FIM_RELACAO));
		filtroClienteImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroClienteImovel.CLIENTE);
		ClienteImovel clienteImovel = (ClienteImovel) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroClienteImovel,
						ClienteImovel.class.getName()));

		if(clienteImovel != null && clienteImovel.getCliente() != null && !Util.isVazioOuBranco(clienteImovel.getCliente().getNome())){
			descricaoCompletaImovel = clienteImovel.getCliente().getNome();
		}

		// [UC0085 - Obter Endereço]
		String enderecoImovel = getControladorEndereco().pesquisarEndereco(imovel.getId());

		if(!Util.isVazioOuBranco(enderecoImovel)){

			// Se a descrição completa já possui informações anteriores, separa com ';'
			if(!Util.isVazioOuBranco(descricaoCompletaImovel)){
				descricaoCompletaImovel = descricaoCompletaImovel + "; ";
			}

			descricaoCompletaImovel = descricaoCompletaImovel + enderecoImovel;
		}

		// Setando a descrição completa do imóvel em todas as contas que serão retornadas
		if(!Util.isVazioOuBranco(descricaoCompletaImovel) && !Util.isVazioOrNulo(contas)){
			for(Conta conta : contas){
				conta.getImovel().setNomeImovel(descricaoCompletaImovel);
			}
		}

		return contas;
	}

	/**
	 * Metódo responsável gerar os objetos do tipo FaturaClienteResponsavelHelper que serão usados
	 * no [UC0321] - Emitir Fatura de Cliente Responsável
	 * 
	 * @author Saulo Lima
	 * @date 23/09/2008
	 * @author Eduardo Henrique
	 * @date 24/12/2008 Correção na atribuição do atributo do helper que exibirá o cód. de barras da
	 *       Fatura.
	 * @author Eduardo Henrique
	 * @date 06/01/2009 Alteração na criação dos bean detalhe do report, para adicionar informações
	 *       de Valor de Agua, Esgoto e Impostos.
	 * @author Eduardo Henrique
	 * @date 01/04/2009 Correção da obtenção do Consumo Medido dos Itens da Fatura. Correção do Nome
	 *       do Cliente exibido nas Faturas associadas.
	 *       Utiliza-se o Cliente Usuário.
	 * @param Collection
	 *            <Integer> Colecção de Inteiros com os Ids das faturas que serão impressas.
	 * @return Collection<FaturaClienteResponsavelHelper> Coleção de FaturaClienteResponsavelHelper
	 * @throws ControladorException
	 */
	public Collection<FaturaClienteResponsavelHelper> gerarColecaoFaturaClienteResponsavelHelper(Collection<Integer> idsFaturas)
					throws ControladorException{

		Collection retorno = new ArrayList();
		FiltroFatura filtroFatura = new FiltroFatura();
		filtroFatura.adicionarCaminhoParaCarregamentoEntidade(FiltroFatura.CLIENTE);
		Collection<Fatura> faturas = getControladorUtil().pesquisar(idsFaturas, filtroFatura, Fatura.class.getName());

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		try{
			Iterator faturasIterator = faturas.iterator();
			while(faturasIterator.hasNext()){

				Fatura fatura = (Fatura) faturasIterator.next();

				FaturaClienteResponsavelHelper faturaClienteResponsavelHelper = new FaturaClienteResponsavelHelper();

				faturaClienteResponsavelHelper.setNumeroFatura("" + fatura.getId());
				faturaClienteResponsavelHelper.setCodigoCliente("" + fatura.getCliente().getId());
				if(fatura.getCliente().getCnpjFormatado() != null){
					faturaClienteResponsavelHelper.setCnpj(fatura.getCliente().getCnpjFormatado());
				}else{
					faturaClienteResponsavelHelper.setCnpj("");
				}
				faturaClienteResponsavelHelper.setNumeroOrgao("" + fatura.getCliente().getId());
				if(fatura.getCliente().getNome() != null){
					faturaClienteResponsavelHelper.setNomeCliente(fatura.getCliente().getNome());
				}else{
					faturaClienteResponsavelHelper.setNomeCliente("");
				}
				String enderecoCorrespondencia = "Não encontrado o Indicador para endereço de correspondência do cliente "
								+ fatura.getCliente().getId() + ".";
				Collection<ClienteEndereco> clienteEnderecos = getControladorCliente().pesquisarEnderecosClienteAbreviado(
								fatura.getCliente().getId());
				if(clienteEnderecos != null && !clienteEnderecos.isEmpty()){
					Iterator<ClienteEndereco> clienteEnderecosIterator = clienteEnderecos.iterator();
					while(clienteEnderecosIterator.hasNext()){
						ClienteEndereco clienteEndereco = clienteEnderecosIterator.next();
						if(clienteEndereco.getIndicadorEnderecoCorrespondencia().equals(ConstantesSistema.SIM)){
							enderecoCorrespondencia = clienteEndereco.getEnderecoFormatado();
						}
					}
				}
				faturaClienteResponsavelHelper.setEndereco(enderecoCorrespondencia); // Pq o objeto
				// Cliente
				// tem um
				// atributo
				// Cliente?
				faturaClienteResponsavelHelper.setDataEmissao(Util.formatarData(new Date()) + " "
								+ Util.formatarHoraSemSegundos(new Date()));
				faturaClienteResponsavelHelper.setMesAno(Util.formatarAnoMesSemBarraParaMesAnoComBarra(fatura.getAnoMesReferencia()));
				faturaClienteResponsavelHelper.setVencimento(Util.formatarData(fatura.getVencimento()));

				int quantidade = 0;
				int quantidadeItensPorFatura = FaturaItem.QTD_ITENS_RELATORIO_FATURA.intValue();
				BigDecimal valorImpostos = new BigDecimal("0.00");

				// Pega a coleção de Itens da Fatura
				Collection<FaturaItemClienteResponsavelHelper> colecaoFaturaItemClienteResponsavelHelper = new ArrayList<FaturaItemClienteResponsavelHelper>();

				// Obtém a coleção dos itens da fatura atual
				ArrayList<FaturaItem> colecaoFaturaItem = (ArrayList) repositorioFaturamento.pesquisarItemsFatura(fatura.getId());

				// Caso a coleção de itens da fatura estejam preenchidos
				if(colecaoFaturaItem != null && colecaoFaturaItem.size() > 0){

					Iterator<FaturaItem> faturaItemIterator = colecaoFaturaItem.iterator();
					while(faturaItemIterator.hasNext()){

						FaturaItem faturaItem = faturaItemIterator.next();
						FaturaItemClienteResponsavelHelper itemHelper = new FaturaItemClienteResponsavelHelper();

						Imovel imovel = faturaItem.getImovel();
						FiltroImovel filtroImovel = new FiltroImovel();
						filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, faturaItem.getImovel().getId()));
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.CEP);
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOGRADOURO);
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOGRADOURO_TIPO);
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.BAIRRO);
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.MUNICIPIO);
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.UNIDADE_FEDERACAO);
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.ENDERECO_REFERENCIA);
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOGRADOURO_TITULO);
						filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.CLIENTES_IMOVEIS);
						Collection<Imovel> imoveis = getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
						if(imoveis != null && !imoveis.isEmpty()){
							imovel = imoveis.iterator().next();
						}

						LigacaoAgua ligacaoAgua = null;
						Hidrometro hidrometro = null;
						HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = null;
						if(imovel.getLigacaoAgua() != null){
							FiltroLigacaoAgua filtroLigacaoAgua = new FiltroLigacaoAgua();
							filtroLigacaoAgua
											.adicionarParametro(new ParametroSimples(FiltroLigacaoAgua.ID, imovel.getLigacaoAgua().getId()));
							Collection<LigacaoAgua> colecaoLigacaoAgua = this.getControladorUtil().pesquisar(filtroLigacaoAgua,
											LigacaoAgua.class.getName());
							if(colecaoLigacaoAgua != null && !colecaoLigacaoAgua.isEmpty()){
								ligacaoAgua = colecaoLigacaoAgua.iterator().next();
							}

							if(ligacaoAgua.getHidrometroInstalacaoHistorico() != null){
								FiltroHidrometroInstalacaoHistorico filtroHidrometroInstalacaoHistorico = new FiltroHidrometroInstalacaoHistorico();
								filtroHidrometroInstalacaoHistorico.adicionarParametro(new ParametroSimples(
												FiltroHidrometroInstalacaoHistorico.ID, imovel.getLigacaoAgua()
																.getHidrometroInstalacaoHistorico().getId()));
								Collection<HidrometroInstalacaoHistorico> hidrometroInstalacaoHistoricos = getControladorUtil().pesquisar(
												filtroHidrometroInstalacaoHistorico, HidrometroInstalacaoHistorico.class.getName());
								if(hidrometroInstalacaoHistoricos != null && !hidrometroInstalacaoHistoricos.isEmpty()){
									hidrometroInstalacaoHistorico = hidrometroInstalacaoHistoricos.iterator().next();
								}

								if(hidrometroInstalacaoHistorico.getHidrometro() != null){
									FiltroHidrometro filtroHidrometro = new FiltroHidrometro();
									filtroHidrometro.adicionarParametro(new ParametroSimples(FiltroHidrometro.ID,
													hidrometroInstalacaoHistorico.getHidrometro().getId()));
									Collection<Hidrometro> hidrometros = getControladorUtil().pesquisar(filtroHidrometro,
													Hidrometro.class.getName());
									if(hidrometros != null && !hidrometros.isEmpty()){
										hidrometro = hidrometros.iterator().next();
									}
								}
							}
						}

						Conta conta = null;
						FiltroConta filtroConta = new FiltroConta();
						filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, faturaItem.getContaGeral().getId()));
						filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.LIGACAO_AGUA_SITUACAO);
						filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.LIGACAO_ESGOTO_SITUACAO);
						filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.IMPOSTOS_DEDUZIDOS);
						Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());
						if(colecaoConta != null && !colecaoConta.isEmpty()){
							conta = colecaoConta.iterator().next();
						}

						itemHelper.setLigacao("" + imovel.getId());
						if(hidrometro != null){
							itemHelper.setNumeroHidrometro(hidrometro.getNumero());
						}else{
							itemHelper.setNumeroHidrometro("");
						}

						if(imovel != null && imovel.getClienteImoveis() != null){
							for(ClienteImovel clienteImovel : imovel.getClienteImoveis()){
								if(clienteImovel.getIndicadorNomeConta().intValue() == ConstantesSistema.SIM.intValue()
												&& clienteImovel.getDataFimRelacao() == null){

									Cliente cliente = clienteImovel.getCliente();
									itemHelper.setNome(cliente.getNome());

									if(cliente.getCnpjFormatado() != null){
										itemHelper.setCnpj(cliente.getCnpjFormatado());
									}else{
										itemHelper.setCnpj("");
									}

									// .....................................................................
									String endereco = "";
									if(sistemaParametro.getIndicadorClienteAtualFatura() != null
													&& sistemaParametro.getIndicadorClienteAtualFatura().equals(ConstantesSistema.SIM)){
										endereco = clienteImovel.getImovel().getEnderecoFormatadoAbreviado();
									}else{
										if(imovel.getEnderecoFormatadoAbreviado() != null){
											endereco = imovel.getEnderecoFormatadoAbreviado();
										}
									}
									itemHelper.setEndereco(endereco);
									// .....................................................................
								}
							}
						}

						if(itemHelper.getNome() == null){
							itemHelper.setNome("");
						}
						if(itemHelper.getCnpj() == null){
							itemHelper.setCnpj("");
						}
						if(itemHelper.getEndereco() == null){
							if(imovel.getEnderecoFormatadoAbreviado() != null){
								itemHelper.setEndereco(imovel.getEnderecoFormatadoAbreviado());
							}else{
								itemHelper.setEndereco("");
							}

						}

						MedicaoHistorico medicaoHistorico = this.getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(
										imovel.getId(), fatura.getAnoMesReferencia());

						if(medicaoHistorico != null){

							FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();
							filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.ID, medicaoHistorico
											.getId()));
							Collection<MedicaoHistorico> colecaoMedicaoHistorico = this.getControladorUtil().pesquisar(
											filtroMedicaoHistorico, MedicaoHistorico.class.getName());

							if(colecaoMedicaoHistorico != null && !colecaoMedicaoHistorico.isEmpty()){
								medicaoHistorico = colecaoMedicaoHistorico.iterator().next();
							}

							itemHelper.setLeituraAnterior("" + medicaoHistorico.getLeituraAnteriorFaturamento());
							itemHelper.setLeituraAtual("" + medicaoHistorico.getLeituraAtualFaturamento());

							if(medicaoHistorico.getNumeroConsumoMes() != null){
								itemHelper.setConsumoMedido(medicaoHistorico.getNumeroConsumoMes().toString());
							}else{
								itemHelper.setConsumoMedido("");
							}

							itemHelper.setConsumoFaturado("" + conta.getConsumoAgua());
							if(medicaoHistorico.getDataLeituraAtualFaturamento() != null){
								itemHelper.setDataLeitura(Util.formatarData(medicaoHistorico.getDataLeituraAtualFaturamento()));
							}else{
								itemHelper.setDataLeitura("");
							}

						}else{
							itemHelper.setLeituraAnterior("");
							itemHelper.setLeituraAtual("");
							itemHelper.setConsumoMedido("");
							itemHelper.setConsumoFaturado("" + conta.getConsumoAgua());
							itemHelper.setDataLeitura("");
						}

						itemHelper.setQtdEconomias("" + imovel.getQuantidadeEconomias());

						if(itemHelper.getConsumoFaturado().equalsIgnoreCase("null")){

							itemHelper.setConsumoFaturado(" ");

						}

						if(conta.getDataVencimentoConta() != null){
							itemHelper.setVencimento(Util.formatarData(conta.getDataVencimentoConta())); // Erro
																											// Jasper
							itemHelper.setDataLeitura(Util.formatarData(conta.getDataVencimentoConta())); // Usando
																											// este!
																											// q
																											// foi
																											// alterado.
						}else{
							itemHelper.setVencimento("");
							itemHelper.setDataLeitura("");
						}
						
						if(conta.getLigacaoAguaSituacao() != null){
							if(conta.getLigacaoAguaSituacao().getDescricaoAbreviado() != null){
								itemHelper.setTipoServicoAgua(conta.getLigacaoAguaSituacao().getDescricaoAbreviado());
							}
						}else{
							itemHelper.setTipoServicoAgua("");
						}

						if(conta.getLigacaoEsgotoSituacao() != null){
							if(conta.getLigacaoEsgotoSituacao().getDescricaoAbreviado() != null){
								itemHelper.setTipoServicoEsgoto(conta.getLigacaoEsgotoSituacao().getDescricaoAbreviado());
							}
						}else{
							itemHelper.setTipoServicoEsgoto("");
						}

						if(conta.getValorAgua() != null){
							itemHelper.setValorAgua(Util.formatarMoedaReal(conta.getValorAgua()));
						}else{
							itemHelper.setValorAgua("");
						}

						if(conta.getValorEsgoto() != null){
							itemHelper.setValorEsgoto(Util.formatarMoedaReal(conta.getValorEsgoto()));
						}else{
							itemHelper.setValorEsgoto("");
						}

						if(conta.getValorCreditos() != null){
							itemHelper.setValorCredito(Util.formatarMoedaReal(conta.getValorCreditos()));
						}else{
							itemHelper.setValorCredito("");
						}

						if(conta.getContaImpostosDeduzidos() != null && !conta.getContaImpostosDeduzidos().isEmpty()){
							Collection<ContaImpostosDeduzidos> colecaoImpostos = conta.getContaImpostosDeduzidos();
							for(ContaImpostosDeduzidos contaImpostoDeduzido : colecaoImpostos){
								if(contaImpostoDeduzido.getImpostoTipo().getId().equals(ImpostoTipo.IR)){
									itemHelper.setValorImpostoIR(Util.formatarMoedaReal(contaImpostoDeduzido.getValorImposto()));
								}else if(contaImpostoDeduzido.getImpostoTipo().getId().equals(ImpostoTipo.COFINS)){
									itemHelper.setValorImpostoCOFINS(Util.formatarMoedaReal(contaImpostoDeduzido.getValorImposto()));
								}else if(contaImpostoDeduzido.getImpostoTipo().getId().equals(ImpostoTipo.CSLL)){
									itemHelper.setValorImpostoCSLL(Util.formatarMoedaReal(contaImpostoDeduzido.getValorImposto()));
								}else if(contaImpostoDeduzido.getImpostoTipo().getId().equals(ImpostoTipo.PIS_PASEP)){
									itemHelper.setValorImpostoPIS(Util.formatarMoedaReal(contaImpostoDeduzido.getValorImposto()));
								}
							}
						}else{
							itemHelper.setValorImpostoCOFINS(Util.formatarMoedaReal(BigDecimal.ZERO));
							itemHelper.setValorImpostoCSLL(Util.formatarMoedaReal(BigDecimal.ZERO));
							itemHelper.setValorImpostoIR(Util.formatarMoedaReal(BigDecimal.ZERO));
							itemHelper.setValorImpostoPIS(Util.formatarMoedaReal(BigDecimal.ZERO));
						}

						// TODO incluir valores de Agua, Esgoto e Impostos separadamente
						valorImpostos = valorImpostos.add(faturaItem.getValorImposto());

						itemHelper.setValor(Util.formatarMoedaReal(faturaItem.getValorConta()));

						// **************** Incluir Valores dos Débitos Cobrados ***************
						if(conta != null){
							if(conta.getDebitos() == null || conta.getDebitos().compareTo(BigDecimal.ZERO) <= 0){
								itemHelper.setDebitoCobradoMulta("0,00");
								itemHelper.setDebitoCobradoJuros("0,00");
								itemHelper.setDebitoCobradoOutrosServicos("0,00");
							}else{
								Object[] debitosCobrados = new Object[3];
								debitosCobrados = repositorioFaturamento.pesquisarDebitosCobradosPorConta(conta.getId());
								itemHelper.setDebitoCobradoMulta(Util.formatarMoedaReal((BigDecimal) debitosCobrados[0]));
								itemHelper.setDebitoCobradoJuros(Util.formatarMoedaReal((BigDecimal) debitosCobrados[1]));
								itemHelper.setDebitoCobradoOutrosServicos(Util.formatarMoedaReal((BigDecimal) debitosCobrados[2]));
							}
						}else{
							itemHelper.setDebitoCobradoMulta("0,00");
							itemHelper.setDebitoCobradoJuros("0,00");
							itemHelper.setDebitoCobradoOutrosServicos("0,00");
						}
						// *********************************************************************

						colecaoFaturaItemClienteResponsavelHelper.add(itemHelper);
					}
				}

				faturaClienteResponsavelHelper.setQtdItens("" + colecaoFaturaItem.size());

				faturaClienteResponsavelHelper.setColecaoFaturaItemClienteResponsavelHelper(colecaoFaturaItemClienteResponsavelHelper);

				String representacaoNumericaCodBarra = this.getControladorArrecadacao().obterRepresentacaoNumericaCodigoBarra(
								Integer.valueOf(7), fatura.getDebito(), null, null, null, null, null, null, null,
								DocumentoTipo.FATURA_CLIENTE, fatura.getCliente().getId(), fatura.getSequencial(), null, null, null, null);

				// Formata a representação númerica do código de barras
				String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11) + " "
								+ representacaoNumericaCodBarra.substring(11, 12) + " " + representacaoNumericaCodBarra.substring(12, 23)
								+ " " + representacaoNumericaCodBarra.substring(23, 24) + " "
								+ representacaoNumericaCodBarra.substring(24, 35) + " " + representacaoNumericaCodBarra.substring(35, 36)
								+ " " + representacaoNumericaCodBarra.substring(36, 47) + " "
								+ representacaoNumericaCodBarra.substring(47, 48);

				// Monta o código de barras sem Dígitos Verificadores
				String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra.substring(0, 11)
								+ representacaoNumericaCodBarra.substring(12, 23) + representacaoNumericaCodBarra.substring(24, 35)
								+ representacaoNumericaCodBarra.substring(36, 47);

				faturaClienteResponsavelHelper.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);
				faturaClienteResponsavelHelper.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);
				faturaClienteResponsavelHelper.setIndicadorCodigoBarras("S");
				faturaClienteResponsavelHelper.setValorTotalAPagar(Util.formatarMoedaReal(fatura.getDebito()));
				faturaClienteResponsavelHelper.setValorExtenso(Util.valorExtenso(fatura.getDebito()));
				faturaClienteResponsavelHelper.setValorImpostos(Util.formatarMoedaReal(valorImpostos));
				faturaClienteResponsavelHelper.setValorBruto(Util.formatarMoedaReal(valorImpostos.add(fatura.getDebito())));
				faturaClienteResponsavelHelper.setNomeEmpresa(sistemaParametro.getNomeEmpresa());
				String enderecoCompletoEmpresa = "RUA " + sistemaParametro.getLogradouro().getNome() + ", "
								+ sistemaParametro.getNumeroImovel() + " - " + sistemaParametro.getBairro().getNome() + " - "
								+ sistemaParametro.getLogradouro().getMunicipio().getNome() + "/"
								+ sistemaParametro.getLogradouro().getMunicipio().getUnidadeFederacao().getSigla();
				faturaClienteResponsavelHelper.setEnderecoCompletoEmpresa(enderecoCompletoEmpresa);
				faturaClienteResponsavelHelper.setFoneEmpresa("FONE: " + Util.formatarFone(sistemaParametro.getNumeroTelefone()));
				faturaClienteResponsavelHelper.setCnpjEmpresa("CNPJ: " + Util.formatarCnpj(sistemaParametro.getCnpjEmpresa()));
				faturaClienteResponsavelHelper.setHomePageEmpresa("Home Page: " + ParametroCadastro.P_SITE_EMPRESA.executar());
				faturaClienteResponsavelHelper.setTituloRelatorioEmpresa("CONTAS DE " + sistemaParametro.getNomeEmpresa());

				retorno.add(faturaClienteResponsavelHelper);

			}
		}catch(ErroRepositorioException ex){
			// Seta o roolback na base
			// sessionContext.setRollbackOnly();

			// Levanta a exceção para o usuário
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Metódo responsável por emitir as faturas geradas pelo [UC0320]
	 * [UC0321] Emitir Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre, Pedro Alexandre, Saulo Lima
	 * @date 27/04/2006, 03/01/2007, 15/03/2007, 19/09/2008
	 * @param colecaoFatura
	 * @throws ControladorException
	 * @Deprecated
	 */
	public void emitirFaturaClienteResponsavel(Collection<Fatura> colecaoFatura, Integer anoMesFaturamentoCorrente)
					throws ControladorException, IOException{

		// Ordena a coleção de faturas pelo código do cliente responsável
		Collections.sort((List) colecaoFatura, new Comparator() {

			public int compare(Object a, Object b){

				Integer cliente1 = ((Fatura) a).getCliente().getId();
				Integer cliente2 = ((Fatura) b).getCliente().getId();

				return cliente1.compareTo(cliente2);
			}
		});

		// Cria a variável que vai armazenar o txt de fatura
		StringBuilder arquivoFaturaTXT = new StringBuilder();

		// Caso a coleção de faturas esteja preenchida
		// Emiti todas as faturas informadas
		if(colecaoFatura != null){

			// Cria o sequêncial da fatura
			int sequencialFatura = 1;
			int quantidadeFaturas = 0;
			// Laço para emitir todas as faturas
			for(Fatura fatura : colecaoFatura){
				try{

					quantidadeFaturas++;

					// Obtém a coleção dos itens da fatura atual
					ArrayList<FaturaItem> colecaoFaturaItem = (ArrayList) repositorioFaturamento.pesquisarItemsFatura(fatura.getId());

					// Caso a coleção de itens da fatura estejam preenchidos
					if(colecaoFaturaItem != null && colecaoFaturaItem.size() > 0){

						// Armazena a quantidade de itens
						String quantidadeItemFatura = "" + colecaoFaturaItem.size();

						// Armazena a quantidade limite de itens por página
						Integer quantidadeItemLimite = 100;

						// Calcula a quantidade de páginas
						Integer quantidadePaginas = ((Double) Math.ceil(Double.parseDouble(quantidadeItemFatura) / quantidadeItemLimite))
										.intValue();

						// Cria os arrays que iram armazenar os itens da
						// primeira e segunda colunas respectivamente
						FaturaItem[] colecaoFaturaItemColuna1 = null;
						FaturaItem[] colecaoFaturaItemColuna2 = null;

						// Cria o indice atual da coleção de itens
						int indiceAtual = 0;

						// Laço para gerar todas as páginas da fatura atual
						for(int i = 1; i <= quantidadePaginas; i++){

							// Recupera o cliente responsável pela fatura
							Cliente cliente = getControladorCliente().pesquisarCliente(fatura.getCliente().getId());

							// Linha 1
							// Linha 1 é composta só pela canal=1
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 2
							// Linha 2 é composta pelo canal=- e fonte=1 e pelo
							// nome do cliente
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(cliente.getNome());
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 3
							// Linha 3 é composta pelo código do cliente e pelo
							// mês/ano de referência da conta
							String codigoClienteFormatado = Util.adicionarZerosEsquedaNumero(8, "" + cliente.getId());
							codigoClienteFormatado = codigoClienteFormatado.substring(0, 7) + "." + codigoClienteFormatado.substring(7, 8);

							arquivoFaturaTXT.append("+");
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append(Util.completaString("", 61));
							arquivoFaturaTXT.append(codigoClienteFormatado);
							arquivoFaturaTXT.append(Util.completaString("", 19));
							arquivoFaturaTXT.append(Util.formatarAnoMesParaMesAno(fatura.getAnoMesReferencia()));
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 4
							String enderecoCorrespondencia = getControladorEndereco().pesquisarEnderecoClienteAbreviado(cliente.getId());
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(enderecoCorrespondencia);
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 5
							// Linha 5 é composta pelo sequêncial da fatura
							arquivoFaturaTXT.append(" ");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString("", 91));
							arquivoFaturaTXT.append(Util.adicionarZerosEsquedaNumero(6, "" + fatura.getSequencial()));
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 6
							// Linha 6 é uma linha em branco
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 7
							// Linha 7 é composta pela descrição do tipo do
							// cliente e pela quantidade de itens da fatura
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString(cliente.getClienteTipo().getDescricao(), 91));
							arquivoFaturaTXT.append(Util.completaStringComEspacoAEsquerda(quantidadeItemFatura, 5));
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 8
							// Linha 8 é uma linha em branco
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 9
							// Linha 9 é composta só pelo canal=-
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 10
							// Linha 10 é composta pelos itens da fatura da
							// página atual

							// Caso seja a última página da fatura
							if(i == quantidadePaginas){
								// Calcula a quantidade de itens da última
								// página
								int quantidadeItemsUltimaPagina = Integer.parseInt(quantidadeItemFatura) - ((quantidadePaginas - 1) * 100);

								// Caso a quantidade de itens da última página
								// seja maior que 50(cinquenta)
								// Recupera os itens restantes para a primeira
								// coluna
								// Caso contrário recupera os 50 primeiros itens
								// para a primeira coluna
								// e os itens restantes para a segunda coluna
								if(quantidadeItemsUltimaPagina <= 50){
									// Cria o array de itens da fatura da
									// primeira coluna
									// com o tamanho igual a quantidade de itens
									// da última página
									colecaoFaturaItemColuna1 = new FaturaItem[quantidadeItemsUltimaPagina];

									// Recupera da coleção principal os itens da
									// fatura
									// para os itens da primeira coluna
									(colecaoFaturaItem.subList(indiceAtual, indiceAtual + quantidadeItemsUltimaPagina))
													.toArray(colecaoFaturaItemColuna1);

									// Cria um array de nulos para a segunda
									// coluna
									colecaoFaturaItemColuna2 = new FaturaItem[quantidadeItemsUltimaPagina];

								}else{
									// Cria o array de itens da fatura da
									// primeira coluna
									// com o tamanho igual a 50(cinquenta)
									colecaoFaturaItemColuna1 = new FaturaItem[50];

									// Recupera da coleção principal os itens da
									// fatura
									// para os itens da primeira coluna
									(colecaoFaturaItem.subList(indiceAtual, indiceAtual + 50)).toArray(colecaoFaturaItemColuna1);

									// Incrementa o indice atual em cinquenta
									// posições
									indiceAtual = indiceAtual + 50;

									// Cria o array da segunda coluna com o
									// tamanho das quantidades de itens
									// restantes
									// colecaoFaturaItemColuna2 = new
									// FaturaItem[quantidadeItemsUltimaPagina -
									// 50];
									colecaoFaturaItemColuna2 = new FaturaItem[50];

									// Recupera os itens restantes para asegunda
									// coluna
									(colecaoFaturaItem.subList(indiceAtual, (indiceAtual + (quantidadeItemsUltimaPagina - 50))))
													.toArray(colecaoFaturaItemColuna2);
								}

							}else{
								colecaoFaturaItemColuna1 = new FaturaItem[50];
								colecaoFaturaItemColuna2 = new FaturaItem[50];

								// Recupera os 50 itens para a primeira coluna
								(colecaoFaturaItem.subList(indiceAtual, indiceAtual + 50)).toArray(colecaoFaturaItemColuna1);

								// Incrementa o indice atual
								indiceAtual = indiceAtual + 50;

								// Recupera os 50 itens da segunda coluna
								(colecaoFaturaItem.subList(indiceAtual, indiceAtual + 50)).toArray(colecaoFaturaItemColuna2);

								// Incrementa o indice atual
								indiceAtual = indiceAtual + 50;
							}

							// Adiciona a linha dez gerada ao txt
							arquivoFaturaTXT.append(gerarLinha10FaturaClienteResponsavel(colecaoFaturaItemColuna1, colecaoFaturaItemColuna2));

							// Linha 11
							// Linha 11 é composta das datas de emissão
							// ,vencimento e do valor do débito da fatura
							arquivoFaturaTXT.append(System.getProperty("line.separator"));
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append(Util.completaString("", 8));
							arquivoFaturaTXT.append(Util.completaString(Util.formatarData(fatura.getEmissao()), 34));
							arquivoFaturaTXT.append(Util.completaString(Util.formatarData(fatura.getVencimento()), 38));
							arquivoFaturaTXT.append(Util.completaStringComEspacoAEsquerda(Util.formatarMoedaReal(fatura.getDebito()), 14));
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 12
							// Linha 12 é composta por apenas o canal=0
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 13
							// Linha 13 é composta por apenas o canal=-
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 14
							// Linha 14 é composta pelo sequêncial da fatura
							String sequencialFaturaFormatado = Util.adicionarZerosEsquedaNumero(6, "" + sequencialFatura);
							sequencialFaturaFormatado = sequencialFaturaFormatado.substring(0, 3) + "."
											+ sequencialFaturaFormatado.substring(3, 6);
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString("", 100));
							arquivoFaturaTXT.append(sequencialFaturaFormatado);
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 15
							// Linha 15 é composta pelo canal=1, fonte=1
							// e pela representação numérica do código de barras
							// Formata o ano/mês em mês/ano de referência da
							// conta no formato MM/AAAA
							String mesAnoReferenciaConta = Util.formatarAnoMesParaMesAno(fatura.getAnoMesReferencia());

							// Formata o ano/mês em mês/ano de referência da
							// conta no formato MMAAAA(sem a barra)
							String mesAnoReferenciaContaSemABarra = mesAnoReferenciaConta.substring(0, 2)
											+ mesAnoReferenciaConta.substring(3, 7);

							// Obtémo dígito verificador da referência da conta
							// no modulo 10(dez)
							Integer digitoVerificadorReferenciaContaModulo10 = Util.obterDigitoVerificadorModulo10(Long
											.valueOf(mesAnoReferenciaContaSemABarra));

							// Variável que vai armazenar a representação
							// numérica do código de barras
							String representacaoNumericaCodBarra = "";

							// Obtém a representação numérica do códigode
							// barra
							representacaoNumericaCodBarra = this.getControladorArrecadacao().obterRepresentacaoNumericaCodigoBarra(7,
											fatura.getDebito(), null, null, mesAnoReferenciaContaSemABarra,
											digitoVerificadorReferenciaContaModulo10, null, null, null, DocumentoTipo.FATURA_CLIENTE,
											cliente.getId(), fatura.getSequencial(), null, null, null, null);

							// Formata a representação númerica do código de
							// barras
							String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11) + " "
											+ representacaoNumericaCodBarra.substring(11, 12) + " "
											+ representacaoNumericaCodBarra.substring(12, 23) + " "
											+ representacaoNumericaCodBarra.substring(23, 24) + " "
											+ representacaoNumericaCodBarra.substring(24, 35) + " "
											+ representacaoNumericaCodBarra.substring(35, 36) + " "
											+ representacaoNumericaCodBarra.substring(36, 47) + " "
											+ representacaoNumericaCodBarra.substring(47, 48);

							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString("", 23));
							arquivoFaturaTXT.append(representacaoNumericaCodBarraFormatada);
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 16 é composta por apenas o canal=1
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 17 é composta pelo canal=1 pela fonte=2 e
							// pela representação do código de barras em
							// caracter
							// Cria o objeto para gerar o códigode barras no
							// padrão intercalado 2 de 5
							Interleaved2of5 codigoBarraIntercalado2de5 = new Interleaved2of5();

							// Recupera a representação númerica do código de
							// barras sem os dígitos verificadores
							String representacaoCodigoBarrasSemDigitoVerificador = representacaoNumericaCodBarra.substring(0, 11)
											+ representacaoNumericaCodBarra.substring(12, 23)
											+ representacaoNumericaCodBarra.substring(24, 35)
											+ representacaoNumericaCodBarra.substring(36, 47);

							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("2");
							arquivoFaturaTXT.append(Util.completaStringComEspacoAEsquerda(
											codigoBarraIntercalado2de5.encodeValue(representacaoCodigoBarrasSemDigitoVerificador), 142));
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 18 é composta por apenas o canal=0
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 19 é composta pelo canal=- pela fonte=2,
							// pela data de validade,
							// pelo código do cliente pelo sequencial da fatura
							// e pelo mês/ano de referência
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString("", 4));
							arquivoFaturaTXT.append(Util.completaString(Util.formatarData(fatura.getValidade()), 30));
							arquivoFaturaTXT.append(Util.completaString(codigoClienteFormatado, 30));
							arquivoFaturaTXT.append(Util.completaString(Util.adicionarZerosEsquedaNumero(6, "" + fatura.getSequencial()),
											24));
							arquivoFaturaTXT.append(Util.completaString(Util.formatarAnoMesParaMesAno(fatura.getAnoMesReferencia()), 29));
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 20 é composta pelo canal=- pela fonte=1 e
							// pelas datas de emissão e vencimento
							// e pelo valor do débito da fatura
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString("", 8));
							arquivoFaturaTXT.append(Util.completaString(Util.formatarData(fatura.getEmissao()), 34));
							arquivoFaturaTXT.append(Util.completaString(Util.formatarData(fatura.getVencimento()), 40));
							arquivoFaturaTXT.append(Util.completaStringComEspacoAEsquerda(Util.formatarMoedaReal(fatura.getDebito()), 22));
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 21 é composta somente pelo canal=-
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 22 é composta somente pelo canal=-
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 23 é composta somente pelo sequêncial de
							// impressão da fatura
							arquivoFaturaTXT.append("-");
							arquivoFaturaTXT.append("1");
							arquivoFaturaTXT.append(Util.completaString("", 100));
							arquivoFaturaTXT.append(sequencialFaturaFormatado);
							arquivoFaturaTXT.append(System.getProperty("line.separator"));

							// Linha 24 é composta pela canal=0, fonte=1 e pela
							// representação do número de páginas
							arquivoFaturaTXT.append("0");
							arquivoFaturaTXT.append("1");

							// Caso a página atual não seja a última página
							if(i != quantidadePaginas.intValue()){
								// Imprime a menssagem que ocntinua a impressão
								// na próxima página
								arquivoFaturaTXT.append(Util.completaString("", 30));
								arquivoFaturaTXT.append(Util.completaString("(CONTINUA)", 64));
								arquivoFaturaTXT.append("PAGINA  " + Util.adicionarZerosEsquedaNumero(2, "" + i) + "/"
												+ Util.adicionarZerosEsquedaNumero(2, "" + quantidadePaginas));
							}else{
								arquivoFaturaTXT.append(Util.completaString("", 94));
								arquivoFaturaTXT.append("PAGINA  " + Util.adicionarZerosEsquedaNumero(2, "" + i) + "/"
												+ Util.adicionarZerosEsquedaNumero(2, "" + quantidadePaginas));
							}
							arquivoFaturaTXT.append(System.getProperty("line.separator"));
						}
					}

					// Incrementa o sequêncial da fatura para a nova fatura
					sequencialFatura++;

					// Erro no repositório
				}catch(ErroRepositorioException ex){
					// Seta o roolback na base
					// sessionContext.setRollbackOnly();

					// Levanta a exceção para o usuário
					throw new ControladorException("erro.sistema", ex);
				}
			}

			String mesReferencia = anoMesFaturamentoCorrente.toString().substring(4, 6);
			String anoReferencia = anoMesFaturamentoCorrente.toString().substring(0, 4);

			String nomeZip = "Faturas_Cliente_Responsavel_" + mesReferencia + "_" + anoReferencia;

			BufferedWriter out = null;
			ZipOutputStream zos = null;
			File compactadoTipo = new File(nomeZip + ".zip");

			File leituraTipo = new File(nomeZip + ".txt");

			if(arquivoFaturaTXT != null && arquivoFaturaTXT.length() != 0){
				try{
					System.out.println("CRIANDO ZIP");
					zos = new ZipOutputStream(new FileOutputStream(compactadoTipo));

					out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipo.getAbsolutePath())));
					out.write(arquivoFaturaTXT.toString());
					out.flush();
					ZipUtil.adicionarArquivo(zos, leituraTipo);
					zos.close();
					leituraTipo.delete();
					out.close();
				}catch(IOException ex){
					throw new ControladorException("erro.sistema", ex);
				}catch(Exception e){
					throw new ControladorException("erro.sistema", e);

				}

				nomeZip = null;
				out = null;
				zos = null;
				compactadoTipo = null;
				leituraTipo = null;
			}
		}
	}

	/**
	 * Este metódo é especifíco para gerar a linha 10(dez) do txt de fatura ele cria os itens da
	 * fatura em duas ou uma coluna dependendo da quantidade
	 * de itens
	 * [UC0321] Emitir Fatura de Cliente Responsável
	 * 
	 * @author Pedro Alexandre
	 * @date 29/04/2006
	 * @param colecaoFaturaItemColuna1
	 * @param colecaoFaturaItemColuna2
	 * @return
	 */
	protected StringBuffer gerarLinha10FaturaClienteResponsavel(FaturaItem[] colecaoFaturaItemColuna1, FaturaItem[] colecaoFaturaItemColuna2){

		// Cria a variável que vai armazenar a linha 10(dez) gerada
		StringBuffer linha10 = new StringBuffer();

		// Cria as variáveis que iram armazenar as colunas 1 e 2
		String coluna1 = null;
		String coluna2 = null;

		// Laço para gerar as colunas 1 e 2 dependendo da quantidade de itens
		for(int i = 0; i < colecaoFaturaItemColuna1.length; i++){

			// Recupera o item de fatura da coluna 1 e 2
			FaturaItem faturaItemColuna1 = colecaoFaturaItemColuna1[i];
			FaturaItem faturaItemColuna2 = colecaoFaturaItemColuna2[i];

			// Recupera a matrícula do imóvel da coluna 1 e formata a matrícula
			// (ex:500000001 em 5000000.1)
			String matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(8, "" + faturaItemColuna1.getImovel().getId());
			matriculaImovelFormatada = matriculaImovelFormatada.substring(0, 7) + "." + matriculaImovelFormatada.substring(7, 8);

			// Caso o consumo do item da fatura não esteja nulo
			// Recupera o consumo do item da fatura
			// Caso contrário atribui 0(zero)
			String consumoFormatado = "";
			if(faturaItemColuna1.getNumeroConsumo() != null){
				consumoFormatado = faturaItemColuna1.getNumeroConsumo() + " M3";
			}else{
				consumoFormatado = "0 M3";
			}

			// Recupera o valor do item da fatura
			String valorFormatado = (Util.formatarMoedaReal(faturaItemColuna1.getValorConta()));

			// Cria a coluna 1(um)
			coluna1 = " " + "3" + matriculaImovelFormatada + Util.completaStringComEspacoAEsquerda(consumoFormatado, 17)
							+ Util.completaStringComEspacoAEsquerda(valorFormatado, 24);

			// Caso exista o item da fatura para a coluna 2(dois)
			if(faturaItemColuna2 != null){
				// Recupera a matrícula do imóvel da coluna 2(dois) e formata a
				// matrícula (ex:500000001 em 5000000.1)

				String matriculaImovelFormatadaColuna2 = Util.adicionarZerosEsquedaNumero(8, "" + faturaItemColuna2.getImovel().getId());

				matriculaImovelFormatadaColuna2 = matriculaImovelFormatadaColuna2.substring(0, 7) + "."
								+ matriculaImovelFormatadaColuna2.substring(7, 8);

				// Caso o consumo do item da fatura não esteja nulo
				// Recupera o consumo do item da fatura
				// Caso contrário atribui 0(zero)
				if(faturaItemColuna2.getNumeroConsumo() != null){
					consumoFormatado = faturaItemColuna2.getNumeroConsumo() + " M3";
				}else{
					consumoFormatado = "0 M3";
				}

				// Recupera o valor do item da fatura
				valorFormatado = (Util.formatarMoedaReal(faturaItemColuna2.getValorConta()));

				// Cria a coluna 2(dois)
				coluna2 = matriculaImovelFormatadaColuna2 + Util.completaStringComEspacoAEsquerda(consumoFormatado, 17)
								+ Util.completaStringComEspacoAEsquerda(valorFormatado, 24);
			}

			// Adiciona na linha 10 as colunas 1 e 2
			linha10.append(coluna1 + Util.completaString("", 17) + coluna2);

			coluna1 = "";
			coluna2 = "";

			// Adiciona uma linha em branco na string
			linha10.append(System.getProperty("line.separator"));
		}

		// Retorna a linha 10(dez) do txt
		return linha10;
	}

	/**
	 * [UC0329] - Restabelecer Situação Anterior de Conta
	 * 
	 * @author Fernanda Paiva
	 * @date 05/05/2006
	 * @param registrosRemocao
	 * @throws ControladorException
	 */

	public void restabelecerSituacaoAnteriorConta(Collection colecaoContas, Usuario usuarioLogado) throws ControladorException{

		Iterator iteratorContas = colecaoContas.iterator();

		try{
			while(iteratorContas.hasNext()){

				FiltroConta filtroContaRestaurada = new FiltroConta();
				Integer idContaHistorico = null;
				Integer situacaoAtual = null;
				Integer situacaoAnterior = null;

				Object object = iteratorContas.next();
				if(object instanceof Conta){

					Conta conta = (Conta) object;

					// ------------ <REGISTRAR TRANSAÇÃO>----------------------------

					RegistradorOperacao registradorOperacao = new RegistradorOperacao(
									Operacao.OPERACAO_CANCELAMENTO_RETIFICACAO_CONTA_DESFAZER, conta.getImovel().getId(), conta.getId(),
									new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacao.registrarOperacao(conta);

					// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

					// filtro conta
					FiltroConta filtroConta = new FiltroConta();

					filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, conta.getId()));

					// Procura o conta na base
					Conta contaNaBase = (Conta) ((List) (getControladorUtil().pesquisar(filtroConta, Conta.class.getName()))).get(0);

					// Verificar se o conta já foi atualizado por outro usuário
					// durante
					// esta atualização
					if(contaNaBase.getUltimaAlteracao() != null){
						if(contaNaBase.getUltimaAlteracao().after(conta.getUltimaAlteracao())){
							sessionContext.setRollbackOnly();
							throw new ControladorException("atencao.atualizacao.timestamp");
						}
					}

					if(conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.RETIFICADA)){

						FiltroConta filtroContaRetificada = new FiltroConta();

						filtroContaRetificada.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, conta.getImovel().getId()));

						filtroContaRetificada.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, conta
										.getAnoMesReferenciaConta()));

						filtroContaRetificada.adicionarParametro(new ParametroSimples(FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
										DebitoCreditoSituacao.RETIFICADA.intValue()));

						Collection contasParaExcluir = getControladorUtil().pesquisar(filtroContaRetificada, Conta.class.getName());

						if(!Util.isVazioOrNulo(contasParaExcluir)){
							Conta contaParaExcluir = (Conta) Util.retonarObjetoDeColecao(contasParaExcluir);

							Integer idContaParaExcluir = contaParaExcluir.getId();

							// ContaCategoriaConsumoFaixa
							FiltroContaCategoriaConsumoFaixa filtroContaCategoriaConsumoFaixa = new FiltroContaCategoriaConsumoFaixa();
							filtroContaCategoriaConsumoFaixa.adicionarParametro(new ParametroSimples(
											FiltroContaCategoriaConsumoFaixa.CONTA_ID, idContaParaExcluir));

							Collection<ContaCategoriaConsumoFaixa> colecaoContaCategoriaConsumoFaixa = this.getControladorUtil().pesquisar(
											filtroContaCategoriaConsumoFaixa, ContaCategoriaConsumoFaixa.class.getName());

							if(!Util.isVazioOrNulo(colecaoContaCategoriaConsumoFaixa)){
								for(ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa : colecaoContaCategoriaConsumoFaixa){
									this.getControladorUtil().remover(contaCategoriaConsumoFaixa);
								}
							}

							// DebitoCobradoCategoria
							FiltroDebitoCobradoCategoria filtroDebitoCobradoCategoria = new FiltroDebitoCobradoCategoria();
							filtroDebitoCobradoCategoria.adicionarParametro(new ParametroSimples(
											FiltroDebitoCobradoCategoria.DEBITO_COBRADO_CONTA_ID, idContaParaExcluir));

							Collection<DebitoCobradoCategoria> colecaoDebitoCobradoCategoria = this.getControladorUtil().pesquisar(
											filtroDebitoCobradoCategoria, DebitoCobradoCategoria.class.getName());

							if(!Util.isVazioOrNulo(colecaoDebitoCobradoCategoria)){
								for(DebitoCobradoCategoria debitoCobradoCategoria : colecaoDebitoCobradoCategoria){
									this.getControladorUtil().remover(debitoCobradoCategoria);
								}
							}

							// DebitoCobrado
							FiltroDebitoCobrado filtroDebitoCobrado = new FiltroDebitoCobrado();
							filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.CONTA_ID, idContaParaExcluir));

							Collection<DebitoCobrado> colecaoDebitoCobrado = this.getControladorUtil().pesquisar(filtroDebitoCobrado,
											DebitoCobrado.class.getName());

							if(!Util.isVazioOrNulo(colecaoDebitoCobrado)){
								for(DebitoCobrado debitoCobrado : colecaoDebitoCobrado){
									this.getControladorUtil().remover(debitoCobrado);
								}
							}

							// CreditoRealizadoCategoria
							FiltroCreditoRealizadoCategoria filtroCreditoRealizadoCategoria = new FiltroCreditoRealizadoCategoria();
							filtroCreditoRealizadoCategoria.adicionarParametro(new ParametroSimples(
											FiltroCreditoRealizadoCategoria.CREDITO_REALIZADO_CONTA_ID, idContaParaExcluir));

							Collection<CreditoRealizadoCategoria> colecaoCreditoRealizadoCategoria = this.getControladorUtil().pesquisar(
											filtroCreditoRealizadoCategoria, CreditoRealizadoCategoria.class.getName());

							if(!Util.isVazioOrNulo(colecaoCreditoRealizadoCategoria)){
								for(CreditoRealizadoCategoria creditoRealizadoCategoria : colecaoCreditoRealizadoCategoria){
									this.getControladorUtil().remover(creditoRealizadoCategoria);
								}
							}

							// CreditoRealizado
							FiltroCreditoRealizado filtroCreditoRealizado = new FiltroCreditoRealizado();
							filtroCreditoRealizado.adicionarParametro(new ParametroSimples(FiltroCreditoRealizado.CONTA_ID,
											idContaParaExcluir));

							Collection<CreditoRealizado> colecaoCreditoRealizado = this.getControladorUtil().pesquisar(
											filtroCreditoRealizado, CreditoRealizado.class.getName());

							if(!Util.isVazioOrNulo(colecaoCreditoRealizado)){
								for(CreditoRealizado creditoRealizado : colecaoCreditoRealizado){
									this.getControladorUtil().remover(creditoRealizado);
								}
							}

							// ContaImpostosDeduzidos
							FiltroContaImpostosDeduzidos filtroContaImpostosDeduzidos = new FiltroContaImpostosDeduzidos();
							filtroContaImpostosDeduzidos.adicionarParametro(new ParametroSimples(FiltroContaImpostosDeduzidos.CONTA_ID,
											idContaParaExcluir));

							Collection<ContaImpostosDeduzidos> colecaoContaImpostosDeduzidos = this.getControladorUtil().pesquisar(
											filtroContaImpostosDeduzidos, ContaImpostosDeduzidos.class.getName());

							if(!Util.isVazioOrNulo(colecaoContaImpostosDeduzidos)){
								for(ContaImpostosDeduzidos contaImpostosDeduzidos : colecaoContaImpostosDeduzidos){
									this.getControladorUtil().remover(contaImpostosDeduzidos);
								}
							}

							// ContaCategoria
							FiltroContaCategoria filtroContaCategoria = new FiltroContaCategoria();
							filtroContaCategoria
											.adicionarParametro(new ParametroSimples(FiltroContaCategoria.CONTA_ID, idContaParaExcluir));

							Collection<ContaCategoria> colecaoContaCategoria = this.getControladorUtil().pesquisar(filtroContaCategoria,
											ContaCategoria.class.getName());

							if(!Util.isVazioOrNulo(colecaoContaCategoria)){
								for(ContaCategoria contaCategoria : colecaoContaCategoria){
									this.getControladorUtil().remover(contaCategoria);
								}
							}

							// ClienteConta
							FiltroClienteConta filtroClienteConta = new FiltroClienteConta();
							filtroClienteConta.adicionarParametro(new ParametroSimples(FiltroClienteConta.CONTA_ID, idContaParaExcluir));

							Collection<ClienteConta> colecaoClienteConta = this.getControladorUtil().pesquisar(filtroClienteConta,
											ClienteConta.class.getName());

							if(!Util.isVazioOrNulo(colecaoClienteConta)){
								for(ClienteConta clienteConta : colecaoClienteConta){
									this.getControladorUtil().remover(clienteConta);
								}
							}

							// Conta
							this.getControladorUtil().remover(contaParaExcluir);

							// ContaGeral
							FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
							filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, idContaParaExcluir));

							Collection<ContaGeral> colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral,
											ContaGeral.class.getName());

							if(!Util.isVazioOrNulo(colecaoContaGeral)){
								for(ContaGeral contaGeral : colecaoContaGeral){
									this.getControladorUtil().remover(contaGeral);
								}
							}

							// Restaurar do histórico
							FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
							filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.IMOVEL_ID, conta.getImovel()
											.getId()));
							filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ANO_MES_REFERENCIA, Integer
											.valueOf(conta.getReferencia())));
							filtroContaHistorico.adicionarParametro(new ParametroSimples(
											FiltroContaHistorico.DEBITO_CREDITO_SITUACAO_ATUAL,
											DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO));
							Collection<ContaHistorico> colecaoContaHistorico = this.getControladorUtil().pesquisar(filtroContaHistorico,
											ContaHistorico.class.getName());

							this.transferirContasHistoricoParaConta(colecaoContaHistorico, 0, conta.getDebitoCreditoSituacaoAtual().getId());

							if(!colecaoContaHistorico.isEmpty()){
								idContaHistorico = colecaoContaHistorico.iterator().next().getId();
							}

						}
					}

					filtroContaRestaurada.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, conta.getImovel().getId()));
					filtroContaRestaurada.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, Integer.valueOf(conta
									.getReferencia())));

					if(conta.getDebitoCreditoSituacaoAnterior() != null){
						situacaoAnterior = conta.getDebitoCreditoSituacaoAnterior().getId();
					}
					situacaoAtual = conta.getDebitoCreditoSituacaoAtual().getId();
				}else if(object instanceof ContaHistorico){

					ContaHistorico contaHistorico = (ContaHistorico) object;

					// ------------ <REGISTRAR TRANSAÇÃO>----------------------------

					RegistradorOperacao registradorOperacao = new RegistradorOperacao(
									Operacao.OPERACAO_CANCELAMENTO_RETIFICACAO_CONTA_DESFAZER, contaHistorico.getImovel().getId(),
									contaHistorico.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
													UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					registradorOperacao.registrarOperacao(contaHistorico);

					// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

					// filtro conta
					FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();

					filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, contaHistorico.getId()));

					// Procura o conta na base
					ContaHistorico contaHistoricoNaBase = (ContaHistorico) ((List) (getControladorUtil().pesquisar(filtroContaHistorico,
									ContaHistorico.class.getName()))).get(0);

					// Verificar se o conta já foi atualizado por outro usuário
					// durante
					// esta atualização
					if(contaHistoricoNaBase.getUltimaAlteracao() != null){
						if(contaHistoricoNaBase.getUltimaAlteracao().after(contaHistorico.getUltimaAlteracao())){
							sessionContext.setRollbackOnly();
							throw new ControladorException("atencao.atualizacao.timestamp");
						}
					}

					// Caso a situação atual da contahistorico (DCST_IDATUAL) corresponda a
					// Cancelada
					if(contaHistorico.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.CANCELADA)){
						// altera a data e o motivo do cancelamento
						try{
							/*
							 * Inicio: Registrar Transacao de Desfazer Cancelamento
							 */

							contaHistorico.setDataCancelamento(null);
							contaHistorico.setContaMotivoCancelamento(null);
							getControladorTransacao().registrarTransacao(contaHistorico);
							/*
							 * Fim: Registrar Transacao de Desfazer Cancelamento
							 */

							repositorioFaturamento.restabelecerSituacaoAnteriorContaCancelada(contaHistorico.getId().toString());
						}catch(ErroRepositorioException e){
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", e);
						}

						// Restaurar do histórico
						FiltroContaHistorico filtroContaHistorico2 = new FiltroContaHistorico();
						filtroContaHistorico2.adicionarParametro(new ParametroSimples(FiltroContaHistorico.IMOVEL_ID, contaHistorico
										.getImovel().getId()));
						filtroContaHistorico2.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ANO_MES_REFERENCIA, Integer
										.valueOf(contaHistorico.getAnoMesReferenciaConta())));
						filtroContaHistorico2.adicionarParametro(new ParametroSimples(FiltroContaHistorico.DEBITO_CREDITO_SITUACAO_ATUAL,
										DebitoCreditoSituacao.CANCELADA));
						filtroContaHistorico2.adicionarCaminhoParaCarregamentoEntidade("localidade");
						Collection<ContaHistorico> colecaoContaHistorico = this.getControladorUtil().pesquisar(filtroContaHistorico2,
										ContaHistorico.class.getName());

						this.transferirContasHistoricoParaConta(colecaoContaHistorico, 0, contaHistorico.getDebitoCreditoSituacaoAtual()
										.getId());

						if(!colecaoContaHistorico.isEmpty()){
							idContaHistorico = colecaoContaHistorico.iterator().next().getId();
						}
					}

					filtroContaRestaurada
									.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, contaHistorico.getImovel().getId()));
					filtroContaRestaurada.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, Integer.valueOf(contaHistorico
									.getAnoMesReferenciaConta())));

					if(contaHistorico.getDebitoCreditoSituacaoAnterior() != null){
						situacaoAnterior = contaHistorico.getDebitoCreditoSituacaoAnterior().getId();
					}
					situacaoAtual = contaHistorico.getDebitoCreditoSituacaoAtual().getId();
				}

				Conta contaRestaurada = (Conta) Util.retonarObjetoDeColecao(Fachada.getInstancia().pesquisar(filtroContaRestaurada,
								Conta.class.getName()));

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
								Operacao.OPERACAO_CANCELAMENTO_RETIFICACAO_CONTA_DESFAZER, contaRestaurada.getImovel().getId(),
								contaRestaurada.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
												UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(contaRestaurada);

				FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
				filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, contaRestaurada.getId()));

				if(situacaoAnterior != null){
					// altera as situações anterior e atual da conta
					try{
						/*
						 * Inicio: Registrar Transacao de Desfazer Cancelamento
						 */
						// conta.setDataCancelamento(null);
						// conta.setContaMotivoCancelamento(null);
						DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao(situacaoAnterior);
						contaRestaurada.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);
						contaRestaurada.setDebitoCreditoSituacaoAnterior(null);
						getControladorTransacao().registrarTransacao(contaRestaurada);

						if(idContaHistorico != null){
							repositorioFaturamento.alterarSituacaoAnteriorAtualConta(idContaHistorico.toString(), situacaoAnterior,
											situacaoAtual);
						}else{
							repositorioFaturamento.alterarSituacaoAnteriorAtualConta(contaRestaurada.getId().toString(), situacaoAnterior,
											situacaoAtual);

						}

					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				}else{
					if(contaRestaurada.getDataRetificacao() == null && contaRestaurada.getDataInclusao() == null){
						// altera as situações anterior e atual da conta
						try{
							/*
							 * Inicio: Registrar Transacao de Desfazer Cancelamento
							 */
							FiltroConta filtroConta = new FiltroConta();
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, contaRestaurada.getImovel().getId()));
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, contaRestaurada
											.getAnoMesReferenciaConta()));
							Conta conta = (Conta) Util.retonarObjetoDeColecao(Fachada.getInstancia().pesquisar(filtroConta,
											Conta.class.getName()));
							conta.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));
							getControladorTransacao().registrarTransacao(conta);
							/*
							 * Fim: Registrar Transacao de Desfazer Cancelamento
							 */
							if(idContaHistorico != null){
								repositorioFaturamento.alterarSituacaoConta(idContaHistorico.toString(), DebitoCreditoSituacao.NORMAL);
							}else{
								repositorioFaturamento.alterarSituacaoConta(conta.getId().toString(), DebitoCreditoSituacao.NORMAL);

							}
						}catch(ErroRepositorioException e){
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", e);
						}
					}else{
						if(contaRestaurada.getDataRetificacao() != null){
							// altera as situações anterior e atual da conta

							try{

								/*
								 * Inicio: Registrar Transacao de Desfazer Cancelamento
								 */
								// conta.setDataCancelamento(null);
								// conta.setContaMotivoCancelamento(null);
								FiltroConta filtroConta = new FiltroConta();
								filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, contaRestaurada.getImovel()
												.getId()));
								filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, contaRestaurada
												.getAnoMesReferenciaConta()));
								Conta conta = (Conta) Util.retonarObjetoDeColecao(Fachada.getInstancia().pesquisar(filtroConta,
												Conta.class.getName()));
								conta.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));
								getControladorTransacao().registrarTransacao(conta);

								conta.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.RETIFICADA));
								getControladorTransacao().registrarTransacao(conta);

								// conta.setDebitoCreditoSituacaoAnterior(null);

								/*
								 * Fim: Registrar Transacao de Desfazer Cancelamento
								 */
								if(idContaHistorico != null){
									repositorioFaturamento.alterarSituacaoConta(idContaHistorico.toString(),
													DebitoCreditoSituacao.RETIFICADA);
								}else{
									repositorioFaturamento.alterarSituacaoConta(conta.getId().toString(), DebitoCreditoSituacao.RETIFICADA);

								}
							}catch(ErroRepositorioException e){
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema", e);
							}
						}else{
							// altera as situações anterior e atual da conta
							FiltroConta filtroConta = new FiltroConta();
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, contaRestaurada.getImovel().getId()));
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, contaRestaurada
											.getAnoMesReferenciaConta()));
							Conta conta = (Conta) Util.retonarObjetoDeColecao(Fachada.getInstancia().pesquisar(filtroConta,
											Conta.class.getName()));
							conta.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));
							getControladorTransacao().registrarTransacao(conta);
							try{
								if(idContaHistorico != null){
									repositorioFaturamento
													.alterarSituacaoConta(idContaHistorico.toString(), DebitoCreditoSituacao.INCLUIDA);
								}else{
									repositorioFaturamento.alterarSituacaoConta(conta.getId().toString(), DebitoCreditoSituacao.INCLUIDA);

								}
							}catch(ErroRepositorioException e){
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema", e);
							}
						}
					}
				}

			}
		}catch(Exception e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0113] - Gerar Faturamento Grupo Author: Rafael Santos Data: 05/05/2006
	 * Dados da Ligacao Esgoto do Imovel
	 * 
	 * @param imovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public LigacaoEsgoto obterLigacaoEsgotoImovel(Integer idImovel) throws ControladorException{

		LigacaoEsgoto ligacaoEsgoto = new LigacaoEsgoto();

		// Pesquisa LigacaoEsgoto
		try{
			ligacaoEsgoto = repositorioFaturamento.obterLigacaoEsgotoImovel(idImovel);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return ligacaoEsgoto;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Pesquisa o valor do percentual de esgoto para o imóvel informado.
	 * 
	 * @author Pedro Alexandre
	 * @date 18/09/2006
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public BigDecimal obterPercentualLigacaoEsgotoImovel(Integer idImovel) throws ControladorException{

		// Pesquisa LigacaoEsgoto
		try{
			return repositorioFaturamento.obterPercentualLigacaoEsgotoImovel(idImovel);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0084] Gerar Faturamento Imediato
	 * [SB0020] Determinar Percentual de Esgoto
	 * Método chamado pelos subfluxos: '[SB0005] Gerar Dados da Conta' e '[SB0007] Gerar Movimento
	 * Roteiro da Empresa'
	 * 
	 * @author Saulo Lima
	 * @since 05/12/2013
	 * @param Imovel
	 * @return BigDecimal percentualEsgoto
	 * @throws ControladorException
	 */
	private BigDecimal determinarPercentualEsgoto(Imovel imovel) throws ControladorException{

		String pHbilitarTarifaSocial = (String) ParametroFaturamento.P_HABILITAR_TARIFA_SOCIAL_PERCENTUAL_ESGOTO.executar();
		String idPerfil = null;

		BigDecimal percentualEsgoto = BigDecimal.ZERO;

		// 1. Caso o imóvel seja TARIFA SOCIAL (IPER_CDIMOVELPERFIL com o valor correspondente à
		// tarifa social) e seja para aplicar o percentual da tarifa social independentemente da
		// situação da ligação de esgoto do imóvel (P_HABILITAR_TARIFA_SOCIAL_PERCENTUAL_ESGOTO):
		// 1.1. Obter o percentual de esgoto existente no PERFIL DE ESGOTO correspondente a TARIFA
		// SOCIAL (LEPF_PCESGOTO da tabela LIGACAO_ESGOTO_PERFIL com LEPF_ID igual ao valor do
		// parâmetro P_LIGACAO_ESGOTO_PERFIL_TARIFA_SOCIAL).

		if(imovel.getImovelPerfil().getId().equals(ImovelPerfil.TARIFA_SOCIAL)
						&& (pHbilitarTarifaSocial != null && pHbilitarTarifaSocial.equals(ConstantesSistema.SIM.toString()))){

				idPerfil = (String) ParametroFaturamento.P_LIGACAO_ESGOTO_PERFIL_TARIFA_SOCIAL.executar();

				FiltroLigacaoEsgotoPerfil filtro = new FiltroLigacaoEsgotoPerfil();
				filtro.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.ID, idPerfil));
				Collection colecaoLigacaoEsgotoPerfil = getControladorUtil().pesquisar(filtro, LigacaoEsgotoPerfil.class.getName());
				LigacaoEsgotoPerfil esgotoPerfil = (LigacaoEsgotoPerfil) Util.retonarObjetoDeColecao(colecaoLigacaoEsgotoPerfil);

				percentualEsgoto = esgotoPerfil.getPercentualEsgotoConsumidaColetada();

		}else{

			// Obter Percentual Ligação Esgoto Imóvel
			percentualEsgoto = obterPercentualLigacaoEsgotoImovel(imovel.getId());

			if(imovel.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.FACTIVEL_FATURADA)){

				if(percentualEsgoto == null){



					if(imovel.getImovelPerfil().getId().equals(ImovelPerfil.TARIFA_SOCIAL)){

						idPerfil = (String) ParametroFaturamento.P_LIGACAO_ESGOTO_PERFIL_TARIFA_SOCIAL.executar();

					}else{

						String localidadeId = imovel.getLocalidade().getId().toString();

						String[] pLocalidadesCapital = ((String) ParametroFaturamento.P_LOCALIDADES_CAPITAL.executar()).split(",");

						boolean localidadeCapital = false;
						for(int x = 0; x < pLocalidadesCapital.length; x++){

							if(pLocalidadesCapital[x].equals(ConstantesSistema.INVALIDO_ID.toString())){
								throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_LOCALIDADES_CAPITAL");
							}

							if(pLocalidadesCapital[x].equals(localidadeId)){
								localidadeCapital = true;
								break;
							}
						}

						if(localidadeCapital){
							idPerfil = (String) ParametroFaturamento.P_LIGACAO_ESGOTO_PERFIL_CAPITAL.executar();
						}else{
							idPerfil = (String) ParametroFaturamento.P_LIGACAO_ESGOTO_PERFIL_INTERIOR.executar();
						}

						if(idPerfil.equals(ConstantesSistema.INVALIDO_ID.toString())){
							throw new ControladorException("atencao.sistemaparametro_inexistente", null, "Perfil de Ligação de Esgoto");
						}
					}

					FiltroLigacaoEsgotoPerfil filtro = new FiltroLigacaoEsgotoPerfil();
					filtro.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.ID, idPerfil));
					Collection colecaoLigacaoEsgotoPerfil = getControladorUtil().pesquisar(filtro, LigacaoEsgotoPerfil.class.getName());
					LigacaoEsgotoPerfil esgotoPerfil = (LigacaoEsgotoPerfil) Util.retonarObjetoDeColecao(colecaoLigacaoEsgotoPerfil);

					percentualEsgoto = esgotoPerfil.getPercentualEsgotoConsumidaColetada();
				}
			}else{

				// Caso o Percentual de esgoto igual a zero (0),
				// recebe LEPF_PCESGOTO da tabela LIGACAO_ESGOTO_PERFIL
				// com LEPF_ID = LEPF_ID da tabela LIGACAO_ESGOTO
				if(percentualEsgoto == null || percentualEsgoto.compareTo(BigDecimal.ZERO) == 0){
					if(!Util.isVazioOuBranco(imovel.getLigacaoEsgoto())){
						if(!Util.isVazioOuBranco(imovel.getLigacaoEsgoto().getLigacaoEsgotoPerfil())){
							percentualEsgoto = imovel.getLigacaoEsgoto().getLigacaoEsgotoPerfil().getPercentualEsgotoConsumidaColetada();
						}
					}
				}

				if(percentualEsgoto == null){
					percentualEsgoto = BigDecimal.ZERO;
				}
			}

		}

		return percentualEsgoto;
	}

	protected Map<Integer, Map<EmitirContaHelper, EmitirContaHelper>> dividirColecao(Collection colecaoContas){

		Map<Integer, Map<EmitirContaHelper, EmitirContaHelper>> mapContasOrdenada = new HashMap();
		List listColecaoContas = new ArrayList();
		listColecaoContas.addAll(colecaoContas);
		int quantidadeContas = 0;
		int quantidadeContasColecao = listColecaoContas.size();
		int metadeColecao = 0;
		if(quantidadeContasColecao % 2 == 0){
			metadeColecao = quantidadeContasColecao / 2;
		}else{
			metadeColecao = (quantidadeContasColecao / 2) + 1;
		}
		while(quantidadeContas < metadeColecao){
			Map<EmitirContaHelper, EmitirContaHelper> mapContas = new HashMap();
			EmitirContaHelper emitirContaHelperPrimeiraParte = (EmitirContaHelper) listColecaoContas.get(quantidadeContas);
			EmitirContaHelper emitirContaHelperSegundaParte = null;
			if(metadeColecao + quantidadeContas < quantidadeContasColecao){
				emitirContaHelperSegundaParte = (EmitirContaHelper) listColecaoContas.get(metadeColecao + quantidadeContas);
			}
			mapContas.put(emitirContaHelperPrimeiraParte, emitirContaHelperSegundaParte);
			mapContasOrdenada.put(quantidadeContas, mapContas);
			mapContas = null;

			quantidadeContas++;
		}
		quantidadeContasColecao = 0;

		return mapContasOrdenada;
	}

	protected int atualizaSequencial(int sequencial, int situacao, int metadeColecao){

		int moduloSequencial = sequencial;
		if(sequencial > 1000){
			moduloSequencial = sequencial % 1000;
			if(moduloSequencial == 0){
				moduloSequencial = sequencial;
			}
		}
		if(situacao == 1 && moduloSequencial > metadeColecao){
			sequencial = sequencial - metadeColecao;
		}else{
			if(situacao == 2 && moduloSequencial <= metadeColecao){
				sequencial = sequencial + metadeColecao;
			}
		}
		return sequencial;
	}

	protected Collection[] pesquisarColecaoContasEstouroConsumo(Collection colecaoContas) throws ControladorException{

		Collection colecaoContaEstouroConsumo = new ArrayList();

		// Collection colecaoContaEstouroConsumoTemporaria = new ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo = colecaoTotalContas.size(); int
		 * quantidadeMaximaPorColecao = 100;
		 */
		Collection idsContasJaUsadas = new ArrayList();
		// for (int i = 0; i < limiteMaximo; i = i + 100) {

		// int totalContas = colecaoContaEstouroConsumo.size();

		// System.out.println("################### PESQUISANDO CONTAS ESTOURO :"
		// + totalContas + "#########################");

		/*
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0; limiteSuperior =
		 * limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; } }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		// try {
		/*
		 * colecaoContaEstouroConsumo = repositorioFaturamento
		 * .pesquisarContasEstouroOuBaixoConsumo( colecaoContas,
		 * ContaMotivoRevisao.REVISAO_AUTOMATICA_ESTOURO_CONSUMO);
		 */
		Iterator iteratorEstouroConsumoAux = colecaoContaEstouroConsumo.iterator();
		while(iteratorEstouroConsumoAux.hasNext()){
			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) iteratorEstouroConsumoAux.next();
			// inseri o id da conta para não entrar o id da conta na
			// proxima
			// consulta
			idsContasJaUsadas.add(emitirContaHelper.getIdConta());
		}
		// colecaoContaEstouroConsumo.addAll(colecaoContaEstouroConsumoTemporaria);
		// colecaoContaEstouroConsumoTemporaria = null;

		// ********************** CONTAS ESTOURO CONSUMO
		// **************************************************

		/*
		 * } catch (ErroRepositorioException e) { throw new ControladorException("erro.sistema", e);
		 * }
		 */
		// }
		// colecaoContas.removeAll(idsContasJaUsadas);
		Collection[] retorno = new Collection[2];
		retorno[0] = colecaoContaEstouroConsumo;
		retorno[1] = idsContasJaUsadas;

		// idsContasJaUsadas = null;
		return retorno;
	}

	protected Collection[] pesquisarColecaoContasBaixoConsumo(Collection colecaoContas) throws ControladorException{

		Collection colecaoContaBaixoConsumo = new ArrayList();

		// Collection colecaoContaBaixoConsumoTemporaria = new ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo = colecaoTotalContas.size(); int
		 * quantidadeMaximaPorColecao = 100;
		 */
		Collection idsContasJaUsadas = new ArrayList();
		// for (int i = 0; i < limiteMaximo; i = i + 100) {

		// int totalContas = colecaoContaBaixoConsumo.size();

		// System.out.println("################### PESQUISANDO CONTAS BAIXO
		// CONSUMO :" + totalContas + "#########################");

		/*
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0; limiteSuperior =
		 * limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; } }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		// try {
		// ********************** CONTAS BAIXO CONSUMO
		// **************************************************
		// recebe uma coleção de parametros(Object[]) das contas com
		// baixo
		// consumo
		/*
		 * colecaoContaBaixoConsumo = repositorioFaturamento
		 * .pesquisarContasEstouroOuBaixoConsumo(colecaoContas,
		 * ContaMotivoRevisao.REVISAO_AUTOMATICA_BAIXO_CONSUMO);
		 */
		Iterator iteratorBaixoConsumoAux = colecaoContaBaixoConsumo.iterator();
		while(iteratorBaixoConsumoAux.hasNext()){
			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) iteratorBaixoConsumoAux.next();
			// inseri o id da conta para não entrar o id da conta na
			// proxima
			// consulta
			idsContasJaUsadas.add(emitirContaHelper.getIdConta());
		}

		// colecaoContaBaixoConsumo.addAll(colecaoContaBaixoConsumoTemporaria);
		// colecaoContaBaixoConsumoTemporaria = null;

		// ********************** FIM CONTAS BAIXO CONSUMO
		// ************************************************

		/*
		 * } catch (ErroRepositorioException e) { throw new ControladorException("erro.sistema", e);
		 * }
		 */
		// }
		// colecaoContas.removeAll(idsContasJaUsadas);
		Collection[] retorno = new Collection[2];
		retorno[0] = colecaoContaBaixoConsumo;
		retorno[1] = idsContasJaUsadas;

		// idsContasJaUsadas = null;
		return retorno;
	}

	protected Collection[] pesquisarColecaoContasDebitoAutomatico(Collection colecaoContas) throws ControladorException{

		Collection colecaoContaDebitoAutomatico = new ArrayList();

		// Collection colecaoContaDebitoAutomaticoTemporaria = new ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo = colecaoTotalContas.size(); int
		 * quantidadeMaximaPorColecao = 100;
		 */
		Collection idsContasJaUsadas = new ArrayList();

		// for (int i = 0; i < limiteMaximo; i = i + 100) {

		// int totalContas = colecaoContaDebitoAutomatico.size();
		// System.out.println("################### PESQUISANDO CONTAS DEBITO
		// AUTOMATICO :" + totalContas + "#########################");

		/*
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0; limiteSuperior =
		 * limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; } }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		try{
			// ********************** CONTAS DEBITO AUTOMATICO
			// **********************************************************
			// recebe uma coleção de emitir contas helper com
			// Dédito automático
			colecaoContaDebitoAutomatico = repositorioFaturamento.pesquisarContasDebitoAutomatico(colecaoContas);
			Iterator iteratorDebitoAutomaticoAux = colecaoContaDebitoAutomatico.iterator();
			while(iteratorDebitoAutomaticoAux.hasNext()){
				EmitirContaHelper emitirContaHelper = (EmitirContaHelper) iteratorDebitoAutomaticoAux.next();

				// inseri o id da conta para não entrar o id da conta na
				// proxima
				// consulta
				idsContasJaUsadas.add(emitirContaHelper.getIdConta());
			}
			// colecaoContaDebitoAutomatico.addAll(colecaoContaDebitoAutomaticoTemporaria);

			// colecaoContaDebitoAutomaticoTemporaria = null;

			// ********************** FIM CONTAS DEBITO AUTOMATICO
			// **********************************************************

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		// }
		Collection[] retorno = new Collection[2];
		retorno[0] = colecaoContaDebitoAutomatico;
		retorno[1] = idsContasJaUsadas;

		// idsContasJaUsadas = null;
		return retorno;
	}

	protected Collection[] pesquisarColecaoContasEntregaClienteResponsavel(Collection colecaoContas) throws ControladorException{

		Collection colecaoContaEntregaClienteResponsavel = new ArrayList();

		// Collection colecaoContaEntregaClienteResponsavelTemporaria = new
		// ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo = colecaoTotalContas.size(); int
		 * quantidadeMaximaPorColecao = 100;
		 */
		Collection idsContasJaUsadas = new ArrayList();
		// for (int i = 0; i < limiteMaximo; i = i + 100) {

		/*
		 * int totalContas = colecaoContaEntregaClienteResponsavel.size();
		 * System.out.println("################### PESQUISANDO CONTAS CLIENTE
		 * RESPONSAVEL:" + totalContas + "#########################");
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0; limiteSuperior =
		 * limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; } }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		/*
		 * try { // ********************** CONTAS ENTREGA CLIENTE RESPONSAVEL //
		 * ********************************************************** // recebe
		 * uma coleção de emitir contas helper com // entrega cliente responsável
		 * colecaoContaEntregaClienteResponsavel = repositorioFaturamento
		 * .pesquisarContasClienteResponsavel(colecaoContas); Iterator iteratorEntregaClienteRespAux
		 * = colecaoContaEntregaClienteResponsavel
		 * .iterator(); while (iteratorEntregaClienteRespAux.hasNext()) { EmitirContaHelper
		 * emitirContaHelper = (EmitirContaHelper)
		 * iteratorEntregaClienteRespAux .next(); // inseri o id da conta para não entrar o id da
		 * conta na // proxima // consulta
		 * idsContasJaUsadas.add(emitirContaHelper.getIdConta()); } //
		 * colecaoContaEntregaClienteResponsavel.addAll(colecaoContaEntregaClienteResponsavelTemporaria
		 * ); //
		 * colecaoContaEntregaClienteResponsavelTemporaria = null; } catch (ErroRepositorioException
		 * e) { throw new
		 * ControladorException("erro.sistema", e); }
		 */
		// }
		Collection[] retorno = new Collection[2];
		retorno[0] = colecaoContaEntregaClienteResponsavel;
		retorno[1] = idsContasJaUsadas;

		// idsContasJaUsadas = null;
		return retorno;
	}

	protected Collection pesquisarColecaoContasNormais(Collection colecaoContas) throws ControladorException{

		Collection colecaoContaNormal = new ArrayList();

		// Collection colecaoContaNormalTemporaria = new ArrayList();

		// List colecaoTotalContas = (List) colecaoContas;

		/*
		 * int limiteSuperior; int limiteInferior; int limiteMaximo = colecaoTotalContas.size(); int
		 * quantidadeMaximaPorColecao = 100;
		 */
		// for (int i = 0; i < limiteMaximo; i = i + 100) {
		/*
		 * int totalContas = colecaoContaNormal.size();
		 * System.out.println("################### PESQUISANDO CONTAS NORMAIS :" + totalContas +
		 * "#########################");
		 * if (limiteMaximo < quantidadeMaximaPorColecao) { limiteInferior = 0; limiteSuperior =
		 * limiteMaximo; } else { limiteInferior = i;
		 * limiteSuperior = i + 100;
		 * if (limiteSuperior > limiteMaximo) { limiteSuperior = limiteMaximo; } }
		 */

		// List colecaoContasTemporaria = new ArrayList();
		// colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior,
		// limiteSuperior));
		try{

			// ********************** CONTAS NORMAIS
			// **********************************************************
			// recebe uma coleção de emitir contas helper normais(que
			// não atenderam a nenhuma condição acima)
			colecaoContaNormal = repositorioFaturamento.pesquisarContasNormais(colecaoContas);
			// colecaoContaNormal.addAll(colecaoContaNormalTemporaria);
			// colecaoContaNormalTemporaria = null;
			// ********************** FIM CONTAS NORMAIS
			// **********************************************************

			// colecaoContas = null;
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		// }

		return colecaoContaNormal;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0001] Determinar Mensagem de Acordo com o Tipo de Conta
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected String determinarMensagem(int tipoConta) throws ControladorException{

		String mensagem = "";

		if(tipoConta == 0){// Caso a conta seja com estouro de consumo
			mensagem = "CONTA RETIDA - CONSUMO MUITO SUPERIOR A MEDIA";

		}else if(tipoConta == 1){// Caso a conta seja de baixo consumo
			mensagem = "CONTA RETIDA - CONSUMO MUITO INFERIOR A MEDIA";
		}

		return mensagem;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0002] Determinar tipo de ligação e tipo de medição
	 * 
	 * @author Sávio Luiz
	 * @date 15/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Integer[] determinarTipoLigacaoMedicao(EmitirContaHelper emitirContaHelper) throws ControladorException{

		Integer[] parmSitLigacao = new Integer[2];
		Integer tipoLigacao = LigacaoTipo.LIGACAO_AGUA;
		Integer tipoMedicao = MedicaoTipo.LIGACAO_AGUA;

		LigacaoAguaSituacao ligacaoAguaSituacao = this.getControladorLigacaoAgua().pesquisarLigacaoAguaSituacao(
						emitirContaHelper.getIdLigacaoAguaSituacao());

		// if(emitirContaHelper.getIdLigacaoAguaSituacao().equals(LigacaoAguaSituacao.LIGADO)
		// || emitirContaHelper.getIdLigacaoAguaSituacao().equals(LigacaoAguaSituacao.CORTADO)
		// ||
		// emitirContaHelper.getIdLigacaoAguaSituacao().equals(LigacaoAguaSituacao.LIGADO_A_REVELIA)){

		// Alteração conforme OC0857313
		// .......................................................

		if(ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

			tipoLigacao = LigacaoTipo.LIGACAO_AGUA;
			tipoMedicao = MedicaoTipo.LIGACAO_AGUA;
		}else{

			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = this.getControladorLigacaoEsgoto().pesquisarLigacaoEsgotoSituacao(
							emitirContaHelper.getIdLigacaoEsgotoSituacao());

			// caso contrário se ligação esgoto situação for iguaç a ligado
			// if(emitirContaHelper.getIdLigacaoEsgotoSituacao().equals(LigacaoEsgotoSituacao.LIGADO)){

			if(ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao().equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)){
				tipoLigacao = LigacaoTipo.LIGACAO_ESGOTO;
				tipoMedicao = MedicaoTipo.POCO;
			}
			// .......................................................
		}
		parmSitLigacao[0] = tipoLigacao;
		parmSitLigacao[1] = tipoMedicao;

		return parmSitLigacao;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0003] Obter Dados do Consumo e Medicao Anterior
	 * 
	 * @author Sávio Luiz
	 * @date 17/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder obterDadosConsumoAnterior(Integer idImovel, int anoMes, int qtdMeses, Integer tipoLigacao, Integer tipoMedicao)
					throws ControladorException{

		StringBuilder dadosConsumoAnterior = new StringBuilder();

		int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
		String mesAnoFormatado = Util.formatarAnoMesParaMesAno(anoMesSubtraido) + " -";

		// adiciona o mes/ano formatado com o traço
		dadosConsumoAnterior.append(Util.completaString(mesAnoFormatado, 9));
		// caso o tipo de ligação e medição seja diferente de nulo
		if(tipoLigacao != null && tipoMedicao != null){
			Object[] parmsConsumoHistorico = null;
			Integer idLeituraAnormalidade = null;
			parmsConsumoHistorico = getControladorMicromedicao().obterConsumoAnteriorAnormalidadeDoImovel(idImovel, anoMesSubtraido,
							tipoLigacao);
			Integer numeroConsumoFaturadoMes = null;
			String descricaoAbreviadaAnormalidadeAnterior = null;
			if(parmsConsumoHistorico != null){
				if(parmsConsumoHistorico[0] != null){
					numeroConsumoFaturadoMes = (Integer) parmsConsumoHistorico[0];
				}
				if(parmsConsumoHistorico[1] != null){
					descricaoAbreviadaAnormalidadeAnterior = (String) parmsConsumoHistorico[1];
				}
			}
			try{

				// caso o tipo de medição seja agua
				if(tipoLigacao.equals(MedicaoTipo.LIGACAO_AGUA)){
					idLeituraAnormalidade = repositorioMicromedicao.pesquisarIdLeituraAnormalidadeTipoAgua(idImovel, anoMesSubtraido);
				}else{
					// senão caso o tipo de medição seja poco
					if(tipoMedicao.equals(MedicaoTipo.POCO)){
						idLeituraAnormalidade = repositorioMicromedicao.pesquisarIdLeituraAnormalidadeTipoEsgoto(idImovel, anoMesSubtraido);
					}
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
			// caso o numero consumo faturado do mes for diferente de nulo
			if(numeroConsumoFaturadoMes != null){
				dadosConsumoAnterior.append(Util.completaStringComEspacoAEsquerda("" + numeroConsumoFaturadoMes, 6));
			}else{
				dadosConsumoAnterior.append(Util.completaStringComEspacoAEsquerda("", 6));
			}
			// caso o id dos dados do consumo anterior for diferente de nulo
			if(idLeituraAnormalidade != null){
				dadosConsumoAnterior.append(Util.completaString("-" + idLeituraAnormalidade, 5));
			}else{
				if(descricaoAbreviadaAnormalidadeAnterior != null){
					dadosConsumoAnterior.append(Util.completaString("-" + descricaoAbreviadaAnormalidadeAnterior, 5));
				}else{
					dadosConsumoAnterior.append(Util.completaString("", 5));
				}
			}
		}else{
			// senão completa com espaços em branco
			dadosConsumoAnterior.append(Util.completaString("", 11));
		}

		return dadosConsumoAnterior;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0004] Obter Dados da Medição da Conta
	 * 
	 * @author Sávio Luiz
	 * @date 17/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Object[] obterDadosMedicaoConta(EmitirContaHelper emitirContaHelper, Integer tipoMedicao) throws ControladorException{

		Object[] parmsMedicao = null;
		try{

			// caso o tipo de medição seja agua
			if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)){
				parmsMedicao = repositorioMicromedicao.obterDadosMedicaoContaTipoAgua(emitirContaHelper.getIdImovel(),
								emitirContaHelper.getAmReferencia());
			}else{
				// senão caso o tipo de medição seja poco
				if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO)){
					parmsMedicao = repositorioMicromedicao.obterDadosMedicaoContaTipoPoco(emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia());
				}
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return parmsMedicao;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0005] Obter Consumo Faturado e Consumo médio Diário
	 * 
	 * @author Sávio Luiz
	 * @date 17/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public String[] obterConsumoFaturadoConsumoMedioDiario(EmitirContaHelper emitirContaHelper, Integer tipoMedicao, String diasConsumo)
					throws ControladorException{

		String[] parmsConsumo = new String[2];
		String consumoFaturado = "";
		String consumoMedioDiario = "";
		// caso o tipo de medição seja agua
		if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)){
			if(emitirContaHelper != null){
				Integer consumoAgua = emitirContaHelper.getConsumoAgua();

				if(consumoAgua != null){
					consumoFaturado = Integer.toString(consumoAgua);
				}
			}
		}else{
			// senão caso o tipo de medição seja poco
			if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO)){
				if(emitirContaHelper != null){
					Integer consumoEsgoto = emitirContaHelper.getConsumoEsgoto();

					if(consumoEsgoto != null){
						consumoFaturado = Integer.toString(consumoEsgoto);
					}
				}
			}
		}
		// se o consumo faturado e o dias consumo não estiver vazio
		if(consumoFaturado != null && !consumoFaturado.equals("") && diasConsumo != null && !diasConsumo.equals("")
						&& !diasConsumo.equals("0")){
			BigDecimal consumoMedioBigDecimal = Util.formatarMoedaRealparaBigDecimal(consumoFaturado);
			BigDecimal diasConsumoBigDecimal = Util.formatarMoedaRealparaBigDecimal(diasConsumo);
			if(consumoMedioBigDecimal != null && diasConsumoBigDecimal != null){
				BigDecimal consumoMedioDiarioBigDecimal = consumoMedioBigDecimal.divide(diasConsumoBigDecimal, 2, RoundingMode.UP);
				consumoMedioDiario = consumoMedioDiarioBigDecimal.toString().replace(".", ",");
			}

		}

		parmsConsumo[0] = consumoFaturado;
		parmsConsumo[1] = consumoMedioDiario;

		return parmsConsumo;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0009] Obter Mensagem de Rateio de Consumo ou Consumo fixo de Esgoto
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder obterMensagemRateioConsumo(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao) throws ControladorException{

		StringBuilder mensagemConsumo = new StringBuilder();
		// caso o consumo de rateio seja diferente de vazio
		if(!consumoRateio.equals("") && !consumoRateio.equals("0")){
			mensagemConsumo.append("CONSUMO DO RATEIO - ");
			mensagemConsumo.append(Util.completaStringComEspacoAEsquerda(consumoRateio, 6));
			mensagemConsumo.append("M³");
			// senão completa com espaços em branco
			mensagemConsumo.append(Util.completaString("", 4));
		}else{
			// senão caso o tipo de medição seja diferente de nulo e seja poço e
			// não existam dados para a medição
			if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO) && parmsMedicaoHistorico == null){
				mensagemConsumo.append("VOLUME FIXO DE ESGOTO - ");
				mensagemConsumo.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 6));
				mensagemConsumo.append("M³");

			}else{
				// caso o tipo de medição seja diferente de nulo e seja ligação
				// de agua e
				// o consumo de esgoto seja diferente de nulo d maior que o
				// consumo de agua
				if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA) && emitirContaHelper.getConsumoEsgoto() != null){

					Boolean exibirMsg = Boolean.FALSE;

					if(emitirContaHelper.getConsumoEsgoto() != null && emitirContaHelper.getConsumoAgua() != null){

						if(emitirContaHelper.getConsumoEsgoto() > emitirContaHelper.getConsumoAgua()){

							exibirMsg = Boolean.TRUE;

						}

					}else{

						if((emitirContaHelper.getConsumoEsgoto() != null)
										&& (emitirContaHelper.getConsumoEsgoto().compareTo(Integer.valueOf(0)) == 1)
										&& (emitirContaHelper.getConsumoAgua() == null)){

							exibirMsg = Boolean.TRUE;

						}

					}

					if(exibirMsg){

						mensagemConsumo.append("VOLUME FIXO DE ESGOTO - ");
						mensagemConsumo.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 6));
						mensagemConsumo.append("M3");

					}

				}else{
					// senão completa com espaços em branco
					mensagemConsumo.append(Util.completaString("", 32));
				}
			}
		}

		return mensagemConsumo;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00010] Gerar Linhas da Descrição dos Serviços e Tarifas
	 * 
	 * @author Sávio Luiz
	 * @date 26/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder gerarLinhasDescricaoServicoTarifas(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao) throws ControladorException{

		StringBuilder linhasDescricaoServicosTarifasTotal = new StringBuilder();
		// caso o valor da agua da conta seja maior que zero
		if(emitirContaHelper.getValorAgua() != null && emitirContaHelper.getValorAgua().compareTo(new BigDecimal("0.00")) == 1){
			// [SB0011] - Gerar Linhas da Tarifa de Água
			StringBuilder linhasTarifaAgua = gerarLinhasTarifaAgua(emitirContaHelper, consumoRateio, parmsMedicaoHistorico, tipoMedicao);
			linhasDescricaoServicosTarifasTotal.append(linhasTarifaAgua);
		}
		// caso o valor de água de esgoto seja maior que zero
		if(emitirContaHelper.getValorEsgoto() != null && emitirContaHelper.getValorEsgoto().compareTo(new BigDecimal("0.00")) == 1){

			// [SB0012] - Gerar Linhas da tarifa de Esgoto
			StringBuilder linhasTarifaEsgoto = gerarLinhasTarifaEsgoto(emitirContaHelper);
			// caso a stringBuilder já esteja preenchida
			if(linhasDescricaoServicosTarifasTotal != null && linhasDescricaoServicosTarifasTotal.length() != 0){
				// caso a stringBuilder já esteja preenchida
				if(linhasTarifaEsgoto != null && linhasTarifaEsgoto.length() != 0){
					linhasDescricaoServicosTarifasTotal.append(System.getProperty("line.separator"));
					linhasDescricaoServicosTarifasTotal.append(linhasTarifaEsgoto);
				}
			}else{
				linhasDescricaoServicosTarifasTotal.append(linhasTarifaEsgoto);
			}

		}
		// caso o valor de debitos cobrados da conta seja maior que zero
		if(emitirContaHelper.getDebitos() != null && emitirContaHelper.getDebitos().compareTo(new BigDecimal("0.00")) == 1){
			// [SB0013] - Gerar Linhas de Débitos Cobrados
			StringBuilder linhasDebitoCobrados = gerarLinhasDebitoCobrados(emitirContaHelper);
			// caso a stringBuilder já esteja preenchida
			if(linhasDescricaoServicosTarifasTotal != null && linhasDescricaoServicosTarifasTotal.length() != 0){
				// caso a stringBuilder já esteja preenchida
				if(linhasDebitoCobrados != null && linhasDebitoCobrados.length() != 0){
					linhasDescricaoServicosTarifasTotal.append(System.getProperty("line.separator"));
					linhasDescricaoServicosTarifasTotal.append(linhasDebitoCobrados);
				}
			}else{
				linhasDescricaoServicosTarifasTotal.append(linhasDebitoCobrados);
			}

		}
		// caso o valor de créditos realizados seja maior que zero
		if(emitirContaHelper.getValorCreditos() != null && emitirContaHelper.getValorCreditos().compareTo(new BigDecimal("0.00")) == 1){
			// [SB0014] - Gerar Linhas de Crédito Realizado
			StringBuilder linhasCreditoRealizados = gerarLinhasCreditosRealizados(emitirContaHelper);

			// caso a stringBuilder já esteja preenchida
			if(linhasDescricaoServicosTarifasTotal != null && linhasDescricaoServicosTarifasTotal.length() != 0){
				if(linhasCreditoRealizados != null && linhasCreditoRealizados.length() != 0){
					linhasDescricaoServicosTarifasTotal.append(System.getProperty("line.separator"));
					linhasDescricaoServicosTarifasTotal.append(linhasCreditoRealizados);
				}
			}else{
				linhasDescricaoServicosTarifasTotal.append(linhasCreditoRealizados);
			}

		}
		// caso o valor dos impostos retidos seja maior que zero
		if(emitirContaHelper.getValorImpostos() != null && emitirContaHelper.getValorImpostos().compareTo(new BigDecimal("0.00")) == 1){
			// [SB0015] - Gerar Linhas dos Impostos Retidos
			StringBuilder linhasImpostosRetidos = gerarLinhasImpostosRetidos(emitirContaHelper);

			// caso a stringBuilder já esteja preenchida
			if(linhasDescricaoServicosTarifasTotal != null && linhasDescricaoServicosTarifasTotal.length() != 0){
				// caso a stringBuilder já esteja preenchida
				if(linhasImpostosRetidos != null && linhasImpostosRetidos.length() != 0){
					linhasDescricaoServicosTarifasTotal.append(System.getProperty("line.separator"));
					linhasDescricaoServicosTarifasTotal.append(linhasImpostosRetidos);
				}
			}else{
				linhasDescricaoServicosTarifasTotal.append(linhasImpostosRetidos);
			}

		}

		return linhasDescricaoServicosTarifasTotal;

	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00011] Gerar Linhas da Tarifa de Água
	 * 
	 * @author Sávio Luiz
	 * @date 22/05/2006
	 * @author Eduardo Henrioque
	 * @date 08/07/2008 Alteração dos Valores de Tarifa para 4 casas decimais
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasTarifaAgua(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao) throws ControladorException{

		StringBuilder linhasTarifaAgua = new StringBuilder();
		// -- Linha 1 --//
		// Canal
		linhasTarifaAgua.append(" ");
		// Fonte
		linhasTarifaAgua.append("1");
		linhasTarifaAgua.append("AGUA");
		linhasTarifaAgua.append(Util.completaString("", 125));

		Collection colecaoContaCategoriaComFaixas = null;
		try{
			colecaoContaCategoriaComFaixas = repositorioFaturamento.pesquisarContaCategoria(emitirContaHelper.getIdConta());
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(colecaoContaCategoriaComFaixas != null && !colecaoContaCategoriaComFaixas.isEmpty()){
			Iterator iteratorContaCategoriaComFaixas = colecaoContaCategoriaComFaixas.iterator();
			while(iteratorContaCategoriaComFaixas.hasNext()){
				ContaCategoria contaCategoria = (ContaCategoria) iteratorContaCategoriaComFaixas.next();
				linhasTarifaAgua.append(System.getProperty("line.separator"));

				// -- Linha 2 --//
				// Canal
				linhasTarifaAgua.append(" ");
				// Fonte
				linhasTarifaAgua.append("1");
				linhasTarifaAgua.append(" ");
				// descricao da categoria
				linhasTarifaAgua.append(Util.completaString(contaCategoria.getComp_id().getCategoria().getDescricao(), 13));
				// quantidade de economias
				linhasTarifaAgua.append(Util.adicionarZerosEsquedaNumero(3, "" + contaCategoria.getQuantidadeEconomia()));
				// completa com espaços em branco
				linhasTarifaAgua.append(Util.completaString("", 2));
				if(contaCategoria.getQuantidadeEconomia() == 1){
					linhasTarifaAgua.append("UNIDADE ");
				}else{
					linhasTarifaAgua.append("UNIDADES");
				}
				// completa com espaços em branco
				linhasTarifaAgua.append(Util.completaString("", 102));
				linhasTarifaAgua.append(System.getProperty("line.separator"));

				// -- Linha 3 --//
				// Canal
				linhasTarifaAgua.append(" ");
				// Fonte
				linhasTarifaAgua.append("1");
				// completa com espaços em branco
				linhasTarifaAgua.append(" ");
				// caso não existam dados de medição
				if(parmsMedicaoHistorico == null){
					// Constante
					linhasTarifaAgua.append("TARIFA MÍNIMA");

					// Valor da tarifa mínima de água para a categoria por
					// economia
					BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getQuantidadeEconomia());
					String valorTarifaMinima = "";
					if(contaCategoria.getValorTarifaMinimaAgua() != null && qtdEconomia != null){
						BigDecimal valorTarifaMinimaBigDecimal = contaCategoria.getValorTarifaMinimaAgua().divide(qtdEconomia, 4,
										RoundingMode.UP);
						valorTarifaMinima = Util.formatarMoedaReal(valorTarifaMinimaBigDecimal, 4);
					}

					linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaMinima, 6));
					// completa com espaços em branco
					linhasTarifaAgua.append(" ");
					// Constante
					linhasTarifaAgua.append("POR UNIDADE");
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 18));
					// Constante
					linhasTarifaAgua.append("MINIMO");
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 11));
					// valor da água para categoria
					String valorAgua = Util.formatarMoedaReal(contaCategoria.getValorAgua());
					linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorAgua, 17));
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 45));
				}else{
					// recupera a coleção de conta categoria consumo faixa
					Collection colecaoContaCategoriaConsumoFaixa = null;
					try{
						colecaoContaCategoriaConsumoFaixa = repositorioFaturamento.pesquisarContaCategoriaFaixas(
										emitirContaHelper.getIdConta(), contaCategoria.getComp_id().getCategoria().getId());
					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}

					if(colecaoContaCategoriaConsumoFaixa != null && !colecaoContaCategoriaConsumoFaixa.isEmpty()){

						// Constante
						linhasTarifaAgua.append("ATE");
						// Constante
						linhasTarifaAgua.append(" ");
						// Consumo mínimo de água para a categoria por
						// economia

						BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getQuantidadeEconomia());

						BigDecimal consumoMinimoAgua = null;
						if(contaCategoria.getConsumoMinimoAgua() != null){
							consumoMinimoAgua = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getConsumoMinimoAgua());
						}

						BigDecimal consumoMinimaBigDecimal = new BigDecimal("0.00");
						if(consumoMinimoAgua != null && qtdEconomia != null){
							consumoMinimaBigDecimal = consumoMinimoAgua.divide(qtdEconomia, 2, RoundingMode.UP);
						}

						String consumoMinima = "" + consumoMinimaBigDecimal.intValue();

						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoMinima, 2));
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append("M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 7));
						// Constante
						linhasTarifaAgua.append("- R$");
						// valor da tarifa minima de agua para a categoria por
						// economia
						BigDecimal valorTarifaMinimaBigDecimal = null;
						if(contaCategoria.getValorTarifaMinimaAgua() != null && qtdEconomia != null){
							valorTarifaMinimaBigDecimal = contaCategoria.getValorTarifaMinimaAgua().divide(qtdEconomia, 4, RoundingMode.UP);
						}
						String valorTarifaMinima = Util.formatarMoedaReal(valorTarifaMinimaBigDecimal, 4);
						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaMinima, 6));
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append(" (POR UNIDADE)");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 8));
						// Consumo mínimo de água
						if(contaCategoria.getConsumoMinimoAgua() != null && !contaCategoria.getConsumoMinimoAgua().equals("")){
							linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoMinimoAgua(), 4));
						}else{
							linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda("", 4));
						}
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append("M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 10));
						// valor agua para categoria
						String valorAguaCategoria = "";
						if(contaCategoria.getValorTarifaMinimaAgua() != null){
							valorAguaCategoria = Util.formatarMoedaReal(contaCategoria.getValorTarifaMinimaAgua());
						}
						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorAguaCategoria, 17));
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 45));

						Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa.iterator();
						while(iteratorContaCategoriaConsumoFaixa.hasNext()){
							ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) iteratorContaCategoriaConsumoFaixa
											.next();

							linhasTarifaAgua.append(System.getProperty("line.separator"));

							// -- Linha 4 --//
							// Canal
							linhasTarifaAgua.append(" ");
							// Fonte
							linhasTarifaAgua.append("1");
							// completa com espaços em branco
							linhasTarifaAgua.append(" ");
							// caso a faixa seja a ultima ta tarifa de consumo
							if(contaCategoriaConsumoFaixa.getConsumoFaixaFim().equals(99999999)){
								// Constante
								linhasTarifaAgua.append("ACIMA DE");
								// Consumo inicial da faixa menos 1 m3
								String consumoInicialFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaInicio() - 1);
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoInicialFaixa, 3));
								// Constante
								linhasTarifaAgua.append(" M3  - R$");
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorTarifaFaixa());
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" POR M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 14));

								// consumo da agua
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(
												"" + contaCategoriaConsumoFaixa.getConsumoAgua() * qtdEconomia.intValue(), 6));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 10));
								// valor da agua na faixa
								String valorAguaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorAgua().multiply(
												qtdEconomia));
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorAguaFaixa, 17));
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 45));

							}else{
								// Consumo inicial da faixa
								String consumoInicialFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaInicio());
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoInicialFaixa, 2));
								// Constante
								linhasTarifaAgua.append(" M3 A");
								// consumo final da faixa
								String consumoFinalFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaFim());
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoFinalFaixa, 3));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 3));
								// Constante
								linhasTarifaAgua.append("- R$");
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorTarifaFaixa());
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" POR M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 14));

								// consumo de Agua na faixa
								// linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(""
								// + contaCategoriaConsumoFaixa.getConsumoAgua() *
								// qtdEconomia.intValue(), 6));
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(
												"" + contaCategoriaConsumoFaixa.getConsumoAgua(), 6));

								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 10));
								// valor da agua na faixa
								// String valorAguaFaixa =
								// Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorAgua().multiply(
								// qtdEconomia));
								String valorAguaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorAgua());

								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorAguaFaixa, 17));
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 45));

							}
						}
					}else{
						linhasTarifaAgua.append("CONSUMO DE ÁGUA");
						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoAgua(), 6) + " M3");
						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(
										Util.formatarMoedaReal(contaCategoria.getValorAgua()), 59));

						linhasTarifaAgua.append(Util.completaString("", 45));

					}

				}
			}
		}

		return linhasTarifaAgua;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00012] Gerar Linhas da Tarifa de Esgoto
	 * 
	 * @author Sávio Luiz
	 * @date 23/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasTarifaEsgoto(EmitirContaHelper emitirContaHelper) throws ControladorException{

		StringBuilder linhasTarifaEsgoto = new StringBuilder();
		// -- Linha 1 --//
		// Canal
		linhasTarifaEsgoto.append(" ");
		// Fonte
		linhasTarifaEsgoto.append("1");
		// Constante
		linhasTarifaEsgoto.append("ESGOTO ");
		// caso o consumo de agua seja igual ao volume coletado de esgoto e o
		// valor de agua seja diferente de 0
		if(emitirContaHelper.getConsumoAgua().equals(emitirContaHelper.getConsumoEsgoto()) && emitirContaHelper.getValorAgua() != null
						&& !emitirContaHelper.getValorAgua().equals("0.00")){
			// Percentual esgoto
			String percentualEsgoto = Util.formatarMoedaReal(emitirContaHelper.getPercentualEsgotoConta());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(percentualEsgoto, 6));
			// Constante
			linhasTarifaEsgoto.append(" % DO VALOR DA ÁGUA");
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 35));
			// Percentual esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper.getValorEsgoto());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(valorEsgoto, 17));
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 45));

		}else{
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 42));
			// Volume coletado de esgoto
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 6));
			// Constante
			linhasTarifaEsgoto.append(" M3");
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 9));
			// Percentual esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper.getValorEsgoto());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(valorEsgoto, 17));
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 45));
		}

		return linhasTarifaEsgoto;
	}

	private Boolean existemDebitosMesmaPrestacao(Collection<Object[]> collectionParmsDebitoAutomatico){

		Boolean mesmaPrestacao = Boolean.TRUE;
		Short numeroPrestacao = null;

		for(Object[] parmsDebitoAutomatico : collectionParmsDebitoAutomatico){

			Short prestacao = parmsDebitoAutomatico[1] != null ? (Short) parmsDebitoAutomatico[1] : null;

			if(numeroPrestacao == null && prestacao != null){

				numeroPrestacao = prestacao;

			}else if(numeroPrestacao != null && prestacao != null){

				if(numeroPrestacao.intValue() != prestacao.intValue()){

					mesmaPrestacao = Boolean.FALSE;
					break;

				}

			}

		}

		return mesmaPrestacao;

	}

	private Boolean existeDebitoCobradoComIdParcelamento(Collection<Object[]> collectionParmsDebitoAutomatico){

		Boolean retorno = Boolean.FALSE;

		for(Object[] parmsDebitoAutomatico : collectionParmsDebitoAutomatico){

			if(parmsDebitoAutomatico[3] != null){

				retorno = Boolean.TRUE;
				break;

			}

		}

		return retorno;

	}

	private Boolean existemRDsDistintas(Collection<Object[]> collectionParmsDebitoAutomatico){

		Boolean retorno = Boolean.FALSE;
		Integer idRd = null;

		for(Object[] parmsDebitoAutomatico : collectionParmsDebitoAutomatico){

			Parcelamento parcelamento = (Parcelamento) parmsDebitoAutomatico[3];

			if(parcelamento != null && parcelamento.getResolucaoDiretoria() != null
							&& parcelamento.getResolucaoDiretoria().getIndicadorEmissaoAssuntoConta() != null
							&& parcelamento.getResolucaoDiretoria().getIndicadorEmissaoAssuntoConta().equals(ConstantesSistema.SIM)){

				if(idRd == null){

					idRd = parcelamento.getResolucaoDiretoria().getId();

				}else if(parcelamento.getResolucaoDiretoria().getId().intValue() != idRd.intValue()){

					retorno = Boolean.TRUE;
					break;

				}

			}

		}

		return retorno;

	}

	private Boolean existemRDsIndicacaoEmissaoAssuntoConta(Collection<Object[]> collectionParmsDebitoAutomatico){

		Boolean retorno = Boolean.FALSE;

		for(Object[] parmsDebitoAutomatico : collectionParmsDebitoAutomatico){

			Parcelamento parcelamento = (Parcelamento) parmsDebitoAutomatico[3];

			if(parcelamento != null && parcelamento.getResolucaoDiretoria() != null
							&& parcelamento.getResolucaoDiretoria().getIndicadorEmissaoAssuntoConta() != null
							&& parcelamento.getResolucaoDiretoria().getIndicadorEmissaoAssuntoConta().equals(ConstantesSistema.SIM)){

				retorno = Boolean.TRUE;
				break;

			}

		}

		return retorno;

	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00013] Gerar Linhas de Débitos Cobrados
	 * 
	 * @author Sávio Luiz
	 * @date 23/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasDebitoCobrados(EmitirContaHelper emitirContaHelper) throws ControladorException{

		StringBuilder linhasDebitosCobrados = new StringBuilder();

		Collection<Object[]> collectionParmsDebitoAutomatico = null;

		Collection<Integer> tiposParcelamento = Util
						.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar());

		try{

			collectionParmsDebitoAutomatico = repositorioFaturamento.listarParametrosDebitosCobradoParcelamento(
							emitirContaHelper.getIdConta(), tiposParcelamento);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(collectionParmsDebitoAutomatico != null){

			Boolean mesmaPrestacao = this.existemDebitosMesmaPrestacao(collectionParmsDebitoAutomatico);

			Iterator iter = collectionParmsDebitoAutomatico.iterator();

			while(iter.hasNext()){
				Object[] parmsDebitoAutomatico = (Object[]) iter.next();

				// caso a consulta retorne algum resultado
				if(parmsDebitoAutomatico != null){

					String valorDebitosCobrados = parmsDebitoAutomatico[0] != null ? Util
									.formatarMoedaReal((BigDecimal) parmsDebitoAutomatico[0]) : "";
					String numeroPrestacao = parmsDebitoAutomatico[1] != null ? String.valueOf(parmsDebitoAutomatico[1]) : "";
					String numeroTotalPrestacao = parmsDebitoAutomatico[2] != null ? String.valueOf(parmsDebitoAutomatico[2]) : "";
					Parcelamento parcelamento = parmsDebitoAutomatico[3] != null ? (Parcelamento) parmsDebitoAutomatico[3] : null;

					if((!valorDebitosCobrados.equals(""))
									&& (Util.formatarMoedaRealparaBigDecimal(valorDebitosCobrados).compareTo(BigDecimal.ZERO) == 1)){

						if(linhasDebitosCobrados != null && linhasDebitosCobrados.length() != 0){
							linhasDebitosCobrados.append(System.getProperty("line.separator"));
						}

						// -- Linha 1 --//
						// Canal
						linhasDebitosCobrados.append(" ");
						// Fonte
						linhasDebitosCobrados.append("1");

						// 2.1.7. Caso os débitos cobrados de parcelamento tenham o mesmo número de
						// prestação (mesmo DBCB_NNPRESTACAODEBITO):
						if(mesmaPrestacao){

							// 2.1.7.1. Caso exista, em algum dos débitos cobrados, a identificação
							// do parcelamento (PARC_ID com o valor diferente de nulo):

							// existemRDsIndicacaoEmissaoAssuntoConta

							if(this.existeDebitoCobradoComIdParcelamento(collectionParmsDebitoAutomatico)){

								Boolean rdsDistintas = this.existemRDsDistintas(collectionParmsDebitoAutomatico);
								Boolean existeRdsIndEmissaoAssuntoConta = this
												.existemRDsIndicacaoEmissaoAssuntoConta(collectionParmsDebitoAutomatico);

								// 2.1.7.1.2. Caso existam RDs com a indicação de emissão do assunto
								// na conta (RDIR_ICEMISSAOASSUNTOCONTA=1) e sejam RDs distintas ou
								// caso não existam RDs com a indicação de emissão do assunto na
								// conta:
								if(rdsDistintas || !existeRdsIndEmissaoAssuntoConta){

									// Constante
									linhasDebitosCobrados.append("PARCELAMENTO DE DÉBITOS");

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 2));

									// Constante
									linhasDebitosCobrados.append("PARCELA ");

									// numero da prestação do débito
									linhasDebitosCobrados.append(Util.completaString(numeroPrestacao, 2));

									// Constante
									linhasDebitosCobrados.append("/");

									// numero total da prestação do débito
									linhasDebitosCobrados.append(Util.completaString(numeroTotalPrestacao, 2));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 29));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 45));

								}else if(existeRdsIndEmissaoAssuntoConta && !rdsDistintas){

									// 2.1.7.1.3. Caso contrário, ou seja, caso existam RDs com a
									// indicação de emissão do assunto na conta e não sejam RDs
									// distintas:

									linhasDebitosCobrados.append("PARCELAMENTO DEBITO ");

									if(parcelamento != null && parcelamento.getResolucaoDiretoria() != null){

										// Completa com espaços em branco
										linhasDebitosCobrados.append(Util.completaString(parcelamento.getResolucaoDiretoria()
														.getDescricaoAssuntoAbreviada(), 3));

									}else{

										linhasDebitosCobrados.append(Util.completaString("", 3));

									}

									// Um espaço em branco
									linhasDebitosCobrados.append(Util.completaString("", 1));

									// Valor do débito correspondente aos débitos cobrados de
									// parcelamento da RD (somatório de
									// DBCB_VLPRESTACAO no formato ZZ.ZZ9,99);
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 9));

									// Constante
									linhasDebitosCobrados.append("PARCELA ");

									// numero da prestação do débito
									linhasDebitosCobrados.append(Util.completaString(numeroPrestacao, 2));

									// Constante
									linhasDebitosCobrados.append("/");

									// numero total da prestação do débito
									linhasDebitosCobrados.append(Util.completaString(numeroTotalPrestacao, 2));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 21));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 45));

								}

							}else{

								// 2.1.7.2. Caso contrário, ou seja, nenhum dos débitos cobrados têm
								// a identificação do parcelamento:

								// Constante
								linhasDebitosCobrados.append("PARCELAMENTO DE DÉBITOS");

								// Completa com espaços em branco
								linhasDebitosCobrados.append(Util.completaString("", 2));

								// Constante
								linhasDebitosCobrados.append("PARCELA ");

								// numero da prestação do débito
								linhasDebitosCobrados.append(Util.completaString(numeroPrestacao, 2));

								// Constante
								linhasDebitosCobrados.append("/");

								// numero total da prestação do débito
								linhasDebitosCobrados.append(Util.completaString(numeroTotalPrestacao, 2));

								// Completa com espaços em branco
								linhasDebitosCobrados.append(Util.completaString("", 29));

								// Completa com espaços em branco
								linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));

								// Completa com espaços em branco
								linhasDebitosCobrados.append(Util.completaString("", 45));
							}

						}else{
							// 2.1.8. Caso contrário, ou seja, os débitos cobrados de parcelamento
							// não tenham o mesmo número de prestação
							// (distintos DBCB_NNPRESTACAODEBITO):

							// 2.1.8.1. Caso exista, em algum dos débitos cobrados, a identificação
							// do parcelamento (PARC_ID com o valor diferente de nulo):
							if(this.existeDebitoCobradoComIdParcelamento(collectionParmsDebitoAutomatico)){

								Boolean rdsDistintas = this.existemRDsDistintas(collectionParmsDebitoAutomatico);
								Boolean existeRdsIndEmissaoAssuntoConta = this
												.existemRDsIndicacaoEmissaoAssuntoConta(collectionParmsDebitoAutomatico);

								// 2.1.8.1.2. Caso existam RDs com a indicação de emissão do assunto
								// na conta (RDIR_ICEMISSAOASSUNTOCONTA=1) e sejam RDs distintas ou
								// caso não existam RDs com a indicação de emissão do assunto na
								// conta:

								if(rdsDistintas || !existeRdsIndEmissaoAssuntoConta){

									linhasDebitosCobrados.append("PARCELAMENTO DE DÉBITOS");

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 44));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 45));

								}else if(existeRdsIndEmissaoAssuntoConta && !rdsDistintas){

									// 2.1.8.1.3. Caso contrário, ou seja, caso existam RDs com a
									// indicação de emissão do assunto na conta e não sejam RDs
									// distintas:

									linhasDebitosCobrados.append("PARCELAMENTO DEBITO ");

									if(parcelamento != null && parcelamento.getResolucaoDiretoria() != null){

										// Completa com espaços em branco
										linhasDebitosCobrados.append(Util.completaString(parcelamento.getResolucaoDiretoria()
														.getDescricaoAssuntoAbreviada(), 3));

									}else{

										linhasDebitosCobrados.append(Util.completaString("", 3));

									}

									// Um espaço em branco
									linhasDebitosCobrados.append(Util.completaString("", 1));

									// Valor do débito correspondente aos débitos cobrados de
									// parcelamento da RD (somatório de
									// DBCB_VLPRESTACAO no formato ZZ.ZZ9,99);
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 9));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 34));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));

									// Completa com espaços em branco
									linhasDebitosCobrados.append(Util.completaString("", 45));

								}

							}else{

								// 2.1.8.2. Caso contrário, ou seja, nenhum dos débitos cobrados têm
								// a identificação do parcelamento:

								linhasDebitosCobrados.append("PARCELAMENTO DE DÉBITOS");

								// Completa com espaços em branco
								linhasDebitosCobrados.append(Util.completaString("", 44));

								// Completa com espaços em branco
								linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));

								// Completa com espaços em branco
								linhasDebitosCobrados.append(Util.completaString("", 45));

							}

						}

					}

				}

			}

		}

		List colecaoDebitoCobradoPorTipo = null;
		try{
			colecaoDebitoCobradoPorTipo = repositorioFaturamento.pesquisarParmsDebitoCobradoPorTipo(emitirContaHelper.getIdConta(),
							tiposParcelamento);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		if(colecaoDebitoCobradoPorTipo != null && !colecaoDebitoCobradoPorTipo.isEmpty()){
			ListIterator iteratorDebitoCobradoPorTipo = (ListIterator) colecaoDebitoCobradoPorTipo.listIterator();
			// variável responsável para controle de mudança do tipo de
			// débito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// débito,que entra para ser escrito
			// no txt só uma vez a descrição do tipo do debito
			boolean primeiraVez = true;
			boolean entrouPrimeiraVez = false;
			Integer idDebitoTipoVerificador = null;
			BigDecimal valorTotalPrestacoes = new BigDecimal("0.00");
			// valor da pretação
			BigDecimal valorPrestacao = null;
			// numero da pretação atual
			Integer numeroPrestacaoDebito = null;
			// numero total de prestações
			Integer numeroPrestacaoTotal = null;
			// colecao para guardar os ano/mes referencia do débito cobrado
			Collection colecaoAnoMesReferenciaDebito = new ArrayList();
			// cria um int que vai ver o tamanho da string builder
			// dependendo da quantidade
			// de mes/ano referencia calcula os espaços em brancos
			// para o valor ficar no lugar certo
			int tamanhoAnoMesReferencia = 0;
			while(iteratorDebitoCobradoPorTipo.hasNext()){
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoCobradoPorTipo.next();

				// recupera os parametros da coleção
				// valor da pretação
				if(parmsDebitoCobradoPorTipo[0] != null){
					valorPrestacao = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if(parmsDebitoCobradoPorTipo[1] != null){
					numeroPrestacaoDebito = Integer.valueOf("" + (Short) parmsDebitoCobradoPorTipo[1]);
				}
				// numero total de prestações
				if(parmsDebitoCobradoPorTipo[2] != null){
					numeroPrestacaoTotal = Integer.valueOf("" + (Short) parmsDebitoCobradoPorTipo[2]);
				}
				// ano Mes Referência do débito
				Integer anoMesReferencia = null;
				if(parmsDebitoCobradoPorTipo[3] != null){
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idDebitoTipo = null;
				if(parmsDebitoCobradoPorTipo[4] != null){
					idDebitoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do débito
				String descricaoDebitoTipo = null;
				if(parmsDebitoCobradoPorTipo[5] != null){
					descricaoDebitoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}
				// muda o estado do boolean e o valor do débito tipo
				// verificador
				// na primeira vez ou quando mudar o tipo
				if(mudou){
					idDebitoTipoVerificador = idDebitoTipo;
					mudou = false;
					tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if(idDebitoTipo.equals(idDebitoTipoVerificador)){
					if(primeiraVez){
						if(linhasDebitosCobrados != null && linhasDebitosCobrados.length() != 0){
							linhasDebitosCobrados.append(System.getProperty("line.separator"));
						}
						// -- Linha 2 --//
						// Canal
						linhasDebitosCobrados.append(" ");
						// Fonte
						linhasDebitosCobrados.append("1");
						// descrição do tipo de débito
						linhasDebitosCobrados.append(Util.completaString(descricaoDebitoTipo, 30));
						primeiraVez = false;
						entrouPrimeiraVez = true;
					}else{
						entrouPrimeiraVez = false;
					}
					// adiciona o valor da prestação ao total
					valorTotalPrestacoes = valorTotalPrestacoes.add(valorPrestacao);
					// adiciona o ano/mes referencia na coleção
					if(anoMesReferencia != null){
						colecaoAnoMesReferenciaDebito.add(anoMesReferencia);
					}else{
						if(!entrouPrimeiraVez){
							if(linhasDebitosCobrados != null && linhasDebitosCobrados.length() != 0){
								linhasDebitosCobrados.append(System.getProperty("line.separator"));
							}

							// -- Linha 2 --//
							// Canal
							linhasDebitosCobrados.append(" ");
							// Fonte
							linhasDebitosCobrados.append("1");
							// descrição do tipo de débito
							linhasDebitosCobrados.append(Util.completaString(descricaoDebitoTipo, 30));
						}
						// Constante
						linhasDebitosCobrados.append("PARCELA ");
						// numero da prestação do débito
						linhasDebitosCobrados.append(Util.completaString("" + numeroPrestacaoDebito, 2));
						// Constante
						linhasDebitosCobrados.append("/");
						// numero total da prestação do débito
						linhasDebitosCobrados.append(Util.completaString("" + numeroPrestacaoTotal, 2));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util.completaString("", 24));
						// Valor da pretação
						String valorPrestacaoString = Util.formatarMoedaReal(valorPrestacao);
						linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorPrestacaoString, 17));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util.completaString("", 45));
					}

				}else{
					// caso a coleção dos meses de referência do grupo do
					// tipo de débito esteja preenchida
					if(colecaoAnoMesReferenciaDebito != null && !colecaoAnoMesReferenciaDebito.isEmpty()){
						Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito.iterator();
						int i = 1;
						while(iteratorAnoMesReferenciaDebito.hasNext()){
							Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito.next();
							String anoMesReferenciaDebitoString = null;
							if(i == 1){
								// mes/ano referencia do débito
								anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
								// caso exita somente um mes/ano de
								// referencia na lista
								if(colecaoAnoMesReferenciaDebito.size() == 1){
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", 30));
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", 45));

								}else{

									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", 92));
								}
							}else{
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if(i == 2){
									linhasDebitosCobrados.append(System.getProperty("line.separator"));
									// -- Linha 3 --//
									// Canal
									linhasDebitosCobrados.append(" ");
									// Fonte
									linhasDebitosCobrados.append("1");
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
									// mes/ano referencia do debito
									anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
									// adiciona o tamanho do mes/ano
									// referencia
									tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
									// caso exita somente um mes/ano de
									// referencia na lista
									if(colecaoAnoMesReferenciaDebito.size() == 2){
										// o tamanho de espaços em
										// branco vai ser o tamanho sem
										// os mes/ano - os meses/anos
										// colocados na
										// stringbuilder.ex.:76-15=61
										// espaços em brancos
										int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
										// completa espaços em brancos
										linhasDebitosCobrados.append(Util.completaString("", tamanhoEspacosBrancos));
										// valor acumulado do tipo do débito
										String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
										linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
										// completa espaços em brancos
										linhasDebitosCobrados.append(Util.completaString("", 45));
									} /*
									 * else { // completa espaços em brancos
									 * linhasDebitosCobrados.append(" "); }
									 */

								}else{
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o
									// ultimo anoMes
									if((colecaoAnoMesReferenciaDebito.size() - 1) <= 6){

										// mes/ano referencia do debito
										anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
										linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
										// completa espaços em brancos
										linhasDebitosCobrados.append(" ");
										// adiciona o tamanho do mes/ano
										// referencia + o espaço em branco
										tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

										// caso não tenha outro ano mes na
										// coleção então
										// completa a linha com o valor
										if(!iteratorAnoMesReferenciaDebito.hasNext()){
											// o tamanho de espaços em
											// branco vai ser o tamanho sem
											// os mes/ano - os meses/anos
											// colocados na
											// stringbuilder.ex.:76-15=61
											// espaços em brancos
											int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util.completaString("", tamanhoEspacosBrancos));
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
											linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util.completaString("", 45));
										}

									}else{
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if(i < 7){
											// mes/ano referencia do débito
											anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
											linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
											// completa espaços em brancos
											linhasDebitosCobrados.append(" ");
										}else{
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util.completaString("E OUTRAS", 18));
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
											linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 25));
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util.completaString("", 45));
											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					} /*
					 * else { // -- Linha 2 (CONTINUAÇÂO)--// // Constante
					 * linhasDebitosCobrados.append("PARCELA "); // numero da prestação do débito
					 * linhasDebitosCobrados.append(Util.completaString("" + numeroPrestacaoDebito,
					 * 2)); // Constante
					 * linhasDebitosCobrados.append("/"); // numero total da prestação do débito
					 * linhasDebitosCobrados.append(Util.completaString("" +
					 * numeroPrestacaoTotal, 2)); // Completa com espaços em branco
					 * linhasDebitosCobrados.append(Util .completaString("", 24)); //
					 * Valor da pretação // Vivianne Sousa // String valorPrestacaoString = Util //
					 * .formatarMoedaReal(valorPrestacao); String
					 * valorPrestacaoString = Util .formatarMoedaReal(valorTotalPrestacoes);
					 * linhasDebitosCobrados.append(Util .completaStringComEspacoAEsquerda(
					 * valorPrestacaoString, 17)); // Completa com espaços em
					 * branco linhasDebitosCobrados.append(Util .completaString("", 45)); }
					 */// limpa os campos
					valorTotalPrestacoes = new BigDecimal("0.00");
					colecaoAnoMesReferenciaDebito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoCobradoPorTipo.previous();
				}
			}

			// no caso de ser o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de débito esteja preenchida
			if(colecaoAnoMesReferenciaDebito != null && !colecaoAnoMesReferenciaDebito.isEmpty()){
				Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito.iterator();
				int i = 1;
				while(iteratorAnoMesReferenciaDebito.hasNext()){
					Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito.next();
					String anoMesReferenciaDebitoString = null;
					if(i == 1){
						// mes/ano referencia do débito
						anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
						linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
						// caso exita somente um mes/ano de
						// referencia na lista
						if(colecaoAnoMesReferenciaDebito.size() == 1){
							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString("", 30));
							// valor acumulado do tipo do débito
							String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
							linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString("", 45));

						}else{
							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString("", 92));
						}
					}else{
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if(i == 2){
							// -- Linha 3 --//
							linhasDebitosCobrados.append(System.getProperty("line.separator"));
							// Canal
							linhasDebitosCobrados.append(" ");
							// Fonte
							linhasDebitosCobrados.append("1");
							// completa espaços em brancos
							linhasDebitosCobrados.append(" ");
							// mes/ano referencia do debito
							anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
							linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));

							// completa espaços em brancos
							linhasDebitosCobrados.append(" ");

							// adiciona o tamanho do mes/ano
							// referencia
							tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
							// caso exita somente um mes/ano de
							// referencia na lista
							if(colecaoAnoMesReferenciaDebito.size() == 2){
								// o tamanho de espaços em
								// branco vai ser o tamanho sem
								// os mes/ano - os meses/anos
								// colocados na
								// stringbuilder.ex.:76-15=61
								// espaços em brancos
								int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
								// completa espaços em brancos
								linhasDebitosCobrados.append(Util.completaString("", tamanhoEspacosBrancos));
								// valor acumulado do tipo do débito
								String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
								linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
								// completa espaços em brancos
								linhasDebitosCobrados.append(Util.completaString("", 45));

							}
						}else{
							// caso exista até mais 6 ocorrências na
							// lista de meses
							// -1 pq já foi colocado na string o
							// ultimo anoMes
							if((colecaoAnoMesReferenciaDebito.size() - 1) <= 6){

								// mes/ano referencia do credito
								anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
								// completa espaços em brancos
								linhasDebitosCobrados.append(" ");
								// adiciona o tamanho do mes/ano
								// referencia + o espaço em branco
								tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
								// caso não tenha outro ano mes na
								// coleção então
								// completa a linha com o valor
								if(!iteratorAnoMesReferenciaDebito.hasNext()){
									// o tamanho de espaços em
									// branco vai ser o tamanho sem
									// os mes/ano - os meses/anos
									// colocados na
									// stringbuilder.ex.:76-15=61
									// espaços em brancos
									int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", tamanhoEspacosBrancos));
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", 45));
								}

							}else{
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if(i < 7){
									// mes/ano referencia do débito
									anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
								}else{
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("E OUTRAS", 18));
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 25));
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", 45));

									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}

		}

		return linhasDebitosCobrados;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00014] Gerar Linhas de Créditos Realizados
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasCreditosRealizados(EmitirContaHelper emitirContaHelper) throws ControladorException{

		StringBuilder linhasCreditosRealizados = new StringBuilder();
		List colecaoCreditoRealizadoPorTipo = null;
		try{
			colecaoCreditoRealizadoPorTipo = repositorioFaturamento.pesquisarParmsCreditoRealizadoPorTipo(emitirContaHelper.getIdConta());
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		if(colecaoCreditoRealizadoPorTipo != null && !colecaoCreditoRealizadoPorTipo.isEmpty()){
			ListIterator iteratorDebitoRealizadoPorTipo = (ListIterator) colecaoCreditoRealizadoPorTipo.listIterator();
			// variável responsável para controle de mudança do tipo de
			// credito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// credito,que entra para ser escrito
			// no txt só uma vez a descrição do tipo do credito
			boolean primeiraVez = true;
			boolean entrouPrimeiraVez = false;
			Integer idCreditoTipoVerificador = null;
			BigDecimal valorTotalCredito = new BigDecimal("0.00");
			BigDecimal valorCredito = null;
			Short numeroCredito = null;
			// numero total de créditos
			Short numeroCreditoTotal = null;
			// cria um int que vai ver o tamanho da string builder
			// dependendo da quantidade
			// de mes/ano referencia calcula os espaços em brancos
			// para o valor ficar no lugar certo
			int tamanhoAnoMesReferencia = 0;
			// caso não seja a primeira vez que entre no boolean primeira
			// vez(que nesse caso é quando troca o tipo de credito)
			boolean primeiraVezIndependenteTipo = false;
			// colecao para guardar os ano/mes referencia do credito realizado
			Collection colecaoAnoMesReferenciaCredito = new ArrayList();
			while(iteratorDebitoRealizadoPorTipo.hasNext()){
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoRealizadoPorTipo.next();

				// recupera os parametros da coleção
				// valor do crédito
				if(parmsDebitoCobradoPorTipo[0] != null){
					valorCredito = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if(parmsDebitoCobradoPorTipo[1] != null){
					numeroCredito = (Short) parmsDebitoCobradoPorTipo[1];
				}

				if(parmsDebitoCobradoPorTipo[2] != null){
					numeroCreditoTotal = (Short) parmsDebitoCobradoPorTipo[2];
				}
				// ano Mes Referência do crédito
				Integer anoMesReferencia = null;
				if(parmsDebitoCobradoPorTipo[3] != null){
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idCreditoTipo = null;
				if(parmsDebitoCobradoPorTipo[4] != null){
					idCreditoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do credito
				String descricaoCreditoTipo = null;
				if(parmsDebitoCobradoPorTipo[5] != null){
					descricaoCreditoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}
				// muda o estado do boolean e o valor do credito tipo
				// verificador
				// na primeira vez ou quando mudar o tipo
				if(mudou){
					idCreditoTipoVerificador = idCreditoTipo;
					mudou = false;
					tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if(idCreditoTipo.equals(idCreditoTipoVerificador)){
					if(primeiraVez){
						// proxima linha
						if(primeiraVezIndependenteTipo){
							linhasCreditosRealizados.append(System.getProperty("line.separator"));
						}
						// -- Linha 1 --//
						// Canal
						linhasCreditosRealizados.append(" ");
						// Fonte
						linhasCreditosRealizados.append("1");
						// descrição do tipo de credito
						linhasCreditosRealizados.append(Util.completaString(descricaoCreditoTipo, 30));
						primeiraVez = false;
						entrouPrimeiraVez = true;
						primeiraVezIndependenteTipo = true;
					}else{
						entrouPrimeiraVez = false;
					}

					// adiciona o valor do credito ao total
					valorTotalCredito = valorTotalCredito.add(valorCredito);
					// adiciona o ano/mes referencia na coleção
					if(anoMesReferencia != null){
						colecaoAnoMesReferenciaCredito.add(anoMesReferencia);
					}else{
						if(!entrouPrimeiraVez){
							// proxima linha
							if(primeiraVezIndependenteTipo){
								linhasCreditosRealizados.append(System.getProperty("line.separator"));
							}
							// -- Linha 1 --//
							// Canal
							linhasCreditosRealizados.append(" ");
							// Fonte
							linhasCreditosRealizados.append("1");
							// descrição do tipo de credito
							linhasCreditosRealizados.append(Util.completaString(descricaoCreditoTipo, 30));
							primeiraVez = false;
						}
						// Constante
						linhasCreditosRealizados.append("PARCELA ");
						// numero da prestação do débito
						linhasCreditosRealizados.append(Util.completaString("" + numeroCredito, 2));
						// Constante
						linhasCreditosRealizados.append("/");
						// numero total da prestação do débito
						linhasCreditosRealizados.append(Util.completaString("" + numeroCreditoTotal, 2));
						// Completa com espaços em branco
						linhasCreditosRealizados.append(Util.completaString("", 24));
						// Valor da pretação
						String valorCreditoString = Util.formatarMoedaReal(valorCredito);
						linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorCreditoString, 17));
						// Completa com espaços em branco
						linhasCreditosRealizados.append(Util.completaString("", 45));

					}

				}else{
					// caso a coleção dos meses de referência do grupo do
					// tipo de credito esteja preenchida
					if(colecaoAnoMesReferenciaCredito != null && !colecaoAnoMesReferenciaCredito.isEmpty()){
						Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito.iterator();
						int i = 1;
						while(iteratorAnoMesReferenciaCredito.hasNext()){
							Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito.next();
							String anoMesReferenciaCreditoString = null;
							if(i == 1){
								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
								// caso exita somente um mes/ano de
								// referencia na lista
								if(colecaoAnoMesReferenciaCredito.size() == 1){
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", 30));
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", 45));

								}else{
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", 92));
								}
							}else{
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if(i == 2){
									// -- Linha 3 --//
									linhasCreditosRealizados.append(System.getProperty("line.separator"));
									// Canal
									linhasCreditosRealizados.append(" ");
									// Fonte
									linhasCreditosRealizados.append("1");
									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");
									// mes/ano referencia do credito
									anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);

									linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));

									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");

									// adiciona o tamanho do mes/ano
									// referencia
									tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
									// caso exita somente um mes/ano de
									// referencia na lista
									if(colecaoAnoMesReferenciaCredito.size() == 2){
										// o tamanho de espaços em
										// branco vai ser o tamanho sem
										// os mes/ano - os meses/anos
										// colocados na
										// stringbuilder.ex.:76-15=61
										// espaços em brancos
										int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
										// completa espaços em brancos
										linhasCreditosRealizados.append(Util.completaString("", tamanhoEspacosBrancos));
										// valor acumulado do tipo do débito
										String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
										linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
										// completa espaços em brancos
										linhasCreditosRealizados.append(Util.completaString("", 45));

									} /*
									 * else { // completa espaços em brancos
									 * linhasCreditosRealizados.append(" "); }
									 */
								}else{
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o
									// ultimo anoMes
									if((colecaoAnoMesReferenciaCredito.size() - 1) <= 6){

										// mes/ano referencia do credito
										anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
										linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
										// completa espaços em brancos
										linhasCreditosRealizados.append(" ");
										// adiciona o tamanho do mes/ano
										// referencia + o espaço em branco
										tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
										// caso não tenha outro ano mes na
										// coleção então
										// completa a linha com o valor
										if(!iteratorAnoMesReferenciaCredito.hasNext()){
											// o tamanho de espaços em
											// branco vai ser o tamanho sem
											// os mes/ano - os meses/anos
											// colocados na
											// stringbuilder.ex.:76-15=61
											// espaços em brancos
											int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
											// completa espaços em brancos
											linhasCreditosRealizados.append(Util.completaString("", tamanhoEspacosBrancos));
											// valor acumulado do tipo do débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
											linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
											// completa espaços em brancos
											linhasCreditosRealizados.append(Util.completaString("", 45));
										}

									}else{
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if(i < 7){
											// mes/ano referencia do débito
											anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
											linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
											// completa espaços em brancos
											linhasCreditosRealizados.append(" ");
										}else{
											// completa espaços em brancos
											linhasCreditosRealizados.append(Util.completaString("E OUTRAS", 18));
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
											linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 25));
											// completa espaços em brancos
											linhasCreditosRealizados.append(Util.completaString("", 45));
											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					}
					// limpa os campos
					valorTotalCredito = new BigDecimal("0.00");
					colecaoAnoMesReferenciaCredito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoRealizadoPorTipo.previous();
				}
			}
			// No caso de ter o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de credito esteja preenchida
			if(colecaoAnoMesReferenciaCredito != null && !colecaoAnoMesReferenciaCredito.isEmpty()){
				Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito.iterator();
				int i = 1;
				while(iteratorAnoMesReferenciaCredito.hasNext()){
					Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito.next();
					String anoMesReferenciaCreditoString = null;
					if(i == 1){
						// mes/ano referencia do credito
						anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
						linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
						// caso exita somente um mes/ano de
						// referencia na lista
						if(colecaoAnoMesReferenciaCredito.size() == 1){
							// completa espaços em brancos
							linhasCreditosRealizados.append(Util.completaString("", 30));
							// valor acumulado do tipo do débito
							String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
							linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
							// completa espaços em brancos
							linhasCreditosRealizados.append(Util.completaString("", 45));

						}else{
							// completa espaços em brancos
							linhasCreditosRealizados.append(Util.completaString("", 92));
						}
					}else{
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if(i == 2){
							// -- Linha 3 --//
							linhasCreditosRealizados.append(System.getProperty("line.separator"));
							// Canal
							linhasCreditosRealizados.append(" ");
							// Fonte
							linhasCreditosRealizados.append("1");
							// completa espaços em brancos
							linhasCreditosRealizados.append(" ");
							// mes/ano referencia do credito
							anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
							linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));

							// completa espaços em brancos
							linhasCreditosRealizados.append(" ");
							// adiciona o tamanho do mes/ano
							// referencia
							tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
							// caso exita somente um mes/ano de
							// referencia na lista
							if(colecaoAnoMesReferenciaCredito.size() == 2){
								// o tamanho de espaços em
								// branco vai ser o tamanho sem
								// os mes/ano - os meses/anos
								// colocados na
								// stringbuilder.ex.:76-15=61
								// espaços em brancos
								int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
								// completa espaços em brancos
								linhasCreditosRealizados.append(Util.completaString("", tamanhoEspacosBrancos));
								// valor acumulado do tipo do débito
								String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
								linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
								// completa espaços em brancos
								linhasCreditosRealizados.append(Util.completaString("", 45));

							}/*
							 * else { // completa espaços em brancos
							 * linhasCreditosRealizados.append(" "); }
							 */
						}else{
							// caso exista até mais 6 ocorrências na
							// lista de meses
							// -1 pq já foi colocado na string o
							// ultimo anoMes
							if((colecaoAnoMesReferenciaCredito.size() - 1) <= 6){

								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
								// completa espaços em brancos
								linhasCreditosRealizados.append(" ");
								// adiciona o tamanho do mes/ano
								// referencia + o espaço em branco
								tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
								// caso não tenha outro ano mes na
								// coleção então
								// completa a linha com o valor
								if(!iteratorAnoMesReferenciaCredito.hasNext()){
									// o tamanho de espaços em
									// branco vai ser o tamanho sem
									// os mes/ano - os meses/anos
									// colocados na
									// stringbuilder.ex.:76-15=61
									// espaços em brancos
									int tamanhoEspacosBrancos = 66 - tamanhoAnoMesReferencia;
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", tamanhoEspacosBrancos));
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 17));
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", 45));
								}

							}else{
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if(i < 7){
									// mes/ano referencia do débito
									anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");
								}else{
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString(" E OUTRAS", 18));
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 25));
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", 45));
									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}

		}

		return linhasCreditosRealizados;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0015] Gerar Linhas de Impostos Retidos
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasImpostosRetidos(EmitirContaHelper emitirContaHelper) throws ControladorException{

		StringBuilder linhasImpostosRetidos = new StringBuilder();
		// -- Linha 1 --//
		// Canal
		linhasImpostosRetidos.append(" ");
		// Fonte
		linhasImpostosRetidos.append("1");
		// Constante
		linhasImpostosRetidos.append("DEDUCAO IMPOSTOS LEI FEDERAL N.9430 DE 27/12/1996");
		// Completa com espaços em branco
		linhasImpostosRetidos.append(Util.completaString("", 80));
		linhasImpostosRetidos.append(System.getProperty("line.separator"));

		// -- Linha 2 --//
		// Canal
		linhasImpostosRetidos.append(" ");
		// Fonte
		linhasImpostosRetidos.append("1");
		// Completa com espaços em branco
		linhasImpostosRetidos.append(Util.completaString("", 2));

		Collection colecaoParmsImpostosDeduzidos = null;
		try{
			colecaoParmsImpostosDeduzidos = repositorioFaturamento.pesquisarParmsContaImpostosDeduzidos(emitirContaHelper.getIdConta());
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		StringBuilder descricaoAbreviadaImposto = new StringBuilder();
		BigDecimal valorImpostosTotal = new BigDecimal("0.00");
		// verifica se a coleção é diferente de nulo
		if(colecaoParmsImpostosDeduzidos != null && !colecaoParmsImpostosDeduzidos.isEmpty()){
			Iterator iteratorParmsImpostosDeduzidos = colecaoParmsImpostosDeduzidos.iterator();
			while(iteratorParmsImpostosDeduzidos.hasNext()){
				Object[] parmsImpostoDeduzido = (Object[]) iteratorParmsImpostosDeduzidos.next();
				String descricaoTipoImposto = "";
				if(parmsImpostoDeduzido[0] != null){
					descricaoTipoImposto = (String) parmsImpostoDeduzido[0];
				}
				String percentualAliquota = "";
				if(parmsImpostoDeduzido[1] != null){
					percentualAliquota = Util.formatarMoedaReal((BigDecimal) parmsImpostoDeduzido[1]);
				}
				BigDecimal valorImpostos = null;
				if(parmsImpostoDeduzido[2] != null){
					valorImpostos = (BigDecimal) parmsImpostoDeduzido[2];
				}
				// concatena a descrição abreviada do tipo de imposto com o
				// precentual de aliquota
				descricaoAbreviadaImposto.append(descricaoTipoImposto + "-" + percentualAliquota + "%");
				// Completa com espaços em branco
				descricaoAbreviadaImposto.append(" ");
				// adiciona o valor dos impostos
				valorImpostosTotal = valorImpostosTotal.add(valorImpostos);
			}
		}
		// recupera a descrição abreviada concatenada com a aliquota
		String descricaoAbreviadaConcatenada = "";
		if(descricaoAbreviadaImposto != null && !descricaoAbreviadaImposto.equals("")){
			descricaoAbreviadaConcatenada = descricaoAbreviadaImposto.toString();
		}
		linhasImpostosRetidos.append(Util.completaString(descricaoAbreviadaConcatenada, 65));
		String valorImpostosTotalString = Util.formatarMoedaReal(valorImpostosTotal);
		linhasImpostosRetidos.append(Util.completaStringComEspacoAEsquerda(valorImpostosTotalString, 17));
		// Completa com espaços em branco
		linhasImpostosRetidos.append(Util.completaString("", 45));

		return linhasImpostosRetidos;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00016] Obter Mensagem da Conta em 3 Partes
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public String[] obterMensagemConta3Partes(EmitirContaHelper emitirContaHelper, SistemaParametro sistemaParametro)
					throws ControladorException{

		String[] linhasImpostosRetidos = new String[3];
		Integer anoMesReferenciaFinal = sistemaParametro.getAnoMesFaturamento();
		int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesReferenciaFinal, 1);
		Integer dataVencimentoFinalInteger = sistemaParametro.getAnoMesArrecadacao();
		String anoMesSubtraidoString = "" + Util.subtrairMesDoAnoMes(dataVencimentoFinalInteger, 1);
		int ano = Integer.parseInt(anoMesSubtraidoString.substring(0, 4));
		int mes = Integer.parseInt(anoMesSubtraidoString.substring(4, 6));

		// recupera o ultimo dia do anomes e passa a data como parametro
		Calendar dataVencimentoFinal = GregorianCalendar.getInstance();
		dataVencimentoFinal.set(Calendar.YEAR, ano);
		dataVencimentoFinal.set(Calendar.MONTH, (mes - 1));
		dataVencimentoFinal.set(Calendar.DAY_OF_MONTH, dataVencimentoFinal.getActualMaximum(Calendar.DAY_OF_MONTH));

		Date dataFinalDate = dataVencimentoFinal.getTime();

		// converte String em data
		Date dataVencimento = Util.converteStringParaDate("01/01/1900");

		ObterDebitoImovelOuClienteHelper debitoImovelClienteHelper = getControladorCobranca().obterDebitoImovelOuCliente(1,
						"" + emitirContaHelper.getIdImovel(), null, null, "190001", "" + anoMesSubtraido, dataVencimento, dataFinalDate, 1,
						2, 2, 2, 2, 1, 2, null, sistemaParametro, null, null, null, ConstantesSistema.SIM, ConstantesSistema.SIM,
						ConstantesSistema.SIM, 2, null);
		// se o imovel possua débito(debitoImovelCobrança for diferente de nulo)
		if(debitoImovelClienteHelper != null
						&& ((debitoImovelClienteHelper.getColecaoGuiasPagamentoValores() != null && !debitoImovelClienteHelper
										.getColecaoGuiasPagamentoValores().isEmpty()) || (debitoImovelClienteHelper
										.getColecaoContasValores() != null && !debitoImovelClienteHelper.getColecaoContasValores()
										.isEmpty()))){
			String dataVencimentoFinalString = Util.formatarData(dataFinalDate);
			linhasImpostosRetidos[0] = "SR. USUÁRIO: EM  " + dataVencimentoFinalString
							+ ",    REGISTRAMOS QUE V.SA. ESTAVA EM DÉBITO COM A " + sistemaParametro.getNomeEmpresa() + ".";
			linhasImpostosRetidos[1] = "COMPAREÇA A UM DOS NOSSOS POSTOS DE ATENDIMENTO PARA REGULARIZAR SUA SITUACAO.EVITE O CORTE.";
			linhasImpostosRetidos[2] = "CASO O SEU DÉBITO TENHA SIDO PAGO APÓS A DATA INDICADA,DESCONSIDERE ESTE AVISO.";

		}else{
			Object[] mensagensConta = null;
			// recupera o id do grupo de faturamento da conta
			Integer idFaturamentoGrupo = emitirContaHelper.getIdFaturamentoGrupo();
			// recupera o id da gerencia regional da conta
			Integer idGerenciaRegional = emitirContaHelper.getIdGerenciaRegional();
			// recupera o id da localidade da conta
			Integer idLocalidade = emitirContaHelper.getIdLocalidade();
			// recupera o id do setor comercial da conta
			Integer idSetorComercial = emitirContaHelper.getIdSetorComercial();
			// o sistema obtem a mensagem para a conta
			// Caso seja a condição 1
			// (FaturamentoGrupo =null, GerenciaRegional=parmConta,
			// Localidade=parmConta, SetorComercial=parmConta)
			mensagensConta = this.pesquisarContaMensagem(emitirContaHelper.getAmReferencia(), idFaturamentoGrupo, idGerenciaRegional,
							idLocalidade, idSetorComercial);

			if(!Util.isVazioOrNulo(mensagensConta)){
				// Conta Mensagem 1
				if(mensagensConta[0] != null){
					linhasImpostosRetidos[0] = (String) mensagensConta[0];
				}else{
					linhasImpostosRetidos[0] = "";
				}
				// Conta Mensagem 2
				if(mensagensConta[1] != null){
					linhasImpostosRetidos[1] = (String) mensagensConta[1];
				}else{
					linhasImpostosRetidos[1] = "";
				}
				// Conta Mensagem 3
				if(mensagensConta[2] != null){
					linhasImpostosRetidos[2] = (String) mensagensConta[2];
				}else{
					linhasImpostosRetidos[2] = "";
				}
			}else{

				// caso não tenha entrado em nenhuma das opções acima
				// então completa a string com espaçõs em branco
				linhasImpostosRetidos[0] = "";
				linhasImpostosRetidos[1] = "";
				linhasImpostosRetidos[2] = "";
			}
		}

		return linhasImpostosRetidos;
	}

	/**
	 * Metódo responsável pra verificar se a Mensagem da Conta esta sendo Faturada.
	 * Manter Mensagem Conta
	 * 
	 * @author Tiago Moreno
	 * @date 23/05/2006
	 * @param String
	 *            [] ids
	 * @throws ControladorException
	 */

	public void verificarUtilizacaoMensagemConta(String[] ids) throws ControladorException{

	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00017] Gerar Linhas das Contas com Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder[] gerarLinhasContaDebitoAutomatico(EmitirContaHelper emitirContaHelper, Integer sequencialEmpresa)
					throws ControladorException{

		StringBuilder[] linhasContaDebitoAutomaticoArray = new StringBuilder[2];
		StringBuilder linhasContaDebitoAutomatico = new StringBuilder();
		// ultima linha que pode ter o continua ou não dependendo da descrição
		// de serviços e tarifas
		StringBuilder ultimaLinhaContaDebitoAutomatico = new StringBuilder();
		// -- Linha 24 --//
		// Canal
		linhasContaDebitoAutomatico.append("1");
		// Fonte
		linhasContaDebitoAutomatico.append("4");
		// parametros debito automatico
		Object[] parmsDebitoAutomatico = null;
		try{
			parmsDebitoAutomatico = repositorioArrecadacao.pesquisarParmsDebitoAutomatico(emitirContaHelper.getIdImovel());
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		String nomeBanco = "";
		String codigoAgencia = "";
		if(parmsDebitoAutomatico != null){
			// nome do banco
			if(parmsDebitoAutomatico[0] != null){
				nomeBanco = (String) parmsDebitoAutomatico[0];
			}
			// codigo Agencia
			if(parmsDebitoAutomatico[1] != null){
				codigoAgencia = ((String) parmsDebitoAutomatico[1]);
			}
		}
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 45));
		// nome do banco
		linhasContaDebitoAutomatico.append(Util.completaString(nomeBanco, 40));
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 44));
		linhasContaDebitoAutomatico.append(System.getProperty("line.separator"));

		// -- Linha 25 --//
		// Canal
		linhasContaDebitoAutomatico.append(" ");
		// Fonte
		linhasContaDebitoAutomatico.append("4");
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 13));
		// codigo agencia
		linhasContaDebitoAutomatico.append(Util.adicionarZerosEsquedaNumero(5, codigoAgencia));
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 111));
		linhasContaDebitoAutomatico.append(System.getProperty("line.separator"));

		// -- Linha 26 --//
		// Canal
		linhasContaDebitoAutomatico.append("1");
		// Fonte
		linhasContaDebitoAutomatico.append("1");
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 23));
		// Constante
		linhasContaDebitoAutomatico.append(Util.completaString("MATRICULA - ", 15));
		// matricula do imóvel
		// Recupera a matrícula do imóvel da coluna 1 e formata a matrícula
		// (ex:500000001 em 5000000.1)
		String matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(9, "" + emitirContaHelper.getIdImovel());
		matriculaImovelFormatada = matriculaImovelFormatada.substring(0, 8) + "." + matriculaImovelFormatada.substring(8, 9);
		linhasContaDebitoAutomatico.append(Util.completaString(matriculaImovelFormatada, 10));
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(" ");
		// Constante
		linhasContaDebitoAutomatico.append(Util.completaString("FATURA - ", 15));
		// mes e ano de referencia da conta
		String mesAnoFormatado = Util.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia());
		linhasContaDebitoAutomatico.append(Util.completaString(mesAnoFormatado, 7));
		String digitoVerificador = "" + emitirContaHelper.getDigitoVerificadorConta();
		linhasContaDebitoAutomatico.append(Util.completaString(("-" + digitoVerificador), 3));
		// completa com espaços em branco
		linhasContaDebitoAutomatico.append(Util.completaString("", 55));
		linhasContaDebitoAutomatico.append(System.getProperty("line.separator"));

		// -- Linha 27 --//
		// Canal
		ultimaLinhaContaDebitoAutomatico.append("1");
		// Fonte
		ultimaLinhaContaDebitoAutomatico.append("1");
		// completa com espaços em branco
		ultimaLinhaContaDebitoAutomatico.append(Util.completaString("", 13));
		// id faturamento grupo
		ultimaLinhaContaDebitoAutomatico.append(Util.completaString("" + emitirContaHelper.getIdFaturamentoGrupo(), 4));
		// completa com espaços em branco
		ultimaLinhaContaDebitoAutomatico.append(Util.completaString("", 27));
		// codigo empresa
		if(emitirContaHelper.getIdEmpresa() != null){
			ultimaLinhaContaDebitoAutomatico.append(Util.completaString("" + emitirContaHelper.getIdEmpresa(), 4));
		}else{
			ultimaLinhaContaDebitoAutomatico.append(Util.completaString("", 4));
		}
		// sequencial empresa
		String sequencialEmpresaFormatada = "";
		if(sequencialEmpresa != null){
			sequencialEmpresaFormatada = Util.adicionarZerosEsquedaNumero(6, "" + sequencialEmpresa);
			sequencialEmpresaFormatada = sequencialEmpresaFormatada.substring(0, 3) + "." + sequencialEmpresaFormatada.substring(3, 6);
			ultimaLinhaContaDebitoAutomatico.append("-" + sequencialEmpresaFormatada);
		}else{
			ultimaLinhaContaDebitoAutomatico.append(Util.completaString("", 8));
		}

		// na ultimaLinhaContaDebitoAutomatico falta ainda o continua ou não
		// assim como o sequencial

		linhasContaDebitoAutomaticoArray[0] = linhasContaDebitoAutomatico;
		linhasContaDebitoAutomaticoArray[1] = ultimaLinhaContaDebitoAutomatico;

		return linhasContaDebitoAutomaticoArray;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00018] Gerar Linhas das Contas com Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 24/05/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder[] gerarLinhasDemaisContas(EmitirContaHelper emitirContaHelper, Integer sequencialEmpresa, BigDecimal valorConta)
					throws ControladorException{

		StringBuilder[] linhasDemaisContaArray = new StringBuilder[2];
		StringBuilder linhasDemaisConta = new StringBuilder();
		// ultima linha que pode ter o continua ou não dependendo da descrição
		// de serviços e tarifas
		StringBuilder ultimaLinhaDemaisContas = new StringBuilder();

		// -- Linha 24 --//
		// Canal
		linhasDemaisConta.append("1");
		// Fonte
		linhasDemaisConta.append("1");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 12));
		String anoMesString = "" + emitirContaHelper.getAmReferencia();
		// formata ano mes para mes ano
		String mesAnoFormatado = anoMesString.substring(4, 6) + anoMesString.substring(0, 4);
		Integer digitoVerificadorConta = Integer.valueOf("" + emitirContaHelper.getDigitoVerificadorConta());

		// Representação numérica código de barras
		String representacaoNumericaCodBarra = null;

		representacaoNumericaCodBarra = this.getControladorArrecadacao().obterRepresentacaoNumericaCodigoBarra(3, valorConta,
						emitirContaHelper.getIdLocalidade(), emitirContaHelper.getIdImovel(), mesAnoFormatado, digitoVerificadorConta,
						null, null, null, DocumentoTipo.CONTA, null, null, null, null, null, null);

		// É necessário realizar essa verificação, pois o GSAN passou a utilizar a tabela
		// CODIGO_BARRAS_LAYOUT na hora de definir o código de barras
		String paramIndicadorTrataLegado = ParametroArrecadacao.P_INDICADOR_TRATA_LEGADO.executar();

		// Para atender à solicitação do cliente é ncessário incluir nas posições 34-41
		// (fica 36-43 contando com os digitos verificadores) do código de barras do
		// documento CONTA a matrícula do imóvel. Observação: As posições foram
		// referenciadas considerando os 44 caracteres do código de barras, sem os
		// dígitos verificadores. A matrícula ficaria nas posições destacadas no
		// exemplo:
		// 11111111111 D 22222222222 D 33333333333 D 44444444444 D
		// representacaoNumericaCodBarra =
		// Util.inserirMatriculaImovelCodigoBarra(emitirContaHelper.getIdImovel(),
		// representacaoNumericaCodBarra);

		if(ConstantesSistema.SIM.toString().equals(paramIndicadorTrataLegado)){
			// Para atender à solicitação do cliente é ncessário incluir nas posições 34-41
			// (fica 36-43 contando com os digitos verificadores) do código de barras do
			// documento CONTA a matrícula do imóvel. Observação: As posições foram
			// referenciadas considerando os 44 caracteres do código de barras, sem os
			// dígitos verificadores. A matrícula ficaria nas posições destacadas no
			// exemplo:
			// 11111111111 D 22222222222 D 33333333333 D 44444444444 D
			// representacaoNumericaCodBarra =
			// Util.inserirMatriculaImovelCodigoBarra(emitirContaHelper.getIdImovel(),
			// representacaoNumericaCodBarra);
		}

		String representacaoNumericaCodBarraSemDigito = "";
		String representacaoNumericaCodBarraFormatada = "";
		if(representacaoNumericaCodBarra != null){
			// Formata a representação númerica do código de
			// barras
			representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11) + "-"
							+ representacaoNumericaCodBarra.substring(11, 12) + " " + representacaoNumericaCodBarra.substring(12, 23) + "-"
							+ representacaoNumericaCodBarra.substring(23, 24) + " " + representacaoNumericaCodBarra.substring(24, 35) + "-"
							+ representacaoNumericaCodBarra.substring(35, 36) + " " + representacaoNumericaCodBarra.substring(36, 47) + "-"
							+ representacaoNumericaCodBarra.substring(47, 48);

			representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra.substring(0, 11)
							+ representacaoNumericaCodBarra.substring(12, 23) + representacaoNumericaCodBarra.substring(24, 35)
							+ representacaoNumericaCodBarra.substring(36, 47);
		}

		// adiciona a representacao codigoBarras
		linhasDemaisConta.append(Util.completaString(representacaoNumericaCodBarraFormatada, 55));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 62));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 25 --//
		// Canal
		linhasDemaisConta.append("-");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 130));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 26 --//
		// Canal
		linhasDemaisConta.append("-");
		// Fonte
		linhasDemaisConta.append("3");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 13));

		// Cria o objeto para gerar o códigode barras no
		// padrão intercalado 2 de 5
		Interleaved2of5 codigoBarraIntercalado2de5 = new Interleaved2of5();
		// Recupera a representação númerica do código de
		// barras sem os dígitos verificadores
		if(representacaoNumericaCodBarraSemDigito != null && !representacaoNumericaCodBarraSemDigito.equals("")){
			linhasDemaisConta.append(Util.completaString(codigoBarraIntercalado2de5.encodeValue(representacaoNumericaCodBarraSemDigito),
							116));
		}else{
			linhasDemaisConta.append(Util.completaString("", 116));
		}
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 27 --//
		// Canal
		linhasDemaisConta.append("1");
		// Fonte
		linhasDemaisConta.append("2");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 4));
		// matricula do imóvel
		// Recupera a matrícula do imóvel da coluna 1 e formata a matrícula
		// (ex:500000001 em 5000000.1)
		String matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(9, "" + emitirContaHelper.getIdImovel());
		matriculaImovelFormatada = matriculaImovelFormatada.substring(0, 8) + "." + matriculaImovelFormatada.substring(8, 9);
		linhasDemaisConta.append(Util.completaString(matriculaImovelFormatada, 10));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 115));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 28 --//
		// Canal
		linhasDemaisConta.append("+");
		// Fonte
		linhasDemaisConta.append("1");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 25));
		// instância um imovel com os dados da conta para recuperar a
		// inscrição que está np objeto imovel
		Imovel imovel = new Imovel();
		Localidade localidade = new Localidade();
		localidade.setId(emitirContaHelper.getIdLocalidade());
		imovel.setLocalidade(localidade);
		SetorComercial setorComercial = new SetorComercial();
		setorComercial.setCodigo(emitirContaHelper.getCodigoSetorComercialConta());
		imovel.setSetorComercial(setorComercial);
		Quadra quadra = new Quadra();
		quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
		imovel.setQuadra(quadra);
		imovel.setLote(emitirContaHelper.getLoteConta());
		imovel.setSubLote(emitirContaHelper.getSubLoteConta());
		// Inscrição do imóvel
		String inscricao = imovel.getInscricaoFormatada();
		linhasDemaisConta.append(Util.completaString(inscricao, 22));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 16));
		String mesAnoString = Util.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia());
		// mes e ano de referencia da conta
		linhasDemaisConta.append(mesAnoString);
		String digitoVerificador = "" + emitirContaHelper.getDigitoVerificadorConta();
		linhasDemaisConta.append(Util.completaString(("-" + digitoVerificador), 3));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 7));
		// data de validade da conta
		String dataValidade = Util.formatarData(emitirContaHelper.getDataValidadeConta());
		linhasDemaisConta.append(Util.completaString(dataValidade, 10));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 39));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 29 --//
		// Canal
		linhasDemaisConta.append(" ");
		// Fonte
		linhasDemaisConta.append("1");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 129));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 30 --//
		// Canal
		linhasDemaisConta.append("-");
		// Fonte
		linhasDemaisConta.append("2");
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 15));
		// data de vencimento da conta
		String dataVencimento = Util.formatarData(emitirContaHelper.getDataVencimentoConta());
		linhasDemaisConta.append(Util.completaString(dataVencimento, 10));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 35));
		// valor da conta
		String valorContaString = Util.formatarMoedaReal(valorConta);
		linhasDemaisConta.append(Util.completaStringComEspacoAEsquerda(valorContaString, 17));
		// completa com espaços em branco
		linhasDemaisConta.append(Util.completaString("", 52));
		linhasDemaisConta.append(System.getProperty("line.separator"));

		// -- Linha 31 --//
		// ultima linha depende da quantidade linhas da descrição de serviços e
		// tarifas(Para saber se vai colocar continua ou não)
		// Canal
		ultimaLinhaDemaisContas.append("-");
		// Fonte
		ultimaLinhaDemaisContas.append("1");
		// completa com espaços em branco
		ultimaLinhaDemaisContas.append(Util.completaString("", 13));
		// id faturamento grupo
		ultimaLinhaDemaisContas.append(Util.completaString("" + emitirContaHelper.getIdFaturamentoGrupo(), 4));
		// completa com espaços em branco
		ultimaLinhaDemaisContas.append(Util.completaString("", 27));
		// codigo empresa
		if(emitirContaHelper.getIdEmpresa() != null){
			ultimaLinhaDemaisContas.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getIdEmpresa(), 4));
		}else{
			ultimaLinhaDemaisContas.append(Util.completaStringComEspacoAEsquerda("", 4));
		}
		// sequencial empresa
		String sequencialEmpresaFormatada = "";
		if(sequencialEmpresa != null){
			sequencialEmpresaFormatada = Util.adicionarZerosEsquedaNumero(6, "" + sequencialEmpresa);
			sequencialEmpresaFormatada = sequencialEmpresaFormatada.substring(0, 3) + "." + sequencialEmpresaFormatada.substring(3, 6);
			ultimaLinhaDemaisContas.append("-" + sequencialEmpresaFormatada);
		}else{
			ultimaLinhaDemaisContas.append(Util.completaString("", 8));
		}
		// na ultimaLinhaContaDebitoAutomatico falta ainda o continua ou não
		// assim como o sequencial

		linhasDemaisContaArray[0] = linhasDemaisConta;
		linhasDemaisContaArray[1] = ultimaLinhaDemaisContas;

		return linhasDemaisContaArray;
	}

	/**
	 * Pesquisa todas as contas para testar o batch
	 * 
	 * @author Sávio Luiz
	 * @date 02/06/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsTodasConta() throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarIdsTodasConta();
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Gerar relatorio acompanhamento faturamento
	 * 
	 * @author Fernanda Paiva
	 * @date 02/06/2006
	 * @author Eduardo Henrique
	 * @date 15/05/2008 (Incluido tratamento para verificar se a LeituraAnormalidade do Faturamento
	 *       está nula , antes de obter Id)
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection gerarRelacaoAcompanhamentoFaturamento(String idImovelCondominio, String idImovelPrincipal, String idNomeConta,
					String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
					String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
					String intervaloValorPercentualEsgotoInicial, String intervaloValorPercentualEsgotoFinal,

					String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
					String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal,

					String idImovelPerfil, String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo,
					String idSituacaoEspecialCobranca, String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal,
					String idCadastroOcorrencia, String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial,
					String idLocalidadeFinal, String setorComercialInicial, String setorComercialFinal, String quadraInicial,
					String quadraFinal, String loteOrigem, String loteDestno, String cep, String logradouro, String bairro,
					String municipio, String idTipoMedicao, String indicadorMedicao, String idSubCategoria, String idCategoria,
					String quantidadeEconomiasInicial, String quantidadeEconomiasFinal, String diaVencimento, String idCliente,
					String idClienteTipo, String idClienteRelacaoTipo, String numeroPontosInicial, String numeroPontosFinal,
					String numeroMoradoresInicial, String numeroMoradoresFinal, String idAreaConstruidaFaixa, int anoMesReferencia,
					String consumoFixadoEsgotoPocoInicial, String consumoFixadoEsgotoPocoFinal) throws ControladorException{

		Collection colecaoImoveis = null;

		try{
			// remove primeiro as linhas do critério cobrança
			colecaoImoveis = repositorioFaturamento.gerarRelacaoAcompanhamentoFaturamento(idImovelCondominio, idImovelPrincipal,
							idNomeConta, idSituacaoLigacaoAgua, consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal,

							intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal, intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal,

							idImovelPerfil, idPocoTipo, idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
							idEloAnormalidade, areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa,
							idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal, setorComercialInicial, setorComercialFinal,
							quadraInicial, quadraFinal, loteOrigem, loteDestno, cep, logradouro, bairro, municipio, idTipoMedicao,
							indicadorMedicao, idSubCategoria, idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal,
							diaVencimento, idCliente, idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal,
							numeroMoradoresInicial, numeroMoradoresFinal, idAreaConstruidaFaixa, consumoFixadoEsgotoPocoInicial,
							consumoFixadoEsgotoPocoFinal);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		// colecao com os dados para o relatorio
		Collection colecaoGerarRelacaoAcompanhamentoFaturamento = null;

		// para cada imovel pega as conta, debitos, creditos e guias
		if(colecaoImoveis != null && !colecaoImoveis.isEmpty()){

			Iterator iteratorColecaoImoveis = colecaoImoveis.iterator();
			colecaoGerarRelacaoAcompanhamentoFaturamento = new ArrayList();

			// GerarRelacaoDebitosImovelHelper gerarRelacaoDebitosImovelHelper =
			// null;
			GerarRelacaoAcompanhamentoFaturamentoHelper gerarRelacaoAcompanhamentoFaturamentoHelper = null;
			while(iteratorColecaoImoveis.hasNext()){

				Object[] contasDadosRelatorio = (Object[]) iteratorColecaoImoveis.next();

				Imovel imovel = new Imovel();

				gerarRelacaoAcompanhamentoFaturamentoHelper = new GerarRelacaoAcompanhamentoFaturamentoHelper();

				// parte do caso de uso
				// id gerencia regional
				if(contasDadosRelatorio[0] != null){ // 0
					gerarRelacaoAcompanhamentoFaturamentoHelper.setIdGerenciaRegional(((Integer) contasDadosRelatorio[0]).toString());
				}
				// nome abreviado gerencia regional
				if(contasDadosRelatorio[1] != null){ // 1
					gerarRelacaoAcompanhamentoFaturamentoHelper.setNomeAbreviadoGerencia((String) contasDadosRelatorio[1]);
				}
				// id localidade
				if(contasDadosRelatorio[2] != null){ // 2
					gerarRelacaoAcompanhamentoFaturamentoHelper.setIdLocalidade(((Integer) contasDadosRelatorio[2]).toString());
				}
				// descricao localidade
				if(contasDadosRelatorio[3] != null){ // 3
					gerarRelacaoAcompanhamentoFaturamentoHelper.setNomeLocalidade((String) contasDadosRelatorio[3]);
				}
				// id imovel
				if(contasDadosRelatorio[4] != null){ // 4
					gerarRelacaoAcompanhamentoFaturamentoHelper.setCodigoImovel(((Integer) contasDadosRelatorio[4]).toString());
				}
				// quantidade de economias
				if(contasDadosRelatorio[5] != null){ // 5
					gerarRelacaoAcompanhamentoFaturamentoHelper.setQuantidadeEconomias(((Short) contasDadosRelatorio[5]).toString());
				}
				// codigo setor comercial
				if(contasDadosRelatorio[6] != null){ // 6
					gerarRelacaoAcompanhamentoFaturamentoHelper.setCodigoSetorComercial(((Integer) contasDadosRelatorio[6]).toString());
				}
				// numero quadra
				if(contasDadosRelatorio[7] != null){ // 7
					gerarRelacaoAcompanhamentoFaturamentoHelper.setNumeroQuadra(((Integer) contasDadosRelatorio[7]).toString());
				}
				// lote
				if(contasDadosRelatorio[8] != null){ // 8
					gerarRelacaoAcompanhamentoFaturamentoHelper.setLote(((Short) contasDadosRelatorio[8]).toString());
				}
				// sub lote
				if(contasDadosRelatorio[9] != null){ // 9
					gerarRelacaoAcompanhamentoFaturamentoHelper.setSubLote(((Short) contasDadosRelatorio[9]).toString());
				}
				// descricao ligacao agua situacao
				if(contasDadosRelatorio[10] != null){ // 10
					gerarRelacaoAcompanhamentoFaturamentoHelper.setSituacaoAgua((String) contasDadosRelatorio[10]);
				}
				// descricao ligacao esgoto situacao
				if(contasDadosRelatorio[11] != null){ // 11
					gerarRelacaoAcompanhamentoFaturamentoHelper.setSituacaoEsgoto((String) contasDadosRelatorio[11]);
				}
				// percentual
				if(contasDadosRelatorio[12] != null){ // 12
					gerarRelacaoAcompanhamentoFaturamentoHelper.setPercentualEsgoto(Util
									.formatarMoedaReal((BigDecimal) contasDadosRelatorio[12]));
				}
				// data corte
				if(contasDadosRelatorio[13] != null){ // 13
					gerarRelacaoAcompanhamentoFaturamentoHelper.setDataCorte(Util.formatarData((Date) contasDadosRelatorio[13]));
				}
				// gerencia regional - nome
				if(contasDadosRelatorio[14] != null){ // 14
					gerarRelacaoAcompanhamentoFaturamentoHelper.setNomeGerenciaRegional((String) contasDadosRelatorio[14]);
				}
				// Esgoto Fixado
				if(contasDadosRelatorio[15] != null){ // 14
					gerarRelacaoAcompanhamentoFaturamentoHelper.setEsgotoFixado((String) contasDadosRelatorio[15].toString());
				}
				// Nome Usuário
				if(contasDadosRelatorio[16] != null){ // 14
					gerarRelacaoAcompanhamentoFaturamentoHelper.setNomeClienteUsuario((String) contasDadosRelatorio[16].toString());
				}
				Localidade localidadeImovel = new Localidade();
				localidadeImovel.setId(Integer.valueOf(gerarRelacaoAcompanhamentoFaturamentoHelper.getIdLocalidade()));
				SetorComercial setorComercialImovel = new SetorComercial();
				setorComercialImovel.setCodigo(Integer.valueOf(gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoSetorComercial())
								.intValue());
				Quadra quadraImovel = new Quadra();
				quadraImovel.setNumeroQuadra(Integer.valueOf(gerarRelacaoAcompanhamentoFaturamentoHelper.getNumeroQuadra()).intValue());

				imovel.setLocalidade(localidadeImovel);
				imovel.setSetorComercial(setorComercialImovel);
				imovel.setQuadra(quadraImovel);
				imovel.setLote(new Short(gerarRelacaoAcompanhamentoFaturamentoHelper.getLote()).shortValue());
				imovel.setSubLote(new Short(gerarRelacaoAcompanhamentoFaturamentoHelper.getSubLote()).shortValue());

				gerarRelacaoAcompanhamentoFaturamentoHelper.setMesAnoFaturamento(Util.formatarAnoMesParaMesAno(anoMesReferencia));
				// Pesquisa as contas para calcular o valor total da conta
				Collection contas = null;
				try{
					contas = repositorioFaturamento.pesquisarContasDoImovelPorMesAnoReferencia(anoMesReferencia,
									gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel());
				}catch(ErroRepositorioException e){
					e.printStackTrace();
				}

				BigDecimal valorFatura = new BigDecimal("0.00");
				BigDecimal valorTotalDebito = new BigDecimal("0.00");
				if(contas != null && !contas.isEmpty()){
					Conta dadosDaConta = (Conta) contas.iterator().next();

					valorFatura = dadosDaConta.getValorTotal();
				}

				// fatura
				gerarRelacaoAcompanhamentoFaturamentoHelper.setValorFatura(valorFatura);
				// inscricao formatada do imovel
				gerarRelacaoAcompanhamentoFaturamentoHelper.setInscricao(imovel.getInscricaoFormatada());

				Calendar dataInicio = new GregorianCalendar();
				dataInicio.set(Calendar.YEAR, 1900);
				dataInicio.set(Calendar.MONTH, 0);
				dataInicio.set(Calendar.DAY_OF_MONTH, 1);

				Calendar dataFim = new GregorianCalendar();
				dataFim.set(Calendar.YEAR, 9999);
				dataFim.set(Calendar.MONTH, 11);
				dataFim.set(Calendar.DAY_OF_MONTH, 31);

				ObterDebitoImovelOuClienteHelper obterDebitoImovelOuClienteHelper = this.getControladorCobranca()
								.obterDebitoImovelOuCliente(1, gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), null, null,
												"190001", "999912", dataInicio.getTime(), dataFim.getTime(), 1, 1, 1, 1, 1, 1, 1, null,
												null, null, null, null, ConstantesSistema.SIM, ConstantesSistema.SIM,
												ConstantesSistema.SIM, 2, null);

				// obter endereco
				gerarRelacaoAcompanhamentoFaturamentoHelper.setEndereco(getControladorEndereco().pesquisarEndereco(
								Integer.valueOf(gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel())));

				// obter categoria do imovel
				gerarRelacaoAcompanhamentoFaturamentoHelper.setCategoriaPrincipal(getControladorImovel().obterPrincipalCategoriaImovel(
								Integer.valueOf(gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel())).getDescricaoAbreviada());

				// pega as colecoes do retorno do método obter débito e calcula
				// o valor total do débito
				if(obterDebitoImovelOuClienteHelper.getColecaoContasValores() != null
								&& !obterDebitoImovelOuClienteHelper.getColecaoContasValores().isEmpty()){

					Iterator contaValores = obterDebitoImovelOuClienteHelper.getColecaoContasValores().iterator();
					while(contaValores.hasNext()){
						ContaValoresHelper contaValoresHelper = (ContaValoresHelper) contaValores.next();

						valorTotalDebito = valorTotalDebito.add(contaValoresHelper.getConta().getValorTotal());
					}
				}
				if(obterDebitoImovelOuClienteHelper.getColecaoDebitoACobrar() != null
								&& !obterDebitoImovelOuClienteHelper.getColecaoDebitoACobrar().isEmpty()){

					Iterator debitoACobrarIterator = obterDebitoImovelOuClienteHelper.getColecaoDebitoACobrar().iterator();
					while(debitoACobrarIterator.hasNext()){
						DebitoACobrar debitoACobrar = (DebitoACobrar) debitoACobrarIterator.next();

						valorTotalDebito = valorTotalDebito.add(debitoACobrar.getValorTotal());
					}
				}
				if(obterDebitoImovelOuClienteHelper.getColecaoCreditoARealizar() != null
								&& !obterDebitoImovelOuClienteHelper.getColecaoCreditoARealizar().isEmpty()){

					Iterator creditoARealizarIterator = obterDebitoImovelOuClienteHelper.getColecaoCreditoARealizar().iterator();
					while(creditoARealizarIterator.hasNext()){
						CreditoARealizar creditoARealizar = (CreditoARealizar) creditoARealizarIterator.next();

						valorTotalDebito = valorTotalDebito.add(creditoARealizar.getValorTotal());
					}
				}
				if(obterDebitoImovelOuClienteHelper.getColecaoGuiasPagamentoValores() != null
								&& !obterDebitoImovelOuClienteHelper.getColecaoGuiasPagamentoValores().isEmpty()){

					Iterator guiaPagamentoValoresIterator = obterDebitoImovelOuClienteHelper.getColecaoGuiasPagamentoValores().iterator();
					while(guiaPagamentoValoresIterator.hasNext()){
						GuiaPagamentoValoresHelper guiaPagamentoValores = (GuiaPagamentoValoresHelper) guiaPagamentoValoresIterator.next();

						valorTotalDebito = valorTotalDebito.add(guiaPagamentoValores.getValorTotalPrestacao());
					}
				}
				gerarRelacaoAcompanhamentoFaturamentoHelper.setValorDebito(valorTotalDebito);
				// Pesquisa o consumo médio de água ou esgoto
				Collection colecaoConsumoMedioAgua = null;
				Collection colecaoConsumoMedioEsgoto = null;

				String consumoMedio = null;
				try{
					colecaoConsumoMedioAgua = repositorioFaturamento.pesquisarConsumoMedioLigacaoAgua(
									gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), anoMesReferencia);
				}catch(ErroRepositorioException e){
					e.printStackTrace();
				}
				if(colecaoConsumoMedioAgua != null){

					Iterator consumoHistoricoIterator = colecaoConsumoMedioAgua.iterator();
					while(consumoHistoricoIterator.hasNext()){
						ConsumoHistorico consumoHistorico = (ConsumoHistorico) consumoHistoricoIterator.next();
						if(consumoHistorico.getConsumoMedio() != null){
							consumoMedio = consumoHistorico.getConsumoMedio().toString();
						}
					}
				}else{
					try{
						colecaoConsumoMedioEsgoto = repositorioFaturamento.pesquisarConsumoMedioLigacaoEsgoto(
										gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), anoMesReferencia);
					}catch(ErroRepositorioException e){
						e.printStackTrace();
					}
					if(colecaoConsumoMedioEsgoto != null){

						Iterator consumoHistoricoIterator = colecaoConsumoMedioEsgoto.iterator();
						while(consumoHistoricoIterator.hasNext()){
							ConsumoHistorico consumoHistoricoEsgoto = (ConsumoHistorico) consumoHistoricoIterator.next();
							if(consumoHistoricoEsgoto.getConsumoMedio() != null){
								consumoMedio = consumoHistoricoEsgoto.getConsumoMedio().toString();
							}
						}
					}
				}
				if(consumoMedio != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setConsumoMedio(consumoMedio.toString());
				}

				// pesquisa o consumo do mes de agua ou esgoto
				String consumoMes = null;
				String consumoAnormalidade = null;
				Collection colecaoConsumoMesAgua = null;
				Collection colecaoConsumoMesEsgoto = null;

				try{
					colecaoConsumoMesAgua = repositorioFaturamento.pesquisarConsumoMesLigacaoAgua(
									gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), anoMesReferencia);
				}catch(ErroRepositorioException e){
					e.printStackTrace();
				}
				if(colecaoConsumoMesAgua != null){

					Iterator consumoHistoricoMesIterator = colecaoConsumoMesAgua.iterator();
					while(consumoHistoricoMesIterator.hasNext()){
						Object[] consumoHistoricoMes = (Object[]) consumoHistoricoMesIterator.next();
						if(consumoHistoricoMes[0] != null){
							consumoMes = ((Integer) consumoHistoricoMes[0]).toString();
						}
						if(consumoHistoricoMes[1] != null){
							consumoAnormalidade = (String) consumoHistoricoMes[1];
						}
					}
				}else{
					try{
						colecaoConsumoMesEsgoto = repositorioFaturamento.pesquisarConsumoMesLigacaoEsgoto(
										gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), anoMesReferencia);
					}catch(ErroRepositorioException e){
						e.printStackTrace();
					}
					if(colecaoConsumoMesEsgoto != null){

						Iterator consumoMesIterator = colecaoConsumoMesEsgoto.iterator();
						while(consumoMesIterator.hasNext()){
							Object[] consumoHistoricoEsgotoMes = (Object[]) consumoMesIterator.next();
							if(consumoHistoricoEsgotoMes[0] != null){
								consumoMes = ((Integer) consumoHistoricoEsgotoMes[0]).toString();
							}
							if(consumoHistoricoEsgotoMes[1] != null){
								consumoAnormalidade = (String) consumoHistoricoEsgotoMes[1];
							}
						}
					}
				}

				if(consumoMes != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setConsumoMes(consumoMes.toString());
				}
				if(consumoAnormalidade != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setConsumoAnormalidade(consumoAnormalidade);
				}

				// pesquisa o leitura faturada de agua ou esgoto
				String fatura = null;
				Collection colecaoFaturaMesAgua = null;
				Collection colecaoFaturaMesEsgoto = null;
				Integer idLeituraAnormalidadeFaturamento = null;
				String anormalidadeLeitura = null;

				try{
					colecaoFaturaMesAgua = repositorioFaturamento.pesquisarLeituraFaturadaLigacaoAgua(
									gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), anoMesReferencia);
				}catch(ErroRepositorioException e){
					e.printStackTrace();
				}
				if(colecaoFaturaMesAgua != null){

					Iterator medicaoHistoricoMesIterator = colecaoFaturaMesAgua.iterator();
					while(medicaoHistoricoMesIterator.hasNext()){
						Object[] medicaoHistoricoMes = (Object[]) medicaoHistoricoMesIterator.next();
						if(medicaoHistoricoMes[0] != null){
							fatura = "" + (Integer) medicaoHistoricoMes[0];
						}
						if(medicaoHistoricoMes[1] != null){
							idLeituraAnormalidadeFaturamento = (Integer) medicaoHistoricoMes[1];
						}
					}
				}else{
					try{
						colecaoFaturaMesEsgoto = repositorioFaturamento.pesquisarLeituraFaturadaLigacaoEsgoto(
										gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), anoMesReferencia);
					}catch(ErroRepositorioException e){
						e.printStackTrace();
					}
					if(colecaoFaturaMesEsgoto != null){

						Iterator faturaMesIterator = colecaoFaturaMesEsgoto.iterator();
						while(faturaMesIterator.hasNext()){
							MedicaoHistorico medicaoHistoricoEsgotoMes = (MedicaoHistorico) faturaMesIterator.next();
							fatura = Integer.valueOf(medicaoHistoricoEsgotoMes.getLeituraAtualFaturamento()).toString();

							idLeituraAnormalidadeFaturamento = medicaoHistoricoEsgotoMes.getLeituraAnormalidadeFaturamento() != null ? medicaoHistoricoEsgotoMes
											.getLeituraAnormalidadeFaturamento().getId() : null;
						}
					}
				}

				if(fatura != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setFatura(fatura);
				}

				// pesquisa a leitura anormalidade
				if(idLeituraAnormalidadeFaturamento != null){
					try{
						anormalidadeLeitura = repositorioFaturamento.pesquisarAnormalidadeLeitura(idLeituraAnormalidadeFaturamento);
					}catch(ErroRepositorioException e){
						e.printStackTrace();
					}
					if(anormalidadeLeitura != null){
						gerarRelacaoAcompanhamentoFaturamentoHelper.setAnormalidade(anormalidadeLeitura);
					}
				}
				// Consumo de seis periodos
				int mesAnoFaturamentoDiferenca = 0;
				String[] consumoSeisMeses = new String[6];
				for(int i = 0; i < 6; i++){
					mesAnoFaturamentoDiferenca = i + 1;

					mesAnoFaturamentoDiferenca = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesReferencia, mesAnoFaturamentoDiferenca);

					// Pesquisa o consumo de seis meses de água ou esgoto
					Collection colecaoConsumoSeisMesesAgua = null;
					Collection colecaoConsumoSeisMesesEsgoto = null;

					try{
						colecaoConsumoSeisMesesAgua = repositorioFaturamento.pesquisarConsumoMedioLigacaoAgua(
										gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), mesAnoFaturamentoDiferenca);
					}catch(ErroRepositorioException e){
						e.printStackTrace();
					}
					if(colecaoConsumoSeisMesesAgua != null){

						Iterator consumoHistoricoSeisMesesIterator = colecaoConsumoSeisMesesAgua.iterator();
						while(consumoHistoricoSeisMesesIterator.hasNext()){
							ConsumoHistorico consumoHistoricoSeisMeses = (ConsumoHistorico) consumoHistoricoSeisMesesIterator.next();
							if(consumoHistoricoSeisMeses.getNumeroConsumoFaturadoMes() != null){
								consumoSeisMeses[i] = consumoHistoricoSeisMeses.getNumeroConsumoFaturadoMes().toString();
							}
						}
					}else{
						try{
							colecaoConsumoSeisMesesEsgoto = repositorioFaturamento.pesquisarConsumoMedioLigacaoEsgoto(
											gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), mesAnoFaturamentoDiferenca);
						}catch(ErroRepositorioException e){
							e.printStackTrace();
						}
						if(colecaoConsumoSeisMesesEsgoto != null){

							Iterator consumoHistoricoSeisMesesIterator = colecaoConsumoSeisMesesEsgoto.iterator();
							while(consumoHistoricoSeisMesesIterator.hasNext()){
								ConsumoHistorico consumoHistoricoSeisMesesEsgoto = (ConsumoHistorico) consumoHistoricoSeisMesesIterator
												.next();
								if(consumoHistoricoSeisMesesEsgoto.getNumeroConsumoFaturadoMes() != null){
									consumoSeisMeses[i] = consumoHistoricoSeisMesesEsgoto.getNumeroConsumoFaturadoMes().toString();
								}
							}
						}
					}
				}
				if(consumoSeisMeses[0] != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setMesUm(consumoSeisMeses[0]);
				}
				if(consumoSeisMeses[1] != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setMesDois(consumoSeisMeses[1]);
				}
				if(consumoSeisMeses[2] != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setMesTres(consumoSeisMeses[2]);
				}
				if(consumoSeisMeses[3] != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setMesQuatro(consumoSeisMeses[3]);
				}
				if(consumoSeisMeses[4] != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setMesCinco(consumoSeisMeses[4]);
				}
				if(consumoSeisMeses[5] != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setMesSeis(consumoSeisMeses[5]);
				}

				// pesquisa o leitura faturada de agua ou esgoto
				Collection colecaoInstacaoHidrometroLigacaoAgua = null;
				Collection colecaoInstacaoHidrometroLigacaoEsgoto = null;
				String dataInstalacaoHidrometro = null;

				try{
					colecaoInstacaoHidrometroLigacaoAgua = repositorioFaturamento
									.pesquisarDataHidrometroLigacaoAgua(gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel());
				}catch(ErroRepositorioException e){
					e.printStackTrace();
				}
				if(colecaoInstacaoHidrometroLigacaoAgua != null){

					Iterator instalacaoHidrometroIterator = colecaoInstacaoHidrometroLigacaoAgua.iterator();
					while(instalacaoHidrometroIterator.hasNext()){
						HidrometroInstalacaoHistorico instalacaoHidrometro = (HidrometroInstalacaoHistorico) instalacaoHidrometroIterator
										.next();
						dataInstalacaoHidrometro = Util.formatarData(instalacaoHidrometro.getDataInstalacao());
					}
				}else{
					try{
						colecaoInstacaoHidrometroLigacaoEsgoto = repositorioFaturamento
										.pesquisarDataHidrometroLigacaoEsgoto(gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel());
					}catch(ErroRepositorioException e){
						e.printStackTrace();
					}
					if(colecaoInstacaoHidrometroLigacaoEsgoto != null){

						Iterator instalacaoHidrometroEsgotoIterator = colecaoInstacaoHidrometroLigacaoEsgoto.iterator();
						while(instalacaoHidrometroEsgotoIterator.hasNext()){
							HidrometroInstalacaoHistorico instalacaoHidrometroEsgoto = (HidrometroInstalacaoHistorico) instalacaoHidrometroEsgotoIterator
											.next();
							dataInstalacaoHidrometro = Util.formatarData(instalacaoHidrometroEsgoto.getDataInstalacao());
						}
					}
				}
				if(dataInstalacaoHidrometro != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setDataInstalacaoHidrometro(dataInstalacaoHidrometro);
				}

				Collection colecaoConsumoFaturadoMes = null;
				String percentualVariacao = null;
				Integer numeroConsumoFaturadoMes = 0;

				try{
					colecaoConsumoFaturadoMes = repositorioFaturamento.pesquisarConsumoFaturadoMes(
									gerarRelacaoAcompanhamentoFaturamentoHelper.getCodigoImovel(), anoMesReferencia);
				}catch(ErroRepositorioException e){
					e.printStackTrace();
				}
				if(colecaoConsumoFaturadoMes != null){

					Iterator consumoFaturadoMesIterator = colecaoConsumoFaturadoMes.iterator();
					while(consumoFaturadoMesIterator.hasNext()){
						ConsumoHistorico consumoHistoricoMes = (ConsumoHistorico) consumoFaturadoMesIterator.next();
						numeroConsumoFaturadoMes = consumoHistoricoMes.getNumeroConsumoFaturadoMes();
					}
					if(numeroConsumoFaturadoMes != 0 && consumoMedio != null){
						percentualVariacao = Calculos.obterPercentualVariacaoConsumoFaturado(numeroConsumoFaturadoMes,
										Integer.parseInt(consumoMedio));
					}
				}
				if(percentualVariacao != null){
					gerarRelacaoAcompanhamentoFaturamentoHelper.setVariacao(percentualVariacao);
				}

				colecaoGerarRelacaoAcompanhamentoFaturamento.add(gerarRelacaoAcompanhamentoFaturamentoHelper);

			}// fim while
		}// fim if

		return colecaoGerarRelacaoAcompanhamentoFaturamento;
	}

	public Collection<FaturamentoAtividadeCronograma> pesquisarRelacaoAtividadesGrupo(Integer faturamentoGrupoId)
					throws ControladorException{

		Collection<FaturamentoAtividadeCronograma> retorno = null;
		try{
			retorno = repositorioFaturamento.pesquisarRelacaoAtividadesGrupo(faturamentoGrupoId);
		}catch(ErroRepositorioException e){

			e.printStackTrace();
		}
		return retorno;
	}

	/**
	 * [UC0169] Manter Taraifa de Consumo Prepara a Vigência para Ser reajustada
	 * 
	 * @author Rafel Santos
	 * @date 21/07/2006
	 */
	public void iniciarProcessoReajustarTarifaConsumo(Map listaParametrosValoresCategoria, Date dataNovaVigencia, String[] idsRecuperados,
					Usuario usuarioLogado, String descricaoAtoAdministrativo) throws ControladorException{

		for(int i = 0; i < idsRecuperados.length; i++){
			Map<ConsumoTarifaVigencia, Map<ConsumoTarifaCategoria, BigDecimal>> mapFachada = new HashMap();

			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia.adicionarCaminhoParaCarregamentoEntidade("consumoTarifaCategorias");
			filtroConsumoTarifaVigencia.adicionarCaminhoParaCarregamentoEntidade("calculoTipo");
			filtroConsumoTarifaVigencia.adicionarCaminhoParaCarregamentoEntidade(FiltroConsumoTarifaVigencia.CONSUMO_TARIFA);
			filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.ID, idsRecuperados[i]));
			Collection colecaoConsumoTarifaVigencia = getControladorUtil().pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());
			ConsumoTarifaVigencia consumoTarifaVigencia = (ConsumoTarifaVigencia) Util.retonarObjetoDeColecao(colecaoConsumoTarifaVigencia);

			consumoTarifaVigencia.setDataVigencia(dataNovaVigencia);
			consumoTarifaVigencia.setDescricaoAtoAdministrativo(descricaoAtoAdministrativo);

			Iterator iteratorConsumoTarifaCategorias = consumoTarifaVigencia.getConsumoTarifaCategorias().iterator();

			Map tempMap = new HashMap();
			while(iteratorConsumoTarifaCategorias.hasNext()){
				ConsumoTarifaCategoria consumoTarifaCategoria = (ConsumoTarifaCategoria) iteratorConsumoTarifaCategorias.next();
				Categoria categoria = consumoTarifaCategoria.getCategoria();

				if(listaParametrosValoresCategoria.get(categoria.getId()) != null){
					BigDecimal percentualReajuste = (BigDecimal) listaParametrosValoresCategoria.get(categoria.getId());

					tempMap.put(consumoTarifaCategoria, percentualReajuste);

				}

			}
			mapFachada.put(consumoTarifaVigencia, tempMap);

			reajustarTarifaConsumo(mapFachada, usuarioLogado);

		}
	}

	/**
	 * [UC0169] Manter Tarifa de Consumo
	 * [FS0002] Verificar Data de Vigencia
	 * 
	 * @author Rafael Santos
	 * @date 21/07/2006
	 * @param mapReajuste
	 * @throws ControladorException
	 */
	protected void verificarDataVigencia(Map<ConsumoTarifaVigencia, Map<ConsumoTarifaCategoria, BigDecimal>> mapReajuste)
					throws ControladorException{

		Iterator<ConsumoTarifaVigencia> iteratorTarifaVigencia2 = mapReajuste.keySet().iterator();

		while(iteratorTarifaVigencia2.hasNext()){
			ConsumoTarifaVigencia consumoTarifaVigencia = iteratorTarifaVigencia2.next();

			// testar a data de vigência se é posterior
			// [FS0002] - Verificar data de vigência
			int idConsumoTarifa = consumoTarifaVigencia.getConsumoTarifa().getId();
			// int idConsumoTarifaVigencia = consumoTarifaVigencia.getId();

			// pesquisa
			FiltroConsumoTarifa filtroConsumoTarifa = new FiltroConsumoTarifa();
			filtroConsumoTarifa.adicionarParametro(new ParametroSimples(FiltroConsumoTarifa.ID, idConsumoTarifa));
			Collection colecaoConsumoTarifa = getControladorUtil().pesquisar(filtroConsumoTarifa, ConsumoTarifa.class.getName());

			for(Iterator iter = colecaoConsumoTarifa.iterator(); iter.hasNext();){
				ConsumoTarifa consumoTarifa = (ConsumoTarifa) iter.next();

				Collection colecaoDataVigenciaEmVigorArray = null;

				try{
					colecaoDataVigenciaEmVigorArray = repositorioFaturamento.pesquisarMaiorDataConsumoTarifaVigencia(consumoTarifa);
				}catch(ErroRepositorioException ex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				Iterator colecaoDataVigenciaEmVigorArrayIt = colecaoDataVigenciaEmVigorArray.iterator();

				Date dataVigenciaEmVigor = ((Date) colecaoDataVigenciaEmVigorArrayIt.next());

				// verificando a Data de Vigencia com a Maior data exisente
				Calendar dataExistente = new GregorianCalendar();
				dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());

				if(dataVigenciaEmVigor != null){

					Calendar dataVigenciaSerInserida = new GregorianCalendar();
					dataVigenciaSerInserida.setTime(dataVigenciaEmVigor);

					if((dataExistente.compareTo(dataVigenciaSerInserida)) <= 0){
						throw new ControladorException("atencao.data_vigencia_errada", null, Util.formatarData(dataVigenciaEmVigor));
					}
				}

				// verifica a Data de Vigencia com a Ano Mes de Faturamento
				Integer anoMesFaturamento = getControladorUtil().pesquisarParametrosDoSistema().getAnoMesFaturamento();

				dataExistente.setTime(consumoTarifaVigencia.getDataVigencia());
				String anoMesDataVigenciaTarifa = null;
				if((dataExistente.get(Calendar.MONTH) + 1) < 10){
					anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR) + "0" + (dataExistente.get(Calendar.MONTH) + 1);
				}else{
					anoMesDataVigenciaTarifa = dataExistente.get(Calendar.YEAR) + "" + (dataExistente.get(Calendar.MONTH) + 1);
				}

				Integer anoMesVigencia = Integer.valueOf(anoMesDataVigenciaTarifa);

				if(anoMesVigencia.intValue() < anoMesFaturamento.intValue()){
					throw new ControladorException("atencao.data_vigencia.posterior.ano_mes_faturamento", null,
									Util.formatarAnoMesParaMesAno(anoMesFaturamento.intValue()));
				}

				// verificar se a Data de Vigencia é mario que 90 dias
				Calendar dataCorrente = new GregorianCalendar();
				dataCorrente.add(Calendar.DAY_OF_MONTH, 90);

				if((dataExistente.compareTo(dataCorrente)) > 0){
					throw new ControladorException("atencao.data_vigencia.maior_que.90_dias", null, Util.formatarData(dataVigenciaEmVigor));
				}
			}

		}
	}

	/**
	 * Este caso de uso calcula a tarifa miníma de água para um imóvel
	 * [UC0451] Obter Tarifa Miníma de Água para um Imóvel
	 * 
	 * @author Roberta Costa
	 * @date 09/08/2006
	 * @author eduardo henrique
	 * @date 08/07/2008 Aumento das casas decimais das Tarifas para 4 casas
	 * @param imovel
	 * @param colecaoCategorias
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	public BigDecimal obterTarifaMinimaAguaImovel(Imovel imovel) throws ControladorException{

		// Declaração de variáveis
		BigDecimal tarifaMinimaAguaImovel = new BigDecimal("0.0000");
		BigDecimal resultadoTarifaMinimaAguaImovel = new BigDecimal("0.0000");

		// Declaração de objetos
		Collection colecaoDataVigencia = null;

		// Obtém o id da tarifa vigência da maior data de vigência da tarifa do
		// imóvel
		try{
			colecaoDataVigencia = repositorioMicromedicao.pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(), imovel
							.getConsumoTarifa().getId());
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém o id do array e atribui na variável
		Object[] consumoTarifaVigenciaIdArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoDataVigencia);
		Integer consumoTarifaVigenciaId = null;

		if(consumoTarifaVigenciaIdArray == null){
			throw new ControladorException("atencao.nao_cadastrada_consumo_tarifa_vigencia", null, String.valueOf(imovel.getId()));
		}

		if(consumoTarifaVigenciaIdArray[0] != null){
			consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0];
		}

		// Cria o objeto consumo tarifa vigência e seta o id
		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		consumoTarifaVigencia.setId(consumoTarifaVigenciaId);

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();

		while(colecaoCategoriasIterator.hasNext()){

			Categoria categoria = (Categoria) colecaoCategoriasIterator.next();

			Integer idSubCategoria = 0;

			try{
				// Obtém a tarifa mínima da categoria do imóvel
				BigDecimal tarifaMinima = (BigDecimal) repositorioFaturamento.pesquisarTarifaMinimaCategoriaVigencia(categoria,
								consumoTarifaVigencia, idSubCategoria);

				if(tarifaMinima != null){
					tarifaMinimaAguaImovel = tarifaMinima;
				}

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			// Multiplica a quantidade de economias da categoria pelo consumo
			// mínimo e acumula
			resultadoTarifaMinimaAguaImovel = resultadoTarifaMinimaAguaImovel.add(tarifaMinimaAguaImovel.multiply(new BigDecimal(categoria
							.getQuantidadeEconomiasCategoria())));

		}

		// Retorna o consumo mínimo da ligação
		return resultadoTarifaMinimaAguaImovel;
	}

	/**
	 * Pesquisa a existencia de uma conta pelo id da conta e pela data da ultima alteracao
	 * 
	 * @param id
	 *            Descrição do parâmetro
	 * @param ultimaAlteracao
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	@Deprecated
	public Integer pesquisarExistenciaContaParaConcorrencia(String idConta, Date ultimaAlteracao) throws ControladorException{

		Integer retornoIdConta = null;
		try{
			retornoIdConta = repositorioFaturamento.pesquisarExistenciaContaParaConcorrencia(idConta, ultimaAlteracao);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retornoIdConta;
	}

	public Integer verificarExistenciaDebitoTipo(Integer idDebitoTipo) throws ControladorException{

		// Retorna o cliente encontrado ou vazio se não existir
		try{
			return repositorioFaturamento.verificarExistenciaDebitoTipo(idDebitoTipo);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0410] - Inserir Tipo de Serviço
	 * 
	 * @author lms
	 * @date 01/08/2006
	 */
	public DebitoTipo pesquisarDebitoTipo(Integer idDebitoTipo) throws ControladorException{

		DebitoTipo debitoTipo = pesquisarDebitoTipo(idDebitoTipo.toString());
		if(debitoTipo == null){
			throw new ControladorException("atencao.pesquisa_inexistente", null, "Tipo de Débito");
		}
		return debitoTipo;
	}

	/**
	 * [UC0410] - Inserir Tipo de Serviço
	 * 
	 * @author lms
	 * @date 07/08/2006
	 */
	public CreditoTipo pesquisarCreditoTipo(Integer idCreditoTipo) throws ControladorException{

		CreditoTipo creditoTipo = null;
		FiltroCreditoTipo filtro = new FiltroCreditoTipo();
		filtro.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, idCreditoTipo));
		filtro.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.INDICADOR_USO, ConstantesSistema.INDICADOR_USO_ATIVO));
		Collection colecao = getControladorUtil().pesquisar(filtro, CreditoTipo.class.getName());
		if(colecao == null || colecao.isEmpty()){
			throw new ControladorException("atencao.pesquisa_inexistente", null, "Crédito Tipo");
		}else{
			creditoTipo = (CreditoTipo) colecao.iterator().next();
		}
		return creditoTipo;
	}

	/**
	 * Consulta os dados da conta
	 * 
	 * @param idConta
	 *            Id da Conta
	 * @author Fernanda Paiva, eduardo henrique
	 * @date 17/07/2009 Alteracao na assinatura do método para retorno de uma instancia de conta,
	 *       com seus principais dados atribuídos.
	 * @return uma colecao de conta
	 */
	public Conta consultarConta(Integer idConta) throws ControladorException{

		Collection colecaoConta = null;
		Conta conta = null;
		// Pesquisa conta
		try{
			colecaoConta = repositorioFaturamento.consultarConta(idConta);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe conta
		if(colecaoConta != null && !colecaoConta.isEmpty()){

			Iterator iteratorColecaoConta = colecaoConta.iterator();

			while(iteratorColecaoConta.hasNext()){

				Object[] arrayConta = (Object[]) iteratorColecaoConta.next();

				conta = new Conta();
				// id do imovel - Item [0]
				if(arrayConta[0] != null){
					Imovel imovel = new Imovel();
					imovel.setId((Integer) arrayConta[0]);
					conta.setImovel(imovel);
				}

				// referencia da conta - Item [1]
				if(arrayConta[1] != null){
					conta.setReferencia((Integer) arrayConta[1]);
				}

				// debito credito situação atual - Item [2]
				if(arrayConta[2] != null){
					conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) arrayConta[2]);
				}

				// ligação de água - Item 3
				if(arrayConta[3] != null){
					conta.setLigacaoAguaSituacao((LigacaoAguaSituacao) arrayConta[3]);
				}
				// ligacao de esgoto - Item [4]
				if(arrayConta[4] != null){

					conta.setLigacaoEsgotoSituacao((LigacaoEsgotoSituacao) arrayConta[4]);
				}
				// indicador de cobranca de multa - item [5]
				if(arrayConta[5] != null){
					conta.setIndicadorCobrancaMulta(((Short) arrayConta[5]).shortValue());
				}
				// indicador de alteracao de vencimento - item [6]
				if(arrayConta[6] != null){
					conta.setIndicadorAlteracaoVencimento((Short) arrayConta[6]);
				}
				// consumo de agua - item [7]
				if(arrayConta[7] != null){
					conta.setConsumoAgua((Integer) arrayConta[7]);
				}
				// consumo de esgoto - item [8]
				if(arrayConta[8] != null){
					conta.setConsumoEsgoto((Integer) arrayConta[8]);
				}
				// percentual esgoto - item [9]
				if(arrayConta[9] != null){
					conta.setPercentualEsgoto((BigDecimal) arrayConta[9]);
				}
				// Valor Agua - item [10]
				if(arrayConta[10] != null){
					conta.setValorAgua((BigDecimal) arrayConta[10]);
				}
				// Valor Esgoto - item [11]
				if(arrayConta[11] != null){
					conta.setValorEsgoto((BigDecimal) arrayConta[11]);
				}
				// Debitos - item [12]
				if(arrayConta[12] != null){
					conta.setDebitos((BigDecimal) arrayConta[12]);
				}
				// valorCreditos - item [13]
				if(arrayConta[13] != null){
					conta.setValorCreditos((BigDecimal) arrayConta[13]);
				}
				// indicador debito conta - item [14]
				if(arrayConta[14] != null){
					conta.setIndicadorDebitoConta(((Short) arrayConta[14]).shortValue());
				}

				// id conta - item [15]
				if(arrayConta[15] != null){
					conta.setId((Integer) arrayConta[15]);
				}
				// data vencimento conta - item [16]
				if(arrayConta[16] != null){
					conta.setDataVencimentoConta((Date) arrayConta[16]);
				}
				// data validade conta - item [17]
				if(arrayConta[17] != null){
					conta.setDataValidadeConta((Date) arrayConta[17]);
				}
				// data inclusao conta - item [18]
				if(arrayConta[18] != null){
					conta.setDataInclusao((Date) arrayConta[18]);
				}
				// data retificacao conta - item [19]
				if(arrayConta[19] != null){
					conta.setDataRetificacao((Date) arrayConta[19]);
				}
				// data cancelamento conta - item [20]
				if(arrayConta[20] != null){
					conta.setDataCancelamento((Date) arrayConta[20]);
				}
				// data revisao conta - item [21]
				if(arrayConta[21] != null){
					conta.setDataRevisao((Date) arrayConta[21]);
				}

				// motivo nao entrega documento - item [22]
				if(arrayConta[22] != null){

					MotivoNaoEntregaDocumento motivoNaoEntregaDocumento = new MotivoNaoEntregaDocumento();

					motivoNaoEntregaDocumento.setId((Integer) arrayConta[22]);
					motivoNaoEntregaDocumento.setDescricao((String) arrayConta[23]);
					motivoNaoEntregaDocumento.setDescricaoAbreviada((String) arrayConta[24]);
					motivoNaoEntregaDocumento.setIndicadorUso((Short) arrayConta[25]);
					motivoNaoEntregaDocumento.setUltimaAlteracao((Date) arrayConta[26]);

					conta.setMotivoNaoEntregaDocumento(motivoNaoEntregaDocumento);
				}

				// contaMotivoInclusao - item [27]
				if(arrayConta[27] != null){

					ContaMotivoInclusao contaMotivoInclusao = new ContaMotivoInclusao();

					contaMotivoInclusao.setId((Integer) arrayConta[27]);
					contaMotivoInclusao.setDescricaoMotivoInclusaoConta((String) arrayConta[28]);
					contaMotivoInclusao.setIndicadorUso((Short) arrayConta[29]);
					contaMotivoInclusao.setUltimaAlteracao((Date) arrayConta[30]);

					conta.setContaMotivoInclusao(contaMotivoInclusao);
				}

				// contaMotivoRetificacao - item [31]
				if(arrayConta[31] != null){

					ContaMotivoRetificacao contaMotivoRetificacao = new ContaMotivoRetificacao();

					contaMotivoRetificacao.setId((Integer) arrayConta[31]);
					contaMotivoRetificacao.setDescricaoMotivoRetificacaoConta((String) arrayConta[32]);
					contaMotivoRetificacao.setIndicadorUso((Short) arrayConta[33]);
					contaMotivoRetificacao.setUltimaAlteracao((Date) arrayConta[34]);

					conta.setContaMotivoRetificacao(contaMotivoRetificacao);
				}

				// contaMotivoCancelamento - item [35]
				if(arrayConta[35] != null){

					ContaMotivoCancelamento contaMotivoCancelamento = new ContaMotivoCancelamento();

					contaMotivoCancelamento.setId((Integer) arrayConta[35]);
					contaMotivoCancelamento.setDescricaoMotivoCancelamentoConta((String) arrayConta[36]);
					contaMotivoCancelamento.setIndicadorUso((Short) arrayConta[37]);
					contaMotivoCancelamento.setUltimaAlteracao((Date) arrayConta[38]);

					conta.setContaMotivoCancelamento(contaMotivoCancelamento);
				}

				// contaMotivoRevisao - item [39]
				if(arrayConta[39] != null){

					ContaMotivoRevisao contaMotivoRevisao = new ContaMotivoRevisao();

					contaMotivoRevisao.setId((Integer) arrayConta[39]);
					contaMotivoRevisao.setDescricaoMotivoRevisaoConta((String) arrayConta[40]);
					contaMotivoRevisao.setIndicadorUso((Short) arrayConta[41]);
					contaMotivoRevisao.setUltimaAlteracao((Date) arrayConta[42]);

					conta.setContaMotivoRevisao(contaMotivoRevisao);
				}

				// CONTA_ORIGEM
				if(arrayConta[43] != null){

					ContaGeral contaGeralOrigem = new ContaGeral();
					contaGeralOrigem.setId((Integer) arrayConta[43]);

					Conta contaOrigem = new Conta();
					contaOrigem.setId((Integer) arrayConta[43]);

					Imovel imovelOrigem = new Imovel();
					imovelOrigem.setId((Integer) arrayConta[44]);

					contaOrigem.setImovel(imovelOrigem);
					contaGeralOrigem.setConta(contaOrigem);

					conta.setOrigem(contaGeralOrigem);

				}

				// Referencia Contabil
				if(arrayConta[45] != null){
					conta.setReferenciaContabil((Integer) arrayConta[45]);
				}

				// Referencia Baixa Contabil
				if(arrayConta[46] != null){
					conta.setReferenciaBaixaContabil((Integer) arrayConta[46]);
				}

				// Crédito de Consumo
				if(arrayConta[47] != null){
					conta.setCreditoConsumo((Integer) arrayConta[47]);
				}

				// consumoTarifa - item [48]
				if(arrayConta[48] != null){

					ConsumoTarifa consumoTarifa = new ConsumoTarifa();

					consumoTarifa.setId((Integer) arrayConta[48]);
					consumoTarifa.setDescricao((String) arrayConta[49]);

					conta.setConsumoTarifa(consumoTarifa);
				}

				// valorImposto - item [51]
				if(arrayConta[51] != null){
					conta.setValorImposto((BigDecimal) arrayConta[51]);
				}

				// indicadorCobrancaAdministrativa - item [52]
				if(arrayConta[52] != null){
					conta.setIndicadorCobrancaAdministrativa((Short) arrayConta[52]);
				}

				// indicadorRemuneraCobrancaAdministrativa - item [53]
				if(arrayConta[53] != null){
					conta.setIndicadorRemuneraCobrancaAdministrativa((Short) arrayConta[53]);
				}

				// indicadorExecucaoFiscal
				if(arrayConta[54] != null){
					conta.setIndicadorExecucaoFiscal((Short) arrayConta[54]);
				}
			}
		}

		return conta;
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Pedro Alexandre
	 * @date 19/09/2006
	 * @param idConta
	 * @return
	 * @throws ControladorException
	 */
	public BigDecimal pesquisarValorMultasCobradas(int idConta) throws ControladorException{

		BigDecimal valorMultasCobradas = null;

		try{
			valorMultasCobradas = repositorioFaturamento.pesquisarValorMultasCobradas(idConta);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return valorMultasCobradas;
	}

	/**
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 15/09/2006
	 * @author Eduardo Henrique
	 * @date 24/12/2008 Alteração no método para tratamento de atributos do imóvel não-obrigatórios.
	 * @author Virgínia Melo
	 * @date 06/01/2009 Adicionados campos de qualidade água
	 * @author Virgínia Melo
	 * @date 27/02/2009 Alteração no método para recuperar o nº do hidrômetro que será exibido no
	 *       relatório.
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Collection<EmitirContaHelper> emitir2ViaContas(Collection idsContaEP, boolean cobrarTaxaEmissaoConta, Short contaSemCodigoBarras)
					throws ControladorException{

		Collection<EmitirContaHelper> colecaoEmitirContaHelper = new ArrayList();

		Iterator iter = idsContaEP.iterator();

		while(iter.hasNext()){
			Integer idContaEP = (Integer) iter.next();

			Collection colectionConta = null;
			try{
				colectionConta = this.repositorioFaturamento.pesquisarConta(idContaEP);
			}catch(ErroRepositorioException e2){
				// TODO Auto-generated catch block
				e2.printStackTrace();
			}
			
			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) colectionConta.iterator().next();

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			String tipoDocCliente = "";
			String cpfCnpj = "";

			if(emitirContaHelper.getTipoDocCliente() != null && emitirContaHelper.getTipoDocCliente().equals("CPF")){
				tipoDocCliente = emitirContaHelper.getTipoDocCliente();
				cpfCnpj = Util.formatarCpf(emitirContaHelper.getCpfCnpjCliente());

			}else if(emitirContaHelper.getTipoDocCliente() != null && emitirContaHelper.getTipoDocCliente().equals("CNPJ")){

				tipoDocCliente = emitirContaHelper.getTipoDocCliente();
				cpfCnpj = Util.formatarCnpj(emitirContaHelper.getCpfCnpjCliente());
			}

			emitirContaHelper.setTipoDocCliente(tipoDocCliente);
			emitirContaHelper.setCpfCnpjCliente(cpfCnpj);

			// Linha 5
			// --------------------------------------------------------------
			// recupera endereco do imóvel
			String enderecoImovel = "";
			try{
				enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(emitirContaHelper.getIdImovel());
			}catch(ControladorException e1){
				e1.printStackTrace();
			}
			emitirContaHelper.setEnderecoImovel(enderecoImovel);

			// Linha 6
			// --------------------------------------------------------------
			// instância um imovel com os dados da conta para recuperar a
			// inscrição que está no objeto imovel
			Imovel imovel = new Imovel();
			Localidade localidade = new Localidade();
			localidade.setId(emitirContaHelper.getIdLocalidade());
			imovel.setLocalidade(localidade);
			SetorComercial setorComercial = new SetorComercial();
			setorComercial.setCodigo(emitirContaHelper.getCodigoSetorComercialConta());
			imovel.setSetorComercial(setorComercial);
			Quadra quadra = new Quadra();
			quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
			imovel.setQuadra(quadra);
			if(emitirContaHelper.getLoteConta() != null){
				imovel.setLote(emitirContaHelper.getLoteConta());
			}
			if(emitirContaHelper.getSubLoteConta() != null){
				imovel.setSubLote(emitirContaHelper.getSubLoteConta());
			}
			if(emitirContaHelper.getIdConsumoTarifa() != null){
				ConsumoTarifa consumoTarifa = new ConsumoTarifa();
				consumoTarifa.setId(emitirContaHelper.getIdConsumoTarifa());
				imovel.setConsumoTarifa(consumoTarifa);
			}

			// Inscrição do imóvel
			emitirContaHelper.setInscricaoImovel(imovel.getInscricaoFormatada());

			imovel.setId(emitirContaHelper.getIdImovel());

			// Linha 7
			// --------------------------------------------------------------

			// Alterado por: Yara Souza
			// Data: 13/05/2010
			// ----------------------------------------------------------------
			String enderecoEntrega = "";
			// Endereço de entrega
			Integer idImovelContaEnvio = emitirContaHelper.getIdImovelContaEnvio();
			if(idImovelContaEnvio != null){

				if(idImovelContaEnvio.intValue() != ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_PAGAVEL_PARA_RESPONSAVEL
								&& idImovelContaEnvio.intValue() != ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_NAO_PAGAVEL_PARA_RESPOSAVEL
								&& idImovelContaEnvio.intValue() != ImovelContaEnvio.ENVIAR_IMOVEL){

					// Obter Endereço
					imovel.setId(emitirContaHelper.getIdImovel());
					Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
					enderecoEntrega = (String) arrayDadosEndereco[0];
				}
			}
			emitirContaHelper.setEnderecoClienteEntrega(enderecoEntrega);

			// Linha 8
			// --------------------------------------------------------------

			// [SB0002] - Determinar tipo de ligação e tipo de Medição
			Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
			Integer tipoLigacao = parmSituacao[0];
			Integer tipoMedicao = parmSituacao[1];

			// Linha 9
			// --------------------------------------------------------------
			// cria uma stringBuilder para recuperar o resultado do [SB0003]
			// o tamanho da string que vem como resultado é de 20 posições
			StringBuilder obterDadosConsumoMedicaoAnterior = null;

			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 1
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 1, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes1(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 4
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 4, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes4(obterDadosConsumoMedicaoAnterior.toString());

			// Linha 10
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 2
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 2, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes2(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 5
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 5, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes5(obterDadosConsumoMedicaoAnterior.toString());
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros da medição historico do
			// [SB0004] - Obter Dados da Medição da Conta
			Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(emitirContaHelper, tipoMedicao);
			// Leitura Anterior
			String leituraAnterior = "";
			// Leitura Atual
			String leituraAtual = "";
			// Data Leitura Anterior
			String dataLeituraAnterior = "";
			// Leitura Anterior
			String dataLeituraAtual = "";
			// Leitura Situação Atual
			// String leituraSituacaoAtual = "";
			// Leitura Anormalidade Faturamento
			String leituraAnormalidadeFaturamento = "";
				
			String consumoMedido = "";
			if(parmsMedicaoHistorico != null){

				if(parmsMedicaoHistorico[0] != null){
					leituraAnterior = "" + (Integer) parmsMedicaoHistorico[0];
				}

				if(parmsMedicaoHistorico[1] != null){
					leituraAtual = "" + (Integer) parmsMedicaoHistorico[1];
				}

				if(parmsMedicaoHistorico[3] != null){
					dataLeituraAnterior = Util.formatarData((Date) parmsMedicaoHistorico[3]);
				}

				if(parmsMedicaoHistorico[2] != null){
					dataLeituraAtual = Util.formatarData((Date) parmsMedicaoHistorico[2]);
				}

				if(parmsMedicaoHistorico[4] != null){
					// leituraSituacaoAtual = ""
					// + (Integer) parmsMedicaoHistorico[4];
				}

				if(parmsMedicaoHistorico[5] != null){
					leituraAnormalidadeFaturamento = "" + (Integer) parmsMedicaoHistorico[5];
				}
				
				if(parmsMedicaoHistorico[6] != null){
					consumoMedido = "" + (Integer) parmsMedicaoHistorico[6];
				}
			}
			
			
			
			emitirContaHelper.setDataLeituraAnterior(dataLeituraAnterior);
			emitirContaHelper.setDataLeituraAtual(dataLeituraAtual);
			emitirContaHelper.setConsumoMedido(consumoMedido);
			
			
			String diasConsumo = "";
			if(!dataLeituraAnterior.equals("") && !dataLeituraAtual.equals("")){
				// calcula a quantidade de dias de consumo que é a
				// quantidade de dias
				// entre a data de leitura
				// anterior(parmsMedicaoHistorico[2]) e a data de leitura
				// atual(parmsMedicaoHistorico[3])
				diasConsumo = "" + Util.obterQuantidadeDiasEntreDuasDatas((Date) parmsMedicaoHistorico[3], (Date) parmsMedicaoHistorico[2]);
			}
			// recupera os parametros de consumo faturamento e consumo médio
			// diário
			// [SB0005] - Obter Consumo Faturado e Consumo Médio Diário
			String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(emitirContaHelper, tipoMedicao, diasConsumo);
			String consumoFaturamento = parmsConsumo[0];
			emitirContaHelper.setConsumoFaturamento(consumoFaturamento);

			String consumoMedioDiario = parmsConsumo[1];
			emitirContaHelper.setConsumoMedioDiario(consumoMedioDiario);
			// Fim Chamar Sub-Fluxo
			// Leitura Anterior
			leituraAnterior = Util.completaString(leituraAnterior, 7);
			emitirContaHelper.setLeituraAnterior(leituraAnterior);
			// Leitura Atual
			leituraAtual = Util.completaString(leituraAtual, 7);
			emitirContaHelper.setLeituraAtual(leituraAtual);
			// Dias de consumo
			diasConsumo = Util.completaString(diasConsumo, 2);
			emitirContaHelper.setDiasConsumo(diasConsumo);

			// Linha 11
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 3
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 3, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes3(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 6
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 6, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes6(obterDadosConsumoMedicaoAnterior.toString());

			// Linha 12
			// --------------------------------------------------------------
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros do consumo historico da conta
			// [SB0006] - Obter Dados de Consumo da Conta
			Object[] parmsConsumoHistorico = null;
			String descricaoAbreviadaTipoConsumo = "";
			String descricaoTipoConsumo = "";
			String consumoMedio = "";
			String descricaoAbreviadaAnormalidadeConsumo = "";
			String descricaoAnormalidadeConsumo = "";
			String consumoRateio = "";
			// caso o tipo de ligacao for diferente de nulo
			if(tipoLigacao != null){
				try{
					parmsConsumoHistorico = getControladorMicromedicao().obterDadosConsumoConta(emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia(), tipoLigacao);
				}catch(ControladorException e){
					e.printStackTrace();
				}

				if(parmsConsumoHistorico != null){
					// descrição abreviada tipo de consumo
					if(parmsConsumoHistorico[0] != null){
						descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
					}
					// descrição tipo de consumo
					if(parmsConsumoHistorico[1] != null){
						descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
					}
					// Consumo médio
					if(parmsConsumoHistorico[2] != null){
						consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
					}
					// descrição abreviada anormalidade de consumo
					if(parmsConsumoHistorico[3] != null){
						descricaoAbreviadaAnormalidadeConsumo = (String) parmsConsumoHistorico[3];
					}
					// descrição anormalidade de consumo
					if(parmsConsumoHistorico[4] != null){
						descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
					}
					// Consumo médio
					if(parmsConsumoHistorico[5] != null){
						consumoRateio = "" + (Integer) parmsConsumoHistorico[5];
					}
				}
			}

			emitirContaHelper.setDescricaoTipoConsumo(descricaoTipoConsumo);
			emitirContaHelper.setDescricaoAnormalidadeConsumo(descricaoAnormalidadeConsumo);

			// Fim Chamar Sub-Fluxo

			// Linha 13
			// --------------------------------------------------------------

			// Inicio Chamar Sub-Fluxo
			// soma a quantidades de economias da tabela contaCategoria
			// [SB0007] - Obter Dados da Medição da Conta
			Short quantidadeEconomiaConta = 0;
			quantidadeEconomiaConta = obterQuantidadeEconomiasConta(emitirContaHelper.getIdConta(), false);
			emitirContaHelper.setQuantidadeEconomiaConta("" + quantidadeEconomiaConta);
			// Fim Chamar Sub-Fluxo

			// Consumo por Economia
			// transforma o consumoFaturamento para um bigDecimal
			BigDecimal consumoFaturadoBigDecimal = null;
			if(consumoFaturamento != null && !consumoFaturamento.equals("")){
				consumoFaturadoBigDecimal = Util.formatarMoedaRealparaBigDecimal(consumoFaturamento);

			}
			// transforma a quantidade de economias da conta para um
			// bigDecimal
			BigDecimal qtdEconomiasBigDecimal = null;
			if(quantidadeEconomiaConta != null && !quantidadeEconomiaConta.equals("")){
				qtdEconomiasBigDecimal = Util.formatarMoedaRealparaBigDecimal("" + quantidadeEconomiaConta);
			}
			String consumoEconomia = "";
			if(consumoFaturadoBigDecimal != null && qtdEconomiasBigDecimal != null){
				BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal.divide(qtdEconomiasBigDecimal, 2, RoundingMode.UP);
				consumoEconomia = Util.formatarMoedaReal(consumoEconomiaBigDecimal);
				emitirContaHelper.setConsumoEconomia(consumoEconomia.substring(0, (consumoEconomia.length() - 3)));
			}

			// Inicio Chamar Sub-Fluxo
			// concatena os campos dos sub-fluxos anteriores
			// [SB0008] - Obter Dados da Medição da Conta
			StringBuilder codigoAuxiliar = new StringBuilder();
			// leitura situação atual
			// tipo de consumo
			codigoAuxiliar.append(Util.completaString(descricaoAbreviadaTipoConsumo, 1));
			// tipo de contrato
			codigoAuxiliar.append(Util.completaString("", 1));
			// anormalidade de leitura
			codigoAuxiliar.append(Util.completaString(leituraAnormalidadeFaturamento, 2));
			// anormalidade de consumo
			codigoAuxiliar.append(Util.completaString(descricaoAbreviadaAnormalidadeConsumo, 2));

			// perfil do imóvel
			if(emitirContaHelper.getIdImovelPerfil() != null){
				codigoAuxiliar.append(Util.completaString("" + emitirContaHelper.getIdImovelPerfil(), 1));
			}else{
				codigoAuxiliar.append(Util.completaString("", 1));
			}
			// dias do consumo
			codigoAuxiliar.append(Util.completaString(diasConsumo, 2));
			// Consumo medio do imóvel
			codigoAuxiliar.append(Util.completaString(consumoMedio, 6));
			// Fim Chamar Sub-Fluxo
			emitirContaHelper.setCodigoAuxiliarString(codigoAuxiliar.toString());

			// chama o [SB0009] - Obter Mensagem de Rateio de Consumo Fixo
			// de Esgoto
			StringBuilder mesagemConsumo = obterMensagemRateioConsumo(emitirContaHelper, consumoRateio, parmsMedicaoHistorico, tipoMedicao);
			// mensagem de rateio de consumo ou consumo fixo de esgoto
			emitirContaHelper.setMensagemConsumoString(mesagemConsumo.toString());

			// Linha 16
			// --------------------------------------------------------------
			// chama o [SB0010] - Gerar Linhas da Descrição dos Serviços e
			// Tarifas

			Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = gerarLinhasDescricaoServicoTarifasRelatorio(
							emitirContaHelper, consumoRateio, parmsMedicaoHistorico, tipoMedicao, false, null, null, false);

			// // --------------------------------------------------------------
			// // CORREÇÃO DIFERENÇA CÁLCULO 2ª VIA CONTA
			// // --------------------------------------------------------------
			// ContaLinhasDescricaoServicosTarifasTotalHelper
			// contaLinhasDescricaoServicosTarifasTotalHelperDiferenca = this
			// .obterDiferencaCalculoValorSegundaViaConta(emitirContaHelper, imovel,
			// colecaoContaLinhasDescricaoServicosTarifasTotalHelper, dataLeituraAnterior,
			// dataLeituraAtual);
			//
			// if(contaLinhasDescricaoServicosTarifasTotalHelperDiferenca != null){
			// colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelperDiferenca);
			// }
			//
			// // --------------------------------------------------------------

			emitirContaHelper
							.setColecaoContaLinhasDescricaoServicosTarifasTotalHelper(colecaoContaLinhasDescricaoServicosTarifasTotalHelper);

			// StringBuilder linhasDescricaoServicosTarifasTotal =
			// gerarLinhasDescricaoServicoTarifas(emitirContaHelper,
			// consumoRateio, parmsMedicaoHistorico, tipoMedicao);
			// emitirContaHelper.setLinhasDescricaoServicosTarifasTotal(linhasDescricaoServicosTarifasTotal);
			// Linha 17
			// --------------------------------------------------------------
			// cria um objeto conta para calcular o valor da conta
			Conta conta = new Conta();
			conta.setValorAgua(emitirContaHelper.getValorAgua());
			conta.setValorEsgoto(emitirContaHelper.getValorEsgoto());
			conta.setValorCreditos(emitirContaHelper.getValorCreditos());
			conta.setDebitos(emitirContaHelper.getDebitos());
			conta.setValorImposto(emitirContaHelper.getValorImpostos());

			// Parâmetro que identifica se a empresa emite o documento com acrescimos
			String parametroTratarAcrescimosEmissaoDocumento = ParametroArrecadacao.P_TRATAR_ACRESCIMOS_EMISSAO_DOCUMENTO.executar()
							.toString();

			if(parametroTratarAcrescimosEmissaoDocumento.equals(Short.toString(ConstantesSistema.SIM))){
				Date menorDataPagamento = null;

				Collection dadosPagamento = null;

				if(emitirContaHelper.getIndicadorPagamento() != null && emitirContaHelper.getIndicadorPagamento() == (short) 1){
					dadosPagamento = this.getControladorCobranca().pesquisarValorTotalPagamentoMenorDataPagamento(
									emitirContaHelper.getIdConta());
				}

				if(dadosPagamento != null && !dadosPagamento.isEmpty()){
					Object[] dadosPagamentoArray = (Object[]) dadosPagamento.iterator().next();

					if(dadosPagamentoArray[1] != null){
						menorDataPagamento = (Date) dadosPagamentoArray[1];
					}
				}

				BigDecimal valorMultasCobradas = this.pesquisarValorMultasCobradas(emitirContaHelper.getIdConta());

				String anoMesArrecadacao = sistemaParametro.getAnoMesArrecadacao().toString();

				CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidade = this.getControladorCobranca()
								.calcularAcrescimoPorImpontualidadeBancoDeDados(emitirContaHelper.getAmReferencia(),
												emitirContaHelper.getDataVencimentoConta(), menorDataPagamento,
												conta.getValorTotalContaBigDecimal(), valorMultasCobradas,
												emitirContaHelper.getIndicadorCobrancaMulta(), anoMesArrecadacao,
												emitirContaHelper.getIdConta(), new Date(), ConstantesSistema.SIM, ConstantesSistema.SIM,
												ConstantesSistema.SIM, ConstantesSistema.SIM);

				if(calcularAcrescimoPorImpontualidade != null){
					ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;
					FiltroDebitoTipo filtroDebitoTipo = null;
					Collection<DebitoTipo> colecaoDebitoTipo = null;
					DebitoTipo debitoTipo = null;
					String descricaoDebitoTipo = "";

					BigDecimal valorDebitoAtualizado = emitirContaHelper.getDebitos();

					if(valorDebitoAtualizado == null){
						valorDebitoAtualizado = BigDecimal.ZERO;
					}

					BigDecimal valorMulta = calcularAcrescimoPorImpontualidade.getValorMulta();

					if(valorMulta != null && valorMulta.compareTo(BigDecimal.ZERO) > 0){
						valorDebitoAtualizado = valorDebitoAtualizado.add(valorMulta);

						filtroDebitoTipo = new FiltroDebitoTipo();
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, DebitoTipo.MULTA_IMPONTUALIDADE));
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
										ConstantesSistema.INDICADOR_USO_ATIVO));

						colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

						descricaoDebitoTipo = "";

						if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
							debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
							descricaoDebitoTipo = debitoTipo.getDescricao();
						}

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoDebitoTipo);
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(Util.formatarMoedaReal(valorMulta));
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");

						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}

					BigDecimal valorJurosMora = calcularAcrescimoPorImpontualidade.getValorJurosMora();

					if(valorJurosMora != null && valorJurosMora.compareTo(BigDecimal.ZERO) > 0){
						valorDebitoAtualizado = valorDebitoAtualizado.add(valorJurosMora);

						filtroDebitoTipo = new FiltroDebitoTipo();
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, DebitoTipo.JUROS_MORA));
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
										ConstantesSistema.INDICADOR_USO_ATIVO));

						colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

						descricaoDebitoTipo = "";

						if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
							debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
							descricaoDebitoTipo = debitoTipo.getDescricao();
						}

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoDebitoTipo);
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(Util.formatarMoedaReal(valorJurosMora));
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");

						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}

					BigDecimal valorAtualizacaoMonetaria = calcularAcrescimoPorImpontualidade.getValorAtualizacaoMonetaria();

					if(valorAtualizacaoMonetaria != null && valorAtualizacaoMonetaria.compareTo(BigDecimal.ZERO) > 0){
						valorDebitoAtualizado = valorDebitoAtualizado.add(valorAtualizacaoMonetaria);

						filtroDebitoTipo = new FiltroDebitoTipo();
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, DebitoTipo.ATUALIZACAO_MONETARIA));
						filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
										ConstantesSistema.INDICADOR_USO_ATIVO));

						colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

						descricaoDebitoTipo = "";

						if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
							debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
							descricaoDebitoTipo = debitoTipo.getDescricao();
						}

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoDebitoTipo);
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(Util.formatarMoedaReal(valorAtualizacaoMonetaria));
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");

						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}

					conta.setDebitos(valorDebitoAtualizado);

					emitirContaHelper.setIndicadorExibirAcrescimos(ConstantesSistema.SIM.toString());
				}
			}

			BigDecimal valorConta = conta.getValorTotalContaBigDecimal();

			emitirContaHelper.setValorContaString(Util.formatarMoedaReal(valorConta));

			if(contaSemCodigoBarras.equals(ConstantesSistema.SIM) || valorConta.compareTo(new BigDecimal("0.00")) == 0){
				emitirContaHelper.setContaSemCodigoBarras("1");
			}else{
				emitirContaHelper.setContaSemCodigoBarras("2");
			}

			// chama o [SB0016] - Obter Mensagem da Conta em 3 Partes
			String[] parmsPartesConta = obterMensagemConta3Partes(emitirContaHelper, sistemaParametro);

			// Linha 18
			// --------------------------------------------------------------
			emitirContaHelper.setPrimeiraParte(parmsPartesConta[0]);

			// Linha 19
			// --------------------------------------------------------------
			emitirContaHelper.setSegundaParte(parmsPartesConta[1]);

			// Linha 20
			// --------------------------------------------------------------
			emitirContaHelper.setTerceiraParte(parmsPartesConta[2]);

			// Linha 21
			// --------------------------------------------------------------
			// Alterado no dia 05/01/2009 vsm - não pegar mais o mês anterior (solicitado por
			// Luciene)
			// int anoMesReferenciaSubtraido =
			// Util.subtrairMesDoAnoMes(emitirContaHelper.getAmReferencia(), 1);
			// emitirContaHelper.setMesAnoFormatado(Util.formatarAnoMesParaMesAno(anoMesReferenciaSubtraido));
			emitirContaHelper.setMesAnoFormatado(Util.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia()));

			// Linha 22
			// --------------------------------------------------------------
			/*
			 * Object[] parmsQualidadeAgua = null; parmsQualidadeAgua =
			 * pesquisarParmsQualidadeAgua(emitirContaHelper);
			 * // numero indice turbidez da qualidade agua String numeroIndiceTurbidez = "";
			 * // numero cloro residual da qualidade agua String numeroCloroResidual = "";
			 * if (parmsQualidadeAgua != null) { if (parmsQualidadeAgua[0] != null) {
			 * numeroIndiceTurbidez = Util.formatarMoedaReal((BigDecimal)
			 * parmsQualidadeAgua[0]); }
			 * if (parmsQualidadeAgua[1] != null) { numeroCloroResidual =
			 * Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]); } }
			 * emitirContaHelper.setNumeroIndiceTurbidez(numeroIndiceTurbidez);
			 * emitirContaHelper.setNumeroCloroResidual(numeroCloroResidual);
			 */

			// Linha 22
			Object[] parmsQualidadeAgua = null;
			parmsQualidadeAgua = pesquisarParmsQualidadeAgua(emitirContaHelper);

			String numeroAmostrasMediaTurbidez = "";
			String numeroAmostrasMediaCloro = "";
			String numeroAmostrasMediaCor = "";
			String numeroAmostrasMediaPH = "";
			String numeroAmostrasMediaBacteriasHeterotroficas = "";
			String numeroAmostrasMediaColiformesTermotolerantes = "";
			String numeroAmostrasMediaColiformesTotais = "";

			if(parmsQualidadeAgua != null){

				if(parmsQualidadeAgua[0] != null){
					numeroAmostrasMediaTurbidez = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]);
				}

				if(parmsQualidadeAgua[1] != null){
					numeroAmostrasMediaCloro = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]);
				}

				if(parmsQualidadeAgua[2] != null){
					numeroAmostrasMediaCor = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[2]);
				}

				if(parmsQualidadeAgua[3] != null){
					numeroAmostrasMediaPH = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[3]);
				}

				if(parmsQualidadeAgua[4] != null){
					numeroAmostrasMediaBacteriasHeterotroficas = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[4]);
				}

				if(parmsQualidadeAgua[5] != null){
					numeroAmostrasMediaColiformesTermotolerantes = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[5]);
				}

				if(parmsQualidadeAgua[6] != null){
					numeroAmostrasMediaColiformesTotais = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[6]);
				}
			}

			emitirContaHelper.setNumeroAmostrasMediaTurbidez(numeroAmostrasMediaTurbidez);
			emitirContaHelper.setNumeroAmostrasMediaCloro(numeroAmostrasMediaCloro);
			emitirContaHelper.setNumeroAmostrasMediaCor(numeroAmostrasMediaCor);
			emitirContaHelper.setNumeroAmostrasMediaPH(numeroAmostrasMediaPH);
			emitirContaHelper.setNumeroAmostrasMediaBacteriasHeterotroficas(numeroAmostrasMediaBacteriasHeterotroficas);
			emitirContaHelper.setNumeroAmostrasMediaColiformesTermotolerantes(numeroAmostrasMediaColiformesTermotolerantes);
			emitirContaHelper.setNumeroAmostrasMediaColiformesTotais(numeroAmostrasMediaColiformesTotais);

			// Linha 23
			// --------------------------------------------------------------
			// Considerar as contas do tipo débito automático como tipo de conta
			// normal
			// [SB0018 - Gerar Linhas das DemaisContas]
			Integer digitoVerificadorConta = Integer.valueOf("" + emitirContaHelper.getDigitoVerificadorConta());
			// formata ano mes para mes ano
			String anoMes = "" + emitirContaHelper.getAmReferencia();
			String mesAno = anoMes.substring(4, 6) + anoMes.substring(0, 4);

			String representacaoNumericaCodBarra = "";

			if(contaSemCodigoBarras.equals(ConstantesSistema.NAO) || valorConta.compareTo(new BigDecimal("0.00")) != 0){

				representacaoNumericaCodBarra = this.getControladorArrecadacao().obterRepresentacaoNumericaCodigoBarra(3, valorConta,
								emitirContaHelper.getIdLocalidade(), emitirContaHelper.getIdImovel(), mesAno, digitoVerificadorConta, null,
								null, null, DocumentoTipo.CONTA, null, null, null, null, null, null);

				// É necessário realizar essa verificação, pois o GSAN passou a utilizar a tabela
				// CODIGO_BARRAS_LAYOUT na hora de definir o código de barras
				String paramIndicadorTrataLegado = ParametroArrecadacao.P_INDICADOR_TRATA_LEGADO.executar();

				if(ConstantesSistema.SIM.toString().equals(paramIndicadorTrataLegado)){
					// Para atender à solicitação do cliente é ncessário incluir nas posições 34-41
					// (fica 36-43 contando com os digitos verificadores) do código de barras do
					// documento CONTA a matrícula do imóvel. Observação: As posições foram
					// referenciadas considerando os 44 caracteres do código de barras, sem os
					// dígitos verificadores. A matrícula ficaria nas posições destacadas no
					// exemplo:
					// 11111111111 D 22222222222 D 33333333333 D 44444444444 D
					// representacaoNumericaCodBarra =
					// Util.inserirMatriculaImovelCodigoBarra(emitirContaHelper.getIdImovel(),
					// representacaoNumericaCodBarra);
				}

				// Linha 24
				// Formata a representação númerica do código de barras
				String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11) + "-"
								+ representacaoNumericaCodBarra.substring(11, 12) + " " + representacaoNumericaCodBarra.substring(12, 23)
								+ "-" + representacaoNumericaCodBarra.substring(23, 24) + " "
								+ representacaoNumericaCodBarra.substring(24, 35) + "-" + representacaoNumericaCodBarra.substring(35, 36)
								+ " " + representacaoNumericaCodBarra.substring(36, 47) + "-"
								+ representacaoNumericaCodBarra.substring(47, 48);
				emitirContaHelper.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

				// Linha 25
				String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra.substring(0, 11)
								+ representacaoNumericaCodBarra.substring(12, 23) + representacaoNumericaCodBarra.substring(24, 35)
								+ representacaoNumericaCodBarra.substring(36, 47);
				emitirContaHelper.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);

			}

			// Linha28
			if(emitirContaHelper.getDataValidadeConta() != null && emitirContaHelper.getDataValidadeConta().compareTo(new Date()) == 1){
				emitirContaHelper.setDataValidade(Util.formatarData(emitirContaHelper.getDataValidadeConta()));

			}else{
				// soma 60 dias a data atual
				Date dataValidadeConta = Util.adicionarNumeroDiasDeUmaData(new Date(), 60);

				int ano = Util.getAno(dataValidadeConta);
				int mes = Util.getMes(dataValidadeConta);
				Calendar calendar = new GregorianCalendar();
				calendar.set(Calendar.MONTH, mes - 1);
				calendar.set(Calendar.YEAR, ano);

				Collection colecaoNacionalFeriado = getControladorUtil().pesquisarFeriadosNacionais();

				Collection colecaoDatasFeriados = new ArrayList();
				Iterator iterNacionalFeriado = colecaoNacionalFeriado.iterator();
				while(iterNacionalFeriado.hasNext()){
					NacionalFeriado nacionalFeriado = (NacionalFeriado) iterNacionalFeriado.next();
					colecaoDatasFeriados.add(nacionalFeriado.getData());
				}

				calendar.set(Calendar.DAY_OF_MONTH, Util.obterUltimoDiaUtilMes(mes, ano, colecaoDatasFeriados));

				dataValidadeConta = calendar.getTime();

				emitirContaHelper.setDataValidade(Util.formatarData(dataValidadeConta));

			}

			try{

				// Recuperando número do hidrômetro
				Integer idHistoricoInstalacaoHidr = null;
				String numeroHidrometro = null;
				BigDecimal valorAgua = emitirContaHelper.getValorAgua();
				BigDecimal valorEsgoto = emitirContaHelper.getValorEsgoto();

				// Se valor agua da conta for maior que zero
				if(valorAgua != null && valorAgua.compareTo(new BigDecimal(0.0)) > 0){
					idHistoricoInstalacaoHidr = this.repositorioFaturamento.pesquisarMedicaoAgua(emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia());
				}

				// Se valor esgoto da conta for maior que zero
				if(idHistoricoInstalacaoHidr == null && valorEsgoto != null && valorEsgoto.compareTo(new BigDecimal(0.0)) > 0){
					idHistoricoInstalacaoHidr = this.repositorioFaturamento.pesquisarMedicaoPoco(emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia());
				}

				if(idHistoricoInstalacaoHidr != null){
					numeroHidrometro = this.repositorioFaturamento.pesquisarNumeroHidrometro(idHistoricoInstalacaoHidr);
					emitirContaHelper.setNumeroHidrometro(numeroHidrometro);
				}

				// Calcular valor imposto PIS / COFINS para CASAL
				BigDecimal valorImpostoPisCofins = this.calcularImposto2ViaConta(emitirContaHelper.getValorAgua(),
								emitirContaHelper.getValorEsgoto());

				if(!Util.isVazioOuBranco(valorImpostoPisCofins)){
					emitirContaHelper.setValorImpostoPisCofins(valorImpostoPisCofins);
				}else{
					emitirContaHelper.setValorImpostoPisCofins(BigDecimal.ZERO);
				}

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			/**
			 * [UC0482] Na emissão de 2ª via de conta, emitir a mensagem de quitação de débito anual
			 * 
			 * @author Gicevalter Couto
			 * @created 12/08/2014
			 */
			String mesBaseEmissaoQuitacaoDebitoAnual = (String) ParametroFaturamento.P_MES_BASE_EMISSAO_QUITACAO_DEBITO_ANUAL.executar();
			if(mesBaseEmissaoQuitacaoDebitoAnual != null
							&& Short.valueOf(String.valueOf(emitirContaHelper.getAmReferencia()).substring(4, 6)).equals(
											Short.valueOf(mesBaseEmissaoQuitacaoDebitoAnual))){
				Integer anoAnteriorConta = Integer.valueOf(String.valueOf(emitirContaHelper.getAmReferencia()).substring(0, 4)) - 1;
				
				FiltroQuitacaoDebitoAnual filtroQuitacaoDebitoAnual = new FiltroQuitacaoDebitoAnual();
				filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.IMOVEL_ID, emitirContaHelper
								.getIdImovel()));
				filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.ANO_REFERENCIA,
								anoAnteriorConta));
				Collection<QuitacaoDebitoAnual> colecaoQuitacaoDebitoAnual = this.getControladorUtil().pesquisar(filtroQuitacaoDebitoAnual,
								QuitacaoDebitoAnual.class.getName());
				if(colecaoQuitacaoDebitoAnual.size() > 0){
					emitirContaHelper.setAnoQuitacaoDebitoAnual(anoAnteriorConta);
				}
			}

			colecaoEmitirContaHelper.add(emitirContaHelper);

			if(cobrarTaxaEmissaoConta){
				this.gerarDebitoACobrar(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(), DebitoTipo.TAXA_2_VIA_CONTA,
								null);
			}

		}

		return colecaoEmitirContaHelper;
	}

	/**
	 * @param imovel
	 * @return String com o endereço
	 * @throws ControladorException
	 */
	public Object[] obterEnderecoEntregaCliente(Imovel imovel) throws ControladorException{

		// caso a coleção de contas seja de entrega para o cliente pesquisando os dados pelo id do
		// imovel, carregando até o cliente
		String enderecoClienteResponsavel = "";
		Integer idLogradouro = null;
		String numeroImovel = null;
		Object[] retorno = new Object[3];

		FiltroImovel filtroImovel = new FiltroImovel();
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("imovelContaEnvio");
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("clienteImoveis");
		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
		Collection<Imovel> imoveis = getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
		Integer imovelContaEnvioId = imoveis.iterator().next().getImovelContaEnvio().getId();
		Imovel imovelPesquisado = imoveis.iterator().next();

		Integer tipoRelacao = 0;
		if(imovelContaEnvioId.intValue() == ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL
						|| imovelContaEnvioId.intValue() == ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL
						|| imovelContaEnvioId.intValue() == ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_PAGAVEL_PARA_RESPONSAVEL
						|| imovelContaEnvioId.intValue() == ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_NAO_PAGAVEL_PARA_RESPOSAVEL){
			tipoRelacao = ClienteRelacaoTipo.RESPONSAVEL;
		}else if(imovelContaEnvioId.intValue() == ImovelContaEnvio.ENVIAR_PARA_CLIENTE_PROPRIETARIO){
			tipoRelacao = ClienteRelacaoTipo.PROPRIETARIO;
		}else{
			tipoRelacao = ClienteRelacaoTipo.USUARIO;
		}
		for(ClienteImovel clienteImovel : imovelPesquisado.getClienteImoveis()){
			Cliente cliente = clienteImovel.getCliente();
			FiltroCliente filtroCliente = new FiltroCliente();
			filtroCliente.adicionarCaminhoParaCarregamentoEntidade(FiltroCliente.CLIENTE_ENDERECOS);
			filtroCliente.adicionarParametro(new ParametroSimples(FiltroCliente.ID, cliente.getId()));
			Collection<Cliente> clientes = getControladorUtil().pesquisar(filtroCliente, Cliente.class.getName());
			cliente = clientes.iterator().next();
			clienteImovel.setCliente(cliente);
		}
		Integer idCliente = null;
		Collection<ClienteImovel> clientesImoveis = imovelPesquisado.getClienteImoveis();
		Date dataAtual = new Date();
		for(ClienteImovel clienteImovel : clientesImoveis){
			if((clienteImovel.getDataFimRelacao() == null || Util.compararData(clienteImovel.getDataFimRelacao(), dataAtual) == -1)
							&& clienteImovel.getClienteRelacaoTipo().getId().intValue() == tipoRelacao.intValue()){

				Collection<ClienteEndereco> clienteEnderecos = clienteImovel.getCliente().getClienteEnderecos();
				for(ClienteEndereco clienteEndereco : clienteEnderecos){
					if(clienteEndereco.getIndicadorEnderecoCorrespondencia().intValue() == ClienteEndereco.INDICADOR_ENDERECO_CORRESPONDENCIA){

						idCliente = clienteEndereco.getCliente().getId();
						// [UC0085]Obter Endereco
						Object[] arrayDadosEndereco = this.getControladorEndereco()
										.pesquisarEnderecoClienteAbreviadoLista(idCliente, false);
						enderecoClienteResponsavel = (String) arrayDadosEndereco[0];
						idLogradouro = (Integer) arrayDadosEndereco[1];
						numeroImovel = (String) arrayDadosEndereco[2];

						break;
					}
				}
			}
		}

		retorno[0] = enderecoClienteResponsavel;
		retorno[1] = idLogradouro;
		retorno[2] = numeroImovel;

		return retorno;
	}

	/**
	 * Recupera o id do cliente responsável pela conta
	 * [UC0348] - Emitir Contas [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 15/05/2006 , 22/05/2007
	 * @return
	 * @throws ControladorException
	 */
	public Integer pesquisarIdClienteResponsavelConta(Integer idConta, boolean contaHistorico) throws ControladorException{

		try{
			if(!contaHistorico){

				return repositorioFaturamento.pesquisarIdClienteResponsavelConta(idConta);
			}else{

				return repositorioFaturamento.pesquisarIdClienteResponsavelContaHistorico(idConta);
			}
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Método que retorna a soma de quantidade economia
	 * [UC0348] Emitir Contas [UC0482]Emitir 2ª Via de Conta
	 * [SB0007] Obter Quantidade de Economias da Conta
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 19/05/2006, 22/05/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Short obterQuantidadeEconomiasConta(Integer idConta, boolean contaHistorico) throws ControladorException{

		try{

			if(!contaHistorico){
				return repositorioFaturamento.obterQuantidadeEconomiasConta(idConta);
			}else{
				return repositorioFaturamento.obterQuantidadeEconomiasContaHistorico(idConta);
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Método que retorna uma array de object de qualidade de agua
	 * [UC0348] Emitir Contas
	 * 
	 * @author Sávio Luiz
	 * @date 25/05/2006
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsQualidadeAgua(EmitirContaHelper emitirContaHelper) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarParmsQualidadeAgua(emitirContaHelper);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00020] Gerar Arquivo TXT das Cartas
	 * 
	 * @author Sávio Luiz
	 * @date 05/12/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public StringBuilder gerarArquivoTxtCartas(EmitirContaHelper emitirContaHelper, Integer sequencial, int situacao)
					throws ControladorException{

		StringBuilder linhasArquivoTxtCartas = new StringBuilder();

		// cria uma stringBuilder para recuperar o resultado
		// do
		// [SB0004]
		// o tamanho da string que vem como resultado é de
		// 20
		// posições
		StringBuilder obterDadosConsumoMedicaoAnterior = null;
		// Caso a situação da conta esteja na primeira parte(=1) e seja
		// diferente de 1
		if(sequencial != 1 && (situacao == 1)){
			// gerar 2 linhas com canal 1
			// Canal
			linhasArquivoTxtCartas.append("1");
			linhasArquivoTxtCartas.append(Util.completaString("", 60));
			linhasArquivoTxtCartas.append(System.getProperty("line.separator"));
			// Canal
			linhasArquivoTxtCartas.append("1");
			linhasArquivoTxtCartas.append(Util.completaString("", 60));
			linhasArquivoTxtCartas.append(System.getProperty("line.separator"));
		}

		// --Linha 1-- //
		// Canal
		linhasArquivoTxtCartas.append("1");
		// mes/ano referencia e o digito verificador
		String formatarMesAnoComDigito = Util.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia()) + "-"
						+ emitirContaHelper.getDigitoVerificadorConta();
		linhasArquivoTxtCartas.append(Util.completaString(formatarMesAnoComDigito, 35));

		// matricula do imóvel
		// Recupera a matrícula do imóvel da coluna 1 e
		// formata
		// a
		// matrícula
		// (ex:500000001 em 5000000.1)
		String matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(9, "" + emitirContaHelper.getIdImovel());
		matriculaImovelFormatada = matriculaImovelFormatada.substring(0, 8) + "." + matriculaImovelFormatada.substring(8, 9);
		linhasArquivoTxtCartas.append(Util.completaString(matriculaImovelFormatada, 25));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));
		// --Linha 2-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// mes/ano referencia e o digito verificador
		// instância um imovel com os dados da conta para
		// recuperar
		// a
		// inscrição que está np objeto imovel
		Imovel imovel = new Imovel();
		Localidade localidade = new Localidade();
		localidade.setId(emitirContaHelper.getIdLocalidade());
		imovel.setLocalidade(localidade);
		SetorComercial setorComercial = new SetorComercial();
		setorComercial.setCodigo(emitirContaHelper.getCodigoSetorComercialConta());
		imovel.setSetorComercial(setorComercial);
		Quadra quadra = new Quadra();
		quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
		imovel.setQuadra(quadra);
		imovel.setLote(emitirContaHelper.getLoteConta());
		imovel.setSubLote(emitirContaHelper.getSubLoteConta());
		// Inscrição do imóvel
		String inscricao = imovel.getInscricaoFormatada();

		imovel = null;
		localidade = null;
		setorComercial = null;
		quadra = null;
		linhasArquivoTxtCartas.append(Util.completaString(inscricao, 60));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 3-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		linhasArquivoTxtCartas.append(Util.completaString(emitirContaHelper.getNomeCliente(), 60));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 4-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// [UC0085]Obter Endereco
		String enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(emitirContaHelper.getIdImovel());
		linhasArquivoTxtCartas.append(Util.completaString(enderecoImovel, 60));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 5-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 3));

		Object[] parmsClienteResponsavel = null;
		try{
			parmsClienteResponsavel = repositorioFaturamento.pesquisarParmsClienteResponsavelConta(emitirContaHelper.getIdConta());

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		Integer idClienteResponsavel = null;
		String nomeClienteResponsavel = "";
		String codigoCliente = "";
		if(parmsClienteResponsavel != null){

			if(parmsClienteResponsavel[0] != null){
				idClienteResponsavel = (Integer) parmsClienteResponsavel[0];
			}
			if(parmsClienteResponsavel[1] != null){
				nomeClienteResponsavel = (String) parmsClienteResponsavel[1];
			}

			if(idClienteResponsavel != null){
				codigoCliente = idClienteResponsavel.toString();
				// formata o valor de 12345 para 1234.5
				codigoCliente = codigoCliente.substring(0, codigoCliente.length() - 1).concat(".")
								.concat(codigoCliente.substring(codigoCliente.length() - 1, codigoCliente.length()));
			}
		}
		// seta o id do cliente responsável
		linhasArquivoTxtCartas.append(Util.completaString(codigoCliente, 12));

		linhasArquivoTxtCartas.append(Util.completaString(nomeClienteResponsavel, 45));
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 6-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 3));
		if(idClienteResponsavel != null){
			// [UC0085]Obter Endereco
			String enderecoClienteResponsavel = getControladorEndereco().pesquisarEnderecoClienteAbreviado(idClienteResponsavel);
			if(enderecoClienteResponsavel != null){
				// endereco cliente responsável
				linhasArquivoTxtCartas.append(Util.completaString(enderecoClienteResponsavel, 57));
			}else{
				// endereco cliente responsável
				linhasArquivoTxtCartas.append(Util.completaString("", 57));
			}

		}else{
			// completa com espaços em branco
			linhasArquivoTxtCartas.append(Util.completaString("", 57));
		}
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 7-- //
		// Canal
		linhasArquivoTxtCartas.append("1");

		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 5));
		// [SB0002] - Determinar tipo de ligação e tipo de
		// Medição
		Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
		Integer tipoLigacao = parmSituacao[1];
		Integer tipoMedicao = parmSituacao[1];

		// recupera os parametros da medição historico do
		// [SB0005] - Obter Dados da Medição da Conta
		Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(emitirContaHelper, tipoMedicao);
		// Leitura Atual
		String leituraAtual = "";
		// Leitura Anterior
		String dataLeituraAtual = "";
		// consumo medido do mês
		String consumoMedidoMes = "";
		if(parmsMedicaoHistorico != null){

			if(parmsMedicaoHistorico[1] != null){
				leituraAtual = "" + (Integer) parmsMedicaoHistorico[1];
			}

			if(parmsMedicaoHistorico[2] != null){
				dataLeituraAtual = Util.formatarData((Date) parmsMedicaoHistorico[2]);
			}

			if(parmsMedicaoHistorico[6] != null){
				consumoMedidoMes = "" + (Integer) parmsMedicaoHistorico[6];
			}
		}
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString(dataLeituraAtual, 10));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaStringComEspacoAEsquerda(leituraAtual, 39));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 6));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 8-- //
		// Canal
		linhasArquivoTxtCartas.append("1");

		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaStringComEspacoAEsquerda(consumoMedidoMes, 26));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 34));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 9-- //
		// Canal
		linhasArquivoTxtCartas.append("0");

		// Inicio Chamar Sub-Fluxo
		// recupera os parametros do consumo historico da
		// conta
		// [SB0007] - Obter Dados de Consumo da Conta
		Object[] parmsConsumoHistorico = null;
		String consumoMedio = "";
		// caso o tipo de ligacao for diferente de nulo
		if(tipoLigacao != null){
			try{
				parmsConsumoHistorico = repositorioMicromedicao.obterDadosConsumoConta(emitirContaHelper.getIdImovel(),
								emitirContaHelper.getAmReferencia(), tipoLigacao);

			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			if(parmsConsumoHistorico != null){
				// Consumo médio
				if(parmsConsumoHistorico[2] != null){
					consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
				}
			}

		}
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaStringComEspacoAEsquerda(consumoMedio, 42));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 18));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 10-- //
		// Canal
		linhasArquivoTxtCartas.append("1");

		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 14));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString(emitirContaHelper.getDescricaoLocalidade(), 46));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 11-- //
		// Canal
		linhasArquivoTxtCartas.append("1");

		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 6 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(),
						6, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 4 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(),
						4, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 2 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(),
						2, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 12-- //
		// Canal
		linhasArquivoTxtCartas.append(" ");

		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 5 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(),
						5, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 3 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(),
						3, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		// chama o [SB0004] -Obter Dados do Consumo e
		// Medição
		// Anterior
		// passando a quantidade de Meses Igual a 1 e o tipo
		// de
		// ligação
		// e medição
		// recuperados anteriormente
		obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(),
						1, tipoLigacao, tipoMedicao);
		linhasArquivoTxtCartas.append(obterDadosConsumoMedicaoAnterior);
		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 13-- //
		// Canal
		linhasArquivoTxtCartas.append("0");
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 42));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append("SEQ.  ");
		// sequencial impressão
		String sequencialImpressaoFormatada = Util.adicionarZerosEsquedaNumero(6, "" + sequencial);
		sequencialImpressaoFormatada = sequencialImpressaoFormatada.substring(0, 3) + "." + sequencialImpressaoFormatada.substring(3, 6);
		linhasArquivoTxtCartas.append(Util.completaString(sequencialImpressaoFormatada, 12));

		linhasArquivoTxtCartas.append(System.getProperty("line.separator"));

		// --Linha 14-- //
		// Canal
		linhasArquivoTxtCartas.append(" ");
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 42));
		linhasArquivoTxtCartas.append("GRUPO - ");
		linhasArquivoTxtCartas.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getIdFaturamentoGrupo(), 5));
		// completa com espaços em branco
		linhasArquivoTxtCartas.append(Util.completaString("", 5));

		return linhasArquivoTxtCartas;

	}

	/**
	 * [UC0351 - Calcular Impostos Deduzidos da Conta Author: Fernanda Paiva Data: 21/09/2006
	 * 
	 * @param idImovel
	 *            Id do Imóvel
	 * @param anoMesReferencia
	 *            Ano/Mês de Referência
	 * @param valorAgua
	 *            Valor da Água
	 * @param valorEsgoto
	 *            Valor do Esgoto
	 * @param valorDebito
	 *            Valor dos Débitos Cobrados
	 * @param valorCredito
	 *            Valor dos Créditos Realizados
	 * @return O valor da Prestacao e a lista de Impostos
	 */
	public GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosConta(Integer idImovel, Integer anoMesReferencia, BigDecimal valorAgua,
					BigDecimal valorEsgoto, BigDecimal valorDebito, BigDecimal valorCredito) throws ControladorException{

		GerarImpostosDeduzidosContaHelper retorno = new GerarImpostosDeduzidosContaHelper();
		ImpostoDeduzidoHelper impostoDeduzidoHelper = null;
		Collection<ImpostoDeduzidoHelper> colecaoHelper = null;

		Integer idCliente = null;
		BigDecimal baseCalculo = new BigDecimal("0.00");
		ImpostoTipoAliquota impostoTipoAliquota = null;
		BigDecimal valorImpostoDeduzido = new BigDecimal("0.00");
		BigDecimal percetagemAliquota = new BigDecimal("0.00");
		BigDecimal valorImpostoDeduzidoFinal = new BigDecimal("0.00");

		BigDecimal percetagemTotalAliquota = new BigDecimal("0.00");
		BigDecimal valorImpostoDeduzidoTotal = new BigDecimal("0.00");

		try{

			// Verifica se o imóvel está enquadrado em uma subcategoria considerada Repartição
			// Pública Federal
			boolean reparticaoPublicaFederal = getControladorImovel().verificarImovelReparticaoPublicaFederal(idImovel);

			// busca um cliente Federal para este imovel e com relação tipo
			// igual a Responsável
			idCliente = this.repositorioFaturamento.pesquisarClienteResponsavelEsferaPoderFederal(idImovel);

			// Se o imóvel está associado a uma subcategoria considerada como Repartição Pública
			// Federal ou possui um cliente responsável da esfera do poder Federal, calcula os
			// impostos deduzidos
			if(reparticaoPublicaFederal || idCliente != null){

				// Determina a base de calculo dos impostos deduzido
				// = (valor de água + valor de esgoto + valor dos débitos
				// cobrados - valor dos créditos realizados)
				baseCalculo = valorAgua.add(valorEsgoto);
				baseCalculo = baseCalculo.add(valorDebito);
				baseCalculo = baseCalculo.subtract(valorCredito);

				baseCalculo = baseCalculo.setScale(2, BigDecimal.ROUND_DOWN);

				// recupera a colecao dos tipos de imposto
				FiltroImpostoTipo filtroImpostoTipo = new FiltroImpostoTipo();
				filtroImpostoTipo.adicionarParametro(new ParametroSimples(FiltroImpostoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));
				Collection colecaoImpostoTipo = getControladorUtil().pesquisar(filtroImpostoTipo, ImpostoTipo.class.getName());

				ImpostoTipo impostoTipo = null;
				if(colecaoImpostoTipo != null && !colecaoImpostoTipo.isEmpty()){
					// para cada tipo de imposto calcula o valor do imposto
					// deduzido e acumula um valor total
					colecaoHelper = new ArrayList();

					Iterator iteratorImpostoTipo = colecaoImpostoTipo.iterator();

					while(iteratorImpostoTipo.hasNext()){
						impostoTipo = (ImpostoTipo) iteratorImpostoTipo.next();
						impostoDeduzidoHelper = new ImpostoDeduzidoHelper();

						if(impostoTipo.getId() != null){
							// pesquisa a aliquota para cada tipo de imposto
							impostoTipoAliquota = this.repositorioFaturamento.pesquisarAliquotaImposto(impostoTipo.getId(),
											anoMesReferencia);

							if(!Util.isVazioOuBranco(impostoTipoAliquota)){
								// TOTAL PERCENTAGEM IMPOSTOS
								// ===========================================
								percetagemTotalAliquota = percetagemTotalAliquota.add(impostoTipoAliquota.getPercentualAliquota());
								// =======================================================================

								/*
								 * Colocado por Raphael Rossiter em 04/06/2007
								 * O valor do ultimo imposto não será mais calculado, será a
								 * diferença
								 * entre o valor total do imposto com o valor dos
								 * impostos calculados.
								 */
								if(iteratorImpostoTipo.hasNext()){

									percetagemAliquota = Util.dividirArredondando(impostoTipoAliquota.getPercentualAliquota(),
													new BigDecimal("100.00"));

									valorImpostoDeduzido = baseCalculo.multiply(percetagemAliquota);

									valorImpostoDeduzido = valorImpostoDeduzido.setScale(2, BigDecimal.ROUND_HALF_DOWN);

									// se o valor deduzido for maior que zero, cria
									// uma
									// colecao com o tipo, o valor e a aliquota
									// do imposto e guarda um valor total de todos
									// os
									// impostos
									if(valorImpostoDeduzido.compareTo(new BigDecimal("0.00")) == 1){

										impostoDeduzidoHelper.setIdImpostoTipo(impostoTipoAliquota.getImpostoTipo().getId());
										impostoDeduzidoHelper.setValor(valorImpostoDeduzido);
										impostoDeduzidoHelper.setPercentualAliquota(impostoTipoAliquota.getPercentualAliquota());

										valorImpostoDeduzidoFinal = valorImpostoDeduzidoFinal.add(valorImpostoDeduzido);

										// adiciona o helper do imposto na colecao
										// de
										// helper
										colecaoHelper.add(impostoDeduzidoHelper);
									}
								}else{

									// TOTAL
									// =================================================
									percetagemTotalAliquota = Util.dividirArredondando(percetagemTotalAliquota, new BigDecimal("100.00"));

									valorImpostoDeduzidoTotal = baseCalculo.multiply(percetagemTotalAliquota);

									valorImpostoDeduzidoTotal = valorImpostoDeduzidoTotal.setScale(2, BigDecimal.ROUND_HALF_DOWN);
									// =======================================================

									// ÚLTIMO IMPOSTO
									// ========================================
									valorImpostoDeduzido = valorImpostoDeduzidoTotal.subtract(valorImpostoDeduzidoFinal);

									valorImpostoDeduzido = valorImpostoDeduzido.setScale(2, BigDecimal.ROUND_DOWN);
									// =======================================================

									// se o valor deduzido for maior que zero, cria
									// uma
									// colecao com o tipo, o valor e a aliquota
									// do imposto e guarda um valor total de todos
									// os
									// impostos
									if(valorImpostoDeduzido.compareTo(new BigDecimal("0.00")) == 1){

										impostoDeduzidoHelper.setIdImpostoTipo(impostoTipoAliquota.getImpostoTipo().getId());
										impostoDeduzidoHelper.setValor(valorImpostoDeduzido);
										impostoDeduzidoHelper.setPercentualAliquota(impostoTipoAliquota.getPercentualAliquota());

										valorImpostoDeduzidoFinal = valorImpostoDeduzidoTotal;

										// adiciona o helper do imposto na colecao
										// de helper
										colecaoHelper.add(impostoDeduzidoHelper);
									}
								}
							}
						}
					}

					retorno.setListaImpostosDeduzidos(colecaoHelper);

					valorImpostoDeduzidoFinal = valorImpostoDeduzidoFinal.setScale(2, BigDecimal.ROUND_DOWN);

					retorno.setValorTotalImposto(valorImpostoDeduzidoFinal);
				}
			}else{
				retorno.setListaImpostosDeduzidos(null);
				retorno.setValorTotalImposto(new BigDecimal("0.00"));
			}
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// return valor total dos impostos e lista dos impostos deduzidos;
		return retorno;
	}

	/**
	 * [UC0150] - Retificar Conta Author: Fernanda Paiva Data: 25/09/2006
	 * Inseri na tabela ClienteConta os dados referentes aos clientes do imovel
	 * 
	 * @param conta
	 * @param colecaoCreditoRealizado
	 * @param imovel
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirClienteImovel(Imovel imovel, Conta contaAtual) throws ControladorException{

		if(imovel.getId() != null && !imovel.getId().equals("")){

			Collection clientesImovel = new ArrayList();
			try{
				clientesImovel = repositorioFaturamento.pesquisarClienteImovelDataRelacaoFimNull(imovel);
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			Iterator clientesImovelIt = clientesImovel.iterator();

			while(clientesImovelIt.hasNext()){

				Object[] array = (Object[]) clientesImovelIt.next();

				ClienteConta clienteContaInserir = new ClienteConta();

				// Id da Conta Selecionada
				clienteContaInserir.setConta(contaAtual);

				// carrega o objeto cliente
				Cliente cliente = (Cliente) array[0];

				// Id do cliente Selecionada
				clienteContaInserir.setCliente(cliente);

				// carrega o objeto cliente relacao tipo
				ClienteRelacaoTipo clienteRelacaoTipo = (ClienteRelacaoTipo) array[1];

				// Cliente Relacao Tipo
				clienteContaInserir.setClienteRelacaoTipo(clienteRelacaoTipo);

				// Cliente Relacao Tipo
				clienteContaInserir.setIndicadorNomeConta((Short) array[2]);

				// Última alteração
				clienteContaInserir.setUltimaAlteracao(new Date());

				// -------------------------------------------------------
				// Inserindo no BD
				this.getControladorUtil().inserir(clienteContaInserir);
			}
		}
	}

	/**
	 * [UC0150] - Retificar Conta Author: Fernanda Paiva Data: 25/09/2006
	 * Inseri na tabela impostos deduzidos da conta
	 * 
	 * @author eduardo henrique
	 * @date 26/11/2008 Alteração no método para a adequação do objeto conta efetuar contabilização
	 *       do evento Inserir Conta.
	 * @param conta
	 * @param colecaoCreditoRealizado
	 * @param imovel
	 * @param colecaoCategoria
	 * @throws ControladorException
	 */
	public void inserirImpostosDeduzidosConta(GerarImpostosDeduzidosContaHelper impostosDeduzidosConta, Conta contaAtual,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		contaAtual.setContaImpostosDeduzidos(new HashSet<ContaImpostosDeduzidos>());

		if(impostosDeduzidosConta.getListaImpostosDeduzidos() != null && !impostosDeduzidosConta.getListaImpostosDeduzidos().isEmpty()){

			FiltroImpostoTipo filtroImpostoTipo = new FiltroImpostoTipo();

			Collection<ImpostoDeduzidoHelper> impostosDeduzidos = new ArrayList();

			impostosDeduzidos = impostosDeduzidosConta.getListaImpostosDeduzidos();

			Iterator impostosDeduzidoIt = impostosDeduzidos.iterator();

			ImpostoTipo impostoTipo = new ImpostoTipo();

			while(impostosDeduzidoIt.hasNext()){

				ImpostoDeduzidoHelper impostosDeduzidoColecao = (ImpostoDeduzidoHelper) impostosDeduzidoIt.next();

				ContaImpostosDeduzidos impostoDeduzidoInserir = new ContaImpostosDeduzidos();

				// Id da Conta Selecionada
				impostoDeduzidoInserir.setConta(contaAtual);

				// pesquisa o objeto imposto tipo a partir do id do imposto tipo
				filtroImpostoTipo.limparListaParametros();

				filtroImpostoTipo
								.adicionarParametro(new ParametroSimples(FiltroImpostoTipo.ID, impostosDeduzidoColecao.getIdImpostoTipo()));

				Collection colecaoImpostoTipo;

				colecaoImpostoTipo = getControladorUtil().pesquisar(filtroImpostoTipo, ImpostoTipo.class.getName());

				impostoTipo = (ImpostoTipo) Util.retonarObjetoDeColecao(colecaoImpostoTipo);

				// imposto Tipo
				impostoDeduzidoInserir.setImpostoTipo(impostoTipo);

				// Valor do Imposto
				impostoDeduzidoInserir.setValorImposto(impostosDeduzidoColecao.getValor());

				// Percentual da Aliquota
				impostoDeduzidoInserir.setPercentualAliquota(impostosDeduzidoColecao.getPercentualAliquota());

				// Base de cálculo
				BigDecimal valorBase = contaAtual.getValorAgua().add(contaAtual.getValorEsgoto());
				valorBase = valorBase.add(contaAtual.getDebitos());
				valorBase = valorBase.subtract(contaAtual.getValorCreditos());

				impostoDeduzidoInserir.setValorBaseCalculo(valorBase);

				// Data da ultima alteracao
				impostoDeduzidoInserir.setUltimaAlteracao(new Date());

				// -------------------------------------------------------
				// Inserindo no BD
				if(!indicadorOperacaoCaucionamento){
					this.getControladorUtil().inserir(impostoDeduzidoInserir);
				}

				contaAtual.getContaImpostosDeduzidos().add(impostoDeduzidoInserir);
			}
		}
	}

	/**
	 * Permite gerar os débitos de doações para os imóveis contidos na coleção [UC0394] Gerar
	 * Débitos a Cobrar de Doações
	 * 
	 * @author César Araújo, Raphael Rossiter
	 * @date 05/08/2006
	 * @author Eduardo Henrique
	 * @date 03/11/2008 Alteração para Realizar a Contabilização de Evento na geração do Debito a
	 *       Cobrar.
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desabilitar a Contabilização por Evento.
	 * @param Collection
	 *            <Rota> rotas
	 * @param int idFuncionalidadeIniciada
	 * @return void
	 * @throws ControladorException
	 */
	public void gerarDebitoACobrarDoacao(Collection<Rota> rotas, int idFuncionalidadeIniciada) throws ControladorException{

		// -------------------------
		/*
		 * Registrar o início do processamento da Unidade de Processamento do Batch
		 * Colocado por Raphael Rossiter em 11/01/2007
		 */
		// -------------------------
		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
						((Rota) Util.retonarObjetoDeColecao(rotas)).getId());

		try{

			/** * Declara variáveis locais ** */
			Imovel imovel = null;
			Quadra quadra = null;
			DebitoTipo debitoTipo = null;
			Localidade localidade = null;
			CobrancaForma cobrancaForma = null;
			DebitoACobrar debitoACobrar = null;
			Integer idDebitoACobrarGeral = null;
			FinanciamentoTipo financiamentoTipo = null;
			DebitoACobrarGeral debitoACobrarGeral = null;
			DebitoCreditoSituacao debitoCreditoSituacao = null;
			LancamentoItemContabil lancamentoItemContabil = null;
			Collection<ImovelCobrarDoacaoHelper> colecaoImovelCobrarDoacaoHelper = null;

			/**
			 * Pesquisa Imoveis que tem doação a faturar baseando-se numa coleção de rotas *
			 */

			// Parte Alterada por Sávio Luiz Data:09/05/2007
			// Parte que remove os débitos a cobrar, do ano mes de faturamento
			// para as rotas recebidas, caso já exista na base.
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			Collection colecaoIdsDebitoACobrar = repositorioFaturamento.pesquisarDebitoACobrarParaRemocao(rotas,
							sistemaParametro.getAnoMesFaturamento());
			if(colecaoIdsDebitoACobrar != null && !colecaoIdsDebitoACobrar.isEmpty()){
				repositorioFaturamento.deletarDebitosACobrarCategoria(colecaoIdsDebitoACobrar);
				getControladorCobranca().atualizarParcelamentoItensDebitoACobrar(colecaoIdsDebitoACobrar);
				getControladorCobranca().removerDocumentosItensDebitoACobrar(colecaoIdsDebitoACobrar);
				repositorioFaturamento.deletarDebitosACobrar(colecaoIdsDebitoACobrar);

			}
			colecaoImovelCobrarDoacaoHelper = getControladorMicromedicao().pesquisarImovelDoacaoPorRota(rotas);
			Collection<ObjetoTransacao> colecaoDebitoACobrarContabilizacao = new ArrayList<ObjetoTransacao>();
			for(ImovelCobrarDoacaoHelper imovelCobrarDoacaoHelper : colecaoImovelCobrarDoacaoHelper){

				/** * Instancia debitoACobrarGeral ** */
				debitoACobrarGeral = new DebitoACobrarGeral();

				/** * preenche os valores para debitoACobrarGeral ** */
				debitoACobrarGeral.setIndicadorHistorico(ImovelCobrarDoacaoHelper.INDICADOR_HISTORICO);
				debitoACobrarGeral.setUltimaAlteracao(new Date());

				/** * insere debitoACobrarGeral na base ** */
				idDebitoACobrarGeral = repositorioFaturamento.inserirDebitoACobrarGeral(debitoACobrarGeral);

				debitoACobrarGeral.setId(idDebitoACobrarGeral);

				/** * Instancia debitoACobrar ** */
				debitoACobrar = new DebitoACobrar();

				/** * preenche os valores para debitoACobrar ** */
				debitoACobrar.setId(idDebitoACobrarGeral);
				debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);

				imovel = new Imovel();
				imovel.setId(imovelCobrarDoacaoHelper.getIdImovel());
				debitoACobrar.setImovel(imovel);

				debitoTipo = new DebitoTipo();
				debitoTipo.setId(imovelCobrarDoacaoHelper.getIdDebitoTipo());
				debitoACobrar.setDebitoTipo(debitoTipo);

				debitoACobrar.setGeracaoDebito(new Date());
				debitoACobrar.setAnoMesReferenciaDebito(null);
				debitoACobrar.setAnoMesCobrancaDebito(null);
				debitoACobrar.setAnoMesReferenciaContabil(sistemaParametro.getAnoMesFaturamento());
				debitoACobrar.setValorDebito(imovelCobrarDoacaoHelper.getValorDebito());
				debitoACobrar.setNumeroPrestacaoDebito(ImovelCobrarDoacaoHelper.NUMERO_PRESTACAO_DEBITO);
				debitoACobrar.setNumeroPrestacaoCobradas(ImovelCobrarDoacaoHelper.NUMERO_PRESTACAO_COBRADA);

				localidade = new Localidade();
				localidade.setId(imovelCobrarDoacaoHelper.getIdLocalidade());
				debitoACobrar.setLocalidade(localidade);

				quadra = new Quadra();
				quadra.setId(imovelCobrarDoacaoHelper.getIdQuadra());
				debitoACobrar.setQuadra(quadra);

				debitoACobrar.setCodigoSetorComercial(imovelCobrarDoacaoHelper.getCodigoSetorComercial());
				debitoACobrar.setNumeroQuadra(imovelCobrarDoacaoHelper.getNumeroQuadra());
				debitoACobrar.setNumeroLote(imovelCobrarDoacaoHelper.getNumeroLote());
				debitoACobrar.setNumeroSubLote(imovelCobrarDoacaoHelper.getNumeroSubLote());
				debitoACobrar.setPercentualTaxaJurosFinanciamento(ImovelCobrarDoacaoHelper.TAXA_JURO_FINANCIAMENTO);
				debitoACobrar.setRegistroAtendimento(null);
				debitoACobrar.setOrdemServico(null);

				financiamentoTipo = new FinanciamentoTipo();
				financiamentoTipo.setId(imovelCobrarDoacaoHelper.getFinanciamentoTipo());
				debitoACobrar.setFinanciamentoTipo(financiamentoTipo);

				lancamentoItemContabil = new LancamentoItemContabil();
				lancamentoItemContabil.setId(imovelCobrarDoacaoHelper.getLancamentoItemContabil());
				debitoACobrar.setLancamentoItemContabil(lancamentoItemContabil);

				debitoCreditoSituacao = new DebitoCreditoSituacao();
				debitoCreditoSituacao.setId(ImovelCobrarDoacaoHelper.DEBITO_CREDITO_SITUACAO_ATUAL);
				debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
				debitoACobrar.setDebitoCreditoSituacaoAnterior(null);
				debitoACobrar.setParcelamentoGrupo(null);

				cobrancaForma = new CobrancaForma();
				cobrancaForma.setId(ImovelCobrarDoacaoHelper.COBRANCA_FORMA);
				debitoACobrar.setCobrancaForma(cobrancaForma);
				debitoACobrar.setUltimaAlteracao(new Date());

				/** * Insere debitoACobrar na base ** */
				repositorioFaturamento.inserirDebitoACobrar(debitoACobrar);

				/** * Insere debitoACobrarCategoria ** */
				this.inserirDebitoACobrarCategoria(debitoACobrar, imovel);

				// inserir CLIENTE_DEBITO_A_COBRAR

				this.getControladorCobranca().inserirClienteDebitoACobrar(debitoACobrar);

				colecaoDebitoACobrarContabilizacao.add(debitoACobrar);
			}

			// Manda débitos Incluídos para Contabilização
			// getControladorFinanceiro().contabilizarEventoFaturamento(colecaoDebitoACobrarContabilizacao,
			// EventoContabil.INCLUSAO_DEBITO_A_COBRAR);

			// --------------------------------------------------------
			// Registrar o fim da execução da Unidade de Processamento
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			/*
			 * Este catch serve para interceptar qualquer exceção que o processo batch venha a
			 * lançar e garantir que a unidade de processamento do
			 * batch será atualizada com o erro ocorrido
			 */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	public void transferirContasParaHistorico(Integer idConta) throws ControladorException{

		try{
			repositorioFaturamento.transferirContaParaHistorico(idConta);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Gera o objeto débito a cobrar historico a partir do debito a cobrar.
	 * 
	 * @param debitoACobrar
	 * @return
	 */
	public DebitoACobrarHistorico gerarDebitoACobrarHistoricoDoDebitoACobrar(DebitoACobrar debitoACobrar){

		DebitoACobrarHistorico debitoACobrarHistoricoTemp;
		// seta os dados do histórico de débito a cobrar
		debitoACobrarHistoricoTemp = new DebitoACobrarHistorico();
		debitoACobrarHistoricoTemp.setId(debitoACobrar.getId());
		debitoACobrarHistoricoTemp.setDebitoGeradoRealizar(debitoACobrar.getGeracaoDebito());
		debitoACobrarHistoricoTemp.setAnoMesReferenciaDebito(debitoACobrar.getAnoMesReferenciaDebito());
		debitoACobrarHistoricoTemp.setAnoMesCobrancaDebito(debitoACobrar.getAnoMesCobrancaDebito());
		debitoACobrarHistoricoTemp.setAnoMesReferenciaContabil(debitoACobrar.getAnoMesReferenciaContabil());
		debitoACobrarHistoricoTemp.setValorDebito(debitoACobrar.getValorDebito());
		debitoACobrarHistoricoTemp.setPrestacaoDebito(debitoACobrar.getNumeroPrestacaoDebito());
		debitoACobrarHistoricoTemp.setPrestacaoCobradas(debitoACobrar.getNumeroPrestacaoCobradas());
		debitoACobrarHistoricoTemp.setCodigoSetorComercial(debitoACobrar.getCodigoSetorComercial());
		debitoACobrarHistoricoTemp.setNumeroQuadra(debitoACobrar.getNumeroQuadra());
		debitoACobrarHistoricoTemp.setLote(debitoACobrar.getNumeroLote());
		debitoACobrarHistoricoTemp.setSublote(debitoACobrar.getNumeroSubLote());
		debitoACobrarHistoricoTemp.setUltimaAlteracao(new Date());
		debitoACobrarHistoricoTemp.setLancamentoItemContabil(debitoACobrar.getLancamentoItemContabil());
		debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAtual(debitoACobrar.getDebitoCreditoSituacaoAtual());
		debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAnterior(debitoACobrar.getDebitoCreditoSituacaoAnterior());
		debitoACobrarHistoricoTemp.setRegistroAtendimento(debitoACobrar.getRegistroAtendimento());
		debitoACobrarHistoricoTemp.setImovel(debitoACobrar.getImovel());
		debitoACobrarHistoricoTemp.setFinanciamentoTipo(debitoACobrar.getFinanciamentoTipo());
		debitoACobrarHistoricoTemp.setOrdemServico(debitoACobrar.getOrdemServico());
		debitoACobrarHistoricoTemp.setCobrancaForma(debitoACobrar.getCobrancaForma());
		debitoACobrarHistoricoTemp.setQuadra(debitoACobrar.getQuadra());
		debitoACobrarHistoricoTemp.setLocalidade(debitoACobrar.getLocalidade());
		debitoACobrarHistoricoTemp.setParcelamentoGrupo(debitoACobrar.getParcelamentoGrupo());
		debitoACobrarHistoricoTemp.setDocumentoTipo(debitoACobrar.getDocumentoTipo());
		debitoACobrarHistoricoTemp.setParcelamento(debitoACobrar.getParcelamento());
		debitoACobrarHistoricoTemp.setDebitoTipo(debitoACobrar.getDebitoTipo());
		debitoACobrarHistoricoTemp.setDataAntecipacao(debitoACobrar.getDataAntecipacao());
		debitoACobrarHistoricoTemp.setQuantidadeParcelasAntecipadas(debitoACobrar.getQuantidadeParcelasAntecipadas());

		debitoACobrarHistoricoTemp.setPercentualTaxaJurosFinanciamento(debitoACobrar.getPercentualTaxaJurosFinanciamento());

		debitoACobrarHistoricoTemp.setNumeroDiasSuspensao(debitoACobrar.getNumeroDiasSuspensao());
		debitoACobrarHistoricoTemp.setOcorrenciaInfracaoItem(debitoACobrar.getOcorrenciaInfracaoItem());

		debitoACobrarHistoricoTemp.setNumeroMesesEntreParcelas(debitoACobrar.getNumeroMesesEntreParcelas());
		debitoACobrarHistoricoTemp.setNumeroParcelasALancar(debitoACobrar.getNumeroParcelasALancar());
		debitoACobrarHistoricoTemp.setAnoMesReferenciaUltimaCobranca(debitoACobrar.getAnoMesReferenciaUltimaCobranca());

		debitoACobrarHistoricoTemp.setIndicadorRemuneraCobrancaAdministrativa(debitoACobrar.getIndicadorRemuneraCobrancaAdministrativa());

		return debitoACobrarHistoricoTemp;
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Para cada conta transferida para o histórico, atualiza o indicador de que a conta está no
	 * histórico na tabela ContaGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * @param colecaoContas
	 * @throws ControladorException
	 */
	public void atualizarIndicadorContaNoHistorico(Collection colecaoContas) throws ControladorException{

		List colecaoTotalContas = (List) colecaoContas;
		int limiteSuperior;
		int limiteInferior;
		int limiteMaximo = colecaoTotalContas.size();
		int quantidadeMaximaPorColecao = 100;

		try{

			for(int i = 0; i < limiteMaximo; i = i + 100){

				if(limiteMaximo < quantidadeMaximaPorColecao){
					limiteInferior = 0;
					limiteSuperior = limiteMaximo;
				}else{
					limiteInferior = i;
					limiteSuperior = i + 100;

					if(limiteSuperior > limiteMaximo){
						limiteSuperior = limiteMaximo;
					}
				}

				List colecaoContasTemporaria = new ArrayList();
				colecaoContasTemporaria.addAll(colecaoTotalContas.subList(limiteInferior, limiteSuperior));

				this.repositorioFaturamento.atualizarIndicadorContaNoHistorico(colecaoContasTemporaria);

			}

		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Para cada débito a cobrar transferido para o histórico, atualiza o indicador de que o débito
	 * a cobrar está no histórico na tabela
	 * DebitoACobrarGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * @param colecaoDebitosACobrar
	 * @throws ControladorException
	 */
	public void atualizarIndicadorDebitoACobrarNoHistorico(Collection colecaoDebitosACobrar) throws ControladorException{

		try{
			List colecaoTotalDebitosACobrar = (List) colecaoDebitosACobrar;
			int limiteSuperior;
			int limiteInferior;
			int limiteMaximo = colecaoTotalDebitosACobrar.size();
			int quantidadeMaximaPorColecao = 100;

			for(int i = 0; i < limiteMaximo; i = i + 100){

				if(limiteMaximo < quantidadeMaximaPorColecao){
					limiteInferior = 0;
					limiteSuperior = limiteMaximo;
				}else{
					limiteInferior = i;
					limiteSuperior = i + 100;

					if(limiteSuperior > limiteMaximo){
						limiteSuperior = limiteMaximo;
					}
				}

				List colecaoDebitosACobrarTemporaria = new ArrayList();
				colecaoDebitosACobrarTemporaria.addAll(colecaoTotalDebitosACobrar.subList(limiteInferior, limiteSuperior));

				this.repositorioFaturamento.atualizarIndicadorDebitoACobrarNoHistorico(colecaoDebitosACobrarTemporaria);

			}

		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Para cada crédito a realizar transferido para o histórico, atualiza o indicador de que o
	 * crédito a realizar está no histórico na tabela
	 * CreditoARealizarGeral.
	 * 
	 * @author Pedro Alexandre
	 * @date 11/10/2006
	 * @param colecaoCreditosARealizar
	 * @throws ControladorException
	 */
	public void atualizarIndicadorCreditosARealizarNoHistorico(Collection<CreditoARealizar> colecaoCreditosARealizar)
					throws ControladorException{

		try{

			List colecaoTotalCreditosARealizar = (List) colecaoCreditosARealizar;
			int limiteSuperior;
			int limiteInferior;
			int limiteMaximo = colecaoTotalCreditosARealizar.size();
			int quantidadeMaximaPorColecao = 100;

			for(int i = 0; i < limiteMaximo; i = i + 100){

				if(limiteMaximo < quantidadeMaximaPorColecao){
					limiteInferior = 0;
					limiteSuperior = limiteMaximo;
				}else{
					limiteInferior = i;
					limiteSuperior = i + 100;

					if(limiteSuperior > limiteMaximo){
						limiteSuperior = limiteMaximo;
					}
				}

				// List colecaoCreditosARealizarTemporaria = new ArrayList();
				// colecaoCreditosARealizarTemporaria.addAll(colecaoTotalCreditosARealizar.subList(limiteInferior,
				// limiteSuperior));
				// this.repositorioFaturamento.atualizarIndicadorCreditoARealizarNoHistorico(colecaoCreditosARealizarTemporaria);

				// Alterado na migração do JBOSS 4.2
				List idsCreditoARealizarTemporaria = new ArrayList();

				List colecaoCreditosARealizarTemporaria = colecaoTotalCreditosARealizar.subList(limiteInferior, limiteSuperior);

				for(Object creditoARealizarObj : colecaoCreditosARealizarTemporaria){

					CreditoARealizar creditoARealizar = (CreditoARealizar) creditoARealizarObj;

					idsCreditoARealizarTemporaria.add(creditoARealizar.getId());
				}

				this.repositorioFaturamento.atualizarIndicadorCreditoARealizarNoHistorico(idsCreditoARealizarTemporaria);

			}

		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto - CAER
	 * 
	 * @author Raphael Rossiter
	 * @date 19/10/2006
	 * @param
	 * @throws ControladorException
	 */
	public Collection<CalcularValoresAguaEsgotoHelper> calcularValoresAguaEsgotoCAER(Integer anoMesReferencia,
					Integer ligacaoSituacaoAguaId, Integer ligacaoSituacaoEsgotoId, Short indicadorFaturamentoAgua,
					Short indicadorFaturamentoEsgoto, Collection categoriasImovel, Integer consumoFaturadoAguaMes,
					Integer consumoFaturadoEsgotoMes, int consumoMinimoLigacao, Date dataLeituraAnterior, Date dataLeituraAtual,
					BigDecimal percentualEsgoto, Integer tarifaImovel) throws ControladorException{

		/*
		 * Seleciona todas as ocorrências da tabela CONSUMO_TARIFA_VIGENCIA com CSTF_ID=Id da tarifa
		 * para o imóvel e com CSTV_DTVIGENCIA entre as
		 * datas de leitura anterior e atual
		 */

		// Legenda: Parcial = true , Final = false
		Collection colecaoConsumoTarifaVigenciaEntreDatas = null;
		Collection colecaoConsumoTarifaVigenciaTodasDatas = new ArrayList();
		Collection colecaoConsumoTarifaVigenciaMaiorData = null;

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresAgua = new ArrayList();
		Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresEsgoto = new ArrayList();

		if(tarifaImovel != null && dataLeituraAnterior != null && dataLeituraAtual != null){

			colecaoConsumoTarifaVigenciaEntreDatas = selecionaTarifasVigentesPeriodoLeituraImovel(tarifaImovel, dataLeituraAnterior,
							dataLeituraAtual, true);

			/*
			 * Caso não seja selecionada nenhuma ocorrência ou caso nenhuma ocorrência selecionada
			 * tenha CSTV_DTVIGENCIA = data de leitura anterior,
			 * selecionar também a ocorrência da tabela CONSUMO_TARIFA_VIGENCIA com CSTF_ID= Id da
			 * tarifa para o imóvel e com a maior CSTV_DTVIGENCIA
			 * que seja menor que a data de leitura anterior
			 */

			if(colecaoConsumoTarifaVigenciaEntreDatas == null || colecaoConsumoTarifaVigenciaEntreDatas.isEmpty()){

				colecaoConsumoTarifaVigenciaMaiorData = selecionaTarifasVigentesPeriodoLeituraImovel(tarifaImovel, dataLeituraAnterior,
								dataLeituraAtual, false);

				colecaoConsumoTarifaVigenciaTodasDatas.addAll(colecaoConsumoTarifaVigenciaMaiorData);

			}else{

				ConsumoTarifaVigencia consumoTarifaVigencia = null;
				Iterator itConsumoTarifaVigencia = colecaoConsumoTarifaVigenciaEntreDatas.iterator();

				boolean flagBuscarOcorrencia = true;

				while(itConsumoTarifaVigencia.hasNext()){
					consumoTarifaVigencia = (ConsumoTarifaVigencia) itConsumoTarifaVigencia.next();

					/*
					 * Verifica se já existe alguma ocorrência onde a dataVigencia é igual a
					 * dataLeituraAnterior
					 */
					if(consumoTarifaVigencia.getDataVigencia() != null
									&& Util.datasIguais(consumoTarifaVigencia.getDataVigencia(), dataLeituraAnterior)){

						flagBuscarOcorrencia = false;
						break;
					}
				}

				colecaoConsumoTarifaVigenciaTodasDatas.addAll(colecaoConsumoTarifaVigenciaEntreDatas);

				if(flagBuscarOcorrencia){

					colecaoConsumoTarifaVigenciaMaiorData = selecionaTarifasVigentesPeriodoLeituraImovel(tarifaImovel, dataLeituraAnterior,
									dataLeituraAtual, false);

					/*
					 * As tarifas vigentes para o período de leitura serão as ocorrências
					 * selecionadas nas coleções parcial e final
					 */
					colecaoConsumoTarifaVigenciaTodasDatas.addAll(colecaoConsumoTarifaVigenciaMaiorData);

					// Organizar a coleção
					Collections.sort((List) colecaoConsumoTarifaVigenciaTodasDatas, new Comparator() {

						public int compare(Object a, Object b){

							Date dataVigencia1 = ((ConsumoTarifaVigencia) a).getDataVigencia();
							Date dataVigencia2 = ((ConsumoTarifaVigencia) b).getDataVigencia();

							return dataVigencia1.compareTo(dataVigencia2);

						}
					});

				}
			}

			/*
			 * Caso a situação da ligação de água corresponda a ligado ou cortado e esteja indicado
			 * que é para faturar água (indicador de faturamento
			 * de água=1), considerar o consumo faturado como o consumo a ser faturado de água
			 */

			ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();

			if((ligacaoSituacaoAguaId.equals(LigacaoAguaSituacao.LIGADO) || ligacaoSituacaoAguaId.equals(LigacaoAguaSituacao.CORTADO))
							&& indicadorFaturamentoAgua.equals(ConsumoHistorico.FATURAR_AGUA)){

				if(colecaoConsumoTarifaVigenciaTodasDatas == null || colecaoConsumoTarifaVigenciaTodasDatas.isEmpty()){
					// A lista com as tarifas vigentes está nula ou vazia
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.nao_cadastrada_data_vigencia");
				}else if(colecaoConsumoTarifaVigenciaTodasDatas.size() == 1){

					// [SF0001 – Cálculo Simples Para Uma Única Tarifa]

					consumoTarifaVigencia = (ConsumoTarifaVigencia) Util.retonarObjetoDeColecao(colecaoConsumoTarifaVigenciaTodasDatas);

					if(consumoTarifaVigencia.getId() != null && consumoTarifaVigencia.getDataVigencia() != null){

						colecaoValoresAgua = calculoSimplesUmaTarifaCAER(consumoFaturadoAguaMes, categoriasImovel, percentualEsgoto,
										consumoTarifaVigencia, ConstantesSistema.CALCULAR_AGUA);
					}else{
						// A lista com as tarifas vigentes está nula ou vazia
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.nao_cadastrada_data_vigencia");
					}

				}else{
					// [SF0002 – Cálculo Proporcional Para Mais de Uma Tarifa]

					colecaoValoresAgua = calculoProporcionalMaisDeUmaTarifa(dataLeituraAtual, dataLeituraAnterior,
									colecaoConsumoTarifaVigenciaTodasDatas, consumoFaturadoAguaMes, categoriasImovel, percentualEsgoto,
									ConstantesSistema.CALCULAR_AGUA);
				}
			}

			/*
			 * Caso a situação da ligação de esgoto corresponda a ligado e esteja indicado que é
			 * para faturar esgoto (indicador de faturamento de
			 * esgoto = 1), considerar o consumo faturado como o consumo a ser faturado de esgoto
			 */
			if(ligacaoSituacaoEsgotoId.equals(LigacaoEsgotoSituacao.LIGADO)
							&& indicadorFaturamentoEsgoto.equals(ConsumoHistorico.FATURAR_ESGOTO)){

				if(colecaoConsumoTarifaVigenciaTodasDatas == null || colecaoConsumoTarifaVigenciaTodasDatas.isEmpty()){
					// A lista com as tarifas vigentes está nula ou vazia
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.nao_cadastrada_data_vigencia");
				}else if(colecaoConsumoTarifaVigenciaTodasDatas.size() == 1){
					// [SF0001 – Cálculo Simples Para Uma Única Tarifa]

					consumoTarifaVigencia = (ConsumoTarifaVigencia) Util.retonarObjetoDeColecao(colecaoConsumoTarifaVigenciaTodasDatas);

					if(consumoTarifaVigencia.getId() != null && consumoTarifaVigencia.getDataVigencia() != null){

						colecaoValoresEsgoto = calculoSimplesUmaTarifaCAER(consumoFaturadoEsgotoMes, categoriasImovel, percentualEsgoto,
										consumoTarifaVigencia, ConstantesSistema.CALCULAR_ESGOTO);
					}else{
						// A lista com as tarifas vigentes está nula ou vazia
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.nao_cadastrada_data_vigencia");
					}

				}else{
					// [SF0002 – Cálculo Proporcional Para Mais de Uma Tarifa]

					colecaoValoresEsgoto = calculoProporcionalMaisDeUmaTarifa(dataLeituraAtual, dataLeituraAnterior,
									colecaoConsumoTarifaVigenciaTodasDatas, consumoFaturadoEsgotoMes, categoriasImovel, percentualEsgoto,
									ConstantesSistema.CALCULAR_ESGOTO);
				}
			}

			// Unificando os valores de água e esgoto em apenas uma coleção

			// O calculo foi realizado apenas para água
			if((colecaoValoresAgua != null && !colecaoValoresAgua.isEmpty())
							&& (colecaoValoresEsgoto == null || colecaoValoresEsgoto.isEmpty())){
				colecaoRetorno.addAll(colecaoValoresAgua);
			}
			// O calculo foi realizado apenas para esgoto
			else if((colecaoValoresEsgoto != null && !colecaoValoresEsgoto.isEmpty())
							&& (colecaoValoresAgua == null || colecaoValoresAgua.isEmpty())){
				colecaoRetorno.addAll(colecaoValoresEsgoto);
			}
			// O calculo foi realizado para ambos
			else{

				Iterator colecaoValoresAguaIt = colecaoValoresAgua.iterator();
				Iterator colecaoValoresEsgotoIt;
				Iterator colecaoValoresAguaFaixaIt;
				Iterator colecaoValoresEsgotoFaixaIt;

				CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelperAgua, calcularValoresAguaEsgotoHelperEsgoto;
				CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelperAgua, calcularValoresAguaEsgotoFaixaHelperEsgoto;

				while(colecaoValoresAguaIt.hasNext()){

					calcularValoresAguaEsgotoHelperAgua = (CalcularValoresAguaEsgotoHelper) colecaoValoresAguaIt.next();

					colecaoValoresEsgotoIt = colecaoValoresEsgoto.iterator();

					while(colecaoValoresEsgotoIt.hasNext()){

						calcularValoresAguaEsgotoHelperEsgoto = (CalcularValoresAguaEsgotoHelper) colecaoValoresEsgotoIt.next();

						// Carregando os valores de esgoto na coleção que contém
						// os valores calculados de água
						if(calcularValoresAguaEsgotoHelperAgua.getIdCategoria().equals(
										calcularValoresAguaEsgotoHelperEsgoto.getIdCategoria())){

							// Carregando o valor faturado de esgoto na coleção
							// de água
							calcularValoresAguaEsgotoHelperAgua.setValorFaturadoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
											.getValorFaturadoEsgotoCategoria());

							// Carregando o consumo faturado de esgoto na
							// coleção de água
							calcularValoresAguaEsgotoHelperAgua.setConsumoFaturadoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
											.getConsumoFaturadoEsgotoCategoria());

							// Carregando o valor da tarifa mínima de esgoto na
							// coleção de água
							calcularValoresAguaEsgotoHelperAgua.setValorTarifaMinimaEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
											.getValorTarifaMinimaEsgotoCategoria());

							// Carregando o consumo mínimo de esgoto na coleção
							// de água
							calcularValoresAguaEsgotoHelperAgua.setConsumoMinimoEsgotoCategoria(calcularValoresAguaEsgotoHelperEsgoto
											.getConsumoMinimoEsgotoCategoria());

							// -------------------------------------------------------------------------------
							// Carregando os valores calculados de esgoto para
							// cada faixa da tarifa de consumo
							// -------------------------------------------------------------------------------

							colecaoValoresAguaFaixaIt = calcularValoresAguaEsgotoHelperAgua.getFaixaTarifaConsumo().iterator();

							while(colecaoValoresAguaFaixaIt.hasNext()){

								calcularValoresAguaEsgotoFaixaHelperAgua = (CalcularValoresAguaEsgotoFaixaHelper) colecaoValoresAguaFaixaIt
												.next();

								colecaoValoresEsgotoFaixaIt = calcularValoresAguaEsgotoHelperEsgoto.getFaixaTarifaConsumo().iterator();

								while(colecaoValoresEsgotoFaixaIt.hasNext()){

									calcularValoresAguaEsgotoFaixaHelperEsgoto = (CalcularValoresAguaEsgotoFaixaHelper) colecaoValoresEsgotoFaixaIt
													.next();

									if(calcularValoresAguaEsgotoFaixaHelperAgua.getIdConsumoTarifaFaixa().equals(
													calcularValoresAguaEsgotoFaixaHelperEsgoto.getIdConsumoTarifaFaixa())){

										// Carregando o valor faturado de esgoto
										// na faixa para coleção de água
										calcularValoresAguaEsgotoFaixaHelperAgua
														.setValorFaturadoEsgotoFaixa(calcularValoresAguaEsgotoFaixaHelperEsgoto
																		.getValorFaturadoEsgotoFaixa());

										// Carregando o consumo faturado de
										// esgoto na faixa para coleção de água
										calcularValoresAguaEsgotoFaixaHelperAgua
														.setConsumoFaturadoEsgotoFaixa(calcularValoresAguaEsgotoFaixaHelperEsgoto
																		.getConsumoFaturadoEsgotoFaixa());
									}
								}
							}
						}
					}

					colecaoRetorno.add(calcularValoresAguaEsgotoHelperAgua);
				}
			}
		}

		return calcularValoresAguaEsgotoTotalizandoPorCategoria(colecaoRetorno);
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto - CAER
	 * [SF0001] - Cálculo Simples Para Uma Única Tarifa
	 * 
	 * @author Raphael Rossiter
	 * @date 19/10/2006
	 * @param
	 * @throws ControladorException
	 */
	protected Collection<CalcularValoresAguaEsgotoHelper> calculoSimplesUmaTarifaCAER(Integer consumoFaturado, Collection categoriasImovel,
					BigDecimal percentualEsgoto, ConsumoTarifaVigencia consumoTarifaVigencia, String tipoCalculo)
					throws ControladorException{

		/*
		 * Para campos relacionados a consumo serão atribuídos valores inteiros, já com os campos
		 * monetários serão atribuídos valores com duas casas
		 * decimais (BigDecimal).
		 * -------------------------------------------------------------------------
		 */

		int quantTotalEconomia = 0;
		int consumoPorEconomia = 0;
		int consumoMinimoCategoria = 0;
		int consumoExcedenteCategoria = 0;
		int consumoEconomiaCategoria = 0;
		int consumoFaturadoCategoria = 0;
		BigDecimal vlTarifaMinimaCategoria = new BigDecimal("0");
		BigDecimal vlEconomiaCategoria = new BigDecimal("0");
		BigDecimal vlFaturadoCategoria = new BigDecimal("0");

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		// --------------------------------------------------------------------------

		Iterator itCategoriasImovel = categoriasImovel.iterator();
		Categoria categoria;

		// Calcula a quantidade total de economias do imóvel.
		// --------------------------------------------------------------------------
		while(itCategoriasImovel.hasNext()){
			categoria = (Categoria) itCategoriasImovel.next();

			quantTotalEconomia = quantTotalEconomia + categoria.getQuantidadeEconomiasCategoria().intValue();
		}

		// Calcula o consumo por economia (consumo faturado / quantidade total
		// de economias).
		// consumoPorEconomia = Util.dividirArredondarResultado(consumoFaturado
		// .intValue(), quantTotalEconomia);

		// Pega o menor valor da divisão para o consumo de água ser o menor
		// multiplo das economias
		// Roberta Costa - 27/07/2006
		if(quantTotalEconomia != 0){
			consumoPorEconomia = consumoFaturado.intValue() / quantTotalEconomia;
		}

		// --------------------------------------------------------------------------
		// Seleciona as tarifas de consumo por categoria
		// (CONSUMO_TARIFA_CATEGORIA).
		// --------------------------------------------------------------------------
		itCategoriasImovel = categoriasImovel.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoria;
		Collection colecaoConsumoTarifaCategoria = null;

		while(itCategoriasImovel.hasNext()){
			categoria = (Categoria) itCategoriasImovel.next();

			try{

				colecaoConsumoTarifaCategoria = repositorioFaturamento.pesquisarConsumoTarifaCategoria(consumoTarifaVigencia, categoria);

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if(colecaoConsumoTarifaCategoria == null || colecaoConsumoTarifaCategoria.isEmpty()){
				sessionContext.setRollbackOnly();
				// ////*****//////
				throw new ControladorException("erro.sistema");
			}

			consumoTarifaCategoria = (ConsumoTarifaCategoria) Util.retonarObjetoDeColecao(colecaoConsumoTarifaCategoria);

			/*
			 * Para cada tarifa de consumo por categoria selecionada serão calculados os valores
			 * (valor da tarifa mínima da categoria, consumo mínimo
			 * da categoria, valor por economia da categoria, consumo excedente da categoria)
			 * OBS - Cada categoria só possuirá uma tarifa de consumo (Analista 15/08/2005)
			 * -----------------------------------------------------------------------
			 */

			// ValorTarifaMinimaCategoria (CSTC_VLTARIFAMINIMA * quantidade
			// de
			// economias)
			if(consumoTarifaCategoria.getValorTarifaMinima() != null){
				vlTarifaMinimaCategoria = consumoTarifaCategoria.getValorTarifaMinima().multiply(
								new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));
			}else{
				vlTarifaMinimaCategoria = null;
			}

			// ConsumoMinimoCategoria (CSTC_NNCONSUMOMINIMO * quantidade de
			// economias)
			if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
				consumoMinimoCategoria = consumoTarifaCategoria.getNumeroConsumoMinimo().intValue()
								* categoria.getQuantidadeEconomiasCategoria();
			}

			// ValorEconomiaCategoria (CSTC_VLTARIFAMINIMA)
			if(consumoTarifaCategoria.getValorTarifaMinima() != null){
				vlEconomiaCategoria = consumoTarifaCategoria.getValorTarifaMinima();
			}else{
				vlEconomiaCategoria = null;
			}

			/*
			 * Caso o consumo por economia seja maior que o CSTC_NNCONSUMOMINIMO então consumo por
			 * economia da categoria = CSTC_NNCONSUMOMINIMO, caso
			 * contrário consumo por economia da categoria = consumo por economia
			 */
			if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
				if(consumoPorEconomia > consumoTarifaCategoria.getNumeroConsumoMinimo().intValue()){

					consumoEconomiaCategoria = consumoTarifaCategoria.getNumeroConsumoMinimo().intValue();

				}else{

					consumoEconomiaCategoria = consumoPorEconomia;

				}
			}

			/*
			 * Consumo excedente da categoria = consumo por economia – CSTC_NNCONSUMOMINIMO
			 */
			if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
				consumoExcedenteCategoria = consumoPorEconomia - consumoTarifaCategoria.getNumeroConsumoMinimo().intValue();
			}

			// Objeto que irá armazenar os valores calculados referentes as
			// faixas
			Collection<CalcularValoresAguaEsgotoFaixaHelper> colecaoCalcularValoresAguaEsgotoFaixaHelper = new ArrayList();

			// Caso o consumo excedente da categoria seja maior que zero
			BigDecimal vlFaturadoFaixa = null;
			if(consumoExcedenteCategoria > 0){

				// int faixaFimAnterior = 0;

				// Calcula a faixa fim anterior = CSTC_NNCONSUMOMINIMO
				/*
				 * if (consumoTarifaCategoria.getNumeroConsumoMinimo() != null) { faixaFimAnterior =
				 * consumoTarifaCategoria
				 * .getNumeroConsumoMinimo().intValue(); }
				 */

				/*
				 * Seleciona as faixas para cálculo do valor faturado, classificadas pela faixa
				 * inicial de consumo (CSTI_NNCONSUMOFAIXAINICIO), (a
				 * partir da tabela CONSUMO_TARIFA_FAIXA com CSTC_ID=CSTC_ID da tabela
				 * CONSUMO_TARIFA_CATEGORIA)
				 */

				Collection colecaoConsumoTarifaFaixa = null;

				try{

					colecaoConsumoTarifaFaixa = repositorioFaturamento.pesquisarConsumoTarifaFaixa(consumoTarifaCategoria);

				}catch(ErroRepositorioException ex){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				if(colecaoConsumoTarifaFaixa == null || colecaoConsumoTarifaFaixa.isEmpty()){
					// Nenhuma faixa foi encontrada
					sessionContext.setRollbackOnly();
					throw new ControladorException("");
				}else{
					Iterator itConsumoTarifaFaixa = colecaoConsumoTarifaFaixa.iterator();
					ConsumoTarifaFaixa consumoTarifaFaixa = new ConsumoTarifaFaixa();

					// int consumoFaturadoFaixa = 0;
					// int limiteInicialConsumoFaixa = 0;
					// int limiteFinalConsumoFaixa = 0;

					// BigDecimal vlTarifaFaixa = new BigDecimal("0");

					while(itConsumoTarifaFaixa.hasNext() && consumoExcedenteCategoria > 0){

						consumoTarifaFaixa = (ConsumoTarifaFaixa) itConsumoTarifaFaixa.next();

						/*
						 * Selecione a faixa em que o consumo excedente se enquadre,
						 * (consumoFaturado menor ou igual a faixa fim)
						 */
						if(consumoTarifaFaixa.getNumeroConsumoFaixaIFim() != null
										&& consumoPorEconomia <= consumoTarifaFaixa.getNumeroConsumoFaixaIFim()){

							vlFaturadoFaixa = this.calcularValorFaturadoFaixaCAER(consumoPorEconomia, vlTarifaMinimaCategoria,
											consumoTarifaFaixa.getValorConsumoTarifa());

							break;
						}

					}

					/*
					 * Inseri os valores calculados no objeto de faixas
					 * -----------------------------------------------------------------
					 */

					CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = new CalcularValoresAguaEsgotoFaixaHelper();

					calcularValoresAguaEsgotoFaixaHelper.setIdConsumoTarifaFaixa(consumoTarifaFaixa.getId());
					/*
					 * calcularValoresAguaEsgotoFaixaHelper
					 * .setLimiteInicialConsumoFaixa(limiteInicialConsumoFaixa);
					 * calcularValoresAguaEsgotoFaixaHelper
					 * .setLimiteFinalConsumoFaixa(limiteFinalConsumoFaixa);
					 * calcularValoresAguaEsgotoFaixaHelper
					 * .setValorTarifaFaixa(vlTarifaFaixa);
					 */

					if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){

						/*
						 * calcularValoresAguaEsgotoFaixaHelper
						 * .setConsumoFaturadoAguaFaixa(consumoFaturadoFaixa);
						 */
						calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoAguaFaixa(vlFaturadoFaixa);

					}else{

						/*
						 * calcularValoresAguaEsgotoFaixaHelper
						 * .setConsumoFaturadoEsgotoFaixa(consumoFaturadoFaixa);
						 */
						calcularValoresAguaEsgotoFaixaHelper.setValorFaturadoEsgotoFaixa(vlFaturadoFaixa);

					}

					// ------------------------------------------------------------------

					colecaoCalcularValoresAguaEsgotoFaixaHelper.add(calcularValoresAguaEsgotoFaixaHelper);

				}
			}

			/*
			 * Calcula o valor faturado na categoria = valor por economia da categoria quantidade de
			 * economias da categoria
			 */
			if(vlFaturadoFaixa != null){
				vlFaturadoCategoria = vlFaturadoFaixa;
			}else{
				vlFaturadoCategoria = vlEconomiaCategoria.multiply(new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));
			}

			/*
			 * Calcula o consumo faturado na categoria = consumo por economia da categoria *
			 * quantidade de economias da categoria
			 */
			consumoFaturadoCategoria = consumoEconomiaCategoria * categoria.getQuantidadeEconomiasCategoria().intValue();

			// --------------------------------------------------------
			// Gerando o novo objeto
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = new CalcularValoresAguaEsgotoHelper();

			// Carregando o id da categoria no objeto
			calcularValoresAguaEsgotoHelper.setIdCategoria(categoria.getId());

			// Carregando a descricao da categoria no objeto
			calcularValoresAguaEsgotoHelper.setDescricaoCategoria(categoria.getDescricao());

			// Carrega a quantidade de economias da categoria
			calcularValoresAguaEsgotoHelper.setQuantidadeEconomiasCategoria(categoria.getQuantidadeEconomiasCategoria());

			// Carregando o id do consumoTarifaCategoria no objeto
			calcularValoresAguaEsgotoHelper.setIdConsumoTarifaCategoria(consumoTarifaCategoria.getId());

			if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){

				calcularValoresAguaEsgotoHelper.setValorFaturadoAguaCategoria(vlFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoFaturadoAguaCategoria(consumoFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setValorTarifaMinimaAguaCategoria(vlTarifaMinimaCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoMinimoAguaCategoria(consumoMinimoCategoria);

			}else{

				// Calculando com o percentual de esgoto
				BigDecimal result = percentualEsgoto.divide(new BigDecimal("100"), 2, BigDecimal.ROUND_HALF_UP);

				// Valor faturado de esgoto
				vlFaturadoCategoria = vlFaturadoCategoria.multiply(result);
				vlFaturadoCategoria = vlFaturadoCategoria.setScale(2, BigDecimal.ROUND_HALF_UP);

				// Valor da tarifa mínima de esgoto
				vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.multiply(result);
				vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.setScale(2, BigDecimal.ROUND_HALF_UP);

				calcularValoresAguaEsgotoHelper.setValorFaturadoEsgotoCategoria(vlFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoFaturadoEsgotoCategoria(consumoFaturadoCategoria);
				calcularValoresAguaEsgotoHelper.setValorTarifaMinimaEsgotoCategoria(vlTarifaMinimaCategoria);
				calcularValoresAguaEsgotoHelper.setConsumoMinimoEsgotoCategoria(consumoMinimoCategoria);

			}

			// Carregando a coleção com os valores referentes as faixas
			calcularValoresAguaEsgotoHelper.setFaixaTarifaConsumo(colecaoCalcularValoresAguaEsgotoFaixaHelper);

			colecaoRetorno.add(calcularValoresAguaEsgotoHelper);
		}

		return colecaoRetorno;

	}

	public BigDecimal calcularValorFaturadoFaixaCAER(Integer consumoFaturado, BigDecimal valorTarifaMinimaCategoria,
					BigDecimal valorTarifaFaixa){

		// Legenda: x = consumoFaturado; NI = valorTarifaMinima

		BigDecimal retorno = new BigDecimal("0");

		Integer CONSUMO_SUPERIOR = 201;

		// Consumidores Taxados
		if(consumoFaturado < CONSUMO_SUPERIOR){

			BigDecimal divisor = new BigDecimal("10000");
			BigDecimal multiplicadorExp = new BigDecimal("7");

			// NI
			if(consumoFaturado <= 10){
				retorno = valorTarifaMinimaCategoria;
			}
			// NI(7x² + valorTarifaFaixa * x) / 10000
			else{

				BigDecimal parcial = new BigDecimal(consumoFaturado * consumoFaturado);
				parcial = parcial.multiply(multiplicadorExp);

				BigDecimal parcial2 = valorTarifaFaixa.multiply(new BigDecimal(consumoFaturado));

				BigDecimal parcialFinal = parcial.add(parcial2);

				parcialFinal = valorTarifaMinimaCategoria.multiply(parcialFinal);

				retorno = parcialFinal.divide(divisor);
			}
		}
		// Consumo Superior = NI(valorTarifaFaixa * x - 11,2)
		else{

			BigDecimal valor1 = new BigDecimal("11.2");

			BigDecimal parcial = valorTarifaFaixa.multiply(new BigDecimal(consumoFaturado));
			parcial = parcial.subtract(valor1);

			retorno = valorTarifaMinimaCategoria.multiply(parcial);
		}

		return retorno;
	}

	/**
	 * @author Raphael Rossiter
	 * @date 30/10/2006
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarContaRetificacao(Integer idConta) throws ControladorException{

		Conta retorno = null;
		Object[] arrayConta = null;

		try{

			arrayConta = repositorioFaturamento.pesquisarContaRetificacao(idConta);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(arrayConta != null){

			retorno = new Conta();

			retorno.setId((Integer) arrayConta[0]);
			retorno.setDataVencimentoConta((Date) arrayConta[1]);
			retorno.setReferencia((Integer) arrayConta[2]);

			if(arrayConta[3] != null){
				retorno.setReferenciaContabil((Integer) arrayConta[3]);
			}

			if(arrayConta[4] != null){
				retorno.setConsumoAgua((Integer) arrayConta[4]);
			}

			if(arrayConta[5] != null){
				retorno.setConsumoEsgoto((Integer) arrayConta[5]);
			}

			retorno.setValorAgua((BigDecimal) arrayConta[6]);
			retorno.setValorEsgoto((BigDecimal) arrayConta[7]);
			retorno.setDebitos((BigDecimal) arrayConta[8]);
			retorno.setValorCreditos((BigDecimal) arrayConta[9]);

			if(arrayConta[10] != null){
				retorno.setValorImposto((BigDecimal) arrayConta[10]);
			}

			if(arrayConta[11] != null){
				retorno.setDataValidadeConta((Date) arrayConta[11]);
			}

			if(arrayConta[12] != null){
				retorno.setLote((Short) arrayConta[12]);
			}

			if(arrayConta[13] != null){
				retorno.setSubLote((Short) arrayConta[13]);
			}

			DebitoCreditoSituacao debitoCreditoSituacaoAtual = new DebitoCreditoSituacao();
			debitoCreditoSituacaoAtual.setId((Integer) arrayConta[14]);
			debitoCreditoSituacaoAtual.setDescricaoDebitoCreditoSituacao((String) arrayConta[42]);
			retorno.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAtual);

			Localidade localidadeConta = new Localidade();
			localidadeConta.setId((Integer) arrayConta[15]);
			retorno.setLocalidade(localidadeConta);

			SetorComercial setorComercialConta = new SetorComercial();
			setorComercialConta.setId((Integer) arrayConta[18]);
			setorComercialConta.setCodigo((Integer) arrayConta[19]);

			Quadra quadraConta = new Quadra();
			quadraConta.setId((Integer) arrayConta[16]);
			quadraConta.setNumeroQuadra((Integer) arrayConta[17]);
			quadraConta.setSetorComercial(setorComercialConta);

			retorno.setQuadraConta(quadraConta);

			retorno.setIndicadorCobrancaMulta((Short) arrayConta[20]);

			ConsumoTarifa consumoTarifa = new ConsumoTarifa();
			consumoTarifa.setId((Integer) arrayConta[21]);

			retorno.setConsumoTarifa(consumoTarifa);

			if(arrayConta[22] != null){
				ImovelPerfil imovelPerfilConta = new ImovelPerfil();
				imovelPerfilConta.setId((Integer) arrayConta[22]);
				retorno.setImovelPerfil(imovelPerfilConta);
			}

			LigacaoAguaSituacao ligacaoAguaSituacaoConta = new LigacaoAguaSituacao();
			ligacaoAguaSituacaoConta.setId((Integer) arrayConta[23]);

			retorno.setLigacaoAguaSituacao(ligacaoAguaSituacaoConta);

			LigacaoEsgotoSituacao ligacaoEsgotoSituacaoConta = new LigacaoEsgotoSituacao();
			ligacaoEsgotoSituacaoConta.setId((Integer) arrayConta[24]);
			ligacaoEsgotoSituacaoConta.setIndicadorFaturamentoSituacao((Short) arrayConta[47]);

			retorno.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacaoConta);

			Imovel imovelConta = new Imovel();
			imovelConta.setId((Integer) arrayConta[25]);

			ImovelPerfil imovelPerfilImovel = new ImovelPerfil();
			imovelPerfilImovel.setId((Integer) arrayConta[26]);
			imovelConta.setImovelPerfil(imovelPerfilImovel);

			if(arrayConta[39] != null){
				imovelConta.setIndicadorDebitoConta((Short) arrayConta[39]);
			}

			Localidade localidadeImovel = new Localidade();
			localidadeImovel.setId((Integer) arrayConta[27]);
			imovelConta.setLocalidade(localidadeImovel);

			SetorComercial setorComercialImovel = new SetorComercial();
			setorComercialImovel.setId((Integer) arrayConta[30]);
			setorComercialImovel.setCodigo((Integer) arrayConta[31]);
			imovelConta.setSetorComercial(setorComercialImovel);

			Quadra quadraImovel = new Quadra();
			quadraImovel.setId((Integer) arrayConta[28]);
			quadraImovel.setNumeroQuadra((Integer) arrayConta[29]);
			imovelConta.setQuadra(quadraImovel);

			LigacaoAguaSituacao ligacaoAguaSituacaoImovel = new LigacaoAguaSituacao();
			ligacaoAguaSituacaoImovel.setId((Integer) arrayConta[32]);
			ligacaoAguaSituacaoImovel.setDescricao((String) arrayConta[33]);
			imovelConta.setLigacaoAguaSituacao(ligacaoAguaSituacaoImovel);

			LigacaoEsgotoSituacao ligacaoEsgotoSituacaoImovel = new LigacaoEsgotoSituacao();
			ligacaoEsgotoSituacaoImovel.setId((Integer) arrayConta[34]);
			ligacaoEsgotoSituacaoImovel.setDescricao((String) arrayConta[35]);
			imovelConta.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacaoImovel);

			ConsumoTarifa consumoTarifaImovel = new ConsumoTarifa();
			consumoTarifaImovel.setId((Integer) arrayConta[36]);
			imovelConta.setConsumoTarifa(consumoTarifaImovel);

			// Rota
			Rota rota = null;

			if(arrayConta[47] != null){
				rota = new Rota();
				rota.setId((Integer) arrayConta[48]);

				// Grupo de Faturamento
				FaturamentoGrupo faturamentoGrupo = null;

				if(arrayConta[48] != null){
					faturamentoGrupo = new FaturamentoGrupo();
					faturamentoGrupo.setId((Integer) arrayConta[49]);
					faturamentoGrupo.setAnoMesReferencia((Integer) arrayConta[54]);
				}

				rota.setFaturamentoGrupo(faturamentoGrupo);
			}

			imovelConta.setRota(rota);

			retorno.setDataVencimentoOriginal((Date) arrayConta[37]);

			if(arrayConta[41] != null){
				retorno.setDataInclusao((Date) arrayConta[41]);
			}

			if(arrayConta[43] != null){
				ContaMotivoRetificacao contaMotivoRetificacao = new ContaMotivoRetificacao();
				contaMotivoRetificacao.setId((Integer) arrayConta[43]);
				retorno.setContaMotivoRetificacao(contaMotivoRetificacao);
			}

			BigDecimal percentualLigacaoEsgoto = null;
			try{
				percentualLigacaoEsgoto = repositorioFaturamento.obterPercentualLigacaoEsgotoImovel(imovelConta.getId());

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
			if(percentualLigacaoEsgoto != null){
				LigacaoEsgoto ligacaoEsgoto = new LigacaoEsgoto();
				ligacaoEsgoto.setPercentual(percentualLigacaoEsgoto);
				imovelConta.setLigacaoEsgoto(ligacaoEsgoto);
				retorno.setPercentualEsgoto(percentualLigacaoEsgoto);
			}else{
				retorno.setPercentualEsgoto((BigDecimal) arrayConta[38]);
			}

			retorno.setIndicadorDebitoConta((Short) arrayConta[39]);

			retorno.setCreditoConsumo((Integer) arrayConta[40]);

			// CodigoSetorComercial
			if(arrayConta[30] != null){
				retorno.setCodigoSetorComercial((Integer) arrayConta[30]);
			}

			// Quadra
			if(arrayConta[28] != null){
				retorno.setQuadra((Integer) arrayConta[28]);
			}

			// IndicadorAlteracaoVencimento
			if(arrayConta[44] != null){
				retorno.setIndicadorAlteracaoVencimento((Short) arrayConta[44]);
			}

			SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd");

			// DataRetificacao
			if(arrayConta[45] != null){

				String retificacao = String.valueOf(arrayConta[45]);

				Date dataRetificacao;

				try{
					dataRetificacao = formatoData.parse(retificacao);
				}catch(java.text.ParseException e){
					dataRetificacao = null;
				}

				retorno.setDataRetificacao(dataRetificacao);
			}

			// DataEmissao
			if(arrayConta[46] != null){
				String emissao = String.valueOf(arrayConta[46]);

				Date dataEmissao;

				try{
					dataEmissao = formatoData.parse(emissao);
				}catch(java.text.ParseException e){
					dataEmissao = null;
				}

				retorno.setDataEmissao(dataEmissao);
			}

			if(arrayConta[50] != null){
				retorno.setIndicadorPagamento((Short) arrayConta[50]);
			}

			if(arrayConta[51] != null){
				retorno.setIndicadorCobrancaAdministrativa((Short) arrayConta[51]);
			}

			if(arrayConta[52] != null){
				retorno.setIndicadorRemuneraCobrancaAdministrativa((Short) arrayConta[52]);
			}

			if(arrayConta[53] != null){

				ContaMotivoRevisao contaMotivoRevisao = new ContaMotivoRevisao();
				contaMotivoRevisao.setId(Util.obterInteger(arrayConta[53].toString()));
				retorno.setContaMotivoRevisao(contaMotivoRevisao);
			}

			if(arrayConta[55] != null){

				retorno.setConsumoPoco((Integer) arrayConta[55]);
			}

			retorno.setImovel(imovelConta);

		}

		this.verificarContaComTarifaErradaAjusteFaturamento(retorno);

		return retorno;
	}

	/**
	 * Este método se destina a validar todas as situações e particularidades da inserir guia de
	 * pagamento no momento da exibição.
	 * [FS0003] Validar registro de atendimento [FS0007] Validar ordem de servico.
	 * 
	 * @author Rafael Pinto
	 * @date 02/11/2006
	 * @param RegistroAtendimento
	 *            ,OrdemServico,idImovel,idCliente
	 */
	public void validarExibirInserirGuiaPagamento(RegistroAtendimento ra, OrdemServico ordemServico, Integer idImovel, Integer idCliente)
					throws ControladorException{

		// [FS0003] Validar registro de atendimento
		if(ra != null){

			Imovel imovel = ra.getImovel();

			// Caso tenha informado o imóvel e não exista imóvel associado ao
			// Registro Atendimento
			if(idImovel != null && imovel == null){
				throw new ControladorException("atencao.registro_atendimento.nao.associado.imovel");
			}

			// Caso tenha informado o imóvel e o imóvel que esteja associado ao
			// Registro Atendimento
			// seja diferente do imóvel informado
			if(idImovel != null && imovel != null && imovel.getId().intValue() != idImovel.intValue()){
				throw new ControladorException("atencao.registro_atendimento.associado.imovel", null, "" + imovel.getId());
			}

			// Caso tenha informado o cliente e o cliente informado não conste
			// na relação
			// de clientes do Registro Atendimento
			if(idCliente != null){

				FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();

				filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.CLIENTE_ID, idCliente));

				filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID, ra.getId()));

				// Pesquisa de acordo com os parâmetros informados no filtro
				Collection colecaoRegistros = this.getControladorUtil().pesquisar(filtro, RegistroAtendimentoSolicitante.class.getName());

				// Verifica se a pesquisa retornou algum objeto para a coleção
				if(colecaoRegistros == null || colecaoRegistros.isEmpty()){
					throw new ControladorException("atencao.registro_atendimento.associado.cliente");
				}
			}

			// Caso a situação do Registro de Atendimento não seja encerrada
			if(ra.getAtendimentoMotivoEncerramento() != null){
				throw new ControladorException("atencao.registro_atendimento.esta.encerrado");
			}

			// Caso o tipo de solicitação do registro atendimento
			// não permita a geração de débito a cobrar
			if(ra.getSolicitacaoTipoEspecificacao().getIndicadorGeracaoDebito().intValue() == ConstantesSistema.NAO.intValue()){
				throw new ControladorException("atencao.registro_atendimento.nao.permite.guia.pagamento");
			}

			// [FS0007] Validar ordem de servico.
		}else if(ordemServico != null){

			// Caso a Ordem de Serviço não esteja associada a um Registro de
			// Atendimento
			if(ordemServico.getRegistroAtendimento() == null || ordemServico.getRegistroAtendimento().getId() == null){
				throw new ControladorException("atencao.ordem_servico.nao.esta.associado.registro_atendimento");
			}

			RegistroAtendimento registroAtendimento = ordemServico.getRegistroAtendimento();
			Imovel imovel = registroAtendimento.getImovel();

			// Caso a Ordem de Serviço esteja associada a um Registro
			// Atendimento,o imóvel tenha sido informado
			// e não existe um imóvel associado ao Registro Atendimento
			if(idImovel != null && imovel == null){
				throw new ControladorException("atencao.ordem_servico.imovel.registro_atendimento.nao.associado");
			}

			// Caso tenha informado o imóvel e o imóvel que esteja associado ao
			// Registro Atendimento
			// seja diferente do imóvel informado
			if(idImovel != null && imovel != null && imovel.getId().intValue() != idImovel.intValue()){
				throw new ControladorException("atencao.os.registro_atendimento.associado.imovel", null, "" + imovel.getId());
			}

			// Caso tenha informado o cliente e o cliente informado não conste
			// na relação
			// de clientes do Registro Atendimento
			if(idCliente != null){

				FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();

				filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.CLIENTE_ID, idCliente));

				filtro.adicionarParametro(new ParametroSimples(FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
								registroAtendimento.getId()));

				// Pesquisa de acordo com os parâmetros informados no filtro
				Collection colecaoRegistros = this.getControladorUtil().pesquisar(filtro, RegistroAtendimentoSolicitante.class.getName());

				// Verifica se a pesquisa retornou algum objeto para a coleção
				if(colecaoRegistros == null || colecaoRegistros.isEmpty()){
					throw new ControladorException("atencao.os.registro_atendimento.associado.cliente");
				}
			}
		}
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * [SB00010] Gerar Linhas da Descrição dos Serviços e Tarifas
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected List gerarLinhasDescricaoServicoTarifasRelatorio(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao, boolean contaHistorico, Conta contaCaucionada,
					Collection<Collection<ContaCategoriaConsumoFaixa>> colecaoContaCategoriaConsumoFaixa,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		Collection<ContaLinhasDescricaoServicosTarifasTotalHelper> colecaoLinhasDescricaoServicosTarifasTotal = new ArrayList<ContaLinhasDescricaoServicosTarifasTotalHelper>();

		// caso o valor da agua da conta seja maior que zero
		if(emitirContaHelper.getValorAgua() != null && emitirContaHelper.getValorAgua().compareTo(BigDecimal.ZERO) == 1){

			if(!contaHistorico){
				// [SB0011] - Gerar Linhas da Tarifa de Água
				colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasTarifaAguaRelatorio(emitirContaHelper, consumoRateio,
								parmsMedicaoHistorico, tipoMedicao, colecaoLinhasDescricaoServicosTarifasTotal, contaCaucionada,
								colecaoContaCategoriaConsumoFaixa, indicadorOperacaoCaucionamento);
			}else{
				colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasTarifaAguaRelatorioContaHistorico(emitirContaHelper, consumoRateio,
								parmsMedicaoHistorico, tipoMedicao, colecaoLinhasDescricaoServicosTarifasTotal, contaCaucionada,
								colecaoContaCategoriaConsumoFaixa, indicadorOperacaoCaucionamento);
			}

		}

		// caso o valor de água de esgoto seja maior que zero
		if(emitirContaHelper.getValorEsgoto() != null && emitirContaHelper.getValorEsgoto().compareTo(BigDecimal.ZERO) == 1){

			// [SB0012] - Gerar Linhas da tarifa de Esgoto
			colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasTarifaEsgotoRelatorio(emitirContaHelper,
							colecaoLinhasDescricaoServicosTarifasTotal);

		}

		// // caso o valor de debitos cobrados da conta seja maior que zero
		if(emitirContaHelper.getDebitos() != null && emitirContaHelper.getDebitos().compareTo(BigDecimal.ZERO) == 1){

			// [SB0013] - Gerar Linhas de Débitos Cobrados
			colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasDebitoCobradosRelatorio(emitirContaHelper,
							colecaoLinhasDescricaoServicosTarifasTotal, contaHistorico, contaCaucionada, indicadorOperacaoCaucionamento);

		}

		// caso o valor de créditos realizados seja maior que zero
		if(emitirContaHelper.getValorCreditos() != null && emitirContaHelper.getValorCreditos().compareTo(BigDecimal.ZERO) == 1){
			// [SB0014] - Gerar Linhas de Crédito Realizado
			colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasCreditosRealizadosRelatorio(emitirContaHelper,
							colecaoLinhasDescricaoServicosTarifasTotal, contaHistorico, contaCaucionada, indicadorOperacaoCaucionamento);

		}

		// caso o valor dos impostos retidos seja maior que zero
		if(emitirContaHelper.getValorImpostos() != null && emitirContaHelper.getValorImpostos().compareTo(BigDecimal.ZERO) == 1){
			// [SB0015] - Gerar Linhas dos Impostos Retidos
			colecaoLinhasDescricaoServicosTarifasTotal = gerarLinhasImpostosRetidosRelatorio(emitirContaHelper,
							colecaoLinhasDescricaoServicosTarifasTotal, contaHistorico);

		}

		return new ArrayList<ContaLinhasDescricaoServicosTarifasTotalHelper>(colecaoLinhasDescricaoServicosTarifasTotal);

	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * [SB00011] Gerar Linhas da Tarifa de Água
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * @author Virgínia Melo
	 * @date 13/01/2009 Correções realizadas.
	 * @author eduardo henrique
	 * @date 20/01/2009 Alteração para inclusão do valor da faixa para 4 casas decimais e para obter
	 *       corretamente o valor da 1a faixa.
	 * @author eduardo henrique
	 * @date 26/01/2009 Alteração na exibição do valor do Consumo Mínimo para 4 casas decimais.
	 * @author Virgínia Melo
	 * @date 09/03/2009 Alteração para multiplicar o valor da 1a faixa pela quantidade de economias.
	 *       TODO Refatorar método na seção que monta as linhas de Serviços/Tarifas da Conta
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasTarifaAguaRelatorio(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao, Collection colecaoLinhasDescricaoServicosTarifasTotal,
					Conta contaCaucionada,
					Collection<Collection<ContaCategoriaConsumoFaixa>> colecaoContaCategoriaConsumoFaixaCaucionamento,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;

		String descricaoServicosTarifas1 = "";

		// -- Linha 1 --//
		descricaoServicosTarifas1 = "AGUA";
		contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
		contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		Collection colecaoContaCategoriaComFaixas = new ArrayList();

		if(indicadorOperacaoCaucionamento){
			Collection<ContaCategoria> colecaoContaCategoria = contaCaucionada.getContaCategorias();

			if(!Util.isVazioOuBranco(contaCaucionada) && !Util.isVazioOuBranco(colecaoContaCategoria)){
				for(ContaCategoria contaCategoria : colecaoContaCategoria){
					colecaoContaCategoriaComFaixas.add(contaCategoria);
				}
			}
		}else{
			try{
				colecaoContaCategoriaComFaixas = repositorioFaturamento.pesquisarContaCategoria(emitirContaHelper.getIdConta());
			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

		if(colecaoContaCategoriaComFaixas != null && !colecaoContaCategoriaComFaixas.isEmpty()){
			Iterator iteratorContaCategoriaComFaixas = colecaoContaCategoriaComFaixas.iterator();
			while(iteratorContaCategoriaComFaixas.hasNext()){
				ContaCategoria contaCategoria = (ContaCategoria) iteratorContaCategoriaComFaixas.next();

				String descricaoServicosTarifas2 = "";

				// -- Linha 2 --//
				descricaoServicosTarifas2 = " ";

				// descricao da categoria
				descricaoServicosTarifas2 = descricaoServicosTarifas2
								+ Util.completaString(contaCategoria.getComp_id().getCategoria().getDescricao(), 13);

				// quantidade de economias
				descricaoServicosTarifas2 = descricaoServicosTarifas2
								+ Util.adicionarZerosEsquedaNumero(3, "" + contaCategoria.getQuantidadeEconomia());

				if(contaCategoria.getQuantidadeEconomia() == 1){
					descricaoServicosTarifas2 = descricaoServicosTarifas2 + "  UNIDADE ";
				}else{
					descricaoServicosTarifas2 = descricaoServicosTarifas2 + "  UNIDADES ";
				}

				contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
				contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
				contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
				contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
				colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

				// -- Linha 3 --//
				contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
				String descricaoServicosTarifas3 = "";
				String consumoFaixa3 = "";
				String valor3 = "";

				// recupera a coleção de conta categoria consumo faixa
				Collection colecaoContaCategoriaConsumoFaixa = new ArrayList();

				if(indicadorOperacaoCaucionamento){
					if(!Util.isVazioOrNulo(colecaoContaCategoriaConsumoFaixaCaucionamento)){
						for(Collection<ContaCategoriaConsumoFaixa> colecaoConsumoFaixa : colecaoContaCategoriaConsumoFaixaCaucionamento){
							if(!Util.isVazioOrNulo(colecaoConsumoFaixa)){
								for(ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa : colecaoConsumoFaixa){
									if(contaCategoria
													.getComp_id()
													.getCategoria()
													.getId()
													.equals(contaCategoriaConsumoFaixa.getContaCategoria().getComp_id().getCategoria()
																	.getId())){
										colecaoContaCategoriaConsumoFaixa.add(contaCategoriaConsumoFaixa);

										Collections.sort((List) colecaoContaCategoriaConsumoFaixa, new Comparator() {

											public int compare(Object a, Object b){

												Integer numeroConsumoFaixaInicio1 = ((ContaCategoriaConsumoFaixa) a)
																.getConsumoFaixaInicio();
												Integer numeroConsumoFaixaInicio2 = ((ContaCategoriaConsumoFaixa) b)
																.getConsumoFaixaInicio();

												return numeroConsumoFaixaInicio1.compareTo(numeroConsumoFaixaInicio2);

											}
										});
									}
								}
							}
						}
					}
				}else{
					try{
						colecaoContaCategoriaConsumoFaixa = repositorioFaturamento.pesquisarContaCategoriaFaixas(
										emitirContaHelper.getIdConta(), contaCategoria.getComp_id().getCategoria().getId());
					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				}

				// 2.3.1 caso existam faixas de consumo para conta/categoria
				if(colecaoContaCategoriaConsumoFaixa != null && !colecaoContaCategoriaConsumoFaixa.isEmpty()){

					// Caso o imóvel tenha tido consumo acima do mínimo, na Categoria.
					Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa.iterator();

					while(iteratorContaCategoriaConsumoFaixa.hasNext()){
						ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) iteratorContaCategoriaConsumoFaixa
										.next();

						// Consumo mínimo de água para a categoria por economia
						BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal(contaCategoria.getQuantidadeEconomia().toString(), 4);

						// linha da tarifa mínima
						if(contaCategoriaConsumoFaixa.getConsumoFaixaInicio() == 0){
							descricaoServicosTarifas3 = " ATE ";

							BigDecimal consumoMinimoAgua = null;
							if(contaCategoria.getConsumoMinimoAgua() != null){
								consumoMinimoAgua = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getConsumoMinimoAgua());
							}
							BigDecimal consumoMinimaBigDecimal = new BigDecimal("0.00");
							if(consumoMinimoAgua != null && qtdEconomia != null && qtdEconomia.compareTo(BigDecimal.ZERO) > 0){
								consumoMinimaBigDecimal = consumoMinimoAgua.divide(qtdEconomia, 2, RoundingMode.UP);
							}
							String consumoMinima = "" + consumoMinimaBigDecimal.intValue();

							descricaoServicosTarifas3 = descricaoServicosTarifas3 + Util.completaStringComEspacoAEsquerda(consumoMinima, 6);

							descricaoServicosTarifas3 = descricaoServicosTarifas3 + " M3" + Util.completaString("", 7);
							descricaoServicosTarifas3 = descricaoServicosTarifas3 + "- R$ ";

							// Consumo mínimo de água para a categoria
							if(contaCategoria.getConsumoMinimoAgua() != null && !contaCategoria.getConsumoMinimoAgua().equals("")){
								consumoFaixa3 = Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoMinimoAgua(), 4);
							}else{
								consumoFaixa3 = Util.completaStringComEspacoAEsquerda("", 4);
							}
							consumoFaixa3 = consumoFaixa3 + " M3";

							// valor da tarifa mínima de agua para categoria
							Integer consumoFaixaMinimaFinal = contaCategoriaConsumoFaixa.getConsumoFaixaFim();
							if(consumoFaixaMinimaFinal == null){
								consumoFaixaMinimaFinal = Integer.valueOf(0);
							}

							// Para obter o valor do mínimo 'por unidade', obtêm-se a faixa final e
							// multiplica-se pela Tarifa
							BigDecimal valorTarifaMinimaBigDecimal = BigDecimal.ZERO;
							if(contaCategoriaConsumoFaixa.getValorTarifaFaixa() != null && qtdEconomia != null){
								valorTarifaMinimaBigDecimal = contaCategoriaConsumoFaixa.getValorTarifaFaixa().setScale(4,
												BigDecimal.ROUND_DOWN);
							}

							String valorTarifaMinima = Util.completaStringComEspacoAEsquerda(
											"" + Util.formatarMoedaReal(valorTarifaMinimaBigDecimal, 4), 7);

							descricaoServicosTarifas3 = descricaoServicosTarifas3 + valorTarifaMinima + " (POR UNIDADE)";

							BigDecimal valorAguaCategoria = BigDecimal.ZERO;
							if(contaCategoria.getValorTarifaMinimaAgua() != null){
								if(contaCategoriaConsumoFaixa.getValorTarifaFaixa() == null){
									throw new ControladorException("atencao.valor.tarifa.faixa.nulo");
								}
								valorAguaCategoria = contaCategoriaConsumoFaixa.getValorTarifaFaixa().multiply(
												new BigDecimal(consumoFaixaMinimaFinal.intValue()));

								// Multiplica o valor pela quantidade de economia
								valorAguaCategoria = valorAguaCategoria.multiply(qtdEconomia).setScale(Parcelamento.CASAS_DECIMAIS,
												BigDecimal.ROUND_DOWN);
							}

							valor3 = Util.formatarMoedaReal(valorAguaCategoria);

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas3);
							contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa3.trim());
							contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor3);
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
						}
						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						String descricaoServicosTarifas4 = "";
						String consumoFaixa4 = "";
						String valor4 = "";

						// -- Linha 4 --//
						descricaoServicosTarifas4 = " ";

						// caso a faixa seja a ultima da tarifa de consumo
						if(contaCategoriaConsumoFaixa.getConsumoFaixaFim().equals(99999999)){
							// Consumo inicial da faixa menos 1 m3
							String consumoInicialFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaInicio() - 1);

							// valor da tarifa na faixa
							String valorTarifaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorTarifaFaixa(), 4);

							descricaoServicosTarifas4 = descricaoServicosTarifas4 + "ACIMA DE";
							descricaoServicosTarifas4 = descricaoServicosTarifas4
											+ Util.completaStringComEspacoAEsquerda(consumoInicialFaixa, 3);
							descricaoServicosTarifas4 = descricaoServicosTarifas4 + " M3  - R$ ";
							descricaoServicosTarifas4 = descricaoServicosTarifas4
											+ Util.completaStringComEspacoAEsquerda(valorTarifaFaixa, 6);
							descricaoServicosTarifas4 = descricaoServicosTarifas4 + " POR M3";

							// consumo da agua na faixa

							// consumoFaixa4 = Util
							// .completaStringComEspacoAEsquerda(""
							// + contaCategoriaConsumoFaixa
							// .getConsumoAgua(), 6)
							consumoFaixa4 = Util.completaStringComEspacoAEsquerda("" + contaCategoriaConsumoFaixa.getConsumoAgua(), 6)
											+ " M3";

							// valor da agua na faixa
							BigDecimal valorAguaFaixa = contaCategoriaConsumoFaixa.getValorAgua().setScale(Parcelamento.CASAS_DECIMAIS,
											BigDecimal.ROUND_DOWN);

							valor4 = "" + Util.formatarMoedaReal(valorAguaFaixa);

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas4);
							contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa4.trim());
							contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor4);
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

						}else{

							if(contaCategoriaConsumoFaixa.getConsumoFaixaInicio() > 0){

								// Consumo inicial da faixa
								String consumoInicialFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaInicio());

								// consumo final da faixa
								String consumoFinalFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaFim());

								// valor da tarifa na faixa
								String valorTarifaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorTarifaFaixa(), 4);

								descricaoServicosTarifas4 = descricaoServicosTarifas4
												+ Util.completaStringComEspacoAEsquerda(consumoInicialFaixa, 3) + " M3 A ";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
												+ Util.completaStringComEspacoAEsquerda(consumoFinalFaixa, 6) + " M3";
								descricaoServicosTarifas4 = descricaoServicosTarifas4 + "   - R$ ";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
												+ Util.completaStringComEspacoAEsquerda(valorTarifaFaixa, 6) + " POR M3";

								// consumo de Agua na faixa
								// consumoFaixa4 = Util.completaStringComEspacoAEsquerda("" +
								// contaCategoriaConsumoFaixa.getConsumoAgua()
								// * contaCategoria.getQuantidadeEconomia(), 6)
								// + " M3";

								consumoFaixa4 = Util.completaStringComEspacoAEsquerda("" + contaCategoriaConsumoFaixa.getConsumoAgua(), 6)
												+ " M3";

								// valor da agua na faixa
								// BigDecimal valorAguaFaixa =
								// contaCategoriaConsumoFaixa.getValorAgua().multiply(qtdEconomia).setScale(
								// Parcelamento.CASAS_DECIMAIS, BigDecimal.ROUND_DOWN);

								BigDecimal valorAguaFaixa = contaCategoriaConsumoFaixa.getValorAgua().setScale(Parcelamento.CASAS_DECIMAIS,
												BigDecimal.ROUND_DOWN);

								valor4 = "" + Util.formatarMoedaReal(valorAguaFaixa);

								// String valorAguaFaixa = Util
								// .formatarMoedaReal(contaCategoriaConsumoFaixa
								// .getValorAgua());
								//
								// valor4 = valorAguaFaixa;

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas4);
								contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa4.trim());
								contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor4);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
							}
						}
					}

				}else{
					// 2.3.2.
					// linha da tarifa mínima
					descricaoServicosTarifas3 = " CONSUMO DE ÁGUA  ATE ";

					// Consumo mínimo de água para a categoria por economia
					BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getQuantidadeEconomia());

					BigDecimal consumoMinimoAgua = null;
					if(contaCategoria.getConsumoMinimoAgua() != null){
						consumoMinimoAgua = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getConsumoMinimoAgua());
					}
					BigDecimal consumoMinimaBigDecimal = new BigDecimal("0.00");
					if(consumoMinimoAgua != null && qtdEconomia != null && qtdEconomia.compareTo(BigDecimal.ZERO) > 0){
						consumoMinimaBigDecimal = consumoMinimoAgua.divide(qtdEconomia, 2, RoundingMode.UP);
					}
					String consumoMinimo = String.valueOf(consumoMinimaBigDecimal.intValue());

					descricaoServicosTarifas3 = descricaoServicosTarifas3 + Util.completaStringComEspacoAEsquerda(consumoMinimo, 6);

					descricaoServicosTarifas3 = descricaoServicosTarifas3 + " M3 - R$ ";

					// valor da tarifa minima de agua para a categoria por economia
					BigDecimal valorTarifaMinimaBigDecimal = BigDecimal.ZERO;
					if(contaCategoria.getValorTarifaMinimaAgua() != null && qtdEconomia != null){
						valorTarifaMinimaBigDecimal = contaCategoria.getValorTarifaMinimaAgua().divide(qtdEconomia, 4,
										RoundingMode.HALF_DOWN);
					}

					String valorTarifaMinima = Util.completaStringComEspacoAEsquerda(
									(Util.formatarMoedaReal(valorTarifaMinimaBigDecimal, 4)).toString(), 7);

					descricaoServicosTarifas3 = descricaoServicosTarifas3 + valorTarifaMinima + " (POR UNIDADE)";

					consumoFaixa3 = Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoAgua(), 6) + " M3";
					valor3 = Util.formatarMoedaReal(contaCategoria.getValorAgua());

					contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
					contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas3);
					contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa3.trim());
					contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor3);
					colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
				}

				// }
			}
		}

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * [SB00012] Gerar Linhas da Tarifa de Esgoto
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasTarifaEsgotoRelatorio(EmitirContaHelper emitirContaHelper,
					Collection colecaoLinhasDescricaoServicosTarifasTotal) throws ControladorException{

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();

		String descricaoServicosTarifas1 = "";
		String consumoFaixa1 = "";
		String valor1 = "";

		// StringBuilder linhasTarifaEsgoto = new StringBuilder();
		// -- Linha 1 --//
		descricaoServicosTarifas1 = "ESGOTO ";

		String indicadorExibirPercentualOuConsumoEsgoto = (String) ParametroFaturamento.P_EXIBIR_PERCENTUAL_OU_CONSUMO_ESGOTO_CONTA
						.executar();

		if(indicadorExibirPercentualOuConsumoEsgoto.equals(ConstantesSistema.ATIVO)){
			// caso o consumo de agua seja igual ao volume coletado de esgoto e o
			// valor de agua seja diferente de 0
			if((emitirContaHelper.getConsumoAgua() != null)
							&& emitirContaHelper.getConsumoAgua().equals(emitirContaHelper.getConsumoEsgoto())
							&& emitirContaHelper.getValorAgua() != null && !emitirContaHelper.getValorAgua().equals("0.00")){
				// Percentual esgoto
				String percentualEsgoto = Util.formatarMoedaReal(emitirContaHelper.getPercentualEsgotoConta());

				descricaoServicosTarifas1 = descricaoServicosTarifas1 + Util.completaStringComEspacoAEsquerda(percentualEsgoto, 6);
				descricaoServicosTarifas1 = descricaoServicosTarifas1 + " % DO VALOR DA ÁGUA";

			}else{
				// Volume coletado de esgoto
				consumoFaixa1 = Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 6);
				consumoFaixa1 = consumoFaixa1 + " M3";

			}
		}

		String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper.getValorEsgoto());
		valor1 = valorEsgoto;

		contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor1);
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * [SB0015] Gerar Linhas de Impostos Retidos
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasImpostosRetidosRelatorio(EmitirContaHelper emitirContaHelper,
					Collection colecaoLinhasDescricaoServicosTarifasTotal, boolean contaHistorico) throws ControladorException{

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;

		String descricaoServicosTarifas1 = "";

		// -- Linha 1 --//
		// Constante
		descricaoServicosTarifas1 = "DEDUCAO IMPOSTOS LEI FEDERAL N.9430 DE 27/12/1996";
		contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
		contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		// -- Linha 2 --//
		String descricaoServicosTarifas2 = "";
		String valor2 = "";
		// Completa com espaços em branco
		descricaoServicosTarifas2 = Util.completaString("", 2);
		Collection colecaoParmsImpostosDeduzidos = null;
		try{
			if(!contaHistorico){
				colecaoParmsImpostosDeduzidos = repositorioFaturamento.pesquisarParmsContaImpostosDeduzidos(emitirContaHelper.getIdConta());
			}else{
				colecaoParmsImpostosDeduzidos = repositorioFaturamento.pesquisarParmsContaImpostosDeduzidosHistorico(emitirContaHelper
								.getIdConta());
			}
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		StringBuilder descricaoAbreviadaImposto = new StringBuilder();
		BigDecimal valorImpostosTotal = new BigDecimal("0.00");
		// verifica se a coleção é diferente de nulo
		if(colecaoParmsImpostosDeduzidos != null && !colecaoParmsImpostosDeduzidos.isEmpty()){
			Iterator iteratorParmsImpostosDeduzidos = colecaoParmsImpostosDeduzidos.iterator();
			while(iteratorParmsImpostosDeduzidos.hasNext()){
				Object[] parmsImpostoDeduzido = (Object[]) iteratorParmsImpostosDeduzidos.next();
				String descricaoTipoImposto = "";
				if(parmsImpostoDeduzido[0] != null){
					descricaoTipoImposto = (String) parmsImpostoDeduzido[0];
				}
				String percentualAliquota = "";
				if(parmsImpostoDeduzido[1] != null){
					percentualAliquota = Util.formatarMoedaReal((BigDecimal) parmsImpostoDeduzido[1]);
				}
				BigDecimal valorImpostos = null;
				if(parmsImpostoDeduzido[2] != null){
					valorImpostos = (BigDecimal) parmsImpostoDeduzido[2];
				}
				// concatena a descrição abreviada do tipo de imposto com o
				// precentual de aliquota
				descricaoAbreviadaImposto.append(descricaoTipoImposto + "-" + percentualAliquota + "%");
				// Completa com espaços em branco
				descricaoAbreviadaImposto.append(" ");
				// adiciona o valor dos impostos
				valorImpostosTotal = valorImpostosTotal.add(valorImpostos);
			}
		}
		// recupera a descrição abreviada concatenada com a aliquota
		String descricaoAbreviadaConcatenada = "";
		if(descricaoAbreviadaImposto != null && !descricaoAbreviadaImposto.equals("")){
			descricaoAbreviadaConcatenada = descricaoAbreviadaImposto.toString();
		}
		descricaoServicosTarifas2 = descricaoServicosTarifas2 + descricaoAbreviadaConcatenada;
		String valorImpostosTotalString = Util.formatarMoedaReal(valorImpostosTotal);
		valor2 = valorImpostosTotalString;

		contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
		contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * [SB00013] Gerar Linhas de Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */

	protected Collection gerarLinhasDebitoCobradosRelatorio(EmitirContaHelper emitirContaHelper,
					Collection colecaoLinhasDescricaoServicosTarifasTotal, boolean contaHistorico, Conta contaCaucionada,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;

		Collection<Object[]> collectionParmsDebitoAutomatico = null;

		Collection<Integer> tiposParcelamento = Util
						.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar());

		try{

			if(!contaHistorico){
				collectionParmsDebitoAutomatico = repositorioFaturamento.listarParametrosDebitosCobradoParcelamento(
								emitirContaHelper.getIdConta(), tiposParcelamento);
			}else{
				collectionParmsDebitoAutomatico = repositorioFaturamento.listarParmsDebitoCobradoHistorico(emitirContaHelper.getIdConta(),
								tiposParcelamento);
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(collectionParmsDebitoAutomatico != null){

			Boolean mesmaPrestacao = this.existemDebitosMesmaPrestacao(collectionParmsDebitoAutomatico);
			Iterator iter = collectionParmsDebitoAutomatico.iterator();

			while(iter.hasNext()){
				Object[] parmsDebitoAutomatico = (Object[]) iter.next();

				if(parmsDebitoAutomatico != null){

					String valorDebitosCobrados = parmsDebitoAutomatico[0] != null ? Util
									.formatarMoedaReal((BigDecimal) parmsDebitoAutomatico[0]) : "";
					String numeroPrestacao = parmsDebitoAutomatico[1] != null ? String.valueOf(parmsDebitoAutomatico[1]) : "";
					String numeroTotalPrestacao = parmsDebitoAutomatico[2] != null ? String.valueOf(parmsDebitoAutomatico[2]) : "";
					Parcelamento parcelamento = parmsDebitoAutomatico[3] != null ? (Parcelamento) parmsDebitoAutomatico[3] : null;

					if((!valorDebitosCobrados.equals(""))
									&& (Util.formatarMoedaRealparaBigDecimal(valorDebitosCobrados).compareTo(BigDecimal.ZERO) == 1)){

						// 2.1.7. Caso os débitos cobrados de parcelamento tenham o mesmo número de
						// prestação (mesmo DBCB_NNPRESTACAODEBITO):
						if(mesmaPrestacao){

							// 2.1.7.1. Caso exista, em algum dos débitos cobrados, a identificação
							// do parcelamento (PARC_ID com o valor diferente de nulo):
							if(this.existeDebitoCobradoComIdParcelamento(collectionParmsDebitoAutomatico)){

								Boolean rdsDistintas = this.existemRDsDistintas(collectionParmsDebitoAutomatico);
								Boolean existeRdsIndEmissaoAssuntoConta = this
												.existemRDsIndicacaoEmissaoAssuntoConta(collectionParmsDebitoAutomatico);

								// 2.1.7.1.2. Caso existam RDs com a indicação de emissão do assunto
								// na conta (RDIR_ICEMISSAOASSUNTOCONTA=1) e sejam RDs distintas ou
								// caso não existam RDs com a indicação de emissão do assunto na
								// conta:
								if(rdsDistintas || !existeRdsIndEmissaoAssuntoConta){

									StringBuffer descricaoServicosTarifa = new StringBuffer();
									descricaoServicosTarifa.append("PARCELAMENTO DE DÉBITOS");
									descricaoServicosTarifa.append(Util.completaString("", 2));
									descricaoServicosTarifa.append("PARCELA ");
									descricaoServicosTarifa.append(Util.completaString(numeroPrestacao, 2) + "/");
									descricaoServicosTarifa.append(Util.completaString(numeroTotalPrestacao, 2));
									descricaoServicosTarifa.append(Util.completaString("", 29));
									descricaoServicosTarifa.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));
									descricaoServicosTarifa.append(Util.completaString("", 45));

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valorDebitosCobrados);
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifa
													.toString());

									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);

								}else if(existeRdsIndEmissaoAssuntoConta && !rdsDistintas){

									// 2.1.7.1.3. Caso contrário, ou seja, caso existam RDs com a
									// indicação de emissão do assunto na conta e não sejam RDs
									// distintas:

									StringBuffer descricaoServicosTarifa = new StringBuffer();
									descricaoServicosTarifa.append("PARCELAMENTO DEBITO ");

									if(parcelamento != null && parcelamento.getResolucaoDiretoria() != null){

										descricaoServicosTarifa.append(Util.completaString(parcelamento.getResolucaoDiretoria()
														.getDescricaoAssuntoAbreviada(), 3));

									}else{

										descricaoServicosTarifa.append(Util.completaString("", 3));

									}

									descricaoServicosTarifa.append(Util.completaString("", 1));
									descricaoServicosTarifa.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 9));
									descricaoServicosTarifa.append("PARCELA ");
									descricaoServicosTarifa.append(Util.completaString(numeroPrestacao, 2));
									descricaoServicosTarifa.append("/");
									descricaoServicosTarifa.append(Util.completaString(numeroTotalPrestacao, 2));
									descricaoServicosTarifa.append(Util.completaString("", 21));
									descricaoServicosTarifa.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));
									descricaoServicosTarifa.append(Util.completaString("", 45));

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valorDebitosCobrados);
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifa
													.toString());

									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);

								}

							}else{

								// 2.1.7.2. Caso contrário, ou seja, nenhum dos débitos cobrados têm
								// a identificação do parcelamento:
								StringBuffer descricaoServicosTarifa = new StringBuffer();
								descricaoServicosTarifa.append("PARCELAMENTO DE DÉBITOS");
								descricaoServicosTarifa.append(Util.completaString("", 2));
								descricaoServicosTarifa.append("PARCELA ");
								descricaoServicosTarifa.append(Util.completaString(numeroPrestacao, 2));
								descricaoServicosTarifa.append("/");
								descricaoServicosTarifa.append(Util.completaString(numeroTotalPrestacao, 2));
								descricaoServicosTarifa.append(Util.completaString("", 29));
								descricaoServicosTarifa.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));
								descricaoServicosTarifa.append(Util.completaString("", 45));

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
								contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valorDebitosCobrados);
								contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifa
												.toString());

								colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

							}

						}else{
							// 2.1.8. Caso contrário, ou seja, os débitos cobrados de parcelamento
							// não tenham o mesmo número de prestação
							// (distintos DBCB_NNPRESTACAODEBITO):

							// 2.1.8.1. Caso exista, em algum dos débitos cobrados, a identificação
							// do parcelamento (PARC_ID com o valor diferente de nulo):
							if(this.existeDebitoCobradoComIdParcelamento(collectionParmsDebitoAutomatico)){

								Boolean rdsDistintas = this.existemRDsDistintas(collectionParmsDebitoAutomatico);
								Boolean existeRdsIndEmissaoAssuntoConta = this
												.existemRDsIndicacaoEmissaoAssuntoConta(collectionParmsDebitoAutomatico);

								// 2.1.8.1.2. Caso existam RDs com a indicação de emissão do assunto
								// na conta (RDIR_ICEMISSAOASSUNTOCONTA=1) e sejam RDs distintas ou
								// caso não existam RDs com a indicação de emissão do assunto na
								// conta:
								if(rdsDistintas || !existeRdsIndEmissaoAssuntoConta){

									StringBuffer descricaoServicosTarifa = new StringBuffer();
									descricaoServicosTarifa.append("PARCELAMENTO DE DÉBITOS");
									descricaoServicosTarifa.append(Util.completaString("", 44));
									descricaoServicosTarifa.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));
									descricaoServicosTarifa.append(Util.completaString("", 45));

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valorDebitosCobrados);
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifa
													.toString());

									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);

								}else if(existeRdsIndEmissaoAssuntoConta && !rdsDistintas){

									// 2.1.8.1.3. Caso contrário, ou seja, caso existam RDs com a
									// indicação de emissão do assunto na conta e não sejam RDs
									// distintas:
									StringBuffer descricaoServicosTarifa = new StringBuffer();
									descricaoServicosTarifa.append("PARCELAMENTO DEBITO ");

									if(parcelamento != null && parcelamento.getResolucaoDiretoria() != null){

										descricaoServicosTarifa.append(Util.completaString(parcelamento.getResolucaoDiretoria()
														.getDescricaoAssuntoAbreviada(), 3));

									}else{

										descricaoServicosTarifa.append(Util.completaString("", 3));

									}

									descricaoServicosTarifa.append(Util.completaString("", 1));
									descricaoServicosTarifa.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 9));
									descricaoServicosTarifa.append(Util.completaString("", 34));
									descricaoServicosTarifa.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));
									descricaoServicosTarifa.append(Util.completaString("", 45));

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valorDebitosCobrados);
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifa
													.toString());

									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);

								}

							}else{

								// 2.1.8.2. Caso contrário, ou seja, nenhum dos débitos cobrados têm
								// a identificação do parcelamento:
								StringBuffer descricaoServicosTarifa = new StringBuffer();
								descricaoServicosTarifa.append("PARCELAMENTO DE DÉBITOS");
								descricaoServicosTarifa.append(Util.completaString("", 44));
								descricaoServicosTarifa.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 17));
								descricaoServicosTarifa.append(Util.completaString("", 45));

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
								contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valorDebitosCobrados);
								contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifa
												.toString());

								colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

							}

						}

					}

				}

			}

		}

		List colecaoDebitoCobradoPorTipo = new ArrayList();

		if(indicadorOperacaoCaucionamento){
			List<DebitoCobrado> colecaoDebitoCobradoOrdenada = new ArrayList<DebitoCobrado>();

			if(!Util.isVazioOuBranco(contaCaucionada) && !Util.isVazioOrNulo(contaCaucionada.getDebitoCobrados())){
				colecaoDebitoCobradoOrdenada.addAll(contaCaucionada.getDebitoCobrados());

				// Ordenar a coleção por mais de um campo
				List sortFields = new ArrayList();
				sortFields.add(new BeanComparator("debitoTipo.id"));
				sortFields.add(new BeanComparator("anoMesReferenciaDebito"));

				ComparatorChain multiSort = new ComparatorChain(sortFields);
				Collections.sort(colecaoDebitoCobradoOrdenada, multiSort);

				if(!Util.isVazioOuBranco(colecaoDebitoCobradoOrdenada)){
					for(DebitoCobrado debitoCobrado : colecaoDebitoCobradoOrdenada){
						// Coloca valores no objeto
						Object[] arraydebitoCobrado = new Object[6];
						arraydebitoCobrado[0] = debitoCobrado.getValorPrestacao();
						arraydebitoCobrado[1] = debitoCobrado.getNumeroPrestacaoDebito();
						arraydebitoCobrado[2] = debitoCobrado.getNumeroPrestacao();
						arraydebitoCobrado[3] = debitoCobrado.getAnoMesReferenciaDebito();
						arraydebitoCobrado[4] = debitoCobrado.getDebitoTipo().getId();
						arraydebitoCobrado[5] = debitoCobrado.getDebitoTipo().getDescricao();

						colecaoDebitoCobradoPorTipo.add(arraydebitoCobrado);
					}
				}
			}
		}else{
			try{

				if(!contaHistorico){
					colecaoDebitoCobradoPorTipo = repositorioFaturamento.pesquisarParmsDebitoCobradoPorTipo(emitirContaHelper.getIdConta(),
									tiposParcelamento);
				}else{
					colecaoDebitoCobradoPorTipo = repositorioFaturamento.pesquisarParmsDebitoCobradoHistoricoPorTipo(
									emitirContaHelper.getIdConta(), tiposParcelamento);
				}
			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}
		if(colecaoDebitoCobradoPorTipo != null && !colecaoDebitoCobradoPorTipo.isEmpty()){
			ListIterator iteratorDebitoCobradoPorTipo = (ListIterator) colecaoDebitoCobradoPorTipo.listIterator();
			// variável responsável para controle de mudança do tipo de débito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// débito,que entra para ser escrito no txt só uma vez a
			// descrição do tipo do debito
			boolean primeiraVez = true;
			Integer idDebitoTipoVerificador = null;
			BigDecimal valorTotalPrestacoes = new BigDecimal("0.00");
			// valor da pretação
			BigDecimal valorPrestacao = null;
			// numero da pretação atual
			Integer numeroPrestacaoDebito = null;
			// numero total de prestações
			Integer numeroPrestacaoTotal = null;
			// colecao para guardar os ano/mes referencia do débito cobrado
			Collection colecaoAnoMesReferenciaDebito = new ArrayList();
			// cria um int que vai ver o tamanho da string builder
			// dependendo da quantidade de mes/ano referencia calcula os
			// espaços em brancos para o valor ficar no lugar certo
			// int tamanhoAnoMesReferencia = 0;
			String descricaoServicosTarifas2 = "";
			// String consumoFaixa2 = "";
			String valor2 = "";

			while(iteratorDebitoCobradoPorTipo.hasNext()){
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoCobradoPorTipo.next();

				// recupera os parametros da coleção valor da pretação
				if(parmsDebitoCobradoPorTipo[0] != null){
					valorPrestacao = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if(parmsDebitoCobradoPorTipo[1] != null){
					numeroPrestacaoDebito = Integer.valueOf("" + (Short) parmsDebitoCobradoPorTipo[1]);
				}
				// numero total de prestações
				if(parmsDebitoCobradoPorTipo[2] != null){
					numeroPrestacaoTotal = Integer.valueOf("" + (Short) parmsDebitoCobradoPorTipo[2]);
				}
				// ano Mes Referência do débito
				Integer anoMesReferencia = null;
				if(parmsDebitoCobradoPorTipo[3] != null){
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idDebitoTipo = null;
				if(parmsDebitoCobradoPorTipo[4] != null){
					idDebitoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do débito
				String descricaoDebitoTipo = null;
				if(parmsDebitoCobradoPorTipo[5] != null){
					descricaoDebitoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}

				// -- Linha 1 --//

				// muda o estado do boolean e o valor do débito tipo
				// verificador na primeira vez ou quando mudar o tipo

				if(mudou){
					idDebitoTipoVerificador = idDebitoTipo;
					mudou = false;
					// tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if(idDebitoTipo.equals(idDebitoTipoVerificador)){
					if(primeiraVez){
						// -- Linha 2 --//
						// descrição do tipo de débito
						descricaoServicosTarifas2 = Util.completaString(descricaoDebitoTipo, 35);
						primeiraVez = false;
					}

					if(!(numeroPrestacaoTotal > 1)){
						// adiciona o valor da prestação ao total
						valorTotalPrestacoes = valorTotalPrestacoes.add(valorPrestacao);
					}
					// adiciona o ano/mes referencia na coleção
					if(numeroPrestacaoTotal > 1){

						// adiciona o valor da prestação ao total

						descricaoServicosTarifas2 = descricaoServicosTarifas2 + Util.completaString("" + numeroPrestacaoDebito, 2);
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + "/" + Util.completaString("" + numeroPrestacaoTotal, 2);
						// Valor da pretação
						String valorPrestacaoString = Util.formatarMoedaReal(valorPrestacao);
						valor2 = valorPrestacaoString;
						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

						descricaoServicosTarifas2 = "";
						valor2 = "";
						primeiraVez = true;

					}else if(anoMesReferencia != null){
						colecaoAnoMesReferenciaDebito.add(anoMesReferencia);
					}else{
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + "PARCELA ";
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + Util.completaString("" + numeroPrestacaoDebito, 2);
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + "/" + Util.completaString("" + numeroPrestacaoTotal, 2);
						// Valor da pretação
						String valorPrestacaoString = Util.formatarMoedaReal(valorTotalPrestacoes);
						valor2 = valorPrestacaoString;
						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}
				}else{
					// 4.1.2. caso a coleção dos meses de referência do
					// grupo do tipo de débito esteja preenchida
					if(colecaoAnoMesReferenciaDebito != null && !colecaoAnoMesReferenciaDebito.isEmpty()){
						Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito.iterator();
						int i = 1;
						while(iteratorAnoMesReferenciaDebito.hasNext()){
							Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito.next();
							String anoMesReferenciaDebitoString = null;
							if(i == 1){
								// mes/ano referencia do débito
								anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;
								// caso exita somente um mes/ano de
								// referencia na lista
								if(colecaoAnoMesReferenciaDebito.size() == 1){
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									valor2 = valorAcumulado;
									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);
								}else{
									// completa espaços em brancos
									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);
									descricaoServicosTarifas2 = "";
								}
							}else{
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if(i == 2){
									// -- Linha 3 --//
									// completa espaços em brancos
									descricaoServicosTarifas2 = " ";
									// mes/ano referencia do debito
									anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									descricaoServicosTarifas2 = descricaoServicosTarifas2 + anoMesReferenciaDebitoString;
									// caso exita somente um mes/ano de
									// referencia na lista
									if(colecaoAnoMesReferenciaDebito.size() == 2){
										// valor acumulado do tipo do débito
										String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
										valor2 = valorAcumulado;
										contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
										contaLinhasDescricaoServicosTarifasTotalHelper
														.setDescricaoServicosTarifas(descricaoServicosTarifas2);
										contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
										contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
										colecaoContaLinhasDescricaoServicosTarifasTotalHelper
														.add(contaLinhasDescricaoServicosTarifasTotalHelper);
									}else{
										// completa espaços em brancos
										descricaoServicosTarifas2 = descricaoServicosTarifas2 + " ";
									}
								}else{
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o
									// ultimo anoMes
									if((colecaoAnoMesReferenciaDebito.size() - 1) <= 6){
										// mes/ano referencia do credito
										anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
										descricaoServicosTarifas2 = descricaoServicosTarifas2 + anoMesReferenciaDebitoString + " ";
										// caso não tenha outro ano mes na
										// coleção então completa a linha
										// com o valor
										if(!iteratorAnoMesReferenciaDebito.hasNext()){
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
											valor2 = valorAcumulado;
											contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
											contaLinhasDescricaoServicosTarifasTotalHelper
															.setDescricaoServicosTarifas(descricaoServicosTarifas2);
											contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
											contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
											colecaoContaLinhasDescricaoServicosTarifasTotalHelper
															.add(contaLinhasDescricaoServicosTarifasTotalHelper);
										}
									}else{
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if(i < 7){
											// mes/ano referencia do débito
											anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
											descricaoServicosTarifas2 = descricaoServicosTarifas2 + anoMesReferenciaDebitoString + " ";
										}else{
											// completa espaços em brancos
											descricaoServicosTarifas2 = descricaoServicosTarifas2 + " E OUTRAS";
											// valor acumulado do tipo do
											// débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
											valor2 = valorAcumulado;
											contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
											contaLinhasDescricaoServicosTarifasTotalHelper
															.setDescricaoServicosTarifas(descricaoServicosTarifas2);
											contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
											contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
											colecaoContaLinhasDescricaoServicosTarifasTotalHelper
															.add(contaLinhasDescricaoServicosTarifasTotalHelper);
											break;
										}
									}
								}
							}
							i = i + 1;
						}
					}// limpa os campos
					valorTotalPrestacoes = new BigDecimal("0.00");
					colecaoAnoMesReferenciaDebito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoCobradoPorTipo.previous();
				}
			}
			// no caso de ser o ultimo tipo
			// caso a coleção dos meses de referência do grupo do
			// tipo de débito esteja preenchida
			if(colecaoAnoMesReferenciaDebito != null && !colecaoAnoMesReferenciaDebito.isEmpty()){
				Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito.iterator();
				int i = 1;
				while(iteratorAnoMesReferenciaDebito.hasNext()){
					Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito.next();
					String anoMesReferenciaDebitoString = null;
					if(i == 1){
						// mes/ano referencia do débito
						anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
						descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;
						// caso exita somente um mes/ano de referencia na
						// lista
						if(colecaoAnoMesReferenciaDebito.size() == 1){
							// valor acumulado do tipo do débito
							String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
							valor2 = valorAcumulado;
							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
							contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
							contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
						}else{
							// completa com espaçoes em branco
							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
							contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
							contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
							descricaoServicosTarifas2 = "";
						}
					}else{
						// caso i seja igual a 2 então começa a linha 3 do
						// subFluxo
						if(i == 2){
							// -- Linha 3 --//
							// mes/ano referencia do debito
							anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
							descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;
							// caso exita somente um mes/ano de referencia
							// na lista
							if(colecaoAnoMesReferenciaDebito.size() == 2){
								// valor acumulado do tipo do débito
								String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
								valor2 = valorAcumulado;
								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
								contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
								contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
							}
						}else{
							// caso exista até mais 6 ocorrências na lista
							// de meses
							// -1 pq já foi colocado na string o ultimo
							// anoMes
							if((colecaoAnoMesReferenciaDebito.size() - 1) <= 6){
								// mes/ano referencia do credito
								anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								descricaoServicosTarifas2 = descricaoServicosTarifas2 + anoMesReferenciaDebitoString + " ";
								// caso não tenha outro ano mes na
								// coleção então completa a linha com o
								// valor
								if(!iteratorAnoMesReferenciaDebito.hasNext()){
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									valor2 = valorAcumulado;
									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);
								}
							}else{
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if(i < 7){
									// mes/ano referencia do débito
									anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									descricaoServicosTarifas2 = descricaoServicosTarifas2 + " " + anoMesReferenciaDebitoString;
								}else{
									descricaoServicosTarifas2 = descricaoServicosTarifas2 + " E OUTRAS";
									// valor acumulado do tipo do
									// débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									valor2 = valorAcumulado;
									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor2);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);
									break;
								}
							}
						}
					}
					i = i + 1;
				}
			}

		}

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * [SB00013] Gerar Linhas de Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasCreditosRealizadosRelatorio(EmitirContaHelper emitirContaHelper,
					Collection colecaoLinhasDescricaoServicosTarifasTotal, boolean contaHistorico, Conta contaCaucionada,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();

		String descricaoServicosTarifas = "";
		String valor = "";

		List colecaoCreditoRealizadoPorTipo = new ArrayList();

		if(indicadorOperacaoCaucionamento){
			List<CreditoRealizado> colecaoCreditoRealizadoPorTipoOrdenada = new ArrayList<CreditoRealizado>();

			if(!Util.isVazioOuBranco(contaCaucionada) && !Util.isVazioOrNulo(contaCaucionada.getCreditoRealizados())){
				colecaoCreditoRealizadoPorTipoOrdenada.addAll(contaCaucionada.getCreditoRealizados());

				// Ordenar a coleção por mais de um campo
				List sortFields = new ArrayList();
				sortFields.add(new BeanComparator("creditoTipo.id"));
				sortFields.add(new BeanComparator("anoMesReferenciaCredito"));

				ComparatorChain multiSort = new ComparatorChain(sortFields);
				Collections.sort(colecaoCreditoRealizadoPorTipoOrdenada, multiSort);

				if(!Util.isVazioOuBranco(colecaoCreditoRealizadoPorTipoOrdenada)){
					for(CreditoRealizado creditoRealizado : colecaoCreditoRealizadoPorTipoOrdenada){
						// Coloca valores no objeto
						Object[] arraycreditoRealizado = new Object[6];
						arraycreditoRealizado[0] = creditoRealizado.getValorCredito();
						arraycreditoRealizado[1] = creditoRealizado.getNumeroPrestacaoCredito();
						arraycreditoRealizado[2] = creditoRealizado.getNumeroPrestacao();
						arraycreditoRealizado[3] = creditoRealizado.getAnoMesReferenciaCredito();
						arraycreditoRealizado[4] = creditoRealizado.getCreditoTipo().getId();
						arraycreditoRealizado[5] = creditoRealizado.getCreditoTipo().getDescricao();

						colecaoCreditoRealizadoPorTipo.add(arraycreditoRealizado);
					}
				}
			}
		}else{
			try{
				if(!contaHistorico){
					colecaoCreditoRealizadoPorTipo = repositorioFaturamento.pesquisarParmsCreditoRealizadoPorTipo(emitirContaHelper
									.getIdConta());
				}else{
					colecaoCreditoRealizadoPorTipo = repositorioFaturamento
									.pesquisarParmsCreditoRealizadoHistoricoPorTipo(emitirContaHelper.getIdConta());
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
		}

		if(colecaoCreditoRealizadoPorTipo != null && !colecaoCreditoRealizadoPorTipo.isEmpty()){
			ListIterator iteratorCreditoRealizadoPorTipo = (ListIterator) colecaoCreditoRealizadoPorTipo.listIterator();
			// variável responsável para controle de mudança do tipo de
			// credito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// credito,que entra para ser escrito
			// no txt só uma vez a descrição do tipo do credito
			boolean primeiraVez = true;
			Integer idCreditoTipoVerificador = null;
			BigDecimal valorTotalCredito = new BigDecimal("0.00");
			BigDecimal valorCredito = null;
			Short numeroCredito = null;
			// numero total de créditos
			Short numeroCreditoTotal = null;
			// cria um int que vai ver o tamanho da string builder
			// dependendo da quantidade
			// de mes/ano referencia calcula os espaços em brancos
			// para o valor ficar no lugar certo
			// int tamanhoAnoMesReferencia = 0;
			// caso não seja a primeira vez que entre no boolean primeira
			// vez(que nesse caso é quando troca o tipo de credito)
			// boolean primeiraVezIndependenteTipo = false;
			// colecao para guardar os ano/mes referencia do credito realizado
			Collection colecaoAnoMesReferenciaCredito = new ArrayList();
			while(iteratorCreditoRealizadoPorTipo.hasNext()){
				Object[] parmsCreditoCobradoPorTipo = (Object[]) iteratorCreditoRealizadoPorTipo.next();

				// recupera os parametros da coleção
				// valor do crédito
				if(parmsCreditoCobradoPorTipo[0] != null){
					valorCredito = (BigDecimal) parmsCreditoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if(parmsCreditoCobradoPorTipo[1] != null){
					numeroCredito = (Short) parmsCreditoCobradoPorTipo[1];
				}

				if(parmsCreditoCobradoPorTipo[2] != null){
					numeroCreditoTotal = (Short) parmsCreditoCobradoPorTipo[2];
				}
				// ano Mes Referência do crédito
				Integer anoMesReferencia = null;
				if(parmsCreditoCobradoPorTipo[3] != null){
					anoMesReferencia = (Integer) parmsCreditoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idCreditoTipo = null;
				if(parmsCreditoCobradoPorTipo[4] != null){
					idCreditoTipo = (Integer) parmsCreditoCobradoPorTipo[4];
				}
				// descrição do tipo do credito
				String descricaoCreditoTipo = null;
				if(parmsCreditoCobradoPorTipo[5] != null){
					descricaoCreditoTipo = (String) parmsCreditoCobradoPorTipo[5];
				}
				// muda o estado do boolean e o valor do credito tipo
				// verificador
				// na primeira vez ou quando mudar o tipo
				if(mudou){
					idCreditoTipoVerificador = idCreditoTipo;
					mudou = false;
					// tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if(idCreditoTipo.equals(idCreditoTipoVerificador)){
					if(primeiraVez){
						// proxima linha
						// if (primeiraVezIndependenteTipo) {
						// linhasCreditosRealizados.append(System
						// .getProperty("line.separator"));
						// }
						// -- Linha 1 --//

						// descrição do tipo de credito
						// descricaoServicosTarifas = descricaoCreditoTipo;
						descricaoServicosTarifas = Util.completaString(descricaoCreditoTipo, 35);

						primeiraVez = false;
						// primeiraVezIndependenteTipo = true;
					}
					// adiciona o valor do credito ao total
					valorTotalCredito = valorTotalCredito.add(valorCredito);
					// adiciona o ano/mes referencia na coleção
					if(anoMesReferencia != null){
						colecaoAnoMesReferenciaCredito.add(anoMesReferencia);
					}else{
						// -- Linha 1 (CONTINUAÇÂO)--//
						// Constante
						descricaoServicosTarifas = descricaoServicosTarifas + "PARCELA ";
						descricaoServicosTarifas = descricaoServicosTarifas + Util.completaString("" + numeroCredito, 2) + "/";
						descricaoServicosTarifas = descricaoServicosTarifas + Util.completaString("" + numeroCreditoTotal, 2);

						// Valor da pretação
						String valorCreditoString = Util.formatarMoedaReal(valorCredito);
						valor = valorCreditoString;

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas);
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
						contaLinhasDescricaoServicosTarifasTotalHelper.setSinal("-");
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

					}

				}else{
					// caso a coleção dos meses de referência do grupo do
					// tipo de credito esteja preenchida
					if(colecaoAnoMesReferenciaCredito != null && !colecaoAnoMesReferenciaCredito.isEmpty()){
						Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito.iterator();
						int i = 1;
						while(iteratorAnoMesReferenciaCredito.hasNext()){
							Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito.next();
							String anoMesReferenciaCreditoString = null;
							if(i == 1){
								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								descricaoServicosTarifas = descricaoServicosTarifas + " " + anoMesReferenciaCreditoString;

								// caso exita somente um mes/ano de
								// referencia na lista
								if(colecaoAnoMesReferenciaCredito.size() == 1){

									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									valor = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);

								}else{
									// completa espaços em brancos
									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);
								}
							}else{
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if(i == 2){
									// -- Linha 3 --//

									// mes/ano referencia do credito
									anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									descricaoServicosTarifas = descricaoServicosTarifas + " " + anoMesReferenciaCreditoString;

									// caso exita somente um mes/ano de
									// referencia na lista
									if(colecaoAnoMesReferenciaCredito.size() == 2){

										// valor acumulado do tipo do débito
										String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
										valor = valorAcumulado;

										contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
										contaLinhasDescricaoServicosTarifasTotalHelper
														.setDescricaoServicosTarifas(descricaoServicosTarifas);
										contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
										contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
										colecaoContaLinhasDescricaoServicosTarifasTotalHelper
														.add(contaLinhasDescricaoServicosTarifasTotalHelper);

									}else{
										// completa espaços em brancos
										descricaoServicosTarifas = descricaoServicosTarifas + " ";
									}
								}else{
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o
									// ultimo anoMes
									if((colecaoAnoMesReferenciaCredito.size() - 1) <= 6){

										// mes/ano referencia do credito
										anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);

										descricaoServicosTarifas = descricaoServicosTarifas + anoMesReferenciaCreditoString + " ";

										// caso não tenha outro ano mes na
										// coleção então
										// completa a linha com o valor
										if(!iteratorAnoMesReferenciaCredito.hasNext()){

											// valor acumulado do tipo do débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
											valor = valorAcumulado;

											contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
											contaLinhasDescricaoServicosTarifasTotalHelper
															.setDescricaoServicosTarifas(descricaoServicosTarifas);
											contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
											contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
											colecaoContaLinhasDescricaoServicosTarifasTotalHelper
															.add(contaLinhasDescricaoServicosTarifasTotalHelper);

										}

									}else{
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if(i < 7){
											// mes/ano referencia do débito
											anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);

											descricaoServicosTarifas = descricaoServicosTarifas + anoMesReferenciaCreditoString + " ";

										}else{
											descricaoServicosTarifas = descricaoServicosTarifas + " E OUTRAS";

											// valor acumulado do tipo do débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
											valor = valorAcumulado;

											contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
											contaLinhasDescricaoServicosTarifasTotalHelper
															.setDescricaoServicosTarifas(descricaoServicosTarifas);
											contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
											contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
											colecaoContaLinhasDescricaoServicosTarifasTotalHelper
															.add(contaLinhasDescricaoServicosTarifasTotalHelper);
											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					}
					// limpa os campos
					valorTotalCredito = new BigDecimal("0.00");
					colecaoAnoMesReferenciaCredito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorCreditoRealizadoPorTipo.previous();
				}
			}
			// No caso de ter o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de credito esteja preenchida
			if(colecaoAnoMesReferenciaCredito != null && !colecaoAnoMesReferenciaCredito.isEmpty()){
				Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito.iterator();
				int i = 1;
				while(iteratorAnoMesReferenciaCredito.hasNext()){
					Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito.next();
					String anoMesReferenciaCreditoString = null;
					if(i == 1){
						// mes/ano referencia do credito
						anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
						descricaoServicosTarifas = descricaoServicosTarifas + " " + anoMesReferenciaCreditoString;

						// caso exita somente um mes/ano de
						// referencia na lista
						if(colecaoAnoMesReferenciaCredito.size() == 1){

							// valor acumulado do tipo do débito
							String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
							valor = valorAcumulado;

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas);
							contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
							contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

						}else{
							// completa espaços em brancos
							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas);
							contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
							contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
							colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
						}
					}else{
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if(i == 2){
							// -- Linha 3 --//

							// mes/ano referencia do credito
							anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);

							descricaoServicosTarifas = descricaoServicosTarifas + " " + anoMesReferenciaCreditoString;

							// caso exita somente um mes/ano de referencia na
							// lista
							if(colecaoAnoMesReferenciaCredito.size() == 2){

								// valor acumulado do tipo do débito
								String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
								valor = valorAcumulado;

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas);
								contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
								contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

							}else{
								// completa espaços em brancos
								descricaoServicosTarifas = descricaoServicosTarifas + " ";
							}
						}else{
							// caso exista até mais 6 ocorrências na lista de
							// meses
							// -1 pq já foi colocado na string o ultimo anoMes
							if((colecaoAnoMesReferenciaCredito.size() - 1) <= 6){

								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								descricaoServicosTarifas = descricaoServicosTarifas + anoMesReferenciaCreditoString + " ";

								// caso não tenha outro ano mes na
								// coleção então
								// completa a linha com o valor
								if(!iteratorAnoMesReferenciaCredito.hasNext()){

									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									valor = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);
								}

							}else{
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if(i < 7){
									// mes/ano referencia do débito
									anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									descricaoServicosTarifas = descricaoServicosTarifas + anoMesReferenciaCreditoString + " ";
								}else{
									descricaoServicosTarifas = descricaoServicosTarifas + " E OUTRAS";

									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									valor = valorAcumulado;

									contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
									contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas);
									contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
									contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor);
									colecaoContaLinhasDescricaoServicosTarifasTotalHelper
													.add(contaLinhasDescricaoServicosTarifasTotalHelper);
									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}
		}

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * Seleciona as contas agrupando por imóvel
	 * [UC0485] - Gerar Resumo dos Devedores Duvidosos
	 * 
	 * @author Rafael Pinto, Pedro Alexandre
	 * @date 22/11/2006, 08/06/2007
	 * @param anoMesReferenciaContabil
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 */

	public HashMap obterContaAgrupadasPorImovel(int anoMesReferenciaContabil, int idLocalidade, int idQuadra) throws ControladorException{

		HashMap mapContasPorImovel = new HashMap();

		Iterator itera = null;

		Collection<Conta> dadosContas = null;
		try{

			dadosContas = this.repositorioFaturamento.obterContaAgrupadasPorImovel(anoMesReferenciaContabil, idLocalidade, idQuadra);

			if(dadosContas != null && !dadosContas.isEmpty()){

				itera = dadosContas.iterator();

				while(itera.hasNext()){

					Conta conta = (Conta) itera.next();

					boolean indicadorClienteResponsavel = repositorioFaturamento.verificarExistenciaClienteResponsavelConta(conta.getId());

					if(!indicadorClienteResponsavel){

						Integer chaveImovel = conta.getImovel().getId();
						if(!mapContasPorImovel.containsKey(chaveImovel)){

							Collection colecao = new ArrayList();
							colecao.add(conta);

							mapContasPorImovel.put(chaveImovel, colecao);
						}else{

							Collection colecao = (ArrayList) mapContasPorImovel.get(chaveImovel);
							colecao.add(conta);

							mapContasPorImovel.put(chaveImovel, colecao);
						}

					}

					conta = null;
				}
			}

			// numeroIndice = numeroIndice + 10000;
			//
			// if (dadosContas == null || dadosContas.size() <
			// quantidadeRegistros) {
			// flagTerminou = true;
			// }

		}catch(Exception e){

			// sessionContext.setRollbackOnly();

			throw new ControladorException("erro.sistema", e);
		}

		return mapContasPorImovel;
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 23/11/2006
	 * @param filtroImovel
	 * @param usuarioLogado
	 * @return
	 * @throws ControladorException
	 */
	public Imovel pesquisarImovelContaManter(FiltroImovel filtroImovel, Usuario usuarioLogado) throws ControladorException{

		Imovel imovel = null;

		imovel = (Imovel) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()));

		// ------------ CONTROLE DE ABRANGENCIA ----------------
		Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

		if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.acesso.negado.abrangencia");
		}

		// ------------ FIM CONTROLE DE ABRANGENCIA ------------

		return imovel;
	}

	/**
	 * Utilizado pelo [UC0] Manter Conta
	 * 
	 * @author Rafael Santos
	 * @date 23/11/2006
	 * @param idConta
	 * @param dataUltimaAlteracao
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Object pesquisarDataUltimaAlteracaoConta(Integer idConta) throws ControladorException{

		try{

			return this.repositorioFaturamento.pesquisarDataUltimaAlteracaoConta(idConta);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	public void atualizarDataHoraRealizacaoAtividade(Integer idAtividade, Integer anoMesReferencia, Integer idFaturamentoGrupo)
					throws ControladorException{

		try{
			repositorioFaturamento.atualizarDataHoraRealizacaoAtividade(idAtividade, anoMesReferencia, idFaturamentoGrupo);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Recupera a data de realização passando o id do imovel e a quantidade de meses que quer
	 * subtrair,caso não queira subtrair colocar 0 [UC0488]
	 * Informar Retorno Ordem de Fiscalização
	 * [SB0004] - Calcular Valor de Água e/ou Esgoto
	 * 
	 * @author Sávio Luiz
	 * @date 04/12/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Date pesquisarDataRealizacaoFaturamentoAtividadeCronagrama(Integer idImovel, int quantidadeMeses) throws ControladorException{

		Date dataRealizacao = null;
		try{
			Object[] parmsFaturamentoGrupo = repositorioFaturamento.pesquisarParmsFaturamentoGrupo(idImovel);
			Integer idFaturamentoGrupo = null;
			Integer anoMesFaturamentoGrupo = null;
			if(parmsFaturamentoGrupo != null){
				if(parmsFaturamentoGrupo[0] != null){
					idFaturamentoGrupo = (Integer) parmsFaturamentoGrupo[0];
				}
				if(parmsFaturamentoGrupo[1] != null){
					anoMesFaturamentoGrupo = (Integer) parmsFaturamentoGrupo[1];
				}
			}
			if(idFaturamentoGrupo != null && anoMesFaturamentoGrupo != null){
				// caso a quantidades de meses que quer subitrair seja diferente
				// de 0
				if(quantidadeMeses > 0){
					anoMesFaturamentoGrupo = Util.subtrairMesDoAnoMes(anoMesFaturamentoGrupo, quantidadeMeses);
				}
				Integer idFaturamentoAtividade = FaturamentoAtividade.EFETUAR_LEITURA;
				// pesquisa a data de realização
				dataRealizacao = repositorioFaturamento.pesquisarDataRealizacaoFaturamentoAtividadeCronograma(idFaturamentoGrupo,
								idFaturamentoAtividade, anoMesFaturamentoGrupo);
			}
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return dataRealizacao;

	}

	/**
	 * Resgata Colecao de contas a apartir do imovel e de um determinad periodo Tiago Moreno
	 */

	public Collection obterContasImovelIntervalo(Integer imovel, Integer situacaoNormal, Integer situacaoIncluida,
					Integer situacaoRetificada, Integer anoMesInicio, Integer anoMesFim, Integer idContaMotivoRevisao)
					throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoContasManutencaoArray = null;

		try{

			if(idContaMotivoRevisao != null && !idContaMotivoRevisao.equals("")){
				colecaoContasManutencaoArray = repositorioFaturamento.obterContasImovelIntervalo(imovel, situacaoNormal, situacaoIncluida,
								situacaoRetificada, anoMesInicio, anoMesFim, idContaMotivoRevisao);
			}else{
				colecaoContasManutencaoArray = repositorioFaturamento.obterContasImovelIntervalo(imovel, situacaoNormal, situacaoIncluida,
								situacaoRetificada, anoMesInicio, anoMesFim);
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoContasManutencaoArray != null && !colecaoContasManutencaoArray.isEmpty()){

			Iterator colecaoContasManutencaoArrayIterator = colecaoContasManutencaoArray.iterator();

			while(colecaoContasManutencaoArrayIterator.hasNext()){

				// Obtém os dados do crédito realizado
				Object[] contaArray = (Object[]) colecaoContasManutencaoArrayIterator.next();

				Conta conta = new Conta();

				// ID da conta
				conta.setId((Integer) contaArray[0]);

				// Ano Mês referencia
				conta.setReferencia((Integer) contaArray[1]);

				// Data de vencimento
				String vencimento = String.valueOf(contaArray[2]);

				SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd");

				Date dataVencimento;

				try{
					dataVencimento = formatoData.parse(vencimento);
				}catch(java.text.ParseException e){
					dataVencimento = null;
				}

				conta.setDataVencimentoConta(dataVencimento);

				// Valor de água
				conta.setValorAgua((BigDecimal) contaArray[3]);

				// Valor de esgoto
				conta.setValorEsgoto((BigDecimal) contaArray[4]);

				// Valor dos débitos
				conta.setDebitos((BigDecimal) contaArray[5]);

				// Valor dos créditos
				conta.setValorCreditos((BigDecimal) contaArray[6]);

				// Consumo de água
				conta.setConsumoAgua((Integer) contaArray[7]);

				// Consumo de esgoto
				conta.setConsumoEsgoto((Integer) contaArray[8]);

				// Data de validade
				String validade = String.valueOf(contaArray[9]);

				Date dataValidade;

				try{
					dataValidade = formatoData.parse(validade);
				}catch(java.text.ParseException e){
					dataValidade = null;
				}

				conta.setDataValidadeConta(dataValidade);

				// Data de revisao
				String revisao = String.valueOf(contaArray[10]);

				Date dataRevisao;

				try{
					dataRevisao = formatoData.parse(revisao);
				}catch(java.text.ParseException e){
					dataRevisao = null;
				}

				conta.setDataRevisao(dataRevisao);

				// DebitoCreditoSituacaoAtual
				conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);

				// Ano Mês referencia contábil
				conta.setReferenciaContabil((Integer) contaArray[12]);

				// ultima Alteracao

				SimpleDateFormat formatoDataEspecifico = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

				String ultimaAlteracao = String.valueOf(contaArray[13]);

				Date dataUltimaAlteracao;

				try{
					dataUltimaAlteracao = formatoDataEspecifico.parse(ultimaAlteracao);
				}catch(java.text.ParseException e){
					dataUltimaAlteracao = null;
				}

				conta.setUltimaAlteracao(dataUltimaAlteracao);

				Imovel objImovel = new Imovel();
				objImovel.setId(imovel);
				conta.setImovel(objImovel);

				retorno.add(conta);
			}
		}

		return retorno;
	}

	/**
	 * [UC113] Faturar Grupo Faturamento
	 * Apaga os dados do faturar da rota do ano/mês
	 * 
	 * @author Rafael Santos
	 * @date 02/01/2007
	 * @param anoMesFaturamento
	 * @param idRota
	 */
	protected void apagarDadosGeradosFaturarGrupoFaturamento(String anoMesFaturamento, Integer idRota) throws ControladorException{

		// obter a quantidade de conta por rota
		Integer quantidadeContas = null;
		try{
			quantidadeContas = repositorioFaturamento.quantidadeContasRota(anoMesFaturamento, idRota);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		if(quantidadeContas != null && quantidadeContas.intValue() > 0){

			try{
				// deleta CONTA_CATEGORIA_CONSUMO_FAIXA
				repositorioFaturamento.apagarContaCategoriaConsumoFaixa(anoMesFaturamento, idRota);

				// deleta CONTA_CATEGORIA
				repositorioFaturamento.apagarContaCategoria(anoMesFaturamento, idRota);

				// deleta CONTA_IMPRESSAO
				repositorioFaturamento.apagarContaImpressao(anoMesFaturamento, idRota);

				// deleta CLIENTE_CONTA
				repositorioFaturamento.apagarClienteConta(anoMesFaturamento, idRota);

				// deleta CONTA_IMPOSTOS_DEDUZIDOS
				repositorioFaturamento.apagarContaImpostosDeduzidos(anoMesFaturamento, idRota);

				// deleta DEBITO_AUTOMATICO_MOVIMENTO
				// repositorioFaturamento.apagarDebitoAutomaticoMovimento(anoMesFaturamento,
				// idRota);

				// deleta DEBITO_COBRADO_CATEGORIA
				repositorioFaturamento.apagarDebitoCobradoCategoria(anoMesFaturamento, idRota);

				// deleta DEBITO_COBRADO
				repositorioFaturamento.apagarDebitoCobrado(anoMesFaturamento, idRota);

				// deleta CREDITO_REALIZADO_CATEGORIA
				repositorioFaturamento.apagarCreditoRealizadoCategoria(anoMesFaturamento, idRota);

				// deleta CREDITO_REALIZADO
				repositorioFaturamento.apagarCreditoRealizado(anoMesFaturamento, idRota);

				// update DEBITO_A_COBRAR
				repositorioFaturamento.atualizarDebitoACobrar(anoMesFaturamento, idRota);

				// update CREDITO_A_REALIZAR
				repositorioFaturamento.atualizarCreditoARealizar(anoMesFaturamento, idRota);

				// update CONTA_GERAL
				repositorioFaturamento.atualizarContaGeral(anoMesFaturamento, idRota);

				// deleta CONTA
				repositorioFaturamento.apagarConta(anoMesFaturamento, idRota);

				// delete CONTA_GERAL
				repositorioFaturamento.apagarContaGeral(anoMesFaturamento, idRota);

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Atualiza o ano/mês de referência do faturamento somando mais um mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 08/01/2007
	 * @param anoMesFaturamentoSistemaParametro
	 * @throws ControladorException
	 */
	public void atualizarAnoMesFaturamento(Integer anoMesFaturamentoSistemaParametro) throws ControladorException{

		try{
			// item 12
			// responsável por atualizar o ano/mês de
			// faturamento da tabela de parâmetros do sistema
			repositorioFaturamento.atualizarAnoMesfaturamento(anoMesFaturamentoSistemaParametro,
							Util.somarData(anoMesFaturamentoSistemaParametro));
			// fim item 12
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Pesquisar os ids das localidades para encerrar o faturamento do mês.
	 * 
	 * @author Pedro Alexandre
	 * @date 08/01/2007
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarIdsLocalidadeParaEncerrarFaturamento() throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarIdsLocalidadeParaEncerrarFaturamento();
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Pesquisar os ids das localidades para gerar o resumo das ligações/economias.
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/01/2007
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarIdsLocalidadeParaGerarResumoLigacoesEconomias() throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarIdsLocalidadeParaEncerrarFaturamento();
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0348] Emitir Contas
	 * 
	 * @author Sávio Luiz,
	 * @date 08/01/2007
	 * @return
	 * @throws ControladorException
	 */
	public Collection<EmitirContaHelper> formatarEmitirContasHelper(Collection colecaoPamsContas, int i){

		Collection<EmitirContaHelper> colecaoContas = new ArrayList();
		if(colecaoPamsContas != null){
			Iterator iteColecaoContas = colecaoPamsContas.iterator();
			while(iteColecaoContas.hasNext()){
				Object[] parmsConta = (Object[]) iteColecaoContas.next();
				if(parmsConta != null){
					EmitirContaHelper emitirContaHelper = new EmitirContaHelper();
					// id da conta
					if(parmsConta[0] != null){
						emitirContaHelper.setIdConta((Integer) parmsConta[0]);
					}
					if(i == 3 || i == 4){
						// nome cliente
						if(parmsConta[1] != null){
							emitirContaHelper.setNomeCliente((String) parmsConta[1]);
						}
						// nome cliente
						if(parmsConta[32] != null){
							emitirContaHelper.setNomeImovel((String) parmsConta[32]);
						}
					}else{
						if(parmsConta[32] != null){
							emitirContaHelper.setNomeCliente((String) parmsConta[32]);
						}else{
							// nome cliente
							if(parmsConta[1] != null){
								emitirContaHelper.setNomeCliente((String) parmsConta[1]);
							}
						}
					}
					// data vencimento da conta
					if(parmsConta[2] != null){
						emitirContaHelper.setDataVencimentoConta((Date) parmsConta[2]);
					}
					// ano mes referencia da conta
					if(parmsConta[3] != null){
						emitirContaHelper.setAmReferencia((Integer) parmsConta[3]);
					}
					// digito verificador da conta
					if(parmsConta[4] != null){
						emitirContaHelper.setDigitoVerificadorConta((Short) parmsConta[4]);
					}
					// codigo setor comercial da conta
					if(parmsConta[5] != null){
						emitirContaHelper.setCodigoSetorComercialConta((Integer) parmsConta[5]);
					}
					// id da quadra da conta
					if(parmsConta[6] != null){
						emitirContaHelper.setIdQuadraConta((Integer) parmsConta[6]);
					}
					// lote da conta
					if(parmsConta[7] != null){
						emitirContaHelper.setLoteConta((Short) parmsConta[7]);
					}
					// sublote da conta
					if(parmsConta[8] != null){
						emitirContaHelper.setSubLoteConta((Short) parmsConta[8]);
					}
					// consumo agua
					if(parmsConta[9] != null){
						emitirContaHelper.setConsumoAgua((Integer) parmsConta[9]);
					}
					// consumo esgoto
					if(parmsConta[10] != null){
						emitirContaHelper.setConsumoEsgoto((Integer) parmsConta[10]);
					}
					// valor agua
					if(parmsConta[11] != null){
						emitirContaHelper.setValorAgua((BigDecimal) parmsConta[11]);
					}
					// valor esgoto
					if(parmsConta[12] != null){
						emitirContaHelper.setValorEsgoto((BigDecimal) parmsConta[12]);
					}
					// id da conta
					if(parmsConta[13] != null){
						emitirContaHelper.setDebitos((BigDecimal) parmsConta[13]);
					}
					// id da conta
					if(parmsConta[14] != null){
						emitirContaHelper.setValorCreditos((BigDecimal) parmsConta[14]);
					}
					// id da conta
					if(parmsConta[15] != null){
						emitirContaHelper.setValorImpostos((BigDecimal) parmsConta[15]);
					}
					// id da conta
					if(parmsConta[16] != null){
						emitirContaHelper.setDataValidadeConta((Date) parmsConta[16]);
					}
					// id da conta
					if(parmsConta[17] != null){
						emitirContaHelper.setIdImovel((Integer) parmsConta[17]);
					}
					// id da conta
					if(parmsConta[18] != null){
						emitirContaHelper.setIdLocalidade((Integer) parmsConta[18]);
					}
					// id da conta
					if(parmsConta[19] != null){
						emitirContaHelper.setIdGerenciaRegional((Integer) parmsConta[19]);
					}
					// id da conta
					if(parmsConta[20] != null){
						emitirContaHelper.setNomeGerenciaRegional((String) parmsConta[20]);
					}
					// id da conta
					if(parmsConta[21] != null){
						emitirContaHelper.setIdLigacaoAguaSituacao((Integer) parmsConta[21]);
					}
					// id da conta
					if(parmsConta[22] != null){
						emitirContaHelper.setIdLigacaoEsgotoSituacao((Integer) parmsConta[22]);
					}
					// id da conta
					if(parmsConta[23] != null){
						emitirContaHelper.setIdImovelPerfil((Integer) parmsConta[23]);
					}
					// id da conta
					if(parmsConta[24] != null){
						emitirContaHelper.setIdSetorComercial((Integer) parmsConta[24]);
					}
					// id da conta
					if(parmsConta[25] != null){
						emitirContaHelper.setIdFaturamentoGrupo((Integer) parmsConta[25]);
					}
					// id da conta
					if(parmsConta[26] != null){
						emitirContaHelper.setIdEmpresa((Integer) parmsConta[26]);
					}
					// id da conta
					if(parmsConta[27] != null){
						emitirContaHelper.setDescricaoLocalidade((String) parmsConta[27]);
					}
					// id da conta
					if(parmsConta[28] != null){
						emitirContaHelper.setDescricaoLigacaoAguaSituacao((String) parmsConta[28]);
					}
					// id da conta
					if(parmsConta[29] != null){
						emitirContaHelper.setDescricaoLigacaoEsgotoSituacao((String) parmsConta[29]);
					}
					// id da conta
					if(parmsConta[30] != null){
						emitirContaHelper.setPercentualEsgotoConta((BigDecimal) parmsConta[30]);
					}
					// nome cliente
					if(parmsConta[31] != null){
						emitirContaHelper.setIdClienteResponsavel("" + (Integer) parmsConta[31]);
					}

					int tam = parmsConta.length;
					if(tam > 34){
						// id da rota
						if(parmsConta[33] != null){
							emitirContaHelper.setCodigoRota((Short) parmsConta[33]);
						}

						// numero sequencial rota
						if(parmsConta[34] != null){
							emitirContaHelper.setNumeroSequencialRota((Integer) parmsConta[34]);
						}

						// origem
						if(parmsConta[35] != null){
							emitirContaHelper.setIdOrigem((Integer) parmsConta[35]);
						}

						// debitoCreditoSituacaoAtual
						if(parmsConta[36] != null){
							emitirContaHelper.setDebitoCreditoSituacaoAtualConta((Integer) parmsConta[36]);
						}

						// id do funcionario
						if(parmsConta[37] != null){
							emitirContaHelper.setIdFuncionario((Integer) parmsConta[37]);
						}

						// nome do funcionario
						if(parmsConta[38] != null){
							emitirContaHelper.setNomeFuncionario((String) parmsConta[38]);
						}

						// Tipo de Conta
						if(parmsConta[39] != null){
							emitirContaHelper.setContaTipo((Integer) parmsConta[39]);
						}
					}

					colecaoContas.add(emitirContaHelper);
					emitirContaHelper = null;
				}

			}
		}
		return colecaoContas;
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição Individualizada
	 * 
	 * @author Vivianne Sousa
	 * @date 10/01/2007
	 * @param colecaoLigacoesMedicao
	 * @throws ControladorException
	 */
	public Collection pesquisarFaturamentoLigacoesMedicaoIndividualizadaRelatorio(FiltroMedicaoHistoricoSql filtroMedicaoHistoricoSql,
					String anoMesfaturamentoGrupo, Integer indicadorRateio) throws ControladorException{

		Collection colecaoIdImovelCondominioLigacoesMedicaoIndividualizada = null;
		Collection colecaoRetorno = new ArrayList();
		Collection<FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper> colecaoRetornoAux = new ArrayList<FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper>();
		BigDecimal rateioValorPorImovel = new BigDecimal("0.00");

		try{

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			Integer anoMesReferencia = sistemaParametro.getAnoMesFaturamento();

			colecaoIdImovelCondominioLigacoesMedicaoIndividualizada = repositorioFaturamento
							.pesquisarIdImovelCondominioLigacoesMedicaoIndividualizada(filtroMedicaoHistoricoSql, anoMesReferencia);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(colecaoIdImovelCondominioLigacoesMedicaoIndividualizada != null
						&& !colecaoIdImovelCondominioLigacoesMedicaoIndividualizada.isEmpty()){

			int indicadorQuebraImovelCondominio = 0;
			Iterator iterImovelCondominio = colecaoIdImovelCondominioLigacoesMedicaoIndividualizada.iterator();

			while(iterImovelCondominio.hasNext()){
				Object[] objetoCondominio = (Object[]) iterImovelCondominio.next();
				FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper = null;
				Integer idImovelCondominio = (Integer) objetoCondominio[0];
				int consumoRateioMacro = 0;
				Integer idLocalidade = (Integer) objetoCondominio[1];
				String nomeLocalidade = (String) objetoCondominio[2];
				Integer indicadorPoco = null;
				indicadorQuebraImovelCondominio++;
				boolean temRateio = false;
				Integer idRateioTipo = 0;

				// somatório da qtde de economias dos imóveis vinculados ao
				// imóvel condomínio
				int somaQtdeEconomias = 0;
				// somatório da qtde de imóveis vinculados ao imóvel condomínio
				int somaQtdeImoveis = 0;

				if(objetoCondominio[3] != null){
					indicadorPoco = (Integer) objetoCondominio[3];
				}

				Collection colecaoImovelLigacoesMedicaoIndividualizada = null;

				try{
					colecaoImovelLigacoesMedicaoIndividualizada = repositorioFaturamento.pesquisarLigacoesMedicaoIndividualizadaRelatorio(
									idImovelCondominio, anoMesfaturamentoGrupo);
				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				if(colecaoImovelLigacoesMedicaoIndividualizada != null && !colecaoImovelLigacoesMedicaoIndividualizada.isEmpty()){
					int cont = 0;
					BigDecimal totalValorSemRateio = new BigDecimal("0.00");
					BigDecimal totalValorComRateio = new BigDecimal("0.00");

					Iterator iterImovelLigacoesMedicaoIndividualizada = colecaoImovelLigacoesMedicaoIndividualizada.iterator();

					while(iterImovelLigacoesMedicaoIndividualizada.hasNext()){
						Object[] imovelLigacoesMedicaoIndividualizada = (Object[]) iterImovelLigacoesMedicaoIndividualizada.next();

						faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper = new FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper();

						faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setIdLocalidade("" + idLocalidade);
						faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setNomeLocalidade(nomeLocalidade);

						// Obtém o MovimentoRoteiroEmpresa do Imóvel e Ano/Mês Referência da Conta
						FiltroMovimentoRoteiroEmpresa filtroMovimentoRoteiroEmpresa = new FiltroMovimentoRoteiroEmpresa();
						filtroMovimentoRoteiroEmpresa.limparListaParametros();
						filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.IMOVEL_ID,
										imovelLigacoesMedicaoIndividualizada[0]));
						filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(
										FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO, anoMesfaturamentoGrupo));
						filtroMovimentoRoteiroEmpresa
										.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.LIGACAO_AGUA_SITUACAO);

						Collection colecaoMovimentoRoteiroEmpresa = getControladorUtil().pesquisar(filtroMovimentoRoteiroEmpresa,
										MovimentoRoteiroEmpresa.class.getName());

						MovimentoRoteiroEmpresa movimentoRoteiroImovel = (MovimentoRoteiroEmpresa) Util
										.retonarObjetoDeColecao(colecaoMovimentoRoteiroEmpresa);

						String indicadorEmissaoCampo = null;

						if(movimentoRoteiroImovel != null){
							indicadorEmissaoCampo = movimentoRoteiroImovel.getIndicadorEmissaoCampo();
						}

						Short indicadorImovelNaoLidoFaturarMedia = ConstantesSistema.NAO;

						if(!Util.isVazioOuBranco(movimentoRoteiroImovel)
										&& movimentoRoteiroImovel.getIndicadorStatusRegistSistLegado() != null
										&& movimentoRoteiroImovel.getIndicadorStatusRegistSistLegado().equals(
														MovimentoRoteiroEmpresa.INDICADOR_STATUS_REGISTRO_NAO_LIDO)
										&& movimentoRoteiroImovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)){

							indicadorImovelNaoLidoFaturarMedia = ConstantesSistema.SIM;
						}

						if(idImovelCondominio.equals(imovelLigacoesMedicaoIndividualizada[0])){
							// imóvel Condomínio
							if(indicadorPoco != null){
								faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setIndicadorPoco("1");
							}else{
								faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setIndicadorPoco("2");
							}

						}

						faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setMatriculaImovel(""
										+ imovelLigacoesMedicaoIndividualizada[0]);

						if(imovelLigacoesMedicaoIndividualizada[1] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setQtdeEconomias(""
											+ imovelLigacoesMedicaoIndividualizada[1]);

							if(!idImovelCondominio.equals(imovelLigacoesMedicaoIndividualizada[0])){
								somaQtdeEconomias = somaQtdeEconomias + (Short) imovelLigacoesMedicaoIndividualizada[1];
							}
						}

						if(imovelLigacoesMedicaoIndividualizada[2] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setDataLeituraAnterior(Util
											.formatarData((Date) imovelLigacoesMedicaoIndividualizada[2]));
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setDataLeituraAnterior("");
						}

						if(imovelLigacoesMedicaoIndividualizada[3] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setLeituraAnterior(Util.adicionarZerosEsquedaNumero(6,
											"" + imovelLigacoesMedicaoIndividualizada[3]));
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setLeituraAnterior("");
						}

						if(imovelLigacoesMedicaoIndividualizada[4] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setDataLeituraAtual(Util
											.formatarData((Date) imovelLigacoesMedicaoIndividualizada[4]));
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setDataLeituraAtual("");
						}

						if(imovelLigacoesMedicaoIndividualizada[5] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setLeituraAtual(Util.adicionarZerosEsquedaNumero(6, ""
											+ imovelLigacoesMedicaoIndividualizada[5]));
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setLeituraAtual("");
						}

						if(imovelLigacoesMedicaoIndividualizada[6] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setConsumoImoveisVinculados(""
											+ imovelLigacoesMedicaoIndividualizada[6]);
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setConsumoImoveisVinculados("0");
						}

						if(imovelLigacoesMedicaoIndividualizada[7] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setAnormalidade(Util.adicionarZerosEsquedaNumero(2, ""
											+ imovelLigacoesMedicaoIndividualizada[7]));

						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setAnormalidade("00");
						}
						
						if(imovelLigacoesMedicaoIndividualizada[24] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
											.setAnormalidadeLeitura((String) imovelLigacoesMedicaoIndividualizada[24]);

						}

						if(imovelLigacoesMedicaoIndividualizada[8] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setMedia(Util.adicionarZerosEsquedaNumero(5, ""
											+ imovelLigacoesMedicaoIndividualizada[8]));
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setMedia("00000");
						}
						
						ContaHistorico contaHistoricoRetificada = null;

						if(imovelLigacoesMedicaoIndividualizada[11] != null){
							String anormalidadeConsumo = (String) imovelLigacoesMedicaoIndividualizada[11];

							FiltroConsumoAnormalidade filtroConsumoAnormalidade = new FiltroConsumoAnormalidade();
							filtroConsumoAnormalidade.adicionarParametro(new ParametroSimples(
											FiltroConsumoAnormalidade.DESCRICAO_ABREVIADA, anormalidadeConsumo));

							ConsumoAnormalidade consumoAnormalidade = (ConsumoAnormalidade) Util
											.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroConsumoAnormalidade,
															ConsumoAnormalidade.class.getName()));

							if(!Util.isVazioOuBranco(consumoAnormalidade)){
								if(consumoAnormalidade.getId().equals(ConsumoAnormalidade.CONSUMO_RETIFICADO)){
									try{
										contaHistoricoRetificada = repositorioFaturamento.pesquisarContaOriginalAntesDaRetificacao(
														(Integer) imovelLigacoesMedicaoIndividualizada[0],
														Integer.valueOf(anoMesfaturamentoGrupo));
									}catch(NumberFormatException e){
										e.printStackTrace();
										throw new ControladorException("erro.sistema", e);
									}catch(ErroRepositorioException e){
										sessionContext.setRollbackOnly();
										throw new ControladorException("erro.sistema", e);
									}

								}
							}
						}

						if(((indicadorEmissaoCampo != null && MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA
										.equals(indicadorEmissaoCampo)) || indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM))
										&& !Util.isVazioOuBranco(movimentoRoteiroImovel)
										&& !Util.isVazioOuBranco(movimentoRoteiroImovel.getNumeroConsumoMedido())){

							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setConsumoFaturado(""
												+ movimentoRoteiroImovel.getNumeroConsumoMedido());
						}else if(!Util.isVazioOuBranco(contaHistoricoRetificada)
										&& !Util.isVazioOuBranco(contaHistoricoRetificada.getConsumoAgua())){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setConsumoFaturado(""
											+ contaHistoricoRetificada.getConsumoAgua());
						}else if(imovelLigacoesMedicaoIndividualizada[9] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setConsumoFaturado(""
											+ imovelLigacoesMedicaoIndividualizada[9]);
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setConsumoFaturado("0");
						}

						if(idImovelCondominio.equals(imovelLigacoesMedicaoIndividualizada[0])){
							// imóvel Condomínio
							if(imovelLigacoesMedicaoIndividualizada[9] != null && imovelLigacoesMedicaoIndividualizada[6] != null){
								int diferencaMacroMicros = 0;
								int consumoFaturadoMacro = ((Integer) imovelLigacoesMedicaoIndividualizada[9]).intValue();
								int consumoFaturadoMicros = ((Integer) imovelLigacoesMedicaoIndividualizada[6]).intValue();

								diferencaMacroMicros = consumoFaturadoMacro - consumoFaturadoMicros;

								// caso a diferente seja negativa ou igual a zero, o valor no
								// relatório sairá zero
								if(diferencaMacroMicros <= 0){
									faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setDiferencaConsumoMacroMicros("0");
								}else{
									faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setDiferencaConsumoMacroMicros(""
													+ diferencaMacroMicros);
								}

								if(imovelLigacoesMedicaoIndividualizada[23] != null){

									idRateioTipo = (Integer) imovelLigacoesMedicaoIndividualizada[23];
								}

							}else{
								faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setDiferencaConsumoMacroMicros("0");
							}
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setDiferencaConsumoMacroMicros("0");
						}

						int qtdFilhos = 0;
						int rateio = 0;
						qtdFilhos = colecaoImovelLigacoesMedicaoIndividualizada.size() - 1;

						if(consumoRateioMacro == 0){

							if(imovelLigacoesMedicaoIndividualizada[10] != null){

								consumoRateioMacro = Integer.valueOf("" + imovelLigacoesMedicaoIndividualizada[10]).intValue();

							}

						}

						if(idRateioTipo.equals(RateioTipo.RATEIO_VALOR_POR_IMOVEL)){

							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setRateio("" + Integer.valueOf(consumoRateioMacro));
						}else{

							if(qtdFilhos > 0){

								rateio = consumoRateioMacro / qtdFilhos;
								faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setRateio("" + Integer.valueOf(rateio));
							}
						}

						if(faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.getRateio() == null){

							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setRateio("0");
						}

						if(imovelLigacoesMedicaoIndividualizada[11] != null){
							String anormalidadeConsumo = (String) imovelLigacoesMedicaoIndividualizada[11];

							if(Util.validarValorNaoNumerico(anormalidadeConsumo)){
								faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setAnormalidadeConsumo(anormalidadeConsumo);
							}else{
								faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setAnormalidadeConsumo(Util
												.adicionarZerosEsquedaNumero(2, anormalidadeConsumo));
							}

						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setAnormalidadeConsumo("00");
						}

						if(imovelLigacoesMedicaoIndividualizada[12] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setTipoConsumo(""
											+ imovelLigacoesMedicaoIndividualizada[12]);
						}

						if(imovelLigacoesMedicaoIndividualizada[13] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setConsumoEsgoto(""
											+ imovelLigacoesMedicaoIndividualizada[13]);
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setConsumoEsgoto("0");
						}

						if(imovelLigacoesMedicaoIndividualizada[14] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setCodigoSetorComercial(""
											+ imovelLigacoesMedicaoIndividualizada[14]);
						}

						if(imovelLigacoesMedicaoIndividualizada[15] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setNumeroQuadra(""
											+ imovelLigacoesMedicaoIndividualizada[15]);
						}

						if(imovelLigacoesMedicaoIndividualizada[16] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setNumeroLote(""
											+ imovelLigacoesMedicaoIndividualizada[16]);
						}

						if(imovelLigacoesMedicaoIndividualizada[17] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setNumeroSubLote(""
											+ imovelLigacoesMedicaoIndividualizada[17]);
						}

						if(imovelLigacoesMedicaoIndividualizada[18] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setNomeConsumidor(""
											+ imovelLigacoesMedicaoIndividualizada[18]);
						}

						if(imovelLigacoesMedicaoIndividualizada[19] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setLigacaoSituacaoAgua(""
											+ imovelLigacoesMedicaoIndividualizada[19]);
						}

						if(imovelLigacoesMedicaoIndividualizada[20] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setLigacaoSituacaoEsgoto(""
											+ imovelLigacoesMedicaoIndividualizada[20]);
						}

						if(imovelLigacoesMedicaoIndividualizada[21] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setNumeroHidrometro(""
											+ imovelLigacoesMedicaoIndividualizada[21]);
						}

						if(imovelLigacoesMedicaoIndividualizada[22] != null){
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setIndicadorImovelCondominio(""
											+ imovelLigacoesMedicaoIndividualizada[22]);
						}

						BigDecimal valorSemRateio = new BigDecimal("0.00");
						BigDecimal valorComRateio = new BigDecimal("0.00");

						try{

							valorSemRateio = this.determinarValoresFaturamentoAguaEsgoto((Integer) imovelLigacoesMedicaoIndividualizada[0],
											anoMesfaturamentoGrupo, "0", contaHistoricoRetificada);

							/*
							 * Caso o tipo de rateio seja "rateio de valor por imóvel"
							 */
							if(idImovelCondominio.equals((Integer) imovelLigacoesMedicaoIndividualizada[0])
											&& idRateioTipo.equals(RateioTipo.RATEIO_VALOR_POR_IMOVEL)){

								/*
								 * [SB0001 - Determinar Valores para Faturamento de Água e/ou
								 * Esgoto] com dados do imóvel condomínio e o consumo a ser rateado
								 * do macro. O sistema divide o valor encontrado pelo número de
								 * imóveis vinculados para definir o valor do rateio (passo 5.3.2).
								 */
								FiltroImovel filtroImovel = new FiltroImovel();
								filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovelCondominio));
								filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.ROTA);
								filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LIGACAO_AGUA_SITUACAO);
								filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LIGACAO_ESGOTO_SITUACAO);
								Imovel imovelCondominio = (Imovel) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroImovel,
												Imovel.class.getName()));

								// Obtém o valor de água e esgoto a ser rateado
								Object[] valoresRatearAguaEsgoto = getControladorMicromedicao()
												.calcularValorRateioAguaEsgotoImovelCondominio(imovelCondominio,
																Util.obterInteger(anoMesfaturamentoGrupo), consumoRateioMacro, qtdFilhos);

								BigDecimal valorRatearAgua = (BigDecimal) valoresRatearAguaEsgoto[0];
								BigDecimal valorRatearEsgoto = (BigDecimal) valoresRatearAguaEsgoto[1];
								rateioValorPorImovel = valorRatearAgua.add(valorRatearEsgoto);
							}

							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setValorSemRateio(valorSemRateio.toString());

							// Caso o tipo de rateio seja "rateio de valor por imóvel"
							if(idRateioTipo.equals(RateioTipo.RATEIO_VALOR_POR_IMOVEL)){

								// O sistema calcula o valor com rateio, que é a soma do valor sem
								// rateio e do valor do rateio calculado no passo 5.3.2
								valorComRateio = valorSemRateio.add(rateioValorPorImovel);
							}else{

								valorComRateio = this.determinarValoresFaturamentoAguaEsgoto(
												(Integer) imovelLigacoesMedicaoIndividualizada[0], anoMesfaturamentoGrupo,
												faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.getRateio(),
												contaHistoricoRetificada);
							}


							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setValorComRateio(valorComRateio.toString());

							if(!idImovelCondominio.equals(imovelLigacoesMedicaoIndividualizada[0])){
								totalValorSemRateio = totalValorSemRateio.add(valorSemRateio);
								totalValorComRateio = totalValorComRateio.add(valorComRateio);
							}

						}catch(ErroRepositorioException e){
							e.printStackTrace();
						}

						faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setIndicadorQuebraImovelCondominio(""
										+ indicadorQuebraImovelCondominio);

						// qtde de imoveis menos o imovel condominio
						somaQtdeImoveis = colecaoImovelLigacoesMedicaoIndividualizada.size() - 1;

						if(idImovelCondominio.equals(imovelLigacoesMedicaoIndividualizada[0])){
							// imóvel Condomínio
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setTotalConsumidoresRateioMacromedidor(""
											+ somaQtdeImoveis);
						}else{
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setTotalConsumidoresRateioMacromedidor("0");
						}

						cont++;

						if(cont == colecaoImovelLigacoesMedicaoIndividualizada.size()){
							BigDecimal diferencaComRateioSemRateio = new BigDecimal("0.00");

							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setNumeroEconomiasRateio("" + somaQtdeEconomias);

							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setTotalValorSemRateio("" + totalValorSemRateio);
							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setTotalValorComRateio("" + totalValorComRateio);

							diferencaComRateioSemRateio = diferencaComRateioSemRateio.add(totalValorComRateio);
							diferencaComRateioSemRateio = diferencaComRateioSemRateio.subtract(totalValorSemRateio);

							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper
											.setDiferencaComRateioSemRateio(diferencaComRateioSemRateio.toString());

							BigDecimal valorRateioProxFat = new BigDecimal("0.00");

							if(somaQtdeImoveis > 0){
								valorRateioProxFat = diferencaComRateioSemRateio.divide(new BigDecimal(somaQtdeImoveis), 2,
												BigDecimal.ROUND_DOWN);
							}

							faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper.setValorRateioProxFat(valorRateioProxFat.toString());
						
							if(diferencaComRateioSemRateio.compareTo(BigDecimal.ZERO) > 0){
								temRateio = true;
							}
						}

						colecaoRetornoAux.add(faturamentoLigacoesMedicaoIndividualizadaRelatorioHelper);

						// Preenche o relatório conforme opção selecionada para o rateio
						if(cont == colecaoImovelLigacoesMedicaoIndividualizada.size()){
							if(indicadorRateio.intValue() == ConstantesSistema.SIM.intValue()){
								if(temRateio){
									if(!Util.isVazioOrNulo(colecaoRetornoAux)){
										for(FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper fatLigMedInd : colecaoRetornoAux){
											colecaoRetorno.add(fatLigMedInd);
										}
									}
								}
							}else if(indicadorRateio.intValue() == ConstantesSistema.NAO.intValue()){
								if(!temRateio){
									if(!Util.isVazioOrNulo(colecaoRetornoAux)){
										for(FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper fatLigMedInd : colecaoRetornoAux){
											colecaoRetorno.add(fatLigMedInd);
										}
									}
								}
							}else{
								if(!Util.isVazioOrNulo(colecaoRetornoAux)){
									for(FaturamentoLigacoesMedicaoIndividualizadaRelatorioHelper fatLigMedInd : colecaoRetornoAux){
										colecaoRetorno.add(fatLigMedInd);
									}
								}
							}

							colecaoRetornoAux.clear();
						}

					}

				}

			}

		}

		return colecaoRetorno;
	}

	/**
	 * [UC0532] Gerar Relatório de Faturamento das Ligações com Medição Individualizada
	 * [SB0001 – Determinar Valores para Faturamento de Água e/ou Esgoto].
	 * 
	 * @author Carlos Chrystian
	 * @data 04/05/2012
	 * @param idImovel
	 * @param anoMesFaturamento
	 * @param rateio
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	private BigDecimal determinarValoresFaturamentoAguaEsgoto(Integer idImovel, String anoMesFaturamento, String rateio,
					ContaHistorico contaHistoricoRetificada) throws ControladorException, ErroRepositorioException{

		// Coleção que vai armazenar as categorias do imóvel
		Collection colecaoCategorias = null;

		// [UC0120] - Calcular Valores de Água e/ou Esgoto
		BigDecimal valorTotalAgua = new BigDecimal("0.00");
		BigDecimal valorTotalEsgoto = new BigDecimal("0.00");
		BigDecimal valorTotalAguaEsgoto = new BigDecimal("0.00");

		Collection colecaoCalcularValoresAguaEsgotoHelper = null;

		Integer anoMesReferencia = Integer.valueOf(anoMesFaturamento);
		BigDecimal percentualEsgoto = BigDecimal.ZERO;
		Integer consumoFaturadoMesAgua = null;
		Integer consumoFaturadoMesEsgoto = null;
		ConsumoHistorico consumoHistoricoAgua = null;
		ConsumoHistorico consumoHistoricoEsgoto = null;
		// Pesquisar consumo histórico
		MedicaoHistorico medicaoHistoricoAgua = null;
		MedicaoHistorico medicaoHistoricoPoco = null;

		// Cria o tipo de ligação para água.
		LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
		ligacaoTipoAgua.setId(LigacaoTipo.LIGACAO_AGUA);

		// Cria o tipo de ligação para esgoto.
		LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
		ligacaoTipoEsgoto.setId(LigacaoTipo.LIGACAO_ESGOTO);

		// 3.3.21. Valor com rateio e sem rateio:

		Imovel imovel = this.getControladorImovel().pesquisarImovel(idImovel);

		// Alteração conforme OC0857313
		// .......................................................

		// 3.3.21.1. Caso o imóvel seja ligado ou cortado de água
		// e/ou ligado de esgoto
		// [SB0001 – Determinar Valores para Faturamento de Água e/ou Esgoto].

		// if((imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO) ||
		// imovel.getLigacaoAguaSituacao().getId().equals(
		// LigacaoAguaSituacao.CORTADO))
		// || imovel.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.LIGADO)){
		if(imovel.getLigacaoAguaSituacao() != null && imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao() != null
						&& imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){
			// .......................................................

			// [SB0001 – Determinar Valores para Faturamento de Água e/ou Esgoto].

			// 1. O sistema calcula os valores de água e/ou esgoto
			// <<Inclui>> [UC0120 – Calcular Valores de Água e/ou Esgoto], passando os seguintes
			// parâmetros: 1.1. Ano e mês de referência. - 1.2. Situação da ligação de água (LAST_ID
			// da tabela imóvel).
			// 1.3. Situação da ligação de esgoto (LEST_ID da tabela imóvel).

			/*
			 * Caso o imóvel tenha Sit. de Faturamento Ativa ou Não-Ativa com Consumo
			 */
			consumoHistoricoAgua = getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipoAgua,
							anoMesReferencia.intValue());

			// Inicializa com zero o percentual de esgoto o consumo faturado do mês de água e de
			// esgoto
			percentualEsgoto = new BigDecimal(0);
			consumoFaturadoMesAgua = Integer.valueOf("0");
			consumoFaturadoMesEsgoto = Integer.valueOf("0");

			// Seta valores iniciais para os indicadores de faturamento de água e esgoto.
			Short indicadorFaturamentoAgua = Short.valueOf("2");
			Short indicadorFaturamentoEsgoto = Short.valueOf("2");

			// 1.4. Indicador de faturamento de água
			// 1.7. Consumo faturado de água do mês
			// Verifica se existe consumo histórico de água
			if(consumoHistoricoAgua != null){
				if((imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.FATURAMENTO_ATIVO
								.intValue())
								|| (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.NAO_FATURAVEL
												.intValue() && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null && consumoHistoricoAgua
												.getNumeroConsumoFaturadoMes().intValue() > 0)){
					indicadorFaturamentoAgua = Short.valueOf("1");
					// caso exista indicador de Faturamento no Consumo, será assumido o do
					// ConsumoHistorico.
					if(consumoHistoricoAgua.getIndicadorFaturamento() != null){
						// Seta o indicador faturamento água
						indicadorFaturamentoAgua = consumoHistoricoAgua.getIndicadorFaturamento();
					}
					
					if(!Util.isVazioOuBranco(contaHistoricoRetificada) && !Util.isVazioOuBranco(contaHistoricoRetificada.getConsumoAgua())){
						consumoFaturadoMesAgua = contaHistoricoRetificada.getConsumoAgua() + Integer.valueOf(rateio);
						
					}else{
						consumoFaturadoMesAgua = consumoHistoricoAgua.getNumeroConsumoFaturadoMes() + Integer.valueOf(rateio);
					}
				}
			}

			// 1.5. Indicador de faturamento de esgoto
			// 1.8. Consumo faturado de esgoto do mês
			// Pesquisa o consumo histórico de esgoto do imóvel para o ano mês de referência
			consumoHistoricoEsgoto = getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipoEsgoto,
							anoMesReferencia.intValue());
			if(consumoHistoricoEsgoto != null
							&& imovel.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue()){
				if(consumoHistoricoEsgoto.getIndicadorFaturamento() != null){
					// Seta o indicador faturamento esgoto
					indicadorFaturamentoEsgoto = consumoHistoricoEsgoto.getIndicadorFaturamento();
				}

				if(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null){
					if(!Util.isVazioOuBranco(consumoHistoricoAgua)
									&& consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null
									&& consumoHistoricoAgua.getNumeroConsumoFaturadoMes() >= consumoHistoricoEsgoto
													.getNumeroConsumoFaturadoMes()){
						if(!Util.isVazioOuBranco(contaHistoricoRetificada)
										&& !Util.isVazioOuBranco(contaHistoricoRetificada.getConsumoEsgoto())){
							consumoFaturadoMesEsgoto = contaHistoricoRetificada.getConsumoEsgoto() + Integer.valueOf(rateio);
						}else{
							consumoFaturadoMesEsgoto = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() + Integer.valueOf(rateio);
						}
					}else{
						if(!Util.isVazioOuBranco(contaHistoricoRetificada)
										&& !Util.isVazioOuBranco(contaHistoricoRetificada.getConsumoEsgoto())){
							consumoFaturadoMesEsgoto = contaHistoricoRetificada.getConsumoEsgoto();
						}else{
							consumoFaturadoMesEsgoto = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
						}
					}
				}
			}

			// 1.6. Categoria(s) do imóvel e sua(s) respectiva(s) quantidade(s) de economias
			// retornadas pelo <<Inclui>>[UC0108 Obter Quantidade de Economias por Categoria].
			// [UC0108] - Obter Quantidade de Economias por Categoria
			colecaoCategorias = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

			// 1.9. Consumo mínimo da ligação <<Inclui>> [UC0105 – Obter Consumo Mínimo da Ligação];
			// [UC0105] - Obter Consumo Mínimo da Ligação
			int consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, null);

			// 1.10. Data de Leitura Anterior
			Integer ligacaoAguaSituacaoId = imovel.getLigacaoAguaSituacao().getId();
			Integer ligacaoEsgotoSituacaoId = imovel.getLigacaoEsgotoSituacao().getId();

			Calendar data = new GregorianCalendar();
			data.set(Calendar.YEAR, Integer.parseInt(anoMesReferencia.toString().substring(0, 4)));
			data.set(Calendar.MONTH, Integer.parseInt(anoMesReferencia.toString().substring(4, 6)) - 1);
			data.set(Calendar.DATE, 1);
			data.add(Calendar.MONTH, -1);

			String anoMesAnterior = "";
			anoMesAnterior = data.get(Calendar.YEAR) + "";
			if((data.get(Calendar.MONTH) + 1) < 10){
				anoMesAnterior = anoMesAnterior + "0" + (data.get(Calendar.MONTH) + 1);
			}else{
				anoMesAnterior = anoMesAnterior + (data.get(Calendar.MONTH) + 1);
			}

			Date dataLeituraAnteriorFaturamento = null;
			try{
				// Determina a data de leitura anterior do faturamento

				dataLeituraAnteriorFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(imovel
								.getRota().getFaturamentoGrupo().getId(), FaturamentoAtividade.EFETUAR_LEITURA,
								Integer.valueOf(anoMesAnterior));

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			// 1.11. Data de Leitura Atual
			// Determina a data de leitura atual do faturamento
			Date dataLeituraAtualFaturamento = null;
			try{
				dataLeituraAtualFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(imovel
								.getRota().getFaturamentoGrupo().getId(), FaturamentoAtividade.EFETUAR_LEITURA, anoMesReferencia);

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			// Verifica se existe medição histórico
			medicaoHistoricoAgua = getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(imovel.getId(), anoMesReferencia);
			if(medicaoHistoricoAgua != null){

				// Seta a data de letura anterior faturamento
				if(medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento() != null){
					dataLeituraAnteriorFaturamento = medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento();
				}

				// Seta a data de leitura atual faturamento
				if(medicaoHistoricoAgua.getDataLeituraAtualFaturamento() != null){
					dataLeituraAtualFaturamento = medicaoHistoricoAgua.getDataLeituraAtualFaturamento();
				}
			}

			// Caso o imóvel seja ligado de esgoto
			if(imovel.getLigacaoEsgoto() != null && imovel.getLigacaoEsgotoSituacao() != null
							&& imovel.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue()){
				// consultar medicao hisotrico tipo poco
				medicaoHistoricoPoco = this.getControladorMicromedicao()
								.pesquisarMedicaoHistoricoTipoPoco(imovel.getId(), anoMesReferencia);

				// Verifica se existe medição histórico para poço
				if(medicaoHistoricoPoco != null){

					// Seta a data de leitura anterior faturamento
					if(medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento() != null){
						dataLeituraAnteriorFaturamento = medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento();
					}

					// Seta a data atual de faturamento
					if(medicaoHistoricoPoco.getDataLeituraAtualFaturamento() != null){
						dataLeituraAtualFaturamento = medicaoHistoricoPoco.getDataLeituraAtualFaturamento();
					}
				}
				// Recupera o percentual de esgoto.
				percentualEsgoto = this.obterPercentualLigacaoEsgotoImovel(imovel.getId());
			}

			// Obtém a tarifa do imóvel
			Integer consumoTarifaId = imovel.getConsumoTarifa().getId();

			if(dataLeituraAnteriorFaturamento == null || dataLeituraAtualFaturamento == null){

				FaturamentoAtivCronRota faturamentoAtivCronRota = this.obterFaturamentoAtividadeCronogramaPorGrupoFaturamentoRota(
								FaturamentoAtividade.EFETUAR_LEITURA, anoMesReferencia, imovel.getRota().getFaturamentoGrupo(), imovel
												.getQuadra().getRota());

				Date periodoLeitura[] = gerarPeriodoLeituraFaturamento(dataLeituraAtualFaturamento, dataLeituraAnteriorFaturamento,
								faturamentoAtivCronRota, Integer.valueOf(anoMesAnterior), anoMesReferencia);
				dataLeituraAnteriorFaturamento = periodoLeitura[0];
				dataLeituraAtualFaturamento = periodoLeitura[1];
			}

			// [UC0120] - Calcular Valores de Água e/ou Esgoto
			colecaoCalcularValoresAguaEsgotoHelper = calcularValoresAguaEsgoto(anoMesReferencia, ligacaoAguaSituacaoId,
							ligacaoEsgotoSituacaoId, indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategorias,
							consumoFaturadoMesAgua, consumoFaturadoMesEsgoto, consumoMinimoLigacao, dataLeituraAnteriorFaturamento,
							dataLeituraAtualFaturamento, percentualEsgoto, consumoTarifaId, imovel.getId(), null);

			for(Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper.iterator(); iteratorColecaoCalcularValoresAguaEsgotoHelper
							.hasNext();){

				CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
								.next();
				/*
				 * Caso tenha valor de água faturado para categoria adiciona o valor de água ao
				 * valor total de água. Caso contrário soma zero.
				 */
				if(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria() != null){
					valorTotalAgua = valorTotalAgua.add(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria());
				}else{
					valorTotalAgua = valorTotalAgua.add(new BigDecimal("0.00"));
				}

				if(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria() != null){
					valorTotalEsgoto = valorTotalEsgoto.add(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria());
				}else{
					valorTotalEsgoto = valorTotalEsgoto.add(new BigDecimal("0.00"));
				}
			}

			valorTotalAguaEsgoto = valorTotalAguaEsgoto.add(valorTotalAgua);
			valorTotalAguaEsgoto = valorTotalAguaEsgoto.add(valorTotalEsgoto);
		}

		return valorTotalAguaEsgoto;
	}

	/**
	 * [UC0493] Emitir de Extrato de Consumo de Imóvel Condomínio
	 * Flávio Cordeiro 08/01/2007
	 */
	public void emitirExtratoConsumoImovelCondominio(String anoMesFaturamento, String idFaturamento, int idFuncionalidadeIniciada)
					throws ControladorException{

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		int idUnidadeIniciada = 0;
		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, 0);

		try{
			Collection rotasFaturamento;

			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID, idFaturamento));

			filtroFaturamentoAtividadeCronograma
							.adicionarParametro(new ParametroSimples(
											FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
											anoMesFaturamento));

			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, FaturamentoAtividade.FATURAR_GRUPO));

			Collection colecaoFaturamentoAtividade = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
							FaturamentoAtividadeCronograma.class.getName());

			rotasFaturamento = RepositorioBatchHBM.getInstancia().pesquisarRotasProcessamentoBatchFaturamentoComandado(
							((FaturamentoAtividadeCronograma) colecaoFaturamentoAtividade.iterator().next()).getId());

			Collection idsRotas = new ArrayList();
			Iterator iteratorRotasFat = rotasFaturamento.iterator();
			while(iteratorRotasFat.hasNext()){
				Object[] objeto = (Object[]) iteratorRotasFat.next();

				idsRotas.add(((Rota) objeto[1]).getId());

			}

			StringBuilder txt = new StringBuilder();

			boolean flagFimPesquisa = false;
			final int quantidadeEmitir = 1000;
			int quantidadeEmitirInicio = 0;

			int sequencialImpressao = 0;

			while(!flagFimPesquisa){

				Collection colecaoEmitir = repositorioFaturamento
								.pesquisarEmitirExtratoConsumoImovelCondominio(idsRotas, anoMesFaturamento);

				if(!colecaoEmitir.isEmpty()){

					EmitirConsumoImovelCondominimoHelper emitirConsumoImovelCondominimoHelper = null;
					Cliente cliente = null;
					String endereco = "";
					String mesAnoDigito = "";
					int count = 0;

					if(colecaoEmitir.size() < quantidadeEmitir){
						flagFimPesquisa = true;
					}else{
						quantidadeEmitirInicio = quantidadeEmitirInicio + 1000;
					}

					int metadeColecao = 0;
					if(colecaoEmitir.size() % 2 == 0){
						metadeColecao = colecaoEmitir.size() / 2;
					}else{
						metadeColecao = (colecaoEmitir.size() / 2) + 1;
					}

					Map<Integer, Map<Object, Object>> mapEmitirOrdenada = getControladorUtil().dividirColecao(colecaoEmitir);

					if(mapEmitirOrdenada != null){
						int countOrdem = 0;

						while(countOrdem < mapEmitirOrdenada.size()){
							Map<Object, Object> mapEmitirDivididas = mapEmitirOrdenada.get(countOrdem);

							Iterator iteratorEmitir = mapEmitirDivididas.keySet().iterator();

							while(iteratorEmitir.hasNext()){
								emitirConsumoImovelCondominimoHelper = new EmitirConsumoImovelCondominimoHelper();

								int situacao = 0;

								Object[] objetoEmitir = (Object[]) iteratorEmitir.next();

								sequencialImpressao++;

								while(situacao < 2){
									if(situacao == 0){
										situacao = 1;
										sequencialImpressao = atualizaSequencial(sequencialImpressao, situacao, metadeColecao);

									}else{
										objetoEmitir = (Object[]) mapEmitirDivididas.get(objetoEmitir);
										situacao = 2;
										sequencialImpressao = atualizaSequencial(sequencialImpressao, situacao, metadeColecao);
									}
									if(objetoEmitir == null){
										break;
									}
									// idImovel
									if(objetoEmitir[0] != null){
										emitirConsumoImovelCondominimoHelper.setIdImovel((Integer) objetoEmitir[0]);
									}
									// idLocalidade
									if(objetoEmitir[1] != null){
										emitirConsumoImovelCondominimoHelper.setIdLocalidade((Integer) objetoEmitir[1]);
									}
									// nomeLocalidade
									if(objetoEmitir[2] != null){
										emitirConsumoImovelCondominimoHelper.setNomeLocalidade((String) objetoEmitir[2]);
									}
									// dataLeituraAtualFat
									if(objetoEmitir[3] != null){
										emitirConsumoImovelCondominimoHelper.setDataLeituraAtualFat((Date) objetoEmitir[3]);
									}
									// numero leitura atual fat
									if(objetoEmitir[4] != null){
										emitirConsumoImovelCondominimoHelper.setNumeroLeituraAtualFat((Integer) objetoEmitir[4]);
									}else{
										emitirConsumoImovelCondominimoHelper.setNumeroLeituraAtualFat(Integer.valueOf(0));
									}
									// consumo fat mes
									if(objetoEmitir[5] != null){
										emitirConsumoImovelCondominimoHelper.setConsumoFaturado((Integer) objetoEmitir[5]);
									}else{
										emitirConsumoImovelCondominimoHelper.setConsumoFaturado(Integer.valueOf(0));
									}
									// descricao da leitura atual
									if(objetoEmitir[6] != null){
										emitirConsumoImovelCondominimoHelper.setDescricaoLeituraSituacao((String) objetoEmitir[6]);
									}else{
										emitirConsumoImovelCondominimoHelper.setDescricaoLeituraSituacao("");
									}
									// descricao tipo de sconsumo
									if(objetoEmitir[7] != null){
										emitirConsumoImovelCondominimoHelper.setDescricaoConsumoTipo((String) objetoEmitir[7]);
									}else{
										emitirConsumoImovelCondominimoHelper.setDescricaoConsumoTipo("");
									}
									// descricao anormalidade de consumo
									if(objetoEmitir[8] != null){
										emitirConsumoImovelCondominimoHelper.setDescricaoAnormalidadeConsumo((String) objetoEmitir[8]);
									}else{
										emitirConsumoImovelCondominimoHelper.setDescricaoAnormalidadeConsumo("");
									}
									// qtd economias
									if(objetoEmitir[9] != null){
										emitirConsumoImovelCondominimoHelper.setQtdEconomias((Integer) objetoEmitir[9]);
									}
									// situacao ligacao agua
									if(objetoEmitir[10] != null){
										emitirConsumoImovelCondominimoHelper.setSituacaoAgua((Integer) objetoEmitir[10]);
									}else{
										emitirConsumoImovelCondominimoHelper.setSituacaoAgua(Integer.valueOf(0));
									}
									// situacao Ligacao Esgoto
									if(objetoEmitir[11] != null){
										emitirConsumoImovelCondominimoHelper.setSituacaoEsgoto((Integer) objetoEmitir[11]);
									}else{
										emitirConsumoImovelCondominimoHelper.setSituacaoEsgoto(Integer.valueOf(0));
									}
									// Abreviacao Consumo Tipo
									if(objetoEmitir[12] != null){
										emitirConsumoImovelCondominimoHelper.setAbreviadaConsumoTipo((String) objetoEmitir[12]);
									}else{
										emitirConsumoImovelCondominimoHelper.setAbreviadaConsumoTipo("");
									}
									// anormalidade leitura faturada
									if(objetoEmitir[13] != null){
										emitirConsumoImovelCondominimoHelper.setAnormalidadeLeituraFat((Integer) objetoEmitir[13]);
									}else{
										emitirConsumoImovelCondominimoHelper.setAnormalidadeLeituraFat(Integer.valueOf(0));
									}
									// Consumo anormalidade abreviada
									if(objetoEmitir[14] != null){
										emitirConsumoImovelCondominimoHelper.setAbreviadaConsumoAnormalidade((String) objetoEmitir[14]);
									}else{
										emitirConsumoImovelCondominimoHelper.setAbreviadaConsumoAnormalidade("");
									}
									// Perfil tipo
									if(objetoEmitir[15] != null){
										emitirConsumoImovelCondominimoHelper.setPerfilImovel((Integer) objetoEmitir[15]);
									}
									// Data leitura anterior Faturamento
									if(objetoEmitir[16] != null){
										emitirConsumoImovelCondominimoHelper.setDataLeituraAnteriorFat((Date) objetoEmitir[16]);
									}
									// Consumo Medio
									if(objetoEmitir[17] != null){
										emitirConsumoImovelCondominimoHelper.setConsumoMedio((Integer) objetoEmitir[17]);
									}
									// rateio
									if(objetoEmitir[18] != null){
										emitirConsumoImovelCondominimoHelper.setRateio((Integer) objetoEmitir[18]);
									}
									// id Empresa
									if(objetoEmitir[19] != null){
										emitirConsumoImovelCondominimoHelper.setIdEmpresa((Integer) objetoEmitir[19]);
									}
									// idLeituraSituacao
									if(objetoEmitir[20] != null){
										emitirConsumoImovelCondominimoHelper.setIdLeituraSituacao((Integer) objetoEmitir[20]);
									}

									// consumorateio
									String consumoVinculados = "0";
									if(objetoEmitir[25] != null){
										consumoVinculados = "" + ((Integer) objetoEmitir[25]);
									}

									String codigoAuxiliar = emitirConsumoImovelCondominimoHelper.getIdLeituraSituacao()
													+ emitirConsumoImovelCondominimoHelper.getAbreviadaConsumoTipo()
													+ "0"
													+ emitirConsumoImovelCondominimoHelper.getAnormalidadeLeituraFat()
													+ emitirConsumoImovelCondominimoHelper.getAbreviadaConsumoAnormalidade()
													+ emitirConsumoImovelCondominimoHelper.getPerfilImovel()
													+ Util.obterQuantidadeDiasEntreDuasDatas(
																	emitirConsumoImovelCondominimoHelper.getDataLeituraAtualFat(),
																	emitirConsumoImovelCondominimoHelper.getDataLeituraAnteriorFat())
													+ emitirConsumoImovelCondominimoHelper.getConsumoMedio();

									cliente = repositorioClienteImovel.retornaClienteUsuario((Integer) objetoEmitir[0]);
									// idCliente
									// nomeCliente
									if(cliente != null){
										emitirConsumoImovelCondominimoHelper.setIdCliente(cliente.getId());
										emitirConsumoImovelCondominimoHelper.setNomeCliente(cliente.getNome());
									}

									if(objetoEmitir[0] != null){
										// inscricaoImovel
										emitirConsumoImovelCondominimoHelper.setInscricaoImovel(getControladorImovel()
														.pesquisarInscricaoImovel((Integer) objetoEmitir[0], true));

										// endereco - [UC0085] Obter
										// Endereço
										endereco = getControladorEndereco().pesquisarEnderecoFormatado((Integer) objetoEmitir[0]);
										emitirConsumoImovelCondominimoHelper.setEndereco(endereco);
									}

									// mesAnoDigito - [UC0260] Obter Digito
									// Verificador
									// Modulo 10
									mesAnoDigito = Util.formatarAnoMesParaMesAno(anoMesFaturamento)
													+ "-"
													+ Util.obterDigitoVerificadorModulo10(Long.valueOf(Util.formatarAnoMesParaMesAno(
																	anoMesFaturamento).replace("/", "")));

									count = count + 1;

									// --Linha 1-- //
									// Canal
									txt.append("1");
									// Fonte
									txt.append("1");
									// restante da linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 2-- //
									// Canal
									txt.append("1");
									// Fonte
									txt.append("1");
									txt.append(Util.completaString("", 19));
									// nome da localidade
									txt.append(Util.completaString(emitirConsumoImovelCondominimoHelper.getNomeLocalidade(), 110));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 3-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// Inscricao do imovel
									txt.append(Util.completaString(
													getControladorImovel().pesquisarInscricaoImovel(
																	emitirConsumoImovelCondominimoHelper.getIdImovel(), true), 30));
									// nome do cliente usuario
									txt.append(Util.completaString(emitirConsumoImovelCondominimoHelper.getNomeCliente(), 99));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 4-- //
									// Canal
									txt.append("+");
									// Fonte
									txt.append("2");
									txt.append(Util.completaString("", 64));
									// matricula do imovel
									txt.append(Util.completaString(
													emitirConsumoImovelCondominimoHelper
																	.getIdImovel()
																	.toString()
																	.substring(0,
																					(emitirConsumoImovelCondominimoHelper.getIdImovel()
																									.toString().length() - 1))
																	+ "."
																	+ emitirConsumoImovelCondominimoHelper
																					.getIdImovel()
																					.toString()
																					.substring((emitirConsumoImovelCondominimoHelper
																									.getIdImovel().toString().length() - 1),
																									emitirConsumoImovelCondominimoHelper
																													.getIdImovel()
																													.toString().length()),
													65));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 5-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// endereco
									txt.append(Util.completaString(emitirConsumoImovelCondominimoHelper.getEndereco(), 50));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 6-- //
									// Canal
									txt.append("+");
									// Fonte
									txt.append("2");
									txt.append(Util.completaString("", 64));
									// mes ano referencia faturamento e
									// digito
									txt.append(Util.completaString(mesAnoDigito, 65));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 6A-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									if(emitirConsumoImovelCondominimoHelper.getEndereco() != null
													&& emitirConsumoImovelCondominimoHelper.getEndereco().length() > 50){
										int quantidadePosicoes = emitirConsumoImovelCondominimoHelper.getEndereco().length();
										// Recupera o fim do
										// endereço do
										// cliente
										// responsável
										txt.append(Util.completaString(
														emitirConsumoImovelCondominimoHelper.getEndereco()
																		.substring(50, quantidadePosicoes), 50));
										// compleca com
										// espaços
										// em
										// brancos
										txt.append(Util.completaString("", 79));

									}else{
										// compleca com
										// espaços
										// em
										// brancos
										txt.append(Util.completaString("", 129));
									}

									// --Linha 7-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// restante a linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 8-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("2");
									// restante a linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 9-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append(" ");
									// restante a linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 10-- //
									// Canal
									txt.append("-");
									// Fonte
									txt.append("1");
									// Dados do consumo do mes anterior 1
									txt.append(this.obterDadosConsumoAnterior(emitirConsumoImovelCondominimoHelper.getIdImovel(),
													Integer.valueOf(anoMesFaturamento), 1, LigacaoTipo.LIGACAO_AGUA,
													MedicaoTipo.LIGACAO_AGUA).toString());
									// Dados do consumo do mes anterior 4
									txt.append(this.obterDadosConsumoAnterior(emitirConsumoImovelCondominimoHelper.getIdImovel(),
													Integer.valueOf(anoMesFaturamento), 4, LigacaoTipo.LIGACAO_AGUA,
													MedicaoTipo.LIGACAO_AGUA).toString());
									// Data de Leitura Atual
									txt.append("      " + Util.formatarData(emitirConsumoImovelCondominimoHelper.getDataLeituraAtualFat()));
									txt.append("  ");
									// Leitura Atual
									txt.append(Util.completaString(emitirConsumoImovelCondominimoHelper.getNumeroLeituraAtualFat()
													.toString(), 20));
									// Consumo Faturado
									txt.append(" " + emitirConsumoImovelCondominimoHelper.getConsumoFaturado());
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 11-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// Dados do consumo do mes anterior 2
									txt.append(this.obterDadosConsumoAnterior(emitirConsumoImovelCondominimoHelper.getIdImovel(),
													Integer.valueOf(anoMesFaturamento), 2, LigacaoTipo.LIGACAO_AGUA,
													MedicaoTipo.LIGACAO_AGUA).toString());
									// Dados do consumo do mes anterior 5
									txt.append(this.obterDadosConsumoAnterior(emitirConsumoImovelCondominimoHelper.getIdImovel(),
													Integer.valueOf(anoMesFaturamento), 5, LigacaoTipo.LIGACAO_AGUA,
													MedicaoTipo.LIGACAO_AGUA).toString());
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 12-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// Dados do consumo do mes anterior 3
									txt.append(this.obterDadosConsumoAnterior(emitirConsumoImovelCondominimoHelper.getIdImovel(),
													Integer.valueOf(anoMesFaturamento), 3, LigacaoTipo.LIGACAO_AGUA,
													MedicaoTipo.LIGACAO_AGUA).toString());
									// Dados do consumo do mes anterior 6
									txt.append(this.obterDadosConsumoAnterior(emitirConsumoImovelCondominimoHelper.getIdImovel(),
													Integer.valueOf(anoMesFaturamento), 6, LigacaoTipo.LIGACAO_AGUA,
													MedicaoTipo.LIGACAO_AGUA).toString());
									// situacao da leitura atual
									txt.append("     " + emitirConsumoImovelCondominimoHelper.getDescricaoLeituraSituacao());
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 13-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									txt.append(Util.completaString("", 45));
									// tipo de consumo
									txt.append(emitirConsumoImovelCondominimoHelper.getDescricaoConsumoTipo());
									// anormalidade de consumo
									txt.append(" " + emitirConsumoImovelCondominimoHelper.getDescricaoAnormalidadeConsumo());
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 14-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// Quantidade de economias do imovel
									// condominio
									txt.append(Util.completaStringComEspacoAEsquerda(emitirConsumoImovelCondominimoHelper.getQtdEconomias()
													.toString(), 6));
									// consumo por economia
									txt.append(Util.completaStringComEspacoAEsquerda(
													(emitirConsumoImovelCondominimoHelper.getConsumoFaturado() / emitirConsumoImovelCondominimoHelper
																	.getQtdEconomias()) + "", 12));
									// codigo Auxiliar
									txt.append(Util.completaStringComEspacoAEsquerda(codigoAuxiliar, 16));
									// cod. situacao de agua
									txt.append(" " + emitirConsumoImovelCondominimoHelper.getSituacaoAgua());
									// cod situacao de esgoto
									txt.append(emitirConsumoImovelCondominimoHelper.getSituacaoEsgoto());
									txt.append(Util.completaStringComEspacoAEsquerda("", 8));
									// Constante
									txt.append("IMÓVEL CONDOMÍNIO ");
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 15-- //
									// Canal
									txt.append(" ");
									// Fonte
									txt.append("1");
									// restante da linha em branco
									txt.append(Util.completaString("", 129));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 16-- //
									// Canal
									txt.append("-");
									// Fonte
									txt.append("1");
									// constante
									txt.append(Util.completaString("  CONSUMO DO IMÓVEL CONDOMÍNIO ", 51));
									// consumo faturado
									txt.append(Util.completaStringComEspacoAEsquerda(emitirConsumoImovelCondominimoHelper
													.getConsumoFaturado().toString(), 6));
									txt.append(" M3");
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 17-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// constante
									txt.append(Util.completaString("  SOMA DOS CONSUMOS DOS IMÓVEIS VINCULADOS ", 51));
									// soma dos consumos dos imoveis
									// associados
									String soma = consumoVinculados;
									/*
									 * repositorioFaturamento .somaConsumosImoveisAssociados(
									 * emitirConsumoImovelCondominimoHelper .getIdImovel(),
									 * anoMesFaturamento) + "";
									 */
									if(soma.trim().equals("null")){
										soma = "0";
									}
									txt.append(Util.completaStringComEspacoAEsquerda(soma, 6));
									txt.append(" M3");
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 18-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// constante
									txt.append(Util.completaString("  QUANTIDADE DE IMÓVEIS VINCULADOS ", 51));
									// Quantidade de imoveis associados
									txt.append(Util.completaStringComEspacoAEsquerda(
													repositorioFaturamento.quantidadeImoveisAssociados(
																	emitirConsumoImovelCondominimoHelper.getIdImovel(), anoMesFaturamento)
																	+ "", 6));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 19-- //
									// Canal
									txt.append("0");
									// Fonte
									txt.append("1");
									// constante
									txt.append(Util.completaString("  CONSUMO RATEADO ", 51));
									// rateio
									if(emitirConsumoImovelCondominimoHelper.getRateio() != null){
										txt.append(Util.completaStringComEspacoAEsquerda(emitirConsumoImovelCondominimoHelper.getRateio()
														.toString(), 6));
									}else{
										txt.append(Util.completaStringComEspacoAEsquerda("0", 6));
									}
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));

									// --Linha 20-- //
									// Canal
									txt.append("1");
									// Fonte
									txt.append("1");
									// Faturamento grupo id
									txt.append(Util.completaStringComEspacoAEsquerda("", 9));
									txt.append(Util.completaString(idFaturamento, 29));
									// id empresa
									txt.append(Util.adicionarZerosEsquedaNumero(2, emitirConsumoImovelCondominimoHelper.getIdEmpresa()
													.toString()));
									// seq impresao extrato por empresa
									txt.append(Util.completaString("-" + Util.retornaSequencialFormatado(sequencialImpressao), 27));

									// count
									txt.append(Util.retornaSequencialFormatado(sequencialImpressao));
									// pula para proxima linha
									txt.append(System.getProperty("line.separator"));
								}
							}
							countOrdem++;
						}
					}

					// criar o arquivo zip
					// File compactado = new File("GRUPO_" + idFaturamento
					// + "_extratoConsumoImovelCondominio" + ".zip"); // nomeZip
					// ZipOutputStream zos = new ZipOutputStream(
					// new FileOutputStream(compactado));
					//
					// File leitura = File.createTempFile("GRUPO_" +
					// idFaturamento
					// + "_extratoConsumoImovelCondominio", ".txt");
					// BufferedWriter out = new BufferedWriter(
					// new OutputStreamWriter(new FileOutputStream(leitura
					// .getAbsolutePath())));
					// out.write(txt.toString());
					// out.close();
					//
					// out.close();
					// ZipUtil.adicionarArquivo(zos, leitura);
					//
					// // close the stream
					// zos.close();
					// leitura.delete();
					EnvioEmail envioEmial = getControladorCadastro().pesquisarEnvioEmail(
									EnvioEmail.EMITIR_EXTRATO_CONSUMO_IMOVEL_CONDOMINIO);

					String emailRemetente = envioEmial.getEmailRemetente();
					String tituloMensagem = envioEmial.getTituloMensagem();
					String corpoMensagem = envioEmial.getCorpoMensagem();
					String emailReceptor = envioEmial.getEmailReceptor();

					getControladorUtil().mandaArquivoLeituraEmail("GRUPO_" + idFaturamento + "_extratoConsumoImovelCondominio", txt,
									emailReceptor, emailRemetente, tituloMensagem, corpoMensagem);

					// leitura.delete();
				}

				// --------------------------------------------------------
				//
				// Registrar o fim da execução da Unidade de Processamento
				//
				// --------------------------------------------------------
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

			}

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o
			// processo
			// batch venha a lançar e garantir que a unidade de
			// processamento do
			// batch será atualizada com o erro ocorrido

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);

		}
	}

	/**
	 * [UC0173] Gerar Relatório de Resumo do Faturamento
	 * 
	 * @author Vivianne Sousa
	 * @created 24/01/2007
	 * @return
	 * @throws ControladorException
	 */
	public Integer consultarQtdeRegistrosResumoFaturamentoRelatorio(int mesAnoReferencia, Integer localidade, Integer gerenciaRegional,
					String opcaoTotalizacao) throws ControladorException{

		Integer retorno = 0;

		int anoMesReferencia = Util.formatarMesAnoParaAnoMes(mesAnoReferencia);

		try{

			retorno = repositorioFaturamento.consultarQtdeRegistrosResumoFaturamentoRelatorio(anoMesReferencia, localidade,
							gerenciaRegional, opcaoTotalizacao);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * [UC0335] Gerar Resumo de Pendência
	 * Pesquisar os ids das localidade
	 * 
	 * @author Ana Maria
	 * @date 29/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarIdsLocalidade() throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarIdsLocalidade();
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * @author Ana Maria
	 * @date 26/01/2007
	 * @param idConta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection obterConta(Integer idConta) throws ControladorException{

		try{
			return repositorioFaturamento.obterConta(idConta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Vivianne Sousa
	 * @created 30/01/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarContasEmitidasRelatorio(int anoMesReferencia, Integer grupoFaturamento, Collection esferaPoder)
					throws ControladorException{

		Collection colecaoContasEmitidas = null;
		Collection colecaoRetorno = new ArrayList();

		try{
			colecaoContasEmitidas = repositorioFaturamento
							.consultarContasEmitidasRelatorio(anoMesReferencia, grupoFaturamento, esferaPoder);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(colecaoContasEmitidas != null && !colecaoContasEmitidas.isEmpty()){

			Iterator iterContasEmitidas = colecaoContasEmitidas.iterator();
			ContasEmitidasRelatorioHelper contasEmitidasRelatorioHelper = new ContasEmitidasRelatorioHelper();

			while(iterContasEmitidas.hasNext()){
				Object[] objetoContasEmitidas = (Object[]) iterContasEmitidas.next();
				contasEmitidasRelatorioHelper = new ContasEmitidasRelatorioHelper();
				contasEmitidasRelatorioHelper.setIdGrupoFaturamento("" + grupoFaturamento);
				contasEmitidasRelatorioHelper.setMesAnoReferencia(Util.formatarAnoMesParaMesAno(anoMesReferencia));

				// id da Conta
				if(objetoContasEmitidas[0] != null){
					contasEmitidasRelatorioHelper.setIdContaImpressao("" + objetoContasEmitidas[0]);
				}

				// id do cliente responsável
				if(objetoContasEmitidas[1] != null){
					contasEmitidasRelatorioHelper.setIdClienteResponsavel("" + objetoContasEmitidas[1]);

					String endereco = getControladorEndereco().pesquisarEnderecoClienteAbreviado((Integer) objetoContasEmitidas[1]);

					contasEmitidasRelatorioHelper.setEndereco(endereco);
				}

				// nome do cliente responsável
				if(objetoContasEmitidas[2] != null){
					contasEmitidasRelatorioHelper.setNomeClienteResponsavel("" + objetoContasEmitidas[2]);
				}

				// id da localidade
				if(objetoContasEmitidas[3] != null){
					contasEmitidasRelatorioHelper.setIdLocalidade("" + objetoContasEmitidas[3]);
				}

				// descrição da localidade
				if(objetoContasEmitidas[4] != null){
					contasEmitidasRelatorioHelper.setDescLocalidade("" + objetoContasEmitidas[4]);
				}

				// data do vencimento da conta
				if(objetoContasEmitidas[5] != null){
					contasEmitidasRelatorioHelper.setDataVencimentoConta(Util.formatarData((Date) objetoContasEmitidas[5]));
				}

				// id do imóvel
				if(objetoContasEmitidas[6] != null){
					contasEmitidasRelatorioHelper.setIdImovel("" + objetoContasEmitidas[6]);
				}

				// codigo do setor comercial
				if(objetoContasEmitidas[7] != null){
					contasEmitidasRelatorioHelper.setCodigoSetorComercial("" + objetoContasEmitidas[7]);
				}

				// numero da quadra
				if(objetoContasEmitidas[8] != null){
					contasEmitidasRelatorioHelper.setNumeroQuadra("" + objetoContasEmitidas[8]);
				}

				// lote
				if(objetoContasEmitidas[9] != null){
					contasEmitidasRelatorioHelper.setNumeroLote("" + objetoContasEmitidas[9]);
				}

				// sublote
				if(objetoContasEmitidas[10] != null){
					contasEmitidasRelatorioHelper.setNumeroSubLote("" + objetoContasEmitidas[10]);
				}

				// nome do cliente usuario
				if(objetoContasEmitidas[11] != null){
					contasEmitidasRelatorioHelper.setNomeUsuario("" + objetoContasEmitidas[11]);
				}

				// valor agua
				if(objetoContasEmitidas[12] != null){
					contasEmitidasRelatorioHelper.setValorAgua((BigDecimal) objetoContasEmitidas[12]);
				}

				// valor esgoto
				if(objetoContasEmitidas[13] != null){
					contasEmitidasRelatorioHelper.setValorEsgoto((BigDecimal) objetoContasEmitidas[13]);
				}

				// valor debitos
				if(objetoContasEmitidas[14] != null){
					contasEmitidasRelatorioHelper.setValorDebitos((BigDecimal) objetoContasEmitidas[14]);
				}

				// valor creditos
				if(objetoContasEmitidas[15] != null){
					contasEmitidasRelatorioHelper.setValorCreditos((BigDecimal) objetoContasEmitidas[15]);
				}

				// id da Esfera Poder
				if(objetoContasEmitidas[16] != null){

					contasEmitidasRelatorioHelper.setIdEsferaPoder("" + objetoContasEmitidas[16]);
				}

				// descrição da Esfera Poder
				if(objetoContasEmitidas[17] != null){
					contasEmitidasRelatorioHelper.setDescEsferaPoder("" + objetoContasEmitidas[17]);
				}

				colecaoRetorno.add(contasEmitidasRelatorioHelper);

			}

		}

		return colecaoRetorno;
	}

	/**
	 * [UC] Gerar Relatório de Contas Emitidas
	 * 
	 * @author Vivianne Sousa
	 * @created 02/02/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQtdeContasEmitidasRelatorio(int anoMesReferencia, Integer grupoFaturamento, Collection esferaPoder)
					throws ControladorException{

		try{
			return repositorioFaturamento.consultarQtdeContasEmitidasRelatorio(anoMesReferencia, grupoFaturamento, esferaPoder);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * retorna o anoMes do faturamento grupo do imóvel passado
	 */
	public Integer retornaAnoMesFaturamentoGrupo(Integer idImovel) throws ControladorException{

		try{
			return repositorioFaturamento.retornaAnoMesFaturamentoGrupo(idImovel);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0001] Inserir Distrito Operacional
	 * 
	 * @author Eduardo Bianchi
	 * @date 26/01/2007
	 * @param Distrito
	 *            Operaciona Descrição do parâmetro
	 */
	public Integer inserirContratoDemanda(ContratoDemanda contratoDemanda, Usuario usuarioLogado) throws ControladorException{

		FiltroContratoDemanda filtroContratoDemanda = new FiltroContratoDemanda();
		filtroContratoDemanda.adicionarParametro(new ParametroSimples(FiltroContratoDemanda.MUMEROCONTRATO, contratoDemanda
						.getNumeroContrato()));

		Collection colecaoContratoDemanda = getControladorUtil().pesquisar(filtroContratoDemanda, ContratoDemanda.class.getName());

		Integer idContratoDemanda = null;

		if(colecaoContratoDemanda.isEmpty()){
			idContratoDemanda = (Integer) getControladorUtil().inserir(contratoDemanda);
		}else{
			throw new ControladorException("atencao.contrato_demanda_existente");
		}

		// // ------------ REGISTRAR TRANSAÇÃO----------------------------
		//
		// RegistradorOperacao registradorOperacao = new RegistradorOperacao(
		// Operacao.OPERACAO_DISTRITO_OPERACIONAL_INSERIR,
		// new UsuarioAcaoUsuarioHelper(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		//
		// Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_DISTRITO_OPERACIONAL_INSERIR);
		//
		// OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		// operacaoEfetuada.setOperacao(operacao);
		//
		// distritoOperacional.setOperacaoEfetuada(operacaoEfetuada);
		// distritoOperacional.adicionarUsuario(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		// registradorOperacao.registrarOperacao(distritoOperacional);
		//
		// // ------------ REGISTRAR TRANSAÇÃO----------------------------

		return idContratoDemanda;
	}

	/**
	 * Permite atualizar os dados de um contrato de demanda
	 * [UC0513] Manter Contrato de Demanda
	 * [SB0001] Atualizar Contrato de Demanda
	 * 
	 * @author Rafael Corrêa
	 * @param usuarioLogado
	 * @date 28/06/2007
	 */
	public void atualizarContratoDemanda(ContratoDemanda contratoDemanda, Usuario usuarioLogado) throws ControladorException{

		// [FS0003] - Atualização realizada por outro usuário
		FiltroContratoDemanda filtroContratoDemanda = new FiltroContratoDemanda();
		filtroContratoDemanda.adicionarParametro(new ParametroSimples(FiltroContratoDemanda.ID, contratoDemanda.getId()));

		Collection colecaoContratoDemandaBase = getControladorUtil().pesquisar(filtroContratoDemanda, ContratoDemanda.class.getName());

		if(colecaoContratoDemandaBase == null || colecaoContratoDemandaBase.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		ContratoDemanda contratoDemandaBase = (ContratoDemanda) colecaoContratoDemandaBase.iterator().next();

		if(contratoDemandaBase.getUltimaAlteracao().after(contratoDemanda.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// [FS0007] - Verificar existência do contrato de demanda
		if(!contratoDemanda.getNumeroContrato().equals(contratoDemandaBase.getNumeroContrato())){
			filtroContratoDemanda.limparListaParametros();
			filtroContratoDemanda.adicionarParametro(new ParametroSimples(FiltroContratoDemanda.MUMEROCONTRATO, contratoDemanda
							.getNumeroContrato()));

			Collection colecaoContratoDemanda = getControladorUtil().pesquisar(filtroContratoDemanda, ContratoDemanda.class.getName());

			if(colecaoContratoDemanda != null && !colecaoContratoDemanda.isEmpty()){
				throw new ControladorException("atencao.contrato_demanda.ja_existente");
			}
		}

		contratoDemanda.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONTRATO_DEMANDA_ATUALIZAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CONTRATO_DEMANDA_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		contratoDemanda.setOperacaoEfetuada(operacaoEfetuada);
		contratoDemanda.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(contratoDemanda);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		getControladorUtil().atualizar(contratoDemanda);

	}

	/**
	 * Monta a colecao de resultdos apartir da tbela conta impressao para geracao do relatorio de
	 * MAPA DE CONTROLE DAS CONTAS EMITIDAS
	 * 
	 * @author Flávio Cordeiro
	 * @date 13/02/2007
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarMapaControleContaRelatorio(Integer idGrupoFaturamento, String mesAno, Usuario usuarioLogado,
					String tipoRelatorio, String indicadorFichaCompensacao) throws ControladorException{

		Collection retorno = new ArrayList();
		try{
			Collection colecaoObjeto = repositorioFaturamento.filtrarMapaControleContaRelatorio(idGrupoFaturamento,
							Util.formatarMesAnoParaAnoMes(mesAno), indicadorFichaCompensacao);

			if(!colecaoObjeto.isEmpty()){

				Iterator iterator = colecaoObjeto.iterator();

				while(iterator.hasNext()){
					Object[] objeto = (Object[]) iterator.next();
					MapaControleContaRelatorioHelper mapaControleContaRelatorioHelper = new MapaControleContaRelatorioHelper();

					// idEmpresa
					// nomeEmpresa
					if(objeto[0] != null){
						mapaControleContaRelatorioHelper.setIdEmpresa((Integer) objeto[0]);
						mapaControleContaRelatorioHelper.setNomeEmpresa((String) objeto[1]);
					}
					// idTipoConta
					// descricaoConta
					if(objeto[2] != null){
						mapaControleContaRelatorioHelper.setIdTipoConta((Integer) objeto[2]);
						mapaControleContaRelatorioHelper.setDescricaoTipoConta((String) objeto[3]);
					}
					// idLocalidade
					if(objeto[4] != null){
						mapaControleContaRelatorioHelper.setIdLocalidade((Integer) objeto[4]);
					}
					// codigoSetorComercial
					if(objeto[5] != null){
						mapaControleContaRelatorioHelper.setCodigoSetor((Integer) objeto[5]);
					}
					// idFaturamentoGrupo
					if(objeto[6] != null){
						mapaControleContaRelatorioHelper.setIdFaturamentoGrupo((Integer) objeto[6]);
					}
					// sequencialInicial
					if(objeto[7] != null){
						mapaControleContaRelatorioHelper.setSequencialInicial((Integer) objeto[7]);
					}
					// sequencialFinal
					if(objeto[8] != null){
						mapaControleContaRelatorioHelper.setSequencialFinal((Integer) objeto[8]);
					}
					// somaValorAgua
					if(objeto[9] != null){
						mapaControleContaRelatorioHelper.setSomaValorAgua((BigDecimal) objeto[9]);
					}
					// somaValorEsgoto
					if(objeto[10] != null){
						mapaControleContaRelatorioHelper.setSomaValorEsgoto((BigDecimal) objeto[10]);
					}
					// somaValordebito
					if(objeto[11] != null){
						mapaControleContaRelatorioHelper.setSomaValordebito((BigDecimal) objeto[11]);
					}
					// somaValorCredito
					if(objeto[12] != null){
						mapaControleContaRelatorioHelper.setSomaValorCredito((BigDecimal) objeto[12]);
					}

					// quantidade de contas
					if(objeto[13] != null){
						mapaControleContaRelatorioHelper.setQtdeContas((Integer) objeto[13]);
					}

					retorno.add(mapaControleContaRelatorioHelper);
				}

				// parte nova para o relatório ter o processamento em batch
				// cria uma instância da classe do relatório
				RelatorioMapaControleConta relatorioMapaControleConta = new RelatorioMapaControleConta(usuarioLogado);

				relatorioMapaControleConta.addParametro("colecaoMapaControleConta", retorno);

				relatorioMapaControleConta.addParametro("mesAno", mesAno);
				relatorioMapaControleConta.addParametro("idGrupoFaturamento", idGrupoFaturamento + "");

				// Parte do codigo q gera a data de vencimento
				// dia do vencimento do grupo/mes ano de referencia do grupo + 1
				FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
				filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, idGrupoFaturamento));

				Collection colecaoFaturamento = this.getControladorUtil().pesquisar(filtroFaturamentoGrupo,
								FaturamentoGrupo.class.getName());
				FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) colecaoFaturamento.iterator().next();

				String vencimento = Util.adicionarZerosEsquedaNumero(2, faturamentoGrupo.getDiaVencimento() + "") + "/"
								+ Util.somaMesMesAnoComBarra(Util.formatarMesAnoSemBarraParaMesAnoComBarra(mesAno), 1);

				relatorioMapaControleConta.addParametro("vencimento", vencimento);

				// if(tipoRelatorio == null){
				// tipoRelatorio = TarefaRelatorio.TIPO_PDF + "";
				// }
				//
				// relatorioMapaControleConta.addParametro("tipoFormatoRelatorio",
				// Integer.parseInt(tipoRelatorio));
				//
				// byte[] relatorioGerado = (byte[]) relatorioMapaControleConta.executar();
				//
				// EnvioEmail envioEmail =
				// getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.GERAR_RELATORIO_MAPA_CONTROLE_CONTA);
				//
				// String emailRemetente = envioEmail.getEmailRemetente();
				//
				// String tituloMensagem = envioEmail.getTituloMensagem();
				//
				// String corpoMensagem = envioEmail.getCorpoMensagem();
				// String emailReceptor = envioEmail.getEmailReceptor();
				//
				// try{
				// File leitura = new File("gcom.PDF");
				// FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
				// out.write(relatorioGerado);
				// out.flush();
				// out.close();
				//
				// ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente,
				// tituloMensagem, corpoMensagem, leitura);
				//
				// // leitura.delete();
				// }catch(IOException e){
				// throw new ControladorException("erro.sistema", e);
				// }catch(Exception e){
				// throw new ControladorException("erro.sistema", e);
				// }

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Monta a colecao de resultdos apartir da tabela conta impressao para geracao do relatorio de
	 * RESUMO CONTAS EMITIDAS POR LOCALIDADE NO GRUPO
	 * 
	 * @author Flávio Cordeiro
	 * @date 13/02/2007
	 * @param idGrupoFaturamento
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarResumoContasLocalidade(Integer idGrupoFaturamento, String anoMes, Integer idFirma, Integer idSetorComercial,
					Integer idLocalidade) throws ControladorException{

		Collection retorno = new ArrayList();
		try{
			Collection colecaoObjeto = repositorioFaturamento.filtrarResumoContasLocalidade(idGrupoFaturamento, anoMes, idFirma,
							idSetorComercial, idLocalidade);

			if(!colecaoObjeto.isEmpty()){

				Iterator iterator = colecaoObjeto.iterator();

				while(iterator.hasNext()){
					Object[] objeto = (Object[]) iterator.next();
					MapaControleContaRelatorioHelper mapaControleContaRelatorioHelper = new MapaControleContaRelatorioHelper();

					// idLocalidade
					if(objeto[0] != null){
						mapaControleContaRelatorioHelper.setIdLocalidade((Integer) objeto[0]);
					}
					// idEmpresa
					if(objeto[1] != null){
						mapaControleContaRelatorioHelper.setIdEmpresa((Integer) objeto[1]);
					}
					// esferaPoder
					if(objeto[2] != null){
						mapaControleContaRelatorioHelper.setIdEsferaPoder((Integer) objeto[2]);
					}
					// Código Setor
					if(objeto[3] != null){
						mapaControleContaRelatorioHelper.setCodigoSetor((Integer) objeto[3]);
					}
					// sequencialInicial
					if(objeto[4] != null){
						mapaControleContaRelatorioHelper.setSequencialInicial((Integer) objeto[4]);
					}
					// sequencialFinal
					if(objeto[5] != null){
						mapaControleContaRelatorioHelper.setSequencialFinal((Integer) objeto[5]);
					}
					// Quantidade de Contas
					if(objeto[6] != null){
						mapaControleContaRelatorioHelper.setQtdeContas((Integer) objeto[6]);
					}
					// Valor total das Contas
					if(objeto[7] != null){
						mapaControleContaRelatorioHelper.setValorConta((Double) objeto[7]);
					}
					
					retorno.add(mapaControleContaRelatorioHelper);
				}
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0482] Emitir Segunda Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 21/02/2007
	 * @author eduardo henrique
	 * @date 05/11/2008 Alteração no método para Contabilização do Debito a Cobrar gerado.
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração no método para desabilitar a Contabilização por Evento.
	 * @param
	 * @throws ControladorException
	 */
	public DebitoACobrar gerarDebitoACobrar(Integer idImovel, Integer anoMesReferencia, Integer idDebitoTipo, BigDecimal valorInformado)
					throws ControladorException{

		DebitoACobrar debitoACobrar = null;

		try{

			Imovel imovel = getControladorImovel().pesquisarImovel(idImovel);

			// Recupera os parametros do sistema
			SistemaParametro sistema = getControladorUtil().pesquisarParametrosDoSistema();

			// Instância a forma de cobrança para cobrança em conta
			CobrancaForma cobrancaForma = new CobrancaForma();
			cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

			// Instância a situação do débito para normal
			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

			// Recupera o tipo de débito referente a despesa postal
			// DebitoTipo debitoTipo = this.getDebitoTipoHql(DebitoTipo.TAXA_2_VIA_CONTA);
			DebitoTipo debitoTipo = this.getDebitoTipoHql(idDebitoTipo);

			// Recupera a data atual
			Date dataAtual = new Date(System.currentTimeMillis());

			// Verifica se já existe débito para este imóvel
			Object[] dadoDebitoACobrar = this.repositorioFaturamento.pesquisarDebitoACobrar(imovel.getId(), debitoTipo.getId(),
							sistema.getAnoMesFaturamento());

			// Cria a variável que vai armazenar o valor do débito
			BigDecimal valor = new BigDecimal("0");

			/*
			 * Caso o perfil do imóvel seja tarifa social o valor vai ser o valor da tarifa social
			 * Caso contrário o valor da tarifa vai ser o normal.
			 */
			if(!imovel.getImovelPerfil().getId().equals(ImovelPerfil.TARIFA_SOCIAL)){
				// caso o imóvel não seja enquadrado em tarifa social

				// Obtém o valor da Tarifa Normal
				BigDecimal valorMinimaTarifaNormal = this.repositorioFaturamento.obterValorTarifa(ConsumoTarifa.CONSUMO_NORMAL);

				// Caso o valor da tarifa normal esteja nulo seta o valor para
				// zero
				if(valorMinimaTarifaNormal == null){
					valorMinimaTarifaNormal = new BigDecimal("0");
				}

				valor = valorMinimaTarifaNormal;

			}else if(imovel.getImovelPerfil().getId().equals(ImovelPerfil.TARIFA_SOCIAL)){
				// caso o imóvel seja enquadrado em tarifa social

				// Obtém o valor da Tarifa Social
				BigDecimal valorMinimaTarifaSocial = this.repositorioFaturamento.obterValorTarifa(ConsumoTarifa.CONSUMO_SOCIAL);

				// Caso o valor da tarifa social esteja nulo seta o valor para
				// zero
				if(valorMinimaTarifaSocial == null){
					valorMinimaTarifaSocial = new BigDecimal("0");
				}

				valor = valorMinimaTarifaSocial;
			}

			// inclui Débito A Cobrar Geral
			DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
			debitoACobrarGeral.setIndicadorHistorico(DebitoACobrarGeral.INDICADOR_NAO_POSSUI_HISTORICO);
			debitoACobrarGeral.setUltimaAlteracao(new Date());
			Integer idDebitoACobrarGeral = (Integer) this.getControladorUtil().inserir(debitoACobrarGeral);
			debitoACobrarGeral.setId(idDebitoACobrarGeral);

			Collection<ObjetoTransacao> colecaoDebitoACobrarContabilizar = new ArrayList<ObjetoTransacao>();

			// Cria uma instância de débito a cobrar
			debitoACobrar = new DebitoACobrar();
			debitoACobrar.setId(debitoACobrarGeral.getId());
			debitoACobrar.setDebitoACobrarGeral(debitoACobrarGeral);

			// Seta o Imóvel
			debitoACobrar.setImovel(imovel);

			// Seta o Débito Tipo
			debitoACobrar.setDebitoTipo(debitoTipo);

			// Seta Data e Hora Atual
			debitoACobrar.setGeracaoDebito(dataAtual);

			// Seta ano/mês da conta emitida como 2 via
			debitoACobrar.setAnoMesReferenciaDebito(anoMesReferencia);

			// Seta Ano/Mês de Cobrança
			/*
			 * Conforme OC0953114 a AnoMesCobrancaDebito
			 * sera de acordo como está na inclusão do débito a cobrar
			 * que utiliza a "data referência" do grupo de faturamento do qual o
			 * imóvel faz parte.
			 * Carlos Chrystian 20.12.2012
			 */
			FaturamentoGrupo faturamentoGrupo = null;
			FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
			filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, imovel.getRota()
							.getFaturamentoGrupo().getId()));
			Collection colecaoFaturamentoGrupo = this.getControladorUtil().pesquisar(filtroFaturamentoGrupo,
							FaturamentoGrupo.class.getName());

			if(colecaoFaturamentoGrupo != null && !colecaoFaturamentoGrupo.isEmpty()){

				faturamentoGrupo = (FaturamentoGrupo) colecaoFaturamentoGrupo.iterator().next();

			}

			if(faturamentoGrupo != null){

				Integer anoMes = faturamentoGrupo.getAnoMesReferencia();

				debitoACobrar.setAnoMesCobrancaDebito(anoMes);
			}

			// Seta Ano/Mês Referência do Faturamento
			debitoACobrar.setAnoMesReferenciaContabil(sistema.getAnoMesFaturamento());

			// Seta Valor do Débito
			// Atenção !!
			// Foi verificado que as empresas ADA,DESO e CASAL não possuem a regra de obter o valor
			// de débito através do valor da tarifa , e sim do valor padrão da tabela debito tipo.
			// Logo caso exista valor na tabela de debito tipo, o mesmo será utilizado. Caso
			// contrário, permanece a regra já existente anteriormente.
			// ...................................................................
			BigDecimal valorFinal = BigDecimal.ZERO;

			if(debitoTipo.getValorPadrao() != null && debitoTipo.getValorPadrao().compareTo(BigDecimal.ZERO) > 0){
				valorFinal = debitoTipo.getValorPadrao();
			}else{
				BigDecimal valorMultiplicado = valor.multiply(new BigDecimal("10"));
				valorFinal = valorMultiplicado.divide(new BigDecimal("100"), 2, BigDecimal.ROUND_HALF_UP);
			}
			// ...................................................................

			if(valorInformado != null){
				// Utilizado no retificar conta, ao ser criado um debito a cobrar com o valor da
				// diferença de um já existente.
				debitoACobrar.setValorDebito(valorInformado);
			}else{
				debitoACobrar.setValorDebito(valorFinal);
			}

			// Seta Número de Prestações do Débito
			debitoACobrar.setNumeroPrestacaoDebito(new Short("1"));

			// Seta Número de Prestações Cobradas
			debitoACobrar.setNumeroPrestacaoCobradas(new Short("0"));

			// Seta Localidade
			debitoACobrar.setLocalidade(imovel.getLocalidade());

			// Seta Quadra
			debitoACobrar.setQuadra(imovel.getQuadra());

			// Seta Código do Setor Comercial
			debitoACobrar.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());

			// Seta Número Quadra
			debitoACobrar.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());

			// Seta Lote
			debitoACobrar.setNumeroLote(imovel.getLote());

			// Seta SubLote
			debitoACobrar.setNumeroSubLote(imovel.getSubLote());

			// Seta Taxa de Juros do Financiamento
			debitoACobrar.setPercentualTaxaJurosFinanciamento(new BigDecimal("0"));

			// Seta Financiamento Tipo
			debitoACobrar.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());

			// Seta Lançamento Item Contábil
			debitoACobrar.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());

			// Seta Débito Crédito Situação
			debitoACobrar.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

			// Seta Cobrança Forma
			debitoACobrar.setCobrancaForma(cobrancaForma);

			// Seta a data de ultima alteração
			debitoACobrar.setUltimaAlteracao(new Date());

			Integer idDebitoACobrar = (Integer) this.getControladorUtil().inserir(debitoACobrar);

			debitoACobrar.setId(idDebitoACobrar);

			inserirDebitoACobrarCategoria(debitoACobrar, debitoACobrar.getImovel());

			this.getControladorCobranca().inserirClienteDebitoACobrar(debitoACobrar);

			this.getControladorContabil().registrarLancamentoContabil(debitoACobrar, OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);

		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return debitoACobrar;
	}

	/*
	 * @author Vivianne Sousa @date 21/02/2007
	 * @param colecaoCategoria @param colecaoValores @throws ControladorException
	 */
	protected void inserirDebitoACobrarCategoria(Collection<Categoria> colecaoCategoria, Collection<BigDecimal> colecaoValoresCategorias,
					DebitoACobrar debitoACobrar) throws ControladorException{

		DebitoACobrarCategoria debitoACobrarCategoria = null;
		BigDecimal valorCategoria = new BigDecimal(0);
		DebitoACobrarCategoriaPK debitoACobrarCategoriaPK = null;

		for(Categoria categoria : colecaoCategoria){

			debitoACobrarCategoriaPK = new DebitoACobrarCategoriaPK();
			debitoACobrarCategoriaPK.setCategoria(categoria);
			debitoACobrarCategoriaPK.setDebitoACobrar(debitoACobrar);

			debitoACobrarCategoria = new DebitoACobrarCategoria();

			debitoACobrarCategoria.setComp_id(debitoACobrarCategoriaPK);

			debitoACobrarCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());

			valorCategoria = colecaoValoresCategorias.iterator().next();

			debitoACobrarCategoria.setValorCategoria(valorCategoria);

			debitoACobrarCategoria.setUltimaAlteracao(new Date());

			this.getControladorUtil().inserir(debitoACobrarCategoria);
		}
	}

	/**
	 * atualiza a guia de pagamento na tabela GUIA_PAGAMENTO (DCST_IDANTERIOR=DCST_IDATUAL e
	 * DCST_IDATUAL=DCST_ID da tabela DEBITO_CREDITO_SITUACAO
	 * com o valor correspondente a Cancelada).
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * @param guiaPagamentoManter
	 * @param operacaoEfetuada
	 * @param registradorOperacao
	 * @param usuarioLogado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarGuiaPagamento(GuiaPagamento guiaPagamentoManter, OperacaoEfetuada operacaoEfetuada,
					RegistradorOperacao registradorOperacao, Usuario usuarioLogado) throws ControladorException{

		try{

			// guiaPagamentoManter
			// .setDebitoCreditoSituacaoAnterior(guiaPagamentoManter
			// .getDebitoCreditoSituacaoAtual());
			DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
			debitoCreditoSituacao.setId(DebitoCreditoSituacao.CANCELADA);
			guiaPagamentoManter.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

			// Seta os parametros do filtro

			FiltroGuiaPagamento filtroGuiaPagamentoBase = new FiltroGuiaPagamento();
			filtroGuiaPagamentoBase.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, guiaPagamentoManter.getId()));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection guiasPagamentosBase = getControladorUtil().pesquisar(filtroGuiaPagamentoBase, GuiaPagamento.class.getName());

			GuiaPagamento guiaPagamentoBase = (GuiaPagamento) Util.retonarObjetoDeColecao(guiasPagamentosBase);

			if(guiasPagamentosBase != null && !guiasPagamentosBase.isEmpty()){

				// Verifica se a data de alteração do objeto
				// gravado na base é
				// maior que a na instancia
				if((guiaPagamentoBase.getUltimaAlteracao().after(guiaPagamentoManter.getUltimaAlteracao()))){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");

				}

			}else{
				System.out.println("Indentificação do objeto não localizado 'GuiaPagamento': id = " + guiaPagamentoManter.getId());
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.removido");
			}

			guiaPagamentoManter.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			guiaPagamentoManter.setOperacaoEfetuada(operacaoEfetuada);
			guiaPagamentoManter.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(guiaPagamentoManter);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			/**
			 * alterado por pedro alexandre dia 23/11/2006 alteração feita para acoplar o controle
			 * de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA
			// ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, guiaPagamentoManter.getImovel());

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{
				getControladorUtil().atualizar(guiaPagamentoManter);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA
			// ----------------

		}catch(ControladorException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Recupera as contas
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImoveis(Integer anoMes, Collection idsImovel, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim) throws ControladorException{

		try{

			return repositorioFaturamento.pesquisarContasImoveis(anoMes, idsImovel, dataVencimentoContaInicio, dataVencimentoContaFim,
							anoMesFim, null, null);

		}catch(ErroRepositorioException ex2){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex2);
		}

	}

	/**
	 * Informar Tarifa de Consumo por Subcategoria
	 * 
	 * @autor Tiago Moreno
	 * @date 05/01/2006
	 * @param consumoTarifa
	 * @param consumoTarifaVigencia
	 * @param colecaoConsumoTarifaCategoria
	 * @param colecaoConsumoTarifaFaixa
	 * @throws ControladorException
	 */

	public void informarConsumoTarifaSubcategoria(ConsumoTarifa consumoTarifa, ConsumoTarifaVigencia consumoTarifaVigencia,
					Collection<ConsumoTarifaCategoria> colecaoConsumoTarifaCategoria) throws ControladorException{

		// Caso o objeto ConsumoTarifa já exista na base
		if(consumoTarifa.getId() != null){

			FiltroConsumoTarifaVigencia filtroConsumoTarifaVigencia = new FiltroConsumoTarifaVigencia();
			filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.CONSUMO_TARIFA_ID,
							consumoTarifa.getId()));
			filtroConsumoTarifaVigencia.adicionarParametro(new ParametroSimples(FiltroConsumoTarifaVigencia.DATA_VIGENCIA,
							consumoTarifaVigencia.getDataVigencia()));
			Collection colecaoConsumoVigenciaExistente = getControladorUtil().pesquisar(filtroConsumoTarifaVigencia,
							ConsumoTarifaVigencia.class.getName());

			consumoTarifaVigencia = (ConsumoTarifaVigencia) colecaoConsumoVigenciaExistente.iterator().next();
		}else{

			// Obtendo o ID gerado pelo BD
			Integer idConsumoTarifaGerado = (Integer) this.getControladorUtil().inserir(consumoTarifa);

			// Carregando o novo objeto ConsumoTarifa
			consumoTarifa.setId(idConsumoTarifaGerado);
			consumoTarifaVigencia.setConsumoTarifa(consumoTarifa);

			// Inserindo o objeto ConsumoTarifaVigencia no BD
			Integer i = (Integer) this.getControladorUtil().inserir(consumoTarifaVigencia);
			consumoTarifaVigencia.setId(i);
		}

		// Para cada categoria: O sistema inserir um objeto do tipo
		// ConsumoTarifaCategoria

		Iterator colecaoConsumoTarifaCategoriaIt = colecaoConsumoTarifaCategoria.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoriaColecao = null;

		while(colecaoConsumoTarifaCategoriaIt.hasNext()){
			consumoTarifaCategoriaColecao = (ConsumoTarifaCategoria) colecaoConsumoTarifaCategoriaIt.next();

			consumoTarifaCategoriaColecao.setConsumoTarifaVigencia(consumoTarifaVigencia);

			Subcategoria subcategoria = new Subcategoria();
			if(consumoTarifaCategoriaColecao.getSubCategoria().getId() == null){
				consumoTarifaCategoriaColecao.getSubCategoria().setId(0);
			}
			subcategoria.setId(consumoTarifaCategoriaColecao.getSubCategoria().getId());
			consumoTarifaCategoriaColecao.setSubCategoria(subcategoria);

			Integer codigoConsumoTarifaCategoriaColecao = (Integer) this.getControladorUtil().inserir(consumoTarifaCategoriaColecao);
			consumoTarifaCategoriaColecao.setId(codigoConsumoTarifaCategoriaColecao);

			Collection consumoTarifaFaixa = new ArrayList(consumoTarifaCategoriaColecao.getConsumoTarifaFaixas());
			Collections.sort((List) consumoTarifaFaixa, new Comparator() {

				public int compare(Object a, Object b){

					Integer numeroConsumoFaixaInicio1 = ((ConsumoTarifaFaixa) a).getNumeroConsumoFaixaInicio();
					Integer numeroConsumoFaixaInicio2 = ((ConsumoTarifaFaixa) b).getNumeroConsumoFaixaInicio();

					return numeroConsumoFaixaInicio1.compareTo(numeroConsumoFaixaInicio2);

				}
			});

			Iterator colecaoConsumoTarifaFaixaIt = consumoTarifaFaixa.iterator();

			while(colecaoConsumoTarifaFaixaIt.hasNext()){
				ConsumoTarifaFaixa consumoTarifaFaixaColecao = (ConsumoTarifaFaixa) colecaoConsumoTarifaFaixaIt.next();

				consumoTarifaFaixaColecao.setConsumoTarifaCategoria(consumoTarifaCategoriaColecao);

				this.getControladorUtil().inserir(consumoTarifaFaixaColecao);
			}

		}

		// Para cada faixa informada para categori: O sistema inserir um objeto
		// do tipo ConsumoTarifaFaixa

	}

	/**
	 * Recupera as contas do Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer obterContasConjuntoImoveis(Integer anoMes, Collection idsImovel, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim, String inContasRevisao, Integer[] motivosRevisaoDisponiveis)
					throws ControladorException{

		Integer quantidadeConta = 0;
		try{

			quantidadeConta = repositorioFaturamento.pesquisarQuantidadeContasImoveis(anoMes, idsImovel, dataVencimentoContaInicio,
							dataVencimentoContaFim, anoMesFim, inContasRevisao, motivosRevisaoDisponiveis);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		/*
		 * if (colecaoContasManutencaoArray != null && !colecaoContasManutencaoArray.isEmpty()) {
		 * Iterator colecaoContasManutencaoArrayIterator = colecaoContasManutencaoArray .iterator();
		 * while (colecaoContasManutencaoArrayIterator.hasNext()) { // Obtém os dados do crédito
		 * realizado Object[] contaArray = (Object[])
		 * colecaoContasManutencaoArrayIterator .next();
		 * Conta conta = new Conta(); // ID da conta conta.setId((Integer) contaArray[0]); // Ano
		 * Mês referencia conta.setReferencia((Integer)
		 * contaArray[1]); // Data de vencimento String vencimento = String.valueOf(contaArray[2]);
		 * SimpleDateFormat formatoData = new SimpleDateFormat( "yyyy-MM-dd");
		 * Date dataVencimento;
		 * try { dataVencimento = formatoData.parse(vencimento); } catch (java.text.ParseException
		 * e) { dataVencimento = null; }
		 * conta.setDataVencimentoConta(dataVencimento); // Valor de água
		 * conta.setValorAgua((BigDecimal) contaArray[3]); // Valor de esgoto
		 * conta.setValorEsgoto((BigDecimal) contaArray[4]); // Valor dos débitos
		 * conta.setDebitos((BigDecimal) contaArray[5]); // Valor dos créditos
		 * conta.setValorCreditos((BigDecimal) contaArray[6]); // Consumo de água
		 * conta.setConsumoAgua((Integer) contaArray[7]); // Consumo de esgoto
		 * conta.setConsumoEsgoto((Integer) contaArray[8]); // Data de validade String validade =
		 * String.valueOf(contaArray[9]);
		 * Date dataValidade;
		 * try { dataValidade = formatoData.parse(validade); } catch (java.text.ParseException e) {
		 * dataValidade = null; }
		 * conta.setDataValidadeConta(dataValidade); // Data de revisao String revisao =
		 * String.valueOf(contaArray[10]);
		 * Date dataRevisao;
		 * try { dataRevisao = formatoData.parse(revisao); } catch (java.text.ParseException e) {
		 * dataRevisao = null; }
		 * conta.setDataRevisao(dataRevisao); // DebitoCreditoSituacaoAtual conta
		 * .setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao)
		 * contaArray[11]); // Ano Mês referencia contábil conta.setReferenciaContabil((Integer)
		 * contaArray[12]); // ultima Alteracao
		 * SimpleDateFormat formatoDataEspecifico = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss");
		 * String ultimaAlteracao = String.valueOf(contaArray[13]);
		 * Date dataUltimaAlteracao;
		 * try { dataUltimaAlteracao = formatoDataEspecifico .parse(ultimaAlteracao); } catch
		 * (java.text.ParseException e) { dataUltimaAlteracao =
		 * null; }
		 * conta.setUltimaAlteracao(dataUltimaAlteracao);
		 * Imovel imovel = (Imovel)contaArray[14];
		 * conta.setImovel(imovel);
		 * retorno.add(conta); } }
		 */

		return quantidadeConta;
	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Ana Maria
	 * @date 20/01/2007
	 * @param colecaoContas
	 * @param dataVencimento
	 * @throws ControladorException
	 */
	public void alterarVencimentoConjuntoConta(Collection colecaoImovel, Date dataVencimentoInformada, Integer anoMes,
					Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Integer anoMesFim, Usuario usuario,
					Collection<Conta> colecaoContasSelecionadas) throws ControladorException{

		Collection colecaoConta = new ArrayList();
		StringBuffer identificadores = new StringBuffer();

			if(colecaoContasSelecionadas != null && !colecaoContasSelecionadas.isEmpty()){

				Iterator colecaoContasManutencaoIterator = colecaoContasSelecionadas.iterator();
				while(colecaoContasManutencaoIterator.hasNext()){

				// Obtém os dados do crédito realizado
					Conta conta = (Conta) colecaoContasManutencaoIterator.next();

				conta.setUltimaAlteracao(new Date());

				/*
				 * Colocado por Raphael Rossiter em 27/12/2007 OBJ: Carregar o id do imóvel para
				 * registrar a transação
				 */
				Imovel imovel = (Imovel) conta.getImovel();
				conta.setImovel(imovel);

				identificadores.append("," + conta.getId());

					colecaoConta.add(conta);
				}
			}
		identificadores.deleteCharAt(0);

		alterarVencimentoConta(colecaoConta, identificadores.toString(), dataVencimentoInformada, usuario);

	}

	/**
	 * Retificar Conjunto de Conta
	 * 
	 * @author Ana Maria
	 * @date 24/01/2007
	 * @throws ControladorException
	 */
	public void retificarConjuntoConta(Collection colecaoImovel, Integer anoMes, ContaMotivoRetificacao contaMotivoRetificacao,
					Collection debitosTipoRetirar, Usuario usuarioLogado, Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
					Integer anoMesFim, Collection<Conta> colecaoContasSelecionadas) throws ControladorException{

		List colecaoAuxiliar = new ArrayList();

		colecaoAuxiliar.addAll(colecaoImovel);

		int i = 0;
		int cont = 500;

		while(i <= colecaoImovel.size()){

			i = i + cont;

			if(colecaoContasSelecionadas != null && !colecaoContasSelecionadas.isEmpty()){

				Iterator colecaoContasManutencaoIterator = colecaoContasSelecionadas.iterator();

				while(colecaoContasManutencaoIterator.hasNext()){

					// Obtém os dados do crédito realizado
					Conta conta = (Conta) colecaoContasManutencaoIterator.next();

					conta.setUltimaAlteracao(new Date());

					Imovel imovel = (Imovel) conta.getImovel();

					Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasContaCategoria(conta);
					Set<Categoria> setCategoria = new HashSet<Categoria>(colecaoCategoria);
					PersistentSet pSetCategoria = new PersistentSet(null, setCategoria);
					conta.setContaCategorias(pSetCategoria);

					Collection colecaoCreditoRealizado = obterCreditosRealizadosConta(conta);
					Set<CreditoRealizado> setCreditoRealizado = new HashSet<CreditoRealizado>(colecaoCreditoRealizado);
					PersistentSet pSetCreditoRealizado = new PersistentSet(null, setCreditoRealizado);
					conta.setCreditoRealizados(pSetCreditoRealizado);

					Collection colecaoDebitoCobrado = obterDebitosCobradosConta(conta);
					Set<DebitoCobrado> setDebitoCobrado = new HashSet<DebitoCobrado>(colecaoDebitoCobrado);
					PersistentSet pSetDebitoCobrado = new PersistentSet(null, setDebitoCobrado);
					conta.setDebitoCobrados(pSetDebitoCobrado);

					String consumoAgua = null;
					if(conta.getConsumoAgua() != null){
						consumoAgua = conta.getConsumoAgua().toString();
					}

					String consumoEsgoto = null;
					if(conta.getConsumoEsgoto() != null){
						consumoEsgoto = conta.getConsumoEsgoto().toString();
					}

					Collection<CalcularValoresAguaEsgotoHelper> valoresConta = calcularValoresConta(Util.formatarAnoMesParaMesAno(conta
									.getReferencia()), imovel.getId().toString(), conta.getLigacaoAguaSituacao().getId(), conta
									.getLigacaoEsgotoSituacao().getId(), colecaoCategoria, consumoAgua, consumoEsgoto, conta
									.getPercentualEsgoto().toString(), conta.getConsumoTarifa().getId(), usuarioLogado, null, null);

					boolean achouDebitoRetirar = false;
					if(colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()){
						Iterator colecaoDebitoCobradoIterator = colecaoDebitoCobrado.iterator();
						while(colecaoDebitoCobradoIterator.hasNext()){
							DebitoCobrado debitoCobrado = (DebitoCobrado) colecaoDebitoCobradoIterator.next();
							DebitoTipo debitoTipo = debitoCobrado.getDebitoTipo();
							if(debitosTipoRetirar.contains(debitoTipo.getId())){
								achouDebitoRetirar = true;
								colecaoDebitoCobradoIterator.remove();
							}
						}
						if(achouDebitoRetirar){
							retificarConta(Integer.valueOf(conta.getReferencia()), conta, imovel, colecaoDebitoCobrado,
											colecaoCreditoRealizado, conta.getLigacaoAguaSituacao(), conta.getLigacaoEsgotoSituacao(),
											colecaoCategoria, consumoAgua, consumoEsgoto, conta.getPercentualEsgoto().toString(),
											conta.getDataVencimentoConta(), valoresConta, contaMotivoRetificacao, null, usuarioLogado,
											null, conta.getConsumoTarifa(), null);
						}

					}
				}
			}
		}
	}

	/**
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * @param anoMes
	 * @param colecaoClientes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer[] chamarGerarArquivoTextoFaturamento(int anoMes, String idCliente, Collection colecaoClientesAptos){

		Collection colecaoClientes = new ArrayList();

		// retorno[0] -> número de clientes selecionados
		// retorno[1] -> número de arquivos enviados
		// retorno[2] -> número de falhas
		Integer[] retorno = {0, 0, 0};
		int falhas = 0;

		if(idCliente.trim().equals("T")){
			Iterator iterator = colecaoClientesAptos.iterator();
			while(iterator.hasNext()){
				colecaoClientes.add(((Cliente) iterator.next()).getId());
			}
			retorno[0] = Integer.valueOf(colecaoClientes.size());
		}else{
			colecaoClientes.add(Integer.valueOf(idCliente));
			retorno[0] = Integer.valueOf(1);
		}

		Iterator iteratorCliente = colecaoClientes.iterator();
		while(iteratorCliente.hasNext()){
			Integer idClienteGerar = (Integer) iteratorCliente.next();
			try{
				Integer intEnviado = this.gerarArquivoTextoFaturamento(anoMes, idClienteGerar);
				if(intEnviado != null){
					retorno[1] = retorno[1] + intEnviado;
				}
			}catch(ControladorException e){
				falhas = falhas + 1;
				e.printStackTrace();
			}
		}
		retorno[2] = falhas;
		return retorno;
	}

	/**
	 * [UC0544] - Gerar Arquivo Texto do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 23/03/2007
	 * @param anoMes
	 * @param idCliente
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer gerarArquivoTextoFaturamento(int anoMes, Integer idCliente) throws ControladorException{

		Collection colecaoObjetos = null;
		Integer qtdArquigosGerados = Integer.valueOf(0);
		try{

			colecaoObjetos = repositorioFaturamento.gerarArquivoTextoFaturamento(anoMes, idCliente);

			StringBuilder documentoTxt = new StringBuilder();
			int sequencialImpressao = 0;

			if(!colecaoObjetos.isEmpty()){
				Iterator iteratorObjetos = colecaoObjetos.iterator();
				BigDecimal somaValorRegitros = new BigDecimal(0);
				// -- HEADER
				// ----------------------------------------------------
				documentoTxt.append("0");// Tipo Registro - Fixo 0 CHAR(1)
				documentoTxt.append(Util.completaString("CONTAS", 10));// Tipo
				// MOVIMENTO
				// -
				// Fixo
				// CONTAS
				// CHAR(10)
				documentoTxt.append("00000003");// CODIGO FORNECEDOR - Fixo
				// 00000008 CHAR(8)
				documentoTxt.append(Util.completaString("COMPESA", 30));// NOME
				// DO
				// FORNECEDOR
				// -
				// Fixo
				// COMPESA
				// CHAR(30)
				documentoTxt.append(Util.recuperaDataInvertida(new Date()));// DATA
				// DO
				// MOVIMENTO
				// -
				// DATA
				// CORRENTE
				documentoTxt.append(Util.completaString("", 74));// CAMPO
				// LIVRE -
				// ESPAÇOS
				// CHAR(74)

				// Quebra de Linha
				documentoTxt.append(System.getProperty("line.separator"));
				// -- Fim HEADER
				// -------------------------------------------------
				while(iteratorObjetos.hasNext()){
					sequencialImpressao++;
					Object[] objeto = (Object[]) iteratorObjetos.next();

					// -- CONTAS
					// -----------------------------------------------------
					documentoTxt.append("1");// Tipo Registro - Fixo 1
					// CHAR(1)
					// idImovel
					if(objeto[0] != null){
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ((Integer) objeto[0]).toString()));// MATRICULA
						// - imov_id
						// CHAR(15)
						documentoTxt.append(Util.completaString("", 7));// MATRICULA
						// -
						// imov_id
						// CHAR(15)
					}
					// amReferencia
					if(objeto[1] != null){
						String anoMesObjeto = ((Integer) objeto[1]).toString();
						String ano = anoMesObjeto.substring(0, 4);
						String mes = anoMesObjeto.substring(4, 6);
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(2, mes));// MES
						// DO
						// CONSUMO
						// - mm
						// CHAR(2)
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(4, ano));// ANO
						// DO
						// CONSUMO
						// -
						// aaaa
						// CHAR(4)
					}
					// dtleitura
					if(objeto[6] != null){
						documentoTxt.append(Util.recuperaDataInvertida((Date) objeto[6]));// DATA
						// DA
						// LEITURA
						// -
						// aaaammdd
					}else{
						documentoTxt.append(Util.recuperaDataInvertida(Util.gerarDataApartirAnoMesRefencia(Integer.valueOf(anoMes))));// DATA
						// DA
						// LEITURA
						// -
						// aaaammdd
					}
					// vencimentoConta
					if(objeto[17] != null){
						documentoTxt.append(Util.recuperaDataInvertida((Date) objeto[17]));// Vencimento
						// Conta
						// -
						// aaaammdd
					}
					// valorAgua
					BigDecimal valorAgua = new BigDecimal(0);
					if(objeto[2] != null){
						valorAgua = (BigDecimal) objeto[2];
					}
					// valorEsgoto
					BigDecimal valorEsgoto = new BigDecimal(0);
					if(objeto[3] != null){
						valorEsgoto = (BigDecimal) objeto[3];
					}
					// valorDebitos
					BigDecimal valorDebitos = new BigDecimal(0);
					if(objeto[4] != null){
						valorDebitos = (BigDecimal) objeto[4];
					}
					// valorCreditos
					BigDecimal valorCreditos = new BigDecimal(0);
					if(objeto[5] != null){
						valorCreditos = (BigDecimal) objeto[5];
					}
					// SOMATORIO
					// cnta_vlagua + cnta_vlesgoto + cnta_vldebitos -
					// cnta_vlcreditos da tabela conta
					BigDecimal valorTotal = new BigDecimal(0);

					valorTotal = valorTotal.add(valorAgua);
					valorTotal = valorTotal.add(valorEsgoto);
					valorTotal = valorTotal.add(valorDebitos);
					valorTotal = valorTotal.subtract(valorCreditos);

					documentoTxt.append(Util.adicionarZerosEsquedaNumero(10, valorTotal.toString().replace(".", "")));// VALOR
					// DA
					// FATURA
					// -
					// SOMATORIO
					// char(12)

					// Acumulador Geral
					somaValorRegitros = somaValorRegitros.add(valorTotal);

					documentoTxt.append(Util.adicionarZerosEsquedaNumero(5, ""));// numero
					// da
					// fatura
					// -
					// char(5)

					// leitura Atual
					if(objeto[7] != null){
						// atualizado 29/10/2007 Flávio leonardo, solicitação de
						// Aryed
						String leituraAtual = Util.adicionarZerosEsquedaNumero(5, ((Integer) objeto[7]) + "");

						documentoTxt.append(leituraAtual.substring(0, 5));// Leitura
						// Atual
						// - char(5)
					}else{
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(5, ""));// Leitura
						// Atual
						// -
						// char(5)
					}
					// ************************Alteração feita no dia 9/4/2007 á
					// pedido de Aryed - Flávio Cordeiro
					// nome cliente
					if(objeto[8] != null){
						String nomeCliente = repositorioFaturamento.pesquisarClienteUsuarioConta((Integer) objeto[8]);
						documentoTxt.append(Util.completaString(nomeCliente, 42));// Nome
						// Cliente -
						// clie_nmCliente
						// char(42)
					}

					documentoTxt.append("+");// Sinal Valor - FIXO + char(1)

					// nome cliente
					if(objeto[9] != null){
						documentoTxt.append(Util.completaString((String) objeto[9], 30));// Nome
						// Municipio
						// -
						// muni_nmmunicipio
						// char(30)
					}

					// Quebra de Linha
					documentoTxt.append(System.getProperty("line.separator"));

					// -- Consumo e Valor de Agua ----------------------
					// Gerar somente se valor de Agua MAIOR (>) que Zero
					if(valorAgua.intValue() > 0){
						documentoTxt.append(Util.completaString("2", 1));// Tipo
						// Registro
						// -
						// fixo
						// 2
						// char(1)
						// idImovel
						if(objeto[0] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ((Integer) objeto[0]).toString()));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
							documentoTxt.append(Util.completaString("", 7));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
						}
						// amReferencia
						if(objeto[1] != null){
							String anoMesObjeto = ((Integer) objeto[1]).toString();
							String ano = anoMesObjeto.substring(0, 4);
							String mes = anoMesObjeto.substring(4, 6);
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(2, mes));// MES
							// DO
							// CONSUMO
							// - mm
							// CHAR(2)
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(4, ano));// ANO
							// DO
							// CONSUMO
							// -
							// aaaa
							// CHAR(4)
						}
						// dtleitura
						if(objeto[6] != null){
							documentoTxt.append(Util.recuperaDataInvertida((Date) objeto[6]));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}else{
							documentoTxt.append(Util.recuperaDataInvertida(Util.gerarDataApartirAnoMesRefencia(Integer.valueOf(anoMes))));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(5, ""));// Codigo
						// -
						// fixo
						// Zeros
						// char(5)
						// consumoAgua
						if(objeto[10] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(7, ((Integer) objeto[10]).toString()));// Consumo
							// -
							// cnta_nnconsumoagua
							// char(7)
						}
						// valor agua
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, valorAgua.toString().replace(".", "")));// Valor
						// Agua
						// -
						// valorAgua
						// char(8)
						documentoTxt.append(Util.completaString("AGUA", 50));// historico
						// -
						// Fixo
						// AGUA
						// char(50)
						documentoTxt.append(Util.completaString("+", 1));// Sinal
						// do
						// Valro
						// -
						// Fixo
						// +
						// char(1)
						documentoTxt.append(Util.completaString("", 30));// Campo
						// livre
						// -
						// Espaços
						// char(1)

						// Quebra de Linha
						documentoTxt.append(System.getProperty("line.separator"));
					}

					// -- Consumo e Valor de Esgoto ------------------------
					// Gerar somente se valor do Esgoto MAIOR (>) que Zero
					if(valorEsgoto.intValue() > 0){
						documentoTxt.append(Util.completaString("2", 1));// Tipo
						// Registro
						// -
						// fixo
						// 2
						// char(1)
						// idImovel
						if(objeto[0] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ((Integer) objeto[0]).toString()));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
							documentoTxt.append(Util.completaString("", 7));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
						}
						// amReferencia
						if(objeto[1] != null){
							String anoMesObjeto = ((Integer) objeto[1]).toString();
							String ano = anoMesObjeto.substring(0, 4);
							String mes = anoMesObjeto.substring(4, 6);
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(2, mes));// MES
							// DO
							// CONSUMO
							// - mm
							// CHAR(2)
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(4, ano));// ANO
							// DO
							// CONSUMO
							// -
							// aaaa
							// CHAR(4)
						}
						// dtleitura
						if(objeto[6] != null){
							documentoTxt.append(Util.recuperaDataInvertida((Date) objeto[6]));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}else{
							documentoTxt.append(Util.recuperaDataInvertida(Util.gerarDataApartirAnoMesRefencia(Integer.valueOf(anoMes))));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(5, ""));// Codigo
						// -
						// fixo
						// Zeros
						// char(5)
						// consumoEsgoto
						if(objeto[11] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(7, ((Integer) objeto[11]).toString()));// Consumo
							// -
							// cnta_nnconsumoagua
							// char(7)
						}
						// valor agua
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, valorEsgoto.toString().replace(".", "")));// Valor
						// Agua
						// -
						// valorAgua
						// char(8)
						documentoTxt.append(Util.completaString("ESGOTO", 50));// historico
						// -
						// Fixo
						// ESGOTO
						// char(50)
						documentoTxt.append(Util.completaString("+", 1));// Sinal
						// do
						// Valro
						// -
						// Fixo
						// +
						// char(1)
						documentoTxt.append(Util.completaString("", 30));// Campo
						// livre
						// -
						// Espaços
						// char(1)

						// Quebra de Linha
						documentoTxt.append(System.getProperty("line.separator"));
					}

					// -- Codigo e valor de debito corbado
					// ------------------------------
					if(objeto[12] != null){
						documentoTxt.append(Util.completaString("2", 1));// Tido
						// do
						// Registro
						// -
						// Fixo
						// 2
						// char(1)
						// idImovel
						if(objeto[0] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ((Integer) objeto[0]).toString()));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
							documentoTxt.append(Util.completaString("", 7));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
						}
						// amReferencia
						if(objeto[1] != null){
							String anoMesObjeto = ((Integer) objeto[1]).toString();
							String ano = anoMesObjeto.substring(0, 4);
							String mes = anoMesObjeto.substring(4, 6);
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(2, mes));// MES
							// DO
							// CONSUMO
							// - mm
							// CHAR(2)
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(4, ano));// ANO
							// DO
							// CONSUMO
							// -
							// aaaa
							// CHAR(4)
						}
						// dtleitura
						if(objeto[6] != null){
							documentoTxt.append(Util.recuperaDataInvertida((Date) objeto[6]));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}else{
							documentoTxt.append(Util.recuperaDataInvertida(Util.gerarDataApartirAnoMesRefencia(Integer.valueOf(anoMes))));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}
						// idDebitoTipo
						if(objeto[12] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(5, ((Integer) objeto[12]).toString()));// Codigo
							// -
							// dbtp_id
							// CHAR(4)
						}else{
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(5, ""));// Codigo
							// -
							// dbtp_id
							// CHAR(4)
						}
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(7, ""));// Volume
						// -
						// Zeros
						// CHAR(9)
						// valor debito
						if(objeto[13] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ((BigDecimal) objeto[13]).toString().replace(".", "")));// Valor
							// Prestação
							// -
							// DBCB_VLPRESTACAO
							// CHAR(10)
						}else{
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ""));// Valor
							// Prestação
							// -
							// DBCB_VLPRESTACAO
							// CHAR(10)
						}
						documentoTxt.append(Util.completaString("SERVICO", 50));// historico
						// -
						// Fixo
						// SERVICO
						// char(50)
						documentoTxt.append(Util.completaString("+", 1));// Sinal
						// do
						// Valro
						// -
						// Fixo
						// +
						// char(1)
						documentoTxt.append(Util.completaString("", 30));// Campo
						// livre
						// -
						// Espaços
						// char(1)

						// Quebra de Linha
						documentoTxt.append(System.getProperty("line.separator"));
					}

					// -- Codigo e valor de credito realizado
					// ------------------------------
					if(objeto[14] != null){
						documentoTxt.append(Util.completaString("2", 1));// Tido
						// do
						// Registro
						// -
						// Fixo
						// 2
						// char(1)
						// idImovel
						if(objeto[0] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ((Integer) objeto[0]).toString()));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
							documentoTxt.append(Util.completaString("", 7));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
						}
						// amReferencia
						if(objeto[1] != null){
							String anoMesObjeto = ((Integer) objeto[1]).toString();
							String ano = anoMesObjeto.substring(0, 4);
							String mes = anoMesObjeto.substring(4, 6);
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(2, mes));// MES
							// DO
							// CONSUMO
							// - mm
							// CHAR(2)
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(4, ano));// ANO
							// DO
							// CONSUMO
							// -
							// aaaa
							// CHAR(4)
						}
						// dtleitura
						if(objeto[6] != null){
							documentoTxt.append(Util.recuperaDataInvertida((Date) objeto[6]));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}else{
							documentoTxt.append(Util.recuperaDataInvertida(Util.gerarDataApartirAnoMesRefencia(Integer.valueOf(anoMes))));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}
						// idCreditoTipo
						if(objeto[14] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(4, ((Integer) objeto[14]).toString()));// Codigo
							// -
							// crti_id
							// CHAR(4)
						}
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(4, ""));// Volume
						// -
						// Zeros
						// CHAR(9)
						// valor credito
						if(objeto[15] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(10, ((BigDecimal) objeto[15]).toString().replace(".", "")));// Valor
							// Prestação
							// -
							// crrz_VLPRESTACAO
							// CHAR(10)
						}
						documentoTxt.append(Util.completaString("CREDITO", 50));// historico
						// -
						// Fixo
						// SERVICO
						// char(50)
						documentoTxt.append(Util.completaString("-", 1));// Sinal
						// do
						// Valro
						// -
						// Fixo
						// -
						// char(1)
						documentoTxt.append(Util.completaString("", 30));// Campo
						// livre
						// -
						// Espaços
						// char(1)

						// Quebra de Linha
						documentoTxt.append(System.getProperty("line.separator"));
					}

					// -- Valores dos Impostos Retidos
					// ------------------------------
					if(objeto[16] != null && (((BigDecimal) objeto[16]).intValue() > 0)){
						documentoTxt.append(Util.completaString("2", 1));// Tido
						// do
						// Registro
						// -
						// Fixo
						// 2
						// char(1)
						// idImovel
						if(objeto[0] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ((Integer) objeto[0]).toString()));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
							documentoTxt.append(Util.completaString("", 7));// MATRICULA
							// -
							// imov_id
							// CHAR(15)
						}
						// amReferencia
						if(objeto[1] != null){
							String anoMesObjeto = ((Integer) objeto[1]).toString();
							String ano = anoMesObjeto.substring(0, 4);
							String mes = anoMesObjeto.substring(4, 6);
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(2, mes));// MES
							// DO
							// CONSUMO
							// - mm
							// CHAR(2)
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(4, ano));// ANO
							// DO
							// CONSUMO
							// -
							// aaaa
							// CHAR(4)
						}
						// dtleitura
						if(objeto[6] != null){
							documentoTxt.append(Util.recuperaDataInvertida((Date) objeto[6]));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}else{
							documentoTxt.append(Util.recuperaDataInvertida(Util.gerarDataApartirAnoMesRefencia(Integer.valueOf(anoMes))));// DATA
							// DA
							// LEITURA
							// -
							// aaaammdd
						}
						// Codigo
						documentoTxt.append(Util.adicionarZerosEsquedaNumero(5, ""));// Codigo
						// -
						// Zeros
						// CHAR(5)

						documentoTxt.append(Util.adicionarZerosEsquedaNumero(7, ""));// Volume
						// -
						// Zeros
						// CHAR(9)
						// somaImpostos - soma dos cnid_vlimpostos
						if(objeto[16] != null){
							documentoTxt.append(Util.adicionarZerosEsquedaNumero(8, ((BigDecimal) objeto[16]).toString().replace(".", "")));// Total
							// das
							// retenções
							// -
							// somaImpostos
							// CHAR(10)
						}
						documentoTxt.append(Util.completaString("IR-4,8% CSLL-1.0% COFINS-3,0% PIS?PASEP-0,65%", 50));// historico
						// -
						// Fixo
						// SERVICO char(50)
						documentoTxt.append(Util.completaString("-", 1));// Sinal
						// do
						// Valro
						// -
						// Fixo
						// -
						// char(1)
						documentoTxt.append(Util.completaString("", 30));// Campo
						// livre
						// -
						// Espaços
						// char(30)

						// Quebra de Linha
						documentoTxt.append(System.getProperty("line.separator"));
					}

				}

				// -- TRAILLER ---------------------------
				documentoTxt.append(Util.completaString("9", 1));// Fixo 9
				// char(1)
				documentoTxt.append(Util.adicionarZerosEsquedaNumero(6, sequencialImpressao + ""));// Sinal
				// do
				// Valro
				// -
				// Fixo
				// -
				// char(1)
				documentoTxt.append(Util.adicionarZerosEsquedaNumero(14, ((BigDecimal) somaValorRegitros).toString().replace(".", "")));// Soma
				// dos
				// valores
				// Registrados
				// - soma char(1)
				documentoTxt.append(Util.completaString("", 110));// Campo
				// livre -
				// Espaços
				// char(112)
				// Quebra de Linha
				documentoTxt.append(System.getProperty("line.separator"));
				documentoTxt.append("\u0004");

				System.out.println("***************************************");
				System.out.println("INICO DA CRIACAO DO ARQUIVO");
				System.out.println("***************************************");

				if(documentoTxt != null && documentoTxt.length() != 0){

					EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.GERAR_ARQUIVO_TEXTO_FATURAMENTO);

					String corpoMensagem = envioEmail.getCorpoMensagem();
					String emailRemetente = envioEmail.getEmailRemetente();
					String emailReceptor = envioEmail.getEmailReceptor();

					try{
						// criar o arquivo zip
						File compactado = new File("" + idCliente + "_" + anoMes + ".zip"); // nomeZip
						ZipOutputStream zos;

						zos = new ZipOutputStream(new FileOutputStream(compactado));

						File leitura;
						leitura = File.createTempFile("" + idCliente + "_" + anoMes + "_", ".txt");

						BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leitura.getAbsolutePath())));
						out.write(documentoTxt.toString());
						out.close();
						ZipUtil.adicionarArquivo(zos, leitura);

						// close the stream
						zos.close();
						leitura.delete();

						ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente,
										"Resumo das Ações de Cobrança do Cronograma", corpoMensagem, compactado);

						qtdArquigosGerados = qtdArquigosGerados + 1;

						leitura.delete();
					}catch(IOException e){
						e.printStackTrace();
						throw new ControladorException("erro.sistema", e);
					}catch(Exception e){
						e.printStackTrace();
						throw new ControladorException("erro.sistema", e);
					}

				}
				System.out.println("***************************************");
				System.out.println("FIM DA CRIACAO DO ARQUIVO");
				System.out.println("***************************************");
			}

		}catch(ErroRepositorioException e){
			e.printStackTrace();
		}
		return qtdArquigosGerados;
	}

	/**
	 * [UC0157] - Simular Cálculo da Conta
	 * [FS0003] - Verificar Consumo Mínimo
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2007
	 * @param idLigacaoAguaSituacao
	 *            , consumoFaturado
	 * @return void
	 * @throws ControladorException
	 */
	public void verificarConsumoFaturadoAgua(Integer idLigacaoAguaSituacao, Integer consumoFaturado) throws ControladorException{

		FiltroLigacaoAguaSituacao filtroLigacaoAguaSituacao = new FiltroLigacaoAguaSituacao();

		filtroLigacaoAguaSituacao.adicionarParametro(new ParametroSimples(FiltroLigacaoAguaSituacao.ID, idLigacaoAguaSituacao));

		Collection colecaoLigacaoAguaSituacao = getControladorUtil().pesquisar(filtroLigacaoAguaSituacao,
						LigacaoAguaSituacao.class.getName());

		if(colecaoLigacaoAguaSituacao != null && !colecaoLigacaoAguaSituacao.isEmpty()){

			LigacaoAguaSituacao ligacaoAguaSituacao = (LigacaoAguaSituacao) Util.retonarObjetoDeColecao(colecaoLigacaoAguaSituacao);

			if(ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().equals(ConstantesSistema.INDICADOR_USO_ATIVO)
							&& consumoFaturado == null){

				throw new ControladorException("atencao.informe.consumoFaturadoAgua");
			}

			// [FS0003] - Verificar Consumo Mínimo
			else if(consumoFaturado != null && consumoFaturado != 0 && consumoFaturado <= ligacaoAguaSituacao.getConsumoMinimoFaturamento()){

				throw new ControladorException("atencao.informe.consumo_faturado_agua_maior_consumo_minimo", null, ligacaoAguaSituacao
								.getConsumoMinimoFaturamento().toString());

			}
		}
	}

	/**
	 * [UC0157] - Simular Cálculo da Conta
	 * [FS0004] - Verificar Volume Mínimo
	 * 
	 * @author Raphael Rossiter
	 * @date 02/04/2007
	 * @param idLigacaoEsgotoSituacao
	 *            , consumoFaturado
	 * @return void
	 * @throws ControladorException
	 */
	public void verificarConsumoFaturadoEsgoto(Integer idLigacaoEsgotoSituacao, Integer consumoFaturado) throws ControladorException{

		FiltroLigacaoEsgotoSituacao filtroLigacaoEsgotoSituacao = new FiltroLigacaoEsgotoSituacao();

		filtroLigacaoEsgotoSituacao.adicionarParametro(new ParametroSimples(FiltroLigacaoEsgotoSituacao.ID, idLigacaoEsgotoSituacao));

		Collection colecaoLigacaoEsgotoSituacao = getControladorUtil().pesquisar(filtroLigacaoEsgotoSituacao,
						LigacaoEsgotoSituacao.class.getName());

		if(colecaoLigacaoEsgotoSituacao != null && !colecaoLigacaoEsgotoSituacao.isEmpty()){

			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = (LigacaoEsgotoSituacao) Util.retonarObjetoDeColecao(colecaoLigacaoEsgotoSituacao);

			// if(ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao().equals(ConstantesSistema.INDICADOR_USO_ATIVO)
			// && consumoFaturado == null){
			//
			// throw new ControladorException("atencao.informe.consumoFaturadoEsgoto");
			// }

			// [FS0004] - Verificar Volume Mínimo
			// else
			if(consumoFaturado != null && consumoFaturado != 0 && consumoFaturado <= ligacaoEsgotoSituacao.getVolumeMinimoFaturamento()){

				throw new ControladorException("atencao.informe.volume_faturado_esgoto_maior_volume_minimo", null, ligacaoEsgotoSituacao
								.getVolumeMinimoFaturamento().toString());

			}
		}
	}

	/**
	 * [UC0XXX] Emitir Aviso de Cobrança
	 * 
	 * @author Sávio LuizO
	 * @date 09/04/2007
	 */
	public Object[] pesquisarAnoMesEDiaVencimentoFaturamentoGrupo(Integer idImovel) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarAnoMesEDiaVencimentoFaturamentoGrupo(idImovel);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa a soma dos valores das multas cobradas para a conta.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorMultasCobradasPorFinanciamnetoTipo(int idConta) throws ControladorException{

		Collection<Integer> tiposParcelamento = Util
						.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar());

		try{
			return repositorioFaturamento.pesquisarValorMultasCobradasPorFinanciamnetoTipo(idConta, tiposParcelamento);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso calcula a tarifa miníma de água para um imóvel (SUBCATEGORIA)
	 * [UC0451] Obter Tarifa Miníma de Água para um Imóvel
	 * 
	 * @author Raphael Rossiter
	 * @date 13/04/2006
	 * @param imovel
	 * @param colecaoSubcategorias
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	public BigDecimal obterTarifaMinimaAguaImovelPorSubcategoria(Imovel imovel) throws ControladorException{

		// Declaração de variáveis
		BigDecimal tarifaMinimaAguaImovel = new BigDecimal("0.00");
		BigDecimal resultadoTarifaMinimaAguaImovel = new BigDecimal("0.00");

		// Declaração de objetos
		Collection colecaoDataVigencia = null;

		// Obtém o id da tarifa vigência da maior data de vigência da tarifa do
		// imóvel
		try{
			colecaoDataVigencia = repositorioMicromedicao.pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(), imovel
							.getConsumoTarifa().getId());
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém o id do array e atribui na variável
		Object[] consumoTarifaVigenciaIdArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoDataVigencia);
		Integer consumoTarifaVigenciaId = null;

		if(consumoTarifaVigenciaIdArray == null){
			throw new ControladorException("atencao.nao_cadastrada_consumo_tarifa_vigencia", null, String.valueOf(imovel.getId()));
		}

		if(consumoTarifaVigenciaIdArray[0] != null){
			consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0];
		}

		// Cria o objeto consumo tarifa vigência e seta o id
		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		consumoTarifaVigencia.setId(consumoTarifaVigenciaId);

		// [UC0108] - Obter Quantidade de Economias por Categoria
		Collection colecaoSubcategorias = getControladorImovel().obterQuantidadeEconomiasSubCategoria(imovel.getId());

		Iterator colecaoSubcategoriasIterator = colecaoSubcategorias.iterator();

		while(colecaoSubcategoriasIterator.hasNext()){

			Subcategoria subcategoria = (Subcategoria) colecaoSubcategoriasIterator.next();

			try{
				// Obtém a tarifa mínima da subcategoria do imóvel
				tarifaMinimaAguaImovel = (BigDecimal) repositorioFaturamento.pesquisarTarifaMinimaCategoriaVigenciaPorSubcategoria(
								consumoTarifaVigencia, subcategoria);

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			/*
			 * Caso não exista tarifa cadastrada para a subcategoria em questao, utilizar a tarifa
			 * da categoria
			 */
			if(tarifaMinimaAguaImovel == null){

				Categoria categoria = subcategoria.getCategoria();
				categoria.setQuantidadeEconomiasCategoria(subcategoria.getQuantidadeEconomias());

				Collection colecaoCategoria = new ArrayList();
				colecaoCategoria.add(categoria);

				tarifaMinimaAguaImovel = this.obterTarifaMinimaAguaImovel(imovel);

			}

			// Multiplica a quantidade de economias da categoria pelo consumo
			// mínimo e acumula
			resultadoTarifaMinimaAguaImovel = resultadoTarifaMinimaAguaImovel.add(tarifaMinimaAguaImovel.multiply(new BigDecimal(
							subcategoria.getQuantidadeEconomias())));

		}

		// Retorna o consumo mínimo da ligação
		return resultadoTarifaMinimaAguaImovel;
	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0004] Verificar Critério de Cobrança para
	 * Imóvel Pesquisa a soma dos imoveis com parcelamento.
	 * 
	 * @author Sávio Luiz
	 * @date 13/04/2007
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public int pesquisarQuantidadeDebitosCobradosComParcelamento(Collection<ContaValoresHelper> colecaoContasValores)
					throws ControladorException{

		Collection<Integer> tiposParcelamento = Util
						.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar());

		try{
			return repositorioFaturamento.pesquisarQuantidadeDebitosCobradosComParcelamento(colecaoContasValores, tiposParcelamento);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisar conjunto de contas p/ emissão da 2°Via
	 * 
	 * @author Ana Maria
	 * @date 19/04/2007
	 * @param colecaoImovel
	 * @param anoMes
	 * @throws ControladorException
	 */
	public Collection pesquisarConjuntoContaEmitir2Via(Collection colecaoImovel, Integer anoMes, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim) throws ControladorException{

		Collection colecaoContasEmissao = new ArrayList();
		Collection colecaoContasManutencao = new ArrayList();
		List colecaoAuxiliar = new ArrayList();

		colecaoAuxiliar.addAll(colecaoImovel);

		int i = 0;
		int cont = 500;

		Collection colecao = new ArrayList();
		while(i <= colecaoImovel.size()){

			if(colecaoImovel.size() - i >= cont){
				colecao = colecaoAuxiliar.subList(i, i + cont);
			}else{
				colecao = colecaoAuxiliar.subList(i, colecaoImovel.size());
			}
			i = i + cont;
			try{
				colecaoContasManutencao = repositorioFaturamento.pesquisarIdContasImoveis(anoMes, colecao, dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFim);
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
			if(colecaoContasManutencao != null && !colecaoContasManutencao.isEmpty()){
				colecaoContasEmissao.addAll(colecaoContasManutencao);
			}
		}

		return colecaoContasEmissao;
	}

	/**
	 * Gera credito a realizar para os imóveis de determinados grupos
	 * BATCH PARA CORREÇÃO DA BASE
	 * 
	 * @author Sávio Luiz
	 * @date 02/05/2007
	 */
	public void gerarCreditoARealizarPorImoveisDoGrupo(Collection idsGrupos, Integer anoMesReferenciaConta, Integer anoMesReferenciaDebito)
					throws ControladorException{

		Collection colecaoDadosImovelCreditoARealizar = null;
		try{
			colecaoDadosImovelCreditoARealizar = repositorioFaturamento.pesquisarDadosImoveisParaGerarCreditoARealizar(idsGrupos,
							anoMesReferenciaConta, anoMesReferenciaDebito);
		}catch(ErroRepositorioException ex){
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		if(colecaoDadosImovelCreditoARealizar != null && !colecaoDadosImovelCreditoARealizar.equals("")){
			Iterator iteDados = colecaoDadosImovelCreditoARealizar.iterator();
			while(iteDados.hasNext()){
				Object[] dadosImovelCreditoARealizar = (Object[]) iteDados.next();
				if(dadosImovelCreditoARealizar != null){
					Integer idImovel = null;
					Integer idLocalidade = null;
					Integer idQuadra = null;
					Integer numeroQuadra = null;
					Integer codigoSetor = null;
					Short lote = null;
					Short subLote = null;
					BigDecimal valorPretacao = null;
					Integer amreferenciaDebito = null;
					if(dadosImovelCreditoARealizar[0] != null){
						idImovel = (Integer) dadosImovelCreditoARealizar[0];
					}
					if(dadosImovelCreditoARealizar[1] != null){
						idLocalidade = (Integer) dadosImovelCreditoARealizar[1];
					}
					if(dadosImovelCreditoARealizar[2] != null){
						idQuadra = (Integer) dadosImovelCreditoARealizar[2];
					}
					if(dadosImovelCreditoARealizar[3] != null){
						numeroQuadra = (Integer) dadosImovelCreditoARealizar[3];
					}
					if(dadosImovelCreditoARealizar[4] != null){
						codigoSetor = (Integer) dadosImovelCreditoARealizar[4];
					}
					if(dadosImovelCreditoARealizar[5] != null){
						lote = (Short) dadosImovelCreditoARealizar[5];
					}
					if(dadosImovelCreditoARealizar[6] != null){
						subLote = (Short) dadosImovelCreditoARealizar[6];
					}
					if(dadosImovelCreditoARealizar[7] != null){
						valorPretacao = (BigDecimal) dadosImovelCreditoARealizar[7];
					}
					if(dadosImovelCreditoARealizar[8] != null){
						amreferenciaDebito = (Integer) dadosImovelCreditoARealizar[8];
					}

					// cria o objeto de credito a realizar Geral
					CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
					creditoARealizarGeral.setIndicadorHistorico(new Short("2"));
					creditoARealizarGeral.setUltimaAlteracao(new Date());
					Integer idCreditoARealizarGeral = (Integer) getControladorUtil().inserir(creditoARealizarGeral);
					creditoARealizarGeral.setId(idCreditoARealizarGeral);

					// cria o objeto de credito a realizar
					CreditoARealizar creditoARealizar = new CreditoARealizar();
					creditoARealizar.setId(idCreditoARealizarGeral);
					creditoARealizar.setCreditoARealizarGeral(creditoARealizarGeral);
					if(idImovel != null){
						Imovel imovel = new Imovel(idImovel);
						creditoARealizar.setImovel(imovel);
					}
					creditoARealizar.setCreditoTipo(new CreditoTipo(CreditoTipo.DEVOLUCAO_ACRESCIMOS_IMPONTUALIDADE));
					creditoARealizar.setGeracaoCredito(new Date());
					creditoARealizar.setAnoMesReferenciaCredito(amreferenciaDebito);
					creditoARealizar.setAnoMesCobrancaCredito(sistemaParametro.getAnoMesArrecadacao());
					creditoARealizar.setAnoMesReferenciaContabil(sistemaParametro.getAnoMesFaturamento());
					creditoARealizar.setValorCredito(valorPretacao);
					creditoARealizar.setValorResidualMesAnterior(new BigDecimal("0.00"));
					creditoARealizar.setNumeroPrestacaoCredito(new Short("1"));
					creditoARealizar.setNumeroPrestacaoRealizada(new Short("0"));
					if(idLocalidade != null){
						Localidade localidade = new Localidade(idLocalidade);
						creditoARealizar.setLocalidade(localidade);
					}
					if(idQuadra != null){
						Quadra quadra = new Quadra(idQuadra);
						creditoARealizar.setQuadra(quadra);
					}
					creditoARealizar.setCodigoSetorComercial(codigoSetor);
					creditoARealizar.setNumeroQuadra(numeroQuadra);
					creditoARealizar.setNumeroLote(lote);
					creditoARealizar.setNumeroSubLote(subLote);
					creditoARealizar.setLancamentoItemContabil(new LancamentoItemContabil(
									LancamentoItemContabil.ACRESCIMOS_POR_IMPONTUALIDADE));
					creditoARealizar.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));
					creditoARealizar.setCreditoOrigem(new CreditoOrigem(CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE));
					creditoARealizar.setUltimaAlteracao(new Date());
					getControladorUtil().inserir(creditoARealizar);

					if(idImovel != null){
						Map<Categoria, BigDecimal> mapValorIRPagamentosClassificadosConta = new HashMap();
						// [UC0108 - Obter Quantidade de Economias por
						// Categoria]
						Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(new Imovel(idImovel));
						Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

						// [UC0185 - Obter Valor por Categoria]
						Iterator iteratorColecaoValorIRPorCategoria = (getControladorImovel().obterValorPorCategoria(
										colecaoCategoriasImovel, valorPretacao)).iterator();

						while(iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorIRPorCategoria.hasNext()){
							Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

							BigDecimal valorIR = (BigDecimal) iteratorColecaoValorIRPorCategoria.next();

							if(!mapValorIRPagamentosClassificadosConta.containsKey(categoria)){
								mapValorIRPagamentosClassificadosConta.put(categoria, BigDecimal.ZERO);
							}

							mapValorIRPagamentosClassificadosConta.put(categoria, mapValorIRPagamentosClassificadosConta.get(categoria)
											.add(valorIR));
						}
						Iterator mapIterator = mapValorIRPagamentosClassificadosConta.keySet().iterator();
						while(mapIterator.hasNext()){
							Categoria categoria = (Categoria) mapIterator.next();
							CreditoARealizarCategoria creditoARealizarCategoria = new CreditoARealizarCategoria();
							creditoARealizarCategoria.setComp_id(new CreditoARealizarCategoriaPK(creditoARealizar, categoria));
							creditoARealizarCategoria.setCategoria(categoria);
							creditoARealizarCategoria.setCreditoARealizar(creditoARealizar);
							BigDecimal valorCategoria = mapValorIRPagamentosClassificadosConta.get(categoria);
							creditoARealizarCategoria.setValorCategoria(valorCategoria);
							creditoARealizarCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
							creditoARealizarCategoria.setUltimaAlteracao(new Date());
							getControladorUtil().inserir(creditoARealizarCategoria);
						}
					}
				}

			}
		}

	}

	/**
	 * [UC0150] - Retificar Conta Author: Vivianne Sousa Data: 25/04/2007
	 * atualizar na tabela PAGAMENTO a coluna CNTA_ID com id da nova conta gerada onde CNTA_ID = id
	 * da conta a ser retificada
	 * 
	 * @param conta
	 * @param colecaoCreditoRealizado
	 * @param imovel
	 * @param colecaoCategoria
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	private void atualizarPagamentoContaRetificada(Integer idContaRetificada, Integer idContaInserida) throws ControladorException{

		// Atualizar, caso existam, os pagamentos referentes a
		// conta que foi retificada com o id da nova conta gerada

		Pagamento pagamento = null;

		pagamento = getControladorArrecadacao().pesquisarPagamentoDeConta(idContaRetificada);

		if(pagamento != null){
			try{
				repositorioArrecadacao.atualizarContaEmPagamento(pagamento.getId(), idContaInserida);
			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

	}

	/**
	 * [UC0144] Inserir Comando Atividade Faturamento
	 * A data de vencimento do grupo será formatada com o mês seguinte ao de referência do grupo
	 * 
	 * @author Raphael Rossiter
	 * @date 05/05/2007
	 * @param diaVencimento
	 *            , mesVencimento, anoVencimento
	 * @throws ControladorException
	 */
	public Date obterDataVencimentoFaturamentoGrupo(int diaVencimento, int mesVencimento, int anoVencimento) throws ControladorException{

		Calendar dataVencimento = new GregorianCalendar(anoVencimento, mesVencimento, diaVencimento);

		return dataVencimento.getTime();
	}

	/**
	 * [UC0XXX] - Gerar Relatório Tarifa de Consumo
	 * Pesquisas as tarifas de consumo para o relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 11/05/2007
	 * @param descricao
	 *            , dataVigenciaInicial, dataVigenciaFinal
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarConsumoTarifaRelatorio(String descricao, Date dataVigenciaInicial, Date dataVigenciaFinal,
					String descricaoAtoAdministrativo) throws ControladorException{

		Collection colecaoDadosConsumoTarifa = null;
		Collection colecaoConsumoTarifaRelatorioHelper = new ArrayList();

		try{
			colecaoDadosConsumoTarifa = repositorioFaturamento.pesquisarConsumoTarifaRelatorio(descricao, dataVigenciaInicial,
							dataVigenciaFinal, descricaoAtoAdministrativo);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDadosConsumoTarifa != null && !colecaoDadosConsumoTarifa.isEmpty()){

			Iterator colecaoDadosConsumoTarifaIterator = colecaoDadosConsumoTarifa.iterator();

			ConsumoTarifaRelatorioHelper consumoTarifaRelatorioHelper = null;

			while(colecaoDadosConsumoTarifaIterator.hasNext()){

				Object[] dadosConsumoTarifa = (Object[]) colecaoDadosConsumoTarifaIterator.next();

				consumoTarifaRelatorioHelper = new ConsumoTarifaRelatorioHelper();

				// Id da Tarifa de Consumo
				if(dadosConsumoTarifa[0] != null){
					consumoTarifaRelatorioHelper.setIdConsumoTarifa((Integer) dadosConsumoTarifa[0]);
				}

				// Descrição da Tarifa de Consumo
				if(dadosConsumoTarifa[1] != null){
					consumoTarifaRelatorioHelper.setDescricaoConsumoTarifa((String) dadosConsumoTarifa[1]);
				}

				// Categoria
				if(dadosConsumoTarifa[2] != null){
					consumoTarifaRelatorioHelper.setCategoria((String) dadosConsumoTarifa[2]);
				}

				// Faixa Inicial
				if(dadosConsumoTarifa[3] != null){
					consumoTarifaRelatorioHelper.setFaixaInicial((Integer) dadosConsumoTarifa[3]);
				}

				// Faixa Final
				if(dadosConsumoTarifa[4] != null){
					consumoTarifaRelatorioHelper.setFaixaFinal((Integer) dadosConsumoTarifa[4]);
				}

				// Custo
				if(dadosConsumoTarifa[5] != null){
					consumoTarifaRelatorioHelper.setCusto((BigDecimal) dadosConsumoTarifa[5]);
				}

				// Tarifa Mínima
				if(dadosConsumoTarifa[6] != null){
					consumoTarifaRelatorioHelper.setTarifaMinima((BigDecimal) dadosConsumoTarifa[6]);
				}

				// Data Validade Inicial
				if(dadosConsumoTarifa[7] != null){
					consumoTarifaRelatorioHelper.setDataValidadeInicial((Date) dadosConsumoTarifa[7]);
				}

				// Consumo Mínimo
				if(dadosConsumoTarifa[8] != null){
					consumoTarifaRelatorioHelper.setConsumoMinimo((Integer) dadosConsumoTarifa[8]);
				}

				colecaoConsumoTarifaRelatorioHelper.add(consumoTarifaRelatorioHelper);

			}

		}

		return colecaoConsumoTarifaRelatorioHelper;

	}

	/**
	 * [UC0XXX] - Gerar Relatório de Tarifa de Consumo
	 * Pesquisas a data final de validade de uma tarifa de consumo
	 * 
	 * @author Rafael Corrêa
	 * @date 11/05/2007
	 * @param Integer
	 *            idConsumoTarifa
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarDataFinalValidadeConsumoTarifa(Integer idConsumoTarifa, Date dataInicioVigencia) throws ControladorException{

		Date dataFimVigencia = null;
		Date dataQuery = null;

		try{
			dataQuery = repositorioFaturamento.pesquisarDataFinalValidadeConsumoTarifa(idConsumoTarifa, dataInicioVigencia);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(dataQuery != null){
			dataFimVigencia = Util.subtrairNumeroDiasDeUmaData(dataQuery, 1);
		}

		return dataFimVigencia;

	}

	/**
	 * Recupera o id da Conta Retificada
	 * 
	 * @author Vivianne Sousa
	 * @date 08/05/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarAnoMesReferenciaFaturamentoGrupo(Integer idImovel) throws ControladorException{

		Integer retorno = null;
		try{
			retorno = repositorioFaturamento.pesquisarAnoMesReferenciaFaturamentoGrupo(idImovel);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Recupera as contas do Imóveis
	 * 
	 * @author Ana Maria
	 * @date 19/03/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Integer obterContasConjuntoImoveis(Integer anoMes, Collection idsImovel, Integer codigoCliente, Integer relacaoTipo,
					Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Collection colecaoGrupoFaturamento, Integer anoMesFinal,
					String inContasRevisao, Integer[] motivosRevisaoDisponiveis) throws ControladorException{

		Integer quantidadeConta = 0;
		try{
			if(codigoCliente != null){
				quantidadeConta = repositorioFaturamento.pesquisarQuantidadeContasCliente(codigoCliente, relacaoTipo, anoMes,
								dataVencimentoContaInicio, dataVencimentoContaFim, anoMesFinal, inContasRevisao, motivosRevisaoDisponiveis);
			}else if(colecaoGrupoFaturamento != null && !colecaoGrupoFaturamento.isEmpty()){
				quantidadeConta = repositorioFaturamento.pesquisarQuantidadeContasGrupoFaturamento(anoMes, colecaoGrupoFaturamento,
								dataVencimentoContaInicio, dataVencimentoContaFim, anoMesFinal, inContasRevisao, motivosRevisaoDisponiveis);
			}else{
				quantidadeConta = repositorioFaturamento.pesquisarQuantidadeContasImoveis(anoMes, idsImovel, dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFinal, inContasRevisao, motivosRevisaoDisponiveis);
			}
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return quantidadeConta;
	}
	
	/**
	 * [UC0146] Manter Conta
	 * Recupera as contas do Imóveis
	 * 
	 * @author Carlos Chrystian
	 * @date 07/05/2013
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection recuperarContasConjuntoImoveis(Integer anoMes, Collection idsImovel, Integer codigoCliente, Integer relacaoTipo,
					Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Collection colecaoGrupoFaturamento, Integer anoMesFinal,
					String inContasRevisao, Integer[] motivosRevisaoDisponiveis) throws ControladorException{

		Collection colecaoContasImoveis = new ArrayList();
		Collection colecaoContasConjuntosImoveis = new ArrayList();
		
		try{
			if(codigoCliente != null){
				colecaoContasImoveis = repositorioFaturamento.pesquisarContasCliente(codigoCliente, relacaoTipo, anoMes,
								dataVencimentoContaInicio, dataVencimentoContaFim, anoMesFinal, inContasRevisao, motivosRevisaoDisponiveis);

				if(!Util.isVazioOrNulo(colecaoContasImoveis)){

					for(Object obj : colecaoContasImoveis){

						Object[] contaArray = (Object[]) obj;

						Conta conta = new Conta();

						// 0 - conta.id
						if(contaArray[0] != null){
							conta.setId((Integer) contaArray[0]);

							// Insere Indicador de Pagamento, Indicador de Conta em Cobrança
							// Administrativa e Motivo de Revisão
							FiltroConta filtroConta = new FiltroConta();
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, conta.getId()));
							filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.CONTA_MOTIVO_REVISAO);

							Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

							if(!Util.isVazioOrNulo(colecaoConta)){
								Conta contaAux = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

								conta.setContaMotivoRevisao(contaAux.getContaMotivoRevisao());

								conta.setIndicadorPagamento(contaAux.getIndicadorPagamento());

								conta.setIndicadorCobrancaAdministrativa(contaAux.getIndicadorCobrancaAdministrativa());
							}
						}

						// 1 - conta.referencia
						if(contaArray[1] != null){
							conta.setReferencia((Integer) contaArray[1]);
						}

						// 2 - conta.dataVencimentoConta
						if(contaArray[2] != null){
							String vencimento = String.valueOf(contaArray[2]);
							SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd");
							Date dataVencimento;

							try{
								dataVencimento = formatoData.parse(vencimento);
							}catch(java.text.ParseException e){
								dataVencimento = null;
							}

							conta.setDataVencimentoConta(dataVencimento);

						}

						// 3 - conta.valorAgua
						if(contaArray[3] != null){
							conta.setValorAgua((BigDecimal) contaArray[3]);
						}
						// 4 - conta.valorEsgoto
						if(contaArray[4] != null){
							conta.setValorEsgoto((BigDecimal) contaArray[4]);
						}
						// 5 - conta.debitos
						if(contaArray[5] != null){
							conta.setDebitos((BigDecimal) contaArray[5]);
						}
						// 6 - conta.valorCreditos
						if(contaArray[6] != null){
							conta.setValorCreditos((BigDecimal) contaArray[6]);
						}
						// 11 - conta.debitoCreditoSituacaoAtual
						if(contaArray[11] != null){
							conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);
						}

						// 14 - imov
						if(contaArray[14] != null){
							Imovel imovel = (Imovel) contaArray[14];
							conta.setImovel(imovel);
						}

						// 17 - conta.valorImposto
						if(contaArray[17] != null){
							conta.setValorImposto((BigDecimal) contaArray[17]);
						}

						// 18 - indicadorExecucaoFiscal
						if(contaArray[18] != null){
							conta.setIndicadorExecucaoFiscal((Short) contaArray[18]);
						}

						if(!colecaoContasConjuntosImoveis.contains(conta)){
							colecaoContasConjuntosImoveis.add(conta);
						}
						
					}
				}
			}else if(colecaoGrupoFaturamento != null && !colecaoGrupoFaturamento.isEmpty()){
				colecaoContasImoveis = repositorioFaturamento.pesquisarContasGrupoFaturamento(anoMes, colecaoGrupoFaturamento,
								dataVencimentoContaInicio, dataVencimentoContaFim, anoMesFinal, inContasRevisao, motivosRevisaoDisponiveis);

				if(!Util.isVazioOrNulo(colecaoContasImoveis)){

					for(Object obj : colecaoContasImoveis){

						Object[] contaArray = (Object[]) obj;

						Conta conta = new Conta();

						// 0 - conta.id
						if(contaArray[0] != null){
							conta.setId((Integer) contaArray[0]);

							// Insere Indicador de Pagamento, Indicador de Conta em Cobrança
							// Administrativa e Motivo de Revisão
							FiltroConta filtroConta = new FiltroConta();
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, conta.getId()));
							filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.CONTA_MOTIVO_REVISAO);

							Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

							if(!Util.isVazioOrNulo(colecaoConta)){
								Conta contaAux = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

								conta.setContaMotivoRevisao(contaAux.getContaMotivoRevisao());

								conta.setIndicadorPagamento(contaAux.getIndicadorPagamento());

								conta.setIndicadorCobrancaAdministrativa(contaAux.getIndicadorCobrancaAdministrativa());
							}
						}

						// 1 - conta.referencia
						if(contaArray[1] != null){
							conta.setReferencia((Integer) contaArray[1]);
						}

						// 2 - conta.dataVencimentoConta
						if(contaArray[2] != null){
							String vencimento = String.valueOf(contaArray[2]);
							SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd");
							Date dataVencimento;

							try{
								dataVencimento = formatoData.parse(vencimento);
							}catch(java.text.ParseException e){
								dataVencimento = null;
							}

							conta.setDataVencimentoConta(dataVencimento);

						}

						// 3 - conta.valorAgua
						if(contaArray[3] != null){
							conta.setValorAgua((BigDecimal) contaArray[3]);
						}
						// 4 - conta.valorEsgoto
						if(contaArray[4] != null){
							conta.setValorEsgoto((BigDecimal) contaArray[4]);
						}
						// 5 - conta.debitos
						if(contaArray[5] != null){
							conta.setDebitos((BigDecimal) contaArray[5]);
						}
						// 6 - conta.valorCreditos
						if(contaArray[6] != null){
							conta.setValorCreditos((BigDecimal) contaArray[6]);
						}
						// 11 - conta.debitoCreditoSituacaoAtual
						if(contaArray[11] != null){
							conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);
						}

						// 14 - imov
						if(contaArray[14] != null){
							Imovel imovel = (Imovel) contaArray[14];
							conta.setImovel(imovel);
						}

						// 16 - conta.valorImposto
						if(contaArray[16] != null){
							conta.setValorImposto((BigDecimal) contaArray[16]);
						}

						if(!colecaoContasConjuntosImoveis.contains(conta)){
							colecaoContasConjuntosImoveis.add(conta);
						}

					}
				}
			}else{
				colecaoContasImoveis = repositorioFaturamento.pesquisarContasImoveis(anoMes, idsImovel, dataVencimentoContaInicio,
								dataVencimentoContaFim, anoMesFinal, inContasRevisao, motivosRevisaoDisponiveis);

				if(!Util.isVazioOrNulo(colecaoContasImoveis)){

					for(Object obj : colecaoContasImoveis){

						Object[] contaArray = (Object[]) obj;

						Conta conta = new Conta();

						// 0 - conta.id
						if(contaArray[0] != null){
							conta.setId((Integer) contaArray[0]);

							// Insere Indicador de Pagamento, Indicador de Conta em Cobrança
							// Administrativa e Motivo de Revisão
							FiltroConta filtroConta = new FiltroConta();
							filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, conta.getId()));
							filtroConta.adicionarCaminhoParaCarregamentoEntidade(FiltroConta.CONTA_MOTIVO_REVISAO);

							Collection<Conta> colecaoConta = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

							if(!Util.isVazioOrNulo(colecaoConta)){
								Conta contaAux = (Conta) Util.retonarObjetoDeColecao(colecaoConta);

								conta.setContaMotivoRevisao(contaAux.getContaMotivoRevisao());

								conta.setIndicadorPagamento(contaAux.getIndicadorPagamento());

								conta.setIndicadorCobrancaAdministrativa(contaAux.getIndicadorCobrancaAdministrativa());
							}
						}

						// 1 - conta.referencia
						if(contaArray[1] != null){
							conta.setReferencia((Integer) contaArray[1]);
						}

						// 2 - conta.dataVencimentoConta
						if(contaArray[2] != null){
							String vencimento = String.valueOf(contaArray[2]);
							SimpleDateFormat formatoData = new SimpleDateFormat("yyyy-MM-dd");
							Date dataVencimento;

							try{
								dataVencimento = formatoData.parse(vencimento);
							}catch(java.text.ParseException e){
								dataVencimento = null;
							}

							conta.setDataVencimentoConta(dataVencimento);

						}

						// 3 - conta.valorAgua
						if(contaArray[3] != null){
							conta.setValorAgua((BigDecimal) contaArray[3]);
						}
						// 4 - conta.valorEsgoto
						if(contaArray[4] != null){
							conta.setValorEsgoto((BigDecimal) contaArray[4]);
						}
						// 5 - conta.debitos
						if(contaArray[5] != null){
							conta.setDebitos((BigDecimal) contaArray[5]);
						}
						// 6 - conta.valorCreditos
						if(contaArray[6] != null){
							conta.setValorCreditos((BigDecimal) contaArray[6]);
						}
						// 11 - conta.debitoCreditoSituacaoAtual
						if(contaArray[11] != null){
							conta.setDebitoCreditoSituacaoAtual((DebitoCreditoSituacao) contaArray[11]);
						}

						// 14 - imov
						if(contaArray[14] != null){
							Imovel imovel = (Imovel) contaArray[14];
							conta.setImovel(imovel);
						}

						// 17 - conta.valorImposto
						if(contaArray[17] != null){
							conta.setValorImposto((BigDecimal) contaArray[17]);
						}

						if(!colecaoContasConjuntosImoveis.contains(conta)){
							colecaoContasConjuntosImoveis.add(conta);
						}
					}
				}
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		
		return colecaoContasConjuntosImoveis;
	}

	/**
	 * [UC0147] - Cancelar Conjunto Conta
	 * 
	 * @author Ana Maria
	 * @date 10/12/2005
	 * @author Luciano Galvao
	 * @date 05/11/2013
	 */
	public void cancelarConjuntoConta(Collection<Conta> colecaoContasSelecionadas, ContaMotivoCancelamento contaMotivoCancelamento,
					Usuario usuarioLogado, String numeroRA) throws ControladorException{

		Collection colecaoConta = new ArrayList();
		Collection colecaoContasCancelar = new ArrayList();
		String identificadores = "";
		try{
			if(colecaoContasSelecionadas != null && !colecaoContasSelecionadas.isEmpty()){

				Iterator colecaoContasManutencaoIterator = colecaoContasSelecionadas.iterator();

				while(colecaoContasManutencaoIterator.hasNext()){

					// Obtém os dados do crédito realizado
					Conta conta = (Conta) colecaoContasManutencaoIterator.next();

					colecaoConta.add(conta);

					if(identificadores.length() == 0){
						identificadores = conta.getId().toString();
					}else{
						identificadores = identificadores + "," + conta.getId();
					}
				}
			}

			Iterator colecaoContasIt = colecaoConta.iterator();
			Conta contaColecao = null;
			FiltroConta filtroConta = new FiltroConta();

			while(colecaoContasIt.hasNext()){
				contaColecao = (Conta) colecaoContasIt.next();

				// Usuário logado
				contaColecao.setUsuario(usuarioLogado);

				// Carregando a conta que está na base
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, contaColecao.getId()));

				filtroConta.limparListaParametros();
				/**
				 * Caso a situação atual da conta corresponda a normal (DCST_IDATUAL com o valor
				 * correspondente a normal da tabela
				 * DEBITO_CREDITO_SITUACAO) ou corresponda a retificada ou incluída (DCST_IDATUAL
				 * com o valor correspondente a retificada ou incluída,
				 * da tabela DEBITO_CREDITO_SITUACAO) e a retificação ou inclusão já tenha sido
				 * contabilizada (CNTA_AMREFERENCIACONTABIL menor que
				 * PARM_AMREFERENCIAFATURAMENTO da tabela SISTEMA_PARAMETROS), atualizar os
				 * seguintes atributos da conta.
				 */

				SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

				if(contaColecao.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.NORMAL)
								|| contaColecao.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.INCLUIDA)
								|| contaColecao.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.RETIFICADA)){

					// Data do cancelamento
					contaColecao.setDataCancelamento(new Date());

					// Motivo do Cancelamento
					contaColecao.setContaMotivoCancelamento(contaMotivoCancelamento);

					// Situação Anterior
					/*
					 * Caso a situação atual da conta corresponda a normal (DCST_IDATUAL com o valor
					 * correspondente a normal da tabela
					 * DEBITO_CREDITO_SITUACAO) e a conta tenha sido faturada no mês de faturamento
					 * corrente (CNTA_AMREFERENCIACONTA=
					 * PARM_AMREFERENCIAFATURAMENTO da tabela SISTEMA_PARAMETROS)
					 * DCST_IDANTERIOR=DCST_IDATUAL, caso contrário DCST_IDANTERIOR=nulo)
					 */
					if(contaColecao.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.NORMAL)
									&& Util.compararAnoMesReferencia(Integer.valueOf(contaColecao.getReferencia()),
													Integer.valueOf(sistemaParametro.getAnoMesFaturamento()), "=")){

						contaColecao.setDebitoCreditoSituacaoAnterior(contaColecao.getDebitoCreditoSituacaoAtual());
					}else{
						contaColecao.setDebitoCreditoSituacaoAnterior(null);
					}

					// Situação Atual
					DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
					debitoCreditoSituacao.setId(DebitoCreditoSituacao.CANCELADA);
					contaColecao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

					// última alteração
					contaColecao.setUltimaAlteracao(new Date());

					// RA informado
					if(!Util.isVazioOuBranco(numeroRA)){
						RegistroAtendimento registroAtendimento = new RegistroAtendimento();

						registroAtendimento.setId(Integer.valueOf(numeroRA));

						contaColecao.setRegistroAtendimento(registroAtendimento);
					}
					// // UPDATE
					// if(contaColecao.getDebitoCreditoSituacaoAnterior() == null){
					// repositorioFaturamento.cancelarContaReferenciaContabilMenorSistemaParametro(contaColecao,
					// null);
					//
					// }else{
					// repositorioFaturamento.cancelarContaReferenciaContabilMenorSistemaParametro(contaColecao,
					// contaColecao
					// .getDebitoCreditoSituacaoAnterior().getId());
					// }

					colecaoContasCancelar.add(contaColecao);

					// // // [UC0566 – Gerar Histograma de Água e Esgoto]
					// Collection colecaoContaCancelar = Collections.singletonList(contaColecao);
					// carregarContaParaHistograma(colecaoContaCancelar);
					// getControladorHistograma().gerarHistogramaAguaEsgoto(colecaoContaCancelar,
					// ConstantesSistema.GERACAO_HISTOGRAMA_CANCELAMENTO);

				}
			}

			this.cancelarConta(colecaoContasCancelar, identificadores, contaMotivoCancelamento, usuarioLogado, numeroRA);

		}catch(ControladorException ex){
			sessionContext.setRollbackOnly();
			throw ex;

		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0435] Encerrar Registro de Atendimento
	 * 
	 * @author Carlos Chrystian
	 * @date 13/05/2013
	 * @param numeroRA
	 * @param codigoCliente
	 * @param usuarioLogado
	 */
	public void encerrarRegistroAtendimento(String numeroRA, ClienteImovel clienteImovel, Usuario usuarioLogado)
					throws ControladorException{

		// 4.1.2. Caso tenha sido informado registro de atendimento para o cancelamento das
		// contas,
		if(!Util.isVazioOuBranco(numeroRA)){
			Collection<FiltroCliente> colecaoCliente = null;
			String idCliente = "";
			String nomeCliente = "";

			// encerrar o registro de atendimento - [UC0435 - Encerrar Registro de Atendimento]
			// ************************************
			RegistroAtendimento registroAtendimento = getControladorRegistroAtendimento().pesquisarRegistroAtendimento(
							Integer.valueOf(numeroRA));
			
			if(!Util.isVazioOuBranco(registroAtendimento)){

				// Motivo do Encerramento (AMEN_ID)
				// AMEN_ID da tabela ATENDIMENTO_MOTIVO_ENCRTO com
				// AMEN_DSMOTIVOENCERRAMENTO=“EXECUCAO DO SERVICO”
				AtendimentoMotivoEncerramento atendimentoMotivoEncerramento = new AtendimentoMotivoEncerramento();
				atendimentoMotivoEncerramento.setId(AtendimentoMotivoEncerramento.CONCLUSAO_SERVICO);

				registroAtendimento.setAtendimentoMotivoEncerramento(atendimentoMotivoEncerramento);

				// Situação do RA (RGAT_CDSITUACAO)
				// --2 (encerrado)
				registroAtendimento.setCodigoSituacao(RegistroAtendimento.SITUACAO_ENCERRADO);
				registroAtendimento.setDataEncerramento(new Date());

				// Data e hora do encerramento (RGAT_TMENCERRAMENTO)
				// --Data e hora corrente
				registroAtendimento.setDataEncerramento(new Date());

				Imovel imovel = null;

				if(Util.isVazioOuBranco(clienteImovel)){
					imovel = this.getControladorCliente().obterClienteImovelResponsavel(registroAtendimento.getImovel().getId());

					if(!Util.isVazioOuBranco(imovel)){
						// Pesquisa nome do cliente
						FiltroCliente filtroCliente = new FiltroCliente();
						filtroCliente.adicionarParametro(new ParametroSimples(FiltroCliente.IMOVEL_ID, imovel.getId()));

						colecaoCliente = this.getControladorUtil().pesquisar(filtroCliente, Cliente.class.getName());

						if(!Util.isVazioOrNulo(colecaoCliente)){
							Cliente cliente = (Cliente) Util.retonarObjetoDeColecao(colecaoCliente);
							idCliente = cliente.getId().toString();
							nomeCliente = cliente.getNome();
						}
					}
				}else{
					// Pesquisa nome do cliente
					idCliente = clienteImovel.getCliente() != null ? clienteImovel.getCliente().getId().toString() : "";
					nomeCliente = (clienteImovel.getCliente() != null && clienteImovel.getCliente().getNome() != null) ? clienteImovel
									.getCliente().getNome() : "";
				}

				// Parecer do encerramento RGAT_DSPARECERENCERRAMENTO
				String descricaoParecerEncerramento = "Este RA foi encerrado em razão do cancelamento das contas do cliente " + idCliente
								+ " - " + nomeCliente;

				registroAtendimento.setParecerEncerramento(descricaoParecerEncerramento);

				// Data e hora da última alteração do RA (RGAT_TMULTIMAALTERACAO)
				registroAtendimento.setUltimaAlteracao(new Date());

				// cria o RegistroAtendimentoUnidade que será enviado para o método
				// encerrarRegistroAtendimento
				RegistroAtendimentoUnidade registroAtendimentoUnidade = new RegistroAtendimentoUnidade();
				registroAtendimentoUnidade.setRegistroAtendimento(registroAtendimento);

				// obtem o usuário batch
				FiltroUsuario filtroUsuario = new FiltroUsuario();
				filtroUsuario.adicionarParametro(new ParametroSimples(FiltroUsuario.ID, Integer
								.valueOf((String) ParametroGeral.P_USUARIO_BATCH.executar())));
				filtroUsuario.adicionarCaminhoParaCarregamentoEntidade("unidadeOrganizacional");

				Collection<Usuario> collUsuario = getControladorUtil().pesquisar(filtroUsuario, Usuario.class.getName());

				Usuario usuarioBatch = null;
				if(collUsuario != null && !collUsuario.isEmpty()){

					usuarioBatch = collUsuario.iterator().next();
					registroAtendimentoUnidade.setUsuario(usuarioBatch);

					if(usuarioBatch.getUnidadeOrganizacional() != null && !usuarioBatch.getUnidadeOrganizacional().equals("")){
						registroAtendimentoUnidade.setUnidadeOrganizacional(usuarioBatch.getUnidadeOrganizacional());
					}

				}

				// atendimento relação tipo
				AtendimentoRelacaoTipo atendimentoRelacaoTipo = new AtendimentoRelacaoTipo();
				atendimentoRelacaoTipo.setId(AtendimentoRelacaoTipo.ENCERRAR);
				registroAtendimentoUnidade.setAtendimentoRelacaoTipo(atendimentoRelacaoTipo);
				registroAtendimentoUnidade.setUltimaAlteracao(new Date());

				// Unidade de encerramento (UNID_ID da tabela REGISTRO_ATENDIMENTO_UNIDADE)
				registroAtendimento.setAtendimentoMotivoEncerramento(atendimentoMotivoEncerramento);
				// Operação realizada (ATTP_ID da tabela REGISTRO_ATENDIMENTO_UNIDADE)
				registroAtendimento.setOperacaoEfetuada(atendimentoMotivoEncerramento.getId());

				// [UC0435 - Encerrar Registro de Atendimento]
				getControladorRegistroAtendimento().encerrarRegistroAtendimento(registroAtendimento, registroAtendimentoUnidade,
								usuarioBatch);

				// **************************************

			}
		}
	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Ana Maria
	 * @date 20/01/2007
	 * @param colecaoContas
	 * @param dataVencimento
	 * @throws ControladorException
	 */
	public void alterarVencimentoConjuntoContaCliente(Integer codigoCliente, Integer relacaoTipo, Date dataVencimentoInformada,
					Integer anoMes, Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Integer anoMesFim, Usuario usuario,
					Collection<Conta> colecaoContasSelecionadas) throws ControladorException{

		Collection colecaoConta = new ArrayList();
		StringBuffer identificadores = new StringBuffer();

		if(colecaoContasSelecionadas != null && !colecaoContasSelecionadas.isEmpty()){

			Iterator colecaoContasManutencaoIterator = colecaoContasSelecionadas.iterator();
			while(colecaoContasManutencaoIterator.hasNext()){

				// Obtém os dados do crédito realizado
				Conta conta = (Conta) colecaoContasManutencaoIterator.next();

				conta.setUltimaAlteracao(new Date());

				/*
				 * Colocado por Raphael Rossiter em 27/12/2007 OBJ: Carregar o id do imóvel para
				 * registrar a transação
				 */
				Imovel imovel = (Imovel) conta.getImovel();
				conta.setImovel(imovel);

				identificadores.append("," + conta.getId());

				colecaoConta.add(conta);
			}
		}

		identificadores.deleteCharAt(0);

		alterarVencimentoConta(colecaoConta, null, dataVencimentoInformada, usuario);
	}

	/**
	 * Retificar Conjunto de Conta
	 * 
	 * @author Ana Maria
	 * @date 24/01/2007
	 * @throws ControladorException
	 */
	public void retificarConjuntoContaCliente(Integer codigoCliente, Integer relacaoTipo, Integer anoMes,
					ContaMotivoRetificacao contaMotivoRetificacao, Collection debitosTipoRetirar, Usuario usuarioLogado,
					Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Integer anoMesFim,
					Collection<Conta> colecaoContasSelecionadas) throws ControladorException{

		if(colecaoContasSelecionadas != null && !colecaoContasSelecionadas.isEmpty()){

			Iterator colecaoContasManutencaoIterator = colecaoContasSelecionadas.iterator();

			while(colecaoContasManutencaoIterator.hasNext()){

				// Obtém os dados do crédito realizado
				Conta conta = (Conta) colecaoContasManutencaoIterator.next();

				conta.setUltimaAlteracao(new Date());

				Imovel imovel = (Imovel) conta.getImovel();

				Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasContaCategoria(conta);

				Collection colecaoCreditoRealizado = obterCreditosRealizadosConta(conta);

				Collection colecaoDebitoCobrado = obterDebitosCobradosConta(conta);

				String consumoAgua = null;
				if(conta.getConsumoAgua() != null){

					consumoAgua = conta.getConsumoAgua().toString();
				}

				String consumoEsgoto = null;
				if(conta.getConsumoEsgoto() != null){

					consumoEsgoto = conta.getConsumoEsgoto().toString();
				}

				Collection<CalcularValoresAguaEsgotoHelper> valoresConta = calcularValoresConta(Util.formatarAnoMesParaMesAno(conta
								.getReferencia()), imovel.getId().toString(), conta.getLigacaoAguaSituacao().getId(), conta
								.getLigacaoEsgotoSituacao().getId(), colecaoCategoria, consumoAgua, consumoEsgoto, conta
								.getPercentualEsgoto().toString(), conta.getConsumoTarifa().getId(), usuarioLogado, null, null);

				boolean achouDebitoRetirar = false;
				if(colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()){
					Iterator colecaoDebitoCobradoIterator = colecaoDebitoCobrado.iterator();
					while(colecaoDebitoCobradoIterator.hasNext()){
						DebitoCobrado debitoCobrado = (DebitoCobrado) colecaoDebitoCobradoIterator.next();
						DebitoTipo debitoTipo = debitoCobrado.getDebitoTipo();
						if(debitosTipoRetirar.contains(debitoTipo.getId())){
							achouDebitoRetirar = true;
							colecaoDebitoCobradoIterator.remove();
						}
					}
					if(achouDebitoRetirar){

						retificarConta(Integer.valueOf(conta.getReferencia()), conta, imovel, colecaoDebitoCobrado,
										colecaoCreditoRealizado, conta.getLigacaoAguaSituacao(), conta.getLigacaoEsgotoSituacao(),
										colecaoCategoria, consumoAgua, consumoEsgoto, conta.getPercentualEsgoto().toString(),
										conta.getDataVencimentoConta(), valoresConta, contaMotivoRetificacao, null, usuarioLogado, null,
										conta.getConsumoTarifa(), null);
					}

				}
			}
		}
	}

	/**
	 * Pesquisar conjunto de contas p/ emissão da 2°Via
	 * 
	 * @author Ana Maria
	 * @date 19/04/2007
	 * @param colecaoImovel
	 * @param anoMes
	 * @throws ControladorException
	 */
	public Collection pesquisarConjuntoContaClienteEmitir2Via(Integer codigoCliente, Integer relacaoTipo, Integer anoMes,
					Date dataVencimentoContaInicio, Date dataVencimentoContaFim, Integer anoMesFim) throws ControladorException{

		Collection colecaoContasEmissao = new ArrayList();
		Collection colecaoContasManutencao = new ArrayList();

		try{
			colecaoContasManutencao = repositorioFaturamento.pesquisarIdContasCliente(codigoCliente, relacaoTipo, anoMes,
							dataVencimentoContaInicio, dataVencimentoContaFim, anoMesFim);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		if(colecaoContasManutencao != null && !colecaoContasManutencao.isEmpty()){
			colecaoContasEmissao.addAll(colecaoContasManutencao);
		}

		return colecaoContasEmissao;
	}

	/**
	 * Recupera id de conta(s) sem revisão ou em revisão por ação do usuário
	 * 
	 * @author Vivianne Sousa
	 * @date 14/05/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasNaoEmRevisaoOuEmRevisaoPorAcaoUsuario(Collection idsConta) throws ControladorException{

		Collection retorno = null;
		try{
			retorno = repositorioFaturamento.obterContasNaoEmRevisaoOuEmRevisaoPorAcaoUsuario(idsConta);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Recupera id de contas que estão em revisão por acão do usuario
	 * 
	 * @author Vivianne Sousa
	 * @date 14/05/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasEmRevisaoPorAcaoUsuario(Collection idsConta) throws ControladorException{

		Collection retorno = null;
		try{
			retorno = repositorioFaturamento.obterContasEmRevisaoPorAcaoUsuario(idsConta);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Permite inserir um Tipo de Credito
	 * [UC0217] Inserir Tipo Credito
	 * 
	 * @author Thiago Tenório
	 * @date 30/03/2006
	 */
	public Integer inserirTipoCredito(CreditoTipo creditoTipo, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_TIPO_CREDITO_INSERIR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_TIPO_CREDITO_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		creditoTipo.setOperacaoEfetuada(operacaoEfetuada);
		creditoTipo.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(creditoTipo);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Integer id = (Integer) getControladorUtil().inserir(creditoTipo);

		return id;

	}

	/**
	 * [UC0513] Manter Tipo de Crédito
	 * Remover Tipo de Crédito
	 * 
	 * @author Thiago Tenório
	 * @date 19/03/2007
	 * @param
	 * @throws ControladorException
	 */
	public void removerTipoCredito(String[] ids, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_TIPO_CREDITO_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		this.getControladorUtil().remover(ids, CreditoTipo.class.getName(), null, null);
	}

	/**
	 * [UC0298] Manter Tipo de Credito[] Atualizar Tipo de Credito Metodo que atualiza a Situação
	 * Usuario
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * @param Tipo
	 *            de Credito
	 * @throws ControladorException
	 */

	public void atualizarTipoCredito(CreditoTipo creditoTipo, Usuario usuarioLogado) throws ControladorException{

		// Verifica se todos os campos obrigatorios foram preenchidos

		if((creditoTipo.getDescricao() == null || creditoTipo.getDescricao().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (creditoTipo.getDescricaoAbreviada() == null || creditoTipo.getDescricaoAbreviada().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (creditoTipo.getIndicadorGeracaoAutomatica() == 0)
						&& (creditoTipo.getIndicadorUso() == null || creditoTipo.getIndicadorUso().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (creditoTipo.getValorLimite() == null || creditoTipo.getValorLimite().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (creditoTipo.getLancamentoItemContabil() == null || creditoTipo.getLancamentoItemContabil().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Descrição foi preenchido

		if(creditoTipo.getDescricao() == null || creditoTipo.getDescricao().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Descrição do Tipo de Crédito");
		}

		// Verifica se o campo Descrição foi preenchido

		if(creditoTipo.getDescricaoAbreviada() == null
						|| creditoTipo.getDescricaoAbreviada().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Descrição do Tipo de Crédito Abreviada");
		}

		// Verifica se o campo Tipo do Lançamento do Item Contábil foi
		// preenchido

		if(creditoTipo.getLancamentoItemContabil() == null
						|| creditoTipo.getLancamentoItemContabil().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Tipo do Lançamento do Item Contábil");
		}

		// Verifica se o campo Referência do Tipo de Serviço foi preenchido
		if(creditoTipo.getValorLimite() == null || creditoTipo.getValorLimite().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Valor Limite do Crédito");
		}

		// Verifica se o campo ndicador de Geração Automática do Crédito foi
		// preenchido
		if(creditoTipo.getIndicadorGeracaoAutomatica() == null
						|| creditoTipo.getIndicadorGeracaoAutomatica().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Indicador de Geração Automática do Crédito");
		}

		// Verifica se o campo Indicador de Uso foi preenchido
		if(creditoTipo.getIndicadorUso() == null || creditoTipo.getIndicadorUso().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Indicador de Uso");
		}

		FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
		filtroCreditoTipo.adicionarParametro(new ParametroSimples(FiltroCreditoTipo.ID, creditoTipo.getId()));

		Collection colecaoCreditoTipoBase = getControladorUtil().pesquisar(filtroCreditoTipo, CreditoTipo.class.getName());

		if(colecaoCreditoTipoBase == null || colecaoCreditoTipoBase.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		CreditoTipo creditoTipoBase = (CreditoTipo) colecaoCreditoTipoBase.iterator().next();

		if(creditoTipo.getUltimaAlteracao().after(creditoTipoBase.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_TIPO_CREDITO_ATUALIZAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_TIPO_CREDITO_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		creditoTipo.setOperacaoEfetuada(operacaoEfetuada);
		creditoTipo.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(creditoTipo);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		creditoTipo.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(creditoTipo);

	}

	/**
	 * Permite informar uma nao entrega de documentos
	 * [UC0559] Informar Nao Entrega de Documentos
	 * 
	 * @author Thiago Tenório
	 * @date 04/04/2007
	 * @author eduardo henrique
	 * @date 11/07/2008 Inclusão das validações contidas no UC para o Tipo de Documento CONTA
	 * @param anoMesDocumento
	 */
	public Integer informarNaoEntregaDocumentos(Collection colecaoDocumentosNaoEntregues, Usuario usuarioLogado, String anoMesDocumento)
					throws ControladorException{

		// Executa as validações para cada Documento Não-Entregue
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		Map colecaoMatriculas = new HashMap();

		for(Iterator iterator = colecaoDocumentosNaoEntregues.iterator(); iterator.hasNext();){
			DocumentoNaoEntregue documento = (DocumentoNaoEntregue) iterator.next();

			// if
			// (Util.compararAnoMesReferencia(Util.formataAnoMes(documento.getDataTentativaEntrega()),
			// Integer.valueOf(anoMesDocumento), "<")) {
			// throw new ControladorException("atencao.data_documento_data_entrega");
			// }

			// [FS0004]
			if(documento.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)){

				// Data de Emissão da Conta, deve ser anterior ou igual à
				// devolução e ao Período de Faturamento do Sistema
				// Verifica se a Conta existe no período informado

				FiltroConta filtroConta = new FiltroConta();
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, anoMesDocumento));
				filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, documento.getContaGeral().getConta().getImovel()
								.getId()));

				Collection colecaoContaPeriodo = getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

				if(colecaoContaPeriodo == null || colecaoContaPeriodo.isEmpty()){
					throw new ControladorException("atencao.matricula_imovel_nao_encontrada", null, documento.getContaGeral().getConta()
									.getImovel().getId().toString());
				}
				Conta conta = (Conta) colecaoContaPeriodo.iterator().next();

				if(Util.isNaoNuloBrancoZero(conta.getDataEmissao())){
					if(Util.compararData(documento.getDataTentativaEntrega(), conta.getDataEmissao()) < 0){
						throw new ControladorException("atencao.data_emissao_conta_superior_data_devolucao", null, Util.formatarData(conta
										.getDataEmissao()));
					}
				}else{
					throw new ControladorException("atencao.data_emissao_conta_nula", null, conta.getId().toString());
				}

				if(Util.compararAnoMesReferencia(sistemaParametro.getAnoMesFaturamento(), Util.formataAnoMes(conta.getDataEmissao()), "<")){
					throw new ControladorException("atencao.data_emissao_conta_superior_data_faturamento", null,
									Util.formatarAnoMes(sistemaParametro.getAnoMesFaturamento().toString()));
				}

				// Matrícula não pode estar repetida (informação de Devolução
				// Anterior) - verifica no Banco e na Coleção Atual
				if(colecaoMatriculas.containsKey(conta.getId())){
					throw new ControladorException("atencao.conta_nao_entrega_duplicada", null, conta.getImovel().getId().toString());
				}
				colecaoMatriculas.put(conta.getId(), null);

				FiltroDocumentoNaoEntregue filtroDocumento = new FiltroDocumentoNaoEntregue();
				filtroDocumento.adicionarParametro(new ParametroSimples(FiltroDocumentoNaoEntregue.CONTA_ID, conta.getId()));

				Collection colecaoDocumento = getControladorUtil().pesquisar(filtroDocumento, DocumentoNaoEntregue.class.getName());
				if(colecaoDocumento != null && !colecaoDocumento.isEmpty()){
					throw new ControladorException("atencao.conta_nao_entrega_ja_informada", null, conta.getImovel().getId().toString());
				}

				// Motivo da Entrega informado
				FiltroMotivoNaoEntregaDocumento filtroMotivo = new FiltroMotivoNaoEntregaDocumento();
				filtroMotivo.adicionarParametro(new ParametroSimples(FiltroMotivoNaoEntregaDocumento.ID, documento
								.getMotivoNaoEntregaDocumento().getId()));

				Collection colecaoMotivo = getControladorUtil().pesquisar(filtroMotivo, MotivoNaoEntregaDocumento.class.getName());
				if(colecaoMotivo == null || colecaoMotivo.isEmpty()){
					throw new ControladorException("atencao.motivo_nao_entrega_inexistente", null, documento.getMotivoNaoEntregaDocumento()
									.getId().toString());
				}

				MotivoNaoEntregaDocumento motivoNaoEntregaDocumento = (MotivoNaoEntregaDocumento) Util
								.retonarObjetoDeColecao(colecaoMotivo);

				documento.getContaGeral().setId(conta.getId());

				// Atualizando o motivo da não entrega
				conta.setMotivoNaoEntregaDocumento(motivoNaoEntregaDocumento);
				this.getControladorUtil().atualizar(conta);
			}

		}

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_NAO_ENTREGA_DOCUMENTOS_INFORMAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_NAO_ENTREGA_DOCUMENTOS_INFORMAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		DocumentoNaoEntregue documentoNaoEntregue = new DocumentoNaoEntregue();

		documentoNaoEntregue.setOperacaoEfetuada(operacaoEfetuada);
		documentoNaoEntregue.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(documentoNaoEntregue);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Iterator iterator = colecaoDocumentosNaoEntregues.iterator();
		Integer id = null;
		while(iterator.hasNext()){
			id = (Integer) getControladorUtil().inserir((DocumentoNaoEntregue) iterator.next());

		}

		return id;

	}

	/**
	 * Este caso de uso permite gerar um relatório analítico do faturamento
	 * [UC0593]Gerar Relatório Analítico do Faturamento
	 * 
	 * @author Flávio Cordeiro
	 * @date 18/05/2007
	 * @author Saulo Lima
	 * @date 07/02/2009 Colocados os Generics nas coleções.
	 * @author Virgínia Melo
	 * @date 26/03/2009 Adicionado parâmetro 'valorMinimo'.
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @param indicadorLocalidadeInformatizada
	 * @param colecaoLocalidades
	 * @param colecaoSetores
	 * @param colecaoQuadras
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosRelatorioAnaliticoFaturamento(int anoMesFaturamento, Integer idFaturamentoGrupo,
					int indicadorLocalidadeInformatizada, Collection<Localidade> colecaoLocalidades,
					Collection<SetorComercial> colecaoSetores, Collection<Quadra> colecaoQuadras, String tipoRelatorio,
					Usuario usuarioLogado, BigDecimal valorMinimo) throws ControladorException{

		Collection retorno = new ArrayList();

		try{

			Collection<Object[]> colecaoObjeto = repositorioFaturamento.pesquisarDadosRelatorioAnaliticoFaturamento(anoMesFaturamento,
							idFaturamentoGrupo, indicadorLocalidadeInformatizada, colecaoLocalidades, colecaoSetores, colecaoQuadras,
							valorMinimo);

			if(colecaoObjeto != null && !colecaoObjeto.isEmpty()){

				Iterator iterator = colecaoObjeto.iterator();

				while(iterator.hasNext()){

					RelatorioAnaliticoFaturamentoHelper relatorioAnaliticoFaturamentoHelper = new RelatorioAnaliticoFaturamentoHelper();
					Object[] objeto = (Object[]) iterator.next();

					// idImovel
					if(objeto[0] != null){
						relatorioAnaliticoFaturamentoHelper.setIdImovel((Integer) objeto[0]);
						relatorioAnaliticoFaturamentoHelper.setInscricao(getControladorImovel().pesquisarInscricaoImovel(
										relatorioAnaliticoFaturamentoHelper.getIdImovel(), true));
					}
					// consumoAgua
					if(objeto[1] != null){
						relatorioAnaliticoFaturamentoHelper.setConsumoAgua((Integer) objeto[1]);
					}
					// consumoRateioAgua
					if(objeto[2] != null){
						relatorioAnaliticoFaturamentoHelper.setConsumoRateioAgua((Integer) objeto[2]);
					}
					// valorAgua
					if(objeto[3] != null){
						relatorioAnaliticoFaturamentoHelper.setValorAgua((BigDecimal) objeto[3]);
					}
					// consumoEsgoto
					if(objeto[4] != null){
						relatorioAnaliticoFaturamentoHelper.setConsumoEsgoto((Integer) objeto[4]);
					}
					// consumoRateioEsgoto
					if(objeto[5] != null){
						relatorioAnaliticoFaturamentoHelper.setConsumoRateioEsgoto((Integer) objeto[5]);
					}
					// valorEsgoto
					if(objeto[6] != null){
						relatorioAnaliticoFaturamentoHelper.setValorEsgoto((BigDecimal) objeto[6]);
					}
					// debitos
					if(objeto[7] != null){
						relatorioAnaliticoFaturamentoHelper.setDebitos((BigDecimal) objeto[7]);
					}
					// creditos
					if(objeto[8] != null){
						relatorioAnaliticoFaturamentoHelper.setValorCreditos((BigDecimal) objeto[8]);
					}
					// imposto
					if(objeto[9] != null){
						relatorioAnaliticoFaturamentoHelper.setValorImposto((BigDecimal) objeto[9]);
					}
					// codigoSetor
					if(objeto[10] != null){
						relatorioAnaliticoFaturamentoHelper.setCodigoSetorComercial((Integer) objeto[10]);

					}
					// idLocalidade
					if(objeto[11] != null){
						relatorioAnaliticoFaturamentoHelper.setIdLocalidade((Integer) objeto[11]);
					}
					// DigitoVerificador
					if(objeto[12] != null){
						relatorioAnaliticoFaturamentoHelper.setDigitoVerificador((Short) objeto[12]);
					}
					// descricaoLocalidade
					if(objeto[13] != null){
						relatorioAnaliticoFaturamentoHelper.setDescricaoLocalidade((String) objeto[13]);
					}

					relatorioAnaliticoFaturamentoHelper.setMesAnoFaturamento(Util.formatarAnoMesParaMesAnoSemBarra(anoMesFaturamento));
					retorno.add(relatorioAnaliticoFaturamentoHelper);

				}

				// parte nova para o relatório ter o processamento em batch
				// cria uma instância da classe do relatório

			}
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Vivianne Sousa
	 * @date 18/05/2007
	 *       Adicionados campos de qualidade água
	 * @author Virgínia Melo
	 * @date 06/01/2009
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public Collection<EmitirContaHelper> emitir2ViaContasHistorico(Collection idsContaEP, boolean cobrarTaxaEmissaoConta,
					Short contaSemCodigoBarras) throws ControladorException{

		Collection<EmitirContaHelper> colecaoEmitirContaHelper = new ArrayList();

		Iterator iter = idsContaEP.iterator();

		while(iter.hasNext()){
			Integer idContaEP = (Integer) iter.next();

			Collection colectionConta;
			try{
				colectionConta = this.repositorioFaturamento.pesquisarContaHistorico(idContaEP);
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			EmitirContaHelper emitirContaHelper = (EmitirContaHelper) colectionConta.iterator().next();

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// Linha 5
			// --------------------------------------------------------------
			// recupera endereco do imóvel
			String enderecoImovel = "";
			try{
				enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(emitirContaHelper.getIdImovel());
			}catch(ControladorException e1){
				e1.printStackTrace();
			}
			emitirContaHelper.setEnderecoImovel(enderecoImovel);

			String tipoDocCliente = "";
			String cpfCnpj = "";

			if(emitirContaHelper.getTipoDocCliente() != null && emitirContaHelper.getTipoDocCliente().equals("CPF")){
				tipoDocCliente = emitirContaHelper.getTipoDocCliente();
				cpfCnpj = Util.formatarCpf(emitirContaHelper.getCpfCnpjCliente());

			}else if(emitirContaHelper.getTipoDocCliente() != null && emitirContaHelper.getTipoDocCliente().equals("CNPJ")){

				tipoDocCliente = emitirContaHelper.getTipoDocCliente();
				cpfCnpj = Util.formatarCnpj(emitirContaHelper.getCpfCnpjCliente());
			}

			emitirContaHelper.setTipoDocCliente(tipoDocCliente);
			emitirContaHelper.setCpfCnpjCliente(cpfCnpj);

			// Linha 6
			// --------------------------------------------------------------
			// instância um imovel com os dados da conta para recuperar a
			// inscrição que está no objeto imovel
			Imovel imovel = new Imovel();
			Localidade localidade = new Localidade();
			localidade.setId(emitirContaHelper.getIdLocalidade());
			imovel.setLocalidade(localidade);
			SetorComercial setorComercial = new SetorComercial();
			setorComercial.setCodigo(emitirContaHelper.getCodigoSetorComercialConta());
			imovel.setSetorComercial(setorComercial);
			Quadra quadra = new Quadra();
			quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
			imovel.setQuadra(quadra);
			imovel.setLote(emitirContaHelper.getLoteConta());

			if(emitirContaHelper.getSubLoteConta() != null){

				imovel.setSubLote(emitirContaHelper.getSubLoteConta());
			}

			// Inscrição do imóvel
			emitirContaHelper.setInscricaoImovel(imovel.getInscricaoFormatada());

			// Linha 7
			// --------------------------------------------------------------
			// Alterado por: Yara Souza
			// Data: 13/05/2010
			// ----------------------------------------------------------------
			String enderecoEntrega = "";
			// Endereço de entrega
			Integer idImovelContaEnvio = emitirContaHelper.getIdImovelContaEnvio();
			if(idImovelContaEnvio != null){
				// Obter Endereço
				imovel.setId(emitirContaHelper.getIdImovel());
				Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
				enderecoEntrega = (String) arrayDadosEndereco[0];
			}
			emitirContaHelper.setEnderecoClienteEntrega(enderecoEntrega);

			// Linha 8
			// --------------------------------------------------------------

			// [SB0002] - Determinar tipo de ligação e tipo de Medição
			Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
			Integer tipoLigacao = parmSituacao[0];
			Integer tipoMedicao = parmSituacao[1];

			// Linha 9
			// --------------------------------------------------------------
			// cria uma stringBuilder para recuperar o resultado do [SB0003]
			// o tamanho da string que vem como resultado é de 20 posições
			StringBuilder obterDadosConsumoMedicaoAnterior = null;

			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 1
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 1, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes1(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 4
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 4, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes4(obterDadosConsumoMedicaoAnterior.toString());

			// Linha 10
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 2
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 2, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes2(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 5
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 5, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes5(obterDadosConsumoMedicaoAnterior.toString());
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros da medição historico do
			// [SB0004] - Obter Dados da Medição da Conta
			Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(emitirContaHelper, tipoMedicao);
			// Leitura Anterior
			String leituraAnterior = "";
			// Leitura Atual
			String leituraAtual = "";
			// Data Leitura Anterior
			String dataLeituraAnterior = "";
			// Leitura Anterior
			String dataLeituraAtual = "";
			// Leitura Situação Atual
			// String leituraSituacaoAtual = "";
			// Leitura Anormalidade Faturamento
			String leituraAnormalidadeFaturamento = "";

			String consumoMedido = "";

			if(parmsMedicaoHistorico != null){

				if(parmsMedicaoHistorico[0] != null){
					leituraAnterior = "" + (Integer) parmsMedicaoHistorico[0];
				}

				if(parmsMedicaoHistorico[1] != null){
					leituraAtual = "" + (Integer) parmsMedicaoHistorico[1];
				}

				if(parmsMedicaoHistorico[3] != null){
					dataLeituraAnterior = Util.formatarData((Date) parmsMedicaoHistorico[3]);
				}

				if(parmsMedicaoHistorico[2] != null){
					dataLeituraAtual = Util.formatarData((Date) parmsMedicaoHistorico[2]);
				}

				if(parmsMedicaoHistorico[4] != null){
					// leituraSituacaoAtual = ""
					// + (Integer) parmsMedicaoHistorico[4];
				}

				if(parmsMedicaoHistorico[5] != null){
					leituraAnormalidadeFaturamento = "" + (Integer) parmsMedicaoHistorico[5];
				}

				if(parmsMedicaoHistorico[6] != null){
					consumoMedido = "" + (Integer) parmsMedicaoHistorico[6];
				}
			}
			emitirContaHelper.setDataLeituraAnterior(dataLeituraAnterior);
			emitirContaHelper.setDataLeituraAtual(dataLeituraAtual);
			emitirContaHelper.setConsumoMedido(consumoMedido);

			String diasConsumo = "";
			if(!dataLeituraAnterior.equals("") && !dataLeituraAtual.equals("")){
				// calcula a quantidade de dias de consumo que é a
				// quantidade de dias
				// entre a data de leitura
				// anterior(parmsMedicaoHistorico[2]) e a data de leitura
				// atual(parmsMedicaoHistorico[3])
				diasConsumo = "" + Util.obterQuantidadeDiasEntreDuasDatas((Date) parmsMedicaoHistorico[3], (Date) parmsMedicaoHistorico[2]);
			}
			// recupera os parametros de consumo faturamento e consumo médio
			// diário
			// [SB0005] - Obter Consumo Faturado e Consumo Médio Diário
			String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(emitirContaHelper, tipoMedicao, diasConsumo);
			String consumoFaturamento = parmsConsumo[0];
			emitirContaHelper.setConsumoFaturamento(consumoFaturamento);

			String consumoMedioDiario = parmsConsumo[1];
			emitirContaHelper.setConsumoMedioDiario(consumoMedioDiario);
			// Fim Chamar Sub-Fluxo
			// Leitura Anterior
			leituraAnterior = Util.completaString(leituraAnterior, 7);
			emitirContaHelper.setLeituraAnterior(leituraAnterior);
			// Leitura Atual
			leituraAtual = Util.completaString(leituraAtual, 7);
			emitirContaHelper.setLeituraAtual(leituraAtual);
			// Dias de consumo
			diasConsumo = Util.completaString(diasConsumo, 2);
			emitirContaHelper.setDiasConsumo(diasConsumo);

			// Linha 11
			// --------------------------------------------------------------
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 3
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 3, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes3(obterDadosConsumoMedicaoAnterior.toString());
			// chama o [SB0003] -Obter Dados do Consumo e Medição Anterior
			// passando a quantidade de Meses Igual a 6
			// e o tipo de ligação e medição recuperados anteriormente
			obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
							emitirContaHelper.getAmReferencia(), 6, tipoLigacao, tipoMedicao);
			emitirContaHelper.setDadosConsumoMes6(obterDadosConsumoMedicaoAnterior.toString());

			// Linha 12
			// --------------------------------------------------------------
			// Inicio Chamar Sub-Fluxo
			// recupera os parametros do consumo historico da conta
			// [SB0006] - Obter Dados de Consumo da Conta
			Object[] parmsConsumoHistorico = null;
			String descricaoAbreviadaTipoConsumo = "";
			String descricaoTipoConsumo = "";
			String consumoMedio = "";
			String descricaoAbreviadaAnormalidadeConsumo = "";
			String descricaoAnormalidadeConsumo = "";
			String consumoRateio = "";
			// caso o tipo de ligacao for diferente de nulo
			if(tipoLigacao != null){
				try{
					parmsConsumoHistorico = getControladorMicromedicao().obterDadosConsumoConta(emitirContaHelper.getIdImovel(),
									emitirContaHelper.getAmReferencia(), tipoLigacao);
				}catch(ControladorException e){
					e.printStackTrace();
				}

				if(parmsConsumoHistorico != null){
					// descrição abreviada tipo de consumo
					if(parmsConsumoHistorico[0] != null){
						descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
					}
					// descrição tipo de consumo
					if(parmsConsumoHistorico[1] != null){
						descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
					}
					// Consumo médio
					if(parmsConsumoHistorico[2] != null){
						consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
					}
					// descrição abreviada anormalidade de consumo
					if(parmsConsumoHistorico[3] != null){
						descricaoAbreviadaAnormalidadeConsumo = (String) parmsConsumoHistorico[3];
					}
					// descrição anormalidade de consumo
					if(parmsConsumoHistorico[4] != null){
						descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
					}
					// Consumo médio
					if(parmsConsumoHistorico[5] != null){
						consumoRateio = "" + (Integer) parmsConsumoHistorico[5];
					}
				}
			}

			emitirContaHelper.setDescricaoTipoConsumo(descricaoTipoConsumo);
			emitirContaHelper.setDescricaoAnormalidadeConsumo(descricaoAnormalidadeConsumo);

			// Fim Chamar Sub-Fluxo

			// Linha 13
			// --------------------------------------------------------------

			// Inicio Chamar Sub-Fluxo
			// soma a quantidades de economias da tabela contaCategoria
			// [SB0007] - Obter Dados da Medição da Conta
			Short quantidadeEconomiaConta = 0;
			quantidadeEconomiaConta = obterQuantidadeEconomiasConta(emitirContaHelper.getIdConta(), true);
			emitirContaHelper.setQuantidadeEconomiaConta("" + quantidadeEconomiaConta);
			// Fim Chamar Sub-Fluxo

			// Consumo por Economia
			// transforma o consumoFaturamento para um bigDecimal
			BigDecimal consumoFaturadoBigDecimal = null;
			if(consumoFaturamento != null && !consumoFaturamento.equals("")){
				consumoFaturadoBigDecimal = Util.formatarMoedaRealparaBigDecimal(consumoFaturamento);

			}
			// transforma a quantidade de economias da conta para um
			// bigDecimal
			BigDecimal qtdEconomiasBigDecimal = null;
			if(quantidadeEconomiaConta != null && !quantidadeEconomiaConta.equals("")){
				qtdEconomiasBigDecimal = Util.formatarMoedaRealparaBigDecimal("" + quantidadeEconomiaConta);
			}
			String consumoEconomia = "";
			if(consumoFaturadoBigDecimal != null && qtdEconomiasBigDecimal != null){
				BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal.divide(qtdEconomiasBigDecimal, 2, RoundingMode.UP);
				consumoEconomia = Util.formatarMoedaReal(consumoEconomiaBigDecimal);
				emitirContaHelper.setConsumoEconomia(consumoEconomia.substring(0, (consumoEconomia.length() - 3)));
			}

			// Inicio Chamar Sub-Fluxo
			// concatena os campos dos sub-fluxos anteriores
			// [SB0008] - Obter Dados da Medição da Conta
			StringBuilder codigoAuxiliar = new StringBuilder();
			// leitura situação atual
			// tipo de consumo
			codigoAuxiliar.append(Util.completaString(descricaoAbreviadaTipoConsumo, 1));
			// tipo de contrato
			codigoAuxiliar.append(Util.completaString("", 1));
			// anormalidade de leitura
			codigoAuxiliar.append(Util.completaString(leituraAnormalidadeFaturamento, 2));
			// anormalidade de consumo
			codigoAuxiliar.append(Util.completaString(descricaoAbreviadaAnormalidadeConsumo, 2));

			// perfil do imóvel
			if(emitirContaHelper.getIdImovelPerfil() != null){
				codigoAuxiliar.append(Util.completaString("" + emitirContaHelper.getIdImovelPerfil(), 1));
			}else{
				codigoAuxiliar.append(Util.completaString("", 1));
			}
			// dias do consumo
			codigoAuxiliar.append(Util.completaString(diasConsumo, 2));
			// Consumo medio do imóvel
			codigoAuxiliar.append(Util.completaString(consumoMedio, 6));
			// Fim Chamar Sub-Fluxo
			emitirContaHelper.setCodigoAuxiliarString(codigoAuxiliar.toString());

			// chama o [SB0009] - Obter Mensagem de Rateio de Consumo Fixo de
			// Esgoto
			StringBuilder mesagemConsumo = obterMensagemRateioConsumo(emitirContaHelper, consumoRateio, parmsMedicaoHistorico, tipoMedicao);
			// mensagem de rateio de consumo ou consumo fixo de esgoto
			emitirContaHelper.setMensagemConsumoString(mesagemConsumo.toString());

			// Linha 16
			// --------------------------------------------------------------
			// chama o [SB0010] - Gerar Linhas da Descrição dos Serviços e
			// Tarifas

			Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = gerarLinhasDescricaoServicoTarifasRelatorio(
							emitirContaHelper, consumoRateio, parmsMedicaoHistorico, tipoMedicao, true, null, null, false);
			emitirContaHelper
							.setColecaoContaLinhasDescricaoServicosTarifasTotalHelper(colecaoContaLinhasDescricaoServicosTarifasTotalHelper);

			// Linha 17
			// --------------------------------------------------------------
			// cria um objeto conta para calcular o valor da conta
			Conta conta = new Conta();
			conta.setValorAgua(emitirContaHelper.getValorAgua());
			conta.setValorEsgoto(emitirContaHelper.getValorEsgoto());
			conta.setValorCreditos(emitirContaHelper.getValorCreditos());
			conta.setDebitos(emitirContaHelper.getDebitos());
			conta.setValorImposto(emitirContaHelper.getValorImpostos());
			BigDecimal valorConta = conta.getValorTotalContaBigDecimal();

			emitirContaHelper.setValorContaString(Util.formatarMoedaReal(valorConta));

			// if (contaSemCodigoBarras.equals(ConstantesSistema.SIM)||
			// valorConta.compareTo(new BigDecimal("0.00")) == 0) {
			emitirContaHelper.setContaSemCodigoBarras("1");
			// } else {
			// emitirContaHelper.setContaSemCodigoBarras("2");
			// }

			// chama o [SB0016] - Obter Mensagem da Conta em 3 Partes
			String[] parmsPartesConta = obterMensagemConta3Partes(emitirContaHelper, sistemaParametro);

			// Linha 18
			// --------------------------------------------------------------
			emitirContaHelper.setPrimeiraParte(parmsPartesConta[0]);

			// Linha 19
			// --------------------------------------------------------------
			emitirContaHelper.setSegundaParte(parmsPartesConta[1]);

			// Linha 20
			// --------------------------------------------------------------
			emitirContaHelper.setTerceiraParte(parmsPartesConta[2]);

			// Linha 21
			// --------------------------------------------------------------
			// int anoMesReferenciaSubtraido =
			// Util.subtrairMesDoAnoMes(emitirContaHelper.getAmReferencia(), 1);
			// emitirContaHelper.setMesAnoFormatado(Util.formatarAnoMesParaMesAno(anoMesReferenciaSubtraido));

			// Alterado no dia 05/01/2009 vsm - não pegar mais o mês anterior (solicitado por
			// Luciene)
			emitirContaHelper.setMesAnoFormatado(Util.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia()));

			// Linha 22
			// --------------------------------------------------------------
			/*
			 * Object[] parmsQualidadeAgua = null; parmsQualidadeAgua =
			 * pesquisarParmsQualidadeAgua(emitirContaHelper);
			 * // numero indice turbidez da qualidade agua String numeroIndiceTurbidez = ""; //
			 * numero cloro residual da qualidade agua String
			 * numeroCloroResidual = ""; if (parmsQualidadeAgua != null) { if (parmsQualidadeAgua[0]
			 * != null) { numeroIndiceTurbidez =
			 * Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]); }
			 * if (parmsQualidadeAgua[1] != null) { numeroCloroResidual =
			 * Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]); } }
			 * emitirContaHelper.setNumeroIndiceTurbidez(numeroIndiceTurbidez);
			 * emitirContaHelper.setNumeroCloroResidual(numeroCloroResidual);
			 */

			// Linha 22
			Object[] parmsQualidadeAgua = null;
			parmsQualidadeAgua = pesquisarParmsQualidadeAgua(emitirContaHelper);

			String numeroAmostrasMediaTurbidez = "";
			String numeroAmostrasMediaCloro = "";
			String numeroAmostrasMediaCor = "";
			String numeroAmostrasMediaPH = "";
			String numeroAmostrasMediaBacteriasHeterotroficas = "";
			String numeroAmostrasMediaColiformesTermotolerantes = "";
			String numeroAmostrasMediaColiformesTotais = "";

			if(parmsQualidadeAgua != null){

				if(parmsQualidadeAgua[0] != null){
					numeroAmostrasMediaTurbidez = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]);
				}

				if(parmsQualidadeAgua[1] != null){
					numeroAmostrasMediaCloro = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]);
				}

				if(parmsQualidadeAgua[2] != null){
					numeroAmostrasMediaCor = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[2]);
				}

				if(parmsQualidadeAgua[3] != null){
					numeroAmostrasMediaPH = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[3]);
				}

				if(parmsQualidadeAgua[4] != null){
					numeroAmostrasMediaBacteriasHeterotroficas = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[4]);
				}

				if(parmsQualidadeAgua[5] != null){
					numeroAmostrasMediaColiformesTermotolerantes = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[5]);
				}

				if(parmsQualidadeAgua[6] != null){
					numeroAmostrasMediaColiformesTotais = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[6]);
				}
			}

			emitirContaHelper.setNumeroAmostrasMediaTurbidez(numeroAmostrasMediaTurbidez);
			emitirContaHelper.setNumeroAmostrasMediaCloro(numeroAmostrasMediaCloro);
			emitirContaHelper.setNumeroAmostrasMediaCor(numeroAmostrasMediaCor);
			emitirContaHelper.setNumeroAmostrasMediaPH(numeroAmostrasMediaPH);
			emitirContaHelper.setNumeroAmostrasMediaBacteriasHeterotroficas(numeroAmostrasMediaBacteriasHeterotroficas);
			emitirContaHelper.setNumeroAmostrasMediaColiformesTermotolerantes(numeroAmostrasMediaColiformesTermotolerantes);
			emitirContaHelper.setNumeroAmostrasMediaColiformesTotais(numeroAmostrasMediaColiformesTotais);

			// Linha28
			if(emitirContaHelper.getDataValidadeConta() != null && emitirContaHelper.getDataValidadeConta().compareTo(new Date()) == 1){

				emitirContaHelper.setDataValidade(Util.formatarData(emitirContaHelper.getDataValidadeConta()));

			}else{
				// soma 60 dias a data atual
				Date dataValidadeConta = Util.adicionarNumeroDiasDeUmaData(new Date(), 60);

				int ano = Util.getAno(dataValidadeConta);
				int mes = Util.getMes(dataValidadeConta);
				Calendar calendar = new GregorianCalendar();
				calendar.set(Calendar.MONTH, mes - 1);
				calendar.set(Calendar.YEAR, ano);

				Collection colecaoNacionalFeriado = getControladorUtil().pesquisarFeriadosNacionais();

				Collection colecaoDatasFeriados = new ArrayList();
				Iterator iterNacionalFeriado = colecaoNacionalFeriado.iterator();
				while(iterNacionalFeriado.hasNext()){
					NacionalFeriado nacionalFeriado = (NacionalFeriado) iterNacionalFeriado.next();
					colecaoDatasFeriados.add(nacionalFeriado.getData());
				}

				calendar.set(Calendar.DAY_OF_MONTH, Util.obterUltimoDiaUtilMes(mes, ano, colecaoDatasFeriados));

				dataValidadeConta = calendar.getTime();

				emitirContaHelper.setDataValidade(Util.formatarData(dataValidadeConta));

			}

			/**
			 * [UC0482] Na emissão de 2ª via de conta, emitir a mensagem de quitação de débito anual
			 * 
			 * @author Gicevalter Couto
			 * @created 12/08/2014
			 */
			String mesBaseEmissaoQuitacaoDebitoAnual = (String) ParametroFaturamento.P_MES_BASE_EMISSAO_QUITACAO_DEBITO_ANUAL.executar();
			if(mesBaseEmissaoQuitacaoDebitoAnual != null
							&& Short.valueOf(String.valueOf(emitirContaHelper.getAmReferencia()).substring(4, 6)).equals(
											Short.valueOf(mesBaseEmissaoQuitacaoDebitoAnual))){
				Integer anoAnteriorConta = Integer.valueOf(String.valueOf(emitirContaHelper.getAmReferencia()).substring(0, 4)) - 1;

				FiltroQuitacaoDebitoAnual filtroQuitacaoDebitoAnual = new FiltroQuitacaoDebitoAnual();
				filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.IMOVEL_ID, emitirContaHelper
								.getIdImovel()));
				filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.ANO_REFERENCIA,
								anoAnteriorConta));
				Collection<QuitacaoDebitoAnual> colecaoQuitacaoDebitoAnual = this.getControladorUtil().pesquisar(filtroQuitacaoDebitoAnual,
								QuitacaoDebitoAnual.class.getName());
				if(colecaoQuitacaoDebitoAnual.size() > 0){
					emitirContaHelper.setAnoQuitacaoDebitoAnual(anoAnteriorConta);
				}
			}

			String pExibirMesagemSubstitutaCodigoBarrasContaPaga = null;

			try{

				pExibirMesagemSubstitutaCodigoBarrasContaPaga = (String) ParametroFaturamento.P_EXIBIR_MENSAGEM_SUSBTITUICAO_CODIGO_BARRAS_2_VIA
								.executar();
			}catch(ControladorException e){

				throw new ControladorException("atencao.sistemaparametro_inexistente", null,
								"P_INDICADOR_FATURAMENTO_ATUAL_TITULAR_DEBITO_IMOVEL");
			}

			if(pExibirMesagemSubstitutaCodigoBarrasContaPaga.equals(ConstantesSistema.SIM.toString())){

				FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.CONTA_ID, emitirContaHelper
								.getIdConta()));
				filtroPagamentoHistorico.setCampoOrderByDesc(FiltroPagamentoHistorico.DATA_PAGAMENTO);

				Collection<PagamentoHistorico> colecaoPagamentoHistorico = getControladorUtil().pesquisar(filtroPagamentoHistorico,
								PagamentoHistorico.class.getName());

				if(!Util.isVazioOrNulo(colecaoPagamentoHistorico)){

					PagamentoHistorico pagamentoHistoricoMaisRecente = (PagamentoHistorico) Util
									.retonarObjetoDeColecao(colecaoPagamentoHistorico);

					emitirContaHelper.setMensagemSubstitutaCodigoBarras("COMPROVANTE DE PAGAMENTO REALIZADO EM "
									+ Util.formatarData(pagamentoHistoricoMaisRecente.getDataPagamento()));
				}else{

					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.CONTA_ID, emitirContaHelper.getIdConta()));
					filtroPagamento.setCampoOrderByDesc(FiltroPagamento.DATA_PAGAMENTO);

					Collection<Pagamento> colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName());

					if(!Util.isVazioOrNulo(colecaoPagamento)){

						Pagamento pagamentoMaisRecente = (Pagamento) Util.retonarObjetoDeColecao(colecaoPagamento);

						emitirContaHelper.setMensagemSubstitutaCodigoBarras("COMPROVANTE DE PAGAMENTO REALIZADO EM "
										+ Util.formatarData(pagamentoMaisRecente.getDataPagamento()));
					}
				}
			}

			colecaoEmitirContaHelper.add(emitirContaHelper);

			if(cobrarTaxaEmissaoConta){
				this.gerarDebitoACobrar(emitirContaHelper.getIdImovel(), emitirContaHelper.getAmReferencia(), DebitoTipo.TAXA_2_VIA_CONTA,
								null);
			}

		}

		return colecaoEmitirContaHelper;
	}

	/**
	 * [UC0482] Emitir 2 Via de Contas
	 * [SB00011] Gerar Linhas da Tarifa de Água
	 * 
	 * @author Vivianne Sousa
	 * @date 21/11/2006
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected Collection gerarLinhasTarifaAguaRelatorioContaHistorico(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao, Collection colecaoLinhasDescricaoServicosTarifasTotal,
					Conta contaCaucionada,
					Collection<Collection<ContaCategoriaConsumoFaixa>> colecaoContaCategoriaConsumoFaixaCaucionamento,
					boolean indicadorOperacaoCaucionamento) throws ControladorException{

		Collection colecaoContaLinhasDescricaoServicosTarifasTotalHelper = colecaoLinhasDescricaoServicosTarifasTotal;
		ContaLinhasDescricaoServicosTarifasTotalHelper contaLinhasDescricaoServicosTarifasTotalHelper = null;

		String descricaoServicosTarifas1 = "";

		// -- Linha 1 --//
		descricaoServicosTarifas1 = "AGUA";
		contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
		contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas1);
		contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
		contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
		colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

		Collection colecaoContaCategoriaComFaixas = new ArrayList();

		if(indicadorOperacaoCaucionamento){
			Collection<ContaCategoria> colecaoContaCategoria = contaCaucionada.getContaCategorias();

			if(!Util.isVazioOuBranco(contaCaucionada) && !Util.isVazioOuBranco(colecaoContaCategoria)){
				for(ContaCategoria contaCategoria : colecaoContaCategoria){
					colecaoContaCategoriaComFaixas.add(contaCategoria);
				}
			}
		}else{
			try{
				colecaoContaCategoriaComFaixas = repositorioFaturamento.pesquisarContaCategoriaHistorico(emitirContaHelper.getIdConta());
			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
		}

		if(colecaoContaCategoriaComFaixas != null && !colecaoContaCategoriaComFaixas.isEmpty()){
			Iterator iteratorContaCategoriaComFaixas = colecaoContaCategoriaComFaixas.iterator();
			while(iteratorContaCategoriaComFaixas.hasNext()){
				ContaCategoriaHistorico contaCategoria = (ContaCategoriaHistorico) iteratorContaCategoriaComFaixas.next();

				String descricaoServicosTarifas2 = "";

				// -- Linha 2 --//
				descricaoServicosTarifas2 = " ";
				// descricao da categoria
				descricaoServicosTarifas2 = descricaoServicosTarifas2
								+ Util.completaString(contaCategoria.getComp_id().getCategoria().getDescricao(), 13);
				// quantidade de economias
				descricaoServicosTarifas2 = descricaoServicosTarifas2
								+ Util.adicionarZerosEsquedaNumero(3, "" + contaCategoria.getQuantidadeEconomia());

				if(contaCategoria.getQuantidadeEconomia() == 1){
					descricaoServicosTarifas2 = descricaoServicosTarifas2 + "  UNIDADE ";
				}else{
					descricaoServicosTarifas2 = descricaoServicosTarifas2 + "  UNIDADES ";
				}

				contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
				contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas2);
				contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa("");
				contaLinhasDescricaoServicosTarifasTotalHelper.setValor("");
				colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

				// -- Linha 3 --//
				contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
				String descricaoServicosTarifas3 = "";
				String consumoFaixa3 = "";
				String valor3 = "";
				if(parmsMedicaoHistorico == null){
					descricaoServicosTarifas3 = " TARIFA MÍNIMA";

					// Valor da tarifa mínima de água para a categoria por
					// economia
					BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getQuantidadeEconomia());
					String valorTarifaMinima = "";
					if(contaCategoria.getValorTarifaMinimaAgua() != null && qtdEconomia != null){
						BigDecimal valorTarifaMinimaBigDecimal = contaCategoria.getValorTarifaMinimaAgua().divide(qtdEconomia, 4,
										RoundingMode.UP);
						valorTarifaMinima = Util.formatarMoedaReal(valorTarifaMinimaBigDecimal, 4);
					}

					descricaoServicosTarifas3 = descricaoServicosTarifas3 + Util.completaStringComEspacoAEsquerda(valorTarifaMinima, 6);
					descricaoServicosTarifas3 = descricaoServicosTarifas3 + " POR UNIDADE";

					consumoFaixa3 = "MINIMO";
					consumoFaixa3 = consumoFaixa3 + Util.completaString("", 11);

					// valor da água para categoria
					String valorAgua = Util.formatarMoedaReal(contaCategoria.getValorAgua());
					valor3 = valorAgua;

					contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
					contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas3);
					contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa3);
					contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor3);
					colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

				}else{

					// recupera a coleção de conta categoria consumo faixa
					Collection colecaoContaCategoriaConsumoFaixa = new ArrayList();

					if(indicadorOperacaoCaucionamento){
						if(!Util.isVazioOrNulo(colecaoContaCategoriaConsumoFaixaCaucionamento)){
							for(Collection<ContaCategoriaConsumoFaixa> colecaoConsumoFaixa : colecaoContaCategoriaConsumoFaixaCaucionamento){
								if(!Util.isVazioOrNulo(colecaoConsumoFaixa)){
									for(ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa : colecaoConsumoFaixa){
										colecaoContaCategoriaConsumoFaixa.add(contaCategoriaConsumoFaixa);

										Collections.sort((List) colecaoContaCategoriaConsumoFaixa, new Comparator() {

											public int compare(Object a, Object b){

												Integer numeroConsumoFaixaInicio1 = ((ContaCategoriaConsumoFaixa) a)
																.getConsumoFaixaInicio();
												Integer numeroConsumoFaixaInicio2 = ((ContaCategoriaConsumoFaixa) b)
																.getConsumoFaixaInicio();

												return numeroConsumoFaixaInicio1.compareTo(numeroConsumoFaixaInicio2);

											}
										});
									}
								}
							}
						}
					}else{
						try{
							colecaoContaCategoriaConsumoFaixa = repositorioFaturamento.pesquisarContaCategoriaHistoricoFaixas(
											emitirContaHelper.getIdConta(), contaCategoria.getComp_id().getCategoria().getId());
						}catch(ErroRepositorioException e){
							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", e);
						}
					}

					// 2.3.1 caso existam faixas de consumo para conta/categoria
					if(colecaoContaCategoriaConsumoFaixa != null && !colecaoContaCategoriaConsumoFaixa.isEmpty()){

						descricaoServicosTarifas3 = " ATE ";

						// Consumo mínimo de água para a categoria por economia
						BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getQuantidadeEconomia());

						BigDecimal consumoMinimoAgua = null;
						if(contaCategoria.getConsumoMinimoAgua() != null){
							consumoMinimoAgua = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getConsumoMinimoAgua());
						}
						BigDecimal consumoMinimaBigDecimal = new BigDecimal("0.00");
						if(consumoMinimoAgua != null && qtdEconomia != null){
							consumoMinimaBigDecimal = consumoMinimoAgua.divide(qtdEconomia, 2, RoundingMode.UP);
						}
						String consumoMinima = "" + consumoMinimaBigDecimal.intValue();

						descricaoServicosTarifas3 = descricaoServicosTarifas3 + Util.completaStringComEspacoAEsquerda(consumoMinima, 6);

						descricaoServicosTarifas3 = descricaoServicosTarifas3 + " M3" + Util.completaString("", 7);
						descricaoServicosTarifas3 = descricaoServicosTarifas3 + "- R$";

						// valor da tarifa minima de agua para a categoria por
						// economia
						BigDecimal valorTarifaMinimaBigDecimal = null;
						if(contaCategoria.getValorTarifaMinimaAgua() != null && qtdEconomia != null){
							valorTarifaMinimaBigDecimal = contaCategoria.getValorTarifaMinimaAgua().divide(qtdEconomia, 4, RoundingMode.UP);
						}

						String valorTarifaMinima = Util.completaStringComEspacoAEsquerda(
										"" + Util.formatarMoedaReal(valorTarifaMinimaBigDecimal, 4), 6);

						descricaoServicosTarifas3 = descricaoServicosTarifas3 + valorTarifaMinima + " (POR UNIDADE)";

						// Consumo mínimo de água para a categoria
						if(contaCategoria.getConsumoMinimoAgua() != null && !contaCategoria.getConsumoMinimoAgua().equals("")){
							consumoFaixa3 = Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoMinimoAgua(), 4);
						}else{
							consumoFaixa3 = Util.completaStringComEspacoAEsquerda("", 4);
						}
						consumoFaixa3 = consumoFaixa3 + " M3";

						// valor da tarifa mínima de agua para categoria
						String valorAguaCategoria = "";
						if(contaCategoria.getValorTarifaMinimaAgua() != null){
							valorAguaCategoria = Util.formatarMoedaReal(contaCategoria.getValorTarifaMinimaAgua(), 4);
						}

						valor3 = valorAguaCategoria;

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas3);
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa3.trim());
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor3);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

						Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa.iterator();
						while(iteratorContaCategoriaConsumoFaixa.hasNext()){
							ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixaHistorico) iteratorContaCategoriaConsumoFaixa
											.next();

							contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
							String descricaoServicosTarifas4 = "";
							String consumoFaixa4 = "";
							String valor4 = "";

							// -- Linha 4 --//
							descricaoServicosTarifas4 = " ";

							// caso a faixa seja a ultima da tarifa de consumo
							if(contaCategoriaConsumoFaixa.getConsumoFaixaFim().equals(99999999)){
								// Consumo inicial da faixa menos 1 m3
								String consumoInicialFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaInicio() - 1);

								// valor da tarifa na faixa
								String valorTarifaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorTarifaFaixa());

								descricaoServicosTarifas4 = descricaoServicosTarifas4 + "ACIMA DE";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
												+ Util.completaStringComEspacoAEsquerda(consumoInicialFaixa, 3);
								descricaoServicosTarifas4 = descricaoServicosTarifas4 + " M3  - R$";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
												+ Util.completaStringComEspacoAEsquerda(valorTarifaFaixa, 6);
								descricaoServicosTarifas4 = descricaoServicosTarifas4 + " POR M3";

								// consumo da agua na faixa

								// consumoFaixa4 = Util
								// .completaStringComEspacoAEsquerda(""
								// + contaCategoriaConsumoFaixa
								// .getConsumoAgua(), 6)
								consumoFaixa4 = Util.completaStringComEspacoAEsquerda("" + contaCategoriaConsumoFaixa.getConsumoAgua()
												* contaCategoria.getQuantidadeEconomia(), 6)
												+ " M3";

								// valor da agua na faixa
								BigDecimal valorAguaFaixa = contaCategoriaConsumoFaixa.getValorAgua().multiply(qtdEconomia)
												.setScale(Parcelamento.CASAS_DECIMAIS);

								valor4 = "" + Util.formatarMoedaReal(valorAguaFaixa);

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas4);
								contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa4.trim());
								contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor4);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);

							}else{
								// Consumo inicial da faixa
								String consumoInicialFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaInicio());
								// consumo final da faixa
								String consumoFinalFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaFim());
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorTarifaFaixa());

								descricaoServicosTarifas4 = descricaoServicosTarifas4
												+ Util.completaStringComEspacoAEsquerda(consumoInicialFaixa, 3) + " M3 A";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
												+ Util.completaStringComEspacoAEsquerda(consumoFinalFaixa, 4) + " M3";
								descricaoServicosTarifas4 = descricaoServicosTarifas4 + "   - R$";
								descricaoServicosTarifas4 = descricaoServicosTarifas4
												+ Util.completaStringComEspacoAEsquerda(valorTarifaFaixa, 6) + " POR M3";

								// consumo de Agua na faixa
								// consumoFaixa4 = Util
								// .completaStringComEspacoAEsquerda(""
								// + contaCategoriaConsumoFaixa
								// .getConsumoAgua(), 6)
								consumoFaixa4 = Util.completaStringComEspacoAEsquerda("" + contaCategoriaConsumoFaixa.getConsumoAgua()
												* contaCategoria.getQuantidadeEconomia(), 6)
												+ " M3";

								// valor da agua na faixa

								BigDecimal valorAguaFaixa = contaCategoriaConsumoFaixa.getValorAgua().multiply(qtdEconomia)
												.setScale(Parcelamento.CASAS_DECIMAIS);

								valor4 = "" + Util.formatarMoedaReal(valorAguaFaixa);

								// String valorAguaFaixa = Util
								// .formatarMoedaReal(contaCategoriaConsumoFaixa
								// .getValorAgua());
								//
								// valor4 = valorAguaFaixa;

								contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
								contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas4);
								contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa4.trim());
								contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor4);
								colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
							}
						}

					}else{
						// 2.3.2.

						descricaoServicosTarifas3 = " CONSUMO DE ÁGUA";
						consumoFaixa3 = Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoAgua(), 6) + " M3";
						valor3 = Util.formatarMoedaReal(contaCategoria.getValorAgua());

						contaLinhasDescricaoServicosTarifasTotalHelper = new ContaLinhasDescricaoServicosTarifasTotalHelper();
						contaLinhasDescricaoServicosTarifasTotalHelper.setDescricaoServicosTarifas(descricaoServicosTarifas3);
						contaLinhasDescricaoServicosTarifasTotalHelper.setConsumoFaixa(consumoFaixa3.trim());
						contaLinhasDescricaoServicosTarifasTotalHelper.setValor(valor3);
						colecaoContaLinhasDescricaoServicosTarifasTotalHelper.add(contaLinhasDescricaoServicosTarifasTotalHelper);
					}

				}
			}
		}

		return colecaoContaLinhasDescricaoServicosTarifasTotalHelper;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<OrdemServico>
	 * @throws ControladorException
	 */
	public Collection<EmitirHistogramaAguaHelper> pesquisarEmitirHistogramaAgua(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		int opcaoTotalizacao = filtro.getOpcaoTotalizacao();

		FiltrarEmitirHistogramaAguaHelper filtroClone = new FiltrarEmitirHistogramaAguaHelper(filtro);

		switch(opcaoTotalizacao){

		// Estado
			case 1:

				colecaoEmitirHistogramaAgua = this.pesquisarEmitirHistogramaAguaEstado(filtro);
				break;

			// Estado por Gerencia Regional
			case 2:

				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaGerenciaRegional(filtro);
				colecaoEmitirHistogramaAgua.addAll(this.pesquisarEmitirHistogramaAguaEstado(filtroClone));
				break;

			// Estado por Unidade Negocio
			case 3:

				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaUnidadeNegocioGerenciaRegional(filtro);
				colecaoEmitirHistogramaAgua.addAll(this.pesquisarEmitirHistogramaAguaEstado(filtroClone));
				break;

			// Estado por Elo Polo
			case 4:

				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaEloUnidadeNegocioGerenciaRegional(filtro);
				colecaoEmitirHistogramaAgua.addAll(this.pesquisarEmitirHistogramaAguaEstado(filtroClone));
				break;

			// Estado por Localidade
			case 5:

				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaLocalidadeEloUnidadeNegocioGerenciaRegional(filtro);
				colecaoEmitirHistogramaAgua.addAll(this.pesquisarEmitirHistogramaAguaEstado(filtroClone));
				break;

			// Gerência Regional
			case 6:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaGerenciaRegional(filtro);
				break;

			// Gerência Regional por Unidade Negocio
			case 7:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaUnidadeNegocioGerenciaRegional(filtro);
				break;

			// Gerência Regional por Elo
			case 8:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaEloUnidadeNegocioGerenciaRegional(filtro);
				break;

			// Gerência Regional por Localidade
			case 9:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaLocalidadeEloUnidadeNegocioGerenciaRegional(filtro);
				break;

			// Unidade de Negocio
			case 10:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaUnidadeNegocio(filtro);
				break;

			// Unidade de Negocio por Elo
			case 11:

				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaEloUnidadeNegocio(filtro);
				break;

			// Unidade de Negocio por Localidade
			case 12:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaLocalidadeEloUnidadeNegocio(filtro);
				break;

			// Elo Polo
			case 13:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaElo(filtro);
				break;

			// Elo Polo Por Localidade
			case 14:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaLocalidadeElo(filtro);
				break;

			// Elo Polo Por Setor Comercial
			case 15:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaSetorComercialLocalidadeElo(filtro);
				break;

			// Localidade
			case 16:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaLocalidade(filtro);
				break;

			// Localidade Por Setor Comercial
			case 17:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaSetorComercialLocalidade(filtro);
				break;

			// Localidade Por Quadra
			case 18:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaQuadraLocalidade(filtro);
				break;

			// Setor Comercial
			case 19:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaSetorComercial(filtro);
				break;

			// Setor Comercial Por Quadra
			case 20:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaQuadraSetorComercial(filtro);
				break;

			// Quadra
			case 21:
				colecaoEmitirHistogramaAgua = this.emitirHistogramaAguaQuadra(filtro);
				break;

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * 
	 * @author Rafael Pinto
	 * @date 06/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> pesquisarEmitirHistogramaAguaEstado(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setOpcaoTotalizacao(1);

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){
			String descricaoOpcaoTotalizacao = this.getControladorUtil().pesquisarParametrosDoSistema().getNomeEstado();

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while(iter.hasNext()){

				String estado = (String) iter.next();

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
								.get(estado);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

			}
		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água - Gerencia Regional
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaGerenciaRegional(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.gerenciaRegional.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setEloPolo(null);
		filtro.setUnidadeNegocio(null);
		filtro.setLocalidade(null);
		filtro.setConsumoFaixaLigacao(null);

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			FiltroGerenciaRegional filtroGerencia = null;
			Collection colecaoGerencia = null;
			GerenciaRegional gerenciaRegional = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while(iter.hasNext()){

				String gerencia = (String) iter.next();

				gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setId(Integer.valueOf(gerencia));

				filtro.setGerenciaRegional(gerenciaRegional);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral
								.get(gerencia);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroGerencia = new FiltroGerenciaRegional();
				filtroGerencia.adicionarParametro(new ParametroSimples(FiltroGerenciaRegional.ID, gerencia));

				// Recupera Gerencia Regional
				colecaoGerencia = this.getControladorUtil().pesquisar(filtroGerencia, GerenciaRegional.class.getName());

				gerenciaRegional = (GerenciaRegional) Util.retonarObjetoDeColecao(colecaoGerencia);

				String descricaoOpcaoTotalizacao = gerenciaRegional.getId() + " - " + gerenciaRegional.getNome();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Unidade Negocio e Gerencia Regional
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaUnidadeNegocioGerenciaRegional(
					FiltrarEmitirHistogramaAguaHelper filtro) throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.unidadeNegocio.id,histograma.gerenciaRegional.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int gerenciaAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			FiltroUnidadeNegocio filtroUnidade = null;
			Collection colecaoUnidade = null;
			UnidadeNegocio unidade = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(Integer.valueOf(arrayNumeracao[0]));

				GerenciaRegional gerencia = new GerenciaRegional();
				gerencia.setId(Integer.valueOf(arrayNumeracao[1]));

				filtro.setUnidadeNegocio(unidadeNegocio);

				if(gerenciaAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					gerenciaAnterior = gerencia.getId();
				}

				// Mudou de Gerencia
				if(gerenciaAnterior != gerencia.getId().intValue()){

					filtro.setOpcaoTotalizacao(2);

					GerenciaRegional gereAnterior = new GerenciaRegional();
					gereAnterior.setId(gerenciaAnterior);
					filtro.setGerenciaRegional(gereAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaGerenciaRegional(filtro));
				}

				filtro.setOpcaoTotalizacao(3);
				filtro.setGerenciaRegional(gerencia);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroUnidade = new FiltroUnidadeNegocio();
				filtroUnidade.adicionarParametro(new ParametroSimples(FiltroUnidadeNegocio.ID, unidadeNegocio.getId()));

				filtroUnidade.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");

				// Recupera Unidade Negocio
				colecaoUnidade = this.getControladorUtil().pesquisar(filtroUnidade, UnidadeNegocio.class.getName());

				unidade = (UnidadeNegocio) Util.retonarObjetoDeColecao(colecaoUnidade);

				String descricaoOpcaoTotalizacao = unidade.getGerenciaRegional().getId() + "-"
								+ unidade.getGerenciaRegional().getNomeAbreviado() + " / " + unidade.getId() + " - " + unidade.getNome();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				filtro.setMedicao(indicadorMedicao);

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				gerenciaAnterior = gerencia.getId();

			}

			filtro.setOpcaoTotalizacao(2);

			GerenciaRegional gereAnterior = new GerenciaRegional();
			gereAnterior.setId(gerenciaAnterior);
			filtro.setGerenciaRegional(gereAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaGerenciaRegional(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * Elo e Unidade Negocio e Gerencia Regional
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaEloUnidadeNegocioGerenciaRegional(
					FiltrarEmitirHistogramaAguaHelper filtro) throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidadeElo.id," + "histograma.unidadeNegocio.id,histograma.gerenciaRegional.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int gerenciaAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int unidadeNegocioAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade eloPolo = null;
			UnidadeNegocio unidadeNegocio = null;
			GerenciaRegional gerencia = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				eloPolo = new Localidade();
				eloPolo.setId(Integer.valueOf(arrayNumeracao[0]));

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(Integer.valueOf(arrayNumeracao[1]));

				gerencia = new GerenciaRegional();
				gerencia.setId(Integer.valueOf(arrayNumeracao[2]));

				if(unidadeNegocioAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					unidadeNegocioAnterior = unidadeNegocio.getId();
				}

				if(gerenciaAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					gerenciaAnterior = gerencia.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setGerenciaRegional(gerencia);

				// Mudou de Unidade
				if(unidadeNegocioAnterior != unidadeNegocio.getId().intValue()){

					filtro.setOpcaoTotalizacao(10);

					UnidadeNegocio uniAnterior = new UnidadeNegocio();
					uniAnterior.setId(unidadeNegocioAnterior);
					filtro.setUnidadeNegocio(uniAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaUnidadeNegocio(filtro));
				}

				filtro.setMedicao(indicadorMedicao);

				// Mudou de Gerencia
				if(gerenciaAnterior != gerencia.getId().intValue()){

					GerenciaRegional gereAnterior = new GerenciaRegional();
					gereAnterior.setId(gerenciaAnterior);
					filtro.setGerenciaRegional(gereAnterior);

					filtro.setOpcaoTotalizacao(2);
					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaGerenciaRegional(filtro));
				}

				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setGerenciaRegional(gerencia);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, eloPolo.getId()));

				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

				eloPolo = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = eloPolo.getGerenciaRegional().getId() + "-"
								+ eloPolo.getGerenciaRegional().getNomeAbreviado() + " / " + eloPolo.getUnidadeNegocio().getId() + "-"
								+ eloPolo.getUnidadeNegocio().getNomeAbreviado() + " / " + eloPolo.getId() + "-" + eloPolo.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				filtro.setMedicao(indicadorMedicao);

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				gerenciaAnterior = gerencia.getId();
				unidadeNegocioAnterior = unidadeNegocio.getId();

			}

			filtro.setMedicao(indicadorMedicao);

			filtro.setOpcaoTotalizacao(10);
			UnidadeNegocio uniAnterior = new UnidadeNegocio();
			uniAnterior.setId(unidadeNegocioAnterior);
			filtro.setUnidadeNegocio(uniAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaUnidadeNegocio(filtro));

			filtro.setMedicao(indicadorMedicao);

			filtro.setOpcaoTotalizacao(2);
			GerenciaRegional gereAnterior = new GerenciaRegional();
			gereAnterior.setId(gerenciaAnterior);
			filtro.setGerenciaRegional(gereAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaGerenciaRegional(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Elo e Unidade Negocio
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaEloUnidadeNegocio(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidadeElo.id,histograma.unidadeNegocio.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int unidadeNegocioAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade eloPolo = null;
			UnidadeNegocio unidadeNegocio = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				eloPolo = new Localidade();
				eloPolo.setId(Integer.valueOf(arrayNumeracao[0]));

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(Integer.valueOf(arrayNumeracao[1]));

				if(unidadeNegocioAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					unidadeNegocioAnterior = unidadeNegocio.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);

				// Mudou de Unidade
				if(unidadeNegocioAnterior != unidadeNegocio.getId().intValue()){

					filtro.setOpcaoTotalizacao(10);

					UnidadeNegocio uniAnterior = new UnidadeNegocio();
					uniAnterior.setId(unidadeNegocioAnterior);
					filtro.setUnidadeNegocio(uniAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaUnidadeNegocio(filtro));
				}

				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, eloPolo.getId()));

				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

				eloPolo = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = eloPolo.getGerenciaRegional().getId() + "-"
								+ eloPolo.getGerenciaRegional().getNomeAbreviado() + " / " + eloPolo.getUnidadeNegocio().getId() + "-"
								+ eloPolo.getUnidadeNegocio().getNomeAbreviado() + " / " + eloPolo.getId() + "-" + eloPolo.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				filtro.setMedicao(indicadorMedicao);

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				unidadeNegocioAnterior = unidadeNegocio.getId();

			}

			filtro.setMedicao(indicadorMedicao);

			filtro.setOpcaoTotalizacao(10);
			UnidadeNegocio uniAnterior = new UnidadeNegocio();
			uniAnterior.setId(unidadeNegocioAnterior);
			filtro.setUnidadeNegocio(uniAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaUnidadeNegocio(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Localidade Elo e Unidade Negocio
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaLocalidadeEloUnidadeNegocio(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidade.id,histograma.localidadeElo.id," + "histograma.unidadeNegocio.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int unidadeNegocioAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int eloPoloAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade localidade = null;
			Localidade eloPolo = null;
			UnidadeNegocio unidadeNegocio = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				localidade = new Localidade();
				localidade.setId(Integer.valueOf(arrayNumeracao[0]));

				eloPolo = new Localidade();
				eloPolo.setId(Integer.valueOf(arrayNumeracao[1]));

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(Integer.valueOf(arrayNumeracao[2]));

				if(eloPoloAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					eloPoloAnterior = eloPolo.getId();
				}

				if(unidadeNegocioAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					unidadeNegocioAnterior = unidadeNegocio.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);

				// Mudou de Elo Polo
				if(eloPoloAnterior != eloPolo.getId().intValue()){

					filtro.setOpcaoTotalizacao(13);
					Localidade eloAnterior = new Localidade();
					eloAnterior.setId(eloPoloAnterior);
					filtro.setEloPolo(eloAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaElo(filtro));
				}

				filtro.setMedicao(indicadorMedicao);

				// Mudou de Unidade
				if(unidadeNegocioAnterior != unidadeNegocio.getId().intValue()){

					filtro.setOpcaoTotalizacao(10);
					UnidadeNegocio uniAnterior = new UnidadeNegocio();
					uniAnterior.setId(unidadeNegocioAnterior);
					filtro.setUnidadeNegocio(uniAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaUnidadeNegocio(filtro));
				}

				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, localidade.getId()));

				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade.getGerenciaRegional().getId() + "-"
								+ localidade.getGerenciaRegional().getNomeAbreviado() + " / " + localidade.getUnidadeNegocio().getId()
								+ "-" + localidade.getUnidadeNegocio().getNomeAbreviado() + " / " + localidade.getLocalidade().getId()
								+ "-" + localidade.getLocalidade().getDescricao() + " / " + localidade.getId() + "-"
								+ localidade.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				unidadeNegocioAnterior = unidadeNegocio.getId();
				eloPoloAnterior = eloPolo.getId();

			}

			filtro.setOpcaoTotalizacao(13);
			filtro.setMedicao(indicadorMedicao);

			Localidade eloAnterior = new Localidade();
			eloAnterior.setId(eloPoloAnterior);
			filtro.setEloPolo(eloAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaElo(filtro));

			filtro.setOpcaoTotalizacao(10);
			filtro.setMedicao(indicadorMedicao);

			UnidadeNegocio uniAnterior = new UnidadeNegocio();
			uniAnterior.setId(unidadeNegocioAnterior);
			filtro.setUnidadeNegocio(uniAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaUnidadeNegocio(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Localidade Elo e Unidade Negocio e Gerencia Regional
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaLocalidadeEloUnidadeNegocioGerenciaRegional(
					FiltrarEmitirHistogramaAguaHelper filtro) throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidade.id,histograma.localidadeElo.id,"
						+ "histograma.unidadeNegocio.id,histograma.gerenciaRegional.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int gerenciaAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int unidadeNegocioAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int eloPoloAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade localidade = null;
			Localidade eloPolo = null;
			UnidadeNegocio unidadeNegocio = null;
			GerenciaRegional gerencia = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				localidade = new Localidade();
				localidade.setId(Integer.valueOf(arrayNumeracao[0]));

				eloPolo = new Localidade();
				eloPolo.setId(Integer.valueOf(arrayNumeracao[1]));

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(Integer.valueOf(arrayNumeracao[2]));

				gerencia = new GerenciaRegional();
				gerencia.setId(Integer.valueOf(arrayNumeracao[3]));

				if(eloPoloAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					eloPoloAnterior = eloPolo.getId();
				}

				if(unidadeNegocioAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					unidadeNegocioAnterior = unidadeNegocio.getId();
				}

				if(gerenciaAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					gerenciaAnterior = gerencia.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setGerenciaRegional(gerencia);

				// Mudou de Elo Polo
				if(eloPoloAnterior != eloPolo.getId().intValue()){

					filtro.setOpcaoTotalizacao(13);
					Localidade eloAnterior = new Localidade();
					eloAnterior.setId(eloPoloAnterior);
					filtro.setEloPolo(eloAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaElo(filtro));
				}

				filtro.setMedicao(indicadorMedicao);

				// Mudou de Unidade
				if(unidadeNegocioAnterior != unidadeNegocio.getId().intValue()){

					filtro.setOpcaoTotalizacao(10);
					UnidadeNegocio uniAnterior = new UnidadeNegocio();
					uniAnterior.setId(unidadeNegocioAnterior);
					filtro.setUnidadeNegocio(uniAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaUnidadeNegocio(filtro));
				}
				filtro.setMedicao(indicadorMedicao);

				// Mudou de Gerencia
				if(gerenciaAnterior != gerencia.getId().intValue()){

					GerenciaRegional gereAnterior = new GerenciaRegional();
					gereAnterior.setId(gerenciaAnterior);
					filtro.setGerenciaRegional(gereAnterior);

					filtro.setOpcaoTotalizacao(2);
					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaGerenciaRegional(filtro));
				}

				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setUnidadeNegocio(unidadeNegocio);
				filtro.setGerenciaRegional(gerencia);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, localidade.getId()));

				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade.getGerenciaRegional().getId() + "-"
								+ localidade.getGerenciaRegional().getNomeAbreviado() + " / " + localidade.getUnidadeNegocio().getId()
								+ "-" + localidade.getUnidadeNegocio().getNomeAbreviado() + " / " + localidade.getLocalidade().getId()
								+ "-" + localidade.getLocalidade().getDescricao() + " / " + localidade.getId() + "-"
								+ localidade.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				gerenciaAnterior = gerencia.getId();
				unidadeNegocioAnterior = unidadeNegocio.getId();
				eloPoloAnterior = eloPolo.getId();

			}

			filtro.setOpcaoTotalizacao(13);
			filtro.setMedicao(indicadorMedicao);

			Localidade eloAnterior = new Localidade();
			eloAnterior.setId(eloPoloAnterior);
			filtro.setEloPolo(eloAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaElo(filtro));

			filtro.setOpcaoTotalizacao(10);
			filtro.setMedicao(indicadorMedicao);

			UnidadeNegocio uniAnterior = new UnidadeNegocio();
			uniAnterior.setId(unidadeNegocioAnterior);
			filtro.setUnidadeNegocio(uniAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaUnidadeNegocio(filtro));

			filtro.setOpcaoTotalizacao(2);
			filtro.setMedicao(indicadorMedicao);

			GerenciaRegional gereAnterior = new GerenciaRegional();
			gereAnterior.setId(gerenciaAnterior);
			filtro.setGerenciaRegional(gereAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaGerenciaRegional(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * Unidade Negocio
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaUnidadeNegocio(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.unidadeNegocio.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setEloPolo(null);
		filtro.setGerenciaRegional(null);
		filtro.setLocalidade(null);
		filtro.setConsumoFaixaLigacao(null);

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			FiltroUnidadeNegocio filtroUnidade = null;
			Collection colecaoUnidade = null;
			UnidadeNegocio unidadeNegocio = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while(iter.hasNext()){

				String chave = (String) iter.next();

				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(Integer.valueOf(chave));

				filtro.setUnidadeNegocio(unidadeNegocio);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroUnidade = new FiltroUnidadeNegocio();
				filtroUnidade.adicionarParametro(new ParametroSimples(FiltroUnidadeNegocio.ID, chave));

				filtroUnidade.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");

				// Recupera Unidade Negocio
				colecaoUnidade = this.getControladorUtil().pesquisar(filtroUnidade, UnidadeNegocio.class.getName());

				unidadeNegocio = (UnidadeNegocio) Util.retonarObjetoDeColecao(colecaoUnidade);

				String descricaoOpcaoTotalizacao = unidadeNegocio.getGerenciaRegional().getId() + "-"
								+ unidadeNegocio.getGerenciaRegional().getNomeAbreviado() + " / " + unidadeNegocio.getId() + "-"
								+ unidadeNegocio.getNome();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}
				filtro.setMedicao(indicadorMedicao);

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * Elo Polo
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaElo(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidadeElo.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setLocalidade(null);
		filtro.setUnidadeNegocio(null);
		filtro.setGerenciaRegional(null);
		filtro.setCodigoSetorComercial(null);
		filtro.setConsumoFaixaLigacao(null);

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;
			Localidade localidade = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while(iter.hasNext()){

				String chave = (String) iter.next();

				localidade = new Localidade();
				localidade.setId(Integer.valueOf(chave));

				filtro.setEloPolo(localidade);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, chave));

				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Unidade Negocio
				colecaoLocalidade = this.getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade.getGerenciaRegional().getId() + "-"
								+ localidade.getGerenciaRegional().getNomeAbreviado() + " / " + localidade.getUnidadeNegocio().getId()
								+ "-" + localidade.getUnidadeNegocio().getNomeAbreviado() + " / " + localidade.getId() + "-"
								+ localidade.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Localidade, Elo e Unidade Negocio
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaLocalidadeElo(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidade.id,histograma.localidadeElo.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int eloPoloAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;

			Localidade localidade = null;
			Localidade eloPolo = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				localidade = new Localidade();
				localidade.setId(Integer.valueOf(arrayNumeracao[0]));

				eloPolo = new Localidade();
				eloPolo.setId(Integer.valueOf(arrayNumeracao[1]));

				if(eloPoloAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					eloPoloAnterior = eloPolo.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);

				// Mudou de Elo Polo
				if(eloPoloAnterior != eloPolo.getId().intValue()){

					filtro.setOpcaoTotalizacao(13);
					Localidade eloAnterior = new Localidade();
					eloAnterior.setId(eloPoloAnterior);
					filtro.setEloPolo(eloAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaElo(filtro));
				}

				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);
				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, localidade.getId()));

				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("gerenciaRegional");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("unidadeNegocio");

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade.getGerenciaRegional().getId() + "-"
								+ localidade.getGerenciaRegional().getNomeAbreviado() + " / " + localidade.getUnidadeNegocio().getId()
								+ "-" + localidade.getUnidadeNegocio().getNomeAbreviado() + " / " + localidade.getLocalidade().getId()
								+ "-" + localidade.getLocalidade().getDescricao() + " / " + localidade.getId() + "-"
								+ localidade.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				eloPoloAnterior = eloPolo.getId();

			}

			filtro.setOpcaoTotalizacao(13);
			filtro.setMedicao(indicadorMedicao);

			Localidade eloAnterior = new Localidade();
			eloAnterior.setId(eloPoloAnterior);
			filtro.setEloPolo(eloAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaElo(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Setor Comercial ,Localidade e Elo
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaSetorComercialLocalidadeElo(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.codigoSetorComercial,histograma.localidade.id," + "histograma.localidadeElo.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int localidadeAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int eloPoloAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroSetorComercial filtroSetorComercial = null;
			Collection colecaoSetorComercial = null;

			Integer codigoSetorComercial = null;
			SetorComercial setorComercial = null;
			Localidade localidade = null;
			Localidade eloPolo = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				codigoSetorComercial = Integer.valueOf(arrayNumeracao[0]);

				localidade = new Localidade();
				localidade.setId(Integer.valueOf(arrayNumeracao[1]));

				eloPolo = new Localidade();
				eloPolo.setId(Integer.valueOf(arrayNumeracao[2]));

				if(eloPoloAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					eloPoloAnterior = eloPolo.getId();
				}

				if(localidadeAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					localidadeAnterior = localidade.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setCodigoSetorComercial(codigoSetorComercial);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);

				// Mudou de Localidade
				if(localidadeAnterior != localidade.getId().intValue()){

					filtro.setOpcaoTotalizacao(16);

					Localidade localAnterior = new Localidade();
					localAnterior.setId(localidadeAnterior);

					filtro.setLocalidade(localAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaLocalidade(filtro));
				}

				filtro.setCodigoSetorComercial(codigoSetorComercial);
				filtro.setLocalidade(localidade);
				filtro.setMedicao(indicadorMedicao);

				// Mudou de Elo Polo
				if(eloPoloAnterior != eloPolo.getId().intValue()){

					filtro.setOpcaoTotalizacao(13);
					Localidade eloAnterior = new Localidade();
					eloAnterior.setId(eloPoloAnterior);
					filtro.setEloPolo(eloAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaElo(filtro));
				}

				filtro.setCodigoSetorComercial(codigoSetorComercial);
				filtro.setLocalidade(localidade);
				filtro.setEloPolo(eloPolo);

				filtro.setMedicao(indicadorMedicao);
				filtro.setOpcaoTotalizacao(4);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroSetorComercial = new FiltroSetorComercial();
				filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.CODIGO_SETOR_COMERCIAL,
								codigoSetorComercial));

				filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.ID_LOCALIDADE, localidade.getId()));

				filtroSetorComercial.adicionarCaminhoParaCarregamentoEntidade("localidade");

				// Recupera Setor Comercial
				colecaoSetorComercial = this.getControladorUtil().pesquisar(filtroSetorComercial, SetorComercial.class.getName());

				setorComercial = (SetorComercial) Util.retonarObjetoDeColecao(colecaoSetorComercial);

				String descricaoOpcaoTotalizacao = setorComercial.getLocalidade().getId() + "-"
								+ setorComercial.getLocalidade().getDescricao() + " / " + setorComercial.getCodigo() + "-"
								+ setorComercial.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				localidadeAnterior = localidade.getId();
				eloPoloAnterior = eloPolo.getId();

			}

			filtro.setOpcaoTotalizacao(16);
			filtro.setMedicao(indicadorMedicao);

			Localidade localAnterior = new Localidade();
			localAnterior.setId(localidadeAnterior);

			filtro.setLocalidade(localAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaLocalidade(filtro));

			filtro.setOpcaoTotalizacao(13);
			filtro.setMedicao(indicadorMedicao);

			Localidade eloAnterior = new Localidade();
			eloAnterior.setId(eloPoloAnterior);
			filtro.setEloPolo(eloAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaElo(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Setor Comercial ,Localidade e Elo
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaSetorComercialLocalidade(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.codigoSetorComercial,histograma.localidade.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int localidadeAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroSetorComercial filtroSetorComercial = null;
			Collection colecaoSetorComercial = null;

			Integer codigoSetorComercial = null;
			SetorComercial setorComercial = null;
			Localidade localidade = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				codigoSetorComercial = Integer.valueOf(arrayNumeracao[0]);

				localidade = new Localidade();
				localidade.setId(Integer.valueOf(arrayNumeracao[1]));

				if(localidadeAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					localidadeAnterior = localidade.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setCodigoSetorComercial(codigoSetorComercial);
				filtro.setLocalidade(localidade);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroSetorComercial = new FiltroSetorComercial();
				filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.CODIGO_SETOR_COMERCIAL,
								codigoSetorComercial));

				filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.ID_LOCALIDADE, localidade.getId()));

				filtroSetorComercial.adicionarCaminhoParaCarregamentoEntidade("localidade");

				// Recupera Setor Comercial
				colecaoSetorComercial = this.getControladorUtil().pesquisar(filtroSetorComercial, SetorComercial.class.getName());

				setorComercial = (SetorComercial) Util.retonarObjetoDeColecao(colecaoSetorComercial);

				String descricaoOpcaoTotalizacao = setorComercial.getLocalidade().getId() + "-"
								+ setorComercial.getLocalidade().getDescricao() + " / " + setorComercial.getCodigo() + "-"
								+ setorComercial.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				localidadeAnterior = localidade.getId();

			}

			filtro.setOpcaoTotalizacao(16);
			filtro.setMedicao(indicadorMedicao);

			Localidade localAnterior = new Localidade();
			localAnterior.setId(localidadeAnterior);

			filtro.setLocalidade(localAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaLocalidade(filtro));
		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Setor Comercial e Quadra
	 * 
	 * @author Rafael Pinto
	 * @date 13/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaQuadraSetorComercial(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.numeroQuadra,histograma.setorComercial.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int setorComercialAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroQuadra filtroQuadra = null;
			Collection colecaoQuadra = null;

			Integer numeroQuadra = null;
			SetorComercial setorComercial = null;
			Quadra quadra = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				numeroQuadra = Integer.valueOf(arrayNumeracao[0]);

				setorComercial = new SetorComercial();
				setorComercial.setId(Integer.valueOf(arrayNumeracao[1]));

				if(setorComercialAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					setorComercialAnterior = setorComercial.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setNumeroQuadra(numeroQuadra);
				filtro.setSetorComercial(setorComercial);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroQuadra = new FiltroQuadra();
				filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.NUMERO_QUADRA, numeroQuadra));

				filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID_SETORCOMERCIAL, setorComercial.getId()));

				filtroQuadra.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
				filtroQuadra.adicionarCaminhoParaCarregamentoEntidade("setorComercial.localidade");

				// Recupera Quadra
				colecaoQuadra = this.getControladorUtil().pesquisar(filtroQuadra, Quadra.class.getName());

				quadra = (Quadra) Util.retonarObjetoDeColecao(colecaoQuadra);

				String descricaoOpcaoTotalizacao = quadra.getSetorComercial().getLocalidade().getId() + "-"
								+ quadra.getSetorComercial().getLocalidade().getDescricao() + " / " + quadra.getSetorComercial().getId()
								+ "-" + quadra.getSetorComercial().getDescricao() + " / " + quadra.getNumeroQuadra();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				setorComercialAnterior = setorComercial.getId();

			}

			SetorComercial setorAnterior = new SetorComercial();
			setorAnterior.setId(setorComercialAnterior);

			filtro.setOpcaoTotalizacao(19);
			filtro.setMedicao(indicadorMedicao);
			filtro.setSetorComercial(setorAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaSetorComercial(filtro));
		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Setor Comercial ,Localidade e Elo
	 * 
	 * @author Rafael Pinto
	 * @date 12/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaQuadraLocalidade(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.numeroQuadra,histograma.setorComercial.id," + "histograma.localidade.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		Short indicadorMedicao = filtro.getMedicao();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			int localidadeAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;
			int setorComercialAnterior = ConstantesSistema.NUMERO_NAO_INFORMADO;

			FiltroQuadra filtroQuadra = null;
			Collection colecaoQuadra = null;

			Integer numeroQuadra = null;

			Quadra quadra = null;
			SetorComercial setorComercial = null;
			Localidade localidade = null;

			while(iter.hasNext()){

				String chave = (String) iter.next();

				String[] arrayNumeracao = chave.split(";");

				numeroQuadra = Integer.valueOf(arrayNumeracao[0]);

				setorComercial = new SetorComercial();
				setorComercial.setId(Integer.valueOf(arrayNumeracao[1]));

				localidade = new Localidade();
				localidade.setId(Integer.valueOf(arrayNumeracao[2]));

				if(setorComercialAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					setorComercialAnterior = setorComercial.getId();
				}

				if(localidadeAnterior == ConstantesSistema.NUMERO_NAO_INFORMADO){
					localidadeAnterior = localidade.getId();
				}

				filtro.setMedicao(indicadorMedicao);
				filtro.setSetorComercial(setorComercial);
				filtro.setLocalidade(localidade);

				// Mudou de Setor Comercial
				if(setorComercialAnterior != setorComercial.getId().intValue()){

					filtro.setOpcaoTotalizacao(19);

					SetorComercial setorAnterior = new SetorComercial();
					setorAnterior.setId(setorComercialAnterior);
					filtro.setSetorComercial(setorAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaSetorComercial(filtro));
				}

				filtro.setMedicao(indicadorMedicao);

				// Mudou de Localidade
				if(localidadeAnterior != localidade.getId().intValue()){

					filtro.setOpcaoTotalizacao(16);

					Localidade localAnterior = new Localidade();
					localAnterior.setId(localidadeAnterior);

					filtro.setLocalidade(localAnterior);

					colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaLocalidade(filtro));
				}

				filtro.setNumeroQuadra(numeroQuadra);
				filtro.setSetorComercial(setorComercial);
				filtro.setLocalidade(localidade);
				filtro.setMedicao(indicadorMedicao);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroQuadra = new FiltroQuadra();
				filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.NUMERO_QUADRA, numeroQuadra));

				filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID_SETORCOMERCIAL, setorComercial.getId()));

				filtroQuadra.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
				filtroQuadra.adicionarCaminhoParaCarregamentoEntidade("setorComercial.localidade");

				// Recupera Quadra
				colecaoQuadra = this.getControladorUtil().pesquisar(filtroQuadra, Quadra.class.getName());

				quadra = (Quadra) Util.retonarObjetoDeColecao(colecaoQuadra);

				String descricaoOpcaoTotalizacao = quadra.getSetorComercial().getLocalidade().getId() + "-"
								+ quadra.getSetorComercial().getLocalidade().getDescricao() + " / " + quadra.getSetorComercial().getId()
								+ "-" + quadra.getSetorComercial().getDescricao() + " / " + quadra.getNumeroQuadra();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}

				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

				localidadeAnterior = localidade.getId();
				setorComercialAnterior = setorComercial.getId();

			}

			SetorComercial setorAnterior = new SetorComercial();
			setorAnterior.setId(setorComercialAnterior);

			filtro.setOpcaoTotalizacao(19);
			filtro.setMedicao(indicadorMedicao);
			filtro.setSetorComercial(setorAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaSetorComercial(filtro));

			Localidade localAnterior = new Localidade();
			localAnterior.setId(localidadeAnterior);

			filtro.setOpcaoTotalizacao(16);
			filtro.setMedicao(indicadorMedicao);
			filtro.setLocalidade(localAnterior);

			colecaoEmitirHistogramaAgua.addAll(this.emitirHistogramaAguaLocalidade(filtro));

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * Localidade
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaLocalidade(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.localidade.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setCodigoSetorComercial(null);
		filtro.setSetorComercial(null);
		filtro.setEloPolo(null);
		filtro.setConsumoFaixaLigacao(null);

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			FiltroLocalidade filtroLocalidade = null;
			Collection colecaoLocalidade = null;
			Localidade localidade = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while(iter.hasNext()){

				String chave = (String) iter.next();

				localidade = new Localidade();
				localidade.setId(Integer.valueOf(chave));

				filtro.setLocalidade(localidade);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, chave));

				// Recupera Localidade
				colecaoLocalidade = this.getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

				localidade = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidade);

				String descricaoOpcaoTotalizacao = localidade.getId() + "-" + localidade.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * Setor Comercial
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaSetorComercial(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.setorComercial.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		filtro.setConsumoFaixaLigacao(null);

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			FiltroSetorComercial filtroSetorComercial = null;
			Collection colecaoSetorComercial = null;
			SetorComercial setorComercial = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while(iter.hasNext()){

				String chave = (String) iter.next();

				setorComercial = new SetorComercial();
				setorComercial.setId(Integer.valueOf(chave));

				filtro.setSetorComercial(setorComercial);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroSetorComercial = new FiltroSetorComercial();
				filtroSetorComercial.adicionarParametro(new ParametroSimples(FiltroSetorComercial.ID, chave));

				filtroSetorComercial.adicionarCaminhoParaCarregamentoEntidade("localidade");

				// Recupera Setor Comercial
				colecaoSetorComercial = this.getControladorUtil().pesquisar(filtroSetorComercial, SetorComercial.class.getName());

				setorComercial = (SetorComercial) Util.retonarObjetoDeColecao(colecaoSetorComercial);

				String descricaoOpcaoTotalizacao = setorComercial.getLocalidade().getId() + "-"
								+ setorComercial.getLocalidade().getDescricao() + " / " + setorComercial.getCodigo() + "-"
								+ setorComercial.getDescricao();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água -
	 * Quadra
	 * 
	 * @author Rafael Pinto
	 * @date 11/06/2007
	 * @param FiltrarEmitirHistogramaAguaHelper
	 * @return Collection<EmitirHistogramaAguaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirHistogramaAguaHelper> emitirHistogramaAguaQuadra(FiltrarEmitirHistogramaAguaHelper filtro)
					throws ControladorException{

		Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua = new ArrayList<EmitirHistogramaAguaHelper>();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoMedido = filtro.getColecaoConsumoFaixaLigacaoMedido();

		Collection<ConsumoFaixaLigacao> colecaoConsumoFaixaLigacaoNaoMedido = filtro.getColecaoConsumoFaixaLigacaoNaoMedido();

		filtro.setTipoGroupBy("histograma.quadra.id ");

		LinkedHashMap hashMapTotalGeral = new LinkedHashMap();

		try{

			if(filtro.getMedicao() != null){
				if(filtro.getMedicao().shortValue() == ConstantesSistema.INDICADOR_USO_ATIVO){
					filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}else{
					filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(filtro.getMedicao()));
				}
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_ATIVO));
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro
								.retornaOLimiteConsultaTotal(ConstantesSistema.INDICADOR_USO_DESATIVO));
			}

			Collection<Object[]> colecaoTotalGeral = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

			hashMapTotalGeral = this.montarEmitirHistogramaAguaTotalGeral(filtro, colecaoTotalGeral);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(hashMapTotalGeral != null && !hashMapTotalGeral.isEmpty()){

			FiltroQuadra filtroQuadra = null;
			Collection colecaoQuadra = null;
			Quadra quadra = null;

			Iterator iter = hashMapTotalGeral.keySet().iterator();

			while(iter.hasNext()){

				String chave = (String) iter.next();

				quadra = new Quadra();
				quadra.setId(Integer.valueOf(chave));

				filtro.setQuadra(quadra);

				EmitirHistogramaAguaHelper emitirHistogramaAguaHelperTotalGeral = (EmitirHistogramaAguaHelper) hashMapTotalGeral.get(chave);

				HashMap mapTotalizacaoCategoria = this.montarEmitirHistogramaAguaTotalGeralCategoria(emitirHistogramaAguaHelperTotalGeral
								.getColecaoEmitirHistogramaAguaDetalhe());

				filtroQuadra = new FiltroQuadra();
				filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID, chave));

				filtroQuadra.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
				filtroQuadra.adicionarCaminhoParaCarregamentoEntidade("setorComercial.localidade");

				// Recupera Setor Comercial
				colecaoQuadra = this.getControladorUtil().pesquisar(filtroQuadra, Quadra.class.getName());

				quadra = (Quadra) Util.retonarObjetoDeColecao(colecaoQuadra);

				String descricaoOpcaoTotalizacao = quadra.getSetorComercial().getLocalidade().getId() + "-"
								+ quadra.getSetorComercial().getLocalidade().getDescricao() + " / " + quadra.getSetorComercial().getId()
								+ "-" + quadra.getSetorComercial().getDescricao() + " / " + quadra.getNumeroQuadra();

				// Vai gerar Faixa para medido
				if(colecaoConsumoFaixaLigacaoMedido != null && !colecaoConsumoFaixaLigacaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_ATIVO, mapTotalizacaoCategoria);

				}

				// Vai gerar Faixa para Não medido
				if(colecaoConsumoFaixaLigacaoNaoMedido != null && !colecaoConsumoFaixaLigacaoNaoMedido.isEmpty()){

					this.montarEmitirHistogramaAguaFaixaConsumo(colecaoConsumoFaixaLigacaoNaoMedido, filtro,
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeLigacoes(),
									emitirHistogramaAguaHelperTotalGeral.getTotalValorFaturado(),
									emitirHistogramaAguaHelperTotalGeral.getTotalQuantidadeVolumeTotal(), colecaoEmitirHistogramaAgua,
									descricaoOpcaoTotalizacao, ConstantesSistema.INDICADOR_USO_DESATIVO, mapTotalizacaoCategoria);
				}
				// Setar Total Geral
				emitirHistogramaAguaHelperTotalGeral.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialLigacao(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialConsumo(100.0);
				emitirHistogramaAguaHelperTotalGeral.setTotalPercentualParcialFaturamento(100.0);
				colecaoEmitirHistogramaAgua.add(emitirHistogramaAguaHelperTotalGeral);

			}

		}

		return colecaoEmitirHistogramaAgua;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Total Geral
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param Collection
	 *            <Object[]>
	 * @return HashMap
	 * @throws ControladorException
	 */
	private LinkedHashMap montarEmitirHistogramaAguaTotalGeral(FiltrarEmitirHistogramaAguaHelper filtro, Collection<Object[]> colecao)
					throws ControladorException{

		LinkedHashMap hashMapTotalizacao = new LinkedHashMap();

		if(colecao != null && !colecao.isEmpty()){

			Iterator iterator = colecao.iterator();

			Collection<EmitirHistogramaAguaDetalheHelper> colecaoEmitirHistogramaAguaDetalhe = null;

			while(iterator.hasNext()){
				Object[] objeto = (Object[]) iterator.next();

				EmitirHistogramaAguaDetalheHelper detalhe = new EmitirHistogramaAguaDetalheHelper();

				detalhe.setDescricaoCategoria((String) objeto[1]);

				if(objeto[2] != null){
					Number quantidadeLigacoes = (Number) objeto[2];
					detalhe.setQuantidadeLigacoes(quantidadeLigacoes.intValue());
				}

				if(objeto[3] != null){
					Number quantidadeEconomias = (Number) objeto[3];
					detalhe.setQuantidadeEconomias(quantidadeEconomias.intValue());
				}

				detalhe.setValorFaturado((BigDecimal) objeto[4]);

				String tipoTotalizacao = "0";

				GerenciaRegional gerencia = null;
				UnidadeNegocio unidadeNegocio = null;
				Localidade eloPolo = null;
				Localidade localidade = null;
				SetorComercial setorComercial = null;
				Quadra quadra = null;

				int chaveQuadra = 0;
				int chaveSetorComercial = 0;
				int chaveLocalidade = 0;
				int chaveElo = 0;
				int chaveUnidade = 0;
				int chaveGerencia = 0;

				if(filtro.getOpcaoTotalizacao() == 2 || filtro.getOpcaoTotalizacao() == 6){

					tipoTotalizacao = ((Integer) objeto[5]).toString();

					gerencia = new GerenciaRegional();
					gerencia.setId(Integer.valueOf(tipoTotalizacao));

					filtro.setGerenciaRegional(gerencia);

				}else if(filtro.getOpcaoTotalizacao() == 3 || filtro.getOpcaoTotalizacao() == 7){

					chaveUnidade = (Integer) objeto[5];
					chaveGerencia = (Integer) objeto[6];

					tipoTotalizacao = chaveUnidade + ";" + chaveGerencia;

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

					gerencia = new GerenciaRegional();
					gerencia.setId(chaveGerencia);
					filtro.setGerenciaRegional(gerencia);

				}else if(filtro.getOpcaoTotalizacao() == 4 || filtro.getOpcaoTotalizacao() == 8){

					chaveElo = (Integer) objeto[5];
					chaveUnidade = (Integer) objeto[6];
					chaveGerencia = (Integer) objeto[7];

					tipoTotalizacao = chaveElo + ";" + chaveUnidade + ";" + chaveGerencia;

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

					gerencia = new GerenciaRegional();
					gerencia.setId(chaveGerencia);
					filtro.setGerenciaRegional(gerencia);

				}else if(filtro.getOpcaoTotalizacao() == 5 || filtro.getOpcaoTotalizacao() == 9){

					chaveLocalidade = (Integer) objeto[5];
					chaveElo = (Integer) objeto[6];
					chaveUnidade = (Integer) objeto[7];
					chaveGerencia = (Integer) objeto[8];

					tipoTotalizacao = chaveLocalidade + ";" + chaveElo + ";" + chaveUnidade + ";" + chaveGerencia;

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

					gerencia = new GerenciaRegional();
					gerencia.setId(chaveGerencia);
					filtro.setGerenciaRegional(gerencia);

				}else if(filtro.getOpcaoTotalizacao() == 10){

					chaveUnidade = (Integer) objeto[5];
					tipoTotalizacao = "" + chaveUnidade;

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

				}else if(filtro.getOpcaoTotalizacao() == 11){

					chaveElo = (Integer) objeto[5];
					chaveUnidade = (Integer) objeto[6];

					tipoTotalizacao = chaveElo + ";" + chaveUnidade;

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

				}else if(filtro.getOpcaoTotalizacao() == 12){

					chaveLocalidade = (Integer) objeto[5];
					chaveElo = (Integer) objeto[6];
					chaveUnidade = (Integer) objeto[7];

					tipoTotalizacao = chaveLocalidade + ";" + chaveElo + ";" + chaveUnidade;

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

					unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(chaveUnidade);
					filtro.setUnidadeNegocio(unidadeNegocio);

				}else if(filtro.getOpcaoTotalizacao() == 13){

					chaveElo = (Integer) objeto[5];
					tipoTotalizacao = "" + chaveElo;

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

				}else if(filtro.getOpcaoTotalizacao() == 14){

					chaveLocalidade = (Integer) objeto[5];
					chaveElo = (Integer) objeto[6];

					tipoTotalizacao = chaveLocalidade + ";" + chaveElo;

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

				}else if(filtro.getOpcaoTotalizacao() == 15){

					chaveSetorComercial = (Integer) objeto[5];
					chaveLocalidade = (Integer) objeto[6];
					chaveElo = (Integer) objeto[7];

					tipoTotalizacao = chaveSetorComercial + ";" + chaveLocalidade + ";" + chaveElo;

					filtro.setCodigoSetorComercial(chaveSetorComercial);

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

					eloPolo = new Localidade();
					eloPolo.setId(chaveElo);
					filtro.setEloPolo(eloPolo);

				}else if(filtro.getOpcaoTotalizacao() == 16){

					chaveLocalidade = (Integer) objeto[5];
					tipoTotalizacao = "" + chaveLocalidade;

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

				}else if(filtro.getOpcaoTotalizacao() == 17){

					chaveSetorComercial = (Integer) objeto[5];
					chaveLocalidade = (Integer) objeto[6];

					tipoTotalizacao = chaveSetorComercial + ";" + chaveLocalidade;

					filtro.setCodigoSetorComercial(chaveSetorComercial);

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

				}else if(filtro.getOpcaoTotalizacao() == 18){

					chaveQuadra = (Integer) objeto[5];
					chaveSetorComercial = (Integer) objeto[6];
					chaveLocalidade = (Integer) objeto[7];

					tipoTotalizacao = chaveQuadra + ";" + chaveSetorComercial + ";" + chaveLocalidade;

					filtro.setNumeroQuadra(chaveQuadra);

					setorComercial = new SetorComercial();
					setorComercial.setId(chaveSetorComercial);
					filtro.setSetorComercial(setorComercial);

					localidade = new Localidade();
					localidade.setId(chaveLocalidade);
					filtro.setLocalidade(localidade);

				}else if(filtro.getOpcaoTotalizacao() == 19){

					chaveSetorComercial = (Integer) objeto[5];
					tipoTotalizacao = "" + chaveSetorComercial;

					setorComercial = new SetorComercial();
					setorComercial.setId(chaveSetorComercial);

					filtro.setSetorComercial(setorComercial);

				}else if(filtro.getOpcaoTotalizacao() == 20){

					chaveQuadra = (Integer) objeto[5];
					chaveSetorComercial = (Integer) objeto[6];

					tipoTotalizacao = chaveQuadra + ";" + chaveSetorComercial;

					filtro.setNumeroQuadra(chaveQuadra);

					setorComercial = new SetorComercial();
					setorComercial.setId(chaveSetorComercial);
					filtro.setSetorComercial(setorComercial);

				}else if(filtro.getOpcaoTotalizacao() == 21){

					chaveQuadra = (Integer) objeto[5];
					tipoTotalizacao = "" + chaveQuadra;

					quadra = new Quadra();
					quadra.setId(chaveQuadra);

					filtro.setQuadra(quadra);

				}

				try{
					Object[] somatorio = this.repositorioFaturamento.pesquisarEmitirHistogramaAguaTotalGeral(filtro, null);

					Categoria categ = new Categoria();
					categ.setId((Integer) objeto[0]);

					Integer quantidadeVolumeMedido = this.repositorioFaturamento.pesquisarEmitirHistogramaAguaVolumeConsumo(filtro,
									ConstantesSistema.INDICADOR_USO_ATIVO, categ, null);

					Integer quantidadeVolumeEstimado = this.repositorioFaturamento.pesquisarEmitirHistogramaAguaVolumeConsumo(filtro,
									ConstantesSistema.INDICADOR_USO_DESATIVO, categ, null);

					if(quantidadeVolumeMedido != null){
						detalhe.setQuantidadeVolumeMedido(quantidadeVolumeMedido);
					}

					if(quantidadeVolumeEstimado != null){
						detalhe.setQuantidadeVolumeEstimado(quantidadeVolumeEstimado);
					}

					BigDecimal percentualParcialLigacao = new BigDecimal(0.0);
					BigDecimal percentualParcialFaturamento = new BigDecimal(0.0);
					BigDecimal percentualParcialConsumo = new BigDecimal(0.0);

					if(((Number) somatorio[0]).intValue() != 0){

						percentualParcialLigacao = Util.calcularPercentualBigDecimal("" + detalhe.getQuantidadeLigacoes(), ""
										+ somatorio[0]);

					}

					if(((Number) somatorio[1]).intValue() != 0){

						percentualParcialConsumo = Util.calcularPercentualBigDecimal("" + detalhe.getQuantidadeVolumeTotal(), ""
										+ somatorio[1]);

					}

					if(((BigDecimal) somatorio[2]).compareTo(new BigDecimal(0.0)) > 0){

						percentualParcialFaturamento = Util.calcularPercentualBigDecimal(detalhe.getValorFaturado(), new BigDecimal(""
										+ somatorio[2]));
					}

					detalhe.setPercentualParcialLigacao(percentualParcialLigacao.doubleValue());
					detalhe.setPercentualParcialConsumo(percentualParcialConsumo.doubleValue());
					detalhe.setPercentualParcialFaturamento(percentualParcialFaturamento.doubleValue());

				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				if(hashMapTotalizacao.get(tipoTotalizacao) != null){

					EmitirHistogramaAguaHelper emitirHistogramaAguaHelper = (EmitirHistogramaAguaHelper) hashMapTotalizacao
									.get(tipoTotalizacao);

					int totalLigacoes = emitirHistogramaAguaHelper.getTotalQuantidadeLigacoes();
					int totalEconomias = emitirHistogramaAguaHelper.getTotalQuantidadeEconomias();
					int volumeEstimado = emitirHistogramaAguaHelper.getTotalQuantidadeVolumeEstimado();
					int volumeMedido = emitirHistogramaAguaHelper.getTotalQuantidadeVolumeMedido();

					BigDecimal totalValorFaturado = emitirHistogramaAguaHelper.getTotalValorFaturado();

					emitirHistogramaAguaHelper.setTotalQuantidadeLigacoes(totalLigacoes + detalhe.getQuantidadeLigacoes());
					emitirHistogramaAguaHelper.setTotalQuantidadeEconomias(totalEconomias + detalhe.getQuantidadeEconomias());
					emitirHistogramaAguaHelper.setTotalValorFaturado(totalValorFaturado.add(detalhe.getValorFaturado()));

					emitirHistogramaAguaHelper.setTotalQuantidadeVolumeMedido(volumeMedido + detalhe.getQuantidadeVolumeMedido());
					emitirHistogramaAguaHelper.setTotalQuantidadeVolumeEstimado(volumeEstimado + detalhe.getQuantidadeVolumeEstimado());

					colecaoEmitirHistogramaAguaDetalhe = emitirHistogramaAguaHelper.getColecaoEmitirHistogramaAguaDetalhe();

					colecaoEmitirHistogramaAguaDetalhe.add(detalhe);
					emitirHistogramaAguaHelper.setColecaoEmitirHistogramaAguaDetalhe(colecaoEmitirHistogramaAguaDetalhe);

					hashMapTotalizacao.put(tipoTotalizacao, emitirHistogramaAguaHelper);

				}else{
					EmitirHistogramaAguaHelper emitirHistogramaAguaHelper = new EmitirHistogramaAguaHelper();
					emitirHistogramaAguaHelper.setDescricaoTitulo("TOTAL GERAL");

					emitirHistogramaAguaHelper.setTotalQuantidadeLigacoes(detalhe.getQuantidadeLigacoes());
					emitirHistogramaAguaHelper.setTotalQuantidadeEconomias(detalhe.getQuantidadeEconomias());
					emitirHistogramaAguaHelper.setTotalQuantidadeVolumeMedido(detalhe.getQuantidadeVolumeMedido());
					emitirHistogramaAguaHelper.setTotalQuantidadeVolumeEstimado(detalhe.getQuantidadeVolumeEstimado());

					emitirHistogramaAguaHelper.setTotalValorFaturado(detalhe.getValorFaturado());

					colecaoEmitirHistogramaAguaDetalhe = new ArrayList();
					colecaoEmitirHistogramaAguaDetalhe.add(detalhe);

					emitirHistogramaAguaHelper.setColecaoEmitirHistogramaAguaDetalhe(colecaoEmitirHistogramaAguaDetalhe);

					hashMapTotalizacao.put(tipoTotalizacao, emitirHistogramaAguaHelper);
				}

			}
		}
		return hashMapTotalizacao;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Total Geral Por Categoria
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param Collection
	 *            <Object[]>
	 * @return HashMap
	 * @throws ControladorException
	 */
	private LinkedHashMap montarEmitirHistogramaAguaTotalGeralCategoria(Collection<EmitirHistogramaAguaDetalheHelper> colecao)
					throws ControladorException{

		LinkedHashMap hashMapTotalizacao = new LinkedHashMap();

		if(colecao != null && !colecao.isEmpty()){

			Iterator iterator = colecao.iterator();

			while(iterator.hasNext()){
				EmitirHistogramaAguaDetalheHelper detalhe = (EmitirHistogramaAguaDetalheHelper) iterator.next();

				Object[] objeto = new Object[3];

				objeto[0] = detalhe.getQuantidadeLigacoes();
				objeto[1] = detalhe.getQuantidadeVolumeTotal();
				objeto[2] = detalhe.getValorFaturado();

				hashMapTotalizacao.put(detalhe.getDescricaoCategoria(), objeto);
			}
		}

		return hashMapTotalizacao;
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Gera as linhas Por Faixa de Consumo
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param Collection
	 *            <Object[]>
	 * @return HashMap
	 * @throws ControladorException
	 */
	private void montarEmitirHistogramaAguaFaixaConsumo(Collection<ConsumoFaixaLigacao> colecao, FiltrarEmitirHistogramaAguaHelper filtro,
					int totalQuantidadeLigacoesTotalGeral, BigDecimal totalValorFaturado, int totalQuantidadeVolumeTotal,
					Collection<EmitirHistogramaAguaHelper> colecaoEmitirHistogramaAgua, String descricaoOpcaoTotalizacao,
					short indicadorMedicao, HashMap mapTotalizacaoGategoria) throws ControladorException{

		// Gera os a linhas com a Faixa (PAI)
		// depois os totalizadores por categoria(FILHO)
		if(colecao != null && !colecao.isEmpty()){

			Collection<Object[]> colecaoRetorno = null;
			EmitirHistogramaAguaHelper emitirTotalizadorIndicador = null;

			String descricaoTitulo = "TOTAL C/HID.";
			if(indicadorMedicao != ConstantesSistema.INDICADOR_USO_ATIVO.shortValue()){
				descricaoTitulo = "TOTAL S/HID.";
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(filtro.retornaOLimiteConsultaTotal(indicadorMedicao));
				filtro.setConsumoFaixaLigacaoIntervaloMedido(null);
			}else{
				filtro.setConsumoFaixaLigacaoIntervaloNaoMedido(null);
				filtro.setConsumoFaixaLigacaoIntervaloMedido(filtro.retornaOLimiteConsultaTotal(indicadorMedicao));
			}

			try{

				filtro.setConsumoFaixaLigacao(null);

				filtro.setMedicao(indicadorMedicao);

				colecaoRetorno = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

				filtro.setMedicao(null);

				emitirTotalizadorIndicador = this.montarEmitirHistogramaAguaDetalhe(colecaoRetorno, descricaoTitulo, filtro,
								descricaoOpcaoTotalizacao, totalQuantidadeLigacoesTotalGeral, totalValorFaturado,
								totalQuantidadeVolumeTotal, indicadorMedicao, mapTotalizacaoGategoria, null, null);

			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			if(emitirTotalizadorIndicador != null){

				// chave(Id categoria),valores(BigDecimal[3] percentuais)
				LinkedHashMap mapPercentualParcialPorCategoriaAnterior = new LinkedHashMap();
				LinkedHashMap mapPercentualParcialPorTotalAnterior = new LinkedHashMap();

				filtro.setMedicao(indicadorMedicao);

				Iterator itera = colecao.iterator();
				while(itera.hasNext()){
					ConsumoFaixaLigacao consumo = (ConsumoFaixaLigacao) itera.next();

					filtro.setConsumoFaixaLigacao(consumo);

					try{
						descricaoTitulo = consumo.getNumeroFaixaInicio() + " a " + consumo.getNumeroFaixaFim();

						colecaoRetorno = this.repositorioFaturamento.pesquisarEmitirHistogramaAgua(filtro);

						EmitirHistogramaAguaHelper emitirFaixa = this.montarEmitirHistogramaAguaDetalhe(colecaoRetorno, descricaoTitulo,
										filtro, descricaoOpcaoTotalizacao, emitirTotalizadorIndicador.getTotalQuantidadeLigacoes(),
										emitirTotalizadorIndicador.getTotalValorFaturado(),
										emitirTotalizadorIndicador.getTotalQuantidadeVolumeTotal(), indicadorMedicao, null,
										mapPercentualParcialPorCategoriaAnterior, mapPercentualParcialPorTotalAnterior);

						if(emitirFaixa != null){
							colecaoEmitirHistogramaAgua.add(emitirFaixa);
						}

					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				}
				if(emitirTotalizadorIndicador != null){
					colecaoEmitirHistogramaAgua.add(emitirTotalizadorIndicador);
				}

			}// fim do emitir totalizador
		}
	}

	/**
	 * [UC0600] Emitir Histograma de Água
	 * Linha Faixa
	 * 
	 * @author Rafael Pinto
	 * @date 04/06/2007
	 * @param Collection
	 *            <Object[]>
	 * @return EmitirHistogramaAguaHelper
	 * @throws ControladorException
	 */
	private EmitirHistogramaAguaHelper montarEmitirHistogramaAguaDetalhe(Collection<Object[]> colecao, String descricaoTitulo,
					FiltrarEmitirHistogramaAguaHelper filtro, String descricaoOpcaoTotalizacao, int quantidadeLigacaoIndicador,
					BigDecimal valorFaturado, int totalQuantidadeVolumeTotal, short indicadorHidrometro, HashMap mapTotalizacaoGategoria,
					LinkedHashMap mapPercentualParcialPorCategoriaAnterior, LinkedHashMap mapPercentualParcialPorTotalAnterior)
					throws ControladorException{

		EmitirHistogramaAguaHelper emitirHistogramaAguaHelper = null;
		if(colecao != null && !colecao.isEmpty()){

			Iterator iterator = colecao.iterator();

			Collection<EmitirHistogramaAguaDetalheHelper> colecaoEmitirHistogramaAguaDetalhe = new ArrayList();

			EmitirHistogramaAguaDetalheHelper detalhe = null;

			int totalLigacoes = 0;
			int totalEconomias = 0;
			int volumeMedido = 0;
			int volumeEstimado = 0;

			BigDecimal totalValorFaturado = new BigDecimal("0.0");

			while(iterator.hasNext()){
				Object[] objeto = (Object[]) iterator.next();

				detalhe = new EmitirHistogramaAguaDetalheHelper();

				detalhe.setDescricaoCategoria((String) objeto[1]);
				if(objeto[2] != null){
					Number quantidadeLigacoes = (Number) objeto[2];
					detalhe.setQuantidadeLigacoes(quantidadeLigacoes.intValue());
				}

				if(objeto[3] != null){
					Number quantidadeEconomias = (Number) objeto[3];
					detalhe.setQuantidadeEconomias(quantidadeEconomias.intValue());
				}

				detalhe.setValorFaturado((BigDecimal) objeto[4]);

				try{

					Categoria categ = new Categoria();
					categ.setId((Integer) objeto[0]);
					Object[] somatorio = null;

					if(mapTotalizacaoGategoria != null){
						somatorio = (Object[]) mapTotalizacaoGategoria.get(detalhe.getDescricaoCategoria());
					}else{
						somatorio = this.repositorioFaturamento.pesquisarEmitirHistogramaAguaTotalGeral(filtro, categ);
					}

					if(somatorio == null){
						somatorio = new Object[3];
						somatorio[0] = 0;
						somatorio[1] = 0;
						somatorio[2] = new BigDecimal(0.0);
					}

					BigDecimal percentualParcialLigacao = new BigDecimal(0.0);
					BigDecimal percentualParcialFaturamento = new BigDecimal(0.0);
					BigDecimal percentualParcialConsumo = new BigDecimal(0.0);

					if(((Number) somatorio[0]).intValue() != 0){

						percentualParcialLigacao = Util.calcularPercentualBigDecimal("" + detalhe.getQuantidadeLigacoes(), ""
										+ somatorio[0]);

					}

					detalhe.setPercentualParcialLigacao(percentualParcialLigacao.doubleValue());

					if(((BigDecimal) somatorio[2]).compareTo(new BigDecimal(0.0)) > 0){

						percentualParcialFaturamento = Util.calcularPercentualBigDecimal(detalhe.getValorFaturado(), new BigDecimal(""
										+ somatorio[2]));
					}

					detalhe.setPercentualParcialFaturamento(percentualParcialFaturamento.doubleValue());

					if(indicadorHidrometro == ConstantesSistema.INDICADOR_USO_ATIVO.shortValue()){

						Integer quantidadeVolumeMedido = this.repositorioFaturamento.pesquisarEmitirHistogramaAguaVolumeConsumo(filtro,
										ConstantesSistema.INDICADOR_USO_ATIVO, categ, indicadorHidrometro);

						Integer quantidadeVolumeEstimado = this.repositorioFaturamento.pesquisarEmitirHistogramaAguaVolumeConsumo(filtro,
										ConstantesSistema.INDICADOR_USO_DESATIVO, categ, indicadorHidrometro);

						if(quantidadeVolumeMedido != null){
							detalhe.setQuantidadeVolumeMedido(quantidadeVolumeMedido);
						}
						if(quantidadeVolumeEstimado != null){
							detalhe.setQuantidadeVolumeEstimado(quantidadeVolumeEstimado);
						}

					}else{
						Integer quantidadeVolumeEstimado = this.repositorioFaturamento.pesquisarEmitirHistogramaAguaVolumeConsumo(filtro,
										ConstantesSistema.INDICADOR_USO_DESATIVO, categ, indicadorHidrometro);

						if(quantidadeVolumeEstimado != null){
							detalhe.setQuantidadeVolumeEstimado(quantidadeVolumeEstimado);
						}
					}

					if(((Number) somatorio[1]).intValue() != 0){

						percentualParcialConsumo = Util.calcularPercentualBigDecimal("" + detalhe.getQuantidadeVolumeTotal(), ""
										+ somatorio[1]);
					}

					detalhe.setPercentualParcialConsumo(percentualParcialConsumo.doubleValue());

					if(mapPercentualParcialPorCategoriaAnterior != null){

						BigDecimal[] valoresPercentual = (BigDecimal[]) mapPercentualParcialPorCategoriaAnterior.get(categ.getId());

						BigDecimal percentualAcumuladoLigacao = new BigDecimal(0.0);
						BigDecimal percentualAcumuladoConsumo = new BigDecimal(0.0);
						BigDecimal percentualAcumuladoFaturamento = new BigDecimal(0.0);

						if(valoresPercentual != null){

							percentualAcumuladoLigacao = percentualParcialLigacao.add(valoresPercentual[0]);
							percentualAcumuladoConsumo = percentualParcialConsumo.add(valoresPercentual[1]);
							percentualAcumuladoFaturamento = percentualParcialFaturamento.add(valoresPercentual[2]);

						}else{

							percentualAcumuladoLigacao = percentualParcialLigacao;
							percentualAcumuladoConsumo = percentualParcialConsumo;
							percentualAcumuladoFaturamento = percentualParcialFaturamento;

						}

						detalhe.setPercentualAcumuladoLigacao(percentualAcumuladoLigacao.doubleValue());
						detalhe.setPercentualAcumuladoConsumo(percentualAcumuladoConsumo.doubleValue());
						detalhe.setPercentualAcumuladoFaturamento(percentualAcumuladoFaturamento.doubleValue());

						valoresPercentual = new BigDecimal[3];

						valoresPercentual[0] = percentualAcumuladoLigacao;
						valoresPercentual[1] = percentualAcumuladoConsumo;
						valoresPercentual[2] = percentualAcumuladoFaturamento;

						mapPercentualParcialPorCategoriaAnterior.put(categ.getId(), valoresPercentual);

					}

				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				totalLigacoes += detalhe.getQuantidadeLigacoes();
				totalEconomias += detalhe.getQuantidadeEconomias();
				volumeMedido += detalhe.getQuantidadeVolumeMedido();
				volumeEstimado += detalhe.getQuantidadeVolumeEstimado();
				totalValorFaturado = totalValorFaturado.add(detalhe.getValorFaturado());

				colecaoEmitirHistogramaAguaDetalhe.add(detalhe);

			}

			emitirHistogramaAguaHelper = new EmitirHistogramaAguaHelper();
			emitirHistogramaAguaHelper.setOpcaoTotalizacao(descricaoOpcaoTotalizacao);
			emitirHistogramaAguaHelper.setDescricaoTitulo(descricaoTitulo);
			emitirHistogramaAguaHelper.setColecaoEmitirHistogramaAguaDetalhe(colecaoEmitirHistogramaAguaDetalhe);
			emitirHistogramaAguaHelper.setTotalQuantidadeLigacoes(totalLigacoes);
			emitirHistogramaAguaHelper.setTotalQuantidadeEconomias(totalEconomias);
			emitirHistogramaAguaHelper.setTotalQuantidadeVolumeMedido(volumeMedido);
			emitirHistogramaAguaHelper.setTotalQuantidadeVolumeEstimado(volumeEstimado);
			emitirHistogramaAguaHelper.setTotalValorFaturado(totalValorFaturado);

			BigDecimal percentualParcialLigacao = new BigDecimal(0.0);
			BigDecimal percentualParcialFaturamento = new BigDecimal(0.0);
			BigDecimal percentualParcialConsumo = new BigDecimal(0.0);

			if(quantidadeLigacaoIndicador != 0){

				percentualParcialLigacao = Util.calcularPercentualBigDecimal("" + emitirHistogramaAguaHelper.getTotalQuantidadeLigacoes(),
								"" + quantidadeLigacaoIndicador);
			}

			if(totalQuantidadeVolumeTotal != 0){

				percentualParcialConsumo = Util.calcularPercentualBigDecimal(
								"" + emitirHistogramaAguaHelper.getTotalQuantidadeVolumeTotal(), "" + totalQuantidadeVolumeTotal);

			}

			if(valorFaturado.compareTo(new BigDecimal(0.0)) > 0){

				percentualParcialFaturamento = Util.calcularPercentualBigDecimal(emitirHistogramaAguaHelper.getTotalValorFaturado(),
								valorFaturado);
			}

			emitirHistogramaAguaHelper.setTotalPercentualParcialLigacao(percentualParcialLigacao.doubleValue());
			emitirHistogramaAguaHelper.setTotalPercentualParcialConsumo(percentualParcialConsumo.doubleValue());
			emitirHistogramaAguaHelper.setTotalPercentualParcialFaturamento(percentualParcialFaturamento.doubleValue());

			if(mapPercentualParcialPorTotalAnterior != null){

				BigDecimal[] valoresPercentual = (BigDecimal[]) mapPercentualParcialPorTotalAnterior.get("TOTAL");

				BigDecimal percentualAcumuladoLigacao = new BigDecimal(0.0);
				BigDecimal percentualAcumuladoConsumo = new BigDecimal(0.0);
				BigDecimal percentualAcumuladoFaturamento = new BigDecimal(0.0);

				if(valoresPercentual != null){

					percentualAcumuladoLigacao = percentualParcialLigacao.add(valoresPercentual[0]);
					percentualAcumuladoConsumo = percentualParcialConsumo.add(valoresPercentual[1]);
					percentualAcumuladoFaturamento = percentualParcialFaturamento.add(valoresPercentual[2]);

				}else{

					percentualAcumuladoLigacao = percentualParcialLigacao;
					percentualAcumuladoConsumo = percentualParcialConsumo;
					percentualAcumuladoFaturamento = percentualParcialFaturamento;

				}

				emitirHistogramaAguaHelper.setTotalPercentualAcumuladoLigacao(percentualAcumuladoLigacao.doubleValue());
				emitirHistogramaAguaHelper.setTotalPercentualAcumuladoConsumo(percentualAcumuladoConsumo.doubleValue());
				emitirHistogramaAguaHelper.setTotalPercentualAcumuladoFaturamento(percentualAcumuladoFaturamento.doubleValue());

				valoresPercentual = new BigDecimal[3];

				valoresPercentual[0] = percentualAcumuladoLigacao;
				valoresPercentual[1] = percentualAcumuladoConsumo;
				valoresPercentual[2] = percentualAcumuladoFaturamento;

				mapPercentualParcialPorTotalAnterior.put("TOTAL", valoresPercentual);

			}

		}

		return emitirHistogramaAguaHelper;
	}

	/**
	 * Inseri o tipo de debito na base
	 * [UC0529] Inserir Tipo de Débito
	 * 
	 * @author Rômulo Aurélio
	 * @date 09/03/2007
	 * @author eduardo henrique
	 * @date 08/07/2008 Adição dos atributos indicadorInicidenciaMulta e
	 *       indicadorIncidenciaJurosMora
	 * @param debitoTipo
	 * @param usuarioLogado
	 * @param valorLimeteDebito
	 * @return
	 */

	public Integer inserirDebitoTipo(DebitoTipo debitoTipo, Usuario usuarioLogado) throws ControladorException{

		Integer retorno = null;

		if(debitoTipo.getDescricao() == null || debitoTipo.getDescricao().equalsIgnoreCase("")){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Descrição do Tipo de Débito");
		}

		if(debitoTipo.getFinanciamentoTipo() == null){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Tipo de Financiamento");
		}

		if(debitoTipo.getIndicadorGeracaoAutomatica() == null || debitoTipo.getIndicadorGeracaoAutomatica().shortValue() <= 0){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Indicador de Geração do Débito Automática");
		}

		if(debitoTipo.getIndicadorGeracaoConta() == null || debitoTipo.getIndicadorGeracaoConta().shortValue() <= 0){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Indicador de Geração do Débito em Conta");
		}

		if(debitoTipo.getLancamentoItemContabil() == null){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Tipo do Lançamento do Item Contábil");
		}

		if(debitoTipo.getValorLimite() == null || debitoTipo.getValorLimite().doubleValue() < 0.00){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Valor Limite do Débito");
		}

		if(debitoTipo.getIndicadorIncidenciaMulta() == null || debitoTipo.getIndicadorIncidenciaMulta().shortValue() <= 0){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Indicador de Incidência de Multa");
		}

		if(debitoTipo.getIndicadorIncidenciaJurosMora() == null || debitoTipo.getIndicadorIncidenciaJurosMora().shortValue() <= 0){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Indicador de Incidência de Juros Mora");
		}

		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();

		// verifica se ja existe a descricao informada na base e exibe uma
		// critica.

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.DESCRICAO, debitoTipo.getDescricao()));

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO, ConstantesSistema.INDICADOR_USO_ATIVO));

		Collection colecaoDebitoTipoDescricao = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

		if(colecaoDebitoTipoDescricao != null && !colecaoDebitoTipoDescricao.isEmpty()){
			throw new ControladorException("atencao.descricao_tipo_debito_ja_existente", null, "" + debitoTipo.getDescricao() + "");
		}

		// verifica se ja existe a descricaoAbreviada informada na base e exibe
		// uma
		// critica.
		if(debitoTipo.getDescricaoAbreviada() != null){

			if(!debitoTipo.getDescricaoAbreviada().equalsIgnoreCase("")){
				filtroDebitoTipo.limparListaParametros();

				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.DESCRICAO_ABREVIADA, debitoTipo
								.getDescricaoAbreviada()));

				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));

				Collection colecaoDebitoTipoDescricaoAbreviada = getControladorUtil().pesquisar(filtroDebitoTipo,
								DebitoTipo.class.getName());

				if(colecaoDebitoTipoDescricaoAbreviada != null && !colecaoDebitoTipoDescricaoAbreviada.isEmpty()){
					throw new ControladorException("atencao.descricao_abreviada_tipo_debito_ja_existente", null, ""
									+ debitoTipo.getDescricaoAbreviada() + "");
				}
			}
		}
		// ------------ REGISTRAR TRANSação----------------------------

		/*
		 * RegistradorOperacao registradorOperacao = new RegistradorOperacao(
		 * Operacao.OPERACAO_TIPO_DEBITO_INSERIR, new
		 * UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		 * Operacao operacao = new Operacao();
		 * operacao.setId(Operacao.OPERACAO_TIPO_DEBITO_INSERIR);
		 * OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		 * operacaoEfetuada.setOperacao(operacao);
		 * debitoTipo.setOperacaoEfetuada(operacaoEfetuada);
		 * debitoTipo.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		 * registradorOperacao.registrarOperacao(debitoTipo);
		 */
		// --------FIM---- REGISTRAR TRANSação----------------------------
		retorno = (Integer) getControladorUtil().inserir(debitoTipo);

		return retorno;

	}

	/**
	 * Atualizar o tipo de debito na base
	 * [UC0530] Atualizar Tipo de Débito
	 * 
	 * @author Rômulo Aurélio
	 * @date 15/03/2007
	 * @author eduardo henrique
	 * @date 09/07/2008
	 * @param debitoTipo
	 * @param usuarioLogado
	 * @return
	 */

	public void atualizarDebitoTipo(DebitoTipo debitoTipo, Usuario usuarioLogado) throws ControladorException{

		if(debitoTipo.getDescricao() == null || debitoTipo.getDescricao().equalsIgnoreCase("")){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Descrição do Tipo de Débito");
		}

		if(debitoTipo.getFinanciamentoTipo() == null){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Tipo de Financiamento");
		}

		if(debitoTipo.getIndicadorGeracaoAutomatica() == null || debitoTipo.getIndicadorGeracaoAutomatica().shortValue() <= 0){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Indicador de Geração do Débito Automática");
		}

		if(debitoTipo.getIndicadorGeracaoConta() == null || debitoTipo.getIndicadorGeracaoConta().shortValue() <= 0){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Indicador de Geração do Débito em Conta");
		}

		if(debitoTipo.getIndicadorIncidenciaJurosMora() == null || debitoTipo.getIndicadorIncidenciaJurosMora().shortValue() <= 0){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Indicador de Incidência de Juros de Mora");
		}

		if(debitoTipo.getIndicadorIncidenciaMulta() == null || debitoTipo.getIndicadorIncidenciaMulta().shortValue() <= 0){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Indicador de Incidência de Juros de Mora");
		}

		if(debitoTipo.getLancamentoItemContabil() == null){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Tipo do Lançamento do Item Contábil");
		}

		if(debitoTipo.getValorLimite() == null || debitoTipo.getValorLimite().doubleValue() < 0.00){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Valor Limite do Débito");
		}

		FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();

		// verifica se ja existe a descricao informada na base e exibe uma
		// critica.

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.DESCRICAO, debitoTipo.getDescricao()));

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO, ConstantesSistema.INDICADOR_USO_ATIVO));

		filtroDebitoTipo.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroDebitoTipo.ID, debitoTipo.getId()));

		Collection colecaoDebitoTipoDescricao = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

		if(colecaoDebitoTipoDescricao != null && !colecaoDebitoTipoDescricao.isEmpty()){
			throw new ControladorException("atencao.descricao_tipo_debito_ja_existente", null, "" + debitoTipo.getDescricao() + "");
		}

		// verifica se ja existe a descricaoAbreviada informada na base e exibe
		// uma
		// critica.
		if(debitoTipo.getDescricaoAbreviada() != null){

			if(!debitoTipo.getDescricaoAbreviada().equalsIgnoreCase("")){
				filtroDebitoTipo.limparListaParametros();

				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.DESCRICAO_ABREVIADA, debitoTipo
								.getDescricaoAbreviada()));

				filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));

				filtroDebitoTipo.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroDebitoTipo.ID, debitoTipo.getId()));

				Collection colecaoDebitoTipoDescricaoAbreviada = getControladorUtil().pesquisar(filtroDebitoTipo,
								DebitoTipo.class.getName());

				if(colecaoDebitoTipoDescricaoAbreviada != null && !colecaoDebitoTipoDescricaoAbreviada.isEmpty()){

					throw new ControladorException("atencao.descricao_abreviada_tipo_debito_ja_existente", null, ""
									+ debitoTipo.getDescricaoAbreviada() + "");
				}
			}
		}

		// Verifica Atualização realizada por outro usuário

		filtroDebitoTipo.limparListaParametros();

		filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, debitoTipo.getId()));

		Collection colecaoDebitoTipoBase = getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

		if(colecaoDebitoTipoBase == null || colecaoDebitoTipoBase.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		DebitoTipo debitoTipoBase = (DebitoTipo) colecaoDebitoTipoBase.iterator().next();

		if(debitoTipoBase.getUltimaAlteracao().after(debitoTipo.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		debitoTipo.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSação----------------------------

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_TIPO_DEBITO_ATUALIZAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_TIPO_DEBITO_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		debitoTipo.setOperacaoEfetuada(operacaoEfetuada);
		debitoTipo.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(debitoTipo);

		// --------FIM---- REGISTRAR TRANSação----------------------------
		getControladorUtil().atualizar(debitoTipo);

	}

	/**
	 * Determina qual a menor datade vencimento para uma coleção de contas
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 19/06/2007
	 * @param colecaoContas
	 * @return
	 * @throws ControladorException
	 */
	public Date determinarMenorDataVencimentoConta(Collection colecaoContas) throws ControladorException{

		Date dataVencimentoConta = null;
		if(colecaoContas != null && !colecaoContas.isEmpty()){
			Iterator<Conta> iteratorContas = colecaoContas.iterator();

			while(iteratorContas.hasNext()){
				Conta conta = iteratorContas.next();

				if(dataVencimentoConta == null){
					dataVencimentoConta = conta.getDataVencimentoConta();
				}else{
					if(dataVencimentoConta.compareTo(conta.getDataVencimentoConta()) > 0){
						dataVencimentoConta = conta.getDataVencimentoConta();
					}
				}
			}
		}
		return dataVencimentoConta;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar Relatório de Resumo
	 * Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 18/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioEstadoPorUnidadeNegocio(int anoMesReferencia) throws ControladorException{

		Collection colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio = new ArrayList();
		Collection retorno = new ArrayList();

		try{
			colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio = repositorioFaturamento
							.consultarResumoFaturamentoRelatorioEstadoPorUnidadeNegocio(anoMesReferencia);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio.iterator();

		// Prepara cada linha do relatório
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while(iterator.hasNext()){
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if(tipoLancamento == null){
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if(tipoLancamento.equals(tempTipoLancamento) && itemLancamento.equals(tempItemLancamento)){

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if(itemContabel == null && tempItemContabel == null
								|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

					// se for agrupado por gerencia
					// compara se o registro atual eh da
					// mesma gerencia regional do registro anterior

					switch(((Integer) element[8]).intValue()){
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
					}

				}else{

					condicaoIgual = false;
				}

			}else{

				condicaoIgual = false;

			}

			if(!condicaoIgual){

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
								(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
								(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
								(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

				retorno.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch(((Integer) element[8]).intValue()){
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
				}

			}

			if(idGerenciaRegionalAnterior != null && !idGerenciaRegionalAnterior.equals("" + element[14])){
				// quebra por gerencia
				retorno = consultarResumoFaturamentoRelatorioPorGerenciaRegional(anoMesReferencia,
								Integer.valueOf(idGerenciaRegionalAnterior), retorno);
			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if(((String) element[1]).equalsIgnoreCase((String) element[2])){
				elementAnterior[2] = null; // descricaoItemLancamento
			}else{
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			descUnidadeNegocioAnterior = "" + element[9];
			idUnidadeNegocioAnterior = "" + element[10];

			descGerenciaRegionalAnterior = "" + element[13];
			idGerenciaRegionalAnterior = "" + element[14];

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if(colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio != null
						&& !colecaoResumoFaturamentoRelatorioEstadoPorUnidadeNegocio.isEmpty()){
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
							(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
							(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
							(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

			retorno.add(resumoFaturamentoRelatorioHelper);

			retorno = consultarResumoFaturamentoRelatorioPorGerenciaRegional(anoMesReferencia, Integer.valueOf(idGerenciaRegionalAnterior),
							retorno);

		}

		return retorno;

	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0173] Gerar Relatório de Resumo
	 * Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 18/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorGerenciaRegional(int anoMesReferencia, Integer idGerenciaRegional,
					Collection colecaoResumoFaturamentoRelatorio) throws ControladorException{

		Collection colecaoResumoFaturamentoRelatorioPorGerenciaRegional = new ArrayList();

		try{
			colecaoResumoFaturamentoRelatorioPorGerenciaRegional = repositorioFaturamento
							.consultarResumoFaturamentoRelatorioPorGerenciaRegional(anoMesReferencia, idGerenciaRegional);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iteratorResumoFaturamentoRelatorioPorGerenciaRegional = colecaoResumoFaturamentoRelatorioPorGerenciaRegional.iterator();

		// Prepara cada linha do relatório
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		Boolean agrupaPorGerencia = true;

		while(iteratorResumoFaturamentoRelatorioPorGerenciaRegional.hasNext()){
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iteratorResumoFaturamentoRelatorioPorGerenciaRegional.next();

			if(tipoLancamento == null){
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if(tipoLancamento.equals(tempTipoLancamento) && itemLancamento.equals(tempItemLancamento)){

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if(itemContabel == null && tempItemContabel == null
								|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

					// se for agrupado por gerencia
					// compara se o registro atual eh da
					// mesma gerencia regional do registro anterior
					if(!agrupaPorGerencia || descGerenciaRegionalAnterior == null
									|| (agrupaPorGerencia && descGerenciaRegionalAnterior.equalsIgnoreCase((String) element[9]))){

						switch(((Integer) element[8]).intValue()){
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
						}
					}else{
						condicaoIgual = false;
					}

				}else{

					condicaoIgual = false;
				}

			}else{

				condicaoIgual = false;

			}

			if(!condicaoIgual){

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
								(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
								(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
								(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

				colecaoResumoFaturamentoRelatorio.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch(((Integer) element[8]).intValue()){
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if(((String) element[1]).equalsIgnoreCase((String) element[2])){
				elementAnterior[2] = null; // descricaoItemLancamento
			}else{
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			descGerenciaRegionalAnterior = "" + element[9];
			idGerenciaRegionalAnterior = "" + element[10];

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if(colecaoResumoFaturamentoRelatorioPorGerenciaRegional != null && !colecaoResumoFaturamentoRelatorioPorGerenciaRegional.isEmpty()){
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
							(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
							(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
							(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

			colecaoResumoFaturamentoRelatorio.add(resumoFaturamentoRelatorioHelper);
		}

		return colecaoResumoFaturamentoRelatorio;

	}

	/**
	 * <p>
	 * [OC1348276] [NF] Refaturar todas as contas da localidade 062 com referência de 10/2009 a
	 * 08/2014
	 * </p>
	 * <p>
	 * Refaturar todas as contas geradas para o municipio de Siriri, para atendermos ao trabalho que
	 * a Deso está desenvolvendo naquele município e a RDE 12/2014. Parâmetros:
	 * <ul>
	 * <li>Localidade: 062</li>
	 * <li>Período de referência das faturas: 10/2009 a 08/2014</li>
	 * <li>Refaturar consumo de todas as matrículas de categoria Residencial e Comercial para 10m³ e
	 * categoria Industrial para 30m³</li>
	 * </ul>
	 * </p>
	 * 
	 * @author Magno Silveira { @literal <magno.silveira@procenge.com.br> }
	 * @since 2014-09-02
	 * @param anoMesReferenciaInicial
	 * @param anoMesReferenciaFinal
	 * @throws ControladorException
	 */
	public void refaturarContasDESOLocalidade062(Integer anoMesReferencia) throws ControladorException{

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.refaturarContasDESOLocalidade062(anoMesReferencia);

		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * Remove os contratos de demanda selecionados pelo usuário
	 * [UC0513] - Manter Contrato de Demanda
	 * 
	 * @author Rafael Corrêa
	 * @date 27/06/2007
	 * @param idsContratosDemanda
	 * @throws ControladorException
	 */
	public void removerContratosDemanda(String[] idsContratosDemanda, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONTRATO_DEMANDA_REMOVER,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CONTRATO_DEMANDA_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		if(idsContratosDemanda != null && idsContratosDemanda.length > 0){
			for(int i = 0; i < idsContratosDemanda.length; i++){
				String idContratoDemanda = idsContratosDemanda[i];

				// Cria o filtro de equipe para verificar se a equipe ja foi
				// removida
				FiltroContratoDemanda filtroContratoDemanda = new FiltroContratoDemanda();

				filtroContratoDemanda.adicionarParametro(new ParametroSimples(FiltroContratoDemanda.ID, idContratoDemanda));

				Collection colecaoContratoDemanda = getControladorUtil().pesquisar(filtroContratoDemanda, ContratoDemanda.class.getName());

				if(colecaoContratoDemanda != null && !colecaoContratoDemanda.isEmpty()){

					ContratoDemanda contratoDemanda = (ContratoDemanda) Util.retonarObjetoDeColecao(colecaoContratoDemanda);

					// ------------ REGISTRAR TRANSAÇÃO ----------------
					contratoDemanda.setOperacaoEfetuada(operacaoEfetuada);
					contratoDemanda.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					registradorOperacao.registrarOperacao(contratoDemanda);
					// ------------ REGISTRAR TRANSAÇÃO ----------------

					getControladorUtil().remover(contratoDemanda);

				}else{
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.registro_remocao_nao_existente");
				}

			}
		}
	}

	/**
	 * Obter a data de vencimento de um grupo de faturamento, no mês de faturamento corrente.
	 * [UC0618] Obter data de vencimento do grupo
	 * 
	 * @author Pedro Alexandre
	 * @date 26/06/2007
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ControladorException
	 */
	public Date obterDataVencimentoGrupo(Integer idFaturamentoGrupo, Integer anoMesReferencia) throws ControladorException{

		SimpleDateFormat formatoData = new SimpleDateFormat("dd/MM/yyyy");
		Date retorno = null;

		// Recupera o grupo de faturamento informado
		FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
		filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, idFaturamentoGrupo));
		Collection colecaoFaturamentoGrupo = getControladorUtil().pesquisar(filtroFaturamentoGrupo, FaturamentoGrupo.class.getName());
		FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) Util.retonarObjetoDeColecao(colecaoFaturamentoGrupo);

		/**
		 * Caso o indicador de que o vencimento do grupo é igual ao ano/mês do faturamento
		 * corresponda a SIM, formatar a data de vencimento a partir
		 * do ano/mês de referência do faturamento e do dia de vencimento do grupo. Caso contrário ,
		 * formatar a apartir do mês seguinte ao mês de
		 * referência do faturamento e do dia de vencimento do grupo.
		 */
		if(faturamentoGrupo.getIndicadorVencimentoMesFatura().equals(ConstantesSistema.INDICADOR_VENCIMENTO_GRUPO_REFERENCIA_POSTERIOR)){
			anoMesReferencia = Util.somaMesAnoMesReferencia(anoMesReferencia, 1);
		}else if(faturamentoGrupo.getIndicadorVencimentoMesFatura()
						.equals(ConstantesSistema.INDICADOR_VENCIMENTO_GRUPO_REFERENCIA_ANTERIOR)){
			anoMesReferencia = Util.subtrairMesDoAnoMes(anoMesReferencia.intValue(), 1);
		}

		try{
			// Recupera o dia de vencimento do grupo
			int diaVencimento = Integer.valueOf(faturamentoGrupo.getDiaVencimento());
			String mesVencimento = String.valueOf(anoMesReferencia).substring(4, 6);
			String anoVencimento = String.valueOf(anoMesReferencia).substring(0, 4);

			retorno = formatoData.parse(diaVencimento + "/" + mesVencimento + "/" + anoVencimento);
			
		}catch(ParseException ex){
			throw new ControladorException("errors.date", null, "Data vencimento");
		}

		return retorno;
	}

	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * 
	 * @author Raphael Rossiter
	 * @date 29/06/2007
	 * @param consumoTarifa
	 * @param dataFaturamento
	 * @throws ErroRepositorioException
	 */
	public ConsumoTarifaVigencia pesquisarConsumoTarifaVigenciaMenorOUIgualDataFaturamento(Integer idConsumoTarifa, Date dataFaturamento)
					throws ControladorException{

		ConsumoTarifaVigencia consumoTarifaVigencia = null;

		try{

			consumoTarifaVigencia = repositorioFaturamento.pesquisarConsumoTarifaVigenciaMenorOUIgualDataFaturamento(idConsumoTarifa,
							dataFaturamento);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return consumoTarifaVigencia;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0345] Gerar Relatório de Resumo
	 * Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstadoPorLocalidade(int anoMesReferencia) throws ControladorException{

		Collection colecaoResumoFaturamentoRelatorioEstadoPorLocalidade = new ArrayList();
		Collection retorno = new ArrayList();

		try{
			colecaoResumoFaturamentoRelatorioEstadoPorLocalidade = repositorioFaturamento
							.consultarResumoFaturamentoRelatorioPorEstadoPorLocalidade(anoMesReferencia);

			if(colecaoResumoFaturamentoRelatorioEstadoPorLocalidade != null
							&& !colecaoResumoFaturamentoRelatorioEstadoPorLocalidade.isEmpty()){

				Iterator iterator = colecaoResumoFaturamentoRelatorioEstadoPorLocalidade.iterator();

				// Prepara cada linha do relatório

				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String idLocalidadeAnterior = null;
				String descLancamentoTipoSuperior = "";

				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				while(iterator.hasNext()){
					Object[] element = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;

					element = (Object[]) iterator.next();

					if(tipoLancamento == null){
						tipoLancamento = (String) element[1];
						itemLancamento = (String) element[2];
						itemContabel = (String) element[3];
					}

					tempTipoLancamento = (String) element[1];
					tempItemLancamento = (String) element[2];
					tempItemContabel = (String) element[3];

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if(tipoLancamento.equals(tempTipoLancamento) && itemLancamento.equals(tempItemLancamento)){

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if(itemContabel == null && tempItemContabel == null
										|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

							switch(((Integer) element[8]).intValue()){
								case 1:
									arrayValores[0] = (BigDecimal) element[0];
									break;
								case 2:
									arrayValores[1] = (BigDecimal) element[0];
									break;
								case 3:
									arrayValores[2] = (BigDecimal) element[0];
									break;
								case 4:
									arrayValores[4] = (BigDecimal) element[0];
									break;
							}

						}else{

							condicaoIgual = false;
						}

					}else{

						condicaoIgual = false;

					}

					if(!condicaoIgual){

						ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
										(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
										(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
										(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
										idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior,
										descLancamentoTipoSuperior, descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

						retorno.add(resumoFaturamentoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch(((Integer) element[8]).intValue()){
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
						}

					}

					if(idUnidadeNegocioAnterior != null && !idUnidadeNegocioAnterior.equals("" + element[16])){
						// quebra por Unidade Negocio
						retorno = consultarResumoFaturamentoRelatorioPorUnidadeNegocio(anoMesReferencia,
										Integer.valueOf(idUnidadeNegocioAnterior), retorno);

					}

					if(idGerenciaRegionalAnterior != null && !idGerenciaRegionalAnterior.equals("" + element[10])){
						// quebra por gerencia
						retorno = consultarResumoFaturamentoRelatorioPorGerenciaRegional(anoMesReferencia,
										Integer.valueOf(idGerenciaRegionalAnterior), retorno);

					}

					elementAnterior[1] = element[1]; // descricaoTipoLancamento
					if(((String) element[1]).equalsIgnoreCase((String) element[2])){
						elementAnterior[2] = null; // descricaoItemLancamento
					}else{
						elementAnterior[2] = element[2]; // descricaoItemLancamento
					}

					elementAnterior[3] = element[3]; // descricaoItemContabil
					elementAnterior[4] = element[4]; // indicadorImpressao
					elementAnterior[5] = element[5]; // indicadorTotal
					elementAnterior[6] = element[6]; // lancamentoTipo
					elementAnterior[7] = element[7]; // lancamentoTipoSuperior

					descGerenciaRegionalAnterior = "" + element[9];
					idGerenciaRegionalAnterior = "" + element[10];
					descLocalidadeAnterior = "" + element[11];
					idLocalidadeAnterior = "" + element[12];
					descUnidadeNegocioAnterior = "" + element[15];
					idUnidadeNegocioAnterior = "" + element[16];

					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;

				}

				if(colecaoResumoFaturamentoRelatorioEstadoPorLocalidade != null
								&& !colecaoResumoFaturamentoRelatorioEstadoPorLocalidade.isEmpty()){
					// adiciona a ultima linha

					ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
									(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
									(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
									(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
									idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
									descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

					retorno.add(resumoFaturamentoRelatorioHelper);

					retorno = consultarResumoFaturamentoRelatorioPorUnidadeNegocio(anoMesReferencia,
									Integer.valueOf(idUnidadeNegocioAnterior), retorno);

					retorno = consultarResumoFaturamentoRelatorioPorGerenciaRegional(anoMesReferencia,
									Integer.valueOf(idGerenciaRegionalAnterior), retorno);

					retorno = consultarResumoFaturamentoRelatorioPorEstado(anoMesReferencia, retorno);
				}
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0345] Gerar Relatório de Resumo
	 * Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorUnidadeNegocio(int anoMesReferencia, Integer idUnidadeNegocio,
					Collection colecaoResumoFaturamentoRelatorio) throws ControladorException{

		Collection colecaoResumoFaturamentoRelatorioPorUnidadeNegocio = new ArrayList();

		try{
			colecaoResumoFaturamentoRelatorioPorUnidadeNegocio = repositorioFaturamento
							.consultarResumoFaturamentoRelatorioPorUnidadeNegocio(anoMesReferencia, idUnidadeNegocio);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoFaturamentoRelatorioPorUnidadeNegocio.iterator();

		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while(iterator.hasNext()){
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if(tipoLancamento == null){
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if(tipoLancamento.equals(tempTipoLancamento) && itemLancamento.equals(tempItemLancamento)){

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if(itemContabel == null && tempItemContabel == null
								|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

					switch(((Integer) element[8]).intValue()){
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
					}

				}else{

					condicaoIgual = false;
				}

			}else{

				condicaoIgual = false;

			}

			if(!condicaoIgual){

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
								(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
								(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
								(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

				colecaoResumoFaturamentoRelatorio.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch(((Integer) element[8]).intValue()){
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if(((String) element[1]).equalsIgnoreCase((String) element[2])){
				elementAnterior[2] = null; // descricaoItemLancamento
			}else{
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			descGerenciaRegionalAnterior = "" + element[13];
			idGerenciaRegionalAnterior = "" + element[14];
			descUnidadeNegocioAnterior = "" + element[9];
			idUnidadeNegocioAnterior = "" + element[10];

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if(colecaoResumoFaturamentoRelatorio != null && !colecaoResumoFaturamentoRelatorio.isEmpty()){
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
							(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
							(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
							(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

			colecaoResumoFaturamentoRelatorio.add(resumoFaturamentoRelatorioHelper);
		}

		return colecaoResumoFaturamentoRelatorio;
	}

	/**
	 * Consulta ResumoFaturamento para a geração do relatório '[UC0345] Gerar Relatório de Resumo
	 * Faturamento' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 27/06/2007
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoFaturamentoRelatorioPorEstado(int anoMesReferencia, Collection colecaoResumoFaturamentoRelatorio)
					throws ControladorException{

		Collection colecaoResumoFaturamentoRelatorioPorEstado = new ArrayList();

		try{
			colecaoResumoFaturamentoRelatorioPorEstado = repositorioFaturamento
							.consultarResumoFaturamentoRelatorioPorEstado(anoMesReferencia);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoFaturamentoRelatorioPorEstado.iterator();

		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while(iterator.hasNext()){
			Object[] element = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if(tipoLancamento == null){
				tipoLancamento = (String) element[1];
				itemLancamento = (String) element[2];
				itemContabel = (String) element[3];
			}

			tempTipoLancamento = (String) element[1];
			tempItemLancamento = (String) element[2];
			tempItemContabel = (String) element[3];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if(tipoLancamento.equals(tempTipoLancamento) && itemLancamento.equals(tempItemLancamento)){

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if(itemContabel == null && tempItemContabel == null
								|| (itemContabel != null && tempItemContabel != null && itemContabel.equals(tempItemContabel))){

					switch(((Integer) element[8]).intValue()){
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
					}

				}else{

					condicaoIgual = false;
				}

			}else{

				condicaoIgual = false;

			}

			if(!condicaoIgual){

				ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
								(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
								(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
								(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

				colecaoResumoFaturamentoRelatorio.add(resumoFaturamentoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch(((Integer) element[8]).intValue()){
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoLancamento
			if(((String) element[1]).equalsIgnoreCase((String) element[2])){
				elementAnterior[2] = null; // descricaoItemLancamento
			}else{
				elementAnterior[2] = element[2]; // descricaoItemLancamento
			}

			elementAnterior[3] = element[3]; // descricaoItemContabil
			elementAnterior[4] = element[4]; // indicadorImpressao
			elementAnterior[5] = element[5]; // indicadorTotal
			elementAnterior[6] = element[6]; // lancamentoTipo
			elementAnterior[7] = element[7]; // lancamentoTipoSuperior

			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if(colecaoResumoFaturamentoRelatorioPorEstado != null && !colecaoResumoFaturamentoRelatorioPorEstado.isEmpty()){
			// adiciona a ultima linha

			ResumoFaturamentoRelatorioHelper resumoFaturamentoRelatorioHelper = new ResumoFaturamentoRelatorioHelper(
							(BigDecimal[]) arrayValores, (String) elementAnterior[1], (String) elementAnterior[2],
							(String) elementAnterior[3], (Short) elementAnterior[4], (Short) elementAnterior[5],
							(Integer) elementAnterior[6], (Integer) elementAnterior[7], false, descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior, idLocalidadeAnterior, descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior, idUnidadeNegocioAnterior);

			colecaoResumoFaturamentoRelatorio.add(resumoFaturamentoRelatorioHelper);
		}

		return colecaoResumoFaturamentoRelatorio;
	}

	/**
	 * Metodo que retorna a data de revisão da conta
	 * 
	 * @author Vivianne Sousa
	 * @date 06/07/2007
	 * @param idsConta
	 * @return
	 */
	public Collection pesquisarDataRevisaoConta(Collection idsConta) throws ControladorException{

		Collection colecaoContas = null;
		Collection colecaoRetorno = new ArrayList();

		String parametroMotivoRevisaoCobrancaBancaria = ((String) ParametroCobranca.P_MOTIVO_REVISAO_COBRANCA_BANCARIA.executar(this));

		try{

			if(Util.isInteger(parametroMotivoRevisaoCobrancaBancaria)){

				colecaoContas = repositorioFaturamento.pesquisarDataRevisaoConta(idsConta,
								Util.obterInteger(parametroMotivoRevisaoCobrancaBancaria));
			}else{

				colecaoContas = repositorioFaturamento.pesquisarDataRevisaoConta(idsConta, 0);
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		if(colecaoContas != null && !colecaoContas.isEmpty()){

			Iterator contaIterator = colecaoContas.iterator();

			while(contaIterator.hasNext()){

				Object[] parmsConta = (Object[]) contaIterator.next();

				if(parmsConta != null){
					Conta conta = new Conta();
					if(parmsConta[0] != null){
						conta.setId((Integer) parmsConta[0]);
					}
					if(parmsConta[1] != null){
						conta.setDataRevisao((Date) parmsConta[1]);
					}
					if(parmsConta[2] != null){
						Parcelamento parcelamento = new Parcelamento();
						parcelamento.setId((Integer) parmsConta[2]);
						conta.setParcelamento(parcelamento);
					}

					colecaoRetorno.add(conta);
				}

			}
		}
		return colecaoRetorno;

	}

	/**
	 * [UC0146] - Manter Conta Author: Raphael Rossiter Data: 21/01/2006
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public boolean verificarImoveisComDebito(Integer idImovel) throws ControladorException{

		boolean temDebito = false;
		try{
			Collection colecaoContas = repositorioFaturamento.obterIdsContasImovel(idImovel);

			if(colecaoContas != null && colecaoContas.size() > 3){
				int qtdPagamentos = repositorioFaturamento.obterPagamentosContas(colecaoContas);

				if(colecaoContas.size() - qtdPagamentos > 3){
					temDebito = true;
				}
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return temDebito;

	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data: 20/07/2007
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoMetas(Integer anoMesReferencia) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarResumoMetas(anoMesReferencia);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0623] - Gerar Resumo de Metas CAERN Author: Sávio Luiz Data: 20/07/2007
	 * Obtém as contas de um imóvel que poderão ser mantidas
	 * 
	 * @param imovel
	 * @param situacaoNormal
	 * @param situacaoIncluida
	 * @param situacaoRetificada
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarResumoMetasAcumulado(Integer anoMesReferencia) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarResumoMetasAcumulado(anoMesReferencia);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0485] Gerar Resumo dos Devedores Duvidosos
	 * 
	 * @author Pedro Alexandre
	 * @date 27/07/2007
	 * @return
	 * @throws ControladorException
	 */
	public Short recuperarValorMaximoSequencialImpressaoMais10() throws ControladorException{

		try{
			return repositorioFaturamento.recuperarValorMaximoSequencialImpressaoMais10();

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	public void emitirContasOrgaoPublico(Integer anoMesReferenciaFaturamento, FaturamentoGrupo faturamentoGrupo,
					int idFuncionalidadeIniciada, int tipoConta, Integer idEmpresa, Short indicadorEmissaoExtratoFaturamento)
					throws ControladorException{

		// Método sem implementação alguma.
		// Colocamos uma linha para inserir breakpoint e ver se o método é chamado por batch.
		System.out.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
		System.out.println("O MÉTODO emitirContasOrgaoPublico FOI CHAMADO!!!!!!!!!!!!");
		System.out.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");

	}

	/**
	 * Recupera o debitoCreditoSituacaoAtual da Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 10/08/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDebitoCreditoSituacaoAtualConta(Integer idImovel, Integer anoMesReferencia) throws ControladorException{

		try{

			return repositorioFaturamento.pesquisarDebitoCreditoSituacaoAtualConta(idImovel, anoMesReferencia);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Metodo temporario para correção da base de dados
	 * Gerar Crédito a Realizar para os imóveis com contas com vencimento em 14/08/2007 com multa da
	 * conta 06/2007 cobrada na conta 07/2007 e que
	 * pagaram em 17/07/2007
	 * 
	 * @author Pedro Alexandre
	 * @date 20/08/2007
	 * @throws ControladorException
	 */
	public void gerarCreditoARealizarPorImoveisComContasComVencimento14_08_2007() throws ControladorException{

		Collection colecaoDadosImovelCreditoARealizar = null;
		try{
			colecaoDadosImovelCreditoARealizar = repositorioFaturamento
							.pesquisarDadosImoveisParaGerarCreditoARealizarPorImoveisComContasComVencimento14082007();
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		if(colecaoDadosImovelCreditoARealizar != null && !colecaoDadosImovelCreditoARealizar.equals("")){

			Iterator iteDados = colecaoDadosImovelCreditoARealizar.iterator();
			while(iteDados.hasNext()){
				/*
				 * 0 - id do imóvel 1 - valor da prestação 2 - id da localidade 3 - id da quadra 4 -
				 * código do setor comercial 5 - nº da quadra 6 - nº
				 * do lote 7 - nº do sublote
				 */
				Object[] dadosImovelCreditoARealizar = (Object[]) iteDados.next();

				if(dadosImovelCreditoARealizar != null){
					Integer idImovel = null;
					Integer idLocalidade = null;
					Integer idQuadra = null;
					Integer numeroQuadra = null;
					Integer codigoSetor = null;
					Short lote = null;
					Short subLote = null;
					BigDecimal valorPretacao = null;
					Integer anoMesReferenciaDebito = null;

					if(dadosImovelCreditoARealizar[0] != null){
						idImovel = (Integer) dadosImovelCreditoARealizar[0];
					}

					if(dadosImovelCreditoARealizar[1] != null){
						valorPretacao = (BigDecimal) dadosImovelCreditoARealizar[1];
					}

					if(dadosImovelCreditoARealizar[2] != null){
						idLocalidade = (Integer) dadosImovelCreditoARealizar[2];
					}

					if(dadosImovelCreditoARealizar[3] != null){
						idQuadra = (Integer) dadosImovelCreditoARealizar[3];
					}

					if(dadosImovelCreditoARealizar[4] != null){
						codigoSetor = (Integer) dadosImovelCreditoARealizar[4];
					}

					if(dadosImovelCreditoARealizar[5] != null){
						numeroQuadra = (Integer) dadosImovelCreditoARealizar[5];
					}

					if(dadosImovelCreditoARealizar[6] != null){
						lote = ((Integer) dadosImovelCreditoARealizar[6]).shortValue();
					}

					if(dadosImovelCreditoARealizar[7] != null){
						subLote = ((Integer) dadosImovelCreditoARealizar[7]).shortValue();
					}

					if(dadosImovelCreditoARealizar[8] != null){
						anoMesReferenciaDebito = ((Integer) dadosImovelCreditoARealizar[8]);
					}

					// cria o objeto de credito a realizar Geral
					CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
					creditoARealizarGeral.setIndicadorHistorico(new Short("2"));
					creditoARealizarGeral.setUltimaAlteracao(new Date());
					Integer idCreditoARealizarGeral = (Integer) getControladorUtil().inserir(creditoARealizarGeral);
					creditoARealizarGeral.setId(idCreditoARealizarGeral);

					// cria o objeto de credito a realizar
					CreditoARealizar creditoARealizar = new CreditoARealizar();
					creditoARealizar.setId(idCreditoARealizarGeral);
					creditoARealizar.setCreditoARealizarGeral(creditoARealizarGeral);

					if(idImovel != null){
						Imovel imovel = new Imovel(idImovel);
						creditoARealizar.setImovel(imovel);
					}

					creditoARealizar.setCreditoTipo(new CreditoTipo(CreditoTipo.DEVOLUCAO_ACRESCIMOS_IMPONTUALIDADE));
					creditoARealizar.setGeracaoCredito(new Date());

					// ------Alterado Rodrigo 31/08/2007
					creditoARealizar.setAnoMesReferenciaCredito(anoMesReferenciaDebito);
					// ------
					creditoARealizar.setAnoMesCobrancaCredito(sistemaParametro.getAnoMesArrecadacao());
					creditoARealizar.setAnoMesReferenciaContabil(sistemaParametro.getAnoMesFaturamento());
					creditoARealizar.setValorCredito(valorPretacao);
					creditoARealizar.setValorResidualMesAnterior(new BigDecimal("0.00"));
					creditoARealizar.setNumeroPrestacaoCredito(new Short("1"));
					creditoARealizar.setNumeroPrestacaoRealizada(new Short("0"));

					if(idLocalidade != null){
						Localidade localidade = new Localidade(idLocalidade);
						creditoARealizar.setLocalidade(localidade);
					}

					if(idQuadra != null){
						Quadra quadra = new Quadra(idQuadra);
						creditoARealizar.setQuadra(quadra);
					}

					creditoARealizar.setCodigoSetorComercial(codigoSetor);
					creditoARealizar.setNumeroQuadra(numeroQuadra);
					creditoARealizar.setNumeroLote(lote);
					creditoARealizar.setNumeroSubLote(subLote);
					creditoARealizar.setRegistroAtendimento(null);
					creditoARealizar.setOrdemServico(null);
					creditoARealizar.setLancamentoItemContabil(new LancamentoItemContabil(
									LancamentoItemContabil.ACRESCIMOS_POR_IMPONTUALIDADE));
					creditoARealizar.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));
					creditoARealizar.setDebitoCreditoSituacaoAnterior(null);
					creditoARealizar.setCreditoOrigem(new CreditoOrigem(CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE));
					creditoARealizar.setUltimaAlteracao(new Date());
					getControladorUtil().inserir(creditoARealizar);

					if(idImovel != null){
						Map<Categoria, BigDecimal> mapValorPorCategoria = new HashMap();
						// [UC0108 - Obter Quantidade de Economias por
						// Categoria]
						Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(new Imovel(idImovel));
						Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

						// [UC0185 - Obter Valor por Categoria]
						Iterator iteratorColecaoValorIRPorCategoria = (getControladorImovel().obterValorPorCategoria(
										colecaoCategoriasImovel, valorPretacao)).iterator();

						while(iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorIRPorCategoria.hasNext()){
							Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

							BigDecimal valorIR = (BigDecimal) iteratorColecaoValorIRPorCategoria.next();

							if(!mapValorPorCategoria.containsKey(categoria)){
								mapValorPorCategoria.put(categoria, BigDecimal.ZERO);
							}

							mapValorPorCategoria.put(categoria, mapValorPorCategoria.get(categoria).add(valorIR));
						}

						Iterator mapIterator = mapValorPorCategoria.keySet().iterator();

						while(mapIterator.hasNext()){
							Categoria categoria = (Categoria) mapIterator.next();
							CreditoARealizarCategoria creditoARealizarCategoria = new CreditoARealizarCategoria();
							creditoARealizarCategoria.setComp_id(new CreditoARealizarCategoriaPK(creditoARealizar, categoria));
							creditoARealizarCategoria.setCategoria(categoria);
							creditoARealizarCategoria.setCreditoARealizar(creditoARealizar);
							BigDecimal valorCategoria = mapValorPorCategoria.get(categoria);
							creditoARealizarCategoria.setValorCategoria(valorCategoria);
							creditoARealizarCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
							creditoARealizarCategoria.setUltimaAlteracao(new Date());
							getControladorUtil().inserir(creditoARealizarCategoria);
						}
					}
				}
			}
		}
	}

	private ControladorTransacaoLocal getControladorTransacao(){

		ControladorTransacaoLocalHome localHome = null;
		ControladorTransacaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorTransacaoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_TRANSACAO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * [UC0099] Emitir Relação Analítica de Faturas
	 * 
	 * @author Rafael Pinto
	 * @date 28/08/2007
	 * @param colecaoFatura
	 * @throws ControladorException
	 */
	public void emitirRelacaoAnaliticaFaturas(Collection<Fatura> colecaoFatura, Integer anoMesFaturamento) throws ControladorException{

		Collection<FaturaClienteResponsavelHelper> colecaoFaturaHelper = new ArrayList();

		if(colecaoFatura != null){

			int quantidadeFaturas = 0;

			for(Fatura fatura : colecaoFatura){

				quantidadeFaturas++;

				try{

					FaturaClienteResponsavelHelper faturaHelper = new FaturaClienteResponsavelHelper();

					Cliente cliente = this.getControladorCliente().pesquisarCliente(fatura.getCliente().getId());

					int anoMes = fatura.getAnoMesReferencia();

					faturaHelper.setCodigoCliente(cliente.getId().toString());
					faturaHelper.setNomeCliente(cliente.getNome());
					faturaHelper.setMesAno(Util.formatarAnoMesParaMesAno(anoMes));

					// Obtém a coleção dos itens da fatura atual
					List<FaturaItem> colecaoFaturaItem = (ArrayList) repositorioFaturamento.pesquisarItemsFatura(fatura.getId());

					Collection<FaturaItemClienteResponsavelHelper> colecaoFaturaItemHelper = new ArrayList();

					// Caso a coleção de itens da fatura estejam preenchidos
					if(colecaoFaturaItem != null && colecaoFaturaItem.size() > 0){

						for(FaturaItem faturaItem : colecaoFaturaItem){

							FaturaItemClienteResponsavelHelper faturaItemHelper = new FaturaItemClienteResponsavelHelper();

							Integer idImovel = faturaItem.getImovel().getId();
							Integer idConta = faturaItem.getContaGeral().getId();

							String endereco = this.getControladorEndereco().obterEnderecoAbreviadoImovel(idImovel);

							Conta conta = (Conta) Util.retonarObjetoDeColecao(this.obterConta(idConta));

							// Matricula
							faturaItemHelper.setMatricula(Util.adicionarZerosEsquedaNumero(8,
											Util.retornaMatriculaImovelFormatada(idImovel)));

							// Inscricao
							String inscricao = this.getControladorImovel().pesquisarInscricaoImovel(idImovel, true);
							faturaItemHelper.setInscricao(inscricao);

							// Categoria
							Categoria categoria = this.getControladorImovel().obterPrincipalCategoriaImovel(idImovel);
							faturaItemHelper.setCategoria(categoria.getDescricaoAbreviada());

							// Quantidade de Economias
							Short quantidadeEconomiaConta = repositorioFaturamento.obterQuantidadeEconomiasConta(idConta);

							faturaItemHelper.setQtdEconomias(quantidadeEconomiaConta.toString());

							// Endereço
							faturaItemHelper.setEndereco(endereco);

							EmitirContaHelper emitirContaHelper = new EmitirContaHelper();

							emitirContaHelper.setAmReferencia(anoMes);
							emitirContaHelper.setIdImovel(idImovel);

							if(conta.getLigacaoAguaSituacao() != null && conta.getLigacaoAguaSituacao().getId() != null){

								emitirContaHelper.setIdLigacaoAguaSituacao(conta.getLigacaoAguaSituacao().getId());
							}

							if(conta.getLigacaoEsgotoSituacao() != null && conta.getLigacaoEsgotoSituacao().getId() != null){

								emitirContaHelper.setIdLigacaoEsgotoSituacao(conta.getLigacaoEsgotoSituacao().getId());
							}

							Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);

							Integer tipoLigacao = parmSituacao[0];
							Integer tipoMedicao = parmSituacao[1];

							Object[] parmsConsumoHistorico = null;

							String consumoMedio = "";

							if(tipoLigacao != null){

								try{
									parmsConsumoHistorico = repositorioMicromedicao.obterDadosConsumoConta(emitirContaHelper.getIdImovel(),
													emitirContaHelper.getAmReferencia(), tipoLigacao);

								}catch(ErroRepositorioException e){
									throw new ControladorException("erro.sistema", e);
								}

								if(parmsConsumoHistorico != null){

									// Consumo médio
									if(parmsConsumoHistorico[2] != null){
										consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
									}

								}
							}

							Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(emitirContaHelper, tipoMedicao);

							// Leitura Anterior
							String leituraAnterior = "";

							// Leitura Atual
							String leituraAtual = "";

							// Data Leitura Anterior
							String dataLeituraAnterior = "";

							// Data Leitura Atual
							String dataLeituraAtual = "";

							if(parmsMedicaoHistorico != null){

								if(parmsMedicaoHistorico[0] != null){
									leituraAnterior = "" + (Integer) parmsMedicaoHistorico[0];
								}

								if(parmsMedicaoHistorico[1] != null){
									leituraAtual = "" + (Integer) parmsMedicaoHistorico[1];
								}

								if(parmsMedicaoHistorico[3] != null){
									dataLeituraAnterior = Util.formatarData((Date) parmsMedicaoHistorico[3]);
								}

								if(parmsMedicaoHistorico[2] != null){
									dataLeituraAtual = Util.formatarData((Date) parmsMedicaoHistorico[2]);
								}

							}

							// Leitura Anterior
							faturaItemHelper.setLeituraAnterior(leituraAnterior);

							// Leitura Atual
							faturaItemHelper.setLeituraAtual(leituraAtual);

							// Média
							faturaItemHelper.setMedia(consumoMedio);

							// Consumo Faturado
							String diasConsumo = "";
							if(!dataLeituraAnterior.equals("") && !dataLeituraAtual.equals("")){

								diasConsumo = ""
												+ Util.obterQuantidadeDiasEntreDuasDatas((Date) parmsMedicaoHistorico[3],
																(Date) parmsMedicaoHistorico[2]);
							}
							emitirContaHelper.setConsumoAgua(conta.getConsumoAgua());
							emitirContaHelper.setConsumoEsgoto(conta.getConsumoEsgoto());

							String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(emitirContaHelper, tipoMedicao, diasConsumo);

							String consumoFaturamento = parmsConsumo[0];

							faturaItemHelper.setConsumoFaturado(consumoFaturamento);

							// Data da leitura
							faturaItemHelper.setDataLeitura(dataLeituraAtual);

							// Data Vencimento
							faturaItemHelper.setDataVencimento(Util.formatarData(conta.getDataVencimentoConta()));

							// Consumo Agua
							String consumoAgua = "";
							if(conta.getConsumoAgua() != null){
								consumoAgua = conta.getConsumoAgua().toString();
							}
							faturaItemHelper.setConsumoAgua(consumoAgua);

							// Rateio Agua
							String rateioAgua = "";
							if(conta.getConsumoRateioAgua() != null){
								rateioAgua = conta.getConsumoRateioAgua().toString();
							}
							faturaItemHelper.setRateioAgua(rateioAgua);

							// Valor Agua
							String valorAgua = "";
							if(conta.getValorAgua() != null){
								valorAgua = Util.formatarMoedaReal(conta.getValorAgua());
							}
							faturaItemHelper.setValorAgua(valorAgua);

							// Valor Credito
							String valorCredito = "";
							if(conta.getValorCreditos() != null){
								valorCredito = Util.formatarMoedaReal(conta.getValorCreditos());
							}
							faturaItemHelper.setValorCredito(valorCredito);

							// Consumo Esgoto
							String consumoEsgoto = "";
							if(conta.getConsumoEsgoto() != null){
								consumoEsgoto = conta.getConsumoEsgoto().toString();
							}
							faturaItemHelper.setConsumoEsgoto(consumoEsgoto);

							// Rateio Esgoto
							String rateioEsgoto = "";
							if(conta.getConsumoRateioEsgoto() != null){
								rateioEsgoto = conta.getConsumoRateioEsgoto().toString();
							}
							faturaItemHelper.setRateioEsgoto(rateioEsgoto);

							// Valor Esgoto
							String valorEsgoto = "";
							if(conta.getValorEsgoto() != null){
								valorEsgoto = Util.formatarMoedaReal(conta.getValorEsgoto());
							}
							faturaItemHelper.setValorEsgoto(valorEsgoto);

							// Debito Cobrado
							String debitoCobrado = "";
							if(conta.getDebitos() != null){
								debitoCobrado = Util.formatarMoedaReal(conta.getDebitos());
							}
							faturaItemHelper.setDebitoCobrado(debitoCobrado);

							// Credito Realizado
							String creditoRealizado = "";
							if(conta.getValorCreditos() != null){
								creditoRealizado = Util.formatarMoedaReal(conta.getValorCreditos());
							}
							faturaItemHelper.setCreditoRealizado(creditoRealizado);

							// Valor Total da Conta
							faturaItemHelper.setValor(Util.formatarMoedaReal(faturaItem.getValorConta()));

							colecaoFaturaItemHelper.add(faturaItemHelper);
						}// fim do for faturaItem

					}// fim do if fatura

					faturaHelper.setValorTotalAPagar(Util.formatarMoedaReal(fatura.getDebito()));
					faturaHelper.setColecaoFaturaItemClienteResponsavelHelper(colecaoFaturaItemHelper);

					colecaoFaturaHelper.add(faturaHelper);

					// Erro no repositório
				}catch(ErroRepositorioException ex){
					throw new ControladorException("erro.sistema", ex);
				}
			}

			RelatorioRelacaoAnaliticaFaturas relatorio = new RelatorioRelacaoAnaliticaFaturas(Usuario.USUARIO_BATCH);

			relatorio.addParametro("colecaoFaturas", colecaoFaturaHelper);
			relatorio.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);

			byte[] relatorioGerado = (byte[]) relatorio.executar();

			try{

				String mesReferencia = anoMesFaturamento.toString().substring(4, 6);
				String anoReferencia = anoMesFaturamento.toString().substring(0, 4);

				String nomeRelatorio = "RELATORIO_RELACAO_ANALITICA_FATURA_" + mesReferencia + "_" + anoReferencia + ".PDF";

				File leitura = new File(nomeRelatorio);
				FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
				out.write(relatorioGerado);
				out.flush();
				out.close();

			}catch(IOException e){
				throw new ControladorException("erro.sistema", e);
			}

		}

	}

	/**
	 * Recupera o data prevista do faturamento atividade cronograma
	 * 
	 * @author Sávio Luiz
	 * @date 28/08/2007
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarFaturamentoAtividadeCronogramaDataPrevista(Integer faturamentoGrupoId, Integer faturamentoAtividadeId,
					Integer anoMesReferencia) throws ControladorException{

		try{

			return repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataPrevista(faturamentoGrupoId, faturamentoAtividadeId,
							anoMesReferencia);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0596] Inserir Qualidade de Agua
	 * 
	 * @author Kássia Albuquerque
	 * @date 06/08/2007
	 * @return
	 * @throws ControladorException
	 */

	public void inserirQualidadeAgua(QualidadeAgua qualidadeAgua, Collection colecaoQualidadeAgua, Usuario usuarioLogado)
					throws ControladorException{

		if(colecaoQualidadeAgua != null && !colecaoQualidadeAgua.isEmpty()){

			Iterator IteratorColecaoQualidadeAgua = colecaoQualidadeAgua.iterator();

			while(IteratorColecaoQualidadeAgua.hasNext()){

				QualidadeAgua qualidadeAguaColecao = (QualidadeAgua) IteratorColecaoQualidadeAgua.next();

				// -------- REGISTRAR TRANSAÇÃO------------------

				RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_QUALIDADE_AGUA_INSERIR,
								new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				Operacao operacao = new Operacao();
				operacao.setId(Operacao.OPERACAO_QUALIDADE_AGUA_INSERIR);

				OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
				operacaoEfetuada.setOperacao(operacao);

				qualidadeAguaColecao.setOperacaoEfetuada(operacaoEfetuada);
				qualidadeAguaColecao.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(qualidadeAguaColecao);
				// ------------ REGISTRAR TRANSAÇÃO----------------------------

				getControladorUtil().inserir(qualidadeAguaColecao);

			}

		}else{

			// [FS0004 - VERIFICAR PREENCHIMENTO DOS CAMPOS]
			// [FS0008 - VERIFICAR PADRAO CORRESPONDENTE]

			if(qualidadeAgua.getAnoMesReferencia() == null){
				throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Ano/Mês de Referência ");
			}

			if(qualidadeAgua.getLocalidade() == null){
				throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Localidade ");
			}

			if(Util.compararAnoMesReferencia(qualidadeAgua.getAnoMesReferencia(), Util.formataAnoMes(new Date()), "<")){
				throw new ControladorException("atencao.mes_ano_menor", null, Util.formatarAnoMesParaMesAno(qualidadeAgua
								.getAnoMesReferencia().intValue()));
			}

			boolean peloMenosUmParametroInformado = false;

			if(qualidadeAgua.getNumeroAmostrasConformesCloro() != null || qualidadeAgua.getNumeroAmostrasRealizadasCloro() != null
							|| qualidadeAgua.getNumeroAmostrasConformesColiformesTermotolerantes() != null
							|| qualidadeAgua.getNumeroAmostrasRealizadasColiformesTermotolerantes() != null
							|| qualidadeAgua.getNumeroAmostrasConformesColiformesTotais() != null
							|| qualidadeAgua.getNumeroAmostrasRealizadasColiformesTotais() != null
							|| qualidadeAgua.getNumeroAmostrasConformesCor() != null
							|| qualidadeAgua.getNumeroAmostrasRealizadasCor() != null
							|| qualidadeAgua.getNumeroAmostrasConformesCloro() != null
							|| qualidadeAgua.getNumeroAmostrasRealizadasCloro() != null
							|| qualidadeAgua.getNumeroAmostrasConformesPH() != null
							|| qualidadeAgua.getNumeroAmostrasRealizadasPH() != null
							|| qualidadeAgua.getNumeroAmostrasConformesFluor() != null
							|| qualidadeAgua.getNumeroAmostrasRealizadasFluor() != null
							|| qualidadeAgua.getNumeroAmostrasConformesTurbidez() != null
							|| qualidadeAgua.getNumeroAmostrasRealizadasTurbidez() != null){
				peloMenosUmParametroInformado = true;
			}
			if(!peloMenosUmParametroInformado){
				throw new ControladorException("atencao.nenhum_parametro_informado");

			}

			// [FS0005 - VERIFICAR EXISTÊNCIA DA QUALIDADE DE ÁGUA PARA
			// LOCALIDADE]
			if((qualidadeAgua.getSetorComercial() == null || qualidadeAgua.getSetorComercial().equals(""))
							&& (qualidadeAgua.getLocalidade() != null && !qualidadeAgua.getLocalidade().equals(""))){

				FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();

				filtroQualidadeAgua.adicionarCaminhoParaCarregamentoEntidade("localidade");

				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.ANO_MES_REFERENCIA, qualidadeAgua
								.getAnoMesReferencia().toString()));
				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.LOCALIDADE_ID, qualidadeAgua
								.getLocalidade().getId().toString()));
				filtroQualidadeAgua.adicionarParametro(new ParametroNulo(FiltroQualidadeAgua.SETOR_COMERCIAL_ID));

				Collection colecaoExistenciaQualidadeAgua = getControladorUtil().pesquisar(filtroQualidadeAgua,
								QualidadeAgua.class.getName());

				if(colecaoExistenciaQualidadeAgua != null && !colecaoExistenciaQualidadeAgua.isEmpty()){

					throw new ControladorException("atencao.faturamento.qualidade_agua_existente", null, qualidadeAgua.getLocalidade()
									.getId().toString());
				}

			}else if((qualidadeAgua.getSetorComercial() != null && !qualidadeAgua.getSetorComercial().equals(""))
							&& (qualidadeAgua.getLocalidade() != null && !qualidadeAgua.getLocalidade().equals(""))){

				// [FS0006 - VERIFICAR EXISTÊNCIA DA QUALIDADE DE ÁGUA PARA
				// SETOR COMERCIAL]

				FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();

				filtroQualidadeAgua.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroQualidadeAgua.adicionarCaminhoParaCarregamentoEntidade("setorComercial");

				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.ANO_MES_REFERENCIA, qualidadeAgua
								.getAnoMesReferencia().toString()));
				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.LOCALIDADE_ID, qualidadeAgua
								.getLocalidade().getId().toString()));
				filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.SETOR_COMERCIAL_ID, qualidadeAgua
								.getSetorComercial().getId().toString()));

				Collection colecaoExistenciaQualidadeAgua = getControladorUtil().pesquisar(filtroQualidadeAgua,
								QualidadeAgua.class.getName());

				if(colecaoExistenciaQualidadeAgua != null && !colecaoExistenciaQualidadeAgua.isEmpty()){

					QualidadeAgua qualidadeAguaExistente = (QualidadeAgua) colecaoExistenciaQualidadeAgua.iterator().next();
					throw new ControladorException("atencao.faturamento.qualidade_agua_existente_setor_comercial", null, ""
									+ qualidadeAguaExistente.getLocalidade().getId() + "/"
									+ qualidadeAguaExistente.getSetorComercial().getCodigo());
				}

			}

			qualidadeAgua.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO------------------

			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_QUALIDADE_AGUA_INSERIR,
							new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_QUALIDADE_AGUA_INSERIR);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			qualidadeAgua.setOperacaoEfetuada(operacaoEfetuada);
			qualidadeAgua.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(qualidadeAgua);

			// ------------ REGISTRAR TRANSAÇÃO----------------------------

			getControladorUtil().inserir(qualidadeAgua);

		}

	}

	/**
	 * [UC0597] Atualizar Qualidade de Agua
	 * 
	 * @author Eduardo henrique
	 * @date 17/07/2008
	 * @return
	 * @throws ControladorException
	 */

	public void atualizarQualidadeAgua(QualidadeAgua qualidadeAgua, Usuario usuarioLogado) throws ControladorException{

		// [FS0001 - VERIFICAR Realização de Faturamento]
		try{
			if(!repositorioFaturamento.verificarExistenciaFaturamentoQualidadeAgua(qualidadeAgua)){
				throw new ControladorException("atencao.qualidade.utilizada_em_faturamento_anterior");
			}
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		// [FS0002 - VERIFICAR Preenchimento dos Campos]
		if(qualidadeAgua.getAnoMesReferencia() == null){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Ano/Mês de Referência ");
		}

		if(qualidadeAgua.getLocalidade() == null){
			throw new ControladorException("atencao.campo_selecionado.obrigatorio", null, "Localidade ");
		}

		boolean peloMenosUmParametroInformado = false;

		if(qualidadeAgua.getNumeroAmostrasConformesCloro() != null || qualidadeAgua.getNumeroAmostrasRealizadasCloro() != null
						|| qualidadeAgua.getNumeroAmostrasConformesColiformesTermotolerantes() != null
						|| qualidadeAgua.getNumeroAmostrasRealizadasColiformesTermotolerantes() != null
						|| qualidadeAgua.getNumeroAmostrasConformesColiformesTotais() != null
						|| qualidadeAgua.getNumeroAmostrasRealizadasColiformesTotais() != null
						|| qualidadeAgua.getNumeroAmostrasConformesCor() != null || qualidadeAgua.getNumeroAmostrasRealizadasCor() != null
						|| qualidadeAgua.getNumeroAmostrasConformesCloro() != null
						|| qualidadeAgua.getNumeroAmostrasRealizadasCloro() != null || qualidadeAgua.getNumeroAmostrasConformesPH() != null
						|| qualidadeAgua.getNumeroAmostrasRealizadasPH() != null || qualidadeAgua.getNumeroAmostrasConformesFluor() != null
						|| qualidadeAgua.getNumeroAmostrasRealizadasFluor() != null
						|| qualidadeAgua.getNumeroAmostrasConformesTurbidez() != null
						|| qualidadeAgua.getNumeroAmostrasRealizadasTurbidez() != null){
			peloMenosUmParametroInformado = true;
		}
		if(!peloMenosUmParametroInformado){
			throw new ControladorException("atencao.nenhum_parametro_informado");

		}

		if((qualidadeAgua.getSetorComercial() == null || qualidadeAgua.getSetorComercial().equals(""))
						&& (qualidadeAgua.getLocalidade() != null && !qualidadeAgua.getLocalidade().equals(""))){

			FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();

			filtroQualidadeAgua.adicionarCaminhoParaCarregamentoEntidade("localidade");

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.ANO_MES_REFERENCIA, qualidadeAgua
							.getAnoMesReferencia().toString()));
			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.LOCALIDADE_ID, qualidadeAgua.getLocalidade()
							.getId().toString()));
			filtroQualidadeAgua.adicionarParametro(new ParametroNulo(FiltroQualidadeAgua.SETOR_COMERCIAL_ID));
			filtroQualidadeAgua.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroQualidadeAgua.ID, qualidadeAgua.getId()));

			Collection colecaoExistenciaQualidadeAgua = getControladorUtil().pesquisar(filtroQualidadeAgua, QualidadeAgua.class.getName());

			if(colecaoExistenciaQualidadeAgua != null && !colecaoExistenciaQualidadeAgua.isEmpty()){

				throw new ControladorException("atencao.faturamento.qualidade_agua_existente", null, qualidadeAgua.getLocalidade().getId()
								.toString());
			}

		}else if((qualidadeAgua.getSetorComercial() != null && !qualidadeAgua.getSetorComercial().equals(""))
						&& (qualidadeAgua.getLocalidade() != null && !qualidadeAgua.getLocalidade().equals(""))){

			// [FS0006 - VERIFICAR EXISTÊNCIA DA QUALIDADE DE ÁGUA PARA
			// SETOR COMERCIAL]

			FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();

			filtroQualidadeAgua.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroQualidadeAgua.adicionarCaminhoParaCarregamentoEntidade("setorComercial");

			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.ANO_MES_REFERENCIA, qualidadeAgua
							.getAnoMesReferencia().toString()));
			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.LOCALIDADE_ID, qualidadeAgua.getLocalidade()
							.getId().toString()));
			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.SETOR_COMERCIAL_ID, qualidadeAgua
							.getSetorComercial().getId().toString()));
			filtroQualidadeAgua.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroQualidadeAgua.ID, qualidadeAgua.getId()));

			Collection colecaoExistenciaQualidadeAgua = getControladorUtil().pesquisar(filtroQualidadeAgua, QualidadeAgua.class.getName());

			if(colecaoExistenciaQualidadeAgua != null && !colecaoExistenciaQualidadeAgua.isEmpty()){

				QualidadeAgua qualidadeAguaExistente = (QualidadeAgua) colecaoExistenciaQualidadeAgua.iterator().next();
				throw new ControladorException("atencao.faturamento.qualidade_agua_existente_setor_comercial", null, ""
								+ qualidadeAguaExistente.getLocalidade().getId() + "/"
								+ qualidadeAguaExistente.getSetorComercial().getCodigo());
			}

		}

		// [FS0003 - Verificar Atualização por Outro Usuário]
		FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();

		// Seta os parametros do filtro
		filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.ID, qualidadeAgua.getId()));

		// Pesquisa a coleção de acordo com o filtro passado
		Collection qualidadesAgua = getControladorUtil().pesquisar(filtroQualidadeAgua, QualidadeAgua.class.getName());
		QualidadeAgua qualidadeAguaBase = (QualidadeAgua) Util.retonarObjetoDeColecao(qualidadesAgua);

		// Verifica se a data de alteração do objeto gravado na base é
		// maior que a na instancia
		if((qualidadeAguaBase.getUltimaAlteracao().after(qualidadeAgua.getUltimaAlteracao()))){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.atualizacao.timestamp");
		}

		// Seta a data/hora
		qualidadeAgua.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSAÇÃO------------------

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_QUALIDADE_AGUA_ALTERAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_QUALIDADE_AGUA_ALTERAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		qualidadeAgua.setOperacaoEfetuada(operacaoEfetuada);
		qualidadeAgua.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(qualidadeAgua);

		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		getControladorUtil().atualizar(qualidadeAgua);

	}

	/**
	 * Alterar Vencimento do Conjunto de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * @throws ControladorException
	 */
	public void alterarVencimentoConjuntoConta(Integer idGrupoFaturamento, Date dataVencimentoInformada, Integer anoMes, Integer anoMesFim,
					Date dataVencimentoContaInicio, Date dataVencimentoContaFim) throws ControladorException{

		try{

			Date dataValidade = this.retornaDataValidadeConta(dataVencimentoInformada);

			repositorioFaturamento.alterarVencimentoContaGrupoFaturamento(dataVencimentoInformada, dataValidade,
							Conta.INDICADOR_ALTERACAO_VENCIMENTO_ATIVO, idGrupoFaturamento, anoMes, anoMesFim, dataVencimentoContaInicio,
							dataVencimentoContaFim);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Retificar Conjunto de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * @throws ControladorException
	 */
	public void retificarConjuntoConta(Integer idGrupoFaturamento, Integer anoMes, ContaMotivoRetificacao contaMotivoRetificacao,
					Collection debitosTipoRetirar, Usuario usuarioLogado, Date dataVencimentoContaInicio, Date dataVencimentoContaFim,
					Integer anoMesFim, Collection<Conta> colecaoContasSelecionadas) throws ControladorException{

		Collection colecaoContasManutencao = new ArrayList();

		if(colecaoContasSelecionadas != null && !colecaoContasSelecionadas.isEmpty()){

			Iterator colecaoContasManutencaoIterator = colecaoContasManutencao.iterator();

			while(colecaoContasManutencaoIterator.hasNext()){

				// Obtém os dados do crédito realizado
				Conta conta = (Conta) colecaoContasManutencaoIterator.next();

				conta.setUltimaAlteracao(new Date());

				Imovel imovel = (Imovel) conta.getImovel();

				Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasContaCategoria(conta);

				Collection colecaoCreditoRealizado = obterCreditosRealizadosConta(conta);

				Collection colecaoDebitoCobrado = obterDebitosCobradosConta(conta);

				String consumoAgua = null;
				if(conta.getConsumoAgua() != null){

					consumoAgua = conta.getConsumoAgua().toString();
				}

				String consumoEsgoto = null;
				if(conta.getConsumoEsgoto() != null){

					consumoEsgoto = conta.getConsumoEsgoto().toString();
				}

				Collection<CalcularValoresAguaEsgotoHelper> valoresConta = calcularValoresConta(Util.formatarAnoMesParaMesAno(conta
								.getReferencia()), imovel.getId().toString(), conta.getLigacaoAguaSituacao().getId(), conta
								.getLigacaoEsgotoSituacao().getId(), colecaoCategoria, consumoAgua, consumoEsgoto, conta
								.getPercentualEsgoto().toString(), conta.getConsumoTarifa().getId(), usuarioLogado, null, null);

				boolean achouDebitoRetirar = false;
				if(colecaoDebitoCobrado != null && !colecaoDebitoCobrado.isEmpty()){
					Iterator colecaoDebitoCobradoIterator = colecaoDebitoCobrado.iterator();
					while(colecaoDebitoCobradoIterator.hasNext()){
						DebitoCobrado debitoCobrado = (DebitoCobrado) colecaoDebitoCobradoIterator.next();
						DebitoTipo debitoTipo = debitoCobrado.getDebitoTipo();
						if(debitosTipoRetirar.contains(debitoTipo.getId())){
							achouDebitoRetirar = true;
							colecaoDebitoCobradoIterator.remove();
						}
					}
					if(achouDebitoRetirar){
						retificarConta(Integer.valueOf(conta.getReferencia()), conta, imovel, colecaoDebitoCobrado,
										colecaoCreditoRealizado, conta.getLigacaoAguaSituacao(), conta.getLigacaoEsgotoSituacao(),
										colecaoCategoria, consumoAgua, consumoEsgoto, conta.getPercentualEsgoto().toString(),
										conta.getDataVencimentoConta(), valoresConta, contaMotivoRetificacao, null, usuarioLogado, null,
										conta.getConsumoTarifa(), null);
					}

				}
			}
		}

	}

	/**
	 * Pesquisar conjunto de contas p/ emissão da 2°Via
	 * 
	 * @author Raphael Rossiter
	 * @date 21/08/2007
	 * @throws ControladorException
	 */
	public Collection pesquisarConjuntoContaEmitir2Via(String idGrupoFaturamento, Integer anoMes, Date dataVencimentoContaInicio,
					Date dataVencimentoContaFim, Integer anoMesFim) throws ControladorException{

		Collection colecaoContasEmissao = new ArrayList();
		Collection colecaoContasManutencao = new ArrayList();

		try{
			colecaoContasManutencao = repositorioFaturamento.pesquisarIdContasGrupoFaturamento(anoMes, idGrupoFaturamento,
							dataVencimentoContaInicio, dataVencimentoContaFim, anoMesFim);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoContasManutencao != null && !colecaoContasManutencao.isEmpty()){
			colecaoContasEmissao.addAll(colecaoContasManutencao);
		}

		return colecaoContasEmissao;
	}

	/**
	 * [UC0216] Calcular Acrescimo por Impontualidade
	 * 
	 * @author Raphael Rossiter
	 * @date 28/08/2007
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Conta pesquisarContaAtualizacaoTarifaria(Integer idConta) throws ControladorException{

		Conta retorno = null;
		Object[] arrayConta = null;

		try{

			arrayConta = repositorioFaturamento.pesquisarContaAtualizacaoTarifaria(idConta);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(arrayConta != null){

			retorno = new Conta();

			retorno.setId((Integer) arrayConta[0]);

			if(arrayConta[1] != null){
				retorno.setConsumoAgua((Integer) arrayConta[1]);
			}

			if(arrayConta[2] != null){
				retorno.setConsumoEsgoto((Integer) arrayConta[2]);
			}

			LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
			ligacaoAguaSituacao.setId((Integer) arrayConta[3]);

			retorno.setLigacaoAguaSituacao(ligacaoAguaSituacao);

			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
			ligacaoEsgotoSituacao.setId((Integer) arrayConta[4]);

			retorno.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

			ConsumoTarifa consumoTarifa = new ConsumoTarifa();
			consumoTarifa.setId((Integer) arrayConta[5]);

			retorno.setConsumoTarifa(consumoTarifa);

			if(arrayConta[6] != null){
				retorno.setPercentualEsgoto((BigDecimal) arrayConta[6]);
			}

			FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
			faturamentoGrupo.setId((Integer) arrayConta[10]);

			Rota rota = new Rota();
			rota.setId((Integer) arrayConta[9]);
			rota.setFaturamentoGrupo(faturamentoGrupo);

			Quadra quadra = new Quadra();
			quadra.setId((Integer) arrayConta[8]);
			quadra.setRota(rota);

			Imovel imovel = new Imovel();
			imovel.setId((Integer) arrayConta[7]);

			imovel.setQuadra(quadra);
			imovel.setRota(rota);

			retorno.setImovel(imovel);

			if(arrayConta[11] != null){
				retorno.setValorAgua((BigDecimal) arrayConta[11]);
			}

			if(arrayConta[12] != null){
				retorno.setValorEsgoto((BigDecimal) arrayConta[12]);
			}

			retorno.setReferencia((Integer) arrayConta[13]);

		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/09/2007
	 * @return Fatura
	 * @throws ErroRepositorioException
	 */
	public Fatura pesquisarFaturaPorQualificador(Short codigoQualificador, Integer anoMesReferencia, BigDecimal valorDebito)
					throws ControladorException{

		Fatura retorno = null;
		Object[] arrayFatura = null;

		try{

			arrayFatura = repositorioFaturamento.pesquisarFaturaPorQualificador(codigoQualificador, anoMesReferencia, valorDebito);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(arrayFatura != null){

			retorno = new Fatura();

			retorno.setId((Integer) arrayFatura[0]);

			Cliente cliente = new Cliente();
			cliente.setId((Integer) arrayFatura[1]);

			retorno.setCliente(cliente);
		}

		return retorno;
	}

	/**
	 * obtem o consumo médio faturado nos ultimos 6 meses [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 05/09/2007
	 * @param
	 * @throws ControladorException
	 */
	public Integer obterValorConsumoMedio6meses(Integer idImovel) throws ControladorException{

		Integer obterValorConsumoMedio6meses = 0;

		int anoMes = Util.getAnoMesComoInt(new Date());

		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses + obterConsumoFaturadoAnterior(idImovel, anoMes, 1, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses + obterConsumoFaturadoAnterior(idImovel, anoMes, 2, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses + obterConsumoFaturadoAnterior(idImovel, anoMes, 3, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses + obterConsumoFaturadoAnterior(idImovel, anoMes, 4, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses + obterConsumoFaturadoAnterior(idImovel, anoMes, 5, 1);
		obterValorConsumoMedio6meses = obterValorConsumoMedio6meses + obterConsumoFaturadoAnterior(idImovel, anoMes, 6, 1);

		if(obterValorConsumoMedio6meses != 0){
			obterValorConsumoMedio6meses = Util.dividirArredondarResultado(obterValorConsumoMedio6meses, 6);
		}

		return obterValorConsumoMedio6meses;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 05/09/2007
	 * @param
	 * @throws ControladorException
	 */
	public Integer obterConsumoFaturadoAnterior(Integer idImovel, int anoMes, int qtdMeses, Integer tipoLigacao)
					throws ControladorException{

		int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
		Integer numeroConsumoFaturadoMes = 0;

		// caso o tipo de ligação e medição seja diferente de nulo
		if(tipoLigacao != null){
			Object[] parmsConsumoHistorico = null;
			parmsConsumoHistorico = getControladorMicromedicao().obterConsumoAnteriorAnormalidadeDoImovel(idImovel, anoMesSubtraido,
							tipoLigacao);

			if(parmsConsumoHistorico != null){
				if(parmsConsumoHistorico[0] != null){
					numeroConsumoFaturadoMes = (Integer) parmsConsumoHistorico[0];
				}
			}
		}

		return numeroConsumoFaturadoMes;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [UC0637] - Gerar Relatórios Volumes Faturados
	 * 
	 * @author Rafael Corrêa
	 * @created 11/09/2007
	 * @throws ControladorException
	 */
	public Collection<VolumesFaturadosRelatorioHelper> pesquisarDadosRelatorioVolumesFaturados(Integer idLocalidade, Integer anoMes,
					Integer anoMesInformado, Integer anoMes1, Integer anoMes2, Integer anoMes3, Integer anoMes4, Integer anoMes5)
					throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosVolumesFaturados = null;

		try{
			colecaoDadosVolumesFaturados = repositorioFaturamento.pesquisarDadosRelatorioVolumesFaturados(idLocalidade, anoMes,
							anoMesInformado, anoMes1, anoMes2, anoMes3, anoMes4, anoMes5);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDadosVolumesFaturados != null && !colecaoDadosVolumesFaturados.isEmpty()){

			Iterator colecaoDadosVolumesFaturadosIterator = colecaoDadosVolumesFaturados.iterator();

			while(colecaoDadosVolumesFaturadosIterator.hasNext()){

				// Obtém os dados do débito cobrado
				Object[] dadosVolumesFaturados = (Object[]) colecaoDadosVolumesFaturadosIterator.next();

				VolumesFaturadosRelatorioHelper volumesFaturadosRelatorioHelper = new VolumesFaturadosRelatorioHelper();

				// Id do Imóvel
				if(dadosVolumesFaturados[0] != null){
					volumesFaturadosRelatorioHelper.setIdImovel((Integer) dadosVolumesFaturados[0]);
				}

				// Id da Localidade
				if(dadosVolumesFaturados[1] != null){
					volumesFaturadosRelatorioHelper.setIdLocalidade((Integer) dadosVolumesFaturados[1]);
				}

				// Nome da Localidade
				if(dadosVolumesFaturados[2] != null){
					volumesFaturadosRelatorioHelper.setNomeLocalidade((String) dadosVolumesFaturados[2]);
				}

				// Id do Setor Comercial
				if(dadosVolumesFaturados[3] != null){
					volumesFaturadosRelatorioHelper.setIdSetorComercial((Integer) dadosVolumesFaturados[3]);
				}

				// Código do Setor Comercial
				if(dadosVolumesFaturados[4] != null){
					volumesFaturadosRelatorioHelper.setCodigoSetorComercial((Integer) dadosVolumesFaturados[4]);
				}

				// Nome do Setor Comercial
				if(dadosVolumesFaturados[5] != null){
					volumesFaturadosRelatorioHelper.setNomeSetorComercial((String) dadosVolumesFaturados[5]);
				}

				// Id da Quadra
				if(dadosVolumesFaturados[6] != null){
					volumesFaturadosRelatorioHelper.setIdQuadra((Integer) dadosVolumesFaturados[6]);
				}

				// Número da Quadra
				if(dadosVolumesFaturados[7] != null){
					volumesFaturadosRelatorioHelper.setNumeroQuadra((Integer) dadosVolumesFaturados[7]);
				}

				// Nome do Usuário
				if(dadosVolumesFaturados[8] != null){
					volumesFaturadosRelatorioHelper.setNomeUsuario((String) dadosVolumesFaturados[8]);
				}

				// Id da Situação de Água
				if(dadosVolumesFaturados[9] != null){
					volumesFaturadosRelatorioHelper.setIdSituacaoAgua((Integer) dadosVolumesFaturados[9]);
				}

				// Id da Situação de Esgoto
				if(dadosVolumesFaturados[10] != null){
					volumesFaturadosRelatorioHelper.setIdSituacaoEsgoto((Integer) dadosVolumesFaturados[10]);
				}

				// Consumo Médio
				if(dadosVolumesFaturados[11] != null){
					volumesFaturadosRelatorioHelper.setMediaConsumo((Integer) dadosVolumesFaturados[11]);
				}

				// Consumo Mês/Ano Informado
				if(dadosVolumesFaturados[12] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAnoInformado((Integer) dadosVolumesFaturados[12]);
				}

				// Consumo Mês/Ano 1
				if(dadosVolumesFaturados[13] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno1((Integer) dadosVolumesFaturados[13]);
				}

				// Consumo Mês/Ano 2
				if(dadosVolumesFaturados[14] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno2((Integer) dadosVolumesFaturados[14]);
				}

				// Consumo Mês/Ano 3
				if(dadosVolumesFaturados[15] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno3((Integer) dadosVolumesFaturados[15]);
				}

				// Consumo Mês/Ano 4
				if(dadosVolumesFaturados[16] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno4((Integer) dadosVolumesFaturados[16]);
				}

				// Consumo Mês/Ano 5
				if(dadosVolumesFaturados[17] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno5((Integer) dadosVolumesFaturados[17]);
				}

				retorno.add(volumesFaturadosRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório resumido
	 * [UC0637] - Gerar Relatórios Volumes Faturados
	 * 
	 * @author Rafael Corrêa
	 * @created 13/09/2007
	 * @throws ControladorException
	 */
	public Collection<VolumesFaturadosRelatorioHelper> pesquisarDadosRelatorioVolumesFaturadosResumido(Integer idLocalidade,
					Integer anoMes, Integer anoMesInformado, Integer anoMes1, Integer anoMes2, Integer anoMes3, Integer anoMes4,
					Integer anoMes5) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosVolumesFaturados = null;

		try{
			colecaoDadosVolumesFaturados = repositorioFaturamento.pesquisarDadosRelatorioVolumesFaturadosResumido(idLocalidade, anoMes,
							anoMesInformado, anoMes1, anoMes2, anoMes3, anoMes4, anoMes5);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDadosVolumesFaturados != null && !colecaoDadosVolumesFaturados.isEmpty()){

			Iterator colecaoDadosVolumesFaturadosIterator = colecaoDadosVolumesFaturados.iterator();

			while(colecaoDadosVolumesFaturadosIterator.hasNext()){

				// Obtém os dados do débito cobrado
				Object[] dadosVolumesFaturados = (Object[]) colecaoDadosVolumesFaturadosIterator.next();

				VolumesFaturadosRelatorioHelper volumesFaturadosRelatorioHelper = new VolumesFaturadosRelatorioHelper();

				// Id da Localidade
				if(dadosVolumesFaturados[0] != null){
					volumesFaturadosRelatorioHelper.setIdLocalidade((Integer) dadosVolumesFaturados[0]);
				}

				// Nome da Localidade
				if(dadosVolumesFaturados[1] != null){
					volumesFaturadosRelatorioHelper.setNomeLocalidade((String) dadosVolumesFaturados[1]);
				}

				// Id do Setor Comercial
				if(dadosVolumesFaturados[2] != null){
					volumesFaturadosRelatorioHelper.setIdSetorComercial((Integer) dadosVolumesFaturados[2]);
				}

				// Código do Setor Comercial
				if(dadosVolumesFaturados[3] != null){
					volumesFaturadosRelatorioHelper.setCodigoSetorComercial((Integer) dadosVolumesFaturados[3]);
				}

				// Nome do Setor Comercial
				if(dadosVolumesFaturados[4] != null){
					volumesFaturadosRelatorioHelper.setNomeSetorComercial((String) dadosVolumesFaturados[4]);
				}

				// Número da Quadra
				if(dadosVolumesFaturados[5] != null){
					volumesFaturadosRelatorioHelper.setNumeroQuadra((Integer) dadosVolumesFaturados[5]);
				}

				// Consumo Médio
				if(dadosVolumesFaturados[6] != null){
					volumesFaturadosRelatorioHelper.setMediaConsumo((Integer) dadosVolumesFaturados[6]);
				}

				// Consumo Mês/Ano Informado
				if(dadosVolumesFaturados[7] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAnoInformado((Integer) dadosVolumesFaturados[7]);
				}

				// Consumo Mês/Ano 1
				if(dadosVolumesFaturados[8] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno1((Integer) dadosVolumesFaturados[8]);
				}

				// Consumo Mês/Ano 2
				if(dadosVolumesFaturados[9] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno2((Integer) dadosVolumesFaturados[9]);
				}

				// Consumo Mês/Ano 3
				if(dadosVolumesFaturados[10] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno3((Integer) dadosVolumesFaturados[10]);
				}

				// Consumo Mês/Ano 4
				if(dadosVolumesFaturados[11] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno4((Integer) dadosVolumesFaturados[11]);
				}

				// Consumo Mês/Ano 5
				if(dadosVolumesFaturados[12] != null){
					volumesFaturadosRelatorioHelper.setConsumoMesAno5((Integer) dadosVolumesFaturados[12]);
				}

				retorno.add(volumesFaturadosRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * @throws ControladorException
	 */
	public Collection<ContasEmRevisaoRelatorioHelper> pesquisarDadosRelatorioContasRevisao(Integer idGerenciaRegional,
					Integer idUnidadeNegocio, Integer idElo, Integer idLocalidadeInicial, Integer idLocalidadeFinal,
					Integer idMotivoRevisao, Integer idImovelPerfil, Integer referenciaInicial, Integer referenciaFinal)
					throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosContasEmRevisao = null;

		try{
			colecaoDadosContasEmRevisao = repositorioFaturamento.pesquisarDadosRelatorioContasRevisao(idGerenciaRegional, idUnidadeNegocio,
							idElo, idLocalidadeInicial, idLocalidadeFinal, idMotivoRevisao, idImovelPerfil, referenciaInicial,
							referenciaFinal);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDadosContasEmRevisao != null && !colecaoDadosContasEmRevisao.isEmpty()){

			Iterator colecaoDadosContasEmRevisaoIterator = colecaoDadosContasEmRevisao.iterator();

			while(colecaoDadosContasEmRevisaoIterator.hasNext()){

				// Obtém os dados do débito cobrado
				Object[] dadosContasEmRevisao = (Object[]) colecaoDadosContasEmRevisaoIterator.next();

				ContasEmRevisaoRelatorioHelper contasEmRevisaoRelatorioHelper = new ContasEmRevisaoRelatorioHelper();

				// Id do Imóvel
				if(dadosContasEmRevisao[0] != null){
					contasEmRevisaoRelatorioHelper.setIdImovel((Integer) dadosContasEmRevisao[0]);
				}

				// Id da Gerência Regional
				if(dadosContasEmRevisao[1] != null){
					contasEmRevisaoRelatorioHelper.setIdGerenciaRegional((Integer) dadosContasEmRevisao[1]);
				}

				// Nome da Gerência Regional
				if(dadosContasEmRevisao[2] != null){
					contasEmRevisaoRelatorioHelper.setNomeGerenciaRegional((String) dadosContasEmRevisao[2]);
				}

				// Id do Elo
				if(dadosContasEmRevisao[3] != null){
					contasEmRevisaoRelatorioHelper.setIdElo((Integer) dadosContasEmRevisao[3]);
				}

				// Nome do Elo
				if(dadosContasEmRevisao[4] != null){
					contasEmRevisaoRelatorioHelper.setNomeElo((String) dadosContasEmRevisao[4]);
				}

				// Id da Localidade
				if(dadosContasEmRevisao[5] != null){
					contasEmRevisaoRelatorioHelper.setIdLocalidade((Integer) dadosContasEmRevisao[5]);
				}

				// Nome da Localidade
				if(dadosContasEmRevisao[6] != null){
					contasEmRevisaoRelatorioHelper.setNomeLocalidade((String) dadosContasEmRevisao[6]);
				}

				// Código do Setor Comercial
				if(dadosContasEmRevisao[7] != null){
					contasEmRevisaoRelatorioHelper.setCodigoSetorComercial((Integer) dadosContasEmRevisao[7]);
				}

				// Número da Quadra
				if(dadosContasEmRevisao[8] != null){
					contasEmRevisaoRelatorioHelper.setNumeroQuadra((Integer) dadosContasEmRevisao[8]);
				}

				// Lote
				if(dadosContasEmRevisao[9] != null){
					contasEmRevisaoRelatorioHelper.setLote((Short) dadosContasEmRevisao[9]);
				}

				// Sublote
				if(dadosContasEmRevisao[10] != null){
					contasEmRevisaoRelatorioHelper.setSublote((Short) dadosContasEmRevisao[10]);
				}

				// Nome do Usuário
				if(dadosContasEmRevisao[11] != null){
					contasEmRevisaoRelatorioHelper.setNomeUsuario((String) dadosContasEmRevisao[11]);
				}

				// DDD
				if(dadosContasEmRevisao[12] != null){
					contasEmRevisaoRelatorioHelper.setDdd((String) dadosContasEmRevisao[12]);
				}

				// Número do Telefone
				if(dadosContasEmRevisao[13] != null){
					contasEmRevisaoRelatorioHelper.setTelefone((String) dadosContasEmRevisao[13]);
				}

				// Ramal
				if(dadosContasEmRevisao[14] != null){
					contasEmRevisaoRelatorioHelper.setRamal((String) dadosContasEmRevisao[14]);
				}

				// Mês/Ano de Referência da Conta
				if(dadosContasEmRevisao[15] != null){
					contasEmRevisaoRelatorioHelper.setAnoMesReferenciaConta((Integer) dadosContasEmRevisao[15]);
				}

				// Valor da Conta
				if(dadosContasEmRevisao[16] != null){
					contasEmRevisaoRelatorioHelper.setValorConta((BigDecimal) dadosContasEmRevisao[16]);
				}

				// Data de Revisão
				if(dadosContasEmRevisao[17] != null){
					contasEmRevisaoRelatorioHelper.setDataRevisao((Date) dadosContasEmRevisao[17]);
				}

				// Id do Motivo de Revisão
				if(dadosContasEmRevisao[18] != null){
					contasEmRevisaoRelatorioHelper.setIdMotivoRevisao((Integer) dadosContasEmRevisao[18]);
				}

				// Descrição do Motivo de Revisão
				if(dadosContasEmRevisao[19] != null){
					contasEmRevisaoRelatorioHelper.setDescricaoMotivoRevisao((String) dadosContasEmRevisao[19]);
				}

				// Id da Gerência Regional
				if(dadosContasEmRevisao[20] != null){
					contasEmRevisaoRelatorioHelper.setIdUnidadeNegocio((Integer) dadosContasEmRevisao[20]);
				}

				// Nome da Gerência Regional
				if(dadosContasEmRevisao[21] != null){
					contasEmRevisaoRelatorioHelper.setNomeUnidadeNegocio((String) dadosContasEmRevisao[21]);
				}

				// Id do Perfil do imóvel
				if(dadosContasEmRevisao[22] != null){
					contasEmRevisaoRelatorioHelper.setIdPerfilImovel((String) dadosContasEmRevisao[22].toString());
				}

				// Descrição do Perfil do imóvel
				if(dadosContasEmRevisao[23] != null){
					contasEmRevisaoRelatorioHelper.setDescricaoPerfilImovel((String) dadosContasEmRevisao[23]);
				}

				if(dadosContasEmRevisao[24] != null){
					contasEmRevisaoRelatorioHelper.setExistePagamento((String) dadosContasEmRevisao[24]);
				}

				retorno.add(contasEmRevisaoRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * pesquisa os dados nessesários para a geracao do relatório analitico de contas
	 * 
	 * @author Adriano Sousa
	 * @created09/10/2014
	 * @throws ControladorException
	 */
	public Collection<RelatorioAnaliticoContasHelper> pesquisarDadosRelatorioAnaliticoContas(Integer idGerenciaRegional,
					Integer idLocalidade, Integer idCategoria, Integer idCliente, Integer IdImovel, Integer idSituacao,
					Integer motivoRetificacao, Integer referencia, Integer faturamentoGrupo, Integer setorComercial, Integer quadra)
					throws ControladorException{

		Collection retorno = new ArrayList();


		// Criação das coleções
		Collection colecaoRelatorioAnaliticoContas = null;



		try{
			colecaoRelatorioAnaliticoContas = repositorioFaturamento.pesquisarDadosRelatorioAnaliticoContas(idGerenciaRegional,
							idLocalidade, idCategoria, idCliente, IdImovel, idSituacao, motivoRetificacao, referencia, faturamentoGrupo,
							setorComercial, quadra);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoRelatorioAnaliticoContas != null && !colecaoRelatorioAnaliticoContas.isEmpty()){

			Iterator colecaoDadosRelatorioAnaliticoContasIterator = colecaoRelatorioAnaliticoContas.iterator();

			while(colecaoDadosRelatorioAnaliticoContasIterator.hasNext()){
				
				// Obtém os dados
				Object[] dadosRelatorioAnaliticoContas = (Object[]) colecaoDadosRelatorioAnaliticoContasIterator.next();

				RelatorioAnaliticoContasHelper relatorioAnaliticoContasHelper = new RelatorioAnaliticoContasHelper();

				/*
				 * 0 origem
				 * 1 matricula
				 * 2 usuario_titular_conta
				 * 3 referencia
				 * 4 valor_original
				 * 5 valor_refaturado
				 * 6 data_alteracao
				 * 7 hora_alteracao
				 * 8 motivo_refaturamento
				 * 9 motivo_cancelamento
				 * 10 usuario_gsan
				 */

				// Origem
				if(dadosRelatorioAnaliticoContas[0] != null){
					relatorioAnaliticoContasHelper.setOrigem((String) dadosRelatorioAnaliticoContas[0]);
				}

				// ID do imovel (matricula)
				if(dadosRelatorioAnaliticoContas[1] != null){
					relatorioAnaliticoContasHelper.setIdImovel((String) dadosRelatorioAnaliticoContas[1]);
				}
				// usuario_titular_conta
				if(dadosRelatorioAnaliticoContas[2] != null){
					relatorioAnaliticoContasHelper.setUsuarioGsan((String) dadosRelatorioAnaliticoContas[2]);
				}
				// Referencia
				if(dadosRelatorioAnaliticoContas[3] != null){
					relatorioAnaliticoContasHelper.setReferencia((String) dadosRelatorioAnaliticoContas[3]);
				}

				// valor_original
				if(dadosRelatorioAnaliticoContas[4] != null){
					relatorioAnaliticoContasHelper.setValorAnterior((BigDecimal) dadosRelatorioAnaliticoContas[4]);
				}

				// valor_refaturado
				if(dadosRelatorioAnaliticoContas[5] != null){
					relatorioAnaliticoContasHelper.setValorAtual((BigDecimal) dadosRelatorioAnaliticoContas[5]);
				}

				// data_alteracao
				if(dadosRelatorioAnaliticoContas[6] != null){
					relatorioAnaliticoContasHelper.setUltimaAlteracao((Date) dadosRelatorioAnaliticoContas[6]);
				}

				// hora_alteracao
				if(dadosRelatorioAnaliticoContas[7] != null){
					relatorioAnaliticoContasHelper.setHora((String) dadosRelatorioAnaliticoContas[7]);
				}
				// motivo
				if(dadosRelatorioAnaliticoContas[8] != null){
					relatorioAnaliticoContasHelper.setMotivo((String) dadosRelatorioAnaliticoContas[8]);
				}
				// usuario_gsan
				if(dadosRelatorioAnaliticoContas[9] != null){
					relatorioAnaliticoContasHelper.setUsuarioGsan((String) dadosRelatorioAnaliticoContas[9]);
				}


				retorno.add(relatorioAnaliticoContasHelper);
			}
		}

		return retorno;
	}


	/**
	 * Pesquisa os dados necessário para a geração do relatório resumido
	 * [UC0635] - Gerar Relatórios de Contas em Revisão
	 * 
	 * @author Rafael Corrêa
	 * @created 20/09/2007
	 * @throws ControladorException
	 */
	public Collection<ContasEmRevisaoRelatorioHelper> pesquisarDadosRelatorioContasRevisaoResumido(Integer idGerenciaRegional,
					Integer idElo, Integer idLocalidadeInicial, Integer idLocalidadeFinal, Integer idMotivoRevisao, Integer idImovelPerfil,
					Integer referenciaInicial, Integer referenciaFinal) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosContasEmRevisao = null;

		try{
			colecaoDadosContasEmRevisao = repositorioFaturamento.pesquisarDadosRelatorioContasRevisaoResumido(idGerenciaRegional, idElo,
							idLocalidadeInicial, idLocalidadeFinal, idMotivoRevisao, idImovelPerfil, referenciaInicial, referenciaFinal);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDadosContasEmRevisao != null && !colecaoDadosContasEmRevisao.isEmpty()){

			Iterator colecaoDadosContasEmRevisaoIterator = colecaoDadosContasEmRevisao.iterator();

			while(colecaoDadosContasEmRevisaoIterator.hasNext()){

				// Obtém os dados do débito cobrado
				Object[] dadosContasEmRevisao = (Object[]) colecaoDadosContasEmRevisaoIterator.next();

				ContasEmRevisaoRelatorioHelper contasEmRevisaoRelatorioHelper = new ContasEmRevisaoRelatorioHelper();

				// Id da Gerência Regional
				if(dadosContasEmRevisao[0] != null){
					contasEmRevisaoRelatorioHelper.setIdGerenciaRegional((Integer) dadosContasEmRevisao[0]);
				}

				// Nome da Gerência Regional
				if(dadosContasEmRevisao[1] != null){
					contasEmRevisaoRelatorioHelper.setNomeGerenciaRegional((String) dadosContasEmRevisao[1]);
				}

				// Id do Elo
				if(dadosContasEmRevisao[2] != null){
					contasEmRevisaoRelatorioHelper.setIdElo((Integer) dadosContasEmRevisao[2]);
				}

				// Nome do Elo
				if(dadosContasEmRevisao[3] != null){
					contasEmRevisaoRelatorioHelper.setNomeElo((String) dadosContasEmRevisao[3]);
				}

				// Id da Localidade
				if(dadosContasEmRevisao[4] != null){
					contasEmRevisaoRelatorioHelper.setIdLocalidade((Integer) dadosContasEmRevisao[4]);
				}

				// Nome da Localidade
				if(dadosContasEmRevisao[5] != null){
					contasEmRevisaoRelatorioHelper.setNomeLocalidade((String) dadosContasEmRevisao[5]);
				}

				// Mês/Ano de Referência da Conta
				if(dadosContasEmRevisao[6] != null){
					contasEmRevisaoRelatorioHelper.setAnoMesReferenciaConta((Integer) dadosContasEmRevisao[6]);
				}

				// Id do Motivo de Revisão
				if(dadosContasEmRevisao[7] != null){
					contasEmRevisaoRelatorioHelper.setIdMotivoRevisao((Integer) dadosContasEmRevisao[7]);
				}

				// Descrição do Motivo de Revisão
				if(dadosContasEmRevisao[8] != null){
					contasEmRevisaoRelatorioHelper.setDescricaoMotivoRevisao((String) dadosContasEmRevisao[8]);
				}

				// Quantidade de Contas
				if(dadosContasEmRevisao[9] != null){
					contasEmRevisaoRelatorioHelper.setQtdeContas((Integer) dadosContasEmRevisao[9]);
				}

				// Valor da Conta
				if(dadosContasEmRevisao[10] != null){
					contasEmRevisaoRelatorioHelper.setValorConta((BigDecimal) dadosContasEmRevisao[10]);
				}

				retorno.add(contasEmRevisaoRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [UC0638] - Gerar Relatórios Anormalidade Consumo
	 * 
	 * @author Rafael Corrêa
	 * @created 15/10/2007
	 * @throws ControladorException
	 */
	public Collection<GerarRelatorioAnormalidadeConsumoHelper> pesquisarDadosRelatorioAnormalidadeConsumo(Integer idGrupoFaturamento,
					Short codigoRota, Integer idGerenciaRegional, Integer idUnidadeNegocio, Integer idElo, Integer idLocalidadeInicial,
					Integer idLocalidadeFinal, Integer referencia, Integer idImovelPerfil, Integer numOcorConsecutivas,
					String indicadorOcorrenciasIguais, Integer mediaConsumoInicial, Integer mediaConsumoFinal,
					Integer idAnormalidadeConsumo, Integer idAnormalidadeLeitura) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoDadosAnormalidadesConsumo = null;

		try{
			colecaoDadosAnormalidadesConsumo = repositorioFaturamento.pesquisarDadosRelatorioAnormalidadeConsumo(idGrupoFaturamento,
							codigoRota, idGerenciaRegional, idUnidadeNegocio, idElo, idLocalidadeInicial, idLocalidadeFinal, referencia,
							idImovelPerfil, numOcorConsecutivas, indicadorOcorrenciasIguais, mediaConsumoInicial, mediaConsumoFinal,
							idAnormalidadeConsumo, idAnormalidadeLeitura);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoDadosAnormalidadesConsumo != null && !colecaoDadosAnormalidadesConsumo.isEmpty()){

			Iterator colecaoDadosAnormalidadesConsumoIterator = colecaoDadosAnormalidadesConsumo.iterator();

			while(colecaoDadosAnormalidadesConsumoIterator.hasNext()){

				// Obtém os dados do débito cobrado
				Object[] dadosAnormalidadesConsumo = (Object[]) colecaoDadosAnormalidadesConsumoIterator.next();

				GerarRelatorioAnormalidadeConsumoHelper gerarRelatorioAnormalidadeConsumoHelper = new GerarRelatorioAnormalidadeConsumoHelper();

				// Id do Grupo de Faturamento
				if(dadosAnormalidadesConsumo[0] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setIdGrupo((Integer) dadosAnormalidadesConsumo[0]);
				}

				// Nome do Grupo de Faturamento
				if(dadosAnormalidadesConsumo[1] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setNomeGrupo((String) dadosAnormalidadesConsumo[1]);
				}

				// Id da Gerência Regional
				if(dadosAnormalidadesConsumo[2] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setIdGerenciaRegional((Integer) dadosAnormalidadesConsumo[2]);
				}

				// Nome da Gerência Regional
				if(dadosAnormalidadesConsumo[3] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setNomeGerenciaRegional((String) dadosAnormalidadesConsumo[3]);
				}

				// Id da Unidade de Negócio
				if(dadosAnormalidadesConsumo[4] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setIdUnidadeNegocio((Integer) dadosAnormalidadesConsumo[4]);
				}

				// Nome da Unidade de Negócio
				if(dadosAnormalidadesConsumo[5] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setNomeUnidadeNegocio((String) dadosAnormalidadesConsumo[5]);
				}

				// Id do Elo
				if(dadosAnormalidadesConsumo[6] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setIdElo((Integer) dadosAnormalidadesConsumo[6]);
				}

				// Nome do Elo
				if(dadosAnormalidadesConsumo[7] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setNomeElo((String) dadosAnormalidadesConsumo[7]);
				}

				// Id da Localidade
				if(dadosAnormalidadesConsumo[8] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setIdLocalidade((Integer) dadosAnormalidadesConsumo[8]);
				}

				// Nome da Localidade
				if(dadosAnormalidadesConsumo[9] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setNomeLocalidade((String) dadosAnormalidadesConsumo[9]);
				}

				// Id do Imóvel
				if(dadosAnormalidadesConsumo[10] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setIdImovel((Integer) dadosAnormalidadesConsumo[10]);
				}

				// Nome do Usuário
				if(dadosAnormalidadesConsumo[11] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setNomeUsuario((String) dadosAnormalidadesConsumo[11]);
				}

				// Id da Situação de Água
				if(dadosAnormalidadesConsumo[12] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setSituacaoLigacaoAgua((Integer) dadosAnormalidadesConsumo[12]);
				}

				// Id da Situação de Esgoto
				if(dadosAnormalidadesConsumo[13] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setSituacaoLigacaoEsgoto((Integer) dadosAnormalidadesConsumo[13]);
				}

				// Indicador de Débito Automático
				if(dadosAnormalidadesConsumo[14] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setIndicadorDebito((Short) dadosAnormalidadesConsumo[14]);
				}

				// Consumo Médio
				if(dadosAnormalidadesConsumo[15] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setConsumoMedio((Integer) dadosAnormalidadesConsumo[15]);
				}

				// Consumo do Mês
				if(dadosAnormalidadesConsumo[16] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setConsumoMes((Integer) dadosAnormalidadesConsumo[16]);
				}

				// Descrição Abreviada da Anormalidade de Consumo
				if(dadosAnormalidadesConsumo[17] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setDescricaoAbrevConsumoAnormalidade((String) dadosAnormalidadesConsumo[17]);
				}

				// Id da Anormalidade de Leitura
				if(dadosAnormalidadesConsumo[18] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setIdLeituraAnormalidade((Integer) dadosAnormalidadesConsumo[18]);
				}

				// Quantidade de Economias
				if(dadosAnormalidadesConsumo[19] != null){
					gerarRelatorioAnormalidadeConsumoHelper.setQuantidadeEconomias((Short) dadosAnormalidadesConsumo[19]);
				}

				// Tipo de Medição
				if(dadosAnormalidadesConsumo[20] != null){

					if(dadosAnormalidadesConsumo[20].equals(MedicaoTipo.POCO)){

						gerarRelatorioAnormalidadeConsumoHelper.setTipoMedicao("PC");

						// Descrição Abreviada da Capacidade do Hidrômetro do
						// Poço
						if(dadosAnormalidadesConsumo[21] != null){
							gerarRelatorioAnormalidadeConsumoHelper.setCapacidadeHidrometro((String) dadosAnormalidadesConsumo[21]);
						}

						// Descrição Abreviada do Local de Instalação do
						// Hidrômetro do Poço
						if(dadosAnormalidadesConsumo[22] != null){
							gerarRelatorioAnormalidadeConsumoHelper.setLocalInstalacaoHidrometro((String) dadosAnormalidadesConsumo[22]);
						}

					}else{
						gerarRelatorioAnormalidadeConsumoHelper.setTipoMedicao("LA");

						// Descrição Abreviada da Capacidade do Hidrômetro da
						// Ligação de Água
						if(dadosAnormalidadesConsumo[23] != null){
							gerarRelatorioAnormalidadeConsumoHelper.setCapacidadeHidrometro((String) dadosAnormalidadesConsumo[23]);
						}

						// Descrição Abreviada do Local de Instalação do
						// Hidrômetro da Ligação de Água
						if(dadosAnormalidadesConsumo[24] != null){
							gerarRelatorioAnormalidadeConsumoHelper.setLocalInstalacaoHidrometro((String) dadosAnormalidadesConsumo[24]);
						}

					}

				}else{
					gerarRelatorioAnormalidadeConsumoHelper.setTipoMedicao("LA");

					// Descrição Abreviada da Capacidade do Hidrômetro da
					// Ligação de Água
					if(dadosAnormalidadesConsumo[23] != null){
						gerarRelatorioAnormalidadeConsumoHelper.setCapacidadeHidrometro((String) dadosAnormalidadesConsumo[23]);
					}

					// Descrição Abreviada do Local de Instalação do Hidrômetro
					// da Ligação de Água
					if(dadosAnormalidadesConsumo[24] != null){
						gerarRelatorioAnormalidadeConsumoHelper.setLocalInstalacaoHidrometro((String) dadosAnormalidadesConsumo[24]);
					}

				}

				retorno.add(gerarRelatorioAnormalidadeConsumoHelper);
			}
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Gerar um perído de leitura para faturamento
	 * 
	 * @author Raphael Rossiter
	 * @data 18/09/2007
	 */
	public Date[] gerarPeriodoLeituraFaturamento(Date dataLeituraAtualFaturamento, Date dataLeituraAnteriorFaturamento,
					FaturamentoAtivCronRota faturamentoAtivCronRota, Integer anoMesAnterior, Integer anoMesReferencia)
					throws ControladorException{

		Date[] periodoFaturamento = new Date[2];

		if(dataLeituraAtualFaturamento != null){

			periodoFaturamento[1] = dataLeituraAtualFaturamento;

			// Obter data Prevista do cronograma do mês anterior
			try{

				if(!Util.isVazioOuBranco(faturamentoAtivCronRota) && !Util.isVazioOuBranco(faturamentoAtivCronRota.getRota())
								&& !Util.isVazioOuBranco(faturamentoAtivCronRota.getRota().getFaturamentoGrupo())){
					dataLeituraAnteriorFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataPrevista(
									faturamentoAtivCronRota.getRota().getFaturamentoGrupo().getId(), FaturamentoAtividade.EFETUAR_LEITURA,
									anoMesAnterior);
				}

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			/*
			 * Caso a data prevista do cronograma anterior esteja nula, a data de leitura anterior
			 * do faturamento será: a data de leitura atual menos
			 * 30 dias
			 */
			if(dataLeituraAnteriorFaturamento == null){
				dataLeituraAnteriorFaturamento = Util.subtrairNumeroDiasDeUmaData(dataLeituraAtualFaturamento, 30);

			}

			periodoFaturamento[0] = dataLeituraAnteriorFaturamento;

		}else if(dataLeituraAnteriorFaturamento != null){

			periodoFaturamento[0] = dataLeituraAnteriorFaturamento;

			/*
			 * Caso a data de leitura anterior NÃO esteja nula: a data de leitura atual será a data
			 * de leitura anterior acrescida de mais 30 dias.
			 */
			dataLeituraAtualFaturamento = Util.adicionarNumeroDiasDeUmaData(dataLeituraAnteriorFaturamento, 30);

			periodoFaturamento[1] = dataLeituraAtualFaturamento;
		}else{

			/*
			 * Caso as datas de letira anterior e atual estejam nulas, o periodo será gerado a
			 * partir do anoMes de referencia da conta.
			 */
			int mesConta = Util.obterMes(anoMesReferencia);
			int anoConta = Util.obterAno(anoMesReferencia);

			int ultimoDiaMes = Integer.valueOf(Util.obterUltimoDiaMes(mesConta, anoConta));

			dataLeituraAtualFaturamento = Util.criarData(ultimoDiaMes, mesConta, anoConta);

			dataLeituraAnteriorFaturamento = Util.criarData(1, mesConta, anoConta);

			periodoFaturamento[0] = dataLeituraAnteriorFaturamento;
			periodoFaturamento[1] = dataLeituraAtualFaturamento;
		}

		return periodoFaturamento;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 18/09/2007
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasAtualizacaoTarifaria(Integer idImovel, Integer inicialReferencia, Integer finalReferencia,
					Date inicialVencimento, Date finalVencimento) throws ControladorException{

		Collection retorno = null;
		Collection colecaoContasAtualizacaoTarifaria = null;
		Conta conta = null;

		try{

			colecaoContasAtualizacaoTarifaria = repositorioFaturamento.pesquisarContasAtualizacaoTarifaria(idImovel, inicialReferencia,
							finalReferencia, inicialVencimento, finalVencimento);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoContasAtualizacaoTarifaria != null && !colecaoContasAtualizacaoTarifaria.isEmpty()){

			Iterator colecaoContasAtualizacaoTarifariaIterator = colecaoContasAtualizacaoTarifaria.iterator();
			retorno = new ArrayList();

			while(colecaoContasAtualizacaoTarifariaIterator.hasNext()){

				Object[] arrayConta = (Object[]) colecaoContasAtualizacaoTarifariaIterator.next();
				conta = new Conta();

				conta.setId((Integer) arrayConta[0]);

				if(arrayConta[1] != null){
					conta.setConsumoAgua((Integer) arrayConta[1]);
				}

				if(arrayConta[2] != null){
					conta.setConsumoEsgoto((Integer) arrayConta[2]);
				}

				LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
				ligacaoAguaSituacao.setId((Integer) arrayConta[3]);

				conta.setLigacaoAguaSituacao(ligacaoAguaSituacao);

				LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
				ligacaoEsgotoSituacao.setId((Integer) arrayConta[4]);

				conta.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

				ConsumoTarifa consumoTarifa = new ConsumoTarifa();
				consumoTarifa.setId((Integer) arrayConta[5]);

				conta.setConsumoTarifa(consumoTarifa);

				if(arrayConta[6] != null){
					conta.setPercentualEsgoto((BigDecimal) arrayConta[6]);
				}

				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				faturamentoGrupo.setId((Integer) arrayConta[10]);

				Rota rota = new Rota();
				rota.setId((Integer) arrayConta[9]);
				rota.setFaturamentoGrupo(faturamentoGrupo);

				Quadra quadra = new Quadra();
				quadra.setId((Integer) arrayConta[8]);
				quadra.setRota(rota);

				Imovel imovel = new Imovel();
				imovel.setId((Integer) arrayConta[7]);

				imovel.setQuadra(quadra);
				imovel.setRota(rota);
				conta.setImovel(imovel);

				if(arrayConta[11] != null){
					conta.setValorAgua((BigDecimal) arrayConta[11]);
				}

				if(arrayConta[12] != null){
					conta.setValorEsgoto((BigDecimal) arrayConta[12]);
				}

				conta.setReferencia((Integer) arrayConta[13]);

				retorno.add(conta);
			}

		}
		return retorno;

	}

	/**
	 * Pesquisa os Valores das Faixas de Débitos
	 * 
	 * @author Ivan Sérgio
	 * @created 14/09/2007
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDebitoFaixaValores(Integer idFaixaValor, Double valorFaixa) throws ControladorException{

		Collection colecaoDebitoFaixaValores = null;

		try{
			colecaoDebitoFaixaValores = repositorioFaturamento.pesquisarDebitoFaixaValores(idFaixaValor, valorFaixa);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return colecaoDebitoFaixaValores;
	}

	/**
	 * [UC0597] - Atualizar Qualidade de Água
	 * 
	 * @param ids
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void removerQualidadeAgua(String[] ids, Usuario usuarioLogado) throws ControladorException{

		for(int i = 0; i < ids.length; i++){
			String idQualidadeAgua = ids[i];

			FiltroQualidadeAgua filtroQualidadeAgua = new FiltroQualidadeAgua();
			filtroQualidadeAgua.adicionarParametro(new ParametroSimples(FiltroQualidadeAgua.ID, idQualidadeAgua));
			filtroQualidadeAgua.setInitializeLazy(true);

			Collection colecaoQualidade = getControladorUtil().pesquisar(filtroQualidadeAgua, QualidadeAgua.class.getName());
			QualidadeAgua qualidadeAguaExclusao = (QualidadeAgua) colecaoQualidade.iterator().next();

			try{
				if(!repositorioFaturamento.verificarExistenciaFaturamentoQualidadeAgua(qualidadeAguaExclusao)){
					throw new ControladorException("atencao.qualidade.utilizada_em_faturamento_anterior");
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
		}

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_QUALIDADE_AGUA_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// [SB0002]
		this.getControladorUtil().remover(ids, QualidadeAgua.class.getName(), null, null);
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0003] - Obter Diferenças de Valores de Créditos
	 * Realizados de Conta Retificada Author: Pedro
	 * Alexandre Data: 27/10/2007
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsOrigemCredito
	 * @throws ControladorException
	 */
	private BigDecimal obterDiferencaValoresCreditosRealizadosContaRetificada(int anoMesReferencia, int idLocalidade, int idCategoria,
					Integer[] idsOrigemCredito) throws ControladorException{

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal diferenca = BigDecimal.ZERO;
		BigDecimal valorCreditoRealizadoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorCreditoRealizadoSituacaoRetificada = null;

		try{
			// obtém o valor dos creditos realizados cancelados do retificação
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesReferencia, idLocalidade, idCategoria,
											idsOrigemCredito, DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO);

			// obtém o valor dos creditos realizados retificados
			valorCreditoRealizadoSituacaoRetificada = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCredito(anoMesReferencia, idLocalidade, idCategoria,
											idsOrigemCredito, DebitoCreditoSituacao.RETIFICADA, DebitoCreditoSituacao.RETIFICADA);

			// erro no hibernate
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		if(valorCreditoRealizadoSituacaoCanceladoPorRetificacao == null){
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
		}

		if(valorCreditoRealizadoSituacaoRetificada == null){
			valorCreditoRealizadoSituacaoRetificada = BigDecimal.ZERO;
		}

		diferenca = valorCreditoRealizadoSituacaoCanceladoPorRetificacao.subtract(valorCreditoRealizadoSituacaoRetificada);

		return diferenca;
	}

	/**
	 * [UC0155] - Encerrar Faturamento do Mês [SB0003] - Obter Diferenças de Valores de Créditos
	 * Realizados de Conta Retificada Author: Pedro
	 * Alexandre Data: 27/10/2007
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param idCategoria
	 * @param idsOrigemCredito
	 * @param idLancamentoItemContabil
	 * @throws ControladorException
	 */
	private BigDecimal obterDiferencaValoresCreditosRealizadosContaRetificada(int anoMesReferencia, int idLocalidade, int idCategoria,
					Integer[] idsOrigemCredito, Integer idLancamentoItemContabil) throws ControladorException{

		// cria as variáveis para armazenar os valores do débitos cobrados
		// cancelados por retificação e retificado
		BigDecimal diferenca = BigDecimal.ZERO;
		BigDecimal valorCreditoRealizadoSituacaoCanceladoPorRetificacao = null;
		BigDecimal valorCreditoRealizadoSituacaoRetificada = null;

		try{
			// obtém o valor dos creditos realizados cancelados do retificação
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(anoMesReferencia,
											idLocalidade, idCategoria, idsOrigemCredito, DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO,
											idLancamentoItemContabil);

			// obtém o valor dos creditos realizados retificados
			valorCreditoRealizadoSituacaoRetificada = repositorioFaturamento
							.acumularValorCategoriaCreditoRealizadoCategoriaPorOrigemCreditoLancamentoItemContabil(anoMesReferencia,
											idLocalidade, idCategoria, idsOrigemCredito, DebitoCreditoSituacao.RETIFICADA,
											DebitoCreditoSituacao.RETIFICADA, idLancamentoItemContabil);

			// erro no hibernate
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		if(valorCreditoRealizadoSituacaoCanceladoPorRetificacao == null){
			valorCreditoRealizadoSituacaoCanceladoPorRetificacao = BigDecimal.ZERO;
		}

		if(valorCreditoRealizadoSituacaoRetificada == null){
			valorCreditoRealizadoSituacaoRetificada = BigDecimal.ZERO;
		}

		diferenca = valorCreditoRealizadoSituacaoCanceladoPorRetificacao.subtract(valorCreditoRealizadoSituacaoRetificada);

		return diferenca;
	}

	/**
	 * [UC0626] Gerar Resumo de Metas Acumulado no Mês (CAERN)
	 * 
	 * @author Sávio Luiz
	 * @data 28/11/2007
	 * @param idConta
	 * @return idParcelamento
	 */
	public boolean verificarDebitoMais3MesesFaturaEmAberto(Integer anoMesReferencia, Integer idImovel) throws ControladorException{

		boolean verificarDebito = false;

		Collection idsContas = null;
		try{
			idsContas = repositorioFaturamento.pesquisarIdsContasDoImovelPorMesAnoReferencia(anoMesReferencia, idImovel);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
		}

		if(idsContas != null && idsContas.size() > 3){
			Collection colecaoPagamento = getControladorArrecadacao().pesquisarPagamentoDeContas(idsContas);

			if(colecaoPagamento == null || colecaoPagamento.isEmpty()){
				verificarDebito = true;
			}
		}

		return verificarDebito;
	}

	public Boolean pesquisarExisteciaParcelamentoConta(Integer idConta) throws ControladorException{

		Collection<Integer> tiposParcelamento = Util
						.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar());

		try{
			return repositorioFaturamento.pesquisarExisteciaParcelamentoConta(idConta, tiposParcelamento);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	// /////////////////////////////////////////////////////////////////////////

	/**
	 * [UC0348] Emitir Contas
	 * 
	 * @author Sávio Luiz, Vivianne Sousa
	 * @date 08/01/2007,29/11/2007
	 * @return
	 * @throws ControladorException
	 */
	protected Collection<EmitirContaHelper> formatarEmitirContasHelperOuFichaCompensacao(Collection colecaoPamsContas, int i){

		Collection<EmitirContaHelper> colecaoContas = new ArrayList();
		if(colecaoPamsContas != null){
			Iterator iteColecaoContas = colecaoPamsContas.iterator();
			while(iteColecaoContas.hasNext()){
				Object[] parmsConta = (Object[]) iteColecaoContas.next();
				if(parmsConta != null){
					EmitirContaHelper emitirContaHelper = new EmitirContaHelper();
					// id da conta
					if(parmsConta[0] != null){
						emitirContaHelper.setIdConta((Integer) parmsConta[0]);
					}
					if(i == 3 || i == 4){
						// nome cliente
						if(parmsConta[1] != null){
							emitirContaHelper.setNomeCliente((String) parmsConta[1]);
						}
						// nome cliente
						if(parmsConta[32] != null){
							emitirContaHelper.setNomeImovel((String) parmsConta[32]);
						}
					}else{
						if(parmsConta[32] != null){
							emitirContaHelper.setNomeCliente((String) parmsConta[32]);
						}else{
							// nome cliente
							if(parmsConta[1] != null){
								emitirContaHelper.setNomeCliente((String) parmsConta[1]);
							}
						}
					}
					// data vencimento da conta
					if(parmsConta[2] != null){
						emitirContaHelper.setDataVencimentoConta((Date) parmsConta[2]);
					}
					// ano mes referencia da conta
					if(parmsConta[3] != null){
						emitirContaHelper.setAmReferencia((Integer) parmsConta[3]);
					}
					// digito verificador da conta
					if(parmsConta[4] != null){
						emitirContaHelper.setDigitoVerificadorConta((Short) parmsConta[4]);
					}
					// codigo setor comercial da conta
					if(parmsConta[5] != null){
						emitirContaHelper.setCodigoSetorComercialConta((Integer) parmsConta[5]);
					}
					// id da quadra da conta
					if(parmsConta[6] != null){
						emitirContaHelper.setIdQuadraConta((Integer) parmsConta[6]);
					}
					// lote da conta
					if(parmsConta[7] != null){
						emitirContaHelper.setLoteConta((Short) parmsConta[7]);
					}
					// sublote da conta
					if(parmsConta[8] != null){
						emitirContaHelper.setSubLoteConta((Short) parmsConta[8]);
					}
					// consumo agua
					if(parmsConta[9] != null){
						emitirContaHelper.setConsumoAgua((Integer) parmsConta[9]);
					}
					// consumo esgoto
					if(parmsConta[10] != null){
						emitirContaHelper.setConsumoEsgoto((Integer) parmsConta[10]);
					}
					// valor agua
					if(parmsConta[11] != null){
						emitirContaHelper.setValorAgua((BigDecimal) parmsConta[11]);
					}
					// valor esgoto
					if(parmsConta[12] != null){
						emitirContaHelper.setValorEsgoto((BigDecimal) parmsConta[12]);
					}
					// id da conta
					if(parmsConta[13] != null){
						emitirContaHelper.setDebitos((BigDecimal) parmsConta[13]);
					}
					// id da conta
					if(parmsConta[14] != null){
						emitirContaHelper.setValorCreditos((BigDecimal) parmsConta[14]);
					}
					// id da conta
					if(parmsConta[15] != null){
						emitirContaHelper.setValorImpostos((BigDecimal) parmsConta[15]);
					}
					// id da conta
					if(parmsConta[16] != null){
						emitirContaHelper.setDataValidadeConta((Date) parmsConta[16]);
					}
					// id da conta
					if(parmsConta[17] != null){
						emitirContaHelper.setIdImovel((Integer) parmsConta[17]);
					}
					// id da conta
					if(parmsConta[18] != null){
						emitirContaHelper.setIdLocalidade((Integer) parmsConta[18]);
					}
					// id da conta
					if(parmsConta[19] != null){
						emitirContaHelper.setIdGerenciaRegional((Integer) parmsConta[19]);
					}
					// id da conta
					if(parmsConta[20] != null){
						emitirContaHelper.setNomeGerenciaRegional((String) parmsConta[20]);
					}
					// id da conta
					if(parmsConta[21] != null){
						emitirContaHelper.setIdLigacaoAguaSituacao((Integer) parmsConta[21]);
					}
					// id da conta
					if(parmsConta[22] != null){
						emitirContaHelper.setIdLigacaoEsgotoSituacao((Integer) parmsConta[22]);
					}
					// id da conta
					if(parmsConta[23] != null){
						emitirContaHelper.setIdImovelPerfil((Integer) parmsConta[23]);
					}
					// id da conta
					if(parmsConta[24] != null){
						emitirContaHelper.setIdSetorComercial((Integer) parmsConta[24]);
					}
					// id da conta
					if(parmsConta[25] != null){
						emitirContaHelper.setIdFaturamentoGrupo((Integer) parmsConta[25]);
					}
					// id da conta
					if(parmsConta[26] != null){
						emitirContaHelper.setIdEmpresa((Integer) parmsConta[26]);
					}
					// id da conta
					if(parmsConta[27] != null){
						emitirContaHelper.setDescricaoLocalidade((String) parmsConta[27]);
					}
					// id da conta
					if(parmsConta[28] != null){
						emitirContaHelper.setDescricaoLigacaoAguaSituacao((String) parmsConta[28]);
					}
					// id da conta
					if(parmsConta[29] != null){
						emitirContaHelper.setDescricaoLigacaoEsgotoSituacao((String) parmsConta[29]);
					}
					// id da conta
					if(parmsConta[30] != null){
						emitirContaHelper.setPercentualEsgotoConta((BigDecimal) parmsConta[30]);
					}
					// nome cliente
					if(parmsConta[31] != null){
						emitirContaHelper.setIdClienteResponsavel("" + (Integer) parmsConta[31]);
					}

					int tam = parmsConta.length;
					if(tam > 34){
						// id da rota
						if(parmsConta[33] != null){
							emitirContaHelper.setCodigoRota((Short) parmsConta[33]);
						}

						// numero sequencial rota
						if(parmsConta[34] != null){
							emitirContaHelper.setNumeroSequencialRota((Integer) parmsConta[34]);
						}

						// origem
						if(parmsConta[35] != null){
							emitirContaHelper.setIdOrigem((Integer) parmsConta[35]);
						}

						// debitoCreditoSituacaoAtual
						if(parmsConta[36] != null){
							emitirContaHelper.setDebitoCreditoSituacaoAtualConta((Integer) parmsConta[36]);
						}

						// id do funcionario
						if(parmsConta[37] != null){
							emitirContaHelper.setIdFuncionario((Integer) parmsConta[37]);
						}

						// nome do funcionario
						if(parmsConta[38] != null){
							emitirContaHelper.setNomeFuncionario((String) parmsConta[38]);
						}

						// valor Conta
						if(tam > 39 && parmsConta[39] != null){
							emitirContaHelper.setValorConta((BigDecimal) parmsConta[39]);
						}

					}

					colecaoContas.add(emitirContaHelper);
					emitirContaHelper = null;
				}

			}
		}
		return colecaoContas;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0009] Obter Mensagem de Rateio de Consumo ou Consumo fixo de Esgoto
	 * 
	 * @author Vivianne Sousa
	 * @date 13/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder obterMensagemRateioConsumoFichaCompensacao(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao) throws ControladorException{

		StringBuilder mensagemConsumo = new StringBuilder();
		// caso o consumo de rateio seja diferente de vazio
		if(!consumoRateio.equals("") && !consumoRateio.equals("0")){
			mensagemConsumo.append("CONSUMO DO RATEIO - ");
			mensagemConsumo.append(Util.completaStringComEspacoAEsquerda(consumoRateio, 6));
			mensagemConsumo.append("M3");
			// senão completa com espaços em branco
			mensagemConsumo.append(Util.completaString("", 3));
		}else{
			// senão caso o tipo de medição seja diferente de nulo e seja poço e
			// não existam dados para a medição
			if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO) && parmsMedicaoHistorico == null){
				mensagemConsumo.append("VOLUME FIXO DE ESGOTO - ");
				mensagemConsumo.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 5));
				mensagemConsumo.append("M3");

			}else{
				// caso o tipo de medição seja diferente de nulo e seja ligação
				// de agua e
				// o consumo de esgoto seja diferente de nulo d maior que o
				// consumo de agua
				if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA) && emitirContaHelper.getConsumoEsgoto() != null
								&& emitirContaHelper.getConsumoEsgoto() > emitirContaHelper.getConsumoAgua()){

					mensagemConsumo.append("VOLUME FIXO DE ESGOTO - ");
					mensagemConsumo.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 5));
					mensagemConsumo.append("M3");

				}else{
					// senão completa com espaços em branco
					mensagemConsumo.append(Util.completaString("", 31));
				}
			}
		}

		return mensagemConsumo;
	}

	/**
	 * [UC0352] Emitir Contas e Cartas
	 * [SB0031] Obter Representação numérica do Nosso Número da Ficha de Compensação
	 * 
	 * @author Vivianne Sousa
	 * @date 13/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder obterNossoNumeroFichaCompensacao(String idDocumentoTipo, String idDocumentoEmitido) throws ControladorException{

		StringBuilder nossoNumero = new StringBuilder();

		// é o numero do convênio fornecido pelo Banco
		// número fixo e não pode ser alterado
		nossoNumero.append("1474823");

		// id do documento tipo de acordo com o tipo de documento q esta sendo
		// emitido
		nossoNumero.append(Util.adicionarZerosEsquedaNumero(2, idDocumentoTipo));

		// id do documento q esta sendo emitido
		nossoNumero.append(Util.adicionarZerosEsquedaNumero(8, idDocumentoEmitido));

		System.out.println("nossoNumero : " + nossoNumero.toString());

		Integer digito = Util.obterDigitoVerificadorModulo11(nossoNumero.toString());

		nossoNumero.append("-");

		nossoNumero.append(digito);

		return nossoNumero;
	}

	/**
	 * [UC0352] Emitir Contas e Cartas
	 * [SB0032] Obter Fator de Vencimento
	 * 
	 * @author Vivianne Sousa
	 * @date 13/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public String obterFatorVencimento(Date dataVencimento) throws ControladorException{

		String fatorVencimento = "";
		Date dataBase = Util.criarData(07, 10, 1997);

		fatorVencimento = "" + Util.obterQuantidadeDiasEntreDuasDatas(dataBase, dataVencimento);

		return fatorVencimento;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00010] Gerar Linhas da Descrição dos Serviços e Tarifas
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasDescricaoServicoTarifasFichaCompensacao(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao) throws ControladorException{

		StringBuilder linhasDescricaoServicosTarifasTotal = new StringBuilder();
		// caso o valor da agua da conta seja maior que zero
		if(emitirContaHelper.getValorAgua() != null && emitirContaHelper.getValorAgua().compareTo(new BigDecimal("0.00")) == 1){

			// [SB0011] - Gerar Linhas da Tarifa de Água
			StringBuilder linhasTarifaAgua = gerarLinhasTarifaAguaFichaCompensacao(emitirContaHelper, consumoRateio, parmsMedicaoHistorico,
							tipoMedicao);
			linhasDescricaoServicosTarifasTotal.append(linhasTarifaAgua);
		}
		// caso o valor de água de esgoto seja maior que zero
		if(emitirContaHelper.getValorEsgoto() != null && emitirContaHelper.getValorEsgoto().compareTo(new BigDecimal("0.00")) == 1){

			// [SB0012] - Gerar Linhas da tarifa de Esgoto
			StringBuilder linhasTarifaEsgoto = gerarLinhasTarifaEsgotoFichaCompensacao(emitirContaHelper);
			linhasDescricaoServicosTarifasTotal.append(linhasTarifaEsgoto);

		}
		// caso o valor de debitos cobrados da conta seja maior que zero
		if(emitirContaHelper.getDebitos() != null && emitirContaHelper.getDebitos().compareTo(new BigDecimal("0.00")) == 1){

			// [SB0013] - Gerar Linhas de Débitos Cobrados
			StringBuilder linhasDebitoCobrados = gerarLinhasDebitoCobradosFichaCompensacao(emitirContaHelper);
			linhasDescricaoServicosTarifasTotal.append(linhasDebitoCobrados);

		}
		// caso o valor de créditos realizados seja maior que zero
		if(emitirContaHelper.getValorCreditos() != null && emitirContaHelper.getValorCreditos().compareTo(new BigDecimal("0.00")) == 1){

			// [SB0014] - Gerar Linhas de Crédito Realizado
			StringBuilder linhasCreditoRealizados = gerarLinhasCreditosRealizadosFichaCompensacao(emitirContaHelper);
			linhasDescricaoServicosTarifasTotal.append(linhasCreditoRealizados);

		}
		// caso o valor dos impostos retidos seja maior que zero
		if(emitirContaHelper.getValorImpostos() != null && emitirContaHelper.getValorImpostos().compareTo(new BigDecimal("0.00")) == 1){

			// [SB0015] - Gerar Linhas dos Impostos Retidos
			StringBuilder linhasImpostosRetidos = gerarLinhasImpostosRetidosFichaCompensacao(emitirContaHelper);
			linhasDescricaoServicosTarifasTotal.append(linhasImpostosRetidos);

		}

		return linhasDescricaoServicosTarifasTotal;

	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00011] Gerar Linhas da Tarifa de Água
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasTarifaAguaFichaCompensacao(EmitirContaHelper emitirContaHelper, String consumoRateio,
					Object[] parmsMedicaoHistorico, Integer tipoMedicao) throws ControladorException{

		StringBuilder linhasTarifaAgua = new StringBuilder();
		// descricao dos serviçoes e tarifas (tam 50)
		linhasTarifaAgua.append(Util.completaString("AGUA", 50));

		// consumo por faixa (tam 15) + valor (tam 14)
		linhasTarifaAgua.append(Util.completaString("", 29));

		Collection colecaoContaCategoriaComFaixas = null;
		try{
			colecaoContaCategoriaComFaixas = repositorioFaturamento.pesquisarContaCategoria(emitirContaHelper.getIdConta());
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(colecaoContaCategoriaComFaixas != null && !colecaoContaCategoriaComFaixas.isEmpty()){
			Iterator iteratorContaCategoriaComFaixas = colecaoContaCategoriaComFaixas.iterator();
			while(iteratorContaCategoriaComFaixas.hasNext()){
				ContaCategoria contaCategoria = (ContaCategoria) iteratorContaCategoriaComFaixas.next();

				// descricao dos serviçoes e tarifas (tam 50)
				// descricao da categoria
				linhasTarifaAgua.append(Util.completaString(contaCategoria.getComp_id().getCategoria().getDescricao(), 13));
				// quantidade de economias
				linhasTarifaAgua.append(Util.adicionarZerosEsquedaNumero(3, "" + contaCategoria.getQuantidadeEconomia()));
				// completa com espaços em branco
				linhasTarifaAgua.append(Util.completaString("", 2));
				if(contaCategoria.getQuantidadeEconomia() == 1){
					linhasTarifaAgua.append(Util.completaString("UNIDADE ", 32));
				}else{
					linhasTarifaAgua.append(Util.completaString("UNIDADES", 32));
				}

				// consumo por faixa (tam 15) + valor (tam 14)
				linhasTarifaAgua.append(Util.completaString("", 29));

				// caso não existam dados de medição
				if(parmsMedicaoHistorico == null){

					// descricao dos serviçoes e tarifas (tam 50)
					// Constante
					linhasTarifaAgua.append("TARIFA MÍNIMA");

					// Valor da tarifa mínima de água para a categoria por
					// economia
					BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getQuantidadeEconomia());
					String valorTarifaMinima = "";
					if(contaCategoria.getValorTarifaMinimaAgua() != null && qtdEconomia != null){
						BigDecimal valorTarifaMinimaBigDecimal = contaCategoria.getValorTarifaMinimaAgua().divide(qtdEconomia, 2,
										RoundingMode.UP);
						valorTarifaMinima = Util.formatarMoedaReal(valorTarifaMinimaBigDecimal, 4);
					}

					linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaMinima, 6));
					// completa com espaços em branco
					linhasTarifaAgua.append(" ");
					// Constante
					linhasTarifaAgua.append("POR UNIDADE");
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 19));

					// consumo por faixa (tam 15)
					// Constante
					linhasTarifaAgua.append("MINIMO");
					// completa com espaços em branco
					linhasTarifaAgua.append(Util.completaString("", 9));

					// valor (tam 14)
					// valor da água para categoria
					String valorAgua = Util.formatarMoedaReal(contaCategoria.getValorAgua());
					linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorAgua, 14));

				}else{
					// recupera a coleção de conta categoria consumo faixa
					Collection colecaoContaCategoriaConsumoFaixa = null;
					try{
						colecaoContaCategoriaConsumoFaixa = repositorioFaturamento.pesquisarContaCategoriaFaixas(
										emitirContaHelper.getIdConta(), contaCategoria.getComp_id().getCategoria().getId());
					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}

					if(colecaoContaCategoriaConsumoFaixa != null && !colecaoContaCategoriaConsumoFaixa.isEmpty()){

						// descricao dos serviçoes e tarifas (tam 50)
						// Constante
						linhasTarifaAgua.append(" ATE");
						// Constante
						linhasTarifaAgua.append(" ");
						// Consumo mínimo de água para a categoria por economia

						BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getQuantidadeEconomia());

						BigDecimal consumoMinimoAgua = null;
						if(contaCategoria.getConsumoMinimoAgua() != null){
							consumoMinimoAgua = Util.formatarMoedaRealparaBigDecimal("" + contaCategoria.getConsumoMinimoAgua());
						}

						BigDecimal consumoMinimaBigDecimal = new BigDecimal("0.00");
						if(consumoMinimoAgua != null && qtdEconomia != null){
							consumoMinimaBigDecimal = consumoMinimoAgua.divide(qtdEconomia, 2, RoundingMode.UP);
						}

						String consumoMinima = "" + consumoMinimaBigDecimal.intValue();

						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoMinima, 2));
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append("M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 7));
						// Constante
						linhasTarifaAgua.append("- R$");
						// valor da tarifa minima de agua para a categoria por
						// economia
						BigDecimal valorTarifaMinimaBigDecimal = null;
						if(contaCategoria.getValorTarifaMinimaAgua() != null && qtdEconomia != null){
							valorTarifaMinimaBigDecimal = contaCategoria.getValorTarifaMinimaAgua().divide(qtdEconomia, 4, RoundingMode.UP);
						}
						String valorTarifaMinima = Util.formatarMoedaReal(valorTarifaMinimaBigDecimal, 4);
						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaMinima, 6));
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append(" (POR UNIDADE)");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 8));

						// consumo por faixa (tam 15)
						// Consumo mínimo de água
						if(contaCategoria.getConsumoMinimoAgua() != null && !contaCategoria.getConsumoMinimoAgua().equals("")){
							linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoMinimoAgua(), 6));
						}else{
							linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda("", 6));
						}
						// completa com espaços em branco
						linhasTarifaAgua.append(" ");
						// Constante
						linhasTarifaAgua.append("M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 6));

						// valor (tam 14)
						// valor agua para categoria
						String valorAguaCategoria = "";
						if(contaCategoria.getValorTarifaMinimaAgua() != null){
							valorAguaCategoria = Util.formatarMoedaReal(contaCategoria.getValorTarifaMinimaAgua(), 4);
						}
						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorAguaCategoria, 14));

						Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa.iterator();
						while(iteratorContaCategoriaConsumoFaixa.hasNext()){
							ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) iteratorContaCategoriaConsumoFaixa
											.next();

							// descricao dos serviçoes e tarifas (tam 50)
							// completa com espaços em branco
							linhasTarifaAgua.append(" ");
							// caso a faixa seja a ultima ta tarifa de consumo
							if(contaCategoriaConsumoFaixa.getConsumoFaixaFim().equals(99999999)){
								// Constante
								linhasTarifaAgua.append("ACIMA DE");
								// Consumo inicial da faixa menos 1 m3
								String consumoInicialFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaInicio() - 1);
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoInicialFaixa, 3));
								// Constante
								linhasTarifaAgua.append(" M3  - R$");
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorTarifaFaixa());
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" POR M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 16));

								// consumo por faixa (tam 15)
								// consumo da agua
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(
												"" + contaCategoriaConsumoFaixa.getConsumoAgua() * qtdEconomia.intValue(), 6));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 6));

								// valor (tam 14)
								// valor da agua na faixa
								String valorAguaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorAgua().multiply(
												qtdEconomia));
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorAguaFaixa, 14));

							}else{
								// Consumo inicial da faixa
								String consumoInicialFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaInicio());
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoInicialFaixa, 2));
								// Constante
								linhasTarifaAgua.append(" M3 A");
								// consumo final da faixa
								String consumoFinalFaixa = "" + (contaCategoriaConsumoFaixa.getConsumoFaixaFim());
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(consumoFinalFaixa, 3));
								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 3));
								// Constante
								linhasTarifaAgua.append("- R$");
								// valor da tarifa na faixa
								String valorTarifaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorTarifaFaixa());
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorTarifaFaixa, 6));
								// Constante
								linhasTarifaAgua.append(" POR M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 16));

								// consumo por faixa (tam 15)
								// consumo de Agua na faixa
								// linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(""
								// + contaCategoriaConsumoFaixa.getConsumoAgua() *
								// qtdEconomia.intValue(), 6));
								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(
												"" + contaCategoriaConsumoFaixa.getConsumoAgua(), 6));

								// Constante
								linhasTarifaAgua.append(" M3");
								// completa com espaços em branco
								linhasTarifaAgua.append(Util.completaString("", 6));

								// valor (tam 14)
								// valor da agua na faixa
								// String valorAguaFaixa =
								// Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorAgua().multiply(
								// qtdEconomia));

								String valorAguaFaixa = Util.formatarMoedaReal(contaCategoriaConsumoFaixa.getValorAgua());

								linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(valorAguaFaixa, 14));

							}
						}
					}else{
						// descricao dos serviçoes e tarifas (tam 50)
						linhasTarifaAgua.append("CONSUMO DE ÁGUA");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 35));

						// consumo por faixa (tam 15)
						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda("" + contaCategoria.getConsumoAgua(), 6) + " M3");
						// completa com espaços em branco
						linhasTarifaAgua.append(Util.completaString("", 6));

						// valor (tam 14)
						linhasTarifaAgua.append(Util.completaStringComEspacoAEsquerda(
										Util.formatarMoedaReal(contaCategoria.getValorAgua()), 14));

					}

				}
			}
		}

		return linhasTarifaAgua;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00012] Gerar Linhas da Tarifa de Esgoto
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasTarifaEsgotoFichaCompensacao(EmitirContaHelper emitirContaHelper) throws ControladorException{

		StringBuilder linhasTarifaEsgoto = new StringBuilder();

		// descricao dos serviçoes e tarifas (tam 50)
		// Constante
		linhasTarifaEsgoto.append("ESGOTO ");

		// caso o consumo de agua seja igual ao volume coletado de esgoto e o
		// valor de agua seja diferente de 0
		if(emitirContaHelper.getConsumoAgua().equals(emitirContaHelper.getConsumoEsgoto()) && emitirContaHelper.getValorAgua() != null
						&& !emitirContaHelper.getValorAgua().equals("0.00")){

			// Percentual esgoto
			String percentualEsgoto = Util.formatarMoedaReal(emitirContaHelper.getPercentualEsgotoConta());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(percentualEsgoto, 6));
			// Constante
			linhasTarifaEsgoto.append(" % DO VALOR DA ÁGUA");
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 18));

			// consumo por faixa (tam 15)
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 15));

			// valor (tam 14)
			// valor esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper.getValorEsgoto());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(valorEsgoto, 14));

		}else{
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 43));
			// consumo por faixa (tam 15)
			// Volume coletado de esgoto
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getConsumoEsgoto(), 6));
			// Constante
			linhasTarifaEsgoto.append(" M3");
			// completa com espaços em branco
			linhasTarifaEsgoto.append(Util.completaString("", 6));

			// valor (tam 14)
			// valor esgoto
			String valorEsgoto = Util.formatarMoedaReal(emitirContaHelper.getValorEsgoto());
			linhasTarifaEsgoto.append(Util.completaStringComEspacoAEsquerda(valorEsgoto, 14));
		}

		return linhasTarifaEsgoto;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00013] Gerar Linhas de Débitos Cobrados
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasDebitoCobradosFichaCompensacao(EmitirContaHelper emitirContaHelper) throws ControladorException{

		StringBuilder linhasDebitosCobrados = new StringBuilder();

		Collection<Object[]> collectionParmsDebitoAutomatico = null;

		Collection<Integer> tiposParcelamento = Util
						.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar());

		try{
			collectionParmsDebitoAutomatico = repositorioFaturamento.pesquisarParmsDebitoAutomatico(emitirContaHelper.getIdConta(),
							tiposParcelamento);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(collectionParmsDebitoAutomatico != null){

			Iterator iter = collectionParmsDebitoAutomatico.iterator();

			while(iter.hasNext()){
				Object[] parmsDebitoAutomatico = (Object[]) iter.next();

				// caso a consulta retorne algum resultado
				if(parmsDebitoAutomatico != null){
					String valorDebitosCobrados = "";
					String numeroPrestacao = "";
					String numeroTotalPrestacao = "";
					// valor acumulado dos debitos cobrados
					if(parmsDebitoAutomatico[0] != null){
						valorDebitosCobrados = Util.formatarMoedaReal((BigDecimal) parmsDebitoAutomatico[0]);
					}
					// numero de prestação do débito
					if(parmsDebitoAutomatico[1] != null){
						numeroPrestacao = "" + ((Short) parmsDebitoAutomatico[1]);
					}
					// valor acumulado dos debitos cobrados
					if(parmsDebitoAutomatico[2] != null){
						numeroTotalPrestacao = "" + ((Short) parmsDebitoAutomatico[2]);
					}
					if(!valorDebitosCobrados.equals("0,00")){

						// descricao dos serviçoes e tarifas (tam 50)
						// Constante
						linhasDebitosCobrados.append("PARCELAMENTO DE DÉBITOS");
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util.completaString("", 2));
						// Constante
						linhasDebitosCobrados.append("PARCELA ");
						// numero da prestação do débito
						linhasDebitosCobrados.append(Util.completaString(numeroPrestacao, 2));
						// Constante
						linhasDebitosCobrados.append("/");
						// numero total da prestação do débito
						linhasDebitosCobrados.append(Util.completaString(numeroTotalPrestacao, 2));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util.completaString("", 12));

						// consumo por faixa (tam 15)
						linhasDebitosCobrados.append(Util.completaString("", 15));

						// valor (tam 14)
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorDebitosCobrados, 14));
					}
				}

			}

		}

		List colecaoDebitoCobradoPorTipo = null;
		try{
			colecaoDebitoCobradoPorTipo = repositorioFaturamento.pesquisarParmsDebitoCobradoPorTipo(emitirContaHelper.getIdConta(),
							tiposParcelamento);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		if(colecaoDebitoCobradoPorTipo != null && !colecaoDebitoCobradoPorTipo.isEmpty()){
			ListIterator iteratorDebitoCobradoPorTipo = (ListIterator) colecaoDebitoCobradoPorTipo.listIterator();
			// variável responsável para controle de mudança do tipo de débito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// débito,que entra para ser escrito no txt só uma vez a descrição
			// do tipo do debito
			boolean primeiraVez = true;
			boolean entrouPrimeiraVez = false;
			Integer idDebitoTipoVerificador = null;
			BigDecimal valorTotalPrestacoes = new BigDecimal("0.00");
			// valor da pretação
			BigDecimal valorPrestacao = null;
			// numero da pretação atual
			Integer numeroPrestacaoDebito = null;
			// numero total de prestações
			Integer numeroPrestacaoTotal = null;
			// colecao para guardar os ano/mes referencia do débito cobrado
			Collection colecaoAnoMesReferenciaDebito = new ArrayList();
			// cria um int que vai ver o tamanho da string builder dependendo da
			// quantidade
			// de mes/ano referencia calcula os espaços em brancos para o valor
			// ficar no lugar certo
			int tamanhoAnoMesReferencia = 0;
			while(iteratorDebitoCobradoPorTipo.hasNext()){
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoCobradoPorTipo.next();

				// recupera os parametros da coleção valor da pretação
				if(parmsDebitoCobradoPorTipo[0] != null){
					valorPrestacao = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if(parmsDebitoCobradoPorTipo[1] != null){
					numeroPrestacaoDebito = Integer.valueOf("" + (Short) parmsDebitoCobradoPorTipo[1]);
				}
				// numero total de prestações
				if(parmsDebitoCobradoPorTipo[2] != null){
					numeroPrestacaoTotal = Integer.valueOf("" + (Short) parmsDebitoCobradoPorTipo[2]);
				}
				// ano Mes Referência do débito
				Integer anoMesReferencia = null;
				if(parmsDebitoCobradoPorTipo[3] != null){
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idDebitoTipo = null;
				if(parmsDebitoCobradoPorTipo[4] != null){
					idDebitoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do débito
				String descricaoDebitoTipo = null;
				if(parmsDebitoCobradoPorTipo[5] != null){
					descricaoDebitoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}
				// muda o estado do boolean e o valor do débito tipo
				// verificador na primeira vez ou quando mudar o tipo
				if(mudou){
					idDebitoTipoVerificador = idDebitoTipo;
					mudou = false;
					tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if(idDebitoTipo.equals(idDebitoTipoVerificador)){
					if(primeiraVez){
						linhasDebitosCobrados.append(Util.completaString(descricaoDebitoTipo, 30));
						primeiraVez = false;
						entrouPrimeiraVez = true;
					}else{
						entrouPrimeiraVez = false;
					}
					// adiciona o valor da prestação ao total
					valorTotalPrestacoes = valorTotalPrestacoes.add(valorPrestacao);
					// adiciona o ano/mes referencia na coleção
					if(anoMesReferencia != null){
						colecaoAnoMesReferenciaDebito.add(anoMesReferencia);
					}else{
						if(!entrouPrimeiraVez){
							// if (linhasDebitosCobrados != null &&
							// linhasDebitosCobrados.length() != 0) {
							// linhasDebitosCobrados.append(System.getProperty("line.separator"));
							// }
							// descrição do tipo de débito
							linhasDebitosCobrados.append(Util.completaString(descricaoDebitoTipo, 30));
						}
						// Constante
						linhasDebitosCobrados.append("PARCELA ");
						// numero da prestação do débito
						linhasDebitosCobrados.append(Util.completaString("" + numeroPrestacaoDebito, 2));
						// Constante
						linhasDebitosCobrados.append("/");
						// numero total da prestação do débito
						linhasDebitosCobrados.append(Util.completaString("" + numeroPrestacaoTotal, 2));
						// Completa com espaços em branco
						linhasDebitosCobrados.append(Util.completaString("", 7));

						// consumo por faixa (tam 15)
						linhasDebitosCobrados.append(Util.completaString("", 15));

						// valor (tam 14)
						// Valor da pretação
						String valorPrestacaoString = Util.formatarMoedaReal(valorPrestacao);
						linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorPrestacaoString, 14));

					}

				}else{
					// caso a coleção dos meses de referência do grupo do
					// tipo de débito esteja preenchida
					if(colecaoAnoMesReferenciaDebito != null && !colecaoAnoMesReferenciaDebito.isEmpty()){
						Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito.iterator();
						int i = 1;
						while(iteratorAnoMesReferenciaDebito.hasNext()){
							Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito.next();
							String anoMesReferenciaDebitoString = null;

							if(i == 1){
								// mes/ano referencia do débito
								anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
								// caso exita somente um mes/ano de referencia
								// na lista
								if(colecaoAnoMesReferenciaDebito.size() == 1){

									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", 13));

									// consumo por faixa (tam 15)
									linhasDebitosCobrados.append(Util.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

								}else{

									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", 42));
								}
							}else{
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if(i == 2){

									// mes/ano referencia do debito
									anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
									// adiciona o tamanho do mes/ano
									// referencia
									tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
									// caso exita somente um mes/ano de
									// referencia na lista
									if(colecaoAnoMesReferenciaDebito.size() == 2){
										// o tamanho de espaços em
										// branco vai ser o tamanho sem
										// os mes/ano - os meses/anos
										// colocados na
										// stringbuilder.ex.:76-15=61
										// espaços em brancos
										int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
										// completa espaços em brancos
										linhasDebitosCobrados.append(Util.completaString("", tamanhoEspacosBrancos));

										// consumo por faixa (tam 15)
										linhasDebitosCobrados.append(Util.completaString("", 15));

										// valor (tam 14)
										// valor acumulado do tipo do débito
										String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
										linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));
									}

								}else{
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o ultimo
									// anoMes
									if((colecaoAnoMesReferenciaDebito.size() - 1) <= 6){

										// mes/ano referencia do debito
										anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
										linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
										// completa espaços em brancos
										linhasDebitosCobrados.append(" ");
										// adiciona o tamanho do mes/ano
										// referencia + o espaço em branco
										tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

										// caso não tenha outro ano mes na
										// coleção então
										// completa a linha com o valor
										if(!iteratorAnoMesReferenciaDebito.hasNext()){
											// o tamanho de espaços em branco
											// vai ser o tamanho sem
											// os mes/ano - os meses/anos
											// colocados na
											// stringbuilder.ex.:76-15=61
											// espaços em brancos
											int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util.completaString("", tamanhoEspacosBrancos));

											// consumo por faixa (tam 15)
											linhasDebitosCobrados.append(Util.completaString("", 15));

											// valor (tam 14)
											// valor acumulado do tipo do débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
											linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

										}

									}else{
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if(i < 7){
											// mes/ano referencia do débito
											anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
											linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
											// completa espaços em brancos
											linhasDebitosCobrados.append(" ");
										}else{
											// completa espaços em brancos
											linhasDebitosCobrados.append(Util.completaString("E OUTRAS", 10));

											// consumo por faixa (tam 15)
											linhasDebitosCobrados.append(Util.completaString("", 15));

											// valor (tam 14)
											// valor acumulado do tipo do débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
											linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					} // limpa os campos
					valorTotalPrestacoes = new BigDecimal("0.00");
					colecaoAnoMesReferenciaDebito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoCobradoPorTipo.previous();
				}
			}

			// no caso de ser o ultimo tipo

			// caso a coleção dos meses de referência do grupo do tipo de débito
			// esteja preenchida
			if(colecaoAnoMesReferenciaDebito != null && !colecaoAnoMesReferenciaDebito.isEmpty()){
				Iterator iteratorAnoMesReferenciaDebito = colecaoAnoMesReferenciaDebito.iterator();
				int i = 1;
				while(iteratorAnoMesReferenciaDebito.hasNext()){
					Integer anoMesReferenciaDebito = (Integer) iteratorAnoMesReferenciaDebito.next();
					String anoMesReferenciaDebitoString = null;

					if(i == 1){
						// mes/ano referencia do débito
						anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
						linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
						// caso exita somente um mes/ano de referencia na lista
						if(colecaoAnoMesReferenciaDebito.size() == 1){

							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString("", 13));

							// consumo por faixa (tam 15)
							linhasDebitosCobrados.append(Util.completaString("", 15));

							// valor (tam 14)
							// valor acumulado do tipo do débito
							String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
							linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

						}else{

							// completa espaços em brancos
							linhasDebitosCobrados.append(Util.completaString("", 42));
						}
					}else{
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if(i == 2){

							// mes/ano referencia do debito
							anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
							linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
							// completa espaços em brancos
							linhasDebitosCobrados.append(" ");
							// adiciona o tamanho do mes/ano
							// referencia
							tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
							// caso exita somente um mes/ano de
							// referencia na lista
							if(colecaoAnoMesReferenciaDebito.size() == 2){
								// o tamanho de espaços em
								// branco vai ser o tamanho sem
								// os mes/ano - os meses/anos
								// colocados na
								// stringbuilder.ex.:76-15=61
								// espaços em brancos
								int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
								// completa espaços em brancos
								linhasDebitosCobrados.append(Util.completaString("", tamanhoEspacosBrancos));

								// consumo por faixa (tam 15)
								linhasDebitosCobrados.append(Util.completaString("", 15));

								// valor (tam 14)
								// valor acumulado do tipo do débito
								String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
								linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));
							}

						}else{
							// caso exista até mais 6 ocorrências na lista de
							// meses
							// -1 pq já foi colocado na string o ultimo anoMes
							if((colecaoAnoMesReferenciaDebito.size() - 1) <= 6){

								// mes/ano referencia do debito
								anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
								linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
								// completa espaços em brancos
								linhasDebitosCobrados.append(" ");
								// adiciona o tamanho do mes/ano
								// referencia + o espaço em branco
								tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

								// caso não tenha outro ano mes na coleção então
								// completa a linha com o valor
								if(!iteratorAnoMesReferenciaDebito.hasNext()){
									// o tamanho de espaços em branco vai ser o
									// tamanho sem
									// os mes/ano - os meses/anos
									// colocados na stringbuilder.ex.:76-15=61
									// espaços em brancos
									int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("", tamanhoEspacosBrancos));

									// consumo por faixa (tam 15)
									linhasDebitosCobrados.append(Util.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

								}

							}else{
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if(i < 7){
									// mes/ano referencia do débito
									anoMesReferenciaDebitoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaDebito);
									linhasDebitosCobrados.append(Util.completaString(anoMesReferenciaDebitoString, 7));
									// completa espaços em brancos
									linhasDebitosCobrados.append(" ");
								}else{
									// completa espaços em brancos
									linhasDebitosCobrados.append(Util.completaString("E OUTRAS", 10));

									// consumo por faixa (tam 15)
									linhasDebitosCobrados.append(Util.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalPrestacoes);
									linhasDebitosCobrados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}

		}

		return linhasDebitosCobrados;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB00014] Gerar Linhas de Créditos Realizados
	 * 
	 * @author Vivianne Sousa
	 * @date 19/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasCreditosRealizadosFichaCompensacao(EmitirContaHelper emitirContaHelper) throws ControladorException{

		StringBuilder linhasCreditosRealizados = new StringBuilder();
		List colecaoCreditoRealizadoPorTipo = null;
		try{
			colecaoCreditoRealizadoPorTipo = repositorioFaturamento.pesquisarParmsCreditoRealizadoPorTipo(emitirContaHelper.getIdConta());
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		if(colecaoCreditoRealizadoPorTipo != null && !colecaoCreditoRealizadoPorTipo.isEmpty()){
			ListIterator iteratorDebitoRealizadoPorTipo = (ListIterator) colecaoCreditoRealizadoPorTipo.listIterator();
			// variável responsável para controle de mudança do tipo de credito
			boolean mudou = true;
			// variavel que verifica se é a primeira vez,de cada tipo do
			// credito,que entra para ser escrito no txt só uma vez a descrição
			// do tipo do credito
			boolean primeiraVez = true;
			boolean entrouPrimeiraVez = false;
			Integer idCreditoTipoVerificador = null;
			BigDecimal valorTotalCredito = new BigDecimal("0.00");
			BigDecimal valorCredito = null;
			Short numeroCredito = null;
			// numero total de créditos
			Short numeroCreditoTotal = null;
			// cria um int que vai ver o tamanho da string builder dependendo da
			// quantidade
			// de mes/ano referencia calcula os espaços em brancos para o valor
			// ficar no lugar certo
			int tamanhoAnoMesReferencia = 0;
			// caso não seja a primeira vez que entre no boolean primeira
			// vez(que nesse caso é quando troca o tipo de credito)
			// boolean primeiraVezIndependenteTipo = false;
			// colecao para guardar os ano/mes referencia do credito realizado
			Collection colecaoAnoMesReferenciaCredito = new ArrayList();
			while(iteratorDebitoRealizadoPorTipo.hasNext()){
				Object[] parmsDebitoCobradoPorTipo = (Object[]) iteratorDebitoRealizadoPorTipo.next();

				// recupera os parametros da coleção
				// valor do crédito
				if(parmsDebitoCobradoPorTipo[0] != null){
					valorCredito = (BigDecimal) parmsDebitoCobradoPorTipo[0];
				}
				// numero da pretação atual
				if(parmsDebitoCobradoPorTipo[1] != null){
					numeroCredito = (Short) parmsDebitoCobradoPorTipo[1];
				}

				if(parmsDebitoCobradoPorTipo[2] != null){
					numeroCreditoTotal = (Short) parmsDebitoCobradoPorTipo[2];
				}
				// ano Mes Referência do crédito
				Integer anoMesReferencia = null;
				if(parmsDebitoCobradoPorTipo[3] != null){
					anoMesReferencia = (Integer) parmsDebitoCobradoPorTipo[3];
				}
				// id do tipo do débito
				Integer idCreditoTipo = null;
				if(parmsDebitoCobradoPorTipo[4] != null){
					idCreditoTipo = (Integer) parmsDebitoCobradoPorTipo[4];
				}
				// descrição do tipo do credito
				String descricaoCreditoTipo = null;
				if(parmsDebitoCobradoPorTipo[5] != null){
					descricaoCreditoTipo = (String) parmsDebitoCobradoPorTipo[5];
				}
				// muda o estado do boolean e o valor do credito tipo
				// verificador na primeira vez ou quando mudar o tipo
				if(mudou){
					idCreditoTipoVerificador = idCreditoTipo;
					mudou = false;
					tamanhoAnoMesReferencia = 0;
				}
				// caso seja o mesmo tipo débito
				if(idCreditoTipo.equals(idCreditoTipoVerificador)){
					if(primeiraVez){
						// descrição do tipo de credito
						linhasCreditosRealizados.append(Util.completaString(descricaoCreditoTipo, 30));
						primeiraVez = false;
						entrouPrimeiraVez = true;
						// primeiraVezIndependenteTipo = true;
					}else{
						entrouPrimeiraVez = false;
					}

					// adiciona o valor do credito ao total
					valorTotalCredito = valorTotalCredito.add(valorCredito);
					// adiciona o ano/mes referencia na coleção
					if(anoMesReferencia != null){
						colecaoAnoMesReferenciaCredito.add(anoMesReferencia);
					}else{
						if(!entrouPrimeiraVez){
							// proxima linha
							// if (primeiraVezIndependenteTipo) {
							// linhasCreditosRealizados.append(System.getProperty("line.separator"));
							// }
							// descrição do tipo de credito
							linhasCreditosRealizados.append(Util.completaString(descricaoCreditoTipo, 30));
							primeiraVez = false;
						}
						// Constante
						linhasCreditosRealizados.append("PARCELA ");
						// numero da prestação do débito
						linhasCreditosRealizados.append(Util.completaString("" + numeroCredito, 2));
						// Constante
						linhasCreditosRealizados.append("/");
						// numero total da prestação do débito
						linhasCreditosRealizados.append(Util.completaString("" + numeroCreditoTotal, 2));
						// Completa com espaços em branco
						linhasCreditosRealizados.append(Util.completaString("", 7));

						// consumo por faixa (tam 15)
						linhasCreditosRealizados.append(Util.completaString("", 15));

						// Valor da pretação
						String valorCreditoString = Util.formatarMoedaReal(valorCredito);
						linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorCreditoString, 14));

					}

				}else{
					// caso a coleção dos meses de referência do grupo do
					// tipo de credito esteja preenchida
					if(colecaoAnoMesReferenciaCredito != null && !colecaoAnoMesReferenciaCredito.isEmpty()){
						Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito.iterator();
						int i = 1;
						while(iteratorAnoMesReferenciaCredito.hasNext()){
							Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito.next();
							String anoMesReferenciaCreditoString = null;
							if(i == 1){
								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
								// caso exita somente um mes/ano de referencia
								// na lista
								if(colecaoAnoMesReferenciaCredito.size() == 1){

									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", 13));

									// consumo por faixa (tam 15)
									linhasCreditosRealizados.append(Util.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

								}else{
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", 42));
								}
							}else{
								// caso i seja igual a 2 então começa a
								// linha 3 do subFluxo
								if(i == 2){

									// mes/ano referencia do credito
									anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");
									// adiciona o tamanho do mes/ano referencia
									tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

									// caso exita somente um mes/ano de
									// referencia na lista
									if(colecaoAnoMesReferenciaCredito.size() == 2){
										// o tamanho de espaços em
										// branco vai ser o tamanho sem
										// os mes/ano - os meses/anos
										// colocados na
										// stringbuilder.ex.:76-15=61
										// espaços em brancos
										int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
										// completa espaços em brancos
										linhasCreditosRealizados.append(Util.completaString("", tamanhoEspacosBrancos));

										// consumo por faixa (tam 15)
										linhasCreditosRealizados.append(Util.completaString("", 15));

										// valor (tam 14)
										// valor acumulado do tipo do débito
										String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
										linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

									}
								}else{
									// caso exista até mais 6 ocorrências na
									// lista de meses
									// -1 pq já foi colocado na string o ultimo
									// anoMes
									if((colecaoAnoMesReferenciaCredito.size() - 1) <= 6){

										// mes/ano referencia do credito
										anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
										linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
										// completa espaços em brancos
										linhasCreditosRealizados.append(" ");
										// adiciona o tamanho do mes/ano
										// referencia + o espaço em branco
										tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
										// caso não tenha outro ano mes na
										// coleção então completa a linha com o
										// valor
										if(!iteratorAnoMesReferenciaCredito.hasNext()){
											// o tamanho de espaços em
											// branco vai ser o tamanho sem
											// os mes/ano - os meses/anos
											// colocados na
											// stringbuilder.ex.:76-15=61
											// espaços em brancos
											int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
											// completa espaços em brancos
											linhasCreditosRealizados.append(Util.completaString("", tamanhoEspacosBrancos));

											// consumo por faixa (tam 15)
											linhasCreditosRealizados.append(Util.completaString("", 15));

											// valor (tam 14)
											// valor acumulado do tipo do débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
											linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

										}

									}else{
										// se existir mais de 6 ano/mes na
										// coleçãoAnoMesReferenciaDebito
										// então só mostra as 5 maiores
										if(i < 7){
											// mes/ano referencia do débito
											anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
											linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
											// completa espaços em brancos
											linhasCreditosRealizados.append(" ");
										}else{
											// completa espaços em brancos
											linhasCreditosRealizados.append(Util.completaString("E OUTRAS", 10));

											// consumo por faixa (tam 15)
											linhasCreditosRealizados.append(Util.completaString("", 15));

											// valor (tam 14)
											// valor acumulado do tipo do débito
											String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
											linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

											break;
										}
									}
								}
							}
							i = i + 1;
						}
						// caso a coleção de ano/mes esteja vazia
					}
					// limpa os campos
					valorTotalCredito = new BigDecimal("0.00");
					colecaoAnoMesReferenciaCredito = new ArrayList();
					// caso contrario mada o estado do boolean
					mudou = true;
					primeiraVez = true;
					// retorna uma posição do iterator
					iteratorDebitoRealizadoPorTipo.previous();
				}
			}
			// No caso de ter o ultimo tipo

			// caso a coleção dos meses de referência do grupo do
			// tipo de credito esteja preenchida
			if(colecaoAnoMesReferenciaCredito != null && !colecaoAnoMesReferenciaCredito.isEmpty()){
				Iterator iteratorAnoMesReferenciaCredito = colecaoAnoMesReferenciaCredito.iterator();
				int i = 1;
				while(iteratorAnoMesReferenciaCredito.hasNext()){
					Integer anoMesReferenciaCredito = (Integer) iteratorAnoMesReferenciaCredito.next();
					String anoMesReferenciaCreditoString = null;
					if(i == 1){
						// mes/ano referencia do credito
						anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
						linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
						// caso exita somente um mes/ano de referencia na lista
						if(colecaoAnoMesReferenciaCredito.size() == 1){

							// completa espaços em brancos
							linhasCreditosRealizados.append(Util.completaString("", 13));

							// consumo por faixa (tam 15)
							linhasCreditosRealizados.append(Util.completaString("", 15));

							// valor (tam 14)
							// valor acumulado do tipo do débito
							String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
							linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

						}else{
							// completa espaços em brancos
							linhasCreditosRealizados.append(Util.completaString("", 42));
						}
					}else{
						// caso i seja igual a 2 então começa a
						// linha 3 do subFluxo
						if(i == 2){
							anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
							linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
							// completa espaços em brancos
							linhasCreditosRealizados.append(" ");
							// adiciona o tamanho do mes/ano referencia
							tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;

							// caso exita somente um mes/ano de referencia na
							// lista
							if(colecaoAnoMesReferenciaCredito.size() == 2){
								// o tamanho de espaços em
								// branco vai ser o tamanho sem
								// os mes/ano - os meses/anos
								// colocados na
								// stringbuilder.ex.:76-15=61
								// espaços em brancos
								int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
								// completa espaços em brancos
								linhasCreditosRealizados.append(Util.completaString("", tamanhoEspacosBrancos));

								// consumo por faixa (tam 15)
								linhasCreditosRealizados.append(Util.completaString("", 15));

								// valor (tam 14)
								// valor acumulado do tipo do débito
								String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
								linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

							}
						}else{
							// caso exista até mais 6 ocorrências na
							// lista de meses
							// -1 pq já foi colocado na string o
							// ultimo anoMes
							if((colecaoAnoMesReferenciaCredito.size() - 1) <= 6){

								// mes/ano referencia do credito
								anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
								linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
								// completa espaços em brancos
								linhasCreditosRealizados.append(" ");
								// adiciona o tamanho do mes/ano
								// referencia + o espaço em branco
								tamanhoAnoMesReferencia = tamanhoAnoMesReferencia + 8;
								// caso não tenha outro ano mes na
								// coleção então completa a linha com o valor
								if(!iteratorAnoMesReferenciaCredito.hasNext()){
									// o tamanho de espaços em
									// branco vai ser o tamanho sem
									// os mes/ano - os meses/anos
									// colocados na
									// stringbuilder.ex.:76-15=61
									// espaços em brancos
									int tamanhoEspacosBrancos = 50 - tamanhoAnoMesReferencia;
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("", tamanhoEspacosBrancos));

									// consumo por faixa (tam 15)
									linhasCreditosRealizados.append(Util.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

								}

							}else{
								// se existir mais de 6 ano/mes na
								// coleçãoAnoMesReferenciaDebito
								// então só mostra as 5 maiores
								if(i < 7){
									// mes/ano referencia do débito
									anoMesReferenciaCreditoString = Util.formatarAnoMesParaMesAno(anoMesReferenciaCredito);
									linhasCreditosRealizados.append(Util.completaString(anoMesReferenciaCreditoString, 7));
									// completa espaços em brancos
									linhasCreditosRealizados.append(" ");
								}else{
									// completa espaços em brancos
									linhasCreditosRealizados.append(Util.completaString("E OUTRAS", 10));

									// consumo por faixa (tam 15)
									linhasCreditosRealizados.append(Util.completaString("", 15));

									// valor (tam 14)
									// valor acumulado do tipo do débito
									String valorAcumulado = Util.formatarMoedaReal(valorTotalCredito);
									linhasCreditosRealizados.append(Util.completaStringComEspacoAEsquerda(valorAcumulado, 14));

									break;
								}
							}
						}
					}
					i = i + 1;
				}
				// caso a coleção de ano/mes esteja vazia
			}

		}

		return linhasCreditosRealizados;
	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0015] Gerar Linhas de Impostos Retidos
	 * 
	 * @author Vivianne Sousa
	 * @date 16/11/2007
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	protected StringBuilder gerarLinhasImpostosRetidosFichaCompensacao(EmitirContaHelper emitirContaHelper) throws ControladorException{

		StringBuilder linhasImpostosRetidos = new StringBuilder();

		// descricao dos serviçoes e tarifas (tam 50)
		// Constante
		linhasImpostosRetidos.append(Util.completaString("DEDUCAO IMPOSTOS LEI FEDERAL N.9430 DE 27/12/1996", 50));

		// consumo por faixa (tam 15)
		linhasImpostosRetidos.append(Util.completaString("", 15));

		// valor (tam 14)
		linhasImpostosRetidos.append(Util.completaString("", 14));

		// descricao dos serviçoes e tarifas (tam 50)
		linhasImpostosRetidos.append(Util.completaString("", 2));

		Collection colecaoParmsImpostosDeduzidos = null;
		try{
			colecaoParmsImpostosDeduzidos = repositorioFaturamento.pesquisarParmsContaImpostosDeduzidos(emitirContaHelper.getIdConta());
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		StringBuilder descricaoAbreviadaImposto = new StringBuilder();
		BigDecimal valorImpostosTotal = new BigDecimal("0.00");
		// verifica se a coleção é diferente de nulo
		if(colecaoParmsImpostosDeduzidos != null && !colecaoParmsImpostosDeduzidos.isEmpty()){
			Iterator iteratorParmsImpostosDeduzidos = colecaoParmsImpostosDeduzidos.iterator();
			while(iteratorParmsImpostosDeduzidos.hasNext()){
				Object[] parmsImpostoDeduzido = (Object[]) iteratorParmsImpostosDeduzidos.next();
				String descricaoTipoImposto = "";
				if(parmsImpostoDeduzido[0] != null){
					descricaoTipoImposto = (String) parmsImpostoDeduzido[0];
				}
				String percentualAliquota = "";
				if(parmsImpostoDeduzido[1] != null){
					percentualAliquota = Util.formatarMoedaReal((BigDecimal) parmsImpostoDeduzido[1]);
				}
				BigDecimal valorImpostos = null;
				if(parmsImpostoDeduzido[2] != null){
					valorImpostos = (BigDecimal) parmsImpostoDeduzido[2];
				}
				// concatena a descrição abreviada do tipo de imposto com o
				// precentual de aliquota
				descricaoAbreviadaImposto.append(descricaoTipoImposto + "-" + percentualAliquota + "%");
				// Completa com espaços em branco
				descricaoAbreviadaImposto.append(" ");
				// adiciona o valor dos impostos
				valorImpostosTotal = valorImpostosTotal.add(valorImpostos);
			}
		}
		// recupera a descrição abreviada concatenada com a aliquota
		String descricaoAbreviadaConcatenada = "";
		if(descricaoAbreviadaImposto != null && !descricaoAbreviadaImposto.equals("")){
			descricaoAbreviadaConcatenada = descricaoAbreviadaImposto.toString();
		}
		linhasImpostosRetidos.append(Util.completaString(descricaoAbreviadaConcatenada, 48));

		// consumo por faixa (tam 15)
		linhasImpostosRetidos.append(Util.completaString("", 15));

		// valor (tam 14)
		String valorImpostosTotalString = Util.formatarMoedaReal(valorImpostosTotal);
		linhasImpostosRetidos.append(Util.completaStringComEspacoAEsquerda(valorImpostosTotalString, 14));

		return linhasImpostosRetidos;
	}

	/**
	 * [UC0352] Emitir Contas e Cartas
	 * [SB0029] Gerar Arquivo TXT das fichas de Compensção
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2007
	 * @param emitirContaHelper
	 * @throws ControladorException
	 */
	public void emitirFichaCompensacao(Collection colecaoEmitirContaHelper, int tipoConta, FaturamentoGrupo faturamentoGrupo,
					Integer idEmpresa, Integer anoMesReferenciaFaturamento) throws ControladorException{

		SistemaParametro sistemaParametro = null;

		int quantidadeContas = 0;

		try{

			sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// recebe todos as contas da lista
			StringBuilder contasTxtLista = null;
			StringBuilder cartasTxtListaConta = null;
			Map<Integer, Integer> mapAtualizaSequencial = null;

			try{

				Integer sequencialImpressao = 0;
				Integer sequencialCarta = 0;

				contasTxtLista = new StringBuilder();
				cartasTxtListaConta = new StringBuilder();

				mapAtualizaSequencial = new HashMap();

				if(colecaoEmitirContaHelper != null && !colecaoEmitirContaHelper.isEmpty()){

					EmitirContaHelper emitirContaHelper = null;
					int countOrdem = 0;
					Iterator iteratorConta = colecaoEmitirContaHelper.iterator();

					while(iteratorConta.hasNext()){

						emitirContaHelper = null;
						int situacao = 0;

						emitirContaHelper = (EmitirContaHelper) iteratorConta.next();

						// [SB0020] - Gerar Arquivo TXT das Cartas
						if(tipoConta == 0 || tipoConta == 1){
							sequencialCarta += 1;
						}
						sequencialImpressao += 1;
						quantidadeContas++;
						// Só para exibir no console a quantidade de contas
						System.out.println("QUANTIDADE CONTAS/BOLETO COMPENSAÇÂO: " + quantidadeContas);

						if(emitirContaHelper != null){

							// [SB0020] - Gerar Arquivo TXT das Cartas
							if(tipoConta == 0 || tipoConta == 1){
								// sequencialCarta =
								// atualizaSequencial(sequencialCarta,situacao,metadeColecao);

								cartasTxtListaConta.append(gerarArquivoTxtCartas(emitirContaHelper, sequencialCarta, situacao));
								cartasTxtListaConta.append(System.getProperty("line.separator"));
							}

							StringBuilder contaTxt = new StringBuilder();
							// caso o [FS0006 - Verificar espaços para descrição
							// dos
							// serviços e tarifas totalmente preenchido]
							StringBuilder parteInicialcontaTxt = new StringBuilder();

							// item 1
							// determinar Mensagem
							String mensagemConta = determinarMensagem(tipoConta);
							contaTxt.append(Util.completaString(mensagemConta, 50));

							// item 2
							// nome da localidade
							String descricaoLocalidade = emitirContaHelper.getDescricaoLocalidade();
							contaTxt.append(Util.completaString(descricaoLocalidade, 30));

							// item 3
							// matricula do imóvel
							// Recupera a matrícula do imóvel da coluna 1 e
							// formata a matrícula
							// (ex:500000001 em 5000000.1)
							String matriculaImovelFormatada = Util.retornaMatriculaImovelFormatada(emitirContaHelper.getIdImovel());
							contaTxt.append(Util.completaString(matriculaImovelFormatada, 9));

							// item 4
							// caso a coleção de contas seja de entrega para o
							// cliente responsável
							String nomeClienteUsuario = "";
							if(tipoConta == 3 || tipoConta == 4){
								if(emitirContaHelper.getNomeImovel() != null && !emitirContaHelper.getNomeImovel().equals("")){
									nomeClienteUsuario = emitirContaHelper.getNomeImovel();

								}else{
									try{
										nomeClienteUsuario = repositorioFaturamento.pesquisarNomeClienteUsuarioConta(emitirContaHelper
														.getIdConta());

									}catch(ErroRepositorioException e){
										throw new ControladorException("erro.sistema", e);
									}
								}
								contaTxt.append(Util.completaString(nomeClienteUsuario, 30));
							}else{
								contaTxt.append(Util.completaString(emitirContaHelper.getNomeCliente(), 30));
							}

							// item 5
							// data de vencimento da conta
							String dataVencimento = Util.formatarData(emitirContaHelper.getDataVencimentoConta());
							contaTxt.append(Util.completaString(dataVencimento, 10));

							// item 6
							// instância um imovel com os dados da conta para
							// recuperar
							// a inscrição que está no objeto imovel
							Imovel imovel = new Imovel();
							Localidade localidade = new Localidade();
							localidade.setId(emitirContaHelper.getIdLocalidade());
							imovel.setLocalidade(localidade);
							SetorComercial setorComercial = new SetorComercial();
							setorComercial.setCodigo(emitirContaHelper.getCodigoSetorComercialConta());
							imovel.setSetorComercial(setorComercial);
							Quadra quadra = new Quadra();
							quadra.setNumeroQuadra(emitirContaHelper.getIdQuadraConta());
							imovel.setQuadra(quadra);
							imovel.setLote(emitirContaHelper.getLoteConta());
							imovel.setSubLote(emitirContaHelper.getSubLoteConta());
							// Inscrição do imóvel
							String inscricao = imovel.getInscricaoFormatada();

							imovel = null;
							localidade = null;
							setorComercial = null;
							quadra = null;

							contaTxt.append(Util.completaString(inscricao, 20));

							// item 7
							// recupera endereco do imóvel
							String enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(emitirContaHelper.getIdImovel());
							contaTxt.append(Util.completaString(enderecoImovel == null ? "" : enderecoImovel, 50));

							// item 8
							// Mês/Ano referência da conta
							String mesAnoReferencia = Util.formatarAnoMesParaMesAno(emitirContaHelper.getAmReferencia());
							// Dígito verificador da conta
							String digitoVerificador = "" + emitirContaHelper.getDigitoVerificadorConta();
							contaTxt.append(Util.completaString(mesAnoReferencia + "-" + digitoVerificador, 9));

							// item 9 e item 10
							// caso a coleção de contas seja de entrega para o
							// cliente responsável
							String enderecoClienteResponsavel = "";

							// Comentado por Sávio Luiz em 08/01/2008 (Analista
							// Responsável: Aryed)
							// o tipo da conta(igual a 3 ou 4)

							if(emitirContaHelper.getIdClienteResponsavel() != null
											&& !emitirContaHelper.getIdClienteResponsavel().equals("")){

								// [UC0085]Obter Endereco
								enderecoClienteResponsavel = getControladorEndereco().pesquisarEnderecoClienteAbreviado(
												Integer.valueOf(emitirContaHelper.getIdClienteResponsavel()));

								// id do cliente
								contaTxt.append(Util.completaString("" + emitirContaHelper.getIdClienteResponsavel(), 6));

								if(enderecoClienteResponsavel != null){
									// endereco cliente responsável
									contaTxt.append(Util.completaString(enderecoClienteResponsavel, 50));
								}else{
									// endereco cliente responsável
									contaTxt.append(Util.completaString("", 50));
								}
							}else{
								// endereco cliente responsável
								contaTxt.append(Util.completaString("", 56));
							}

							// item 11
							// descrição da situação da agua na conta
							String descricaoAguaSituacao = emitirContaHelper.getDescricaoLigacaoAguaSituacao();
							contaTxt.append(Util.completaString(descricaoAguaSituacao, 20));

							// item 12
							// descrição da situação de esgoto na conta
							String descricaoEsgotoSituacao = emitirContaHelper.getDescricaoLigacaoEsgotoSituacao();
							contaTxt.append(Util.completaString(descricaoEsgotoSituacao, 20));

							// if (enderecoClienteResponsavel != null &&
							// enderecoClienteResponsavel.length() > 50) {
							// int quantidadePosicoes =
							// enderecoClienteResponsavel.length();
							// // Recupera o fim do endereço do cliente
							// responsável
							// contaTxt.append(Util.completaString(enderecoClienteResponsavel
							// .substring(50,quantidadePosicoes),50));
							//
							// }

							// [SB0002] - Determinar tipo de ligação e tipo de
							// Medição
							Integer[] parmSituacao = determinarTipoLigacaoMedicao(emitirContaHelper);
							Integer tipoLigacao = parmSituacao[0];
							Integer tipoMedicao = parmSituacao[1];

							// cria uma stringBuilder para recuperar o resultado
							// do [SB0004]
							StringBuilder obterDadosConsumoMedicaoAnterior = null;

							// item 13
							// chama o [SB0004] - Obter Dados do Consumo e
							// Medição Anterior passando a quantidade de Meses
							// Igual a 1 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
											emitirContaHelper.getAmReferencia(), 1, tipoLigacao, tipoMedicao);
							contaTxt.append(Util.completaString(obterDadosConsumoMedicaoAnterior.toString(), 19));

							// item 14
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade
							// de Meses Igual a 4 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
											emitirContaHelper.getAmReferencia(), 4, tipoLigacao, tipoMedicao);
							contaTxt.append(Util.completaString(obterDadosConsumoMedicaoAnterior.toString(), 19));

							// item 15
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade
							// de Meses Igual a 2 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
											emitirContaHelper.getAmReferencia(), 2, tipoLigacao, tipoMedicao);
							contaTxt.append(Util.completaString(obterDadosConsumoMedicaoAnterior.toString(), 19));

							// item 16
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade
							// de Meses Igual a 5 e o tipode ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
											emitirContaHelper.getAmReferencia(), 5, tipoLigacao, tipoMedicao);
							contaTxt.append(Util.completaString(obterDadosConsumoMedicaoAnterior.toString(), 19));

							// item 17 e item 18
							// Inicio Chamar Sub-Fluxo recupera os parametros da
							// medição
							// historico do [SB0005] - Obter Dados da Medição da
							// Conta
							Object[] parmsMedicaoHistorico = obterDadosMedicaoConta(emitirContaHelper, tipoMedicao);
							// Leitura Anterior
							String leituraAnterior = "";
							// Leitura Atual
							String leituraAtual = "";
							// Data Leitura Anterior
							String dataLeituraAnterior = "";
							// Leitura Anterior
							String dataLeituraAtual = "";
							// Leitura Situação Atual
							String leituraSituacaoAtual = "";
							// Leitura Anormalidade Faturamento
							String leituraAnormalidadeFaturamento = "";
							if(parmsMedicaoHistorico != null){

								if(parmsMedicaoHistorico[0] != null){
									leituraAnterior = "" + (Integer) parmsMedicaoHistorico[0];
								}

								if(parmsMedicaoHistorico[1] != null){
									leituraAtual = "" + (Integer) parmsMedicaoHistorico[1];
								}

								if(parmsMedicaoHistorico[3] != null){
									dataLeituraAnterior = Util.formatarData((Date) parmsMedicaoHistorico[3]);
								}

								if(parmsMedicaoHistorico[2] != null){
									dataLeituraAtual = Util.formatarData((Date) parmsMedicaoHistorico[2]);
								}

								if(parmsMedicaoHistorico[4] != null){
									leituraSituacaoAtual = "" + (Integer) parmsMedicaoHistorico[4];
								}

								if(parmsMedicaoHistorico[5] != null){
									leituraAnormalidadeFaturamento = "" + (Integer) parmsMedicaoHistorico[5];
								}
							}
							String diasConsumo = "";
							if(!dataLeituraAnterior.equals("") && !dataLeituraAtual.equals("")){
								// calcula a quantidade de dias de consumo que é
								// a quantidade de
								// dias entre a data de leitura
								// anterior(parmsMedicaoHistorico[2])
								// e a data de leitura
								// atual(parmsMedicaoHistorico[3])
								diasConsumo = ""
												+ Util.obterQuantidadeDiasEntreDuasDatas((Date) parmsMedicaoHistorico[3],
																(Date) parmsMedicaoHistorico[2]);
							}

							// recupera os parametros de consumo faturamento e
							// consumo médio diário
							// [SB0005] - Obter Consumo Faturado e Consumo Médio
							// Diário
							String[] parmsConsumo = obterConsumoFaturadoConsumoMedioDiario(emitirContaHelper, tipoMedicao, diasConsumo);
							String consumoFaturamento = parmsConsumo[0];
							String consumoMedioDiario = parmsConsumo[1];
							// Fim Chamar Sub-Fluxo

							// item 17
							// Leitura Anterior
							contaTxt.append(Util.completaString(leituraAnterior, 7));

							// item 18
							// Leitura Atual
							contaTxt.append(Util.completaString(leituraAtual, 7));

							// item 19
							// Consumo faturado
							contaTxt.append((Util.completaStringComEspacoAEsquerdaCondicaoTamanhoMaximo(
											consumoFaturamento.replace(".", ""), 4).substring(0, 4)));

							// item 20
							// Dias de consumo
							contaTxt.append(Util.completaString(diasConsumo, 2));

							// item 21
							// Consumo médio diário
							contaTxt.append((Util.completaStringComEspacoAEsquerdaCondicaoTamanhoMaximo(
											consumoMedioDiario.replace(".", ""), 6)).substring(0, 6));

							// item 22
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade de Meses
							// Igual a 3 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
											emitirContaHelper.getAmReferencia(), 3, tipoLigacao, tipoMedicao);
							contaTxt.append(Util.completaString(obterDadosConsumoMedicaoAnterior.toString(), 19));

							// item 23
							// chama o [SB0004] -Obter Dados do Consumo e
							// Medição Anterior passando a quantidade
							// de Meses Igual a 6 e o tipo de ligação e medição
							// recuperados anteriormente
							obterDadosConsumoMedicaoAnterior = obterDadosConsumoAnterior(emitirContaHelper.getIdImovel(),
											emitirContaHelper.getAmReferencia(), 6, tipoLigacao, tipoMedicao);
							contaTxt.append(Util.completaString(obterDadosConsumoMedicaoAnterior.toString(), 19));

							// item 24
							// Data Leitura Anterior
							contaTxt.append(Util.completaString(dataLeituraAnterior, 10));

							// item 25
							// Data Leitura Atual
							contaTxt.append(Util.completaString(dataLeituraAtual, 10));

							// Inicio Chamar Sub-Fluxo recupera os parametros do
							// consumo historico
							// da conta [SB0007] - Obter Dados de Consumo da
							// Conta
							Object[] parmsConsumoHistorico = null;
							String descricaoAbreviadaTipoConsumo = "";
							String descricaoTipoConsumo = "";
							String consumoMedio = "";
							String descricaoAbreviadaAnormalidadeConsumo = "";
							String descricaoAnormalidadeConsumo = "";
							String consumoRateio = "";
							// caso o tipo de ligacao for diferente de nulo
							if(tipoLigacao != null){
								try{
									parmsConsumoHistorico = repositorioMicromedicao.obterDadosConsumoConta(emitirContaHelper.getIdImovel(),
													emitirContaHelper.getAmReferencia(), tipoLigacao);

								}catch(ErroRepositorioException e){
									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema", e);
								}

								if(parmsConsumoHistorico != null){
									// descrição abreviada tipo de consumo
									if(parmsConsumoHistorico[0] != null){
										descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
									}
									// descrição tipo de consumo
									if(parmsConsumoHistorico[1] != null){
										descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
									}
									// Consumo médio
									if(parmsConsumoHistorico[2] != null){
										consumoMedio = "" + (Integer) parmsConsumoHistorico[2];
									}
									// descrição abreviada anormalidade de
									// consumo
									if(parmsConsumoHistorico[3] != null){
										descricaoAbreviadaAnormalidadeConsumo = (String) parmsConsumoHistorico[3];
									}
									// descrição anormalidade de consumo
									if(parmsConsumoHistorico[4] != null){
										descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
									}
									// Consumo médio
									if(parmsConsumoHistorico[5] != null){
										consumoRateio = "" + (Integer) parmsConsumoHistorico[5];
									}
								}
							}
							// Fim Chamar Sub-Fluxo

							// item 26
							// constante
							contaTxt.append("CONSUMO ");

							// item 27
							// descrição tipo consumo
							contaTxt.append(Util.completaString(descricaoTipoConsumo, 20));

							// item 28
							// descrição da Anormalidade de consumo
							contaTxt.append(Util.completaString(descricaoAnormalidadeConsumo, 25));

							// Inicio Chamar Sub-Fluxo soma a quantidades de
							// economias da
							// tabela contaCategoria [SB0007] - Obter Dados da
							// Medição da Conta
							Short quantidadeEconomiaConta = 0;
							try{
								quantidadeEconomiaConta = repositorioFaturamento.obterQuantidadeEconomiasConta(emitirContaHelper
												.getIdConta());
							}catch(ErroRepositorioException e){
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema", e);
							}
							// Fim Chamar Sub-Fluxo

							// item 29
							// Quantidade de economias da conta
							contaTxt.append(Util.completaStringComEspacoAEsquerda("" + quantidadeEconomiaConta, 3));

							// Consumo por Economia transforma o
							// consumoFaturamento para um bigDecimal
							BigDecimal consumoFaturadoBigDecimal = null;
							if(consumoFaturamento != null && !consumoFaturamento.equals("")){
								consumoFaturadoBigDecimal = Util.formatarMoedaRealparaBigDecimal(consumoFaturamento);
							}
							// transforma a quantidade de economias da conta
							// para um bigDecimal
							BigDecimal qtdEconomiasBigDecimal = null;
							if(quantidadeEconomiaConta != null && !quantidadeEconomiaConta.equals("")){
								qtdEconomiasBigDecimal = Util.formatarMoedaRealparaBigDecimal("" + quantidadeEconomiaConta);
							}

							String consumoEconomia = "";
							if(consumoFaturadoBigDecimal != null && qtdEconomiasBigDecimal != null){
								BigDecimal consumoEconomiaBigDecimal = consumoFaturadoBigDecimal.divide(qtdEconomiasBigDecimal, 2,
												RoundingMode.UP);
								consumoEconomia = Util.formatarMoedaReal(consumoEconomiaBigDecimal);
								if(consumoEconomia != null){
									consumoEconomia = consumoEconomia.substring(0, consumoEconomia.length() - 3);
								}
							}

							// item 30
							// consumo por economia
							contaTxt.append((Util.completaStringComEspacoAEsquerdaCondicaoTamanhoMaximo(consumoEconomia.replace(".", ""), 4))
											.substring(0, 4));

							// Inicio Chamar Sub-Fluxo concatena os campos dos
							// sub-fluxos anteriores
							// [SB0009] - Obter Código auxiliar
							StringBuilder codigoAuxiliar = new StringBuilder();
							// leitura situação atual
							codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(1, leituraSituacaoAtual));
							// tipo de consumo
							codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(1, descricaoAbreviadaTipoConsumo));
							// tipo de contrato
							codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(1, ""));
							// anormalidade de leitura
							codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(2, leituraAnormalidadeFaturamento));
							// anormalidade de consumo
							codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(2, descricaoAbreviadaAnormalidadeConsumo));
							// perfil do imóvel
							if(emitirContaHelper.getIdImovelPerfil() != null){
								codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(1, "" + emitirContaHelper.getIdImovelPerfil()));
							}else{
								codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(1, ""));
							}
							// dias do consumo
							codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(2, diasConsumo));
							// Consumo medio do imóvel
							codigoAuxiliar.append(Util.adicionarZerosEsquedaNumero(6, consumoMedio));
							// Fim Chamar Sub-Fluxo

							// item 31
							// codigo auxiliar
							contaTxt.append(Util.completaString(codigoAuxiliar.toString(), 16));
							codigoAuxiliar = null;

							// item 32
							// chama o [SB0009] - Obter Mensagem de Rateio de
							// Consumo Fixo de Esgoto
							StringBuilder mesagemConsumo = obterMensagemRateioConsumoFichaCompensacao(emitirContaHelper, consumoRateio,
											parmsMedicaoHistorico, tipoMedicao);
							// mensagem de rateio de consumo ou consumo fixo de
							// esgoto
							contaTxt.append(mesagemConsumo);

							// [SB0010] - Gerar Linhas da Descrição dos Serviços
							// e Tarifas
							StringBuilder linhasDescricaoServicosTarifasTotal = gerarLinhasDescricaoServicoTarifasFichaCompensacao(
											emitirContaHelper, consumoRateio, parmsMedicaoHistorico, tipoMedicao);
							StringBuilder linhasDescricaoServicosTarifas = new StringBuilder();
							int posicaoAtual = 0;
							int tamanhoString = linhasDescricaoServicosTarifasTotal.length();
							// cada linha = 79 => 50 + 15 + 14
							// 79 * 15 = 1185
							int limite = 1185;

							// caso a quantidade de linhas seja menor ou igual a
							// zero,pois na conta
							// só cabe 15 linhas, passando isso é preciso gerar
							// outra folha para a conta
							if(tamanhoString <= limite){
								// caso esteja vazio o array então completa com
								// espaços em branco
								if(tamanhoString == 0){
									// completa com espaços em branco
									contaTxt.append(Util.completaString(consumoEconomia, limite));

								}else{
									posicaoAtual = 0;
									linhasDescricaoServicosTarifas = linhasDescricaoServicosTarifasTotal;
									linhasDescricaoServicosTarifasTotal = new StringBuilder();
								}
								// caso contrario [FS0006 - Verificar espaços
								// para descrição
								// dos serviços e tarifas totalmente preenchido]
							}else{

								linhasDescricaoServicosTarifas.append(linhasDescricaoServicosTarifasTotal.substring(0, limite - 1));
								// posição atual recebe a posição inicial
								posicaoAtual = limite;

								parteInicialcontaTxt = new StringBuilder(contaTxt);

							}

							int espacosEmBranco = 0;

							// caso a posicao limite seja maior que o tamanho do
							// array,
							// significa que todas as strings já foram
							// atualizadas na conta.
							if(tamanhoString <= limite){
								// Limpa os campos para mandar para o método que
								// o chamou
								posicaoAtual = 0;
								linhasDescricaoServicosTarifasTotal = null;
								espacosEmBranco = limite - tamanhoString;
							}

							if(linhasDescricaoServicosTarifas != null && linhasDescricaoServicosTarifas.length() != 0){
								contaTxt.append(linhasDescricaoServicosTarifas);
							}
							linhasDescricaoServicosTarifas = null;

							contaTxt.append(Util.completaString("", espacosEmBranco));

							if(tamanhoString <= limite){
								contaTxt.append(Util.completaString("", 15));
							}else{
								contaTxt.append(Util.completaString(" CONTINUA...", 15));
							}

							// item 79
							String valorContaString = Util.formatarMoedaReal(emitirContaHelper.getValorConta());
							// valor da conta
							contaTxt.append(Util.completaStringComEspacoAEsquerda(valorContaString, 14));

							// chama o [SB0016] - Obter Mensagem da Conta em 3
							// Partes
							String[] parmsPartesConta = obterMensagemConta3Partes(emitirContaHelper, sistemaParametro);
							String primeiraParte = parmsPartesConta[0];
							String segundaParte = parmsPartesConta[1];
							String terceiraParte = parmsPartesConta[2];

							// item 80
							// completa com a primeira parte do [SB0016]
							contaTxt.append(Util.completaString(primeiraParte, 100));

							// item 81
							// completa com a segunda parte do [SB0016]
							contaTxt.append(Util.completaString(segundaParte, 100));

							// item 82
							// completa com a terceira parte do [SB0016]
							contaTxt.append(Util.completaString(terceiraParte, 100));

							// item 83
							// nome da gerencia regional
							contaTxt.append(Util.completaString(emitirContaHelper.getNomeGerenciaRegional(), 25));

							// item 84
							int anoMesReferenciaSubtraido = Util.subtrairMesDoAnoMes(emitirContaHelper.getAmReferencia(), 1);
							String mesAnoFormatado = Util.formatarAnoMesParaMesAno(anoMesReferenciaSubtraido);
							// mes/ano da referencia da conta
							contaTxt.append(Util.completaString(mesAnoFormatado, 7));

							Object[] parmsQualidadeAgua = null;
							try{
								parmsQualidadeAgua = repositorioFaturamento.pesquisarParmsQualidadeAgua(emitirContaHelper);
							}catch(ErroRepositorioException e){
								sessionContext.setRollbackOnly();
								throw new ControladorException("erro.sistema", e);
							}

							// numero indice turbidez da qualidade agua
							String numeroIndiceTurbidez = "";
							// numero cloro residual da qualidade agua
							String numeroCloroResidual = "";
							if(parmsQualidadeAgua != null){
								if(parmsQualidadeAgua[0] != null){
									numeroIndiceTurbidez = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[0]);
								}

								if(parmsQualidadeAgua[1] != null){
									numeroCloroResidual = Util.formatarMoedaReal((BigDecimal) parmsQualidadeAgua[1]);
								}
							}

							// item 85
							// turbidez
							contaTxt.append(Util.completaStringComEspacoAEsquerda(numeroIndiceTurbidez, 9));

							// item 86
							// cloro residual
							contaTxt.append(Util.completaStringComEspacoAEsquerda(numeroCloroResidual, 9));

							// item 87
							// grupo de faturamento
							if(faturamentoGrupo != null){
								contaTxt.append(Util.completaString(faturamentoGrupo.getId().toString(), 2));
							}else{
								contaTxt.append(Util.completaString("", 2));
							}

							// item 88
							// código da empresa
							if(emitirContaHelper.getIdEmpresa() != null){
								contaTxt.append(Util.completaStringComEspacoAEsquerda("" + emitirContaHelper.getIdEmpresa(), 2));
							}else{
								contaTxt.append(Util.completaString("", 2));
							}

							// incrementa o sequencial de impressao
							// sequencialImpressao =
							// atualizaSequencial(sequencialImpressao,situacao,
							// metadeColecao);

							System.out.println("***************************");
							System.out.println("SEQUENCIAL IMPRESSAO" + sequencialImpressao);
							System.out.println("***************************");

							// caso seja conta do cliente responsável então o
							// sequencial fica nulo
							// if (tipoConta == 3 || tipoConta == 4) {
							// sequencialEmpresa = null;
							// } else {
							// sequencialEmpresa = sequencialImpressao;
							// }

							// sequencial impressão
							String sequencialImpressaoFormatada = Util.adicionarZerosEsquedaNumero(6, "" + sequencialImpressao);
							sequencialImpressaoFormatada = sequencialImpressaoFormatada.substring(0, 3) + "."
											+ sequencialImpressaoFormatada.substring(3, 6);
							System.out.println("***************************");
							System.out.println("SEQUENCIAL IMPRESSAO FORMATADA" + sequencialImpressao);
							System.out.println("***************************");

							// item 89
							// adiciona o sequencial ao txt
							contaTxt.append(Util.completaString("" + sequencialImpressaoFormatada, 7));

							// item 90
							// código do banco
							contaTxt.append("001-9");

							// item 91
							// representação numérica do código de barras
							// [SB0030 - Obter representação numérica do código
							// de barras
							// da Ficha de Compensação]
							String codigoBanco = "001";
							String codigoMoeda = "9";
							StringBuilder nossoNumero = obterNossoNumeroFichaCompensacao("1", emitirContaHelper.getIdConta().toString());
							String nossoNumeroSemDV = nossoNumero.toString().substring(0, 17);
							System.out.println("nossoNumeroSemDV : " + nossoNumeroSemDV);

							String carteira = "18";
							Date dataVencimentoMais15 = Util.adicionarNumeroDiasDeUmaData(new Date(), 15);
							String fatorVencimento = obterFatorVencimento(dataVencimentoMais15);

							String especificacaoCodigoBarra = getControladorArrecadacao().obterEspecificacaoCodigoBarraFichaCompensacao(
											codigoBanco, codigoMoeda, emitirContaHelper.getValorConta(), nossoNumeroSemDV.toString(),
											carteira, fatorVencimento);

							String representacaoNumericaCodigoBarraFichaCompensacao = getControladorArrecadacao()
											.obterRepresentacaoNumericaCodigoBarraFichaCompensacao(especificacaoCodigoBarra);
							System.out.println("representacaoNumerica = " + representacaoNumericaCodigoBarraFichaCompensacao);

							contaTxt.append(representacaoNumericaCodigoBarraFichaCompensacao);

							// item 92
							// local de pagamento
							contaTxt.append(Util.completaString("PAGÁVEL EM QUALQUER BANCO ATÉ O VENCIMENTO", 45));

							// item 93
							// vencimento
							contaTxt.append(Util.completaString("Contra-apresentação", 20));

							// item 94
							// cedente
							contaTxt.append(Util.completaString("COMPESA-Companhia Pernambucana de Saneamento", 50));

							// item 95
							// agência/código cedente
							contaTxt.append("3234-4/2868-1");

							// item 96
							// data do documento
							contaTxt.append(Util.formatarData(new Date()));

							// item 97
							// número do documento
							contaTxt.append(Util.completaString(matriculaImovelFormatada, 10));

							// item 98
							// espécie do documento
							contaTxt.append("FAT");

							// item 99
							// aceite
							contaTxt.append("N");

							// item 100
							// data do processamento
							contaTxt.append(Util.formatarData(new Date()));

							// item 101
							// nosso número com DV
							contaTxt.append(nossoNumero);

							// item 102
							// carteira
							contaTxt.append("18");

							// item 103
							// valor do documento
							contaTxt.append(Util.completaStringComEspacoAEsquerda(valorContaString, 14));

							// item 104
							// Sacado - linha 1.a
							if(nomeClienteUsuario != null && !nomeClienteUsuario.equalsIgnoreCase("")){
								contaTxt.append(Util.completaString(nomeClienteUsuario, 30));
							}else{
								contaTxt.append(Util.completaString(emitirContaHelper.getNomeCliente(), 30));
							}

							// item 105
							// Sacado - linha 1.b
							contaTxt.append(Util.completaString("   Matrícula: ", 16));

							// item 106
							// Sacado - linha 1.c
							contaTxt.append(Util.completaString(matriculaImovelFormatada, 9));

							// item 107
							// Sacado - linha 1.d
							contaTxt.append(Util.completaString("   Fatura: ", 14));

							// item 108
							// Sacado - linha 1.d
							contaTxt.append(Util.completaString(mesAnoReferencia + "-" + digitoVerificador, 9));

							// item 109
							// Sacado - linha 2.a
							contaTxt.append(Util.completaString(enderecoImovel, 50));

							// item 110
							// código de barras
							if(especificacaoCodigoBarra != null && !especificacaoCodigoBarra.equals("")){
								// Cria o objeto para gerar o códigode barras no
								// padrão intercalado 2 de 5
								Interleaved2of5 codigoBarraIntercalado2de5 = new Interleaved2of5();

								contaTxt.append(Util.completaString(codigoBarraIntercalado2de5.encodeValue(especificacaoCodigoBarra), 112));

							}

							// recupera todas as linhas do while
							StringBuilder todasPaginasContaTxt = new StringBuilder();
							// se é a primeira vez que entra no while então
							// recupera o final da
							// linha colocando o continua para depois criar as
							// proximas paginas
							boolean primeiraVez = true;
							int posicaoLimite = 0;
							espacosEmBranco = 0;
							// responsável de criar outra pagina para a conta
							// caso a
							// descrição dos serviços e tarifas exceda as 15
							// linhas
							while(posicaoAtual != 0){
								// é criado para criar a stringBuilder da ultima
								// linha no caso
								// da primeira vez,no caso da segunda vez em
								// diante é criado
								// para criar a proxima pagina da mesma conta
								StringBuilder paginaTxt = new StringBuilder();
								if(primeiraVez){
									// paginaTxt.append(ultimaLinhasConta);
									// // completa com espaços em branco
									// paginaTxt.append(Util.completaString("
									// CONTINUA...", 25));
									// // imprime o sequencial de impressão
									// paginaTxt.append(sequencialImpressaoFormatada);
									// // completa com espaços em branco
									// paginaTxt.append(Util.completaString("",
									// 41));
									primeiraVez = false;
								}else{
									// caso a quantidade de linhas seja menor ou
									// igual a zero,
									// pois na conta só cabe 15 linhas, passando
									// isso é
									// preciso gerar outra folha para a conta

									// caso o tamanho do array seja maior que a
									// posição atual + 15
									if(tamanhoString <= posicaoAtual + limite){
										posicaoLimite = tamanhoString;
									}else{
										posicaoLimite = posicaoAtual + limite;
									}

									linhasDescricaoServicosTarifas = new StringBuilder();
									linhasDescricaoServicosTarifas.append(linhasDescricaoServicosTarifasTotal.substring(posicaoAtual,
													posicaoLimite - 1));

									// posição atual recebe a posição inicial
									posicaoAtual = posicaoLimite;

									// caso a posicao limite seja maior que o
									// tamanho do array,
									// significa que todas as strings já foram
									// atualizadas na conta.
									if(tamanhoString <= posicaoLimite){
										// Limpa os campos para mandar para o
										// método que o chamou
										posicaoAtual = 0;
										linhasDescricaoServicosTarifasTotal = null;
										espacosEmBranco = posicaoLimite - tamanhoString;

									}
									paginaTxt.append(parteInicialcontaTxt);
									paginaTxt.append(linhasDescricaoServicosTarifas);

									// recupera a ultima linha
									// paginaTxt.append(ultimaLinhasConta);
									if(posicaoAtual != 0){
										paginaTxt.append(Util.completaString("", espacosEmBranco));

										if(tamanhoString <= limite){
											paginaTxt.append(Util.completaString("", 15));
										}else{
											paginaTxt.append(Util.completaString(" CONTINUA...", 15));
										}

									}
									// else {
									// // imprime o sequencial de impressão
									// paginaTxt.append(sequencialImpressaoFormatada);
									// // completa com espaços em branco
									// paginaTxt.append(Util.completaString("",
									// 41));
									// }

								}
								todasPaginasContaTxt.append(paginaTxt);
								paginaTxt = null;
								if(posicaoAtual != 0){
									todasPaginasContaTxt.append(System.getProperty("line.separator"));
								}
							}

							// coloca a ultima linha ou a outra(s) parte(s) da
							// conta
							// (outra pagina caso a descrição de serviços e
							// tarifas exceda as 15 linhas) no txt da conta
							if(todasPaginasContaTxt != null && todasPaginasContaTxt.length() != 0){
								contaTxt.append(System.getProperty("line.separator"));
								contaTxt.append(todasPaginasContaTxt);
								todasPaginasContaTxt = null;
							}

							// txt recupera a string builder da conta da lista
							// de contas
							contasTxtLista.append(contaTxt.toString());

							StringBuilder teste = new StringBuilder();
							teste.append(contaTxt);

							contaTxt = null;

							contasTxtLista.append(System.getProperty("line.separator"));

							// adiciona o id da conta e o sequencial no para
							// serem atualizados
							mapAtualizaSequencial.put(emitirContaHelper.getIdConta(), sequencialImpressao);

						}// fim do laço que verifica se o
							// helper é diferente de nulo
					}// fim laço while do iterator do objeto helper
					countOrdem++;

					// fim do laço que verifica se a coleção é nula
				}

				repositorioFaturamento.atualizarSequencialContaImpressaoFichaCompensacao(mapAtualizaSequencial);
				mapAtualizaSequencial = null;

				String idGrupoFaturamento = null;

				if(faturamentoGrupo == null){
					idGrupoFaturamento = "G";
				}else{
					idGrupoFaturamento = "G" + faturamentoGrupo.getId();
				}

				String mesReferencia = "_Fat" + anoMesReferenciaFaturamento.toString().substring(4, 6);
				String nomeZip = null;
				String nomeZipCartaConta = null;

				switch(tipoConta){
					case 0:
						nomeZip = "BOLETO_E" + "_" + idGrupoFaturamento + mesReferencia + "_Emp" + idEmpresa + "-";
						nomeZipCartaConta = "CARTA_BOLETO_CONTA_ESTOURO" + "_" + idGrupoFaturamento + mesReferencia + "_Emp" + idEmpresa
										+ "-";
						break;
					case 1:
						nomeZip = "BOLETO_A" + "_" + idGrupoFaturamento + mesReferencia + "_Emp" + idEmpresa + "-";
						nomeZipCartaConta = "CARTA_BOLETO_BAIXO_CONSUMO" + "_" + idGrupoFaturamento + mesReferencia + "_Emp" + idEmpresa
										+ "-";
						break;
					case 2:
						nomeZip = "BOLETO_D" + "_" + idGrupoFaturamento + mesReferencia + "_Emp" + idEmpresa + "-";
						break;
					case 3:
						nomeZip = "BOLETO_N_R" + "_" + idGrupoFaturamento + mesReferencia + "-";
						break;
					case 4:
						nomeZip = "BOLETO_D_R" + "_" + idGrupoFaturamento + mesReferencia + "-";
						break;
					case 5:
						nomeZip = "BOLETO_N" + "_" + idGrupoFaturamento + mesReferencia + "_Emp" + idEmpresa + "-";
						break;
				}

				BufferedWriter out = null;
				ZipOutputStream zos = null;
				File compactadoTipoCarta = null;

				File compactadoTipo = new File(nomeZip + ".zip");
				if(nomeZipCartaConta != null){
					compactadoTipoCarta = new File(nomeZipCartaConta + ".zip");
				}

				File leituraTipo = new File(nomeZip + ".txt");
				File leituraTipoCarta = null;
				if(nomeZipCartaConta != null){
					leituraTipoCarta = new File(nomeZipCartaConta + ".txt");
				}

				if(contasTxtLista != null && contasTxtLista.length() != 0){
					// fim de arquivo
					contasTxtLista.append("\u0004");
					// ************ TIPO E *************
					System.out.println("CRIANDO ZIP");
					zos = new ZipOutputStream(new FileOutputStream(compactadoTipo));
					out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipo.getAbsolutePath())));
					out.write(contasTxtLista.toString());
					out.flush();
					ZipUtil.adicionarArquivo(zos, leituraTipo);
					zos.close();
					leituraTipo.delete();
					out.close();
				}

				if(cartasTxtListaConta != null && cartasTxtListaConta.length() != 0){
					// fim de arquivo
					contasTxtLista.append("\u0004");
					// ************ TIPO N *************
					System.out.println("CRIANDO ZIP CARTA BOLETO BAIXO");
					zos = new ZipOutputStream(new FileOutputStream(compactadoTipoCarta));
					out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipoCarta.getAbsolutePath())));
					out.write(cartasTxtListaConta.toString());
					out.flush();
					ZipUtil.adicionarArquivo(zos, leituraTipoCarta);
					zos.close();
					leituraTipoCarta.delete();
					out.close();
				}

				// limpa todos os campos
				nomeZip = null;
				nomeZipCartaConta = null;
				out = null;
				zos = null;
				compactadoTipo = null;
				compactadoTipoCarta = null;
				leituraTipo = null;
				leituraTipoCarta = null;
				cartasTxtListaConta = null;
				contasTxtLista = null;

				tipoConta++;
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

		}catch(IOException e){
			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");
			if(inicioMensagem != null && (inicioMensagem[0].equals("erro") || inicioMensagem[0].equals("atencao"))){
				throw new ControladorException(mensagem);
			}else{
				throw new ControladorException("erro.sistema", e);
			}
		}catch(Exception e){
			e.printStackTrace();
			String mensagem = e.getMessage();
			if(mensagem != null){
				String[] inicioMensagem = mensagem.split("\\.");
				if(inicioMensagem != null && (inicioMensagem[0].equals("erro") || inicioMensagem[0].equals("atencao"))){
					throw new ControladorException(mensagem);
				}else{
					throw new ControladorException("erro.sistema", e);
				}
			}else{
				throw new ControladorException("erro.sistema", e);
			}
		}
	}

	public boolean verificarExistenciaRegistroAtendimentoGuiaPagamento(Integer idRegistroAtendimento, Integer idDebitoTipo)
					throws ControladorException{

		try{
			return repositorioFaturamento.verificarExistenciaRegistroAtendimentoGuiaPagamento(idRegistroAtendimento, idDebitoTipo);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Pesquisa os dados de Guias de Pagamento (e suas Prestações) de um determinado Imóvel
	 * 
	 * @author eduardo henrique
	 * @date 08/08/2008
	 * @param idImovel
	 * @param idCliente
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoPrestacaoImovelOuCliente(Integer idImovel, Integer idCliente) throws ControladorException{

		try{

			return repositorioFaturamento.pesquisarGuiasPagamentoPrestacaoImovelOuCliente(idImovel, idCliente);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * @param imovel
	 * @param sistemaParametro
	 * @return true se Imóvel em Fiscalização ou Rota do Imóvel em Fiscalização
	 * @throws ControladorException
	 *             em Caso de Erro na pesquisa de SistemaParametros
	 */
	private boolean verificarImovelSituacaoFiscalizacaoLeituraFaturamentoImediato(Imovel imovel, SistemaParametro sistemaParametro)
					throws ControladorException{

		boolean situacaoFiscalizacao = false;

		if(sistemaParametro.getIndicadorUsoFiscalizadorLeitura() != null
						&& ((sistemaParametro.getIndicadorUsoFiscalizadorLeitura()
										.equals(SistemaParametro.INDICADOR_USO_FISCALIZADOR_GERA_FISCALIZACAO_SISTEMA_PARAMETRO)) || (sistemaParametro
										.getIndicadorUsoFiscalizadorLeitura().equals(
														SistemaParametro.INDICADOR_USO_FISCALIZADOR_LEITURA_ROTA)
										&& imovel.getRota().getIndicadorGerarFiscalizacao() != null && imovel.getRota()
										.getIndicadorGerarFiscalizacao().equals(Rota.INDICADOR_GERAR_FISCALIZACAO)))){
			situacaoFiscalizacao = true;
		}

		return situacaoFiscalizacao;
	}

	/**
	 * [UC0084] - Gerar Faturamento Imediato
	 * [SB0001] - Gerar Dados Pré-Faturamento
	 * 
	 * @author eduardo henrique,Yara Souza
	 * @date 29/09/2008, 20/08/2011
	 *       Realiza a geração de uma Conta (com Status de Pré-Faturada)
	 * @throws ControladorException
	 */
	private void gerarDadosPreFaturamento(Collection<Imovel> colecaoImoveis, FaturamentoGrupo faturamentoGrupo, Integer anoMesReferencia,
					SistemaParametro sistemaParametro, boolean indicadorFaturamentoAntecipado,
					Collection<Imovel> colecaoOcorrenciaGeracaoPreFaturamento) throws ControladorException{

		try{

			if(colecaoImoveis != null && !colecaoImoveis.isEmpty()){
				Iterator iteratorColecaoFaturamentoImoveis = colecaoImoveis.iterator();

				while(iteratorColecaoFaturamentoImoveis.hasNext()){
					Imovel imovel = (Imovel) iteratorColecaoFaturamentoImoveis.next();

					Collection colecaoCategorias = null;
					colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
					imovel.setImovelSubcategorias(new HashSet());

					if(colecaoCategorias != null){ // necessário
						// iterar, pois o
						// retorno é um
						// ArrayList
						for(Iterator iterator = colecaoCategorias.iterator(); iterator.hasNext();){
							Categoria categoria = (Categoria) iterator.next();
							imovel.getImovelSubcategorias().add(categoria);
						}
					}

					// [SB0002-Verifica Situação Especial de Faturamento]
					// Verifica Situação Especial de Faturamento
					imovel.setFaturamentosSituacaoHistorico(new HashSet());
					Collection colecaoSituacaoEspecialFaturamento = repositorioFaturamento.pesquisarFaturamentoSituacaoHistoricoImovel(
									imovel.getId(), anoMesReferencia);
					if(colecaoSituacaoEspecialFaturamento != null && !colecaoSituacaoEspecialFaturamento.isEmpty()){
						for(Iterator iterator = colecaoSituacaoEspecialFaturamento.iterator(); iterator.hasNext();){
							FaturamentoSituacaoHistorico faturamentoSituacaoHistoricoImovel = (FaturamentoSituacaoHistorico) iterator
											.next();
							imovel.getFaturamentosSituacaoHistorico().add(faturamentoSituacaoHistoricoImovel);
						}
					}

					// Gera Conta Pré-Faturada
					this.gerarContaPreFaturadaImovel(imovel, faturamentoGrupo, anoMesReferencia, sistemaParametro, colecaoCategorias,
									indicadorFaturamentoAntecipado, colecaoOcorrenciaGeracaoPreFaturamento);

				}
			}
		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0084] - Gerar Faturamento Imediato [SB0003], [SB0004], [SB0005], [SB0006]
	 * 
	 * @author eduardo henrique, Yara Souza
	 * @date 29/09/2008, 18/08/2011
	 *       Obtém os dados para a geração da conta pré-faturada.
	 * @param faturamentoGrupo
	 * @param sistemaParametro
	 * @throws ControladorException
	 */
	public void gerarContaPreFaturadaImovel(Imovel imovel, FaturamentoGrupo faturamentoGrupo, Integer anoMesReferencia,
					SistemaParametro sistemaParametro, Collection colecaoCategorias, boolean antecipado,
					Collection<Imovel> colecaoOcorrenciaGeracaoPreFaturamento) throws ControladorException{

		try{
			if(imovel != null && anoMesReferencia != null && sistemaParametro != null){

				// Verifica se já existe conta para o anoMes e o imovel
				Integer idConta = repositorioFaturamento.pesquisarExistenciaConta(imovel, anoMesReferencia.intValue());

				if(idConta == null){

					// Variável que vai armazenar os resumos de faturamento
					// para simulação.
					Collection colecaoResumoFaturamento = new ArrayList();

					// [UC3042] – Realizar Arrasto de Parcelamento
					Integer idImovel = imovel.getId();

					Object[] retornoArrasto = this.getControladorCobranca().realizarArrastoDeParcelamento(idImovel);
					BigDecimal valorTotalDebitosArrasto = (BigDecimal) retornoArrasto[0];
					Map<DebitoCobrado, Collection> mapDebitosCobradosArrasto = (Map<DebitoCobrado, Collection>) retornoArrasto[1];
					boolean indicadorArrasto = (Boolean) retornoArrasto[2];

					if(indicadorArrasto){

						System.out.println("Imovel = " + idImovel + " Arrasto = " + valorTotalDebitosArrasto);
						colecaoOcorrenciaGeracaoPreFaturamento.add(imovel);
					}

					if(valorTotalDebitosArrasto == null){

						valorTotalDebitosArrasto = BigDecimal.ZERO;
					}

					/*
					 * Caso exista indicação de geração do valor do débito líquido inferior (menor)
					 * ao valor mínimo para a emissão da conta (PARM_VLMINIMOEMISSAOCONTA da tabela
					 * SISTEMA_PARAMETROS) para a situação da ligação de água do imóvel (LAST_ID da
					 * tabela IMOVEL contido em PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com
					 * PASI_CDPARAMETRO
					 * =”P_SIT_LIG_AGUA_GERA_VLDEBITO_INFERIOR_VLMINEMISSAOCONTA_FATUR_IMEDIATO” ou
					 * LEST_ID da tabela IMOVEL contido em PASI_VLPARAMETRO da tabela
					 * PARAMETRO_SISTEMA comPASI_CDPARAMETRO=”
					 * P_SIT_LIG_ESG_GERA_VLDEBITO_INFERIOR_VLMINEMISSAOCONTA_FATUR_IMEDIATO”)
					 */
					boolean situacaoPermiteGerarDebitoMenorMinimo = false;
					boolean imovelPossuiDebitos = false;

					String[] parametroSituacaoAguaGerarValorMenorMinimoArray = null;

					String parametroSituacaoAguaGerarValorMenorMinimo = ((String) ParametroFaturamento.P_SIT_LIG_AGUA_GERA_VLDEBITO_INFERIOR_VLMINEMISSAOCONTA_FATUR_IMEDIATO
									.executar(this));
					if(parametroSituacaoAguaGerarValorMenorMinimo != null){

						parametroSituacaoAguaGerarValorMenorMinimoArray = parametroSituacaoAguaGerarValorMenorMinimo.split(",");
					}

					String[] parametroSituacaoEsgotoGerarValorMenorMinimoArray = null;

					String parametroSituacaoEsgotoGerarValorMenorMinimo = ((String) ParametroFaturamento.P_SIT_LIG_ESG_GERA_VLDEBITO_INFERIOR_VLMINEMISSAOCONTA_FATUR_IMEDIATO
									.executar(this));
					if(parametroSituacaoEsgotoGerarValorMenorMinimo != null){

						parametroSituacaoEsgotoGerarValorMenorMinimoArray = parametroSituacaoEsgotoGerarValorMenorMinimo.split(",");
					}

					if(!Util.isVazioOrNulo(parametroSituacaoAguaGerarValorMenorMinimoArray)){

						for(int i = 0; i < parametroSituacaoAguaGerarValorMenorMinimoArray.length; i++){

							if(parametroSituacaoAguaGerarValorMenorMinimoArray[i]
											.equals(imovel.getLigacaoAguaSituacao().getId().toString())){

								situacaoPermiteGerarDebitoMenorMinimo = true;
								break;
							}
						}
					}

					if(situacaoPermiteGerarDebitoMenorMinimo == false
									&& !Util.isVazioOrNulo(parametroSituacaoEsgotoGerarValorMenorMinimoArray)){

						for(int i = 0; i < parametroSituacaoEsgotoGerarValorMenorMinimoArray.length; i++){

							if(parametroSituacaoEsgotoGerarValorMenorMinimoArray[i].equals(imovel.getLigacaoEsgotoSituacao().getId()
											.toString())){

								situacaoPermiteGerarDebitoMenorMinimo = true;
								break;
							}
						}
					}

					if(situacaoPermiteGerarDebitoMenorMinimo){

						imovelPossuiDebitos = true;
					}else{

						/*
						 * Caso contrário, ou seja, caso não exista indicação de geração do valor
						 * do débito líquido inferior (menor) ao valor mínimo para a emissão da
						 * conta (PARM_VLMINIMOEMISSAOCONTA da tabela SISTEMA_PARAMETROS) para a
						 * situação da ligação de água do imóvel (LAST_ID da tabela IMOVEL não está
						 * contido em PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com
						 * PASI_CDPARAMETRO
						 * =”P_SIT_LIG_AGUA_GERA_VLDEBITO_INFERIOR_VLMINEMISSAOCONTA_FATUR_IMEDIATO”
						 * e LEST_ID da tabela IMOVEL não está contido em PASI_VLPARAMETRO da tabela
						 * PARAMETRO_SISTEMA comPASI_CDPARAMETRO=”
						 * P_SIT_LIG_ESG_GERA_VLDEBITO_INFERIOR_VLMINEMISSAOCONTA_FATUR_IMEDIATO”):
						 */

						// [SB0013 - Obter Valor dos Débitos a Cobrar Faturáveis]
						BigDecimal somatorioValorDebitosACobrar = this.calcularValorDebitoACobrar(imovel.getId(), anoMesReferencia, false);

						if((somatorioValorDebitosACobrar.add(valorTotalDebitosArrasto)).compareTo(BigDecimal.ZERO) > 0){

							BigDecimal valorSomatorioDebitos = (somatorioValorDebitosACobrar.add(valorTotalDebitosArrasto));

							/*
							 * Caso o somatório dos débitos a cobrar menos o somatório dos
							 * créditos a realizar seja maior ou igual ao valor mínimo para
							 * emissão de conta (PARM_VLMINIMOEMISSAOCONTA da tabela
							 * SISTEMA_PARAMETROS),
							 */
							if(valorSomatorioDebitos.compareTo(sistemaParametro.getValorMinimoEmissaoConta()) >= 0){

								imovelPossuiDebitos = true;
							}
						}
					}

					// ---------------------------------------------------------------------------------
					// [SB0003 - Gerar os Débitos Cobrados]
					// ---------------------------------------------------------------------------------

					BigDecimal valorTotalDebitos = new BigDecimal("0.00");
					List colecaoDebitosACobrarUpdate = new ArrayList();

					// Cria o map para armazenar os débitos a cobrar junto com os débitos a cobrar
					// por categoria.
					Map<DebitoCobrado, Collection> mapDebitosCobrados = null;

					// [SB0003 - Gerar os Débitos Cobrados]
					Object[] retornoDebitosCobrados = null;

					BigDecimal valorTotalAgua = BigDecimal.ZERO;
					BigDecimal valorTotalEsgoto = BigDecimal.ZERO;

					if(imovelPossuiDebitos){

						retornoDebitosCobrados = this.gerarDebitosCobrados(imovel, anoMesReferencia, null);

						if(!Util.isVazioOrNulo(retornoDebitosCobrados)){

							valorTotalDebitos = (BigDecimal) retornoDebitosCobrados[0];
							colecaoDebitosACobrarUpdate = (List) retornoDebitosCobrados[1];
							mapDebitosCobrados = (Map<DebitoCobrado, Collection>) retornoDebitosCobrados[2];
						}

						valorTotalDebitos = valorTotalDebitos.add(valorTotalDebitosArrasto);

						if(mapDebitosCobrados != null && !mapDebitosCobrados.isEmpty()){
							if(mapDebitosCobradosArrasto != null && !mapDebitosCobradosArrasto.isEmpty()){
								Iterator iteratorColecaoDebitosCobrados = mapDebitosCobradosArrasto.keySet().iterator();

								DebitoCobrado debitoCobrado = null;
								Collection colecaoDebitoCobradoCategoriaDebitoCobrado = null;

								while(iteratorColecaoDebitosCobrados.hasNext()){
									debitoCobrado = (DebitoCobrado) iteratorColecaoDebitosCobrados.next();
									colecaoDebitoCobradoCategoriaDebitoCobrado = mapDebitosCobradosArrasto.get(debitoCobrado);

									mapDebitosCobrados.put(debitoCobrado, colecaoDebitoCobradoCategoriaDebitoCobrado);
								}
							}
						}else{
							mapDebitosCobrados = mapDebitosCobradosArrasto;
						}
					}

					// [SB0004 - Obter os Créditos a Realizar
					Object[] creditosARealizar = this.obterCreditosARealizarFaturamentoImediato(imovel.getId(), anoMesReferencia, false,
									null);
					BigDecimal valorTotalCreditos = (BigDecimal) creditosARealizar[0];

					// [SB0020] - Determinar Percentual de Esgoto
					BigDecimal percentualEsgoto = this.determinarPercentualEsgoto(imovel);

					// ---------------------------------------------------------------------------------
					// [SB0006] - Determinar Vencimento da Conta.
					// ---------------------------------------------------------------------------------
					FaturamentoAtivCronRota atividadeCronogramaRota = this.obterFaturamentoAtividadeCronogramaPorGrupoFaturamentoRota(
									FaturamentoAtividade.GERAR_ARQUIVO_LEITURA, anoMesReferencia, faturamentoGrupo, imovel.getRota());
					if(atividadeCronogramaRota == null){
						throw new ControladorException("erro.atividade_cronograma_rota_nao_encontrada_conta_pre_faturamento");
					}

					// ---------------------------------------------------------------------------------
					// [SB0005 - Gerar Dados da Conta]
					// ---------------------------------------------------------------------------------
					Conta conta = this.gerarDadosConta(imovel, anoMesReferencia, false, antecipado, atividadeCronogramaRota,
									sistemaParametro, valorTotalAgua, valorTotalEsgoto, valorTotalDebitos, valorTotalCreditos,
									percentualEsgoto, null, colecaoCategorias);

					// inserir a conta
					this.getControladorUtil().inserir(conta);

					System.out.println("********************************Imovel = " + imovel.getId() + " Conta = " + conta.getId());

					Object[] retornoDadosContaCategoriaEContaCategoriaConsumoFaixa = this
									.gerarDadosContaCategoriaEContaCategoriaConsumoFaixa(colecaoCategorias, null, conta);
					Collection colecaoContaCategoria = (Collection) retornoDadosContaCategoriaEContaCategoriaConsumoFaixa[0];

					// [SF0006] 2.
					// incluir a conta categoria
					if(colecaoContaCategoria != null && !colecaoContaCategoria.isEmpty()){
						this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoria);

						// Incluir a colecao de categorias no objeto conta, que será utilizado na
						// Contabilização
						conta.setContaCategorias(new HashSet());
						for(Iterator iterator = colecaoContaCategoria.iterator(); iterator.hasNext();){
							ContaCategoria categoriaConta = (ContaCategoria) iterator.next();
							conta.getContaCategorias().add(categoriaConta);
						}

						colecaoContaCategoria.clear();
						colecaoContaCategoria = null;
					}

					// ---------------------------------------------------------------------------------
					// [SB0006] Item 6
					// ---------------------------------------------------------------------------------
					// incluir os clientes imovel em ClienteConta
					this.inserirClienteConta(conta, imovel, null);

					// ---------------------------------------------------------------------------------

					// Gravar os Dados refernte ao ID da Conta inserir debito
					// cobrado
					this.inserirDebitoCobrado(mapDebitosCobrados, conta);

					// atualizar debito a cobrar
					this.atualizarDebitoACobrarFaturamento(colecaoDebitosACobrarUpdate);

					// ---------------------------------------------------------------------------------
					// [SF0001] - Determinar Faturamento para o Imóvel
					// 6.2. Gerar resumo de ligações e economias.
					// [UC0275 – Gerar Resumo das Ligações/Economias]
					// ---------------------------------------------------------------------------------
					// this.getControladorMicromedicao().gerarResumoLigacoesEconomias(imovel.getId());

					// ---------------------------------------------------------------------------------
					// [SB0009] - Gerar Resumo da Simulação do Faturamento
					// ---------------------------------------------------------------------------------
					this.gerarResumoSimulacaoFaturamento(colecaoCategorias, valorTotalDebitos, valorTotalCreditos, null,
									colecaoResumoFaturamento, atividadeCronogramaRota, imovel, anoMesReferencia, null, faturamentoGrupo);
					// ---------------------------------------------------------------------------------

				}

			}
		}catch(Exception ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Pesquisa o Volume Faturamento Situação Histótico
	 * 
	 * @author Virgínia Melo
	 * @param idImovel
	 * @param anoMesFaturamento
	 * @return
	 * @throws ControladorException
	 */
	public Integer pesquisarVolumeFaturamentoSituacaoHistorico(Integer idImovel, Integer anoMesFaturamento) throws ControladorException{

		Integer volumeFaturamentoSituacao = Integer.valueOf(0);

		try{
			volumeFaturamentoSituacao = this.repositorioFaturamento
							.pesquisarVolumeFaturamentoSituacaoHistorico(idImovel, anoMesFaturamento);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return volumeFaturamentoSituacao;
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato Método responsável por criar um helper para o
	 * relatório do resultado de Processamento dos Imóveis de
	 * Faturamento Imediato
	 * 
	 * @author Eduardo Henrique
	 * @date 16/10/2008
	 * @param imovel
	 *            - Imovel com atributos de Setor Comercial e Localidades populados
	 * @param leituraAnormalidade
	 *            - Caso houve Anormalidade de Leitura no Processamento do Imóvel
	 * @param numeroLeitura
	 *            - Caso houve leitura medida no Processamento do Imóvel
	 */
	private RelatorioResumoLeituraFaturamentoImediatoHelper criarHelperRelatorioAnormalidadeRegistroFaturamentoImediato(Imovel imovel,
					LeituraAnormalidade leituraAnormalidade, Integer numeroLeitura){

		RelatorioResumoLeituraFaturamentoImediatoHelper helperResumo = null;

		if(imovel != null){
			helperResumo = new RelatorioResumoLeituraFaturamentoImediatoHelper();

			if(imovel.getLocalidade() != null){
				helperResumo.setIdLocalidade(imovel.getLocalidade().getId());
				helperResumo.setDescricaoLocalidade(imovel.getLocalidade().getDescricao());
			}

			if(imovel.getSetorComercial() != null){
				helperResumo.setIdSetorComercial(imovel.getSetorComercial().getId());
				helperResumo.setDescricaoSetorComercial(imovel.getSetorComercial().getDescricao());
			}

			if(leituraAnormalidade != null){
				helperResumo.setIdAnormalidade(leituraAnormalidade.getId());
				helperResumo.setDescricaoAnormalidade(leituraAnormalidade.getDescricao());
			}
			helperResumo.setIdLeitura(numeroLeitura);
		}
		return helperResumo;
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato Método responsável por criar um helper para o
	 * relatório do resultado de Processamento dos Imóveis de
	 * Faturamento Imediato
	 * 
	 * @author Eduardo Henrique
	 * @date 16/10/2008
	 * @param imovel
	 *            - Imovel com atributos de Setor Comercial e Localidades populados
	 * @param Cliente
	 *            - Cliente do Imóvel/Conta que será exibido no relatório
	 * @param numeroConsumoFaturadoAgua
	 *            - Caso houve leitura medida no Processamento do Imóvel
	 * @throws ControladorException
	 */
	private RelatorioResumoOcorrenciasFaturamentoImediatoHelper criarHelperRelatorioOcorrenciaRegistroFaturamentoImediato(Imovel imovel,
					String nomeClienteConta, Integer numeroConsumoFaturadoAgua, Integer numeroConsumoFaturadoEsgoto,
					String mensagemOcorrencia, String valorAguaGsan, String valorAguaColetor, String valorEsgotoGsan,
					String valorEsgotoColetor, String consumoMedio, boolean isDivergenciaValoresSistemaColetor) throws ControladorException{

		RelatorioResumoOcorrenciasFaturamentoImediatoHelper helperResumo = null;
		Collection colecaoSubcategorias = null;
		String categoriasFormatadas = "";

		if(imovel != null){
			helperResumo = new RelatorioResumoOcorrenciasFaturamentoImediatoHelper();

			helperResumo.setCodImovel(imovel.getId());
			helperResumo.setInscricao(imovel.getInscricaoFormatada());
			helperResumo.setErroEncontradoNoProcessamento(mensagemOcorrencia);
			helperResumo.setNomeCliente(nomeClienteConta);

			if(numeroConsumoFaturadoAgua != null){
				helperResumo.setNumeroConsumoFaturadoAgua(numeroConsumoFaturadoAgua);
			}
			if(numeroConsumoFaturadoEsgoto != null){
				helperResumo.setNumeroConsumoFaturadoEsgoto(numeroConsumoFaturadoEsgoto);
			}

			if(imovel.getLigacaoAguaSituacao() != null){
				helperResumo.setSituacaoAgua(imovel.getLigacaoAguaSituacao().getId().toString());
			}

			if(imovel.getLigacaoEsgotoSituacao() != null){
				helperResumo.setSituacaoEsgoto(imovel.getLigacaoEsgotoSituacao().getId().toString());
			}

			if(imovel.getLocalidade() != null){
				helperResumo.setCodLocalidade(imovel.getLocalidade().getId());
				helperResumo.setNomeLocalidade(imovel.getLocalidade().getDescricao());
			}

			if(valorAguaGsan != null){
				helperResumo.setValorAguaGsan(valorAguaGsan);
			}
			if(valorAguaColetor != null){
				helperResumo.setValorAguaColetor(valorAguaColetor);
			}
			if(valorEsgotoGsan != null){
				helperResumo.setValorEsgotoGsan(valorEsgotoGsan);
			}
			if(valorEsgotoColetor != null){
				helperResumo.setValorEsgotoColetor(valorEsgotoColetor);
			}

			helperResumo.setIsDivergenciaValoresSistemaColetor(isDivergenciaValoresSistemaColetor);

			colecaoSubcategorias = this.getControladorImovel().gerarRelatorioDadosEconomiasImovelSubcategoria(imovel.getId().toString());

			if(colecaoSubcategorias != null && !colecaoSubcategorias.isEmpty()){

				boolean primeiraIteracao = true;
				Iterator colecaoSubcategoriasIterator = colecaoSubcategorias.iterator();
				while(colecaoSubcategoriasIterator.hasNext()){
					Object[] subcategoriasDadosRelatorio = (Object[]) colecaoSubcategoriasIterator.next();

					// Descrição Abreviada da Categoria
					if(subcategoriasDadosRelatorio[4] != null){
						categoriasFormatadas = categoriasFormatadas + "CAT: " + (String) subcategoriasDadosRelatorio[4];
					}

					// Quantidade de economias
					if(subcategoriasDadosRelatorio[2] != null){
						categoriasFormatadas = categoriasFormatadas + "  QTD: " + (Short) subcategoriasDadosRelatorio[2];
					}

					// Quantidade de economias
					if(consumoMedio != null && !consumoMedio.equals("") && primeiraIteracao){
						categoriasFormatadas = categoriasFormatadas + "  MÉDIA: " + consumoMedio;
						primeiraIteracao = false;
					}

					if(colecaoSubcategoriasIterator.hasNext()){
						categoriasFormatadas = categoriasFormatadas + "\n";
					}
				}

				helperResumo.setCategorias(categoriasFormatadas);
			}
		}

		return helperResumo;
	}

	/**
	 * [UC0088] - Registrar Faturamento Imediato Método responsável por iniciar a
	 * execução/processamento dos relatórios do Processo de Registro do
	 * Faturamento Imediato
	 * 
	 * @author Eduardo Henrique
	 * @date 16/10/2008
	 * @param colecaoHelperAnormalidade
	 *            - Coleção de Helpers de Anormalidade gerados no Processamento do Registro do Fat.
	 *            Imediato
	 * @param colecaoHelperOcorrencia
	 *            - Coleção de Helpers de Ocorrências gerados no Processamento do Registro do Fat.
	 *            Imediato
	 * @param usuario
	 *            - Usuário do sistema que iniciou/agendou o processo.
	 * @param faturamentoGrupo
	 *            - grupo de Faturamento do Processamento
	 * @param anoMesReferencia
	 *            - Ano/Mês de Referência do Processamento
	 */
	private void iniciarProcessamentoRelatoriosFaturamentoImediato(
					Collection<RelatorioResumoLeituraFaturamentoImediatoHelper> colecaoHelperAnormalidade,
					Collection<RelatorioResumoOcorrenciasFaturamentoImediatoHelper> colecaoHelperOcorrencia, Usuario usuario,
					FaturamentoGrupo faturamentoGrupo, Integer anoMesReferencia, SistemaParametro sistemaParametro,
					Collection<RelatorioContasBloqueadasAnaliseHelper> colecaoContasBloqueadasAnaliseHelper) throws ControladorException{

		log.info("*******Início Geração dos Relatórios Gerados no processamento do Atualizar Faturamento Imediato*******");

		String mensagemEmailAnormalidade = null;
		String mensagemEmailOcorrencia = null;
		String mensagemEmailContasBloqueadas = null;
		int quantidadeDivergenciaLeitura = 0;

		if(colecaoHelperOcorrencia != null && !colecaoHelperOcorrencia.isEmpty()){

			Iterator itColecaoOcorrencia = colecaoHelperOcorrencia.iterator();
			RelatorioResumoOcorrenciasFaturamentoImediatoHelper relatorioHelper;

			while(itColecaoOcorrencia.hasNext()){
				relatorioHelper = (RelatorioResumoOcorrenciasFaturamentoImediatoHelper) itColecaoOcorrencia.next();

				if(relatorioHelper.getIsDivergenciaValoresSistemaColetor()){

					quantidadeDivergenciaLeitura = quantidadeDivergenciaLeitura + 1;
				}
			}
		}

		// Inicia o Relatório de Anormalidades e Leituras
		if(colecaoHelperAnormalidade != null && !colecaoHelperAnormalidade.isEmpty()){

			RelatorioResumoLeituraFaturamentoImediato relatorioResumoLeituraFaturamentoImediato = new RelatorioResumoLeituraFaturamentoImediato(
							usuario);

			relatorioResumoLeituraFaturamentoImediato.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
			relatorioResumoLeituraFaturamentoImediato.addParametro("colecaoResumoHelper", colecaoHelperAnormalidade);
			relatorioResumoLeituraFaturamentoImediato.addParametro("anoMesReferencia",
							Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesReferencia));
			relatorioResumoLeituraFaturamentoImediato.addParametro("idGrupoFaturamento", faturamentoGrupo.getId());
			relatorioResumoLeituraFaturamentoImediato
							.addParametro("quantidadeRegistrosComDivergenciaValores", quantidadeDivergenciaLeitura);
			relatorioResumoLeituraFaturamentoImediato.addParametro("empresa", sistemaParametro.getNomeEmpresa());

			getControladorBatch().iniciarProcessoRelatorio(relatorioResumoLeituraFaturamentoImediato);

			mensagemEmailAnormalidade = " Gerado Relatório de Resumo de Leituras do Processamento do Faturamento Imediato do Grupo:"
							+ faturamentoGrupo.getId() + " Ano/Mês:" + Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesReferencia);
		}

		// Iniciar o Relatório de Ocorrências
		if(colecaoHelperOcorrencia != null && !colecaoHelperOcorrencia.isEmpty()){

			RelatorioResumoOcorrenciasFaturamentoImediato relatorioResumoOcorrenciasFaturamentoImediato = new RelatorioResumoOcorrenciasFaturamentoImediato(
							usuario);
			relatorioResumoOcorrenciasFaturamentoImediato.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
			relatorioResumoOcorrenciasFaturamentoImediato.addParametro("colecaoResumoHelper", colecaoHelperOcorrencia);
			relatorioResumoOcorrenciasFaturamentoImediato.addParametro("anoMesReferencia",
							Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesReferencia));
			relatorioResumoOcorrenciasFaturamentoImediato.addParametro("idGrupoFaturamento", faturamentoGrupo.getId());
			relatorioResumoOcorrenciasFaturamentoImediato.addParametro("nomeEmpresa", sistemaParametro.getNomeEmpresa());

			getControladorBatch().iniciarProcessoRelatorio(relatorioResumoOcorrenciasFaturamentoImediato);

			mensagemEmailOcorrencia = " Gerado Relatório de Resumo de Ocorrências do Processamento do Faturamento Imediato do Grupo:"
							+ faturamentoGrupo.getId() + " Ano/Mês:" + Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesReferencia);
		}

		// [SB0015] - Gera Relatório de Contas Bloqueadas para análise
		if(!Util.isVazioOrNulo(colecaoContasBloqueadasAnaliseHelper)){

			List<RelatorioContasBloqueadasAnaliseHelper> listContasBloqueadasAnaliseOrdenada = new ArrayList<RelatorioContasBloqueadasAnaliseHelper>();
			listContasBloqueadasAnaliseOrdenada.addAll(colecaoContasBloqueadasAnaliseHelper);
			List sortFields = new ArrayList();

			sortFields.add(new BeanComparator("idLocalidade"));
			sortFields.add(new BeanComparator("codigoSetorComercial"));
			sortFields.add(new BeanComparator("matriculaImovel"));

			ComparatorChain multiSort = new ComparatorChain(sortFields);
			Collections.sort((List) listContasBloqueadasAnaliseOrdenada, multiSort);

			RelatorioContasBloqueadasAnalise relatorioContasBloqueadasAnalise = new RelatorioContasBloqueadasAnalise(usuario);
			relatorioContasBloqueadasAnalise.addParametro("colecaoContasBloqueadasAnaliseHelper", listContasBloqueadasAnaliseOrdenada);
			relatorioContasBloqueadasAnalise.addParametro("anoMesReferenciaFaturamento", anoMesReferencia);
			relatorioContasBloqueadasAnalise.addParametro("idFaturamentoGrupo", faturamentoGrupo.getId());
			relatorioContasBloqueadasAnalise.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);

			String anoMes = Util.formatarAnoMesParaMesAnoSemBarra(anoMesReferencia);
			String dataVencimentoFormatada = Util.completarStringComValorEsquerda(faturamentoGrupo.getDiaVencimento().toString(), "0", 2)
							+ "/" + anoMes.substring(0, 2) + "/" + anoMes.substring(2);
			relatorioContasBloqueadasAnalise.addParametro("dataVencimentoGrupo", dataVencimentoFormatada);

			getControladorBatch().iniciarProcessoRelatorio(relatorioContasBloqueadasAnalise);

			mensagemEmailContasBloqueadas = " Gerado Relatório de Contas Bloqueadas para análise do Processamento do Faturamento Imediato do Grupo:"
							+ faturamentoGrupo.getId() + " Ano/Mês:" + Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesReferencia);
		}

		// envia email caso tenha sido gerado algum relatório
		if(mensagemEmailAnormalidade != null || mensagemEmailOcorrencia != null || mensagemEmailContasBloqueadas != null){

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.REGISTRAR_FATURAMENTO_IMEDIATO);
			String emailRemetente = envioEmail.getEmailRemetente();
			String tituloMensagem = envioEmail.getTituloMensagem();
			String corpoMensagem = envioEmail.getCorpoMensagem();

			if(mensagemEmailAnormalidade != null){

				corpoMensagem += (System.getProperty("line.separator") + mensagemEmailAnormalidade);
			}

			if(mensagemEmailOcorrencia != null){

				corpoMensagem += (System.getProperty("line.separator") + mensagemEmailOcorrencia);
			}

			if(mensagemEmailContasBloqueadas != null){

				corpoMensagem += (System.getProperty("line.separator") + mensagemEmailContasBloqueadas);
			}

			String emailReceptor = envioEmail.getEmailReceptor();

			try{

				ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, corpoMensagem);
			}catch(Exception e){

				e.printStackTrace();
			}
		}

		log.info("*******Fim Geração dos Relatórios Gerados no processamento do Atualizar Faturamento Imediato*******");
	}

	/**
	 * Emitir Contas
	 * [UC0352] - Emitir Contas
	 * 
	 * @author Saulo Lima, Eduardo Henrique, Anderson Italo
	 * @date 08/10/2008 , 18/11/2008, 03/08/2013
	 */
	public void emitirContas(Integer idEmpresa, Integer anoMesReferencia, FaturamentoGrupo faturamentoGrupo, Usuario usuario,
					Integer idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		try{

			log.info("............Início do Emitir Conta Empresa: " + idEmpresa.toString());

			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada.intValue(),
							FaturamentoAtividade.DISTRIBUIR_CONTAS, idEmpresa);

			Collection<EmitirContaTipo2Helper> colecaoConta = new ArrayList<EmitirContaTipo2Helper>();
			Collection<EmitirContaTipo2Helper> colecaoContaTipo2Helper = new ArrayList<EmitirContaTipo2Helper>();
			String indicadorGeracaoArquivoEmissaoConta = (String) ParametroFaturamento.P_INDICADOR_GERACAO_ARQUIVO_EMISSAO_CONTA
							.executar(this);
			String indicadorGeracaoArquivoPdfEmissaoConta = (String) ParametroFaturamento.P_INDICADOR_GERACAO_ARQUIVO_PDF_EMISSAO_CONTA
							.executar(this);

			String[] idsMotivoRevisaoNaoPermitida = null;
			try{

				String parametroMotivoRevisaoNaoPermitida = ((String) ParametroFaturamento.P_MOTIVO_REVISAO_NAO_PERMITIDA.executar(this));
				idsMotivoRevisaoNaoPermitida = parametroMotivoRevisaoNaoPermitida.split(",");
			}catch(ControladorException e){

				throw new ActionServletException("atencao.sistemaparametro_inexistente", "P_MOTIVO_REVISAO_NAO_PERMITIDA");
			}

			String indicadorMotivoRevisaoContasRetidas = (String) ParametroFaturamento.P_EMISSAO_MOTIVO_REVISAO_CONTAS_RETIDAS.executar();
			Short indicadorDuasContasPorPagina = Short.valueOf((String) ParametroFaturamento.P_INDICADOR_GERACAO_DUAS_CONTA_POR_PAGINA
							.executar());
			Integer anoMesReferenciaFaturamentoAntecipado = null;

			int mes = Util.obterMes(anoMesReferencia.intValue());
			if(mes == 11){
				SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
				if(sistemaParametro != null && sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){
					anoMesReferenciaFaturamentoAntecipado = Util.somaMesAnoMesReferencia(anoMesReferencia, 1);
				}
			}

			Collection colecaoParametrosConta = repositorioFaturamento.pesquisarContasEmitirTipo2(idEmpresa, anoMesReferencia,
							faturamentoGrupo.getId(), anoMesReferenciaFaturamentoAntecipado);

			if(colecaoParametrosConta != null && !colecaoParametrosConta.isEmpty()){

				colecaoConta = this.formatarEmitirContasTipo2Helper(colecaoParametrosConta);

				if(colecaoConta != null){

					Collection<EmitirContaTipo2Helper> colecaoContaAtualizada = new ArrayList<EmitirContaTipo2Helper>();

					for(EmitirContaTipo2Helper contaTipo2Helper : colecaoConta){

						Boolean add = Boolean.TRUE;

						// [FS0012] – Verificar bloqueio funcionalidade por motivo da
						// retificação/revisão da
						// conta
						// Caso alguma das contas selecionadas esteja em revisão
						// (CNTA_DTREVISAO<>nulo) e o
						// motivo da revisão da conta (CMRV_ID) corresponda a um dos valores do
						// parâmetro
						// (motivo de revisão da conta = PSFN_VLPARAMETRO na tabela
						// PARAMETRO_SIST_FUNCIONALIDADE com FNCD_ID = Id da Funcionalidade
						// corrente e PASI_ID = PASI_ID da Tabela PARAMETRO_SISTEMA com
						// PASI_DSPARAMETRO =
						// ‘P_MOTIVO_REVISAO_NAO_PERMITIDA’),
						// não selecionar a conta para emissão.
						if(contaTipo2Helper.getDataRevisao() != null && contaTipo2Helper.getIdMotivoRevisao() != null
										&& !Util.isVazioOrNulo(idsMotivoRevisaoNaoPermitida)){

							for(int i = 0; i < idsMotivoRevisaoNaoPermitida.length; i++){

								if(contaTipo2Helper.getIdMotivoRevisao().toString().equals(idsMotivoRevisaoNaoPermitida[i])){

									add = Boolean.FALSE;
									break;
								}
							}
						}

						if(add){

							if(indicadorMotivoRevisaoContasRetidas != null
											&& !StringUtils.isEmpty(indicadorMotivoRevisaoContasRetidas.trim())
											&& contaTipo2Helper.getIdMotivoRevisao() != null){

								if(Integer.valueOf(indicadorMotivoRevisaoContasRetidas).intValue() == contaTipo2Helper.getIdMotivoRevisao()
												.intValue()){

									colecaoContaAtualizada.add(contaTipo2Helper);

								}

							}else{

								colecaoContaAtualizada.add(contaTipo2Helper);

							}

						}

					}

					colecaoConta = colecaoContaAtualizada;
				}

				if(colecaoConta != null && !colecaoConta.isEmpty()){

					// Caso esteja indicada a geração de arquivo tipo TXT com as contas ou apenas
					// uma conta por página
					if(indicadorGeracaoArquivoEmissaoConta.equals(ConstantesSistema.SIM.toString())
									|| indicadorDuasContasPorPagina.equals(ConstantesSistema.NAO)){

						colecaoConta = this.completarEmitirContasHelperUmaContaPorPagina(colecaoConta);
					}else{

						this.completarEmitirContasHelperDuasContasPorPagina(colecaoConta);
					}
				}
			}

			// Inicio - Ordenar Coleção
			Collection<EmitirContaTipo2Helper> colecaoContaTipo2HelperEndAlternativo = new ArrayList<EmitirContaTipo2Helper>();
			Collection<EmitirContaTipo2Helper> colecaoContaTipo2HelperBraille = new ArrayList<EmitirContaTipo2Helper>();

			if(colecaoConta != null && !colecaoConta.isEmpty()){

				Short separarEndAlternativos = Short.valueOf((String) ParametroFaturamento.P_SEPARAR_ENDERECOS_ALTERNATIVOS_IMPRESSAO_CONTA
								.executar());

				if(separarEndAlternativos.shortValue() == ConstantesSistema.SIM.intValue()){

					for(EmitirContaTipo2Helper contaHelper : colecaoConta){
						if(contaHelper.getIndicadorContaBraille().equals(ConstantesSistema.SIM)){
							colecaoContaTipo2HelperBraille.add(contaHelper);
						}else{

							if(contaHelper.getEnderecoClienteEntrega() == null){
								// Coloca vazio para ordenação
								contaHelper.setEnderecoClienteEntrega("");

							}else if(!contaHelper.getEnderecoClienteEntrega().equals("")){

								Integer idLogradouroImovel = contaHelper.getIdLogradouro();
								Integer idLogradouroEntrega = contaHelper.getIdLogradouroEnderecoClienteEntrega();
								String numeroImovel = contaHelper.getNumeroImovel();
								String numeroImovelEntrega = contaHelper.getNumeroImovelEnderecoClienteEntrega();

								// Se imóvel e endereço de entrega tiverem logradouros diferentes,
								// enviar
								// para o fim do arquivo
								if(idLogradouroImovel == null || idLogradouroEntrega == null
												|| !idLogradouroImovel.equals(idLogradouroEntrega)){

									colecaoContaTipo2HelperEndAlternativo.add(contaHelper);
									continue;

									// Se imóvel e endereço de entrega tiverem MESMO logradouro e
									// números
									// diferentes, enviar para o fim do arquivo
								}else if(numeroImovel == null || numeroImovelEntrega == null
												|| !numeroImovel.trim().equalsIgnoreCase(numeroImovelEntrega.trim())){

									colecaoContaTipo2HelperEndAlternativo.add(contaHelper);

									continue;

								}
							}

							if((contaHelper.getAnoMesConta() != null) && (contaHelper.getIdEmpresa() != null)
											&& (contaHelper.getInscLocalidade() != null) && (contaHelper.getInscSetorComercial() != null)
											&& (contaHelper.getInscQuadra() != null) && (contaHelper.getInscLote() != null)
											&& (contaHelper.getInscSubLote() != null)){

								// Adiciona conta na coleção de contas com envio para o endereço do
								// imóvel
								colecaoContaTipo2Helper.add(contaHelper);

							}else{

								colecaoContaTipo2HelperEndAlternativo.add(contaHelper);

							}

						}
					}
				}else{

					for(EmitirContaTipo2Helper contaHelper : colecaoConta){

						if(contaHelper.getEnderecoClienteEntrega() == null){

							contaHelper.setEnderecoClienteEntrega("");

						}

						if(contaHelper.getIndicadorContaBraille().equals(ConstantesSistema.SIM)){
							colecaoContaTipo2HelperBraille.add(contaHelper);
						}else{
							colecaoContaTipo2Helper.add(contaHelper);
						}

					}

				}

			}

			// Indica se havera ordenacao por responsavel na rotina de emissao de contas
			Short ordenarImpressaoContaResponsavel = Short
							.valueOf((String) ParametroFaturamento.P_ORDENACAO_IMPRESSAO_CONTA_POR_RESPONSAVEL.executar());

			ComparatorChain sortColecaoContaTipo2Helper = new ComparatorChain();

			if(colecaoContaTipo2Helper != null && !colecaoContaTipo2Helper.isEmpty()){

				// Ordenar por mais de um campo
				List sortFields = new ArrayList();

				sortFields.add(new BeanComparator("anoMesConta", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("idEmpresa", br.com.procenge.util.Util.getComparator()));

				if(ordenarImpressaoContaResponsavel.intValue() == ConstantesSistema.SIM.intValue()){

					sortFields.add(new BeanComparator("idClienteResponsavelOrdenacao", br.com.procenge.util.Util.getComparator()));

				}

				sortFields.add(new BeanComparator("codigoElo", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscLocalidade", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscSetorComercial", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscQuadra", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscLote", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscSubLote", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("enderecoClienteEntrega", br.com.procenge.util.Util.getComparator()));

				sortColecaoContaTipo2Helper = new ComparatorChain(sortFields);
				Collections.sort((List) colecaoContaTipo2Helper, sortColecaoContaTipo2Helper);

			}

			ComparatorChain sortColecaoContaTipo2HelperEndAlternativo = new ComparatorChain();

			if(colecaoContaTipo2HelperEndAlternativo != null && !colecaoContaTipo2HelperEndAlternativo.isEmpty()){

				// Ordenar por mais de um campo
				List sortFields = new ArrayList();
				// ---------------------------------------------------------------------------------------------------------
				// ATENÇÃO !!! APENAS PARA LIBERAÇÃO VERSÃO DESO (13/11/2012) NA VERSÃO SEGUINTE UM
				// PARÂMETRO SERÁ CRIADO.
				// ---------------------------------------------------------------------------------------------------------
				// Comentadi o : sortFields.add(new BeanComparator("enderecoClienteEntrega"));
				// Acrescentado o : sortFields.add(new BeanComparator("idClienteResponsavel"));
				// --------------------------------------------------------------------------------------------------------

				if(ordenarImpressaoContaResponsavel.intValue() == ConstantesSistema.SIM.intValue()){

					sortFields.add(new BeanComparator("idClienteResponsavelOrdenacao", br.com.procenge.util.Util.getComparator()));

				}

				sortFields.add(new BeanComparator("codigoElo", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscLocalidade", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscSetorComercial", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscQuadra", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscLote", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("inscSubLote", br.com.procenge.util.Util.getComparator()));
				sortFields.add(new BeanComparator("anoMesConta", br.com.procenge.util.Util.getComparator()));

				sortColecaoContaTipo2HelperEndAlternativo = new ComparatorChain(sortFields);
				Collections.sort((List) colecaoContaTipo2HelperEndAlternativo, sortColecaoContaTipo2HelperEndAlternativo);
			}

			Short separarArquivoEndAlternativos = Short
							.valueOf((String) ParametroFaturamento.P_SEPARAR_ENDERECOS_ALTERNATIVOS_ARQUIVO_CONTA.executar());

			if(separarArquivoEndAlternativos.shortValue() == ConstantesSistema.NAO.intValue()){
				// Acrescenta as contas com envio para o cliente (endereço diferente do imóvel) no
				// final da coleção
				colecaoContaTipo2Helper.addAll(colecaoContaTipo2HelperEndAlternativo);
			}

			// Gerar sequencial das contas após a ordenação
			int totalContas = colecaoContaTipo2Helper.size();
			int sequencialAtual = 1;
			Map<Integer, EmitirContaTipo2Helper> mapContasPorSequencial = new HashMap<Integer, EmitirContaTipo2Helper>();

			for(EmitirContaTipo2Helper contaTipo2Helper : colecaoContaTipo2Helper){

				contaTipo2Helper.setSequencialImpressao(sequencialAtual);
				contaTipo2Helper.setTotalContasImpressao(totalContas);
				mapContasPorSequencial.put(sequencialAtual, contaTipo2Helper);
				sequencialAtual++;
			}

			List<EmitirContaTipo2Helper> colecaoContaTipo2HelperOrdenada = new ArrayList<EmitirContaTipo2Helper>();

			if(!Util.isVazioOrNulo(colecaoContaTipo2Helper)){

				// Caso seja gerado duas contas por página
				if(indicadorDuasContasPorPagina.equals(ConstantesSistema.SIM)){

					Integer metade = null;
					int resto = colecaoContaTipo2Helper.size() % 2;

					if(resto == 1){

						metade = (colecaoContaTipo2Helper.size() / 2) + 1;
					}else{

						metade = colecaoContaTipo2Helper.size() / 2;
					}

					/*
					 * Popula a coleção para impressão considerando a ordem do sequencial de
					 * impressão para o corte do montante impresso em dois por página. Por exemplo,
					 * se tiver 5 contas na coleção a ordem será ({1,4} folha 1,{2,5} folha 2,{3}
					 * folha 3), ou se tiver 4 contas na coleção a ordem será ({1,3} folha 1,{2,4}
					 * folha 2).
					 */
					for(int i = 1; i <= metade; i++){

						colecaoContaTipo2HelperOrdenada.add(mapContasPorSequencial.get(Integer.valueOf(i)));

						if(mapContasPorSequencial.get(Integer.valueOf(i) + metade) != null){

							colecaoContaTipo2HelperOrdenada.add(mapContasPorSequencial.get(Integer.valueOf(i) + metade));
						}
					}
				}else{

					colecaoContaTipo2HelperOrdenada.addAll(colecaoContaTipo2Helper);
				}
			}

			if(!Util.isVazioOrNulo(colecaoContaTipo2HelperOrdenada) || !Util.isVazioOrNulo(colecaoContaTipo2HelperEndAlternativo)){

				// Caso esteja indicada a geração de arquivo tipo TXT com as contas
				if(indicadorGeracaoArquivoEmissaoConta.equals(ConstantesSistema.SIM.toString())){

					log.info("............Quantidade de Contas Geração TXT: " + colecaoContaTipo2HelperOrdenada.size());

					/*
					 * Executar o método correspondente ao subfluxo de geração do arquivo de emissão
					 * de contas
					 */
					ParametroFaturamento.P_GERAR_ARQUIVO_TXT_CONTAS.executar(this, -1, colecaoContaTipo2HelperOrdenada, faturamentoGrupo,
									idEmpresa, usuario, colecaoContaTipo2HelperEndAlternativo, sortColecaoContaTipo2Helper,
									sortColecaoContaTipo2HelperEndAlternativo, colecaoContaTipo2HelperBraille);
					if(indicadorGeracaoArquivoPdfEmissaoConta.equals(ConstantesSistema.SIM.toString())){
						// Executar o método(qual seja .rpt, jasper,...etc) de geração do relatório
						// correspondente ao subfluxo de geração das contas em PDF
						ParametroFaturamento.P_LAYOUT_IMPRESSAO_CONTA_FATURAMENTO.executar(this, -1, faturamentoGrupo, anoMesReferencia,
										usuario, colecaoContaTipo2HelperOrdenada);
					}

				}else{

					log.info("............Quantidade de Contas Geração PDF: " + colecaoContaTipo2HelperOrdenada.size());

					// Executar o método(qual seja .rpt, jasper,...etc) de geração do relatório
					// correspondente ao subfluxo de geração das contas em PDF
					ParametroFaturamento.P_LAYOUT_IMPRESSAO_CONTA_FATURAMENTO.executar(this, -1, faturamentoGrupo, anoMesReferencia,
									usuario, colecaoContaTipo2HelperOrdenada);
				}
			}


			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

			log.info("............Fim do Emitir Conta Empresa: " + idEmpresa.toString());

		}catch(Exception e){

			e.printStackTrace();
			if(idUnidadeIniciada != 0){

				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			}

			throw new EJBException(e);
		}
	}

	/**
	 * formatarEmitirContasTipo2Helper Responsável por receber uma Collection<Object> do repositório
	 * e retornar uma Collection<EmitirContaTipo2Helper>
	 * [UC0352] Emitir Contas
	 * 
	 * @author Saulo Lima
	 * @date 10/10/2008
	 * @author eduardo henrique
	 * @date 03/06/2009 Alteração para inclusão de atributo Tipo de Envio de Conta de Imóvel.
	 * @param Collection
	 * @return Collection<EmitirContaHelper>
	 * @throws ControladorException
	 */
	private Collection<EmitirContaTipo2Helper> formatarEmitirContasTipo2Helper(Collection colecaoParametrosConta)
					throws ControladorException{

		Collection<EmitirContaTipo2Helper> colecaoContasTipo2Helper = new ArrayList();
		if(colecaoParametrosConta != null){

			Cliente clienteResponsavel = null;
			Cliente clienteUsuario = null;
			Iterator iteColecaoContas = colecaoParametrosConta.iterator();
			while(iteColecaoContas.hasNext()){

				Object[] parmsConta = (Object[]) iteColecaoContas.next();
				if(parmsConta != null){

					EmitirContaTipo2Helper emitirContaTipo2Helper = new EmitirContaTipo2Helper();

					// Id da conta
					if(parmsConta[0] != null){

						emitirContaTipo2Helper.setIdConta((Integer) parmsConta[0]);
					}

					// Nome Cliente
					if(parmsConta[1] != null){

						emitirContaTipo2Helper.setNomeCliente((String) parmsConta[1]);
					}

					// Nome Imóvel
					if(parmsConta[32] != null){

						emitirContaTipo2Helper.setNomeImovel((String) parmsConta[32]);
					}

					// Data Vencimento da Conta
					if(parmsConta[2] != null){
						emitirContaTipo2Helper.setDataVencimento((Date) parmsConta[2]);
					}

					// Ano Mês Referência da Conta
					if(parmsConta[3] != null){

						emitirContaTipo2Helper.setAnoMesConta((Integer) parmsConta[3]);
					}

					// Dígito Verificador da Conta
					if(parmsConta[4] != null){

						emitirContaTipo2Helper.setDigitoVerificadorConta((Short) parmsConta[4]);
					}

					// Código Setor Comercial da Conta
					if(parmsConta[5] != null){

						emitirContaTipo2Helper.setInscSetorComercial((Integer) parmsConta[5]);
					}

					// Id da Quadra da Conta
					if(parmsConta[6] != null){

						emitirContaTipo2Helper.setInscQuadra((Integer) parmsConta[6]);
					}

					// Lote da Conta
					if(parmsConta[7] != null){

						emitirContaTipo2Helper.setInscLote((Short) parmsConta[7]);
					}

					// Sublote da Conta
					if(parmsConta[8] != null){

						emitirContaTipo2Helper.setInscSubLote((Short) parmsConta[8]);
					}

					// Consumo Água
					if(parmsConta[9] != null){

						emitirContaTipo2Helper.setConsumoAgua((Integer) parmsConta[9]);
					}

					// Consumo Esgoto
					if(parmsConta[10] != null){

						emitirContaTipo2Helper.setConsumoEsgoto((Integer) parmsConta[10]);
					}

					// Valor Água
					if(parmsConta[11] != null){

						emitirContaTipo2Helper.setValorAgua((BigDecimal) parmsConta[11]);
					}

					// Valor Esgoto
					if(parmsConta[12] != null){

						emitirContaTipo2Helper.setValorEsgoto((BigDecimal) parmsConta[12]);
					}

					// Valor Débitos
					if(parmsConta[13] != null){

						emitirContaTipo2Helper.setDebitos((BigDecimal) parmsConta[13]);
					}

					// Valor Créditos
					if(parmsConta[14] != null){

						emitirContaTipo2Helper.setValorCreditos((BigDecimal) parmsConta[14]);
					}

					// Valor Impostos
					if(parmsConta[15] != null){

						emitirContaTipo2Helper.setValorImpostos((BigDecimal) parmsConta[15]);
					}

					// // Data Validade da Conta
					// if(parmsConta[16] != null){
					// // não utilizado por contasTipo2
					// // emitirContaTipo2Helper.setDataValidadeConta((Date) parmsConta[16]);
					// }

					// Id do Imóvel
					if(parmsConta[17] != null){
						emitirContaTipo2Helper.setIdImovel((Integer) parmsConta[17]);
					}

					// Id da Localidade
					if(parmsConta[18] != null){

						emitirContaTipo2Helper.setInscLocalidade((Integer) parmsConta[18]);
					}

					// Id da Gerência Regional
					if(parmsConta[19] != null){

						emitirContaTipo2Helper.setIdGerenciaRegional((Integer) parmsConta[19]);
					}

					// Nome da Gerência Regional
					if(parmsConta[20] != null){

						emitirContaTipo2Helper.setNomeGerenciaRegional((String) parmsConta[20]);
					}

					// Id da Ligação Água Situação
					if(parmsConta[21] != null){

						emitirContaTipo2Helper.setIdLigacaoAguaSituacao((Integer) parmsConta[21]);
					}

					// Id da Ligação Esgoto Situação
					if(parmsConta[22] != null){

						emitirContaTipo2Helper.setIdLigacaoEsgotoSituacao((Integer) parmsConta[22]);
					}

					// // id do Perfil do Imóvel
					if(parmsConta[23] != null){

						emitirContaTipo2Helper.setIdImovelPerfil((Integer) parmsConta[23]);
					}

					// Id do Faturamento Grupo
					if(parmsConta[25] != null){

						emitirContaTipo2Helper.setIdFaturamentoGrupo((Integer) parmsConta[25]);
					}

					// Id da Empresa
					if(parmsConta[26] != null){

						emitirContaTipo2Helper.setIdEmpresa((Integer) parmsConta[26]);
					}

					// Descrição da Localidade
					if(parmsConta[27] != null){

						emitirContaTipo2Helper.setDescricaoLocalidade((String) parmsConta[27]);
					}

					// Descrição da Sistuação da Lig. de Água
					if(parmsConta[28] != null){

						emitirContaTipo2Helper.setDescricaoLigacaoAguaSituacao((String) parmsConta[28]);
					}

					// Descrição da Sistuação da Lig. de Esgoto
					if(parmsConta[29] != null){

						emitirContaTipo2Helper.setDescricaoLigacaoEsgotoSituacao((String) parmsConta[29]);
					}

					// Percentual Esgoto da Conta
					if(parmsConta[30] != null){

						emitirContaTipo2Helper.setPercentualEsgotoConta((BigDecimal) parmsConta[30]);
					}
					
					// Id do Cliente Responsável
					if(parmsConta[31] != null){

						clienteResponsavel = getControladorCliente().pesquisarCliente((Integer) parmsConta[31]);
						
						String pConsideraResponsavelApenasClienteTipoEspecial = null;

						try{

							pConsideraResponsavelApenasClienteTipoEspecial = (String) ParametroFaturamento.P_CONSIDERA_RESPONSAVEL_APENAS_CLIENTE_ESPECIAL
											.executar();
						}catch(ControladorException e){

							throw new ControladorException("atencao.sistemaparametro_inexistente", null,
											"P_CONSIDERA_RESPONSAVEL_APENAS_CLIENTE_ESPECIAL");
						}

						String pIdClienteTipoEspecialLegado = null;

						try{

							pIdClienteTipoEspecialLegado = (String) ParametroFaturamento.P_ID_CLIENTE_TIPO_ESPECIAL_LEGADO.executar();
						}catch(ControladorException e){

							throw new ControladorException("atencao.sistemaparametro_inexistente", null,
											"P_ID_CLIENTE_TIPO_ESPECIAL_LEGADO");
						}

						if(pConsideraResponsavelApenasClienteTipoEspecial.equals(ConstantesSistema.NAO.toString())
										|| (pConsideraResponsavelApenasClienteTipoEspecial.equals(ConstantesSistema.SIM.toString())
														&& clienteResponsavel.getClienteTipoEspecial() != null && clienteResponsavel
														.getClienteTipoEspecial().getId()
														.equals(Util.obterInteger(pIdClienteTipoEspecialLegado)))){
							
							emitirContaTipo2Helper.setClienteResponsavel(clienteResponsavel);
							emitirContaTipo2Helper.setIdClienteResponsavel(clienteResponsavel.getId());
						}
					}

					// Código da Rota
					if(parmsConta[33] != null){

						emitirContaTipo2Helper.setCodigoRota((Short) parmsConta[33]);
					}

					// // numero sequencial rota
					// if(parmsConta[34] != null){
					// // não utilizado por contasTipo2
					// // emitirContaTipo2Helper.setNumeroSequencialRota((Integer) parmsConta[34]);
					// }
					//
					// // origem
					// if(parmsConta[35] != null){
					// // não utilizado por contasTipo2
					// // emitirContaTipo2Helper.setIdOrigem((Integer) parmsConta[35]);
					// }
					//
					// // debitoCreditoSituacaoAtual
					// if(parmsConta[36] != null){
					// // não utilizado por contasTipo2
					// // emitirContaTipo2Helper.setDebitoCreditoSituacaoAtualConta((Integer)
					// // parmsConta[36]);
					// }
					//
					// // id do funcionario
					// if(parmsConta[37] != null){
					// // não utilizado por contasTipo2
					// // emitirContaTipo2Helper.setIdFuncionario((Integer) parmsConta[37]);
					// }
					//
					// // nome do funcionario
					// if(parmsConta[38] != null){
					// // não utilizado por contasTipo2
					// // emitirContaTipo2Helper.setNomeFuncionario((String) parmsConta[38]);
					// }
					//
					// // Tipo de Conta
					// if(parmsConta[39] != null){
					// // não utilizado por contasTipo2
					// // emitirContaTipo2Helper.setContaTipo((Integer) parmsConta[39]);
					// }
					//
					// // id da Rota
					// if(parmsConta[40] != null){
					//
					// emitirContaTipo2Helper.setIdRota((Integer) parmsConta[40]);
					// }

					// Tipo de Envio de Conta
					if(parmsConta[42] != null){

						emitirContaTipo2Helper.setIdImovelContaEnvio((Integer) parmsConta[42]);
					}

					// Id do Cliente Relação Tipo
					if(parmsConta[43] != null){

						emitirContaTipo2Helper.setIdClienteRelacaoTipo((Integer) parmsConta[43]);
					}

					// Elo
					if(parmsConta[44] != null){

						emitirContaTipo2Helper.setCodigoElo((Integer) parmsConta[44]);
					}

					// Id do cliente usuário
					clienteUsuario = getControladorImovel().pesquisarClienteUsuarioImovel(emitirContaTipo2Helper.getIdImovel());
					emitirContaTipo2Helper.setClienteUsuario(clienteUsuario);
					if(clienteUsuario != null){

						emitirContaTipo2Helper.setIdClienteUsuario(clienteUsuario.getId());
					}

					if(parmsConta[46] != null){

						emitirContaTipo2Helper.setDataRevisao((Date) parmsConta[46]);

					}

					if(parmsConta[47] != null){

						emitirContaTipo2Helper.setIdMotivoRevisao((Integer) parmsConta[47]);

					}

					if(parmsConta[48] != null){

						emitirContaTipo2Helper.setIdSetorComercial((Integer) parmsConta[48]);

					}

					if(parmsConta[49] != null){

						emitirContaTipo2Helper.setIndicadorContaBraille((Short) parmsConta[49]);

					}

					colecaoContasTipo2Helper.add(emitirContaTipo2Helper);
					emitirContaTipo2Helper = null;
				}
			}
		}
		return colecaoContasTipo2Helper;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB00010] Gerar Linhas da Descrição dos Serviços e Tarifas
	 * 
	 * @author Saulo Lima
	 * @date 10/10/2008
	 * @author Eduardo Henrique
	 * @date 23/12/2008, 31/01/2009, 16/02/2009, 04/05/2009 Alteração na verificação do Tipo de
	 *       Ligação do Imóvel, baseado na Situação da Ligação de
	 *       Água Correção na atribuição do Consumo Estimado no Não-Medido. Correção na obtenção do
	 *       Valor Total da Conta, quando a mesma possuía
	 *       Impostos gerados.
	 * @param Collection
	 *            <EmitirContaTipo2Helper> coleção de Helpers que representam cada conta a ser
	 *            impressa, populado.
	 * @throws ControladorException
	 */
	private void completarEmitirContasHelperDuasContasPorPagina(Collection<EmitirContaTipo2Helper> colecaoContaTipo2Retorno)
					throws ControladorException{

		// Devido à verificacao de necessidade de quebras de páginas , novos elementos podem ser
		// adicionados à coleção principal, então cria-se um
		// "espelho" da coleção original para evitar um concurrentModificationException
		Collection<EmitirContaTipo2Helper> colecaoEspelhoContasEmissao = new ArrayList<EmitirContaTipo2Helper>();
		colecaoEspelhoContasEmissao.addAll(colecaoContaTipo2Retorno);

		Iterator<EmitirContaTipo2Helper> colecaoContaTipo2Iterator = colecaoEspelhoContasEmissao.iterator();
		try{
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			while(colecaoContaTipo2Iterator.hasNext()){
				EmitirContaTipo2Helper contaTipo2Helper = colecaoContaTipo2Iterator.next();
				boolean duplicarConta = false;
				boolean adicionarEnderecoEntrega = false;
				boolean pagavelResponsavel = false;
				String enderecoEntrega = "";

				// Matrícula do Imovel
				contaTipo2Helper.setIdImovel(contaTipo2Helper.getIdImovel());

				// Nome do Imóvel ou Nome do cliente usuário
				contaTipo2Helper.setNomeCliente(contaTipo2Helper.getNomeCliente());

				// Endereço do imóvel
				Object[] arrayDadosEnderecoImovel = getControladorEndereco()
								.pesquisarEnderecoFormatadoLista(contaTipo2Helper.getIdImovel());
				contaTipo2Helper.setEndereco((String) arrayDadosEnderecoImovel[0]);
				contaTipo2Helper.setIdLogradouro((Integer) arrayDadosEnderecoImovel[1]);
				contaTipo2Helper.setNumeroImovel((String) arrayDadosEnderecoImovel[2]);

				if(arrayDadosEnderecoImovel[3] != null){

					contaTipo2Helper.setCepImovelFormatado((String) arrayDadosEnderecoImovel[3]);
				}

				// Endereço de entrega
				Integer idImovelContaEnvio = contaTipo2Helper.getIdImovelContaEnvio();
				if(idImovelContaEnvio != null){
					if(idImovelContaEnvio.intValue() == ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL.intValue()){
						duplicarConta = true;
						adicionarEnderecoEntrega = true;
						pagavelResponsavel = true;
						Imovel imovel = new Imovel();
						imovel.setId(contaTipo2Helper.getIdImovel());

						// Obter Endereço
						Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
						enderecoEntrega = (String) arrayDadosEndereco[0];
						contaTipo2Helper.setIdLogradouroEnderecoClienteEntrega((Integer) arrayDadosEndereco[1]);
						contaTipo2Helper.setNumeroImovelEnderecoClienteEntrega((String) arrayDadosEndereco[2]);

						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.NAO);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
						contaTipo2Helper.setIndicadorFaturaInformativa(ConstantesSistema.SIM);
					}else if(idImovelContaEnvio.intValue() == ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_PAGAVEL_PARA_RESPONSAVEL.intValue()){
						duplicarConta = true;
						pagavelResponsavel = true;
						adicionarEnderecoEntrega = true;
						Imovel imovel = new Imovel();
						imovel.setId(contaTipo2Helper.getIdImovel());

						// Obter Endereço
						Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
						enderecoEntrega = (String) arrayDadosEndereco[0];
						contaTipo2Helper.setIdLogradouroEnderecoClienteEntrega((Integer) arrayDadosEndereco[1]);
						contaTipo2Helper.setNumeroImovelEnderecoClienteEntrega((String) arrayDadosEndereco[2]);

						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
					}else if(idImovelContaEnvio.intValue() == ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_NAO_PAGAVEL_PARA_RESPOSAVEL.intValue()){
						duplicarConta = true;
						adicionarEnderecoEntrega = true;
						Imovel imovel = new Imovel();
						imovel.setId(contaTipo2Helper.getIdImovel());

						// Obter Endereço
						Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
						enderecoEntrega = (String) arrayDadosEndereco[0];
						contaTipo2Helper.setIdLogradouroEnderecoClienteEntrega((Integer) arrayDadosEndereco[1]);
						contaTipo2Helper.setNumeroImovelEnderecoClienteEntrega((String) arrayDadosEndereco[2]);

						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
					}else if(idImovelContaEnvio.intValue() == ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL.intValue()
									|| idImovelContaEnvio.intValue() == ImovelContaEnvio.ENVIAR_PARA_CLIENTE_PROPRIETARIO.intValue()
									|| idImovelContaEnvio.intValue() == ImovelContaEnvio.ENVIAR_PARA_CLIENTE_USUARIO.intValue()){
						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
						Imovel imovel = new Imovel();
						imovel.setId(contaTipo2Helper.getIdImovel());

						// Obter Endereço
						Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
						enderecoEntrega = (String) arrayDadosEndereco[0];
						contaTipo2Helper.setIdLogradouroEnderecoClienteEntrega((Integer) arrayDadosEndereco[1]);
						contaTipo2Helper.setNumeroImovelEnderecoClienteEntrega((String) arrayDadosEndereco[2]);

						contaTipo2Helper.setEnderecoClienteEntrega(enderecoEntrega);
					}else{ // enviar p/ imovel
						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
					}
				}else{ // enviar p/ imovel
					contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
					contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
				}

				// Referência
				contaTipo2Helper.setAnoMesConta(contaTipo2Helper.getAnoMesConta());

				// Inscrição - Localidade
				contaTipo2Helper.setInscLocalidade(contaTipo2Helper.getInscLocalidade());

				// Inscrição - SetorComercial
				contaTipo2Helper.setInscSetorComercial(contaTipo2Helper.getInscSetorComercial());

				// Inscrição - Quadra
				contaTipo2Helper.setInscQuadra(contaTipo2Helper.getInscQuadra());

				// Inscrição - Lote
				contaTipo2Helper.setInscLote(contaTipo2Helper.getInscLote());

				// Inscrição - Sub Lote
				contaTipo2Helper.setInscSubLote(contaTipo2Helper.getInscSubLote());

				// Economias da Conta por categoria
				// [SB0008] - Obter Quantidade de Economias da Conta
				Collection<ContaCategoria> colecaoContaCategoria = repositorioFaturamento.pesquisarContaCategoria(contaTipo2Helper
								.getIdConta());
				if(colecaoContaCategoria != null && !colecaoContaCategoria.isEmpty()){
					Iterator<ContaCategoria> iteratorCategoria = colecaoContaCategoria.iterator();
					while(iteratorCategoria.hasNext()){
						ContaCategoria contaCategoria = iteratorCategoria.next();
						if(contaCategoria.getComp_id().getCategoria() != null){
							Categoria categoria = contaCategoria.getComp_id().getCategoria();
							// Residencial, Comercial, Industrial ou Publico
							if(categoria.getId().equals(Categoria.RESIDENCIAL)){
								contaTipo2Helper.setEconResidencial(contaCategoria.getQuantidadeEconomia());
							}else if(categoria.getId().equals(Categoria.COMERCIAL)){
								contaTipo2Helper.setEconComercial(contaCategoria.getQuantidadeEconomia());
							}else if(categoria.getId().equals(Categoria.INDUSTRIAL)){
								contaTipo2Helper.setEconIndustrial(contaCategoria.getQuantidadeEconomia());
							}else if(categoria.getId().equals(Categoria.PUBLICO)){
								contaTipo2Helper.setEconPublica(contaCategoria.getQuantidadeEconomia());
							}
						}
					}
				}

				// Número do Hidrômetro
				MedicaoHistorico medicaoHistorico = repositorioMicromedicao.pesquisarMedicaoHistoricoTipoAgua(
								contaTipo2Helper.getIdImovel(), contaTipo2Helper.getAnoMesConta());
				if(medicaoHistorico != null){

					if(medicaoHistorico.getLigacaoAgua() != null
									&& medicaoHistorico.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){

						HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = medicaoHistorico.getLigacaoAgua()
										.getHidrometroInstalacaoHistorico();
						if(hidrometroInstalacaoHistorico != null && hidrometroInstalacaoHistorico.getHidrometro() != null
										&& hidrometroInstalacaoHistorico.getHidrometro().getNumero() != null){

							contaTipo2Helper.setHidrometro(hidrometroInstalacaoHistorico.getHidrometro().getNumero());
							contaTipo2Helper.setHidrometroLocalInstalacao(hidrometroInstalacaoHistorico.getHidrometroLocalInstalacao());
						}
					}
				}

				// Tipo Ligação
				Integer tipoLigacao = null;
				Integer tipoMedicao = null;

				Integer consumoAgua = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(
								contaTipo2Helper.getIdImovel(), contaTipo2Helper.getAnoMesConta(), LigacaoTipo.LIGACAO_AGUA);

				// Alteração conforme OC0857313
				// .......................................................
				LigacaoAguaSituacao ligacaoAguaSituacao = this.getControladorLigacaoAgua().pesquisarLigacaoAguaSituacao(
								contaTipo2Helper.getIdLigacaoAguaSituacao());

				// se a situação de agua da conta for ligado ou houve consumo de água
				if((ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO))
								|| (consumoAgua != null && consumoAgua.intValue() > 0)){

					tipoLigacao = LigacaoTipo.LIGACAO_AGUA;
					tipoMedicao = MedicaoTipo.LIGACAO_AGUA;
				}else{
					// caso contrário se ligação esgoto situação for igual a ligado

					LigacaoEsgotoSituacao ligacaoEsgotoSituacao = this.getControladorLigacaoEsgoto().pesquisarLigacaoEsgotoSituacao(
									contaTipo2Helper.getIdLigacaoEsgotoSituacao());

					if(ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao().equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)){
						tipoLigacao = LigacaoTipo.LIGACAO_ESGOTO;
						tipoMedicao = MedicaoTipo.POCO;
					}
				}
				// .......................................................

				// Início [SB0005] - Obter Dados da Medição da Conta
				Object[] parmsMedicaoHistorico = null;
				// caso o tipo de medição seja agua
				if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA)){

					parmsMedicaoHistorico = repositorioMicromedicao.obterDadosMedicaoContaTipoAgua(contaTipo2Helper.getIdImovel(),
									contaTipo2Helper.getAnoMesConta());
					contaTipo2Helper.setIdTipoMedicao(MedicaoTipo.LIGACAO_AGUA);
				}else{
					// senão caso o tipo de medição seja poco
					if(tipoMedicao != null && tipoMedicao.equals(MedicaoTipo.POCO)){

						parmsMedicaoHistorico = repositorioMicromedicao.obterDadosMedicaoContaTipoPoco(contaTipo2Helper.getIdImovel(),
										contaTipo2Helper.getAnoMesConta());
						contaTipo2Helper.setIdTipoMedicao(MedicaoTipo.POCO);
					}
				}

				Integer leituraAnterior = null;
				Integer leituraAtual = null;
				Date dataLeituraAnterior = null;
				Date dataLeituraAtual = null;
				Integer idLeituraSituacaoAtual = null;
				Integer idLeituraAnormalidadeFaturamento = null;

				if(parmsMedicaoHistorico != null){

					contaTipo2Helper.setIndicadorPossuiMedicaoHistorico(ConstantesSistema.SIM);
					if(parmsMedicaoHistorico[0] != null){

						leituraAnterior = (Integer) parmsMedicaoHistorico[0];
					}

					if(parmsMedicaoHistorico[1] != null){

						leituraAtual = (Integer) parmsMedicaoHistorico[1];
					}

					if(parmsMedicaoHistorico[3] != null){

						dataLeituraAnterior = (Date) parmsMedicaoHistorico[3];
					}

					if(parmsMedicaoHistorico[2] != null){

						dataLeituraAtual = (Date) parmsMedicaoHistorico[2];
					}

					if(parmsMedicaoHistorico[4] != null){

						idLeituraSituacaoAtual = (Integer) parmsMedicaoHistorico[4];
					}

					if(parmsMedicaoHistorico[5] != null){

						idLeituraAnormalidadeFaturamento = (Integer) parmsMedicaoHistorico[5];
					}
				}else{

					contaTipo2Helper.setIndicadorPossuiMedicaoHistorico(ConstantesSistema.NAO);
				}
				// Fim [SB0005]

				// Inicio - Período de Consumo e leituras
				contaTipo2Helper.setDtLeituraAnterior(dataLeituraAnterior);
				contaTipo2Helper.setDtLeituraAtual(dataLeituraAtual);
				contaTipo2Helper.setLeituraAnterior(leituraAnterior);
				contaTipo2Helper.setLeituraAtual(leituraAtual);
				contaTipo2Helper.setIdLeituraSituacaoAtual(idLeituraSituacaoAtual);
				contaTipo2Helper.setIdLeituraAnormalidadeFaturamento(idLeituraAnormalidadeFaturamento);
				contaTipo2Helper.setIdTipoLigacao(tipoLigacao);

				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				faturamentoGrupo.setId(contaTipo2Helper.getIdFaturamentoGrupo());
				FaturamentoAtividade atividadeLeitura = new FaturamentoAtividade();
				atividadeLeitura.setId(FaturamentoAtividade.EFETUAR_LEITURA);
				// Caso não tenha localizado a data de leitura Anterior, pegar a data da atividade
				// de leitura do Cronograma
				if(contaTipo2Helper.getDtLeituraAnterior() == null){
					int anoMesAnterior = Util.subtrairMesDoAnoMes(contaTipo2Helper.getAnoMesConta().intValue(), 1);

					Object[] dadosAtividadeLeituraGrupo = repositorioFaturamento.obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
									faturamentoGrupo, anoMesAnterior, atividadeLeitura);
					if(dadosAtividadeLeituraGrupo != null){
						if(dadosAtividadeLeituraGrupo[1] != null){
							contaTipo2Helper.setDtLeituraAnterior((Date) dadosAtividadeLeituraGrupo[1]);
						}else{ // Caso a data de realização esteja nula , coloca a data prevista
							if(dadosAtividadeLeituraGrupo[0] != null){
								contaTipo2Helper.setDtLeituraAnterior((Date) dadosAtividadeLeituraGrupo[0]);
							}
						}
					}
				}
				// Caso não tenha localizado a data de leitura Atual, pegar a data da atividade de
				// leitura do Cronograma
				if(contaTipo2Helper.getDtLeituraAtual() == null){
					int anoMesAnterior = contaTipo2Helper.getAnoMesConta().intValue();

					Object[] dadosAtividadeLeituraGrupo = repositorioFaturamento.obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
									faturamentoGrupo, anoMesAnterior, atividadeLeitura);
					if(dadosAtividadeLeituraGrupo != null){
						if(dadosAtividadeLeituraGrupo[1] != null){
							contaTipo2Helper.setDtLeituraAtual((Date) dadosAtividadeLeituraGrupo[1]);
						}else{ // Caso a data de realização esteja nula , coloca a data prevista
							if(dadosAtividadeLeituraGrupo[0] != null){
								contaTipo2Helper.setDtLeituraAtual((Date) dadosAtividadeLeituraGrupo[0]);
							}
						}
					}
				}
				// Fim - Período de Consumo e leituras

				// Ligação
				contaTipo2Helper.setDescricaoLigacaoAguaSituacao(contaTipo2Helper.getDescricaoLigacaoAguaSituacao());
				contaTipo2Helper.setDescricaoLigacaoEsgotoSituacao(contaTipo2Helper.getDescricaoLigacaoEsgotoSituacao());

				// Histórico de consumo dos últimos 6 meses
				if(tipoLigacao != null){
					int anoMes = contaTipo2Helper.getAnoMesConta().intValue();
					int qtdMeses = 1;
					int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					// Mês 1
					Integer consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(
									contaTipo2Helper.getIdImovel(), anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes1Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo1Conta(consumo);
					// Mês 2
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes2Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo2Conta(consumo);
					// Mês 3
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes3Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo3Conta(consumo);
					// Mês 4
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes4Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo4Conta(consumo);
					// Mês 5
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes5Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo5Conta(consumo);
					// Mês 6
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes6Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo6Conta(consumo);
				}
				// Inicio [SB0007] - Obter Dados de Consumo da Conta
				Object[] parmsConsumoHistorico = null;
				// String descricaoAbreviadaTipoConsumo = "";
				// String descricaoTipoConsumo = "";
				Integer consumoMedio = null;
				// String descricaoAbreviadaAnormalidadeConsumo = "";
				String descricaoAnormalidadeConsumo = "";
				Integer consumoRateio = null;
				Integer idConsumoTipo = null;
				Integer idConsumoAnormalidade = null;

				if(tipoLigacao != null){
					parmsConsumoHistorico = getControladorMicromedicao().obterDadosConsumoConta(contaTipo2Helper.getIdImovel(),
									contaTipo2Helper.getAnoMesConta(), tipoLigacao);

					if(parmsConsumoHistorico != null){
						// // descrição abreviada tipo de consumo
						// if(parmsConsumoHistorico[0] != null){
						// descricaoAbreviadaTipoConsumo = (String) parmsConsumoHistorico[0];
						// }
						// // descrição tipo de consumo
						// if(parmsConsumoHistorico[1] != null){
						// descricaoTipoConsumo = (String) parmsConsumoHistorico[1];
						// }
						// Consumo médio
						if(parmsConsumoHistorico[2] != null){
							consumoMedio = (Integer) parmsConsumoHistorico[2];
						}
						// // descrição abreviada anormalidade de consumo
						// if(parmsConsumoHistorico[3] != null){
						// descricaoAbreviadaAnormalidadeConsumo = (String)
						// parmsConsumoHistorico[3];
						// }
						// descrição anormalidade de consumo
						if(parmsConsumoHistorico[4] != null){
							descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
						}

						// Consumo médio
						if(parmsConsumoHistorico[5] != null){
							consumoRateio = (Integer) parmsConsumoHistorico[5];
						}

						// Id do Consumo Tipo
						if(parmsConsumoHistorico[6] != null){

							idConsumoTipo = (Integer) parmsConsumoHistorico[6];
						}

						// Id do Consumo Anormalidade
						if(parmsConsumoHistorico[7] != null){

							idConsumoAnormalidade = (Integer) parmsConsumoHistorico[7];
						}
					}
				}
				// Fim [SB0007]

				// Consumo Médio
				if(consumoMedio != null){
					contaTipo2Helper.setConsumoMedio(consumoMedio);
				}

				// Anormalidade Consumo
				contaTipo2Helper.setDescricaoAnormalidadeConsumo(descricaoAnormalidadeConsumo);

				// Id do Tipo de Consumo
				contaTipo2Helper.setIdConsumoTipo(idConsumoTipo);

				// Id do Consumo Anormalidade
				contaTipo2Helper.setIdConsumoAnormalidade(idConsumoAnormalidade);

				// Desrição Tipo Consumo
				if(tipoMedicao != null){
					FiltroMedicaoTipo filtroMedicaoTipo = new FiltroMedicaoTipo();
					filtroMedicaoTipo.adicionarParametro(new ParametroSimples(FiltroMedicaoTipo.ID, tipoMedicao));
					Collection<MedicaoTipo> colecaoMedicaoTipo = repositorioUtil.pesquisar(filtroMedicaoTipo, MedicaoTipo.class.getName());
					if(colecaoMedicaoTipo != null && !colecaoMedicaoTipo.isEmpty()){
						contaTipo2Helper.setDescricaoTipoConsumo(colecaoMedicaoTipo.iterator().next().getDescricao());
					}
				}

				// Inicio [SB0010] – Obter Mensagem de Rateio de Consumo ou Consumo Fixo de Esgoto
				/*
				 * 3. Caso o tipo de medição corresponda a poço e não existam dados de medição
				 * (verificar [FS0002]) ou o tipo de medição corresponda a ligação de água e o
				 * volume coletado de esgoto (CNTA_NNCONSUMOESGOTO) seja diferente de nulo e maior
				 * que o consumo de água (CNTA_NNCONSUMOAGUA)
				 */
				Integer idTipoContrato = 0;
				if(tipoMedicao != null
								&& ((tipoMedicao.intValue() == MedicaoTipo.POCO.intValue() && Util.isVazioOrNulo(parmsMedicaoHistorico)) || (tipoMedicao
												.intValue() == MedicaoTipo.LIGACAO_AGUA.intValue() && (contaTipo2Helper.getConsumoEsgoto() != null && contaTipo2Helper
												.getConsumoEsgoto().intValue() > contaTipo2Helper.getConsumoAgua().intValue())))){

					idTipoContrato = 2;
				}

				contaTipo2Helper.setIdTipoContrato(idTipoContrato);
				// Fim [SB0010]

				// Inicio [SB0017] – Obter Mensagem da Conta
				Object[] mensagensConta = null;
				String mensagemConta = "";

				Integer idGerenciaRegional = null;
				Integer idLocalidade = null;
				Integer idSetorComercial = null;
				Integer idFaturamentoGrupo = null;
				// Foi criado o objeto "emitirContaHelperTemp1" apenas para reutilizar o método
				// "pesquisarParmsContaMensagem"
				EmitirContaHelper emitirContaHelperTemp1 = new EmitirContaHelper();
				emitirContaHelperTemp1.setAmReferencia(contaTipo2Helper.getAnoMesConta().intValue());

				// Alterado por: Yara Souza
				// Data: 27/05/2010
				// O campo AnoReferenciaDebitoConta recebe o ano em que deve ser exibida a mensagem
				// de cliente sem débitos.
				// Caso não seja mais necessária a exibição da mensagem o mesmo deve receber valor
				// null e seguir o fluxo 2

				if(sistemaParametro.getAnoReferenciaDebitoConta() != null){
					// Calendar tempo = Calendar.getInstance();
					// fluxo 1
					Integer idImovel = contaTipo2Helper.getIdImovel();
					Integer idQuitacaoMensagem = this.verificarContaDebitoAnualConta(idImovel, sistemaParametro);

					if(idQuitacaoMensagem != null){
						mensagensConta = repositorioFaturamento.pesquisarParmsQuitacaoMensagem(idQuitacaoMensagem);

						if(Util.isVazioOrNulo(mensagensConta)){

							mensagensConta = this.pesquisarContaMensagem(emitirContaHelperTemp1.getAmReferencia(), idFaturamentoGrupo,
											idGerenciaRegional, idLocalidade, idSetorComercial);
						}
					}else{
						idGerenciaRegional = contaTipo2Helper.getIdGerenciaRegional();
						idLocalidade = contaTipo2Helper.getInscLocalidade();
						idSetorComercial = contaTipo2Helper.getInscSetorComercial();
						idFaturamentoGrupo = contaTipo2Helper.getIdFaturamentoGrupo();
						mensagensConta = this.pesquisarContaMensagem(emitirContaHelperTemp1.getAmReferencia(), idFaturamentoGrupo,
										idGerenciaRegional, idLocalidade, idSetorComercial);
					}

					// System.out.println(" Tempo retorno =" + Util.calcularDiferencaTempo(tempo));
				}else{
					// fluxo 2
					idGerenciaRegional = contaTipo2Helper.getIdGerenciaRegional();
					idLocalidade = contaTipo2Helper.getInscLocalidade();
					idSetorComercial = contaTipo2Helper.getInscSetorComercial();
					idFaturamentoGrupo = contaTipo2Helper.getIdFaturamentoGrupo();
					mensagensConta = this.pesquisarContaMensagem(emitirContaHelperTemp1.getAmReferencia(), idFaturamentoGrupo,
									idGerenciaRegional, idLocalidade, idSetorComercial);
				}

				if(mensagensConta != null){
					// Conta Mensagem 1
					if(mensagensConta[0] != null){
						mensagemConta += (String) mensagensConta[0] + " \n";
						contaTipo2Helper.setMsgContaParte1((String) mensagensConta[0]);
					}
					// Conta Mensagem 2
					if(mensagensConta[1] != null){
						mensagemConta += (String) mensagensConta[1] + " \n";
						contaTipo2Helper.setMsgContaParte2((String) mensagensConta[1]);
					}
					// Conta Mensagem 3
					if(mensagensConta[2] != null){
						mensagemConta += (String) mensagensConta[2];
						contaTipo2Helper.setMsgContaParte3((String) mensagensConta[2]);
					}
				}

				// Fim [SB0017]

				// Mensagem Conta
				contaTipo2Helper.setMsgConta(mensagemConta);

				// Consumo Faturado
				Integer consumoFaturado = null;
				if(tipoLigacao != null){
					if(tipoLigacao.equals(LigacaoTipo.LIGACAO_AGUA)){
						consumoFaturado = contaTipo2Helper.getConsumoAgua();
					}else if(tipoLigacao.equals(LigacaoTipo.LIGACAO_ESGOTO)){
						consumoFaturado = contaTipo2Helper.getConsumoEsgoto();
					}
				}
				contaTipo2Helper.setConsumoFaturado(consumoFaturado);

				// Consumo Medido / Estimado
				if(medicaoHistorico != null){
					if(medicaoHistorico.getNumeroConsumoMes() != null){
						contaTipo2Helper.setConsumoMedidoEstimado("Cons Medido: " + medicaoHistorico.getNumeroConsumoMes());
					}
				}

				// data Vencimento
				contaTipo2Helper.setDataVencimento(contaTipo2Helper.getDataVencimento());

				// Valor Total Conta
				Conta conta = new Conta();
				conta.setValorAgua(contaTipo2Helper.getValorAgua());
				conta.setValorEsgoto(contaTipo2Helper.getValorEsgoto());
				conta.setValorCreditos(contaTipo2Helper.getValorCreditos());
				conta.setDebitos(contaTipo2Helper.getDebitos());
				conta.setValorImposto(contaTipo2Helper.getValorImpostos());

				contaTipo2Helper.setValorTotalConta(conta.getValorTotal());

				// Início [SB0011] - Gerar Linhas da Descrição dos Serviços e Tarifas
				// Foi criado o objeto "emitirContaHelperTemp2" apenas para reutilizar o método
				// "gerarLinhasDescricaoServicoTarifasRelatorio"
				EmitirContaHelper emitirContaHelperTemp2 = new EmitirContaHelper();
				emitirContaHelperTemp2.setIdConta(contaTipo2Helper.getIdConta());
				emitirContaHelperTemp2.setValorAgua(contaTipo2Helper.getValorAgua());
				emitirContaHelperTemp2.setValorEsgoto(contaTipo2Helper.getValorEsgoto());
				emitirContaHelperTemp2.setDebitos(contaTipo2Helper.getDebitos());
				emitirContaHelperTemp2.setValorCreditos(contaTipo2Helper.getValorCreditos());
				emitirContaHelperTemp2.setValorImpostos(contaTipo2Helper.getValorImpostos());
				emitirContaHelperTemp2.setConsumoAgua(contaTipo2Helper.getConsumoAgua());
				emitirContaHelperTemp2.setConsumoEsgoto(contaTipo2Helper.getConsumoEsgoto());
				emitirContaHelperTemp2.setPercentualEsgotoConta(contaTipo2Helper.getPercentualEsgotoConta());

				List<ContaLinhasDescricaoServicosTarifasTotalHelper> colecaoContaLinhasDescricaoServicosTarifasTotalHelper = gerarLinhasDescricaoServicoTarifasRelatorio(
								emitirContaHelperTemp2, "" + consumoRateio, parmsMedicaoHistorico, tipoMedicao, false, null, null, false);

				contaTipo2Helper.setColecaoContaLinhasDescricaoServicosTarifasTotalHelper(colecaoContaLinhasDescricaoServicosTarifasTotalHelper);
				// Fim [SB0011]
				Integer idDebitoAutomatico = repositorioFaturamento.obterDebitoAutomatico(contaTipo2Helper.getIdImovel());
				if(idDebitoAutomatico != null){
					contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.NAO); // conta SEM
					// código de
					// barras
					contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.SIM);
				}

				// [SB0018] – Gerar Linhas das Contas com Débito Automático
				if(contaTipo2Helper.getIndicadorDebitoAutomatico().equals(ConstantesSistema.SIM)){

					FiltroDebitoAutomaticoRetornoCodigo filtroDebitoAutomaticoRetornoCodigo = new FiltroDebitoAutomaticoRetornoCodigo();
					filtroDebitoAutomaticoRetornoCodigo.adicionarParametro(new ParametroSimples(FiltroDebitoAutomaticoRetornoCodigo.ID,
									idDebitoAutomatico));
					filtroDebitoAutomaticoRetornoCodigo
									.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoAutomaticoRetornoCodigo.AGENCIA);
					filtroDebitoAutomaticoRetornoCodigo
									.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoAutomaticoRetornoCodigo.AGENCIA_BANCO);

					Collection<DebitoAutomatico> colecaoDebitoAutomatico = repositorioUtil.pesquisar(filtroDebitoAutomaticoRetornoCodigo,
									DebitoAutomatico.class.getName());

					if(colecaoDebitoAutomatico != null && !colecaoDebitoAutomatico.isEmpty()){
						DebitoAutomatico debitoAutomatico = colecaoDebitoAutomatico.iterator().next();

						if(debitoAutomatico.getAgencia() != null){
							contaTipo2Helper.setCodigoAgencia(debitoAutomatico.getAgencia().getCodigoAgencia());

							if(debitoAutomatico.getAgencia().getBanco() != null){
								contaTipo2Helper.setNomeBanco(debitoAutomatico.getAgencia().getBanco().getDescricao());
							}
						}
					}

					// [SB0019] – Gerar Linhas das Demais Contas
				}else{

					String anoMesString = "" + contaTipo2Helper.getAnoMesConta();
					String mesAnoString = anoMesString.substring(4, 6) + anoMesString.substring(0, 4);

					Integer digitoVerificadorContaInt = null;
					Short digitoVerificadorConta = contaTipo2Helper.getDigitoVerificadorConta();

					if(digitoVerificadorConta != null){
						digitoVerificadorContaInt = digitoVerificadorConta.intValue();
					}

					String representacaoNumericaCodBarra = this.getControladorArrecadacao().obterRepresentacaoNumericaCodigoBarra(3,
									contaTipo2Helper.getValorTotalConta(), null, contaTipo2Helper.getIdImovel(), mesAnoString,
									digitoVerificadorContaInt, null, null, null, DocumentoTipo.CONTA, null, null, null, null, null, null);

					// É necessário realizar essa verificação, pois o GSAN passou a utilizar a
					// tabela CODIGO_BARRAS_LAYOUT na hora de definir o código de barras
					String paramIndicadorTrataLegado = ParametroArrecadacao.P_INDICADOR_TRATA_LEGADO.executar();

					if(ConstantesSistema.SIM.toString().equals(paramIndicadorTrataLegado)){
						// Para atender à solicitação do cliente é ncessário incluir nas posições
						// 34-41
						// (fica 36-43 contando com os digitos verificadores) do código de barras do
						// documento CONTA a matrícula do imóvel. Observação: As posições foram
						// referenciadas considerando os 44 caracteres do código de barras, sem os
						// dígitos verificadores. A matrícula ficaria nas posições destacadas no
						// exemplo:
						// 11111111111 D 22222222222 D 33333333333 D 44444444444 D
						// representacaoNumericaCodBarra =
						// Util.inserirMatriculaImovelCodigoBarra(contaTipo2Helper.getIdImovel(),
						// representacaoNumericaCodBarra);
					}

					// Formata a representação númerica do código de barras
					String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11) + "-"
									+ representacaoNumericaCodBarra.substring(11, 12) + " "
									+ representacaoNumericaCodBarra.substring(12, 23) + "-"
									+ representacaoNumericaCodBarra.substring(23, 24) + " "
									+ representacaoNumericaCodBarra.substring(24, 35) + "-"
									+ representacaoNumericaCodBarra.substring(35, 36) + " "
									+ representacaoNumericaCodBarra.substring(36, 47) + "-"
									+ representacaoNumericaCodBarra.substring(47, 48);
					contaTipo2Helper.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

					String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra.substring(0, 11)
									+ representacaoNumericaCodBarra.substring(12, 23) + representacaoNumericaCodBarra.substring(24, 35)
									+ representacaoNumericaCodBarra.substring(36, 47);
					contaTipo2Helper.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);
				}

				// Inscrição Formatada
				Imovel imovel = new Imovel();
				Localidade localidade = new Localidade();
				localidade.setId(contaTipo2Helper.getInscLocalidade());
				imovel.setLocalidade(localidade);
				SetorComercial setorComercial = new SetorComercial();
				setorComercial.setCodigo(contaTipo2Helper.getInscSetorComercial());
				imovel.setSetorComercial(setorComercial);
				Quadra quadra = new Quadra();
				quadra.setNumeroQuadra(contaTipo2Helper.getInscQuadra());
				imovel.setQuadra(quadra);
				if(contaTipo2Helper.getInscLote() != null){
					imovel.setLote(contaTipo2Helper.getInscLote());
				}
				if(contaTipo2Helper.getInscSubLote() != null){
					imovel.setSubLote(contaTipo2Helper.getInscSubLote());
				}
				contaTipo2Helper.setInscricao(imovel.getInscricaoFormatada());

				// duplica a conta para enviar uma via de DEMONSTRAÇAO
				if(duplicarConta){
					EmitirContaTipo2Helper contaDemonstracao = new EmitirContaTipo2Helper();

					/*
					 * Inicio - CLONANDO HELPER Antes de fazer um CLONE do helper é necessário criar
					 * novas coleções para não referenciar as mesmas
					 * coleções do 'pai'.
					 */
					List<ContaLinhasDescricaoServicosTarifasTotalHelper> colecaoContaLinhasHelper = new ArrayList<ContaLinhasDescricaoServicosTarifasTotalHelper>();
					colecaoContaLinhasHelper.addAll(contaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper());

					List<EmitirContaTipo2Helper> colecaoPaginasAdicionaisFatura = new ArrayList<EmitirContaTipo2Helper>();
					colecaoPaginasAdicionaisFatura.addAll(contaTipo2Helper.getColecaoPaginasAdicionaisFatura());

					try{
						contaDemonstracao = (EmitirContaTipo2Helper) contaTipo2Helper.clone();
					}catch(CloneNotSupportedException e){
						throw new ControladorException("erro.sistema", e);
					}

					contaDemonstracao.setColecaoContaLinhasDescricaoServicosTarifasTotalHelper(colecaoContaLinhasHelper);
					contaDemonstracao.setColecaoPaginasAdicionaisFatura(colecaoPaginasAdicionaisFatura);
					// Fim - CLONANDO HELPER

					if(adicionarEnderecoEntrega){
						contaDemonstracao.setEnderecoClienteEntrega(enderecoEntrega);
					}

					if(pagavelResponsavel){
						contaDemonstracao.setIndicadorFaturaInformativa(ConstantesSistema.NAO);
						contaDemonstracao.setIndicadorCodigoBarras(ConstantesSistema.SIM);
					}else{
						contaDemonstracao.setIndicadorFaturaInformativa(ConstantesSistema.SIM);
						contaDemonstracao.setIndicadorCodigoBarras(ConstantesSistema.NAO);
					}
					// Pagina Inicial ficará com o label de demonstrativo e valores exibidos sem
					// codigo. conta não pagável.
					contaDemonstracao.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
					contaDemonstracao.setIndicadorValorConta(ConstantesSistema.SIM);
					contaDemonstracao.setIndicadorVencimentoConta(ConstantesSistema.SIM);

					// é realizado por último pela necessidade de verificação de quebra de páginas
					this.verificarGeracaoPaginasAdicionaisEmissaoConta(contaDemonstracao);

					colecaoContaTipo2Retorno.add(contaDemonstracao);

					// verifica se o Helper vai ter novas páginas e adiciona as páginas à coleção
					// inicial
					for(EmitirContaTipo2Helper contaHelperPaginaAdicional : contaDemonstracao.getColecaoPaginasAdicionaisFatura()){
						colecaoContaTipo2Retorno.add(contaHelperPaginaAdicional);
					}
				}

				// Inicio [FS0006] – Verificar espaço para descrição dos serviços e tarifas
				// totalmente preenchido
				// é realizado por último pela necessidade de verificação de quebra de páginas
				this.verificarGeracaoPaginasAdicionaisEmissaoConta(contaTipo2Helper);

				// verifica se o Helper vai ter novas páginas e adiciona as páginas à coleção
				// inicial
				for(EmitirContaTipo2Helper contaHelperPaginaAdicional : contaTipo2Helper.getColecaoPaginasAdicionaisFatura()){
					colecaoContaTipo2Retorno.add(contaHelperPaginaAdicional);
				}
			}
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Método realiza a verificação da necessidade de criação de novas "páginas" para a fatura,
	 * baseado no parâmetro de nr. de linhas por página a ser
	 * impresso no formulário.
	 * 
	 * @author eduardo henrique
	 * @date 05/05/2009
	 * @param emitirContaTipo2Helper
	 *            ContaHelper Instanciado e com coleção de Linhas de Serviços e Tarifas populados
	 * @throws ControladorException
	 */
	private void verificarGeracaoPaginasAdicionaisEmissaoConta(EmitirContaTipo2Helper emitirContaTipo2Helper) throws ControladorException{

		if(emitirContaTipo2Helper == null || emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper() == null
						|| emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper().isEmpty()){
			throw new IllegalArgumentException("erro.fatura_nula_ou_sem_tarifa_servico");
		}

		// Caso a quantidade de linhas de Tarifas e Serviços for maior que o Param. de Itens por
		// Página
		// TODO obter parâmetro de Quantidade de Itens
		if(emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper().size() > RelatorioContaTipo2.QUANTIDADE_ITENS_POR_PAGINA
						.intValue()){
			this.gerarPaginasAdicionaisEmissaoConta(emitirContaTipo2Helper, RelatorioContaTipo2.QUANTIDADE_ITENS_POR_PAGINA.intValue());
		}
	}

	/**
	 * Método realiza a geração novas páginas a serem impressas. Serão novos EmitirContaTipo2Helper,
	 * que serão adicionados à coleção de "páginas" do
	 * Helper "Principal". O helper principal sempre será a 1a página.
	 * 
	 * @author eduardo henrique
	 * @date 05/05/2009
	 * @param emitirContaTipo2Helper
	 *            ContaHelper Instanciado e com coleção de Linhas de Serviços e Tarifas populados
	 */
	private void gerarPaginasAdicionaisEmissaoConta(EmitirContaTipo2Helper emitirContaTipo2Helper, int maximoLinhasPorPagina)
					throws ControladorException{

		if(emitirContaTipo2Helper == null || emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper() == null
						|| emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper().isEmpty()
						|| maximoLinhasPorPagina <= 0){
			throw new IllegalArgumentException("erro.fatura_nula_ou_sem_tarifa_servico");
		}

		// "Clone" do helper original que será modelo para as novas instâncias geradas
		EmitirContaTipo2Helper contaHelperModelo = new EmitirContaTipo2Helper();

		try{
			contaHelperModelo = (EmitirContaTipo2Helper) emitirContaTipo2Helper.clone();
		}catch(CloneNotSupportedException e){
			throw new ControladorException("erro.sistema", e);
		}

		/*
		 * Caso o "Consumo da Conta" esteja NULL em algum dos 6 meses anteriores no Helper, colocar
		 * também NULL no Helper copiado (Motivo: o método
		 * BeanUtils.copyProperties coloca ZERO em Inteiros que estejam nulos).
		 */
		if(emitirContaTipo2Helper.getConsumo1Conta() == null){
			contaHelperModelo.setConsumo1Conta(null);
		}
		if(emitirContaTipo2Helper.getConsumo2Conta() == null){
			contaHelperModelo.setConsumo2Conta(null);
		}
		if(emitirContaTipo2Helper.getConsumo3Conta() == null){
			contaHelperModelo.setConsumo3Conta(null);
		}
		if(emitirContaTipo2Helper.getConsumo4Conta() == null){
			contaHelperModelo.setConsumo4Conta(null);
		}
		if(emitirContaTipo2Helper.getConsumo5Conta() == null){
			contaHelperModelo.setConsumo5Conta(null);
		}
		if(emitirContaTipo2Helper.getConsumo6Conta() == null){
			contaHelperModelo.setConsumo6Conta(null);
		}

		// Pagina Inicial ficará com Cód. Barras e valores inibidos
		emitirContaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.NAO);
		emitirContaTipo2Helper.setIndicadorFaturaInformativa(ConstantesSistema.NAO);
		emitirContaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
		emitirContaTipo2Helper.setIndicadorValorConta(ConstantesSistema.NAO);
		emitirContaTipo2Helper.setIndicadorVencimentoConta(ConstantesSistema.NAO);

		// Descrição de Linha para cada página que será quebrada
		ContaLinhasDescricaoServicosTarifasTotalHelper descricaoLinhaProximaPagina = new ContaLinhasDescricaoServicosTarifasTotalHelper(
						ConstantesSistema.TEXTO_QUEBRA_PAGINA_FATURA);

		// deixa na Coleção principal apenas os elementos da 1a página, e separa o que faltará ser
		// calculado (diminui-se 1, porque será adicionado ao
		// fim da Lista, a Descrição "CONTINUA..."
		List<ContaLinhasDescricaoServicosTarifasTotalHelper> colecaoLinhasAdicionais = new ArrayList<ContaLinhasDescricaoServicosTarifasTotalHelper>();

		colecaoLinhasAdicionais.addAll(emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper().subList(
						(maximoLinhasPorPagina - 1),
						emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper().size()));

		emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper().removeAll(colecaoLinhasAdicionais);
		emitirContaTipo2Helper.getColecaoContaLinhasDescricaoServicosTarifasTotalHelper().add(descricaoLinhaProximaPagina);

		// Inicia a geração das páginas restantes
		while(!colecaoLinhasAdicionais.isEmpty()){

			// Cria o novo helper que representará uma nova página
			EmitirContaTipo2Helper contaHelperNovaPagina = new EmitirContaTipo2Helper();

			try{
				contaHelperNovaPagina = (EmitirContaTipo2Helper) contaHelperModelo.clone();
			}catch(CloneNotSupportedException e){
				throw new ControladorException("erro.sistema", e);
			}

			// checa o tamanho das linhas restantes para a fatura
			List<ContaLinhasDescricaoServicosTarifasTotalHelper> colecaoGeracaoParcialPagina = new ArrayList<ContaLinhasDescricaoServicosTarifasTotalHelper>();
			if(colecaoLinhasAdicionais.size() <= maximoLinhasPorPagina){ // Ultima pagina
				colecaoGeracaoParcialPagina.addAll(colecaoLinhasAdicionais);

				// Pagina Final ficará com Cód. Barras/ Debito Autom. (baseados no original) e
				// valores/vencimento visiveis
				contaHelperNovaPagina.setIndicadorValorConta(ConstantesSistema.SIM);
				contaHelperNovaPagina.setIndicadorVencimentoConta(ConstantesSistema.SIM);

			}else{
				colecaoGeracaoParcialPagina.addAll(colecaoLinhasAdicionais.subList(0, (maximoLinhasPorPagina - 1)));
				colecaoGeracaoParcialPagina.add(descricaoLinhaProximaPagina);

				contaHelperNovaPagina.setIndicadorCodigoBarras(ConstantesSistema.NAO);
				contaHelperNovaPagina.setIndicadorFaturaInformativa(ConstantesSistema.NAO);
				contaHelperNovaPagina.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
				contaHelperNovaPagina.setIndicadorValorConta(ConstantesSistema.NAO);
				contaHelperNovaPagina.setIndicadorVencimentoConta(ConstantesSistema.NAO);
			}

			// Adiciona a colecao Parcial (seja última página ou não) na coleção de Páginas do
			// Helper "Principal"
			contaHelperNovaPagina.setColecaoContaLinhasDescricaoServicosTarifasTotalHelper(colecaoGeracaoParcialPagina);
			emitirContaTipo2Helper.getColecaoPaginasAdicionaisFatura().add(contaHelperNovaPagina);

			colecaoLinhasAdicionais.removeAll(colecaoGeracaoParcialPagina);
		}
	}

	/**
	 * Recupera o anoMesReferencia baseado em filtros do FaturamentoGrupo
	 * 
	 * @author eduardo henrique
	 * @date 10/12/2008
	 * @param idFaturamentoGrupo
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarAnoMesPorIdFaturamentoGrupo(Integer idFaturamentoGrupo) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarAnoMesReferenciaPorIdFaturamentoGrupo(idFaturamentoGrupo);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Recupera os FaturamentoSituacaoHistorico em vigência (baseado numa referência) de um Imóvel.
	 * 
	 * @author eduardo henrique
	 * @date 28/05/2009
	 * @param idImovel
	 *            [obrigatório]
	 * @param anoMesFaturamento
	 *            [obrigatório]
	 * @return Collection<FaturamentoSituacaoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<FaturamentoSituacaoHistorico> pesquisarFaturamentoSituacaoHistoricoImovel(Integer idImovel, Integer anoMesFaturamento)
					throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarFaturamentoSituacaoHistoricoImovel(idImovel, anoMesFaturamento);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public void criarDebitoACobrarCorrecaoAcrescimosVoid(Imovel imovel,
					CalcularAcrescimoPorImpontualidadeHelper calcularAcrescimoPorImpontualidadeHelper, SistemaParametro sistemaParametros,
					DebitoTipo debitoTipo, BigDecimal valorDebito, Integer referencia) throws ControladorException{

		Integer anoMesArrecadacaoAnterior = sistemaParametros.getAnoMesArrecadacao();
		Integer anoMesFaturamentoAnterior = sistemaParametros.getAnoMesFaturamento();
		sistemaParametros.setAnoMesArrecadacao(201902);
		sistemaParametros.setAnoMesFaturamento(referencia);
		this.criarDebitoACobrar(imovel, calcularAcrescimoPorImpontualidadeHelper, sistemaParametros, debitoTipo, valorDebito, referencia);

		sistemaParametros.setAnoMesArrecadacao(anoMesArrecadacaoAnterior);
		sistemaParametros.setAnoMesFaturamento(anoMesFaturamentoAnterior);
	}

	/**
	 * Insere uma conta motivo revisao
	 * 
	 * @param contaMotivoRevisao
	 * @param usuarioLogado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer inserirContaMotivoRevisao(ContaMotivoRevisao contaMotivoRevisao, Usuario usuarioLogado) throws ControladorException{

		try{
			return repositorioFaturamento.inserirContaMotivoRevisao(contaMotivoRevisao, usuarioLogado);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Lista ContasMotivoRevisao por filtro
	 * 
	 * @param contaMotivoRevisao
	 * @return lista de ContaMotivoRevisao
	 * @throws ControladorException
	 */
	public Collection<ContaMotivoRevisao> pesquisarContaMotivoRevisao(ContaMotivoRevisao contaMotivoRevisao, String tipoPesquisa)
					throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarContaMotivoRevisao(contaMotivoRevisao, tipoPesquisa);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Atualiza uma conta motivo revisao
	 * 
	 * @param contaMotivoRevisao
	 * @throws ControladorException
	 */
	public void atualizarContaMotivoRevisao(ContaMotivoRevisao contaMotivoRevisao) throws ControladorException{

		try{
			this.repositorioFaturamento.atualizarContaMotivoRevisao(contaMotivoRevisao);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Insere uma conta motivo Retificacao
	 * 
	 * @param contaMotivoRetificacao
	 * @param usuarioLogado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer inserirContaMotivoRetificacao(ContaMotivoRetificacao contaMotivoRetificacao, Usuario usuarioLogado)
					throws ControladorException{

		try{
			return repositorioFaturamento.inserirContaMotivoRetificacao(contaMotivoRetificacao, usuarioLogado);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Lista ContasMotivoRetificacao por filtro
	 * 
	 * @param contaMotivoRetificacao
	 * @return lista de ContaMotivoRetificacao
	 * @throws ControladorException
	 */
	public Collection<ContaMotivoRetificacao> pesquisarContaMotivoRetificacao(ContaMotivoRetificacao contaMotivoRetificacao,
					String tipoPesquisa) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarContaMotivoRetificacao(contaMotivoRetificacao, tipoPesquisa);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Atualiza uma conta motivo Retificacao
	 * 
	 * @param contaMotivoRetificacao
	 * @throws ControladorException
	 */
	public void atualizarContaMotivoRetificacao(ContaMotivoRetificacao contaMotivoRetificacao) throws ControladorException{

		try{
			this.repositorioFaturamento.atualizarContaMotivoRetificacao(contaMotivoRetificacao);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método responsável por carregar os atributos das contas que serão usados ao gerar histograma.
	 * 
	 * @param colecaoConta
	 * @throws ControladorException
	 */
	public void carregarContaParaHistograma(Collection colecaoConta) throws ControladorException{

		try{

			if(colecaoConta != null && !colecaoConta.isEmpty()){

				Iterator it = colecaoConta.iterator();

				while(it.hasNext()){

					Conta conta = (Conta) it.next();
					HashSet set = new HashSet();

					Collection collContasCategoria = new ArrayList();
					collContasCategoria = repositorioHistograma.pesquisarContaCategoriaParaHistograma(conta.getId());

					if(collContasCategoria != null && !collContasCategoria.isEmpty()){

						Iterator itt = collContasCategoria.iterator();

						while(itt.hasNext()){
							ContaCategoria contaCategoria = (ContaCategoria) itt.next();
							set.add(contaCategoria);
						}
					}
					conta.setContaCategorias(set);
				}
			}
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Método responsável por verificar débitos para exibir mensagem
	 * 
	 * @author Hebert Falcão
	 * @date 02/05/2011
	 */
	private Integer verificarContaDebitoAnualConta(Integer idImovel, SistemaParametro sistemaParametro) throws ControladorException{

		Integer retorno = null;

		// Data zero
		Calendar dataZero = GregorianCalendar.getInstance();
		dataZero.setTime(Util.converteStringParaDate("01/01/1900"));
		int anoZero = dataZero.get(Calendar.YEAR);

		// Ano de referência
		Integer anoRefereciaDebito = sistemaParametro.getAnoReferenciaDebitoConta();

		// Referencia Inicial
		String referenciaInicialString = anoZero + "01";
		Integer referenciaInicial = Util.converterStringParaInteger(referenciaInicialString);

		// Referencia Final
		String referenciaFinalString = (anoRefereciaDebito - 1) + "12";
		Integer referenciaFinal = Util.converterStringParaInteger(referenciaFinalString);

		// Data Vencimento Inicial
		Date dataVencimentoInicio = dataZero.getTime();

		// Data Vencimento Final
		int anoFinal = Integer.parseInt(referenciaFinalString.substring(0, 4));
		int mesFinal = Integer.parseInt(referenciaFinalString.substring(4, 6));
		int diaFinal = 31;

		// Recupera o último dia do anomes e passa a data como parametro
		Calendar dataVencimentoFinal = GregorianCalendar.getInstance();
		dataVencimentoFinal.set(Calendar.YEAR, anoFinal);
		dataVencimentoFinal.set(Calendar.MONTH, (mesFinal - 1));
		dataVencimentoFinal.set(Calendar.DAY_OF_MONTH, diaFinal);

		Date dataVencimentoFim = dataVencimentoFinal.getTime();

		Integer indicadorDebito = 1;
		Integer indicadorPagamento = 1;
		Integer indicadorConta = 1;
		Integer indicadorDebitoACobrar = 1;
		Integer indicadorGuiasPagamento = 1;
		Boolean indicadorContas = true;

		// Verifica se existe cobrança judicial (IMOV_ID em
		// COBRANCA_SITUACAO_HISTORICO com CBSH_AMCOBRANCASITUACAOFIM
		// BETWEEN referência inicial = [01/1900] e referência final =
		// [12/ano corrente - 1])
		Collection<CobrancaSituacaoHistorico> colecaoCobrancaSituacaoHistorico = this.getControladorCobranca()
						.pesquisarCobrancaSituacaoHistorico(idImovel, referenciaFinal);

		if(!Util.isVazioOrNulo(colecaoCobrancaSituacaoHistorico)){
			retorno = QuitacaoMensagem.MENSAGEM_02;
		}else{
			// Verifica se existe algum débito para o imóvel (referência inicial =
			// [01/1900] e referência final = [12/ano corrente - 1])
			ObterDebitoImovelOuClienteHelper imovelDebitos = this.getControladorCobranca().obterDebitoImovelParaMensagem(indicadorDebito,
							idImovel.toString(), referenciaInicial.toString(), referenciaFinal.toString(), dataVencimentoInicio,
							dataVencimentoFim, indicadorPagamento, indicadorConta, indicadorDebitoACobrar, indicadorGuiasPagamento,
							indicadorContas, anoRefereciaDebito);

			Collection<ContaValoresHelper> colecaoContasValores = imovelDebitos.getColecaoContasValores();
			Collection<ContaValoresHelper> colecaoContasValoresImovel = imovelDebitos.getColecaoContasValoresImovel();
			Collection<GuiaPagamentoValoresHelper> colecaoGuiasPagamentoValores = imovelDebitos.getColecaoGuiasPagamentoValores();

			// Verifica se não tem débito a cobrar de parcelamento em
			// aberto
			// referente a contas do [ano corrente - 1] (IMOV_ID em
			// DEBITO_A_COBRAR com DCST_IDATUAL com o valor
			// correspondente a Normal, com número de prestações
			// cobradas (DBAC_NNPRESTACAOCOBRADAS) menor que o número
			// total de prestações do débito (DBAC_NNPRESTACAODEBITO) e
			// DBTP_ID igual aos descritos na tabela DebitoTipo e
			// DBAC_ID = DBAC_ID da tabela PARCELAMENTO_ITEM com CNTA_ID
			// = CNTA_ID da tabela CONTA_HISTORICO e
			// CNTA_AMREFERENCIACONTA <= referência final = [12/ano
			// corrente - 1])
			Collection<Integer> idsDebitoTipo = new ArrayList<Integer>();

			idsDebitoTipo.add(DebitoTipo.ENTRADA_PARCELAMENTO);
			idsDebitoTipo.add(DebitoTipo.JUROS_SOBRE_PARCELAMENTO);
			idsDebitoTipo.add(DebitoTipo.PARCELAMENTO_ACRESCIMOS_IMPONTUALIDADE);
			idsDebitoTipo.add(DebitoTipo.PARCELAMENTO_CONTAS);
			idsDebitoTipo.add(DebitoTipo.PARCELAMENTO_DEBITO_A_COBRAR_CURTO_PRAZO);
			idsDebitoTipo.add(DebitoTipo.PARCELAMENTO_DEBITO_A_COBRAR_LONGO_PRAZO);
			idsDebitoTipo.add(DebitoTipo.PARCELAMENTO_GUIAS_PAGAMENTO);
			idsDebitoTipo.add(DebitoTipo.REPARCELAMENTOS_CURTO_PRAZO);
			idsDebitoTipo.add(DebitoTipo.REPARCELAMENTOS_LONGO_PRAZO);
			idsDebitoTipo.add(DebitoTipo.PARCELAMENTO);
			idsDebitoTipo.add(DebitoTipo.CORRECAO_PARCELAMENTO);

			Integer qtdDebitosACobrar = this.getControladorCobranca().pesquisarDebitosACobrarDeParcelamentoEmAberto(idImovel,
							referenciaFinal, idsDebitoTipo);

			if(Util.isVazioOrNulo(colecaoContasValores) && Util.isVazioOrNulo(colecaoContasValoresImovel)
							&& Util.isVazioOrNulo(colecaoGuiasPagamentoValores) && (qtdDebitosACobrar == null || qtdDebitosACobrar == 0)){
				// Sem débito
				retorno = QuitacaoMensagem.MENSAGEM_03;
			}else{
				// Verifica se tem apenas débito de anos anteriores (não tem
				// nenhum débito para referência inicial = [01/ano corrente - 1]
				// e referência final = [12/ano corrente - 1] e tem para
				// referência inicial = [01/1900] e referência final = [12/ano
				// corrente - 2])

				boolean possuiDebitoAnoAnterior = false;

				// Referencia Inicial
				referenciaInicialString = (anoRefereciaDebito - 1) + "01";
				referenciaInicial = Util.converterStringParaInteger(referenciaInicialString);

				// Data Vencimento Inicial
				int anoInicial = Integer.parseInt(referenciaInicialString.substring(0, 4));
				int mesInicial = Integer.parseInt(referenciaInicialString.substring(4, 6));
				int diaInicial = 01;

				// Recupera o primeiro dia do anomes
				Calendar dataVencimentoInicial = GregorianCalendar.getInstance();
				dataVencimentoInicial.set(Calendar.YEAR, anoInicial);
				dataVencimentoInicial.set(Calendar.MONTH, (mesInicial - 1));
				dataVencimentoInicial.set(Calendar.DAY_OF_MONTH, diaInicial);

				dataVencimentoInicio = dataVencimentoInicial.getTime();

				// Referencia Final
				referenciaFinalString = (anoRefereciaDebito - 1) + "12";
				referenciaFinal = Util.converterStringParaInteger(referenciaFinalString);

				// Data Vencimento Final
				anoFinal = Integer.parseInt(referenciaFinalString.substring(0, 4));
				mesFinal = Integer.parseInt(referenciaFinalString.substring(4, 6));
				diaFinal = 31;

				// Recupera o último dia do anomes
				dataVencimentoFinal = GregorianCalendar.getInstance();
				dataVencimentoFinal.set(Calendar.YEAR, anoFinal);
				dataVencimentoFinal.set(Calendar.MONTH, (mesFinal - 1));
				dataVencimentoFinal.set(Calendar.DAY_OF_MONTH, diaFinal);

				dataVencimentoFim = dataVencimentoFinal.getTime();

				if(!possuiDebitoAnoAnterior && !Util.isVazioOrNulo(colecaoContasValores)){
					for(ContaValoresHelper obj : colecaoContasValores){
						Conta conta = obj.getConta();
						int referencia = conta.getReferencia();
						Date dataVencimentoConta = conta.getDataVencimentoConta();

						if(referenciaInicial <= referencia && referencia <= referenciaFinal
										&& Util.compararData(dataVencimentoInicio, dataVencimentoConta) != 1
										&& Util.compararData(dataVencimentoConta, dataVencimentoFim) != 1){
							possuiDebitoAnoAnterior = true;

							break;
						}
					}
				}

				if(!possuiDebitoAnoAnterior && !Util.isVazioOrNulo(colecaoContasValoresImovel)){
					for(ContaValoresHelper obj : colecaoContasValoresImovel){
						Conta conta = obj.getConta();
						int referencia = conta.getReferencia();
						Date dataVencimentoConta = conta.getDataVencimentoConta();

						if(referenciaInicial <= referencia && referencia <= referenciaFinal
										&& Util.compararData(dataVencimentoInicio, dataVencimentoConta) != 1
										&& Util.compararData(dataVencimentoConta, dataVencimentoFim) != 1){
							possuiDebitoAnoAnterior = true;

							break;
						}
					}
				}

				if(!possuiDebitoAnoAnterior && !Util.isVazioOrNulo(colecaoGuiasPagamentoValores)){
					for(GuiaPagamentoValoresHelper obj : colecaoGuiasPagamentoValores){
						Integer anoMesReferenciaFaturamento = obj.getAnoMesReferenciaFaturamento();
						Date dataVencimento = obj.getDataVencimento();

						if(referenciaInicial <= anoMesReferenciaFaturamento && anoMesReferenciaFaturamento <= referenciaFinal
										&& Util.compararData(dataVencimentoInicio, dataVencimento) != 1
										&& Util.compararData(dataVencimento, dataVencimentoFim) != 1){
							possuiDebitoAnoAnterior = true;

							break;
						}
					}
				}

				if(!possuiDebitoAnoAnterior && (qtdDebitosACobrar == null || qtdDebitosACobrar == 0)){
					retorno = QuitacaoMensagem.MENSAGEM_01;
				}
			}
		}

		return retorno;
	}

	public int pesquisarQuantidadeDebitosCobradosComParcelamentoPorConta(Collection idsContas) throws ControladorException{

		Collection<Integer> tiposParcelamento = Util
						.converterStringParaColecaoInteger(ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar());
		try{
			return repositorioFaturamento.pesquisarQuantidadeDebitosCobradosComParcelamentoPorConta(idsContas, tiposParcelamento);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Metodo que retorno o somátorio dos debitos cobrados.
	 * [0] - Multas,
	 * [1] - Juros
	 * [2] - Outros Serviços
	 * 
	 * @author isilva
	 * @date 17/11/2010
	 * @param idConta
	 * @return
	 * @throws ControladorException
	 */
	public Object[] pesquisarDebitosCobradosPorConta(Integer idConta) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarDebitosCobradosPorConta(idConta);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Retorna os SetorComercialVencimento, Ativos ou Inativos;
	 * Ordenados pelo dia de Vencimento.
	 * Não Carrega Localidade, ném SetorComercial
	 * 
	 * @author isilva
	 * @date 21/01/2011
	 * @param idLocalidade
	 * @param idSetorComercial
	 * @param indicadorUso
	 * @return
	 * @throws ControladorException
	 */
	public Collection<SetorComercialVencimento> pesquisarSetorComercialVencimentoPorLocalidadeSetorComercial(Integer idLocalidade,
					Integer idSetorComercial, Short indicadorUso) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarSetorComercialVencimentoPorLocalidadeSetorComercial(idLocalidade, idSetorComercial,
							indicadorUso);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Relatório Ordem de Serviço de Substituição de Hidrômetro
	 * Obter dados de até duas contas em revisão
	 * 
	 * @author Anderson Italo
	 * @date 26/05/2011
	 */
	public Collection<DadosContaEmRevisaoHelper> pesquisarDadosContasEmRevisao(Integer idImovel) throws ControladorException{

		Collection<DadosContaEmRevisaoHelper> retorno = null;
		try{
			retorno = this.repositorioFaturamento.pesquisarDadosContasEmRevisao(idImovel);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0083] Gerar dados para leitura
	 * 
	 * @author Bruno Ferreira dos Santos
	 * @date 02/08/2011
	 */

	public void atualizarFaturamentoAtividadeCronograma(FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal)
					throws ControladorException{

		try{
			repositorioFaturamento.atualizarFaturamentoAtividadeCronograma(faturamentoGrupoCronogramaMensal);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			throw new ControladorException(e.getMessage());
		}
	}

	/**
	 * [UC0083] Gerar Dados para Leitura
	 * - Atualizar situação do faturamento do imóvel
	 * - Atualizar o ano/mês de faturamento retirada
	 * 
	 * @author Hebert Falcão
	 * @date 28/06/2011
	 */
	public void atualizarImoveisSituacaoEspecialFaturamentoFinalizadaPorGrupo(Integer anoMesFaturamento, Integer idGrupoFaturamento)
					throws ControladorException{

		try{
			this.repositorioFaturamento
							.atualizarImoveisSituacaoEspecialFaturamentoFinalizadaPorGrupo(anoMesFaturamento, idGrupoFaturamento);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public Date buscarDataLeituraCronograma(Integer grupoFaturamentoID, boolean situacao, Integer anoMesReferencia)
					throws ControladorException{

		Date retorno = null;
		Collection colecaoFaturamentoAtividadeCronograma;

		FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();

		/*
		 * Vai buscar o objeto FaturamentoGrupoCronogramaMensal com as características do imóvel
		 * recebido e o anoMes da Conta - Fernanda Paiva -
		 * 19/08/2006
		 */
		FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensal = buscarFaturamentoGrupoCronogramaMensal(anoMesReferencia, null,
						situacao, grupoFaturamentoID);

		if(faturamentoGrupoCronogramaMensal != null){

			// Comentado por Raphael Rossiter em 09/05/2007
			/*
			 * throw new ControladorException( "atencao.nao_realizada_atividade_leitura", null,
			 * imovel .getQuadra().getRota().getFaturamentoGrupo()
			 * .getId().toString());
			 */

			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID, faturamentoGrupoCronogramaMensal
											.getId()));

			/*
			 * FTAT_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA com o valor correspondente a
			 * leitura
			 */
			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, FaturamentoAtividade.EFETUAR_LEITURA));

			colecaoFaturamentoAtividadeCronograma = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
							FaturamentoAtividadeCronograma.class.getName());

			if(colecaoFaturamentoAtividadeCronograma != null && !colecaoFaturamentoAtividadeCronograma.isEmpty()){
				FaturamentoAtividadeCronograma faturamentoAtividadeCronograma = (FaturamentoAtividadeCronograma) Util
								.retonarObjetoDeColecao(colecaoFaturamentoAtividadeCronograma);

				if(faturamentoAtividadeCronograma.getDataRealizacao() != null){
					retorno = faturamentoAtividadeCronograma.getDataRealizacao();
				}
			}
		}

		return retorno;
	}

	private Collection obterColecaoIdsRotas(Collection collRotas){

		Collection collIdsRotas = new ArrayList();

		Iterator it = collRotas.iterator();
		while(it.hasNext()){
			Rota rota = (Rota) it.next();
			collIdsRotas.add(rota.getId());
		}

		return collIdsRotas;
	}

	/**
	 * @param imovel
	 * @author Yara Souza
	 * @throws ControladorException
	 * @Date 19/08/2011
	 *       verifica se o imovel possui ligação de agua e esgoto e se possui hidrometro instalado.
	 *       Caso NÃO existam e ambas ligacoes de agua e esgoto nao possuam hidrometro instalado,
	 *       retorna TRUE.
	 *       Caso contrario retorna FALSE.
	 */
	public boolean verificarImovelNaoMedido(Imovel imovel) throws ControladorException{

		boolean imovelNaoMedido = false;

		// [UC0409 Obter Indicador de existência de hidrômetro na Ligação
		// de Água e poço
		ObterIndicadorExistenciaHidrometroHelper indicadorHidrometroAguaPoco;
		try{
			indicadorHidrometroAguaPoco = this.getControladorRegistroAtendimento().obterIndicadorExistenciaHidrometroLigacaoAguaPoco(
							imovel.getId(), false);

			Short hidrometroLigacaoAguaImovel = indicadorHidrometroAguaPoco.getIndicadorLigacaoAgua();
			Short hidrometroLigacaoPocoImovel = indicadorHidrometroAguaPoco.getIndicadorPoco();

			if(hidrometroLigacaoAguaImovel.equals(ConstantesSistema.NAO) && hidrometroLigacaoPocoImovel.equals(ConstantesSistema.NAO)){
				imovelNaoMedido = true;
			}

		}catch(ControladorException e){
			throw new ControladorException("erro.sistema", e);
		}

		return imovelNaoMedido;

	}

	/**
	 * @autor Bruno Ferreira dos Santos
	 * @date 15/08/2011
	 * @param idTipoEspecificacaoSolicitacao
	 * @return
	 * @throws ControladorException
	 */
	public Integer obterQuantidadeRAEncerradaAnoCorrentePorTipoSolicitacaoEspecificacao(Integer idTipoEspecificacaoSolicitacao,
					Integer idImovel) throws ControladorException{

		try{
			return this.repositorioFaturamento.obterQuantidadeRAEncerradaAnoCorrentePorTipoSolicitacaoEspecificacao(
							idTipoEspecificacaoSolicitacao, idImovel);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

	}

	public ExecutorParametro getExecutorParametro(){

		return ExecutorParametrosFaturamento.getInstancia();
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Determina os dados do faturamento do imóvel.
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * 2.2.1 - Método que retorna true caso o imóvel tenha o número[PARM_NNCONSUMOEXCEDIDOAPT] de
	 * consumos consecutivos maior que o mínimo [PARÂMETRO – PARM_NNCONSUMOMINIMOAPT]
	 * 
	 * @author Ailton Sousa
	 * @data 05/07/2011
	 * @param imovel
	 * @param ligacaoTipoAgua
	 * @param anoMesReferencia
	 * @param sistemaParametro
	 * @return
	 * @throws ControladorException
	 */
	private boolean isNumeroConsumoConsecutivoMaiorQueMinimo(Imovel imovel, LigacaoTipo ligacaoTipoAgua, int anoMesReferencia,
					SistemaParametro sistemaParametro) throws ControladorException{

		ConsumoHistorico consumoHistoricoAgua = null;
		boolean retorno = false;
		Integer numeroConsumoExcedidoAPT = sistemaParametro.getNumeroConsumoExcedidoAguaParaTodos();
		Integer numeroConsumoMinimoAPT = sistemaParametro.getNumeroConsumoMinAguaParaTodos();
		int contador = 0;

		for(int i = 0; i < numeroConsumoExcedidoAPT; i++){
			consumoHistoricoAgua = getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipoAgua,
							Util.subtrairMesDoAnoMes(anoMesReferencia, i));
			if(consumoHistoricoAgua != null && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() > numeroConsumoMinimoAPT){
				contador = contador + 1;
			}
		}

		if(contador == numeroConsumoExcedidoAPT.intValue()){
			retorno = true;
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Determina os dados do faturamento do imóvel.
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * Método que exclui o imóvel do programa águas para todos.
	 * 
	 * @author Ailton Sousa
	 * @data 05/08/2011
	 * @param imovel
	 * @param sistemaParametro
	 * @throws ControladorException
	 */
	private void excluirImoveldoProgramaAguaParaTodos(Imovel imovel, SistemaParametro sistemaParametro) throws ControladorException{

		imovel = getControladorImovel().consultarImovel(imovel.getId());

		// Excluir o imóvel do programa Agua para Todos.
		imovel.setConsumoTarifaTemporaria(null);
		imovel.setImovelAguaParaTodos(null);
		imovel.setDataValidadeTarifaTemporaria(null);

		// Registrar os dados da exclusão em IMOVEL_AGUA_PARA_TODOS
		FiltroImovelAguaParaTodos filtroImovelAguaParaTodos = new FiltroImovelAguaParaTodos();
		filtroImovelAguaParaTodos.adicionarParametro(new ParametroSimples(FiltroImovelAguaParaTodos.ID, imovel.getId()));
		// filtroImovelAguaParaTodos.adicionarParametro(new ConectorOr(new
		// ParametroSimplesDiferenteDe(
		// FiltroImovelAguaParaTodos.CODIGO_SITUACAO, ImovelAguaParaTodos.EXCLUIDO), new
		// ParametroNulo(
		// FiltroImovelAguaParaTodos.CODIGO_SITUACAO)));
		filtroImovelAguaParaTodos.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroImovelAguaParaTodos.CODIGO_SITUACAO,
						ImovelAguaParaTodos.EXCLUIDO));

		Collection colImovelAguaParaTodos = getControladorUtil().pesquisar(filtroImovelAguaParaTodos, ImovelAguaParaTodos.class.getName());

		ImovelAguaParaTodos imovelAguaParaTodos = null;
		Iterator itImovelAPT;

		if(!colImovelAguaParaTodos.isEmpty()){
			itImovelAPT = colImovelAguaParaTodos.iterator();
			Date dataAtual = new Date();
			while(itImovelAPT.hasNext()){
				imovelAguaParaTodos = (ImovelAguaParaTodos) itImovelAPT.next();

				imovelAguaParaTodos.setDataExclusao(dataAtual);
				imovelAguaParaTodos.setUltimaAlteracao(dataAtual);
				imovelAguaParaTodos.setCodigoSituacao(ImovelAguaParaTodos.EXCLUIDO);
				if(sistemaParametro.getCodMotivoExclusaoAguaParaTodos() != null){
					imovelAguaParaTodos.setMotivoExclusao(sistemaParametro.getCodMotivoExclusaoAguaParaTodos());
				}

				getControladorCadastro().atualizarImovelAguaParaTodos(imovelAguaParaTodos, imovel, Usuario.USUARIO_BATCH);
			}
		}
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Determina os dados do faturamento do imóvel.
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * Método que verifica se o imóvel deve ser excluido do programa águas para todos.
	 * 
	 * @author Yara Souza
	 * @data 19/08/2011
	 * @param imovel
	 * @param sistemaParametro
	 * @throws ControladorException
	 */
	private boolean verificarExclusaoImoveldoProgramaAguaParaTodos(Imovel imovel, SistemaParametro sistemaParametro)
					throws ControladorException{

		boolean excluirImovel = false;
		if(imovel.getImovelAguaParaTodos() == null){
			return excluirImovel;
		}

		ObterDebitoImovelOuClienteHelper obterDebitoImovelOuClienteHelper = null;
		String referenciaInicial = "01/0001";
		String referenciaFinal = "12/9999";
		String dataVencimentoInicial = "01/01/0001";
		String dataVencimentoFinal = "31/12/9999";

		// Para auxiliar na formatação de uma data
		SimpleDateFormat formatoData = new SimpleDateFormat("dd/MM/yyyy");
		String mesInicial = referenciaInicial.substring(0, 2);
		String anoInicial = referenciaInicial.substring(3, referenciaInicial.length());
		String anoMesInicial = anoInicial + mesInicial;
		String mesFinal = referenciaFinal.substring(0, 2);
		String anoFinal = referenciaFinal.substring(3, referenciaFinal.length());
		String anoMesFinal = anoFinal + mesFinal;

		Date dataVencimentoDebitoI = null;
		Date dataVencimentoDebitoF = null;
		try{
			dataVencimentoDebitoI = formatoData.parse(dataVencimentoInicial);
			dataVencimentoDebitoF = formatoData.parse(dataVencimentoFinal);
		}catch(ParseException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		obterDebitoImovelOuClienteHelper = getControladorCobranca().obterDebitoImovelOuCliente(1, imovel.getId().toString(), null, null,
						anoMesInicial, anoMesFinal, dataVencimentoDebitoI, dataVencimentoDebitoF, 2, 2, 2, 2, 2, 2, 2, null,
						sistemaParametro, null, null, null, ConstantesSistema.SIM, ConstantesSistema.SIM, ConstantesSistema.SIM, 2, null);

		// Verificar se existe a quantidade[PARÂMETRO – PARM_NNMINIMODEBITOSAPT] ou mais de
		// débitos.
		if(obterDebitoImovelOuClienteHelper != null
						&& sistemaParametro.getNumeroMinDebitosAguaParaTodos() != null
						&& obterDebitoImovelOuClienteHelper.getColecaoContasValores().size() > sistemaParametro
										.getNumeroMinDebitosAguaParaTodos().intValue()){
			excluirImovel = true;

		}

		return excluirImovel;

	}

	/**
	 * Início da reestruturação do [SB0001] - Determinar Faturamento do Imóvel.
	 */

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * Determina os dados do faturamento do imóvel.
	 * [SB0001 - Determinar Faturamento para o Imóvel]
	 * 
	 * @author Yara Souza
	 * @data 19/08/2011
	 * @param imovel
	 * @param anoMesFaturamento
	 * @param faturamentoAtivCronRta
	 * @param colecaoResumoFaturamento
	 * @param sistemaParametro
	 * @param antecipado
	 * @param faturamentoGrupo
	 * @param anoMes
	 * @param isRegistrarFaturamentoImediato
	 *            (indica se é chamado pelo faturamento imediato)
	 * @param contaImovel
	 *            (vai vir null quando não for chamado pelo faturamento imediato)
	 * @param colecaoHelperRelatorioOcorrenciaRegistrada
	 *            (vai vir null quando não for chamado pelo faturamento imediato)
	 * @return Conta [Conta gerada para imóvel, que será usada para geração de Histogramas, Resumos
	 *         e Contabilizacao]
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	private Conta determinarFaturamentoImovel(Imovel imovel, int anoMesFaturamento, FaturamentoAtivCronRota faturamentoAtivCronRota,
					Collection colecaoResumoFaturamento, SistemaParametro sistemaParametro, boolean antecipado,
					FaturamentoGrupo faturamentoGrupo, Integer anoMes, boolean isRegistrarFaturamentoImediato, Conta contaImovel,
					Collection<RelatorioResumoOcorrenciasFaturamentoImediatoHelper> colecaoHelperRelatorioOcorrenciaRegistrada,
					Object[] arrayMedicaoConsumoHistorico, Collection<Imovel> colecaoOcorrenciaGeracaoPreFaturamento,
					MovimentoRoteiroEmpresa movimentoRoteiroEmpresa,
					Collection<RelatorioContasBloqueadasAnaliseHelper> colecaoContasBloqueadasAnaliseHelper,
					FaturamentoSimulacaoComando faturamentoSimulacaoComando) throws ControladorException, ErroRepositorioException{

		// Caso seja chamado pelo método [UC0088] Registrar Faturamento Imediato.
		if(isRegistrarFaturamentoImediato){
			return determinarFaturamentoImovelParaFaturamentoImediato(imovel, anoMesFaturamento, faturamentoAtivCronRota,
							colecaoResumoFaturamento, sistemaParametro, antecipado, faturamentoGrupo, anoMes, contaImovel,
							colecaoHelperRelatorioOcorrenciaRegistrada, arrayMedicaoConsumoHistorico, movimentoRoteiroEmpresa,
							colecaoContasBloqueadasAnaliseHelper);
		}else{
			// Caso seja chamado pela rotina normal do Faturamento.
			return determinarFaturamentoImovelParaFaturamento(imovel, anoMesFaturamento, faturamentoAtivCronRota, colecaoResumoFaturamento,
							sistemaParametro, antecipado, faturamentoGrupo, anoMes, colecaoOcorrenciaGeracaoPreFaturamento,
							faturamentoSimulacaoComando);
		}

	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * [SB0005] - Gerar Creditos Realizados
	 * 
	 * @author Yara Souza
	 * @data 20/08/2011
	 * @param imovel
	 * @param anoMesFaturamento
	 * @param gerarAtividadeGrupoFaturamento
	 * @param valorTotalAgua
	 * @param valorTotalEsgoto
	 * @param valorTotalDebitos
	 */

	private Object[] gerarCreditosRealizadosFaturamentoConvencional(Imovel imovel, Integer anoMesFaturamento, BigDecimal valorTotalAgua,
					BigDecimal valorTotalEsgoto, BigDecimal valorTotalDebitos, FaturamentoSimulacaoComando faturamentoSimulacaoComando,
					Short indicadorFaturamentoAgua, Short indicadorFaturamentoEsgoto, Collection colecaoCategoriasImovel,
					int consumoMinimoLigacao, Date dataLeituraAnterior, Date dataLeituraAtual, BigDecimal percentualEsgoto,
					Integer idConsumoTarifaImovel) throws ControladorException{

		Object[] retorno = new Object[4];
		try{

			Collection<CreditoARealizar> colecaoCreditosARealizarTemp = this.obterCreditoARealizarImovelObjeto(imovel.getId());
			
			// [FS0006 - Verificar créditos a realizar de parcelamento], 
			Collection<CreditoARealizar> colecaoCreditosARealizar = this.verificarCreditosARealizarDeParcelamento(
							colecaoCreditosARealizarTemp, anoMesFaturamento);

			// [FS0011 - Verificar créditos a realizar de CREDTAC].
			Object[] verificadorCreditosARealizarCREDTAC = this.verificarCreditosARealizarCREDTAC(colecaoCreditosARealizarTemp, imovel);
			colecaoCreditosARealizar = (Collection<CreditoARealizar>) verificadorCreditosARealizarCREDTAC[0];
			boolean possuiCreditosCREDTAC = (Boolean) verificadorCreditosARealizarCREDTAC[1];

			BigDecimal valorTarifaMinimaLigacao = BigDecimal.ZERO;

			// Caso possua CREDTAC
			if(possuiCreditosCREDTAC){

				// Obtém o valor da tarifa mínima para a ligação
				Collection<CalcularValoresAguaEsgotoHelper> colecaoCalcularValoresAguaEsgotoHelper = this.calcularValoresAguaEsgoto(
								anoMesFaturamento, imovel.getLigacaoAguaSituacao().getId(), imovel.getLigacaoEsgotoSituacao().getId(),
								indicadorFaturamentoAgua, indicadorFaturamentoEsgoto, colecaoCategoriasImovel, 0, 0, consumoMinimoLigacao,
								dataLeituraAnterior, dataLeituraAtual, percentualEsgoto, idConsumoTarifaImovel, imovel.getId(), null);

				for(CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper : colecaoCalcularValoresAguaEsgotoHelper){

					if(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria() != null){

						valorTarifaMinimaLigacao = valorTarifaMinimaLigacao.add(calcularValoresAguaEsgotoHelper
										.getValorFaturadoAguaCategoria());
					}

					if(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria() != null){

						valorTarifaMinimaLigacao = valorTarifaMinimaLigacao.add(calcularValoresAguaEsgotoHelper
										.getValorFaturadoEsgotoCategoria());
					}
				}
			}

			// Inicializa o valor total dos créditos e a cobrar com zero
			BigDecimal valorTotalCreditos = BigDecimal.ZERO;
			BigDecimal valorTotalACobrar = BigDecimal.ZERO;

			BigDecimal parte1 = valorTotalACobrar.add(valorTotalAgua);
			BigDecimal parte2 = parte1.add(valorTotalEsgoto);
			valorTotalACobrar = parte2.add(valorTotalDebitos);
			Collection colecaoCreditosARealizarUpdate = new ArrayList();
			Set colecaoCreditosRealizado = new HashSet();

			// Cria o map para armazenar os créditos realizados junto com os créditos ralizados por
			// categoria
			Map<CreditoRealizado, Collection> mapCreditoRealizado = null;

			/*
			 * Caso a coleção de creditos a realizar não esteja vazia [SB0005] - Gerar Creditos
			 * Realizados
			 */
			if(colecaoCreditosARealizar != null && !colecaoCreditosARealizar.isEmpty()){

				mapCreditoRealizado = new HashMap();

				// Cria o iterator para os créditos a realizar do imóvel
				Iterator iteratorColecaoCreditosARealizar = colecaoCreditosARealizar.iterator();

				CreditoARealizar creditoARealizar = null;

				/*
				 * Para cada crédito a realizar selecionado e até que o valor total a cobrar seja
				 * igual a zero.
				 */

				// Laço para gerar todos os creditos realizados
				while(iteratorColecaoCreditosARealizar.hasNext()){

					// Recupera o crédito a realizar
					creditoARealizar = (CreditoARealizar) iteratorColecaoCreditosARealizar.next();

					BigDecimal valorCorrespondenteParcelaMes = new BigDecimal("0.00");

					BigDecimal valorCredito = new BigDecimal("0.00");

					/*
					 * Caso o nº de prestações realizadas seja menor que o nº de prestação dos
					 * créditos calcula o valor correspondente da parcela do
					 * mês.
					 */
					if(creditoARealizar.getNumeroPrestacaoRealizada().intValue() < creditoARealizar.getNumeroPrestacaoCredito().intValue()){

						/*
						 * Valor correspondente da parcela do mês = valor do crédito / nº de
						 * pestações do crédito.
						 */
						valorCorrespondenteParcelaMes = creditoARealizar.getValorCredito().divide(
										new BigDecimal(creditoARealizar.getNumeroPrestacaoCredito()), 2, BigDecimal.ROUND_HALF_UP);

						/*
						 * Caso seja a última pretação o valor do crédito correspondente a parcela
						 * do mês = valor do crédito correspondente a parcela
						 * do mês + valor do crédito - (valor do crédito correspondente a parcela do
						 * mês * o nº de prestações do crédito)
						 */
						if(creditoARealizar.getNumeroPrestacaoRealizada().intValue() == (creditoARealizar.getNumeroPrestacaoCredito()
										.intValue() - 1)){

							/*
							 * PARTE 01 valor do crédito correspondente a parcela do mês * o nº de
							 * prestações do crédito
							 */
							BigDecimal valorMesVezesPrestacaoCredito = valorCorrespondenteParcelaMes.multiply(
											new BigDecimal(creditoARealizar.getNumeroPrestacaoCredito())).setScale(2);

							/*
							 * PARTE 02 valor do crédito correspondente a parcela do mês + valor do
							 * crédito
							 */
							BigDecimal parte11 = valorCorrespondenteParcelaMes.add(creditoARealizar.getValorCredito());

							// valor do crédito correspondente a parcela do mês = PARTE 02 - PARTE
							// 01
							BigDecimal parte22 = parte11.subtract(valorMesVezesPrestacaoCredito);

							valorCorrespondenteParcelaMes = parte22;
						}

						// Atualiza o nº de prestações realizadas
						creditoARealizar.setNumeroPrestacaoRealizada(new Short(
										(creditoARealizar.getNumeroPrestacaoRealizada().intValue() + 1) + ""));
					}

					// Valor de credito
					valorCredito = valorCorrespondenteParcelaMes.add(creditoARealizar.getValorResidualMesAnterior());

					/*
					 * Caso o tipo de crédito (CRTI_CDCONSTANTE = "CREDTAC") corresponda ao crédito
					 * gerado pelo termo de ajuste de conduta de realinhamento de tarifas (CREDTAC)
					 * e o Valor total a cobrar menos valor do crédito seja menor que o valor da
					 * tarifa mínima da ligação
					 */
					if(creditoARealizar.getCreditoTipo().getId().equals(CreditoTipo.CREDTAC)
									&& (valorTotalACobrar.subtract(valorCredito)).compareTo(valorTarifaMinimaLigacao) == -1){

						// Atribuir 0 (zero) ao Valor do crédito
						valorCredito = BigDecimal.ZERO;
					}

					// Retira o valor de credito do valor total a cobrar
					valorTotalACobrar = valorTotalACobrar.subtract(valorCredito);

					/*
					 * Caso o valor total a cobrar seja menor que zero o valor residual do mês
					 * anterior vai ser igual a valor total a cobrar vezes
					 * -1(menos um) e o valor do crédito vai ser igual ao valor do crédito menos
					 * valor residual do mês anterior.
					 * Valor Total A Cobrar = 0.00
					 * Caso contrário o valor residual do mês anterior vai ser iguala zero.
					 */
					if(valorTotalACobrar.compareTo(new BigDecimal("0.00")) == -1){
						creditoARealizar.setValorResidualMesAnterior(valorTotalACobrar.multiply(new BigDecimal("-1")));
						valorCredito = valorCredito.subtract(creditoARealizar.getValorResidualMesAnterior());
						valorTotalACobrar = new BigDecimal("0.00");

					}else{
						creditoARealizar.setValorResidualMesAnterior(new BigDecimal("0.00"));
					}

					// Acumula o valor do crédito
					valorTotalCreditos = valorTotalCreditos.add(valorCredito);

					// Se não for um comando de simulação de faturamento
					if(faturamentoSimulacaoComando == null){

						// Cria o crédito realizado
						CreditoRealizado creditoRealizado = new CreditoRealizado();
						creditoRealizado.setCreditoTipo(creditoARealizar.getCreditoTipo());
						creditoRealizado.setDataHoraCreditoRealizado(new Date());
						creditoRealizado.setLancamentoItemContabil(creditoARealizar.getLancamentoItemContabil());
						creditoRealizado.setLocalidade(creditoARealizar.getLocalidade());
						creditoRealizado.setQuadra(creditoARealizar.getQuadra());
						creditoRealizado.setCodigoSetorComercial(creditoARealizar.getCodigoSetorComercial());
						creditoRealizado.setNumeroQuadra(creditoARealizar.getNumeroQuadra());
						creditoRealizado.setNumeroLote(creditoARealizar.getNumeroLote());
						creditoRealizado.setNumeroSubLote(creditoARealizar.getNumeroSubLote());
						creditoRealizado.setAnoMesReferenciaCredito(creditoARealizar.getAnoMesReferenciaCredito());
						creditoRealizado.setAnoMesCobrancaCredito(creditoARealizar.getAnoMesCobrancaCredito());
						creditoRealizado.setValorCredito(valorCredito);
						creditoRealizado.setCreditoOrigem(creditoARealizar.getCreditoOrigem());
						creditoRealizado.setNumeroPrestacao(creditoARealizar.getNumeroPrestacaoCredito());
						creditoRealizado.setParcelamento(creditoARealizar.getParcelamento());

						/*
						 * Alterado por Raphael Rossiter em 12/12/2007 - Analista: Aryed Lins OBJ:
						 * Gerar a quantidade de prestações do
						 * creditoRealizado sincronizadas com a quantidade de prestações do
						 * creditoARealizar
						 */

						creditoRealizado.setNumeroPrestacaoCredito(creditoARealizar.getNumeroPrestacaoRealizada());

						// Adiciona o crédito realizado na sessão
						colecaoCreditosRealizado.add(creditoRealizado);

						// Pesquisa os créditos a realizar categoria
						Collection colecaoCreditoARealizarCategoria = this.obterCreditoRealizarCategoria(creditoARealizar.getId());

						Iterator colecaoCreditoARealizarCategoriaIterator = colecaoCreditoARealizarCategoria.iterator();

						// Crédito a realizar categoria
						CreditoARealizarCategoria creditoARealizarCategoria = null;

						Collection colecaoCategoriasObterValor = new ArrayList();

						// Laço para recuperar as categorias do crédito a realizar
						while(colecaoCreditoARealizarCategoriaIterator.hasNext()){
							creditoARealizarCategoria = (CreditoARealizarCategoria) colecaoCreditoARealizarCategoriaIterator.next();
							Categoria categoria = new Categoria();
							categoria.setId(creditoARealizarCategoria.getCategoria().getId());
							categoria.setQuantidadeEconomiasCategoria(creditoARealizarCategoria.getQuantidadeEconomia());
							colecaoCategoriasObterValor.add(categoria);
						}

						// Obter os valores das categorias por categoria do credito a realizar
						// categoria
						Collection colecaoCategoriasCalculadasValor = getControladorImovel().obterValorPorCategoria(
										colecaoCategoriasObterValor, valorCredito);

						Iterator colecaoCategoriasCalculadasValorIterator = colecaoCategoriasCalculadasValor.iterator();
						Iterator colecaoCategoriasObterValorIterator = colecaoCategoriasObterValor.iterator();

						// Cria os créditos a realizar por categoria
						CreditoRealizadoCategoria creditoRealizadoCategoria = null;
						Collection colecaoCreditosRealizadoCategoria = new ArrayList();

						while(colecaoCategoriasCalculadasValorIterator.hasNext() && colecaoCategoriasObterValorIterator.hasNext()){
							// Obtém o valor por categoria
							BigDecimal valorPorCategoria = (BigDecimal) colecaoCategoriasCalculadasValorIterator.next();

							// Obtém a categoria
							Categoria categoria = (Categoria) colecaoCategoriasObterValorIterator.next();

							// Cria o crédito a ralizar por categoria
							creditoRealizadoCategoria = new CreditoRealizadoCategoria();
							CreditoRealizadoCategoriaPK creditoRealizadoCategoriaPk = new CreditoRealizadoCategoriaPK();
							creditoRealizadoCategoriaPk.setCategoria(categoria);
							creditoRealizadoCategoriaPk.setCreditoRealizado(creditoRealizado);
							creditoRealizadoCategoria.setComp_id(creditoRealizadoCategoriaPk);
							creditoRealizadoCategoria.setValorCategoria(valorPorCategoria);
							creditoRealizadoCategoria.setCreditoRealizado(creditoRealizado);
							creditoRealizadoCategoria.setCategoria(categoria);
							creditoRealizadoCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria());
							colecaoCreditosRealizadoCategoria.add(creditoRealizadoCategoria);

							/*
							 * REGISTRAR LANCAMENTO CONTABIL
							 * ------------------------------------------------------------------
							 */
							CreditoARealizarCategoria creditoARealizarCategoriaRegLancConta = new CreditoARealizarCategoria();
							creditoARealizarCategoriaRegLancConta.setValorCategoria(valorPorCategoria);
							creditoARealizarCategoriaRegLancConta.setCategoria(categoria);

							creditoARealizarCategoriaRegLancConta.setCreditoARealizar(creditoARealizar);

							if(creditoARealizar.getNumeroPrestacaoCredito() - creditoARealizar.getNumeroPrestacaoRealizada() > 12){
								getControladorContabil().registrarLancamentoContabil(creditoARealizarCategoriaRegLancConta,
												OperacaoContabil.TRANSFERENCIA_CREDITO_LONGO_PARA_CURTO_PRAZO);
							}
							/*
							 * ------------------------------------------------------------------
							 */

						}

						if(colecaoCategoriasCalculadasValor != null){
							colecaoCategoriasCalculadasValor.clear();
							colecaoCategoriasCalculadasValor = null;

						}

						// Armazena o credito realizado junto com os créditos realizados por
						// categoria
						mapCreditoRealizado.put(creditoRealizado, colecaoCreditosRealizadoCategoria);

						/*
						 * Caso o tipo de crédito (CRTI_CDCONSTANTE = "CREDTAC") corresponda ao
						 * crédito gerado pelo termo de ajuste de conduta de realinhamento de
						 * tarifas (CREDTAC), atualiza o log de processamento na tabela
						 * AJUSTE_TARIFA para o imóvel e crédito a realizar
						 */
						if(creditoARealizar.getCreditoTipo().getId().equals(CreditoTipo.CREDTAC)){

							FiltroAjusteTarifa filtroAjusteTarifa = new FiltroAjusteTarifa();
							filtroAjusteTarifa.adicionarParametro(new ParametroSimples(FiltroAjusteTarifa.IMOVEL_ID, imovel.getId()));
							filtroAjusteTarifa.adicionarParametro(new ParametroSimples(FiltroAjusteTarifa.CREDITO_A_REALIZAR_ID,
											creditoARealizar.getId()));
							filtroAjusteTarifa.setCampoOrderByDesc(FiltroAjusteTarifa.DATA_CALCULO);

							Collection<AjusteTarifa> colecaoAjusteTarifa = getControladorUtil().pesquisar(filtroAjusteTarifa,
											AjusteTarifa.class.getName());

							AjusteTarifa ajusteTarifa = (AjusteTarifa) Util.retonarObjetoDeColecao(colecaoAjusteTarifa);

							if(ajusteTarifa != null){

								StringBuilder builderLog = new StringBuilder();

								if(ajusteTarifa.getDescricaoLog() != null){

									builderLog.append(ajusteTarifa.getDescricaoLog());
								}

								builderLog.append(System.getProperty("line.separator"));
								builderLog.append("******************************************************************************************************************");
								builderLog.append(System.getProperty("line.separator"));
								builderLog.append("Parcela CREDTAC (");
								builderLog.append(creditoRealizado.getNumeroPrestacao().toString() + "/"
												+ creditoRealizado.getNumeroPrestacaoCredito().toString() + ") incorporada na fatura Ref.");
								builderLog.append(Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesFaturamento));
								builderLog.append(" no valor de R$ " + Util.formatarMoedaReal(creditoRealizado.getValorCredito(), 2));
								builderLog.append(" em " + Util.formatarDataComHoraSemSegundos(new Date()));

								ajusteTarifa.setDescricaoLog(builderLog.toString());

								getControladorUtil().atualizar(ajusteTarifa);
							}
						}

					// Adiciona o crédito a realizar para ser atualizado
					colecaoCreditosARealizarUpdate.add(creditoARealizar);
					}

				}// fim laço de credito a realizar

			}// fim do creditos a realizar

			retorno[0] = valorTotalCreditos;
			retorno[1] = colecaoCreditosARealizarUpdate;
			retorno[2] = mapCreditoRealizado;
			retorno[3] = colecaoCreditosRealizado;

		}catch(ControladorException e){

			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * [SB0006] - Gerar Dados da Conta
	 * 
	 * @author Yara Souza
	 * @data 20/08/2011
	 * @param imovel
	 * @param anoMesReferencia
	 * @param gerarAtividadeGrupoFaturamento
	 * @param antecipado
	 * @param faturamentoAtivCronRota
	 * @param sistemaParametro
	 * @param valorTotalAgua
	 * @param valorTotalEsgoto
	 * @param valorTotalDebitos
	 * @param valorTotalCreditos
	 * @param percentualEsgoto
	 * @param consumoTarifa
	 * @param colecaoCategorias
	 * @return
	 */
	private Conta gerarDadosConta(Imovel imovel, Integer anoMesReferencia, boolean ehFaturamentoConvencional, boolean antecipado,
					FaturamentoAtivCronRota faturamentoAtivCronRota, SistemaParametro sistemaParametro, BigDecimal valorTotalAgua,
					BigDecimal valorTotalEsgoto, BigDecimal valorTotalDebitos, BigDecimal valorTotalCreditos, BigDecimal percentualEsgoto,
					ConsumoTarifa consumoTarifa, Collection colecaoCategorias) throws ControladorException{

		Conta conta = null;

		Integer consumoAgua = null;
		Integer consumoEsgoto = null;
		ConsumoHistorico consumoHistoricoAgua = null;
		ConsumoHistorico consumoHistoricoEsgoto = null;

		// Cria o tipo de ligação para água.
		LigacaoTipo ligacaoTipoAgua = new LigacaoTipo();
		ligacaoTipoAgua.setId(LigacaoTipo.LIGACAO_AGUA);

		// Cria o tipo de ligação para esgoto.
		LigacaoTipo ligacaoTipoEsgoto = new LigacaoTipo();
		ligacaoTipoEsgoto.setId(LigacaoTipo.LIGACAO_ESGOTO);

		// -------------------------------------------------------
		// Inseri a conta geral
		ContaGeral contaGeral = new ContaGeral();
		contaGeral.setIndicadorHistorico(ConstantesSistema.NAO);
		contaGeral.setUltimaAlteracao(new Date());
		Integer idContaGeral = (Integer) getControladorUtil().inserir(contaGeral);

		contaGeral.setId(idContaGeral);

		// Insere a conta
		conta = new Conta();
		conta.setImovel(imovel);
		conta.setReferencia(anoMesReferencia);
		conta.setLigacaoAguaSituacao(imovel.getLigacaoAguaSituacao());
		conta.setLigacaoEsgotoSituacao(imovel.getLigacaoEsgotoSituacao());
		conta.setMotivoNaoEntregaDocumento(null);
		conta.setLocalidade(imovel.getLocalidade());
		conta.setQuadraConta(imovel.getQuadra());
		conta.setSubLote(imovel.getSubLote());
		conta.setLote(imovel.getLote());
		conta.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
		conta.setQuadra(imovel.getQuadra().getNumeroQuadra());
		conta.setRota(imovel.getRota());
		// Removido "DigitoVerificador" para o cliente ADA - Analista
		// Responsável: Luciene Bezerra - Saulo Lima 09/09/2008
		// conta.setDigitoVerificadorConta(new
		// Short(String.valueOf(Util.calculoRepresentacaoNumericaCodigoBarrasModulo10(anoMesReferencia))));
		conta.setIndicadorCobrancaMulta(Short.valueOf("2"));

		/*
		 * Caso seja faturamento antecipado, a data de vencimento da conta será o último dia
		 * útil do ano e mês de referência. Caso contrário
		 * [SB0007] - Determinar Vencimento da Conta.
		 */
		if(antecipado){
			int ano = Integer.parseInt(anoMesReferencia.toString().substring(0, 4));
			int mes = Integer.parseInt(anoMesReferencia.toString().substring(4, 6));
			Calendar calendar = new GregorianCalendar();
			calendar.set(Calendar.MONTH, mes - 1);
			calendar.set(Calendar.YEAR, ano);

			Collection colecaoNacionalFeriado = getControladorUtil().pesquisarFeriadosNacionais();

			Collection colecaoDatasFeriados = new ArrayList();
			Iterator iter = colecaoNacionalFeriado.iterator();
			while(iter.hasNext()){
				NacionalFeriado nacionalFeriado = (NacionalFeriado) iter.next();
				colecaoDatasFeriados.add(nacionalFeriado.getData());
			}

			calendar.set(Calendar.DAY_OF_MONTH, Util.obterUltimoDiaUtilMes(mes, ano, colecaoDatasFeriados));
			conta.setDataVencimentoConta(calendar.getTime());
		}else{
			// [SB0007] - Determinar Vencimento da Conta.
			conta.setDataVencimentoConta(this.determinarVencimentoConta(imovel, faturamentoAtivCronRota, sistemaParametro));
		}

		// data vencimento original
		conta.setDataVencimentoOriginal(conta.getDataVencimentoConta());

		conta.setIndicadorAlteracaoVencimento(Short.parseShort("2"));

		Calendar calendarDataVencimentoConta = new GregorianCalendar();
		calendarDataVencimentoConta.setTime(conta.getDataVencimentoConta());

		// data de validade da conta
		Calendar calendarDataValidadeConta = new GregorianCalendar();
		calendarDataValidadeConta.set(Calendar.MONTH, calendarDataVencimentoConta.get(Calendar.MONTH));
		calendarDataValidadeConta.set(Calendar.YEAR, calendarDataVencimentoConta.get(Calendar.YEAR));

		// aumentando o numero de meses validade conta
		calendarDataValidadeConta.add(Calendar.MONTH, sistemaParametro.getNumeroMesesValidadeConta());

		// seta o dia como o ultimo dia do mes
		calendarDataValidadeConta.set(Calendar.DAY_OF_MONTH, calendarDataValidadeConta.getActualMaximum(Calendar.DAY_OF_MONTH));

		conta.setDataValidadeConta(calendarDataValidadeConta.getTime());
		conta.setReferenciaContabil(anoMesReferencia);
		conta.setValorAgua(valorTotalAgua);
		conta.setValorEsgoto(valorTotalEsgoto);
		conta.setValorCreditos(valorTotalCreditos);
		conta.setDebitos(valorTotalDebitos);
		if(percentualEsgoto != null){
			conta.setPercentualEsgoto(percentualEsgoto);
		}else{
			conta.setPercentualEsgoto(BigDecimal.ZERO);
		}

		conta.setContaMotivoCancelamento(null);
		conta.setContaMotivoRetificacao(null);
		conta.setContaMotivoInclusao(null);
		conta.setFuncionarioEntrega(null);

		conta.setFaturamentoTipo(imovel.getFaturamentoTipo());

		conta.setRegistroAtendimento(null);
		conta.setImovelPerfil(imovel.getImovelPerfil());
		conta.setIndicadorDebitoConta(imovel.getIndicadorDebitoConta());

		conta.setUltimaAlteracao(new Date());

		conta.setContaGeral(contaGeral);
		conta.setId(contaGeral.getId());

		// -----------------------------------------------
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();

		// Se a atividade é faturar grupo de faturamento
		if(ehFaturamentoConvencional){

			debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
			conta.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

			// Pesquisa o histórico de consumo de água

			consumoHistoricoAgua = this.getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipoAgua,
							anoMesReferencia.intValue());

			// Verifica se existe consumo histórico de água
			if(consumoHistoricoAgua != null){

				// seta o rateio de agua
				if(consumoHistoricoAgua.getConsumoRateio() != null){
					conta.setConsumoRateioAgua(consumoHistoricoAgua.getConsumoRateio());
				}else{
					conta.setConsumoRateioAgua(null);
				}

				// seta o consumo de agua
				if(consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null){

					if(ConstantesSistema.SIM.toString().equals(ParametroFaturamento.P_UTILIZAR_CONSUMO_FATURADO_NA_CONTA.executar())){
						// Seta o consumo faturado mês
						consumoAgua = consumoHistoricoAgua.getNumeroConsumoFaturadoMes();
					}else{
						MedicaoHistorico medicaoHistoricoAgua = this.getControladorMicromedicao().pesquisarMedicaoHistoricoTipoAgua(
										imovel.getId(), anoMesReferencia);

						if(medicaoHistoricoAgua != null && medicaoHistoricoAgua.getNumeroConsumoMes() != null){
							// Seta o consumo medido
							consumoAgua = medicaoHistoricoAgua.getNumeroConsumoMes();
						}else{
							consumoAgua = 0;
						}
					}

					conta.setConsumoAgua(consumoAgua);
				}else{
					conta.setConsumoAgua(0);
				}

				if(consumoHistoricoAgua.getConsumoMinimoCreditado() != null){
					conta.setCreditoConsumo(consumoHistoricoAgua.getConsumoMinimoCreditado());
				}else{
					conta.setCreditoConsumo(null);
				}
				conta.setDataRevisao(null);
				conta.setContaMotivoRevisao(null);

			}else{
				conta.setConsumoRateioAgua(Integer.valueOf("0"));
				conta.setConsumoAgua(Integer.valueOf("0"));
			}

			consumoHistoricoEsgoto = this.getControladorMicromedicao().obterConsumoHistoricoMedicaoIndividualizada(imovel,
							ligacaoTipoEsgoto, anoMesReferencia.intValue());

			// Verifica se existe consumo histórico de esgoto
			if(consumoHistoricoEsgoto != null){

				// seta o consumo rateio de esgoto
				if(consumoHistoricoEsgoto.getConsumoRateio() != null){
					conta.setConsumoRateioEsgoto(consumoHistoricoEsgoto.getConsumoRateio());
				}else{
					conta.setConsumoRateioEsgoto(null);
				}

				// seta consumo esgoto
				if(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null){

					if(ConstantesSistema.SIM.toString().equals(ParametroFaturamento.P_UTILIZAR_CONSUMO_FATURADO_NA_CONTA.executar())){
						// Seta o consumo faturado mês de esgoto
						consumoEsgoto = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
					}else{
						MedicaoHistorico medicaoHistoricoPoco = this.getControladorMicromedicao().pesquisarMedicaoHistoricoTipoPoco(
										imovel.getId(), anoMesReferencia);

						// Seta o consumo medido
						if(medicaoHistoricoPoco != null && medicaoHistoricoPoco.getNumeroConsumoMes() != null){
							consumoEsgoto = medicaoHistoricoPoco.getNumeroConsumoMes();
						}else{
							consumoEsgoto = 0;
						}
					}

					conta.setConsumoEsgoto(consumoEsgoto);
				}else{
					conta.setConsumoEsgoto(0);
				}

			}else{
				conta.setConsumoRateioEsgoto(Integer.valueOf("0"));
				conta.setConsumoEsgoto(Integer.valueOf("0"));
			}

			// [UC0351]-Gerar Impostos Deduzidos da Conta
			GerarImpostosDeduzidosContaHelper gerarImpostosDeduzidosContaHelper = null;

			gerarImpostosDeduzidosContaHelper = this.gerarImpostosDeduzidosConta(imovel.getId(), anoMesReferencia, valorTotalAgua,
							valorTotalEsgoto, valorTotalDebitos, valorTotalCreditos);

			if(gerarImpostosDeduzidosContaHelper.getValorTotalImposto() != null){
				conta.setValorImposto(gerarImpostosDeduzidosContaHelper.getValorTotalImposto());
			}else{
				conta.setValorImposto(new BigDecimal("0.00"));
			}
			conta.setDataInclusao(new Date());
			conta.setDataEmissao(new Date());

			conta.setConsumoTarifa(consumoTarifa);

		}else{

			// .....................................
			// Faturamento Imediato
			// .....................................

			debitoCreditoSituacao.setId(DebitoCreditoSituacao.PRE_FATURADA);
			conta.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);

			// Caso exista contrato de demanda de consumo vigente para o imóvel e tarifa de consumo
			// não esteja vazia
			// atribuir CSTF_ID da tabela CONTRATO_DEMANDA_CONSUMO
			ContratoDemandaConsumo contratoDemandaConsumo = this.pesquisarContratoDemandaConsumoVigenteComTarifa(imovel.getId(),
							sistemaParametro.getAnoMesFaturamento());

			if(contratoDemandaConsumo != null){

				conta.setConsumoTarifa(contratoDemandaConsumo.getConsumoTarifa());

			}else if(imovel.getConsumoTarifa() != null){

				if(imovel.getConsumoTarifaTemporaria() != null
								&& imovel.getDataValidadeTarifaTemporaria() != null
								&& (Util.compararData(imovel.getDataValidadeTarifaTemporaria(), new Date()) > 0 || Util.compararData(
												imovel.getDataValidadeTarifaTemporaria(), new Date()) == 0)){
					conta.setConsumoTarifa(imovel.getConsumoTarifaTemporaria());
				}else{
					conta.setConsumoTarifa(imovel.getConsumoTarifa());
				}
			}

		}

		return conta;

	}

	public ContratoDemandaConsumo pesquisarContratoDemandaConsumoVigenteComTarifa(Integer idImovel, Integer anoMesFaturamento)
					throws ControladorException{

		ContratoDemandaConsumo retorno = null;

		FiltroContratoDemandaConsumo filtroContratoDemandaConsumo = new FiltroContratoDemandaConsumo();
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.IMOVEL_ID, idImovel));
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.INDICADORENCERRAMENTO,
						ConstantesSistema.NAO));
		filtroContratoDemandaConsumo.adicionarParametro(new MenorQue(FiltroContratoDemandaConsumo.ANOMESFATURAMENTOINICIO,
						anoMesFaturamento));
		filtroContratoDemandaConsumo.adicionarParametro(new MaiorQue(FiltroContratoDemandaConsumo.ANOMESFATURAMENTOFIM, anoMesFaturamento));
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroNaoNulo(FiltroContratoDemandaConsumo.CONSUMO_TARIFA));

		try{
			Collection<ContratoDemandaConsumo> colContratoDemandaConsumo = repositorioUtil.pesquisar(filtroContratoDemandaConsumo,
							ContratoDemandaConsumo.class.getName());

			if(colContratoDemandaConsumo != null && !colContratoDemandaConsumo.isEmpty()){

				retorno = (ContratoDemandaConsumo) Util.retonarObjetoDeColecao(colContratoDemandaConsumo);
			}
		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}
	
	public ContratoDemandaConsumo pesquisarContratoDemandaConsumoVigenteComConsumoFixo(Integer idImovel, Integer anoMesFaturamento)
					throws ControladorException{

		ContratoDemandaConsumo retorno = null;

		FiltroContratoDemandaConsumo filtroContratoDemandaConsumo = new FiltroContratoDemandaConsumo();
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.IMOVEL_ID, idImovel));
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.INDICADORENCERRAMENTO,
						ConstantesSistema.NAO));
		filtroContratoDemandaConsumo.adicionarParametro(new MenorQue(FiltroContratoDemandaConsumo.ANOMESFATURAMENTOINICIO,
						anoMesFaturamento));
		filtroContratoDemandaConsumo.adicionarParametro(new MaiorQue(FiltroContratoDemandaConsumo.ANOMESFATURAMENTOFIM, anoMesFaturamento));
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroNaoNulo(FiltroContratoDemandaConsumo.NN_CONSUMO_FIXO));

		try{
			Collection<ContratoDemandaConsumo> colContratoDemandaConsumo = repositorioUtil.pesquisar(filtroContratoDemandaConsumo,
							ContratoDemandaConsumo.class.getName());

			if(colContratoDemandaConsumo != null && !colContratoDemandaConsumo.isEmpty()){

				retorno = (ContratoDemandaConsumo) Util.retonarObjetoDeColecao(colContratoDemandaConsumo);
			}
		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Yara Souza
	 * @data 20/08/2011
	 * @param imovel
	 * @param conta
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @param faturamentoAtivCronRota
	 * @return
	 * @throws ControladorException
	 */
	public ContaImpressao gerarDadosContaImpressao(Imovel imovel, Conta conta, Integer anoMesFaturamento,
					FaturamentoGrupo faturamentoGrupo, Rota rota) throws ControladorException{

		ContaImpressao contaImpressao = new ContaImpressao();

		try{
			contaImpressao.setContaGeral(conta.getContaGeral());
			contaImpressao.setId(conta.getContaGeral().getId());
			contaImpressao.setReferenciaConta(anoMesFaturamento);
			contaImpressao.setFaturamentoGrupo(faturamentoGrupo);

			contaImpressao.setIndicadorFichaCompensacao(ConstantesSistema.NAO);
			contaImpressao.setUltimaAlteracao(new Date());

			Cliente clienteResponsavel = getControladorImovel().pesquisarClienteResponsavelImovel(imovel.getId());

			// grava o cliente responsavel
			Integer idClienteResponsavel = null;
			if(clienteResponsavel != null){
				
				
				String pConsideraResponsavelApenasClienteTipoEspecial = null;

				try{

					pConsideraResponsavelApenasClienteTipoEspecial = (String) ParametroFaturamento.P_CONSIDERA_RESPONSAVEL_APENAS_CLIENTE_ESPECIAL
									.executar();
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null,
									"P_CONSIDERA_RESPONSAVEL_APENAS_CLIENTE_ESPECIAL");
				}

				String pIdClienteTipoEspecialLegado = null;

				try{

					pIdClienteTipoEspecialLegado = (String) ParametroFaturamento.P_ID_CLIENTE_TIPO_ESPECIAL_LEGADO.executar();
				}catch(ControladorException e){

					throw new ControladorException("atencao.sistemaparametro_inexistente", null, "P_ID_CLIENTE_TIPO_ESPECIAL_LEGADO");
				}

				if(pConsideraResponsavelApenasClienteTipoEspecial.equals(ConstantesSistema.NAO.toString())
								|| (pConsideraResponsavelApenasClienteTipoEspecial.equals(ConstantesSistema.SIM.toString())
												&& clienteResponsavel.getClienteTipoEspecial() != null && clienteResponsavel
												.getClienteTipoEspecial().getId().equals(Util.obterInteger(pIdClienteTipoEspecialLegado)))){
					
					contaImpressao.setClienteResponsavel(clienteResponsavel);
					idClienteResponsavel = clienteResponsavel.getId();
				}
			}

			contaImpressao.setContaTipo(this.obterContaTipoParaContaImpressao(conta, idClienteResponsavel, imovel));

			Integer idEmpresaContaImpressao = repositorioMicromedicao.obterIdEmpresaPorRota(rota);

			if(idEmpresaContaImpressao != null){
				Empresa empresaContaImpressao = new Empresa();
				empresaContaImpressao.setId(idEmpresaContaImpressao);
				contaImpressao.setEmpresa(empresaContaImpressao);
			}

			// alterado por Vivianne Sousa data:02/12/2007
			// analista responsavel: Adriano
			contaImpressao.setValorConta(conta.getValorTotalContaBigDecimal());

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return contaImpressao;

	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Yara Souza
	 * @data 20/08/2011
	 * @param colecaoCategorias
	 * @param valorTotalDebitos
	 * @param valorTotalCreditos
	 * @param colecaoCalcularValoresAguaEsgotoHelper
	 * @param colecaoResumoFaturamento
	 * @param faturamentoAtivCronRota
	 * @param imovel
	 * @param gerarAtividadeGrupoFaturamento
	 * @param anoMesReferencia
	 */
	public void gerarResumoSimulacaoFaturamento(Collection colecaoCategorias, BigDecimal valorTotalDebitos, BigDecimal valorTotalCreditos,
					Collection colecaoCalcularValoresAguaEsgotoHelper, Collection colecaoResumoFaturamento,
					FaturamentoAtivCronRota faturamentoAtivCronRota, Imovel imovel, Integer anoMesReferencia,
					FaturamentoSimulacaoComando faturamentoSimulacaoComando, FaturamentoGrupo faturamentoGrupo){

		if((colecaoCategorias != null && !colecaoCategorias.isEmpty())
						&& (colecaoCalcularValoresAguaEsgotoHelper != null && !colecaoCalcularValoresAguaEsgotoHelper.isEmpty())){

			/*
			 * Colocado por Raphael Rossiter em 26/03/2007 OBJ: Gerar o resumo da simulação do
			 * faturamento com os valores por categoria e não com
			 * o valor total
			 */

			// Coleção com os valores por Categoria (DÉBITOS)
			Collection colecaoValoresDebitosCategorias = getControladorImovel()
							.obterValorPorCategoria(colecaoCategorias, valorTotalDebitos);

			// Coleção com os valores por Categoria (CRÉDITOS)
			Collection colecaoValoresCreditosCategorias = getControladorImovel().obterValorPorCategoria(colecaoCategorias,
							valorTotalCreditos);

			// Coleção de categorias
			Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();

			// colecao com os valores para ser usados em conta categoria
			Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper.iterator();

			// Coleção com os valores por Categoria (DÉBITOS)
			Iterator iteratorColecaoValoresDebitosCategorias = colecaoValoresDebitosCategorias.iterator();

			// Coleção com os valores por Categoria (CRÉDITOS)
			Iterator iteratorColecaoValoresCreditosCategorias = colecaoValoresCreditosCategorias.iterator();

			Categoria categoria = null;
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = null;
			BigDecimal valorTotalDebitoCategoria = null;
			BigDecimal valorTotalCreditoCategoria = null;

			boolean primeiraCategoria = true;
			while(iteratorColecaoCategorias.hasNext() && iteratorColecaoCalcularValoresAguaEsgotoHelper.hasNext()
							&& iteratorColecaoValoresDebitosCategorias.hasNext() && iteratorColecaoValoresCreditosCategorias.hasNext()){

				categoria = (Categoria) iteratorColecaoCategorias.next();

				calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper.next();

				valorTotalDebitoCategoria = (BigDecimal) iteratorColecaoValoresDebitosCategorias.next();

				valorTotalCreditoCategoria = (BigDecimal) iteratorColecaoValoresCreditosCategorias.next();

				// [SB0009] - Gerar Resumo da Simulação do Faturamento

				this.adicionarColecaoResumoFaturamentoSimulacao(colecaoResumoFaturamento, categoria, Subcategoria.SUBCATEGORIA_ZERO,
								calcularValoresAguaEsgotoHelper, imovel, valorTotalDebitoCategoria, valorTotalCreditoCategoria,
								faturamentoAtivCronRota, anoMesReferencia, primeiraCategoria, faturamentoSimulacaoComando, faturamentoGrupo);

				primeiraCategoria = false;
			}
		}else if(colecaoCategorias != null && !colecaoCategorias.isEmpty()){

			/*
			 * Colocado por Raphael Rossiter em 26/03/2007 OBJ: Gerar o resumo da simulação do
			 * faturamento com os valores por categoria e não com
			 * o valor total
			 */

			// Coleção com os valores por Categoria (DÉBITOS)
			Collection colecaoValoresDebitosCategorias = getControladorImovel()
							.obterValorPorCategoria(colecaoCategorias, valorTotalDebitos);

			// Coleção com os valores por Categoria (CRÉDITOS)
			Collection colecaoValoresCreditosCategorias = getControladorImovel().obterValorPorCategoria(colecaoCategorias,
							valorTotalCreditos);

			// Coleção de categorias
			Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();

			// Coleção com os valores por Categoria (DÉBITOS)
			Iterator iteratorColecaoValoresDebitosCategorias = colecaoValoresDebitosCategorias.iterator();

			// Coleção com os valores por Categoria (CRÉDITOS)
			Iterator iteratorColecaoValoresCreditosCategorias = colecaoValoresCreditosCategorias.iterator();

			Categoria categoria = null;
			BigDecimal valorTotalDebitoCategoria = null;
			BigDecimal valorTotalCreditoCategoria = null;

			boolean primeiraCategoria = true;
			while(iteratorColecaoCategorias.hasNext() && iteratorColecaoValoresDebitosCategorias.hasNext()
							&& iteratorColecaoValoresCreditosCategorias.hasNext()){

				categoria = (Categoria) iteratorColecaoCategorias.next();

				valorTotalDebitoCategoria = (BigDecimal) iteratorColecaoValoresDebitosCategorias.next();

				valorTotalCreditoCategoria = (BigDecimal) iteratorColecaoValoresCreditosCategorias.next();

				// [SB0009] - Gerar Resumo da Simulação do Faturamento
				this.adicionarColecaoResumoFaturamentoSimulacao(colecaoResumoFaturamento, categoria, Subcategoria.SUBCATEGORIA_ZERO, null,
								imovel, valorTotalDebitoCategoria, valorTotalCreditoCategoria, faturamentoAtivCronRota, anoMesReferencia,
								primeiraCategoria, faturamentoSimulacaoComando, faturamentoGrupo);

				primeiraCategoria = false;
			}

		}

	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Yara Souza
	 * @data 20/08/2011
	 * @param colecaoCategorias
	 * @param colecaoCalcularValoresAguaEsgotoHelper
	 * @param conta
	 * @return
	 * @throws ControladorException 
	 */
	public Object[] gerarDadosContaCategoriaEContaCategoriaConsumoFaixa(Collection colecaoCategorias,
					Collection colecaoCalcularValoresAguaEsgotoHelper, Conta conta) throws ControladorException{

		Object[] retorno = new Object[2];
		Collection colecaoContaCategoria = null;
		ContaCategoria contaCategoria = null;
		ContaCategoriaPK contaCategoriaPK = null;
		Categoria categoria = null;

		// incluir as faixas de consumo por categoria em
		ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = null;
		Collection colecaoContaCategoriaConsumoFaixa = null;

		if((colecaoCategorias != null && !colecaoCategorias.isEmpty())
						&& (colecaoCalcularValoresAguaEsgotoHelper != null && !colecaoCalcularValoresAguaEsgotoHelper.isEmpty())){

			colecaoContaCategoria = new ArrayList();
			colecaoContaCategoriaConsumoFaixa = new ArrayList();
			CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = null;

			// colecao de categorias
			Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();

			// colecao com os valores para ser usados em conta categoria
			Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelper.iterator();

			while(iteratorColecaoCategorias.hasNext() && iteratorColecaoCalcularValoresAguaEsgotoHelper.hasNext()){
				categoria = (Categoria) iteratorColecaoCategorias.next();
				calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper.next();

				contaCategoria = new ContaCategoria();
				contaCategoriaPK = new ContaCategoriaPK();
				contaCategoriaPK.setConta(conta);
				contaCategoriaPK.setCategoria(categoria);
				contaCategoriaPK.setSubcategoria(this.getControladorImovel()
								.obterPrincipalSubcategoria(categoria.getId(), conta.getImovel().getId()).getComp_id().getSubcategoria());

				contaCategoria.setComp_id(contaCategoriaPK);
				contaCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria().shortValue());
				contaCategoria.setValorAgua(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria());
				contaCategoria.setConsumoAgua(calcularValoresAguaEsgotoHelper.getConsumoFaturadoAguaCategoria());
				contaCategoria.setValorEsgoto(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria());
				contaCategoria.setConsumoEsgoto(calcularValoresAguaEsgotoHelper.getConsumoFaturadoEsgotoCategoria());
				contaCategoria.setValorTarifaMinimaAgua(calcularValoresAguaEsgotoHelper.getValorTarifaMinimaAguaCategoria());
				contaCategoria.setConsumoMinimoAgua(calcularValoresAguaEsgotoHelper.getConsumoMinimoAguaCategoria());
				contaCategoria.setValorTarifaMinimaEsgoto(calcularValoresAguaEsgotoHelper.getValorTarifaMinimaEsgotoCategoria());
				contaCategoria.setConsumoMinimoEsgoto(calcularValoresAguaEsgotoHelper.getConsumoMinimoEsgotoCategoria());
				contaCategoria.setUltimaAlteracao(new Date());

				colecaoContaCategoria.add(contaCategoria);

				Collection colecaoFaixaTarifaConsumo = calcularValoresAguaEsgotoHelper.getFaixaTarifaConsumo();

				if(colecaoFaixaTarifaConsumo != null && !colecaoFaixaTarifaConsumo.isEmpty()){
					Iterator iteratorColecaoFaixaTarifaConsumo = colecaoFaixaTarifaConsumo.iterator();

					CalcularValoresAguaEsgotoFaixaHelper calcularValoresAguaEsgotoFaixaHelper = null;

					while(iteratorColecaoFaixaTarifaConsumo.hasNext()){
						calcularValoresAguaEsgotoFaixaHelper = (CalcularValoresAguaEsgotoFaixaHelper) iteratorColecaoFaixaTarifaConsumo
										.next();

						// conta categoria consumo faixa
						contaCategoriaConsumoFaixa = new ContaCategoriaConsumoFaixa();
						contaCategoriaConsumoFaixa.setContaCategoria(contaCategoria);
						contaCategoriaConsumoFaixa.setValorAgua(calcularValoresAguaEsgotoFaixaHelper.getValorFaturadoAguaFaixa());
						contaCategoriaConsumoFaixa.setConsumoAgua(calcularValoresAguaEsgotoFaixaHelper.getConsumoFaturadoAguaFaixa());
						contaCategoriaConsumoFaixa.setValorEsgoto(calcularValoresAguaEsgotoFaixaHelper.getValorFaturadoEsgotoFaixa());
						contaCategoriaConsumoFaixa.setConsumoEsgoto(calcularValoresAguaEsgotoFaixaHelper.getConsumoFaturadoEsgotoFaixa());
						contaCategoriaConsumoFaixa.setConsumoFaixaInicio(calcularValoresAguaEsgotoFaixaHelper
										.getLimiteInicialConsumoFaixa());
						contaCategoriaConsumoFaixa.setConsumoFaixaFim(calcularValoresAguaEsgotoFaixaHelper.getLimiteFinalConsumoFaixa());
						contaCategoriaConsumoFaixa.setValorTarifaFaixa(calcularValoresAguaEsgotoFaixaHelper.getValorTarifaFaixa());
						contaCategoriaConsumoFaixa.setUltimaAlteracao(new Date());

						colecaoContaCategoriaConsumoFaixa.add(contaCategoriaConsumoFaixa);

					}
				}

			}
		}else if(colecaoCategorias != null && !colecaoCategorias.isEmpty()){

			colecaoContaCategoria = new ArrayList();
			colecaoContaCategoriaConsumoFaixa = new ArrayList();

			Iterator iteratorColecaoCategorias = colecaoCategorias.iterator();

			while(iteratorColecaoCategorias.hasNext()){
				categoria = (Categoria) iteratorColecaoCategorias.next();

				// conta categoria
				contaCategoria = new ContaCategoria();
				contaCategoriaPK = new ContaCategoriaPK();
				contaCategoriaPK.setConta(conta);
				contaCategoriaPK.setCategoria(categoria);
				contaCategoriaPK.setSubcategoria(this.getControladorImovel()
								.obterPrincipalSubcategoria(categoria.getId(), conta.getImovel().getId()).getComp_id().getSubcategoria());
				contaCategoria.setComp_id(contaCategoriaPK);
				contaCategoria.setQuantidadeEconomia(categoria.getQuantidadeEconomiasCategoria().shortValue());
				contaCategoria.setValorAgua(new BigDecimal("0.00"));
				contaCategoria.setConsumoAgua(Integer.valueOf("0"));
				contaCategoria.setValorEsgoto(new BigDecimal("0.00"));
				contaCategoria.setConsumoEsgoto(Integer.valueOf("0"));
				contaCategoria.setValorTarifaMinimaAgua(new BigDecimal("0.0000"));
				contaCategoria.setConsumoMinimoAgua(Integer.valueOf("0"));
				contaCategoria.setValorTarifaMinimaEsgoto(new BigDecimal("0.0000"));
				contaCategoria.setConsumoMinimoEsgoto(Integer.valueOf("0"));
				contaCategoria.setUltimaAlteracao(new Date());

				colecaoContaCategoria.add(contaCategoria);
			}
		}

		retorno[0] = colecaoContaCategoria;
		retorno[1] = colecaoContaCategoriaConsumoFaixa;

		return retorno;

	}

	public void gerarResumoFaturamentoImediato(Collection collResumoHelper, Integer idGrupoFaturamento, Integer anoMesReferencia){

		try{

			// Parâmetros do relatório
			RelatorioResumoFaturamentoImediato relatorioResumoFaturamentoImediato = new RelatorioResumoFaturamentoImediato(
							Usuario.USUARIO_BATCH);

			relatorioResumoFaturamentoImediato.addParametro("collResumoHelper", collResumoHelper);
			relatorioResumoFaturamentoImediato.addParametro("idGrupoFaturamento", idGrupoFaturamento);
			relatorioResumoFaturamentoImediato.addParametro("referencia", anoMesReferencia);

			byte[] relatorioGerado = (byte[]) relatorioResumoFaturamentoImediato.executar();

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.GERAR_RESUMO_FATURAMENTO_IMEDIATO);

			String corpoMensagem = envioEmail.getCorpoMensagem();
			String emailRemetente = envioEmail.getEmailRemetente();
			String emailReceptor = envioEmail.getEmailReceptor();
			String tituloMensagem = "RESUMO FATURAMENTO IMEDIATO";

			File leitura = File.createTempFile("gcom", ".PDF");
			FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
			out.write(relatorioGerado);
			out.close();

			ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

			// leitura.delete();

		}catch(IOException e){
			try{
				throw new ControladorException("atencao.erro_permissao_gravacao_arquivo_email", e);
			}catch(ControladorException e1){
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}catch(ControladorException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(Exception e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Transfere para o histórico de contas
	 * 
	 * @author Pedro Alexandre
	 * @date 09/10/2006
	 * @author Yara Souza
	 * @date 01/06/2010
	 *       Correção para casos com mais de uma categoria
	 * @param contas
	 * @param anoMesFaturamentoSistemaParametro
	 * @throws ControladorException
	 */
	public void transferirContasParaHistorico(Collection<Conta> contas, int anoMesFaturamentoSistemaParametro) throws ControladorException{

		try{
			// System.out.println("Transferindo para histórico...");
			// cria um objeto de histórico da conta

			ContaHistorico contaHistoricoTemp = null;

			Collection colecaoContaHistoricoInserir = new ArrayList();
			Collection colecaoContaCategoriaHistoricoInserir = new ArrayList();
			Collection colecaoContaCategoriaConsumoFaixaHistoricoInserir = new ArrayList();
			Collection colecaoDebitoCobradoHistoricoInserir = new ArrayList();
			Collection colecaoDebitoCobradoCategoriaHistoricoInserir = new ArrayList();
			Collection colecaoCreditoRealizadoHistoricoInserir = new ArrayList();
			Collection colecaoCreditoRealizadoCategoriaHistoricoInserir = new ArrayList();
			Collection colecaoContaImpostosDeduzidosHistoricoInserir = new ArrayList();
			Collection colecaoClienteContaHistoricoInserir = new ArrayList();

			Collection colecaoContasRemover = new ArrayList();
			Collection colecaoContaCategoriaRemover = new ArrayList();
			Collection colecaoContaCategoriaConsumoFaixaRemover = new ArrayList();
			Collection colecaoDebitoCobradoRemover = new ArrayList();
			Collection colecaoDebitoCobradoCategoriaRemover = new ArrayList();
			Collection colecaoCreditoRealizadoRemover = new ArrayList();
			Collection colecaoCreditoRealizadoCategoriaRemover = new ArrayList();
			Collection colecaoContaImpostosDeduzidosRemover = new ArrayList();
			Collection colecaoClienteContaRemover = new ArrayList();

			Collection<Integer> colecaoContaGeralId = new ArrayList<Integer>();

			if(contas != null && !contas.isEmpty()){

				colecaoContasRemover.addAll(contas);
				int cont = 0;
				// laço para criar os históricos das contas canceladas
				for(Conta conta : contas){

					cont++;
					// System.out.println("################### GERANDO HISTORICO DAS CONTAS:" + cont
					// + "#########################"); // NOPMD by ebandeira on 06/04/09 15:33

					Integer idConta = conta.getId();
					colecaoContaGeralId.add(idConta);

					/* Apaga as referências da conta nos pagamentos para poder remover */
					this.repositorioFaturamento.apagarIdContaPagamentos(idConta);

					// seta a conta histórico com os dados da conta cancelada
					contaHistoricoTemp = new ContaHistorico();
					contaHistoricoTemp.setId(idConta);
					contaHistoricoTemp.setAnoMesReferenciaConta(conta.getReferencia());
					contaHistoricoTemp.setContaHistorico(new Date());
					contaHistoricoTemp.setImovel(conta.getImovel());
					contaHistoricoTemp.setLote(conta.getLote());
					contaHistoricoTemp.setSublote(conta.getSubLote());
					contaHistoricoTemp.setSetorComercial(conta.getCodigoSetorComercial());
					contaHistoricoTemp.setNumeroQuadra(conta.getQuadra());
					contaHistoricoTemp.setVerificadorConta(conta.getDigitoVerificadorConta());
					contaHistoricoTemp.setIndicadorCobrancaMulta(conta.getIndicadorCobrancaMulta());
					contaHistoricoTemp.setIndicadorAlteracaoVencimento(conta.getIndicadorAlteracaoVencimento());
					contaHistoricoTemp.setConsumoAgua(conta.getConsumoAgua());
					contaHistoricoTemp.setConsumoEsgoto(conta.getConsumoEsgoto());
					contaHistoricoTemp.setConsumoRateioAgua(conta.getConsumoRateioAgua());
					contaHistoricoTemp.setConsumoRateioEsgoto(conta.getConsumoRateioEsgoto());
					contaHistoricoTemp.setValorAgua(conta.getValorAgua());
					contaHistoricoTemp.setValorEsgoto(conta.getValorEsgoto());
					contaHistoricoTemp.setValorDebitos(conta.getDebitos());
					contaHistoricoTemp.setValorCreditos(conta.getValorCreditos());
					contaHistoricoTemp.setValorImposto(conta.getValorImposto());
					contaHistoricoTemp.setPercentualEsgoto(conta.getPercentualEsgoto());
					contaHistoricoTemp.setDataVencimentoConta(conta.getDataVencimentoConta());
					contaHistoricoTemp.setDataValidadeConta(conta.getDataValidadeConta());
					contaHistoricoTemp.setDataInclusao(conta.getDataInclusao());
					contaHistoricoTemp.setDataRevisao(conta.getDataRevisao());
					contaHistoricoTemp.setDataRetificacao(conta.getDataRetificacao());
					contaHistoricoTemp.setDataCancelamento(conta.getDataCancelamento());
					contaHistoricoTemp.setDataEmissao(conta.getDataEmissao());
					contaHistoricoTemp.setAnoMesReferenciaContabil(conta.getReferenciaContabil());
					contaHistoricoTemp.setAnoMesReferenciaBaixaContabil(conta.getReferenciaBaixaContabil());
					contaHistoricoTemp.setLigacaoEsgotoSituacao(conta.getLigacaoEsgotoSituacao());
					contaHistoricoTemp.setLigacaoAguaSituacao(conta.getLigacaoAguaSituacao());
					contaHistoricoTemp.setMotivoNaoEntregaDocumento(conta.getMotivoNaoEntregaDocumento());
					contaHistoricoTemp.setLocalidade(conta.getLocalidade());
					contaHistoricoTemp.setQuadra(conta.getQuadraConta());
					contaHistoricoTemp.setContaMotivoInclusao(conta.getContaMotivoInclusao());
					contaHistoricoTemp.setContaMotivoRevisao(conta.getContaMotivoRevisao());
					contaHistoricoTemp.setContaMotivoRetificacao(conta.getContaMotivoRetificacao());
					contaHistoricoTemp.setContaMotivoCancelamento(conta.getContaMotivoCancelamento());
					contaHistoricoTemp.setFaturamentoTipo(conta.getFaturamentoTipo());
					contaHistoricoTemp.setImovelPerfil(conta.getImovelPerfil());
					contaHistoricoTemp.setRegistroAtendimento(conta.getRegistroAtendimento());
					contaHistoricoTemp.setConsumoTarifa(conta.getConsumoTarifa());
					contaHistoricoTemp.setIndicadorDebitoConta(conta.getIndicadorDebitoConta());
					contaHistoricoTemp.setFuncionarioEntrega(conta.getFuncionarioEntrega());
					contaHistoricoTemp.setFuncionarioLeitura(conta.getFuncionarioLeitura());
					contaHistoricoTemp.setUltimaAlteracao(new Date());
					contaHistoricoTemp.setDebitoCreditoSituacaoAtual(conta.getDebitoCreditoSituacaoAtual());
					contaHistoricoTemp.setDebitoCreditoSituacaoAnterior(conta.getDebitoCreditoSituacaoAnterior());
					contaHistoricoTemp.setCreditoConsumo(conta.getCreditoConsumo());
					contaHistoricoTemp.setUsuario(conta.getUsuario());
					// contaHistoricoTemp.setOperacaoEfetuada(conta.getOperacaoEfetuada());
					// DebitoCreditoSituacao debitoCreditoSituacaoAnterior = new
					// DebitoCreditoSituacao();
					// debitoCreditoSituacaoAnterior.setId(DebitoCreditoSituacao.PARCELADA);
					// contaHistoricoTemp.setDebitoCreditoSituacaoAtual(debitoCreditoSituacaoAnterior);
					// contaHistoricoTemp.setDebitoCreditoSituacaoAnterior(conta.getDebitoCreditoSituacaoAtual());

					contaHistoricoTemp.setDocumentoTipo(conta.getDocumentoTipo());
					contaHistoricoTemp.setContaBancaria(conta.getContaBancaria());
					contaHistoricoTemp.setDataVencimentoOriginal(conta.getDataVencimentoOriginal());
					contaHistoricoTemp.setParcelamento(conta.getParcelamento());
					contaHistoricoTemp.setRota(conta.getRota());
					contaHistoricoTemp.setIndicadorPDD(conta.getIndicadorPDD());
					contaHistoricoTemp.setIndicadorCobrancaAdministrativa(conta.getIndicadorCobrancaAdministrativa());
					contaHistoricoTemp.setIndicadorRemuneraCobrancaAdministrativa(conta.getIndicadorRemuneraCobrancaAdministrativa());
					contaHistoricoTemp.setIndicadorDividaAtiva(conta.getIndicadorDividaAtiva());
					contaHistoricoTemp.setDataDividaAtiva(conta.getDataDividaAtiva());
					contaHistoricoTemp.setIndicadorExecucaoFiscal(conta.getIndicadorExecucaoFiscal());
					contaHistoricoTemp.setDataExecucaoFiscal(conta.getDataExecucaoFiscal());
					contaHistoricoTemp.setNumeroProcessoAdministrativoExecucaoFiscal(conta.getNumeroProcessoAdministrativoExecucaoFiscal());

					colecaoContaHistoricoInserir.add(contaHistoricoTemp);

					// ************CONTA CATEGORIA
					// ***********************************
					Collection<ContaCategoria> colecaoContaCategoria = repositorioFaturamento.pesquisarContaCategoria(idConta);

					ContaCategoriaHistorico contaCategoriaHistoricoTemp = null;

					if(colecaoContaCategoria != null && !colecaoContaCategoria.isEmpty()){

						colecaoContaCategoriaRemover.addAll(colecaoContaCategoria);

						for(ContaCategoria contaContaCategoria : colecaoContaCategoria){
							contaCategoriaHistoricoTemp = new ContaCategoriaHistorico();
							contaCategoriaHistoricoTemp.setComp_id(new ContaCategoriaHistoricoPK(contaHistoricoTemp, contaContaCategoria
											.getComp_id().getCategoria()));
							contaCategoriaHistoricoTemp.getComp_id().setSubcategoria(contaContaCategoria.getComp_id().getSubcategoria());
							contaCategoriaHistoricoTemp.setConsumoAgua(contaContaCategoria.getConsumoAgua());
							contaCategoriaHistoricoTemp.setConsumoEsgoto(contaContaCategoria.getConsumoEsgoto());
							contaCategoriaHistoricoTemp.setConsumoMinimoAgua(contaContaCategoria.getConsumoMinimoAgua());
							contaCategoriaHistoricoTemp.setConsumoMinimoEsgoto(contaContaCategoria.getConsumoMinimoEsgoto());
							contaCategoriaHistoricoTemp.setQuantidadeEconomia(contaContaCategoria.getQuantidadeEconomia());
							contaCategoriaHistoricoTemp.setUltimaAlteracao(new Date());
							contaCategoriaHistoricoTemp.setValorAgua(contaContaCategoria.getValorAgua());
							contaCategoriaHistoricoTemp.setValorEsgoto(contaContaCategoria.getValorEsgoto());
							contaCategoriaHistoricoTemp.setValorTarifaMinimaAgua(contaContaCategoria.getValorTarifaMinimaAgua());
							contaCategoriaHistoricoTemp.setValorTarifaMinimaEsgoto(contaContaCategoria.getValorTarifaMinimaEsgoto());
							contaCategoriaHistoricoTemp.setContaCategoriaConsumoFaixasHistorico(contaContaCategoria
											.getContaCategoriaConsumoFaixas());

							colecaoContaCategoriaHistoricoInserir.add(contaCategoriaHistoricoTemp);

							// Alterado por Yara Souza em 01/06/2010 : Correção para casos de mais
							// de 1 categoria.
							// ************************CONTA CATEGORIA CONSUMO FAIXA
							// HISTORICO*************************************
							Collection<ContaCategoriaConsumoFaixa> colecaoContaCategoriaConsumoFaixa = this.repositorioFaturamento
											.pesquisarContaCategoriaConsumoFaixa(idConta, contaContaCategoria.getComp_id().getCategoria()
															.getId());

							ContaCategoriaConsumoFaixaHistorico contaCategoriaConsumoFaixaHistoricoTemp = null;

							if(colecaoContaCategoriaConsumoFaixa != null && !colecaoContaCategoriaConsumoFaixa.isEmpty()){

								colecaoContaCategoriaConsumoFaixaRemover.addAll(colecaoContaCategoriaConsumoFaixa);

								for(ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa : colecaoContaCategoriaConsumoFaixa){
									contaCategoriaConsumoFaixaHistoricoTemp = new ContaCategoriaConsumoFaixaHistorico();
									contaCategoriaConsumoFaixaHistoricoTemp.setId(contaCategoriaConsumoFaixa.getId());
									contaCategoriaConsumoFaixaHistoricoTemp.setConsumoAgua(contaCategoriaConsumoFaixa.getConsumoAgua());
									contaCategoriaConsumoFaixaHistoricoTemp.setConsumoEsgoto(contaCategoriaConsumoFaixa.getConsumoEsgoto());
									contaCategoriaConsumoFaixaHistoricoTemp.setConsumoFaixaFim(contaCategoriaConsumoFaixa
													.getConsumoFaixaFim());
									contaCategoriaConsumoFaixaHistoricoTemp.setConsumoFaixaInicio(contaCategoriaConsumoFaixa
													.getConsumoFaixaInicio());
									contaCategoriaConsumoFaixaHistoricoTemp.setContaCategoriaHistorico(contaCategoriaHistoricoTemp);
									contaCategoriaConsumoFaixaHistoricoTemp.setUltimaAlteracao(new Date());
									contaCategoriaConsumoFaixaHistoricoTemp.setValorAgua(contaCategoriaConsumoFaixa.getValorAgua());
									contaCategoriaConsumoFaixaHistoricoTemp.setValorEsgoto(contaCategoriaConsumoFaixa.getValorEsgoto());
									contaCategoriaConsumoFaixaHistoricoTemp.setCategoria(contaCategoriaConsumoFaixaHistoricoTemp
													.getCategoria());
									contaCategoriaConsumoFaixaHistoricoTemp.setSubcategoria(contaCategoriaConsumoFaixaHistoricoTemp
													.getSubcategoria());
									contaCategoriaConsumoFaixaHistoricoTemp.setValorTarifaFaixa(contaCategoriaConsumoFaixa
													.getValorTarifaFaixa());

									colecaoContaCategoriaConsumoFaixaHistoricoInserir.add(contaCategoriaConsumoFaixaHistoricoTemp);
								}
							}
							// ************************FIM CONTA CATEGORIA CONSUMO FAIXA
							// HISTORICO*********************************

						}
					}

					// pesquisa os débitos cobrados para a conta atual
					Collection<DebitoCobrado> debitosCobrados;

					// debitosCobrados =
					// repositorioFaturamento.pesquisarDebitosCobradosCanceladosPorMesAnoReferenciaContabil(anoMesFaturamentoSistemaParametro,
					// idConta);
					debitosCobrados = repositorioFaturamento.pesquisarDebitosCobrados(idConta);

					// cria o objeto débito cobrado histórico
					DebitoCobradoHistorico debitoCobradoHistoricoTemp = null;

					if(debitosCobrados != null && !debitosCobrados.isEmpty()){

						colecaoDebitoCobradoRemover.addAll(debitosCobrados);

						// laço para criar o histórico dos débitos cobrados da
						// conta
						for(DebitoCobrado debitoCobrado : debitosCobrados){
							// seta os dados do débito cobrado histórico
							debitoCobradoHistoricoTemp = new DebitoCobradoHistorico();
							debitoCobradoHistoricoTemp.setId(debitoCobrado.getId());
							debitoCobradoHistoricoTemp.setDebitoCobrado(debitoCobrado.getDebitoCobrado());
							/*
							 * debitoCobradoHistoricoTemp
							 * .setDebitoCobradoHistorico(new Date());
							 */
							debitoCobradoHistoricoTemp.setCodigoSetorComercial(debitoCobrado.getCodigoSetorComercial());
							debitoCobradoHistoricoTemp.setNumeroQuadra(debitoCobrado.getNumeroQuadra());
							debitoCobradoHistoricoTemp.setNumeroLote(debitoCobrado.getNumeroLote());
							debitoCobradoHistoricoTemp.setNumeroSubLote(debitoCobrado.getNumeroSubLote());
							debitoCobradoHistoricoTemp.setAnoMesReferenciaDebito(debitoCobrado.getAnoMesReferenciaDebito());
							debitoCobradoHistoricoTemp.setAnoMesCobrancaDebito(debitoCobrado.getAnoMesCobrancaDebito());
							debitoCobradoHistoricoTemp.setValorPrestacao(debitoCobrado.getValorPrestacao());
							debitoCobradoHistoricoTemp.setNumeroPrestacao(debitoCobrado.getNumeroPrestacao());
							debitoCobradoHistoricoTemp.setNumeroPrestacaoDebito(debitoCobrado.getNumeroPrestacaoDebito());
							debitoCobradoHistoricoTemp.setUltimaAlteracao(new Date());
							debitoCobradoHistoricoTemp.setFinanciamentoTipo(debitoCobrado.getFinanciamentoTipo());
							debitoCobradoHistoricoTemp.setQuadra(debitoCobrado.getQuadra());
							debitoCobradoHistoricoTemp.setLocalidade(debitoCobrado.getLocalidade());
							debitoCobradoHistoricoTemp.setContaHistorico(contaHistoricoTemp);
							debitoCobradoHistoricoTemp.setDebitoTipo(debitoCobrado.getDebitoTipo());
							debitoCobradoHistoricoTemp.setLancamentoItemContabil(debitoCobrado.getLancamentoItemContabil());
							debitoCobradoHistoricoTemp.setParcelamentoGrupo(debitoCobrado.getParcelamentoGrupo());
							debitoCobradoHistoricoTemp.setParcelamento(debitoCobrado.getParcelamento());
							debitoCobradoHistoricoTemp.setIndicadorRemuneraCobrancaAdministrativa(debitoCobrado
											.getIndicadorRemuneraCobrancaAdministrativa());
							debitoCobradoHistoricoTemp.setNumeroProcessoAdministrativoExecucaoFiscal(debitoCobrado
											.getNumeroProcessoAdministrativoExecucaoFiscal());

							colecaoDebitoCobradoHistoricoInserir.add(debitoCobradoHistoricoTemp);

							Collection<DebitoCobradoCategoria> colecaoDebitoCobradoCategoria = this.repositorioFaturamento
											.pesquisarDebitoCobradoCategoria(debitoCobrado.getId());

							if(colecaoDebitoCobradoCategoria != null && !colecaoDebitoCobradoCategoria.isEmpty()){

								colecaoDebitoCobradoCategoriaRemover.addAll(colecaoDebitoCobradoCategoria);

								for(DebitoCobradoCategoria debitoCobradoCategoria : colecaoDebitoCobradoCategoria){
									DebitoCobradoCategoriaHistorico debitoCobradoCategoriaHistorico = new DebitoCobradoCategoriaHistorico();
									debitoCobradoCategoriaHistorico.setComp_id(new DebitoCobradoCategoriaHistoricoPK(
													debitoCobradoHistoricoTemp, debitoCobradoCategoria.getCategoria()));
									debitoCobradoCategoriaHistorico.setCategoria(debitoCobradoCategoria.getCategoria());
									debitoCobradoCategoriaHistorico.setDebitoCobradoHistorico(debitoCobradoHistoricoTemp);
									debitoCobradoCategoriaHistorico.setQuantidadeEconomia(debitoCobradoCategoria.getQuantidadeEconomia());
									debitoCobradoCategoriaHistorico.setUltimaAlteracao(new Date());
									debitoCobradoCategoriaHistorico.setValorCategoria(debitoCobradoCategoria.getValorCategoria());
									colecaoDebitoCobradoCategoriaHistoricoInserir.add(debitoCobradoCategoriaHistorico);
								}
							}
						}
					}
					// pesquisa os créditos realizados da conta cancelada
					Collection<CreditoRealizado> creditosRealizados = repositorioFaturamento.pesquisarCreditosRealizados(idConta);

					// cria o crédito realizados histórico
					CreditoRealizadoHistorico creditoRealizadoHistoricoTemp = null;

					if(creditosRealizados != null && !creditosRealizados.isEmpty()){

						colecaoCreditoRealizadoRemover.addAll(creditosRealizados);

						// laço para inserir todos os históricos dos créditos
						// realizados
						for(CreditoRealizado creditoRealizado : creditosRealizados){
							// cria o histórico do crédito realizado da conta
							// cancelada
							creditoRealizadoHistoricoTemp = new CreditoRealizadoHistorico();
							creditoRealizadoHistoricoTemp.setId(creditoRealizado.getId());
							creditoRealizadoHistoricoTemp.setDataHoraCreditoRealizado(creditoRealizado.getDataHoraCreditoRealizado());
							/*
							 * creditoRealizadoHistoricoTemp
							 * .setGeracaoHistoricoCredito(new Date());
							 */
							creditoRealizadoHistoricoTemp.setCodigoSetorComercial(creditoRealizado.getCodigoSetorComercial());
							creditoRealizadoHistoricoTemp.setNumeroQuadra(creditoRealizado.getNumeroQuadra());
							creditoRealizadoHistoricoTemp.setNumeroLote(creditoRealizado.getNumeroLote());
							creditoRealizadoHistoricoTemp.setNumeroSubLote(creditoRealizado.getNumeroSubLote());
							creditoRealizadoHistoricoTemp.setAnoMesReferenciaCredito(creditoRealizado.getAnoMesReferenciaCredito());
							creditoRealizadoHistoricoTemp.setAnoMesCobrancaCredito(creditoRealizado.getAnoMesCobrancaCredito());
							creditoRealizadoHistoricoTemp.setValorCredito(creditoRealizado.getValorCredito());
							creditoRealizadoHistoricoTemp.setNumeroPrestacao(creditoRealizado.getNumeroPrestacao());
							creditoRealizadoHistoricoTemp.setNumeroPrestacaoCredito(creditoRealizado.getNumeroPrestacaoCredito());
							creditoRealizadoHistoricoTemp.setUltimaAlteracao(new Date());
							creditoRealizadoHistoricoTemp.setQuadra(creditoRealizado.getQuadra());
							creditoRealizadoHistoricoTemp.setLocalidade(creditoRealizado.getLocalidade());
							creditoRealizadoHistoricoTemp.setCreditoTipo(creditoRealizado.getCreditoTipo());
							creditoRealizadoHistoricoTemp.setContaHistorico(contaHistoricoTemp);
							creditoRealizadoHistoricoTemp.setLancamentoItemContabil(creditoRealizado.getLancamentoItemContabil());
							creditoRealizadoHistoricoTemp.setCreditoOrigem(creditoRealizado.getCreditoOrigem());
							creditoRealizadoHistoricoTemp.setParcelamento(creditoRealizado.getParcelamento());

							colecaoCreditoRealizadoHistoricoInserir.add(creditoRealizadoHistoricoTemp);

							Collection<CreditoRealizadoCategoria> colecaoCreditoRealizadoCategoria = this.repositorioFaturamento
											.pesquisarCreditoRealizadoCategoria(creditoRealizado.getId());

							if(colecaoCreditoRealizadoCategoria != null && !colecaoCreditoRealizadoCategoria.isEmpty()){

								colecaoCreditoRealizadoCategoriaRemover.addAll(colecaoCreditoRealizadoCategoria);

								for(CreditoRealizadoCategoria creditoRelizadoCategoria : colecaoCreditoRealizadoCategoria){
									CreditoRealizadoCategoriaHistorico creditoRealizadoCategoriaHistorico = new CreditoRealizadoCategoriaHistorico();
									creditoRealizadoCategoriaHistorico
													.setComp_id(new CreditoRealizadoCategoriaHistoricoPK(creditoRealizadoHistoricoTemp
																	.getId(), creditoRelizadoCategoria.getCategoria().getId()));
									creditoRealizadoCategoriaHistorico.setCategoria(creditoRelizadoCategoria.getCategoria());
									creditoRealizadoCategoriaHistorico.setCreditoRealizadoHistorico(creditoRealizadoHistoricoTemp);
									creditoRealizadoCategoriaHistorico.setQuantidadeEconomia(creditoRelizadoCategoria
													.getQuantidadeEconomia());
									creditoRealizadoCategoriaHistorico.setUltimaAlteracao(new Date());
									creditoRealizadoCategoriaHistorico.setValorCategoria(creditoRelizadoCategoria.getValorCategoria());
									colecaoCreditoRealizadoCategoriaHistoricoInserir.add(creditoRealizadoCategoriaHistorico);
								}
							}
						}
					}

					Collection<ContaImpostosDeduzidos> colecaoContaImpostosDeduzidos = this.repositorioFaturamento
									.pesquisarContaImpostosDeduzidos(idConta);

					ContaImpostosDeduzidosHistorico contaImpostosDeduzidosHistoricoTemp = null;

					if(colecaoContaImpostosDeduzidos != null && !colecaoContaImpostosDeduzidos.isEmpty()){

						colecaoContaImpostosDeduzidosRemover.addAll(colecaoContaImpostosDeduzidos);

						for(ContaImpostosDeduzidos contaImpostosDeduzidos : colecaoContaImpostosDeduzidos){
							contaImpostosDeduzidosHistoricoTemp = new ContaImpostosDeduzidosHistorico();
							contaImpostosDeduzidosHistoricoTemp.setId(contaImpostosDeduzidos.getId());
							contaImpostosDeduzidosHistoricoTemp.setContaHistorico(contaHistoricoTemp);
							contaImpostosDeduzidosHistoricoTemp.setImpostoTipo(contaImpostosDeduzidos.getImpostoTipo());
							contaImpostosDeduzidosHistoricoTemp.setPercentualAliquota(contaImpostosDeduzidos.getPercentualAliquota());
							contaImpostosDeduzidosHistoricoTemp.setUltimaAlteracao(new Date());
							contaImpostosDeduzidosHistoricoTemp.setValorImposto(contaImpostosDeduzidos.getValorImposto());
							contaImpostosDeduzidosHistoricoTemp.setValorBaseCalculo(contaImpostosDeduzidos.getValorBaseCalculo());

							colecaoContaImpostosDeduzidosHistoricoInserir.add(contaImpostosDeduzidosHistoricoTemp);
						}
					}
					// ************* FIM CONTA IMPOSTOS DEDUZIDOS
					// *****************************************************

					// ************ CLIENTE CONTA
					// ***********************************
					Collection<ClienteConta> colecaoClienteConta = repositorioFaturamento.pesquisarClienteConta(idConta);

					ClienteContaHistorico clienteContaHistoricoTemp = null;

					if(colecaoClienteConta != null && !colecaoClienteConta.isEmpty()){

						colecaoClienteContaRemover.addAll(colecaoClienteConta);

						for(ClienteConta clienteConta : colecaoClienteConta){
							clienteContaHistoricoTemp = new ClienteContaHistorico();
							clienteContaHistoricoTemp.setId(clienteConta.getId());
							clienteContaHistoricoTemp.setCliente(clienteConta.getCliente());
							clienteContaHistoricoTemp.setClienteRelacaoTipo(clienteConta.getClienteRelacaoTipo());
							clienteContaHistoricoTemp.setContaHistorico(contaHistoricoTemp);
							clienteContaHistoricoTemp.setIndicadorNomeConta(clienteConta.getIndicadorNomeConta());
							clienteContaHistoricoTemp.setUltimaAlteracao(new Date());

							colecaoClienteContaHistoricoInserir.add(clienteContaHistoricoTemp);
						}
					}

					// *********************FIM CLIENTE CONTA
					// ****************************

					ContaGeral contaGeral = conta.getContaGeral();
					// contaGeral.setIndicadorHistorico(1);

				}// fim conta
			}

			/*
			 * Remove as contas , débitos a cobrar e créditos a realizar que
			 * iram para o histórico e remove todos os objetos relacionados com
			 * eles.
			 */

			// System.out.println("################### REMOVENDO CONTAS  CATEGORIA CONSUMO FAIXA #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoContaCategoriaConsumoFaixaRemover);

			// System.out.println("################### REMOVENDO DEBITO COBRADO CATEGORIA #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoDebitoCobradoCategoriaRemover);

			// System.out.println("################### REMOVENDO DEBITO COBRADO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoDebitoCobradoRemover);

			// System.out.println("################### REMOVENDO CREDITO REALIZADO CATEGORIA #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoCreditoRealizadoCategoriaRemover);

			// System.out.println("################### REMOVENDO CREDITO REALIZADO #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoCreditoRealizadoRemover);

			// System.out.println("################### REMOVENDO CONTAS IMPOSTOS DEDUZIDOS #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoContaImpostosDeduzidosRemover);

			// System.out.println("################### REMOVENDO CONTAS CATEGORIA #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoContaCategoriaRemover);

			// System.out.println("################### REMOVENDO CLIENTE CONTA #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoClienteContaRemover);

			// System.out.println("################### REMOVENDO CONTAS #########################");
			getControladorBatch().removerColecaoObjetoParaBatch(colecaoContasRemover);

			/*
			 * Transfere para o histórico as contas, debitos a cobrar e créditos
			 * a realizar junto com os objetos a eles relacionados.
			 */
			// System.out.println("################### TRANSFERINDO CONTAS PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaHistoricoInserir);

			// System.out.println("################### TRANSFERINDO CONTAS CATEGORIA PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoriaHistoricoInserir);

			// System.out.println("################### TRANSFERINDO CLIENTE CONTA PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoClienteContaHistoricoInserir);

			// System.out.println("################### TRANSFERINDO CONTAS CATEGORIA CONSUMO FAIXA PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaCategoriaConsumoFaixaHistoricoInserir);

			// System.out.println("################### TRANSFERINDO DEBITO COBRADO PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoCobradoHistoricoInserir);

			// System.out.println("################### TRANSFERINDO DEBITO COBRADO CATEGORIA PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoCobradoCategoriaHistoricoInserir);

			// System.out.println("################### TRANSFERINDO CREDITO REALIZADO PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoRealizadoHistoricoInserir);

			// System.out.println("################### TRANSFERINDO CREDITO REALIZADO CATEGORIA PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoRealizadoCategoriaHistoricoInserir);

			// System.out.println("################### TRANSFERINDO CONTAS IMPOSTOS DEDUZIDOS PARA O HISTORICO #########################");
			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoContaImpostosDeduzidosHistoricoInserir);
			// fim item 6

			// OC1407024
			this.atualizarIndicadorContaNoHistorico(colecaoContaGeralId);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Transfere para o histórico os débitos a cobrar.
	 * 
	 * @author Vitor
	 * @date 12/08/2008
	 * @param debitosACobrar
	 * @throws ControladorException
	 */
	public void transferirDebitosACobrarParaHistorico(Collection<DebitoACobrar> debitosACobrar, Boolean registrarTransacao)
					throws ControladorException{

		try{

			Collection colecaoDebitoACobrarHistoricoInserir = new ArrayList();
			Collection colecaoDebitoACobrarCategoriaHistoricoInserir = new ArrayList();
			Collection colecaoClienteDebitoACobrarHistoricoInserir = new ArrayList();

			Collection colecaoDebitoACobrarRemover = new ArrayList<DebitoACobrar>();
			Collection colecaoDebitoACobrarCategoriaRemover = new ArrayList();
			Collection colecaoClienteDebitoACobrarRemover = new ArrayList();

			Collection colecaoDebitoACobrarGeralAtualizar = new ArrayList();

			// cria débito a cobrar histórico
			DebitoACobrarHistorico debitoACobrarHistoricoTemp = null;

			if(debitosACobrar != null && !debitosACobrar.isEmpty()){
				Integer idDebitoACobrar = null;

				DebitoACobrarGeral debitoACobrarGeral = null;
				int cont = 0;
				// laço para cria todo os históricos de débito a cobrar
				for(DebitoACobrar debitoACobrar : debitosACobrar){

					cont++;
					log.info("...################### TRANSFERINDO DEBITOS A COBRAR PARA HISTORICO :" + debitoACobrar.getImovel().getId()
									+ "#########################");
					log.info("...################### Id do débito a cobrar: " + debitoACobrar.getId());

					idDebitoACobrar = debitoACobrar.getId();

					debitoACobrarGeral = new DebitoACobrarGeral();
					debitoACobrarGeral.setId(idDebitoACobrar);
					debitoACobrarGeral.setIndicadorHistorico(ConstantesSistema.SIM);
					debitoACobrarGeral.setUltimaAlteracao(new Date());

					colecaoDebitoACobrarGeralAtualizar.add(debitoACobrarGeral);

					// seta os dados do histórico de débito a cobrar
					debitoACobrarHistoricoTemp = new DebitoACobrarHistorico();
					debitoACobrarHistoricoTemp.setId(idDebitoACobrar);
					debitoACobrarHistoricoTemp.setDebitoGeradoRealizar(debitoACobrar.getGeracaoDebito());
					debitoACobrarHistoricoTemp.setAnoMesReferenciaDebito(debitoACobrar.getAnoMesReferenciaDebito());
					debitoACobrarHistoricoTemp.setAnoMesCobrancaDebito(debitoACobrar.getAnoMesCobrancaDebito());
					debitoACobrarHistoricoTemp.setAnoMesReferenciaContabil(debitoACobrar.getAnoMesReferenciaContabil());
					debitoACobrarHistoricoTemp.setValorDebito(debitoACobrar.getValorDebito());
					debitoACobrarHistoricoTemp.setPrestacaoDebito(debitoACobrar.getNumeroPrestacaoDebito());
					debitoACobrarHistoricoTemp.setPrestacaoCobradas(debitoACobrar.getNumeroPrestacaoCobradas());
					debitoACobrarHistoricoTemp.setCodigoSetorComercial(debitoACobrar.getCodigoSetorComercial());
					debitoACobrarHistoricoTemp.setNumeroQuadra(debitoACobrar.getNumeroQuadra());
					debitoACobrarHistoricoTemp.setLote(debitoACobrar.getNumeroLote());
					debitoACobrarHistoricoTemp.setSublote(debitoACobrar.getNumeroSubLote());
					debitoACobrarHistoricoTemp.setUltimaAlteracao(new Date());
					debitoACobrarHistoricoTemp.setLancamentoItemContabil(debitoACobrar.getLancamentoItemContabil());
					debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAtual(debitoACobrar.getDebitoCreditoSituacaoAtual());
					debitoACobrarHistoricoTemp.setDebitoCreditoSituacaoAnterior(debitoACobrar.getDebitoCreditoSituacaoAnterior());
					debitoACobrarHistoricoTemp.setRegistroAtendimento(debitoACobrar.getRegistroAtendimento());
					debitoACobrarHistoricoTemp.setImovel(debitoACobrar.getImovel());
					debitoACobrarHistoricoTemp.setFinanciamentoTipo(debitoACobrar.getFinanciamentoTipo());
					debitoACobrarHistoricoTemp.setOrdemServico(debitoACobrar.getOrdemServico());
					debitoACobrarHistoricoTemp.setCobrancaForma(debitoACobrar.getCobrancaForma());
					debitoACobrarHistoricoTemp.setQuadra(debitoACobrar.getQuadra());
					debitoACobrarHistoricoTemp.setLocalidade(debitoACobrar.getLocalidade());
					debitoACobrarHistoricoTemp.setParcelamentoGrupo(debitoACobrar.getParcelamentoGrupo());
					debitoACobrarHistoricoTemp.setDocumentoTipo(debitoACobrar.getDocumentoTipo());
					debitoACobrarHistoricoTemp.setParcelamento(debitoACobrar.getParcelamento());
					debitoACobrarHistoricoTemp.setDebitoTipo(debitoACobrar.getDebitoTipo());
					debitoACobrarHistoricoTemp.setNumeroDiasSuspensao(debitoACobrar.getNumeroDiasSuspensao());
					debitoACobrarHistoricoTemp.setOcorrenciaInfracaoItem(debitoACobrar.getOcorrenciaInfracaoItem());
					debitoACobrarHistoricoTemp.setNumeroMesesEntreParcelas(debitoACobrar.getNumeroMesesEntreParcelas());
					debitoACobrarHistoricoTemp.setNumeroParcelasALancar(debitoACobrar.getNumeroParcelasALancar());
					debitoACobrarHistoricoTemp.setAnoMesReferenciaUltimaCobranca(debitoACobrar.getAnoMesReferenciaUltimaCobranca());
					debitoACobrarHistoricoTemp.setPercentualTaxaJurosFinanciamento(debitoACobrar.getPercentualTaxaJurosFinanciamento());
					debitoACobrarHistoricoTemp.setIndicadorRemuneraCobrancaAdministrativa(debitoACobrar
									.getIndicadorRemuneraCobrancaAdministrativa());
					debitoACobrarHistoricoTemp.setNumeroProcessoAdministrativoExecucaoFiscal(debitoACobrar
									.getNumeroProcessoAdministrativoExecucaoFiscal());

					colecaoDebitoACobrarHistoricoInserir.add(debitoACobrarHistoricoTemp);

					Collection<DebitoACobrarCategoria> colecaoDebitoACobrarCategoria = this.repositorioFaturamento
									.pesquisarDebitosACobrarCategoria(debitoACobrar);

					if(colecaoDebitoACobrarCategoria != null && !colecaoDebitoACobrarCategoria.isEmpty()){

						colecaoDebitoACobrarCategoriaRemover.addAll(colecaoDebitoACobrarCategoria);

						for(DebitoACobrarCategoria debitoACobrarCategoria : colecaoDebitoACobrarCategoria){

							DebitoACobrarCategoriaHistorico debitoACobrarCategoriaHistorico = new DebitoACobrarCategoriaHistorico();
							debitoACobrarCategoriaHistorico.setComp_id(new DebitoACobrarCategoriaHistoricoPK(debitoACobrarHistoricoTemp,
											debitoACobrarCategoria.getCategoria()));
							debitoACobrarCategoriaHistorico.setCategoria(debitoACobrarCategoria.getCategoria());
							debitoACobrarCategoriaHistorico.setDebitoACobrarHistorico(debitoACobrarHistoricoTemp);
							debitoACobrarCategoriaHistorico.setQuantidadeEconomia(debitoACobrarCategoria.getQuantidadeEconomia());
							debitoACobrarCategoriaHistorico.setUltimaAlteracao(new Date());
							debitoACobrarCategoriaHistorico.setValorCategoria(debitoACobrarCategoria.getValorCategoria());

							colecaoDebitoACobrarCategoriaHistoricoInserir.add(debitoACobrarCategoriaHistorico);
						}
					}

					Collection<ClienteDebitoACobrar> colecaoClienteDebitoACobrar = this.pesquisarClienteDebitoACobrar(debitoACobrar);

					if(colecaoClienteDebitoACobrar != null && !colecaoClienteDebitoACobrar.isEmpty()){

						colecaoClienteDebitoACobrarRemover.addAll(colecaoClienteDebitoACobrar);

						for(ClienteDebitoACobrar clienteDebitoACobrar : colecaoClienteDebitoACobrar){

							ClienteDebitoACobrarHistorico clienteDebitoACobrarHistorico = new ClienteDebitoACobrarHistorico();
							clienteDebitoACobrarHistorico.setId(clienteDebitoACobrar.getId());
							clienteDebitoACobrarHistorico.setDebitoACobrarHistorico(debitoACobrarHistoricoTemp);
							clienteDebitoACobrarHistorico.setCliente(clienteDebitoACobrar.getCliente());
							clienteDebitoACobrarHistorico.setClienteRelacaoTipo(clienteDebitoACobrar.getClienteRelacaoTipo());
							clienteDebitoACobrarHistorico.setUltimaAlteracao(new Date());

							colecaoClienteDebitoACobrarHistoricoInserir.add(clienteDebitoACobrarHistorico);
						}
					}



					colecaoDebitoACobrarRemover.add(debitoACobrar);

				}

				if(registrarTransacao != null && registrarTransacao){

					this.getControladorUtil().removerColecaoObjetos(colecaoClienteDebitoACobrarRemover);

					this.getControladorUtil().removerColecaoObjetos(colecaoDebitoACobrarRemover);
					this.getControladorUtil().atualizarColecaoObjetos(colecaoDebitoACobrarGeralAtualizar);

					this.getControladorUtil().inserirColecaoObjetos(colecaoDebitoACobrarHistoricoInserir);
					this.getControladorUtil().inserirColecaoObjetos(colecaoDebitoACobrarCategoriaHistoricoInserir);
					this.getControladorUtil().inserirColecaoObjetos(colecaoClienteDebitoACobrarHistoricoInserir);


				}else{

					this.getControladorUtil().removerColecaoObjetos(colecaoClienteDebitoACobrarRemover);

					this.getControladorBatch().removerColecaoObjetoParaBatch(colecaoDebitoACobrarCategoriaRemover);

					this.getControladorBatch().removerColecaoObjetoParaBatch(colecaoDebitoACobrarRemover);

					this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoACobrarHistoricoInserir);

					this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDebitoACobrarCategoriaHistoricoInserir);

					this.getControladorUtil().inserirColecaoObjetos(colecaoClienteDebitoACobrarHistoricoInserir);

					this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoDebitoACobrarGeralAtualizar);

				}

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Transfere para o histórico os créditos a realizar.
	 * 
	 * @author Vitor
	 * @date 13/08/2008
	 * @param creditosARealizar
	 * @throws ControladorException
	 */
	public void transferirCreditoARealizarParaHistorico(Collection<CreditoARealizar> creditosARealizar) throws ControladorException{

		try{

			Collection colecaoCreditoARealizarHistoricoInserir = new ArrayList();
			Collection colecaoCreditoARealizarCategoriaHistoricoInserir = new ArrayList();
			Collection colecaoClienteCreditoARealizarHistoricoInserir = new ArrayList();

			Collection colecaoCreditoARealizarRemover = new ArrayList();
			Collection colecaoCreditoARealizarCategoriaRemover = new ArrayList();
			Collection colecaoClienteCreditoARealizarRemover = new ArrayList();

			// cria o histórico de crédito a realizar
			CreditoARealizarHistorico creditoARealizarHistoricoTemp = null;

			if(creditosARealizar != null && !creditosARealizar.isEmpty()){

				colecaoCreditoARealizarRemover.addAll(creditosARealizar);

				int cont = 0;
				// laço para criar todos os históricos de créditos a realizar
				for(CreditoARealizar creditoARealizar : creditosARealizar){
					cont++;
					System.out.println("################### TRANSFERINDO CREDITOS A REALIZAR PARA HISTORICO :" + cont
									+ "#########################");

					// seta os dados do histórico de crédito a realizar
					creditoARealizarHistoricoTemp = new CreditoARealizarHistorico();
					creditoARealizarHistoricoTemp.setId(creditoARealizar.getId());
					creditoARealizarHistoricoTemp.setGeracaoCreditoARealizar(creditoARealizar.getGeracaoCredito());
					creditoARealizarHistoricoTemp.setAnoMesReferenciaCredito(creditoARealizar.getAnoMesReferenciaCredito());
					creditoARealizarHistoricoTemp.setAnoMesCobrancaCredito(creditoARealizar.getAnoMesCobrancaCredito());
					creditoARealizarHistoricoTemp.setValorResidualMesAnterior(creditoARealizar.getValorResidualMesAnterior());
					creditoARealizarHistoricoTemp.setValorCredito(creditoARealizar.getValorCredito());
					creditoARealizarHistoricoTemp.setPrestacaoCredito(creditoARealizar.getNumeroPrestacaoCredito());
					creditoARealizarHistoricoTemp.setPrestacaoRealizadas(creditoARealizar.getNumeroPrestacaoRealizada());
					creditoARealizarHistoricoTemp.setCodigoSetorComercial(creditoARealizar.getCodigoSetorComercial());
					creditoARealizarHistoricoTemp.setNumeroQuadra(creditoARealizar.getNumeroQuadra());
					creditoARealizarHistoricoTemp.setLote(creditoARealizar.getNumeroLote());
					creditoARealizarHistoricoTemp.setSubLote(creditoARealizar.getNumeroSubLote());
					creditoARealizarHistoricoTemp.setAnoMesReferenciaContabil(creditoARealizar.getAnoMesReferenciaContabil());
					creditoARealizarHistoricoTemp.setUltimaAlteracao(new Date());
					creditoARealizarHistoricoTemp.setLancamentoItemContabil(creditoARealizar.getLancamentoItemContabil());
					creditoARealizarHistoricoTemp.setDebitoCreditoSituacaoAtual(creditoARealizar.getDebitoCreditoSituacaoAtual());
					creditoARealizarHistoricoTemp.setDebitoCreditoSituacaoAnterior(creditoARealizar.getDebitoCreditoSituacaoAnterior());
					creditoARealizarHistoricoTemp.setRegistroAtendimento(creditoARealizar.getRegistroAtendimento());
					creditoARealizarHistoricoTemp.setImovel(creditoARealizar.getImovel());
					creditoARealizarHistoricoTemp.setOrdemServico(creditoARealizar.getOrdemServico());
					creditoARealizarHistoricoTemp.setQuadra(creditoARealizar.getQuadra());
					creditoARealizarHistoricoTemp.setLocalidade(creditoARealizar.getLocalidade());
					creditoARealizarHistoricoTemp.setCreditoTipo(creditoARealizar.getCreditoTipo());
					creditoARealizarHistoricoTemp.setCreditoOrigem(creditoARealizar.getCreditoOrigem());
					creditoARealizarHistoricoTemp.setParcelamento(creditoARealizar.getParcelamento());
					creditoARealizarHistoricoTemp.setDocumentoTipo(creditoARealizar.getDocumentoTipo());
					CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
					creditoARealizarGeral.setId(creditoARealizar.getId());
					creditoARealizarHistoricoTemp.setCreditoARealizarGeral(creditoARealizarGeral);
					creditoARealizarHistoricoTemp.setPagamentoHistorico(creditoARealizar.getPagamentoHistorico());

					colecaoCreditoARealizarHistoricoInserir.add(creditoARealizarHistoricoTemp);

					Collection<CreditoARealizarCategoria> colecaoCreditoARealizarCategoria = this.repositorioFaturamento
									.pesquisarCreditoARealizarCategoria(creditoARealizar);

					if(colecaoCreditoARealizarCategoria != null && !colecaoCreditoARealizarCategoria.isEmpty()){

						colecaoCreditoARealizarCategoriaRemover.addAll(colecaoCreditoARealizarCategoria);

						for(CreditoARealizarCategoria creditoARealizarCategoria : colecaoCreditoARealizarCategoria){

							CreditoARealizarCategoriaHistorico creditoARealizarCategoriaHistorico = new CreditoARealizarCategoriaHistorico();
							creditoARealizarCategoriaHistorico.setComp_id(new CreditoARealizarCategoriaHistoricoPK(
											creditoARealizarHistoricoTemp, creditoARealizarCategoria.getCategoria()));
							creditoARealizarCategoriaHistorico.setCategoria(creditoARealizarCategoria.getCategoria());
							creditoARealizarCategoriaHistorico.setCreditoARealizarHistorico(creditoARealizarHistoricoTemp);
							creditoARealizarCategoriaHistorico.setQuantidadeEconomia(creditoARealizarCategoria.getQuantidadeEconomia());
							creditoARealizarCategoriaHistorico.setUltimaAlteracao(new Date());
							creditoARealizarCategoriaHistorico.setValorCategoria(creditoARealizarCategoria.getValorCategoria());

							colecaoCreditoARealizarCategoriaHistoricoInserir.add(creditoARealizarCategoriaHistorico);
						}
					}

					Collection<ClienteCreditoARealizar> colecaoClienteCreditoARealizar = this.repositorioFaturamento
									.pesquisarClienteCreditoARealizar(creditoARealizar);

					if(colecaoClienteCreditoARealizar != null && !colecaoClienteCreditoARealizar.isEmpty()){

						colecaoClienteCreditoARealizarRemover.addAll(colecaoClienteCreditoARealizar);

						for(ClienteCreditoARealizar clienteCreditoARealizar : colecaoClienteCreditoARealizar){

							ClienteCreditoARealizarHistorico clienteCreditoARealizarHistorico = new ClienteCreditoARealizarHistorico();
							clienteCreditoARealizarHistorico.setId(clienteCreditoARealizar.getId());
							clienteCreditoARealizarHistorico.setCliente(clienteCreditoARealizar.getCliente());
							clienteCreditoARealizarHistorico.setCreditoARealizarHistorico(creditoARealizarHistoricoTemp);
							clienteCreditoARealizarHistorico.setClienteRelacaoTipo(clienteCreditoARealizar.getClienteRelacaoTipo());
							clienteCreditoARealizarHistorico.setUltimaAlteracao(new Date());

							colecaoClienteCreditoARealizarHistoricoInserir.add(clienteCreditoARealizarHistorico);
						}
					}

				}

				getControladorBatch().removerColecaoObjetoParaBatch(colecaoClienteCreditoARealizarRemover);
				getControladorBatch().removerColecaoObjetoParaBatch(colecaoCreditoARealizarCategoriaRemover);
				getControladorBatch().removerColecaoObjetoParaBatch(colecaoCreditoARealizarRemover);

				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoARealizarHistoricoInserir);
				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoARealizarCategoriaHistoricoInserir);
				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoClienteCreditoARealizarHistoricoInserir);
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0155] Encerrar Faturamento do Mês
	 * Transfere para o histórico os créditos a realizar.
	 * 
	 * @author Vitor Hora
	 * @date 13/08/2008
	 * @param creditosARealizar
	 * @throws ControladorException
	 */
	public void transferirCreditoARealizarHistoricoParaAtivo(Collection<CreditoARealizarHistorico> creditosARealizarHistorico)
					throws ControladorException{

		try{

			Collection colecaoCreditoARealizarInserir = new ArrayList();
			Collection colecaoCreditoARealizarCategoriaInserir = new ArrayList();

			Collection colecaoCreditoARealizarRemover = new ArrayList();
			Collection colecaoCreditoARealizarCategoriaHistoricoRemover = new ArrayList();

			// cria o histórico de crédito a realizar
			CreditoARealizar creditoARealizarTemp = null;

			if(creditosARealizarHistorico != null && !creditosARealizarHistorico.isEmpty()){

				int cont = 0;
				// laço para criar todos os históricos de créditos a realizar
				for(CreditoARealizarHistorico creditoARealizarHistorico : creditosARealizarHistorico){
					cont++;
					System.out.println("################### TRANSFERINDO CREDITOS A REALIZAR PARA ATIVO :" + cont
									+ "#########################");

					// seta os dados do histórico de crédito a realizar
					creditoARealizarTemp = new CreditoARealizar();
					creditoARealizarTemp.setId(creditoARealizarHistorico.getId());
					creditoARealizarTemp.setGeracaoCredito(creditoARealizarHistorico.getGeracaoCreditoARealizar());
					creditoARealizarTemp.setAnoMesReferenciaCredito(creditoARealizarHistorico.getAnoMesReferenciaCredito());
					creditoARealizarTemp.setAnoMesCobrancaCredito(creditoARealizarHistorico.getAnoMesCobrancaCredito());
					creditoARealizarTemp.setValorResidualMesAnterior(creditoARealizarHistorico.getValorResidualMesAnterior());
					creditoARealizarTemp.setValorCredito(creditoARealizarHistorico.getValorCredito());
					creditoARealizarTemp.setNumeroPrestacaoCredito(creditoARealizarHistorico.getPrestacaoCredito());
					creditoARealizarTemp.setNumeroPrestacaoRealizada(creditoARealizarHistorico.getPrestacaoRealizadas());
					creditoARealizarTemp.setCodigoSetorComercial(creditoARealizarHistorico.getCodigoSetorComercial());
					creditoARealizarTemp.setNumeroQuadra(creditoARealizarHistorico.getNumeroQuadra());
					creditoARealizarTemp.setNumeroLote(creditoARealizarHistorico.getLote());
					creditoARealizarTemp.setNumeroSubLote(creditoARealizarHistorico.getSubLote());
					creditoARealizarTemp.setAnoMesReferenciaContabil(creditoARealizarHistorico.getAnoMesReferenciaContabil());
					creditoARealizarTemp.setUltimaAlteracao(new Date());
					creditoARealizarTemp.setLancamentoItemContabil(creditoARealizarHistorico.getLancamentoItemContabil());
					creditoARealizarTemp.setDebitoCreditoSituacaoAtual(creditoARealizarHistorico.getDebitoCreditoSituacaoAtual());
					creditoARealizarTemp.setDebitoCreditoSituacaoAnterior(creditoARealizarHistorico.getDebitoCreditoSituacaoAnterior());
					creditoARealizarTemp.setRegistroAtendimento(creditoARealizarHistorico.getRegistroAtendimento());
					creditoARealizarTemp.setImovel(creditoARealizarHistorico.getImovel());
					creditoARealizarTemp.setOrdemServico(creditoARealizarHistorico.getOrdemServico());
					creditoARealizarTemp.setQuadra(creditoARealizarHistorico.getQuadra());
					creditoARealizarTemp.setLocalidade(creditoARealizarHistorico.getLocalidade());
					creditoARealizarTemp.setCreditoTipo(creditoARealizarHistorico.getCreditoTipo());
					creditoARealizarTemp.setCreditoOrigem(creditoARealizarHistorico.getCreditoOrigem());
					creditoARealizarTemp.setParcelamento(creditoARealizarHistorico.getParcelamento());
					creditoARealizarTemp.setDocumentoTipo(creditoARealizarHistorico.getDocumentoTipo());

					colecaoCreditoARealizarInserir.add(creditoARealizarTemp);

					Collection<CreditoARealizarCategoriaHistorico> colecaoCreditoARealizarCategoriaHistorico = this.repositorioFaturamento
									.pesquisarCreditoARealizarCategoriaHistorico(creditoARealizarHistorico);

					if(colecaoCreditoARealizarCategoriaHistorico != null && !colecaoCreditoARealizarCategoriaHistorico.isEmpty()){

						colecaoCreditoARealizarCategoriaHistoricoRemover.addAll(colecaoCreditoARealizarCategoriaHistorico);

						for(CreditoARealizarCategoriaHistorico creditoARealizarCategoriaHistorico : colecaoCreditoARealizarCategoriaHistorico){

							CreditoARealizarCategoria creditoARealizarCategoria = new CreditoARealizarCategoria();
							creditoARealizarCategoria.setComp_id(new CreditoARealizarCategoriaPK(creditoARealizarTemp,
											creditoARealizarCategoriaHistorico.getCategoria()));
							creditoARealizarCategoria.setCategoria(creditoARealizarCategoria.getCategoria());
							creditoARealizarCategoria.setCreditoARealizar(creditoARealizarTemp);
							creditoARealizarCategoria.setQuantidadeEconomia(creditoARealizarCategoria.getQuantidadeEconomia());
							creditoARealizarCategoria.setUltimaAlteracao(new Date());
							creditoARealizarCategoria.setValorCategoria(creditoARealizarCategoria.getValorCategoria());

							colecaoCreditoARealizarCategoriaInserir.add(creditoARealizarCategoria);
						}
					}
				}
				colecaoCreditoARealizarRemover.addAll(creditosARealizarHistorico);
				getControladorBatch().removerColecaoObjetoParaBatch(colecaoCreditoARealizarCategoriaHistoricoRemover);
				getControladorBatch().removerColecaoObjetoParaBatch(colecaoCreditoARealizarRemover);

				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoARealizarInserir);
				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoCreditoARealizarCategoriaInserir);
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}





	/**
	 * [UC0120] - Calcular Valores de Água e/ou Esgoto
	 * [SB0002] - Cálculo Simples Faixa Para Uma Única Tarifa
	 * 
	 * @author Yara Souza
	 * @date 30/08/2011
	 * @param consumoFaturado
	 * @param categoriasImovel
	 * @param percentualEsgoto
	 * @param consumoTarifaVigencia
	 * @param tipoCalculo
	 * @param consumoMinimoLigacao
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @return
	 * @throws ControladorException
	 */

	protected Collection<CalcularValoresAguaEsgotoHelper> calculoSimplesFaixaUmaUnicaTarifa(Integer consumoFaturado,
					Collection categoriasImovel, BigDecimal percentualEsgoto, ConsumoTarifaVigencia consumoTarifaVigencia,
					String tipoCalculo, int consumoMinimoLigacao, Date dataLeituraAnterior, Date dataLeituraAtual)
					throws ControladorException{

		Integer residuoConsumoExcedente = 0;
		Integer residuoConsumoProjetado = 0;
		Integer consumoMinimoCategoria = 0;
		BigDecimal vlFaturadoFaixa = new BigDecimal("0");
		BigDecimal vlTarifaMinimaCategoria = new BigDecimal("0");
		Integer consumoFaturadoFaixa = 0;
		Integer consumoExcedenteCategoria = 0;
		Integer consumoCategoria = 0;
		Integer consumoProjetadoExcedenteCategoria = 0;
		BigDecimal vlFaturadoCategoria = new BigDecimal("0");
		Integer consumoFaturadoCategoria = 0;

		Collection<CalcularValoresAguaEsgotoHelper> colecaoRetorno = new ArrayList();

		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		Integer quantTotalEconomia = this.obterQuantidadeTotalEconomiasImovel(categoriasImovel);

		Integer idMenorCategoria = this.obterMenorCategoria(categoriasImovel);

		Integer consumoProjetado = consumoFaturado;

		Integer consumoProjetadoExcedente = 0;
		Integer consumoProjetadoExcedentePorEconomia = 0;

		// PARM_ICAJUSTETARIFALEITPROJ da tabela SISTEMA_PARAMETROS for igual a 1.
		if(sistemaParametro.getIndicadorAjusteTarifaLeituraProjetada() == ConstantesSistema.SIM.shortValue()){
			Object[] retornoAjusteConsumoProjetado = new Object[3];
			retornoAjusteConsumoProjetado = ajustarConsumoProjetado(dataLeituraAnterior, dataLeituraAtual, consumoFaturado,
							quantTotalEconomia);
			consumoProjetado = (Integer) retornoAjusteConsumoProjetado[0];
			consumoProjetadoExcedente = (Integer) retornoAjusteConsumoProjetado[1];
			consumoProjetadoExcedentePorEconomia = (Integer) retornoAjusteConsumoProjetado[2];
		}

		Integer consumoExcedentePorEconomia = 0;

		if(consumoProjetado > consumoMinimoLigacao && quantTotalEconomia != 0){

			consumoExcedentePorEconomia = (consumoProjetado - consumoMinimoLigacao) / quantTotalEconomia;

			residuoConsumoExcedente = (consumoProjetado - consumoMinimoLigacao) - (consumoExcedentePorEconomia * quantTotalEconomia);

			if(consumoProjetadoExcedente != 0){
				residuoConsumoProjetado = consumoProjetadoExcedente - (consumoProjetadoExcedentePorEconomia * quantTotalEconomia);
			}

		}

		int consumoFaturadoExcedentePorEconomia = 0;
		int residuoConsumoFaturadoExcedente = 0;

		if(consumoProjetado <= consumoMinimoLigacao && consumoFaturado > consumoMinimoLigacao && quantTotalEconomia != 0){
			consumoFaturadoExcedentePorEconomia = (consumoFaturado - consumoMinimoLigacao) / quantTotalEconomia;

			residuoConsumoFaturadoExcedente = (consumoFaturado - consumoMinimoLigacao)
							- (consumoFaturadoExcedentePorEconomia * quantTotalEconomia);
		}

		Iterator itCategoriasImovel = categoriasImovel.iterator();
		ConsumoTarifaCategoria consumoTarifaCategoria = null;
		Collection colecaoConsumoTarifaCategoria = null;

		// Objeto que irá armazenar os valores calculados referentes as faixas
		Collection<CalcularValoresAguaEsgotoFaixaHelper> colecaoCalcularValoresAguaEsgotoFaixaHelper = new ArrayList();

		while(itCategoriasImovel.hasNext()){
			Categoria categoria = (Categoria) itCategoriasImovel.next();
			try{

				colecaoConsumoTarifaCategoria = repositorioFaturamento.pesquisarConsumoTarifaCategoria(consumoTarifaVigencia, categoria);

				if(colecaoConsumoTarifaCategoria == null || colecaoConsumoTarifaCategoria.isEmpty()){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.categoria_nao_existe_para_tarifa_vigente");
				}

				consumoTarifaCategoria = (ConsumoTarifaCategoria) Util.retonarObjetoDeColecao(colecaoConsumoTarifaCategoria);

				if(consumoTarifaCategoria.getNumeroConsumoMinimo() != null){
					consumoMinimoCategoria = consumoTarifaCategoria.getNumeroConsumoMinimo() * categoria.getQuantidadeEconomiasCategoria();
				}

				consumoExcedenteCategoria = consumoExcedentePorEconomia * categoria.getQuantidadeEconomiasCategoria();
				consumoProjetadoExcedenteCategoria = consumoProjetadoExcedentePorEconomia * categoria.getQuantidadeEconomiasCategoria();
				int consumoFaturadoExcedenteCategoria = consumoFaturadoExcedentePorEconomia * categoria.getQuantidadeEconomiasCategoria();

				if(idMenorCategoria.equals(categoria.getId())){
					consumoExcedenteCategoria = consumoExcedenteCategoria + residuoConsumoExcedente;
					consumoProjetadoExcedenteCategoria = consumoProjetadoExcedenteCategoria + residuoConsumoProjetado;
					consumoFaturadoExcedenteCategoria = consumoFaturadoExcedenteCategoria + residuoConsumoFaturadoExcedente;
				}

				consumoCategoria = consumoMinimoCategoria + consumoExcedenteCategoria;

				if(consumoCategoria <= consumoMinimoCategoria){

					if(consumoTarifaCategoria.getValorTarifaMinima() != null && consumoTarifaCategoria.getNumeroConsumoMinimo() != null){

						if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_ESGOTO)
										&& consumoTarifaVigencia.getConsumoTarifa().getIcTarifaEsgotoPropria()
														.equals(ConstantesSistema.SIM)){

							vlTarifaMinimaCategoria = consumoTarifaCategoria.getValorTarifaMinimaEsgoto().multiply(
											new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));

							vlFaturadoFaixa = consumoTarifaCategoria.getValorTarifaMinimaEsgoto().multiply(
											new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));
						} else {
							
							vlTarifaMinimaCategoria = consumoTarifaCategoria.getValorTarifaMinima().multiply(
											new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));

							vlFaturadoFaixa = consumoTarifaCategoria.getValorTarifaMinima().multiply(
											new BigDecimal("" + categoria.getQuantidadeEconomiasCategoria()));
						}

						consumoFaturadoFaixa = consumoTarifaCategoria.getNumeroConsumoMinimo()
										* categoria.getQuantidadeEconomiasCategoria();
						if(consumoFaturadoExcedenteCategoria > 0){
							BigDecimal numeroConsumoMinimoBD = new BigDecimal(consumoTarifaCategoria.getNumeroConsumoMinimo());
							BigDecimal consumoFaturadoExcedenteCategoriaBD = new BigDecimal(consumoFaturadoExcedenteCategoria);

							vlFaturadoFaixa = vlFaturadoFaixa.add((consumoFaturadoExcedenteCategoriaBD.multiply(vlTarifaMinimaCategoria
											.divide(numeroConsumoMinimoBD, 4, BigDecimal.ROUND_HALF_UP))));

							consumoFaturadoFaixa = consumoFaturadoFaixa + consumoFaturadoExcedenteCategoria;
						}

					}

				}else{

					Collection colecaoConsumoTarifaFaixa = repositorioFaturamento.pesquisarConsumoTarifaFaixa(consumoTarifaCategoria);
					Iterator itConsumoTarifaFaixa = colecaoConsumoTarifaFaixa.iterator();
					ConsumoTarifaFaixa consumoTarifaFaixa = null;

					int limiteInicialConsumoFaixa = 0;
					int limiteFinalConsumoFaixa = 0;
					BigDecimal vlTarifaFaixa = new BigDecimal("0");

					while(itConsumoTarifaFaixa.hasNext()){

						consumoTarifaFaixa = (ConsumoTarifaFaixa) itConsumoTarifaFaixa.next();

						if(consumoCategoria >= (consumoTarifaFaixa.getNumeroConsumoFaixaInicio() * categoria
										.getQuantidadeEconomiasCategoria())
										&& consumoCategoria <= (consumoTarifaFaixa.getNumeroConsumoFaixaIFim() * categoria
														.getQuantidadeEconomiasCategoria())){
							break;
						}

					}

					consumoFaturadoFaixa = consumoCategoria + consumoProjetadoExcedenteCategoria;

					if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_ESGOTO)
									&& consumoTarifaVigencia.getConsumoTarifa().getIcTarifaEsgotoPropria().equals(ConstantesSistema.SIM)){

						vlFaturadoFaixa = new BigDecimal(consumoFaturadoFaixa).multiply(consumoTarifaFaixa.getValorUsoEsgotoTarifa());

					}else{
						vlFaturadoFaixa = new BigDecimal(consumoFaturadoFaixa).multiply(consumoTarifaFaixa.getValorConsumoTarifa());
					}

					limiteInicialConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaInicio();
					limiteFinalConsumoFaixa = consumoTarifaFaixa.getNumeroConsumoFaixaIFim();
					vlTarifaFaixa = consumoTarifaFaixa.getValorConsumoTarifa();

				}

				vlFaturadoCategoria = vlFaturadoFaixa;

				consumoFaturadoCategoria = consumoFaturadoFaixa;

				// --------------------------------------------------------
				CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = new CalcularValoresAguaEsgotoHelper();

				// Carregando o id da categoria no objeto
				calcularValoresAguaEsgotoHelper.setIdCategoria(categoria.getId());

				// Carregando a descricao da categoria no objeto
				calcularValoresAguaEsgotoHelper.setDescricaoCategoria(categoria.getDescricao());

				// Carrega a quantidade de economias da categoria
				calcularValoresAguaEsgotoHelper.setQuantidadeEconomiasCategoria(categoria.getQuantidadeEconomiasCategoria());

				// Carregando o id do consumoTarifaCategoria no objeto
				calcularValoresAguaEsgotoHelper.setIdConsumoTarifaCategoria(consumoTarifaCategoria.getId());

				if(tipoCalculo.equalsIgnoreCase(ConstantesSistema.CALCULAR_AGUA)){

					calcularValoresAguaEsgotoHelper.setValorFaturadoAguaCategoria(vlFaturadoCategoria.setScale(2, BigDecimal.ROUND_DOWN));
					calcularValoresAguaEsgotoHelper.setConsumoFaturadoAguaCategoria(consumoFaturadoCategoria);
					calcularValoresAguaEsgotoHelper.setValorTarifaMinimaAguaCategoria(vlTarifaMinimaCategoria);
					calcularValoresAguaEsgotoHelper.setConsumoMinimoAguaCategoria(consumoMinimoCategoria);

				}else{

					if(consumoTarifaVigencia.getConsumoTarifa().getIcTarifaEsgotoPropria().equals(ConstantesSistema.NAO)){
						// Calculando com o percentual de esgoto
						BigDecimal result = percentualEsgoto.divide(new BigDecimal("100"), 2, BigDecimal.ROUND_HALF_UP);
	
						// Valor faturado de esgoto
						vlFaturadoCategoria = vlFaturadoCategoria.multiply(result);
						vlFaturadoCategoria = vlFaturadoCategoria.setScale(2, BigDecimal.ROUND_HALF_UP);
	
						// Valor da tarifa mínima de esgoto
						vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.multiply(result);
						vlTarifaMinimaCategoria = vlTarifaMinimaCategoria.setScale(2, BigDecimal.ROUND_HALF_UP);
					
					}

					calcularValoresAguaEsgotoHelper.setValorFaturadoEsgotoCategoria(vlFaturadoCategoria);
					calcularValoresAguaEsgotoHelper.setConsumoFaturadoEsgotoCategoria(consumoFaturadoCategoria);
					calcularValoresAguaEsgotoHelper.setValorTarifaMinimaEsgotoCategoria(vlTarifaMinimaCategoria);
					calcularValoresAguaEsgotoHelper.setConsumoMinimoEsgotoCategoria(consumoMinimoCategoria);
				}

				// Carregando a coleção com os valores referentes as faixas
				calcularValoresAguaEsgotoHelper.setFaixaTarifaConsumo(colecaoCalcularValoresAguaEsgotoFaixaHelper);

				colecaoRetorno.add(calcularValoresAguaEsgotoHelper);

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

		}

		return colecaoRetorno;

	}

	/**
	 * @author Yara Souza
	 * @date 30/08/2011
	 * @param categoriasImovel
	 * @return
	 */

	private Integer obterQuantidadeTotalEconomiasImovel(Collection categoriasImovel){

		Integer quantTotalEconomia = 0;

		// Calcula a quantidade total de economias do imóvel.
		// 1.1
		Iterator itCategoriasImovel = categoriasImovel.iterator();
		while(itCategoriasImovel.hasNext()){
			Categoria categoria = (Categoria) itCategoriasImovel.next();

			if(categoria.getQuantidadeEconomiasCategoria() != null){
				quantTotalEconomia = quantTotalEconomia + categoria.getQuantidadeEconomiasCategoria().intValue();
			}

		}

		return quantTotalEconomia;

	}

	/**
	 * @author Yara Souza
	 * @date 30/08/2011
	 * @param categoriasImovel
	 * @return
	 */
	private Integer obterMenorCategoria(Collection categoriasImovel){

		Integer menorIdCategoria = ConstantesSistema.NUMERO_MAXIMO_CATEGORIAS;

		Iterator itCategoriasImovel = categoriasImovel.iterator();
		while(itCategoriasImovel.hasNext()){
			Categoria categoria = (Categoria) itCategoriasImovel.next();

			if(categoria.getId() < menorIdCategoria){
				menorIdCategoria = categoria.getId();
			}

		}

		return menorIdCategoria;

	}

	/**
	 * @autor Bruno Ferreira dos Santos
	 * @date 15/08/2011
	 * @param idTipoEspecificacaoSolicitacao
	 * @return
	 * @throws ControladorException
	 */
	public DebitoAutomatico obterObjetoDebitoAutomatico(Integer idImovel) throws ControladorException{

		try{
			return repositorioFaturamento.obterObjetoDebitoAutomatico(idImovel);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @autor Cinthya Cavalcanti
	 * @date 13/09/2011
	 * @param consumoFaturadoAgua
	 * @param consumoMinimoLigacao
	 * @param consumoFaturadoEsgoto
	 * @param qtdEconnomia
	 * @return Map<String, String>
	 * @throws ControladorException
	 */
	public Map<String, String> ajusteConsumoMultiploQuantidadeEconomia(Integer consumoFaturadoAgua, int consumoMinimoLigacao,
					Integer consumoFaturadoEsgoto, Integer qtdEconnomia) throws ControladorException{

		String consumoMultiploQTDEEconomias = (String) ParametroFaturamento.P_AJUSTAR_CONSUMO.executar();
		Integer consumoAgua = 0;
		Map<String, String> consumoFaturadoAguaEsgoto = new HashMap<String, String>();

		// se a empresa realizar ajuste de consumo para múltiplo da quantidade de economias
		if(Integer.parseInt(consumoMultiploQTDEEconomias) == 1){
			if(consumoFaturadoAgua != null && consumoFaturadoAgua > consumoMinimoLigacao){
				consumoAgua = (consumoFaturadoAgua - consumoMinimoLigacao) / qtdEconnomia;
				consumoAgua = (consumoAgua * qtdEconnomia) + consumoMinimoLigacao;
			}else{
				consumoAgua = consumoMinimoLigacao;
			}
			consumoFaturadoAguaEsgoto.put("agua", consumoAgua.toString());

			Integer consumoEsgoto = 0;
			if(qtdEconnomia != 0 && consumoFaturadoEsgoto != null){
				consumoEsgoto = consumoFaturadoEsgoto / qtdEconnomia;
				consumoEsgoto = consumoEsgoto * qtdEconnomia;
				consumoFaturadoAguaEsgoto.put("esgoto", consumoEsgoto.toString());
			}
		}

		return consumoFaturadoAguaEsgoto;
	}

	/**
	 * @author Isaac Silva
	 * @date 15/09/2011
	 * @param codigoSetorComercial
	 * @param idLocalidade
	 * @return
	 * @throws ControladorException
	 */
	public Collection<FaturamentoGrupo> pesquisarFaturamentoGrupoPorCodigoSetorComercialELocalidade(Integer codigoSetorComercial,
					Integer idLocalidade) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarFaturamentoGrupoPorCodigoSetorComercialELocalidade(codigoSetorComercial, idLocalidade);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Verifica se a ROTA informada está em
	 * (SETOR COMERCIAL, FATURAMENTO_GRUPO)
	 * 
	 * @author Isaac Silva
	 * @date 15/09/2011
	 * @param codigoSetorComercial
	 * @param idLocalidade
	 * @return
	 * @throws ControladorException
	 */
	public boolean existeVinculoRotaSetorComercialFaturamentoGrupo(Quadra quadra) throws ControladorException{

		try{
			return repositorioFaturamento.existeVinculoRotaSetorComercialFaturamentoGrupo(quadra);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	protected ControladorRegistroAtendimentoLocal getControladorRegistroAtendimento(){

		ControladorRegistroAtendimentoLocalHome localHome = null;
		ControladorRegistroAtendimentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorRegistroAtendimentoLocalHome) locator
							.getLocalHome(ConstantesJNDI.CONTROLADOR_REGISTRO_ATENDIMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	public BigDecimal calcularValorDebitoACobrar(Integer idImovel, Integer anoMesReferencia, boolean apenasDebitoTipoParcelamento)
					throws ControladorException{

		BigDecimal valorTotalDebitos = BigDecimal.ZERO;

		try{
			// Pesquisa os débitos a cobrar do imóvel.
			Collection colecaoDebitosACobrar = null;

			colecaoDebitosACobrar = this.obterDebitoACobrarImovel(idImovel, DebitoCreditoSituacao.NORMAL, anoMesReferencia);

			/*
			 * Caso o imóvel tenha débitos a cobrar gera os débitos cobrados [SB0004] - Gerar os
			 * Débitos Cobrados
			 */
			if(colecaoDebitosACobrar != null && !colecaoDebitosACobrar.isEmpty()){

				// Cria o iterator dos débitos a cobrar
				Iterator iteratorColecaoDebitosACobrar = colecaoDebitosACobrar.iterator();
				DebitoACobrar debitoACobrar = new DebitoACobrar();
				BigDecimal valorPrestacao = BigDecimal.ZERO;

				Integer idTipoDebitoParcelamentoContas = Integer.valueOf(ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_CONTA.executar());

				// Laço para gerar os débitos cobrados e os débitos cobrados por categoria
				while(iteratorColecaoDebitosACobrar.hasNext()){

					// Recupera o débito a cobrar do iterator
					debitoACobrar = (DebitoACobrar) iteratorColecaoDebitosACobrar.next();

					// Caso o método tenha sido chamado do [UC3010 – Verificar Atendimento do
					// Critério de Faturamento pelo Imóvel]
					if(apenasDebitoTipoParcelamento
									&& (debitoACobrar.getParcelamento() == null
													&& !debitoACobrar.getDebitoTipo().getId().equals(DebitoTipo.PARCELAMENTO_CONTAS)
													&& !debitoACobrar.getDebitoTipo().getId().equals(DebitoTipo.ENTRADA_PARCELAMENTO)
													&& !debitoACobrar.getDebitoTipo().getId()
																	.equals(DebitoTipo.PARCELAMENTO_DEBITO_TRANSFERIDO)
													&& !debitoACobrar.getDebitoTipo().getId().equals(DebitoTipo.REPARCELAMENTO) && !debitoACobrar
													.getDebitoTipo().getId().equals(DebitoTipo.TEMPORARIO_CAERD))){

						continue;
					}

					// .................................................................................................................
					// Verificar para cada débito a lançar a partir da data de criação do débito a
					// cobrar,
					// se considerado o número de dias de suspensão a data obtida supera a data
					// corrente.
					// Nesse caso o débito a cobrar não será lançado na conta a ser faturada,
					// permanecendo até expiração do prazo.
					if(debitoACobrar.getNumeroDiasSuspensao() != null && debitoACobrar.getGeracaoDebito() != null){
						Date dataDebito = Util.adicionarNumeroDiasDeUmaData(debitoACobrar.getGeracaoDebito(),
										debitoACobrar.getNumeroDiasSuspensao());
						if(Util.compararData(dataDebito, new Date()) > 0){
							continue;
						}
					}
					// .................................................................................................................

					boolean debitoACobrarEmExtratoValido;
					debitoACobrarEmExtratoValido = verificarDebitoACobrarEmDocumentoCobranca(debitoACobrar);

					if(!debitoACobrarEmExtratoValido){

						// Calcula o valor da prestação
						valorPrestacao = debitoACobrar.getValorDebito().divide(new BigDecimal(debitoACobrar.getNumeroPrestacaoDebito()), 2,
										BigDecimal.ROUND_DOWN);

						// Caso seja a última prestação
						if(debitoACobrar.getNumeroPrestacaoCobradas() == (debitoACobrar.getNumeroPrestacaoDebito() - 1)){

							// Obtém o número de prestação débito
							BigDecimal numeroPrestacaoDebito = new BigDecimal(debitoACobrar.getNumeroPrestacaoDebito());

							// Mutiplica o valor da prestação * número da prestação debito
							BigDecimal multiplicacao = valorPrestacao.multiply(numeroPrestacaoDebito).setScale(2);

							// Subtrai o valor do débito pelo resultado da multiplicação
							BigDecimal parte1 = debitoACobrar.getValorDebito().subtract(multiplicacao).setScale(2);

							// Calcula o valor da prestação
							valorPrestacao = valorPrestacao.add(parte1).setScale(2);
						}

						// Acumula o valor da prestação no valor total dos debitos
						valorTotalDebitos = valorTotalDebitos.add(valorPrestacao);

					}

				}

			}

		}catch(Exception ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return valorTotalDebitos;

	}

	/**
	 * @author Ailton Sousa
	 * @date 09/08/2011
	 * @param imovel
	 * @param anoMesFaturamento
	 * @return
	 */
	public BigDecimal obterValorTotalDebitosCobrados(Imovel imovel, Integer anoMesFaturamento){

		BigDecimal valorTotalDebitos = BigDecimal.ZERO;

		// Pesquisa os débitos a cobrar do imóvel.
		Collection colecaoDebitosACobrar = null;
		try{
			colecaoDebitosACobrar = this.obterDebitoACobrarImovel(imovel.getId(), DebitoCreditoSituacao.NORMAL, anoMesFaturamento);

			if(colecaoDebitosACobrar != null && !colecaoDebitosACobrar.isEmpty()){

				Iterator iteratorColecaoDebitosACobrar = colecaoDebitosACobrar.iterator();
				DebitoACobrar debitoACobrar = new DebitoACobrar();
				BigDecimal valorPrestacao = BigDecimal.ZERO;

				// Laço para acumular os débitos cobrados e os débitos cobrados por categoria
				while(iteratorColecaoDebitosACobrar.hasNext()){
					// Recupera o débito a cobrar do iterator
					debitoACobrar = (DebitoACobrar) iteratorColecaoDebitosACobrar.next();

					// .................................................................................................................
					// Verificar para cada debito a lançar a partir da data de criação do débito a
					// cobrar,
					// se considerado o número de dias de suspensão a data obtida supera a data
					// corrente.
					// Nesse caso o débito a cobrar não será lançado na conta a ser faturada,
					// permanecendo até expiração do prazo.
					if(debitoACobrar.getNumeroDiasSuspensao() != null && debitoACobrar.getGeracaoDebito() != null){
						Date dataDebito = Util.adicionarNumeroDiasDeUmaData(debitoACobrar.getGeracaoDebito(),
										debitoACobrar.getNumeroDiasSuspensao());
						if(Util.compararData(dataDebito, new Date()) > 0){
							continue;
						}
					}
					// .................................................................................................................

					boolean debitoACobrarEmExtratoValido = verificarDebitoACobrarEmDocumentoCobranca(debitoACobrar);

					if(!debitoACobrarEmExtratoValido){

						// Calcula o valor da prestação
						valorPrestacao = debitoACobrar.getValorDebito().divide(new BigDecimal(debitoACobrar.getNumeroPrestacaoDebito()), 2,
										BigDecimal.ROUND_DOWN);

						// Caso seja a última prestação
						if(debitoACobrar.getNumeroPrestacaoCobradas() == (debitoACobrar.getNumeroPrestacaoDebito() - 1)){

							// Obtém o número de prestação débito
							BigDecimal numeroPrestacaoDebito = new BigDecimal(debitoACobrar.getNumeroPrestacaoDebito());

							// Mutiplica o valor da prestação * número da prestação debito
							BigDecimal multiplicacao = valorPrestacao.multiply(numeroPrestacaoDebito).setScale(2);

							// Subtrai o valor do débito pelo resultado da multiplicação
							BigDecimal parte1 = debitoACobrar.getValorDebito().subtract(multiplicacao).setScale(2);

							// Calcula o valor da prestação
							valorPrestacao = valorPrestacao.add(parte1).setScale(2);
						}

						// Acumula o valor da prestação no valor total dos debitos
						valorTotalDebitos = valorTotalDebitos.add(valorPrestacao);

					}

				}// fim do laço de debito a cobrar

			}

		}catch(ControladorException e){
			e.printStackTrace();
		}

		return valorTotalDebitos;

	}

	/**
	 * Retorna o Objeto FaturamentoGrupo pelo ID pesquisado.
	 * 
	 * @author Ailton Sousa
	 * @date 04/10/2011
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public FaturamentoGrupo pesquisarFaturamentoGrupoPorID(Integer idFaturamentoGrupo) throws ControladorException{

		FaturamentoGrupo retorno;

		try{
			retorno = this.repositorioFaturamento.pesquisarFaturamentoGrupoPorID(idFaturamentoGrupo);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * obtem imovel, localidade e conta atraves do id da conta
	 * 
	 * @author Vivianne Sousa
	 * @date 29/01/2008
	 * @param idConta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Conta obterImovelLocalidadeConta(Integer idConta) throws ControladorException{

		try{
			return repositorioFaturamento.obterImovelLocalidadeConta(idConta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
	 * obtem imovel, localidade e contaHistorico atraves do id da conta historico
	 * 
	 * @author Vivianne Sousa
	 * @date 29/01/2008
	 * @param idConta
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public ContaHistorico obterImovelLocalidadeContaHistorico(Integer idConta) throws ControladorException{

		try{
			return repositorioFaturamento.obterImovelLocalidadeContaHistorico(idConta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0146] - Manter Conta
	 * [FS0021] – Verificar situação da conta
	 * 
	 * @param conta
	 */
	public boolean verificarSituacaoContaPermitida(Conta conta) throws ControladorException{

		boolean situacaoPermitidaCorresponde = true;

		// Caso o indicador de verificar situação da conta esteja marcado como “SIM”
		// (P_VERIFICAR_SITUACAO_CONTA=1) e a situação da conta não corresponda a nenhum valor do
		// parâmetro
		// exibir a mensagem “Conta em <<descrição da situação da conta>> não
		// permitida.”
		// e retornar para o passo correspondente no fluxo principal.

		String[] parametroSituacaoContaPermitida = null;
		try{
			String parametroVerificarSituacaoContaPermitida = (String) ParametroFaturamento.P_VERIFICAR_SITUACAO_CONTA.executar();

			if(parametroVerificarSituacaoContaPermitida != null
							&& parametroVerificarSituacaoContaPermitida.equals(ConstantesSistema.SIM.toString())){
				// Caso indicador de verificação de conta permitida ativo.

				// inicializa a situação para falso
				situacaoPermitidaCorresponde = false;

				parametroSituacaoContaPermitida = ((String) ParametroFaturamento.P_SITUACAO_CONTA_PERMITIDA.executar()).split(",");

				// Verifica as situações de conta permitidas retornadas no valor do parâmetro para a
				// funcionalidade.
				for(int y = 0; y < parametroSituacaoContaPermitida.length; y++){
					if(parametroSituacaoContaPermitida[y].equals(conta.getDebitoCreditoSituacaoAtual().getId().toString())){
						// Caso situação da conta esteja dentro da lista de situações
						situacaoPermitidaCorresponde = true;
						// retorna verdadeiro e não exibe mensagem.
						return situacaoPermitidaCorresponde;
					}
				}
				// Caso não atenda a nenhuma situação da lista percorrida, retorna falso e exibe
				// mensagem.
				return situacaoPermitidaCorresponde;

			}else{
				// Caso o parametro de verificação de sit. conta permitida esteja desativado (valor
				// 2 ou null), retorna verdadeiro, e não exibe mensagem.
				return situacaoPermitidaCorresponde;
			}

		}catch(ControladorException e){
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0147] Cancelar Conta
	 * [SB0002] - Tratar Movimento Débito Automático
	 * 
	 * @author Anderson Italo
	 * @date 11/11/2011
	 */
	private void gerarDebitoAutomaticoMovimentoCancelarConta(Conta conta) throws ControladorException{

		DebitoAutomaticoMovimento debitoAutomaticoMovimento = this.getControladorArrecadacao()
						.pesquisarUltimoDebitoAutomaticoMovimentoConta(conta.getId());

		if(debitoAutomaticoMovimento != null){

			Boolean gerarMovCancelar = Boolean.FALSE;
			Boolean gerarMovExclusao = Boolean.FALSE;

			if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
							&& debitoAutomaticoMovimento.getIndicadorExclusao() == null
							&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() == null){

				gerarMovCancelar = Boolean.TRUE;

			}else if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
							&& debitoAutomaticoMovimento.getIndicadorExclusao() != null
							&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() != null){

				gerarMovExclusao = Boolean.TRUE;

			}else if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() != null
							&& debitoAutomaticoMovimento.getIndicadorExclusao() == null){

				gerarMovExclusao = Boolean.TRUE;

			}

			if(gerarMovCancelar){

				DebitoAutomaticoMovimentoCancelamentoMotivo damc = new DebitoAutomaticoMovimentoCancelamentoMotivo();
				damc.setId(DebitoAutomaticoMovimentoCancelamentoMotivo.CANCELAMENTO_CONTA);
				debitoAutomaticoMovimento.setDebitoAutomaticoMovimentoCancelamentoMotivo(damc);
				debitoAutomaticoMovimento.setUltimaAlteracao(new Date());

				this.getControladorUtil().atualizar(debitoAutomaticoMovimento);

			}else if(gerarMovExclusao){

				DebitoAutomaticoMovimento debitoAutomaticoMovimentoNovo = new DebitoAutomaticoMovimento();
				debitoAutomaticoMovimentoNovo.setDebitoAutomatico(debitoAutomaticoMovimento.getDebitoAutomatico());
				debitoAutomaticoMovimentoNovo.setValorDebito(debitoAutomaticoMovimento.getValorDebito());

				FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
				filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, conta.getId()));

				Collection colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral, ContaGeral.class.getName());

				ContaGeral contaGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);

				debitoAutomaticoMovimentoNovo.setContaGeral(contaGeral);

				debitoAutomaticoMovimentoNovo.setDataVencimento(debitoAutomaticoMovimento.getDataVencimento());
				debitoAutomaticoMovimentoNovo.setFaturamentoGrupo(debitoAutomaticoMovimento.getFaturamentoGrupo());
				debitoAutomaticoMovimentoNovo.setProcessamento(new Date());
				debitoAutomaticoMovimentoNovo.setUltimaAlteracao(new Date());
				debitoAutomaticoMovimentoNovo.setIndicadorExclusao(ConstantesSistema.SIM);

				this.getControladorUtil().inserir(debitoAutomaticoMovimentoNovo);

			}

		}

	}

	/**
	 * Pesquisar Prestações de Guia de Pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @throws ControladorException
	 * @date 20/12/2011
	 */
	public Collection<GuiaPagamentoPrestacaoHelper> pesquisarGuiasPagamentoPrestacaoFiltrar(Integer guiaPagamentoId)
					throws ControladorException{

		Collection<GuiaPagamentoPrestacaoHelper> retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarGuiasPagamentoPrestacaoFiltrar(guiaPagamentoId,
							ConstantesSistema.CONSULTA_UC0188_SB0001_ITEM_3);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Pesquisar Prestações de Guia de Pagamento
	 * 
	 * @author Gicevalter Couto
	 * @throws ControladorException
	 * @date 29/01/2014
	 */
	public Collection<GuiaPagamentoPrestacaoHelper> pesquisarGuiasPagamentoPrestacaoPorParcelamento(Integer parcelamentoId)
					throws ControladorException{

		Collection<GuiaPagamentoPrestacaoHelper> retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarGuiasPagamentoPrestacaoPorParcelamento(parcelamentoId);

		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Pesquisar Prestações de Guia de Pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 05/01/2012
	 */
	public Collection<GuiaPagamentoPrestacaoHelper> pesquisarGuiasPagamentoPrestacaoRelatorio(Integer guiaPagamentoId)
					throws ControladorException{

		Collection<GuiaPagamentoPrestacaoHelper> retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarGuiasPagamentoPrestacaoRelatorio(guiaPagamentoId);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Pesquisar tipos de financiamento de débitos que não permitam o cancelamento de uma guia de
	 * pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 02/01/2011
	 */
	public Collection<String> pesquisarTipoFinanciamentoDebitoNaoPermiteCancelarGuiaPagamento(Integer guiaPagamentoId)
					throws ControladorException{

		Collection retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarTipoFinanciamentoDebitoNaoPermiteCancelarGuiaPagamento(guiaPagamentoId);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Pesquisar parcelamentos de cobranca bancarias correspondentes a uma guia de pagamento
	 * pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 02/01/2011
	 */
	public Collection<String> pesquisarBoletoEmissaoGuiaPagamento(Integer guiaPagamentoId) throws ControladorException{

		Collection retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarBoletoEmissaoGuiaPagamento(guiaPagamentoId);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Pesquisar parcelamentos de cobranca bancarias correspondentes a uma guia de pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * 
	 * @author Hugo Lima
	 * @date 05/01/2011
	 */
	public Collection<Object[]> pesquisarBoletoGeradoGuiaPagamento(Integer guiaPagamentoId, Short numeroPrestacao)
					throws ControladorException{

		Collection retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarBoletoGeradoGuiaPagamento(guiaPagamentoId, numeroPrestacao);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC3027] Filtrar Guia de Pagamento
	 * 
	 * @author Anderson Italo
	 * @date 27/10/2011
	 */
	public Collection<GuiaPagamentoHelper> pesquisarRegistrosManterGuiaPagamento(FiltroGuiaPagamentoHelper filtro)
					throws ControladorException{

		Collection<GuiaPagamentoHelper> colecaoRetorno = null;
		try{

			Collection retornoConsulta = this.repositorioFaturamento.pesquisarRegistrosManterGuiaPagamento(filtro);

			if(!Util.isVazioOrNulo(retornoConsulta)){

				colecaoRetorno = new ArrayList<GuiaPagamentoHelper>();
				for(Iterator iterator = retornoConsulta.iterator(); iterator.hasNext();){

					Object[] item = (Object[]) iterator.next();
					GuiaPagamentoHelper guia = new GuiaPagamentoHelper();

					// Número da Guia
					if(item[1] != null && !item[1].toString().equals("")){

						guia.setNumeroGuia(Util.obterInteger(item[1].toString()));
					}else{

						guia.setNumeroGuia(Util.obterInteger(item[2].toString()));
					}

					// Imóvel
					if(item[3] != null && !item[3].toString().equals("")){

						guia.setIdImovel(Util.obterInteger(item[3].toString()));
					}else if(item[4] != null && !item[4].toString().equals("")){

						guia.setIdImovel(Util.obterInteger(item[4].toString()));
					}

					// Cliente Responsável
					if(item[5] != null && !item[5].toString().equals("")){

						guia.setIdClienteResponsavel(Util.obterInteger(item[5].toString()));
						guia.setNomeClienteResponsavel(item[6].toString());
					}else if(item[7] != null && !item[7].toString().equals("")){

						guia.setIdClienteResponsavel(Util.obterInteger(item[7].toString()));
						guia.setNomeClienteResponsavel(item[8].toString());
					}

					// Cliente da Guia
					if(item[9] != null && !item[9].toString().equals("")){

						guia.setIdClienteGuia(Util.obterInteger(item[9].toString()));
						guia.setNomeClienteGuia(item[10].toString());
					}else if(item[11] != null && !item[11].toString().equals("")){

						guia.setIdClienteGuia(Util.obterInteger(item[11].toString()));
						guia.setNomeClienteGuia(item[12].toString());
					}

					// Numero RA
					if(item[19] != null && !item[19].toString().equals("")){

						guia.setNumeroRA(Util.obterInteger(item[19].toString()));
					}else if(item[20] != null && !item[20].toString().equals("")){

						guia.setNumeroRA(Util.obterInteger(item[20].toString()));
					}

					// Total de Débitos
					if(item[13] != null && !item[13].toString().equals("")){

						guia.setValorDebitos(new BigDecimal(item[13].toString()));
					}else{

						guia.setValorDebitos(new BigDecimal(item[14].toString()));
					}

					// Total Pago
					guia.setValorPagamentos(this.repositorioFaturamento.obterTotalPagamentosPorGuiaPagamento(guia.getNumeroGuia()));

					// Total Pendente
					guia.setTotalPendente(guia.getValorDebitos().subtract(guia.getValorPagamentos()));

					// Total de Prestações
					if(item[15] != null && !item[15].toString().equals("")){

						guia.setNumeroPrestacaoTotal(Util.obterInteger(item[15].toString()));
					}else if(item[16] != null && !item[16].toString().equals("")){

						guia.setNumeroPrestacaoTotal(Util.obterInteger(item[16].toString()));
					}else{

						guia.setNumeroPrestacaoTotal(0);
					}

					// Total de Prestações Pagas e Data de Pagamento
					List<PagamentoHistorico> colecaoPagamento = this.repositorioFaturamento.obterTotalPrestacoesPagas(guia.getNumeroGuia());
					if(!Util.isVazioOrNulo(colecaoPagamento)){
						Collection<Short> colecaoNumeroPrestacaoPaga = new ArrayList<Short>();

						FiltroGuiaPagamentoPrestacaoHistorico filtroGuiaPagamentoPrestacaoHistorico = new FiltroGuiaPagamentoPrestacaoHistorico();
						filtroGuiaPagamentoPrestacaoHistorico.adicionarParametro(new ParametroSimples(
										FiltroGuiaPagamentoPrestacaoHistorico.GUIA_PAGAMENTO_ID, guia.getNumeroGuia()));

						Collection<GuiaPagamentoPrestacaoHistorico> colecaoGuiaPagamentoPrestacaoHistorico = this.getControladorUtil()
										.pesquisar(filtroGuiaPagamentoPrestacaoHistorico, GuiaPagamentoPrestacaoHistorico.class.getName());

						if(!Util.isVazioOrNulo(colecaoGuiaPagamentoPrestacaoHistorico)){
							GuiaPagamentoPrestacaoHistoricoPK guiaPagamentoPrestacaoHistoricoPK = null;
							Short numeroPrestacao = null;
							Short indicadorPagamentoPendente = null;

							for(GuiaPagamentoPrestacaoHistorico guiaPagamentoPrestacaoHistorico : colecaoGuiaPagamentoPrestacaoHistorico){
								indicadorPagamentoPendente = guiaPagamentoPrestacaoHistorico.getIndicadorPagamentoPendente();

								if(indicadorPagamentoPendente != null
												&& indicadorPagamentoPendente.shortValue() == ConstantesSistema.SIM.shortValue()){
									guiaPagamentoPrestacaoHistoricoPK = guiaPagamentoPrestacaoHistorico.getComp_id();
									numeroPrestacao = guiaPagamentoPrestacaoHistoricoPK.getNumeroPrestacao();

									if(!colecaoNumeroPrestacaoPaga.contains(numeroPrestacao)){
										colecaoNumeroPrestacaoPaga.add(numeroPrestacao);
									}
								}
							}
						}

						PagamentoHistorico pagamento = colecaoPagamento.get(0);
						guia.setNumeroPrestacaoPaga(colecaoNumeroPrestacaoPaga.size());
						guia.setDataPagamento(Util.formatarData(pagamento.getDataPagamento()));
					}else{

						guia.setNumeroPrestacaoPaga(0);
						guia.setDataPagamento("");
					}

					// Total de Prestações Pendentes
					guia.setNumeroPrestacaoPendente(guia.getNumeroPrestacaoTotal().intValue() - guia.getNumeroPrestacaoPaga().intValue());

					// Endereço do Imóvel
					if(guia.getIdImovel() != null){

						// [UC0085 - Obter Endereço]
						String enderecoImovel = getControladorEndereco().pesquisarEndereco(guia.getIdImovel());
						if(!Util.isVazioOuBranco(enderecoImovel)){

							guia.setEnderecoImovel(enderecoImovel);
						}else{

							guia.setEnderecoImovel("");
						}
					}

					colecaoRetorno.add(guia);
				}
			}

		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return colecaoRetorno;
	}

	/**
	 * [UC3027] Filtrar Guia de Pagamento
	 * Obter total de registros retornados na consulta
	 * 
	 * @author Anderson Italo
	 * @date 27/10/2011
	 */
	public Integer pesquisarTotalRegistrosManterGuiaPagamento(FiltroGuiaPagamentoHelper filtro) throws ControladorException{

		Integer retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarTotalRegistrosManterGuiaPagamento(filtro);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0111] Iniciar Processo
	 * [SB0006] – Obter Dados Complementares de Comando de Faturamento
	 * 
	 * @author Hugo Lima
	 * @date 28/02/2012
	 * @param idComandoFaturamento
	 * @return
	 * @throws ControladorException
	 */
	public String obterDadosComplementaresComandoFaturamento(Integer idComandoFaturamento) throws ControladorException{

		String retorno = "";
		try{
			Object[] retornoConsulta = this.repositorioFaturamento.pesquisarDadosComplementaresComandoFaturamento(idComandoFaturamento);
			if(!Util.isVazioOrNulo(retornoConsulta)){
				ProcessoIniciadoDadoComplementarHelper helper = new ProcessoIniciadoDadoComplementarHelper();
				helper.adcionarDadoComplementar(DadoComplementarEnumerator.GRUPO_DESCRICAO, retornoConsulta[0]);
				helper.adcionarDadoComplementar(DadoComplementarEnumerator.ANO_MES_REFERENCIA,
								Util.formatarAnoMesParaMesAno((Integer) retornoConsulta[1]));
				retorno = helper.getStringFormatoPesistencia();
			}
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC3037] Filtrar Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 24/02/2012
	 *          Exibir Contas Pré-Faturadas.
	 */
	public Integer obterMaiorAnoMesReferenciaAnteriorMedicaoHistorico(Integer idImovel, Integer anoMesConta) throws ControladorException{

		Integer retorno = null;
		try{
			retorno = this.repositorioFaturamento.obterMaiorAnoMesReferenciaAnteriorMedicaoHistorico(idImovel, anoMesConta);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC3037] Filtrar Contas Pré-Faturadas
	 * 
	 * @author Carlos Chrystian
	 * @created 12/03/2012
	 *          Exibir Contas Pré-Faturadas.
	 */
	public Integer obterMaiorAnoMesReferenciaAnteriorConsumoHistorico(Integer idImovel, Integer anoMesConta) throws ControladorException{

		Integer retorno = null;
		try{
			retorno = this.repositorioFaturamento.obterMaiorAnoMesReferenciaAnteriorConsumoHistorico(idImovel, anoMesConta);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	public HashSet obterContas(Integer idImovel, Integer anoMesReferencia, Integer idDebitoCreditoSituacao) throws ControladorException{

		HashSet hashContas = null;
		HashSet hashDebitosCobrados = null;

		FiltroConta filtroConta = new FiltroConta();
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, anoMesReferencia));
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, idImovel));
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.DEBITO_CREDITO_SITUACAO_ATUAL_ID, idDebitoCreditoSituacao));

		Collection contas = this.getControladorUtil().pesquisar(filtroConta, Conta.class.getName());

		Iterator it = contas.iterator();
		while(it.hasNext()){
			hashContas = new HashSet();
			Conta conta = (Conta) it.next();
			FiltroDebitoCobrado filtroDebitoCobrado = new FiltroDebitoCobrado();
			filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.CONTA_ID, conta.getId()));
			filtroDebitoCobrado.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoCobrado.DEBITO_TIPO);
			Collection debitosCobrados = this.getControladorUtil().pesquisar(filtroDebitoCobrado, DebitoCobrado.class.getName());

			hashDebitosCobrados = new HashSet();
			Iterator itDb = debitosCobrados.iterator();
			while(itDb.hasNext()){
				DebitoCobrado debitoCobrado = (DebitoCobrado) itDb.next();
				hashDebitosCobrados.add(debitoCobrado);
			}

			conta.setDebitoCobrados(hashDebitosCobrados);
			hashContas.add(conta);

		}

		return hashContas;
	}

	/**
	 * [UC3055] Encerrar Faturamento
	 * [SB0001] – Selecionar Grupos de Faturamento por Situação
	 * 
	 * @author Hebert Falcão
	 * @date 01/04/2012
	 */
	public Collection<GupoFaturamentoHelper> selecionarGruposFaturamentoPorSituacao(Integer referencia, Short situacao)
					throws ControladorException{

		Collection<GupoFaturamentoHelper> retorno = null;

		try{
			Collection<Object[]> colecaoAux = this.repositorioFaturamento.selecionarGruposFaturamentoPorSituacao(referencia, situacao);

			if(!Util.isVazioOrNulo(colecaoAux)){
				retorno = new ArrayList<GupoFaturamentoHelper>();

				String descricaoAux = null;

				Integer referenciaAux = null;
				String referenciaAuxStr = null;

				String situacaoAux = null;

				Date dataUltimoFaturamentoAux = null;
				String dataUltimoFaturamentoAuxStr = null;

				String idFaturamentoGrupoAux = null;

				String qtRotasNaoFaturadasAux = null;

				GupoFaturamentoHelper gupoFaturamentoHelper = null;

				for(Object[] objeto : colecaoAux){
					gupoFaturamentoHelper = new GupoFaturamentoHelper();

					if(objeto[0] != null){
						descricaoAux = (String) objeto[0];
						gupoFaturamentoHelper.setDescricao(descricaoAux);
					}

					if(objeto[1] != null){
						referenciaAux = (Integer) objeto[1];
						referenciaAuxStr = Util.formatarMesAnoReferencia(referenciaAux);
						gupoFaturamentoHelper.setReferencia(referenciaAuxStr);

						if(referenciaAux > referencia){
							situacaoAux = ConstantesSistema.SITUACAO_GRUPO_FATURADO;
						}else{
							situacaoAux = ConstantesSistema.SITUACAO_GRUPO_NAO_FATURADO;
						}

						gupoFaturamentoHelper.setSituacao(situacaoAux);
					}

					if(objeto[2] != null){
						dataUltimoFaturamentoAux = (Date) objeto[2];
						dataUltimoFaturamentoAuxStr = Util.formatarData(dataUltimoFaturamentoAux);
						gupoFaturamentoHelper.setDataUltimoFaturamento(dataUltimoFaturamentoAuxStr);
					}

					if(objeto[3] != null){
						idFaturamentoGrupoAux = (String) objeto[3];
						gupoFaturamentoHelper.setId(idFaturamentoGrupoAux);
					}

					if(objeto[4] != null){
						qtRotasNaoFaturadasAux = (String) objeto[4];
						if(!qtRotasNaoFaturadasAux.equals("0")){
							gupoFaturamentoHelper.setQtRotasNaoFaturadas(qtRotasNaoFaturadasAux);
						}
					}

					retorno.add(gupoFaturamentoHelper);
				}
			}
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC3055] Encerrar Faturamento
	 * Pesquisar Grupos Não Faturados
	 * 
	 * @author Hebert Falcão
	 * @date 01/04/2012
	 */
	public Collection<FaturamentoGrupo> pesquisarGruposNaoFaturados(Integer referencia) throws ControladorException{

		try{
			return this.repositorioFaturamento.pesquisarGruposNaoFaturados(referencia);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC3055] Encerrar Faturamento
	 * [SB0002] – Encerrar Faturamento
	 * 
	 * @author Hebert Falcão
	 * @date 01/04/2012
	 */
	public void encerrarFaturamento(Integer referencia, Usuario usuario) throws ControladorException{

		try{

			Integer novaReferencia = Util.somaUmMesAnoMesReferencia(referencia);

			// Registrar a transação de alteração
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ENCERRAR_FATURAMENTO, referencia,
							referencia, new UsuarioAcaoUsuarioHelper(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_ENCERRAR_FATURAMENTO);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			Collection<FaturamentoGrupo> colecaoFaturamentoGrupoAtualizar = new ArrayList<FaturamentoGrupo>();
			Collection<FaturamentoGrupo> colecaoFaturamentoGrupo = this.pesquisarGruposNaoFaturados(referencia);

			if(!Util.isVazioOrNulo(colecaoFaturamentoGrupo)){

				// Referência dos grupos não faturados
				for(FaturamentoGrupo faturamentoGrupo : colecaoFaturamentoGrupo){
					faturamentoGrupo.setAnoMesReferencia(novaReferencia);
					faturamentoGrupo.setUltimaAlteracao(new Date());

					faturamentoGrupo.setOperacaoEfetuada(operacaoEfetuada);
					faturamentoGrupo.adicionarUsuario(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

					registradorOperacao.registrarOperacao(faturamentoGrupo);

					colecaoFaturamentoGrupoAtualizar.add(faturamentoGrupo);
				}

				this.getControladorUtil().atualizarColecaoObjetos(colecaoFaturamentoGrupoAtualizar);
			}

			this.repositorioFaturamento.atualizarImoveisSituacaoEspecialFaturamentoFinalizada(referencia);

			this.repositorioFaturamento.atualizarImoveisSituacaoEspecialCobrancaFinalizada(referencia);

			// Referência geral do faturamento
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			sistemaParametro.setAnoMesFaturamento(novaReferencia);
			sistemaParametro.setUltimaAlteracao(new Date());

			this.getControladorUtil().atualizar(sistemaParametro);

			this.getControladorParametroSistema().atualizarValorParametroSistema(
							ParametroFaturamento.P_ANO_BASE_DECLARACAO_QUITACAO_DEBITO_ANUAL.getCodigo(),
							ConstantesSistema.SEM_ANO_BASE_DECLARACAO_QUITACAO_DEBITO_ANUAL.toString());

			FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
			filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.INDICADOR_USO,
							ConstantesSistema.INDICADOR_USO_ATIVO));

			Collection<FaturamentoGrupo> colecaoFaturamentoGrupos = getControladorUtil().pesquisar(filtroFaturamentoGrupo,
							FaturamentoGrupo.class.getName());

			Collection<NacionalFeriado> colecaoNacionalFeriado = getControladorUtil().pesquisarFeriadosNacionais();
			Collection<MunicipioFeriado> colecaoMunicipioFeriado = getControladorUtil().pesquisarFeriadosMunicipais();

			String pGerarCronogramaAutomaticamente = null;
			try{

				pGerarCronogramaAutomaticamente = ((String) ParametroFaturamento.P_GERA_CRONOGRAMA_AUTOMATICAMENTE.executar(this));
			}catch(ControladorException e){

				throw new ActionServletException("atencao.sistemaparametro_inexistente", "P_GERA_CRONOGRAMA_AUTOMATICAMENTE");
			}

			// Caso a empresa opte por gerar um novo cronograma automaticamente
			if(pGerarCronogramaAutomaticamente.equals(ConstantesSistema.SIM.toString())){

				for(FaturamentoGrupo faturamentoGrupoEncerrado : colecaoFaturamentoGrupos){

					FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensalMaiorReferencia = repositorioFaturamento
									.pesquisarUltimoFaturamentoGrupoCronogramaMensal(faturamentoGrupoEncerrado.getId());

					if(faturamentoGrupoCronogramaMensalMaiorReferencia != null){

						// [FS0003] - Verificar existência do cronograma para o grupo
						FiltroFaturamentoGrupoCronogramaMensal filtroFaturamentoGrupoCronogramaMensal = new FiltroFaturamentoGrupoCronogramaMensal();

						filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoGrupoCronogramaMensal.ANO_MES_REFERENCIA, Util.somaMesAnoMesReferencia(
														faturamentoGrupoCronogramaMensalMaiorReferencia.getAnoMesReferencia(), 1)));
						filtroFaturamentoGrupoCronogramaMensal.adicionarParametro(new ParametroSimples(
										FiltroFaturamentoGrupoCronogramaMensal.ID_FATURAMENTO_GRUPO,
										faturamentoGrupoCronogramaMensalMaiorReferencia.getFaturamentoGrupo().getId()));
						Collection<FaturamentoGrupoCronogramaMensal> colecaoFaturamentoGrupoCronogramaMensalExistente = getControladorUtil()
										.pesquisar(filtroFaturamentoGrupoCronogramaMensal, FaturamentoGrupoCronogramaMensal.class.getName());

						if(Util.isVazioOrNulo(colecaoFaturamentoGrupoCronogramaMensalExistente)){

							// ------------ REGISTRAR TRANSAÇÃO ----------------------------
							RegistradorOperacao registradorOperacaoCronogramaNovo = new RegistradorOperacao(
											Operacao.OPERACAO_INSERIR_CRONOGRAMA_FATURAMENTO, new UsuarioAcaoUsuarioHelper(usuario,
															UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

							FaturamentoGrupoCronogramaMensal faturamentoGrupoCronogramaMensalNovo = new FaturamentoGrupoCronogramaMensal();
							faturamentoGrupoCronogramaMensalNovo.setUltimaAlteracao(new Date());
							faturamentoGrupoCronogramaMensalNovo.setAnoMesReferencia(Util.somaMesAnoMesReferencia(
											faturamentoGrupoCronogramaMensalMaiorReferencia.getAnoMesReferencia(), 1));
							faturamentoGrupoCronogramaMensalNovo.setFaturamentoGrupo(faturamentoGrupoCronogramaMensalMaiorReferencia
											.getFaturamentoGrupo());

							registradorOperacaoCronogramaNovo.registrarOperacao(faturamentoGrupoCronogramaMensalNovo);
							Integer idFaturamentoGrupoCronogramaMensalInserido = (Integer) getControladorUtil().inserir(
											faturamentoGrupoCronogramaMensalNovo);
							faturamentoGrupoCronogramaMensalNovo.setId(idFaturamentoGrupoCronogramaMensalInserido);

							FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronogramaMaiorReferencia = new FiltroFaturamentoAtividadeCronograma();
							filtroFaturamentoAtividadeCronogramaMaiorReferencia.adicionarParametro(new ParametroSimples(
											FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ID,
											faturamentoGrupoCronogramaMensalMaiorReferencia.getId()));
							filtroFaturamentoAtividadeCronogramaMaiorReferencia
											.adicionarCaminhoParaCarregamentoEntidade(FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE);

							Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaRefenciaMaiorReferencia = getControladorUtil()
											.pesquisar(filtroFaturamentoAtividadeCronogramaMaiorReferencia,
															FaturamentoAtividadeCronograma.class.getName());

							if(!Util.isVazioOrNulo(colecaoFaturamentoAtividadeCronogramaRefenciaMaiorReferencia)){

								Collection<FaturamentoAtividadeCronograma> colecaoFaturamentoAtividadeCronogramaNova = new ArrayList<FaturamentoAtividadeCronograma>();

								for(FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaMaiorReferencia : colecaoFaturamentoAtividadeCronogramaRefenciaMaiorReferencia){

									FaturamentoAtividadeCronograma faturamentoAtividadeCronogramaNovoBaseadoAnterior = new FaturamentoAtividadeCronograma();
									faturamentoAtividadeCronogramaNovoBaseadoAnterior
													.setComando(faturamentoAtividadeCronogramaMaiorReferencia.getComando());
									faturamentoAtividadeCronogramaNovoBaseadoAnterior
													.setDataPrevista(faturamentoAtividadeCronogramaMaiorReferencia.getDataPrevista());
									faturamentoAtividadeCronogramaNovoBaseadoAnterior.setDataRealizacao(null);
									faturamentoAtividadeCronogramaNovoBaseadoAnterior
													.setFaturamentoAtividade(faturamentoAtividadeCronogramaMaiorReferencia
																	.getFaturamentoAtividade());
									faturamentoAtividadeCronogramaNovoBaseadoAnterior
													.setFaturamentoGrupoCronogramaMensal(faturamentoGrupoCronogramaMensalNovo);

									// Define a data projetada pela soma de 30 dias à data projetada
									// do
									// cronograma
									// anterior
									Date dataProjetada = Util.adicionarNumeroDiasDeUmaData(
													faturamentoAtividadeCronogramaNovoBaseadoAnterior.getDataPrevista(), 30);

									// Caso a data projetada seja um dia não útil, a data prevista
									// será
									// o
									// próximo
									// dia útil
									if(!Util.ehDiaUtil(dataProjetada, colecaoNacionalFeriado, colecaoMunicipioFeriado)){

										dataProjetada = Util.obterProximoDiaUtil(dataProjetada, colecaoNacionalFeriado,
														colecaoMunicipioFeriado);
									}

									faturamentoAtividadeCronogramaNovoBaseadoAnterior.setDataPrevista(dataProjetada);

									if(faturamentoAtividadeCronogramaNovoBaseadoAnterior.getComando() != null){

										faturamentoAtividadeCronogramaNovoBaseadoAnterior.setComando(dataProjetada);
									}

									faturamentoAtividadeCronogramaNovoBaseadoAnterior
													.setFaturamentoAtividadeCronogramaRotas(faturamentoAtividadeCronogramaMaiorReferencia
																	.getFaturamentoAtividadeCronogramaRotas());
									colecaoFaturamentoAtividadeCronogramaNova.add(faturamentoAtividadeCronogramaNovoBaseadoAnterior);
								}

								// Inclui as atividades do cronograma
								this.inserirFaturamentoAtividadeCronograma(colecaoFaturamentoAtividadeCronogramaNova,
												faturamentoGrupoCronogramaMensalNovo, registradorOperacaoCronogramaNovo);
							}
						}
					}
				}
			}

		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}catch(NegocioException ex1){

			throw new ControladorException("erro.sistema", ex1);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [FS0005] - Verificar existência da conta
	 * 
	 * @author Anderson Italo
	 * @date 02/08/2011
	 * @return Object
	 * @exception ErroRepositorioException
	 */
	public Object verificarExistenciaConta(Integer imovelId, Integer anoMesReferencia) throws ControladorException{

		try{

			return this.repositorioFaturamento.verificarExistenciaConta(imovelId, anoMesReferencia);
		}catch(ErroRepositorioException ex){

			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Relatório de Ocorrência da Geração do Pré-Faturamento
	 * 
	 * @author Hebert Falcão
	 * @date 06/04/2012
	 */
	private void iniciarProcessamentoRelatorioOcorrenciaGeracaoPreFaturamento(FaturamentoGrupo faturamentoGrupo, Integer anoMesReferencia,
					Collection<Imovel> colecaoOcorrenciaGeracaoPreFaturamento, Integer idFuncionalidadeIniciada, Date dataVencimento)
					throws ControladorException{

		if(!Util.isVazioOrNulo(colecaoOcorrenciaGeracaoPreFaturamento)){

			String idFaturamentoGrupoStr = "";

			if(faturamentoGrupo != null){
				Integer idFaturamentoGrupo = faturamentoGrupo.getId();
				idFaturamentoGrupoStr = Integer.toString(idFaturamentoGrupo);
			}

			String anoMesReferenciaStr = "";

			if(anoMesReferencia != null){
				anoMesReferenciaStr = Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesReferencia);
			}

			Usuario usuarioProcessamento = null;

			if(idFuncionalidadeIniciada != null){
				usuarioProcessamento = this.getControladorBatch().obterUsuarioFuncionalidadeIniciada(idFuncionalidadeIniciada);
			}else{
				usuarioProcessamento = Usuario.USUARIO_BATCH;
			}

			String dataVencimentoStr = "";

			if(dataVencimento != null){
				dataVencimentoStr = Util.formatarData(dataVencimento);
			}

			RelatorioOcorrenciaGeracaoPreFaturamento relatorio = new RelatorioOcorrenciaGeracaoPreFaturamento(usuarioProcessamento);
			relatorio.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
			relatorio.addParametro("anoMesReferencia", anoMesReferenciaStr);
			relatorio.addParametro("idGrupoFaturamento", idFaturamentoGrupoStr);
			relatorio.addParametro("colecaoOcorrenciaGeracaoPreFaturamento", colecaoOcorrenciaGeracaoPreFaturamento);
			relatorio.addParametro("dataVencimento", dataVencimentoStr);
			relatorio.addParametro("referenciaTarifa", anoMesReferenciaStr);

			this.getControladorBatch().iniciarProcessoRelatorio(relatorio);
		}
	}

	/**
	 * Este caso de uso permite Retirar de Revisão Todas as Contas com o Prazo de Revisão vencido
	 * [UC3057] Retirar Conta de Revisão Prazo Vencido
	 * 
	 * @author Hugo Lima
	 * @created 15/05/2012
	 * @param usuario
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void retirarContaRevisaoPrazoVencido(Integer idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;
		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, idUnidadeIniciada);

		System.out.println("******INICO DA REMOÇÃO DE CONTAS EM REVISÃO COM PRAZO VENCIDO******");
		try{
			// Recupera o usuário, nesse caso, o sistema.
			Usuario usuario = Usuario.USUARIO_BATCH;

			// Pesquisa as contas em revisão com prazo de validade expirado
			Collection<Conta> colecaoConta = repositorioFaturamento.pesquisarContasRevisaoPrazoVencido();

			// Retira as contas consultadas de revisão
			Collection<ContaRetiradaRevisaoHelper> colecaoContasParaRelatorio = this.retirarRevisaoConta(colecaoConta, null, usuario);
			
			RelatorioContasRetiradasRevisao relatorioContasRetiradasRevisao = new RelatorioContasRetiradasRevisao(usuario);
			Collections.sort((List<ContaRetiradaRevisaoHelper>) colecaoContasParaRelatorio);
			relatorioContasRetiradasRevisao.addParametro("colecaoContasRetiradasRevisao", colecaoContasParaRelatorio);
			relatorioContasRetiradasRevisao.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);

			getControladorBatch().iniciarProcessoRelatorio(relatorioContasRetiradasRevisao);

			this.getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
		}catch(Exception e){
			e.printStackTrace();
			this.getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}finally{
			System.out.println("******FIM DA REMOÇÃO DE CONTAS EM REVISÃO COM PRAZO VENCIDO******");

		}
	}

	/**
	 * Verifica se existem dados para processamento do Relatório Mapa Controle Contas
	 * 
	 * @author Hugo Lima
	 * @date 10/07/2012
	 * @param idGrupoFaturamento
	 * @param mesAno
	 * @param indicadorFichaCompensacao
	 * @return
	 * @throws ControladorException
	 */
	public void verificarDadosMapaControleContaRelatorio(Integer idGrupoFaturamento, String mesAno, String indicadorFichaCompensacao)
					throws ControladorException{

		try{
			Collection colecaoObjeto = repositorioFaturamento.filtrarMapaControleContaRelatorio(idGrupoFaturamento,
							Util.formatarMesAnoParaAnoMes(mesAno), indicadorFichaCompensacao);

			if(colecaoObjeto.isEmpty()){
				throw new ControladorException("atencao.relatorio.vazio");
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC3061] Gerar Relatório Posição do Débito da Negativação – Legado CASAL
	 * Pesquisar as contas em processo de negativação e já transferidas para o histórico
	 * 
	 * @date 28/07/2012
	 * @author Hebert Falcão
	 */
	public Collection pesquisarContaEmProcessoNegativacao(Integer anoMesFaturamento) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarContaEmProcessoNegativacao(anoMesFaturamento);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Verificar e Atualizar Itens Documento de Cobrança e da Cobrança Administrativa - Conta
	 * 
	 * @date 17/08/2012
	 * @author Hebert Falcão
	 */
	public void atualizarCobrancaDocumentoItemContaCobrancaAdministrativa(Collection<Integer> colecaoContaId) throws ControladorException{

		if(!Util.isVazioOrNulo(colecaoContaId)){
			Collection<CobrancaDocumento> colecaoCobrancaDocumentoAdm = new ArrayList<CobrancaDocumento>();

			Integer idCobrancaDocumento = null;

			Collection<Integer> colecaoCobrancaDocumentoId = new ArrayList<Integer>();
			Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItem = null;

			CobrancaDocumento cobrancaDocumento = null;

			FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItem = null;

			for(Integer idContaAux : colecaoContaId){
				filtroCobrancaDocumentoItem = new FiltroCobrancaDocumentoItem();
				filtroCobrancaDocumentoItem
								.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.CONTA_GERAL_ID, idContaAux));
				filtroCobrancaDocumentoItem.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO);
				filtroCobrancaDocumentoItem
								.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ATIVIDADE_COMANDO);

				colecaoCobrancaDocumentoItem = this.getControladorUtil().pesquisar(filtroCobrancaDocumentoItem,
								CobrancaDocumentoItem.class.getName());

				if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){
					for(CobrancaDocumentoItem cobrancaDocumentoItem : colecaoCobrancaDocumentoItem){
						// Se o Item em questão Pertencer a Cobrança Administrativa
						cobrancaDocumento = cobrancaDocumentoItem.getCobrancaDocumento();
						idCobrancaDocumento = cobrancaDocumento.getId();

						if(!colecaoCobrancaDocumentoId.contains(idCobrancaDocumento)){
							colecaoCobrancaDocumentoAdm.add(cobrancaDocumento);
							colecaoCobrancaDocumentoId.add(idCobrancaDocumento);
						}
					}
				}
			}

			this.atualizarImovelCobrancaSituacaoEmCobrancaAdministrativa(colecaoCobrancaDocumentoAdm);
		}
	}

	/**
	 * Verificar e Atualizar Itens Documento de Cobrança e da Cobrança Administrativa - Guia
	 * 
	 * @date 17/08/2012
	 * @author Hebert Falcão
	 */
	public void atualizarCobrancaDocumentoItemGuiaCobrancaAdministrativa(Collection<GuiaPagamento> colecaoGuiaPagamento)
					throws ControladorException{

		if(!Util.isVazioOrNulo(colecaoGuiaPagamento)){
			Collection<CobrancaDocumento> colecaoCobrancaDocumento = new ArrayList<CobrancaDocumento>();

			Short numeroPrestacao = null;

			Integer idCobrancaDocumento = null;
			Integer idGuiaPagamento = null;

			Collection<Integer> colecaoCobrancaDocumentoId = new ArrayList<Integer>();
			Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItem = null;

			CobrancaDocumento cobrancaDocumento = null;
			GuiaPagamentoPrestacaoPK compId = null;

			FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItem = null;

			Set<GuiaPagamentoPrestacao> guiasPagamentoPrestacao = null;

			for(GuiaPagamento guiaPagamento : colecaoGuiaPagamento){
				idGuiaPagamento = guiaPagamento.getId();

				guiasPagamentoPrestacao = guiaPagamento.getGuiasPagamentoPrestacao();

				if(guiasPagamentoPrestacao != null){
					for(GuiaPagamentoPrestacao guiaPagamentoPrestacao : guiasPagamentoPrestacao){
						compId = guiaPagamentoPrestacao.getComp_id();
						numeroPrestacao = compId.getNumeroPrestacao();

						filtroCobrancaDocumentoItem = new FiltroCobrancaDocumentoItem();
						filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(
										FiltroCobrancaDocumentoItem.GUIA_PAGAMENTO_GERAL_ID, idGuiaPagamento));
						filtroCobrancaDocumentoItem.adicionarParametro(new ParametroSimples(
										FiltroCobrancaDocumentoItem.NUMERO_DA_PRESTACAO, numeroPrestacao));
						filtroCobrancaDocumentoItem
										.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO);
						filtroCobrancaDocumentoItem
										.adicionarCaminhoParaCarregamentoEntidade(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ATIVIDADE_COMANDO);

						colecaoCobrancaDocumentoItem = this.getControladorUtil().pesquisar(filtroCobrancaDocumentoItem,
										CobrancaDocumentoItem.class.getName());

						if(!Util.isVazioOrNulo(colecaoCobrancaDocumentoItem)){
							for(CobrancaDocumentoItem cobrancaDocumentoItem : colecaoCobrancaDocumentoItem){
								// Se o Item em questão Pertencer a Cobrança Administrativa
								cobrancaDocumento = cobrancaDocumentoItem.getCobrancaDocumento();
								idCobrancaDocumento = cobrancaDocumento.getId();

								if(!colecaoCobrancaDocumentoId.contains(idCobrancaDocumento)){
									colecaoCobrancaDocumento.add(cobrancaDocumento);
									colecaoCobrancaDocumentoId.add(idCobrancaDocumento);
								}
							}
						}
					}
				}
			}

			this.atualizarImovelCobrancaSituacaoEmCobrancaAdministrativa(colecaoCobrancaDocumento);
		}
	}

	/**
	 * Atualizar Imovel Cobrança Situação em Cobrança Administrativa
	 * 
	 * @date 17/08/2012
	 * @author Hebert Falcão
	 */
	public void atualizarImovelCobrancaSituacaoEmCobrancaAdministrativa(Collection<CobrancaDocumento> colecaoCobrancaDocumento)
					throws ControladorException{

		if(!Util.isVazioOrNulo(colecaoCobrancaDocumento)){
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			Integer anoMesArrecadacao = sistemaParametro.getAnoMesArrecadacao();

			CobrancaAcao cobrancaAcao = null;
			Imovel imovel = null;
			CobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando = null;

			Integer idCobrancaAcao = null;
			Integer idImovel = null;
			Integer idCobrancaAcaoAtividadeComando = null;
			Integer idCobrancaDocumento = null;

			FiltroCobrancaDocumentoItem filtroCobrancaDocumentoItemAux = null;
			FiltroImovelCobrancaSituacao filtroImovelCobrancaSituacao = null;

			Collection<CobrancaDocumentoItem> colecaoCobrancaDocumentoItemAux = null;
			Collection<ImovelCobrancaSituacao> colecaoImovelCobrancaSituacao = null;

			Collection<Object> colecaoImovelCobrancaSituacaoAtualizar = new ArrayList<Object>();

			for(CobrancaDocumento cobrancaDocumentoAux : colecaoCobrancaDocumento){
				idCobrancaDocumento = cobrancaDocumentoAux.getId();
				cobrancaAcaoAtividadeComando = cobrancaDocumentoAux.getCobrancaAcaoAtividadeComando();

				imovel = cobrancaDocumentoAux.getImovel();

				if(imovel != null){
					idImovel = imovel.getId();
				}else{
					idImovel = null;
				}

				cobrancaAcao = cobrancaDocumentoAux.getCobrancaAcao();

				if(cobrancaAcao != null){
					idCobrancaAcao = cobrancaAcao.getId();
				}else{
					idCobrancaAcao = null;
				}

				if(cobrancaAcaoAtividadeComando != null && idImovel != null && idCobrancaAcao != null
								&& idCobrancaAcao.equals(CobrancaAcao.COBRANCA_ADMINISTRATIVA)){
					idCobrancaAcaoAtividadeComando = cobrancaAcaoAtividadeComando.getId();

					filtroImovelCobrancaSituacao = new FiltroImovelCobrancaSituacao();
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(
									FiltroImovelCobrancaSituacao.COBRANCA_ACAO_ATIVIDADE_COMANDO_ID, idCobrancaAcaoAtividadeComando));
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroSimples(FiltroImovelCobrancaSituacao.IMOVEL_ID, idImovel));
					filtroImovelCobrancaSituacao.adicionarParametro(new ParametroNulo(FiltroImovelCobrancaSituacao.DATA_RETIRADA_COBRANCA));

					colecaoImovelCobrancaSituacao = this.getControladorUtil().pesquisar(filtroImovelCobrancaSituacao,
									ImovelCobrancaSituacao.class.getName());

					if(!Util.isVazioOrNulo(colecaoImovelCobrancaSituacao)){
						filtroCobrancaDocumentoItemAux = new FiltroCobrancaDocumentoItem();
						filtroCobrancaDocumentoItemAux.adicionarParametro(new ParametroSimples(
										FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ID, idCobrancaDocumento));
						filtroCobrancaDocumentoItemAux.adicionarParametro(new ParametroSimples(
										FiltroCobrancaDocumentoItem.COBRANCA_DEBITO_SITUACAO_ID, CobrancaDebitoSituacao.PENDENTE));

						colecaoCobrancaDocumentoItemAux = this.getControladorUtil().pesquisar(filtroCobrancaDocumentoItemAux,
										CobrancaDocumentoItem.class.getName());

						if(Util.isVazioOrNulo(colecaoCobrancaDocumentoItemAux)){
							for(ImovelCobrancaSituacao imovelCobrancaSituacao : colecaoImovelCobrancaSituacao){
								imovelCobrancaSituacao.setDataAdimplencia(new Date());
								imovelCobrancaSituacao.setAnoMesAdimplencia(anoMesArrecadacao);
								imovelCobrancaSituacao.setUltimaAlteracao(new Date());

								colecaoImovelCobrancaSituacaoAtualizar.add(imovelCobrancaSituacao);
							}
						}
					}
				}
			}

			this.getControladorUtil().atualizarColecaoObjetos(colecaoImovelCobrancaSituacaoAtualizar);
		}
	}

	/**
	 * Verifica o proprietario das contas,
	 * 
	 * @param idConta
	 * @param matricula
	 * @throws ErroRepositorioException
	 * @throws FachadaException
	 */
	public void verificarPermissaoImovelConta(Integer idConta, Integer matriculaImovel) throws ControladorException,
					ErroRepositorioException{

		try{

			if(!repositorioFaturamento.existePermissaoImovelConta(idConta, matriculaImovel)){
				throw new ControladorException("A conta " + idConta + " não pertence ao imovel " + matriculaImovel);
			}
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Retorna a lista de ids tipos de debitos dos itens de parcelamento (prestacoes)
	 * 
	 * @author Hugo Lima
	 * @date 15/08/2012
	 * @param idParcelamento
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Integer> obterDebitosGuiasPagamentoPrestacoesParcelamento(Integer idParcelamento) throws ControladorException{

		try{
			return repositorioFaturamento.obterDebitosGuiasPagamentoPrestacoesParcelamento(idParcelamento);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @author Diogo Monteiro
	 * @date 03/09/2012
	 * @param anoMesFaturamento
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Integer> obterValorTotalContasSelicionadas(String anoMesFaturamento) throws ControladorException{

		try{
			return repositorioFaturamento.obterValorTotalContasSelicionadas(anoMesFaturamento);

		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0188] Manter Guia de Pagamento
	 * [SB0005] – Validar autorização de acesso a prestação da guia de imóvel
	 * 
	 * @author Hugo Lima
	 * @date 21/08/2012
	 * @param usuario
	 * @param idImovel
	 * @param colecaoGuiaPagamentoHelper
	 * @throws ControladorException
	 */
	public void validarAutorizacaoAcessoPrestacaoGuiaImovel(Usuario usuario, Integer idImovel,
					Collection<GuiaPagamentoPrestacaoHelper> colecaoGuiaPagamentoPrestacaoHelper) throws ControladorException{

		String mensagemListaPrestacoes = "";
		String conector = "";
		boolean existeOcorrenciaCobrancaAdministrativa = false;
		Collection<Integer> colecaoIdsGuiasRemover = null;

		try{

			// [SB0006] – Validar autorização de acesso ao imóvel pelos usuários das empresas de
			// cobrança administrativa
			if(this.getControladorImovel()
							.obterValidacaoAutorizacaoAcessoImovelCobrancaAdministrativa(usuario, Integer.valueOf(idImovel),
											ConstantesSistema.CODIGO_VALIDACAO_USUARIO_EMPRESA_COBRANCA_ADMINISTRATIVA)
							.equals(ConstantesSistema.NAO)){
				throw new ControladorException("atencao.usuario_empresa_cobranca_administrativa_sem_acesso_imovel_guia", null,
								usuario.getNomeUsuario(), idImovel.toString());
			}

			// [SB0007] – Validar autorização de acesso ao imóvel em cobrança administrativa pelos
			// usuários da empresa contratante
			for(GuiaPagamentoPrestacaoHelper guiaPagamentoPrestacaoHelper : colecaoGuiaPagamentoPrestacaoHelper){
				if(guiaPagamentoPrestacaoHelper.getIndicadorCobrancaAdministrativa().equals(ConstantesSistema.SIM)){
					existeOcorrenciaCobrancaAdministrativa = true;
					break;
				}
			}

			if(existeOcorrenciaCobrancaAdministrativa
							&& this.getControladorImovel()
											.obterValidacaoAutorizacaoAcessoImovelCobrancaAdministrativa(usuario,
															Integer.valueOf(idImovel),
															ConstantesSistema.CODIGO_VALIDACAO_USUARIO_EMPRESA_CONTRATANTE)
											.equals(ConstantesSistema.NAO)){
				throw new ControladorException("atencao.usuario_empresa_sem_acesso_imovel_guia_cobranca_administrativa", null,
								idImovel.toString(), usuario.getNomeUsuario());
			}

			// [SB0008] – Verificar Débito em Cobrança Administrativa
			// 1. Caso o usuário logado pertença a uma empresa de cobrança administrativa
			if(this.getControladorCobranca().existeEmpresaCobrancaContrato(usuario.getEmpresa().getId())){

				colecaoIdsGuiasRemover = this.repositorioCobranca.obterIdsGuiasPagamentoCobrancaAdministrativaEmpresaDiferente(usuario
								.getEmpresa().getId(), idImovel);

				if(!Util.isVazioOrNulo(colecaoIdsGuiasRemover)){
					// Armazena os ids de guias e suas prestacoes em uma lista para a
					// comparacao
					ArrayList<Hashtable<Integer, Short>> listaGuiasPrestacaoRemover = new ArrayList<Hashtable<Integer, Short>>();
					Iterator dadosGuias = colecaoIdsGuiasRemover.iterator();
					while(dadosGuias.hasNext()){
						Object[] dadoGuia = (Object[]) dadosGuias.next();
						Hashtable<Integer, Short> hashGuiaPrestacao = new Hashtable<Integer, Short>();
						hashGuiaPrestacao.put((Integer) dadoGuia[0], (Short) dadoGuia[1]);
						listaGuiasPrestacaoRemover.add(hashGuiaPrestacao);
					}

					// Caso a hsatable que representa a guia prestação atual esteja contida
					// na lista de guias prestação nao permitidas essa é excluida da colecao
					for(GuiaPagamentoPrestacaoHelper guiaPagamentoPrestacaoHelper : colecaoGuiaPagamentoPrestacaoHelper){

						Hashtable<Integer, Short> hashGuiaPrestacaoAtual = new Hashtable<Integer, Short>();
						hashGuiaPrestacaoAtual.put(guiaPagamentoPrestacaoHelper.getIdGuiaPagamento(),
										guiaPagamentoPrestacaoHelper.getNumeroPrestacao());

						if(listaGuiasPrestacaoRemover.contains(hashGuiaPrestacaoAtual)){
							mensagemListaPrestacoes = mensagemListaPrestacoes + conector
											+ guiaPagamentoPrestacaoHelper.getNumeroPrestacao();
							conector = ", ";
						}
					}

					if(!Util.isVazioOuBranco(mensagemListaPrestacoes)){
						throw new ControladorException("atencao.usuario_empresa_sem_acesso_prestacoes_guia_cobranca_administrativa", null,
										usuario.getNomeUsuario(), mensagemListaPrestacoes,
										((GuiaPagamentoPrestacaoHelper) Util.retonarObjetoDeColecao(colecaoGuiaPagamentoPrestacaoHelper))
														.getIdGuiaPagamento().toString());
					}
				}

			}
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Count do Gerar Relacao Acompanhamento Faturamento
	 * [UC0336] GerarRelacaoAcompanhamentoFaturamento
	 * 
	 * @author Jose Claudio
	 * @date 29/08/2012
	 */
	public Integer gerarRelacaoAcompanhamentoFaturamentoCount(String idImovelCondominio, String idImovelPrincipal, String idNomeConta,
					String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
					String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
					String intervaloValorPercentualEsgotoInicial, String intervaloValorPercentualEsgotoFinal,
					String intervaloMediaMinimaImovelInicial, String intervaloMediaMinimaImovelFinal,
					String intervaloMediaMinimaHidrometroInicial, String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
					String idPocoTipo, String idFaturamentoSituacaoTipo, String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
					String idEloAnormalidade, String areaConstruidaInicial, String areaConstruidaFinal, String idCadastroOcorrencia,
					String idConsumoTarifa, String idGerenciaRegional, String idLocalidadeInicial, String idLocalidadeFinal,
					String setorComercialInicial, String setorComercialFinal, String quadraInicial, String quadraFinal, String loteOrigem,
					String loteDestno, String cep, String logradouro, String bairro, String municipio, String idTipoMedicao,
					String indicadorMedicao, String idSubCategoria, String idCategoria, String quantidadeEconomiasInicial,
					String quantidadeEconomiasFinal, String diaVencimento, String idCliente, String idClienteTipo,
					String idClienteRelacaoTipo, String numeroPontosInicial, String numeroPontosFinal, String numeroMoradoresInicial,
					String numeroMoradoresFinal, String idAreaConstruidaFaixa, int anoMesReferencia, String consumoFixadoEsgotoPocoInicial,
					String consumoFixadoEsgotoPocoFinal) throws ControladorException{

		try{
			return repositorioFaturamento.gerarRelacaoAcompanhamentoFaturamentoCount(idImovelCondominio, idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua, consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto, intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal, intervaloMediaMinimaImovelInicial, intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial, intervaloMediaMinimaHidrometroFinal, idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo, idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa, idGerenciaRegional,
							idLocalidadeInicial, idLocalidadeFinal, setorComercialInicial, setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro, municipio, idTipoMedicao, indicadorMedicao, idSubCategoria,
							idCategoria, quantidadeEconomiasInicial, quantidadeEconomiasFinal, diaVencimento, idCliente, idClienteTipo,
							idClienteRelacaoTipo, numeroPontosInicial, numeroPontosFinal, numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa, consumoFixadoEsgotoPocoInicial, consumoFixadoEsgotoPocoFinal);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

	}


	/**
	 * [UC00084] Gerar Faturamento Imediato
	 * [SB0008 - Selecionar Imóveis para Faturamento Imediato
	 */
	public Short selecionarImovelParaFaturamentoImediato(Imovel imovel, Integer anoMesReferencia, SistemaParametro sistemaParametro,
					Collection colecaoFaturamentoAtividadeCriterio, int idFuncionalidade) throws ControladorException{

		Short selecionarImovelFaturamentoImediato = ConstantesSistema.SIM;

		try{

			// [SB0009 - Verificar Ocorrência Situação Especial de Faturamento
			selecionarImovelFaturamentoImediato = this.verificarImovelSituacaoEspecialFaturamento(imovel, anoMesReferencia,
							sistemaParametro);

			if(selecionarImovelFaturamentoImediato.equals(ConstantesSistema.SIM)){

				// [SB0010 - Verificar Geração de Conta Pré-Faturada
				selecionarImovelFaturamentoImediato = this.verificarGeracaoContaPreFaturada(imovel, anoMesReferencia, sistemaParametro,
								idFuncionalidade);

				if(selecionarImovelFaturamentoImediato.equals(ConstantesSistema.SIM)){

					// [UC3010 - Verificar Atendimento do Critério do Faturamento Imediato
					Short indicadorAtendimentoCriterios = this.getControladorMicromedicao().verificarAtendimentoCriterioFaturamentoImovel(
									imovel, colecaoFaturamentoAtividadeCriterio);

					if(indicadorAtendimentoCriterios.equals(ConstantesSistema.NAO)){

						String parametroSituacaoLigAguaNaoAtendeCriterio = ((String) ParametroFaturamento.P_SIT_LIG_AGUA_SELECIONAR_IMOVEL_QUE_NAO_ATENDE_CRITERIO
										.executar(this));

						String[] parametroSituacaoLigAguaNaoAtendeCriterioArray = null;
						parametroSituacaoLigAguaNaoAtendeCriterioArray = parametroSituacaoLigAguaNaoAtendeCriterio.split(",");
						Collection<String> colecaoSituacoesLigacaoAguaParametrizadas = new ArrayList<String>();

						if(!Util.isVazioOrNulo(parametroSituacaoLigAguaNaoAtendeCriterioArray)){

							colecaoSituacoesLigacaoAguaParametrizadas = Arrays.asList(parametroSituacaoLigAguaNaoAtendeCriterioArray);
						}

						/*
						 * Caso exista indicação de selecionar o imóvel que não satisfaz nenhum
						 * dos critérios em razão da situação da ligação de água e a situação da
						 * ligação de água do imóvel não corresponda a uma dessas situações
						 */
						if(Util.verificarIdNaoVazio(parametroSituacaoLigAguaNaoAtendeCriterio)
										&& !colecaoSituacoesLigacaoAguaParametrizadas.contains(imovel.getLigacaoAguaSituacao().getId()
														.toString())){

							// Não selecionar o imóvel para faturamento imediato
							selecionarImovelFaturamentoImediato = ConstantesSistema.NAO;
						}else{

							/*
							 * Caso esteja indicado, nos parâmetros do sistema, que seja
							 * gerada fiscalização de leitura. Caso contrário, não selecionar o
							 * imóvel para faturamento imediato
							 */
							if(verificarImovelSituacaoFiscalizacaoLeituraFaturamentoImediato(imovel, sistemaParametro) == false){

								selecionarImovelFaturamentoImediato = ConstantesSistema.NAO;
							}
						}
					}
				}
			}

		}catch(ErroRepositorioException e){

			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

		return selecionarImovelFaturamentoImediato;
	}

	/**
	 * [UC00084] Gerar Faturamento Imediato
	 * [SB0010 - Verificar Geração de Conta Pré-Faturada
	 * 
	 * @throws ControladorException
	 */
	private Short verificarGeracaoContaPreFaturada(Imovel imovel, Integer anoMesReferencia, SistemaParametro sistemaParametro,
					int idFuncionalidade) throws ControladorException{

		// Caso o imóvel satisfaça uma das condições, não selecionar o imóvel para faturamento
		// imediato
		Short selecionarImovelFaturamentoImediato = ConstantesSistema.SIM;

		try{

			// Verifica se existe conta para o imóvel com referência ao faturamento mês corrente.
			if(repositorioFaturamento.pesquisarExistenciaConta(imovel, anoMesReferencia) != null){

				selecionarImovelFaturamentoImediato = ConstantesSistema.NAO;
			}else if(repositorioFaturamento.pesquisarExistenciaContaHistoricoComSituacaoAtual(imovel, anoMesReferencia) != null){

				// Verifica se existe conta no histórico para o imóvel com referência ao faturamento
				// mês corrente.
				selecionarImovelFaturamentoImediato = ConstantesSistema.NAO;
			}else{

				// Verifica se imóvel é não medido.
				if(verificarImovelNaoMedido(imovel)){

					Short indicadorNaoEmitirNaoMedido = new Short(
									(String) ParametroFaturamento.P_INDICADOR_EMISSAO_NAO_MEDIDO_FATURAMENTO_IMEDIATO.executar(this));

					// Caso esteja indicado para não emitir não medido
					if(indicadorNaoEmitirNaoMedido.equals(ConstantesSistema.NAO)){

						selecionarImovelFaturamentoImediato = ConstantesSistema.NAO;
					}
				}
			}

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return selecionarImovelFaturamentoImediato;
	}

	/**
	 * [UC00084] Gerar Faturamento Imediato
	 * [SB0009] - Verificar Ocorrência Situação Especial de Faturamento
	 */
	private Short verificarImovelSituacaoEspecialFaturamento(Imovel imovel, Integer anoMesReferencia, SistemaParametro sistemaParametro)
					throws ControladorException{

		Short selecionarImovelFaturamentoImediato = ConstantesSistema.SIM;

		try{

			// Caso o imóvel possua algum tipo de situação especial de faturamento
			if(imovel.getFaturamentoSituacaoTipo() != null){

				// Verifica se há situação especial de faturamento para o Imóvel em vigência
				Collection<FaturamentoSituacaoHistorico> situacoesVigentesImovel = repositorioFaturamento
								.pesquisarFaturamentoSituacaoHistoricoImovel(imovel.getId(), anoMesReferencia);

				if(!Util.isVazioOrNulo(situacoesVigentesImovel)){

					for(FaturamentoSituacaoHistorico faturamentoSituacaoHistorico : situacoesVigentesImovel){

						// Caso o tipo de situação especial indique que não deve ser realizada
						// leitura
						if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo() != null
										&& FaturamentoSituacaoTipo.INDICADOR_PARALIZACAO_LEITURA_NAO_REALIZADA
														.equals(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
																		.getIndicadorParalisacaoLeitura())){

							// Não selecionar o imóvel para o faturamento imediato e passar para o
							// próximo imóvel da rota
							selecionarImovelFaturamentoImediato = ConstantesSistema.NAO;
						}
					}
				}

			}

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return selecionarImovelFaturamentoImediato;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento
	 * [UC0088] Registrar Faturamento Imediato
	 * Verifica perda do beneficio da Tarifa Social <br>
	 * <br>
	 * [FS0011] – Verifica perda do beneficio da Tarifa Social
	 * - Caso o Id da tarifa temporária selecionada seja referente à Tarifa Social (PASI_VLPARAMETRO
	 * da tabela PARAMETRO_SISTEMA com PASI_DSPARAMETRO="P_TARIFA_CONSUMO _TARIFA_SOCIAL"):
	 * • Obter “Consumo máximo” (PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com PASI_DSPARAMETRO =
	 * ”P_CONSUMO_MAXIMO_BENEFICIO_TARIFA_SOCIAL”);
	 * • Caso o consumo medido no mês seja maior que Consumo máximo, o imóvel não será beneficiado
	 * com a tarifa social, atribuir a tarifa Padrão (CSTF_ID da tabela IMOVEL).
	 * 
	 * @author Hebert Falcão
	 * @date 29/09/2012
	 */
	public ConsumoTarifa verificarPerdaBeneficioDaTarifaSocialParaFaturamento(Integer consumoMedido, Integer consumoMinimo, Imovel imovel)
					throws ControladorException{

		ConsumoTarifa retorno = imovel.getConsumoTarifaTemporaria();

		String parametroTarifaSocial = ParametroCadastro.P_TARIFA_CONSUMO_TARIFA_SOCIAL.executar();

		if(imovel.getConsumoTarifaTemporaria().getId().toString().equals(parametroTarifaSocial)){

			if(consumoMedido > consumoMinimo){

				log.info("IMOVEL[" + imovel.getId() + "] perdeu beneficio TARIFA SOCIAL. ");
				retorno = imovel.getConsumoTarifa();
			}
		}

		return retorno;
	}

	/**
	 * [UC0084] - Gerar Faturamento Imediato
	 * 
	 * @author eduardo henrique
	 * @date 30/09/2008
	 *       Obtém o FaturamentoAtivCronogramaRota de um determinado grupo de AnoMesReferencia,
	 *       AtividadeFaturamento, FaturamentoGrupo e Rota
	 * @throws ControladorException
	 */
	public FaturamentoAtivCronRota obterFaturamentoAtividadeCronogramaPorGrupoFaturamentoRota(Integer idAtividadeComandoFaturamento,
					Integer anoMesReferenciaComandoFaturamento, FaturamentoGrupo faturamentoGrupo, Rota rota) throws ControladorException{

		try{
			FiltroFaturamentoAtividadeCronograma filtroFaturamentoAtividadeCronograma = new FiltroFaturamentoAtividadeCronograma();
			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, idAtividadeComandoFaturamento));
			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA,
							anoMesReferenciaComandoFaturamento));
			filtroFaturamentoAtividadeCronograma.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtividadeCronograma.FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID, faturamentoGrupo
											.getId()));
			Collection colecaoAtividadeCronograma = getControladorUtil().pesquisar(filtroFaturamentoAtividadeCronograma,
							FaturamentoAtividadeCronograma.class.getName());
			FaturamentoAtividadeCronograma atividadeCronograma = (FaturamentoAtividadeCronograma) Util
							.retonarObjetoDeColecao(colecaoAtividadeCronograma);
			if(atividadeCronograma == null){
				return null;
			}
			FiltroFaturamentoAtivCronRota filtroFaturamentoAtivCronRota = new FiltroFaturamentoAtivCronRota();
			filtroFaturamentoAtivCronRota
							.adicionarCaminhoParaCarregamentoEntidade(FiltroFaturamentoAtivCronRota.FATURAMENTO_ATIVIDADE_CRONOGRAMA);
			filtroFaturamentoAtivCronRota.adicionarCaminhoParaCarregamentoEntidade(FiltroFaturamentoAtivCronRota.COMP_ID_ROTA);
			filtroFaturamentoAtivCronRota
							.adicionarCaminhoParaCarregamentoEntidade(FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_GRUPO_FATURAMENTO);
			filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(
							FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_ID, atividadeCronograma.getId()));
			filtroFaturamentoAtivCronRota.adicionarParametro(new ParametroSimples(FiltroFaturamentoAtivCronRota.COMP_ID_ROTA_ID, rota
							.getId()));
			filtroFaturamentoAtivCronRota
							.adicionarCaminhoParaCarregamentoEntidade(FiltroFaturamentoAtivCronRota.COMP_ID_FATURAMENTO_ATIVIDADE_CRONOGRAMA_FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL);

			Collection colecaoAtividadeCronogramaRota = getControladorUtil().pesquisar(filtroFaturamentoAtivCronRota,
							FaturamentoAtivCronRota.class.getName());
			FaturamentoAtivCronRota atividadeCronogramaRota = (FaturamentoAtivCronRota) Util
							.retonarObjetoDeColecao(colecaoAtividadeCronogramaRota);

			return atividadeCronogramaRota;
		}catch(Exception ex){
			throw new ControladorException("erro.atividade_cronograma_rota_nao_encontrada", ex, rota.getId().toString());
		}
	}

	/**
	 * [UC0084] - Gerar Faturamento Imediato [SB0007] - Gerar Movimento Roteiro de Empresa
	 * 
	 * @author eduardo henrique, Yara Souza
	 * @date 22/09/2008, 18/08/2011
	 *       Realiza a geração dos Dados na Tabela de Integração com Gestão de Leituristas.
	 * @throws ControladorException
	 */
	private void gerarMovimentoRoteiroEmpresaImoveisPreFaturamento(Collection<Imovel> colecaoImoveis, FaturamentoGrupo faturamentoGrupo,
					SistemaParametro sistemaParametro, Integer anoMesReferenciaFaturamento) throws ControladorException{

		try{

			log.info("..........Gerando Movimento Roteiro Empresa do Grupo/Referência: " + faturamentoGrupo.getId().toString() + "/"
							+ anoMesReferenciaFaturamento.toString());

			Collection colecaoMovimentoRoteiroInserir = new ArrayList<MovimentoRoteiroEmpresa>();
			MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = null;
			Integer ultimoConsumoFaturadoMes = null;
			boolean reparticaoPublicaFederal = false;
			Integer idClientePublicoFederal = null;

			for(Iterator iterator = colecaoImoveis.iterator(); iterator.hasNext();){

				Imovel imovel = (Imovel) iterator.next();

				// Checa se já existe movimento para o imóvel na referência do faturamento corrente
				if(anoMesReferenciaFaturamento != null){

					movimentoRoteiroEmpresa = repositorioMicromedicao.obterMovimentoRoteiroPorImovel(imovel, anoMesReferenciaFaturamento);

					if(movimentoRoteiroEmpresa != null){

						continue;
					}
				}

				log.info("........................Populando Movimento Roteiro Empresa na Coleção => imov_id = " + imovel.getId().toString());

				movimentoRoteiroEmpresa = new MovimentoRoteiroEmpresa();
				movimentoRoteiroEmpresa.setAnoMesMovimento(anoMesReferenciaFaturamento);

				ConsumoTipo consumoTipo = new ConsumoTipo();
				consumoTipo.setId(ConsumoTipo.INDEFINIDO);
				movimentoRoteiroEmpresa.setConsumoTipo(consumoTipo);

				if(imovel.getQuadra() != null){
					movimentoRoteiroEmpresa.setRota(imovel.getRota());

					if(imovel.getRota() != null){
						movimentoRoteiroEmpresa.setCodigoRota(imovel.getRota().getCodigo());
					}

					if(imovel.getRota() != null && imovel.getRota().getEmpresa() != null){
						movimentoRoteiroEmpresa.setEmpresa(imovel.getRota().getEmpresa());
					}

					if(imovel.getRota() != null && imovel.getRota().getLeiturista() != null
									&& imovel.getRota().getLeiturista().getId() != null){
						movimentoRoteiroEmpresa.setLeiturista(imovel.getRota().getLeiturista());
					}

					movimentoRoteiroEmpresa.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
				}

				movimentoRoteiroEmpresa.setFaturamentoGrupo(faturamentoGrupo);
				movimentoRoteiroEmpresa.setLocalidade(imovel.getLocalidade());
				if(imovel.getSetorComercial() != null){
					movimentoRoteiroEmpresa.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
				}
				movimentoRoteiroEmpresa.setNumeroLoteImovel(Short.valueOf(imovel.getLote()));
				movimentoRoteiroEmpresa.setNumeroSubLoteImovel(Short.valueOf(imovel.getSubLote()));

				if(imovel.getInscricaoFormatada() != null){
					movimentoRoteiroEmpresa.setNumeroInscricao(imovel.getInscricaoFormatada());
				}

				movimentoRoteiroEmpresa.setImovel(imovel);

				try{
					Cliente clienteConta = repositorioClienteImovel.pesquisarClienteImovelNomeConta(imovel.getId());
					if(clienteConta != null) movimentoRoteiroEmpresa.setNomeCliente(Util.completaString(clienteConta.getNome(), 25));
				}catch(ErroRepositorioException e){
					throw new ControladorException("erro.sistema", e);
				}

				String enderecoImovel[] = getControladorEndereco().pesquisarEnderecoFormatadoDividido(imovel.getId(), 50);
				if(enderecoImovel != null){
					if(enderecoImovel[0] != null){
						movimentoRoteiroEmpresa.setEnderecoImovel(Util.completaString(enderecoImovel[0], 50));
					}else{
						movimentoRoteiroEmpresa.setEnderecoImovel(Util.completaString("", 50));
					}
					if(enderecoImovel[6] != null){
						movimentoRoteiroEmpresa.setComplementoEnderecoImovel(Util.completaString(enderecoImovel[6], 13));
					}else{
						movimentoRoteiroEmpresa.setComplementoEnderecoImovel(Util.completaString("", 13));
					}
					if(enderecoImovel[4] != null){
						movimentoRoteiroEmpresa.setCepEnderecoImovel(Util.completaString(enderecoImovel[4], 10));
					}else{
						movimentoRoteiroEmpresa.setCepEnderecoImovel(Util.completaString("", 10));
					}
					if(enderecoImovel[3] != null){
						movimentoRoteiroEmpresa.setBairroEnderecoImovel(Util.completaString(enderecoImovel[3], 30));
					}else{
						movimentoRoteiroEmpresa.setBairroEnderecoImovel(Util.completaString("", 30));
					}
					if(enderecoImovel[1] != null){
						movimentoRoteiroEmpresa.setMunicipioEnderecoImovel(Util.completaString(enderecoImovel[1], 30));
					}else{
						movimentoRoteiroEmpresa.setMunicipioEnderecoImovel(Util.completaString("", 30));
					}
				}

				if(imovel.getQuadra().getAreaTipo() != null && imovel.getQuadra().getAreaTipo().getDescricao() != null){
					movimentoRoteiroEmpresa.setZonaTerritorial(Util.completaString(imovel.getQuadra().getAreaTipo().getDescricao(), 15));
				}else{
					movimentoRoteiroEmpresa.setZonaTerritorial(Util.completaString("", 15));
				}

				Collection<Categoria> colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
				for(Categoria categoria : colecaoCategoriasImovel){
					switch(categoria.getId().intValue()){
						case Categoria.RESIDENCIAL_INT:
							movimentoRoteiroEmpresa.setQuantidadeEconomiasResidencial(Short.valueOf(categoria
											.getQuantidadeEconomiasCategoria().shortValue()));
							break;
						case Categoria.COMERCIAL_INT:
							movimentoRoteiroEmpresa.setQuantidadeEconomiasComercial(Short.valueOf(categoria
											.getQuantidadeEconomiasCategoria().shortValue()));
							break;
						case Categoria.INDUSTRIAL_INT:
							movimentoRoteiroEmpresa.setQuantidadeEconomiasIndustrial(Short.valueOf(categoria
											.getQuantidadeEconomiasCategoria().shortValue()));
							break;
						case Categoria.PUBLICO_INT:
							movimentoRoteiroEmpresa.setQuantidadeEconomiasPublica(Short.valueOf(categoria.getQuantidadeEconomiasCategoria()
											.shortValue()));
							break;
					}
				}

				if(imovel.getLigacaoAguaSituacao() != null && imovel.getLigacaoAguaSituacao().getId() != null){
					movimentoRoteiroEmpresa.setLigacaoAguaSituacao(imovel.getLigacaoAguaSituacao());
				}

				if(imovel.getLigacaoEsgotoSituacao() != null && imovel.getLigacaoEsgotoSituacao().getId() != null){
					movimentoRoteiroEmpresa.setLigacaoEsgotoSituacao(imovel.getLigacaoEsgotoSituacao());
				}

				// Caso exista contrato de demanda de consumo vigente para o imóvel e tarifa de
				// consumo não esteja vazia
				// atribuir CSTF_ID da tabela CONTRATO_DEMANDA_CONSUMO
				ContratoDemandaConsumo contratoDemandaConsumo = this.pesquisarContratoDemandaConsumoVigenteComTarifa(imovel.getId(),
								sistemaParametro.getAnoMesFaturamento());

				if(contratoDemandaConsumo != null){

					movimentoRoteiroEmpresa.setConsumoTarifa(contratoDemandaConsumo.getConsumoTarifa());

				}else if(imovel.getConsumoTarifa() != null){
					if(imovel.getConsumoTarifaTemporaria() != null
									&& imovel.getDataValidadeTarifaTemporaria() != null
									&& (Util.compararData(imovel.getDataValidadeTarifaTemporaria(), new Date()) > 0 || Util.compararData(
													imovel.getDataValidadeTarifaTemporaria(), new Date()) == 0)){
						movimentoRoteiroEmpresa.setConsumoTarifa(imovel.getConsumoTarifaTemporaria());
					}else{
						movimentoRoteiroEmpresa.setConsumoTarifa(imovel.getConsumoTarifa());
					}
				}

				// Verifica se o imóvel está enquadrado em uma subcategoria considerada Repartição
				// Pública Federal
				reparticaoPublicaFederal = getControladorImovel().verificarImovelReparticaoPublicaFederal(imovel.getId());

				idClientePublicoFederal = repositorioFaturamento.pesquisarClienteResponsavelEsferaPoderFederal(imovel.getId());

				// Se o imóvel está associado a uma subcategoria considerada como Repartição Pública
				// Federal ou possui um cliente responsável da esfera do poder Federal, calcula os
				// impostos deduzidos
				if(reparticaoPublicaFederal || idClientePublicoFederal != null){

					movimentoRoteiroEmpresa.setIndicadorImpostoFederal(ConstantesSistema.SIM);
				}else{

					movimentoRoteiroEmpresa.setIndicadorImpostoFederal(ConstantesSistema.NAO);
				}

				if(imovel.getPocoTipo() != null){
					movimentoRoteiroEmpresa.setIndicadorPoco(new Short(ConstantesSistema.SIM.shortValue()));
				}else{

					movimentoRoteiroEmpresa.setIndicadorPoco(new Short(ConstantesSistema.NAO.shortValue()));
				}

				if(imovel.getImovelPerfil().getId().equals(ImovelPerfil.GRANDE)){
					movimentoRoteiroEmpresa.setIndicadorGrandeCliente(ConstantesSistema.SIM);
					movimentoRoteiroEmpresa.setIndicadorBaixaRenda(ConstantesSistema.NAO);

				}else if(imovel.getImovelPerfil().getId().equals(ImovelPerfil.TARIFA_SOCIAL)){
					movimentoRoteiroEmpresa.setIndicadorGrandeCliente(ConstantesSistema.NAO);
					movimentoRoteiroEmpresa.setIndicadorBaixaRenda(ConstantesSistema.SIM);

				}else{
					movimentoRoteiroEmpresa.setIndicadorGrandeCliente(ConstantesSistema.NAO);
					movimentoRoteiroEmpresa.setIndicadorBaixaRenda(ConstantesSistema.NAO);
				}

				if(imovel.getIndicadorDebitoConta() != null){
					movimentoRoteiroEmpresa.setIndicadorDebitoAutomatico(imovel.getIndicadorDebitoConta());
				}

				// Checa Anormalidade de Consumo
				Integer anoMesReferenciaAnoAnterior = Util.subtrairMesDoAnoMes(anoMesReferenciaFaturamento, 12);
				FiltroConsumoHistorico filtroConsumoHistorico = new FiltroConsumoHistorico();
				filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, imovel.getId()));
				filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANORMALIDADE_CONSUMO,
								ConsumoAnormalidade.ALTO_CONSUMO_COM_DESCONTO));
				filtroConsumoHistorico.adicionarParametro(new Intervalo(FiltroConsumoHistorico.ANO_MES_FATURAMENTO,
								anoMesReferenciaAnoAnterior, anoMesReferenciaFaturamento));

				Collection colecaoConsumoHistorico = getControladorUtil().pesquisar(filtroConsumoHistorico,
								ConsumoHistorico.class.getName());
				if(colecaoConsumoHistorico != null && !colecaoConsumoHistorico.isEmpty()){
					movimentoRoteiroEmpresa.setIndicadorDescontoAltoConsumo(ConstantesSistema.SIM);
				}else{
					movimentoRoteiroEmpresa.setIndicadorDescontoAltoConsumo(ConstantesSistema.NAO);
				}

				// Dados do Hidrômetro
				Short numeroDigitosHidrometro = null;
				ultimoConsumoFaturadoMes = null;

				ObterIndicadorExistenciaHidrometroHelper indicadorHidrometroAguaPoco = this.getControladorRegistroAtendimento()
								.obterIndicadorExistenciaHidrometroLigacaoAguaPoco(imovel.getId(), false);

				Short hidrometroLigacaoAguaImovel = indicadorHidrometroAguaPoco.getIndicadorLigacaoAgua();
				Short hidrometroLigacaoPocoImovel = indicadorHidrometroAguaPoco.getIndicadorPoco();

				if(hidrometroLigacaoAguaImovel.equals(ConstantesSistema.SIM) && hidrometroLigacaoPocoImovel.equals(ConstantesSistema.SIM)){
					Object dadosHidrometroNumeroLeitura[] = getControladorMicromedicao().pesquisarDadosHidrometroTipoLigacaoAgua(imovel);
					numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];

					movimentoRoteiroEmpresa.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
					movimentoRoteiroEmpresa.setNumeroDigitosLeitura(numeroDigitosHidrometro);

					MedicaoTipo medicaoTipo = new MedicaoTipo();
					medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);
					movimentoRoteiroEmpresa.setMedicaoTipo(medicaoTipo);

					// Obtém o último consumo faturado do imóvel
					ultimoConsumoFaturadoMes = (Integer) repositorioMicromedicao.obterUltimoConsumoFaturadoImovel(imovel.getId(),
									LigacaoTipo.LIGACAO_AGUA);

				}else if(hidrometroLigacaoAguaImovel.equals(ConstantesSistema.SIM)){
					Object dadosHidrometroNumeroLeitura[] = getControladorMicromedicao().pesquisarDadosHidrometroTipoLigacaoAgua(imovel);
					numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];

					movimentoRoteiroEmpresa.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
					movimentoRoteiroEmpresa.setNumeroDigitosLeitura(numeroDigitosHidrometro);

					MedicaoTipo medicaoTipo = new MedicaoTipo();
					medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);
					movimentoRoteiroEmpresa.setMedicaoTipo(medicaoTipo);

					// Obtém o último consumo faturado do imóvel
					ultimoConsumoFaturadoMes = (Integer) repositorioMicromedicao.obterUltimoConsumoFaturadoImovel(imovel.getId(),
									LigacaoTipo.LIGACAO_AGUA);

				}else if(hidrometroLigacaoPocoImovel.equals(ConstantesSistema.SIM)){
					Object dadosHidrometroNumeroLeitura[] = getControladorMicromedicao().pesquisarDadosHidrometroTipoPoco(imovel);
					numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];

					movimentoRoteiroEmpresa.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
					movimentoRoteiroEmpresa.setNumeroDigitosLeitura(numeroDigitosHidrometro);

					MedicaoTipo medicaoTipo = new MedicaoTipo();
					medicaoTipo.setId(MedicaoTipo.POCO);
					movimentoRoteiroEmpresa.setMedicaoTipo(medicaoTipo);

					// Obtém o último consumo faturado do imóvel
					ultimoConsumoFaturadoMes = (Integer) repositorioMicromedicao.obterUltimoConsumoFaturadoImovel(imovel.getId(),
									LigacaoTipo.LIGACAO_ESGOTO);
				}else{

					// Obtém o último consumo faturado do imóvel
					ultimoConsumoFaturadoMes = (Integer) repositorioMicromedicao.obterUltimoConsumoFaturadoImovel(imovel.getId(),
									LigacaoTipo.LIGACAO_AGUA);
				}

				// Caso o imóvel tenha consumo faturado anterior
				if(ultimoConsumoFaturadoMes != null){

					// Atribui ao consumo anterior o último consumo faturado do imóvel
					movimentoRoteiroEmpresa.setNumeroConsumoAnterior(ultimoConsumoFaturadoMes);
				}

				if(imovel.getHidrometroInstalacaoHistorico() != null){
					movimentoRoteiroEmpresa.setDataInstalacaoHidrometro(imovel.getHidrometroInstalacaoHistorico().getDataInstalacao());
					if(imovel.getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao() != null){
						movimentoRoteiroEmpresa.setLocalInstalacaoHidrometro(imovel.getHidrometroInstalacaoHistorico()
										.getHidrometroLocalInstalacao().getDescricaoAbreviada());
					}
				}

				if(imovel.getLigacaoAgua() != null){

					if(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){

						if(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao() != null){
							movimentoRoteiroEmpresa.setLocalInstalacaoHidrometro(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()
											.getHidrometroLocalInstalacao().getDescricaoAbreviada());
						}
						movimentoRoteiroEmpresa.setDataInstalacaoHidrometro(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()
										.getDataInstalacao());
					}

					if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua() != null){

						movimentoRoteiroEmpresa.setNumeroConsumoMinimo(imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua());
					}else if(imovel.getLigacaoEsgoto() != null && imovel.getLigacaoEsgoto().getConsumoMinimo() != null){

						movimentoRoteiroEmpresa.setNumeroConsumoMinimo(imovel.getLigacaoEsgoto().getConsumoMinimo());
					}
				}else if(imovel.getLigacaoEsgoto() != null && imovel.getLigacaoEsgoto().getConsumoMinimo() != null){

					movimentoRoteiroEmpresa.setNumeroConsumoMinimo(imovel.getLigacaoEsgoto().getConsumoMinimo());
				}

				Short atribuirConsumoMinimoLigacao = Util.obterShort(ParametroFaturamento.P_ATRIBUIR_MINIMO_LIGACAO_AO_CONSUMO_MINIMO
								.executar().toString());

				// [UC0105] - Obter Consumo Mínimo
				Collection colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
				int consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, colecaoCategorias);

				if(atribuirConsumoMinimoLigacao.equals(ConstantesSistema.NAO)){

					if(movimentoRoteiroEmpresa.getNumeroConsumoMinimo() == null){

						if(consumoMinimoLigacao > 0){

							movimentoRoteiroEmpresa.setNumeroConsumoMinimo(Integer.valueOf(consumoMinimoLigacao));
						}
					}
				}else if(atribuirConsumoMinimoLigacao.equals(ConstantesSistema.SIM)){

					movimentoRoteiroEmpresa.setNumeroConsumoMinimo(Integer.valueOf(consumoMinimoLigacao));
				}

				// Consumo Médio do Imóvel
				int[] consumoMedioImovel = getControladorMicromedicao().obterConsumoMedioImovel(imovel, sistemaParametro);
				movimentoRoteiroEmpresa.setNumeroConsumoMedio(consumoMedioImovel[0]);

				// Caso o imóvel seja medido
				if(movimentoRoteiroEmpresa.getMedicaoTipo() != null){

					// Dados da última medição
					Object[] dadosLeituraAnterior = obterDadosLeituraAnterior(anoMesReferenciaFaturamento, movimentoRoteiroEmpresa
									.getMedicaoTipo().getId(), imovel);

					movimentoRoteiroEmpresa.setNumeroLeituraAnterior((Integer) dadosLeituraAnterior[0]);
					movimentoRoteiroEmpresa.setDataLeituraAnterior((Date) dadosLeituraAnterior[1]);
					movimentoRoteiroEmpresa.setIdLeituraSituacaoAnterior((Integer) dadosLeituraAnterior[2]);

					int consumoCreditoConsumoHistoricoAnterior = 0;

					Object[] dadosConsumoHistoricoAnterior = repositorioMicromedicao.obterConsumoHistoricoAnterior(imovel.getId(),
									anoMesReferenciaFaturamento, LigacaoTipo.LIGACAO_AGUA);

					if(!Util.isVazioOrNulo(dadosConsumoHistoricoAnterior)){

						if(dadosConsumoHistoricoAnterior[4] != null){

							consumoCreditoConsumoHistoricoAnterior = (Integer) dadosConsumoHistoricoAnterior[4];
						}
					}

					// Saldo do Crédito de Consumo Calculado
					// (MDHI_NNCONSUMOCREDITOANTERIOR + MDHI_NNCONSUMOCREDITOGERADO) -
					// CSHI_NNCONSUMOCREDITO da tabela CONSUMO_HISTORICO da referência anterior
					movimentoRoteiroEmpresa
									.setNumeroConsumoCredito((((Integer) dadosLeituraAnterior[3]).intValue() + ((Integer) dadosLeituraAnterior[5])
													.intValue()) - consumoCreditoConsumoHistoricoAnterior);

				}else{

					// Caso contrário, imóvel não medido
					movimentoRoteiroEmpresa.setNumeroConsumoCredito(0);
					movimentoRoteiroEmpresa.setIdLeituraSituacaoAnterior(LeituraSituacao.NAO_REALIZADA);
				}

				// [SB0020] - Determinar Percentual de Esgoto
				BigDecimal percentualEsgoto = this.determinarPercentualEsgoto(imovel);
				movimentoRoteiroEmpresa.setPercentualEsgoto(percentualEsgoto);

				FaturamentoSituacaoHistorico fsh = null;
				Collection collFaturamentoSituacaoHistoricoImovel = repositorioFaturamento.pesquisarFaturamentoSituacaoHistoricoImovel(
								imovel.getId(), anoMesReferenciaFaturamento);
				if(collFaturamentoSituacaoHistoricoImovel != null && !collFaturamentoSituacaoHistoricoImovel.isEmpty()){
					Iterator it = collFaturamentoSituacaoHistoricoImovel.iterator();
					fsh = (FaturamentoSituacaoHistorico) it.next();
				}

				boolean icFaturamentoSituacaoEspecial = false;

				if(fsh != null && fsh.getFaturamentoSituacaoTipo() != null){
					// FTSH_NNVOLUME da tabela FATURAMENTO_SITUACAO_HISTORICO caso o imóvel esteja
					// com situação de faturamento especial do tipo “Faturar Limite” (FTST_ID) e a
					// mesma seja válida para água (FTST_ID com o valor diferente de nulo na tabela
					// IMOVEL, e FTST_ICVALIDOAGUA=1 para FTST_ID=FTST_ID da tabela
					// FATURAMENTO_SITUACAO_TIPO)
					if(fsh.getFaturamentoSituacaoTipo().getId().equals(FaturamentoSituacaoTipo.FATURAMENTO_ATE_LIMITE)
									&& imovel.getFaturamentoSituacaoTipo() != null
									&& fsh.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().equals(ConstantesSistema.SIM)){
						movimentoRoteiroEmpresa.setNumeroConsumoFixoAgua(fsh.getVolume());
						icFaturamentoSituacaoEspecial = true;
					}

					// FTSH_NNVOLUME da tabela FATURAMENTO_SITUACAO_HISTORICO caso o imóvel esteja
					// com situação de faturamento especial e a mesma seja válida para esgoto
					// (FTST_ID com o valor diferente de nulo na tabela IMOVEL, e FTST_
					// ICVALIDOESGOTO=1 para FTST_ID=FTST_ID da tabela FATURAMENTO_SITUACAO_TIPO)

					if(imovel.getFaturamentoSituacaoTipo() != null
									&& fsh.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().equals(ConstantesSistema.SIM)){
						movimentoRoteiroEmpresa.setNumeroConsumoFixoEsgoto(fsh.getVolume());
					}

				}

				if(!icFaturamentoSituacaoEspecial){
					icFaturamentoSituacaoEspecial = false;
					// Caso exista contrato de demanda de consumo vigente para o imóvel e tarifa de
					// consumo não esteja vazia
					// atribuir CSTF_ID da tabela CONTRATO_DEMANDA_CONSUMO
					ContratoDemandaConsumo contratoDemandaConsumoVigente = this.pesquisarContratoDemandaConsumoVigenteComConsumoFixo(
									imovel.getId(), anoMesReferenciaFaturamento);

					if(contratoDemandaConsumoVigente != null){

						movimentoRoteiroEmpresa.setNumeroConsumoFixoAgua(contratoDemandaConsumoVigente.getNumeroConsumoFixo());

					}
				}

				// 2. Caso o imóvel possua hidrômetro instalado na ligação de água (HIDI_ID com o
				// valor diferente de nulo na tabela LIGACAO_AGUA para LAGU_ID=IMOV_ID da tabela
				// IMOVEL) e seja uma ligação nova (PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com
				// PASI_CDPARAMETRO = “P_HIDROMETRO_NOVO”), indicar que o imóvel é isento de água e
				// de esgoto:
				// 2.1.1. Caso o valor do parâmetro indique Data de Instalação igual ou maior que a
				// Data de Leitura e HIDI_DTINSTALACAOHIDROMETRO igual ou maior que a data da
				// leitura anterior, ou

				// 2.1.2. Caso o valor do parâmetro indique Quantidade de dias de consumo e a
				// diferença de dias entre a data de instalação do hidrômetro.
				// (HIDI_DTINSTALACAOHIDROMETRO da tabela HIDROMETRO_INSTALACAO_HISTORICO com
				// HIDI_ID da imóvel caso o tipo de medição seja “2 - Poço”, ou com HIDI_ID da
				// tabela LIGACAO_AGUA caso o tipo de medição seja “1 – Ligação de Água”) e a data
				// da leitura atual seja menor que a quantidade de dias parametrizada
				// (PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com PASI_CDPARAMETRO =
				// “P_QTD_DIAS_HIDROMETRO_NOVO”)

				if(hidrometroLigacaoAguaImovel.equals(ConstantesSistema.SIM)){
					String pHidrometroNovo = (String) ParametroFaturamento.P_HIDROMETRO_NOVO.executar();
					if(pHidrometroNovo != null){

						if(pHidrometroNovo.equals(ConstantesSistema.DATA_INSTALACAO_MAIOR_QUE_DATA_LEITURA)){

							if((movimentoRoteiroEmpresa.getDataInstalacaoHidrometro() != null
											&& movimentoRoteiroEmpresa.getDataLeituraAnterior() != null && movimentoRoteiroEmpresa
											.getDataLeitura() != null)
											&& Util.compararData(movimentoRoteiroEmpresa.getDataInstalacaoHidrometro(),
															movimentoRoteiroEmpresa.getDataLeitura()) >= 1
											&& Util.compararData(movimentoRoteiroEmpresa.getDataInstalacaoHidrometro(),
															movimentoRoteiroEmpresa.getDataLeituraAnterior()) >= 1){
								movimentoRoteiroEmpresa.setIndicadorIsencaoAgua(ConstantesSistema.SIM);
								movimentoRoteiroEmpresa.setIndicadorIsencaoEsgoto(ConstantesSistema.SIM);

							}

						}else if(pHidrometroNovo.equals(ConstantesSistema.QUANTIDADE_DIAS_CONSUMO)){

							String pQtdDiasHidrometroNovo = (String) ParametroFaturamento.P_QTD_DIAS_HIDROMETRO_NOVO.executar();

							if(movimentoRoteiroEmpresa.getDataInstalacaoHidrometro() != null
											&& movimentoRoteiroEmpresa.getDataLeitura() != null){
								int diferenca = Util.dataDiff(movimentoRoteiroEmpresa.getDataInstalacaoHidrometro(),
												movimentoRoteiroEmpresa.getDataLeitura());
								if(diferenca < Util.converterStringParaInteger(pQtdDiasHidrometroNovo)){
									movimentoRoteiroEmpresa.setIndicadorIsencaoAgua(ConstantesSistema.SIM);
									movimentoRoteiroEmpresa.setIndicadorIsencaoEsgoto(ConstantesSistema.SIM);

								}
							}

						}
					}
				}

				// busca o Faturamento Atividade Cronograma da Rota/Imovel
				FaturamentoAtivCronRota faturamentoAtividadeCronRota = this
								.obterFaturamentoAtividadeCronogramaPorGrupoFaturamentoRota(FaturamentoAtividade.GERAR_ARQUIVO_LEITURA,
												anoMesReferenciaFaturamento, faturamentoGrupo, imovel.getRota());
				if(faturamentoAtividadeCronRota == null){
					throw new ControladorException("erro.atividade_cronograma_rota_nao_encontrada_conta_pre_faturamento");
				}

				Date dataVencimentoImovel = determinarVencimentoConta(imovel, faturamentoAtividadeCronRota, sistemaParametro);
				if(dataVencimentoImovel != null){
					movimentoRoteiroEmpresa.setDataVencimento(dataVencimentoImovel);
				}

				if(faturamentoAtividadeCronRota.getFaturamentoAtividadeCronograma() != null
								&& faturamentoAtividadeCronRota.getFaturamentoAtividadeCronograma().getComando() != null){
					movimentoRoteiroEmpresa.setDataProgramacaoLeitura(faturamentoAtividadeCronRota.getFaturamentoAtividadeCronograma()
									.getComando());
				}

				// mrem_icemissao Caso possua endereço alternativo para entrega (ICTE_ID da tabela
				// IMOVEL seja igual a 1 ou 3) ou esteja indicado que deve ser emitida a fatura de
				// cliente responsável (IMOV_ICEMISSAOEXTRATOFATURAMENTO=1 (SIM) da tabela IMOVEL)
				// ou esteja indicado para não emitir não medido (PASI_VLPARAMETRO com o valor 2
				// (dois) na tabela PARAMETRO_SISTEMA para PASI_DSPARAMETRO =
				// “P_INDICADOR_EMISSAO_NAO_MEDIDO_FATURAMENTO_IMEDIATO”) ou o imóvel seja um
				// condomínio (IMOV_ICCONDOMINIO com o valor 1) ou caso o Grupo de
				// Faturamento(FTGR_ID) em questão para referência(MREM_AMMOVIMENTO) entre
				// FGRV_AMREFERENCIAFATURINICIAL e FGRV_AMREFERENCIAFATURFINAL de
				// FATURAMENTO_GRUPO_REVISAO(caso exista) tenha o indicador FGRV_ICIMPRESSAOCAMPO =
				// 2, atribuir 2. Caso contrário, atribuir 1.

				FaturamentoGrupoRevisao faturamentoGrupoRevisao = null;

				if(faturamentoGrupo != null && faturamentoGrupo.getId() != null && anoMesReferenciaFaturamento != null){

					FiltroFaturamentoGrupoRevisao filtroFaturamentoGrupoRevisao = new FiltroFaturamentoGrupoRevisao();
					filtroFaturamentoGrupoRevisao.adicionarParametro(new ParametroSimples(
									FiltroFaturamentoGrupoRevisao.FATURAMENTO_GRUPO_ID, faturamentoGrupo.getId()));
					filtroFaturamentoGrupoRevisao.adicionarParametro(new MenorQue(
									FiltroFaturamentoGrupoRevisao.ANO_MES_REFERENCIA_FATURAMENTO_INICIAL, anoMesReferenciaFaturamento));
					filtroFaturamentoGrupoRevisao.adicionarParametro(new MaiorQue(
									FiltroFaturamentoGrupoRevisao.ANO_MES_REFERENCIA_FATURAMENTO_FINAL, anoMesReferenciaFaturamento));

					faturamentoGrupoRevisao = (FaturamentoGrupoRevisao) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(
									filtroFaturamentoGrupoRevisao, FaturamentoGrupoRevisao.class.getName()));
				}

				String indicadorEmissaoNaoMedidoFatImediato = (String) ParametroFaturamento.P_INDICADOR_EMISSAO_NAO_MEDIDO_FATURAMENTO_IMEDIATO
								.executar(this);

				if((imovel.getIndicadorEmissaoExtratoFaturamento() != null && (imovel.getIndicadorEmissaoExtratoFaturamento()
								.equals(ConstantesSistema.SIM)))
								|| ((imovel.getImovelContaEnvio() != null && (imovel.getImovelContaEnvio().getId()
												.equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL) || imovel.getImovelContaEnvio()
												.getId().equals(ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL))))
								|| new Short(indicadorEmissaoNaoMedidoFatImediato).equals(ConstantesSistema.NAO)
								|| imovel.getIndicadorImovelCondominio().equals(ConstantesSistema.SIM)
								|| (faturamentoGrupoRevisao != null && faturamentoGrupoRevisao.getIndicadorImpressaoCampo() != null && faturamentoGrupoRevisao
												.getIndicadorImpressaoCampo().equals(ConstantesSistema.NAO))){
					movimentoRoteiroEmpresa.setIndicadorEmissao(ConstantesSistema.NAO);
				}else{
					movimentoRoteiroEmpresa.setIndicadorEmissao(ConstantesSistema.SIM);
				}

				movimentoRoteiroEmpresa.setNumeroDocumentoCobranca(null);
				movimentoRoteiroEmpresa.setIndicadorFase(MovimentoRoteiroEmpresa.FASE_GERADO);
				movimentoRoteiroEmpresa.setTempoGeracao(new Date());
				movimentoRoteiroEmpresa.setUltimaAlteracao(new Date());

				// Criar parâmetro para usuário batch e substituir o valor fixo.
				movimentoRoteiroEmpresa.setIdUsuarioGeracao(Usuario.getIdUsuarioBatchParametro());

				imovel.setContas(this.obterContas(imovel.getId(), anoMesReferenciaFaturamento, DebitoCreditoSituacao.PRE_FATURADA));

				// Seção apenas para imóveis que tenham tido conta gerada
				if(imovel.getContas() != null && !imovel.getContas().isEmpty()){

					// Dados de Paralisação
					if(imovel.getFaturamentosSituacaoHistorico() != null && !imovel.getFaturamentosSituacaoHistorico().isEmpty()){
						for(Iterator iteratorFaturamentosSituacaoHistorico = imovel.getFaturamentosSituacaoHistorico().iterator(); iteratorFaturamentosSituacaoHistorico
										.hasNext();){
							FaturamentoSituacaoHistorico faturamentoSituacaoHistorico = (FaturamentoSituacaoHistorico) iteratorFaturamentosSituacaoHistorico
											.next();
							if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo() != null
											&& faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo().getIndicadorParalisacaoLeitura() != null){
								movimentoRoteiroEmpresa.setIndicadorLeituraParalisacao(faturamentoSituacaoHistorico
												.getFaturamentoSituacaoTipo().getIndicadorParalisacaoLeitura());
							}else{
								movimentoRoteiroEmpresa.setIndicadorLeituraParalisacao(ConstantesSistema.NAO);
							}

							if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo() != null
											&& faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
															.getLeituraAnormalidadeConsumoComLeitura() != null){
								movimentoRoteiroEmpresa.setLeituraAnormalidadeConsumo(faturamentoSituacaoHistorico
												.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura());

								if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura()
												.getId().equals(LeituraAnormalidadeConsumo.LIMITE)
												|| faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
																.getLeituraAnormalidadeConsumoComLeitura().getId()
																.equals(LeituraAnormalidadeConsumo.ATE_LIMITE)){
									movimentoRoteiroEmpresa.setNumeroConsumoFixoAgua(faturamentoSituacaoHistorico.getVolume());
								}

							}

							if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo() != null
											&& faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
															.getIndicadorParalisacaoFaturamento() != null){
								movimentoRoteiroEmpresa.setIndicadorIsencaoAgua(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
												.getIndicadorParalisacaoFaturamento());
							}else{
								movimentoRoteiroEmpresa.setIndicadorIsencaoAgua(ConstantesSistema.NAO);
							}

							if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo() != null
											&& faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
															.getIndicadorFaturamentoParalisacaoEsgoto() != null){
								movimentoRoteiroEmpresa.setIndicadorIsencaoEsgoto(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
												.getIndicadorFaturamentoParalisacaoEsgoto());
							}else{
								movimentoRoteiroEmpresa.setIndicadorIsencaoEsgoto(ConstantesSistema.NAO);
							}

						}
					}else{
						movimentoRoteiroEmpresa.setIndicadorLeituraParalisacao(ConstantesSistema.NAO);
						movimentoRoteiroEmpresa.setIndicadorIsencaoAgua(ConstantesSistema.NAO);
						movimentoRoteiroEmpresa.setIndicadorIsencaoEsgoto(ConstantesSistema.NAO);
					}

					// Serviços Efetuados e Dedução de Créditos PRC
					for(Iterator iteratorContaImovel = imovel.getContas().iterator(); iteratorContaImovel.hasNext();){

						Conta contaPreFaturadaImovel = (Conta) iteratorContaImovel.next();

						/*
						 * Criado tratamento para aglutinar débitos cobrados do mesmo tipo antes de
						 * jogar essas informações em MOVIMENTO_ROTEIRO_EMPRESA. Solicitação da
						 * OC780187 para evitar inconsistência nos casos em que a quantidade de
						 * débitos era maior que 15.
						 */
						List<DebitoCobrado> colecaoDebitoCobradoOrdenada = new ArrayList<DebitoCobrado>();

						if(!Util.isVazioOrNulo(contaPreFaturadaImovel.getDebitoCobrados())){

							colecaoDebitoCobradoOrdenada.addAll(contaPreFaturadaImovel.getDebitoCobrados());

							// Ordenar a coleção por mais de um campo
							List sortFields = new ArrayList();
							sortFields.add(new BeanComparator("debitoTipo.id"));
							sortFields.add(new BeanComparator("numeroPrestacao"));
							sortFields.add(new BeanComparator("numeroPrestacaoDebito"));

							ComparatorChain multiSort = new ComparatorChain(sortFields);
							Collections.sort(colecaoDebitoCobradoOrdenada, multiSort);

							BigDecimal acumularValorPrestacao = BigDecimal.ZERO;
							Collection<DebitoCobrado> colecaoDebitoCobradoAglutinada = new ArrayList<DebitoCobrado>();

							String[] valoresParmTipoDebRefFatura = ((String) ParametroFaturamento.P_TIPO_DE_DEBITO_EXIBE_REFERENCIA_NA_FATURA
											.executar(this)).split(",");

							for(int i = 0; i < colecaoDebitoCobradoOrdenada.size(); i++){

								DebitoCobrado debitoCobrado = colecaoDebitoCobradoOrdenada.get(i);

								if(!this.exibirReferenciaNaFatura(debitoCobrado.getDebitoTipo().getId(), valoresParmTipoDebRefFatura)){

									DebitoCobrado debitoCobradoProximo = null;

									if(i != (colecaoDebitoCobradoOrdenada.size() - 1)){

										debitoCobradoProximo = colecaoDebitoCobradoOrdenada.get(i + 1);
									}else{

										debitoCobradoProximo = colecaoDebitoCobradoOrdenada.get(i);
									}

									if(debitoCobrado.getDebitoTipo().getId().equals(debitoCobradoProximo.getDebitoTipo().getId())
													&& (debitoCobrado.getNumeroPrestacao() == debitoCobradoProximo.getNumeroPrestacao())
													&& (debitoCobrado.getNumeroPrestacaoDebito() == debitoCobradoProximo
																	.getNumeroPrestacaoDebito())){

										acumularValorPrestacao = acumularValorPrestacao.add(debitoCobrado.getValorPrestacao());

										if(i == (colecaoDebitoCobradoOrdenada.size() - 1)){

											debitoCobrado.setAnoMesReferenciaDebito(0);
											debitoCobrado.setValorPrestacao(acumularValorPrestacao);
											colecaoDebitoCobradoAglutinada.add(debitoCobrado);
										}

									}else{

										acumularValorPrestacao = acumularValorPrestacao.add(debitoCobrado.getValorPrestacao());
										debitoCobrado.setValorPrestacao(acumularValorPrestacao);
										debitoCobrado.setAnoMesReferenciaDebito(0);
										colecaoDebitoCobradoAglutinada.add(debitoCobrado);
										acumularValorPrestacao = BigDecimal.ZERO;

									}

								}else{

									acumularValorPrestacao = acumularValorPrestacao.add(debitoCobrado.getValorPrestacao());
									debitoCobrado.setValorPrestacao(acumularValorPrestacao);
									colecaoDebitoCobradoAglutinada.add(debitoCobrado);
									acumularValorPrestacao = BigDecimal.ZERO;

								}

							}

							int contador = 1;
							BigDecimal valorDebitos = BigDecimal.ZERO;

							Short numeroPrestacaoDebito = null;
							Short numeroPrestacao = null;

							Conta conta = null;
							Integer idConta = null;

							DebitoTipo debitoTipo = null;
							Integer idDebitoTipo = null;
							String idDebitoTipoStr = "";

							Integer idDebitoCobrado = null;

							// Map utilizado para acumular o crédito residual do desconto de
							// acréscimos por impontualidade
							Map<Integer, BigDecimal> mapCreditoResidual = new HashMap<Integer, BigDecimal>();

							for(Iterator iteratorDebitosConta = colecaoDebitoCobradoAglutinada.iterator(); iteratorDebitosConta.hasNext();){
								DebitoCobrado debitoConta = (DebitoCobrado) iteratorDebitosConta.next();

								idDebitoCobrado = debitoConta.getId();

								debitoTipo = debitoConta.getDebitoTipo();

								if(debitoTipo != null){
									idDebitoTipo = debitoTipo.getId();
									idDebitoTipoStr = Integer.toString(idDebitoTipo);
								}else{
									idDebitoTipo = null;
									idDebitoTipoStr = "";
								}

								idDebitoTipoStr = Util.adicionarZerosEsqueda(3, idDebitoTipoStr);

								conta = debitoConta.getConta();

								if(conta != null){
									idConta = conta.getId();
								}else{
									idConta = null;
								}

								numeroPrestacaoDebito = debitoConta.getNumeroPrestacaoDebito();

								numeroPrestacao = debitoConta.getNumeroPrestacao();

								// [SB0019] – Formatar Descrição do Débito
								String descricaoDebito = this.formatarDescricaoDebitoCobrado(idConta, idDebitoTipo, numeroPrestacaoDebito,
												numeroPrestacao);

								Object[] dadosDesconto = this.verificarExistenciaDescontoDebitoCobradoParcelamento(idDebitoCobrado,
												idConta, idDebitoTipo, numeroPrestacaoDebito, numeroPrestacao,
												debitoConta.getValorPrestacao(), movimentoRoteiroEmpresa, mapCreditoResidual);

								BigDecimal vlRubrica = (BigDecimal) dadosDesconto[0];

								String dadosTextoConta = (String) ParametroFaturamento.P_FORMATO_DESCRICAO_RUBRICA.executar(this, -1,
												idDebitoTipoStr, descricaoDebito);

								valorDebitos = valorDebitos.add(vlRubrica);
								if(contador <= 15){
									Util.executarMetodo(movimentoRoteiroEmpresa, "setDescricaoRubrica" + contador, dadosTextoConta);
									Util.executarMetodo(movimentoRoteiroEmpresa, "setNumeroPrestacaoRubrica" + contador, numeroPrestacao);
									Util.executarMetodo(movimentoRoteiroEmpresa, "setNumeroPrestacaoCobradaRubrica" + contador,
													numeroPrestacaoDebito);
									Util.executarMetodo(movimentoRoteiroEmpresa, "setReferenciaRubrica" + contador,
													debitoConta.getAnoMesReferenciaDebito());
									Util.executarMetodo(movimentoRoteiroEmpresa, "setValorRubrica" + contador, vlRubrica);
								}else{
									movimentoRoteiroEmpresa.setDescricaoRubrica15("Outros Serviços");
									movimentoRoteiroEmpresa.setNumeroPrestacaoRubrica15(null);
									movimentoRoteiroEmpresa.setNumeroPrestacaoCobradaRubrica15(null);
									movimentoRoteiroEmpresa.setReferenciaRubrica15(null);

									vlRubrica = vlRubrica.add(movimentoRoteiroEmpresa.getValorRubrica15());
									movimentoRoteiroEmpresa.setValorRubrica15(vlRubrica);
								}

								contador++;
							}

							movimentoRoteiroEmpresa.setValorDebitos(valorDebitos);
						}
					}

					imovel.setConsumosHistoricos(new HashSet());
					imovel.setMedicaoHistoricos(new HashSet());
					Collection colecaoConsumoHistoricoImovel = null;
					Integer idLigacao = this.getControladorMicromedicao().verificarExistenciaHidrometroInstalacaoHistoricoTipoAgua(
									imovel.getId());

					if(idLigacao != null){
						LigacaoTipo ligacaoTipoImovel = new LigacaoTipo();
						ligacaoTipoImovel.setId(LigacaoTipo.LIGACAO_AGUA);
						colecaoConsumoHistoricoImovel = this.getControladorMicromedicao()
										.pesquisarConsumoMedidoHidrometroPeriodoInformadoLigacaoAgua(imovel, anoMesReferenciaFaturamento,
														12, ligacaoTipoImovel);

					}else{
						colecaoConsumoHistoricoImovel = this.getControladorMicromedicao()
										.pesquisarConsumoMedidoHidrometroPeriodoInformadoPoco(imovel, anoMesReferenciaFaturamento, 12);
					}

					for(Iterator iteratorConsumoHistorico = colecaoConsumoHistoricoImovel.iterator(); iteratorConsumoHistorico.hasNext();){
						Object[] dadosConsumoHistorico = (Object[]) iteratorConsumoHistorico.next();

						Integer anoMesReferenciaConsumo = (Integer) dadosConsumoHistorico[0];
						Integer numeroFaturadoConsumo = (Integer) dadosConsumoHistorico[6];

						Integer idAnormalidadeConsumo = null;
						ConsumoAnormalidade consumoAnormalidade = null;

						if(dadosConsumoHistorico[5] != null){
							idAnormalidadeConsumo = (Integer) dadosConsumoHistorico[5];
							consumoAnormalidade = new ConsumoAnormalidade();
							consumoAnormalidade.setId(idAnormalidadeConsumo);
						}

						ConsumoHistorico consumoHistoricoImovel = new ConsumoHistorico();
						consumoHistoricoImovel.setReferenciaFaturamento(anoMesReferenciaConsumo);
						consumoHistoricoImovel.setNumeroConsumoFaturadoMes(numeroFaturadoConsumo);
						consumoHistoricoImovel.setConsumoAnormalidade(consumoAnormalidade);

						MedicaoHistorico medicaoHistoricoImovel = new MedicaoHistorico();
						medicaoHistoricoImovel.setAnoMesReferencia(anoMesReferenciaConsumo);

						Integer idAnormalidadeLeituraFaturamento = null;
						LeituraAnormalidade leituraAnormalidade = null;

						if(dadosConsumoHistorico[9] != null){
							idAnormalidadeLeituraFaturamento = (Integer) dadosConsumoHistorico[9];
							leituraAnormalidade = new LeituraAnormalidade();
							leituraAnormalidade.setId(idAnormalidadeLeituraFaturamento);

						}
						medicaoHistoricoImovel.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
						medicaoHistoricoImovel.setLeituraAtualFaturamento((Integer) dadosConsumoHistorico[8]);

						imovel.getConsumosHistoricos().add(consumoHistoricoImovel);
						imovel.getMedicaoHistoricos().add(medicaoHistoricoImovel);
					}

					// Históricos de Consumos e Anormalidades
					if(imovel.getConsumosHistoricos() != null && !imovel.getConsumosHistoricos().isEmpty()){

						Object[] colecaoArrayConsumoHistorico = imovel.getConsumosHistoricos().toArray();
						Collection colecaoConsumoHistoricoOrdenada = Arrays.asList(colecaoArrayConsumoHistorico);

						// Ordenando a lista de histórico de consumo a partir da
						// ReferenciaFaturamento
						List sortFields = new ArrayList();
						sortFields.add(new BeanComparator(FiltroConsumoHistorico.ANO_MES_FATURAMENTO));
						ComparatorChain multiSort = new ComparatorChain(sortFields);
						multiSort.setReverseSort(0);
						Collections.sort((List) colecaoConsumoHistoricoOrdenada, multiSort);

						int contador = 1;
						for(Iterator iteratorConsumoHistoricoImovel = colecaoConsumoHistoricoOrdenada.iterator(); iteratorConsumoHistoricoImovel
										.hasNext();){
							ConsumoHistorico consumoHistoricoImovel = (ConsumoHistorico) iteratorConsumoHistoricoImovel.next();

							switch(contador){
								case 1:
									movimentoRoteiroEmpresa.setReferenciaConsumo1(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo1(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo1(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;
								case 2:
									movimentoRoteiroEmpresa.setReferenciaConsumo2(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo2(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo2(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;
								case 3:
									movimentoRoteiroEmpresa.setReferenciaConsumo3(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo3(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo3(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;
								case 4:
									movimentoRoteiroEmpresa.setReferenciaConsumo4(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo4(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo4(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;
								case 5:
									movimentoRoteiroEmpresa.setReferenciaConsumo5(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo5(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo5(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;
								case 6:
									movimentoRoteiroEmpresa.setReferenciaConsumo6(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo6(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo6(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;

								// ..............................................................................
								case 7:
									movimentoRoteiroEmpresa.setReferenciaConsumo7(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo7(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo7(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;
								case 8:
									movimentoRoteiroEmpresa.setReferenciaConsumo8(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo8(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo8(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;

								case 9:
									movimentoRoteiroEmpresa.setReferenciaConsumo9(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo9(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo9(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;

								case 10:
									movimentoRoteiroEmpresa.setReferenciaConsumo10(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo10(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo10(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;
								case 11:
									movimentoRoteiroEmpresa.setReferenciaConsumo11(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo11(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo11(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;

								case 12:
									movimentoRoteiroEmpresa.setReferenciaConsumo12(consumoHistoricoImovel.getReferenciaFaturamento());
									movimentoRoteiroEmpresa.setNumeroConsumo12(consumoHistoricoImovel.getNumeroConsumoFaturadoMes());
									if(consumoHistoricoImovel.getConsumoAnormalidade() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeConsumo12(consumoHistoricoImovel.getConsumoAnormalidade()
														.getId());
									}
									break;

							}
							contador++;
						}
					}

					if(imovel.getMedicaoHistoricos() != null && !imovel.getMedicaoHistoricos().isEmpty()){

						Object[] colecaoArrayMedicaoHistorico = imovel.getMedicaoHistoricos().toArray();
						Collection colecaoMedicaoHistoricoOrdenada = Arrays.asList(colecaoArrayMedicaoHistorico);

						// Ordenando a lista de histórico de medição a partir da
						// referência de faturamento
						List sortFields = new ArrayList();
						sortFields.add(new BeanComparator(FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO));
						ComparatorChain multiSort = new ComparatorChain(sortFields);
						multiSort.setReverseSort(0);
						Collections.sort((List) colecaoMedicaoHistoricoOrdenada, multiSort);

						int contador = 1;
						for(Iterator iteratorMedicaoHistoricoImovel = colecaoMedicaoHistoricoOrdenada.iterator(); iteratorMedicaoHistoricoImovel
										.hasNext();){
							MedicaoHistorico medicaoHistoricoImovel = (MedicaoHistorico) iteratorMedicaoHistoricoImovel.next();

							switch(contador){
								case 1:
									movimentoRoteiroEmpresa.setLeituraFaturada1(medicaoHistoricoImovel.getLeituraAtualFaturamento());

									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura1(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());

									}

									break;
								case 2:
									movimentoRoteiroEmpresa.setLeituraFaturada2(medicaoHistoricoImovel.getLeituraAtualFaturamento());

									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura2(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());

									}

									break;
								case 3:
									movimentoRoteiroEmpresa.setLeituraFaturada3(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura3(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;
								case 4:
									movimentoRoteiroEmpresa.setLeituraFaturada4(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura4(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;
								case 5:
									movimentoRoteiroEmpresa.setLeituraFaturada5(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){

										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura5(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;
								case 6:
									movimentoRoteiroEmpresa.setLeituraFaturada6(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura6(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;

								case 7:
									movimentoRoteiroEmpresa.setLeituraFaturada7(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura7(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;

								case 8:
									movimentoRoteiroEmpresa.setLeituraFaturada8(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura8(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;

								case 9:
									movimentoRoteiroEmpresa.setLeituraFaturada9(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura9(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;
								case 10:
									movimentoRoteiroEmpresa.setLeituraFaturada10(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura10(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;

								case 11:
									movimentoRoteiroEmpresa.setLeituraFaturada11(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura11(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;

								case 12:
									movimentoRoteiroEmpresa.setLeituraFaturada12(medicaoHistoricoImovel.getLeituraAtualFaturamento());
									if(medicaoHistoricoImovel.getLeituraAnormalidadeFaturamento() != null){
										movimentoRoteiroEmpresa.setIdAnormalidadeLeitura12(medicaoHistoricoImovel
														.getLeituraAnormalidadeFaturamento().getId());
									}

									break;

							}
							contador++;

						}

					}

				}

				// [SB0004] – Obter os Créditos a Realizar
				tratarCreditosARealizarEnvioFaturamentoImediato(imovel.getId(), movimentoRoteiroEmpresa, anoMesReferenciaFaturamento,
								false, null);

				colecaoMovimentoRoteiroInserir.add(movimentoRoteiroEmpresa);
			}

			log.info("........................Inserindo Movimento Roteiro Empresa na Base de Dados");

			if(!colecaoMovimentoRoteiroInserir.isEmpty()){

				getControladorBatch().inserirColecaoObjetoParaBatch(colecaoMovimentoRoteiroInserir);
				log.info("........................Total Movimento Roteiro Empresa inseridos : " + colecaoMovimentoRoteiroInserir.size());
			}

		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * @param emitirContaHelper
	 * @param imovel
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @return
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 * @throws ControladorException
	 */

	public Collection<CalcularValoresAguaEsgotoHelper> obterCalcularValoresAguaEsgotoParaAjuste(EmitirContaHelper emitirContaHelper,
					Imovel imovel, Date dataLeituraAnterior, Date dataLeituraAtual) throws ControladorException{

		Collection colecaoCategoria = new ArrayList();

		Collection colecaoContaCategoriaComFaixas = null;
		Collection colecaoContaCategoriaHistoricoComFaixas = null;
		Collection<CalcularValoresAguaEsgotoHelper> colecaoValoresCalculadosAguaEsgoto = null;
		try{
			colecaoContaCategoriaComFaixas = repositorioFaturamento.pesquisarContaCategoria(emitirContaHelper.getIdConta());

			if(Util.isVazioOrNulo(colecaoContaCategoriaComFaixas)){
				colecaoContaCategoriaHistoricoComFaixas = repositorioFaturamento.pesquisarContaCategoriaHistorico(emitirContaHelper
								.getIdConta());

				Iterator it = colecaoContaCategoriaHistoricoComFaixas.iterator();
				while(it.hasNext()){
					ContaCategoriaHistorico contaCategoriaHistorico = (ContaCategoriaHistorico) it.next();

					FiltroCategoria filtroCategoria = new FiltroCategoria();
					filtroCategoria.adicionarParametro(new ParametroSimples(FiltroCategoria.CODIGO, contaCategoriaHistorico.getComp_id()
									.getCategoria().getId()));

					Collection<Categoria> colecaoCategoriaFiltro;

					colecaoCategoriaFiltro = getControladorUtil().pesquisar(filtroCategoria, Categoria.class.getName());

					Categoria categoria = null;
					if(colecaoCategoriaFiltro != null && !colecaoCategoriaFiltro.isEmpty()){
						categoria = (Categoria) Util.retonarObjetoDeColecao(colecaoCategoriaFiltro);
					}

					categoria.setQuantidadeEconomiasCategoria(Short.valueOf(contaCategoriaHistorico.getQuantidadeEconomia()).intValue());

					colecaoCategoria.add(categoria);
				}

			}else{
				Iterator it = colecaoContaCategoriaComFaixas.iterator();
				while(it.hasNext()){
					ContaCategoria contaCategoria = (ContaCategoria) it.next();

					FiltroCategoria filtroCategoria = new FiltroCategoria();
					filtroCategoria.adicionarParametro(new ParametroSimples(FiltroCategoria.CODIGO, contaCategoria.getComp_id()
									.getCategoria().getId()));

					Collection<Categoria> colecaoCategoriaFiltro;

					colecaoCategoriaFiltro = getControladorUtil().pesquisar(filtroCategoria, Categoria.class.getName());

					Categoria categoria = null;
					if(colecaoCategoriaFiltro != null && !colecaoCategoriaFiltro.isEmpty()){
						categoria = (Categoria) Util.retonarObjetoDeColecao(colecaoCategoriaFiltro);
					}

					categoria.setQuantidadeEconomiasCategoria(contaCategoria.getQuantidadeEconomia().intValue());

					colecaoCategoria.add(categoria);
				}
			}

			// [UC0105] - Obter Consumo Mínimo da Ligação
			int consumoMinimoLigacao = getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, null);

			// Recupera o percentual de esgoto.
			BigDecimal percentualEsgoto = emitirContaHelper.getPercentualEsgotoConta();

			// pegar o percentual da conta

			colecaoValoresCalculadosAguaEsgoto = this.calcularValoresAguaEsgoto(emitirContaHelper.getAmReferencia(), emitirContaHelper
							.getIdLigacaoAguaSituacao(), emitirContaHelper.getIdLigacaoEsgotoSituacao(), emitirContaHelper
							.getIndicadorFaturamentoLigacaoAguaSituacao().shortValue(), emitirContaHelper
							.getIndicadorFaturamentoLigacaoEsgotoSituacao().shortValue(), colecaoCategoria, emitirContaHelper
							.getConsumoAgua(), emitirContaHelper.getConsumoEsgoto(), consumoMinimoLigacao, null, dataLeituraAtual,
							percentualEsgoto, emitirContaHelper.getIdConsumoTarifa(), imovel.getId(), null);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}catch(ControladorException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoValoresCalculadosAguaEsgoto;

	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0005] - Obter Dados da Medição da Conta
	 * [SB0007] - Obter Dados de Consumo da Conta
	 * [SB0008] - Obter Quantidade de Economias da Conta
	 * [SB0010] – Obter Mensagem de Rateio de Consumo ou Consumo Fixo de Esgoto
	 * [SB0017] – Obter Mensagem da Conta
	 * 
	 * @date 24/09/2011
	 * @param List
	 *            <EmitirContaTipo2Helper> coleção de Helpers que representam cada conta a ser
	 *            impressa.
	 * @throws ControladorException
	 * @depredated
	 */
	private Collection completarEmitirContasHelperUmaContaPorPagina(Collection<EmitirContaTipo2Helper> colecaoContaTipo2Retorno)
					throws ControladorException{

		Collection colecaoContaTipo2IteratorDuplicar = new ArrayList();

		Iterator<EmitirContaTipo2Helper> colecaoContaTipo2Iterator = colecaoContaTipo2Retorno.iterator();
		try{

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			while(colecaoContaTipo2Iterator.hasNext()){

				EmitirContaTipo2Helper contaTipo2Helper = colecaoContaTipo2Iterator.next();
				boolean duplicarConta = false;
				boolean adicionarEnderecoEntrega = false;
				boolean pagavelResponsavel = false;
				String enderecoEntrega = "";

				// Matrícula do Imovel
				contaTipo2Helper.setIdImovel(contaTipo2Helper.getIdImovel());

				// Nome do Imóvel ou Nome do cliente usuário
				contaTipo2Helper.setNomeCliente(contaTipo2Helper.getNomeCliente());

				// Endereço do imóvel
				Object[] arrayDadosEnderecoImovel = getControladorEndereco()
								.pesquisarEnderecoFormatadoLista(contaTipo2Helper.getIdImovel());
				contaTipo2Helper.setEndereco((String) arrayDadosEnderecoImovel[0]);
				contaTipo2Helper.setIdLogradouro((Integer) arrayDadosEnderecoImovel[1]);
				contaTipo2Helper.setNumeroImovel((String) arrayDadosEnderecoImovel[2]);

				if(arrayDadosEnderecoImovel[3] != null){

					contaTipo2Helper.setCepImovelFormatado((String) arrayDadosEnderecoImovel[3]);
				}

				// Endereço de entrega
				Integer idImovelContaEnvio = contaTipo2Helper.getIdImovelContaEnvio();
				Imovel imovel = getControladorImovel().pesquisarImovel(contaTipo2Helper.getIdImovel());

				// [UC0108] - Obter Quantidade de Economias por Categoria
				Collection colecaoCategorias = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

				if(idImovelContaEnvio != null){

					if(idImovelContaEnvio.intValue() == ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL.intValue()){

						duplicarConta = true;
						adicionarEnderecoEntrega = true;
						pagavelResponsavel = true;

						// Obter Endereço
						Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
						enderecoEntrega = (String) arrayDadosEndereco[0];
						contaTipo2Helper.setIdLogradouroEnderecoClienteEntrega((Integer) arrayDadosEndereco[1]);
						contaTipo2Helper.setNumeroImovelEnderecoClienteEntrega((String) arrayDadosEndereco[2]);

						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.NAO);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
						contaTipo2Helper.setIndicadorFaturaInformativa(ConstantesSistema.SIM);
					}else if(idImovelContaEnvio.intValue() == ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_PAGAVEL_PARA_RESPONSAVEL.intValue()){

						duplicarConta = true;

						pagavelResponsavel = true;
						adicionarEnderecoEntrega = true;

						// Obter Endereço
						Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
						enderecoEntrega = (String) arrayDadosEndereco[0];
						contaTipo2Helper.setIdLogradouroEnderecoClienteEntrega((Integer) arrayDadosEndereco[1]);
						contaTipo2Helper.setNumeroImovelEnderecoClienteEntrega((String) arrayDadosEndereco[2]);

						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
					}else if(idImovelContaEnvio.intValue() == ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_NAO_PAGAVEL_PARA_RESPOSAVEL.intValue()){

						duplicarConta = true;
						adicionarEnderecoEntrega = true;

						// Obter Endereço
						Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
						enderecoEntrega = (String) arrayDadosEndereco[0];
						contaTipo2Helper.setIdLogradouroEnderecoClienteEntrega((Integer) arrayDadosEndereco[1]);
						contaTipo2Helper.setNumeroImovelEnderecoClienteEntrega((String) arrayDadosEndereco[2]);

						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
					}else if(idImovelContaEnvio.intValue() == ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL.intValue()
									|| idImovelContaEnvio.intValue() == ImovelContaEnvio.ENVIAR_PARA_CLIENTE_PROPRIETARIO.intValue()
									|| idImovelContaEnvio.intValue() == ImovelContaEnvio.ENVIAR_PARA_CLIENTE_USUARIO.intValue()){

						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);

						// Obter Endereço
						Object[] arrayDadosEndereco = this.obterEnderecoEntregaCliente(imovel);
						enderecoEntrega = (String) arrayDadosEndereco[0];
						contaTipo2Helper.setIdLogradouroEnderecoClienteEntrega((Integer) arrayDadosEndereco[1]);
						contaTipo2Helper.setNumeroImovelEnderecoClienteEntrega((String) arrayDadosEndereco[2]);

						contaTipo2Helper.setEnderecoClienteEntrega(enderecoEntrega);
					}else{ // enviar p/ imovel

						contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
						contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
					}
				}else{ // enviar p/ imovel

					contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.SIM);
					contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.NAO);
				}

				// Referência
				contaTipo2Helper.setAnoMesConta(contaTipo2Helper.getAnoMesConta());

				// Inscrição - Localidade
				contaTipo2Helper.setInscLocalidade(contaTipo2Helper.getInscLocalidade());

				// Inscrição - SetorComercial
				contaTipo2Helper.setInscSetorComercial(contaTipo2Helper.getInscSetorComercial());

				// Inscrição - Quadra
				contaTipo2Helper.setInscQuadra(contaTipo2Helper.getInscQuadra());

				// Inscrição - Lote
				contaTipo2Helper.setInscLote(contaTipo2Helper.getInscLote());

				// Inscrição - Sub Lote
				contaTipo2Helper.setInscSubLote(contaTipo2Helper.getInscSubLote());

				// Economias da Conta por categoria
				// [SB0008] - Obter Quantidade de Economias da Conta
				Collection<ContaCategoria> colecaoContaCategoria = repositorioFaturamento.pesquisarContaCategoria(contaTipo2Helper
								.getIdConta());
				if(colecaoContaCategoria != null && !colecaoContaCategoria.isEmpty()){

					Iterator<ContaCategoria> iteratorCategoria = colecaoContaCategoria.iterator();
					while(iteratorCategoria.hasNext()){

						ContaCategoria contaCategoria = iteratorCategoria.next();

						if(contaCategoria.getComp_id().getCategoria() != null){

							Categoria categoria = contaCategoria.getComp_id().getCategoria();

							// Residencial, Comercial, Industrial ou Publico
							if(categoria.getId().equals(Categoria.RESIDENCIAL)){

								contaTipo2Helper.setEconResidencial(contaCategoria.getQuantidadeEconomia());
							}else if(categoria.getId().equals(Categoria.COMERCIAL)){

								contaTipo2Helper.setEconComercial(contaCategoria.getQuantidadeEconomia());
							}else if(categoria.getId().equals(Categoria.INDUSTRIAL)){

								contaTipo2Helper.setEconIndustrial(contaCategoria.getQuantidadeEconomia());
							}else if(categoria.getId().equals(Categoria.PUBLICO)){

								contaTipo2Helper.setEconPublica(contaCategoria.getQuantidadeEconomia());
							}
						}
					}
				}

				// [SB0005] - Obter Dados da Medição da Conta
				Integer tipoLigacao = LigacaoTipo.LIGACAO_AGUA;
				Integer tipoMedicao = null;
				Integer leituraAnterior = null;
				Integer leituraAtual = null;
				Date dataLeituraAnterior = null;
				Date dataLeituraAtual = null;
				Integer idLeituraSituacaoAtual = null;
				Integer idLeituraAnormalidadeFaturamento = null;
				Integer consumoMedido = null;

				MedicaoHistorico medicaoHistoricoAgua = repositorioMicromedicao.pesquisarMedicaoHistoricoTipoAgua(
								contaTipo2Helper.getIdImovel(), contaTipo2Helper.getAnoMesConta());

				// Caso o imóvel possua hidrômetro na ligação de água
				if(medicaoHistoricoAgua != null && medicaoHistoricoAgua.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){

					HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = medicaoHistoricoAgua.getLigacaoAgua()
									.getHidrometroInstalacaoHistorico();
					contaTipo2Helper.setHidrometro(hidrometroInstalacaoHistorico.getHidrometro().getNumero());
					contaTipo2Helper.setHidrometroLocalInstalacao(hidrometroInstalacaoHistorico.getHidrometroLocalInstalacao());
					contaTipo2Helper.setDataInstalacaoHidrometro(hidrometroInstalacaoHistorico.getDataInstalacao());
					contaTipo2Helper.setHidrometroMarca(hidrometroInstalacaoHistorico.getHidrometro().getHidrometroMarca());
					contaTipo2Helper.setHidrometroCapacidade(hidrometroInstalacaoHistorico.getHidrometro().getHidrometroCapacidade());

					leituraAnterior = medicaoHistoricoAgua.getLeituraAnteriorFaturamento();
					leituraAtual = medicaoHistoricoAgua.getLeituraAtualFaturamento();
					dataLeituraAnterior = medicaoHistoricoAgua.getDataLeituraAnteriorFaturamento();
					dataLeituraAtual = medicaoHistoricoAgua.getDataLeituraAtualFaturamento();
					idLeituraSituacaoAtual = medicaoHistoricoAgua.getLeituraSituacaoAtual().getId();

					if(medicaoHistoricoAgua.getLeituraAnormalidadeFaturamento() != null){

						idLeituraAnormalidadeFaturamento = medicaoHistoricoAgua.getLeituraAnormalidadeFaturamento().getId();
					}

					consumoMedido = medicaoHistoricoAgua.getNumeroConsumoMes();

					tipoMedicao = MedicaoTipo.LIGACAO_AGUA;
					contaTipo2Helper.setIndicadorPossuiMedicaoHistorico(ConstantesSistema.SIM);

				}else{

					MedicaoHistorico medicaoHistoricoPoco = repositorioMicromedicao.pesquisarMedicaoHistoricoTipoPoco(
									contaTipo2Helper.getIdImovel(), contaTipo2Helper.getAnoMesConta());

					// Caso o imóvel possua hidrômetro no poço
					if(medicaoHistoricoPoco != null && medicaoHistoricoPoco.getImovel().getHidrometroInstalacaoHistorico() != null){

						HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = medicaoHistoricoPoco.getImovel()
										.getHidrometroInstalacaoHistorico();

						contaTipo2Helper.setHidrometro(hidrometroInstalacaoHistorico.getHidrometro().getNumero());
						contaTipo2Helper.setHidrometroLocalInstalacao(hidrometroInstalacaoHistorico.getHidrometroLocalInstalacao());
						contaTipo2Helper.setDataInstalacaoHidrometro(hidrometroInstalacaoHistorico.getDataInstalacao());
						contaTipo2Helper.setHidrometroMarca(hidrometroInstalacaoHistorico.getHidrometro().getHidrometroMarca());
						contaTipo2Helper.setHidrometroCapacidade(hidrometroInstalacaoHistorico.getHidrometro().getHidrometroCapacidade());

						leituraAnterior = medicaoHistoricoPoco.getLeituraAnteriorFaturamento();
						leituraAtual = medicaoHistoricoPoco.getLeituraAtualFaturamento();
						dataLeituraAnterior = medicaoHistoricoPoco.getDataLeituraAnteriorFaturamento();
						dataLeituraAtual = medicaoHistoricoPoco.getDataLeituraAtualFaturamento();
						idLeituraSituacaoAtual = medicaoHistoricoPoco.getLeituraSituacaoAtual().getId();

						if(medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() != null){

							idLeituraAnormalidadeFaturamento = medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento().getId();
						}

						consumoMedido = medicaoHistoricoPoco.getNumeroConsumoMes();

						tipoLigacao = LigacaoTipo.LIGACAO_ESGOTO;
						tipoMedicao = MedicaoTipo.POCO;
						contaTipo2Helper.setIndicadorPossuiMedicaoHistorico(ConstantesSistema.SIM);
					}else{

						// Caso contrário, o imóvel é não medido
						contaTipo2Helper.setIndicadorPossuiMedicaoHistorico(ConstantesSistema.NAO);
					}
				}


				// Inicio - Período de Consumo e leituras
				contaTipo2Helper.setDtLeituraAnterior(dataLeituraAnterior);
				contaTipo2Helper.setDtLeituraAtual(dataLeituraAtual);
				contaTipo2Helper.setLeituraAnterior(leituraAnterior);
				contaTipo2Helper.setLeituraAtual(leituraAtual);
				contaTipo2Helper.setIdLeituraSituacaoAtual(idLeituraSituacaoAtual);
				contaTipo2Helper.setIdLeituraAnormalidadeFaturamento(idLeituraAnormalidadeFaturamento);
				contaTipo2Helper.setIdTipoLigacao(tipoLigacao);

				if(tipoMedicao != null){

					contaTipo2Helper.setIdTipoMedicao(tipoMedicao);
				}

				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				faturamentoGrupo.setId(contaTipo2Helper.getIdFaturamentoGrupo());
				FaturamentoAtividade atividadeLeitura = new FaturamentoAtividade();
				atividadeLeitura.setId(FaturamentoAtividade.EFETUAR_LEITURA);

				// Caso não tenha localizado a data de leitura Anterior, pegar a data da atividade
				// de leitura do Cronograma
				if(contaTipo2Helper.getDtLeituraAnterior() == null){

					int anoMesAnterior = Util.subtrairMesDoAnoMes(contaTipo2Helper.getAnoMesConta().intValue(), 1);

					Object[] dadosAtividadeLeituraGrupo = repositorioFaturamento.obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
									faturamentoGrupo, anoMesAnterior, atividadeLeitura);
					if(dadosAtividadeLeituraGrupo != null){

						if(dadosAtividadeLeituraGrupo[1] != null){

							contaTipo2Helper.setDtLeituraAnterior((Date) dadosAtividadeLeituraGrupo[1]);
						}else{ // Caso a data de realização esteja nula , coloca a data prevista

							if(dadosAtividadeLeituraGrupo[0] != null){

								contaTipo2Helper.setDtLeituraAnterior((Date) dadosAtividadeLeituraGrupo[0]);
							}
						}
					}
				}

				// Caso não tenha localizado a data de leitura Atual, pegar a data da atividade de
				// leitura do Cronograma
				if(contaTipo2Helper.getDtLeituraAtual() == null){

					int anoMesAnterior = contaTipo2Helper.getAnoMesConta().intValue();

					Object[] dadosAtividadeLeituraGrupo = repositorioFaturamento.obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
									faturamentoGrupo, anoMesAnterior, atividadeLeitura);

					if(dadosAtividadeLeituraGrupo != null){

						if(dadosAtividadeLeituraGrupo[1] != null){

							contaTipo2Helper.setDtLeituraAtual((Date) dadosAtividadeLeituraGrupo[1]);
						}else{ // Caso a data de realização esteja nula , coloca a data prevista

							if(dadosAtividadeLeituraGrupo[0] != null){

								contaTipo2Helper.setDtLeituraAtual((Date) dadosAtividadeLeituraGrupo[0]);
							}
						}
					}
				}
				// Fim - Período de Consumo e leituras

				// Ligação
				contaTipo2Helper.setDescricaoLigacaoAguaSituacao(contaTipo2Helper.getDescricaoLigacaoAguaSituacao());
				contaTipo2Helper.setDescricaoLigacaoEsgotoSituacao(contaTipo2Helper.getDescricaoLigacaoEsgotoSituacao());

				// Histórico de consumo dos últimos 6 meses
				if(tipoLigacao != null){

					int anoMes = contaTipo2Helper.getAnoMesConta().intValue();
					int qtdMeses = 1;
					int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					// Mês 1
					Integer consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(
									contaTipo2Helper.getIdImovel(), anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes1Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo1Conta(consumo);
					// Mês 2
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes2Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo2Conta(consumo);
					// Mês 3
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes3Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo3Conta(consumo);
					// Mês 4
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes4Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo4Conta(consumo);
					// Mês 5
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes5Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo5Conta(consumo);
					// Mês 6
					qtdMeses++;
					anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
					consumo = repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(contaTipo2Helper.getIdImovel(),
									anoMesSubtraido, tipoLigacao);
					contaTipo2Helper.setAnoMes6Conta(anoMesSubtraido);
					contaTipo2Helper.setConsumo6Conta(consumo);
				}

				// Inicio [SB0007] - Obter Dados de Consumo da Conta
				Object[] parmsConsumoHistorico = null;
				Integer consumoMedio = null;
				String descricaoAnormalidadeConsumo = "";
				Integer idConsumoTipo = null;
				Integer idConsumoAnormalidade = null;

				if(tipoLigacao != null){

					parmsConsumoHistorico = getControladorMicromedicao().obterDadosConsumoConta(contaTipo2Helper.getIdImovel(),
									contaTipo2Helper.getAnoMesConta(), tipoLigacao);

					if(parmsConsumoHistorico != null){

						// Consumo médio
						if(parmsConsumoHistorico[2] != null){

							consumoMedio = (Integer) parmsConsumoHistorico[2];
						}

						// descrição anormalidade de consumo
						if(parmsConsumoHistorico[4] != null){

							descricaoAnormalidadeConsumo = (String) parmsConsumoHistorico[4];
						}

						// Id do Consumo Tipo
						if(parmsConsumoHistorico[6] != null){

							idConsumoTipo = (Integer) parmsConsumoHistorico[6];
						}

						// Id do Consumo Anormalidade
						if(parmsConsumoHistorico[7] != null){

							idConsumoAnormalidade = (Integer) parmsConsumoHistorico[7];
						}
					}
				}
				// Fim [SB0007]

				// Consumo Médio
				if(consumoMedio != null){

					contaTipo2Helper.setConsumoMedio(consumoMedio);
				}

				// Anormalidade Consumo
				contaTipo2Helper.setDescricaoAnormalidadeConsumo(descricaoAnormalidadeConsumo);

				// Id do Tipo de Consumo
				contaTipo2Helper.setIdConsumoTipo(idConsumoTipo);

				// Id do Consumo Anormalidade
				contaTipo2Helper.setIdConsumoAnormalidade(idConsumoAnormalidade);

				// Desrição Tipo Consumo
				if(tipoMedicao != null){

					FiltroMedicaoTipo filtroMedicaoTipo = new FiltroMedicaoTipo();
					filtroMedicaoTipo.adicionarParametro(new ParametroSimples(FiltroMedicaoTipo.ID, tipoMedicao));
					Collection<MedicaoTipo> colecaoMedicaoTipo = repositorioUtil.pesquisar(filtroMedicaoTipo, MedicaoTipo.class.getName());

					if(colecaoMedicaoTipo != null && !colecaoMedicaoTipo.isEmpty()){

						contaTipo2Helper.setDescricaoTipoConsumo(colecaoMedicaoTipo.iterator().next().getDescricao());
					}
				}

				// Inicio [SB0010] – Obter Mensagem de Rateio de Consumo ou Consumo Fixo de Esgoto
				/*
				 * 3. Caso o tipo de medição corresponda a poço e não existam dados de medição
				 * (verificar [FS0002]) ou o tipo de medição corresponda a ligação de água e o
				 * volume coletado de esgoto (CNTA_NNCONSUMOESGOTO) seja diferente de nulo e maior
				 * que o consumo de água (CNTA_NNCONSUMOAGUA)
				 */
				Integer idTipoContrato = 0;
				if(tipoMedicao != null
								&& ((tipoMedicao.intValue() == MedicaoTipo.POCO.intValue() && contaTipo2Helper
												.getIndicadorPossuiMedicaoHistorico().equals(ConstantesSistema.NAO)) || (tipoMedicao
												.intValue() == MedicaoTipo.LIGACAO_AGUA.intValue() && (contaTipo2Helper.getConsumoEsgoto() != null && contaTipo2Helper
												.getConsumoEsgoto().intValue() > contaTipo2Helper.getConsumoAgua().intValue())))){

					idTipoContrato = 2;
				}

				contaTipo2Helper.setIdTipoContrato(idTipoContrato);
				// Fim [SB0010]

				// Inicio [SB0017] – Obter Mensagem da Conta
				Object[] mensagensConta = null;
				String mensagemConta = "";

				// Alterado por: Yara Souza
				// Data: 27/05/2010
				// O campo AnoReferenciaDebitoConta recebe o ano em que deve ser exibida a mensagem
				// de cliente sem débitos.
				// Caso não seja mais necessária a exibição da mensagem o mesmo deve receber valor
				// null e seguir o fluxo 2
				if(sistemaParametro.getAnoReferenciaDebitoConta() != null){

					Integer idImovel = contaTipo2Helper.getIdImovel();
					Integer idQuitacaoMensagem = this.verificarContaDebitoAnualConta(idImovel, sistemaParametro);

					if(idQuitacaoMensagem != null){

						mensagensConta = repositorioFaturamento.pesquisarParmsQuitacaoMensagem(idQuitacaoMensagem);

						if(Util.isVazioOrNulo(mensagensConta)){

							mensagensConta = this.pesquisarContaMensagem(contaTipo2Helper.getAnoMesConta(),
											contaTipo2Helper.getIdFaturamentoGrupo(), contaTipo2Helper.getIdGerenciaRegional(),
											contaTipo2Helper.getInscLocalidade(), contaTipo2Helper.getIdSetorComercial());
						}
					}else{

						mensagensConta = this.pesquisarContaMensagem(contaTipo2Helper.getAnoMesConta(),
										contaTipo2Helper.getIdFaturamentoGrupo(), contaTipo2Helper.getIdGerenciaRegional(),
										contaTipo2Helper.getInscLocalidade(), contaTipo2Helper.getIdSetorComercial());
					}

				}else{

					mensagensConta = this.pesquisarContaMensagem(contaTipo2Helper.getAnoMesConta(),
									contaTipo2Helper.getIdFaturamentoGrupo(), contaTipo2Helper.getIdGerenciaRegional(),
									contaTipo2Helper.getInscLocalidade(), contaTipo2Helper.getIdSetorComercial());
				}

				if(mensagensConta != null){

					// Mensagem Conta
					contaTipo2Helper.setMensagemConta(mensagensConta);

					// Conta Mensagem 1
					if(mensagensConta[0] != null){

						mensagemConta += (mensagensConta[0]).toString() + " \n";
						contaTipo2Helper.setMsgContaParte1((mensagensConta[0]).toString());
					}

					// Conta Mensagem 2
					if(mensagensConta[1] != null){

						mensagemConta += (mensagensConta[1]).toString() + " \n";
						contaTipo2Helper.setMsgContaParte2((mensagensConta[1]).toString());
					}

					// Conta Mensagem 3
					if(mensagensConta[2] != null){

						mensagemConta += (mensagensConta[2]).toString();
						contaTipo2Helper.setMsgContaParte3((mensagensConta[2]).toString());
					}
				}

				// Fim [SB0017]

				// Mensagem Conta
				contaTipo2Helper.setMsgConta(mensagemConta);

				// Consumo Faturado
				Integer consumoFaturado = null;
				if(tipoLigacao != null){

					if(tipoLigacao.equals(LigacaoTipo.LIGACAO_AGUA)){

						consumoFaturado = contaTipo2Helper.getConsumoAgua();
					}else if(tipoLigacao.equals(LigacaoTipo.LIGACAO_ESGOTO)){

						consumoFaturado = contaTipo2Helper.getConsumoEsgoto();
					}
				}
				contaTipo2Helper.setConsumoFaturado(consumoFaturado);

				// Consumo Medido / Estimado
				if(consumoMedido != null){

					contaTipo2Helper.setConsumoMedidoEstimado(consumoMedido.toString());
				}

				// [UC0105] - Obter Consumo Mínimo da Ligação
				contaTipo2Helper.setConsumoMinimoLigacao(getControladorMicromedicao().obterConsumoMinimoLigacao(imovel, colecaoCategorias));

				// data Vencimento
				contaTipo2Helper.setDataVencimento(contaTipo2Helper.getDataVencimento());

				// Valor Total Conta
				Conta conta = new Conta();
				conta.setValorAgua(contaTipo2Helper.getValorAgua());
				conta.setValorEsgoto(contaTipo2Helper.getValorEsgoto());
				conta.setValorCreditos(contaTipo2Helper.getValorCreditos());
				conta.setDebitos(contaTipo2Helper.getDebitos());
				conta.setValorImposto(contaTipo2Helper.getValorImpostos());
				contaTipo2Helper.setValorTotalConta(conta.getValorTotal());

				Integer idDebitoAutomatico = repositorioFaturamento.obterDebitoAutomatico(contaTipo2Helper.getIdImovel());
				if(idDebitoAutomatico != null){

					contaTipo2Helper.setIndicadorCodigoBarras(ConstantesSistema.NAO); // conta SEM
					// código de
					// barras
					contaTipo2Helper.setIndicadorDebitoAutomatico(ConstantesSistema.SIM);
				}

				if(contaTipo2Helper.getIndicadorDebitoAutomatico().equals(ConstantesSistema.NAO)){

					String anoMesString = "" + contaTipo2Helper.getAnoMesConta();
					String mesAnoString = anoMesString.substring(4, 6) + anoMesString.substring(0, 4);

					Integer digitoVerificadorContaInt = null;
					Short digitoVerificadorConta = contaTipo2Helper.getDigitoVerificadorConta();

					if(digitoVerificadorConta != null){
						digitoVerificadorContaInt = digitoVerificadorConta.intValue();
					}

					String representacaoNumericaCodBarra = this.getControladorArrecadacao().obterRepresentacaoNumericaCodigoBarra(3,
									contaTipo2Helper.getValorTotalConta(), null, contaTipo2Helper.getIdImovel(), mesAnoString,
									digitoVerificadorContaInt, null, null, null, DocumentoTipo.CONTA, null, null, null, null, null, null);

					// É necessário realizar essa verificação, pois o GSAN passou a utilizar a
					// tabela CODIGO_BARRAS_LAYOUT na hora de definir o código de barras
					String paramIndicadorTrataLegado = ParametroArrecadacao.P_INDICADOR_TRATA_LEGADO.executar();

					if(ConstantesSistema.SIM.toString().equals(paramIndicadorTrataLegado)){
						// Para atender à solicitação do cliente é ncessário incluir nas posições
						// 34-41
						// (fica 36-43 contando com os digitos verificadores) do código de barras do
						// documento CONTA a matrícula do imóvel. Observação: As posições foram
						// referenciadas considerando os 44 caracteres do código de barras, sem os
						// dígitos verificadores. A matrícula ficaria nas posições destacadas no
						// exemplo:
						// 11111111111 D 22222222222 D 33333333333 D 44444444444 D
						// representacaoNumericaCodBarra =
						// Util.inserirMatriculaImovelCodigoBarra(contaTipo2Helper.getIdImovel(),
						// representacaoNumericaCodBarra);
					}

					// Formata a representação númerica do código de barras
					String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11) + "-"
									+ representacaoNumericaCodBarra.substring(11, 12) + " "
									+ representacaoNumericaCodBarra.substring(12, 23) + "-"
									+ representacaoNumericaCodBarra.substring(23, 24) + " "
									+ representacaoNumericaCodBarra.substring(24, 35) + "-"
									+ representacaoNumericaCodBarra.substring(35, 36) + " "
									+ representacaoNumericaCodBarra.substring(36, 47) + "-"
									+ representacaoNumericaCodBarra.substring(47, 48);
					contaTipo2Helper.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

					String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra.substring(0, 11)
									+ representacaoNumericaCodBarra.substring(12, 23) + representacaoNumericaCodBarra.substring(24, 35)
									+ representacaoNumericaCodBarra.substring(36, 47);
					contaTipo2Helper.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);
				}

				// Inscrição Formatada
				contaTipo2Helper.setInscricao(imovel.getInscricaoFormatada());

				// duplica a conta para enviar uma via de DEMONSTRAÇAO
				if(duplicarConta){

					EmitirContaTipo2Helper contaDemonstracao = new EmitirContaTipo2Helper();

					try{

						contaDemonstracao = (EmitirContaTipo2Helper) contaTipo2Helper.clone();
					}catch(CloneNotSupportedException e){

						throw new ControladorException("erro.sistema", e);
					}

					if(adicionarEnderecoEntrega){
						contaDemonstracao.setEnderecoClienteEntrega(enderecoEntrega);
					}

					if(pagavelResponsavel){

						contaDemonstracao.setIndicadorFaturaInformativa(ConstantesSistema.NAO);
						contaDemonstracao.setIndicadorCodigoBarras(ConstantesSistema.SIM);
					}else{

						contaDemonstracao.setIndicadorFaturaInformativa(ConstantesSistema.SIM);
						contaDemonstracao.setIndicadorCodigoBarras(ConstantesSistema.NAO);
					}

					colecaoContaTipo2IteratorDuplicar.add(contaDemonstracao);
				}
			}

			colecaoContaTipo2Retorno.addAll(colecaoContaTipo2IteratorDuplicar);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return colecaoContaTipo2Retorno;

	}

	/**
	 * [UC0084] Gerar Faturamento Imediato
	 * [SB0017] Verificar Existência de Desconto para o Débito a Cobrar de Parcelamento
	 * 
	 * @author Hebert Falcão
	 * @date 30/11/2012
	 */
	private Object[] verificarExistenciaDescontoDebitoCobradoParcelamento(Integer idDebitoCobrado, Integer idConta, Integer idDebitoTipo,
					Short numeroPrestacaoDebito, Short numeroPrestacao, BigDecimal vlRubrica,
					MovimentoRoteiroEmpresa movimentoRoteiroEmpresa, Map<Integer, BigDecimal> mapCreditoResidual)
					throws ControladorException{

		// Map utilizado para acumular o crédito residual do desconto de acréscimos por
		// impontualidade
		if(mapCreditoResidual == null){
			mapCreditoResidual = new HashMap<Integer, BigDecimal>();
		}

		Object[] retorno = new Object[2];

		BigDecimal valorCreditoCalculado = BigDecimal.ZERO;

		Integer idTipoDebitoParAcresPontualidade = Integer
						.valueOf((String) ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_ACRESCIMO_IMPONTUALIDADE.executar());

		Integer idTipoDebitoParAcresPontualidadeCobAdm = Integer
						.valueOf((String) ParametroParcelamento.P_TIPO_DEBITO_PARCELAMENTO_ACRESCIMO_IMPONTUALIDADE_COBRANCA_ADMINISTRATIVA
										.executar());

		if(idTipoDebitoParAcresPontualidade != null
						&& idDebitoTipo != null
						&& idTipoDebitoParAcresPontualidadeCobAdm != null
						&& (idTipoDebitoParAcresPontualidade.intValue() == idDebitoTipo.intValue() || idTipoDebitoParAcresPontualidadeCobAdm
										.intValue() == idDebitoTipo.intValue())){

			FiltroDebitoCobrado filtroDebitoCobrado = new FiltroDebitoCobrado();
			filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.CONTA_ID, idConta));
			filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.DEBITO_TIPO_ID, idDebitoTipo));
			filtroDebitoCobrado
							.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.NUMERO_PRESTACAO_DEBITO, numeroPrestacaoDebito));
			filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.NUMERO_PRESTACAO, numeroPrestacao));

			Collection<DebitoCobrado> colecaoDebitoCobrado = this.getControladorUtil().pesquisar(filtroDebitoCobrado,
							DebitoCobrado.class.getName());

			if(!Util.isVazioOrNulo(colecaoDebitoCobrado)){
				FiltroCreditoARealizar filtroCreditoARealizar = null;

				Collection<CreditoARealizar> colecaoCreditoARealizar = null;

				Parcelamento parcelamento = null;
				Integer idParcelamento = null;

				BigDecimal valorCreditoResidual = BigDecimal.ZERO;

				for(DebitoCobrado debitoCobrado : colecaoDebitoCobrado){
					parcelamento = debitoCobrado.getParcelamento();

					if(parcelamento != null){
						idParcelamento = parcelamento.getId();

						if(mapCreditoResidual.containsKey(idParcelamento)){
							// Como o crédito associado ao parcelamento já foi calculado, o sistema
							// não deve fazer uma nova consulta

							valorCreditoResidual = mapCreditoResidual.get(idParcelamento);

							vlRubrica = vlRubrica.subtract(valorCreditoResidual);

							mapCreditoResidual.put(idParcelamento, BigDecimal.ZERO);
						}else{
							filtroCreditoARealizar = new FiltroCreditoARealizar();
							filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.PARCELAMENTO_ID,
											idParcelamento));
							filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID_CREDITO_TIPO,
											CreditoTipo.DESCONTO_ACRESCIMOS_IMPONTUALIDADE));

							colecaoCreditoARealizar = this.getControladorUtil().pesquisar(filtroCreditoARealizar,
											CreditoARealizar.class.getName());

							if(!Util.isVazioOrNulo(colecaoCreditoARealizar)){
								BigDecimal vlCredCorrespParcelaMes = BigDecimal.ZERO;

								BigDecimal valorCredito = null;
								Short numeroPrestacaoCredito = null;

								Short numeroParcelaBonus = null;

								Short numeroPrestacaoRealizada = null;

								Short numeroPrestacaoRealizadaAux = null;

								BigDecimal calculo1 = null;
								BigDecimal calculo2 = null;
								BigDecimal calculo3 = null;

								BigDecimal valorResidualMesAnterior = null;
								int contador = 1;

								for(CreditoARealizar creditoARealizar : colecaoCreditoARealizar){
									valorCredito = creditoARealizar.getValorCredito();
									numeroPrestacaoCredito = creditoARealizar.getNumeroPrestacaoCredito();

									if(valorCredito != null && numeroPrestacaoCredito != null){
										vlCredCorrespParcelaMes = valorCredito.divide(new BigDecimal(numeroPrestacaoCredito), 2,
														BigDecimal.ROUND_DOWN);
									}

									numeroParcelaBonus = creditoARealizar.getNumeroParcelaBonus();

									if(numeroParcelaBonus == null){
										numeroParcelaBonus = 0;
									}

									numeroPrestacaoRealizada = creditoARealizar.getNumeroPrestacaoRealizada();

									if(numeroPrestacaoCredito != null){
										numeroPrestacaoRealizadaAux = Short.parseShort(String
														.valueOf((numeroPrestacaoCredito - numeroParcelaBonus) - 1));
									}else{
										numeroPrestacaoRealizadaAux = null;
									}

									// Caso seja a última prestação
									if(numeroPrestacaoRealizada != null && numeroPrestacaoRealizadaAux != null
													&& numeroPrestacaoRealizada.shortValue() == numeroPrestacaoRealizadaAux.shortValue()){

										if(valorCredito != null){
											calculo1 = BigDecimal.valueOf(numeroPrestacaoCredito - numeroParcelaBonus);
											calculo2 = vlCredCorrespParcelaMes.multiply(calculo1);
											calculo3 = valorCredito.subtract(calculo2);

											vlCredCorrespParcelaMes = vlCredCorrespParcelaMes.add(calculo3);
										}
									}

									valorResidualMesAnterior = creditoARealizar.getValorResidualMesAnterior();

									if(valorResidualMesAnterior == null){
										valorResidualMesAnterior = BigDecimal.ZERO;
									}

									valorCreditoCalculado = vlCredCorrespParcelaMes.add(valorResidualMesAnterior);
									vlRubrica = vlRubrica.subtract(valorCreditoCalculado);

									if(vlRubrica.compareTo(BigDecimal.ZERO) < 0){
										valorCreditoResidual = vlRubrica.abs();
										vlRubrica = BigDecimal.ZERO;
									}else{
										valorCreditoResidual = BigDecimal.ZERO;
									}

									mapCreditoResidual.put(idParcelamento, valorCreditoResidual);

									if(contador <= 5){

										Util.executarMetodo(movimentoRoteiroEmpresa, "setValorCreditado" + contador, valorCreditoCalculado);
									}else{

										movimentoRoteiroEmpresa.setValorCreditado5(movimentoRoteiroEmpresa.getValorCreditado5().add(
														valorCreditoCalculado));
									}
								}
							}
						}
					}
				}
			}
		}

		retorno[0] = vlRubrica;
		retorno[1] = valorCreditoCalculado;

		return retorno;
	}

	/**
	 * [UC0084] Gerar Faturamento Imediato
	 * [SB0019] Formatar Descrição do Débito
	 * 
	 * @author Hebert Falcão
	 * @date 30/11/2012
	 */
	public String formatarDescricaoDebitoCobrado(Integer idConta, Integer idDebitoTipo, Short numeroPrestacaoDebito, Short numeroPrestacao)
					throws ControladorException{

		String retorno = "";

		FiltroDebitoCobrado filtroDebitoCobrado = new FiltroDebitoCobrado();
		filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.CONTA_ID, idConta));
		filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.DEBITO_TIPO_ID, idDebitoTipo));
		filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.NUMERO_PRESTACAO_DEBITO, numeroPrestacaoDebito));
		filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.NUMERO_PRESTACAO, numeroPrestacao));
		filtroDebitoCobrado.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoCobrado.PARCELAMENTO);
		filtroDebitoCobrado.adicionarCaminhoParaCarregamentoEntidade(FiltroDebitoCobrado.PARCELAMENTO_RESOLUCAO_DIRETORIA);

		Collection<DebitoCobrado> colecaoDebitoCobrado = this.getControladorUtil().pesquisar(filtroDebitoCobrado,
						DebitoCobrado.class.getName());

		if(!Util.isVazioOrNulo(colecaoDebitoCobrado)){
			Parcelamento parcelamento = null;

			ResolucaoDiretoria resolucaoDiretoria = null;
			Integer idResolucaoDiretoria = null;
			Integer idResolucaoDiretoriaAux = null;

			boolean tratarEmissaoAssuntoConta = false;

			Short indicadorEmissaoAssuntoConta = null;

			String descricaoAssunto = "";

			for(DebitoCobrado debitoCobrado : colecaoDebitoCobrado){
				parcelamento = debitoCobrado.getParcelamento();

				if(parcelamento != null){
					resolucaoDiretoria = parcelamento.getResolucaoDiretoria();

					if(resolucaoDiretoria != null){
						idResolucaoDiretoria = resolucaoDiretoria.getId();

						indicadorEmissaoAssuntoConta = resolucaoDiretoria.getIndicadorEmissaoAssuntoConta();

						if(indicadorEmissaoAssuntoConta != null && indicadorEmissaoAssuntoConta.shortValue() == ConstantesSistema.SIM){
							if(idResolucaoDiretoriaAux == null){
								idResolucaoDiretoriaAux = idResolucaoDiretoria;
							}else if(!idResolucaoDiretoriaAux.equals(idResolucaoDiretoria)){
								tratarEmissaoAssuntoConta = false;

								break;
							}

							tratarEmissaoAssuntoConta = true;

							descricaoAssunto = resolucaoDiretoria.getDescricaoAssunto();
						}
					}
				}
			}

			String descricaoDebitoTipo = "";

			FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
			filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.ID, idDebitoTipo));

			Collection<DebitoTipo> colecaoDebitoTipo = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());

			if(!Util.isVazioOrNulo(colecaoDebitoTipo)){
				DebitoTipo debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
				descricaoDebitoTipo = debitoTipo.getDescricao();
			}

			if(tratarEmissaoAssuntoConta){
				if(descricaoDebitoTipo.length() > 13){
					descricaoDebitoTipo = descricaoDebitoTipo.substring(0, 13);
				}

				if(descricaoAssunto.length() > 3){
					descricaoAssunto = descricaoAssunto.substring(0, 3);
				}

				retorno = descricaoDebitoTipo + " " + descricaoAssunto;
			}else{
				retorno = descricaoDebitoTipo;
			}
		}

		return retorno;
	}

	public void cancelarDebitosRotinaAjusteFaturamentoDeso() throws ControladorException{

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.cancelarDebitosDuplicadosSegundaViaAjusteFaturamentoDeso();

		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * @param idImovel
	 * @param anoMesReferencia
	 * @param idDebitoTipo
	 * @param numeroPrestacaoDebito
	 * @return
	 * @throws ControladorException
	 */
	public Collection<DebitoACobrar> pesquisarDebitosACobrarDoImovel(Integer idImovel, Collection anoMesReferencia, Integer idDebitoTipo)
					throws ControladorException{

		Collection<DebitoACobrar> colecao = null;
		try{

			colecao = this.repositorioFaturamento.pesquisarDebitosACobrarDoImovel(idImovel, anoMesReferencia, idDebitoTipo);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return colecao;

	}

	/**
	 * Método que realiza o ajuste do faturamento de débitos a cobrar da DESO para referência 201211
	 * 
	 * @author Yara Souza
	 * @date 26/11/2012
	 */
	public void executarAjusteConta(Integer idGrupoFaturamento) throws ControladorException{

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteConta(idGrupoFaturamento);

		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	private Boolean exibirReferenciaNaFatura(Integer idDebitoTipo, String[] valoresParmTipoDebRefFatura){

		Boolean exibir = Boolean.FALSE;

		for(String valorParametro : valoresParmTipoDebRefFatura){

			if(StringUtils.isNumeric(valorParametro)){

				if(idDebitoTipo.equals(Integer.valueOf(valorParametro))){

					exibir = Boolean.TRUE;
					break;

				}

			}

		}

		return exibir;

	}

	/**
	 * [UC0150][SB0006]
	 * [UC0151][SB0001]
	 * Método responsável por gerar débito automático
	 */
	private void gerarDebitoAutomaticoMovimentoConta(Conta contaAntiga, Conta contaNova, boolean permitirIncluirNovo)
					throws ControladorException{

		Date dataVencimentoContaAntiga = contaAntiga.getDataVencimentoConta();
		Date dataVencimentoContaNova = contaNova.getDataVencimentoConta();

		if(dataVencimentoContaAntiga != null && dataVencimentoContaNova != null){

			Integer qtdDiasVencimento = Integer.valueOf((String) ParametroFaturamento.P_QUANTIDADE_DIAS_VENCIMENTO_DEBITO_AUTOMATICO
							.executar());

			Date dataAtual = Util.adicionarNumeroDiasDeUmaData(new Date(), qtdDiasVencimento);

			if(dataVencimentoContaAntiga.compareTo(dataAtual) == 1 && dataVencimentoContaNova.compareTo(dataAtual) == 1){

				DebitoAutomaticoMovimento debitoAutomaticoMovimento = this.getControladorArrecadacao()
								.pesquisarUltimoDebitoAutomaticoMovimentoConta(contaAntiga.getId());

				if(debitoAutomaticoMovimento != null){

					Boolean gerarMovAtualizar = Boolean.FALSE;
					Boolean gerarMovExcluirIncluir = Boolean.FALSE;
					Boolean gerarMovIncluirNovo = Boolean.FALSE;

					if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
									&& debitoAutomaticoMovimento.getIndicadorExclusao() == null
									&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() == null){

						gerarMovAtualizar = Boolean.TRUE;

					}else if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
									&& debitoAutomaticoMovimento.getIndicadorExclusao() != null
									&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() != null){

						gerarMovExcluirIncluir = Boolean.TRUE;

					}else if(debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() != null
									&& debitoAutomaticoMovimento.getIndicadorExclusao() == null){

						gerarMovExcluirIncluir = Boolean.TRUE;

					}else if(permitirIncluirNovo && debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
									&& debitoAutomaticoMovimento.getIndicadorExclusao() == null
									&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() != null){

						gerarMovIncluirNovo = Boolean.TRUE;

					}else if(permitirIncluirNovo && debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() == null
									&& debitoAutomaticoMovimento.getIndicadorExclusao() != null
									&& debitoAutomaticoMovimento.getDebitoAutomaticoMovimentoCancelamentoMotivo() == null){

						gerarMovIncluirNovo = Boolean.TRUE;

					}else if(permitirIncluirNovo && debitoAutomaticoMovimento.getNumeroSequenciaArquivoEnviado() != null
									&& debitoAutomaticoMovimento.getIndicadorExclusao() != null){

						gerarMovIncluirNovo = Boolean.TRUE;

					}

					if(gerarMovAtualizar){

						// Atualiza movimento

						debitoAutomaticoMovimento.setDataVencimento(contaNova.getDataVencimentoConta());
						debitoAutomaticoMovimento.setValorDebito(contaNova.getValorTotalContaSemImposto());

						FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
						filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, contaNova.getId()));
						Collection colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral, ContaGeral.class.getName());
						ContaGeral novaContaGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);
						debitoAutomaticoMovimento.setContaGeral(novaContaGeral);

						debitoAutomaticoMovimento.setDebitoAutomaticoRetornoCodigo(null);
						debitoAutomaticoMovimento.setFaturamentoGrupo(this.obterFaturamentoGrupoImovel(contaNova.getImovel().getId()));
						debitoAutomaticoMovimento.setProcessamento(new Date());
						debitoAutomaticoMovimento.setEnvioBanco(null);
						debitoAutomaticoMovimento.setRetornoBanco(null);
						debitoAutomaticoMovimento.setUltimaAlteracao(new Date());
						debitoAutomaticoMovimento.setNumeroSequenciaArquivoEnviado(null);
						debitoAutomaticoMovimento.setNumeroSequenciaArquivoRecebido(null);
						debitoAutomaticoMovimento.setIndicadorExclusao(null);
						debitoAutomaticoMovimento.setDebitoAutomaticoMovimentoCancelamentoMotivo(null);

						this.getControladorUtil().atualizar(debitoAutomaticoMovimento);

					}else if(gerarMovExcluirIncluir){

						// Movimento para excluir conta antiga

						DebitoAutomaticoMovimento debitoAutomaticoMovimentoAntigo = new DebitoAutomaticoMovimento();
						debitoAutomaticoMovimentoAntigo.setDebitoAutomatico(debitoAutomaticoMovimento.getDebitoAutomatico());
						debitoAutomaticoMovimentoAntigo.setDataVencimento(debitoAutomaticoMovimento.getDataVencimento());
						debitoAutomaticoMovimentoAntigo.setValorDebito(debitoAutomaticoMovimento.getValorDebito());

						FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
						filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, contaAntiga.getId()));
						Collection colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral, ContaGeral.class.getName());
						ContaGeral contaAtualGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);
						debitoAutomaticoMovimentoAntigo.setContaGeral(contaAtualGeral);

						debitoAutomaticoMovimentoAntigo.setFaturamentoGrupo(debitoAutomaticoMovimento.getFaturamentoGrupo());
						debitoAutomaticoMovimentoAntigo.setProcessamento(new Date());
						debitoAutomaticoMovimentoAntigo.setUltimaAlteracao(new Date());
						debitoAutomaticoMovimentoAntigo.setIndicadorExclusao(ConstantesSistema.SIM);

						this.getControladorUtil().inserir(debitoAutomaticoMovimentoAntigo);

						// Movimento para incluir conta nova

						DebitoAutomaticoMovimento debitoAutomaticoMovimentoNovo = new DebitoAutomaticoMovimento();
						debitoAutomaticoMovimentoNovo.setDebitoAutomatico(debitoAutomaticoMovimento.getDebitoAutomatico());
						debitoAutomaticoMovimentoNovo.setDataVencimento(contaNova.getDataVencimentoConta());
						debitoAutomaticoMovimentoNovo.setValorDebito(contaNova.getValorTotalContaSemImposto());

						filtroContaGeral = new FiltroContaGeral();
						filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, contaNova.getId()));
						colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral, ContaGeral.class.getName());
						ContaGeral novaContaGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);
						debitoAutomaticoMovimentoNovo.setContaGeral(novaContaGeral);

						debitoAutomaticoMovimentoNovo.setFaturamentoGrupo(this.obterFaturamentoGrupoImovel(contaNova.getImovel().getId()));
						debitoAutomaticoMovimentoNovo.setProcessamento(new Date());
						debitoAutomaticoMovimentoNovo.setUltimaAlteracao(new Date());

						this.getControladorUtil().inserir(debitoAutomaticoMovimentoNovo);

					}else if(gerarMovIncluirNovo){

						// Movimento para incluir conta nova

						DebitoAutomaticoMovimento debitoAutomaticoMovimentoNovo = new DebitoAutomaticoMovimento();
						debitoAutomaticoMovimentoNovo.setDebitoAutomatico(debitoAutomaticoMovimento.getDebitoAutomatico());
						debitoAutomaticoMovimentoNovo.setDataVencimento(contaNova.getDataVencimentoConta());
						debitoAutomaticoMovimentoNovo.setValorDebito(contaNova.getValorTotalContaSemImposto());

						FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
						filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, contaNova.getId()));
						Collection colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral, ContaGeral.class.getName());
						ContaGeral novaContaGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);
						debitoAutomaticoMovimentoNovo.setContaGeral(novaContaGeral);

						debitoAutomaticoMovimentoNovo.setFaturamentoGrupo(this.obterFaturamentoGrupoImovel(contaNova.getImovel().getId()));
						debitoAutomaticoMovimentoNovo.setProcessamento(new Date());
						debitoAutomaticoMovimentoNovo.setUltimaAlteracao(new Date());

						this.getControladorUtil().inserir(debitoAutomaticoMovimentoNovo);
					}
				}
			}
		}
	}

	private FaturamentoGrupo obterFaturamentoGrupoImovel(Integer idImovel) throws ControladorException{

		FaturamentoGrupo faturamentoGrupo = null;

		FiltroImovel filtroImovel = new FiltroImovel();
		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovel));
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.ROTA_FATURAMENTO_GRUPO);

		Imovel imovel = (Imovel) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()));

		if(imovel.getRota() != null && imovel.getRota().getFaturamentoGrupo() != null){

			faturamentoGrupo = imovel.getRota().getFaturamentoGrupo();

		}

		return faturamentoGrupo;

	}

	public void executarCancelamentoDebitoACobrar() throws ControladorException{

		try{
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarCancelamentoDebitoACobrar();
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}



	public void executarCancelamentoDebitoACobrarRateioCasal() throws ControladorException{

		try{
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarCancelamentoDebitoACobrarRateioCasal();
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * @throws ControladorException
	 */

	public void executarAjusteDebitoACobrar() throws ControladorException{

		try{
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteDebitoACobrar();
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * @param idCreditoTipo
	 * @return
	 * @throws ControladorException
	 */
	public Collection<CreditoOrigem> listarCreditoOrigem(Integer idCreditoTipo, Short indicadorUsoLivre) throws ControladorException{

		Collection<CreditoOrigem> retorno = null;

		try{

			retorno = repositorioFaturamento.listarCreditoOrigem(idCreditoTipo, indicadorUsoLivre);

		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);

		}

		return retorno;

	}

	/**
	 * [UC0195] [SB0001]
	 * Método responsável por estornar um pagamento
	 * 
	 * @param creditoARealizar
	 * @throws ControladorException
	 */
	private void estornarPagamento(CreditoARealizar creditoARealizar, Usuario usuarioLogado) throws ControladorException{

		if(creditoARealizar.getPagamentoHistorico() != null && creditoARealizar.getValorResidualMesAnterior() != null
						&& creditoARealizar.getValorResidualMesAnterior().equals(BigDecimal.ZERO)){

			PagamentoHistorico pagamentoHistorico = creditoARealizar.getPagamentoHistorico();

			creditoARealizar.setPagamentoHistorico(null);

			this.getControladorUtil().atualizar(creditoARealizar);

			this.getControladorArrecadacao().estornarPagamento(pagamentoHistorico, usuarioLogado);

		}

	}

	/**
	 * Método responavel por agrupar os creditos realizados baseado no credito a realizar geral
	 * 
	 * @param map
	 * @param creditoRealizado
	 * @param collCreditoRealizado
	 */
	private void agruparCreditosRealizadosTratados(Map<Integer, Collection<CreditoRealizado>> map, CreditoRealizado creditoRealizado,
					Collection<CreditoRealizado> collCreditoRealizado){

		CreditoARealizarGeral crg = null;

		if(creditoRealizado != null){

			crg = creditoRealizado.getCreditoARealizarGeral();

			if(crg != null){

				if(map.containsKey(crg.getId())){

					map.get(crg.getId()).add(creditoRealizado);

				}else{

					Collection<CreditoRealizado> coll = new ArrayList<CreditoRealizado>();
					coll.add(creditoRealizado);

					map.put(crg.getId(), coll);

				}

			}

		}else{

			if(collCreditoRealizado != null){

				for(CreditoRealizado cr : collCreditoRealizado){

					crg = cr.getCreditoARealizarGeral();

					if(crg != null){

						if(map.containsKey(crg.getId())){

							map.get(crg.getId()).add(cr);

						}else{

							Collection<CreditoRealizado> coll = new ArrayList<CreditoRealizado>();
							coll.add(cr);

							map.put(crg.getId(), coll);

						}

					}

				}

			}

		}

	}

	/**
	 * Método responsável por agrupar os creditos realizados comparando sua existência atual com a
	 * anterior
	 * 
	 * @param collBd
	 * @param collAtualizada
	 * @return
	 */
	private Map<String, Collection<CreditoRealizado>> agruparCreditosRealizados(Collection<CreditoRealizado> collBd,
					Collection<CreditoRealizado> collAtualizada){

		Map<String, Collection<CreditoRealizado>> retorno = new HashMap<String, Collection<CreditoRealizado>>();
		retorno.put("CREDITOS_NOVOS", new ArrayList<CreditoRealizado>());
		retorno.put("CREDITOS_MENOR", new ArrayList<CreditoRealizado>());
		retorno.put("CREDITOS_MAIOR", new ArrayList<CreditoRealizado>());
		retorno.put("CREDITOS_EXCLUIDOS", new ArrayList<CreditoRealizado>());
		retorno.put("CREDITOS_SEM_ALTERACAO", new ArrayList<CreditoRealizado>());

		for(CreditoRealizado creditoRealizado : collAtualizada){

			if(creditoRealizado.getId() == null){

				retorno.get("CREDITOS_NOVOS").add(creditoRealizado);

			}else{

				for(CreditoRealizado creditoRealizadoBd : collBd){

					if(creditoRealizadoBd.getId().equals(creditoRealizado.getId())){

						if(creditoRealizadoBd.getValorCredito().compareTo(creditoRealizado.getValorCredito()) == 1){

							retorno.get("CREDITOS_MENOR").add(creditoRealizado);

						}else if(creditoRealizadoBd.getValorCredito().compareTo(creditoRealizado.getValorCredito()) == -1){

							retorno.get("CREDITOS_MAIOR").add(creditoRealizado);

						}else{

							retorno.get("CREDITOS_SEM_ALTERACAO").add(creditoRealizado);

						}

						break;

					}

				}

			}

		}

		for(CreditoRealizado creditoRealizadoBd : collBd){

			Boolean encontrou = Boolean.FALSE;

			for(CreditoRealizado creditoRealizado : collAtualizada){

				if(creditoRealizado.getId() != null && creditoRealizado.getId().equals(creditoRealizadoBd.getId())){

					encontrou = Boolean.TRUE;
					break;

				}

			}

			if(!encontrou){

				retorno.get("CREDITOS_EXCLUIDOS").add(creditoRealizadoBd);

			}

		}

		return retorno;

	}

	/**
	 * Método responsável por remover um credito a realizar do historico
	 * 
	 * @param idCreditoARealizarHistorico
	 * @param numeroPrestacaoRealizada
	 * @throws ControladorException
	 */
	private void estornarCreditoARealizar(Integer idCreditoARealizarHistorico, Short numeroPrestacaoRealizada) throws ControladorException{

		try{

			this.repositorioFaturamento.estornarCreditoARealizar(idCreditoARealizarHistorico, numeroPrestacaoRealizada);

		}catch(ErroRepositorioException e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);

		}

	}

	/**
	 * Método responsável por Estornar crédito ou atualizar seu valor residual
	 * 
	 * @param creditoRealizado
	 * @param creditoARealizarExcluido
	 * @throws ControladorException
	 */
	private void tratarCreditoARealizarExcluidoEMenor(CreditoRealizado creditoRealizado, Boolean creditoARealizarExcluido,
					Collection<CreditoRealizado> collBd) throws ControladorException{

		if(creditoRealizado.getCreditoARealizarGeral() != null){

			FiltroCreditoARealizar filtro = new FiltroCreditoARealizar();
			filtro.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID, creditoRealizado.getCreditoARealizarGeral().getId()));

			CreditoARealizar creditoARealizar = (CreditoARealizar) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtro,
							CreditoARealizar.class.getName()));

			// Caso o credito a realizar esteja em historico
			if(creditoARealizar == null){

				BigDecimal totalCreditoRealizadoAnterior = BigDecimal.ZERO;

				if(!Util.isVazioOrNulo(collBd)){
					for(CreditoRealizado creditoRealizadoAnterior : collBd){
						if(creditoRealizadoAnterior.getId().equals(creditoRealizado.getId())){
							totalCreditoRealizadoAnterior = totalCreditoRealizadoAnterior.add(creditoRealizadoAnterior.getValorCredito());
						}
					}
				}

				FiltroCreditoARealizarHistorico filtroHistorico = new FiltroCreditoARealizarHistorico();
				filtroHistorico.adicionarParametro(new ParametroSimples(FiltroCreditoARealizarHistorico.ID, creditoRealizado
								.getCreditoARealizarGeral().getId()));

				CreditoARealizarHistorico creditoARealizarHistorico = (CreditoARealizarHistorico) Util.retonarObjetoDeColecao(this
								.getControladorUtil().pesquisar(filtroHistorico, CreditoARealizarHistorico.class.getName()));

				// Estornar o credito a realizar em historico
				this.estornarCreditoARealizar(creditoARealizarHistorico.getId(),
								!creditoARealizarExcluido ? creditoARealizarHistorico.getPrestacaoRealizadas() : Short.valueOf("0"));

				// Caso a seja o tratamento de credito excluido, o valor residual e o numero de
				// prestações realizadas são atualizados e o credito é enviado ou não para historico
				// if(!creditoARealizarExcluido){
				creditoARealizar = (CreditoARealizar) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtro,
								CreditoARealizar.class.getName()));

				BigDecimal vlCreditoRealizado = creditoRealizado.getValorCredito();

				// BigDecimal vlCreditoARealizar = creditoARealizar.getValorTotal();

				BigDecimal vlResidual = totalCreditoRealizadoAnterior.subtract(vlCreditoRealizado);

				creditoARealizar.setNumeroPrestacaoRealizada(Short.valueOf("1"));
				creditoARealizar.setValorResidualMesAnterior(vlResidual);
				creditoARealizar.setUltimaAlteracao(new Date());

				Collection<CreditoARealizar> colecaoCreditosARealizarUpdate = new ArrayList<CreditoARealizar>();
				colecaoCreditosARealizarUpdate.add(creditoARealizar);

				this.atualizarCreditoARealizar(colecaoCreditosARealizarUpdate);
				// }

			}else{

				// Caso o credito a realizar não esteja em historico, o valor do credito e o valor
				// residual são atualizados e o credito é enviado ou não para historico

				FiltroCreditoRealizado filtroCreditoRealizado = new FiltroCreditoRealizado();
				filtroCreditoRealizado.adicionarParametro(new ParametroSimples(FiltroCreditoRealizado.CODIGO, creditoRealizado.getId()));

				CreditoRealizado creditoRealizadoBd = (CreditoRealizado) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(
								filtroCreditoRealizado, CreditoRealizado.class.getName()));

				BigDecimal vlDifCredito = null;

				if(!creditoARealizarExcluido){

					vlDifCredito = creditoRealizadoBd.getValorCredito().subtract(creditoRealizado.getValorCredito());

				}else{

					vlDifCredito = creditoRealizadoBd.getValorCredito();

				}

				BigDecimal vlResidual = creditoARealizar.getValorResidualMesAnterior();

				if(vlResidual != null){

					vlResidual = vlResidual.add(vlDifCredito);

				}else{

					vlResidual = vlDifCredito;

				}

				if(vlResidual != null && vlResidual.compareTo(creditoARealizar.getValorCredito()) == 0){

					creditoARealizar.setValorResidualMesAnterior(BigDecimal.ZERO);
					creditoARealizar.setNumeroPrestacaoRealizada(Short.valueOf("0"));
					creditoARealizar.setUltimaAlteracao(new Date());

				}else{

					creditoARealizar.setValorResidualMesAnterior(vlResidual);
					creditoARealizar.setUltimaAlteracao(new Date());

				}

				Collection<CreditoARealizar> colecaoCreditosARealizarUpdate = new ArrayList<CreditoARealizar>();
				colecaoCreditosARealizarUpdate.add(creditoARealizar);

				this.atualizarCreditoARealizar(colecaoCreditosARealizarUpdate);

			}

		}else{

			throw new ControladorException("atencao.atualizacao.timestamp");

		}

	}

	/**
	 * Método responsável por Estornar crédito ou atualizar seu valor residual
	 * 
	 * @param idImovel
	 * @param creditoRealizado
	 * @return
	 * @throws ControladorException
	 */
	private Collection<CreditoRealizado> tratarCreditoARealizarAMaior(Integer idImovel, CreditoRealizado creditoRealizado)
					throws ControladorException{

		Collection<CreditoRealizado> collCreditoRealizado = new ArrayList<CreditoRealizado>();

		BigDecimal dif = this.obterDiferencaValorCreditoRealizado(creditoRealizado);
		BigDecimal difAux = dif;

		BigDecimal vlCr = creditoRealizado.getValorCredito();
		FiltroCreditoARealizar filtroCreditoARealizar = new FiltroCreditoARealizar();
		filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID, creditoRealizado
						.getCreditoARealizarGeral().getId()));
		CreditoARealizar credARealizarUtilizado = (CreditoARealizar) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(
						filtroCreditoARealizar, CreditoARealizar.class.getName()));

		// Caso o valor do credito utilizado seja maior ou igual ao valor do credito realizado,
		// então é gerado um novo credito realizado e o valor do credito e o valor residual são
		// atualizados e o credito é enviado ou não para historico
		if(credARealizarUtilizado != null && credARealizarUtilizado.getValorTotal().compareTo(vlCr) >= 0){

			// É gerado um credito realizado
			CreditoRealizado credGerado = this.gerarCreditoRealizado(creditoRealizado);
			credGerado.setValorCredito(vlCr);
			collCreditoRealizado.add(credGerado);

			credARealizarUtilizado.setNumeroPrestacaoRealizada(Short.valueOf("1"));
			credARealizarUtilizado.setValorResidualMesAnterior(credARealizarUtilizado.getValorTotal().subtract(vlCr));
			credARealizarUtilizado.setUltimaAlteracao(new Date());

			Collection<CreditoARealizar> colecaoCreditosARealizarUpdate = new ArrayList<CreditoARealizar>();
			colecaoCreditosARealizarUpdate.add(credARealizarUtilizado);
			credGerado.setCreditoARealizarGeral(credARealizarUtilizado.getCreditoARealizarGeral());

			this.atualizarCreditoARealizar(colecaoCreditosARealizarUpdate);

		}else{

			// Caso o valor do credito utilizado seja menor que o valor do credito realizado, então
			// seu valor é abatido dos creditos disponiveis que por sua vez podem ir ou não para
			// historico
			BigDecimal vlCar = null;

			Collection<CreditoARealizar> collCreditoARealizar = this.obterCreditosARealizarDisponiveis(idImovel, creditoRealizado
							.getCreditoTipo().getId());

			Boolean criou = Boolean.FALSE;

			for(CreditoARealizar car : collCreditoARealizar){

				vlCar = car.getValorTotal();

				if(vlCar.compareTo(dif) > 0){

					// É gerado um credito realizado
					CreditoRealizado credGerado = this.gerarCreditoRealizado(creditoRealizado);
					credGerado.setCreditoARealizarGeral(car.getCreditoARealizarGeral());
					credGerado.setValorCredito(dif);
					collCreditoRealizado.add(credGerado);

					if(!criou){

						// É gerado um credito realizado
						CreditoRealizado credGerado2 = this.gerarCreditoRealizado(creditoRealizado);
						credGerado2.setCreditoARealizarGeral(creditoRealizado.getCreditoARealizarGeral());
						credGerado2.setValorCredito(vlCr.subtract(difAux));
						collCreditoRealizado.add(credGerado2);

						criou = Boolean.TRUE;

					}

					car.setNumeroPrestacaoRealizada(Short.valueOf("1"));
					car.setValorResidualMesAnterior(vlCar.subtract(dif));
					car.setUltimaAlteracao(new Date());

					Collection<CreditoARealizar> colecaoCreditosARealizarUpdate = new ArrayList<CreditoARealizar>();
					colecaoCreditosARealizarUpdate.add(car);

					this.atualizarCreditoARealizar(colecaoCreditosARealizarUpdate);

					break;

				}else{

					dif = dif.subtract(vlCar);

					// É gerado um credito realizado
					CreditoRealizado credGerado = this.gerarCreditoRealizado(creditoRealizado);
					credGerado.setCreditoARealizarGeral(car.getCreditoARealizarGeral());
					credGerado.setValorCredito(vlCar);
					collCreditoRealizado.add(credGerado);

					car.setNumeroPrestacaoRealizada(Short.valueOf("1"));
					car.setValorResidualMesAnterior(BigDecimal.ZERO);
					car.setUltimaAlteracao(new Date());

					Collection<CreditoARealizar> colecaoCreditosARealizarUpdate = new ArrayList<CreditoARealizar>();
					colecaoCreditosARealizarUpdate.add(car);

					this.atualizarCreditoARealizar(colecaoCreditosARealizarUpdate);

					if(!criou){

						// É gerado um credito realizado
						CreditoRealizado credGerado2 = this.gerarCreditoRealizado(creditoRealizado);
						credGerado2.setCreditoARealizarGeral(creditoRealizado.getCreditoARealizarGeral());
						credGerado2.setValorCredito(vlCr.subtract(difAux));
						collCreditoRealizado.add(credGerado2);

						criou = Boolean.TRUE;

					}

					if(dif.compareTo(BigDecimal.ZERO) == 0){

						break;

					}

				}

			}

		}

		return collCreditoRealizado;

	}

	private BigDecimal obterDiferencaValorCreditoRealizado(CreditoRealizado creditoRealizado) throws ControladorException{

		FiltroCreditoRealizado filtro = new FiltroCreditoRealizado();
		filtro.adicionarParametro(new ParametroSimples(FiltroCreditoRealizado.CODIGO, creditoRealizado.getId()));

		CreditoRealizado creditoRealizadoBd = (CreditoRealizado) Util.retonarObjetoDeColecao(this.getControladorUtil().pesquisar(filtro,
						CreditoRealizado.class.getName()));

		BigDecimal dif = BigDecimal.ZERO;

		if(creditoRealizadoBd != null){

			dif = creditoRealizado.getValorCredito().subtract(creditoRealizadoBd.getValorCredito());

		}

		return dif;

	}

	/**
	 * Método responsável por Estornar crédito ou atualizar seu valor residual
	 * 
	 * @param idImovel
	 * @param creditoRealizado
	 * @return
	 * @throws ControladorException
	 */
	private Collection<CreditoRealizado> tratarCreditoARealizarNovos(Integer idImovel, CreditoRealizado creditoRealizado)
					throws ControladorException{

		Collection<CreditoRealizado> collCreditoRealizado = new ArrayList<CreditoRealizado>();
		Collection<CreditoARealizar> collCreditoARealizar = this.obterCreditosARealizarDisponiveis(idImovel, creditoRealizado
						.getCreditoTipo().getId());

		BigDecimal vlCr = creditoRealizado.getValorCredito();
		BigDecimal vlCar = null;
		BigDecimal vlResidual = null;

		// O valor do novo credito é abatido dos creditos disponiveis que por sua vez podem ir ou
		// não para historico

		for(CreditoARealizar car : collCreditoARealizar){

			vlCar = car.getValorTotal();

			if(vlCar.compareTo(vlCr) > 0){

				// É gerado um credito realizado
				CreditoRealizado credGerado = this.gerarCreditoRealizado(creditoRealizado);
				credGerado.setValorCredito(vlCr);
				collCreditoRealizado.add(credGerado);

				vlResidual = vlCar.subtract(vlCr);

				car.setNumeroPrestacaoRealizada(Short.valueOf("1"));
				car.setValorResidualMesAnterior(vlResidual);
				car.setUltimaAlteracao(new Date());

				Collection<CreditoARealizar> colecaoCreditosARealizarUpdate = new ArrayList<CreditoARealizar>();
				colecaoCreditosARealizarUpdate.add(car);
				credGerado.setCreditoARealizarGeral(car.getCreditoARealizarGeral());

				this.atualizarCreditoARealizar(colecaoCreditosARealizarUpdate);

				break;

			}else{
				CreditoRealizado credGerado = this.gerarCreditoRealizado(creditoRealizado);
				credGerado.setValorCredito(vlCar);

				BigDecimal vlOriginalCredito = car.getValorCredito();

				if(vlOriginalCredito.compareTo(vlCr) == 0){

					vlCr = BigDecimal.ZERO;

				}else{

					vlCr = vlCr.subtract(vlCar);

				}

				collCreditoRealizado.add(credGerado);

				car.setNumeroPrestacaoRealizada(Short.valueOf("1"));
				car.setValorResidualMesAnterior(BigDecimal.ZERO);
				car.setUltimaAlteracao(new Date());

				Collection<CreditoARealizar> colecaoCreditosARealizarUpdate = new ArrayList<CreditoARealizar>();
				colecaoCreditosARealizarUpdate.add(car);

				credGerado.setCreditoARealizarGeral(car.getCreditoARealizarGeral());

				this.atualizarCreditoARealizar(colecaoCreditosARealizarUpdate);

				if(vlCr.compareTo(BigDecimal.ZERO) == 0){

					break;

				}

			}

		}

		if(vlCr.compareTo(BigDecimal.ZERO) == -1){

			throw new ControladorException("atencao.atualizacao.timestamp");

		}

		return collCreditoRealizado;

	}

	private CreditoRealizado gerarCreditoRealizado(CreditoRealizado creditoRealizado){

		CreditoRealizado credGerado = new CreditoRealizado();
		credGerado.setDataHoraCreditoRealizado(creditoRealizado.getDataHoraCreditoRealizado());
		credGerado.setCodigoSetorComercial(creditoRealizado.getCodigoSetorComercial());
		credGerado.setNumeroQuadra(creditoRealizado.getNumeroQuadra());
		credGerado.setNumeroLote(creditoRealizado.getNumeroLote());
		credGerado.setNumeroSubLote(creditoRealizado.getNumeroSubLote());
		credGerado.setAnoMesReferenciaCredito(creditoRealizado.getAnoMesReferenciaCredito());
		credGerado.setAnoMesCobrancaCredito(creditoRealizado.getAnoMesCobrancaCredito());
		credGerado.setValorCredito(creditoRealizado.getValorCredito());
		credGerado.setNumeroPrestacao(creditoRealizado.getNumeroPrestacao());
		credGerado.setNumeroPrestacaoCredito(creditoRealizado.getNumeroPrestacaoCredito());
		credGerado.setUltimaAlteracao(new Date());
		credGerado.setConta(creditoRealizado.getConta());
		credGerado.setQuadra(creditoRealizado.getQuadra());
		credGerado.setLocalidade(creditoRealizado.getLocalidade());
		credGerado.setCreditoTipo(creditoRealizado.getCreditoTipo());
		credGerado.setLancamentoItemContabil(creditoRealizado.getLancamentoItemContabil());
		credGerado.setCreditoOrigem(creditoRealizado.getCreditoOrigem());
		credGerado.setParcelamento(creditoRealizado.getParcelamento());
		credGerado.setCreditoARealizarGeral(creditoRealizado.getCreditoARealizarGeral());

		return credGerado;

	}

	public Map<Integer, BigDecimal> obterValorTotalDisponivelCreditoArealizarImovel(Integer idImovel) throws ControladorException{

		Map<Integer, BigDecimal> retorno = new HashMap<Integer, BigDecimal>();
		Collection<CreditoARealizar> coll = this.obterCreditosARealizarDisponiveis(idImovel, null);

		if(!coll.isEmpty()){

			for(CreditoARealizar creditoARealizar : coll){

				if(retorno.containsKey(creditoARealizar.getCreditoTipo().getId())){

					BigDecimal vlAtual = retorno.get(creditoARealizar.getCreditoTipo().getId());
					retorno.remove(creditoARealizar.getCreditoTipo().getId());
					retorno.put(creditoARealizar.getCreditoTipo().getId(), vlAtual.add(creditoARealizar.getValorTotal()));

				}else{

					retorno.put(creditoARealizar.getCreditoTipo().getId(), creditoARealizar.getValorTotal());

				}

			}

		}

		return retorno;

	}

	private Collection<CreditoARealizar> obterCreditosARealizarDisponiveis(Integer idImovel, Integer idCreditoTipo)
					throws ControladorException{

		FiltroCreditoARealizar filtro = new FiltroCreditoARealizar();
		filtro.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.IMOVEL_ID, idImovel));
		filtro.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID_CREDITO_ORIGEM,
						CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO));
		filtro.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.IC_USO_LIVRE_CREDITO_ORIGEM, ConstantesSistema.NAO));
		filtro.adicionarParametro(new ParametroNaoNulo(FiltroCreditoARealizar.PAGAMENTO_HISTORICO));
		filtro.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoARealizar.CREDITO_TIPO);
		filtro.adicionarCaminhoParaCarregamentoEntidade(FiltroCreditoARealizar.CREDITO_A_REALIZAR_GERAL);

		if(idCreditoTipo != null){

			filtro.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID_CREDITO_TIPO, idCreditoTipo));

		}

		return this.getControladorUtil().pesquisar(filtro, CreditoARealizar.class.getName());

	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * [UC0265] Inserir Pagamentos
	 * Pesquisa a conta do imóvel com a referência informada pelo usuário
	 * [FS0012] - Verificar existência da conta
	 */
	public ContaHistorico pesquisarContaHistoricoDigitada(String idImovel, String referenciaConta) throws ControladorException{

		// Variável que vai armazenar a conta pesquisada
		ContaHistorico contaDigitada = null;
		Object[] dadosConta = null;

		// Formata a referência da conta informada para o formato (AAAAMM) sem a
		// barra
		String anoMesConta = Util.formatarMesAnoParaAnoMesSemBarra(referenciaConta);

		// Cria o filtro de conta e seta todos os parâmetros para pesquisar a
		// conta do imóvel
		// Pesquisa imovel
		try{
			dadosConta = repositorioFaturamento.pesquisarContaHistoricoDigitada(idImovel, anoMesConta);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(dadosConta != null){

			contaDigitada = new ContaHistorico();

			// Id da Conta
			if(dadosConta[0] != null){
				contaDigitada.setId((Integer) dadosConta[0]);
			}

			// Referência
			if(dadosConta[1] != null){
				contaDigitada.setAnoMesReferenciaConta((Integer) dadosConta[1]);
			}

			// Valor da Água
			if(dadosConta[2] != null){
				contaDigitada.setValorAgua((BigDecimal) dadosConta[2]);
			}

			// Valor de Esgoto
			if(dadosConta[3] != null){
				contaDigitada.setValorEsgoto((BigDecimal) dadosConta[3]);
			}

			// Débitos
			if(dadosConta[4] != null){
				contaDigitada.setValorDebitos((BigDecimal) dadosConta[4]);
			}

			// Valor Créditos
			if(dadosConta[5] != null){
				contaDigitada.setValorCreditos((BigDecimal) dadosConta[5]);
			}

			// Valor Imposto
			if(dadosConta[6] != null){
				contaDigitada.setValorImposto((BigDecimal) dadosConta[6]);
			}

		}

		return contaDigitada;
	}

	/**
	 * Método responsável por obter o total de economias e o total de ligações do histograma de agua
	 * por economia
	 * 
	 * @param idGerenciaRegional
	 * @param idLocalidade
	 * @param idCategoria
	 * @return
	 * @throws ControladorException
	 */
	public Object[] obterTotalEconomiasETotalLigacoesHistogramaAgua(Integer idGerenciaRegional, Integer idLocalidade, Integer idCategoria)
					throws ControladorException{

		try{

			return this.repositorioFaturamento.obterTotalEconomiasETotalLigacoesHistogramaAgua(idGerenciaRegional, idLocalidade,
							idCategoria);

		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}

	}

	/**
	 * Recupera as contas para o Imóvel
	 * 
	 * @author André Lopes
	 * @date 09/04/2013
	 * @return Total de contas que pertence ao imóvel com CNTA_DTVENCIMENTOCONTA menor que
	 *         data corrente.
	 * @throws ControladorException
	 */
	public Object[] listarSomatorioEValorFaturasDebito(Integer idImovel) throws ControladorException{

		try{
			return repositorioFaturamento.listarSomatorioEValorFaturasDebito(idImovel, new Date());

		}catch(Exception e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC3014] Emitir Declaração Anual Quitação Débitos
	 * [SB0001] Emitir Declaração Anual de Quitação de Débitos
	 * 
	 * @author Hebert Falcão
	 * @created 27/04/2013
	 */
	public Integer pesquisarQuitacaoDebitoAnualParaEmicaoQtd(Integer idFaturamentoGrupo, Integer anoReferencia) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarQuitacaoDebitoAnualParaEmicaoQtd(idFaturamentoGrupo, anoReferencia);
		}catch(Exception e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Método responsável por obter o percentual de esgoto
	 * 
	 * @param anoMesFaturamento
	 * @param idGerenciaRegional
	 * @param idLocalidade
	 * @param idCategoria
	 * @return
	 * @throws ControladorException
	 */
	public Short obterPercentualEsgotoHistogramaEsgotoEconomia(Integer anoMesFaturamento, Integer idGerenciaRegional, Integer idLocalidade,
					Integer idCategoria) throws ControladorException{

		try{

			return this.repositorioFaturamento.obterPercentualEsgotoHistogramaEsgotoEconomia(anoMesFaturamento, idGerenciaRegional,
							idLocalidade, idCategoria);

		}catch(ErroRepositorioException e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);

		}

	}

	/**
	 * Método responsável por obter o valor da tarifa vigente por categoria
	 * 
	 * @param idConsumoTarifaDefault
	 * @param anoMesReferencia
	 * @param idCategoria
	 * @return
	 * @throws ControladorException
	 */
	public BigDecimal obterValorTarifaVigentePorCategoria(Integer idConsumoTarifaDefault, Integer anoMesReferencia, Integer idCategoria,
					Integer numeroFaixaInicio, Integer numeroFaixaFim, boolean isPrimeiraFaixa) throws ControladorException{

		try{

			return this.repositorioFaturamento.obterValorTarifaVigentePorCategoria(idConsumoTarifaDefault, anoMesReferencia, idCategoria,
							numeroFaixaInicio, numeroFaixaFim, isPrimeiraFaixa);

		}catch(ErroRepositorioException e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);

		}

	}

	/**
	 * Cria uma instância do controlador de imóvel
	 * 
	 * @author Carlos Chrystian Ramos
	 * @date 15/02/2013
	 * @return
	 */
	private ControladorParametroSistema getControladorParametroSistema(){

		return (ControladorParametroSistema) SpringBeanLocator.getInstancia().getBeanPorID(
						ControladorParametroSistema.BEAN_ID_CONTROLADOR_PARAMETRO_SISTEMA);
	}

	/**
	 * @throws ControladorException
	 */
	public void executarAjusteValorDebitoCobradoCasal(Integer caso) throws ControladorException{

		try{
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteValorDebitoCobrancaAdminstrativaCasal(caso);
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * Pesquisar Prestações de Guia de Pagamento
	 * [UC0188] Manter Guia de Pagamento
	 * idConsulta = 1 -> [SB0001] Item 3
	 * 2 -> [SB0009] Item 1.2
	 * 
	 * @author Hiroshi Gonçalves
	 * @throws ControladorException
	 * @date 06/05/2013
	 */
	public Collection<GuiaPagamentoPrestacaoHelper> pesquisarGuiasPagamentoPrestacaoFiltrar(Integer guiaPagamentoId, int idConsulta)
					throws ControladorException{

		Collection<GuiaPagamentoPrestacaoHelper> retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarGuiasPagamentoPrestacaoFiltrar(guiaPagamentoId, idConsulta);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Método isImovelHabilitadoParaBeneficioDaTarifaParaPequenoNegocio
	 * <p>
	 * [FS0014] – Verifica perda do beneficio da Tarifa para Pequeno Negócio . Caso o Id da tarifa
	 * temporária selecionada seja referente à Tarifa para Pequeno Negócio (PASI_VLPARAMETRO da
	 * tabela PARAMETRO_SISTEMA com PASI_DSPARAMETRO="P_TARIFA_CONSUMO _PEQUENO_NEGOCIO"): • Obter
	 * “Consumo máximo” para pequeno negócio [ 5 x Qtd. Economias. Comerciais + 10 x (Soma das
	 * demais economias) ] <<Inclui>> [UC0108 – Obter Quantidade de Economias por Categoria]; • Caso
	 * o consumo medido no mês seja maior que Consumo máximo, o imóvel não será beneficiado com a
	 * tarifa de pequeno negócio, atribuir a tarifa Padrão (CSTF_ID da tabela IMOVEL).
	 * </p>
	 * RASTREIO: [OC1061105][UC0088][FS0014]
	 * 
	 * @return FALSO caso o consumo medido no mês seja maior que Consumo máximo
	 * @author Marlos Ribeiro
	 * @param consumoTarifaTemporaria
	 * @param imovel
	 * @param consumoMedido
	 * @throws ControladorException
	 * @since 27/05/2013
	 */
	private ConsumoTarifa verificarPerdaBeneficioDaTarifaParaPequenoNegocio(Imovel imovel, Integer consumoMedido)
					throws ControladorException{

		ConsumoTarifa retorno = imovel.getConsumoTarifaTemporaria();
		String idTarifaConsumoPequenoNegocio = ParametroFaturamento.P_TARIFA_CONSUMO_PEQUENO_NEGOCIO.executar();

		if(Integer.valueOf(idTarifaConsumoPequenoNegocio).equals(imovel.getConsumoTarifaTemporaria().getId())){

			Collection<Categoria> colecaoCategorias = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
			int qtdEconomiasComerciais = 0;
			int qtdEconomiasNaoComerciais = 0;
			for(Categoria categoria : colecaoCategorias){

				if(Categoria.COMERCIAL.equals(categoria.getId())){

					qtdEconomiasComerciais++;
				}else{

					qtdEconomiasNaoComerciais++;
				}
			}

			Integer consumoMaximo = 5 * qtdEconomiasComerciais + 10 * qtdEconomiasNaoComerciais;

			if(consumoMedido.intValue() > consumoMaximo.intValue()){

				retorno = imovel.getConsumoTarifa();
				log.info("IMOVEL[" + imovel.getId() + "] tem benefício PEQUENO NEGOCIO. ");
			}
		}

		return retorno;
	}

	/**
	 * @param idListaGrupos
	 * @throws ControladorException
	 */
	public void executarAjusteHidrometroInstaladoMeioCicloFaturamento(String idListaGrupos, Integer anoMesReferencia)
					throws ControladorException{

		try{
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteHidrometroInstaladoMeioCicloFaturamento(idListaGrupos, anoMesReferencia);
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC3100] Consultar Histórico de Débito Automático Imóvel
	 * 
	 * @param imovel
	 * @param ehContasOuGuia
	 *            true = ContaGeral, false GuiaPagamento
	 */
	public Collection<DebitoAutomaticoMovimentoHelper> pesquisarDebitoAutomaticoMovimentoPorImovel(Integer idImovel, boolean ehContaOuGuia)
					throws ControladorException{

		try{
			Collection<Object[]> collection = repositorioFaturamento.pesquisarDebitoAutomaticoMovimentoPorImovel(idImovel, ehContaOuGuia);

			List<DebitoAutomaticoMovimentoHelper> retorno = new ArrayList<DebitoAutomaticoMovimentoHelper>();
			for(Object[] array : collection){
				DebitoAutomaticoMovimentoHelper debitoAutoMovimento = new DebitoAutomaticoMovimentoHelper();
				debitoAutoMovimento.setId((Integer) array[0]);

				int referencia;

				Integer idConta = (Integer) array[1];

				if(idConta != null){
					Short indicadorHistorico = (Short) array[2];

					FiltroContaGeral filtroContaGeral = new FiltroContaGeral();
					filtroContaGeral.adicionarParametro(new ParametroSimples(FiltroContaGeral.ID, idConta));
					Collection colecaoContaGeral = this.getControladorUtil().pesquisar(filtroContaGeral, ContaGeral.class.getName());
					ContaGeral contaGeral = (ContaGeral) Util.retonarObjetoDeColecao(colecaoContaGeral);

					if(ConstantesSistema.SIM.equals(indicadorHistorico)){
						referencia = contaGeral.getContaHistorico().getAnoMesReferenciaConta();
					}else{
						referencia = contaGeral.getConta().getReferencia();
					}
					debitoAutoMovimento.setDtReferenciaComparar(referencia);
					String refStr = Util.formatarAnoMesParaMesAno(referencia);
					debitoAutoMovimento.setReferenciaConta(refStr);
				}

				Integer idGuia = (Integer) array[3];
				if(idGuia != null){
					Integer prestacao = (Integer) array[4];
					String prestStr = "";
					if(Util.isNaoNuloBrancoZero(prestacao)){
						prestStr = prestacao.toString();
					}
					debitoAutoMovimento.setParcelaGuia(idGuia + "/" + prestStr);
				}

				Date dataEnvio = (Date) array[6];

				debitoAutoMovimento.setDataEnvioBanco(Util.formatarData(dataEnvio));
				debitoAutoMovimento.setDataVencimento(Util.formatarData((Date) array[7]));
				Date dataRetorno = (Date) array[8];
				debitoAutoMovimento.setDataRetornoBanco(Util.formatarData(dataRetorno));
				debitoAutoMovimento.setValorDebito(Util.formataBigDecimal((BigDecimal) array[9], 2, false));

				String situacao = "";
				String descricaoSituacao = (String) array[10];
				if(Util.isNaoNuloBrancoZero(descricaoSituacao)){
					situacao = "CANCELADO";
				}

				Short indicadorExclusao = (Short) array[13];
				if(indicadorExclusao != null && ConstantesSistema.SIM.equals(indicadorExclusao)){
					situacao = "EXCLUÍDO";
					descricaoSituacao = "";
				}

				debitoAutoMovimento.setSituacao(situacao);
				debitoAutoMovimento.setDescricaoSituacao(descricaoSituacao);

				String ocorrencia = "";
				if(!ConstantesSistema.SIM.equals(indicadorExclusao)){
					if(dataEnvio != null && dataRetorno == null){
						Date dataUltimaAlteracao = (Date) array[11];
						if(dataEnvio.after(dataUltimaAlteracao)){
							ocorrencia = "AGUARDANDO DEBITO";
						}
					}else if(dataEnvio != null && dataRetorno != null){
						ocorrencia = (String) array[12];
					}
				}

				debitoAutoMovimento.setOcorrencia(ocorrencia);

				retorno.add(debitoAutoMovimento);
			}

			if(ehContaOuGuia){
				Collections.sort(retorno, new Comparator<DebitoAutomaticoMovimentoHelper>() {

					public int compare(DebitoAutomaticoMovimentoHelper o1, DebitoAutomaticoMovimentoHelper o2){

						Integer dt1 = o1.getDtReferenciaComparar();
						Integer dt2 = o2.getDtReferenciaComparar();
						return dt2.compareTo(dt1); // DESC
					}

				});
			}else{
				Collections.sort(retorno, new Comparator<DebitoAutomaticoMovimentoHelper>() {

					public int compare(DebitoAutomaticoMovimentoHelper o1, DebitoAutomaticoMovimentoHelper o2){

						return o2.getParcelaGuia().compareTo(o1.getParcelaGuia()); // DESC
					}

				});
			}

			return retorno;

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	
	/**
	 * [UC0352] - Emitir Contas
	 * [SB0033] – Gerar Contas Modelo 2
	 * Responsável pela geração PDF com a conta
	 * 
	 * @author Anderson Italo
	 * @date 07/08/2013
	 */
	public List<RelatorioContaModelo2Bean> obterDadosRelatorioEmitirContasModelo2(FaturamentoGrupo faturamentoGrupo,
					Integer anoMesReferencia, Collection<EmitirContaTipo2Helper> colecaoEmitirContaTipo2Helper) throws ControladorException{

		List<RelatorioContaModelo2Bean> relatorioBeans = new ArrayList<RelatorioContaModelo2Bean>();

		try{

			Iterator<EmitirContaTipo2Helper> contaHelperIterator = colecaoEmitirContaTipo2Helper.iterator();
			EmitirContaTipo2Helper helper = null;
			String matriculaImovelFormatada = null;
			String referencia = null;
			String dataLeituraAnterior = "";
			String dataLeituraAtual = "";
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			while(contaHelperIterator.hasNext()){

				RelatorioContaModelo2Bean bean = new RelatorioContaModelo2Bean();
				helper = contaHelperIterator.next();

				// Sequencial
				bean.setSequencial(String.valueOf(helper.getSequencialImpressao()));
				log.info("............Emitindo conta imóvel: " + helper.getIdImovel().toString());

				// Matrícula
				matriculaImovelFormatada = helper.getIdImovel().toString();
				matriculaImovelFormatada = Util.adicionarZerosEsquedaNumero(10,
								"" + Util.retornaMatriculaImovelFormatada(Util.obterInteger(matriculaImovelFormatada)));
				bean.setMatricula(matriculaImovelFormatada);

				// Referência
				referencia = Util.retornaDescricaoAnoMes4Digitos(helper.getAnoMesConta().toString());
				bean.setReferencia(referencia);

				// Código do Responsável
				if(helper.getIdClienteResponsavel() != null){

					bean.setCodigoResponsavel(helper.getIdClienteResponsavel().toString());
				}

				// Nome do cliente
				bean.setNomeCliente(helper.getNomeCliente());

				// Endereço do imóvel
				bean.setEnderecoImovel(helper.getEndereco());

				// Quantidade de ecônomias
				if(helper.getEconResidencial() != null){

					bean.setQuantidadeEconomiasResidencial(helper.getEconResidencial().toString());
				}

				if(helper.getEconComercial() != null){

					bean.setQuantidadeEconomiasComercial(helper.getEconComercial().toString());
				}

				if(helper.getEconIndustrial() != null){

					bean.setQuantidadeEconomiasIndustrial(helper.getEconIndustrial().toString());
				}

				if(helper.getEconPublica() != null){

					bean.setQuantidadeEconomiasPublica(helper.getEconPublica().toString());
				}

				// Localidade
				bean.setLocalidade(helper.getInscLocalidade().toString());

				// Setor Comercial
				bean.setSetor(helper.getInscSetorComercial().toString());

				// Quadra
				bean.setQuadra(helper.getInscQuadra().toString());

				// Lote
				if(helper.getInscLote() != null){
					bean.setLote(helper.getInscLote().toString());
				}

				if(helper.getHidrometro() != null){

					// Número do hidrômetro
					bean.setNumeroHidrometro(helper.getHidrometro());

					// Data de instalação hidrômetro
					if(helper.getDataInstalacaoHidrometro() != null){
						bean.setDataInstalacaoHidrometro(Util.formatarData(helper.getDataInstalacaoHidrometro()));
					}

					// Marca do hidrômetro
					if(helper.getHidrometroMarca() != null){
						bean.setMarcaHidrometro(helper.getHidrometroMarca().getDescricaoAbreviada());
					}

					// Local de instalação do hidrômetro
					if(helper.getHidrometroLocalInstalacao() != null){
						bean.setLocalInstalacaoHidrometro(helper.getHidrometroLocalInstalacao().getDescricaoAbreviada());
					}

					// Capacidade do hidrômetro
					if(helper.getHidrometroCapacidade() != null){
						bean.setCapacidadeHidrometro(helper.getHidrometroCapacidade().getDescricaoAbreviada());
					}

					// Situação de água
					bean.setSituacaoAgua(helper.getDescricaoLigacaoAguaSituacao());

					// Situação de esgoto
					bean.setSituacaoEsgoto(helper.getDescricaoLigacaoEsgotoSituacao());

					if(helper.getDtLeituraAtual() != null){

						// Data de leitura atual
						bean.setDataLeitura(Util.formatarData(helper.getDtLeituraAtual()));
					}
				}

				// Qualidade da água
				// [SB0031] – Obter Dados da Qualidade Água
				QualidadeAgua qualidadeAgua = repositorioFaturamento.pesquisarQualidadeAguaPorLocalidadeAnoMesFaturamento(
								sistemaParametro.getAnoMesFaturamento(), helper.getInscLocalidade());

				if(qualidadeAgua == null && helper.getCodigoElo() != null){

					qualidadeAgua = repositorioFaturamento.pesquisarQualidadeAguaPorLocalidadeAnoMesFaturamento(
									sistemaParametro.getAnoMesFaturamento(), helper.getCodigoElo());
				}

				QualidadeAguaPadrao qualidadeAguaPadrao = repositorioFaturamento.retornarQualidadeAguaPadrao();

				// Turbidez Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasTurbidez() != null){

					bean.setQualidadeTurbidezExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasTurbidez().toString());
				}

				// Turbidez Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasTurbidez() != null){

					bean.setQualidadeTurbidezRealizada(qualidadeAgua.getNumeroAmostrasRealizadasTurbidez().toString());
				}

				// Turbidez Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesTurbidez() != null){

					bean.setQualidadeTurbidezConforme(qualidadeAgua.getNumeroAmostrasConformesTurbidez().toString());
				}

				// Cor Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasCor() != null){

					bean.setQualidadeCorExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasCor().toString());
				}

				// Cor Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasCor() != null){

					bean.setQualidadeCorRealizada(qualidadeAgua.getNumeroAmostrasRealizadasCor().toString());
				}

				// Cor Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesCor() != null){

					bean.setQualidadeCorConforme(qualidadeAgua.getNumeroAmostrasConformesCor().toString());
				}

				// Cloro Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasCloro() != null){

					bean.setQualidadeCloroExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasCloro().toString());
				}

				// Cloro Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasCloro() != null){

					bean.setQualidadeCloroRealizada(qualidadeAgua.getNumeroAmostrasRealizadasCloro().toString());
				}

				// Cloro Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesCloro() != null){

					bean.setQualidadeCloroConforme(qualidadeAgua.getNumeroAmostrasConformesCloro().toString());
				}

				// Flúor Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasFluor() != null){

					bean.setQualidadeFluorExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasFluor().toString());
				}

				// Flúor Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasFluor() != null){

					bean.setQualidadeFluorRealizada(qualidadeAgua.getNumeroAmostrasRealizadasFluor().toString());
				}

				// Flúor Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesFluor() != null){

					bean.setQualidadeFluorConforme(qualidadeAgua.getNumeroAmostrasConformesFluor().toString());
				}

				// Coliformes Totais Exigida
				if(qualidadeAguaPadrao.getNumeroAmostrasExigidasColiformesTotais() != null){

					bean.setQualidadeColiformesTotaisExigida(qualidadeAguaPadrao.getNumeroAmostrasExigidasColiformesTotais().toString());
				}

				// Coliformes Totais Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasColiformesTotais() != null){

					bean.setQualidadeColiformesTotaisRealizada(qualidadeAgua.getNumeroAmostrasRealizadasColiformesTotais().toString());
				}

				// Coliformes Totais Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesColiformesTotais() != null){

					bean.setQualidadeColiformesTotaisConforme(qualidadeAgua.getNumeroAmostrasConformesColiformesTotais().toString());
				}

				// Coliformes Termotolerantes Realizada
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasRealizadasColiformesTermotolerantes() != null){

					bean.setQualidadeColiformesTermotolerantesRealizada(qualidadeAgua
									.getNumeroAmostrasRealizadasColiformesTermotolerantes().toString());
				}

				// Coliformes Termotolerantes Conforme
				if(qualidadeAgua != null && qualidadeAgua.getNumeroAmostrasConformesColiformesTermotolerantes() != null){

					bean.setQualidadeColiformesTermotolerantesConforme(qualidadeAgua.getNumeroAmostrasConformesColiformesTermotolerantes()
									.toString());
				}

				// Qualidade Água - Conclusão
				if(qualidadeAgua != null){

					bean.setQualidadeConclusao(qualidadeAgua.getDescricaoConclusaoAnalisesRealizadas());
				}

				// Leitura Anterior
				if(helper.getLeituraAnterior() != null){

					bean.setLeituraAnterior(helper.getLeituraAnterior().toString());
				}

				// Leitura Atual
				if(helper.getLeituraAtual() != null){

					bean.setLeituraAtual(helper.getLeituraAtual().toString());
				}

				// Situação de Leitura
				if(helper.getIdLeituraSituacaoAtual() != null){

					LeituraSituacao leituraSituacao = (LeituraSituacao) getControladorUtil().pesquisar(helper.getIdLeituraSituacaoAtual(),
									LeituraSituacao.class, false);
					bean.setSituacaoLeitura(leituraSituacao.getDescricao());
				}

				// Consumo
				Integer consumoFaturado = 0;
				Integer consumoMedido = 0;
				if (helper.getConsumoFaturado() != null){
					
					consumoFaturado = helper.getConsumoFaturado();
				}

				if(helper.getConsumoMedidoEstimado() != null){

					consumoMedido = Util.obterInteger(helper.getConsumoMedidoEstimado());
				}

				if(consumoFaturado.intValue() < helper.getConsumoMinimoLigacao() && helper.getIdConsumoTipo() != null
								&& helper.getIdConsumoTipo().equals(ConsumoTipo.REAL)){

					log.info("Imovel [" + helper.getIdImovel().toString() + "] faturou consumo medido");
					bean.setConsumo(consumoMedido.toString());
				}else{

					bean.setConsumo(consumoFaturado.toString());
				}

				// Périodo Faturamento
				dataLeituraAnterior = "";
				dataLeituraAtual = "";
				if(helper.getDtLeituraAnterior() != null){

					dataLeituraAnterior = Util.formatarData(helper.getDtLeituraAnterior());
				}

				if(helper.getDtLeituraAtual() != null){

					dataLeituraAtual = Util.formatarData(helper.getDtLeituraAtual());
				}

				bean.setPeriodoFaturamento(dataLeituraAnterior + " A " + dataLeituraAtual);

				// Dias de Consumo
				if(helper.getDtLeituraAnterior() != null && helper.getDtLeituraAtual() != null){

					bean.setDiasConsumo(String.valueOf(Util.obterQuantidadeDiasEntreDuasDatas(helper.getDtLeituraAnterior(),
									helper.getDtLeituraAtual())));
				}

				// Média
				if(helper.getConsumoMedio() != null){

					bean.setMedia(helper.getConsumoMedio().toString());
				}

				// Condição de Faturamento
				if(helper.getIdConsumoTipo() != null){

					ConsumoTipo consumoTipo = (ConsumoTipo) getControladorUtil().pesquisar(helper.getIdConsumoTipo(), ConsumoTipo.class,
									false);
					bean.setCondicaoFaturamento(consumoTipo.getDescricao());
				}

				// Anormalidade de Leitura
				if(helper.getIdLeituraAnormalidadeFaturamento() != null){

					LeituraAnormalidade leituraAnormalidade = (LeituraAnormalidade) getControladorUtil().pesquisar(
									helper.getIdLeituraAnormalidadeFaturamento(), LeituraAnormalidade.class, false);
					bean.setAnormalidadeLeitura(leituraAnormalidade.getId().toString());
					bean.setDescricaoAnormalidade(leituraAnormalidade.getDescricao());
				}

				/*
				 * Faturas em Atraso ([SB0102 – Obter Débitos] ordenadas por referencia
				 * decrescente
				 * da conta. O limite é de 12(doze) ocorrências, acumulando as demais para o
				 * próximo
				 * campo)
				 */
				obterFaturasEmAtraso(anoMesReferencia, bean, helper);

				/*
				 * Últimos Consumos (Histórico de consumo dos últimos 6 meses [SB0004 – Obter
				 * Dados
				 * do Consumo e Medição Anterior])
				 */
				Collection<DadosConsumoAnteriorHelper> colecaoDadosConsumoAnterior = this.obterDadosConsumoAnteriorModelo(
								helper.getIdImovel(), faturamentoGrupo.getAnoMesReferencia(), 6, LigacaoTipo.LIGACAO_AGUA,
								helper.getIdTipoMedicao());

				int indexConsumos = 1;
				for(DadosConsumoAnteriorHelper dadosConsumoAnteriorHelper : colecaoDadosConsumoAnterior){

					Util.executarMetodo(bean, "setReferenciaConsumoMes" + indexConsumos,
									Util.retornaDescricaoAnoMes4Digitos(String.valueOf(dadosConsumoAnteriorHelper.getAnoMesReferencia())));

					if(dadosConsumoAnteriorHelper.getLeitura() != null){

						Util.executarMetodo(bean, "setLeituraMes" + indexConsumos, dadosConsumoAnteriorHelper.getLeitura().toString());
					}

					if(dadosConsumoAnteriorHelper.getIdLeituraAnormalidade() != null){

						Util.executarMetodo(bean, "setAnormalidadeMes" + indexConsumos, dadosConsumoAnteriorHelper
										.getIdLeituraAnormalidade().toString());

					}else if(dadosConsumoAnteriorHelper.getDescricaoAbreviadaConsumAnormalidade() != null){

						Util.executarMetodo(bean, "setAnormalidadeMes" + indexConsumos,
										dadosConsumoAnteriorHelper.getDescricaoAbreviadaConsumAnormalidade());
					}

					Util.executarMetodo(bean, "setConsumoFaturadoMes" + indexConsumos, dadosConsumoAnteriorHelper.getConsumoFaturado()
									.toString());

					indexConsumos++;
				}

				// Faturamento Realizado (Descrição Tarifas/Débitos/Créditos obtidos no SB0105)
				bean.setFaturamentoRealizado(this.gerarLinhasDescricaoTarifasDebitosCreditosModelo(helper));


				// >>>>>>>>>>>>>>>>>>>>>>>.
				String msg = "";
				// Indicador Declaração de Quitação
				// [FS0010 – Verificar indicador de mensagem de quitação de débito]
				// O sistema obtém o ano de referência para a geração da
				// declaração anual de quitação de débitos
				Integer anoBaseDeclaracaoQuitacaoDebitoAnual = Integer
								.valueOf((String) ParametroFaturamento.P_ANO_BASE_DECLARACAO_QUITACAO_DEBITO_ANUAL.executar());

				// 1. Caso o ano de referência seja diferente de “-1” e exista registro de quitação
				// pendente associado ao imóvel
				if(!Util.isVazioOuBranco(anoBaseDeclaracaoQuitacaoDebitoAnual)
								&& !anoBaseDeclaracaoQuitacaoDebitoAnual
												.equals(ConstantesSistema.SEM_ANO_BASE_DECLARACAO_QUITACAO_DEBITO_ANUAL)){

					// Verifica geração da declaração para o grupo no ano de referência
					FiltroQuitacaoDebitoAnual filtroQuitacaoDebitoAnual = new FiltroQuitacaoDebitoAnual();

					filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.IMOVEL_ID, helper
									.getIdImovel()));
					filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.ANO_REFERENCIA,
									anoBaseDeclaracaoQuitacaoDebitoAnual));
					filtroQuitacaoDebitoAnual.adicionarParametro(new ParametroSimples(FiltroQuitacaoDebitoAnual.INDICADOR_IMPRESSAO,
									ConstantesSistema.NAO));

					// Obtém registros na tabela QUITACAO_ANUAL_DEBITO
					Collection<QuitacaoDebitoAnual> colecaoQuitacaoDebitoAnual = (Collection<QuitacaoDebitoAnual>) this
									.getControladorUtil().pesquisar(filtroQuitacaoDebitoAnual, QuitacaoDebitoAnual.class.getName());

					// 1. Caso o ano de referência seja diferente de “-1” e exista registro de
					// quitação
					// pendente associado ao imóvel
					if(!Util.isVazioOrNulo(colecaoQuitacaoDebitoAnual)){
						// 1.1. Atribuir o valor S ao Indicador de Mensagem de Quitação do Débito.

						for(QuitacaoDebitoAnual quitacaoDebitoAnual : colecaoQuitacaoDebitoAnual){
							// 1.2. O sistema indica a emissão da declaração anual de quitação de
							// débitos
							// atualiza a tabela QUITACAO_DEBITO_ANUAL com os seguintes valores:

							// QADB_ICIMPRESSAO >> 1 (sim)
							quitacaoDebitoAnual.setIndicadorImpressao(ConstantesSistema.SIM);

							// QADB_TMULTIMAALTERACAO >> data e hora correntes
							quitacaoDebitoAnual.setUltimaAlteracao(new Date());

							// *********************************************************
							// Inclui o registro na tabela de quitação de débito anual
							this.getControladorUtil().atualizar(quitacaoDebitoAnual);
							// *********************************************************

							msg = "	Em conformidade com art. 3º da lei 12.007/2009, informamos que não há pendencia ou fatura vencida para "
											+ "esta matricula. Esta declaração substitui a comprovação da quitação das faturas mensais dos débitos "
											+ "até 31/12/"
											+ anoBaseDeclaracaoQuitacaoDebitoAnual
											+ ", não abrangendo os parcelamentos pendentes nas "
											+ "faturas de "
											+ anoBaseDeclaracaoQuitacaoDebitoAnual + ". ";

						}
					}
				}

				// >>>>>>>>>>>>>>>>>>>>>>>

				// Mensagem [SB0017 – Obter Mensagem da Conta em 3 Partes]
				String mensagemConta = "";
				if(!Util.isVazioOrNulo(helper.getMensagemConta())){

					Object[] mensagens = helper.getMensagemConta();

					if(mensagens[0] != null && !mensagens[0].toString().equals("")){

						if(mensagens[0].toString().length() <= 50){

							mensagemConta += Util.completaString(mensagens[0].toString(), 50);
							mensagemConta += Util.completaString("", 50);
						}else{

							mensagemConta += mensagens[0].toString().substring(0, 50);
							mensagemConta += Util.completaString(mensagens[0].toString().substring(50), 50);
						}
					}else{

						mensagemConta += Util.completaString("", 100);
					}

					if(mensagens[1] != null && !mensagens[1].toString().equals("")){

						if(mensagens[1].toString().length() <= 50){

							mensagemConta += Util.completaString(mensagens[1].toString(), 50);
						}else{

							mensagemConta += mensagens[1].toString().substring(0, 50);
						}
					}else{

						mensagemConta += Util.completaString("", 50);
					}

					if(mensagens[1] != null && !mensagens[1].toString().equals("")){

						if(mensagens[1].toString().length() <= 50){

							mensagemConta += Util.completaString("", 50);
						}else{

							mensagemConta += Util.completaString(mensagens[1].toString().substring(50), 50);
						}
					}else{

						mensagemConta += Util.completaString("", 50);
					}

					mensagemConta = msg + mensagemConta;

					bean.setMensagemConta(mensagemConta);
				}



				// Vencimento
				bean.setVencimento(Util.formatarData(helper.getDataVencimento()));

				// Total a Pagar
				bean.setTotalAPagar(Util.formatarMoedaReal(helper.getValorTotalConta(), 2));

				// Inscrição (Local, Setor, Quadra e Lote)
				bean.setInscricao(helper.getInscricao().substring(0, helper.getInscricao().length() - 4));

				// [SB0030] - Gerar Código de Barras
				if((helper.getIndicadorDebitoAutomatico() != null && helper.getIndicadorCodigoBarras() != null)
								&& helper.getIndicadorDebitoAutomatico().equals(ConstantesSistema.NAO)
								&& helper.getIndicadorCodigoBarras().equals(ConstantesSistema.SIM)){

					gerarCodigoDeBarras(helper);
					bean.setRepresentacaoNumericaCodBarraFormatada(Util.completaString(helper.getRepresentacaoNumericaCodBarraFormatada(),
									51));
					bean.setRepresentacaoNumericaCodBarraSemDigito(helper.getRepresentacaoNumericaCodBarraSemDigito());
				}

				// VERSO DA CONTA (Segunda Página)
				RelatorioContaModelo2SubVersoBean beanVerso = new RelatorioContaModelo2SubVersoBean();

				// Nome do Cliente
				beanVerso.setNomeClienteEntrega(helper.getNomeCliente());

				// Endereço de Entrega
				if(!Util.isVazioOuBranco(helper.getEnderecoClienteEntrega())){

					beanVerso.setEnderecoClienteEntrega(helper.getEnderecoClienteEntrega());
				}else{

					beanVerso.setEnderecoClienteEntrega(helper.getEndereco());
				}

				Collection colecaoBeanSubRelatorioVerso = new ArrayList<RelatorioContaModelo2SubVersoBean>();
				colecaoBeanSubRelatorioVerso.add(beanVerso);
				bean.setarBeansSubRelatorioVerso(colecaoBeanSubRelatorioVerso);

				relatorioBeans.add(bean);
			}
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return relatorioBeans;
	}

	/**
	 * [UC0352] - Emitir Contas
	 * [SB0033] – Gerar Contas Modelo 2
	 * Faturas em Atraso ([SB0102 – Obter Débitos] ordenadas por referencia decrescente da conta. O
	 * limite é de 12(doze) ocorrências, acumulando as demais para o próximo campo)
	 * 
	 * @author Anderson Italo
	 * @date 05/08/2013
	 * @throws ControladorException
	 */
	private void obterFaturasEmAtraso(Integer anoMesReferencia, RelatorioBean beanObject, EmitirContaTipo2Helper helper)
					throws ControladorException{

		if(beanObject instanceof RelatorioContaModelo3Bean){
			RelatorioContaModelo3Bean bean = (RelatorioContaModelo3Bean) beanObject;

			int contador = 0;
			BigDecimal somaValorOutrasFaturas = BigDecimal.ZERO;
			BigDecimal somaValorFaturas = BigDecimal.ZERO;
			String anoMesReferenciaInicial = "000101";
			String anoMesReferenciaFinal = String.valueOf(Util.subtrairAnoAnoMesReferencia(anoMesReferencia, 1));

			Integer parametroQuantidadeDiasVencimentoContaAvisoCorte = Integer
							.parseInt(ParametroCobranca.P_QUANTIDADE_DIAS_VENCIMENTO_CONTA_AVISO_CORTE.executar());

			Date dataVencimentoInicial = Util.converteStringParaDate("01/01/0001", false);
			Date dataVencimentoFinal = Util.subtrairNumeroDiasDeUmaData(new Date(), parametroQuantidadeDiasVencimentoContaAvisoCorte);

			ObterDebitoImovelOuClienteHelper debitoImovelOuClienteHelper = getControladorCobranca().obterDebitoImovelContas(1,
							helper.getIdImovel().toString(), anoMesReferenciaInicial, anoMesReferenciaFinal, dataVencimentoInicial,
							dataVencimentoFinal);

			if(!Util.isVazioOrNulo(debitoImovelOuClienteHelper.getColecaoContasValores())){

				List<ContaValoresHelper> colecaoContaValores = new ArrayList<ContaValoresHelper>();
				colecaoContaValores.addAll(debitoImovelOuClienteHelper.getColecaoContasValores());
				List sortFields = new ArrayList();

				sortFields.add(new BeanComparator("conta.referencia"));

				ComparatorChain multiSort = new ComparatorChain(sortFields);
				Collections.sort((List) colecaoContaValores, multiSort);
				Collections.reverse(colecaoContaValores);

				String anoAux = "";
				String anoCorrente = "";
				String strAnosComDebitos = "";

				for(ContaValoresHelper contaValorHelper : colecaoContaValores){
					contador++;

					anoCorrente = String.valueOf(Util.obterAno(contaValorHelper.getConta().getReferencia()));
					if(anoCorrente != anoAux){
						strAnosComDebitos = anoCorrente + ", ";
					}
					anoAux = anoCorrente;

					if(!(contador <= 12)){
						somaValorOutrasFaturas = somaValorOutrasFaturas.add(contaValorHelper.getConta().getValorTotalContaBigDecimal());
					}

					somaValorFaturas = somaValorFaturas.add(contaValorHelper.getConta().getValorTotalContaBigDecimal());
				}

				bean.setFaturaAtrasoReferencia1(strAnosComDebitos.substring(strAnosComDebitos.length() - 2));
			}

			if(somaValorFaturas.compareTo(BigDecimal.ZERO) == 1){

				// Outros Meses
				bean.setOutrosMesesFaturaAtraso(Util.formatarMoedaReal(somaValorOutrasFaturas, 2));

				// Débito em
				bean.setDebitoDataCorrente(Util.formatarData(new Date()));

				// Consulmo Médio
				if(helper.getConsumoMedio() != null){
					bean.setConsumoMedio(helper.getConsumoMedio().toString());
				}

				// Total
				bean.setTotalValorContasAtraso(Util.formatarMoedaReal(somaValorFaturas, 2));

				// Ignore Se Pago Até
				bean.setIgnoreDataCorrenteMenosDoisDias(Util.formatarData(Util.subtrairNumeroDiasDeUmaData(new Date(), 2)));
			}
		}else{
			RelatorioContaModelo2Bean bean = (RelatorioContaModelo2Bean) beanObject;

		BigDecimal somaValorOutrasFaturas = BigDecimal.ZERO;
		BigDecimal somaValorFaturas = BigDecimal.ZERO;
		String anoMesReferenciaInicial = "000101";
		String anoMesReferenciaFinal = String.valueOf(Util.subtrairMesDoAnoMes(anoMesReferencia, 1));
		int contador = 0;

		Integer parametroQuantidadeDiasVencimentoContaAvisoCorte = Integer
						.parseInt(ParametroCobranca.P_QUANTIDADE_DIAS_VENCIMENTO_CONTA_AVISO_CORTE.executar());

		Date dataVencimentoInicial = Util.converteStringParaDate("01/01/0001", false);
		Date dataVencimentoFinal = Util.subtrairNumeroDiasDeUmaData(new Date(), parametroQuantidadeDiasVencimentoContaAvisoCorte);

		ObterDebitoImovelOuClienteHelper debitoImovelOuClienteHelper = getControladorCobranca().obterDebitoImovelContas(1,
						helper.getIdImovel().toString(), anoMesReferenciaInicial, anoMesReferenciaFinal, dataVencimentoInicial,
						dataVencimentoFinal);

		if(!Util.isVazioOrNulo(debitoImovelOuClienteHelper.getColecaoContasValores())){

			List<ContaValoresHelper> colecaoContaValores = new ArrayList<ContaValoresHelper>();
			colecaoContaValores.addAll(debitoImovelOuClienteHelper.getColecaoContasValores());
			List sortFields = new ArrayList();

			sortFields.add(new BeanComparator("conta.referencia"));

			ComparatorChain multiSort = new ComparatorChain(sortFields);
			Collections.sort((List) colecaoContaValores, multiSort);
			Collections.reverse(colecaoContaValores);

			for(ContaValoresHelper contaValorHelper : colecaoContaValores){

				contador++;

				if(contador <= 12){

					Util.executarMetodo(bean, "setFaturaAtrasoReferencia" + contador,
									Util.retornaDescricaoAnoMes4Digitos(String.valueOf(contaValorHelper.getConta().getReferencia())));
					Util.executarMetodo(bean, "setFaturaAtrasoValor" + contador,
									Util.formatarMoedaReal(contaValorHelper.getConta().getValorTotalContaBigDecimal(), 2));
				}else{

					somaValorOutrasFaturas = somaValorOutrasFaturas.add(contaValorHelper.getConta().getValorTotalContaBigDecimal());
				}

				somaValorFaturas = somaValorFaturas.add(contaValorHelper.getConta().getValorTotalContaBigDecimal());
			}
		}

		if(somaValorFaturas.compareTo(BigDecimal.ZERO) == 1){

			// Outros Meses
			bean.setOutrosMesesFaturaAtraso(Util.formatarMoedaReal(somaValorOutrasFaturas, 2));

			// Débito em
			bean.setDebitoDataCorrente(Util.formatarData(new Date()));

			// Total
			bean.setTotalValorContasAtraso(Util.formatarMoedaReal(somaValorFaturas, 2));

			// Ignore Se Pago Até
			bean.setIgnoreDataCorrenteMenosDoisDias(Util.formatarData(Util.subtrairNumeroDiasDeUmaData(new Date(), 2)));
		}
	}

	}

	/**
	 * Metódo responsável por emitir os txts das contas.
	 * [UC0348] Emitir Contas
	 * [SB0004] Obter Dados do Consumo e Medicao Anterior
	 * 
	 * @author Anderson Italo
	 * @date 05/08/2013
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public Collection<DadosConsumoAnteriorHelper> obterDadosConsumoAnteriorModelo(Integer idImovel, Integer anoMes, int qtdMeses,
					Integer tipoLigacao, Integer tipoMedicao) throws ControladorException, ErroRepositorioException{

		Collection<DadosConsumoAnteriorHelper> colecaoDadosconsumoAnteriorHelper = new ArrayList<DadosConsumoAnteriorHelper>();

		for(int i = 1; i <= qtdMeses; i++){

			DadosConsumoAnteriorHelper dadosConsumoAnteriorHelper = new DadosConsumoAnteriorHelper();
			int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, i);
			dadosConsumoAnteriorHelper.setAnoMesReferencia(anoMesSubtraido);

			String descricaoAbreviadaAnormalidadeAnterior = null;
			Object[] parmsConsumoHistorico = null;
			Integer numeroConsumoFaturadoMes = null;

			parmsConsumoHistorico = getControladorMicromedicao().obterConsumoAnteriorAnormalidadeDoImovel(idImovel, anoMesSubtraido,
							tipoLigacao);

			if(parmsConsumoHistorico != null){

				if(parmsConsumoHistorico[0] != null){

					numeroConsumoFaturadoMes = (Integer) parmsConsumoHistorico[0];
				}

				if(parmsConsumoHistorico[1] != null){

					descricaoAbreviadaAnormalidadeAnterior = (String) parmsConsumoHistorico[1];
				}
			}

			if(numeroConsumoFaturadoMes != null){

				dadosConsumoAnteriorHelper.setConsumoFaturado(numeroConsumoFaturadoMes);
			}else{

				dadosConsumoAnteriorHelper.setConsumoFaturado(0);
			}

			if(tipoLigacao != null && tipoMedicao != null && tipoMedicao.intValue() > 0){

				Integer idLeituraAnormalidade = null;

				// Caso o tipo de medição seja agua
				if(tipoLigacao.equals(MedicaoTipo.LIGACAO_AGUA)){

					idLeituraAnormalidade = repositorioMicromedicao.pesquisarIdLeituraAnormalidadeTipoAgua(idImovel, anoMesSubtraido);
				}else if(tipoMedicao.equals(MedicaoTipo.POCO)){

					// Caso o tipo de medição seja poco
					idLeituraAnormalidade = repositorioMicromedicao.pesquisarIdLeituraAnormalidadeTipoEsgoto(idImovel, anoMesSubtraido);
				}

				// Caso tenha anormalidade de leitura
				if(idLeituraAnormalidade != null){

					dadosConsumoAnteriorHelper.setIdLeituraAnormalidade(idLeituraAnormalidade);
				}else if(descricaoAbreviadaAnormalidadeAnterior != null){

					dadosConsumoAnteriorHelper.setDescricaoAbreviadaConsumAnormalidade(descricaoAbreviadaAnormalidadeAnterior);
				}

				MedicaoHistorico medicaoHistorico = getControladorMicromedicao().pesquisarMedicaoHistorico(idImovel, anoMesSubtraido,
								tipoMedicao);

				if(medicaoHistorico != null){

					dadosConsumoAnteriorHelper.setLeitura(medicaoHistorico.getLeituraAtualFaturamento());
				}
			}

			colecaoDadosconsumoAnteriorHelper.add(dadosConsumoAnteriorHelper);
		}

		return colecaoDadosconsumoAnteriorHelper;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0105] – Gerar Linhas da Descrição das Tarifas/Débitos/Créditos
	 * 
	 * @author Anderson Italo
	 * @data 07/08/2013
	 */
	private String gerarLinhasDescricaoTarifasDebitosCreditosModelo(EmitirContaTipo2Helper contaEmitirHelper) throws ControladorException,
					ErroRepositorioException{

		StringBuilder descricaoTarifasDebitosCreditosImpostos = new StringBuilder("");

		/*
		 * O sistema inicializa com nulos a tabela de Descrição das Tarifas/Débitos/Créditos (Índice
		 * de tarifas/débitos/créditos) variando o índice de 1 (um) até o limite de linhas
		 * (PASI_VLPARAMETRO da tabela PARAMETRO_SISTEMA com
		 * PASI_DSPARAMETRO=”P_LIMITE_EMISSAO_TARIFAS_CONTA”)).
		 */
		int limitacaoIndex = 3;

		// O sistema obtém o valor total dos débitos cobrados de parcelamento para a conta
		String idsFinanciamentoTipo = ParametroParcelamento.P_FINANCIAMENTO_TIPO_PARCELAMENTO.executar();

		// Acrescenta aos Ids o tipo de financiamento Juros de Parcelamento
		idsFinanciamentoTipo = idsFinanciamentoTipo + "," + FinanciamentoTipo.JUROS_PARCELAMENTO;

		List<RelatorioContaModelo2SubDescritivoFaixasHelper> linhasDescricaoServicosConta = new ArrayList<RelatorioContaModelo2SubDescritivoFaixasHelper>();

		/*
		 * carrega coleções utilizadas posteriormente para determinar a limitação do index de
		 * tarifas
		 */
		Collection<DebitoCobrado> colecaoDebitoCobrado = null;
		Collection<DebitoCobrado> colecaoDebitoCobradoParcelamento = null;
		boolean possuiDebitos = false;
		if(contaEmitirHelper.getDebitos().compareTo(new BigDecimal("0")) == 1){

			// O sistema obtém os débitos cobrados de serviço para a conta
			colecaoDebitoCobrado = repositorioFaturamento.buscarDebitosCobradosContaEmissaoTxt(contaEmitirHelper.getIdConta(),
							FinanciamentoTipo.SERVICO_NORMAL.toString());

			// O sistema obtém os débitos cobrados de parcelamento para a conta
			colecaoDebitoCobradoParcelamento = repositorioFaturamento.buscarDebitosCobradosContaEmissaoTxt(contaEmitirHelper.getIdConta(),
							idsFinanciamentoTipo);

			if(!Util.isVazioOrNulo(colecaoDebitoCobrado) || !Util.isVazioOrNulo(colecaoDebitoCobradoParcelamento)){

				possuiDebitos = true;
				limitacaoIndex += 2;
			}
		}

		Collection<CreditoRealizado> colecaoCreditoRealizado = null;
		boolean possuiCreditos = false;
		if(contaEmitirHelper.getValorCreditos().compareTo(new BigDecimal("0")) == 1){

			// O sistema obtém os créditos realizados para a conta
			colecaoCreditoRealizado = repositorioFaturamento.buscarCreditosRealizadosContaEmissaoTxt(contaEmitirHelper.getIdConta());

			if(!Util.isVazioOrNulo(colecaoCreditoRealizado)){

				possuiCreditos = true;
				limitacaoIndex++;
			}
		}

		Collection<ContaImpostosDeduzidos> colecaoContaImpostosDeduzidos = null;
		boolean possuiImpostos = false;
		if(contaEmitirHelper.getValorImpostos().compareTo(new BigDecimal("0")) == 1){

			// O sistema obtém os impostos deduzidos para a conta
			colecaoContaImpostosDeduzidos = this.repositorioFaturamento.pesquisarContaImpostosDeduzidos(contaEmitirHelper.getIdConta());

			if(!Util.isVazioOrNulo(colecaoContaImpostosDeduzidos)){

				possuiImpostos = true;
				limitacaoIndex++;
			}
		}

		/*
		 * Caso o valor de água da conta (CNTA_VLAGUA) seja maior que zero:
		 * O sistema gera as linhas com as faixas de consumo da conta
		 * [SB0025 – Gerar Linhas das Faixas de Consumo da Conta]
		 */
		if(contaEmitirHelper.getValorAgua().compareTo(new BigDecimal("0")) == 1){

			linhasDescricaoServicosConta = this.gerarLinhasFaixaConsumoContaModelo2(contaEmitirHelper, linhasDescricaoServicosConta,
							limitacaoIndex);
		}

		/*
		 * Caso o valor de água de esgoto (CNTA_VLESGOTO) seja maior que zero
		 * [SB0026 – Gerar Linha da Tarifa de Esgoto].
		 */
		if(contaEmitirHelper.getValorEsgoto().compareTo(new BigDecimal("0")) == 1){

			linhasDescricaoServicosConta = this.gerarLinhaTarifaEsgotoModelo2(contaEmitirHelper, linhasDescricaoServicosConta);
		}

		/*
		 * Caso o valor dos débitos cobrados da conta (CNTA_VLDEBITOS) seja maior que zero
		 * [SB0027 – Gerar Linha da Tarifa de Esgoto].
		 */
		if(possuiDebitos && (possuiCreditos == false && possuiImpostos == false)){

			linhasDescricaoServicosConta = this.gerarLinhasDebitosCobradosModelo2(contaEmitirHelper, linhasDescricaoServicosConta,
							colecaoDebitoCobrado, colecaoDebitoCobradoParcelamento, 2);

		}else if(possuiDebitos && possuiCreditos && (possuiImpostos == false)){

			linhasDescricaoServicosConta = this.gerarLinhasDebitosCobradosModelo2(contaEmitirHelper, linhasDescricaoServicosConta,
							colecaoDebitoCobrado, colecaoDebitoCobradoParcelamento, 3);
		}else if(possuiDebitos && possuiCreditos && possuiImpostos){

			linhasDescricaoServicosConta = this.gerarLinhasDebitosCobradosModelo2(contaEmitirHelper, linhasDescricaoServicosConta,
							colecaoDebitoCobrado, colecaoDebitoCobradoParcelamento, 4);
		}else if(possuiDebitos && possuiImpostos && possuiCreditos == false){
			linhasDescricaoServicosConta = this.gerarLinhasDebitosCobradosModelo2(contaEmitirHelper, linhasDescricaoServicosConta,
							colecaoDebitoCobrado, colecaoDebitoCobradoParcelamento, 3);
		}

		/*
		 * Caso o valor dos créditos realizados na conta (CNTA_VLCREDITOS) seja maior que zero
		 * [SB0109] – Gerar Linhas dos Créditos Realizados.
		 */
		if(possuiCreditos && (possuiImpostos == false)){

			linhasDescricaoServicosConta = this.gerarLinhasCreditosRealizadosModelo2(contaEmitirHelper, linhasDescricaoServicosConta,
							colecaoCreditoRealizado, 1);
		}else if(possuiCreditos && possuiImpostos){

			linhasDescricaoServicosConta = this.gerarLinhasCreditosRealizadosModelo2(contaEmitirHelper, linhasDescricaoServicosConta,
							colecaoCreditoRealizado, 2);
		}

		/*
		 * Caso o valor dos impostos retidos da conta (CNTA_VLIMPOSTOS) seja maior que zero
		 * [SB0110] – Gerar Linhas dos Impostos Retidos.
		 */
		if(possuiImpostos){

			linhasDescricaoServicosConta = this.gerarLinhasImpostosRetidosModelo2(contaEmitirHelper, linhasDescricaoServicosConta,
							colecaoContaImpostosDeduzidos);
		}

		for(RelatorioContaModelo2SubDescritivoFaixasHelper helper : linhasDescricaoServicosConta){

			if(helper.getPrimeiraColuna() != null){

				descricaoTarifasDebitosCreditosImpostos.append(Util.completaString(helper.getPrimeiraColuna(), 30));
			}else{

				descricaoTarifasDebitosCreditosImpostos.append(Util.completaString("", 30));
			}

			if(helper.getSegundaColuna() != null){

				descricaoTarifasDebitosCreditosImpostos.append(Util.completarStringComValorEsquerda(helper.getSegundaColuna(), " ", 9));
			}else{

				descricaoTarifasDebitosCreditosImpostos.append(Util.completaString("", 9));
			}

			if(helper.getTerceiraColuna() != null){

				descricaoTarifasDebitosCreditosImpostos.append(Util.completarStringComValorEsquerda(helper.getTerceiraColuna(), " ", 17));
			}else{

				descricaoTarifasDebitosCreditosImpostos.append(Util.completaString("", 17));
			}

			if(helper.getQuartaColuna() != null){

				descricaoTarifasDebitosCreditosImpostos.append(Util.completarStringComValorEsquerda(helper.getQuartaColuna(), " ", 19));
			}else{

				descricaoTarifasDebitosCreditosImpostos.append(Util.completaString("", 19));
			}

			if(helper.getQuintaColuna() != null){

				descricaoTarifasDebitosCreditosImpostos.append(Util.completarStringComValorEsquerda(helper.getQuintaColuna(), " ", 17));
			}else{

				descricaoTarifasDebitosCreditosImpostos.append(Util.completaString("", 17));
			}

			if(helper.getSextaColuna() != null){

				descricaoTarifasDebitosCreditosImpostos.append(Util.completarStringComValorEsquerda(helper.getSextaColuna(), " ", 19));
			}else{

				descricaoTarifasDebitosCreditosImpostos.append(Util.completaString("", 19));
			}

			descricaoTarifasDebitosCreditosImpostos.append(System.getProperty("line.separator"));
		}

		return descricaoTarifasDebitosCreditosImpostos.toString();
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0025] – Gerar Linhas das Faixas de Consumo da Conta
	 * 
	 * @author Anderson Italo
	 * @data 07/08/2013
	 */
	private List<RelatorioContaModelo2SubDescritivoFaixasHelper> gerarLinhasFaixaConsumoContaModelo2(
					EmitirContaTipo2Helper contaEmitirHelper,
					List<RelatorioContaModelo2SubDescritivoFaixasHelper> linhasDescricaoServicosConta, int limitacaoIndex)
					throws ControladorException, ErroRepositorioException{

		/*
		 * O sistema inicializa com nulos a tabela de Tarifa (índice de tarifas), Categoria
		 * (índice de tarifas), Faixa de Consumo (índice de tarifas), Valor da Tarifa na Faixa
		 * (índice de tarifas) e Valor de Consumo na Faixa (índice de tarifas) variando o índice de
		 * 1 (um) até o limite de emissão de tarifas na conta
		 */
		int limite = Util.obterInteger((String) ParametroFaturamento.P_LIMITE_EMISSAO_TARIFAS_CONTA.executar(this));
		int indexTarifas = 0;

		Collection colecaoContaCategoria = repositorioFaturamento.pesquisarContaCategoriaSubCategoria(contaEmitirHelper.getIdConta());

		if(colecaoContaCategoria != null && !colecaoContaCategoria.isEmpty()){

			Iterator iteratorContaCategoria = colecaoContaCategoria.iterator();
			List<ContaCategoria> colecaoContaCategoriaNaoProcessadas = new ArrayList<ContaCategoria>();

			while(iteratorContaCategoria.hasNext()){

				ContaCategoria contaCategoria = (ContaCategoria) iteratorContaCategoria.next();

				BigDecimal qtdEconomia = Util.formatarMoedaRealparaBigDecimal(contaCategoria.getQuantidadeEconomia().toString(), 2);

				if(colecaoContaCategoriaNaoProcessadas.isEmpty()){

					RelatorioContaModelo2SubDescritivoFaixasHelper linhaFaixaConsumo = new RelatorioContaModelo2SubDescritivoFaixasHelper();

					FiltroContaCategoriaConsumoFaixa filtroContaCategoriaConsumoFaixa = new FiltroContaCategoriaConsumoFaixa();
					filtroContaCategoriaConsumoFaixa.adicionarParametro(new ParametroSimples(FiltroContaCategoriaConsumoFaixa.CONTA_ID,
									contaEmitirHelper.getIdConta()));
					filtroContaCategoriaConsumoFaixa.adicionarParametro(new ParametroSimples(FiltroContaCategoriaConsumoFaixa.CATEGORIA_ID,
									contaCategoria.getComp_id().getCategoria().getId()));
					filtroContaCategoriaConsumoFaixa.setCampoOrderBy(FiltroContaCategoriaConsumoFaixa.CONSUMO_FAIXA_INICIO);

					Collection<ContaCategoriaConsumoFaixa> colecaoContaCategoriaConsumoFaixa = getControladorUtil().pesquisar(
									filtroContaCategoriaConsumoFaixa, ContaCategoriaConsumoFaixa.class.getName());

					// Consumo na Categoria dividido pela Qtd de Ecônomias
					Integer consumoCategoria = 0;
					if(contaCategoria.getConsumoAgua() != null){

						consumoCategoria = (contaCategoria.getConsumoAgua().intValue() / contaCategoria.getQuantidadeEconomia());
					}

					linhaFaixaConsumo.setSegundaColuna(consumoCategoria.toString());

					if(Util.isVazioOrNulo(colecaoContaCategoriaConsumoFaixa)){

						linhaFaixaConsumo = new RelatorioContaModelo2SubDescritivoFaixasHelper();
						String descricaoCategoria = "";
						String faixaConsumo = "";
						String volumePorUnidade = "";
						String numeroUnidades = qtdEconomia.toString();
						String volumeTotal = "";
						String preco = "";
						String subTotal = "";

						/*
						 * Caso existam dados de medição (verificar FS0002) e não existam faixas de
						 * consumo para a conta/categoria. Índice de tarifas = Índice de tarifas +
						 * 1.
						 */
						indexTarifas++;

						/*
						 * Formata a Tarifa (Índice de tarifas) = “descrição abreviada da categoria
						 */
						descricaoCategoria = Util.completaString(contaCategoria.getComp_id().getCategoria().getDescricaoAbreviada(), 8);

						// Formata a Faixa de Consumo (Índice de tarifas) = “ATÉ” + Consumo de água
						// para a categoria
						faixaConsumo += "ATÉ ";

						if(contaCategoria.getConsumoAgua() != null){

							faixaConsumo += contaCategoria.getConsumoAgua().toString();
						}else if(contaCategoria.getConsumoEsgoto() != null){

							faixaConsumo += contaCategoria.getConsumoEsgoto().toString();
						}else{

							faixaConsumo += "0";
						}

						if(contaCategoria.getConsumoAgua() != null
										&& new BigDecimal(contaCategoria.getConsumoAgua().toString()).compareTo(BigDecimal.ZERO) == 1){

							// volumePorUnidade = Util.formatarMoedaReal(
							// new
							// BigDecimal(contaCategoria.getConsumoAgua().toString()).divide(qtdEconomia),
							// 2);
							//
							
							volumePorUnidade = Util.arredondar(new BigDecimal(contaCategoria.getConsumoAgua().toString())
											.divide(qtdEconomia)) + " M³";
							
						}else if(contaCategoria.getConsumoEsgoto() != null
										&& new BigDecimal(contaCategoria.getConsumoEsgoto().toString()).compareTo(BigDecimal.ZERO) == 1){

								// volumePorUnidade = Util.formatarMoedaReal(
							// new
							// BigDecimal(contaCategoria.getConsumoEsgoto().toString()).divide(qtdEconomia),
							// 2);
							
							volumePorUnidade = Util.arredondar(new BigDecimal(contaCategoria.getConsumoEsgoto().toString())
											.divide(qtdEconomia)) + " M³";
						}else{

							volumePorUnidade = "0 M³";
						}

						if(contaCategoria.getConsumoAgua() != null){

							volumeTotal = contaCategoria.getConsumoAgua().toString();
						}else if(contaCategoria.getConsumoEsgoto() != null){

							volumeTotal = contaCategoria.getConsumoEsgoto().toString();
						}else{

							volumeTotal = "0";
						}

						if(contaCategoria.getValorTarifaMinimaAgua() != null){

							preco = Util.formataBigDecimal(contaCategoria.getValorTarifaMinimaAgua(), 4, true);
						}else if(contaCategoria.getValorTarifaMinimaEsgoto() != null){

							preco = Util.formataBigDecimal(contaCategoria.getValorTarifaMinimaEsgoto(), 4, true);
						}else{

							preco = "0,0000";
						}

						if(contaCategoria.getValorAgua() != null){

							subTotal = Util.formataBigDecimal(contaCategoria.getValorAgua(), 2, true);
						}else if(contaCategoria.getValorEsgoto() != null){

							subTotal = Util.formataBigDecimal(contaCategoria.getValorEsgoto(), 2, true);
						}else{

							subTotal = Util.formataBigDecimal(BigDecimal.ZERO, 2, true);
						}

						linhaFaixaConsumo.setPrimeiraColuna(descricaoCategoria + faixaConsumo);
						linhaFaixaConsumo.setSegundaColuna(volumePorUnidade);
						linhaFaixaConsumo.setTerceiraColuna(numeroUnidades);
						linhaFaixaConsumo.setQuartaColuna(volumeTotal);
						linhaFaixaConsumo.setQuintaColuna(preco);
						linhaFaixaConsumo.setSextaColuna(subTotal);

						linhasDescricaoServicosConta.add(linhaFaixaConsumo);

						// Preparar total da categoria
						// Índice de tarifas = Índice de tarifas + 1
						indexTarifas++;
						linhaFaixaConsumo = new RelatorioContaModelo2SubDescritivoFaixasHelper();
						if(contaCategoria.getValorAgua() != null){

							linhaFaixaConsumo.setPrimeiraColuna("VALOR TOTAL DE CONSUMO DE ÁGUA");
							linhaFaixaConsumo.setSextaColuna(Util.formataBigDecimal(contaCategoria.getValorAgua(), 2, true));
						}else if(contaCategoria.getValorEsgoto() != null){

							linhaFaixaConsumo.setPrimeiraColuna("VALOR TOTAL DE CONSUMO DE ESGOTO");
							linhaFaixaConsumo.setSextaColuna(Util.formataBigDecimal(contaCategoria.getValorEsgoto(), 2, true));
						}else{

							linhaFaixaConsumo.setPrimeiraColuna("VALOR TOTAL DE CONSUMO");
							linhaFaixaConsumo.setSextaColuna(Util.formataBigDecimal(BigDecimal.ZERO, 2, true));
						}

						/*
						 * Descrição das Tarifas/Débitos/Créditos (Índice de
						 * tarifas/débitos/créditos)
						 */
						linhasDescricaoServicosConta.add(linhaFaixaConsumo);

					}else if(!Util.isVazioOrNulo(colecaoContaCategoriaConsumoFaixa)){

						/*
						 * Caso existam faixas de consumo para a conta/categoria. O sistema obtém as
						 * faixas de consumo para a conta/categoria.
						 */
						boolean primeiraOcorrenciaCategoriaFaixa = true;
						BigDecimal somatorioValorConsumoFaixa = new BigDecimal(0);

						for(Iterator iteratorContaCategoriaConsumoFaixa = colecaoContaCategoriaConsumoFaixa.iterator(); iteratorContaCategoriaConsumoFaixa
										.hasNext();){

							ContaCategoriaConsumoFaixa contaCategoriaConsumoFaixa = (ContaCategoriaConsumoFaixa) iteratorContaCategoriaConsumoFaixa
											.next();

							linhaFaixaConsumo = new RelatorioContaModelo2SubDescritivoFaixasHelper();
							String descricaoCategoria = "";
							String faixaConsumo = "";
							String volumePorUnidade = "";
							String numeroUnidades = qtdEconomia.toString();
							String volumeTotal = "";
							String preco = "";
							String subTotal = "";

							// Índice de tarifas = Índice de tarifas + 1
							indexTarifas++;

							/*
							 * Caso o Índice de tarifas seja menor que o limite de emissão de
							 * tarifas na
							 * conta menos 3 (três) (reservar 3 linhas para total da categoria,
							 * total demais categorias e valor de esgoto) menos 2 (dois), caso
							 * existam débitos cobrados (reservar 2 linhas para os débitos), menos 1
							 * (um), caso existam créditos realizados (reservar 1 linha para os
							 * créditos), menos 1 (um), caso existam impostos retidos (reservar 1
							 * linha para os impostos)
							 */
							if(indexTarifas < (limite - limitacaoIndex)){

								/*
								 * Formata a Categoria (Índice de tarifas) = Descrição abreviada
								 * da
								 * categoria , caso seja a primeira ocorrência da categoria nas
								 * faixas
								 * de
								 * consumo da conta; caso contrário, atribuir o valor nulo à
								 * Categoria
								 * (Índice de tarifas).
								 */
								if(primeiraOcorrenciaCategoriaFaixa){

									descricaoCategoria = Util.completaString(contaCategoria.getComp_id().getCategoria()
													.getDescricaoAbreviada(), 8);
									primeiraOcorrenciaCategoriaFaixa = false;
								}else{

									descricaoCategoria = Util.completaString("", 8);
								}

								/*
								 * Faixa (CCCF_NNCONSUMOFAIXAINICIO “A” CCCF_NNCONSUMOFAIXAFIM de
								 * CONTA_CATEGORIA_CONSUMO_FAIXA)
								 */
								faixaConsumo += contaCategoriaConsumoFaixa.getConsumoFaixaInicio().toString() + " A "
												+ contaCategoriaConsumoFaixa.getConsumoFaixaFim().toString();

								// Preço (CCCF_VLTARIFAFAIXA de CONTA_CATEGORIA_CONSUMO_FAIXA)
								preco = Util.formataBigDecimal(contaCategoriaConsumoFaixa.getValorTarifaFaixa(), 4, true);

								Integer consumoFaixa = null;
								BigDecimal valorConsumoFaixa = null;

								if(contaCategoriaConsumoFaixa.getConsumoFaixaInicio() == 0){

									// ConsumoFaixa = ContaCategoria.ConsumoMinimoAgua;
									// (conta_categoria.ctcg_nnconsumominimoagua)
									consumoFaixa = contaCategoria.getConsumoMinimoAgua();

									if(contaCategoria.getValorTarifaMinimaAgua() != null){

										if(contaCategoriaConsumoFaixa.getValorTarifaFaixa() == null){
											throw new ControladorException("atencao.valor.tarifa.faixa.nulo");
										}

										// valor da tarifa mínima de agua para categoria
										Integer consumoFaixaMinimaFinal = contaCategoriaConsumoFaixa.getConsumoFaixaFim();
										if(consumoFaixaMinimaFinal == null){
											consumoFaixaMinimaFinal = Integer.valueOf(0);
										}

										valorConsumoFaixa = contaCategoriaConsumoFaixa.getValorTarifaFaixa().multiply(
														new BigDecimal(consumoFaixaMinimaFinal.intValue()));

										// Multiplica o valor pela quantidade de economia
										valorConsumoFaixa = valorConsumoFaixa.multiply(qtdEconomia).setScale(Parcelamento.CASAS_DECIMAIS,
														BigDecimal.ROUND_DOWN);
									}

								}else{
									// ConsumoFaixa = ContaCategoria.ConsumoMinimoAgua;
									// (conta_categoria.ctcg_nnconsumominimoagua)
									consumoFaixa = contaCategoriaConsumoFaixa.getConsumoAgua();
									valorConsumoFaixa = contaCategoriaConsumoFaixa.getValorAgua();
								}

								if(consumoFaixa == null){
									consumoFaixa = Integer.valueOf(0);
								}

								if(valorConsumoFaixa == null){
									valorConsumoFaixa = BigDecimal.ZERO;
								}

								if((new BigDecimal(consumoFaixa.toString()).compareTo(BigDecimal.ZERO) == 1)
												&& qtdEconomia.compareTo(BigDecimal.ZERO) > 0){

									System.out.println("consumoFaixa: " + consumoFaixa);

									System.out.println("qtdEconomia: " + qtdEconomia);

									volumePorUnidade = Util.dividirArredondando(new BigDecimal(consumoFaixa.toString()), qtdEconomia, 2)
													.toString() + " M³";

								}else{

									volumePorUnidade = "0 M³";
								}

								volumeTotal = consumoFaixa.toString();
								subTotal = Util.formataBigDecimal(valorConsumoFaixa, 2, true);

								somatorioValorConsumoFaixa = somatorioValorConsumoFaixa.add(valorConsumoFaixa);

								linhaFaixaConsumo.setPrimeiraColuna(descricaoCategoria + faixaConsumo);
								linhaFaixaConsumo.setSegundaColuna(volumePorUnidade);
								linhaFaixaConsumo.setTerceiraColuna(numeroUnidades);
								linhaFaixaConsumo.setQuartaColuna(volumeTotal);
								linhaFaixaConsumo.setQuintaColuna(preco);
								linhaFaixaConsumo.setSextaColuna(subTotal);
								linhaFaixaConsumo.setSubTotal(valorConsumoFaixa);

								linhasDescricaoServicosConta.add(linhaFaixaConsumo);

								/*
								 * Caso tenha percorrido todas as faixas, acrescenta a linha de
								 * TOTAL REAL e realiza o ajuste da última faixa
								 */
								if(!iteratorContaCategoriaConsumoFaixa.hasNext()){

									// Preparar total da categoria
									// Índice de tarifas = Índice de tarifas + 1
									indexTarifas++;
									linhaFaixaConsumo = new RelatorioContaModelo2SubDescritivoFaixasHelper();
									linhaFaixaConsumo.setPrimeiraColuna("VALOR TOTAL DE CONSUMO DE ÁGUA");
									linhaFaixaConsumo.setSextaColuna(Util.formataBigDecimal(contaCategoria.getValorAgua(), 2, true));

									/*
									 * Descrição das Tarifas/Débitos/Créditos (Índice de
									 * tarifas/débitos/créditos)
									 */
									linhasDescricaoServicosConta.add(linhaFaixaConsumo);

									// [SB0032] – Verificar Ajuste Valor Última Faixa.
									verificarAjusteValorUltimaFaixaModelo2(linhasDescricaoServicosConta, contaCategoria, linhaFaixaConsumo,
													somatorioValorConsumoFaixa);

									// Passa para Próxima Categoria
									break;
								}

							}else{

								/*
								 * Caso contrário, ou seja, o Índice de tarifas seja igual ao
								 * limite
								 * de
								 * emissão de tarifas na conta menos 3 (três) (reservar 3 linhas
								 * para total da categoria, total demais categorias e valor de
								 * esgoto) menos 2 (dois), caso existam débitos cobrados (reservar 2
								 * linhas para os débitos), menos 1 (um), caso existam créditos
								 * realizados (reservar 1 linha para os créditos), menos 1 (um),
								 * caso existam impostos retidos (reservar 1 linha para os impostos)
								 */

								/*
								 * Formata a Categoria (Índice de tarifas) = Descrição abreviada
								 * da
								 * categoria , caso seja a primeira ocorrência da categoria nas
								 * faixas
								 * de consumo da conta; caso contrário, atribuir o valor nulo à
								 * Categoria (Índice de tarifas).
								 */
								if(primeiraOcorrenciaCategoriaFaixa){

									descricaoCategoria = Util.completaString(contaCategoria.getComp_id().getCategoria()
													.getDescricaoAbreviada(), 8);
									primeiraOcorrenciaCategoriaFaixa = false;
								}else{

									descricaoCategoria = Util.completaString("", 8);
								}

								/*
								 * Faixa de Consumo (Índice de tarifas) = “ACIMA DE” + Faixa
								 * Inicial
								 * de
								 * Consumo
								 */
								faixaConsumo = "ACIMA DE " + contaCategoriaConsumoFaixa.getConsumoFaixaInicio().toString();

								/*
								 * Valor de Consumo na Faixa (Índice de tarifas) = valor de água
								 * da
								 * conta (CTCG_VLAGUA da tabela CONTA_CATEGORIA) menos os
								 * valores já
								 * acumulados para a categoria (somatório (Valor de Consumo na
								 * Faixa) na
								 * categoria)
								 */
								subTotal = Util.formataBigDecimal(contaCategoria.getValorAgua().subtract(somatorioValorConsumoFaixa), 2,
												true);

								/*
								 * Descrição das Tarifas/Débitos/Créditos (Índice de
								 * tarifas/débitos/créditos) = Tarifa (Índice de tarifas) +
								 * Categoria
								 * (Índice de tarifas) + Faixa de Consumo (Índice de tarifas) +
								 * Valor da
								 * Tarifa na Faixa (Índice de tarifas) + Valor de Consumo na
								 * Faixa
								 * (Índice
								 * de tarifas).
								 */
								linhaFaixaConsumo.setPrimeiraColuna(descricaoCategoria + faixaConsumo);
								linhaFaixaConsumo.setSextaColuna(subTotal);
								linhaFaixaConsumo.setSubTotal(contaCategoria.getValorAgua().subtract(somatorioValorConsumoFaixa));
								linhasDescricaoServicosConta.add(linhaFaixaConsumo);

								// Preparar total da categoria
								// Índice de tarifas = Índice de tarifas + 1
								indexTarifas++;
								linhaFaixaConsumo = new RelatorioContaModelo2SubDescritivoFaixasHelper();

								linhaFaixaConsumo.setPrimeiraColuna("VALOR TOTAL DE CONSUMO DE ÁGUA");
								linhaFaixaConsumo.setSextaColuna(Util.formataBigDecimal(contaCategoria.getValorAgua(), 2, true));

								/*
								 * Descrição das Tarifas/Débitos/Créditos (Índice de
								 * tarifas/débitos/créditos)
								 */
								linhasDescricaoServicosConta.add(linhaFaixaConsumo);

								// [SB0032] – Verificar Ajuste Valor Última Faixa.
								verificarAjusteValorUltimaFaixaModelo2(linhasDescricaoServicosConta, contaCategoria, linhaFaixaConsumo,
												somatorioValorConsumoFaixa);

								/*
								 * Preparar total das demais categorias, caso ainda existam
								 * categorias a
								 * processar
								 */
								if(iteratorContaCategoria.hasNext()){

									colecaoContaCategoriaNaoProcessadas.add(contaCategoria);
								}

								break;
							}
						}
					}
				}else{

					/*
					 * Preparar total das demais categorias, caso ainda existam
					 * categorias a
					 * processar
					 */
					if(iteratorContaCategoria.hasNext()){

						colecaoContaCategoriaNaoProcessadas.add(contaCategoria);
					}
				}
			}

			// caso ainda restem faixas/categorias a processar
			if(!Util.isVazioOrNulo(colecaoContaCategoriaNaoProcessadas)){

				// Índice de tarifas = Índice de tarifas + 1
				indexTarifas++;
				RelatorioContaModelo2SubDescritivoFaixasHelper linhaFaixaConsumo = new RelatorioContaModelo2SubDescritivoFaixasHelper();

				// Categoria (Índice de tarifas) = “OUTRAS”
				linhaFaixaConsumo.setPrimeiraColuna("OUTRAS ");

				/*
				 * Valor de Consumo na Faixa (Índice de tarifas) = somatório dos valores de água das
				 * categorias ainda não processadas valor de água da conta
				 */
				BigDecimal valorAguaAcumulado = new BigDecimal(0);
				for(ContaCategoria contaCategoriaNaoProcessada : colecaoContaCategoriaNaoProcessadas){

					valorAguaAcumulado = valorAguaAcumulado.add(contaCategoriaNaoProcessada.getValorAgua());
				}

				linhaFaixaConsumo.setSextaColuna(Util.formataBigDecimal(valorAguaAcumulado, 2, true));

				/*
				 * Descrição das Tarifas/Débitos/Créditos (Índice de
				 * tarifas/débitos/créditos) = Tarifa (Índice de tarifas) +
				 * Categoria
				 * (Índice de tarifas) + Faixa de Consumo (Índice de tarifas) +
				 * Valor da
				 * Tarifa na Faixa (Índice de tarifas) + Valor de Consumo na Faixa
				 * (Índice
				 * de tarifas).
				 */
				linhasDescricaoServicosConta.add(linhaFaixaConsumo);
			}
		}

		contaEmitirHelper.setIndexDescricaoTarifasServicos(indexTarifas);
		return linhasDescricaoServicosConta;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0032] – Verificar Ajuste Valor Última Faixa
	 * 
	 * @author Anderson Italo
	 * @data 07/08/2013
	 */
	private void verificarAjusteValorUltimaFaixaModelo2(List<RelatorioContaModelo2SubDescritivoFaixasHelper> linhasDescricaoServicosConta,
					ContaCategoria contaCategoria, RelatorioContaModelo2SubDescritivoFaixasHelper linhaFaixaConsumo,
					BigDecimal somatorioValorConsumoFaixa) throws ControladorException{

		/*
		 * Caso os valores já acumulados para a categoria (somatório
		 * (Valor de Consumo na Faixa) na categoria) sejam diferentes do
		 * valor total da categoria
		 */
		if(!(somatorioValorConsumoFaixa.compareTo(contaCategoria.getValorAgua()) == 0)){

			BigDecimal diferenca = new BigDecimal(0);
			RelatorioContaModelo2SubDescritivoFaixasHelper ultimaOcorrenciaDescricaoServicosContaHelper = new RelatorioContaModelo2SubDescritivoFaixasHelper();
			/*
			 * adicionar ou subtrair a diferença na última ocorrência da
			 * categoria
			 */
			ultimaOcorrenciaDescricaoServicosContaHelper = linhasDescricaoServicosConta.get(linhasDescricaoServicosConta.size() - 2);

			if(somatorioValorConsumoFaixa.compareTo(contaCategoria.getValorAgua()) == 1){

				diferenca = somatorioValorConsumoFaixa.subtract(contaCategoria.getValorAgua());
				ultimaOcorrenciaDescricaoServicosContaHelper.setSextaColuna(Util.formataBigDecimal(
								ultimaOcorrenciaDescricaoServicosContaHelper.getSubTotal().subtract(diferenca), 2, true));
			}else{

				diferenca = contaCategoria.getValorAgua().subtract(somatorioValorConsumoFaixa);
				ultimaOcorrenciaDescricaoServicosContaHelper.setSextaColuna(Util.formataBigDecimal(
								ultimaOcorrenciaDescricaoServicosContaHelper.getSubTotal().add(diferenca), 2, true));
			}

			linhasDescricaoServicosConta.set(linhasDescricaoServicosConta.size() - 2, ultimaOcorrenciaDescricaoServicosContaHelper);
		}
	}

	/**
	 * [UC0352] Emitir Contas
	 * 
	 * @author Anderson Italo
	 * @data 07/08/2013
	 */
	private List<RelatorioContaModelo2SubDescritivoFaixasHelper> gerarLinhaTarifaEsgotoModelo2(EmitirContaTipo2Helper contaEmitirHelper,
					List<RelatorioContaModelo2SubDescritivoFaixasHelper> linhasDescricaoServicosConta) throws ControladorException{

		RelatorioContaModelo2SubDescritivoFaixasHelper linhaTarifaEsgoto = new RelatorioContaModelo2SubDescritivoFaixasHelper();

		// Caso o valor de esgoto (CNTA_VLESGOTO) seja maior que zero
		if(contaEmitirHelper.getValorEsgoto() != null && contaEmitirHelper.getValorEsgoto().compareTo(BigDecimal.ZERO) == 1){

			linhaTarifaEsgoto.setPrimeiraColuna("ESGOTOS");
			linhaTarifaEsgoto.setSextaColuna(Util.formataBigDecimal(contaEmitirHelper.getValorEsgoto(), 2, true));
		}

		linhasDescricaoServicosConta.add(linhaTarifaEsgoto);
		contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

		return linhasDescricaoServicosConta;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0108] – Gerar Linhas dos Débitos Cobrados
	 * 
	 * @author Anderson Italo
	 * @data 07/08/2013
	 */
	private List<RelatorioContaModelo2SubDescritivoFaixasHelper> gerarLinhasDebitosCobradosModelo2(
					EmitirContaTipo2Helper contaEmitirHelper,
					List<RelatorioContaModelo2SubDescritivoFaixasHelper> linhasDescricaoServicosConta,
					Collection<DebitoCobrado> colecaoDebitoCobrado, Collection<DebitoCobrado> colecaoDebitoCobradoParcelamento,
					int limitacaoIndex) throws ErroRepositorioException, ControladorException{

		/*
		 * O sistema inicializa com nulos a tabela de Descrição do Débito (índice de débitos) e
		 * Valor do Débito (índice de débitos) variando o índice de 1 (um) até o limite de emissão
		 * de tarifas na débitos
		 */
		int limite = Util.obterInteger((String) ParametroFaturamento.P_LIMITE_EMISSAO_TARIFAS_CONTA.executar(this));
		int indexDebitos = contaEmitirHelper.getIndexDescricaoTarifasServicos();

		boolean possuiDebitosParcelamento = false;
		Collection<DadosDebitoParcelamentoContaHelper> colecaoDebitosParcelamentoHelper = new ArrayList<DadosDebitoParcelamentoContaHelper>();

		if(!Util.isVazioOrNulo(colecaoDebitoCobradoParcelamento)){

			possuiDebitosParcelamento = true;
			for(DebitoCobrado debitoCobrado : colecaoDebitoCobradoParcelamento){

				if(!Util.isVazioOrNulo(colecaoDebitosParcelamentoHelper)){

					boolean achouDebito = false;

					for(DadosDebitoParcelamentoContaHelper dadosDebitoParcelamentoContaHelper : colecaoDebitosParcelamentoHelper){

						if(dadosDebitoParcelamentoContaHelper.getPrestacao().shortValue() == debitoCobrado.getNumeroPrestacao()
										&& dadosDebitoParcelamentoContaHelper.getPrestacaoDebito().shortValue() == debitoCobrado
														.getNumeroPrestacaoDebito()){

							achouDebito = true;
						}

						if(achouDebito){

							dadosDebitoParcelamentoContaHelper.setValorDebito(debitoCobrado.getValorPrestacao().add(
											dadosDebitoParcelamentoContaHelper.getValorDebito()));
							break;

						}
					}

					if(achouDebito == false){

						DadosDebitoParcelamentoContaHelper helper = new DadosDebitoParcelamentoContaHelper();
						helper.setPrestacao(debitoCobrado.getNumeroPrestacao());
						helper.setPrestacaoDebito(debitoCobrado.getNumeroPrestacaoDebito());
						helper.setValorDebito(debitoCobrado.getValorPrestacao());
						colecaoDebitosParcelamentoHelper.add(helper);
					}
				}else{

					DadosDebitoParcelamentoContaHelper helper = new DadosDebitoParcelamentoContaHelper();
					helper.setPrestacao(debitoCobrado.getNumeroPrestacao());
					helper.setPrestacaoDebito(debitoCobrado.getNumeroPrestacaoDebito());
					helper.setValorDebito(debitoCobrado.getValorPrestacao());
					colecaoDebitosParcelamentoHelper.add(helper);
				}
			}
		}else{

			limitacaoIndex--;
		}

		Collection<DebitoCobrado> colecaoDebitoCobradoRestantes = new ArrayList<DebitoCobrado>();

		if(!Util.isVazioOrNulo(colecaoDebitoCobrado)){
			for(DebitoCobrado debitoCobrado : colecaoDebitoCobrado){

				RelatorioContaModelo2SubDescritivoFaixasHelper linhaDebitoCobrado = new RelatorioContaModelo2SubDescritivoFaixasHelper();

				// Índice de débitos = Índice de débitos + 1
				indexDebitos++;

				/*
				 * Caso o Índice de débitos seja menor que o limite de emissão de débitos na conta
				 * menos 1 (um) (reservar 1 linha para os débitos de parcelamento), caso existam
				 * débitos
				 * de parcelamento, menos 1 (um), caso existam créditos realizados (reservar 1 linha
				 * para os créditos), menos 1 (um), caso existam impostos retidos (reservar 1 linha
				 * para
				 * os impostos)
				 */
				if(indexDebitos < (limite - limitacaoIndex)){

					// Descrição do tipo de débito e Prestação/Total Prestações
					linhaDebitoCobrado.setPrimeiraColuna(debitoCobrado.getDebitoTipo().getDescricao().trim() + " "
									+ debitoCobrado.getNumeroPrestacaoDebito() + "/" + debitoCobrado.getNumeroPrestacao());

					/*
					 * Valor do débito (DBCB_VLPRESTACAO da
					 * tabela DEBITO_COBRADO)
					 */
					linhaDebitoCobrado.setSextaColuna(Util.formataBigDecimal(debitoCobrado.getValorPrestacao(), 2, true));

					/*
					 * Descrição das Tarifas/Débitos/Créditos (Índice de tarifas/débitos/créditos) =
					 * Descrição do Débito (Índice de débitos) + Valor do Débito (Índice de
					 * débitos).
					 */
					linhasDescricaoServicosConta.add(linhaDebitoCobrado);
					contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

				}else{

					/*
					 * Caso contrário, o índice de débitos seja igual ao limite de emissão de
					 * débitos na conta menos 1 (um), caso existam créditos realizados (reservar 1
					 * linha
					 * para os créditos), menos 1 (um), caso existam impostos retidos (reservar 1
					 * linha
					 * para os impostos)
					 */
					colecaoDebitoCobradoRestantes.add(debitoCobrado);
				}
			}
		}

		if(!colecaoDebitoCobradoRestantes.isEmpty()){

			// Índice de débitos = Índice de débitos + 1
			contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

			RelatorioContaModelo2SubDescritivoFaixasHelper linhaDebitoCobrado = new RelatorioContaModelo2SubDescritivoFaixasHelper();

			/* Descrição do Débito = “OUTROS DÉBITOS DE SERVIÇOS” */
			linhaDebitoCobrado.setPrimeiraColuna("Demais Serviços ");

			/*
			 * Valor do Débito (Índice de débitos) = somatório dos débitos cobrados
			 * restantes para a conta
			 */
			BigDecimal somatorioDebitosRestantes = new BigDecimal(0);
			for(DebitoCobrado debitoCobradoRestante : colecaoDebitoCobradoRestantes){

				somatorioDebitosRestantes = somatorioDebitosRestantes.add(debitoCobradoRestante.getValorPrestacao());
			}

			linhaDebitoCobrado.setSextaColuna(Util.formataBigDecimal(somatorioDebitosRestantes, 2, true));

			linhasDescricaoServicosConta.add(linhaDebitoCobrado);
		}

		// Caso o valor total dos débitos cobrados de parcelamento para a conta seja maior que zero
		if(possuiDebitosParcelamento){

			BigDecimal totalOutrosParcelamentos = BigDecimal.ZERO;
			String outrasParcelas = "";
			indexDebitos = contaEmitirHelper.getIndexDescricaoTarifasServicos();
			for(DadosDebitoParcelamentoContaHelper dadosDebitoParcelamentoContaHelper : colecaoDebitosParcelamentoHelper){

				// Índice de débitos = Índice de débitos + 1
				indexDebitos++;

				/*
				 * Caso o Índice de débitos seja menor que o limite de emissão de débitos na conta
				 * menos 1 (um) (reservar 1 linha para os débitos de parcelamento), caso existam
				 * débitos
				 * de parcelamento, menos 1 (um), caso existam créditos realizados (reservar 1 linha
				 * para os créditos), menos 1 (um), caso existam impostos retidos (reservar 1 linha
				 * para
				 * os impostos)
				 */
				if(indexDebitos < (limite - limitacaoIndex)){

					// Índice de débitos = Índice de débitos + 1
					contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

					RelatorioContaModelo2SubDescritivoFaixasHelper linhaDebitoCobrado = new RelatorioContaModelo2SubDescritivoFaixasHelper();
					linhaDebitoCobrado.setPrimeiraColuna("PARCELAMENTO DE DÉBITOS");
					linhaDebitoCobrado.setSegundaColuna(dadosDebitoParcelamentoContaHelper.getPrestacaoDebito().toString() + "/"
									+ dadosDebitoParcelamentoContaHelper.getPrestacao().toString());
					linhaDebitoCobrado.setSextaColuna(Util.formataBigDecimal(dadosDebitoParcelamentoContaHelper.getValorDebito(), 2, true));
					linhasDescricaoServicosConta.add(linhaDebitoCobrado);
				}else{

					totalOutrosParcelamentos = totalOutrosParcelamentos.add(dadosDebitoParcelamentoContaHelper.getValorDebito());
					outrasParcelas += dadosDebitoParcelamentoContaHelper.getPrestacaoDebito().toString() + "/"
									+ dadosDebitoParcelamentoContaHelper.getPrestacao().toString() + " ";
				}
			}

			if(totalOutrosParcelamentos.compareTo(BigDecimal.ZERO) == 1){

				// Índice de débitos = Índice de débitos + 1
				contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

				RelatorioContaModelo2SubDescritivoFaixasHelper linhaDebitoCobrado = new RelatorioContaModelo2SubDescritivoFaixasHelper();
				linhaDebitoCobrado.setPrimeiraColuna("PARCELAMENTOS DE DÉBITOS");
				linhaDebitoCobrado.setSextaColuna(Util.formataBigDecimal(totalOutrosParcelamentos, 2, true));
				linhaDebitoCobrado.setSegundaColuna(outrasParcelas);
				linhasDescricaoServicosConta.add(linhaDebitoCobrado);
			}

		}

		return linhasDescricaoServicosConta;

	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0109] – Gerar Linhas dos Créditos Realizados
	 * 
	 * @author Anderson Italo
	 * @data 07/08/2013
	 */
	private List<RelatorioContaModelo2SubDescritivoFaixasHelper> gerarLinhasCreditosRealizadosModelo2(
					EmitirContaTipo2Helper contaEmitirHelper,
					List<RelatorioContaModelo2SubDescritivoFaixasHelper> linhasDescricaoServicosConta,
					Collection<CreditoRealizado> colecaoCreditoRealizado, int limitacaoIndex) throws ErroRepositorioException,
					ControladorException{

		/*
		 * O sistema inicializa com nulos a tabela de Descrição do Crédito (índice de créditos) e
		 * Valor do Crédito (índice de créditos) variando o índice de 1 (um) até o limite de emissão
		 * de créditos na conta
		 */
		int limite = Util.obterInteger((String) ParametroFaturamento.P_LIMITE_EMISSAO_TARIFAS_CONTA.executar(this));
		int indexCreditos = contaEmitirHelper.getIndexDescricaoTarifasServicos();

		Collection<CreditoRealizado> colecaoCreditosRealizadosRestantes = new ArrayList<CreditoRealizado>();

		for(CreditoRealizado creditoRealizado : colecaoCreditoRealizado){

			RelatorioContaModelo2SubDescritivoFaixasHelper linhaCreditoRealizado = new RelatorioContaModelo2SubDescritivoFaixasHelper();

			// Índice de créditos = Índice de créditos + 1
			indexCreditos++;

			/*
			 * Caso o Índice de créditos seja menor que o limite de emissão de créditos na conta
			 * menos 1 (um), caso existam impostos retidos (reservar 1 linha para os impostos)
			 */
			if(indexCreditos < (limite - limitacaoIndex)){

				contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

				// Descrição do Crédito = Descrição do tipo de crédito
				linhaCreditoRealizado.setPrimeiraColuna(Util.completaString(creditoRealizado.getCreditoTipo().getDescricao(), 27));

				// Valor do crédito (CRRZ_VLCREDITO da tabela CREDITO_REALIZADO).
				linhaCreditoRealizado.setSextaColuna(Util.formataBigDecimal(creditoRealizado.getValorCredito(), 2, true));

				/*
				 * Descrição das Tarifas/Débitos/Créditos (Índice de tarifas/débitos/créditos) =
				 * Descrição do Crédito (Índice de créditos) + Valor do Crédito (Índice de
				 * créditos).
				 */
				linhasDescricaoServicosConta.add(linhaCreditoRealizado);

			}else{

				/*
				 * Caso contrário, ou seja, o Índice de créditos seja igual ao limite de emissão
				 * de créditos na conta menos 1 (um), caso existam impostos retidos (reservar 1
				 * linha para os impostos)
				 */
				colecaoCreditosRealizadosRestantes.add(creditoRealizado);
			}
		}

		if(!colecaoCreditosRealizadosRestantes.isEmpty()){

			// Índice de créditos = Índice de créditos + 1
			contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

			RelatorioContaModelo2SubDescritivoFaixasHelper linhaCreditoRealizado = new RelatorioContaModelo2SubDescritivoFaixasHelper();

			// Descrição do Crédito = “OUTROS CRÉDITOS”.
			linhaCreditoRealizado.setPrimeiraColuna(Util.completaString("OUTROS CRÉDITOS", 27));

			// Valor do Crédito = somatório dos créditos realizados
			BigDecimal somatorioCreditoRelizadosRestantes = new BigDecimal(0);
			for(CreditoRealizado creditoRealizadoRestante : colecaoCreditosRealizadosRestantes){

				somatorioCreditoRelizadosRestantes = somatorioCreditoRelizadosRestantes.add(creditoRealizadoRestante.getValorCredito());
			}

			linhaCreditoRealizado.setSextaColuna(Util.formataBigDecimal(somatorioCreditoRelizadosRestantes, 2, true));

			/*
			 * Descrição das Tarifas/Débitos/Créditos (Índice de tarifas/débitos/créditos) =
			 * Descrição do Crédito (Índice de créditos) + Valor do Crédito (Índice de
			 * créditos).
			 */
			linhasDescricaoServicosConta.add(linhaCreditoRealizado);
		}

		return linhasDescricaoServicosConta;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0110] – Gerar Linhas dos Impostos Retidos
	 * 
	 * @author Anderson Italo
	 * @data 07/08/2013
	 */
	private List<RelatorioContaModelo2SubDescritivoFaixasHelper> gerarLinhasImpostosRetidosModelo2(
					EmitirContaTipo2Helper contaEmitirHelper,
					List<RelatorioContaModelo2SubDescritivoFaixasHelper> linhasDescricaoServicosConta,
					Collection<ContaImpostosDeduzidos> colecaoContaImpostosDeduzidos) throws ErroRepositorioException, ControladorException{

		/*
		 * O sistema inicializa com nulos a tabela de Descrição do Imposto (índice de impostos) e
		 * Valor do Imposto (índice de impostos) variando o índice de 1 (um) até o limite de emissão
		 * de impostos na conta
		 */
		int limite = Util.obterInteger((String) ParametroFaturamento.P_LIMITE_EMISSAO_TARIFAS_CONTA.executar(this));
		int indexImpostos = contaEmitirHelper.getIndexDescricaoTarifasServicos();

		Collection<ContaImpostosDeduzidos> colecaoContaImpostosDeduzidosRestantes = new ArrayList<ContaImpostosDeduzidos>();

		for(ContaImpostosDeduzidos contaImpostosDeduzidos : colecaoContaImpostosDeduzidos){

			RelatorioContaModelo2SubDescritivoFaixasHelper linhaCreditoRealizado = new RelatorioContaModelo2SubDescritivoFaixasHelper();

			// Índice de impostos = Índice de impostos + 1.
			indexImpostos++;

			// Caso o Índice de impostos seja menor que o limite de emissão de impostos na conta
			if(indexImpostos < limite){

				contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

				// Descrição do Imposto = Descrição do tipo de imposto
				linhaCreditoRealizado.setPrimeiraColuna(Util.completaString(contaImpostosDeduzidos.getImpostoTipo().getDescricao(), 27));

				// Valor do Imposto = Valor do imposto (CNID_VLIMPOSTO
				linhaCreditoRealizado.setSextaColuna(Util.formataBigDecimal(contaImpostosDeduzidos.getValorImposto(), 2, true));

				/*
				 * Descrição das Tarifas/Débitos/Créditos (Índice de
				 * tarifas/débitos/créditos) = Descrição do Imposto (Índice de impostos) + Valor
				 * do Imposto (Índice de impostos)
				 */
				linhasDescricaoServicosConta.add(linhaCreditoRealizado);

			}else{

				/*
				 * Caso contrário, ou seja, o Índice de impostos seja igual ao limite de emissão
				 * de impostos na conta
				 */
				colecaoContaImpostosDeduzidosRestantes.add(contaImpostosDeduzidos);
			}
		}

		if(!colecaoContaImpostosDeduzidosRestantes.isEmpty()){

			// Índice de impostos = Índice de impostos + 1.
			contaEmitirHelper.setIndexDescricaoTarifasServicos(contaEmitirHelper.getIndexDescricaoTarifasServicos() + 1);

			RelatorioContaModelo2SubDescritivoFaixasHelper linhaCreditoRealizado = new RelatorioContaModelo2SubDescritivoFaixasHelper();

			// Descrição do Imposto (Índice de impostos) = “OUTROS IMPOSTOS”
			linhaCreditoRealizado.setPrimeiraColuna(Util.completaString("OUTROS IMPOSTOS", 27));

			/*
			 * Valor do Imposto (Índice de impostos) = somatório dos impostos deduzidos
			 * restantes para a conta
			 */
			BigDecimal somatorioImpostosDeduzidosRestantes = new BigDecimal(0);
			for(ContaImpostosDeduzidos contaImpostosDeduzidosRestante : colecaoContaImpostosDeduzidosRestantes){

				somatorioImpostosDeduzidosRestantes = somatorioImpostosDeduzidosRestantes.add(contaImpostosDeduzidosRestante
								.getValorImposto());
			}

			linhaCreditoRealizado.setSextaColuna(Util.formataBigDecimal(somatorioImpostosDeduzidosRestantes, 2, true));

			/*
			 * Descrição das Tarifas/Débitos/Créditos (Índice de tarifas/débitos/créditos) =
			 * Descrição do Imposto (Índice de impostos) + Valor do Imposto (Índice de impostos)
			 */
			linhasDescricaoServicosConta.add(linhaCreditoRealizado);
		}

		return linhasDescricaoServicosConta;
	}

	/**
	 * [UC0352] Emitir Contas
	 * [SB0030] – Gerar Código de Barras
	 * 
	 * @author Anderson Italo
	 * @data 27/08/2011
	 * @param idImovel
	 * @throws ControladorException
	 */
	public void gerarCodigoDeBarras(EmitirContaTipo2Helper contaEmitirHelper) throws ControladorException{

		String anoMesString = "" + contaEmitirHelper.getAnoMesConta();
		String mesAnoString = anoMesString.substring(4, 6) + anoMesString.substring(0, 4);

		String representacaoNumericaCodBarra = this.getControladorArrecadacao().obterRepresentacaoNumericaCodigoBarra(3,
						contaEmitirHelper.getValorTotalConta(), contaEmitirHelper.getInscLocalidade(), contaEmitirHelper.getIdImovel(),
						mesAnoString, contaEmitirHelper.getDigitoVerificadorConta().intValue(), null, null, null, DocumentoTipo.CONTA,
						null, null, null, null, null, null);

		/*
		 * Formata a representação númerica do código de barras com dígito e com espaços em branco
		 * e retornando ex: 817700000000 010936599702 411310797039 0011433708318
		 */
		String representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra.substring(0, 11)
						+ representacaoNumericaCodBarra.substring(11, 12) + " " + representacaoNumericaCodBarra.substring(12, 23)
						+ representacaoNumericaCodBarra.substring(23, 24) + " " + representacaoNumericaCodBarra.substring(24, 35)
						+ representacaoNumericaCodBarra.substring(35, 36) + " " + representacaoNumericaCodBarra.substring(36, 47)
						+ representacaoNumericaCodBarra.substring(47, 48);
		contaEmitirHelper.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

		/*
		 * Formata a representação númerica do código de barras sem dígito e sem espaços em branco
		 * e retornando ex: 817700000000109365997041131079703001143370831
		 */
		String representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra.substring(0, 11)
						+ representacaoNumericaCodBarra.substring(12, 23) + representacaoNumericaCodBarra.substring(24, 35)
						+ representacaoNumericaCodBarra.substring(36, 47);
		contaEmitirHelper.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);

	}

	public Object[] pesquisarContaMensagem(Integer anoMesFaturamento, Integer idFaturamentoGrupo, Integer idGerenciaRegional,
					Integer idLocalidade, Integer idSetorComercial) throws ControladorException{

		Object[] contaMensagem = null;
		try{

			// Pesquisa Mensagem da Conta por Setor
			contaMensagem = repositorioFaturamento.pesquisarDescricaoContaMensagemFaturamentoImediato(anoMesFaturamento,
							idFaturamentoGrupo, idGerenciaRegional, idLocalidade, idSetorComercial);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return contaMensagem;
	}
	
		/**
	 * @param debitoACobrar
	 * @param numeroTotalParcelas
	 * @param totalParcelasAntecipadas
	 * @return
	 */

	public BigDecimal calcularValorPrestacaoParcelasAntecipadas(DebitoACobrar debitoACobrar, Integer totalParcelasAntecipadas){

		BigDecimal valorPrestacao = BigDecimal.ZERO;
		BigDecimal valorTotalDebitoACobrar = BigDecimal.ZERO;

		short numeroPrestacaoDebitoShort = debitoACobrar.getNumeroPrestacaoDebito();
		short numeroPrestacaoCobradas = debitoACobrar.getNumeroPrestacaoCobradas();

		if(totalParcelasAntecipadas > (numeroPrestacaoDebitoShort - numeroPrestacaoCobradas)){
			totalParcelasAntecipadas = Integer.valueOf(numeroPrestacaoDebitoShort - numeroPrestacaoCobradas);
		}

		// Integer numeroTotalParcelas = Integer.valueOf(numeroPrestacaoDebitoShort);

		// "i" varia de 0 (zero) até "quantidadeParcelasAntecipadas - 1"
		for(int i = 0; i < totalParcelasAntecipadas; i++){

			valorPrestacao = debitoACobrar.getValorDebito().divide(new BigDecimal(numeroPrestacaoDebitoShort), Parcelamento.CASAS_DECIMAIS,
							Parcelamento.TIPO_ARREDONDAMENTO);


			if(i == 0 && ((numeroPrestacaoCobradas + totalParcelasAntecipadas) == numeroPrestacaoDebitoShort)){

				// Obtém o número de prestação débito
				BigDecimal numeroPrestacaoDebito = new BigDecimal(numeroPrestacaoDebitoShort);

				// Mutiplica o valor da prestação * número da prestação debito
				BigDecimal multiplicacao = valorPrestacao.multiply(numeroPrestacaoDebito).setScale(2);

				// Subtrai o valor do débito pelo resultado da multiplicação
				BigDecimal parte1 = debitoACobrar.getValorDebito().subtract(multiplicacao).setScale(2);

				// Calcula o valor da prestação
				valorPrestacao = valorPrestacao.add(parte1).setScale(2);
			}

			valorTotalDebitoACobrar = valorTotalDebitoACobrar.add(valorPrestacao);


		}

		return valorTotalDebitoACobrar;

	}
	
	/**
	 * [UC3103] Cancelar Débito a Cobrar de Rateio por Macromedidor.
	 * 6. O sistema apresenta os dados do imóvel Condomínio.
	 * 
	 * @param listaIdImovel
	 * @return
	 * @throws ControladorException
	 */
	public List<ClienteImovelCondominioHelper> pesquisarClienteImovelCondominioHelper(Integer idImovel, Integer idLigacaoTipo,
					Integer anoMesRefFaturamento) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarClienteImovelCondominioHelper(idImovel);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC3103] Cancelar Débito a Cobrar de Rateio por Macromedidor.
	 * 6.4.7. Histórico de Medição Individualizada.
	 * 
	 * @param idImovel
	 * @param idLigacaoTipo
	 * @param anoMesRefFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public HistoricoMedicaoIndividualizadaHelper pesquisarHistoricoMedicaoIndividualizadaHelper(Integer idImovel, Integer idLigacaoTipo,
					Integer anoMesRefFaturamento) throws ControladorException{

		HistoricoMedicaoIndividualizadaHelper helper;

		try{
			helper = repositorioFaturamento.pesquisarHistoricoMedicaoIndividualizadaHelper(idImovel, idLigacaoTipo, anoMesRefFaturamento);
			// 6.4.7.4. FS0005 - Verificar existência do histórico de medição.
			if(Util.isNaoNuloBrancoZero(helper) && Util.isVazioOuBranco(helper.getConsumoMedidoMes())){
				helper.setConsumoMedidoMes(0);
				}
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return helper;
	}

	/**
	 * [UC3103] Cancelar Débito a Cobrar de Rateio por Macromedidor.
	 * 7. O sistema seleciona os débitos a cobrar de rateio dos imóveis vinculados para o mês
	 * informado.
	 * 
	 * @param idImovel
	 * @param idLigacaoTipo
	 * @param anoMesRefFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public List<DebitosACobrarRateioImoveisVinculadosHelper> pesquisarDebitosACobrarRateioImoveisVinculadosHelper(
					List<Integer> listaIdImovel, Integer idLigacaoTipo, Integer anoMesRefFaturamento) throws ControladorException{

		List<DebitosACobrarRateioImoveisVinculadosHelper> listaDebitosACobrarRateioImoveisVinculadosHelper;

		try{
			listaDebitosACobrarRateioImoveisVinculadosHelper = new ArrayList<DebitosACobrarRateioImoveisVinculadosHelper>();
			for(Integer idImovel : listaIdImovel){
				List<DebitosACobrarRateioImoveisVinculadosHelper> lista = repositorioFaturamento
								.pesquisarDebitosACobrarRateioImoveisVinculadosHelper(idImovel, idLigacaoTipo, anoMesRefFaturamento);
				for(DebitosACobrarRateioImoveisVinculadosHelper helper : lista){
					// 6.4.7.4. FS0005 - Verificar existência do histórico de medição.
					if(Util.isNaoNuloBrancoZero(helper.getConsumoMedidoAgua())){
						helper.setConsumoMedidoAgua(0);
					}
					listaDebitosACobrarRateioImoveisVinculadosHelper.add(helper);
				}
			}
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return listaDebitosACobrarRateioImoveisVinculadosHelper;
	}

	/**
	 * Pesquisa os dados necessário para a geração do relatório
	 * [UC3114] - Gerar Relatório Faturamento e Consumo Direto e Indireto Estadual
	 * 
	 * @author Victon Santos
	 * @created 27/09/2013
	 * @throws ControladorException
	 */
	public Collection<FaturamentoConsumoDiretoIndiretoEstadualRelatorioHelper> pesquisarDadosRelatorioFaturamentoConsumoDiretoIndiretoEstadual(
					Integer anoMes, Integer opcaoRelatorio) throws ControladorException{

		Collection retorno = new ArrayList();

		// Criação das coleções
		Collection colecaoFaturamentoConsumoDiretoIndiretoEstadualRelatorio = null;

		try{
			colecaoFaturamentoConsumoDiretoIndiretoEstadualRelatorio = repositorioFaturamento
							.pesquisarDadosRelatorioFaturamentoConsumoDiretoIndiretoEstadual(anoMes, opcaoRelatorio);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoFaturamentoConsumoDiretoIndiretoEstadualRelatorio != null
						&& !colecaoFaturamentoConsumoDiretoIndiretoEstadualRelatorio.isEmpty()){

			Iterator colecaoFaturamentoConsumoDiretoIndiretoEstadualIterator = colecaoFaturamentoConsumoDiretoIndiretoEstadualRelatorio
							.iterator();

			while(colecaoFaturamentoConsumoDiretoIndiretoEstadualIterator.hasNext()){

				Object[] dadosFaturamentoConsumoDiretoIndiretoEstadual = (Object[]) colecaoFaturamentoConsumoDiretoIndiretoEstadualIterator
								.next();

				FaturamentoConsumoDiretoIndiretoEstadualRelatorioHelper faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper = new FaturamentoConsumoDiretoIndiretoEstadualRelatorioHelper();

				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[0] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setReferencia((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[0]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[1] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setCodigoResponsavel((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[1]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[2] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setResponsavel((String) dadosFaturamentoConsumoDiretoIndiretoEstadual[2]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[3] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setTipoResponsavel((String) dadosFaturamentoConsumoDiretoIndiretoEstadual[3]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[4] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setLocalidade((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[4]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[5] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setNomeLocalidade((String) dadosFaturamentoConsumoDiretoIndiretoEstadual[5]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[6] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setMatricula((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[6]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[7] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setCodigoUsuario((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[7]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[8] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setUsuario((String) dadosFaturamentoConsumoDiretoIndiretoEstadual[8]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[9] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setTipoAgua((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[9]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[10] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setTipoEsgoto((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[10]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[11] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setCategoria((Character) dadosFaturamentoConsumoDiretoIndiretoEstadual[11]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[12] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setEconomia((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[12]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[13] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setEndereco((String) dadosFaturamentoConsumoDiretoIndiretoEstadual[13]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[14] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setValorLeituraAnterior((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[14]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[15] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setValorLeituraAtual((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[15]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[16] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setConsumoMicromedido((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[16]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[17] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setConsumoFaturado((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[17]);
				}
				if(dadosFaturamentoConsumoDiretoIndiretoEstadual[18] != null){
					faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper
									.setConsumoMedio((BigDecimal) dadosFaturamentoConsumoDiretoIndiretoEstadual[18]);
				}


				retorno.add(faturamentoConsumoDiretoIndiretoEstadualRelatorioHelper);
			}
		}

		return retorno;
	}

	/**
	 * @param idImovel
	 * @param idDebitoTipo
	 * @return
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarPorDebitoTipo(Integer idImovel, Integer idDebitoTipo){

		Collection<DebitoACobrar> retorno = null;
		try{
			retorno = this.repositorioFaturamento.pesquisarDebitoACobrarPorDebitoTipo(idImovel, idDebitoTipo);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;
	}
	
	/**
	 * [UC3128] GerarRelatorioImóveiscomLigaçãoCortadacomConsumo
	 * 
	 * @author Hiroshi Gonçalves
	 * @created 09/12/2013
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarImoveisLigacaoCortadaComConsumo(int anoMesReferencia, Integer grupoFaturamento) throws ControladorException{

		Collection retornoConsulta = null;
		Collection colecaoHelper = new ArrayList();

		try{
			retornoConsulta = this.repositorioFaturamento.consultarImoveisLigacaoCortadaComConsumo(anoMesReferencia, grupoFaturamento);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			throw new ControladorException("erro.sistema", e);
		}

		if(retornoConsulta != null && !retornoConsulta.isEmpty()){

			Iterator iterContasEmitidas = retornoConsulta.iterator();
			RelatorioImoveisLigacaoCortadaComConsumoHelper relatorioImoveisLigacaoCortadaComConsumoHelper = null;

			while(iterContasEmitidas.hasNext()){
				Object[] objeto = (Object[]) iterContasEmitidas.next();
				relatorioImoveisLigacaoCortadaComConsumoHelper = new RelatorioImoveisLigacaoCortadaComConsumoHelper();

				// Localidade
				if(objeto[0] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setLocalidade("" + objeto[0]);
				}

				// Setor Comercial
				if(objeto[1] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setSetorComercial("" + objeto[1]);
				}

				// Quadra
				if(objeto[2] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setQuadra("" + objeto[2]);
				}

				// Lote
				if(objeto[3] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setLote("" + objeto[3]);
				}

				// Imóvel
				if(objeto[4] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setMatriculaImovel("" + objeto[4]);
				}

				// Nome do Cliente
				if(objeto[5] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setNomeCliente("" + objeto[5]);
				}

				// Data Corte
				if(objeto[6] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setDtCorte(Util.formatarData((Date) objeto[6]));
				}

				// Leitura Corte LAGU_ID
				if(objeto[7] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setLeituraCorteLaguId("" + objeto[7]);
				}

				// Leitura Corte IMOV_ID
				if(objeto[8] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setLeituraCorteImovId("" + objeto[8]);
				}

				// Consumo Anterior
				if(objeto[9] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setConsumoAnterior("" + objeto[9]);
				}

				// Referência Consumo Anterior
				if(objeto[10] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setRefConsumoAnterior("" + objeto[10]);
				}

				// Leitura Anterior LAGU_ID
				if(objeto[11] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setLeituraAnteriorLaguId("" + objeto[11]);
				}

				// Leitura Atual LAGU_ID
				if(objeto[12] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setLeituraAtualLaguId("" + objeto[12]);
				}

				// Leitura Anterior IMOV_ID
				if(objeto[13] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setLeituraAnteriorImovId("" + objeto[13]);
				}

				// Leitura Atual IMOV_ID
				if(objeto[14] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setLeituraAtualImovId("" + objeto[14]);
				}

				// Consumo Mes
				if(objeto[15] != null){
					relatorioImoveisLigacaoCortadaComConsumoHelper.setConsumoMes("" + objeto[15]);
				}

				colecaoHelper.add(relatorioImoveisLigacaoCortadaComConsumoHelper);

			}

		}

		return colecaoHelper;
	}
	/**
	 * @throws ControladorException
	 */
	public void executarAjusteContasEnviadasHistorico(Integer anoMesRefInicial, Integer anoMesRefFinal, String[] idsCliente)
					throws ControladorException{

		try{
			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteContasEnviadasHistorico(anoMesRefInicial, anoMesRefFinal, idsCliente);
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * Método que realiza o ajuste do faturamento para trazer de volta as contas que estão em
	 * conta_historico para tabela de conta devido a um erro do faturamento
	 * 
	 * @author Anderson Italo
	 * @date 09/01/2014
	 */
	public void executarAjusteContasEnviadasHistoricoPreFaturadasComValorZeroIndicadorEmissaoCampo3(String idsFaturamentoGrupo)
					throws ControladorException{

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteContasEnviadasHistoricoPreFaturadasComValorZeroIndicadorEmissaoCampo3(idsFaturamentoGrupo);

		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * @param colecao
	 * @throws ControladorException
	 */

	public void executarAjusteCoordenadasGIS(Collection colecao) throws ControladorException{

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteCoordenadasGIS(colecao);

		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}
	/**
	 * [UC3118] Inserir Comando de Simulação de Faturamento
	 * 
	 * @author Anderson Italo
	 * @date 24/12/2013
	 */

	public Integer inserirComandoSimulacaoFaturamento(InserirComandoSimulacaoFaturamentoHelper inserirComandoSimulacaoFaturamentoHelper)
					throws ControladorException{

		Integer retorno = null;
		FaturamentoSimulacaoComando faturamentoSimulacaoComando = new FaturamentoSimulacaoComando();

		try{

			// [FS0007] - Verificar existência do comando
			if(repositorioFaturamento.pesquisarFaturamentoSimulacaoComando(inserirComandoSimulacaoFaturamentoHelper) != null){

				throw new ControladorException("atencao.campo_selecionado.obrigatorioatencao.faturamento_simulacao_comando_existente");
			}

			// [FS0008] - Verificar existência de imóveis para os parâmetros
			if(Util.isVazioOrNulo(repositorioFaturamento
							.pesquisarIdsImoveisComandoSimulacaoFaturamento(inserirComandoSimulacaoFaturamentoHelper))){

				throw new ControladorException("atencao.faturamento_simulacao_comando_imovel_inexistente");
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getTituloComando() != null){

				faturamentoSimulacaoComando.setDescricaoTitulo(inserirComandoSimulacaoFaturamentoHelper.getTituloComando());
			}else{

				faturamentoSimulacaoComando.setDescricaoTitulo("Comando incluido");
			}

			faturamentoSimulacaoComando.setDataComando(new Date());
			faturamentoSimulacaoComando.setUltimaAlteracao(new Date());

			if(inserirComandoSimulacaoFaturamentoHelper.getIdFaturamentoGrupo() != null){

				faturamentoSimulacaoComando.setFaturamentoGrupo(new FaturamentoGrupo(inserirComandoSimulacaoFaturamentoHelper
								.getIdFaturamentoGrupo()));
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdGerenciaRegional() != null){

				GerenciaRegional gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setId(inserirComandoSimulacaoFaturamentoHelper.getIdGerenciaRegional());
				faturamentoSimulacaoComando.setGerenciaRegional(gerenciaRegional);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdUnidadeNegocio() != null){

				UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(inserirComandoSimulacaoFaturamentoHelper.getIdUnidadeNegocio());
				faturamentoSimulacaoComando.setUnidadeNegocio(unidadeNegocio);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdLocalidadeInicial() != null){

				Localidade localidade = new Localidade();
				localidade.setId(inserirComandoSimulacaoFaturamentoHelper.getIdLocalidadeInicial());
				faturamentoSimulacaoComando.setLocalidadeInicial(localidade);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdLocalidadeFinal() != null){

				Localidade localidade = new Localidade();
				localidade.setId(inserirComandoSimulacaoFaturamentoHelper.getIdLocalidadeFinal());
				faturamentoSimulacaoComando.setLocalidadeFinal(localidade);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdSetorComercialInicial() != null){

				SetorComercial setorComercial = new SetorComercial();
				setorComercial.setId(inserirComandoSimulacaoFaturamentoHelper.getIdSetorComercialInicial());
				faturamentoSimulacaoComando.setSetorComercialInicial(setorComercial);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdSetorComercialFinal() != null){

				SetorComercial setorComercial = new SetorComercial();
				setorComercial.setId(inserirComandoSimulacaoFaturamentoHelper.getIdSetorComercialFinal());
				faturamentoSimulacaoComando.setSetorComercialFinal(setorComercial);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdQuadraInicial() != null){

				Quadra quadra = new Quadra();
				quadra.setId(inserirComandoSimulacaoFaturamentoHelper.getIdQuadraInicial());
				faturamentoSimulacaoComando.setQuadraInicial(quadra);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdQuadraFinal() != null){

				Quadra quadra = new Quadra();
				quadra.setId(inserirComandoSimulacaoFaturamentoHelper.getIdQuadraFinal());
				faturamentoSimulacaoComando.setQuadraFinal(quadra);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdRotaInicial() != null){

				Rota rota = new Rota();
				rota.setId(inserirComandoSimulacaoFaturamentoHelper.getIdRotaInicial());
				faturamentoSimulacaoComando.setRotaInicial(rota);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdRotaFinal() != null){

				Rota rota = new Rota();
				rota.setId(inserirComandoSimulacaoFaturamentoHelper.getIdRotaFinal());
				faturamentoSimulacaoComando.setRotaFinal(rota);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getLoteInicial() != null){

				faturamentoSimulacaoComando.setLoteInicial(inserirComandoSimulacaoFaturamentoHelper.getLoteInicial());
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getLoteFinal() != null){

				faturamentoSimulacaoComando.setLoteFinal(inserirComandoSimulacaoFaturamentoHelper.getLoteFinal());
			}

			faturamentoSimulacaoComando.setCodigoTipoConsumoAgua(inserirComandoSimulacaoFaturamentoHelper.getCodigoTipoConsumoAgua());
			faturamentoSimulacaoComando.setCodigoTipoConsumoEsgoto(inserirComandoSimulacaoFaturamentoHelper.getCodigoTipoConsumoEsgoto());

			if(inserirComandoSimulacaoFaturamentoHelper.getIdConsumoTarifa() != null){

				ConsumoTarifa consumoTarifa = new ConsumoTarifa();
				consumoTarifa.setId(inserirComandoSimulacaoFaturamentoHelper.getIdConsumoTarifa());
				faturamentoSimulacaoComando.setConsumoTarifa(consumoTarifa);
			}

			

			retorno = (Integer) getControladorUtil().inserir(faturamentoSimulacaoComando);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * [UC0111] Iniciar Processo
	 * [SB0009] - Obter Dados Complementares do Comando de Simulação de Faturamento
	 * 
	 * @author Anderson Italo
	 * @date 29/12/2013
	 * @throws ControladorException
	 */
	public String obterDadosComplementaresComandoSimulacaoFaturamento(FaturamentoSimulacaoComando faturamentoSimulacaoComando)
					throws ControladorException{

		String retorno = "";

		if(faturamentoSimulacaoComando != null){

			ProcessoIniciadoDadoComplementarHelper helper = new ProcessoIniciadoDadoComplementarHelper();

			// Título do comando
			helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_TITULO,
							faturamentoSimulacaoComando.getDescricaoTitulo());

			// Grupo de faturamento
			if(faturamentoSimulacaoComando.getFaturamentoGrupo() != null){

				helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_GRUPO_FATURAMENTO,
								faturamentoSimulacaoComando.getFaturamentoGrupo().getDescricao());
			}

			// Tipo de consumo de água
			if(faturamentoSimulacaoComando.getCodigoTipoConsumoAgua().equals(FaturamentoSimulacaoComando.CONSUMO_ANTERIOR)){

				helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_TIPO_CONSUMO_AGUA,
								"Consumo Anterior");
			}else if(faturamentoSimulacaoComando.getCodigoTipoConsumoAgua().equals(FaturamentoSimulacaoComando.CONSUMO_MINIMO)){

				helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_TIPO_CONSUMO_AGUA,
								"Consumo Minimo");
			}else{

				helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_TIPO_CONSUMO_AGUA, "Consumo Médio");
			}

			// Tipo de consumo de esgoto
			if(faturamentoSimulacaoComando.getCodigoTipoConsumoEsgoto().equals(FaturamentoSimulacaoComando.CONSUMO_ANTERIOR)){

				helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_TIPO_CONSUMO_ESGOTO,
								"Consumo Anterior");
			}else if(faturamentoSimulacaoComando.getCodigoTipoConsumoEsgoto().equals(FaturamentoSimulacaoComando.CONSUMO_MINIMO)){

				helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_TIPO_CONSUMO_ESGOTO,
								"Consumo Minimo");
			}else{

				helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_TIPO_CONSUMO_ESGOTO,
								"Consumo Medio");
			}

			// Tarifa de consumo
			if(faturamentoSimulacaoComando.getConsumoTarifa() != null){

				helper.adcionarDadoComplementar(DadoComplementarEnumerator.FATURAMENTO_SIMULACAO_COMANDO_GRUPO_FATURAMENTO,
								faturamentoSimulacaoComando.getConsumoTarifa().getDescricao());
			}

			retorno = helper.getStringFormatoPesistencia();
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite simular o faturamento quando a atividade executada for
	 * "simular faturamento do grupo"
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Anderson Italo
	 * @date 29/12/2013
	 * @throws ControladorException
	 */
	public void simularFaturamento(Integer anoMesFaturamentoCorrente, int idFaturamentoAtividade,
					FaturamentoSimulacaoComando faturamentoSimulacaoComando, int idFuncionalidadeIniciada) throws ControladorException{

		// Registrar o início do processamento da unidade de processamento do batch
		int idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, 0);

		try{

			// [UC0113] Faturar Grupo de Faturamento
			this.faturarGrupoFaturamento(null, null, anoMesFaturamentoCorrente, idFaturamentoAtividade, 0, faturamentoSimulacaoComando);

			// Registrar o fim da execução da Unidade de Processamento
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}

	}



	/**
	 * [UC3134] Manter Comando de Simulação de Faturamento
	 * 
	 * @author Anderson Italo
	 * @date 19/01/2014
	 */
	public Collection<FaturamentoSimulacaoComando> pesquisarFaturamentoSimulacaoComando(Integer numeroPagina, Date dataInicialComando,
					Date dataFinalComando, Short indicadorExecutado) throws ControladorException{

		try{

			return repositorioFaturamento.pesquisarFaturamentoSimulacaoComando(numeroPagina, dataInicialComando, dataFinalComando,
							indicadorExecutado);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC3134] Manter Comando de Simulação de Faturamento
	 * 
	 * @author Anderson Italo
	 * @date 19/01/2014
	 */
	public Integer pesquisarTotalRegistrosFaturamentoSimulacaoComando(Date dataInicialComando, Date dataFinalComando,
					Short indicadorExecutado) throws ControladorException{

		try{

			return repositorioFaturamento.pesquisarTotalRegistrosFaturamentoSimulacaoComando(dataInicialComando, dataFinalComando,
							indicadorExecutado);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC3134] Manter Comando de Simulação de Faturamento
	 * [SB001] - Alterar comando de simulação de faturamento
	 * 
	 * @author Anderson Italo
	 * @date 28/01/2014
	 */
	public void atualizarComandoSimulacaoFaturamento(InserirComandoSimulacaoFaturamentoHelper inserirComandoSimulacaoFaturamentoHelper,
					FaturamentoSimulacaoComando faturamentoSimulacaoComando) throws ControladorException{

		try{

			// [FS0007] - Verificar existência do comando
			if(repositorioFaturamento.pesquisarFaturamentoSimulacaoComando(inserirComandoSimulacaoFaturamentoHelper) != null){

				throw new ControladorException("atencao.campo_selecionado.obrigatorioatencao.faturamento_simulacao_comando_existente");
			}

			// [FS0008] - Verificar existência de imóveis para os parâmetros
			if(Util.isVazioOrNulo(repositorioFaturamento
							.pesquisarIdsImoveisComandoSimulacaoFaturamento(inserirComandoSimulacaoFaturamentoHelper))){

				throw new ControladorException("atencao.faturamento_simulacao_comando_imovel_inexistente");
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getTituloComando() != null){

				faturamentoSimulacaoComando.setDescricaoTitulo(inserirComandoSimulacaoFaturamentoHelper.getTituloComando());
			}else{

				faturamentoSimulacaoComando.setDescricaoTitulo("Comando alterado");
			}

			faturamentoSimulacaoComando.setUltimaAlteracao(new Date());
			faturamentoSimulacaoComando.setDataComando(new Date());

			if(inserirComandoSimulacaoFaturamentoHelper.getIdFaturamentoGrupo() != null){

				faturamentoSimulacaoComando.setFaturamentoGrupo(new FaturamentoGrupo(inserirComandoSimulacaoFaturamentoHelper
								.getIdFaturamentoGrupo()));
			}else{

				faturamentoSimulacaoComando.setFaturamentoGrupo(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdGerenciaRegional() != null){

				GerenciaRegional gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setId(inserirComandoSimulacaoFaturamentoHelper.getIdGerenciaRegional());
				faturamentoSimulacaoComando.setGerenciaRegional(gerenciaRegional);
			}else{

				faturamentoSimulacaoComando.setGerenciaRegional(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdUnidadeNegocio() != null){

				UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(inserirComandoSimulacaoFaturamentoHelper.getIdUnidadeNegocio());
				faturamentoSimulacaoComando.setUnidadeNegocio(unidadeNegocio);
			}else{

				faturamentoSimulacaoComando.setUnidadeNegocio(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdLocalidadeInicial() != null){

				Localidade localidade = new Localidade();
				localidade.setId(inserirComandoSimulacaoFaturamentoHelper.getIdLocalidadeInicial());
				faturamentoSimulacaoComando.setLocalidadeInicial(localidade);
			}else{

				faturamentoSimulacaoComando.setLocalidadeInicial(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdLocalidadeFinal() != null){

				Localidade localidade = new Localidade();
				localidade.setId(inserirComandoSimulacaoFaturamentoHelper.getIdLocalidadeFinal());
				faturamentoSimulacaoComando.setLocalidadeFinal(localidade);
			}else{

				faturamentoSimulacaoComando.setLocalidadeFinal(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdSetorComercialInicial() != null){

				SetorComercial setorComercial = new SetorComercial();
				setorComercial.setId(inserirComandoSimulacaoFaturamentoHelper.getIdSetorComercialInicial());
				faturamentoSimulacaoComando.setSetorComercialInicial(setorComercial);
			}else{

				faturamentoSimulacaoComando.setSetorComercialInicial(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdSetorComercialFinal() != null){

				SetorComercial setorComercial = new SetorComercial();
				setorComercial.setId(inserirComandoSimulacaoFaturamentoHelper.getIdSetorComercialFinal());
				faturamentoSimulacaoComando.setSetorComercialFinal(setorComercial);
			}else{

				faturamentoSimulacaoComando.setSetorComercialFinal(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdQuadraInicial() != null){

				Quadra quadra = new Quadra();
				quadra.setId(inserirComandoSimulacaoFaturamentoHelper.getIdQuadraInicial());
				faturamentoSimulacaoComando.setQuadraInicial(quadra);
			}else{

				faturamentoSimulacaoComando.setQuadraInicial(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdQuadraFinal() != null){

				Quadra quadra = new Quadra();
				quadra.setId(inserirComandoSimulacaoFaturamentoHelper.getIdQuadraFinal());
				faturamentoSimulacaoComando.setQuadraFinal(quadra);
			}else{

				faturamentoSimulacaoComando.setQuadraFinal(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdRotaInicial() != null){

				Rota rota = new Rota();
				rota.setId(inserirComandoSimulacaoFaturamentoHelper.getIdRotaInicial());
				faturamentoSimulacaoComando.setRotaInicial(rota);
			}else{

				faturamentoSimulacaoComando.setRotaInicial(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getIdRotaFinal() != null){

				Rota rota = new Rota();
				rota.setId(inserirComandoSimulacaoFaturamentoHelper.getIdRotaFinal());
				faturamentoSimulacaoComando.setRotaFinal(rota);
			}else{

				faturamentoSimulacaoComando.setRotaFinal(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getLoteInicial() != null){

				faturamentoSimulacaoComando.setLoteInicial(inserirComandoSimulacaoFaturamentoHelper.getLoteInicial());
			}else{

				faturamentoSimulacaoComando.setLoteInicial(null);
			}

			if(inserirComandoSimulacaoFaturamentoHelper.getLoteFinal() != null){

				faturamentoSimulacaoComando.setLoteFinal(inserirComandoSimulacaoFaturamentoHelper.getLoteFinal());
			}else{

				faturamentoSimulacaoComando.setLoteFinal(null);
			}


			faturamentoSimulacaoComando.setCodigoTipoConsumoAgua(inserirComandoSimulacaoFaturamentoHelper.getCodigoTipoConsumoAgua());
			faturamentoSimulacaoComando.setCodigoTipoConsumoEsgoto(inserirComandoSimulacaoFaturamentoHelper.getCodigoTipoConsumoEsgoto());

			if(inserirComandoSimulacaoFaturamentoHelper.getIdConsumoTarifa() != null){

				ConsumoTarifa consumoTarifa = new ConsumoTarifa();
				consumoTarifa.setId(inserirComandoSimulacaoFaturamentoHelper.getIdConsumoTarifa());
				faturamentoSimulacaoComando.setConsumoTarifa(consumoTarifa);
			}else{

				faturamentoSimulacaoComando.setConsumoTarifa(null);
			}

			getControladorUtil().atualizar(faturamentoSimulacaoComando);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0146] Manter Conta
	 * [SB0003] - Retificar Conta
	 * 
	 * @author Anderson Italo
	 * @created 17/01/2014
	 * @throws ErroRepositorioException
	 */
	public ClienteConta pesquisarClienteContaPorTipoRelacao(Integer idConta, Integer idClienteRelacaoTipo) throws ControladorException{

		ClienteConta retorno = null;
		try{

			retorno = this.repositorioFaturamento.pesquisarClienteContaPorTipoRelacao(idConta, idClienteRelacaoTipo);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}
	/**
	 * [UC3132] Gerar Relatório de Contratos de Demanda de Consumo
	 * 
	 * @author Vicente Zarga
	 * @date 18/01/2014
	 * @throws ControladorException
	 */
	public Collection<ContratoDemandaConsumo> pesquisarDadosRelatorioContratoDemandaConsumo(Integer faturamentoGrupo,
					Integer[] localidades, String tipoContrato, Integer tarifaConsumo, Integer mesAnoFaturamentoInicial,
					Integer mesAnoFaturamentoFinal, Integer encerrado) throws ControladorException{
	
		Collection<ContratoDemandaConsumo> colecao = new ArrayList<ContratoDemandaConsumo>();
		
		try{
			
			colecao = repositorioFaturamento.pesquisarDadosRelatorioContratoDemandaConsumo(faturamentoGrupo, localidades, tipoContrato,
							tarifaConsumo, mesAnoFaturamentoInicial, mesAnoFaturamentoFinal, encerrado);
			
			
		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
		
		return colecao;
	}
	/**
	 * [UC3132] Gerar Relatório de Contratos de Demanda de Consumo
	 * 
	 * @author Vicente Zarga
	 * @date 18/01/2014
	 * @throws ControladorException
	 */
	public Integer pesquisarDadosRelatorioContratoDemandaConsumoCount(Integer faturamentoGrupo, Integer[] localidades, String tipoContrato,
					Integer tarifaConsumo, Integer mesAnoFaturamentoInicial, Integer mesAnoFaturamentoFinal, Integer encerrado)
					throws ControladorException{
	
		Integer retorno = 0;
		
		try{
			
			retorno = repositorioFaturamento.pesquisarDadosRelatorioContratoDemandaConsumoCount(faturamentoGrupo, localidades,
							tipoContrato, tarifaConsumo, mesAnoFaturamentoInicial, mesAnoFaturamentoFinal, encerrado);
			
			
		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
		
		return retorno;
	}
	/**
	 * [UC3055] Encerrar Faturamento
	 * [SB0007] Encerrar contratos de demanda de consumo
	 * 
	 * @author Vicente Zarga
	 * @date 27/01/2014
	 */
	public void encerrarContratoDemandaConsumo(String referencia) throws ControladorException{

		try{
			repositorioFaturamento.encerrarContratoDemandaConsumo(referencia);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}


	/**
	 * Atauliza a tabela de consumo_historico com o consumo médio correto
	 * 
	 * @author Anderson Italo
	 * @date 10/02/2014
	 */
	public void executarAjusteErroCalculoConsumoMedioPercentualColeta(Collection<Integer> colecaoReferenciasAjuste)
					throws ControladorException{

		try{

			log.info("-----------Início ajuste atualiza consumo histórico consumo médio errado: ----------------");

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteErroCalculoConsumoMedioPercentualColeta(colecaoReferenciasAjuste);

			log.info("-----------Fim ajuste ajuste atualiza consumo histórico consumo médio errado: ----------------");

		}catch(Exception e){

			log.info("-----------Erro ajuste atualiza consumo histórico consumo médio errado: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}
	/**
	 * Obter o endereço de entrega do cliente com detalhamentos
	 * 
	 * @author Hebert Falcão
	 * @date 02/02/2014
	 */
	public Object[] obterEnderecoEntregaClienteComDetalhamento(Imovel imovel) throws ControladorException{

		// Caso a coleção de contas seja de entrega para o cliente pesquisando os dados pelo id do
		// imovel, carregando até o cliente

		String enderecoClienteResponsavel = "";
		Integer idLogradouro = null;
		String numeroImovel = null;
		String bairroEntrega = "";
		String cepEntrega = "";
		String municipioEntrega = "";
		String ufEntrega = "";
		String complementoEndereco = "";

		Object[] retorno = new Object[8];

		FiltroImovel filtroImovel = new FiltroImovel();
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("imovelContaEnvio");
		filtroImovel.adicionarCaminhoParaCarregamentoEntidade("clienteImoveis");
		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
		Collection<Imovel> imoveis = getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
		Integer imovelContaEnvioId = imoveis.iterator().next().getImovelContaEnvio().getId();
		Imovel imovelPesquisado = imoveis.iterator().next();

		Integer tipoRelacao = 0;
		if(imovelContaEnvioId.intValue() == ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL
						|| imovelContaEnvioId.intValue() == ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL
						|| imovelContaEnvioId.intValue() == ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_PAGAVEL_PARA_RESPONSAVEL
						|| imovelContaEnvioId.intValue() == ImovelContaEnvio.PAGAVEL_PARA_IMOVEL_E_NAO_PAGAVEL_PARA_RESPOSAVEL){
			tipoRelacao = ClienteRelacaoTipo.RESPONSAVEL;
		}else if(imovelContaEnvioId.intValue() == ImovelContaEnvio.ENVIAR_PARA_CLIENTE_PROPRIETARIO){
			tipoRelacao = ClienteRelacaoTipo.PROPRIETARIO;
		}else{
			tipoRelacao = ClienteRelacaoTipo.USUARIO;
		}
		for(ClienteImovel clienteImovel : imovelPesquisado.getClienteImoveis()){
			Cliente cliente = clienteImovel.getCliente();
			FiltroCliente filtroCliente = new FiltroCliente();
			filtroCliente.adicionarCaminhoParaCarregamentoEntidade(FiltroCliente.CLIENTE_ENDERECOS);
			filtroCliente.adicionarParametro(new ParametroSimples(FiltroCliente.ID, cliente.getId()));
			Collection<Cliente> clientes = getControladorUtil().pesquisar(filtroCliente, Cliente.class.getName());
			cliente = clientes.iterator().next();
			clienteImovel.setCliente(cliente);
		}
		Integer idCliente = null;
		Collection<ClienteImovel> clientesImoveis = imovelPesquisado.getClienteImoveis();
		Date dataAtual = new Date();
		for(ClienteImovel clienteImovel : clientesImoveis){
			if((clienteImovel.getDataFimRelacao() == null || Util.compararData(clienteImovel.getDataFimRelacao(), dataAtual) == -1)
							&& clienteImovel.getClienteRelacaoTipo().getId().intValue() == tipoRelacao.intValue()){

				Collection<ClienteEndereco> clienteEnderecos = clienteImovel.getCliente().getClienteEnderecos();
				for(ClienteEndereco clienteEndereco : clienteEnderecos){
					if(clienteEndereco.getIndicadorEnderecoCorrespondencia().intValue() == ClienteEndereco.INDICADOR_ENDERECO_CORRESPONDENCIA){
						idCliente = clienteEndereco.getCliente().getId();

						// [UC0085]Obter Endereco
						Object[] arrayDadosEndereco = this.getControladorEndereco().pesquisarEnderecoClienteAbreviadoListaComDetalhamento(
										idCliente, false);

						enderecoClienteResponsavel = (String) arrayDadosEndereco[0];
						idLogradouro = (Integer) arrayDadosEndereco[1];
						numeroImovel = (String) arrayDadosEndereco[2];
						bairroEntrega = (String) arrayDadosEndereco[3];
						cepEntrega = (String) arrayDadosEndereco[4];
						municipioEntrega = (String) arrayDadosEndereco[5];
						ufEntrega = (String) arrayDadosEndereco[6];
						complementoEndereco = (String) arrayDadosEndereco[7];

						break;
					}
				}
			}
		}

		retorno[0] = enderecoClienteResponsavel;
		retorno[1] = idLogradouro;
		retorno[2] = numeroImovel;
		retorno[3] = bairroEntrega;
		retorno[4] = cepEntrega;
		retorno[5] = municipioEntrega;
		retorno[6] = ufEntrega;
		retorno[7] = complementoEndereco;

		return retorno;
	}

	/**
	 * Remover Mensagem da Conta
	 * 
	 * @author Hebert Falcão
	 * @created 14/03/2014
	 */
	public void removerMensagemConta(String[] ids, Usuario usuarioLogado) throws ControladorException{

		for(int i = 0; i < ids.length; i++){
			FiltroContaMensagem filtroContaMensagem = new FiltroContaMensagem();
			filtroContaMensagem.adicionarParametro(new ParametroSimples(FiltroContaMensagem.ID, new Integer(ids[i])));

			Collection<ContaMensagem> colecaoContaMensagem = this.getControladorUtil().pesquisar(filtroContaMensagem,
							ContaMensagem.class.getName());

			ContaMensagem contaMensagem = (ContaMensagem) Util.retonarObjetoDeColecao(colecaoContaMensagem);

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorContaMensagem = new RegistradorOperacao(Operacao.OPERACAO_CONTA_MENSAGEM_REMOVER,
							contaMensagem.getId(), contaMensagem.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
											UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_CONTA_MENSAGEM_REMOVER);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			contaMensagem.setOperacaoEfetuada(operacaoEfetuada);

			registradorContaMensagem.registrarOperacao(contaMensagem);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			contaMensagem.setIndicadorUso(ConstantesSistema.INDICADOR_USO_DESATIVO);

			this.getControladorUtil().atualizar(contaMensagem);
		}
	}

	/**
	 * [XYZ] Gerar Relatório Situação Especial de Faturamento
	 * 
	 * @author Hebert Falcão
	 * @date 16/03/2014
	 */
	public Collection<FaturamentoSituacaoHistorico> consultarSituacaoEspecialDeFaturamento(RelatorioSituacaoEspecialFaturamentoHelper helper)
					throws ControladorException{

		try{
			return repositorioFaturamento.consultarSituacaoEspecialDeFaturamento(helper);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [XYZ] Gerar Relatório Situação Especial de Faturamento
	 * 
	 * @author Hebert Falcão
	 * @date 16/03/2014
	 */
	public Integer consultarSituacaoEspecialDeFaturamentoCount(RelatorioSituacaoEspecialFaturamentoHelper helper)
					throws ControladorException{

		try{
			return repositorioFaturamento.consultarSituacaoEspecialDeFaturamentoCount(helper);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * @param colecao
	 * @throws ControladorException
	 */

	public void executarRegeracaoHistograma(Integer anoMesRefInicial, Integer anoMesRefFinal) throws ControladorException{

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarRegeracaoHistograma(anoMesRefInicial, anoMesRefFinal);

		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * @param colecao
	 * @throws ControladorException
	 */

	public void gerarDebitoACobrarContaComValorAMenor(Integer referencia, String idsGrupos) throws ControladorException{

		try{

			AjusteContabilidadeDeso ajusteContabilidadeDeso = new AjusteContabilidadeDeso();
			ajusteContabilidadeDeso.gerarDebitoACobrarContaComValorAMenor(referencia, idsGrupos);

		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * Pesquisa count dos dados necessário para a geração do relatório
	 * [UC0638] - Gerar Relatórios Anormalidade Consumo
	 * 
	 * @author Ado Rocha
	 * @created 27/03/2014
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Integer pesquisarDadosRelatorioAnormalidadeConsumoCount(Integer idGrupoFaturamento, Short codigoRota,
					Integer idGerenciaRegional, Integer idUnidadeNegocio, Integer idElo, Integer idLocalidadeInicial,
					Integer idLocalidadeFinal, Integer referencia, Integer idImovelPerfil, Integer numOcorConsecutivas,
					String indicadorOcorrenciasIguais, Integer mediaConsumoInicial, Integer mediaConsumoFinal,
					Integer idAnormalidadeConsumo, Integer idAnormalidadeLeitura) throws ControladorException{

		Integer retorno = null;

		try{
			retorno = repositorioFaturamento.pesquisarDadosRelatorioAnormalidadeConsumoCount(idGrupoFaturamento, codigoRota,
							idGerenciaRegional, idUnidadeNegocio, idElo, idLocalidadeInicial, idLocalidadeFinal, referencia,
							idImovelPerfil, numOcorConsecutivas, indicadorOcorrenciasIguais, mediaConsumoInicial, mediaConsumoFinal,
							idAnormalidadeConsumo, idAnormalidadeLeitura);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}
	
	/**
	 * [UC0146] Manter Conta
	 * [FS0039] - Verifica existência de débito prescrito
	 * 
	 * @author Anderson Italo
	 * @date 28/03/2014
	 */
	public void verificarContaPrescrita(Usuario usuario, Collection<Conta> colecaoConta) throws ControladorException{

		boolean temPermissaoEmitirDocumentoPagavelPrescrito = getControladorPermissaoEspecial()
						.verificarPermissaoEmitirDocumentoPagavelDebitoPrescrito(usuario);

		if(!Util.isVazioOrNulo(colecaoConta)){

			for(Conta conta : colecaoConta){

				if(!temPermissaoEmitirDocumentoPagavelPrescrito
								&& conta.getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.PRESCRITA)){

					throw new ControladorException("atencao.conta_prescrita", null);
				}
			}
		}
	}

	/**
	 * [UC0203] Consultar Débitos
	 * [FS0013 - Verifica existência de débito prescrito]
	 * 
	 * @author Anderson Italo
	 * @date 29/03/2014
	 */
	public void verificarExistenciaDebitoPrescrito(Usuario usuario, Collection<ContaValoresHelper> colecaoContaValoresHelper,
					Collection<GuiaPagamentoValoresHelper> colecaoGuiaValoresHelper) throws ControladorException{

		boolean temPermissaoEmitirDocumentoPagavelPrescrito = getControladorPermissaoEspecial()
						.verificarPermissaoEmitirDocumentoPagavelDebitoPrescrito(usuario);

		if(!Util.isVazioOrNulo(colecaoContaValoresHelper)){

			for(ContaValoresHelper contaHelper : colecaoContaValoresHelper){

				if(!temPermissaoEmitirDocumentoPagavelPrescrito
								&& contaHelper.getConta().getDebitoCreditoSituacaoAtual().getId().equals(DebitoCreditoSituacao.PRESCRITA)){

					throw new ControladorException("atencao.extrato_conta_ou_guia_prescrita", null);
				}
			}
		}

		if(!Util.isVazioOrNulo(colecaoGuiaValoresHelper)){

			for(GuiaPagamentoValoresHelper guia : colecaoGuiaValoresHelper){

				if(!temPermissaoEmitirDocumentoPagavelPrescrito
								&& guia.getIdDebitoCreditoSituacaoAtual().equals(DebitoCreditoSituacao.PRESCRITA)){

					throw new ControladorException("atencao.extrato_conta_ou_guia_prescrita", null);
				}
			}
		}
	}

	/**
	 * [UC0188] Manter Guia de Pagamento
	 * [SB0010] - Verificar Guia de Pagamento Prescrita
	 * 
	 * @author Anderson Italo
	 * @date 25/03/2014
	 */
	public void verificarGuiaPagamentoPrescrita(Usuario usuario,
					Collection<GuiaPagamentoPrestacaoHelper> colecaoGuiaPagamentoPrestacaoHelper) throws ControladorException{

		DebitoCreditoSituacao debitoCreditoSituacaoPrescrita = (DebitoCreditoSituacao) getControladorUtil().pesquisar(
						DebitoCreditoSituacao.PRESCRITA, DebitoCreditoSituacao.class, false);

		boolean temPermissaoEmitirDocumentoPagavelPrescrito = getControladorPermissaoEspecial()
						.verificarPermissaoEmitirDocumentoPagavelDebitoPrescrito(usuario);

		for(GuiaPagamentoPrestacaoHelper guiaPagamentoPrestacaoHelper : colecaoGuiaPagamentoPrestacaoHelper){

			if(!temPermissaoEmitirDocumentoPagavelPrescrito
							&& guiaPagamentoPrestacaoHelper.getDescricaoDebitoCreditoSituacao().equals(
											debitoCreditoSituacaoPrescrita.getDescricaoAbreviada())){

				throw new ControladorException("atencao.guia_prestacao_prescrita", null, usuario.getNomeUsuario(),
								debitoCreditoSituacaoPrescrita.getDescricaoDebitoCreditoSituacao());
			}
		}
	}

	/**
	 * * [UC0482]Emitir 2ª Via de Conta
	 * 
	 * @author Carlos Chrystian
	 * @date 05/06/2014
	 */
	public BigDecimal calcularImposto2ViaConta(BigDecimal valorAgua, BigDecimal valorEsgoto) throws ControladorException{

		BigDecimal baseCalculo = BigDecimal.ZERO;
		BigDecimal percetagemAliquota_COFINS = BigDecimal.ZERO;
		BigDecimal percetagemAliquota_PIS_PASEP = BigDecimal.ZERO;
		BigDecimal percetagemTotalAliquota = BigDecimal.ZERO;
		BigDecimal valorImpostoTotal = BigDecimal.ZERO;

		// Determina a base de calculo do imposto
		// valor de água + valor de esgoto
		baseCalculo = valorAgua.add(valorEsgoto);
		baseCalculo = baseCalculo.setScale(2, BigDecimal.ROUND_DOWN);

		// recupera alíquota do imposto COFINS
		String parametroAliquotaImpostoCOFINS = ParametroFaturamento.P_ALIQUOTA_IMPOSTO_COFINS.executar();
		percetagemAliquota_COFINS = Util.formatarMoedaRealparaBigDecimal(parametroAliquotaImpostoCOFINS);

		// recupera alíquota do imposto PIS_PASEP
		String parametroAliquotaImpostoPIS_PASEP = ParametroFaturamento.P_ALIQUOTA_IMPOSTO_PIS_PASEP.executar();
		percetagemAliquota_PIS_PASEP = Util.formatarMoedaRealparaBigDecimal(parametroAliquotaImpostoPIS_PASEP);

		// Obtém o percentual total das alíquotas
		percetagemTotalAliquota = percetagemAliquota_COFINS.add(percetagemAliquota_PIS_PASEP);

		percetagemTotalAliquota = Util.dividirArredondando(percetagemTotalAliquota, new BigDecimal("100.00"));

		// Valor do imposto total sobre a base de cálculo
		valorImpostoTotal = percetagemTotalAliquota.multiply(baseCalculo);
		valorImpostoTotal = valorImpostoTotal.setScale(2, BigDecimal.ROUND_HALF_DOWN);

		// return valor total dos impostos e lista dos impostos deduzidos;
		return valorImpostoTotal;
	}

	/**
	 * OC1307375 - Criado rotina de ajuste para testar alteração no calcular valores de água e
	 * esgoto cascata
	 * 
	 * @author Anderson Italo
	 * @date 03/07/2014
	 **/
	public void executarAjusteVerificarBatimentoCalculoValorConta(Integer anoMesReferencia) throws ControladorException{

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteVerificarBatimentoCalculoValorConta(anoMesReferencia);

		}catch(Exception e){

			log.info("-----------Erro executarAjusteVerificarBatimentoCalculoValorConta: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * @author Yara Souza
	 * @date 29/07/2014
	 **/
	public void executarAjusteClienteDebitoACobrar() throws ControladorException{

		try{

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteClienteDebitoACobrar();

		}catch(Exception e){

			log.info("-----------Erro executarAjusteClienteDebitoACobrar: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * @param creditoARealizar
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarClienteCreditoARealizar(CreditoARealizar creditoARealizar) throws ControladorException{

		Collection retorno = null;

		try{
			retorno = repositorioFaturamento.pesquisarClienteCreditoARealizar(creditoARealizar);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * @param debitoACobrar
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarClienteDebitoACobrar(DebitoACobrar debitoACobrar) throws ControladorException{

		Collection retorno = null;

		try{
			retorno = repositorioFaturamento.pesquisarClienteDebitoACobrar(debitoACobrar);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * @param debitoACobrarHistorico
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarClienteDebitoACobrarHistorico(DebitoACobrarHistorico debitoACobrarHistorico) throws ControladorException{

		Collection retorno = null;

		try{
			retorno = repositorioFaturamento.pesquisarClienteDebitoACobrarHistorico(debitoACobrarHistorico);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC3156] Simular Cálculo da Conta Dados Reais
	 * 
	 * @author Anderson Italo
	 * @date 22/09/2014
	 */
	public Collection pesquisarContasSimularCalculoDadosReais(FiltroContaSimularCalculoHelper helper, Integer numeroPagina)
					throws ControladorException{

		Collection retorno = null;

		try{

			retorno = repositorioFaturamento.pesquisarContasSimularCalculoDadosReais(helper, numeroPagina);
		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * /**
	 * [UC3156] Simular Cálculo da Conta Dados Reais
	 * 
	 * @author Anderson Italo
	 * @date 22/09/2014
	 */
	public Integer pesquisarTotalRegistrosContasSimularCalculoDadosReais(FiltroContaSimularCalculoHelper helper)
					throws ControladorException{

		Integer retorno = null;

		try{

			retorno = repositorioFaturamento.pesquisarTotalRegistrosContasSimularCalculoDadosReais(helper);
		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	public void executarAjusteConversaoAcordoTac() throws ControladorException{

		try{

			log.info("-----------Início executarAjusteConversaoAcordoTac: ----------------");

			AjusteFaturamentoDeso ajusteFaturamentoDeso = new AjusteFaturamentoDeso();
			ajusteFaturamentoDeso.executarAjusteConversaoAcordoTac();

			log.info("-----------Fim executarAjusteConversaoAcordoTac: ----------------");

		}catch(Exception e){

			log.info("-----------Erro executarAjusteConversaoAcordoTac: ----------------");
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC0187] Inserir Guia de Pagamento
	 * Processos das execuções especiais pendentes de cobrança do valor de sucumbência
	 */
	public Collection<Integer> pesquisarProcessosExecucaoEspeciaisPendentesCobrancaPorCliente(Integer idCliente)
					throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarProcessosExecucaoEspeciaisPendentesCobrancaPorCliente(idCliente,
							CobrancaSituacao.EXECUCAO_FISCAL, DebitoTipo.SUCUMBENCIA);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	public void criarTabelaTemporariaRelatorioTotalContasEmitidasLocalidade() throws ErroRepositorioException{

		try{
			repositorioFaturamento.criarTabelaTemporariaRelatorioTotalContasEmitidasLocalidade();
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	public void inserirRegistrosTabelaTemporariaRelatorioTotalContasEmitidasLocalidade(Integer anoMesReferencia)
					throws ErroRepositorioException{

		try{
			repositorioFaturamento.inserirRegistrosTabelaTemporariaRelatorioTotalContasEmitidasLocalidade(anoMesReferencia);
		}catch(Exception e){
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	public List<Object[]> gerarRelatorioTotalContasEmitidasLocalidade(Integer anoMesReferencia) throws ControladorException{

		try{
			return repositorioFaturamento.gerarRelatorioTotalContasEmitidasLocalidade(anoMesReferencia);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			throw new ControladorException(e.getMessage());

		}

	}

	public Long gerarQuantidadeRelatorioTotalContasEmitidasLocalidade(Integer anoMesReferencia) throws ControladorException{

		try{
			return repositorioFaturamento.gerarQuantidadeRelatorioTotalContasEmitidasLocalidade(anoMesReferencia);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			throw new ControladorException(e.getMessage());

		}
	}

	/**
	 * @param idGuia
	 * @return
	 * @throws ControladorException
	 */

	public BigDecimal pesquisarValorPrestacoesGuiaPagamento(Integer idGuia) throws ControladorException{

		BigDecimal valorTotalGuiaPagamentoPrestacao = BigDecimal.ZERO;

		try{
			Collection<Object[]> colecao = repositorioFaturamento.pesquisarValorPrestacoesGuiaPagamento(idGuia);

			Iterator it = colecao.iterator();
			while(it.hasNext()){

				Object[] arrayValorGuiaPagamentoPrestacao = (Object[]) it.next();
				
				valorTotalGuiaPagamentoPrestacao = valorTotalGuiaPagamentoPrestacao.add((BigDecimal) arrayValorGuiaPagamentoPrestacao[1]);
				

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return valorTotalGuiaPagamentoPrestacao;
	}
	/**
	 * @param colecao
	 * @throws ControladorException
	 */

	public void gerarCreditoARealizarAjuste(Integer referencia, String idsGrupos) throws ControladorException{

		try{

			AjusteContabilidadeDeso ajusteContabilidadeDeso = new AjusteContabilidadeDeso();
			ajusteContabilidadeDeso.gerarCreditoARealizarAjuste(referencia, idsGrupos);

		}catch(Exception e){

			e.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new EJBException(e);
		}
	}

	/**
	 * [UC3165] Gerar Relatório Posição do Débito da Negativação - Legado CAGEPA
	 * Pesquisar as contas em processo de negativação e já transferidas para o histórico
	 * 
	 * @date 07/03/2015
	 * @author Luciano Galvão
	 */
	public Collection pesquisarContaEmProcessoNegativacaoCagepa(Integer anoMesFaturamento) throws ControladorException{

		try{
			return repositorioFaturamento.pesquisarContaEmProcessoNegativacaoCagepa(anoMesFaturamento);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * <p>
	 * OC1434185 Fatura PDF
	 * </p>
	 * 
	 * @author Magno Gouveia
	 * @date 10/03/2015
	 * @throws ControladorException
	 */
	private void obterFaturasEmAtrasoModelo3(Integer anoMesReferencia, RelatorioBean beanObject, EmitirContaTipo2Helper helper)
					throws ControladorException{

		int anoAux = 0;
		int anoCorrente = 0;
		String strAnosComDebitos = " ";

		if(beanObject instanceof RelatorioContaModelo3Bean){
			RelatorioContaModelo3Bean bean = (RelatorioContaModelo3Bean) beanObject;

			String anoMesReferenciaInicial = "000101";
			String anoMesReferenciaFinal = String.valueOf(Util.subtrairAnoAnoMesReferencia(anoMesReferencia, 1));

			Integer parametroQuantidadeDiasVencimentoContaAvisoCorte = Integer
							.parseInt(ParametroCobranca.P_QUANTIDADE_DIAS_VENCIMENTO_CONTA_AVISO_CORTE.executar());

			Date dataVencimentoInicial = Util.converteStringParaDate("01/01/0001", false);
			Date dataVencimentoFinal = Util.subtrairNumeroDiasDeUmaData(new Date(), parametroQuantidadeDiasVencimentoContaAvisoCorte);

			ObterDebitoImovelOuClienteHelper debitoImovelOuClienteHelper = getControladorCobranca().obterDebitoImovelContas(1,
							helper.getIdImovel().toString(), anoMesReferenciaInicial, anoMesReferenciaFinal, dataVencimentoInicial,
							dataVencimentoFinal);

			if(!Util.isVazioOrNulo(debitoImovelOuClienteHelper.getColecaoContasValores())){

				List<ContaValoresHelper> colecaoContaValores = new ArrayList<ContaValoresHelper>();
				colecaoContaValores.addAll(debitoImovelOuClienteHelper.getColecaoContasValores());
				List sortFields = new ArrayList();

				sortFields.add(new BeanComparator("conta.referencia"));

				ComparatorChain multiSort = new ComparatorChain(sortFields);
				Collections.sort((List) colecaoContaValores, multiSort);
				// Collections.reverse(colecaoContaValores);

				for(ContaValoresHelper contaValorHelper : colecaoContaValores){
					anoCorrente = Util.obterAno(contaValorHelper.getConta().getReferencia());

					if(anoCorrente != anoAux){
						strAnosComDebitos += anoCorrente + ", ";
					}

					anoAux = Util.obterAno(contaValorHelper.getConta().getReferencia());
				}

				strAnosComDebitos = strAnosComDebitos.substring(0, strAnosComDebitos.length() - 2);

				bean.setFaturaAtrasoReferencia1(strAnosComDebitos);
			}

		}else{
			RelatorioContaModelo2Bean bean = (RelatorioContaModelo2Bean) beanObject;

			BigDecimal somaValorOutrasFaturas = BigDecimal.ZERO;
			BigDecimal somaValorFaturas = BigDecimal.ZERO;
			String anoMesReferenciaInicial = "000101";
			String anoMesReferenciaFinal = String.valueOf(Util.subtrairMesDoAnoMes(anoMesReferencia, 1));
			int contador = 0;

			Integer parametroQuantidadeDiasVencimentoContaAvisoCorte = Integer
							.parseInt(ParametroCobranca.P_QUANTIDADE_DIAS_VENCIMENTO_CONTA_AVISO_CORTE.executar());

			Date dataVencimentoInicial = Util.converteStringParaDate("01/01/0001", false);
			Date dataVencimentoFinal = Util.subtrairNumeroDiasDeUmaData(new Date(), parametroQuantidadeDiasVencimentoContaAvisoCorte);

			ObterDebitoImovelOuClienteHelper debitoImovelOuClienteHelper = getControladorCobranca().obterDebitoImovelContas(1,
							helper.getIdImovel().toString(), anoMesReferenciaInicial, anoMesReferenciaFinal, dataVencimentoInicial,
							dataVencimentoFinal);

			if(!Util.isVazioOrNulo(debitoImovelOuClienteHelper.getColecaoContasValores())){

				List<ContaValoresHelper> colecaoContaValores = new ArrayList<ContaValoresHelper>();
				colecaoContaValores.addAll(debitoImovelOuClienteHelper.getColecaoContasValores());
				List sortFields = new ArrayList();

				sortFields.add(new BeanComparator("conta.referencia"));

				ComparatorChain multiSort = new ComparatorChain(sortFields);
				Collections.sort((List) colecaoContaValores, multiSort);
				Collections.reverse(colecaoContaValores);

				for(ContaValoresHelper contaValorHelper : colecaoContaValores){

					contador++;

					if(contador <= 12){

						Util.executarMetodo(bean, "setFaturaAtrasoReferencia" + contador,
										Util.retornaDescricaoAnoMes4Digitos(String.valueOf(contaValorHelper.getConta().getReferencia())));
						Util.executarMetodo(bean, "setFaturaAtrasoValor" + contador,
										Util.formatarMoedaReal(contaValorHelper.getConta().getValorTotalContaBigDecimal(), 2));
					}else{

						somaValorOutrasFaturas = somaValorOutrasFaturas.add(contaValorHelper.getConta().getValorTotalContaBigDecimal());
					}

					somaValorFaturas = somaValorFaturas.add(contaValorHelper.getConta().getValorTotalContaBigDecimal());
				}
			}
		}
	}

	/**
	 * @author Magno Silveira <magno.silveira@procenge.com.br>
	 * @since 16/04/2015
	 * @param idImovel
	 * @param paramMotivoRetificaoOcorrenciaConsumo
	 * @return
	 */
	public int obterQtdContasRetificadasPorMotivoRetificacao(Integer idImovel, Integer paramMotivoRetificaoOcorrenciaConsumo)
					throws ControladorException{

		int qtdContasRetificadasPorMotivoRetificacao = 0;

		try{
			qtdContasRetificadasPorMotivoRetificacao = repositorioFaturamento.obterQtdContasRetificadasPorMotivoRetificacao(idImovel,
							paramMotivoRetificaoOcorrenciaConsumo);
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			throw new ControladorException(e.getMessage());
		}

		return qtdContasRetificadasPorMotivoRetificacao;
	}
}
