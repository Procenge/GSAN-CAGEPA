/*
] * Copyright (C) 2007-2007 the GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 *
 * This file is part of GSAN, an integrated service management system for Sanitation
 *
 * GSAN is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * GSAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place – Suite 330, Boston, MA 02111-1307, USA
 */

/*
 * GSAN – Sistema Integrado de Gestão de Serviços de Saneamento
 * Copyright (C) <2007> 
 * Adriano Britto Siqueira
 * Alexandre Santos Cabral
 * Ana Carolina Alves Breda
 * Ana Maria Andrade Cavalcante
 * Aryed Lins de Araújo
 * Bruno Leonardo Rodrigues Barros
 * Carlos Elmano Rodrigues Ferreira
 * Cláudio de Andrade Lira
 * Denys Guimarães Guenes Tavares
 * Eduardo Breckenfeld da Rosa Borges
 * Fabíola Gomes de Araújo
 * Flávio Leonardo Cavalcanti Cordeiro
 * Francisco do Nascimento Júnior
 * Homero Sampaio Cavalcanti
 * Ivan Sérgio da Silva Júnior
 * José Edmar de Siqueira
 * José Thiago Tenório Lopes
 * Kássia Regina Silvestre de Albuquerque
 * Leonardo Luiz Vieira da Silva
 * Márcio Roberto Batista da Silva
 * Maria de Fátima Sampaio Leite
 * Micaela Maria Coelho de Araújo
 * Nelson Mendonça de Carvalho
 * Newton Morais e Silva
 * Pedro Alexandre Santos da Silva Filho
 * Rafael Corrêa Lima e Silva
 * Rafael Francisco Pinto
 * Rafael Koury Monteiro
 * Rafael Palermo de Araújo
 * Raphael Veras Rossiter
 * Roberto Sobreira Barbalho
 * Rodrigo Avellar Silveira
 * Rosana Carvalho Barbosa
 * Sávio Luiz de Andrade Cavalcante
 * Tai Mu Shih
 * Thiago Augusto Souza do Nascimento
 * Tiago Moreno Rodrigues
 * Vivianne Barbosa Sousa
 * 
 * GSANPCG
 * Eduardo Henrique Bandeira Carneiro da Silva
 * Saulo Vasconcelos de Lima
 * Virginia Santos de Melo
 *
 * Este programa é software livre; você pode redistribuí-lo e/ou
 * modificá-lo sob os termos de Licença Pública Geral GNU, conforme
 * publicada pela Free Software Foundation; versão 2 da
 * Licença.
 * Este programa é distribuído na expectativa de ser útil, mas SEM
 * QUALQUER GARANTIA; sem mesmo a garantia implícita de
 * COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM
 * PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais
 * detalhes.
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU
 * junto com este programa; se não, escreva para Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307, USA.
 */

package gcom.micromedicao;

import gcom.arrecadacao.ContratoDemandaConsumo;
import gcom.arrecadacao.bean.OperacaoContabilHelper;
import gcom.atendimentopublico.ligacaoagua.*;
import gcom.atendimentopublico.ligacaoesgoto.*;
import gcom.atendimentopublico.ordemservico.FiltroServicoTipo;
import gcom.atendimentopublico.ordemservico.ServicoTipo;
import gcom.atendimentopublico.ordemservico.bean.LeituraConsumoHelper;
import gcom.atendimentopublico.registroatendimento.ControladorRegistroAtendimentoLocal;
import gcom.atendimentopublico.registroatendimento.ControladorRegistroAtendimentoLocalHome;
import gcom.atendimentopublico.registroatendimento.bean.ObterIndicadorExistenciaHidrometroHelper;
import gcom.batch.*;
import gcom.cadastro.ControladorCadastroLocal;
import gcom.cadastro.ControladorCadastroLocalHome;
import gcom.cadastro.EnvioEmail;
import gcom.cadastro.aguaparatodos.ImovelAguaParaTodos;
import gcom.cadastro.cliente.*;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.endereco.*;
import gcom.cadastro.funcionario.FiltroFuncionario;
import gcom.cadastro.funcionario.Funcionario;
import gcom.cadastro.funcionario.IRepositorioFuncionario;
import gcom.cadastro.funcionario.RepositorioFuncionarioHBM;
import gcom.cadastro.geografico.Bairro;
import gcom.cadastro.geografico.FiltroMunicipio;
import gcom.cadastro.geografico.Municipio;
import gcom.cadastro.geografico.UnidadeFederacao;
import gcom.cadastro.imovel.*;
import gcom.cadastro.imovel.bean.*;
import gcom.cadastro.localidade.*;
import gcom.cadastro.sistemaparametro.FiltroSistemaParametro;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cobranca.CobrancaForma;
import gcom.cobranca.FiltroRotaAcaoCriterio;
import gcom.cobranca.RotaAcaoCriterio;
import gcom.cobranca.RotaAcaoCriterioPK;
import gcom.contabil.ControladorContabilLocal;
import gcom.contabil.ControladorContabilLocalHome;
import gcom.contabil.OperacaoContabil;
import gcom.fachada.Fachada;
import gcom.faturamento.*;
import gcom.faturamento.bean.CalcularValoresAguaEsgotoHelper;
import gcom.faturamento.consumofaixaareacategoria.ConsumoFaixaAreaCategoria;
import gcom.faturamento.consumotarifa.ConsumoTarifa;
import gcom.faturamento.consumotarifa.ConsumoTarifaVigencia;
import gcom.faturamento.credito.CreditoARealizar;
import gcom.faturamento.credito.CreditoRealizado;
import gcom.faturamento.credito.FiltroCreditoARealizar;
import gcom.faturamento.credito.FiltroCreditoRealizado;
import gcom.faturamento.debito.*;
import gcom.gerencial.cadastro.IRepositorioGerencialCadastro;
import gcom.gerencial.cadastro.RepositorioGerencialCadastroHBM;
import gcom.gerencial.cadastro.bean.ResumoLigacaoEconomiaHelper;
import gcom.gui.micromedicao.DadosMovimentacao;
import gcom.interceptor.RegistradorOperacao;
import gcom.micromedicao.bean.*;
import gcom.micromedicao.consumo.*;
import gcom.micromedicao.hidrometro.*;
import gcom.micromedicao.leitura.*;
import gcom.micromedicao.medicao.FiltroMedicaoHistorico;
import gcom.micromedicao.medicao.FiltroMedicaoHistoricoSql;
import gcom.micromedicao.medicao.MedicaoHistorico;
import gcom.micromedicao.medicao.MedicaoTipo;
import gcom.relatorio.ConstantesRelatorios;
import gcom.relatorio.GerenciadorExecucaoTarefaRelatorio;
import gcom.relatorio.faturamento.RelatorioDadosTabelasFaturamentoImediato;
import gcom.relatorio.faturamento.RelatorioOcorrenciaGeracaoPreFatResumo;
import gcom.relatorio.faturamento.RelatorioOcorrenciaGeracaoPreFatResumoHelper;
import gcom.relatorio.gerencial.micromedicao.RelatorioResumoAnormalidadesConsumo;
import gcom.relatorio.micromedicao.RelatorioComprovantesLeitura;
import gcom.relatorio.micromedicao.RelatorioGerarDadosParaleitura;
import gcom.relatorio.micromedicao.RelatorioRegistrarLeiturasAnormalidades;
import gcom.seguranca.acesso.*;
import gcom.seguranca.acesso.usuario.Usuario;
import gcom.seguranca.acesso.usuario.UsuarioAcao;
import gcom.seguranca.acesso.usuario.UsuarioAcaoUsuarioHelper;
import gcom.seguranca.transacao.ControladorTransacaoLocal;
import gcom.seguranca.transacao.ControladorTransacaoLocalHome;
import gcom.tarefa.TarefaRelatorio;
import gcom.util.*;
import gcom.util.email.ErroEmailException;
import gcom.util.email.ServicosEmail;
import gcom.util.filtro.*;
import gcom.util.parametrizacao.ExecutorParametro;
import gcom.util.parametrizacao.Parametrizacao;
import gcom.util.parametrizacao.faturamento.ParametroFaturamento;
import gcom.util.parametrizacao.micromedicao.*;

import java.io.*;
import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.Map.Entry;
import java.util.zip.ZipOutputStream;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;

import org.apache.log4j.Logger;

import br.com.procenge.comum.exception.NegocioException;
import br.com.procenge.util.Constantes;

/**
 * < <Descrição da Classe>>
 * 
 * @author Administrador
 * @created 13 de Setembro de 2005
 */
public class ControladorMicromedicao
				implements SessionBean, Parametrizacao {

	/**
	 * 
	 */
	private static final Logger LOGGER = Logger.getLogger(ControladorMicromedicao.class);

	private static final long serialVersionUID = 1L;

	protected IRepositorioHidrometro repositorioHidrometro = null;

	protected IRepositorioMicromedicao repositorioMicromedicao = null;

	protected IRepositorioFaturamento repositorioFaturamento = null;

	protected IRepositorioClienteImovel repositorioClienteImovel = null;

	protected IRepositorioUtil repositorioUtil = null;

	protected IRepositorioImovel repositorioImovel = null;

	protected IRepositorioFuncionario repositorioFuncionario = null;

	protected IRepositorioSetorComercial repositorioSetorComercial = null;

	protected IRepositorioGerencialCadastro repositorioGerencialCadastro = null;

	protected IRepositorioLigacaoAgua repositorioLigacaoAgua = null;

	protected IRepositorioLigacaoEsgoto repositorioLigacaoEsgoto = null;

	SessionContext sessionContext;

	private static Logger log = Logger.getLogger(ControladorMicromedicao.class);

	/**
	 * < <Descrição do método>>
	 * 
	 * @exception CreateException
	 *                Descrição da exceção
	 */
	public void ejbCreate() throws CreateException{

		repositorioUtil = RepositorioUtilHBM.getInstancia();
		repositorioHidrometro = RepositorioHidrometroHBM.getInstancia();
		repositorioMicromedicao = RepositorioMicromedicaoHBM.getInstancia();
		repositorioFaturamento = RepositorioFaturamentoHBM.getInstancia();
		repositorioClienteImovel = RepositorioClienteImovelHBM.getInstancia();
		repositorioImovel = RepositorioImovelHBM.getInstancia();
		// repositorioLeitura = RepositorioLeituraHBM.getInstancia();
		repositorioFuncionario = RepositorioFuncionarioHBM.getInstancia();
		repositorioSetorComercial = RepositorioSetorComercialHBM.getInstancia();
		repositorioGerencialCadastro = RepositorioGerencialCadastroHBM.getInstancia();
		repositorioLigacaoAgua = RepositorioLigacaoAguaHBM.getInstancia();
		repositorioLigacaoEsgoto = RepositorioLigacaoEsgotoHBM.getInstancia();
	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbRemove(){

	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbActivate(){

	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbPassivate(){

	}

	/**
	 * Seta o valor de sessionContext
	 * 
	 * @param sessionContext
	 *            O novo valor de sessionContext
	 */
	public void setSessionContext(SessionContext sessionContext){

		this.sessionContext = sessionContext;
	}

	/**
	 * Retorna o valor de controladorContabil
	 * 
	 * @return O valor de controladorContabil
	 */
	private ControladorContabilLocal getControladorContabil(){

		ControladorContabilLocalHome localHome = null;
		ControladorContabilLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorContabilLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_CONTABIL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorUtil
	 * 
	 * @return O valor de controladorUtil
	 */
	protected ControladorUtilLocal getControladorUtil(){

		ControladorUtilLocalHome localHome = null;
		ControladorUtilLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorUtilLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_UTIL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	protected ControladorCadastroLocal getControladorCadastro(){

		ControladorCadastroLocalHome localHome = null;
		ControladorCadastroLocal local = null;

		ServiceLocator locator = null;
		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorCadastroLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_CADASTRO_SEJB);

			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorAcesso
	 * 
	 * @return O valor de controladorAcesso
	 */
	protected ControladorAcessoLocal getControladorAcesso(){

		ControladorAcessoLocalHome localHome = null;
		ControladorAcessoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorAcessoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_ACESSO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	protected ControladorFaturamentoLocal getControladorFaturamento(){

		ControladorFaturamentoLocalHome localHome = null;
		ControladorFaturamentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorFaturamentoLocalHome) locator.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_FATURAMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorImovel
	 * 
	 * @return O valor de controladorImovel
	 */
	protected ControladorImovelLocal getControladorImovel(){

		ControladorImovelLocalHome localHome = null;
		ControladorImovelLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorImovelLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_IMOVEL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o valor de controladorEndereco
	 * 
	 * @return O valor de controladorEndereco
	 */
	protected ControladorEnderecoLocal getControladorEndereco(){

		ControladorEnderecoLocalHome localHome = null;
		ControladorEnderecoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorEnderecoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_ENDERECO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * @author isilva Retorna o valor de RegistroAtendimento
	 * @return O valor de RegistroAtendimento
	 */
	protected ControladorRegistroAtendimentoLocal getControladorRegistroAtendimento(){

		ControladorRegistroAtendimentoLocalHome localHome = null;
		ControladorRegistroAtendimentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorRegistroAtendimentoLocalHome) locator
							.getLocalHome(ConstantesJNDI.CONTROLADOR_REGISTRO_ATENDIMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	private ControladorTransacaoLocal getControladorTransacao(){

		ControladorTransacaoLocalHome localHome = null;
		ControladorTransacaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorTransacaoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_TRANSACAO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	private ControladorLigacaoAguaLocal getControladorLigacaoAgua(){

		ControladorLigacaoAguaLocalHome localHome = null;
		ControladorLigacaoAguaLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorLigacaoAguaLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_LIGACAO_AGUA_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	private ControladorLigacaoEsgotoLocal getControladorLigacaoEsgoto(){

		ControladorLigacaoEsgotoLocalHome localHome = null;
		ControladorLigacaoEsgotoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorLigacaoEsgotoLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_LIGACAO_ESGOTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * [UC3104] - Gerar Relatório de Consumidores para Leitura Convencional
	 * Preenche os indicadores de totalização no objeto GerarDadosParaLeituraHelper, utilizados no
	 * Relatório de Consumidores para Leitura Convencional (RelatorioGerarDadosParaLeitura)
	 * 
	 * @author Luciano Galvao
	 * @date 22/08/2013
	 */
	public void preencherTotalizadoresRelatorioGerarDadosParaLeitura(GerarDadosParaLeituraHelper gerarDadosParaLeituraHelper,
					Imovel imovel, Integer anoMesReferencia) throws ControladorException{

		if(gerarDadosParaLeituraHelper != null){

			Integer numeroUm = new Integer(1);
			Integer numeroZero = new Integer(0);

			// ==================================
			// TOTAL DE LIGAÇÕES ATIVAS
			// ==================================
			if(imovel != null && imovel.getLigacaoAguaSituacao() != null
							&& imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)){
				gerarDadosParaLeituraHelper.setIndicadorLigacaoAtiva(numeroUm);
			}else{
				gerarDadosParaLeituraHelper.setIndicadorLigacaoAtiva(numeroZero);
			}

			// ==================================
			// TOTAL DE LIGAÇÕES CORTADAS
			// ==================================
			if(imovel != null && imovel.getLigacaoAguaSituacao() != null
							&& imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO)){
				gerarDadosParaLeituraHelper.setIndicadorLigacaoCortada(numeroUm);
			}else{
				gerarDadosParaLeituraHelper.setIndicadorLigacaoCortada(numeroZero);
			}

			// ==================================
			// TOTAL DE LIGAÇÕES COM ESGOTO
			// ==================================
			if(imovel != null && imovel.getLigacaoEsgotoSituacao() != null
							&& imovel.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.LIGADO)){
				gerarDadosParaLeituraHelper.setIndicadorLigacaoComEsgoto(numeroUm);
				gerarDadosParaLeituraHelper.setIndicadorLigacaoSemEsgoto(numeroZero);
			}else{
				// ==================================
				// TOTAL DE LIGAÇÕES SEM ESGOTO
				// ==================================
				gerarDadosParaLeituraHelper.setIndicadorLigacaoComEsgoto(numeroZero);
				gerarDadosParaLeituraHelper.setIndicadorLigacaoSemEsgoto(numeroUm);
			}

			// ==================================
			// TOTAL DE LIGAÇÕES COM HIDRÔMETRO
			// ==================================
			if(gerarDadosParaLeituraHelper.getNumeroHidrometro() != null){

				gerarDadosParaLeituraHelper.setIndicadorLigacaoComHidrometro(numeroUm);
				gerarDadosParaLeituraHelper.setIndicadorLigacaoSemHidrometro(numeroZero);
			}else{
				// ==================================
				// TOTAL DE LIGAÇÕES SEM HIDRÔMETRO
				// ==================================
				gerarDadosParaLeituraHelper.setIndicadorLigacaoComHidrometro(numeroZero);
				gerarDadosParaLeituraHelper.setIndicadorLigacaoSemHidrometro(numeroUm);
			}


			// Faturamento convencional
			// Neste caso, os débitos cobrados e créditos realizados ainda não foram gerados. Vamos
			// pesquisar por débitos
			// a cobrar e créditos a realizar
			if(imovel != null
							&& imovel.getRota() != null
							&& imovel.getRota().getLeituraTipo() != null
							&& (imovel.getRota().getLeituraTipo().getId().equals(LeituraTipo.CONVENCIONAL)
											|| imovel.getRota().getLeituraTipo().getId().equals(LeituraTipo.CELULAR_MOBILE) || imovel
											.getRota().getLeituraTipo().getId().equals(LeituraTipo.MICROCOLETOR))){

				// Pesquisa os débitos a cobrar do imóvel para o mês de referência do faturamento
				FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
				filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, imovel.getId()));
				filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.REFERENCIA_COBRANCA_DEBITO,
								anoMesReferencia));
				Collection<DebitoACobrar> colecaoDebitosACobrar = (Collection<DebitoACobrar>) getControladorUtil().pesquisar(
								filtroDebitoACobrar, DebitoACobrar.class.getName());

				// ==================================
				// TOTAL DE LIGAÇÕES COM SERVIÇOS COBR. (Para faturamento convencional)
				// ==================================

				if(!Util.isVazioOrNulo(colecaoDebitosACobrar)){
					gerarDadosParaLeituraHelper.setIndicadorLigacaoComServicosCobrados(numeroUm);
				}else{
					gerarDadosParaLeituraHelper.setIndicadorLigacaoComServicosCobrados(numeroZero);
				}


				// Pesquisa os créditos a realizar do imóvel para o mês de referência do faturamento
				FiltroCreditoARealizar filtroCreditoARealizar = new FiltroCreditoARealizar();
				filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.IMOVEL_ID, imovel.getId()));
				filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ANO_MES_COBRANCA_CREDITO,
								anoMesReferencia));
				Collection<CreditoARealizar> colecaoCreditosARealizar = (Collection<CreditoARealizar>) getControladorUtil().pesquisar(
								filtroCreditoARealizar, CreditoARealizar.class.getName());

				// ==================================
				// TOTAL DE LIGAÇÕES COM DEVOLUÇÕES (Para faturamento convencional)
				// ==================================

				if(!Util.isVazioOrNulo(colecaoCreditosARealizar)){
					gerarDadosParaLeituraHelper.setIndicadorLigacaoComDevolucoes(numeroUm);
				}else{
					gerarDadosParaLeituraHelper.setIndicadorLigacaoComDevolucoes(numeroZero);
				}

			}else{
				// Faturamento imediato
				// Neste caso, os débitos cobrados e os créditos realizados já foram gerados

				// Pesquisa ps débitos cobrados do imóvel para o mês de referência do faturamento
				FiltroDebitoCobrado filtroDebitoCobrado = new FiltroDebitoCobrado();
				filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.CONTA_IMOVEL_ID, imovel.getId()));
				filtroDebitoCobrado.adicionarParametro(new ParametroSimples(FiltroDebitoCobrado.ANO_MES_COBRANCA_DEBITO, anoMesReferencia));
				Collection<DebitoCobrado> colecaoDebitosCobrados = (Collection<DebitoCobrado>) getControladorUtil().pesquisar(
								filtroDebitoCobrado, DebitoCobrado.class.getName());

				// ==================================
				// TOTAL DE LIGAÇÕES COM SERVIÇOS COBR. (Para faturamento imediato)
				// ==================================

				if(!Util.isVazioOrNulo(colecaoDebitosCobrados)){
					gerarDadosParaLeituraHelper.setIndicadorLigacaoComServicosCobrados(numeroUm);
				}else{
					gerarDadosParaLeituraHelper.setIndicadorLigacaoComServicosCobrados(numeroZero);
				}

				// Pesquisa os créditos realizados do imóvel para o mês de referência do faturamento
				FiltroCreditoRealizado filtroCreditoRealizado = new FiltroCreditoRealizado();
				filtroCreditoRealizado.adicionarParametro(new ParametroSimples(FiltroCreditoRealizado.CONTA_IMOVEL_ID, imovel.getId()));
				filtroCreditoRealizado.adicionarParametro(new ParametroSimples(FiltroCreditoRealizado.ANO_MES_COBRANCA_CREDITO,
								anoMesReferencia));
				Collection<CreditoRealizado> colecaoCreditosRealizados = (Collection<CreditoRealizado>) getControladorUtil().pesquisar(
								filtroCreditoRealizado, CreditoRealizado.class.getName());

				// ==================================
				// TOTAL DE LIGAÇÕES COM DEVOLUÇÕES (Para faturamento imediato)
				// ==================================

				if(!Util.isVazioOrNulo(colecaoCreditosRealizados)){
					gerarDadosParaLeituraHelper.setIndicadorLigacaoComDevolucoes(numeroUm);
				}else{
					gerarDadosParaLeituraHelper.setIndicadorLigacaoComDevolucoes(numeroZero);
				}
			}

			FiltroMovimentoRoteiroEmpresa filtroMovimentoRoteiroEmpresa = new FiltroMovimentoRoteiroEmpresa();
			filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.IMOVEL_ID, imovel.getId()));
			filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO,
							anoMesReferencia));
			filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.INDICADOR_EMISSAO,
							ConstantesSistema.SIM));
			Collection<MovimentoRoteiroEmpresa> colecaoMovimentos = (Collection<MovimentoRoteiroEmpresa>) getControladorUtil().pesquisar(
							filtroMovimentoRoteiroEmpresa, MovimentoRoteiroEmpresa.class.getName());

			// ==================================
			// TOTAL DE LIGAÇÕES PARA EMITIR CONTAS
			// ==================================
			// Possui movimentos com indicador de emissão ATIVO
			if(!Util.isVazioOrNulo(colecaoMovimentos)){
				gerarDadosParaLeituraHelper.setIndicadorLigacaoComEmissaoConta(numeroUm);
				gerarDadosParaLeituraHelper.setIndicadorLigacaoSemEmissaoConta(numeroZero);

			}else{
				// ==================================
				// TOTAL DE LIGAÇÕES SEM EMISSÃO DE CONTAS
				// ==================================
				gerarDadosParaLeituraHelper.setIndicadorLigacaoComEmissaoConta(numeroZero);
				gerarDadosParaLeituraHelper.setIndicadorLigacaoSemEmissaoConta(numeroUm);
			}
		}
	}

	/**
	 * [UC00083] Gerar Dados para Leitura Convencional(Relação de Leituras e Comprovantes em PDF)
	 * [SB0007] – Gera Relação Lista de Consumidores
	 * [SB0008] – Gera Comprovante de Leitura
	 * 
	 * @param imoveisParaSerGerados
	 * @return
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */

	public GerarDadosParaLeituraHelper montarGerarDadosParaLeituraHelper(Imovel imovelParaSerGerado, Integer anoMesCorrente, SistemaParametro sistemaParametro)
					throws ErroRepositorioException, ControladorException{

		GerarDadosParaLeituraHelper helper = new GerarDadosParaLeituraHelper();

		/***
		 * relatorio de comprovantes inicio
		 */

		helper.setAnoMesReferncia(Util.formatarAnoMesParaMesAno(anoMesCorrente));

		// matricula
		helper.setMatriculaImovel(Util.adicionarZerosEsquedaNumero(3, imovelParaSerGerado.getLocalidade().getId().toString()) + " - "
						+ imovelParaSerGerado.getId());

		helper.setMatricula(Util.retornaMatriculaImovelFormatadaParametrizada(imovelParaSerGerado.getId()));

		// leitura atual (INFORMADO PELO USUARIO)
		helper.setLeituraAtual("");

		// ocorrencia (INFORMADO PELO USUARIO)
		helper.setOcorrencia("");

		// confirmação (INFORMADO PELO USUARIO)
		helper.setConfirmacao("");

		// consumo informado (INFORMADO PELO USUARIO)
		helper.setConsumoInformado("");

		// localização
		helper.setInscricao(imovelParaSerGerado.getInscricaoFormatada());

		// consumo medio
		int mediaConsumo;
		int[] consumoMedioImovel = this.obterConsumoMedioImovel(imovelParaSerGerado, sistemaParametro);
		mediaConsumo = consumoMedioImovel[0];
		helper.setConsumoMedio(String.valueOf(mediaConsumo));

		ObterIndicadorExistenciaHidrometroHelper indicadorHidrometroAguaPoco = this.getControladorRegistroAtendimento()
						.obterIndicadorExistenciaHidrometroLigacaoAguaPoco(imovelParaSerGerado.getId(), false);

		Short hidrometroLigacaoAguaImovel = indicadorHidrometroAguaPoco.getIndicadorLigacaoAgua();
		Short hidrometroLigacaoPocoImovel = indicadorHidrometroAguaPoco.getIndicadorPoco();

		MedicaoTipo medicaoTipo = null;
		Hidrometro hidrometro = null;
		if((hidrometroLigacaoAguaImovel.equals(ConstantesSistema.SIM) && hidrometroLigacaoPocoImovel.equals(ConstantesSistema.SIM))
						|| hidrometroLigacaoAguaImovel.equals(ConstantesSistema.SIM)){

			Object dadosHidrometroNumeroLeitura[] = this.pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);
			helper.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);

			medicaoTipo = new MedicaoTipo();
			medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);

			hidrometro = imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro();

		}else if(hidrometroLigacaoPocoImovel.equals(ConstantesSistema.SIM)){

			Object dadosHidrometroNumeroLeitura[] = this.pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);
			helper.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);

			medicaoTipo = new MedicaoTipo();
			medicaoTipo.setId(MedicaoTipo.POCO);

			hidrometro = imovelParaSerGerado.getHidrometroInstalacaoHistorico().getHidrometro();
		}

		// usuario cliente
		Object[] dadosUsuario = repositorioMicromedicao.consultarDadosClienteImovelUsuario(imovelParaSerGerado);
		helper.setNomeClienteUsuario(dadosUsuario != null ? dadosUsuario[1].toString() : "");

		// endereço
		helper.setEnderecoImovel(getControladorEndereco().pesquisarEndereco(imovelParaSerGerado.getId()));

		// observação - responsavel e categorias concatenadas
		String categoriasConcatenadas = montarStringCategorias(imovelParaSerGerado);
		String responsavel = repositorioImovel.consultarClienteUsuarioImovel(imovelParaSerGerado.getId());
		helper.setObservacao("Resp. " + responsavel + " - " + categoriasConcatenadas);

		// responsavel
		helper.setResponsavel(responsavel);

		// categoria
		helper.setCategoria(getControladorImovel().obterDescricoesCategoriaImovel(imovelParaSerGerado).getDescricao());

		/***
		 * relatorio de comprovantes fim
		 */

		/***
		 * relatorio de roteiro inicio
		 */
		if(imovelParaSerGerado.getNumeroSequencialRota() != null){
			helper.setSequencialRota(imovelParaSerGerado.getNumeroSequencialRota().toString());
		}

		// elo, codigo localidade e descricao localidade
		if(imovelParaSerGerado.getLocalidade() != null){
			// elo
			if(imovelParaSerGerado.getLocalidade().getLocalidade() != null){
				helper.setElo(Util.adicionarZerosEsquedaNumero(3, imovelParaSerGerado.getLocalidade().getLocalidade().getId().toString()));
			}
			// id localidade
			helper.setCodigoLocalidade(Util.adicionarZerosEsquedaNumero(3, imovelParaSerGerado.getLocalidade().getId().toString()));
			// descricao localidade
			helper.setDescricaoLocalidade(imovelParaSerGerado.getLocalidade().getDescricao());
		}
		// setor
		if(imovelParaSerGerado.getSetorComercial() != null){
			helper.setCodigoSetor(String.valueOf(imovelParaSerGerado.getSetorComercial().getCodigo()));
		}

		// codigo da rota
		if(imovelParaSerGerado.getRota() != null){
			helper.setCodigoRota(Util.adicionarZerosEsquedaNumero(7, imovelParaSerGerado.getRota().getCodigo().toString()));
		}

		// codigo da grupo
		if(imovelParaSerGerado.getRota() != null && imovelParaSerGerado.getRota().getFaturamentoGrupo() != null){
			helper.setGrupo(Util.adicionarZerosEsquedaNumero(3, imovelParaSerGerado.getRota().getFaturamentoGrupo().getId().toString()));
		}

		// codigo da categoria
		// UC0064 - Obter quantidade de economias
		Collection colecaoSubCategoria = this.getControladorImovel().obterQuantidadeEconomiasSubCategoria(imovelParaSerGerado.getId());
		String descricaoCategoria = "";
		int quantidadeEconomia = 0;
		if(colecaoSubCategoria != null && !colecaoSubCategoria.isEmpty()){
			Iterator itera = colecaoSubCategoria.iterator();

			while(itera.hasNext()){
				Subcategoria subcategoria = (Subcategoria) itera.next();

				if(descricaoCategoria.equals("")){
					descricaoCategoria = subcategoria.getCategoria().getDescricao().substring(0, 1);
				}else if(descricaoCategoria != subcategoria.getCategoria().getDescricao().substring(0, 1)){
					descricaoCategoria = "M";
				}

				quantidadeEconomia = quantidadeEconomia + subcategoria.getQuantidadeEconomias();
			}
			helper.setCodigoCategoria(descricaoCategoria + Util.adicionarZerosEsquedaNumero(3, String.valueOf(quantidadeEconomia)));
		}

		// local instalação
		if(imovelParaSerGerado.getLigacaoAgua() != null && imovelParaSerGerado.getLigacaoAgua().getId() != null
						&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
						&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao() != null){

			helper.setLocalInstalacao(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico()
							.getHidrometroLocalInstalacao().getDescricaoAbreviada());
		}else if(imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null
						&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getHidrometro() != null
						&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao() != null){

			helper.setLocalInstalacao(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao()
							.getDescricaoAbreviada());
		}

		// data atual
		helper.setDataAtual(Util.formatarData(new Date()));

		// Caso o imóvel seja medido
		if(medicaoTipo != null){

			Object[] dadosLeituraAnterior = getControladorFaturamento().obterDadosLeituraAnterior(anoMesCorrente, medicaoTipo.getId(), imovelParaSerGerado);

			// <<Inclui>> [UC0086] Calcular Faixa de Leitura Esperada
			int[] faixaLeituraEsperada = this.calcularFaixaLeituraEsperada(mediaConsumo, null, hidrometro,
							(Integer) dadosLeituraAnterior[0]);
			helper.setFaixaLeitura(faixaLeituraEsperada[0] + " - " + faixaLeituraEsperada[1]);

			// data de leitura anterior
			helper.setDataLeituraAnterior(Util.formatarData((Date) dadosLeituraAnterior[1]));

			// leitura Anterior
			helper.setLeituraAnterior(dadosLeituraAnterior[0].toString());
		}

		// preenche os indicadores de totalização do relatório de consumidores para leitura
		// (RelatorioGerarDadosParaLeitura)
		preencherTotalizadoresRelatorioGerarDadosParaLeitura(helper, imovelParaSerGerado, anoMesCorrente);

		return helper;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura Convencional(Relação de Leituras e Comprovantes em PDF)
	 * [SB0002] - Gerar Relação
	 * [SB0003] - Gerar Movimento Roteiro da Empresa
	 * [SB0004] – Gera dados para leitura convencional DESO
	 * [SB0007] – Gera Relação Lista de Consumidores
	 * [SB0008] – Gera Comprovante de Leitura
	 * 
	 * @author Hebert Falcão
	 * @date 15/02/2011
	 * @param colecaoRota
	 * @param anoMesCorrente
	 * @param idGrupoFaturamentoRota
	 * @param idFuncionalidadeIniciada
	 * @param dataPrevistaAtividadeLeitura
	 * @throws ControladorException
	 */
	public void gerarDadosPorLeituraConvencionalPdf(Collection<Rota> colecaoRota, Integer anoMesCorrente, Integer idGrupoFaturamentoRota,
					FuncionalidadeIniciada funcionalidade, Date dataPrevistaAtividadeLeitura, Collection collLeituraTipo)
					throws ControladorException{

		int idUnidadeIniciada = ConstantesSistema.NUMERO_NAO_INFORMADO;

		try{

			SistemaParametro sistemaParametro = null;
			sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// Registrar o início do processamento da Unidade de Processamento do Batch
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(funcionalidade.getId(),
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			// Cria uma coleção de imóvel por rota
			Collection imoveisPorRota = new ArrayList();

			try{

				List<Integer> colecaoRotaIds = new ArrayList<Integer>();
				for(Rota rota : colecaoRota){

					colecaoRotaIds.add(rota.getId());
				}

				// Recupera todos os imóveis da coleção de rotas
				Collection arrayImoveis = repositorioMicromedicao.pesquisarImoveisParaLeituraPorColecaoRota(colecaoRotaIds,
								sistemaParametro);

				imoveisPorRota.addAll(arrayImoveis);
			}catch(ErroRepositorioException e){

				throw new ControladorException("erro.sistema", e);
			}

			Collection<FaturamentoAtividadeCriterio> colecaoFaturamentoAtividadeCriterio = null;

			colecaoFaturamentoAtividadeCriterio = this.pesquisarFaturamentoAtividadeCriterioPorLeituraTipo(
							FaturamentoAtividade.GERAR_ARQUIVO_LEITURA, collLeituraTipo);

			// Instancia uma coleção que será usada para gerar o arquivo txt.
			Collection<Imovel> imoveisParaSerGerados = new ArrayList();

			if(imoveisPorRota != null && !imoveisPorRota.isEmpty()){
				Iterator imovelporRotaIterator = imoveisPorRota.iterator();

				while(imovelporRotaIterator.hasNext()){

					Object[] arrayImoveisPorRota = (Object[]) imovelporRotaIterator.next();

					Imovel imovel = this.criarImovelApartirDadosPorLeituraConvencional(arrayImoveisPorRota);

					// [SB0006] – Seleção imóveis para Faturamento
					boolean ehValido = this.selecionarImovelParaFaturamento(imovel, anoMesCorrente, colecaoFaturamentoAtividadeCriterio);

					if(ehValido){
						imoveisParaSerGerados.add(imovel);
					}
				}
			}

			if(imoveisParaSerGerados != null && !imoveisParaSerGerados.isEmpty()){

				Iterator imovelParaSerGeradoIterator = imoveisParaSerGerados.iterator();
				Collection<GerarDadosParaLeituraHelper> colecaoGerarDadosParaLeituraHelper = new ArrayList<GerarDadosParaLeituraHelper>();

				repositorioMicromedicao.removerMovimentoRoteiroEmpresa(anoMesCorrente, idGrupoFaturamentoRota);

				GerarDadosParaLeituraHelper helper = null;

				while(imovelParaSerGeradoIterator.hasNext()){

					Imovel imovelParaSerGerado = (Imovel) imovelParaSerGeradoIterator.next();

					helper = this.montarGerarDadosParaLeituraHelper(imovelParaSerGerado, anoMesCorrente, sistemaParametro);

					colecaoGerarDadosParaLeituraHelper.add(helper);

					// [SB0003] - Gerar Movimento Roteiro da Empresa
					inserirMovimentoRoteiroEmpresa(sistemaParametro, imovelParaSerGerado, anoMesCorrente, funcionalidade,
									dataPrevistaAtividadeLeitura, idGrupoFaturamentoRota);
				}

				/*
				 * [SB0007 – Gera Relação Lista de Consumidores]
				 * [SB0008 – Gera Comprovante de Leitura]
				 */

				// Parâmetros do relatório
				Map parametros = new HashMap();
				parametros.put("tipoFormatoRelatorio", "PDF");

				RelatorioGerarDadosParaleitura relatorioDadosParaLeitura = new RelatorioGerarDadosParaleitura(Usuario.USUARIO_BATCH);
				relatorioDadosParaLeitura.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
				relatorioDadosParaLeitura.addParametro("colecaoGerarDadosParaLeituraHelper", colecaoGerarDadosParaLeituraHelper);
				relatorioDadosParaLeitura.addParametro("indicadorExibirTotalizacoes",
								ParametroMicromedicao.P_EXIBIR_TOTALIZACOES_RELAT_CONSUMIDORES_LEITURA.executar());

				GerenciadorExecucaoTarefaRelatorio.analisarExecucao(relatorioDadosParaLeitura, TarefaRelatorio.TIPO_PDF);

				RelatorioComprovantesLeitura relatorioComprovanteLeitura = new RelatorioComprovantesLeitura(Usuario.USUARIO_BATCH);
				relatorioComprovanteLeitura.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
				relatorioComprovanteLeitura.addParametro("colecaoGerarDadosParaLeituraHelper", colecaoGerarDadosParaLeituraHelper);
				GerenciadorExecucaoTarefaRelatorio.analisarExecucao(relatorioComprovanteLeitura, TarefaRelatorio.TIPO_PDF);

			}
			// Atualiza a data e a hora da realização da atividade com a data e
			// a hora correntes
			try{

				repositorioMicromedicao.atualizarFaturamentoAtividadeCronograma(idGrupoFaturamentoRota, anoMesCorrente);
			}catch(ErroRepositorioException e){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			// Encerra a unidade de Faturamento
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	/**
	 * [UC0083] Gerar Dados para Leitura
	 * [SB0003] - Gerar Movimento Roteiro da Empresa
	 * 
	 * @date 17/08/2011
	 */
	public void inserirMovimentoRoteiroEmpresa(SistemaParametro sistemaParametro, Imovel imovelParaSerGerado, Integer anoMesCorrente,
					FuncionalidadeIniciada funcionalidade, Date dataPrevistaAtividadeLeitura, Integer idGrupoFaturamentoRota)
					throws ControladorException, ErroRepositorioException{

		boolean ligacaoAgua = false;
		boolean ligacaoPoco = false;
		boolean reparticaoPublicaFederal = false;
		Integer idClientePublicoFederal = null;

		if(imovelParaSerGerado.getId().equals(541591) || imovelParaSerGerado.getId().equals(536512)){
			System.out.println("achou");
		}

		if(imovelParaSerGerado.getLigacaoAgua() != null && imovelParaSerGerado.getLigacaoAgua().getId() != null
						&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
						&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null){

			ligacaoAgua = true;
		}
		if(imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null
						&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId() != null){

			ligacaoPoco = true;
		}

		MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = new MovimentoRoteiroEmpresa();
		movimentoRoteiroEmpresa.setAnoMesMovimento(anoMesCorrente);

		if((imovelParaSerGerado.getIndicadorEmissaoExtratoFaturamento() != null && (imovelParaSerGerado
						.getIndicadorEmissaoExtratoFaturamento().equals(ConstantesSistema.SIM)))
						|| ((imovelParaSerGerado.getImovelContaEnvio() != null && (imovelParaSerGerado.getImovelContaEnvio().getId()
										.equals(ImovelContaEnvio.ENVIAR_CLIENTE_RESPONSAVEL) || imovelParaSerGerado.getImovelContaEnvio()
										.getId().equals(ImovelContaEnvio.NAO_PAGAVEL_IMOVEL_PAGAVEL_RESPONSAVEL))))
						|| (imovelParaSerGerado.getIndicadorImovelCondominio() != null && imovelParaSerGerado
										.getIndicadorImovelCondominio().equals(ConstantesSistema.SIM))){
			movimentoRoteiroEmpresa.setIndicadorEmissao(ConstantesSistema.NAO);
		}else{
			movimentoRoteiroEmpresa.setIndicadorEmissao(ConstantesSistema.SIM);
		}

		if(imovelParaSerGerado.getQuadra() != null){

			if(sistemaParametro.getIndicadorRoteiroEmpresa() == 1){

				if(imovelParaSerGerado.getQuadra().getRoteiroEmpresa() == null){

					return;
				}
			}

			/*
			 * movimentoRoteiroEmpresa.setRoteiroEmpresa(imovelParaSerGerado
			 * .getQuadra().getRoteiroEmpresa());
			 */
			movimentoRoteiroEmpresa.setNumeroQuadra(imovelParaSerGerado.getQuadra().getNumeroQuadra());

			if(imovelParaSerGerado.getRota() != null){

				// id do grupo de faturamento
				movimentoRoteiroEmpresa.setFaturamentoGrupo(imovelParaSerGerado.getRota().getFaturamentoGrupo());
				movimentoRoteiroEmpresa.setRota(imovelParaSerGerado.getRota());
				movimentoRoteiroEmpresa.setLeiturista(imovelParaSerGerado.getRota().getLeiturista());
				movimentoRoteiroEmpresa.setCodigoRota(imovelParaSerGerado.getRota().getCodigo());
			}

			if(imovelParaSerGerado.getQuadra().getRoteiroEmpresa() != null){

				movimentoRoteiroEmpresa.setEmpresa(imovelParaSerGerado.getQuadra().getRoteiroEmpresa().getEmpresa());
			}else{

				movimentoRoteiroEmpresa.setEmpresa(imovelParaSerGerado.getRota().getEmpresa());
			}
		}

		movimentoRoteiroEmpresa.setLocalidade(imovelParaSerGerado.getLocalidade());
		movimentoRoteiroEmpresa.setCodigoSetorComercial(imovelParaSerGerado.getSetorComercial().getCodigo());

		// Matricula do imóvel
		movimentoRoteiroEmpresa.setImovel(imovelParaSerGerado);

		movimentoRoteiroEmpresa.setNumeroInscricao(imovelParaSerGerado.getInscricaoFormatada());

		movimentoRoteiroEmpresa.setNumeroLoteImovel(imovelParaSerGerado.getLote());
		movimentoRoteiroEmpresa.setNumeroSubLoteImovel(imovelParaSerGerado.getSubLote());

		// caso seja tipo ligação agua e poço cria a string primeiro com tipo
		// ligação agua
		if(ligacaoAgua && ligacaoPoco){

			if(imovelParaSerGerado.getLigacaoAgua() != null
							&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
							&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null
							&& !imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId().equals("")){

				movimentoRoteiroEmpresa.setMedicaoTipo(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico()
								.getMedicaoTipo());
			}

			// caso não seja
		}else{

			// caso seja tipo ligação agua cria a string com tipo ligação agua
			if(ligacaoAgua){

				if(imovelParaSerGerado.getLigacaoAgua() != null
								&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
								&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null
								&& !imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId().equals("")){

					movimentoRoteiroEmpresa.setMedicaoTipo(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico()
									.getMedicaoTipo());
				}
			}else{
				// caso seja tipo ligação poço cria a string com tipo ligação poço
				if(ligacaoPoco){

					if(imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null
									&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId() != null
									&& !imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId().equals("")){

						movimentoRoteiroEmpresa.setMedicaoTipo(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getMedicaoTipo());
					}
				}
			}
		}

		String nomeClienteUsuario = null;
		try{

			// Pesquisa o nome do cliente que tem o tipo de relação usuário.
			nomeClienteUsuario = repositorioClienteImovel.pesquisarNomeClientePorImovel(imovelParaSerGerado.getId());
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		// nome do cliente usuário
		if(nomeClienteUsuario == null){

			nomeClienteUsuario = "";
		}

		movimentoRoteiroEmpresa.setNomeCliente(completaString(nomeClienteUsuario, 25));

		// Pesquisa o endereço do imovel passando o id
		String[] enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatadoDividido(imovelParaSerGerado.getId());
		if(enderecoImovel != null){

			if(enderecoImovel[0] != null){

				movimentoRoteiroEmpresa.setEnderecoImovel(completaString(enderecoImovel[0], 50));
			}else{

				movimentoRoteiroEmpresa.setEnderecoImovel(completaString("", 50));
			}

			if(enderecoImovel[4] != null){

				movimentoRoteiroEmpresa.setCepEnderecoImovel(completaString(enderecoImovel[4], 10));
			}else{

				movimentoRoteiroEmpresa.setCepEnderecoImovel(completaString("", 10));
			}

			if(enderecoImovel[3] != null){

				movimentoRoteiroEmpresa.setBairroEnderecoImovel(completaString(enderecoImovel[3], 30));
			}else{

				movimentoRoteiroEmpresa.setBairroEnderecoImovel(completaString("", 30));
			}

			if(enderecoImovel[1] != null){

				movimentoRoteiroEmpresa.setMunicipioEnderecoImovel(completaString(enderecoImovel[1], 30));
			}else{

				movimentoRoteiroEmpresa.setMunicipioEnderecoImovel(completaString("", 30));
			}

			if(enderecoImovel[6] != null){

				movimentoRoteiroEmpresa.setComplementoEnderecoImovel(completaString(enderecoImovel[6], 25));
			}else{

				movimentoRoteiroEmpresa.setComplementoEnderecoImovel(completaString("", 25));
			}
		}

		// Zona Territorial
		if(imovelParaSerGerado.getQuadra().getAreaTipo() != null && imovelParaSerGerado.getQuadra().getAreaTipo().getDescricao() != null){

			movimentoRoteiroEmpresa.setZonaTerritorial(completaString(imovelParaSerGerado.getQuadra().getAreaTipo().getDescricao(), 15));
		}else{

			movimentoRoteiroEmpresa.setZonaTerritorial(completaString("", 15));
		}

		// id da ligacao agua situação
		if(imovelParaSerGerado.getLigacaoAguaSituacao() != null && imovelParaSerGerado.getLigacaoAguaSituacao().getId() != null){

			// Situação da ligação de agua
			movimentoRoteiroEmpresa.setLigacaoAguaSituacao(imovelParaSerGerado.getLigacaoAguaSituacao());
		}

		// id da ligacao esgoto situação
		if(imovelParaSerGerado.getLigacaoEsgotoSituacao() != null && imovelParaSerGerado.getLigacaoEsgotoSituacao().getId() != null){

			// Situação de ligação esgoto
			movimentoRoteiroEmpresa.setLigacaoEsgotoSituacao(imovelParaSerGerado.getLigacaoEsgotoSituacao());
		}

		if(imovelParaSerGerado.getPocoTipo() != null){

			movimentoRoteiroEmpresa.setIndicadorPoco(Short.valueOf(ConstantesSistema.SIM));
		}else{

			movimentoRoteiroEmpresa.setIndicadorPoco(Short.valueOf(ConstantesSistema.NAO));
		}

		// [UC0108 - Obter Quantidade de Economias por Categoria]
		Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovelParaSerGerado);
		for(Iterator iterator = colecaoCategoriasImovel.iterator(); iterator.hasNext();){

			Categoria categoria = (Categoria) iterator.next();

			switch(categoria.getId().intValue()){
				case Categoria.RESIDENCIAL_INT:

					movimentoRoteiroEmpresa.setQuantidadeEconomiasResidencial(Short.valueOf(categoria.getQuantidadeEconomiasCategoria()
									.shortValue()));
					break;
				case Categoria.COMERCIAL_INT:

					movimentoRoteiroEmpresa.setQuantidadeEconomiasComercial(Short.valueOf(categoria.getQuantidadeEconomiasCategoria()
									.shortValue()));
					break;
				case Categoria.INDUSTRIAL_INT:

					movimentoRoteiroEmpresa.setQuantidadeEconomiasIndustrial(Short.valueOf(categoria.getQuantidadeEconomiasCategoria()
									.shortValue()));
					break;
				case Categoria.PUBLICO_INT:

					movimentoRoteiroEmpresa.setQuantidadeEconomiasPublica(Short.valueOf(categoria.getQuantidadeEconomiasCategoria()
									.shortValue()));
					break;
			}
		}

		// Tarifa de Consumo

		// Caso exista contrato de demanda de consumo vigente para o imóvel e tarifa de
		// consumo não esteja vazia
		// atribuir CSTF_ID da tabela CONTRATO_DEMANDA_CONSUMO
		ContratoDemandaConsumo contratoDemandaConsumo = this.getControladorFaturamento().pesquisarContratoDemandaConsumoVigenteComTarifa(
						imovelParaSerGerado.getId(), sistemaParametro.getAnoMesFaturamento());

		if(contratoDemandaConsumo != null){

			movimentoRoteiroEmpresa.setConsumoTarifa(contratoDemandaConsumo.getConsumoTarifa());

		}else if(imovelParaSerGerado.getConsumoTarifa() != null){

			movimentoRoteiroEmpresa.setConsumoTarifa(imovelParaSerGerado.getConsumoTarifa());
		}

		// NN CONSUMO FIXO ÁGUA
		// Caso exista contrato de demanda de consumo vigente para o imóvel e consumo fixo
		// não esteja vazia
		// atribuir CSTF_ID da tabela CONTRATO_DEMANDA_CONSUMO
		ContratoDemandaConsumo contratoDemandaConsumoFixo = this.getControladorFaturamento()
						.pesquisarContratoDemandaConsumoVigenteComConsumoFixo(imovelParaSerGerado.getId(),
										sistemaParametro.getAnoMesFaturamento());

		if(contratoDemandaConsumo != null){

			movimentoRoteiroEmpresa.setNumeroConsumoFixoAgua(contratoDemandaConsumo.getNumeroConsumoFixo());

		}

		// Verifica se o imóvel está enquadrado em uma subcategoria considerada Repartição
		// Pública Federal
		reparticaoPublicaFederal = getControladorImovel().verificarImovelReparticaoPublicaFederal(imovelParaSerGerado.getId());

		idClientePublicoFederal = repositorioFaturamento.pesquisarClienteResponsavelEsferaPoderFederal(imovelParaSerGerado.getId());

		// Se o imóvel está associado a uma subcategoria considerada como Repartição Pública
		// Federal ou possui um cliente responsável da esfera do poder Federal, calcula os
		// impostos deduzidos
		if(reparticaoPublicaFederal || idClientePublicoFederal != null){

			movimentoRoteiroEmpresa.setIndicadorImpostoFederal(ConstantesSistema.SIM);
		}else{

			movimentoRoteiroEmpresa.setIndicadorImpostoFederal(ConstantesSistema.NAO);
		}

		// Perfil
		if(imovelParaSerGerado.getImovelPerfil().getId().equals(ImovelPerfil.GRANDE)){

			movimentoRoteiroEmpresa.setIndicadorGrandeCliente(ConstantesSistema.SIM);
			movimentoRoteiroEmpresa.setIndicadorBaixaRenda(ConstantesSistema.NAO);
		}else if(imovelParaSerGerado.getImovelPerfil().getId().equals(ImovelPerfil.TARIFA_SOCIAL)){

			movimentoRoteiroEmpresa.setIndicadorGrandeCliente(ConstantesSistema.NAO);
			movimentoRoteiroEmpresa.setIndicadorBaixaRenda(ConstantesSistema.SIM);
		}else{

			movimentoRoteiroEmpresa.setIndicadorGrandeCliente(ConstantesSistema.NAO);
			movimentoRoteiroEmpresa.setIndicadorBaixaRenda(ConstantesSistema.NAO);
		}

		// Dados do Hidrometro

		// caso seja tipo ligação agua e poço cria a string primeiro com tipo
		// ligação agua
		Short numeroDigitosHidrometro = null;

		if(ligacaoAgua && ligacaoPoco){

			Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);
			numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];

			movimentoRoteiroEmpresa.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
			movimentoRoteiroEmpresa.setNumeroDigitosLeitura(numeroDigitosHidrometro);

			// caso não seja
		}else{

			// caso seja tipo ligação agua cria a string com tipo ligação agua
			if(ligacaoAgua){

				Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);
				numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];

				movimentoRoteiroEmpresa.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
				movimentoRoteiroEmpresa.setNumeroDigitosLeitura(numeroDigitosHidrometro);

				// caso não seja
			}else{

				// caso seja tipo ligação poço cria a string com tipo ligação poço
				if(ligacaoPoco){

					Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);
					numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];

					movimentoRoteiroEmpresa.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
					movimentoRoteiroEmpresa.setNumeroDigitosLeitura(numeroDigitosHidrometro);

					// caso não seja nem um nem outro então pode chamar qualquer um
					// dos métodos pois os dois fazem a verificação e
					// retorna strings vazia e a data cpm zeros
				}else{

					Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);
					numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
					movimentoRoteiroEmpresa.setNumeroHidrometro((String) dadosHidrometroNumeroLeitura[4]);
					movimentoRoteiroEmpresa.setNumeroDigitosLeitura(numeroDigitosHidrometro);
				}
			}
		}

		if(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){

			if(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao() != null){

				movimentoRoteiroEmpresa.setLocalInstalacaoHidrometro(imovelParaSerGerado.getLigacaoAgua()
								.getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao().getDescricao());
			}

			movimentoRoteiroEmpresa.setDataInstalacaoHidrometro(imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico()
							.getDataInstalacao());

		}else if(imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null){

			movimentoRoteiroEmpresa.setDataInstalacaoHidrometro(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getDataInstalacao());
			if(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao() != null){

				movimentoRoteiroEmpresa.setLocalInstalacaoHidrometro(imovelParaSerGerado.getHidrometroInstalacaoHistorico()
								.getHidrometroLocalInstalacao().getDescricao());
			}

			movimentoRoteiroEmpresa.setDataInstalacaoHidrometro(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getDataInstalacao());
		}

		// Leitura anterior
		Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);
		Integer idMedicaoTipo = null;
		Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior, imovelParaSerGerado);

		// verifica se o id da medição tipo é diferente de nula
		MedicaoTipo medicaoTipo = new MedicaoTipo();
		if(retorno[2] != null){
			idMedicaoTipo = (Integer) retorno[2];
			if(idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)){
				medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);

			}else if(idMedicaoTipo.equals(MedicaoTipo.POCO)){
				medicaoTipo.setId(MedicaoTipo.POCO);
			}
		}
		movimentoRoteiroEmpresa.setMedicaoTipo(medicaoTipo);
		if(movimentoRoteiroEmpresa.getMedicaoTipo() != null && movimentoRoteiroEmpresa.getMedicaoTipo().getId() != null){
			try{
				Object[] dadosUltimoMedicaoHistorico = (Object[]) repositorioMicromedicao.pesquisarObterDadosMaiorHistoricoMedicao(
								imovelParaSerGerado, movimentoRoteiroEmpresa.getMedicaoTipo(), sistemaParametro);
				if(dadosUltimoMedicaoHistorico != null){
					movimentoRoteiroEmpresa.setDataLeituraAnterior((Date) dadosUltimoMedicaoHistorico[0]);
					movimentoRoteiroEmpresa.setNumeroLeituraAnterior((Integer) dadosUltimoMedicaoHistorico[1]);
					movimentoRoteiroEmpresa.setNumeroConsumoCredito((Integer) dadosUltimoMedicaoHistorico[3]);

				}

				Collection<Integer> colecaoConsumoHistoricoImovel = repositorioMicromedicao.pesquisarConsumoFaturadoQuantidadeMeses(
								imovelParaSerGerado.getId(), movimentoRoteiroEmpresa.getMedicaoTipo().getId(), Short.valueOf("1"));
				if(colecaoConsumoHistoricoImovel != null && !colecaoConsumoHistoricoImovel.isEmpty()){
					Integer ultimoConsumoFaturadoMes = (Integer) colecaoConsumoHistoricoImovel.iterator().next();
					movimentoRoteiroEmpresa.setNumeroConsumoAnterior(ultimoConsumoFaturadoMes);
				}
			}catch(ErroRepositorioException ex){
				throw new ControladorException("", ex);
			}

			// [UC0102] - Obter Consumo médio do hidrômetro
			int[] consumoMedioHidrometro = this.obterConsumoMedioHidrometro(imovelParaSerGerado, sistemaParametro, movimentoRoteiroEmpresa
							.getMedicaoTipo());
			if(consumoMedioHidrometro != null){
				movimentoRoteiroEmpresa.setNumeroConsumoMedio(Integer.valueOf(consumoMedioHidrometro[0]));
			}
		}

		movimentoRoteiroEmpresa.setIdUsuarioGeracao(funcionalidade.getProcessoIniciado().getUsuario().getId());
		movimentoRoteiroEmpresa.setTempoGeracao(new Date());
		movimentoRoteiroEmpresa.setIndicadorFase(MovimentoRoteiroEmpresa.FASE_GERADO);
		movimentoRoteiroEmpresa.setDataProgramacaoLeitura(dataPrevistaAtividadeLeitura);

		getControladorUtil().inserir(movimentoRoteiroEmpresa);
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos. Método que recebe um
	 * array com as informações de um imóvel para faturamento e retorna um
	 * objeto Imovel.
	 * 
	 * @date 02/08/2011
	 */
	public Imovel obterImovelParaFaturamento(Object[] arrayImovel){

		Imovel imovel = new Imovel();
		LigacaoAgua ligacaoAgua = null;
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = null;
		Hidrometro hidrometro = null;
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = null;
		PocoTipo pocoTipo = null;
		LigacaoAguaSituacao ligacaoAguaSituacao = null;
		LigacaoEsgotoSituacao ligacaoEsgotoSituacao = null;
		LigacaoEsgoto ligacaoEsgoto = null;
		ConsumoTarifa consumoTarifa = null;
		ConsumoTarifa consumoTarifaTemporaria = null;
		SetorComercial setorComercial = null;
		Localidade localidade = null;
		Localidade elo = null;
		Quadra quadra = null;
		ImovelPerfil imovelPerfil = null;
		ImovelContaEnvio imovelContaEnvio = null;
		FaturamentoTipo faturamentoTipo = null;
		ImovelAguaParaTodos imovelAPT = null;
		Rota rota = null;
		LeituraTipo leituraTipo = null;
		Leiturista leiturista = null;
		Empresa empresa = null;

		// Id do imóvel
		imovel.setId((Integer) arrayImovel[0]);

		// Se existe ligação de água
		if(arrayImovel[3] != null){
			ligacaoAgua = new LigacaoAgua();
			ligacaoAgua.setId((Integer) arrayImovel[3]);

			// Seta o consumo mínimo de água da ligação de água
			if(arrayImovel[12] != null){
				ligacaoAgua.setNumeroConsumoMinimoAgua((Integer) arrayImovel[12]);
			}


			// Seta a data de supressão
			if(arrayImovel[65] != null){

				ligacaoAgua.setDataSupressao((Date) arrayImovel[65]);
			}

			// Seta a data de corte
			if(arrayImovel[36] != null){

				ligacaoAgua.setDataCorte((Date) arrayImovel[36]);
			}

			// Seta a data de religação
			if(arrayImovel[66] != null){

				ligacaoAgua.setDataReligacao((Date) arrayImovel[66]);
			}


			// Seta a data de reestabelecimento
			if(arrayImovel[67] != null){

				ligacaoAgua.setDataRestabelecimentoAgua((Date) arrayImovel[67]);
			}

			// Seta a data de ligação
			if(arrayImovel[75] != null){

				ligacaoAgua.setDataLigacao((Date) arrayImovel[75]);
			}


			// Se existe hidrômetro instalado na ligação de água
			if(arrayImovel[4] != null){
				hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
				hidrometroInstalacaoHistorico.setId((Integer) arrayImovel[4]);

				// Seta a data de instalação do hidrômetro
				if(arrayImovel[18] != null){
					hidrometroInstalacaoHistorico.setDataInstalacao((Date) arrayImovel[18]);
				}

				// seta O Indicador de substituição da instalação
				if(arrayImovel[29] != null){
					hidrometroInstalacaoHistorico.setIndicadorInstalcaoSubstituicao((Short) arrayImovel[29]);
				}

				// Seta o hidrômetro
				if(arrayImovel[5] != null){
					hidrometro = new Hidrometro();
					hidrometro.setId((Integer) arrayImovel[5]);
					hidrometroInstalacaoHistorico.setHidrometro(hidrometro);
				}

				// Local de Instalação
				if(arrayImovel[57] != null){
					HidrometroLocalInstalacao hidrometroLocalInstalacao = new HidrometroLocalInstalacao();
					hidrometroLocalInstalacao.setId((Integer) arrayImovel[57]);
					hidrometroLocalInstalacao.setDescricaoAbreviada((String) arrayImovel[58]);

					hidrometroInstalacaoHistorico.setHidrometroLocalInstalacao(hidrometroLocalInstalacao);
				}

				// Seta número de leitura instalação
				if(arrayImovel[68] != null){

					hidrometroInstalacaoHistorico.setNumeroLeituraInstalacao((Integer) arrayImovel[68]);
				}

				// Seta número de leitura corte
				if(arrayImovel[69] != null){

					hidrometroInstalacaoHistorico.setNumeroLeituraCorte((Integer) arrayImovel[69]);
				}

				// Seta número de leitura supressão
				if(arrayImovel[70] != null){

					hidrometroInstalacaoHistorico.setNumeroLeituraSupressao((Integer) arrayImovel[70]);
				}

				// Seta o hidrômetro instalação histórico na ligação de água
				ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);

				// Seta o número de digitos da leitura (esse valor será
				// usado no UC calcularFaixaLeituraEsperada)
				if(arrayImovel[6] != null){
					hidrometro.setNumeroDigitosLeitura((Short) arrayImovel[6]);
				}

				// Hidrômetro capacidade
				if(arrayImovel[32] != null){
					HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
					hidrometroCapacidade.setId((Integer) arrayImovel[32]);

					if(arrayImovel[33] != null){
						hidrometroCapacidade.setCodigoHidrometroCapacidade((String) arrayImovel[33]);
					}

					hidrometro.setHidrometroCapacidade(hidrometroCapacidade);
				}
			}

			imovel.setLigacaoAgua(ligacaoAgua);

		}

		// Se existe ligação de esgoto
		if(arrayImovel[16] != null){
			ligacaoEsgoto = new LigacaoEsgoto();
			ligacaoEsgoto.setId((Integer) arrayImovel[16]);

			// Seta o consumo mínimo de ligação de esgoto
			if(arrayImovel[17] != null){
				ligacaoEsgoto.setConsumoMinimo((Integer) arrayImovel[17]);
			}

			// Seta o percentual de coleta de ligação do esgoto
			if(arrayImovel[20] != null){
				ligacaoEsgoto.setPercentualAguaConsumidaColetada((BigDecimal) arrayImovel[20]);
			}

			if(arrayImovel[63] != null){
				LigacaoEsgotoPerfil ligacaoEsgotoPerfil = new LigacaoEsgotoPerfil();
				ligacaoEsgotoPerfil.setPercentualEsgotoConsumidaColetada((BigDecimal) arrayImovel[63]);
				ligacaoEsgoto.setLigacaoEsgotoPerfil(ligacaoEsgotoPerfil);
			}

			imovel.setLigacaoEsgoto(ligacaoEsgoto);

		}
		// Seta faturamento situacao tipo
		if(arrayImovel[7] != null){
			faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
			faturamentoSituacaoTipo.setId((Integer) arrayImovel[7]);
			// Seta o indicador de faturamento paralisação
			if(arrayImovel[14] != null){
				faturamentoSituacaoTipo.setIndicadorParalisacaoFaturamento((Short) arrayImovel[14]);
			}

			// Seta o indicador de validade de água
			if(arrayImovel[24] != null){
				faturamentoSituacaoTipo.setIndicadorValidoAgua((Short) arrayImovel[24]);
			}

			// Seta o indicador de validade de esgoto
			if(arrayImovel[25] != null){
				faturamentoSituacaoTipo.setIndicadorValidoEsgoto((Short) arrayImovel[25]);
			}

			// seta o indicador de Faturamento de paralisação de Esgoto
			if(arrayImovel[31] != null){
				faturamentoSituacaoTipo.setIndicadorFaturamentoParalisacaoEsgoto((Short) arrayImovel[31]);
			}

			imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
		}

		// Seta o tipo do poço
		if(arrayImovel[8] != null){
			pocoTipo = new PocoTipo();
			pocoTipo.setId((Integer) arrayImovel[8]);
			imovel.setPocoTipo(pocoTipo);
		}

		// Seta o indicador imóvel condomínio
		if(arrayImovel[13] != null){
			imovel.setIndicadorImovelCondominio((Short) arrayImovel[13]);
		}

		// Seta o consumo tipo
		if(arrayImovel[19] != null){
			consumoTarifa = new ConsumoTarifa();
			consumoTarifa.setId((Integer) arrayImovel[19]);
			imovel.setConsumoTarifa(consumoTarifa);
		}

		// Seta o indicador débito conta
		if(arrayImovel[15] != null){
			imovel.setIndicadorDebitoConta((Short) arrayImovel[15]);
		}

		if(arrayImovel[1] != null){
			ligacaoAguaSituacao = new LigacaoAguaSituacao();
			ligacaoAguaSituacao.setId((Integer) arrayImovel[1]);
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);

			if(arrayImovel[27] != null){

				imovel.getLigacaoAguaSituacao().setIndicadorFaturamentoSituacao((Short) arrayImovel[27]);
			}

			if(arrayImovel[62] != null){

				imovel.getLigacaoAguaSituacao().setIndicadorAjusteConsumo((Short) arrayImovel[62]);
			}
		}

		if(arrayImovel[2] != null){
			ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
			ligacaoEsgotoSituacao.setId((Integer) arrayImovel[2]);
			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

			if(arrayImovel[28] != null){

				imovel.getLigacaoEsgotoSituacao().setIndicadorFaturamentoSituacao((Short) arrayImovel[28]);
			}

			if(arrayImovel[61] != null){
				imovel.getLigacaoEsgotoSituacao().setIndicadorAjusteConsumo((Short) arrayImovel[61]);
			}
		}

		// [UC0064 – Obter Quantidade Economias]
		short quantidadeEconomiasImovel = 0;
		try{

			quantidadeEconomiasImovel = Short.valueOf(String.valueOf(getControladorImovel().obterQuantidadeEconomias(imovel)));
		}catch(NumberFormatException e){

			e.printStackTrace();
		}catch(ControladorException e){

			e.printStackTrace();
		}

		if(quantidadeEconomiasImovel > 0){

			imovel.setQuantidadeEconomias(quantidadeEconomiasImovel);
		}else if(arrayImovel[21] != null){

			imovel.setQuantidadeEconomias((Short) arrayImovel[21]);
		}

		if(arrayImovel[9] != null){

			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoPoco = new HidrometroInstalacaoHistorico();
			hidrometroInstalacaoHistoricoPoco.setId((Integer) arrayImovel[9]);

			// Seta a data de instalação do hidrômetro
			if(arrayImovel[23] != null){
				hidrometroInstalacaoHistoricoPoco.setDataInstalacao((Date) arrayImovel[23]);
			}

			// seta O Indicador de substituição da instalação
			if(arrayImovel[30] != null){
				hidrometroInstalacaoHistoricoPoco.setIndicadorInstalcaoSubstituicao((Short) arrayImovel[30]);
			}

			// Seta número de leitura instalação
			if(arrayImovel[71] != null){

				hidrometroInstalacaoHistoricoPoco.setNumeroLeituraInstalacao((Integer) arrayImovel[71]);
			}

			// Seta número de leitura corte
			if(arrayImovel[72] != null){

				hidrometroInstalacaoHistoricoPoco.setNumeroLeituraCorte((Integer) arrayImovel[72]);
			}

			// Seta número de leitura supressão
			if(arrayImovel[73] != null){

				hidrometroInstalacaoHistoricoPoco.setNumeroLeituraSupressao((Integer) arrayImovel[73]);
			}

			// Seta o hidrômetro
			Hidrometro hidrometroPoco = null;
			if(arrayImovel[10] != null){

				hidrometroPoco = new Hidrometro();
				hidrometroPoco.setId((Integer) arrayImovel[10]);

				// Seta o número de digitos da leitura (esse valor será
				// usado no UC calcularFaixaLeituraEsperada)
				if(arrayImovel[22] != null){
					hidrometroPoco.setNumeroDigitosLeitura((Short) arrayImovel[22]);
				}

				// Hidrômetro capacidade
				if(arrayImovel[34] != null){
					HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
					hidrometroCapacidade.setId((Integer) arrayImovel[34]);

					if(arrayImovel[35] != null){
						hidrometroCapacidade.setCodigoHidrometroCapacidade((String) arrayImovel[35]);
					}

					hidrometroPoco.setHidrometroCapacidade(hidrometroCapacidade);
				}
			}

			hidrometroInstalacaoHistoricoPoco.setHidrometro(hidrometroPoco);

			// Local de Instalação
			if(arrayImovel[59] != null){
				HidrometroLocalInstalacao hidrometroLocalInstalacaoPoco = new HidrometroLocalInstalacao();
				hidrometroLocalInstalacaoPoco.setId((Integer) arrayImovel[59]);
				hidrometroLocalInstalacaoPoco.setDescricaoAbreviada((String) arrayImovel[60]);

				hidrometroInstalacaoHistoricoPoco.setHidrometroLocalInstalacao(hidrometroLocalInstalacaoPoco);
			}

			imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoPoco);

		}

		// Setor Comercial
		if(arrayImovel[37] != null){
			setorComercial = new SetorComercial();
			setorComercial.setId((Integer) arrayImovel[37]);
			setorComercial.setCodigo((Integer) arrayImovel[38]);
		}

		imovel.setSetorComercial(setorComercial);

		// Localidade
		if(arrayImovel[39] != null){

			localidade = new Localidade();
			localidade.setId((Integer) arrayImovel[39]);
			localidade.setDescricao((String) arrayImovel[76]);

			if(arrayImovel[77] != null){

				elo = new Localidade();
				elo.setId((Integer) arrayImovel[77]);
				elo.setDescricao((String) arrayImovel[78]);
				localidade.setLocalidade(elo);
			}
		}

		imovel.setLocalidade(localidade);

		// Quadra
		if(arrayImovel[40] != null){
			quadra = new Quadra();
			quadra.setId((Integer) arrayImovel[40]);
			if(arrayImovel[44] != null){
				quadra.setNumeroQuadra(((Integer) arrayImovel[44]).intValue());
			}

		}
		imovel.setQuadra(quadra);

		// Imovel Perfil
		if(arrayImovel[41] != null){
			imovelPerfil = new ImovelPerfil();
			imovelPerfil.setId((Integer) arrayImovel[41]);
		}
		imovel.setImovelPerfil(imovelPerfil);

		// imovel Conta Envio
		// Imovel Perfil
		if(arrayImovel[42] != null){
			imovelContaEnvio = new ImovelContaEnvio();
			imovelContaEnvio.setId((Integer) arrayImovel[42]);
		}
		imovel.setImovelContaEnvio(imovelContaEnvio);

		// Faturamento Tipo
		if(arrayImovel[43] != null){
			faturamentoTipo = new FaturamentoTipo();
			faturamentoTipo.setId((Integer) arrayImovel[43]);
		}

		// Lote
		if(arrayImovel[45] != null){
			imovel.setLote(((Short) arrayImovel[45]).shortValue());
		}

		if(arrayImovel[64] != null){
			imovel.setSubLote(((Short) arrayImovel[64]).shortValue());
		}

		// Imovel Agua Para Todos
		if(arrayImovel[46] != null){
			imovelAPT = new ImovelAguaParaTodos();
			imovelAPT.setId((Integer) arrayImovel[46]);
		}
		imovel.setImovelAguaParaTodos(imovelAPT);

		imovel.setFaturamentoTipo(faturamentoTipo);

		if(arrayImovel[47] != null){
			imovel.setDiaVencimento((Short) arrayImovel[47]);
		}

		if(arrayImovel[48] != null){
			imovel.setIndicadorEmissaoExtratoFaturamento((Short) arrayImovel[48]);
		}

		if(arrayImovel[49] != null){
			rota = new Rota();
			rota.setId((Integer) arrayImovel[49]);

			if(arrayImovel[50] != null){
				leituraTipo = new LeituraTipo();
				leituraTipo.setId((Integer) arrayImovel[50]);
				rota.setLeituraTipo(leituraTipo);
			}

			if(arrayImovel[51] != null){
				leiturista = new Leiturista();
				leiturista.setId((Integer) arrayImovel[51]);
				rota.setLeiturista(leiturista);

			}
			if(arrayImovel[52] != null){
				empresa = new Empresa();
				empresa.setId((Integer) arrayImovel[52]);
				rota.setEmpresa(empresa);
			}
			if(arrayImovel[53] != null){
				rota.setIndicadorFiscalizarCortado((Short) arrayImovel[53]);
			}
			if(arrayImovel[54] != null){
				rota.setIndicadorFiscalizarSuprimido((Short) arrayImovel[54]);
			}

			if(arrayImovel[74] != null){
				rota.setCodigo((Short) arrayImovel[74]);
			}

			imovel.setRota(rota);
		}

		// Seta o consumo tarifa temporaria
		if(arrayImovel[55] != null){
			consumoTarifaTemporaria = new ConsumoTarifa();
			consumoTarifaTemporaria.setId((Integer) arrayImovel[55]);
			imovel.setConsumoTarifaTemporaria(consumoTarifaTemporaria);
		}

		if(arrayImovel[56] != null){
			imovel.setDataValidadeTarifaTemporaria((Date) arrayImovel[56]);
		}

		return imovel;

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0001] - Determinar
	 * Dados para Faturamento de Água
	 * 
	 * @author eduardo henrique
	 * @date 12/12/2008
	 * @author Saulo Lima
	 * @date 29/12/2008 Ajuste para não cobrar o mínimo dos imóveis
	 *       "não fatuáveis" sem consumo Alteração para reinicialização do
	 *       Crédito de Consumo Gerado, caso existe dados anteriores. Alteração
	 *       para ajuste do Consumo Mínimo da Ligação para utilizar
	 * @author eduardo henrique
	 * @date 17/01/2008 Alteração na forma de obtenção do valor do Mínimo de
	 *       Ligação do Imóvel.
	 * @author eduardo henrique
	 * @date 30/01/2009 Correção na atribuição de Tipo de Consumo e Anormalidade
	 *       após verificação do mínimo de Ligação.
	 * @author eduardo henrique
	 * @date 14/02/2009 Alteracao para Baixo Consumo ser verificado independente
	 *       da indicacao de Poco
	 */
	// protected void determinarDadosFaturamentoAgua(MedicaoHistorico
	// medicaoHistorico,
	// ConsumoHistorico consumoHistorico,
	// Imovel imovel, FaturamentoGrupo faturamentoGrupo, SistemaParametro
	// sistemaParametro, int[]
	// consumoMedioImovel,
	// int quantidadeEconomias, Rota rota, Collection
	// colecaoInserirMedicaoHistoricoAgua, Collection
	// colecaoAtualizarMedicaoHistoricoAgua,
	// Collection colecaoInserirConsumoHistoricoAgua, EsferaPoder esferaPoder)
	// throws ControladorException {
	//
	// medicaoHistorico = new MedicaoHistorico();
	//
	// // Define a medição tipo água
	// MedicaoTipo medicaoTipo = new MedicaoTipo();
	//
	// // [SB0003] - Determinar Dados para Faturamento de Água do Medido
	// // Caso o hidrômetro possua ligação de água
	// if (imovel.getLigacaoAgua() != null &&
	// imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) {
	//
	// medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);
	//
	// medicaoHistorico = this.obterDadosHistoricoMedicao(faturamentoGrupo,
	// imovel, medicaoTipo,
	// sistemaParametro);
	//
	// // Alteração solicitada por Luciene em 08/10/2008
	// // Implementada por Virgínia Melo.
	// // Iniciando este campo sempre com o valor do Mês anterior, não haverá
	// problema
	// // de crédito quando esta funcionalidade for executada mais de uma vez.
	// Collection colecaoParmsMedicaoAnterior = null;
	// int anoMesReferencia = medicaoHistorico.getAnoMesReferencia();
	// int anoMesAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia, 1);
	//
	// // Pesquisa pela Medição Histórico do Mês Anterior.
	// try {
	// colecaoParmsMedicaoAnterior =
	// repositorioMicromedicao.pesquisarMedicaoHistoricoAnterior(Collections.singletonList(imovel),
	// anoMesAnterior, medicaoTipo.getId());
	// } catch (ErroRepositorioException e) {
	// throw new ControladorException("erro.sistema", e);
	// }
	//
	// // Caso não encontre registro, o Crédito Anterior será ZERO. o Crédito
	// Gerado será sempre
	// inicializado
	// if (colecaoParmsMedicaoAnterior == null ||
	// colecaoParmsMedicaoAnterior.isEmpty()) {
	// medicaoHistorico.setConsumoCreditoAnterior(Integer.valueOf(0));
	// }
	//
	// Iterator colecaoParmsMedicaoAnteriorIterator =
	// colecaoParmsMedicaoAnterior.iterator();
	//
	// while (colecaoParmsMedicaoAnteriorIterator.hasNext()) {
	// Object[] dadosAnterioresMedicaoHistorico = (Object[])
	// colecaoParmsMedicaoAnteriorIterator.next();
	//
	// if (dadosAnterioresMedicaoHistorico[7] != null) {
	// medicaoHistorico.setConsumoCreditoAnterior((Integer)
	// dadosAnterioresMedicaoHistorico[7]);
	// }
	// }
	// medicaoHistorico.setConsumoCreditoGerado(Integer.valueOf(0));
	// // Fim nova alteração - 08/10/2008
	//
	//
	// //Alteração solicitada por Aryed 10/12/2007 e realizada por Leonardo
	// Vieira na mesma data
	// //O consumo médio do hidrômetro deve ser igual ao do imóvel
	//
	// // [UC0102] - Obter Consumo Médio do Hidrômetro
	// int[] consumoMedioHidrometro = consumoMedioImovel;
	//
	// /*obterConsumoMedioHidrometro(imovel,
	// sistemaParametro, medicaoTipo);*/
	//
	// // Seta o consumo médio do hidrômetro
	// medicaoHistorico.setConsumoMedioHidrometro(Integer.valueOf(consumoMedioHidrometro[0]));
	//
	// // *******IMPRESSÃO EM TELA PARA TESTE********//
	// //System.out.println("---Consumo médio hidrômetro: " +
	// consumoMedioHidrometro[0]);
	//
	// // [SB0012] - Obter Leitura Anterior
	// int leituraAnterior = this.obterLeituraAnterior(medicaoHistorico);
	//
	// int codigoImovel = imovel.getId().intValue();
	//
	// // *******IMPRESSÃO EM TELA PARA TESTE********//
	// // System.out.println("---Leitura Anterior: " + leituraAnterior);
	// // System.out.println("---Leitura Atual Informada: " +
	// medicaoHistorico.getLeituraAtualInformada());
	//
	// // Leitura atual informada diferente de nulo
	// if (medicaoHistorico.getLeituraAtualInformada() != null) {
	//
	// // Leitura atual informada <<<MAIOR>>> que a leitura anterior obtida
	// if (medicaoHistorico.getLeituraAtualInformada().intValue() >
	// leituraAnterior) {
	//
	// // [SF0007] - Dados para Faturamento para Leitura Maior que a Anterior
	// this.dadosFaturamentoLeituraMaiorAnterior(medicaoHistorico,
	// consumoHistorico,
	// consumoMedioHidrometro[0], imovel);
	//
	// // Leitura atual informada <<<IGUAL>>> a leitura anterior obtida
	// } else if (medicaoHistorico.getLeituraAtualInformada().intValue() ==
	// leituraAnterior) {
	//
	// // [SF0008] - Dados para Faturamento para Leitura Igual a Anterior
	// this.dadosFaturamentoLeituraIgualAnterior(medicaoHistorico,
	// consumoHistorico, medicaoTipo,
	// imovel, null);
	//
	// // Leitura atual informada <<<MENOR>>> a leitura anterior obtida
	// } else if (medicaoHistorico.getLeituraAtualInformada().intValue() <
	// leituraAnterior) {
	//
	// // [SF0009] - Dados para Faturamento para Leitura Menor que a Anterior
	// this.dadosFaturamentoLeituraMenorAnterior(imovel, consumoHistorico,
	// medicaoHistorico,
	// sistemaParametro, leituraAnterior, medicaoTipo,
	// consumoMedioImovel, consumoMedioHidrometro);
	//
	// }
	//
	// // Caso a leitura atual inforamda seja igual 0 e a leitura anormalidade
	// de faturamento seja
	// nula
	// } else if (medicaoHistorico.getLeituraAtualInformada() == null &&
	// medicaoHistorico.getLeituraAnormalidadeFaturamento() == null) {
	//
	// if
	// (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){
	// // [SF0010] - Dados para Faturamento para Leitura Não Informada e Sem
	// Anormalidade de Leitura
	// this.dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(medicaoHistorico,
	// consumoHistorico, consumoMedioHidrometro, leituraAnterior);
	// } else {
	//
	// // Seta consumo igual a zero
	// consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(0));
	//
	// // Seta o tipo de consumo
	// ConsumoTipo consumoTipo = new ConsumoTipo();
	// consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);
	// consumoHistorico.setConsumoTipo(consumoTipo);
	//
	// // Seta o consumo anormalidade para leitura não informada
	// ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
	// consumoAnormalidade.setId(ConsumoAnormalidade.LEITURA_NAO_INFORMADA);
	// consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
	//
	// // Leitura atual de faturamento será a igual a anterior
	// medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
	// }
	// }
	//
	// // Sistema determina os dados para faturamento caso a anormalidade
	// // de faturamento seja diferente de nulo
	// if (medicaoHistorico.getLeituraAnormalidadeFaturamento() != null) {
	//
	// // [SF0011] - Dados para Faturamento Com Anormalidade de Leitura
	// this.dadosFaturamentoAnormalidadeLeitura(medicaoHistorico,
	// consumoHistorico,
	// consumoMedioHidrometro, leituraAnterior, imovel);
	// }
	//
	// /*
	// * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson
	// * Carvalho
	// *
	// * Sistema determina os dados para faturamento caso o imóvel esteja
	// * com situação de faturamento especial (DIFERENTE DE NULO) e que
	// * seja válido para água.
	// */
	// if (imovel.getFaturamentoSituacaoTipo() != null &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua() != null
	// &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue()
	// == 1) {
	//
	// // [SF0021] - Dados para Faturamento Especial do Medido.
	// this.dadosFaturamentoEspecialMedido(medicaoHistorico, consumoHistorico,
	// imovel,
	// consumoMedioHidrometro, leituraAnterior);
	// }
	//
	// // se não conseguiu determinar Consumo, atribui-se 0
	// if (consumoHistorico.getNumeroConsumoFaturadoMes() == null){
	// consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(0));
	// }
	//
	// // Obtém a quantidade de economias por categoria
	// Collection colecaoCategoria = getControladorImovel()
	// .obterQuantidadeEconomiasCategoria(imovel);
	//
	// // [SF0014] - Verificar Estouro de Consumo
	// if (!verificarEstouroConsumo(consumoHistorico, imovel,
	// consumoMedioImovel, consumoMedioHidrometro,
	// sistemaParametro, medicaoTipo, colecaoCategoria,
	// medicaoHistorico, leituraAnterior)) {
	//
	// // [SF0015] - Verificar Alto Consumo
	// this.verificarAltoConsumo(consumoHistorico, consumoMedioImovel,
	// colecaoCategoria, imovel,
	// medicaoTipo, medicaoHistorico);
	// }
	//
	// if ((medicaoHistorico.getLeituraSituacaoAtual().getId().intValue() ==
	// LeituraSituacao.CONFIRMADA.intValue() ||
	// medicaoHistorico.getLeituraSituacaoAtual().getId().intValue() ==
	// LeituraSituacao.REALIZADA.intValue())
	// && medicaoHistorico.getLeituraAnormalidadeFaturamento() == null) {
	//
	// // [SF0016] - Verificar Baixo Consumo
	// this.verificarBaixoConsumo(consumoHistorico, consumoMedioImovel,
	// colecaoCategoria, imovel, medicaoTipo);
	// }
	//
	// // Customização para v0.05 - vsm 11.3
	// int minimoLigacao = obterConsumoMinimoLigacao(imovel, null);
	// int creditoExistente = 0;
	// int consumoCobrado = 0;
	//
	// // Caso esteja indicado o ajuste mensal do consumo
	// if (rota.getIndicadorAjusteConsumo() != null &&
	// rota.getIndicadorAjusteConsumo().intValue()
	// == Rota.INDICADOR_AJUSTE_MENSAL) {
	//
	// // [SF0017] - Ajuste Mensal do Consumo
	// this.ajusteMensalConsumo(medicaoHistorico, consumoHistorico, imovel,
	// medicaoTipo, rota, minimoLigacao);
	// }
	//
	// // Cria o objeto consumo tipo
	// ConsumoTipo consumoTipo = new ConsumoTipo();
	// ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
	//
	// this.determinarAjusteConsumoMinimoLigacao(imovel, medicaoHistorico,
	// consumoHistorico,
	// consumoTipo, consumoAnormalidade);
	//
	// // Verifica se foi definido o consumo tipo para mínimo fixado ou
	// informado
	// if (consumoTipo.getId() != null) {
	// consumoHistorico.setConsumoTipo(consumoTipo);
	// }
	// // Verifica se foi definido uma anormalidade de consumo
	// if (consumoAnormalidade.getId() != null) {
	// consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
	// }
	//
	// if (medicaoHistorico.getConsumoCreditoAnterior() != null) {
	// creditoExistente =
	// medicaoHistorico.getConsumoCreditoAnterior().intValue();
	// }
	//
	// if (consumoHistorico.getNumeroConsumoFaturadoMes() != null) {
	// consumoCobrado =
	// consumoHistorico.getNumeroConsumoFaturadoMes().intValue();
	// }
	//
	// // Seta indefinido para ser verificado - Saulo 25/01/2009
	// if (consumoHistorico.getConsumoTipo() == null) {
	// ConsumoTipo consumoTipoTemp = new ConsumoTipo();
	// consumoTipoTemp.setId(ConsumoTipo.INDEFINIDO);
	// consumoHistorico.setConsumoTipo(consumoTipoTemp);
	// } else if (consumoHistorico.getConsumoTipo().getId() == null) {
	// consumoHistorico.getConsumoTipo().setId(ConsumoTipo.INDEFINIDO);
	// }
	//
	// if (medicaoHistorico.getConsumoCreditoAnterior() != null
	// && consumoHistorico.getConsumoTipo() != null
	// && consumoHistorico.getConsumoTipo().getId().equals(ConsumoTipo.REAL)
	// && consumoCobrado >= minimoLigacao ) {
	//
	// if (creditoExistente > 0) {
	//
	// // Seta o consumo histórico
	// consumoHistorico.setNumeroConsumoFaturadoMes(consumoCobrado +
	// creditoExistente);
	//
	// // Credito Faturado será o crédito existente;
	// consumoHistorico.setConsumoMinimoCreditado(creditoExistente);
	//
	// // Zera o credito anterior pois utilizou tudo
	// medicaoHistorico.setConsumoCreditoAnterior(Integer.valueOf(0));
	//
	// // Ajuste, pois ao utilizar todo o crédito, pode ser q o valor n seja
	// divisivel pela qtd de
	// economias
	// this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistorico,
	// consumoHistorico,
	// quantidadeEconomias);
	//
	// } else {
	// // o Consumo a Ser Cobrado no mês será o proprio consumo + crédito
	// existente limitando o
	// // resultado ao mínimo da ligação e o Crédito Faturado será o crédito
	// utilizado.
	//
	// // Pode ser utilizado todo o crédito que mesmo assim não chega ao mínimo
	// da ligação
	// if (consumoCobrado + creditoExistente >= minimoLigacao) {
	//
	// consumoHistorico.setNumeroConsumoFaturadoMes(consumoCobrado +
	// creditoExistente);
	// consumoHistorico.setConsumoMinimoCreditado(creditoExistente);
	//
	// // Zera o credito anterior pois utilizou tudo
	// medicaoHistorico.setConsumoCreditoAnterior(Integer.valueOf(0));
	//
	// // Ajuste, pois ao utilizar todo o crédito, pode ser q o valor n seja
	// divisivel pela qtd de
	// economias
	// this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistorico,
	// consumoHistorico,
	// quantidadeEconomias);
	//
	// // Não pode usar todo o crédito pois tornará o valor a ser pago menor que
	// o mínimo
	// } else {
	//
	// // Valor que seria cobrado caso pudesse ser menor que o mínimo.
	// int valorMenorQueMinimo = consumoCobrado + creditoExistente;
	//
	// // Calcula em quanto passou do mínimo
	// int valorUltrapassado = minimoLigacao - valorMenorQueMinimo;
	//
	// consumoHistorico.setNumeroConsumoFaturadoMes(minimoLigacao);
	// consumoHistorico.setConsumoMinimoCreditado(creditoExistente +
	// valorUltrapassado);
	//
	// // Atualiza o credito anterior
	// medicaoHistorico.setConsumoCreditoAnterior(medicaoHistorico.getConsumoCreditoAnterior()
	// - (creditoExistente + valorUltrapassado) );
	//
	//
	// }
	// }
	// }
	//
	// } else {
	// // [SF0004] - Determinar Dados para Faturamento de Água do Não Medido
	// ConsumoTipo consumoTipo = new ConsumoTipo();
	//
	// // Customização v0.05
	// int consumoCobradoMes = 0;
	//
	// if
	// (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO))
	// {
	//
	// // [UC0105] - Obter Consumo Mínimo da Ligação
	// consumoCobradoMes = this.obterConsumoMinimoLigacao(imovel, null);
	//
	// // Caso tenha consumo mínimo de água definido (caso exista) -> e não seja
	// inferior ao mínimo
	// da ligação
	// if (imovel.getLigacaoAgua() != null &&
	// imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua()
	// != null
	// && imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua() >=
	// consumoCobradoMes) {
	//
	// // Seta o consumo histórico - consumo a ser cobrado mês
	// consumoHistorico.setNumeroConsumoFaturadoMes(imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua());
	//
	// // Seta o consumo tipo
	// consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);
	//
	// } else {
	//
	// // Seta o consumo histórico - consumo a ser cobrado mês
	// consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoCobradoMes));
	//
	// // Seta o consumo tipo
	// consumoTipo.setId(ConsumoTipo.NAO_MEDIDO);
	// }
	//
	// // Seta o consumo tipo no consumo histórico
	// if (consumoTipo.getId() != null) {
	// consumoHistorico.setConsumoTipo(consumoTipo);
	// }
	//
	// /*
	// * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson
	// * Carvalho
	// *
	// * Sistema determina os dados para faturamento caso o imóvel esteja
	// * com situação de faturamento especial (DIFERENTE DE NULO) e que
	// * seja válido para água.
	// */
	// if (imovel.getFaturamentoSituacaoTipo() != null &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua() != null
	// &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue()
	// == 1) {
	//
	// // [SF0022] - Dados para Faturamento Especial do Não Medido.
	// this.dadosFaturamentoEspecialNaoMedido(consumoHistorico,
	// consumoMedioImovel,
	// imovel,consumoCobradoMes );
	// }
	// }
	// }
	//
	// // Caso a quantidade de economias seja maior que 1
	// if (quantidadeEconomias > 1) {
	// // [SF0018] - Ajuste do Consumo Múltiplo da Quantidade de Economias
	// this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistorico,
	// consumoHistorico,
	// quantidadeEconomias);
	// }
	//
	//
	//
	// // Seta o funcionário
	// // medicaoHistorico.setFuncionario(funcionario);
	// // Seta a data de última alteração
	// medicaoHistorico.setUltimaAlteracao(new Date());
	//
	// // Caso o imóvel possua hidromêtro com ligação de água
	// if (imovel.getLigacaoAgua() != null
	// && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) {
	//
	// if (medicaoHistorico.getId() == null) {
	// colecaoInserirMedicaoHistoricoAgua.add(medicaoHistorico);
	// } else {
	// colecaoAtualizarMedicaoHistoricoAgua.add(medicaoHistorico);
	// }
	//
	// int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());
	//
	// if (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(
	// ConstantesSistema.SIM)) {
	//
	// // Verifica se é faturamento antecipado
	// if
	// (imovel.getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
	// && (mes == 11)
	// && esferaPoder != null && esferaPoder.getId() != null
	// && (esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.MUNICIPAL))
	// || esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.ESTADUAL)) ||
	// esferaPoder.getId().equals(
	// Integer.valueOf(EsferaPoder.FEDERAL)))) {
	//
	// MedicaoHistorico medicaoHistoricoPosterior = new MedicaoHistorico();
	//
	// // Adiciona 1 ao mês/ano de faturamento para gerar o mês de dezembro
	// sistemaParametro.setAnoMesFaturamento(Util.somaMesAnoMesReferencia(sistemaParametro.getAnoMesFaturamento(),
	// 1));
	//
	// medicaoHistoricoPosterior =
	// this.obterDadosHistoricoMedicao(faturamentoGrupo, imovel,
	// medicaoTipo, sistemaParametro);
	//
	// // // [UC0102] - Obter Consumo Médio do Hidrômetro
	// // int[] consumoMedioHidrometroPosterior =
	// // obterConsumoMedioHidrometro(imovel,
	// // sistemaParametro, medicaoTipo);
	//
	// // Retorna ao mês de referência atual
	// sistemaParametro.setAnoMesFaturamento(Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(),
	// 1));
	//
	// medicaoHistoricoPosterior.setLeituraAnormalidadeFaturamento(medicaoHistorico.getLeituraAnormalidadeFaturamento());
	// medicaoHistoricoPosterior.setLeituraAnteriorFaturamento(medicaoHistorico.getLeituraAtualFaturamento());
	// medicaoHistoricoPosterior.setDataLeituraAnteriorFaturamento(medicaoHistorico.getDataLeituraAtualFaturamento());
	//
	// Date dataAtual = new Date();
	// medicaoHistoricoPosterior.setDataLeituraAtualFaturamento(Util.adicionarNumeroDiasDeUmaData(dataAtual,
	// 30));
	//
	// Integer leituraAtual = medicaoHistorico.getLeituraAtualFaturamento() +
	// consumoHistorico.getNumeroConsumoFaturadoMes();
	//
	// medicaoHistoricoPosterior.setLeituraAtualFaturamento(leituraAtual);
	//
	// // // Seta o consumo médio do hidrômetro
	// // medicaoHistoricoPosterior.setConsumoMedioHidrometro(new
	// // Integer(
	// // consumoMedioHidrometroPosterior[0]));
	//
	// medicaoHistoricoPosterior.setConsumoMedioHidrometro(medicaoHistorico.getConsumoMedioHidrometro());
	//
	// medicaoHistoricoPosterior.setUltimaAlteracao(new Date());
	//
	// if (medicaoHistoricoPosterior.getId() == null) {
	// colecaoInserirMedicaoHistoricoAgua.add(medicaoHistoricoPosterior);
	// } else {
	// colecaoAtualizarMedicaoHistoricoAgua.add(medicaoHistoricoPosterior);
	// }
	//
	// }
	//
	// }
	//
	// }
	//
	// // Seta o imóvel
	// consumoHistorico.setImovel(imovel);
	//
	// // Seta o tipo de ligação
	// LigacaoTipo ligacaoTipo = new LigacaoTipo();
	//
	// ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);
	// consumoHistorico.setLigacaoTipo(ligacaoTipo);
	//
	// // Seta a referência de faturamento
	// consumoHistorico.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
	//
	// // Seta o indicador alteração últimos consumos
	// consumoHistorico.setIndicadorAlteracaoUltimosConsumos(Short.valueOf("2"));
	//
	// // Seta o indicador ajuste
	// consumoHistorico.setIndicadorAjuste(rota.getIndicadorAjusteConsumo());
	//
	// // Seta o consumo rateio
	// consumoHistorico.setConsumoRateio(null);
	//
	// // Seta o consumo histórico condomínio
	// consumoHistorico.setConsumoHistoricoCondominio(null);
	//
	// // Seta o indicador imóvel condomínio
	// consumoHistorico.setIndicadorImovelCondominio(imovel.getIndicadorImovelCondominio());
	//
	// // Seta o consumo médio do imóvel
	// consumoHistorico.setConsumoMedio(Integer.valueOf(consumoMedioImovel[0]));
	//
	// // Seta o consumo mínimo de água
	// consumoHistorico.setConsumoMinimo(imovel.getLigacaoAgua() != null ?
	// imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua() : null);
	//
	// // Seta o percentual de coleta
	// consumoHistorico.setPercentualColeta(null);
	//
	// // Seta a última alteração
	// consumoHistorico.setUltimaAlteracao(new Date());
	//
	// // Seta o rateio tipo
	// if (consumoHistorico.getId() == null) {
	// RateioTipo rateioTipo = new RateioTipo();
	// rateioTipo.setId(RateioTipo.SEM_RATEIO);
	// consumoHistorico.setRateioTipo(rateioTipo);
	// }
	// // Seta o poco tipo
	// consumoHistorico.setPocoTipo(imovel.getPocoTipo());
	//
	// // Seta o faturamento situação tipo
	// consumoHistorico.setFaturamentoSituacaoTipo(imovel.getFaturamentoSituacaoTipo());
	//
	// /*
	// * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson
	// * Carvalho Seta o indicador de faturamento paralisação
	// */
	// if (imovel.getFaturamentoSituacaoTipo() == null) {
	// consumoHistorico.setIndicadorFaturamento(Short.valueOf("1"));
	// } else if
	// (imovel.getFaturamentoSituacaoTipo().getIndicadorParalisacaoFaturamento().intValue()
	// == 1
	// &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue()
	// == 1) {
	// consumoHistorico.setIndicadorFaturamento(Short.valueOf("2"));
	// } else {
	// consumoHistorico.setIndicadorFaturamento(Short.valueOf("1"));
	// }
	//
	// colecaoInserirConsumoHistoricoAgua.add(consumoHistorico);
	//
	// int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());
	//
	// if
	// (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM))
	// {
	//
	// // Verifica se é faturamento antecipado
	// if
	// (imovel.getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
	// && (mes == 11)
	// && esferaPoder != null && esferaPoder.getId() != null
	// && (esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.MUNICIPAL))
	// || esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.ESTADUAL)) ||
	// esferaPoder.getId().equals(
	// Integer.valueOf(EsferaPoder.FEDERAL)))) {
	//
	// ConsumoHistorico consumoHistoricoPosterior = new
	// ConsumoHistorico(consumoHistorico);
	//
	// consumoHistoricoPosterior.setReferenciaFaturamento(Util.somaMesAnoMesReferencia(consumoHistorico.getReferenciaFaturamento(),
	// 1));
	//
	// consumoHistoricoPosterior.setUltimaAlteracao(new Date());
	//
	// ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
	//
	// consumoAnormalidade.setId(ConsumoAnormalidade.FATURAMENTO_ANTEIPADO);
	//
	// consumoHistoricoPosterior.setConsumoAnormalidade(consumoAnormalidade);
	//
	// colecaoInserirConsumoHistoricoAgua.add(consumoHistoricoPosterior);
	// }
	// }
	// }

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0013] - Obter Dados
	 * do Histórico de Medição
	 */
	protected MedicaoHistorico obterDadosHistoricoMedicao(FaturamentoGrupo faturamentoGrupo, Imovel imovel, MedicaoTipo medicaoTipo,
					SistemaParametro sistemaParametro) throws ControladorException{

		MedicaoHistorico retorno = null;

		// Criação das coleções
		Collection colecaoMedicaoHistorico = null;

		// Pesquisa o histórico de medicao
		try{
			colecaoMedicaoHistorico = repositorioMicromedicao.pesquisarObterDadosHistoricoMedicao(imovel, medicaoTipo, sistemaParametro);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Pega a coleção e cria o objeto medição histórico
		MedicaoHistorico medicaoHistorico = obterHistoricoMedicao(colecaoMedicaoHistorico, imovel, medicaoTipo);

		// [FS0003 - Verificar Existência do Histórico de Medição
		retorno = verificarExistenciaHistoricoMedicao(faturamentoGrupo, medicaoHistorico, imovel, medicaoTipo, sistemaParametro);

		return retorno;
	}

	/**
	 * Método utilizado para receber uma coleção e criar e retornar um objeto do
	 * tipo medição histórico
	 */
	public MedicaoHistorico obterHistoricoMedicao(Collection colecaoMedicaoHistorico, Imovel imovel, MedicaoTipo medicaoTipo){

		MedicaoHistorico retorno = null;

		MedicaoHistorico medicaoHistorico = null;

		if(colecaoMedicaoHistorico != null && !colecaoMedicaoHistorico.isEmpty()){

			Object[] medicaoHistoricoArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoMedicaoHistorico);

			medicaoHistorico = new MedicaoHistorico();

			LigacaoAgua ligacaoAgua = new LigacaoAgua();
			LeituraSituacao leituraSituacaoAnterior = new LeituraSituacao();
			LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
			LeituraAnormalidade leituraAnormalidadeInformada = new LeituraAnormalidade();
			LeituraAnormalidade leituraAnormalidadeFaturamento = new LeituraAnormalidade();
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
			/*
			 * LeituraAnormalidadeConsumo leituraAnormalidadeConsumoComleitura =
			 * new LeituraAnormalidadeConsumo(); LeituraAnormalidadeConsumo
			 * leituraAnormalidadeConsumoSemleitura = new
			 * LeituraAnormalidadeConsumo(); LeituraAnormalidadeLeitura
			 * leituraAnormalidadeLeituraComleitura = new
			 * LeituraAnormalidadeLeitura(); LeituraAnormalidadeLeitura
			 * leituraAnormalidadeLeituraSemleitura = new
			 * LeituraAnormalidadeLeitura();
			 */

			// Seta o id do histórico de medição
			if(medicaoHistoricoArray[0] != null){
				medicaoHistorico.setId((Integer) medicaoHistoricoArray[0]);
			}

			Integer idMedicaoTipo = medicaoTipo.getId();

			if(MedicaoTipo.LIGACAO_AGUA.equals(idMedicaoTipo)){
				if(medicaoHistoricoArray[2] != null){
					ligacaoAgua.setId((Integer) medicaoHistoricoArray[2]);
					medicaoHistorico.setLigacaoAgua(ligacaoAgua);
				}
			}else if(MedicaoTipo.POCO.equals(idMedicaoTipo)){
				medicaoHistorico.setImovel(imovel);
			}

			// Seta o tipo de medição
			medicaoHistorico.setMedicaoTipo(medicaoTipo);

			// Seta o ano mês de referência
			if(medicaoHistorico != null){
				medicaoHistorico.setAnoMesReferencia(((Integer) medicaoHistoricoArray[4]).intValue());
			}

			// Seta a leitura anormalidade informada
			if(medicaoHistoricoArray[5] != null){
				leituraAnormalidadeInformada.setId((Integer) medicaoHistoricoArray[5]);
				medicaoHistorico.setLeituraAnormalidadeInformada(leituraAnormalidadeInformada);
			}

			// Seta a leitura anormalidade faturamento
			if(medicaoHistoricoArray[6] != null){
				leituraAnormalidadeFaturamento.setId((Integer) medicaoHistoricoArray[6]);

				/*
				 * if (medicaoHistoricoArray[18] != null) {
				 * leituraAnormalidadeConsumoSemleitura .setId((Integer)
				 * medicaoHistoricoArray[18]); } if (medicaoHistoricoArray[19]
				 * != null) { leituraAnormalidadeConsumoComleitura
				 * .setId((Integer) medicaoHistoricoArray[19]); } if
				 * (medicaoHistoricoArray[20] != null) {
				 * leituraAnormalidadeLeituraSemleitura .setId((Integer)
				 * medicaoHistoricoArray[20]); } if (medicaoHistoricoArray[21]
				 * != null) { leituraAnormalidadeLeituraComleitura
				 * .setId((Integer) medicaoHistoricoArray[21]); }
				 * leituraAnormalidadeFaturamento
				 * .setLeituraAnormalidadeConsumoSemleitura
				 * (leituraAnormalidadeConsumoSemleitura);
				 * leituraAnormalidadeFaturamento
				 * .setLeituraAnormalidadeConsumoComleitura
				 * (leituraAnormalidadeConsumoComleitura);
				 * leituraAnormalidadeFaturamento
				 * .setLeituraAnormalidadeLeituraSemleitura
				 * (leituraAnormalidadeLeituraSemleitura);
				 * leituraAnormalidadeFaturamento
				 * .setLeituraAnormalidadeLeituraComleitura
				 * (leituraAnormalidadeLeituraComleitura);
				 */

				medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturamento);
			}

			// Seta a leitura situação anterior
			if(medicaoHistoricoArray[7] != null){
				leituraSituacaoAnterior.setId((Integer) medicaoHistoricoArray[7]);
				medicaoHistorico.setLeituraSituacaoAnterior(leituraSituacaoAnterior);
			}

			// Seta a data de leitura anterior faturamento
			if(medicaoHistoricoArray[8] != null){
				medicaoHistorico.setDataLeituraAnteriorFaturamento((Date) medicaoHistoricoArray[8]);
			}

			// Seta a leitura anterior faturamento
			if(medicaoHistoricoArray[9] != null){
				medicaoHistorico.setLeituraAnteriorFaturamento(((Integer) medicaoHistoricoArray[9]).intValue());
			}

			// Seta a leitura anterior informada
			if(medicaoHistoricoArray[10] != null){
				medicaoHistorico.setLeituraAnteriorInformada((Integer) medicaoHistoricoArray[10]);
			}

			// Seta a leitura situação atual
			if(medicaoHistoricoArray[11] != null){
				leituraSituacaoAtual.setId((Integer) medicaoHistoricoArray[11]);
				medicaoHistorico.setLeituraSituacaoAtual(leituraSituacaoAtual);
			}

			// Seta a data leitura atual informada
			if(medicaoHistoricoArray[12] != null){
				medicaoHistorico.setDataLeituraAtualInformada((Date) medicaoHistoricoArray[12]);
			}

			// Seta a leitura atual informada
			if(medicaoHistoricoArray[13] != null){
				medicaoHistorico.setLeituraAtualInformada(((Integer) medicaoHistoricoArray[13]).intValue());
			}

			// Seta a data de leitura atual faturamento
			if(medicaoHistoricoArray[14] != null){
				medicaoHistorico.setDataLeituraAtualFaturamento((Date) medicaoHistoricoArray[14]);
			}

			// Seta a de leitura atual faturamento
			if(medicaoHistoricoArray[18] != null){
				medicaoHistorico.setLeituraAtualFaturamento(((Integer) medicaoHistoricoArray[18]).intValue());
			}

			// Seta o número consumo mês
			if(medicaoHistoricoArray[15] != null){
				medicaoHistorico.setNumeroConsumoMes((Integer) medicaoHistoricoArray[15]);
			}

			// Seta o número consumo informado
			if(medicaoHistoricoArray[16] != null){
				medicaoHistorico.setNumeroConsumoInformado((Integer) medicaoHistoricoArray[16]);
			}

			// Seta o histórico de instalação do hidrômetro
			if(medicaoHistoricoArray[17] != null){
				hidrometroInstalacaoHistorico.setId((Integer) medicaoHistoricoArray[17]);
				medicaoHistorico.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
			}

			// Seta a data de leitura processada no movimento
			if(medicaoHistoricoArray[19] != null){
				medicaoHistorico.setLeituraProcessamentoMovimento(((Date) medicaoHistoricoArray[19]));
			}

			// Seta o credito de consumos anteriores
			if(medicaoHistoricoArray[20] != null){
				medicaoHistorico.setConsumoCreditoAnterior((Integer) medicaoHistoricoArray[20]);
			}

			// Seta o funcionario
			if(medicaoHistoricoArray[21] != null){
				Funcionario funcionario = new Funcionario();
				funcionario.setId((Integer) medicaoHistoricoArray[21]);
				medicaoHistorico.setFuncionario(funcionario);
			}

			retorno = medicaoHistorico;
		}

		return retorno;
	}

	/**
	 * Método utilizado obter o consumo histórico de um imóvel de acordo com o
	 * tipo de ligação e ano mês de referência
	 */

	public ConsumoHistorico obterConsumoHistorico(Imovel imovel, LigacaoTipo ligacaoTipo, int anoMesReferencia) throws ControladorException{

		ConsumoHistorico consumoHistorico = null;

		Collection colecaoConsumoHistoricoArray = null;

		try{
			colecaoConsumoHistoricoArray = repositorioMicromedicao.pesquisarConsumoHistorico(imovel, ligacaoTipo, anoMesReferencia);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoConsumoHistoricoArray != null && !colecaoConsumoHistoricoArray.isEmpty()){

			Object[] consumoHistoricoArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoConsumoHistoricoArray);

			consumoHistorico = new ConsumoHistorico();

			// Seta o id do histórico
			if(consumoHistoricoArray[0] != null){
				consumoHistorico.setId((Integer) consumoHistoricoArray[0]);
			}
			// Seta o id do imóvel
			if(consumoHistoricoArray[1] != null){
				imovel.setId(imovel.getId());
			}
			// Seta o tipo de ligação
			if(consumoHistoricoArray[2] != null){
				consumoHistorico.setLigacaoTipo(ligacaoTipo);
			}

			// Seta o ano mes de referência
			if(consumoHistoricoArray[3] != null){
				consumoHistorico.setReferenciaFaturamento(anoMesReferencia);
			}
			// Seta o indicador de alteração dos últimos consumos
			if(consumoHistoricoArray[4] != null){
				consumoHistorico.setIndicadorAlteracaoUltimosConsumos(Short.valueOf("2"));
			}

			// Seta o indicador de ajuste
			if(consumoHistoricoArray[5] != null){
				consumoHistorico.setIndicadorAjuste((Short) consumoHistoricoArray[5]);
			}

			// Não necessário, será calculado
			// Seta o consumo a ser cobrado no mês
			/*
			 * if (consumoHistoricoArray[6] != null) { consumoHistorico
			 * .setNumeroConsumoFaturadoMes((Integer) consumoHistoricoArray[6]);
			 * }
			 */

			// Seta o consumo rateio
			if(consumoHistoricoArray[7] != null){
				consumoHistorico.setConsumoRateio((Integer) consumoHistoricoArray[7]);
			}

			// Seta o consumo histórico condomínio
			if(consumoHistoricoArray[8] != null){
				ConsumoHistorico consumoHistoricoCondominio = new ConsumoHistorico();

				consumoHistoricoCondominio.setId((Integer) consumoHistoricoArray[8]);
				consumoHistorico.setConsumoHistoricoCondominio(consumoHistoricoCondominio);
			}

			// Seta o indicador imóvel condomínio
			if(consumoHistoricoArray[9] != null){
				consumoHistorico.setIndicadorImovelCondominio((Short) consumoHistoricoArray[9]);
			}

			// Seta o consumo médio
			if(consumoHistoricoArray[10] != null){
				consumoHistorico.setConsumoMedio((Integer) consumoHistoricoArray[10]);
			}

			// Seta o consumo mínimo de água
			if(consumoHistoricoArray[11] != null){
				consumoHistorico.setConsumoMinimo((Integer) consumoHistoricoArray[11]);
			}

			// Seta o percentual de coleta
			if(consumoHistoricoArray[12] != null){
				consumoHistorico.setPercentualColeta((BigDecimal) consumoHistoricoArray[12]);
			}

			// Seta a última alteração
			if(consumoHistoricoArray[13] != null){
				consumoHistorico.setUltimaAlteracao((Date) consumoHistoricoArray[13]);
			}

			// Seta o rateio tipo
			if(consumoHistoricoArray[14] != null){
				RateioTipo rateioTipo = new RateioTipo();

				rateioTipo.setId((Integer) consumoHistoricoArray[14]);
				consumoHistorico.setRateioTipo(rateioTipo);
			}

			// Não necessário, será definido
			// Seta o consumo tipo
			/*
			 * if (consumoHistoricoArray[15] != null) { ConsumoTipo consumoTipo
			 * = new ConsumoTipo(); consumoTipo.setId((Integer)
			 * consumoHistoricoArray[15]);
			 * consumoHistorico.setConsumoTipo(consumoTipo); }
			 */

			// Não necessário, será definido
			// Seta a anormalidade de consumo
			/*
			 * if (consumoHistoricoArray[16] != null) { ConsumoAnormalidade
			 * consumoAnormalidade = new ConsumoAnormalidade();
			 * consumoAnormalidade.setId((Integer) consumoHistoricoArray[16]);
			 * consumoHistorico.setConsumoAnormalidade(consumoAnormalidade); }
			 */

			// Seta o poço tipo
			if(consumoHistoricoArray[17] != null){
				PocoTipo pocoTipo = new PocoTipo();

				pocoTipo.setId((Integer) consumoHistoricoArray[17]);
				consumoHistorico.setPocoTipo(pocoTipo);
			}

			// Seta o faturamento situação tipo
			if(consumoHistoricoArray[18] != null){
				FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();

				faturamentoSituacaoTipo.setId((Integer) consumoHistoricoArray[18]);
				consumoHistorico.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
			}

			// Seta o faturamento situação tipo
			if(consumoHistoricoArray[19] != null){
				consumoHistorico.setIndicadorFaturamento((Short) consumoHistoricoArray[19]);
			}
		}

		return consumoHistorico;
	}

	/**
	 * Método utilizado obter o consumo histórico de um imóvel de acordo com o
	 * tipo de ligação e ano mês de referência
	 */

	public ConsumoHistorico obterConsumoHistoricoCompleto(Imovel imovel, LigacaoTipo ligacaoTipo, int anoMesReferencia)
					throws ControladorException{

		ConsumoHistorico consumoHistorico = null;

		Collection colecaoConsumoHistoricoArray = null;

		try{
			colecaoConsumoHistoricoArray = repositorioMicromedicao.pesquisarConsumoHistorico(imovel, ligacaoTipo, anoMesReferencia);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoConsumoHistoricoArray != null && !colecaoConsumoHistoricoArray.isEmpty()){

			Object[] consumoHistoricoArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoConsumoHistoricoArray);

			consumoHistorico = new ConsumoHistorico();

			// Seta o id do histórico
			if(consumoHistoricoArray[0] != null){
				consumoHistorico.setId((Integer) consumoHistoricoArray[0]);
			}
			// Seta o id do imóvel
			if(consumoHistoricoArray[1] != null){
				imovel.setId(imovel.getId());
			}
			// Seta o tipo de ligação
			if(consumoHistoricoArray[2] != null){
				consumoHistorico.setLigacaoTipo(ligacaoTipo);
			}

			// Seta o ano mes de referência
			if(consumoHistoricoArray[3] != null){
				consumoHistorico.setReferenciaFaturamento(anoMesReferencia);
			}
			// Seta o indicador de alteração dos últimos consumos
			if(consumoHistoricoArray[4] != null){
				consumoHistorico.setIndicadorAlteracaoUltimosConsumos(Short.valueOf("2"));
			}

			// Seta o indicador de ajuste
			if(consumoHistoricoArray[5] != null){
				consumoHistorico.setIndicadorAjuste((Short) consumoHistoricoArray[5]);
			}

			// Seta o consumo a ser cobrado no mês
			if(consumoHistoricoArray[6] != null){
				consumoHistorico.setNumeroConsumoFaturadoMes((Integer) consumoHistoricoArray[6]);
			}

			// Seta o consumo rateio
			if(consumoHistoricoArray[7] != null){
				consumoHistorico.setConsumoRateio((Integer) consumoHistoricoArray[7]);
			}

			// Seta o consumo histórico condomínio
			if(consumoHistoricoArray[8] != null){
				ConsumoHistorico consumoHistoricoCondominio = new ConsumoHistorico();

				consumoHistoricoCondominio.setId((Integer) consumoHistoricoArray[8]);
				consumoHistorico.setConsumoHistoricoCondominio(consumoHistoricoCondominio);
			}

			// Seta o indicador imóvel condomínio
			if(consumoHistoricoArray[9] != null){
				consumoHistorico.setIndicadorImovelCondominio((Short) consumoHistoricoArray[9]);
			}

			// Seta o consumo médio
			if(consumoHistoricoArray[10] != null){
				consumoHistorico.setConsumoMedio((Integer) consumoHistoricoArray[10]);
			}

			// Seta o consumo mínimo de água
			if(consumoHistoricoArray[11] != null){
				consumoHistorico.setConsumoMinimo((Integer) consumoHistoricoArray[11]);
			}

			// Seta o percentual de coleta
			if(consumoHistoricoArray[12] != null){
				consumoHistorico.setPercentualColeta((BigDecimal) consumoHistoricoArray[12]);
			}

			// Seta a última alteração
			if(consumoHistoricoArray[13] != null){
				consumoHistorico.setUltimaAlteracao((Date) consumoHistoricoArray[13]);
			}

			// Seta o rateio tipo
			if(consumoHistoricoArray[14] != null){
				RateioTipo rateioTipo = new RateioTipo();

				rateioTipo.setId((Integer) consumoHistoricoArray[14]);
				consumoHistorico.setRateioTipo(rateioTipo);
			}

			// Seta o consumo tipo
			if(consumoHistoricoArray[15] != null){
				ConsumoTipo consumoTipo = new ConsumoTipo();

				consumoTipo.setId((Integer) consumoHistoricoArray[15]);
				consumoHistorico.setConsumoTipo(consumoTipo);
			}

			// Seta a anormalidade de consumo
			if(consumoHistoricoArray[16] != null){
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

				consumoAnormalidade.setId((Integer) consumoHistoricoArray[16]);
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
			}

			// Seta o poço tipo
			if(consumoHistoricoArray[17] != null){
				PocoTipo pocoTipo = new PocoTipo();

				pocoTipo.setId((Integer) consumoHistoricoArray[17]);
				consumoHistorico.setPocoTipo(pocoTipo);
			}

			// Seta o faturamento situação tipo
			if(consumoHistoricoArray[18] != null){
				FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();

				faturamentoSituacaoTipo.setId((Integer) consumoHistoricoArray[18]);
				consumoHistorico.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
			}

			// Seta o faturamento situação tipo
			if(consumoHistoricoArray[19] != null){
				consumoHistorico.setIndicadorFaturamento((Short) consumoHistoricoArray[19]);
			}
		}

		return consumoHistorico;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [FS0003] - Verificar
	 * Existência do Histórico de Medição
	 */
	protected MedicaoHistorico verificarExistenciaHistoricoMedicao(FaturamentoGrupo faturamentoGrupo, MedicaoHistorico medicaoHistorico,
					Imovel imovel, MedicaoTipo medicaoTipo, SistemaParametro sistemaParametro) throws ControladorException{

		MedicaoHistorico retorno = null;

		// Caso não exista histórico de medição para o hidrometro da ligação de
		// água
		if(medicaoHistorico == null){

			// medicaoHistorico = new MedicaoHistorico();
			//
			// // Caso seja ligação de água
			// if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA
			// .intValue()) {
			//
			// medicaoHistorico.setLigacaoAgua(imovel.getLigacaoAgua());
			// medicaoHistorico.setHidrometroInstalacaoHistorico(imovel
			// .getLigacaoAgua().getHidrometroInstalacaoHistorico());
			//
			// // Caso seja ligação de poço
			// } else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO
			// .intValue()) {
			//
			// medicaoHistorico.setImovel(imovel);
			// medicaoHistorico.setHidrometroInstalacaoHistorico(imovel
			// .getHidrometroInstalacaoHistorico());
			//
			// }
			//
			// medicaoHistorico
			// .setNumeroVezesConsecutivasOcorrenciaAnormalidade(new Short(
			// "0"));
			//
			// medicaoHistorico.setMedicaoTipo(medicaoTipo);
			// medicaoHistorico.setAnoMesReferencia(sistemaParametro
			// .getAnoMesFaturamento());
			//
			// String anoMes = "" + sistemaParametro.getAnoMesFaturamento();
			//
			// int anoMesAnterior = Util.subtrairMesDoAnoMes(new Integer(anoMes)
			// .intValue(), 1);
			//
			// // Define o mês de faturamento anterior
			// SistemaParametro sistemaParametroMesAnteriorFaturamento = new
			// SistemaParametro();
			//
			// sistemaParametroMesAnteriorFaturamento
			// .setAnoMesFaturamento(new Integer(anoMesAnterior)
			// .intValue());
			//
			// // Pesquisa historico medição do mês anterior
			// try {
			// colecaoMedicaoHistoricoMesAnterior = repositorioMicromedicao
			// .pesquisarObterDadosHistoricoMedicao(imovel,
			// medicaoTipo,
			// sistemaParametroMesAnteriorFaturamento);
			// } catch (ErroRepositorioException ex) {
			// // sessionContext.setRollbackOnly();
			// throw new ControladorException("erro.sistema", ex);
			// }
			//
			// // caso não seja o ano mes anterior, então pesquisa os dados
			// // anteriores de dois meses atrás
			// if (colecaoMedicaoHistoricoMesAnterior == null
			// || colecaoMedicaoHistoricoMesAnterior.isEmpty()) {
			// int anoMesDoisMesesAnteriores = Util.subtrairMesDoAnoMes(
			// new Integer(anoMes).intValue(), 2);
			// sistemaParametroMesAnteriorFaturamento
			// .setAnoMesFaturamento(anoMesDoisMesesAnteriores);
			//
			// // Pesquisa historico medição do mês anterior
			// try {
			// colecaoMedicaoHistoricoMesAnterior = repositorioMicromedicao
			// .pesquisarObterDadosHistoricoMedicao(imovel,
			// medicaoTipo,
			// sistemaParametroMesAnteriorFaturamento);
			// } catch (ErroRepositorioException ex) {
			// // sessionContext.setRollbackOnly();
			// throw new ControladorException("erro.sistema", ex);
			// }
			// }
			//
			// LeituraSituacao leituraSituacao = new LeituraSituacao();
			//
			// // Define a situação da leitura como não houve leitura
			// leituraSituacao.setId(LeituraSituacao.NAO_REALIZADA);
			//
			// // Com o valor da Data Prevista para a atividade de efetuar
			// leitura
			// // no cronograma do
			// // grupo de faturamento do mês corrente (FTAC_DTPREVISTA),
			// limitada
			// // à data corrente
			// Object[] datas =
			// obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
			// faturamentoGrupo, sistemaParametro.getAnoMesFaturamento());
			//
			// Date dataPrevista = (Date) datas[0];
			//
			// // Caso exista histórico de medição do mês anterior
			// if (colecaoMedicaoHistoricoMesAnterior != null
			// && !colecaoMedicaoHistoricoMesAnterior.isEmpty()) {
			//
			// // Pega coleção e cria o histórico de medição
			// MedicaoHistorico medicaoHistoricoMesAnterior =
			// obterHistoricoMedicao(
			// colecaoMedicaoHistoricoMesAnterior, imovel, medicaoTipo);
			//
			// // Recebe a data de leitura atual faturada do mês anterior
			// medicaoHistorico
			// .setDataLeituraAnteriorFaturamento(medicaoHistoricoMesAnterior
			// .getDataLeituraAtualFaturamento());
			// // Recebe a leitura atual faturada no mês anterior
			// medicaoHistorico
			// .setLeituraAnteriorFaturamento(medicaoHistoricoMesAnterior
			// .getLeituraAtualFaturamento());
			// // Recebe a leitura atual informada no mês anterior
			// medicaoHistorico
			// .setLeituraAnteriorInformada(medicaoHistoricoMesAnterior
			// .getLeituraAtualInformada());
			// // Recebe a situaçao da leitura atual do mês anterior
			// medicaoHistorico
			// .setLeituraSituacaoAnterior(medicaoHistoricoMesAnterior
			// .getLeituraSituacaoAtual());
			//
			// } else {
			//
			// Object[] maiorMedicaoHistorico = null;
			//
			// // Pesquisa a maior medicao histórico para o imóvel
			// try {
			// maiorMedicaoHistorico = (Object[]) repositorioMicromedicao
			// .pesquisarObterDadosMaiorHistoricoMedicao(imovel,
			// medicaoTipo, sistemaParametro);
			// } catch (ErroRepositorioException ex) {
			// // sessionContext.setRollbackOnly();
			// throw new ControladorException("erro.sistema", ex);
			// }
			//
			// if (maiorMedicaoHistorico != null) {
			//
			// medicaoHistorico
			// .setDataLeituraAnteriorFaturamento((Date)
			// maiorMedicaoHistorico[0]);
			// medicaoHistorico
			// .setLeituraAnteriorFaturamento(((Integer)
			// maiorMedicaoHistorico[1])
			// .intValue());
			// medicaoHistorico
			// .setLeituraAnteriorInformada((Integer) maiorMedicaoHistorico[2]);
			// }
			// // Caso não exista a maior medição historico
			// else {
			//
			// // e a data de Realização para a atividade de efetuar
			// // leitura no cronograma do grupo
			// // de faturamento do mês anterior (FTAC_TMREALIZACAO).
			// Integer anoMesFaturamentoAnterior = Util
			// .subtrairMesDoAnoMes(sistemaParametro
			// .getAnoMesFaturamento(), 1);
			//
			// Object[] datasAnterior =
			// obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(
			// faturamentoGrupo, anoMesFaturamentoAnterior);
			//
			// /*
			// * Alterado por Raphael Rossiter em 05/08/2007
			// * OBJ: Consistir imóveis sem leitura anterior
			// */
			// Date dataRealizada = null;
			//
			// if (datasAnterior == null) {
			// dataRealizada =
			// this.gerarDataRealizacaoLeituraAnterior(faturamentoGrupo,
			// sistemaParametro);
			// }
			// else if (datasAnterior[1] == null){
			// dataRealizada =
			// this.gerarDataRealizacaoLeituraAnterior(faturamentoGrupo,
			// sistemaParametro);
			// }
			// else{
			// dataRealizada = (Date) datasAnterior[1];
			// }
			//
			//
			// Date dataLeituraAnteriorFaturamento = null;
			//
			// // Caso seja ligação de água
			// if (medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA
			// .intValue()) {
			//
			// if (Util.compararData(dataRealizada, imovel
			// .getLigacaoAgua()
			// .getHidrometroInstalacaoHistorico()
			// .getDataInstalacao()) == 1) {
			//
			// dataLeituraAnteriorFaturamento = dataRealizada;
			// } else {
			// dataLeituraAnteriorFaturamento = imovel
			// .getLigacaoAgua()
			// .getHidrometroInstalacaoHistorico()
			// .getDataInstalacao();
			// }
			//
			// // Caso seja ligação de poço
			// } else if (medicaoTipo.getId().intValue() == MedicaoTipo.POCO
			// .intValue()) {
			//
			// if (Util.compararData(dataRealizada, imovel
			// .getHidrometroInstalacaoHistorico()
			// .getDataInstalacao()) == 1) {
			//
			// dataLeituraAnteriorFaturamento = dataRealizada;
			// } else {
			// dataLeituraAnteriorFaturamento = imovel
			// .getHidrometroInstalacaoHistorico()
			// .getDataInstalacao();
			// }
			// }
			//
			// medicaoHistorico
			// .setDataLeituraAnteriorFaturamento(dataLeituraAnteriorFaturamento);
			// }
			//
			// // Seta a situação da leitura anterior como não realizada
			// medicaoHistorico.setLeituraSituacaoAnterior(leituraSituacao);
			//
			// }
			//
			// medicaoHistorico.setDataLeituraAtualFaturamento(dataPrevista);
			// medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
			//
			// // Seja o timestamp
			// medicaoHistorico.setUltimaAlteracao(new Date());
			//
			// retorno = medicaoHistorico;
			retorno = gerarHistoricoMedicao(medicaoTipo, imovel, faturamentoGrupo, sistemaParametro);

		}else{
			// existe histórico de medição
			retorno = medicaoHistorico;
		}

		return retorno;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param faturamentoGrupo
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 */
	protected Object[] obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(FaturamentoGrupo faturamentoGrupo, Integer anoMesFaturamento)
					throws ControladorException{

		FaturamentoAtividade faturamentoAtividade = new FaturamentoAtividade();

		faturamentoAtividade.setId(FaturamentoAtividade.EFETUAR_LEITURA);

		Object[] datas = null;

		Date dataPrevista = new Date();

		// System.out.println("MES ERRO:" + anoMesFaturamento);

		try{
			datas = repositorioFaturamento.obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(faturamentoGrupo, anoMesFaturamento,
							faturamentoAtividade);

			if(datas != null){
				dataPrevista = (Date) datas[0];
				// System.out.println("DATA ERRO:" + datas[0].toString());
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Caso a data prevista seja anterior a data atual retorna true
		if(dataPrevista == null){
			System.out.println("teste");
		}
		if(datas == null){
			System.out.println("datas");
		}
		if(!dataPrevista.before(new Date()) && datas != null){
			datas[0] = (new Date());
		}

		return datas;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param numeroConsumoFaturadoMes
	 *            Descrição do parâmetro
	 * @param percentual
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 */
	public int calculoConsumoLigacaoEsgoto(int numeroConsumoFaturadoMes, BigDecimal percentual){

		BigDecimal numeroConsumoFaturadoMesAUX = new BigDecimal(numeroConsumoFaturadoMes);
		BigDecimal percentualAUX = BigDecimal.ZERO;
		if(percentual != null){
			percentualAUX = percentual.divide(new BigDecimal(100));
		}
		BigDecimal resultado = numeroConsumoFaturadoMesAUX.multiply(percentualAUX);
		Integer consumoFaturadoMesEsgoto = Integer.valueOf(resultado.intValue());

		return consumoFaturadoMesEsgoto.intValue();
	}

	/**
	 * [UC0068] - Obter Consumo Médio do Imóvel
	 * 
	 * @author eduardo henrique
	 * @date 17/01/2009 Alteração no método para não considerar meses sem
	 *       consumo, porém sem mudar o contador de meses.
	 */
	public int[] obterConsumoMedioImovel(Imovel imovel, SistemaParametro sistemaParametro) throws ControladorException{

		// Para retornar o consumo médio do imóvel
		int retorno[] = new int[2];

		retorno[0] = 0;
		retorno[1] = 0;

		// Criação de coleção
		Collection colecaoConsumoHistorico = null;

		// Obtém o périodo de meses para a média de consumo
		Short periodoInformado = sistemaParametro.getMesesMediaConsumo();

		// Ano e mês de faturamento
		int anoMesFaturamento = sistemaParametro.getAnoMesFaturamento();

		// Período informado válido para o cálculo
		int periodoInformadoValidoCalculo = periodoInformado.intValue();

		int totalConsumoFaturadoMes = 0;

		// Laço de acordo com o período informado
		for(int i = 0; i < periodoInformado.shortValue(); i++){

			// Subtrai a data (mes anterior)
			anoMesFaturamento = Util.subtrairData(anoMesFaturamento);

			// Pesquisa para obter o histórico de consumo do imóvel de acordo
			// com o período informado para obter a média de consumo
			try{
				colecaoConsumoHistorico = repositorioMicromedicao.pesquisarObterConsumoMedioImovel(imovel, anoMesFaturamento);
			}catch(ErroRepositorioException ex){
				// sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			boolean agua = false;
			boolean esgoto = false;
			int consumoFaturadoMes = 0;

			boolean periodoValido = true;

			int c = 0;
			Integer ligacaoTipo;
			Integer[] consumoTipo = new Integer[2];
			Integer[] numeroConsumoFaturadoMes = new Integer[2];
			Integer[] indentificadorLigacaoTipo = new Integer[2];
			Integer[] consumoAnormalidade = new Integer[2];
			BigDecimal[] percentualAguaConsumidaColetada = new BigDecimal[2];

			// Caso exista histórico de consumo
			if(colecaoConsumoHistorico != null && !colecaoConsumoHistorico.isEmpty()){

				Iterator iteratorColecaoConsumoHistorico = colecaoConsumoHistorico.iterator();

				// Laço para identificar se é água ou esgoto
				while(iteratorColecaoConsumoHistorico.hasNext()){

					Object[] consumoHistoricoArray = (Object[]) iteratorColecaoConsumoHistorico.next();

					ligacaoTipo = (Integer) consumoHistoricoArray[1];
					indentificadorLigacaoTipo[c] = (Integer) consumoHistoricoArray[1];
					consumoTipo[c] = (Integer) consumoHistoricoArray[2];

					consumoAnormalidade[c] = (Integer) consumoHistoricoArray[3];

					numeroConsumoFaturadoMes[c] = (Integer) consumoHistoricoArray[4];

					percentualAguaConsumidaColetada[c] = (BigDecimal) consumoHistoricoArray[5];

					// Tem água
					if(ligacaoTipo.intValue() == LigacaoTipo.LIGACAO_AGUA.intValue()){
						agua = true;
					}
					// Tem esgoto
					if(ligacaoTipo.intValue() == LigacaoTipo.LIGACAO_ESGOTO.intValue()){
						esgoto = true;
					}

					c++;

				}

				// Só tem ligação de água
				if(agua && !esgoto){
					// ALTERADO POR SÁVIO
					// verificação se os campos são nulos
					if(consumoTipo[0] != null){
						// Caso a água seja não medido

						if((consumoTipo[0].intValue() == ConsumoTipo.NAO_MEDIDO.intValue()) || numeroConsumoFaturadoMes[0] == null
										|| numeroConsumoFaturadoMes[0].intValue() == 0){
							periodoValido = false;
						}else{
							consumoFaturadoMes = numeroConsumoFaturadoMes[0].intValue();
						}
					}
				}else if(agua && esgoto){
					int indiceAgua = 0;
					int indiceEsgoto = 0;
					// ALTERADO POR SÁVIO
					// verificação se os campos são nulos
					if(indentificadorLigacaoTipo[0] != null){
						if(indentificadorLigacaoTipo[0].intValue() == LigacaoTipo.LIGACAO_AGUA.intValue()){
							indiceAgua = 0;
							indiceEsgoto = 1;
						}else{
							indiceAgua = 1;
							indiceEsgoto = 0;
						}
					}
					// ALTERADO POR SÁVIO
					// verificação se os campos são nulos
					if(consumoTipo[indiceAgua] != null && consumoTipo[indiceEsgoto] != null){
						if((consumoTipo[indiceAgua].intValue() == ConsumoTipo.NAO_MEDIDO.intValue() && consumoTipo[indiceEsgoto].intValue() == ConsumoTipo.NAO_MEDIDO
										.intValue())
										|| (numeroConsumoFaturadoMes[indiceAgua] == null && numeroConsumoFaturadoMes[indiceEsgoto] == null)
										|| (numeroConsumoFaturadoMes[indiceAgua] != null && numeroConsumoFaturadoMes[indiceEsgoto] != null
														&& numeroConsumoFaturadoMes[indiceAgua].intValue() == 0 && numeroConsumoFaturadoMes[indiceEsgoto]
														.intValue() == 0)){
							periodoValido = false;
						}else{

							consumoFaturadoMes = 0;

							if(!Util.isVazioOrNulo(numeroConsumoFaturadoMes) && numeroConsumoFaturadoMes[indiceAgua] != null){

								consumoFaturadoMes = numeroConsumoFaturadoMes[indiceAgua].intValue();
							}

							if(consumoFaturadoMes == 0){

								consumoFaturadoMes = calculoConsumoLigacaoEsgoto(numeroConsumoFaturadoMes[indiceEsgoto].intValue(),
											percentualAguaConsumidaColetada[indiceEsgoto]);
							}
						}
					}
				}else{
					// ALTERADO POR SÁVIO
					// verificação se os campos são nulos
					if(consumoTipo[0] != null){

						if(numeroConsumoFaturadoMes[0] == null || numeroConsumoFaturadoMes[0].intValue() == 0){
							periodoValido = false;
						}else{
							consumoFaturadoMes = calculoConsumoLigacaoEsgoto(numeroConsumoFaturadoMes[0].intValue(),
											percentualAguaConsumidaColetada[0]);
						}
					}
				}

				if(periodoValido){
					totalConsumoFaturadoMes += consumoFaturadoMes;
				}else{ // Somente períodos com Consumo são válidos dentre os
					// buscados
					periodoInformadoValidoCalculo--;
				}

				// Caso não exista consumo
			}else{
				periodoInformadoValidoCalculo--;
			}

		}

		// [FS0003] – Verificar o calculo da média de consumo com ou sem arrendondamento. Caso o
		// Parâmetro indicar se o consumo deverá ser ajustado para múltiplo da quantidade de
		// economias (PASI_VLPARAMETRO = SIM da tabela PARAMETRO_SISTEMA para PASI_DSPARAMETRO =
		// ‘P_AJUSTAR_CONSUMO’) calcular o consumo médio com
		// arrendondamento. Caso contrário calcular sem arrendondamento (truncar).

		if(Short.valueOf((String) ParametroFaturamento.P_AJUSTAR_CONSUMO.executar()).equals(ConstantesSistema.SIM)){
			retorno[0] = Util.dividirArredondarResultado(totalConsumoFaturadoMes, periodoInformadoValidoCalculo);
		}else{
			retorno[0] = Util.dividirTruncarResultado(totalConsumoFaturadoMes, periodoInformadoValidoCalculo);
		}

		// Retorno o período informado válido para o cáculo na posição 1;
		retorno[1] = periodoInformadoValidoCalculo;

		return retorno;
	}

	/**
	 * [UC0102] - Obter Consumo Médio do Hidrômetro Calcula o consumo médio do
	 * hidrômetro para uma quantidade de meses informada.
	 * 
	 * @author eduardo henrique
	 * @date 17/01/2009 Alteração no método para não considerar como periodo
	 *       válido, meses sem consumo.
	 */
	public int[] obterConsumoMedioHidrometro(Imovel imovel, SistemaParametro sistemaParametro, MedicaoTipo medicaoTipo)
					throws ControladorException{

		// Para retornar o consumo médio do hirdrometro
		int[] retorno = new int[2];

		retorno[0] = 0;
		retorno[1] = 0;

		// Criação de coleção
		Collection colecaoMedicaoHistorico = null;

		// Obtém o périodo de meses para a média de consumo
		int periodoInformado = sistemaParametro.getMesesMediaConsumo().intValue();

		// Ano e mês de faturamento
		int anoMesReferencia = sistemaParametro.getAnoMesFaturamento();

		// Para acumular o consumo total medido
		int totalConsumoMedidoMes = 0;

		try{

			LigacaoTipo ligacaoTipo = new LigacaoTipo();

			// Caso seja medição de ÁGUA
			if(medicaoTipo.getId() != null && medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()){

				ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

				colecaoMedicaoHistorico = repositorioMicromedicao.pesquisarConsumoMedidoHidrometroPeriodoInformadoLigacaoAgua(imovel,
								anoMesReferencia, periodoInformado, ligacaoTipo);

			}else if(medicaoTipo.getId() != null && medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()){

				ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

				colecaoMedicaoHistorico = repositorioMicromedicao.pesquisarConsumoMedidoHidrometroPeriodoInformadoPoco(imovel,
								anoMesReferencia, periodoInformado);
			}
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Período informado válido para o cálculo
		int periodoObtidoValidoCalculo = (colecaoMedicaoHistorico != null ? colecaoMedicaoHistorico.size() : 0);

		// Caso existe histórico de medição para o período informado
		if(colecaoMedicaoHistorico != null && !colecaoMedicaoHistorico.isEmpty()){

			Iterator colecaoMedicaoHistoricoIterator = colecaoMedicaoHistorico.iterator();

			while(colecaoMedicaoHistoricoIterator.hasNext()){

				Object[] medicaoHistoricoArray = (Object[]) colecaoMedicaoHistoricoIterator.next();

				Integer historicoInstalacaoHidrometroLigacaoAgua = (Integer) medicaoHistoricoArray[1];
				Integer historicoInstalacaoHidrometroMedicaoHistorico = (Integer) medicaoHistoricoArray[2];

				Integer numeroConsumoMes = 0;
				if(medicaoHistoricoArray[3] != null){
					numeroConsumoMes = (Integer) medicaoHistoricoArray[3];
				}

				// Integer consumoAnormalidade = (Integer) medicaoHistoricoArray[5];

				Integer numeroConsumoFaturadoMes = 0;
				if(medicaoHistoricoArray[6] != null){
					numeroConsumoFaturadoMes = (Integer) medicaoHistoricoArray[6];
				}

				// Caso o hidrômetro atual da ligação de água seja diferente do
				// hidrômetro do histórico de medição
				// e o consumo seja 0
				if(historicoInstalacaoHidrometroMedicaoHistorico == null || historicoInstalacaoHidrometroLigacaoAgua == null){

					// if(numeroConsumoMes != null){
					totalConsumoMedidoMes += numeroConsumoMes.intValue();
					// }

				}else if((historicoInstalacaoHidrometroLigacaoAgua.intValue() != historicoInstalacaoHidrometroMedicaoHistorico.intValue())
								|| numeroConsumoMes == null || numeroConsumoMes.intValue() == 0){

					periodoObtidoValidoCalculo -= 1;

				}else if(medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()){
					totalConsumoMedidoMes += numeroConsumoFaturadoMes.intValue();
				}else if(medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()){
					Integer numeroConsumoFaturadoMesAgua = null;
					try{
						numeroConsumoFaturadoMesAgua = this.repositorioMicromedicao.pesquisarConsumoFaturadoMesPorConsumoHistorico(imovel
										.getId(), anoMesReferencia, LigacaoTipo.LIGACAO_AGUA);
					}catch(ErroRepositorioException ex){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}

					if(numeroConsumoFaturadoMesAgua != null){
						totalConsumoMedidoMes += (numeroConsumoFaturadoMes.intValue() - numeroConsumoFaturadoMesAgua.intValue());
					}else{
						totalConsumoMedidoMes += numeroConsumoFaturadoMes.intValue();
					}
				}else{
					totalConsumoMedidoMes += numeroConsumoMes.intValue();
				}
			}
		}

		retorno[0] = Util.dividirArredondarResultado(totalConsumoMedidoMes, periodoObtidoValidoCalculo);
		retorno[1] = periodoObtidoValidoCalculo;

		return retorno;
	}

	/**
	 * Método para obter a coleção de um período informado (quantidade de meses)
	 * e de acordo com o mes e ano de referencia
	 */
	/*
	 * protected Collection obterColecaoPeriodoInformado(int periodoInformado,
	 * int mesAnoReferencia, Filtro filtro, Imovel imovel, MedicaoTipo
	 * medicaoTipo) throws ControladorException { Collection retorno = null; //
	 * Obtém a coleção de acordo com - > MEDIÇÃO HISTÓRICO if (filtro instanceof
	 * FiltroMedicaoHistorico) { FiltroMedicaoHistorico filtroMedicaoHistorico =
	 * (FiltroMedicaoHistorico) filtro; ParametroSimples parametroSimples = new
	 * ParametroSimples( FiltroMedicaoHistorico.IMOVEL_ID, imovel.getId()); //
	 * Laço de acordo com o período informado for (int i = 0; i <
	 * periodoInformado; i++) { mesAnoReferencia =
	 * Util.subtrairData(mesAnoReferencia); // Adiciona o parametro de acordo
	 * como o período informado filtroMedicaoHistorico.adicionarParametro(new
	 * ParametroSimples( FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO,
	 * new Integer(mesAnoReferencia), ParametroSimples.CONECTOR_AND)); } //
	 * Define o filtro de acordo com o tipo de medição filtroMedicaoHistorico
	 * .adicionarParametro(new ParametroSimples(
	 * FiltroMedicaoHistorico.MEDICAO_TIPO_ID, medicaoTipo .getId())); //
	 * Realiza a pesquisa try { retorno =
	 * repositorioUtil.pesquisar(filtroMedicaoHistorico,
	 * MedicaoHistorico.class.getName()); } catch (ErroRepositorioException ex)
	 * { sessionContext.setRollbackOnly(); throw new
	 * ControladorException("erro.sistema", ex); } } return retorno; }
	 */

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0012] - Obter
	 * Leitura Anterior
	 */
	protected int obterLeituraAnterior(MedicaoHistorico medicaoHistorico){

		int retorno = 0;
		int leituraAnteriorFaturamento = 0;

		if(medicaoHistorico.getLeituraAnteriorFaturamento() != null){
			leituraAnteriorFaturamento = medicaoHistorico.getLeituraAnteriorFaturamento();
		}

		if(medicaoHistorico.getLeituraAnteriorInformada() != null && medicaoHistorico.getLeituraAtualInformada() != null){

			if(medicaoHistorico.getLeituraAnteriorInformada().intValue() == medicaoHistorico.getLeituraAtualInformada().intValue()){
				retorno = medicaoHistorico.getLeituraAnteriorInformada().intValue();
			}else{
				retorno = leituraAnteriorFaturamento;
			}

		}else{

			retorno = leituraAnteriorFaturamento;
		}

		return retorno;
	}

	/**
	 * [UC0086] - Calcular Faixa de Leitura Esperada
	 */
	public int[] calcularFaixaLeituraEsperada(int media, MedicaoHistorico medicaoHistorico, Hidrometro hidrometro,
					Integer leituraAnteriorPesquisada){

		int[] retorno = new int[2];

		// Criação de variáveis
		BigDecimal faixaInicial = null;
		BigDecimal faixaFinal = null;

		BigDecimal leituraAnterior = null;

		// Alterado por Sávio data:20/03/2007
		// Caso seja usado o método pelo consistirLeituraECalcularConsumo então
		// a leituraAnteriorPesquisada vem nulo para ser calculado a leitura
		// anterior
		if(leituraAnteriorPesquisada == null){
			leituraAnterior = new BigDecimal(obterLeituraAnterior(medicaoHistorico));
			// Essa situação vem do gerarDadosParaLeitura que já vem com a
			// leituraAnteriorPesquisada
		}else{
			leituraAnterior = new BigDecimal(leituraAnteriorPesquisada);
		}

		BigDecimal mediaConsumo = new BigDecimal(media);

		// Caso a média seja até 10
		if(media <= 10){
			faixaInicial = leituraAnterior;
			faixaFinal = leituraAnterior.add(mediaConsumo).add(new BigDecimal(10));
		}
		// Caso a média seja de 11 a 20
		else if(media >= 11 && media <= 20){
			faixaInicial = leituraAnterior.add((new BigDecimal(0.4)).multiply(mediaConsumo));
			faixaFinal = leituraAnterior.add((new BigDecimal(1.6)).multiply(mediaConsumo));
		}
		// Caso a média seja de 21 a 45
		else if(media >= 21 && media <= 45){
			faixaInicial = leituraAnterior.add((new BigDecimal(0.5)).multiply(mediaConsumo));
			faixaFinal = leituraAnterior.add((new BigDecimal(1.5)).multiply(mediaConsumo));
		}
		// Caso a média seja seja de 46 a 100
		else if(media >= 46 && media <= 100){
			faixaInicial = leituraAnterior.add((new BigDecimal(0.6)).multiply(mediaConsumo));
			faixaFinal = leituraAnterior.add((new BigDecimal(1.4)).multiply(mediaConsumo));
		}else if(media > 100){
			faixaInicial = leituraAnterior.add((new BigDecimal(0.7)).multiply(mediaConsumo));
			faixaFinal = leituraAnterior.add((new BigDecimal(1.3)).multiply(mediaConsumo));
		}

		int[] faixaEsperada = new int[2];

		// Faixa Inicial
		faixaEsperada[0] = Util.arredondar(faixaInicial);

		// Faixa Final
		faixaEsperada[1] = Util.arredondar(faixaFinal);

		retorno = verificarViradaHidrometroFaixaEsperada(hidrometro, faixaEsperada);

		return retorno;
	}

	/**
	 * [UC0086] - Calcular Faixa de Leitura Esperada [FS0001] - Verificar Virada
	 * do Hidrômetro
	 */
	protected int[] verificarViradaHidrometroFaixaEsperada(Hidrometro hidrometro, int[] faixaEsperada){

		// Obtém o número de digitos da leitura
		int numeroDigitosLeitura = hidrometro.getNumeroDigitosLeitura().intValue();

		// 10 elevado ao número de digitos leitura
		Double valor = new Double((Math.pow(10.0, numeroDigitosLeitura)));
		int valorDigitos = valor.intValue() - 1;

		// Faixa Inicial
		if(faixaEsperada[0] > valorDigitos){
			faixaEsperada[0] = faixaEsperada[0] - valor.intValue();

		}

		// Faixa Final
		if(faixaEsperada[1] > valorDigitos){
			faixaEsperada[1] = faixaEsperada[1] - valor.intValue();
		}

		return faixaEsperada;
	}

	/**
	 * Método utlizado para receber uma coleção e retornar um objeto do tipo
	 * Anormalidade de Leitura
	 */
	public LeituraAnormalidade obterAnormalidadeLeitura(Collection colecaoAnormalidadeLeitura){

		// Cria os objetos
		LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
		LeituraAnormalidadeConsumo leituraAnormalidadeConsumoSemLeitura = new LeituraAnormalidadeConsumo();
		LeituraAnormalidadeConsumo leituraAnormalidadeConsumoComLeitura = new LeituraAnormalidadeConsumo();
		LeituraAnormalidadeLeitura leituraAnormalidadeLeituraSemLeitura = new LeituraAnormalidadeLeitura();
		LeituraAnormalidadeLeitura leituraAnormalidadeLeituraComLeitura = new LeituraAnormalidadeLeitura();

		// Verifica se a coleção é nula
		if(colecaoAnormalidadeLeitura != null && !colecaoAnormalidadeLeitura.isEmpty()){

			Object[] anormalidadeLeituraArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoAnormalidadeLeitura);

			// Seta o id da anormalidade de leitura
			if(anormalidadeLeituraArray[0] != null){
				leituraAnormalidade.setId((Integer) anormalidadeLeituraArray[0]);

				// Seta o consumo sem leitura
				if(anormalidadeLeituraArray[1] != null){
					leituraAnormalidadeConsumoSemLeitura.setId((Integer) anormalidadeLeituraArray[1]);
				}

				// Seta o consumo com leitura
				if(anormalidadeLeituraArray[2] != null){
					leituraAnormalidadeConsumoComLeitura.setId((Integer) anormalidadeLeituraArray[2]);
				}

				// Seta a leitura sem leitura
				if(anormalidadeLeituraArray[3] != null){
					leituraAnormalidadeLeituraSemLeitura.setId((Integer) anormalidadeLeituraArray[3]);
				}

				// Seta a leitura com leitura
				if(anormalidadeLeituraArray[4] != null){
					leituraAnormalidadeLeituraComLeitura.setId((Integer) anormalidadeLeituraArray[4]);
				}

				// Seta o indicador crédito consumo
				if(anormalidadeLeituraArray[5] != null){
					leituraAnormalidade.setIndicadorCreditoConsumo((Short) anormalidadeLeituraArray[5]);
				}

				// Associa seta a anormalidade de leitura
				leituraAnormalidade.setLeituraAnormalidadeConsumoSemleitura(leituraAnormalidadeConsumoSemLeitura);
				leituraAnormalidade.setLeituraAnormalidadeConsumoComleitura(leituraAnormalidadeConsumoComLeitura);
				leituraAnormalidade.setLeituraAnormalidadeLeituraSemleitura(leituraAnormalidadeLeituraSemLeitura);
				leituraAnormalidade.setLeituraAnormalidadeLeituraComleitura(leituraAnormalidadeLeituraComLeitura);
			}

		}

		// Retorna a anormalidade de leitura
		return leituraAnormalidade;

	}

	/**
	 * Método utlizado para receber uma coleção e retornar um objeto do tipo
	 * faturamento situação tipo
	 */

	public FaturamentoSituacaoTipo obterFaturamentoSituacaoTipo(Collection colecaoFaturamentoSituacaoTipo){

		// Cria os objetos
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
		LeituraAnormalidadeConsumo leituraAnormalidadeConsumoSemLeitura = new LeituraAnormalidadeConsumo();
		LeituraAnormalidadeConsumo leituraAnormalidadeConsumoComLeitura = new LeituraAnormalidadeConsumo();
		LeituraAnormalidadeLeitura leituraAnormalidadeLeituraSemLeitura = new LeituraAnormalidadeLeitura();
		LeituraAnormalidadeLeitura leituraAnormalidadeLeituraComLeitura = new LeituraAnormalidadeLeitura();

		// Verifica se a coleção é nula
		if(colecaoFaturamentoSituacaoTipo != null && !colecaoFaturamentoSituacaoTipo.isEmpty()){

			Object[] faturamentoSituacaoTipoArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoFaturamentoSituacaoTipo);

			// Seta o id da anormalidade de leitura
			if(faturamentoSituacaoTipoArray[0] != null){
				faturamentoSituacaoTipo.setId((Integer) faturamentoSituacaoTipoArray[0]);

				// Seta o consumo sem leitura
				if(faturamentoSituacaoTipoArray[1] != null){
					leituraAnormalidadeConsumoSemLeitura.setId((Integer) faturamentoSituacaoTipoArray[1]);
				}

				// Seta o consumo com leitura
				if(faturamentoSituacaoTipoArray[2] != null){
					leituraAnormalidadeConsumoComLeitura.setId((Integer) faturamentoSituacaoTipoArray[2]);
				}

				// Seta a leitura sem leitura
				if(faturamentoSituacaoTipoArray[3] != null){
					leituraAnormalidadeLeituraSemLeitura.setId((Integer) faturamentoSituacaoTipoArray[3]);
				}

				// Seta a leitura com leitura
				if(faturamentoSituacaoTipoArray[4] != null){
					leituraAnormalidadeLeituraComLeitura.setId((Integer) faturamentoSituacaoTipoArray[4]);
				}

				// Associa seta a anormalidade de leitura
				faturamentoSituacaoTipo.setLeituraAnormalidadeConsumoSemLeitura(leituraAnormalidadeConsumoSemLeitura);
				faturamentoSituacaoTipo.setLeituraAnormalidadeConsumoComLeitura(leituraAnormalidadeConsumoComLeitura);
				faturamentoSituacaoTipo.setLeituraAnormalidadeLeituraSemLeitura(leituraAnormalidadeLeituraSemLeitura);
				faturamentoSituacaoTipo.setLeituraAnormalidadeLeituraComLeitura(leituraAnormalidadeLeituraComLeitura);
			}

		}

		// Retorna a anormalidade de leitura
		return faturamentoSituacaoTipo;

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos.
	 * [SF0011] - Dados para Faturamento com Anormalidade de Leitura
	 * 
	 * @author virginia melo
	 * @author eduardo henrique
	 * @date 11/12/2008 Correção da definição do crédito de consumo quando a
	 *       anormalidade indica que deve ser concedido crédito de consumo
	 */
	protected void dadosFaturamentoComAnormalidadeLeitura(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico,
					int consumoMedioImovel, int leituraAnterior, Imovel imovel, int consumoMinimoLigacao) throws ControladorException{

		Collection colecaoAnormalidadeLeitura = null;

		try{

			// Pesquisa a anormalidade de leitura de faturamento
			colecaoAnormalidadeLeitura = repositorioMicromedicao.pesquisarAnormalidadeLeitura(medicaoHistorico
							.getLeituraAnormalidadeFaturamento());

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém a leitura anormalidade
		LeituraAnormalidade leituraAnormalidade = obterAnormalidadeLeitura(colecaoAnormalidadeLeitura);

		// Seta a leitura anormalidade faturamento
		medicaoHistorico.getLeituraAnormalidadeFaturamento().setLeituraAnormalidadeConsumoSemleitura(
						leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura());
		medicaoHistorico.getLeituraAnormalidadeFaturamento().setLeituraAnormalidadeConsumoComleitura(
						leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura());
		medicaoHistorico.getLeituraAnormalidadeFaturamento().setLeituraAnormalidadeLeituraSemleitura(
						leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura());
		medicaoHistorico.getLeituraAnormalidadeFaturamento().setLeituraAnormalidadeLeituraComleitura(
						leituraAnormalidade.getLeituraAnormalidadeLeituraComleitura());
		medicaoHistorico.getLeituraAnormalidadeFaturamento().setIndicadorCreditoConsumo(leituraAnormalidade.getIndicadorCreditoConsumo());

		MedicaoTipo medicaoTipo = medicaoHistorico.getMedicaoTipo();

		// Identifica o hidrometro de acordo com o tipo de medição
		Hidrometro hidrometro = null;

		// Caso o tipo de medição seja <<<LIGACAO DE ÁGUA>>>
		if(medicaoTipo.getId() == MedicaoTipo.LIGACAO_AGUA){

			hidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro();
		}else if(medicaoTipo.getId() == MedicaoTipo.POCO){

			// Caso seja medição de <<<POÇO>>>
			hidrometro = imovel.getHidrometroInstalacaoHistorico().getHidrometro();
		}

		/*
		 * O sistema determina o consumo e a leitura para faturamento de acordo com os parâmetros
		 * definidos para a Anormalidade de Leitura de Faturamento
		 */

		// Leitura Atual Informada com o valor nulo (Leitura Não informada)
		if(medicaoHistorico.getLeituraAtualInformada() == null){

			if((medicaoTipo.getId().equals(MedicaoTipo.LIGACAO_AGUA) && imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
							.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO))
							|| medicaoTipo.getId().equals(MedicaoTipo.POCO)){

				/*
				 * Consumo a Ser Cobrado no Mês (LACS_IDCONSUMOACOBRARSEMLEITURA com os seguintes
				 * valores na tabela LEITURA_ANORMALIDADE_CONSUMO):
				 */
				if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoSemleitura() != null){

					// Não ocorre
					if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoSemleitura().getId().intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
									.intValue()){

						// O Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
						consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedioImovel));

						// O Tipo de Consumo será o valor correspondente à “média do imóvel”
						consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_HIDROMETRO));

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoSemleitura().getId()
									.intValue() == LeituraAnormalidadeConsumo.MINIMO.intValue()){

						// Mínimo
						// O Tipo de Consumo será o valor correspondente a “consumo mínimo”
						consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.CONSUMO_MINIMO_FIXADO));

						// Caso seja para tratar mínimo com valor zero (0)
						/*
						 * Parametro que indica valor atribuído ao consumo do mês quando for
						 * definida a
						 * cobrança de mínimo na consistência de leitura
						 */
						String parametroCobrancaConsumoMinimo = (String) ParametroMicromedicao.P_COBRANCA_CONSUMO_MINIMO.executar(this, 0);

						// Caso seja para tratar mínimo com valor zero (0)
						if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.DOIS.getValor())){

							// O Consumo Ser Cobrado no Mês será igual a zero (0)
							consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
						}else{

							/*
							 * O Consumo a Ser Cobrado no Mês será o mínimo da ligação <<Inclui>>
							 * [UC0105 –
							 * Obter Consumo Mínimo da Ligação]
							 */
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
						}
					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoSemleitura().getId()
									.intValue() == LeituraAnormalidadeConsumo.MEDIA.intValue()){

						/*
						 * Parametro que indica a regra a ser utilizada quando a média for igual a
						 * zero
						 * (0).
						 */
						String parametroTratamentoMediaZerada = (String) ParametroMicromedicao.P_TRATAMENTO_MEDIA_ZERADA.executar(this, 0);

						/* O sistema Calcula Consumo a Ser Cobrado no Mês */
						if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.UM.getValor())){

							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
						}else if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.DOIS.getValor())){

							// Caso o consumo médio do imóvel seja igual “zero”
							if(consumoMedioImovel == 0){

								/*
								 * Consumo a Ser Cobrado no Mês será o Consumo Medido
								 * (MDHI_NNCONSUMOMEDIDOMES),
								 * caso esse seja maior que zero, caso contrário, o Consumo a Ser
								 * Cobrado no
								 * Mês
								 * será o mínimo da ligação <<Inclui>> [UC0105 – Obter Consumo
								 * Mínimo da
								 * Ligação]
								 */
								if(medicaoHistorico.getNumeroConsumoMes() != null && medicaoHistorico.getNumeroConsumoMes() > 0){

									consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoMes());
								}else{

									int consumoMinimo = 0;
									consumoMinimo = obterConsumoMinimoLigacao(imovel, null);
									consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimo);
								}
							}else{

								// Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
								consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
							}
						}

						// O Tipo de Consumo será o valor correspondente à “média do imóvel”
						consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));
					}
				}

				/*
				 * Leitura Atual de Faturamento (LALT_IDLEITURAAFATURARSEMLEITURA com os seguintes
				 * valores correspondentes na tabela LEITURA_ANORMALIDADE_LEITURA):
				 */
				if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraSemleitura() != null){

					// Não ocorre
					if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraSemleitura().getId().intValue() == LeituraAnormalidadeLeitura.NAO_OCORRE
									.intValue()){

						/*
						 * Anterior mais a média : A Leitura atual de faturamento será a anterior
						 * mais a
						 * média
						 */
						medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior + consumoMedioImovel);
					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraSemleitura().getId()
									.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA.intValue()){

						/*
						 * Anterior mais a média : A Leitura atual de faturamento será a anterior
						 * mais a
						 * média
						 */
						medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior + consumoMedioImovel);

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraSemleitura().getId()
									.intValue() == LeituraAnormalidadeLeitura.ANTERIOR.intValue()){

						// Anterior: A Leitura atual de faturamento será a igual a anterior
						medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraSemleitura().getId()
									.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO.intValue()){

						/*
						 * Anterior mais o consumo: A Leitura Atual de Faturamento será a anterior
						 * mais
						 * o
						 * Consumo a Ser Cobrado no Mês
						 */
						medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior
										+ consumoHistorico.getNumeroConsumoFaturadoMes().intValue());
					}
				}
			}else{

				// Faturamento Situação não ativo Consumo a ser cobrado no mês será zero
				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(0));

				// O Tipo de Consumo será o valor correspondente à “sem consumo”
				consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.SEM_CONSUMO));

				// Leitura atual de faturamento será a igual a anterior
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
			}
		}else if(medicaoHistorico.getLeituraAtualInformada() != null){

			// Leitura Atual Informada com o valor diferente de nulo (Leitura Informada)

			if((medicaoTipo.getId().equals(MedicaoTipo.LIGACAO_AGUA) && (imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao()
							.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO) || (imovel.getLigacaoAguaSituacao()
							.getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.NAO_FATURAVEL)
							&& consumoHistorico.getNumeroConsumoFaturadoMes() != null && consumoHistorico.getNumeroConsumoFaturadoMes()
							.intValue() > 0)))
							|| medicaoTipo.getId().equals(MedicaoTipo.POCO)){

				// Caso o Fator de conversão do Hidrômetro instalado no Imóvel esteja informado
				Integer consumoCalculadoMes = null;
				if(hidrometro.getFatorConversao() != null){

					/*
					 * Consumo Calculado = Consumo a Ser Cobrado no Mês * Fator de conversão do
					 * Hidrômetro
					 */
					consumoCalculadoMes = Util.arredondar(new BigDecimal(consumoHistorico.getNumeroConsumoFaturadoMes())
									.multiply(hidrometro.getFatorConversao()));
				}else{

					consumoCalculadoMes = consumoHistorico.getNumeroConsumoFaturadoMes();
				}

				/*
				 * Consumo a Ser Cobrado no Mês (LACS_IDCONSUMOACOBRARCOMLEITURA com os seguintes
				 * valores correspondentes na tabela LEITURA_ANORMALIDADE_CONSUMO)
				 */
				if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoComleitura() != null){

					// Não ocorre
					if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoComleitura().getId().intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
									.intValue()){

						// O Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

						// O Tipo de Consumo será o valor correspondente à “média do imóvel”
						consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoComleitura().getId()
									.intValue() == LeituraAnormalidadeConsumo.MINIMO.intValue()){

						// Mínimo
						// O Tipo de Consumo será o valor correspondente a “consumo mínimo”
						consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.CONSUMO_MINIMO_FIXADO));

						// Caso seja para tratar mínimo com valor zero (0)
						/*
						 * Parametro que indica valor atribuído ao consumo do mês quando for
						 * definida a
						 * cobrança de mínimo na consistência de leitura
						 */
						String parametroCobrancaConsumoMinimo = (String) ParametroMicromedicao.P_COBRANCA_CONSUMO_MINIMO.executar(this, 0);

						// Caso seja para tratar mínimo com valor zero (0)
						if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.DOIS.getValor())){

							// O Consumo Ser Cobrado no Mês será igual a zero (0)
							consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
						}else{

							/*
							 * O Consumo a Ser Cobrado no Mês será o mínimo da ligação <<Inclui>>
							 * [UC0105 –
							 * Obter Consumo Mínimo da Ligação]
							 */
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
						}

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoComleitura().getId()
									.intValue() == LeituraAnormalidadeConsumo.MEDIA.intValue()){

						/*
						 * Parametro que indica a regra a ser utilizada quando a média for igual a
						 * zero
						 * (0).
						 */
						String parametroTratamentoMediaZerada = (String) ParametroMicromedicao.P_TRATAMENTO_MEDIA_ZERADA.executar(this, 0);

						/* O sistema Calcula Consumo a Ser Cobrado no Mês */
						if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.UM.getValor())){

							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
						}else if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.DOIS.getValor())){

							// Caso o consumo médio do imóvel seja igual “zero”
							if(consumoMedioImovel == 0){

								/*
								 * Consumo a Ser Cobrado no Mês será o Consumo Medido
								 * (MDHI_NNCONSUMOMEDIDOMES),
								 * caso esse seja maior que zero, caso contrário, o Consumo a Ser
								 * Cobrado no
								 * Mês
								 * será o mínimo da ligação <<Inclui>> [UC0105 – Obter Consumo
								 * Mínimo da
								 * Ligação]
								 */
								if(medicaoHistorico.getNumeroConsumoMes() != null && medicaoHistorico.getNumeroConsumoMes() > 0){

									consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoMes());
								}else{

									int consumoMinimo = 0;
									consumoMinimo = obterConsumoMinimoLigacao(imovel, null);
									consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimo);
								}
							}else{

								// Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
								consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
							}
						}

						// O Tipo de Consumo será o valor correspondente à “média do imóvel”
						consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoComleitura().getId()
									.intValue() == LeituraAnormalidadeConsumo.NORMAL.intValue()){

						// Normal: Consumo a ser cobrado no mês será o já calculado
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculadoMes);

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoComleitura().getId()
									.intValue() == LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_IMOVEL_CONSUMO_CALCULADO.intValue()){

						/*
						 * Maior entre o consumo médio do imóvel e o consumo calculado: o Consumo a
						 * Ser
						 * Cobrado no Mês será o maior entre o Consumo Médio do Imóvel e o Consumo a
						 * Ser
						 * Cobrado no Mês já calculado.
						 */
						if(consumoMedioImovel > consumoCalculadoMes.intValue()){

							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

						}else{

							consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculadoMes);
						}

						// O Tipo de Consumo será o valor correspondente à “média do imóvel”
						consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));
					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeConsumoComleitura().getId()
									.intValue() == LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_IMOVEL_CONSUMO_CALCULADO.intValue()){

						/*
						 * Menor entre o consumo médio do imóvel e o consumo calculado: o Consumo a
						 * Ser
						 * Cobrado no Mês será o maior entre o Consumo Médio do Imóvel e o Consumo a
						 * Ser
						 * Cobrado no Mês já calculado.
						 */
						if(consumoMedioImovel < consumoCalculadoMes.intValue()){

							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

						}else{

							consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculadoMes);
						}

						// O Tipo de Consumo será o valor correspondente à “média do imóvel”
						consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));
					}
				}

				/*
				 * Leitura Atual de Faturamento (LALT_IDLEITURAAFATURARCOMLEITURA com os seguintes
				 * valores correspondentes na tabela LEITURA_ANORMALIDADE_LEITURA):
				 */
				if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraComleitura() != null){

					if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraComleitura().getId().intValue() == LeituraAnormalidadeLeitura.NORMAL
									.intValue()){

						medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraComleitura().getId()
									.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA.intValue()){

						// <<anterior mais média>>
						// A Leitura Atual de Faturamento será a anterior mais a média
						medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior + consumoMedioImovel);

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraComleitura().getId()
									.intValue() == LeituraAnormalidadeLeitura.ANTERIOR.intValue()){

						// <<anterior>>
						// Leitura Atual de Faturamento será igual à anterior
						medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraComleitura().getId()
									.intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO.intValue()){

						// <<anterior mais consumo>>
						// A Leitura Atual de Faturamento será a anterior mais o Consumo a Ser
						// Cobrado
						// no Mês
						medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior + consumoCalculadoMes);

					}else if(medicaoHistorico.getLeituraAnormalidadeFaturamento().getLeituraAnormalidadeLeituraComleitura().getId()
									.intValue() == LeituraAnormalidadeLeitura.INFORMADA.intValue()){

						// A Leitura Atual de Faturamento será a Leitura Atual Informada
						medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());
					}
				}
			}else{

				// Faturamento Situação não ativo Consumo a ser cobrado no mês será zero
				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(0));

				// O Tipo de Consumo será o valor correspondente à “sem consumo”
				consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.SEM_CONSUMO));

				// Leitura atual de faturamento será a igual a anterior
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
			}
		}

		/*
		 * Caso a anormalidade indique que deve ser concedido crédito de consumo
		 * (LTAN_ICCREDITOCONSUMO = 1 da tabela LEITURA_ANORMALIDADE), o Crédito Gerado será o
		 * Consumo a Ser Cobrado no Mês com sinal negativo
		 */

		if(medicaoHistorico.getLeituraAnormalidadeFaturamento() != null
						&& medicaoHistorico.getLeituraAnormalidadeFaturamento().getIndicadorCreditoConsumo() != null
						&& medicaoHistorico.getLeituraAnormalidadeFaturamento().getIndicadorCreditoConsumo() == 1){

			Integer consumoCobrado = consumoHistorico.getNumeroConsumoFaturadoMes().intValue();

			if(consumoCobrado > 0){

				consumoCobrado = consumoCobrado * -1;
			}

			// O Crédito Gerado será o Consumo a Ser Cobrado no Mês com sinal
			// negativo.
			medicaoHistorico.setConsumoCreditoGerado(consumoCobrado);

			Integer consumoCreditoAnterior = medicaoHistorico.getConsumoCreditoAnterior();
			if(consumoCreditoAnterior == null){

				consumoCreditoAnterior = Integer.valueOf(0);
			}

			medicaoHistorico.setConsumoCreditoAnterior(consumoCreditoAnterior + medicaoHistorico.getConsumoCreditoGerado());
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param consumoMedioImovel
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	/*
	 * protected int[]
	 * obterConsumoTotalReferenciaConsumoMedioFatorMultiplicacao( Imovel imovel,
	 * int[] consumoMedioImovel) throws ControladorException { int[] retorno =
	 * new int[1]; try { int consumoTotalReferencia = 0; // Cria o filtro de
	 * Imóvel SubCategoria FiltroImovelSubCategoria filtroImovelSubCategoria =
	 * new FiltroImovelSubCategoria(); // Cria e define o parametro para o
	 * filtro de imóvel subcategoria ParametroSimples parametroSimples = new
	 * ParametroSimples( FiltroImovelSubCategoria.IMOVEL_ID, imovel.getId()); //
	 * Pesquisar colecao de Imóvel Subcategoria Collection
	 * colecaoImovelSubCategoria = repositorioUtil.pesquisar(
	 * filtroImovelSubCategoria, ImovelSubcategoria.class .getName()); int
	 * maiorQuantidadeEconomias = 0; // Cria objeto categoria Categoria
	 * categoria = new Categoria(); BigDecimal consumoMedioFatorMultiplicacao =
	 * null; // Verifica se a coleção retornou objetos if
	 * (colecaoImovelSubCategoria != null &&
	 * !colecaoImovelSubCategoria.isEmpty()) { Iterator
	 * colecaoImovelSubCategoriaIterator = colecaoImovelSubCategoria
	 * .iterator(); while (colecaoImovelSubCategoriaIterator.hasNext()) { //
	 * Obtém o Imóvel Subcategoria ImovelSubcategoria imovelSubcategoria =
	 * (ImovelSubcategoria) colecaoImovelSubCategoriaIterator .next(); // Obtém
	 * o consumo de referência int consumoReferencia =
	 * (imovelSubcategoria.getComp_id() .getSubcategoria().getCategoria()
	 * .getConsumoEstouro().intValue() * imovelSubcategoria
	 * .getQuantidadeEconomias()); // Obtém a quantidade de economias int
	 * quantidadeEconomias = imovelSubcategoria .getQuantidadeEconomias(); //
	 * Verifica qual a maior quantidade de economias if (quantidadeEconomias >
	 * maiorQuantidadeEconomias) { maiorQuantidadeEconomias =
	 * quantidadeEconomias; // Obtém a categoria com a maior quantidade de
	 * economias categoria = imovelSubcategoria.getComp_id()
	 * .getSubcategoria().getCategoria(); } // Acumula o consumo total de
	 * referência consumoTotalReferencia += consumoReferencia; } // Armazena o
	 * consumo médio do imóvel BigDecimal consumoMedioImovel1 = new BigDecimal(
	 * consumoMedioImovel[0]); // Obtém o consumo médio X fator de multiplicação
	 * consumoMedioFatorMultiplicacao = consumoMedioImovel1
	 * .multiply(categoria.getVezesMediaEstouro()); // Arredonda o consumo médio
	 * consumoMedioFatorMultiplicacao = consumoMedioFatorMultiplicacao
	 * .setScale(0, BigDecimal.ROUND_UP); } else { // Caso a coleção não tenha
	 * retornado objetos sessionContext.setRollbackOnly(); throw new
	 * ControladorException( "atencao.nao_cadastrado.imovel_subcategoria",
	 * null); } // Armazena o consumo total de referência retorno[0] =
	 * consumoTotalReferencia; // Armazena o consumo médio fator multiplicação
	 * retorno[1] = consumoMedioFatorMultiplicacao.intValue(); } catch
	 * (ErroRepositorioException ex) { sessionContext.setRollbackOnly(); throw
	 * throw new ControladorException("erro.sistema", ex); } return retorno; }
	 */

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0015] - Verificar
	 * Alto Consumo
	 * 
	 * @author Eduardo Henrique
	 * @date 28/11/2008 - Correção na Obtenção do Consumo Anterior
	 * @author eduardo henrique
	 * @date 12/12/2008 - Correção na definição do Consumo Atual
	 * @author eduardo hernique
	 * @date 17/01/2009 - Correção para situação de Consumo Zero (não verificar
	 *       AC se consumo Atual 0) ou se ConsumoAnterior não existir, não
	 *       verificar AC.
	 * @throws ControladorException
	 */
	protected boolean verificarAltoConsumo(ConsumoHistorico consumoHistorico, int consumoMedioImovel, Collection colecaoCategoria,
					Imovel imovel, MedicaoTipo medicaoTipo, MedicaoHistorico medicaoHistorico, int leituraAnterior, int consumoMinimoLigacao)
					throws ControladorException{

		// O sistema determina se houve alto consumo
		boolean retorno = false;

		/*
		 * Parametro que indica o critério utilizado para determinar um alto consumo
		 */
		String parametroCriterioAltoConsumo = (String) ParametroMicromedicao.P_CRITERIO_ALTO_CONSUMO.executar(this, 0);

		/* O sistema Calcula Consumo a Ser Cobrado no Mês */
		if(parametroCriterioAltoConsumo.equals(CriterioAltoConsumo.UM.getValor())){

			ConsumoHistorico consumoHistoricoAnterior = new ConsumoHistorico();
			ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
			BigDecimal consumoAnterior = new BigDecimal(0);
			BigDecimal consumoAtual = new BigDecimal(0);

			// Obtém o ano e mês de referência anterior
			Integer anoMesReferenciaAtual = Integer.valueOf(consumoHistorico.getReferenciaFaturamento());
			Integer anoMesReferenciaAnterior = Util.subtrairData(anoMesReferenciaAtual);
			// Collection consumoHistoricoAnteriorColecao = null;

			// Cria o objeto ligação tipo
			LigacaoTipo ligacaoTipo = new LigacaoTipo();

			// Caso a medição seja para água o tipo de ligação é de água
			if(medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()){
				ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);
			}else if(medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()){
				ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
			}

			// Pesquisa o consumo histórico

			// Verifica se a pesquisa retornou algo
			consumoHistoricoAnterior = this.obterConsumoHistoricoCompleto(imovel, ligacaoTipo, anoMesReferenciaAnterior);

			// Consumo Anterior não encontrado (não verificar AC)
			if(consumoHistoricoAnterior == null){
				return false;
			}

			if(consumoHistoricoAnterior != null && consumoHistoricoAnterior.getNumeroConsumoFaturadoMes() != null){
				consumoAnterior = new BigDecimal(consumoHistoricoAnterior.getNumeroConsumoFaturadoMes());
			}

			// seta o consumo Atual
			if(consumoHistorico.getNumeroConsumoFaturadoMes() != null){
				consumoAtual = new BigDecimal(consumoHistorico.getNumeroConsumoFaturadoMes());
			}
			// Consumo Zero (não verificar AC)
			if(consumoAtual.compareTo(BigDecimal.ZERO) <= 0){
				return false;
			}

			BigDecimal limite = consumoAnterior.add(consumoAnterior.multiply(new BigDecimal(1.7)));

			/*
			 * Caso o Consumo a Ser Cobrado no Mês seja maior ou igual a 170% do Consumo Anterior, o
			 * sistema gera a Anormalidade de Consumo com o valor correspondente a “alto consumo” da
			 * tabela CONSUMO_ANORMALIDADE, sendo mantidos o Consumo a Ser Cobrado no Mês e a
			 * Leitura Atual de Faturamento
			 */
			if(consumoAtual.compareTo(limite) >= 0){

				consumoAnormalidade.setId(ConsumoAnormalidade.ALTO_CONSUMO);
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
				retorno = true;
			}

			// Obtém a ocorrência de anormalidade
			Integer indicadorAnormalidade = Integer.valueOf(0);

			if(medicaoHistorico.getLeituraAnormalidadeFaturamento() != null
							&& medicaoHistorico.getLeituraAnormalidadeFaturamento().getId() != null){

				indicadorAnormalidade = medicaoHistorico.getLeituraAnormalidadeFaturamento().getId();
			}

			BigDecimal consumoMedio = BigDecimal.ZERO;
			consumoMedio = new BigDecimal(Integer.valueOf(consumoMedioImovel).toString());

			/*
			 * Caso seja detectada ocorrência de “vazamento interno” ou “vazamento após o
			 * hidrômetro”, o sistema verifica o direito ao desconto de alto consumo
			 */
			if(indicadorAnormalidade == LeituraAnormalidade.VAZAMENTO_INTERNO
							|| indicadorAnormalidade == LeituraAnormalidade.VAZAMENTO_APOS_HIDROMETRO){

				int qtdEconomias = Integer.valueOf(0);
				Boolean descontoAltoConsumoDoze = false;
				BigDecimal valorComDesconto = new BigDecimal(consumoHistorico.getNumeroConsumoFaturadoMes());

				// Obtendo a quantidade de economias
				qtdEconomias = getControladorImovel().obterQuantidadeEconomias(imovel);

				// Verifica se foi concedido desconto de ALTO CONSUMO nos
				// últimos doze meses.
				descontoAltoConsumoDoze = verificarDescontoAltoConsumoUltimosDozeMeses(imovel, anoMesReferenciaAnterior);

				/*
				 * Caso o Consumo a Ser Cobrado seja maior que trinta vezes o total de economias e
				 * (maior que a média ou maior que o Consumo Anterior) e não tenha sido concedido
				 * desconto de alto consumo nos últimos doze meses, o sistema aplica desconto de 50%
				 * sobre o Consumo a Ser Cobrado e gera a Anormalidade de Consumo com o valor
				 * correspondente a “alto consumo com desconto”
				 */
				if((consumoHistorico.getNumeroConsumoFaturadoMes().intValue() > (qtdEconomias * 30)) && !descontoAltoConsumoDoze){

					BigDecimal desconto = new BigDecimal(consumoHistorico.getNumeroConsumoFaturadoMes() * 0.5);
					valorComDesconto = new BigDecimal(consumoHistorico.getNumeroConsumoFaturadoMes()).subtract(desconto);
					consumoHistorico.setNumeroConsumoFaturadoMes(valorComDesconto.intValue());

					consumoAnormalidade.setId(ConsumoAnormalidade.ALTO_CONSUMO_COM_DESCONTO);
					consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
				}

				/*
				 * Caso o consumo calculado com o desconto seja maior ou igual a oito vezes a média,
				 * o Consumo a Ser Cobrado será igual a cinco vezes a média
				 */
				if(valorComDesconto.compareTo(consumoMedio.multiply(new BigDecimal(8))) >= 0){

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedio.multiply(new BigDecimal(5)).intValue());
				}

				retorno = true;
			}

			/*
			 * Caso seja detectada ocorrência de “sem justificativa alto consumo” e o Consumo a Ser
			 * Cobrado seja maior ou igual a cinco vezes a média, o Consumo a Ser Cobrado será igual
			 * a três vezes a média
			 */
			if(indicadorAnormalidade == LeituraAnormalidade.ALTO_CONSUMO_SEM_JUSTIFICATIVA
							&& (new BigDecimal(consumoHistorico.getNumeroConsumoFaturadoMes())).compareTo(consumoMedio
											.multiply(new BigDecimal(5))) >= 0){

				retorno = true;
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedio.multiply(new BigDecimal(3)).intValue());

			}
		}else if(parametroCriterioAltoConsumo.equals(CriterioAltoConsumo.DOIS.getValor())){

			retorno = this.verificarAltoConsumoPorQuantidadeEconomiasNaoPublico(consumoHistorico, consumoMedioImovel, imovel, medicaoTipo,
							medicaoHistorico, leituraAnterior, consumoMinimoLigacao);
		}else if(parametroCriterioAltoConsumo.equals(CriterioAltoConsumo.TRES.getValor())){

			retorno = this.verificarAltoConsumoPorQuantidadeEconomias(consumoHistorico, consumoMedioImovel, imovel, medicaoTipo,
							medicaoHistorico, leituraAnterior, consumoMinimoLigacao);
		}

		return retorno;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0016] - Verificar
	 * Baixo Consumo Customização para v0.05
	 * 
	 * @author Virgínia Melo
	 * @author Eduardo Henrique
	 * @date 28/11/2008 - Correção na Obtenção do Consumo Anterior
	 * @date 29/06/2009 - Correção para não atribuir Baixo Consumo caso consumo
	 *       Anterior seja 0 (Zero).
	 */
	protected void verificarBaixoConsumo(ConsumoHistorico consumoHistorico, int consumoMedioImovel, Collection colecaoCategoria,
					Imovel imovel, MedicaoTipo medicaoTipo, int consumoMinimoLigacao, MedicaoHistorico medicaoHistorico)
					throws ControladorException{

		// Parâmetro que indica o critério utilizado para determinar um baixo consumo
		String parametroCriterioBaixoConsumo = (String) ParametroMicromedicao.P_CRITERIO_BAIXO_CONSUMO.executar(this, 0);

		// Caso o valor indique Pelo Consumo Anterior
		if(parametroCriterioBaixoConsumo.equals(CriterioBaixoConsumo.UM.getValor())){

			BigDecimal consumoAtual = new BigDecimal(0);
			BigDecimal consumoAnterior = new BigDecimal(0);
			ConsumoHistorico consumoHistoricoAnterior = new ConsumoHistorico();

			// Obtém o ano e mês de referência anterior
			int anoMesReferenciaAnterior = Util.subtrairData(Integer.parseInt(Util.formatarMesAnoParaAnoMesSemBarra(consumoHistorico
							.getMesAno())));

			// Cria o objeto ligação tipo
			LigacaoTipo ligacaoTipo = new LigacaoTipo();

			// Caso a medição seja para água o tipo de ligação é de água
			if(medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()){
				ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);
			}else if(medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()){
				ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
			}

			// Verifica se a pesquisa retornou algo
			consumoHistoricoAnterior = this.obterConsumoHistoricoCompleto(imovel, ligacaoTipo, anoMesReferenciaAnterior);

			if(consumoHistoricoAnterior != null && consumoHistoricoAnterior.getNumeroConsumoFaturadoMes() != null){
				consumoAnterior = new BigDecimal(consumoHistoricoAnterior.getNumeroConsumoFaturadoMes());
			}

			if(consumoHistorico.getNumeroConsumoFaturadoMes() != null){
				consumoAtual = new BigDecimal(consumoHistorico.getNumeroConsumoFaturadoMes().intValue());
			}

			if(consumoAnterior.compareTo(BigDecimal.ZERO) <= 0){
				return;
			}

			// Mudança para considerar baixo consumo apenas se for até 70% do
			// consumo anterior
			if(consumoAtual.compareTo(consumoAnterior.multiply(new BigDecimal(0.7))) <= 0){

				/*
				 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “baixo
				 * consumo”
				 */
				ConsumoAnormalidade consumoAnormalidade = null;
				try{

					consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.BAIXO_CONSUMO);
				}catch(ErroRepositorioException ex){

					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

				// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
				this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico, consumoMedioImovel,
								consumoMinimoLigacao, consumoAnormalidade, consumoAtual.intValue());
			}
		}else if(parametroCriterioBaixoConsumo.equals(CriterioBaixoConsumo.DOIS.getValor())){

			// Caso contrário, caso indique Pelo Consumo Médio
			this
							.verificarBaixoConsumoPeloConsumoMedio(consumoHistorico, consumoMedioImovel, imovel, consumoMinimoLigacao,
											medicaoHistorico);
		}

	}

	/**
	 * [UC0105] - Obter Consumo Mínimo da Ligação
	 */
	public int obterConsumoMinimoLigacao(Imovel imovel, Collection colecaoCategorias) throws ControladorException{

		// Declaração de variáveis
		int consumoMinimoLigacao = 0;

		// Declaração de objetos
		Collection colecaoDataVigencia = null;
		Integer consumoMinimo = null;
		boolean icExisteContratoDemandaConsumoVigente = false;
		
		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();

		// Consulta por Contrato de Demanda de Consumo Vigente
		FiltroContratoDemandaConsumo filtroContratoDemandaConsumo = new FiltroContratoDemandaConsumo();
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.IMOVEL_ID, imovel.getId()));
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.INDICADORENCERRAMENTO,
						ConstantesSistema.NAO));
		filtroContratoDemandaConsumo.adicionarParametro(new ParametroNaoNulo(FiltroContratoDemandaConsumo.NN_CONSUMO_FIXO));

		try{
			Collection<ContratoDemandaConsumo> colContratoDemandaConsumo = repositorioUtil.pesquisar(filtroContratoDemandaConsumo,
							ContratoDemandaConsumo.class.getName());

			if(!colContratoDemandaConsumo.isEmpty()){
				ContratoDemandaConsumo contratoDemandaConsumo = (ContratoDemandaConsumo) Util
								.retonarObjetoDeColecao(colContratoDemandaConsumo);

				consumoMinimo = contratoDemandaConsumo.getNumeroConsumoFixo();
				icExisteContratoDemandaConsumoVigente = true;

			}else{

				// [FS0001] - Obter tarifa válida para o imóvel
				Integer idConsumoTarifa = this.obterTarifaValidaParaImovel(imovel);
				// Obtém o id do consumo tarifa vigência da maior data de vigência da
				// tarifa do imóvel
				colecaoDataVigencia = repositorioMicromedicao.pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(), idConsumoTarifa);

				// Obtém o id do array e atribui na variável
				Object[] consumoTarifaVigenciaIdArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoDataVigencia);
				Integer consumoTarifaVigenciaId = null;

				if(consumoTarifaVigenciaIdArray == null){
					// String usada para "SimularCalculoConta", no qual não vem o Id do
					// imóvel.
					String mensagemImovel = "na simulação";
					if(imovel != null && imovel.getId() != null){
						mensagemImovel = String.valueOf(imovel.getId());
					}
					throw new ControladorException("atencao.nao_cadastrada_consumo_tarifa_vigencia", null, mensagemImovel);
				}

				if(consumoTarifaVigenciaIdArray[0] != null){
					consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0];
				}

				consumoTarifaVigencia.setId(consumoTarifaVigenciaId);
			}
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// [UC0108] - Obter Quantidade de Economias por Categoria
		if(colecaoCategorias == null){
			colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
		}

		Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();

		while(colecaoCategoriasIterator.hasNext()){

			Categoria categoria = (Categoria) colecaoCategoriasIterator.next();

			try{

				if(!icExisteContratoDemandaConsumoVigente){
					// Obtém o consumo mínimo da tarifa da categoria do imóvel
					Object consumoMinimoObjeto = repositorioMicromedicao.pesquisarConsumoMinimoTarifaCategoriaVigencia(categoria,
									consumoTarifaVigencia);

					consumoMinimo = (Integer) consumoMinimoObjeto;
				}

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if(consumoMinimo != null){
				// Multiplica a quantidade de economias da categoria pelo
				// consumo
				// mínimo e acumula
				consumoMinimoLigacao = consumoMinimoLigacao
								+ (categoria.getQuantidadeEconomiasCategoria().intValue() * consumoMinimo.intValue());
			}

		}

		// Retorna o consumo mínimo da ligação
		return consumoMinimoLigacao;
	}

	/**
	 * [UC0105] - Obter Consumo Mínimo da Ligação
	 * [FS0001] - Obter tarifa válida para o imóvel
	 */
	private Integer obterTarifaValidaParaImovel(Imovel imovel) throws ControladorException{

		Integer idConsumoTarifa = imovel.getConsumoTarifa().getId();
		ConsumoTarifa consumoTarifaTemporaria = null;

		if(imovel != null && imovel.getId() != null){

			// [FS0001] - Obter tarifa válida para o imóvel
			try{
				SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
				// Caso exista contrato de demanda de consumo vigente para o imóvel e tarifa de
				// consumo não esteja vazia
				FiltroContratoDemandaConsumo filtroContratoDemandaConsumo = new FiltroContratoDemandaConsumo();
				filtroContratoDemandaConsumo
								.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.IMOVEL_ID, imovel.getId()));
				filtroContratoDemandaConsumo.adicionarParametro(new ParametroSimples(FiltroContratoDemandaConsumo.INDICADORENCERRAMENTO,
								ConstantesSistema.NAO));
				filtroContratoDemandaConsumo.adicionarParametro(new MenorQue(FiltroContratoDemandaConsumo.ANOMESFATURAMENTOINICIO,
								sistemaParametro.getAnoMesFaturamento()));
				filtroContratoDemandaConsumo.adicionarParametro(new MaiorQue(FiltroContratoDemandaConsumo.ANOMESFATURAMENTOFIM,
								sistemaParametro.getAnoMesFaturamento()));
				filtroContratoDemandaConsumo.adicionarParametro(new ParametroNaoNulo(FiltroContratoDemandaConsumo.CONSUMO_TARIFA));

				Collection<ContratoDemandaConsumo> colContratoDemandaConsumo = repositorioUtil.pesquisar(filtroContratoDemandaConsumo,
								ContratoDemandaConsumo.class.getName());

				if(!colContratoDemandaConsumo.isEmpty()){

					ContratoDemandaConsumo contratoDemandaConsumo = (ContratoDemandaConsumo) Util
									.retonarObjetoDeColecao(colContratoDemandaConsumo);

					idConsumoTarifa = contratoDemandaConsumo.getConsumoTarifa().getId();

				}else{

					consumoTarifaTemporaria = repositorioMicromedicao.obterConsumoTarifaTemporariaImovel(imovel.getId());

					if(consumoTarifaTemporaria != null){

						idConsumoTarifa = consumoTarifaTemporaria.getId();
					}

				}
			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}

		return idConsumoTarifa;
	}

	/**
	 * [UC0105] - Obter Consumo Mínimo da Ligação no Período informado
	 * 
	 * @author Virgínia Melo
	 * @date 18/03/2009
	 */
	public int obterConsumoMinimoLigacaoPeriodo(Imovel imovel, Collection colecaoCategorias, String mesAnoConta,
					Integer idConsumoTarifaConta) throws ControladorException{

		int consumoMinimoLigacao = 0;
		Collection colecaoDataVigencia = null;
		Integer consumoMinimo = null;

		// Subtraindo 1 mês da referência
		// int referenciaConta = Integer.parseInt(mesAnoConta);
		DateFormat formatter = new SimpleDateFormat("MM/yyyy");
		Date referenciaMesAnoConta = null;
		Boolean barraEncontrada = false;
		String mesAnoContaComBarra = null;

		for(int i = 0; i < mesAnoConta.length(); i++){
			if(mesAnoConta.charAt(i) == '/'){
				barraEncontrada = true;
			}
		}

		if(!barraEncontrada){
			NumberFormat nf = NumberFormat.getInstance();
			Integer mesAnoContaInteger = null;
			try{
				Long mesAnoContaLong = (Long) nf.parse(mesAnoConta);
				mesAnoContaInteger = Integer.valueOf(mesAnoContaLong.toString());
			}catch(ParseException e){
				new ControladorException("erro.sistema", e);
			}

			mesAnoContaComBarra = Util.formatarAnoMesSemBarraParaMesAnoComBarra(mesAnoContaInteger);
		}else{
			mesAnoContaComBarra = mesAnoConta;
		}

		try{
			referenciaMesAnoConta = (Date) formatter.parse(mesAnoContaComBarra);
		}catch(ParseException e){
			new ControladorException("erro.sistema", e);
		}

		int referenciaConta = Util.getAnoMesComoInt(referenciaMesAnoConta);
		// referenciaConta = Util.subtrairMesDoAnoMes(referenciaConta, 1);

		// Recuperando data
		int mesConta = Util.obterMes(Integer.valueOf(referenciaConta));
		int anoConta = Util.obterAno(Integer.valueOf(referenciaConta));
		int ultimoDiaMes = Integer.valueOf(Util.obterUltimoDiaMes(mesConta, anoConta));

		Date dataLeitura = Util.criarData(ultimoDiaMes, mesConta, anoConta);

		// Usar o consumoTarifa do imóvel no caso de 'inserirConta' pois nessa
		// situação esse campo
		// vem nulo.
		if(idConsumoTarifaConta == null){
			if(imovel != null && imovel.getConsumoTarifa() != null){
				idConsumoTarifaConta = imovel.getConsumoTarifa().getId();
			}else{
				throw new ControladorException("atencao.consumo_tarifa_nao_identificado");
			}
		}

		try{
			// Obtém o id do consumoTarifaVigência de acordo com a data
			// informada.
			colecaoDataVigencia = repositorioMicromedicao.pesquisarDataVigenciaConsumoTarifaPeriodo(dataLeitura, idConsumoTarifaConta);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém o id do array e atribui na variável
		Object[] consumoTarifaVigenciaIdArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoDataVigencia);
		Integer consumoTarifaVigenciaId = null;

		if(consumoTarifaVigenciaIdArray == null){

			// String usada para "SimularCalculoConta", no qual não vem o Id do
			// imóvel.
			String mensagemImovel = "na simulação";

			if(imovel != null && imovel.getId() != null){
				mensagemImovel = String.valueOf(imovel.getId());
			}

			throw new ControladorException("atencao.nao_cadastrada_consumo_tarifa_vigencia", null, mensagemImovel);
		}

		if(consumoTarifaVigenciaIdArray[0] != null){
			consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0];
		}

		// Cria o objeto consumo tarifa vigência e seta o id
		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		consumoTarifaVigencia.setId(consumoTarifaVigenciaId);

		// [UC0108] - Obter Quantidade de Economias por Categoria
		if(colecaoCategorias == null){
			colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
		}

		Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();

		while(colecaoCategoriasIterator.hasNext()){

			Categoria categoria = (Categoria) colecaoCategoriasIterator.next();

			try{

				// Obtém o consumo mínimo da tarifa da categoria do imóvel
				Object consumoMinimoObjeto = repositorioMicromedicao.pesquisarConsumoMinimoTarifaCategoriaVigencia(categoria,
								consumoTarifaVigencia);
				consumoMinimo = (Integer) consumoMinimoObjeto;

			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if(consumoMinimo != null){

				// Multiplica a quantidade de economias da categoria pelo
				// consumo mínimo e acumula
				consumoMinimoLigacao = consumoMinimoLigacao
								+ (categoria.getQuantidadeEconomiasCategoria().intValue() * consumoMinimo.intValue());
			}
		}

		// Retorna o consumo mínimo da ligação
		return consumoMinimoLigacao;
	}

	/**
	 * < <Descrição do método>>
	 */
	/*
	 * protected Collection obterQuantidadeEconomiasCategoria(Imovel imovel) {
	 * //Criação das coleções Collection retorno = null; Collection
	 * colecaoCategoria = null; //Filtro para obter o imóvel subcategoria
	 * FiltroImovelSubCategoria filtroImovelSubCategoria = new
	 * FiltroImovelSubCategoria(); ParametroSimples parametroSimples = new
	 * ParametroSimples( filtroImovelSubCategoria.IMOVEL_ID, imovel.getId());
	 * //Pesquisa imóvel subcategoria passado como parâmetro um imóvel
	 * Collection colecaoImovelSubCategoria =
	 * pesquisar(filtroImovelSubCategoria, ImovelSubcategoria.class.getName());
	 * if (colecaoImovelSubCategoria != null &&
	 * !colecaoImovelSubCategoria.isEmpty()) { Iterator
	 * colecaoImovelSubCategoriaIterator = colecaoImovelSubCategoria.iterator();
	 * int idCategoria = 0; int idCategoriaFixa = 0; boolean primeiroId = true;
	 * int totalQuantidadeEconomiasPorCategoria = 0; while
	 * (colecaoImovelSubCategoriaIterator.hasNext()) { //Obtém o imóvel
	 * subcategoria ImovelSubcategoria imovelSubcategoria = (ImovelSubcategoria)
	 * colecaoImovelSubCategoriaIterator.next(); //Obtém a quantidade de
	 * economias int quantidadeEconomias =
	 * imovelSubcategoria.getQuantidadeEconomias(); //Obtém o id da categoria
	 * idCategoria = imovelSubcategoria.getComp_id().getSubcategoria().
	 * getCategoria().getId().intValue(); //Cria os objetos categoria Categoria
	 * categoria = new Categoria(); Categoria categoriaAnterior = new
	 * Categoria(); //Acumula a quantidade de economias por categoria
	 * totalQuantidadeEconomiasPorCategoria += quantidadeEconomias; //Seta a
	 * categoria categoria.setId(new Integer(idCategoria));
	 * categoria.setQuantidadeEconomiasCategoria(
	 * totalQuantidadeEconomiasPorCategoria); //Verifica se é o primeiro objeto
	 * da coleção if (primeiroId) { //Armazena o id da categoria idCategoriaFixa
	 * = idCategoria; //Deixa se ser o primeiro objeto da coleção primeiroId =
	 * false; //Verifica se o id mudou } else if (idCategoria !=
	 * idCategoriaFixa) { idCategoriaFixa = idCategoria; //O total de quantidade
	 * de economias recebe novo valor sem acumular
	 * totalQuantidadeEconomiasPorCategoria = quantidadeEconomias;
	 * categoria.setQuantidadeEconomiasCategoria(
	 * totalQuantidadeEconomiasPorCategoria); //Caso ainda tenha mais objetos na
	 * coleção adiciona a anterior if
	 * (colecaoImovelSubCategoriaIterator.hasNext()) {
	 * colecaoCategoria.add(categoriaAnterior); } } //Caso a coleção só tenha
	 * apenas um imóvel subcategoria if
	 * (!colecaoImovelSubCategoriaIterator.hasNext()) {
	 * colecaoCategoria.add(categoria); } else { //Armazena a categoria para que
	 * possa ser utilizada posteriormente categoriaAnterior.setId(new
	 * Integer(idCategoria)); categoriaAnterior.setQuantidadeEconomiasCategoria(
	 * totalQuantidadeEconomiasPorCategoria); } } } else { //Caso a coleção não
	 * tenha retornado objetos throw new ControladorException(
	 * "atencao.nao_cadastrado.imovel_subcategoria", null); } return
	 * colecaoCategoria; }
	 */

	/**
	 * < <Descrição do método>>
	 */
	/*
	 * protected int obterQuantidadeEconomias(Imovel imovel) { //Filtro para
	 * obter o imóvel subcategoria FiltroImovelSubCategoria
	 * filtroImovelSubCategoria = new FiltroImovelSubCategoria();
	 * ParametroSimples parametroSimples = new
	 * ParametroSimples(filtroImovelSubCategoria.IMOVEL_ID, imovel.getId());
	 * //Pesquisa imóvel subcategoria passado como parâmetro um imóvel
	 * Collection colecaoImovelSubCategoria =
	 * pesquisar(filtroImovelSubCategoria, ImovelSubcategoria.class.getName());
	 * int totalQuantidadeEconomias = 0; if (colecaoImovelSubCategoria != null
	 * && !colecaoImovelSubCategoria.isEmpty()) { Iterator
	 * colecaoImovelSubCategoriaIterator = colecaoImovelSubCategoria.iterator();
	 * while (colecaoImovelSubCategoriaIterator.hasNext()) { //Obtém o imóvel
	 * subcategoria ImovelSubcategoria imovelSubcategoria = (ImovelSubcategoria)
	 * colecaoImovelSubCategoriaIterator.next(); //Obtém a quantidade de
	 * economias int quantidadeEconomias =
	 * imovelSubcategoria.getQuantidadeEconomias(); //Acumula a quantidade de
	 * economias por categoria totalQuantidadeEconomias += quantidadeEconomias;
	 * } } else { //Caso a coleção não tenha retornado objetos throw new
	 * ControladorException("atencao.nao_cadastrado.imovel_subcategoria", null);
	 * } return totalQuantidadeEconomias; }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param medicaoHistorico
	 *            Descrição do parâmetro
	 * @param consumoHistorico
	 *            Descrição do parâmetro
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param faturamentoGrupo
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param medicaoTipo
	 *            Descrição do parâmetro
	 * @param consumoMedioImovel
	 *            Descrição do parâmetro
	 * @param consumoHistoricoLigacaoAgua
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	/*
	 * protected void determinarDadosFaturamentoEsgotoMedidoPoco(
	 * MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico,
	 * Imovel imovel, FaturamentoGrupo faturamentoGrupo, SistemaParametro
	 * sistemaParametro, MedicaoTipo medicaoTipo, int[] consumoMedioImovel,
	 * ConsumoHistorico consumoHistoricoLigacaoAgua) throws ControladorException
	 * { medicaoHistorico = new MedicaoHistorico(); if (consumoHistorico ==
	 * null) { consumoHistorico = new ConsumoHistorico(); } // Obtém o histórico
	 * de medição medicaoHistorico =
	 * obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo,
	 * sistemaParametro); // Obtém consumo médio do hidrometro int[]
	 * consumoMedioHidrometro = obterConsumoMedioHidrometro(imovel,
	 * sistemaParametro, medicaoTipo); // Determinar o consumo medido do mês, o
	 * consumo a ser cobrado no mês e // a leitura atual de faturamento int
	 * leituraAnterior = 0; // Caso a leitura atual informada diferente de zero
	 * if (medicaoHistorico.getLeituraAtualInformada() != null) { // Obtém a
	 * leitura anterior leituraAnterior =
	 * obterLeituraAnterior(medicaoHistorico); // Caso leitura atual informada
	 * maior que a leitura anterior if
	 * (medicaoHistorico.getLeituraAtualInformada() > leituraAnterior) { //
	 * Definir dados para faturamento para leitura MAIOR que a // anterior
	 * dadosFaturamentoLeituraMaiorAnterior(medicaoHistorico, consumoHistorico,
	 * consumoMedioHidrometro[0], imovel); // Caso a leitura atual informada
	 * igual a leitura anterior } else if
	 * (medicaoHistorico.getLeituraAtualInformada() == leituraAnterior) { //
	 * Definir dados para faturamento leitura IGUAL a anteior
	 * dadosFaturamentoLeituraIgualAnterior(medicaoHistorico, consumoHistorico,
	 * medicaoTipo, imovel); // Caso a leitura atual informada menor que a
	 * leitura anterior } else if (medicaoHistorico.getLeituraAtualInformada() <
	 * leituraAnterior) { // Definir dados para faturamento leitura MENOR que a
	 * anterior dadosFaturamentoLeituraMenorAnterior(imovel, consumoHistorico,
	 * medicaoHistorico, sistemaParametro, leituraAnterior, medicaoTipo,
	 * consumoMedioImovel, consumoMedioHidrometro); } // Caso a leitura atual
	 * inforamda seja zero e a leitura anormalidade // faturamento diferente de
	 * null } else if (medicaoHistorico.getLeituraAtualInformada() == null &&
	 * medicaoHistorico.getLeituraAnormalidadeFaturamento() == null) {
	 * dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(
	 * medicaoHistorico, consumoHistorico, consumoMedioHidrometro); } // Caso a
	 * anormalidade de leitura de faturamento esteja com valor // diferente de
	 * nulo if (medicaoHistorico.getLeituraAnormalidadeFaturamento() != null) {
	 * // Definir dados para faturamento com anormalidade leitura
	 * dadosFaturamentoAnormalidadeLeitura(medicaoHistorico, consumoHistorico,
	 * consumoMedioHidrometro, leituraAnterior); } // Caso o imóvel esteja com a
	 * situação de faturamento especial if
	 * (imovel.getFaturamentoSituacaoTipo().getId() !=
	 * FaturamentoSituacaoTipo.FATURAMENTO_NORMAL) { // Define dados para
	 * faturamento especial do medido
	 * dadosFaturamentoEspecialMedido(medicaoHistorico, consumoHistorico,
	 * imovel, consumoMedioHidrometro, leituraAnterior); } Collection
	 * colecaoCategoria = null; // (Chamar método para obter quantidade de
	 * economias por categoria) // Verifica se houve estouro de consumo // Caso
	 * não tenha estouro de consumo if
	 * (!verificarEstouroConsumo(consumoHistorico, imovel, consumoMedioImovel,
	 * consumoMedioHidrometro, sistemaParametro, medicaoTipo, colecaoCategoria,
	 * medicaoHistorico, leituraAnterior)) { // Verifica se houve alto consumo
	 * verificarAltoConsumo(consumoHistorico, consumoMedioImovel,
	 * colecaoCategoria); } // Caso a leitura atual tenha sido real e
	 * anormalidade de leitura e // faturamento esteja com valor nulo if
	 * ((medicaoHistorico.getLeituraSituacaoAtual().getId() ==
	 * LeituraSituacao.REALIZADA || medicaoHistorico
	 * .getLeituraSituacaoAtual().getId() == LeituraSituacao.CONFIRMADA) &&
	 * (medicaoHistorico.getLeituraAnormalidadeFaturamento() .getId() == null))
	 * { // Verifica se houve baixo consumo
	 * verificarBaixoConsumo(consumoHistorico, consumoMedioImovel,
	 * colecaoCategoria); } // Caso o indicador de ajuste de consumo esteja
	 * definido como um if
	 * (imovel.getQuadra().getRota().getIndicadorAjusteConsumo() .shortValue()
	 * == new Short("1").shortValue()) { // Realiza o ajuste mensal // /---
	 * FALTA ADICIONAR ROTA ajusteMensalConsumo(medicaoHistorico, //
	 * consumoHistorico, imovel, // medicaoTipo, rota); } // Caso existe consumo
	 * a ser cobrado no mês para água if (consumoHistoricoLigacaoAgua != null &&
	 * consumoHistoricoLigacaoAgua.getNumeroConsumoFaturadoMes() != null) { //
	 * Consumo a ser cobrado no mês de esgoto vai ser consumo cobrado // mês de
	 * ligação de água + consumo a ser cobrado mês de esgoto int
	 * consumoCobradoMesEsgoto = consumoHistoricoLigacaoAgua.getId() .intValue()
	 * + consumoHistorico.getNumeroConsumoFaturadoMes().intValue(); // Seta o
	 * consumo a ser cobrado consumoHistorico.setNumeroConsumoFaturadoMes(new
	 * Integer( consumoCobradoMesEsgoto)); } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param consumoHistorico
	 *            Descrição do parâmetro
	 * @param consumoHistoricoLigacaoAgua
	 *            Descrição do parâmetro
	 * @param imovel
	 *            Descrição do parâmetro
	 * @param consumoMedioImovel
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarDadosFaturamentoEsgotoSemPocoComPocoSemMedicao(
	 * ConsumoHistorico consumoHistorico, ConsumoHistorico
	 * consumoHistoricoLigacaoAgua, Imovel imovel, int[] consumoMedioImovel)
	 * throws ControladorException { // Caso exista consumo a ser cobrado no
	 * consumo histórico de ligação de // água if (consumoHistoricoLigacaoAgua
	 * != null && consumoHistoricoLigacaoAgua.getNumeroConsumoFaturadoMes() !=
	 * null) { // Seta o consumo a ser cobrado no mês será o mesmo do consumo //
	 * histórico de ligação de água consumoHistorico
	 * .setNumeroConsumoFaturadoMes(consumoHistoricoLigacaoAgua
	 * .getNumeroConsumoFaturadoMes()); // Seta o tipo de consumo setá o mesmo
	 * do consumo histórico ligação // de água
	 * consumoHistorico.setConsumoTipo(consumoHistoricoLigacaoAgua
	 * .getConsumoTipo()); } else { // Obtém o consumo mínimo da ligação int
	 * consumoMinimoLigacao = obterConsumoMinimoLigacao(imovel, null); // O
	 * consumo a ser cobrado no mês será o consumo mínimo de ligação // de
	 * ligação consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoMinimoLigacao)); ConsumoTipo consumoTipo = new ConsumoTipo(); // O
	 * tipo de consumo será não medido
	 * consumoTipo.setId(ConsumoTipo.NAO_MEDIDO); } // Caso o faturamento
	 * situação tipo seja diferente de normal if
	 * (imovel.getFaturamentoSituacaoTipo().getId() !=
	 * FaturamentoSituacaoTipo.FATURAMENTO_NORMAL) { // Determinar dados para
	 * faturamento especial do não medido
	 * dadosFaturamentoEspecialNaoMedido(consumoHistorico, consumoMedioImovel,
	 * imovel); } }
	 */

	/**
	 * Determinar Rateio de Água
	 * 
	 * @param imovelCondominio
	 *            Descrição do parâmetro
	 * @param somaNumeroConsumoFaturadoMesAgua
	 *            Descrição do parâmetro
	 * @param somaConsumosMinimos
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasMedidasAgua
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasNaoMedidasAgua
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoAgua
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominioAgua
	 *            Descrição do parâmetro
	 */

	/*
	 * protected void determinarRateioAgua(Imovel imovelCondominio, int
	 * somaNumeroConsumoFaturadoMesAgua, int somaConsumosMinimos,
	 * SistemaParametro sistemaParametro, int quantidadeEconomiasMedidasAgua,
	 * int quantidadeEconomiasNaoMedidasAgua, Collection
	 * colecaoConsumoHistoricoAgua, ConsumoHistorico
	 * consumoHistoricoCondominioAgua) throws ControladorException { // Obtém o
	 * consumo a ser rateado int consumoAguaSerRateado =
	 * consumoHistoricoCondominioAgua .getNumeroConsumoFaturadoMes().intValue()
	 * - somaNumeroConsumoFaturadoMesAgua; // Negativa // Caso o consumo de água
	 * a ser rateado seja menor ou igual a zero e o // número do consumo
	 * faturado no mês seja superior a soma dos consumos // mínimos if
	 * (consumoAguaSerRateado <= 0 &&
	 * consumoHistoricoCondominioAgua.getNumeroConsumoFaturadoMes() .intValue()
	 * > somaConsumosMinimos) { // Realização de cálculo BigDecimal numerador =
	 * sistemaParametro .getPercentualToleranciaRateio().multiply( new
	 * BigDecimal(consumoHistoricoCondominioAgua
	 * .getNumeroConsumoFaturadoMes().toString())); BigDecimal resultado =
	 * numerador.divide(new BigDecimal("100"), BigDecimal.ROUND_UP); // Caso o
	 * consumo de água a ser rateado seja maior que o resultado // do cálculo if
	 * (consumoAguaSerRateado > resultado.intValue()) { // Caso a quantidade de
	 * economias não medidas seja diferente de // zero if
	 * (quantidadeEconomiasNaoMedidasAgua != 0) { // Determinar rateio de água
	 * do não medido determinarRateioAguaNaoMedido(consumoAguaSerRateado,
	 * quantidadeEconomiasNaoMedidasAgua, colecaoConsumoHistoricoAgua,
	 * consumoHistoricoCondominioAgua); } else if
	 * (quantidadeEconomiasMedidasAgua != 0) { // Determinar rateio de água
	 * medido determinarRateioAguaMedido(consumoAguaSerRateado,
	 * quantidadeEconomiasMedidasAgua, sistemaParametro,
	 * colecaoConsumoHistoricoAgua, consumoHistoricoCondominioAgua); } } } }
	 */

	/**
	 * Determinar Rateio de Água Não Medido
	 * 
	 * @param consumoAguaSerRateado
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasNaoMedidasAgua
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoAgua
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominio
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioAguaNaoMedido(int consumoAguaSerRateado,
	 * int quantidadeEconomiasNaoMedidasAgua, Collection
	 * colecaoConsumoHistoricoAgua, ConsumoHistorico consumoHistoricoCondominio)
	 * throws ControladorException { // Obtém o consumo de água a ser rateado
	 * por economia double consumoAguaSerRateadoEconomia =
	 * (consumoAguaSerRateado / quantidadeEconomiasNaoMedidasAgua); // Realiza o
	 * arredondamento do cálculo acima BigDecimal
	 * arredondamentoConsumoAguaSerRateadoEconomia = new BigDecimal(
	 * consumoAguaSerRateadoEconomia);
	 * arredondamentoConsumoAguaSerRateadoEconomia =
	 * arredondamentoConsumoAguaSerRateadoEconomia .setScale(0,
	 * BigDecimal.ROUND_UP); // Caso o consumo a ser rateado por economia seja
	 * maior que zero if (arredondamentoConsumoAguaSerRateadoEconomia.intValue()
	 * > 0) { Iterator colecaoConsumoHistoricoAguaIterator =
	 * colecaoConsumoHistoricoAgua .iterator(); // Laço nos imóveis vinculados
	 * ao imóvel condomínio while
	 * (colecaoConsumoHistoricoAguaIterator.hasNext()) { ConsumoHistorico
	 * consumoHistorico = (ConsumoHistorico) colecaoConsumoHistoricoAguaIterator
	 * .next(); // Para cada imóvel vinculado ao imóvel condomínio que seja //
	 * ligado ou cortado de água e não medido na ligação de água if
	 * ((consumoHistorico.getImovel().getLigacaoAgua()
	 * .getHidrometroInstalacaoHistorico().getId() == null) &&
	 * (consumoHistorico.getImovel() .getLigacaoAguaSituacao().getId() ==
	 * LigacaoAguaSituacao.LIGADO || consumoHistorico
	 * .getImovel().getLigacaoAguaSituacao().getId() ==
	 * LigacaoAguaSituacao.CORTADO)) { // Obtém o número do consumo rateio int
	 * numeroConsumoRateio = arredondamentoConsumoAguaSerRateadoEconomia
	 * .intValue() consumoHistorico.getImovel()
	 * .getQuantidadeEconomias().intValue(); // Seta o consumo histórico
	 * consumoHistorico.setConsumoRateio(new Integer( numeroConsumoRateio));
	 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() +
	 * consumoHistorico.getConsumoRateio() .intValue())); consumoHistorico
	 * .setConsumoHistoricoCondominio(consumoHistoricoCondominio); // Atualiza o
	 * consumo histórico try { repositorioUtil.atualizar(consumoHistorico); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param consumoAguaSerRateado
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasMedidasAgua
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoAgua
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominio
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioAguaMedido(int consumoAguaSerRateado, int
	 * quantidadeEconomiasMedidasAgua, SistemaParametro sistemaParametro,
	 * Collection colecaoConsumoHistoricoAgua, ConsumoHistorico
	 * consumoHistoricoCondominio) throws ControladorException { // Obtém o
	 * consumo de água a ser rateado por economia double
	 * consumoAguaSerRateadoEconomia = consumoAguaSerRateado /
	 * quantidadeEconomiasMedidasAgua; // Realiza o arredondamento do cálculo
	 * acima BigDecimal arredondamentoConsumoAguaSerRateadoEconomia = new
	 * BigDecimal( consumoAguaSerRateadoEconomia); // Obtém o consumo de água a
	 * ser rateado por economia arredondado
	 * arredondamentoConsumoAguaSerRateadoEconomia =
	 * arredondamentoConsumoAguaSerRateadoEconomia .setScale(0,
	 * BigDecimal.ROUND_UP); // Caso o consumo de água a ser rateado por
	 * economia seja inferior ao // decremento máximo de consumo por economia if
	 * (arredondamentoConsumoAguaSerRateadoEconomia.intValue() <
	 * (sistemaParametro .getDecrementoMaximoConsumoRateio().intValue() * -1)) {
	 * arredondamentoConsumoAguaSerRateadoEconomia =
	 * arredondamentoConsumoAguaSerRateadoEconomia .multiply(new
	 * BigDecimal("-1")); } else if
	 * (arredondamentoConsumoAguaSerRateadoEconomia.intValue() >
	 * sistemaParametro .getDecrementoMaximoConsumoRateio().intValue()) {
	 * arredondamentoConsumoAguaSerRateadoEconomia = new BigDecimal(
	 * sistemaParametro.getDecrementoMaximoConsumoRateio() .toString()); }
	 * Iterator colecaoConsumoHistoricoAguaIterator =
	 * colecaoConsumoHistoricoAgua .iterator(); // Laço nos imóveis vinculados
	 * ao imóvel condomínio while
	 * (colecaoConsumoHistoricoAguaIterator.hasNext()) { ConsumoHistorico
	 * consumoHistorico = (ConsumoHistorico) colecaoConsumoHistoricoAguaIterator
	 * .next(); // Para cada imóvel vinculado ao imóvel condomínio que seja
	 * ligado // ou cortado de água e não medido na ligação de água if
	 * ((consumoHistorico.getImovel().getLigacaoAgua()
	 * .getHidrometroInstalacaoHistorico().getId() != null) &&
	 * (consumoHistorico.getImovel().getLigacaoAguaSituacao() .getId() ==
	 * LigacaoAguaSituacao.LIGADO || consumoHistorico
	 * .getImovel().getLigacaoAguaSituacao().getId() ==
	 * LigacaoAguaSituacao.CORTADO)) { // Obtém o número do consumo rateio int
	 * numeroConsumoRateio = arredondamentoConsumoAguaSerRateadoEconomia
	 * .intValue() consumoHistorico.getImovel().getQuantidadeEconomias()
	 * .intValue(); // Caso o consumo faturado mês seja menor que o consumo
	 * rateio // multiplicado por -1 if
	 * (consumoHistorico.getNumeroConsumoFaturadoMes().intValue() <
	 * (consumoHistorico .getConsumoRateio().intValue() * -1)) { // Seta o
	 * consumo rateio consumoHistorico.setConsumoRateio(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() -1)); } //
	 * Seta o consumo faturado mês
	 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() +
	 * consumoHistorico.getConsumoRateio() .intValue())); // Seta o consumo
	 * imóvel condomínio consumoHistorico
	 * .setConsumoHistoricoCondominio(consumoHistoricoCondominio); // Atualiza o
	 * consumo histórico try { repositorioUtil.atualizar(consumoHistorico); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param imovelCondominio
	 *            Descrição do parâmetro
	 * @param somaNumeroConsumoFaturadoMesEsgoto
	 *            Descrição do parâmetro
	 * @param somaConsumosMinimos
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasMedidasEsgoto
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasNaoMedidasEsgoto
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoEsgoto
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominioEsgoto
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioEsgoto(Imovel imovelCondominio, int
	 * somaNumeroConsumoFaturadoMesEsgoto, int somaConsumosMinimos,
	 * SistemaParametro sistemaParametro, int quantidadeEconomiasMedidasEsgoto,
	 * int quantidadeEconomiasNaoMedidasEsgoto, Collection
	 * colecaoConsumoHistoricoEsgoto, ConsumoHistorico
	 * consumoHistoricoCondominioEsgoto) throws ControladorException { // Obtém
	 * o consumo a ser rateado int consumoEsgotoSerRateado =
	 * consumoHistoricoCondominioEsgoto
	 * .getNumeroConsumoFaturadoMes().intValue() -
	 * somaNumeroConsumoFaturadoMesEsgoto; // Negativa // Caso o consumo de
	 * esgoto a ser rateado seja menor ou igual a zero e o // número do consumo
	 * faturado no mês seja superior a soma dos consumos // mínimos if
	 * (consumoEsgotoSerRateado <= 0 && consumoHistoricoCondominioEsgoto
	 * .getNumeroConsumoFaturadoMes().intValue() > somaConsumosMinimos) { //
	 * Realização de cálculo BigDecimal numerador = sistemaParametro
	 * .getPercentualToleranciaRateio().multiply( new
	 * BigDecimal(consumoHistoricoCondominioEsgoto
	 * .getNumeroConsumoFaturadoMes().toString())); BigDecimal resultado =
	 * numerador.divide(new BigDecimal("100"), BigDecimal.ROUND_UP); // Caso o
	 * consumo de água a ser rateado seja maior que o resultado // do cálculo if
	 * (consumoEsgotoSerRateado > resultado.intValue()) { // Caso a quantidade
	 * de economias não medidas seja diferente de // zero if
	 * (quantidadeEconomiasNaoMedidasEsgoto != 0) { // Determinar rateio de água
	 * do não medido determinarRateioEsgotoNaoMedido(consumoEsgotoSerRateado,
	 * quantidadeEconomiasNaoMedidasEsgoto, colecaoConsumoHistoricoEsgoto,
	 * consumoHistoricoCondominioEsgoto); } else if
	 * (quantidadeEconomiasMedidasEsgoto != 0) { // Determinar rateio de água
	 * medido determinarRateioEsgotoMedido(consumoEsgotoSerRateado,
	 * quantidadeEconomiasMedidasEsgoto, sistemaParametro,
	 * colecaoConsumoHistoricoEsgoto, consumoHistoricoCondominioEsgoto); } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param consumoEsgotoSerRateado
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasNaoMedidasEsgoto
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoEsgoto
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominio
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioEsgotoNaoMedido(int
	 * consumoEsgotoSerRateado, int quantidadeEconomiasNaoMedidasEsgoto,
	 * Collection colecaoConsumoHistoricoEsgoto, ConsumoHistorico
	 * consumoHistoricoCondominio) throws ControladorException { // Obtém o
	 * consumo de água a ser rateado por economia double
	 * consumoEsgotoSerRateadoEconomia = (consumoEsgotoSerRateado /
	 * quantidadeEconomiasNaoMedidasEsgoto); // Realiza o arredondamento do
	 * cálculo acima BigDecimal arredondamentoConsumoEsgotoSerRateadoEconomia =
	 * new BigDecimal( consumoEsgotoSerRateadoEconomia);
	 * arredondamentoConsumoEsgotoSerRateadoEconomia =
	 * arredondamentoConsumoEsgotoSerRateadoEconomia .setScale(0,
	 * BigDecimal.ROUND_UP); // Caso o consumo a ser rateado por economia seja
	 * maior que zero if
	 * (arredondamentoConsumoEsgotoSerRateadoEconomia.intValue() > 0) { Iterator
	 * colecaoConsumoHistoricoEsgotoIterator = colecaoConsumoHistoricoEsgoto
	 * .iterator(); // Laço nos imóveis vinculados ao imóvel condomínio while
	 * (colecaoConsumoHistoricoEsgotoIterator.hasNext()) { ConsumoHistorico
	 * consumoHistorico = (ConsumoHistorico)
	 * colecaoConsumoHistoricoEsgotoIterator .next(); // Para cada imóvel
	 * vinculado ao imóvel condomínio que seja // ligado ou cortado de água e
	 * não medido na ligação de água if ((consumoHistorico.getImovel()
	 * .getHidrometroInstalacaoHistorico().getId() == null) &&
	 * (consumoHistorico.getImovel() .getLigacaoEsgotoSituacao().getId() ==
	 * LigacaoEsgotoSituacao.LIGADO)) { // Obtém o número do consumo rateio int
	 * numeroConsumoRateio = arredondamentoConsumoEsgotoSerRateadoEconomia
	 * .intValue() consumoHistorico.getImovel()
	 * .getQuantidadeEconomias().intValue(); // Seta o consumo histórico
	 * consumoHistorico.setConsumoRateio(new Integer( numeroConsumoRateio));
	 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() +
	 * consumoHistorico.getConsumoRateio() .intValue())); consumoHistorico
	 * .setConsumoHistoricoCondominio(consumoHistoricoCondominio); // Atualiza o
	 * consumo histórico try { repositorioUtil.atualizar(consumoHistorico); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } } } } }
	 */

	/**
	 * < <Descrição do método>>
	 * 
	 * @param consumoEsgotoSerRateado
	 *            Descrição do parâmetro
	 * @param quantidadeEconomiasMedidasEsgoto
	 *            Descrição do parâmetro
	 * @param sistemaParametro
	 *            Descrição do parâmetro
	 * @param colecaoConsumoHistoricoEsgoto
	 *            Descrição do parâmetro
	 * @param consumoHistoricoCondominio
	 *            Descrição do parâmetro
	 */
	/*
	 * protected void determinarRateioEsgotoMedido(int consumoEsgotoSerRateado,
	 * int quantidadeEconomiasMedidasEsgoto, SistemaParametro sistemaParametro,
	 * Collection colecaoConsumoHistoricoEsgoto, ConsumoHistorico
	 * consumoHistoricoCondominio) throws ControladorException { // Obtém o
	 * consumo de esgoto a ser rateado por economia double
	 * consumoEsgotoSerRateadoEconomia = consumoEsgotoSerRateado /
	 * quantidadeEconomiasMedidasEsgoto; // Realiza o arredondamento do cálculo
	 * acima BigDecimal arredondamentoConsumoEsgotoSerRateadoEconomia = new
	 * BigDecimal( consumoEsgotoSerRateadoEconomia);
	 * arredondamentoConsumoEsgotoSerRateadoEconomia =
	 * arredondamentoConsumoEsgotoSerRateadoEconomia .setScale(0,
	 * BigDecimal.ROUND_UP); // Caso o consumo de esgoto a ser rateado por
	 * economia seja maior que // zero if
	 * (arredondamentoConsumoEsgotoSerRateadoEconomia.intValue() > 0) { // Caso
	 * o consumo esgoto rateado por economia seja maior que o // incremento
	 * máximo do do consumo rateio if
	 * (arredondamentoConsumoEsgotoSerRateadoEconomia.intValue() >
	 * sistemaParametro .getIncrementoMaximoConsumoRateio().intValue()) {
	 * arredondamentoConsumoEsgotoSerRateadoEconomia = new BigDecimal(
	 * sistemaParametro.getIncrementoMaximoConsumoRateio() .toString()); }
	 * Iterator colecaoConsumoHistoricoEsgotoIterator =
	 * colecaoConsumoHistoricoEsgoto .iterator(); // Laço nos imóveis vinculados
	 * ao imóvel condomínio while
	 * (colecaoConsumoHistoricoEsgotoIterator.hasNext()) { ConsumoHistorico
	 * consumoHistorico = (ConsumoHistorico)
	 * colecaoConsumoHistoricoEsgotoIterator .next(); // Para cada imóvel
	 * vinculado ao imóvel condomínio que seja // ligado e medido de poço if
	 * ((consumoHistorico.getImovel()
	 * .getHidrometroInstalacaoHistorico().getId() != null) &&
	 * (consumoHistorico.getImovel() .getLigacaoEsgotoSituacao().getId() ==
	 * LigacaoEsgotoSituacao.LIGADO)) { // Obtém o número do consumo rateio int
	 * numeroConsumoRateio = arredondamentoConsumoEsgotoSerRateadoEconomia
	 * .intValue() consumoHistorico.getImovel()
	 * .getQuantidadeEconomias().intValue(); // Caso o consumo faturado mês seja
	 * menor que o consumo // rateio multiplicado por -1 if
	 * (consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() <
	 * (consumoHistorico.getConsumoRateio() .intValue() * -1)) { // Seta o
	 * consumo rateio consumoHistorico.setConsumoRateio(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() -1)); } //
	 * Seta o consumo faturado mês
	 * consumoHistorico.setNumeroConsumoFaturadoMes(new Integer(
	 * consumoHistorico.getNumeroConsumoFaturadoMes() .intValue() +
	 * consumoHistorico.getConsumoRateio() .intValue())); // Seta o consumo
	 * imóvel condomínio consumoHistorico
	 * .setConsumoHistoricoCondominio(consumoHistoricoCondominio); // Atualiza o
	 * consumo histórico try { repositorioUtil.atualizar(consumoHistorico); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } } } } }
	 */

	/**
	 * <<Descrição do método>>
	 * 
	 * @author Saulo Lima
	 * @date 03/03/2009 Alteração para inserir os hidrômetros e atualizar os que
	 *       já existem na base; Retornar a quantidade de hidrômetros inseridos.
	 * @param hidrometro
	 * @param fixo
	 * @param faixaInicial
	 * @param faixaFinal
	 * @return int Quantidade de Hidrômetros inseridos
	 * @throws ControladorException
	 */
	public int inserirHidrometro(Hidrometro hidrometro, String fixo, Integer faixaInicial, Integer faixaFinal, Usuario usuarioLogado)
					throws ControladorException{

		// Obtém o intervalo: faixa final - inicial + 1
		int quantidade = (faixaFinal.intValue() - faixaInicial.intValue()) + 1;

		int contador = 0;

		// Verifica se já existem hidrometros cadastrados dentro da faixa
		// determinada.
		Collection<Hidrometro> colecaoHidrometro = this
						.pesquisarNumeroHidrometroFaixa(fixo, faixaInicial.toString(), faixaFinal.toString());

		Integer codigoFormatoNumeracao = hidrometro.getCodigoFormatoNumeracao();

		for(int i = 0; i < quantidade; i++){

			String intervalo = (Integer.valueOf(faixaInicial.intValue() + i)).toString();

			String numeroFormatado = "";

			if(codigoFormatoNumeracao.equals(Hidrometro.FORMATO_NUMERACAO_4_X_6)){
				numeroFormatado = Util.adicionarZerosEsquedaNumero(6, intervalo);
			}else if(codigoFormatoNumeracao.equals(Hidrometro.FORMATO_NUMERACAO_5_X_5)){
				numeroFormatado = Util.adicionarZerosEsquedaNumero(5, intervalo);
			}

			hidrometro.setNumero(fixo + numeroFormatado);

			// Verifica se o hidrometro a ser inserido já está na coleção
			boolean existe = false;
			Hidrometro hidrometroBase = null;
			if(colecaoHidrometro != null && !colecaoHidrometro.isEmpty()){
				Iterator<Hidrometro> iteratorHidrometro = colecaoHidrometro.iterator();
				while(iteratorHidrometro.hasNext()){
					hidrometroBase = iteratorHidrometro.next();
					if(hidrometroBase.getNumero().equals(fixo + numeroFormatado)){
						existe = true;
						break;
					}
				}
			}

			// Caso não exista será inserido
			if(!existe){
				try{
					hidrometro.setUltimaAlteracao(new Date());

					// [UC] - Registrar Transação
					// Início - Registrando as transações
					RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_HIDROMETRO_INSERIR,
									new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					Operacao operacao = new Operacao();
					operacao.setId(Operacao.OPERACAO_HIDROMETRO_INSERIR);

					OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
					operacaoEfetuada.setOperacao(operacao);

					hidrometro.setOperacaoEfetuada(operacaoEfetuada);
					hidrometro.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

					registradorOperacao.registrarOperacao(hidrometro);
					// Fim - Registrando as transações

					repositorioUtil.inserir(hidrometro);
					contador++;
				}catch(ErroRepositorioException e1){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e1);
				}

				// Caso exista será atualizado
			}else{

				try{
					if(faixaInicial.equals(faixaFinal)){
						throw new ControladorException("atencao.hidrometro.ja.cadastrado");
					}

					if(hidrometroBase != null){

						if(hidrometro.getDataAquisicao() != null){
							hidrometroBase.setDataAquisicao(hidrometro.getDataAquisicao());
						}
						if(hidrometro.getAnoFabricacao() != null){
							hidrometroBase.setAnoFabricacao(hidrometro.getAnoFabricacao());
						}
						if(hidrometro.getIndicadorMacromedidor() != null){
							hidrometroBase.setIndicadorMacromedidor(hidrometro.getIndicadorMacromedidor());
						}
						if(hidrometro.getNumeroDigitosLeitura() != null){
							hidrometroBase.setNumeroDigitosLeitura(hidrometro.getNumeroDigitosLeitura());
						}
						if(hidrometro.getHidrometroTipo() != null){
							hidrometroBase.setHidrometroTipo(hidrometro.getHidrometroTipo());
						}
						if(hidrometro.getHidrometroMarca() != null){
							hidrometroBase.setHidrometroMarca(hidrometro.getHidrometroMarca());
						}
						if(hidrometro.getHidrometroCapacidade() != null){
							hidrometroBase.setHidrometroCapacidade(hidrometro.getHidrometroCapacidade());
						}
						if(hidrometroBase.getHidrometroSituacao().equals(HidrometroSituacao.DISPONIVEL)
										&& hidrometro.getHidrometroLocalArmazenagem() != null){
							hidrometroBase.setHidrometroLocalArmazenagem(hidrometro.getHidrometroLocalArmazenagem());
						}
						if(hidrometro.getHidrometroClasseMetrologica() != null){
							hidrometroBase.setHidrometroClasseMetrologica(hidrometro.getHidrometroClasseMetrologica());
						}
						if(hidrometro.getHidrometroDiametro() != null){
							hidrometroBase.setHidrometroDiametro(hidrometro.getHidrometroDiametro());
						}
						if(hidrometro.getIndicadorHidrometroComposto() != null){
							hidrometroBase.setIndicadorHidrometroComposto(hidrometro.getIndicadorHidrometroComposto());
						}
						if(hidrometro.getFatorConversao() != null){
							hidrometroBase.setFatorConversao(hidrometro.getFatorConversao());
						}

						// Formato da Numeração do Hidrômetro
						if(codigoFormatoNumeracao != null){
							hidrometroBase.setCodigoFormatoNumeracao(codigoFormatoNumeracao);
						}

						// Tipo de Instalação da Turbina
						HidrometroTipoTurbina hidrometroTipoTurbina = hidrometro.getHidrometroTipoTurbina();

						if(hidrometroTipoTurbina != null){
							hidrometroBase.setHidrometroTipoTurbina(hidrometroTipoTurbina);
						}

						hidrometroBase.setUltimaAlteracao(new Date());

						// [UC] - Registrar Transação
						// Início - Registrando as transações
						RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_HIDROMETRO_ATUALIZAR,
										hidrometroBase.getId(), hidrometroBase.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
														UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

						Operacao operacao = new Operacao();
						operacao.setId(Operacao.OPERACAO_HIDROMETRO_ATUALIZAR);

						OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
						operacaoEfetuada.setOperacao(operacao);

						hidrometroBase.setOperacaoEfetuada(operacaoEfetuada);
						hidrometroBase.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

						registradorOperacao.registrarOperacao(hidrometroBase);
						// Fim - Registrando as transações

						repositorioUtil.atualizar(hidrometroBase);

					}else{
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema");
					}

				}catch(ErroRepositorioException e1){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e1);
				}
			}
		}
		return contador;
	}

	/**
	 * Insere a marca de um hidrômetro
	 * 
	 * @param hidrometroMarca
	 *            Marca de hidrometro a ser inserida
	 * @return código da marca que foi inserida
	 * @throws ControladorException
	 */
	public Integer inserirHidrometroMarca(HidrometroMarca hidrometroMarca, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_INSERIR_MARCA_HIDROMETRO,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_INSERIR_MARCA_HIDROMETRO);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		// [FS-0002] - Verificar existencia de hidrômetro
		Collection colFiltros;
		FiltroHidrometroMarca filtro = new FiltroHidrometroMarca();
		filtro.adicionarParametro(new ParametroSimples(FiltroHidrometroMarca.DESCRICAO, hidrometroMarca.getDescricao()));
		colFiltros = getControladorUtil().pesquisar(filtro, hidrometroMarca.getClass().getName());

		if(colFiltros != null && colFiltros.size() > 0){
			throw new ControladorException("atencao.hidrometro_marca.existente");
		}

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		hidrometroMarca.setOperacaoEfetuada(operacaoEfetuada);
		hidrometroMarca.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(hidrometroMarca);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		return (Integer) this.getControladorUtil().inserir(hidrometroMarca);
	}

	/**
	 * Insere o diametro do hidrômetro
	 * 
	 * @param hidrometroDiametro
	 *            Diametro do hidrometro a ser inserido
	 * @return código do diametro que foi inserido
	 * @throws ControladorException
	 */
	public Integer inserirHidrometroDiametro(HidrometroDiametro hidrometroDiametro, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_INSERIR_DIAMETRO_HIDROMETRO,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_INSERIR_DIAMETRO_HIDROMETRO);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		// [FS-0002] - Verificar existencia de hidrômetro
		Collection colFiltros;
		/*
		 * FiltroHidrometroMarca filtro = new FiltroHidrometroMarca(); filtro
		 * .adicionarParametro(new ParametroSimples(
		 * FiltroHidrometroMarca.DESCRICAO, hidrometroMarca .getDescricao()));
		 * colFiltros = getControladorUtil().pesquisar(filtro,
		 * hidrometroMarca.getClass().getName());
		 */

		FiltroHidrometroDiametro filtro = new FiltroHidrometroDiametro();
		filtro.adicionarParametro(new ParametroSimples(FiltroHidrometroDiametro.DESCRICAO, hidrometroDiametro.getDescricao()));

		colFiltros = getControladorUtil().pesquisar(filtro, hidrometroDiametro.getClass().getName());
		if(colFiltros != null && colFiltros.size() > 0){
			throw new ControladorException("atencao.hidrometro_diametro.existente");
		}

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		hidrometroDiametro.setOperacaoEfetuada(operacaoEfetuada);
		hidrometroDiametro.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(hidrometroDiametro);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		return (Integer) this.getControladorUtil().inserir(hidrometroDiametro);
	}

	/**
	 * @author Saulo Lima
	 * @date 03/03/2009 Alteração para colocar o Generics no retorno
	 * @param fixo
	 * @param faixaInicial
	 * @param faixaFinal
	 * @return Collection<Hidrometro>
	 * @throws ControladorException
	 */
	public Collection<Hidrometro> pesquisarNumeroHidrometroFaixa(String fixo, String faixaInicial, String faixaFinal)
					throws ControladorException{

		try{
			int tamanhoParteFixa = fixo.length();
			int tamanhoParteFaixa = 10 - tamanhoParteFixa;

			String numeroFormatadoInicial = Util.adicionarZerosEsquedaNumero(tamanhoParteFaixa, faixaInicial);
			String numeroFormatadoFinal = Util.adicionarZerosEsquedaNumero(tamanhoParteFaixa, faixaFinal);

			return repositorioMicromedicao.pesquisarNumeroHidrometroFaixa((fixo + numeroFormatadoInicial), (fixo + numeroFormatadoFinal));

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa uma coleção de hidrômetros de acordo com fixo, faixa inicial e
	 * faixa final
	 * 
	 * @param fixo
	 *            Descrição do parâmetro
	 * @param faixaInicial
	 *            Descrição do parâmetro
	 * @param faixaFinal
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroFaixaRelatorio(String fixo, String faixaInicial, String faixaFinal)
					throws ControladorException{

		try{
			int tamanhoParteFixa = fixo.length();
			int tamanhoParteFaixa = 10 - tamanhoParteFixa;

			String numeroFormatadoInicial = Util.adicionarZerosEsquedaNumero(tamanhoParteFaixa, faixaInicial);
			String numeroFormatadoFinal = Util.adicionarZerosEsquedaNumero(tamanhoParteFaixa, faixaFinal);

			return repositorioMicromedicao.pesquisarNumeroHidrometroFaixaRelatorio((fixo + numeroFormatadoInicial),
							(fixo + numeroFormatadoFinal));
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param fixo
	 *            Descrição do parâmetro
	 * @param faixaInicial
	 *            Descrição do parâmetro
	 * @param faixaFinal
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroFaixaPaginacao(String fixo, String faixaInicial, String faixaFinal, Integer numeroPagina)
					throws ControladorException{

		try{
			int tamanhoParteFixa = fixo.length();
			int tamanhoParteFaixa = 10 - tamanhoParteFixa;

			String numeroFormatadoInicial = Util.adicionarZerosEsquedaNumero(tamanhoParteFaixa, faixaInicial);
			String numeroFormatadoFinal = Util.adicionarZerosEsquedaNumero(tamanhoParteFaixa, faixaFinal);

			return repositorioMicromedicao.pesquisarNumeroHidrometroFaixaPaginacao((fixo + numeroFormatadoInicial),
							(fixo + numeroFormatadoFinal), numeroPagina);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param fixo
	 *            Descrição do parâmetro
	 * @param faixaInicial
	 *            Descrição do parâmetro
	 * @param faixaFinal
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection pesquisarNumeroHidrometroFaixaComLimite(String fixo, String faixaInicial, String faixaFinal)
					throws ControladorException{

		try{
			int tamanhoParteFixa = fixo.length();
			int tamanhoParteFaixa = 10 - tamanhoParteFixa;

			String zerosInicial = Util.adicionarZerosEsquedaNumero(tamanhoParteFaixa, faixaInicial);

			String zerosFinal = "";

			if(faixaFinal == null || faixaFinal.equals("")){
				zerosFinal = Util.completarStringComValorEsquerda("9", "9", tamanhoParteFaixa);
			}else{
				zerosFinal = Util.adicionarZerosEsquedaNumero(tamanhoParteFaixa, faixaFinal);
			}

			return repositorioMicromedicao.pesquisarNumeroHidrometroFaixaComLimite((fixo + zerosInicial), (fixo + zerosFinal));
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Description of the Method
	 * 
	 * @param hidrometros
	 *            Description of the Parameter
	 * @param hidrometroAtualizado
	 *            Description of the Parameter
	 * @throws ControladorException
	 */
	public void atualizarConjuntoHidrometro(Collection hidrometros, Hidrometro hidrometroAtualizado, Usuario usuarioLogado)
					throws ControladorException{

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CONJUNTO_HIDROMETRO_ATUALIZAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CONJUNTO_HIDROMETRO_ATUALIZAR);
		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		Iterator hidrometroIterator = hidrometros.iterator();

		while(hidrometroIterator.hasNext()){
			Hidrometro hidrometro = (Hidrometro) hidrometroIterator.next();

			// seta os valoes do hidrometro atualizado que veio do
			// hidrometro_atualizar_conjunto
			hidrometro.setCodigoFormatoNumeracao(hidrometroAtualizado.getCodigoFormatoNumeracao());
			hidrometro.setHidrometroClasseMetrologica(hidrometroAtualizado.getHidrometroClasseMetrologica());
			hidrometro.setHidrometroMarca(hidrometroAtualizado.getHidrometroMarca());
			hidrometro.setHidrometroCapacidade(hidrometroAtualizado.getHidrometroCapacidade());
			hidrometro.setHidrometroDiametro(hidrometroAtualizado.getHidrometroDiametro());
			hidrometro.setHidrometroTipo(hidrometroAtualizado.getHidrometroTipo());
			hidrometro.setDataAquisicao(hidrometroAtualizado.getDataAquisicao());
			hidrometro.setAnoFabricacao(hidrometroAtualizado.getAnoFabricacao());
			hidrometro.setIndicadorMacromedidor(hidrometroAtualizado.getIndicadorMacromedidor());
			hidrometro.setNumeroDigitosLeitura(hidrometroAtualizado.getNumeroDigitosLeitura());
			hidrometro.setHidrometroTipoTurbina(hidrometroAtualizado.getHidrometroTipoTurbina());
			hidrometro.setDataUltimaRevisao(hidrometroAtualizado.getDataUltimaRevisao());
			// ------------ REGISTRAR TRANSAÇÃO ----------------------------
			hidrometro.setOperacaoEfetuada(operacaoEfetuada);
			hidrometro.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(hidrometro);

			// chama o metodo atualizar hidrometro para atualizar cada
			// hidrometro do conjunto
			atualizarHidrometro(hidrometro, usuarioLogado);
		}
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param colecaoHidrometro
	 *            Descrição do parâmetro
	 * @param ids
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 * @throws ControladorException
	 */
	public Collection obterColecaoObjetosSelecionados(Collection colecaoHidrometro, String[] ids) throws ControladorException{

		Collection retorno = null;

		Collection colecaoObjetosSelecionados = new ArrayList();

		// Verifica se foram selecionados hidrômetros
		if(ids != null && ids.length != 0){

			// Criação de objetos
			Hidrometro hidrometro = null;

			for(int i = 0; i < ids.length; i++){
				// atribui a variável "id" o código do hidrômetro
				int id = Integer.parseInt(ids[i]);

				Iterator iteratorColecaoHidrometro = colecaoHidrometro.iterator();

				while(iteratorColecaoHidrometro.hasNext()){

					// Obtém o hidrômetro da coleção
					hidrometro = (Hidrometro) iteratorColecaoHidrometro.next();

					// Verifica se o código selecionado possui na coleção
					if(id == hidrometro.getId().intValue()){

						colecaoObjetosSelecionados.add(hidrometro);
					}
				}

			}

		}else{
			// Caso não tenha(m) selecionado(s) hidrômetros gera exceção
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.registros.nao_selecionados", null);
		}

		retorno = colecaoObjetosSelecionados;

		return retorno;
	}

	/**
	 * < <Seleciona os objetos existentes na coleção de acordo com os ids
	 * informados e verifica se o local de armazenagem são os mesmos para os
	 * selecionados, retorna TRUE (vedadeiro) caso o local de armazenagem sejam
	 * os mesmos ou retorna FALSE (falso) caso o local de armazenagem sejam
	 * diferentes>>
	 * 
	 * @param colecaoHidrometro
	 *            Descrição do parâmetro
	 * @return Descrição do retorno
	 */
	public String verificarLocalArmazenagemSituacao(Collection colecaoHidrometro){

		// TODO verificarLocalArmazenagemSituacao
		String retorno = "valido";
		// /
		// Criação de objetos
		Hidrometro hidrometro = null;

		Integer idLocalArmazenagem = null;

		Iterator iteratorColecaoHidrometro = colecaoHidrometro.iterator();

		while(iteratorColecaoHidrometro.hasNext()){
			// Obtém o hidrômetro da coleção
			hidrometro = (Hidrometro) iteratorColecaoHidrometro.next();

			if(hidrometro.getHidrometroLocalArmazenagem() != null){

				if(idLocalArmazenagem == null){

					// Armazena o id do local de armazenagem do 1º hidrômetro
					// encontrado
					idLocalArmazenagem = hidrometro.getHidrometroLocalArmazenagem().getId();

					// Caso seja diferentes retorna falso
				}else if(idLocalArmazenagem.intValue() != hidrometro.getHidrometroLocalArmazenagem().getId().intValue()){

					retorno = "localArmazenagemDiferente";
					break;
				}
			}else{
				// Não é permitida a movimentação de Hidrometros Sem Armazenagem Local

				return "hidrometroSemArmazenagemLocal";
			}
			// Verifica se o hidrometro selecionado está com a situação de
			// instalado
			if(hidrometro.getHidrometroSituacao().getId().equals(HidrometroSituacao.INSTALADO)){
				retorno = "hidrometroInstalado";
				break;
			}
		}

		return retorno;
	}

	/**
	 * < <Descrição do método>>
	 * 
	 * @param colecaoHidrometro
	 *            Descrição do parâmetro
	 * @param data
	 *            Descrição do parâmetro
	 * @param hora
	 *            Descrição do parâmetro
	 * @param idLocalArmazenagemDestino
	 *            Descrição do parâmetro
	 * @param idMotivoMovimentacao
	 *            Descrição do parâmetro
	 * @param parecer
	 *            Descrição do parâmetro
	 * @throws ControladorException
	 */
	public void inserirAtualizarMovimentacaoHidrometroIds(Collection colecaoHidrometro, String data, String hora,
					String idLocalArmazenagemDestino, String idMotivoMovimentacao, String parecer, Usuario usuario)
					throws ControladorException{

		try{
			HidrometroMovimentacao hidrometroMovimentacao = new HidrometroMovimentacao();

			SimpleDateFormat formatoData = new SimpleDateFormat("dd/MM/yyyy");
			SimpleDateFormat formatoHora = new SimpleDateFormat("HH:mm");

			Date dataMovimentacao = null;
			Date horaMovimentacao = null;
			try{
				dataMovimentacao = formatoData.parse(data);
				horaMovimentacao = formatoHora.parse(hora);
			}catch(ParseException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.data.hora.invalido", null);
			}

			// Seta a data de movimentação
			hidrometroMovimentacao.setData(dataMovimentacao);
			hidrometroMovimentacao.setHora(horaMovimentacao);
			// Seta o local de armazenagem destino
			FiltroHidrometroLocalArmazenagem filtroHidrometroLocalArmazenagem = new FiltroHidrometroLocalArmazenagem();
			filtroHidrometroLocalArmazenagem.adicionarParametro(new ParametroSimples(FiltroHidrometroLocalArmazenagem.ID,
							idLocalArmazenagemDestino));

			Collection colecaoHidrometroLocalArmazenagem = getControladorUtil().pesquisar(filtroHidrometroLocalArmazenagem,
							HidrometroLocalArmazenagem.class.getName());

			HidrometroLocalArmazenagem hidrometroLocalArmazenagemDestino = (HidrometroLocalArmazenagem) Util
							.retonarObjetoDeColecao(colecaoHidrometroLocalArmazenagem);

			hidrometroMovimentacao.setHidrometroLocalArmazenagemDestino(hidrometroLocalArmazenagemDestino);

			// Seta o motivo da movimentacao
			HidrometroMotivoMovimentacao hidrometroMotivoMovimentacao = new HidrometroMotivoMovimentacao();

			hidrometroMotivoMovimentacao.setId(Integer.valueOf(idMotivoMovimentacao));
			hidrometroMovimentacao.setHidrometroMotivoMovimentacao(hidrometroMotivoMovimentacao);

			// Seta o parecer
			hidrometroMovimentacao.setParecer(parecer);
			// Seta a data e hora de última alteração
			hidrometroMovimentacao.setUltimaAlteracao(new Date());

			// Seta o funcionário
			hidrometroMovimentacao.setUsuario(usuario);

			Hidrometro dadosHidrometroParaMovimentacao = (Hidrometro) ((List) colecaoHidrometro).get(0);

			// Seta o local de armazenagem origem
			hidrometroMovimentacao.setHidrometroLocalArmazenagemOrigem(dadosHidrometroParaMovimentacao.getHidrometroLocalArmazenagem());

			// Inseri a movimentção do hidrômetro
			Integer idHidrometroMovimentacao = (Integer) repositorioUtil.inserir(hidrometroMovimentacao);

			hidrometroMovimentacao.setId(idHidrometroMovimentacao);

			// Criação de objetos
			Hidrometro hidrometro = null;

			Iterator iteratorColecaoHidrometro = colecaoHidrometro.iterator();

			while(iteratorColecaoHidrometro.hasNext()){

				// Obtém o hidrômetro da coleção
				hidrometro = (Hidrometro) iteratorColecaoHidrometro.next();

				// Verifica se está movimentando o hidrômetro para o mesmo local
				// de armazenagem
				if(hidrometro.getHidrometroLocalArmazenagem().getId().intValue() == Integer.valueOf(idLocalArmazenagemDestino).intValue()){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.nao.possivel.movimentar.hidrometro.mesmo.local.armazenagem", null);
				}

				// Procura hidrometro na base
				FiltroHidrometro filtroHidrometro = new FiltroHidrometro();

				filtroHidrometro.adicionarParametro((new ParametroSimples(FiltroHidrometro.ID, hidrometro.getId())));

				Hidrometro hidrometroNaBase = (Hidrometro) ((List) (getControladorUtil().pesquisar(filtroHidrometro, Hidrometro.class
								.getName()))).get(0);

				// Verificar se categoria já foi atualizada por outro usuário
				// durante esta atualização
				if(hidrometroNaBase.getUltimaAlteracao().after(hidrometro.getUltimaAlteracao())){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");
				}

				HidrometroMovimentado hidrometroMovimentado = new HidrometroMovimentado(new HidrometroMovimentadoPK(
								idHidrometroMovimentacao, hidrometro.getId()));

				hidrometroMovimentado.setHidrometroMovimentacao(hidrometroMovimentacao);

				repositorioUtil.inserir(hidrometroMovimentado);

				// Seta o hidrometro para o novo local de armazenagem
				hidrometro.setHidrometroLocalArmazenagem(hidrometroLocalArmazenagemDestino);

				HidrometroSituacao hidrometroSituacao = new HidrometroSituacao();

				if(hidrometroLocalArmazenagemDestino.getIndicadorOficina().equals(HidrometroLocalArmazenagem.INDICADOR_OFICINA)){
					hidrometroSituacao.setId(HidrometroSituacao.EM_MANUTENCAO);
				}else{
					hidrometroSituacao.setId(HidrometroSituacao.DISPONIVEL);
				}

				hidrometro.setHidrometroSituacao(hidrometroSituacao);
				hidrometro.setUltimaAlteracao(new Date());

				// Atualiza o hidrômetro
				repositorioUtil.atualizar(hidrometro);
			}
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método utilizado para apoio na realização de testes do caso de uso
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 */
	public void executarImovelTestesMedicaoConsumo(FaturamentoGrupo faturamentoGrupo, Imovel imovel) throws ControladorException{

		try{

			// Criação das coleções
			ImovelTestesMedicaoConsumo imovelTestesMedicaoConsumoLigacaoAgua = null;
			ImovelTestesMedicaoConsumo imovelTestesMedicaoConsumoPoco = null;
			ImovelTestesMedicaoConsumo imovelTestesMedicaoConsumoLigacaoEsgoto = null;
			ImovelTestesMedicaoConsumo imovelTestesMedicaoConsumo = null;
			Imovel imovelAPesquisar = new Imovel();

			// Criação dos objetos
			Collection colecaoMedicaoConsumoLigacaoAgua = null;
			// Collection colecaoMedicaoConsumoPoco = null;
			Collection colecaoMedicaoConsumoLigacaoEsgoto = null;
			Collection colecaoImovelLigacaoSituacao = null;

			// Filtro para obter os parametros do sistema
			// FiltroSistemaParametro filtroSistemaParametro = new
			// FiltroSistemaParametro();
			// Collection colecaoSistemaParametro = pesquisar(
			// filtroSistemaParametro, SistemaParametro.class.getName());
			// SistemaParametro sistemaParametro = (SistemaParametro) Util
			// .retonarObjetoDeColecao(colecaoSistemaParametro);
			SistemaParametro sistemaParametro = new SistemaParametro();
			sistemaParametro.setAnoMesFaturamento(200408);
			sistemaParametro.setMesesMediaConsumo(Short.valueOf("6"));

			// Obtém na coleção todos os ids dos imóveis pertencentes ao grupo
			// de faturamento informado
			/*
			 * Collection colecaoIdsImoveis = repositorioMicromedicao
			 * .pesquisarImovelFaturamentoGrupoObterIds(faturamentoGrupo);
			 */

			Collection colecaoIdsImoveis = new ArrayList();

			colecaoIdsImoveis.add(Integer.valueOf("18380544"));
			colecaoIdsImoveis.add(Integer.valueOf("18401258"));
			colecaoIdsImoveis.add(Integer.valueOf("54260490"));
			colecaoIdsImoveis.add(Integer.valueOf("54265735"));

			Iterator colecaoIdsImoveisIterator = colecaoIdsImoveis.iterator();

			int[] consumoMedioHidrometroLigacaoAgua = null;
			int[] consumoMedioImovelLigacaoAgua = null;

			// int[] consumoMedioHidrometroPoco = null;
			// int[] consumoMedioImovelPoco = null;
			// int[] consumoMedioImovelLigacaoEsgoto = null;
			int[] faixaLeituraEsperada = null;
			int quantidadeEconomias = 0;

			MedicaoTipo medicaoTipo = new MedicaoTipo();
			MedicaoHistorico medicaoHistorico = null;
			Hidrometro hidrometro = null;
			boolean ligacaoAgua = false;
			boolean poco = false;
			// boolean ligacaoEsgoto = false;

			while(colecaoIdsImoveisIterator.hasNext()){

				ligacaoAgua = false;
				poco = false;
				// ligacaoEsgoto = false;

				// Obtém o id do imóvel
				Integer imovelId = (Integer) colecaoIdsImoveisIterator.next();

				imovelTestesMedicaoConsumo = new ImovelTestesMedicaoConsumo();
				imovelTestesMedicaoConsumoLigacaoAgua = new ImovelTestesMedicaoConsumo();
				imovelTestesMedicaoConsumoPoco = new ImovelTestesMedicaoConsumo();
				imovelTestesMedicaoConsumoLigacaoEsgoto = new ImovelTestesMedicaoConsumo();

				// Seta o id em um objeto do tipo imóvel
				imovelAPesquisar.setId(imovelId);

				// Pesquisa o imóvel para obter as informações de ligação de
				// água
				colecaoMedicaoConsumoLigacaoAgua = repositorioMicromedicao.pesquisarImovelTesteMedicaoConsumoLigacaoAgua(faturamentoGrupo,
								imovelAPesquisar);
				// Pesquisa o imóvel para obter as informações de ligação de
				// poço
				/* colecaoMedicaoConsumoPoco = */repositorioMicromedicao.pesquisarImovelTesteMedicaoConsumoPoco(faturamentoGrupo,
								imovelAPesquisar);
				// Pesquisa o imóvel para obter as informações de ligação de
				// esgoto
				colecaoMedicaoConsumoLigacaoEsgoto = repositorioMicromedicao.pesquisarImovelTesteMedicaoConsumoLigacaoEsgoto(
								faturamentoGrupo, imovelAPesquisar);

				// Pesquisa a ligação situacao do imóvel
				colecaoImovelLigacaoSituacao = repositorioMicromedicao.pesquisarImovelLigacaoSituacao(imovelAPesquisar);

				if(colecaoImovelLigacaoSituacao != null && !colecaoImovelLigacaoSituacao.isEmpty()){

					Object[] imovelLigacaoSituacaoArray = Util.retonarObjetoDeColecaoArray(colecaoImovelLigacaoSituacao);

					// Seta o ligação situação de água e esgoto
					imovelTestesMedicaoConsumo.setIdLigacaoAguaSituacao((Integer) imovelLigacaoSituacaoArray[1]);
					imovelTestesMedicaoConsumo.setIdLigacaoEsgotoSituacao((Integer) imovelLigacaoSituacaoArray[2]);
				}

				if(colecaoMedicaoConsumoLigacaoAgua != null && !colecaoMedicaoConsumoLigacaoAgua.isEmpty()){
					// Obtém os dados necessários de ligação de água
					imovelTestesMedicaoConsumoLigacaoAgua = (ImovelTestesMedicaoConsumo) Util
									.retonarObjetoDeColecao(colecaoMedicaoConsumoLigacaoAgua);

					// Seta o tipo de medição
					medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);
					// Obtém o consumo médio do hidrômetro
					consumoMedioHidrometroLigacaoAgua = obterConsumoMedioHidrometro(imovelAPesquisar, sistemaParametro, medicaoTipo);

					// Obtém o consumo médio do imóvel
					if(!poco){
						consumoMedioImovelLigacaoAgua = obterConsumoMedioImovel(imovelAPesquisar, sistemaParametro);
						imovelTestesMedicaoConsumo.setNumeroMedioConsumoImovel(Integer.valueOf(consumoMedioImovelLigacaoAgua[0]));
					}
					// Para obter a leitura anterior
					medicaoHistorico = new MedicaoHistorico();
					medicaoHistorico.setLeituraAnteriorInformada(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAnteriorInformadaAgua());
					medicaoHistorico.setLeituraAtualInformada(imovelTestesMedicaoConsumoLigacaoAgua.getNumeroLeituraAtualAgua().intValue());
					medicaoHistorico.setLeituraAnteriorFaturamento(imovelTestesMedicaoConsumoLigacaoAgua.getNumeroLeituraAnteriorAgua()
									.intValue());

					hidrometro = new Hidrometro();
					hidrometro.setNumeroDigitosLeitura(imovelTestesMedicaoConsumoLigacaoAgua.getNumeroDigitosLeituraAgua());

					// Seta os valores de água
					imovelTestesMedicaoConsumo.setNumeroLeituraAnteriorAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAnteriorAgua());
					imovelTestesMedicaoConsumo.setNumeroLeituraAnteriorInformadaAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroLeituraAnteriorInformadaAgua());
					imovelTestesMedicaoConsumo.setIdLeituraSituacaoAnteriorAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdLeituraSituacaoAnteriorAgua());
					imovelTestesMedicaoConsumo.setNumeroLeituraAtualAgua(imovelTestesMedicaoConsumoLigacaoAgua.getNumeroLeituraAtualAgua());
					imovelTestesMedicaoConsumo.setIdLeituraSituacaoAtualAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdLeituraSituacaoAtualAgua());
					imovelTestesMedicaoConsumo.setNumeroLeituraAtualAgua(imovelTestesMedicaoConsumoLigacaoAgua.getNumeroLeituraAtualAgua());
					imovelTestesMedicaoConsumo.setIdLeituraAnormalidadeAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdLeituraAnormalidadeAgua());
					imovelTestesMedicaoConsumo.setIdFaturamentoSituacaoTipo(imovelTestesMedicaoConsumoLigacaoAgua
									.getIdFaturamentoSituacaoTipo());
					imovelTestesMedicaoConsumo.setNumeroConsumoMinimoAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroConsumoMinimoAgua());
					imovelTestesMedicaoConsumo.setNumeroDigitosLeituraAgua(imovelTestesMedicaoConsumoLigacaoAgua
									.getNumeroDigitosLeituraAgua());
					imovelTestesMedicaoConsumo.setIdHidrometroAgua(imovelTestesMedicaoConsumoLigacaoAgua.getIdHidrometroAgua());

					imovelTestesMedicaoConsumo.setNumeroMedioConsumoHidrometroAgua(Integer.valueOf(consumoMedioHidrometroLigacaoAgua[0]));

					faixaLeituraEsperada = calcularFaixaLeituraEsperada(consumoMedioImovelLigacaoAgua[0], medicaoHistorico, hidrometro,
									null);

					// Inicial
					imovelTestesMedicaoConsumo.setNumeroFaixaIncialAgua(Integer.valueOf(faixaLeituraEsperada[0]));
					// Final
					imovelTestesMedicaoConsumo.setNumeroFaixaFinalAgua(Integer.valueOf(faixaLeituraEsperada[1]));

					System.out.println("---Leitura Anterior Água...............:"
									+ imovelTestesMedicaoConsumo.getNumeroLeituraAnteriorAgua());
					System.out.println("---Leitura Anterior Informada Água...............:"
									+ imovelTestesMedicaoConsumo.getNumeroLeituraAnteriorInformadaAgua());
					System.out.println("---Leitura Atual Água..................:" + imovelTestesMedicaoConsumo.getNumeroLeituraAtualAgua());

					ligacaoAgua = true;

				}

				/*---POÇO
				 if (colecaoMedicaoConsumoPoco != null
				 && !colecaoMedicaoConsumoPoco.isEmpty()) {
				 //Obtém os dados necessários do poço
				 imovelTestesMedicaoConsumoPoco = (ImovelTestesMedicaoConsumo) Util
				 .retonarObjetoDeColecao(colecaoMedicaoConsumoPoco);

				 //Seta o tipo de medição
				 medicaoTipo.setId(MedicaoTipo.POCO);
				 //Obtém o consumo médio do hidrômetro
				 consumoMedioHidrometroPoco = obterConsumoMedioHidrometro(
				 imovel, sistemaParametro, medicaoTipo);
				 //Obtém o consumo médio do imóvel

				 if (!ligacaoAgua) {
				 consumoMedioImovelPoco = obterConsumoMedioHidrometro(
				 imovel, sistemaParametro, medicaoTipo);
				 imovelTestesMedicaoConsumo
				 .setNumeroMedioConsumoImovel(new Integer(
				 consumoMedioImovelPoco[0]));
				 }
				 //Para obter a leitura anterior
				 medicaoHistorico = new MedicaoHistorico();
				 medicaoHistorico
				 .setLeituraAnteriorInformada(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAnteriorInformadaPoco());
				 medicaoHistorico
				 .setLeituraAtualInformada(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAtualPoco().intValue());
				 medicaoHistorico
				 .setLeituraAnteriorFaturamento(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAnteriorPoco().intValue());

				 hidrometro = new Hidrometro();
				 hidrometro
				 .setNumeroDigitosLeitura(imovelTestesMedicaoConsumoPoco
				 .getNumeroDigitosLeituraPoco());

				 //Seta os valores de poço
				 imovelTestesMedicaoConsumo
				 .setNumeroLeituraAnteriorPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAnteriorPoco());
				 imovelTestesMedicaoConsumo
				 .setNumeroLeituraAnteriorInformadaPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAnteriorInformadaPoco());
				 imovelTestesMedicaoConsumo
				 .setIdLeituraSituacaoAnteriorPoco(imovelTestesMedicaoConsumoPoco
				 .getIdLeituraSituacaoAnteriorPoco());
				 imovelTestesMedicaoConsumo
				 .setNumeroLeituraAtualPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAtualPoco());
				 imovelTestesMedicaoConsumo
				 .setIdLeituraSituacaoAtualPoco(imovelTestesMedicaoConsumoPoco
				 .getIdLeituraSituacaoAtualPoco());
				 imovelTestesMedicaoConsumo
				 .setNumeroLeituraAtualPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroLeituraAtualPoco());
				 imovelTestesMedicaoConsumo
				 .setIdLeituraAnormalidadePoco(imovelTestesMedicaoConsumoPoco
				 .getIdLeituraAnormalidadePoco());
				 imovelTestesMedicaoConsumo
				 .setIdFaturamentoSituacaoTipo(imovelTestesMedicaoConsumoPoco
				 .getIdFaturamentoSituacaoTipo());
				 imovelTestesMedicaoConsumo
				 .setIdPoco(imovelTestesMedicaoConsumoPoco.getId());
				 imovelTestesMedicaoConsumo
				 .setNumeroDigitosLeituraPoco(imovelTestesMedicaoConsumoPoco
				 .getNumeroDigitosLeituraPoco());
				 imovelTestesMedicaoConsumo
				 .setIdHidrometroPoco(imovelTestesMedicaoConsumoPoco
				 .getIdHidrometroPoco());

				 faixaLeituraEsperada = calcularFaixaLeituraEsperada(
				 consumoMedioImovelPoco[0], medicaoHistorico,
				 hidrometro);

				 //Inicial
				 imovelTestesMedicaoConsumo
				 .setNumeroFaixaInicialPoco(new Integer(
				 faixaLeituraEsperada[0]));
				 //Final
				 imovelTestesMedicaoConsumo
				 .setNumeroFaixaFinalPoco(new Integer(
				 faixaLeituraEsperada[1]));

				 imovelTestesMedicaoConsumo
				 .setNumeroMedioConsumoHidrometroPoco(new Integer(
				 consumoMedioHidrometroPoco[0]));

				 poco = true;
				 } */

				if(colecaoMedicaoConsumoLigacaoEsgoto != null && !colecaoMedicaoConsumoLigacaoEsgoto.isEmpty()){
					// Obtém os dados necessários da ligação de esgoto
					imovelTestesMedicaoConsumoLigacaoEsgoto = (ImovelTestesMedicaoConsumo) Util
									.retonarObjetoDeColecao(colecaoMedicaoConsumoLigacaoEsgoto);

					imovelTestesMedicaoConsumo.setNumeroConsumoMinimoEsgoto(imovelTestesMedicaoConsumoLigacaoEsgoto
									.getNumeroConsumoMinimoEsgoto());
					imovelTestesMedicaoConsumo.setPercentualColetaLigacaoEsgoto(imovelTestesMedicaoConsumoLigacaoEsgoto
									.getPercentualColetaLigacaoEsgoto());

					if(!ligacaoAgua && !poco){
						/* consumoMedioImovelLigacaoEsgoto = */obterConsumoMedioImovel(imovelAPesquisar, sistemaParametro);
					}
				}

				if(imovelTestesMedicaoConsumoLigacaoAgua != null
								&& imovelTestesMedicaoConsumoLigacaoAgua.getIndicadorHidrometroAgua() != null){
					imovelTestesMedicaoConsumo.setIndicadorHidrometroAgua(Integer.valueOf(1));
				}else{
					imovelTestesMedicaoConsumo.setIndicadorHidrometroAgua(Integer.valueOf(2));
				}

				if(imovelTestesMedicaoConsumoPoco != null && imovelTestesMedicaoConsumoPoco.getIndicadorHidrometroPoco() != null){
					imovelTestesMedicaoConsumo.setIndicadorHidrometroPoco(Integer.valueOf(1));
				}else{
					imovelTestesMedicaoConsumo.setIndicadorHidrometroPoco(Integer.valueOf(2));
				}

				// Obtém a quantidade de economia(s) do imóvel
				quantidadeEconomias = getControladorImovel().obterQuantidadeEconomias(imovelAPesquisar);
				imovelTestesMedicaoConsumo.setQuantidadeEconomias(quantidadeEconomias);
				imovelTestesMedicaoConsumo.setId(imovelId);

				imovelTestesMedicaoConsumo.setUltimaAlteracao(new Date());

				repositorioMicromedicao.inserirBat(imovelTestesMedicaoConsumo);

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0002] - Determinar
	 * Dados para Faturamento de Esgoto
	 * 
	 * @author Leonardo Vieira
	 * @date 06/12/2006
	 * @author eduardo henrique
	 * @date 31/01/2009 Adição de tratamento para não determinação de Consumo.
	 * @author Saulo Lima
	 * @date 05/10/2009 Alterações para TEE (Tratamento Esgoto Especial)
	 */
	// public void determinarDadosFaturamentoEsgoto(Imovel imovel, int[]
	// consumoMedioImovel,
	// ConsumoHistorico consumoHistoricoEsgoto,
	// ConsumoHistorico consumoHistoricoAgua, int quantidadeEconomias,
	// SistemaParametro
	// sistemaParametro, Rota rota,
	// Collection colecaoInserirConsumoHistoricoEsgoto, FaturamentoGrupo
	// faturamentoGrupo,
	// Collection colecaoInserirMedicaoHistoricoEsgoto,
	// Collection colecaoAtualizarMedicaoHistoricoEsgoto, EsferaPoder
	// esferaPoder) throws
	// ControladorException {
	//
	//
	// // Cria objeto
	// MedicaoHistorico medicaoHistoricoPoco = null;
	// MedicaoTipo medicaoTipo = null;
	//
	// // Caso o imóvel possua hidrômetro no poco
	// if (imovel.getHidrometroInstalacaoHistorico() != null) {
	//
	// // [SB0005] - Determinar Dados para Faturamento de Esgoto Medido no Poço
	// medicaoHistoricoPoco = new MedicaoHistorico();
	//
	// medicaoTipo = new MedicaoTipo();
	// medicaoTipo.setId(MedicaoTipo.POCO);
	//
	// // [SB0013] - Obter Dados do Histórico de Medição
	// medicaoHistoricoPoco = this.obterDadosHistoricoMedicao(faturamentoGrupo,
	// imovel, medicaoTipo,
	// sistemaParametro);
	//
	// medicaoHistoricoPoco.setImovel(imovel);
	//
	// // Alteração solicitada por Luciene em 08/10/2008. Implementada por
	// Virgínia Melo.
	// // Iniciando este campo sempre com o valor do Mês anterior, não haverá
	// problema
	// // de crédito quando esta funcionalidade for executada mais de uma vez.
	// Collection colecaoParmsMedicaoAnterior = null;
	// int anoMesReferencia = medicaoHistoricoPoco.getAnoMesReferencia();
	// int anoMesAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia, 1);
	//
	// // Pesquisa pela Medição Histórico do Mês Anterior.
	// try {
	// colecaoParmsMedicaoAnterior =
	// repositorioMicromedicao.pesquisarMedicaoHistoricoAnterior(Collections.singletonList(imovel),
	// anoMesAnterior, medicaoTipo.getId());
	// } catch (ErroRepositorioException e) {
	// throw new ControladorException("erro.sistema", e);
	// }
	//
	// // Caso não encontre registro, o Crédito Anterior será ZERO.
	// if (colecaoParmsMedicaoAnterior == null ||
	// colecaoParmsMedicaoAnterior.isEmpty()) {
	// medicaoHistoricoPoco.setConsumoCreditoAnterior(Integer.valueOf(0));
	// }
	//
	// Iterator colecaoParmsMedicaoAnteriorIterator =
	// colecaoParmsMedicaoAnterior.iterator();
	//
	// while (colecaoParmsMedicaoAnteriorIterator.hasNext()) {
	// Object[] dadosAnterioresMedicaoHistorico = (Object[])
	// colecaoParmsMedicaoAnteriorIterator.next();
	//
	// if (dadosAnterioresMedicaoHistorico[7] != null) {
	// medicaoHistoricoPoco.setConsumoCreditoAnterior((Integer)
	// dadosAnterioresMedicaoHistorico[7]);
	// }
	// }
	// // Fim nova alteração - 08/10/2008
	//
	// // Alteração solicitada por Aryed 10/12/2007 e realizada por Leonardo
	// Vieira na mesma data
	// // O consumo médio do hidrômetro deve ser igual do do imóvel
	//
	// // [UC0102] - Obter Consumo Médio do Hidrômetro
	// int[] consumoMedioHidrometro = consumoMedioImovel;
	//
	// /* obterConsumoMedioHidrometro(imovel, sistemaParametro, medicaoTipo); */
	//
	// medicaoHistoricoPoco.setConsumoMedioHidrometro(Integer.valueOf(consumoMedioHidrometro[0]));
	//
	// // [SB0012] - Obter Leitura Anterior
	// int leituraAnterior = this.obterLeituraAnterior(medicaoHistoricoPoco);
	//
	// // *******IMPRESSÃO EM TELA PARA TESTE********//
	// //System.out.println("---Consumo médio hidrômetro: " +
	// consumoMedioHidrometro[0]);
	// //System.out.println("---Leitura Anterior: " + leituraAnterior);
	// //System.out.println("---Leitura Atual Informada: " +
	// medicaoHistoricoPoco.getLeituraAtualInformada());
	//
	// // Leitura atual informada diferente de nulo
	// if (medicaoHistoricoPoco.getLeituraAtualInformada() != null) {
	//
	// // Leitura atual informada <<<MAIOR>>> que a leitura anterior obtida
	// if (medicaoHistoricoPoco.getLeituraAtualInformada().intValue() >
	// leituraAnterior) {
	//
	// // [SB0007] - Dados para Faturamento para Leitura Maior que a Anterior
	// this.dadosFaturamentoLeituraMaiorAnterior(medicaoHistoricoPoco,
	// consumoHistoricoEsgoto,
	// consumoMedioHidrometro[0], imovel);
	//
	// // Leitura atual informada <<<IGUAL>>> a leitura anterior obtida
	// } else if (medicaoHistoricoPoco.getLeituraAtualInformada().intValue() ==
	// leituraAnterior) {
	//
	// // [SB0008] - Dados para Faturamento para Leitura Igual a Anterior
	// this.dadosFaturamentoLeituraIgualAnterior(medicaoHistoricoPoco,
	// consumoHistoricoEsgoto,
	// medicaoTipo, imovel,
	// consumoHistoricoAgua);
	//
	// // Leitura atual informada <<<MENOR>>> a leitura anterior obtida
	// } else if (medicaoHistoricoPoco.getLeituraAtualInformada().intValue() <
	// leituraAnterior) {
	//
	// // [SB0009] - Dados para Faturamento para Leitura Menor que a Anterior
	// this.dadosFaturamentoLeituraMenorAnterior(imovel, consumoHistoricoEsgoto,
	// medicaoHistoricoPoco, sistemaParametro,
	// leituraAnterior, medicaoTipo, consumoMedioImovel,
	// consumoMedioHidrometro);
	// }
	//
	// // Caso a leitura atual inforamda seja igual 0 e a leitura anormalidade
	// de faturamento seja
	// nula
	// } else if (medicaoHistoricoPoco.getLeituraAtualInformada() == null &&
	// medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() == null) {
	//
	// // [SB0010] - Dados para Faturamento para Leitura Não Informada e Sem
	// Anormalidade de Leitura
	// this.dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(medicaoHistoricoPoco,
	// consumoHistoricoEsgoto, consumoMedioHidrometro,
	// leituraAnterior);
	// }
	//
	// // Sistema determina os dados para faturamento caso a anormalidade
	// // de faturamento seja diferente de nulo
	// if (medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() != null) {
	//
	// // [SB0011] - Dados para Faturamento Com Anormalidade de Leitura
	// this.dadosFaturamentoAnormalidadeLeitura(medicaoHistoricoPoco,
	// consumoHistoricoEsgoto,
	// consumoMedioHidrometro, leituraAnterior, imovel);
	// }
	//
	// /*
	// * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson Carvalho
	// *
	// * Sistema determina os dados para faturamento caso o imóvel esteja com
	// situação de
	// faturamento especial (DIFERENTE DE NULO) e que seja
	// * válido para esgoto.
	// */
	// if (imovel.getFaturamentoSituacaoTipo() != null &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto() != null
	// &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().intValue()
	// == 1) {
	//
	// // [SB0021] - Dados para Faturamento Especial do Medido
	// this.dadosFaturamentoEspecialMedido(medicaoHistoricoPoco,
	// consumoHistoricoEsgoto, imovel,
	// consumoMedioHidrometro, leituraAnterior);
	// }
	//
	// // se não conseguiu determinar Consumo, atribui-se 0
	// if (consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() == null) {
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(Integer.valueOf(0));
	// }
	//
	// // Obtém a quantidade de economias por categoria
	// Collection colecaoCategoria =
	// this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
	//
	// // [SB0014] - Verificar Estouro de Consumo
	// if (!verificarEstouroConsumo(consumoHistoricoEsgoto, imovel,
	// consumoMedioImovel,
	// consumoMedioHidrometro, sistemaParametro, medicaoTipo,
	// colecaoCategoria, medicaoHistoricoPoco, leituraAnterior)) {
	//
	// // [SB0015] - Verificar Alto Consumo
	// this.verificarAltoConsumo(consumoHistoricoEsgoto, consumoMedioImovel,
	// colecaoCategoria,
	// imovel, medicaoTipo, medicaoHistoricoPoco);
	// }
	//
	// if ((medicaoHistoricoPoco.getLeituraSituacaoAtual().getId().intValue() ==
	// LeituraSituacao.CONFIRMADA.intValue() || medicaoHistoricoPoco
	// .getLeituraSituacaoAtual().getId().intValue() ==
	// LeituraSituacao.REALIZADA.intValue())
	// && medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() == null) {
	//
	// // [SB0016] - Verificar Baixo Consumo
	// this.verificarBaixoConsumo(consumoHistoricoEsgoto, consumoMedioImovel,
	// colecaoCategoria,
	// imovel, medicaoTipo);
	// }
	//
	// // Customização para v0.05 - vsm 11.3
	// int minimoLigacao = 0;
	// int creditoExistente = 0;
	// int consumoCobrado = 0;
	//
	// // Caso esteja indicado o ajuste mensal do consumo
	// if (rota.getIndicadorAjusteConsumo() != null &&
	// rota.getIndicadorAjusteConsumo().intValue()
	// == Rota.INDICADOR_AJUSTE_MENSAL) {
	//
	// // [SB0017] - Ajuste Mensal do Consumo
	// this.ajusteMensalConsumo(medicaoHistoricoPoco, consumoHistoricoEsgoto,
	// imovel, medicaoTipo,
	// rota, minimoLigacao);
	// }
	//
	// // Caso exista Consumo a Ser Cobrado no Mês da ligação de água,
	// // o Consumo a Ser Cobrado no Mês de esgoto = (Cobrado no Mês da ligação
	// de água + Consumo a
	// Ser Cobrado no Mês);
	// // caso contrário, o Consumo a Ser Cobrado no Mês de esgoto = Consumo a
	// Ser Cobrado no Mês.
	// if (consumoHistoricoAgua != null &&
	// consumoHistoricoAgua.getNumeroConsumoFaturadoMes() !=
	// null) {
	//
	// // Seta o consumo histórico
	// Integer consumoFaturadoMes =
	// consumoHistoricoAgua.getNumeroConsumoFaturadoMes()
	// + consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
	//
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoFaturadoMes);
	// }
	//
	// if (imovel.getLigacaoEsgoto().getConsumoMinimo() != null) {
	// minimoLigacao = imovel.getLigacaoEsgoto().getConsumoMinimo().intValue();
	// }
	//
	// if (medicaoHistoricoPoco.getConsumoCreditoAnterior() != null) {
	// creditoExistente =
	// medicaoHistoricoPoco.getConsumoCreditoAnterior().intValue();
	// }
	//
	// if (consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null) {
	// consumoCobrado =
	// consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue();
	// }
	//
	// if (consumoHistoricoEsgoto.getConsumoTipo() == null) {
	// ConsumoTipo consumoTipoTemp = new ConsumoTipo();
	// consumoTipoTemp.setId(ConsumoTipo.INDEFINIDO);
	// consumoHistoricoEsgoto.setConsumoTipo(consumoTipoTemp);
	// } else if (consumoHistoricoEsgoto.getConsumoTipo().getId() == null) {
	// consumoHistoricoEsgoto.getConsumoTipo().setId(ConsumoTipo.INDEFINIDO);
	// }
	//
	// if (medicaoHistoricoPoco.getConsumoCreditoAnterior() != null &&
	// consumoHistoricoEsgoto.getConsumoTipo().getId() == ConsumoTipo.REAL
	// && consumoCobrado >= minimoLigacao) {
	//
	// if (creditoExistente > 0) {
	//
	// // Seta o consumo histórico
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoCobrado +
	// creditoExistente);
	//
	// // Credito Faturado será o crédito existente;
	// consumoHistoricoEsgoto.setConsumoMinimoCreditado(creditoExistente);
	//
	// // Zera o credito anterior pois utilizou tudo
	// medicaoHistoricoPoco.setConsumoCreditoAnterior(Integer.valueOf(0));
	//
	// // Ajuste, pois ao utilizar todo o crédito, pode ser q o valor n seja
	// divisivel pela qtd de
	// economias
	// this.ajusteConsumoMultiploQuantidadeEconomias(imovel,
	// medicaoHistoricoPoco,
	// consumoHistoricoEsgoto, quantidadeEconomias);
	//
	// } else {
	// // o Consumo a Ser Cobrado no mês será o proprio consumo + crédito
	// existente limitando o
	// // resultado ao mínimo da ligação e o Crédito Faturado será o crédito
	// utilizado.
	//
	// // Pode ser utilizado todo o crédito que mesmo assim não chega ao mínimo
	// da ligação
	// if (consumoCobrado + creditoExistente >= minimoLigacao) {
	//
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoCobrado +
	// creditoExistente);
	// consumoHistoricoEsgoto.setConsumoMinimoCreditado(creditoExistente);
	//
	// // Zera o credito anterior pois utilizou tudo
	// medicaoHistoricoPoco.setConsumoCreditoAnterior(Integer.valueOf(0));
	//
	// // Ajuste, pois ao utilizar todo o crédito, pode ser q o valor n seja
	// divisivel pela qtd de
	// economias
	// this.ajusteConsumoMultiploQuantidadeEconomias(imovel,
	// medicaoHistoricoPoco,
	// consumoHistoricoEsgoto, quantidadeEconomias);
	//
	// // Não pode usar todo o crédito pois tornará o valor a ser pago menor que
	// o mínimo
	// } else {
	//
	// // Valor que seria cobrado caso pudesse ser menor que o mínimo.
	// int valorMenorQueMinimo = consumoCobrado + creditoExistente;
	//
	// // Calcula em quanto passou do mínimo
	// int valorUltrapassado = minimoLigacao - valorMenorQueMinimo;
	//
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(minimoLigacao);
	// consumoHistoricoEsgoto.setConsumoMinimoCreditado(creditoExistente +
	// valorUltrapassado);
	//
	// // Atualiza o credito anterior
	// medicaoHistoricoPoco.setConsumoCreditoAnterior(medicaoHistoricoPoco.getConsumoCreditoAnterior()
	// - (creditoExistente + valorUltrapassado));
	// }
	// }
	// }
	//
	// } else {
	//
	// // [SB0006] - Determinar Dados Para Faturamento de Esgoto Sem Poço ou Com
	// Poço Sem Medição
	// int consumoMinimoLigacao = 0;
	//
	// // Caso exista consumo a ser cobrado para ligação de água
	// if (imovel.getLigacaoAgua() != null && consumoHistoricoAgua != null &&
	// consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null) {
	//
	// // O consumo a ser cobrado de esgoto será igual ao de ligação de agua
	// juntamente com o
	// consumo tipo
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoHistoricoAgua.getNumeroConsumoFaturadoMes());
	// consumoHistoricoEsgoto.setConsumoTipo(consumoHistoricoAgua.getConsumoTipo());
	//
	// } else {
	//
	// // [UC0105] - Obter Consumo Mínimo da Ligacao
	// consumoMinimoLigacao = this.obterConsumoMinimoLigacao(imovel, null);
	//
	// // O consumo a ser cobrado será o consumo mínimo da ligação e tipo de
	// consumo não medido
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMinimoLigacao));
	//
	// ConsumoTipo consumoTipo = new ConsumoTipo();
	// consumoTipo.setId(ConsumoTipo.NAO_MEDIDO);
	//
	// // Seta o consumo tipo
	// consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);
	//
	// /*
	// * if (medicaoHistorico.getNumeroConsumoInformado() != null) {
	// *
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoInformado());
	// * consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_INFORMADO);
	// * }
	// */
	// }
	//
	// /*
	// * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson Carvalho
	// *
	// * Sistema determina os dados para faturamento caso o imóvel esteja com
	// situação de
	// faturamento especial (DIFERENTE DE NULO) e que seja
	// * válido para esgoto.
	// */
	// if (imovel.getFaturamentoSituacaoTipo() != null &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto() != null
	// &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().intValue()
	// == 1) {
	//
	// // [SB0022] - Dados para Faturamento Especial do Não Medido.
	// this.dadosFaturamentoEspecialNaoMedido(consumoHistoricoEsgoto,
	// consumoMedioImovel,
	// imovel,consumoMinimoLigacao);
	// }
	//
	// // Calcula (percentualColeta / 100) * consumo a ser cobrado mês
	// BigDecimal fatorColeta =
	// imovel.getLigacaoEsgoto().getPercentualAguaConsumidaColetada().divide(new
	// BigDecimal("100"));
	// fatorColeta = fatorColeta.multiply(new
	// BigDecimal(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue()));
	//
	// // Arrendonda o resultado (CRIA O FATOR DE COLETA)
	// int consumoSerCobradoMes = Util.arredondar(fatorColeta);
	//
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoSerCobradoMes));
	//
	// // Caso o consumo a ser cobrado mês seja inferior ao consumo mínimo
	// if ((imovel.getLigacaoEsgoto().getConsumoMinimo() != null)
	// && (consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue() <
	// imovel.getLigacaoEsgoto().getConsumoMinimo().intValue())) {
	//
	// // O consumo a ser cobrado mês será o consumo mínimo
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(imovel.getLigacaoEsgoto().getConsumoMinimo());
	//
	// // A anormalidade de consumo será o consumo mínimo fixado de esgoto
	// ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
	// consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_MINIMO_FIXADO);
	// consumoHistoricoEsgoto.setConsumoAnormalidade(consumoAnormalidade);
	// }
	// }
	//
	// if (imovel.getHidrometroInstalacaoHistorico() != null) {
	//
	// // Caso o consumo informado tenha sido informado
	// if (medicaoHistoricoPoco.getNumeroConsumoInformado() != null) {
	//
	// // Seta o consumo histórico
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(medicaoHistoricoPoco.getNumeroConsumoInformado());
	//
	// ConsumoTipo consumoTipo = new ConsumoTipo();
	// consumoTipo.setId(ConsumoTipo.INFORMADO);
	// consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);
	//
	// // Seta o consumo anormalidade
	// ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
	// consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_INFORMADO);
	// consumoHistoricoEsgoto.setConsumoAnormalidade(consumoAnormalidade);
	// }
	// }
	//
	// // Customização v5.05
	// /*
	// * 2.4. Caso o Consumo a Ser Cobrado no Mês seja inferior ao mínimo da
	// ligação <<Inclui>>
	// [UC0105 – Obter Consumo Mínimo da Ligação], o
	// * Consumo a Ser Cobrado no Mês de esgoto será o consumo mínimo da ligação
	// e o de Tipo de
	// Consumo será o valor correspondente a “mínimo
	// * fixado” na tabela CONSUMO_TIPO.
	// */
	// int consumoMinimo = 0;
	// consumoMinimo = this.obterConsumoMinimoLigacao(imovel, null);
	//
	// if (consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue() <
	// consumoMinimo) {
	//
	// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoMinimo);
	//
	// ConsumoTipo consumoTipo = new ConsumoTipo();
	// consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);
	// consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);
	// }
	//
	// // ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistoricoPoco,
	// consumoHistoricoEsgoto, quantidadeEconomias);
	//
	// if (imovel.getHidrometroInstalacaoHistorico() != null) {
	//
	// // Seta o timestamp do histórico de medição do poço
	// medicaoHistoricoPoco.setUltimaAlteracao(new Date());
	//
	// if (medicaoHistoricoPoco.getId() == null) {
	// colecaoInserirMedicaoHistoricoEsgoto.add(medicaoHistoricoPoco);
	// } else {
	// colecaoAtualizarMedicaoHistoricoEsgoto.add(medicaoHistoricoPoco);
	// }
	//
	// int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());
	//
	// if
	// (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM))
	// {
	//
	// // Verifica se é faturamento antecipado
	// if
	// (imovel.getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
	// && (mes == 11)
	// && esferaPoder != null
	// && esferaPoder.getId() != null
	// && (esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.MUNICIPAL))
	// || esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.ESTADUAL))
	// || esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.FEDERAL)))) {
	//
	// MedicaoHistorico medicaoHistoricoPosteriorPoco = new MedicaoHistorico();
	//
	// // Adiciona 1 ao mês/ano de faturamento para gerar o mês de dezembro
	// sistemaParametro.setAnoMesFaturamento(Util.somaMesAnoMesReferencia(sistemaParametro.getAnoMesFaturamento(),
	// 1));
	//
	// medicaoHistoricoPosteriorPoco =
	// this.obterDadosHistoricoMedicao(faturamentoGrupo, imovel,
	// medicaoTipo, sistemaParametro);
	//
	// // [UC0102] - Obter Consumo Médio do Hidrômetro
	// // int[] consumoMedioHidrometroPosterior =
	// obterConsumoMedioHidrometro(imovel,
	// sistemaParametro, medicaoTipo);
	//
	// // Retorna ao mês de referência atual
	// sistemaParametro.setAnoMesFaturamento(Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(),
	// 1));
	//
	// medicaoHistoricoPosteriorPoco.setLeituraAnormalidadeFaturamento(medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento());
	// medicaoHistoricoPosteriorPoco.setLeituraAnteriorFaturamento(medicaoHistoricoPoco.getLeituraAtualFaturamento());
	// medicaoHistoricoPosteriorPoco.setDataLeituraAnteriorFaturamento(medicaoHistoricoPoco.getDataLeituraAtualFaturamento());
	//
	// Date dataAtual = new Date();
	// medicaoHistoricoPosteriorPoco.setDataLeituraAtualFaturamento(Util.adicionarNumeroDiasDeUmaData(dataAtual,
	// 30));
	//
	// Integer leituraAtual = medicaoHistoricoPoco.getLeituraAtualFaturamento()
	// +
	// consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
	// medicaoHistoricoPosteriorPoco.setLeituraAtualFaturamento(leituraAtual);
	//
	// // Seta o consumo médio do hidrômetro
	// // medicaoHistoricoPosterior.setConsumoMedioHidrometro(new
	// Integer(consumoMedioHidrometroPosterior[0]));
	//
	// medicaoHistoricoPosteriorPoco.setConsumoMedioHidrometro(medicaoHistoricoPoco.getConsumoMedioHidrometro());
	// medicaoHistoricoPosteriorPoco.setUltimaAlteracao(new Date());
	//
	// if (medicaoHistoricoPosteriorPoco.getId() == null) {
	// colecaoInserirMedicaoHistoricoEsgoto.add(medicaoHistoricoPosteriorPoco);
	// } else {
	// colecaoAtualizarMedicaoHistoricoEsgoto.add(medicaoHistoricoPosteriorPoco);
	// }
	// }
	// }
	// }
	//
	// // Seta o imóvel
	// consumoHistoricoEsgoto.setImovel(imovel);
	//
	// // Seta o tipo de ligação
	// LigacaoTipo ligacaoTipo = new LigacaoTipo();
	//
	// ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
	// consumoHistoricoEsgoto.setLigacaoTipo(ligacaoTipo);
	//
	// // Seta a referência de faturamento
	// consumoHistoricoEsgoto.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
	//
	// // Seta o indicador alteração últimos consumos
	// consumoHistoricoEsgoto.setIndicadorAlteracaoUltimosConsumos(ConstantesSistema.NAO);
	//
	// // Seta o indicador ajuste
	// consumoHistoricoEsgoto.setIndicadorAjuste(rota.getIndicadorAjusteConsumo());
	//
	// // Seta o consumo rateio
	// consumoHistoricoEsgoto.setConsumoRateio(null);
	//
	// // Seta o consumo histórico condomínio
	// consumoHistoricoEsgoto.setConsumoHistoricoCondominio(null);
	//
	// // Seta o indicador imóvel condomínio
	// consumoHistoricoEsgoto.setIndicadorImovelCondominio(imovel.getIndicadorImovelCondominio());
	//
	// // Seta o consumo médio do imóvel
	// consumoHistoricoEsgoto.setConsumoMedio(Integer.valueOf(consumoMedioImovel[0]));
	//
	// // Seta o consumo mínimo de água
	// if (imovel.getLigacaoEsgoto() != null) {
	// consumoHistoricoEsgoto.setConsumoMinimo(imovel.getLigacaoEsgoto().getConsumoMinimo());
	//
	// // Seta o percentual de coleta
	// consumoHistoricoEsgoto.setPercentualColeta(imovel.getLigacaoEsgoto().getPercentualAguaConsumidaColetada());
	// }
	//
	// // Seta a última alteração
	// consumoHistoricoEsgoto.setUltimaAlteracao(new Date());
	//
	// // Seta o poco tipo
	// consumoHistoricoEsgoto.setPocoTipo(imovel.getPocoTipo());
	//
	// // Seta o faturamento situação tipo
	// consumoHistoricoEsgoto.setFaturamentoSituacaoTipo(imovel.getFaturamentoSituacaoTipo());
	//
	// // Faturar os imóveis sem consumo de água que sejam TEE
	// boolean faturaEsgotoSemConsumo =
	// this.verificarFaturamentoEsgotoSemConsumoAgua(imovel,
	// consumoHistoricoAgua);
	//
	// /*
	// * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson Carvalho
	// * Seta o indicador de faturamento paralisação
	// */
	// if (!faturaEsgotoSemConsumo
	// || (imovel.getFaturamentoSituacaoTipo() != null
	// &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorFaturamentoParalisacaoEsgoto()
	// != null
	// &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorFaturamentoParalisacaoEsgoto().intValue()
	// == 1
	// && imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto() != null
	// &&
	// imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().intValue()
	// == 1)) {
	// consumoHistoricoEsgoto.setIndicadorFaturamento(ConstantesSistema.NAO);
	// } else {
	// consumoHistoricoEsgoto.setIndicadorFaturamento(ConstantesSistema.SIM);
	// }
	//
	// // Seta o rateio tipo
	// if (consumoHistoricoEsgoto.getId() == null) {
	// RateioTipo rateioTipo = new RateioTipo();
	// rateioTipo.setId(RateioTipo.SEM_RATEIO);
	// consumoHistoricoEsgoto.setRateioTipo(rateioTipo);
	// }
	//
	// colecaoInserirConsumoHistoricoEsgoto.add(consumoHistoricoEsgoto);
	//
	// int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());
	//
	// if
	// (sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM))
	// {
	//
	// // Verifica se é faturamento antecipado
	// if
	// (imovel.getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
	// && (mes == 11)
	// && esferaPoder != null
	// && esferaPoder.getId() != null
	// && (esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.MUNICIPAL))
	// || esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.ESTADUAL)) ||
	// esferaPoder.getId().equals(
	// Integer.valueOf(EsferaPoder.FEDERAL)))) {
	//
	// ConsumoHistorico consumoHistoricoEsgotoPosterior = new
	// ConsumoHistorico(consumoHistoricoEsgoto);
	//
	// consumoHistoricoEsgotoPosterior.setReferenciaFaturamento(Util.somaMesAnoMesReferencia(consumoHistoricoEsgoto
	// .getReferenciaFaturamento(), 1));
	//
	// consumoHistoricoEsgotoPosterior.setUltimaAlteracao(new Date());
	//
	// ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
	// consumoAnormalidade.setId(ConsumoAnormalidade.FATURAMENTO_ANTEIPADO);
	// consumoHistoricoEsgotoPosterior.setConsumoAnormalidade(consumoAnormalidade);
	// colecaoInserirConsumoHistoricoEsgoto.add(consumoHistoricoEsgotoPosterior);
	// }
	// }
	// }
	//

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0002] - Determinar
	 * Dados para Faturamento de Esgoto Se o volume determinado para esgoto for
	 * zero ou nulo, e o imóvel seja ligado de esgoto e com “Poço TEE“, faturar
	 * o esgoto pelo volume mínimo da ligação
	 * 
	 * @author Saulo Lima
	 * @date 15/10/2009
	 * @param imovel
	 * @param consumoHistoricoAgua
	 * @return boolean TRUE - Faturar FALSE - Não Faturar
	 * @throws ControladorException
	 */
	private boolean verificarFaturamentoEsgotoSemConsumoAgua(Imovel imovel, ConsumoHistorico consumoHistoricoAgua)
					throws ControladorException{

		boolean retorno = false;

		// Verifica se é ligado de esgoto
		if(imovel.getLigacaoEsgotoSituacao() != null && imovel.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.LIGADO)){

			// Verifica se houve consumo
			if(consumoHistoricoAgua != null && consumoHistoricoAgua.getIndicadorFaturamento() != null
							&& consumoHistoricoAgua.getIndicadorFaturamento().equals(ConstantesSistema.SIM)
							&& consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null
							&& consumoHistoricoAgua.getNumeroConsumoFaturadoMes().intValue() > 0){
				retorno = true;

				// Verifica se é TEE
			}else if(imovel.getPocoTipo() != null && imovel.getPocoTipo().getId().equals(PocoTipo.POCO_TEE)){
				retorno = true;
			}
		}

		return retorno;
	}

	/**
	 * [UC0083] - Gerar Dados para Leitura
	 * [SF0001] - Gerar Arquivo Convencional
	 * ou Relação Autor: Sávio Luiz, Pedro Alexandre Data: 21/12/2005,
	 * 15/10/2007
	 * 
	 * @author eduardo henrique
	 * @date 05/09/2008 Alterado funcionamento para envio de e-mail após geração
	 *       do Arquivo Texto.
	 * @author eduardo henrique
	 * @date 07/01/2009 Paginação do hibernate desativada, por forma inadequada
	 *       de execução para o cache do Oracle.
	 * @param colecaoRota
	 * @param anoMesCorrente
	 * @param idGrupoFaturamentoRota
	 * @param idFuncionalidadeIniciada
	 * @return
	 * @throws ControladorException
	 */
	public Collection gerarDadosPorLeituraMicroColetor(Collection colecaoRota, Integer anoMesCorrente, Integer idGrupoFaturamentoRota,
					FuncionalidadeIniciada funcionalidade, Date dataPrevistaAtividadeLeitura, Collection collLeituraTipo)
					throws ControladorException{

		int idUnidadeIniciada = 0;

		try{

			// -------------------------
			//
			// Registrar o início do processamento da Unidade de
			// Processamento
			// do Batch
			//
			// -------------------------
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(funcionalidade.getId(),
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			// inicializa uma coleção de imoveis
			Collection objetosImoveis = new ArrayList();

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.GERAR_DADOS_PARA_LEITURA_MICRO_COLETOR);

			// cria uma coleção de imóvel por rota
			Collection imoveisPorRota = null;
			try{
				// recupera todos os imóveis da coleção de rotas do tipo
				// convencional

				imoveisPorRota = repositorioMicromedicao.pesquisarImoveisPorRotaOrdenadoPorInscricao(colecaoRota);

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			if(imoveisPorRota != null && !imoveisPorRota.isEmpty()){

				Iterator imovelporRotaIterator = imoveisPorRota.iterator();
				while(imovelporRotaIterator.hasNext()){
					// cria um array de objetos para pegar os parametros
					// de
					// retorno da pesquisa

					Object[] arrayImoveisPorRota = (Object[]) imovelporRotaIterator.next();

					// instancia um imóvel
					Imovel imovel = new Imovel();
					if(arrayImoveisPorRota[0] != null){
						// seta o id no imovel
						imovel.setId((Integer) arrayImoveisPorRota[0]);
					}

					if(arrayImoveisPorRota[1] != null){
						// instancia uma localidade para ser setado no
						// imóvel
						Localidade localidade = new Localidade();
						localidade.setId((Integer) arrayImoveisPorRota[1]);
						imovel.setLocalidade(localidade);
					}

					if(arrayImoveisPorRota[2] != null){
						// instancia um setor comercial para ser setado
						// no
						// imóvel
						SetorComercial setorComercial = new SetorComercial();
						setorComercial.setCodigo(Integer.parseInt(arrayImoveisPorRota[2].toString()));
						imovel.setSetorComercial(setorComercial);
					}
					Quadra quadra = new Quadra();
					if(arrayImoveisPorRota[3] != null){

						// instancia uma quadra para ser setado no
						// imóvel
						// Roteiro Empresa

						quadra = (Quadra) arrayImoveisPorRota[40];
						Integer numeroQuadra = (Integer) arrayImoveisPorRota[3];
						quadra.setNumeroQuadra(numeroQuadra);
						imovel.setQuadra(quadra);
					}

					if(arrayImoveisPorRota[4] != null){
						// seta o lote no imóvel
						imovel.setLote(Short.parseShort(arrayImoveisPorRota[4].toString()));
					}

					if(arrayImoveisPorRota[5] != null){
						// seta o lote no imóvel
						imovel.setSubLote(Short.parseShort(arrayImoveisPorRota[5].toString()));
					}
					if(arrayImoveisPorRota[6] != null){
						// instancia uma imovel perfil para ser setado
						// no
						// imóvel
						ImovelPerfil imovelPerfil = new ImovelPerfil();
						imovelPerfil.setId((Integer) arrayImoveisPorRota[6]);
						imovel.setImovelPerfil(imovelPerfil);
					}

					LigacaoAgua ligacaoAgua = new LigacaoAgua();
					if(arrayImoveisPorRota[7] != null){
						// instancia uma ligação agua para ser setado no
						// imóvel

						ligacaoAgua.setId((Integer) arrayImoveisPorRota[7]);
					}
					// instancia um hidrometro instalação historico para
					// ser
					// colocado na ligacao agua
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoLigacaoAgua = new HidrometroInstalacaoHistorico();
					if(arrayImoveisPorRota[8] != null){

						hidrometroInstalacaoHistoricoLigacaoAgua = (HidrometroInstalacaoHistorico) arrayImoveisPorRota[30];
						hidrometroInstalacaoHistoricoLigacaoAgua.setId((Integer) arrayImoveisPorRota[8]);
						MedicaoTipo medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId((Integer) arrayImoveisPorRota[26]);
						hidrometroInstalacaoHistoricoLigacaoAgua.setMedicaoTipo(medicaoTipo);
						ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoLigacaoAgua);

					}
					imovel.setLigacaoAgua(ligacaoAgua);

					// //instancia um hidrometro instalação historico
					// para
					// ser colocado no imovel
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel = new HidrometroInstalacaoHistorico();
					if(arrayImoveisPorRota[9] != null){

						hidrometroInstalacaoHistoricoImovel = (HidrometroInstalacaoHistorico) arrayImoveisPorRota[31];
						hidrometroInstalacaoHistoricoImovel.setId((Integer) arrayImoveisPorRota[9]);
						MedicaoTipo medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId((Integer) arrayImoveisPorRota[27]);
						hidrometroInstalacaoHistoricoImovel.setMedicaoTipo(medicaoTipo);
						imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoImovel);

					}
					// instancia a rota
					Rota rotaImovel = new Rota();

					if(arrayImoveisPorRota[10] != null){
						// seta o id da rota
						rotaImovel.setId((Integer) arrayImoveisPorRota[10]);
					}
					if(arrayImoveisPorRota[11] != null){
						// seta o indicador fiscalizador suprimido na
						// rota
						rotaImovel.setIndicadorFiscalizarSuprimido(Short.parseShort(arrayImoveisPorRota[11].toString()));
					}
					if(arrayImoveisPorRota[12] != null){
						// seta o indicador fiscalizador cortado na rota
						rotaImovel.setIndicadorFiscalizarCortado(Short.parseShort(arrayImoveisPorRota[12].toString()));
					}
					if(arrayImoveisPorRota[13] != null){
						// seta o indicador gerar fiscalizacao na rota
						rotaImovel.setIndicadorGerarFiscalizacao(Short.parseShort(arrayImoveisPorRota[13].toString()));
					}
					if(arrayImoveisPorRota[14] != null){
						// seta o indicador fgerar falsa faixa na rota
						rotaImovel.setIndicadorGerarFalsaFaixa(Short.parseShort(arrayImoveisPorRota[14].toString()));
					}
					if(arrayImoveisPorRota[15] != null){
						// seta o percentual geracao fiscalizacao na
						// rota
						rotaImovel.setPercentualGeracaoFiscalizacao((BigDecimal) (arrayImoveisPorRota[15]));
					}
					if(arrayImoveisPorRota[16] != null){
						// seta o percentual geracao faixa falsa na rota
						rotaImovel.setPercentualGeracaoFaixaFalsa((BigDecimal) (arrayImoveisPorRota[16]));
					}

					// Leiturista
					if(arrayImoveisPorRota[36] != null){

						Leiturista leiturista = new Leiturista();
						leiturista.setId((Integer) (arrayImoveisPorRota[36]));
						rotaImovel.setLeiturista(leiturista);
					}

					// Poço Tipo
					if(arrayImoveisPorRota[38] != null){

						PocoTipo pocoTipo = new PocoTipo();
						pocoTipo.setId((Integer) (arrayImoveisPorRota[38]));
						imovel.setPocoTipo(pocoTipo);
					}

					// Código da Rota
					if(arrayImoveisPorRota[39] != null){

						rotaImovel.setCodigo((Short) (arrayImoveisPorRota[39]));
					}

					// instancia a empresa
					Empresa empresa = new Empresa();
					if(arrayImoveisPorRota[17] != null){

						// seta o id na empresa
						empresa.setId((Integer) arrayImoveisPorRota[17]);

					}
					if(arrayImoveisPorRota[18] != null){

						// seta a descrição abreviada na empresa
						empresa.setDescricaoAbreviada(arrayImoveisPorRota[18].toString());

					}
					if(arrayImoveisPorRota[19] != null){

						// seta email da empresa
						empresa.setEmail(arrayImoveisPorRota[19].toString());

					}
					if(arrayImoveisPorRota[28] != null){

						// seta email da empresa
						empresa.setDescricao(arrayImoveisPorRota[28].toString());

					}

					// Roteiro Empresa
					if(arrayImoveisPorRota[29] != null){

						RoteiroEmpresa roteiroEmpresa = (RoteiroEmpresa) arrayImoveisPorRota[29];
						quadra.setRoteiroEmpresa(roteiroEmpresa);

						// Empresa
						if(arrayImoveisPorRota[32] != null){

							Empresa empresaRoteiro = new Empresa();
							empresaRoteiro.setId((Integer) arrayImoveisPorRota[32]);
							quadra.getRoteiroEmpresa().setEmpresa(empresaRoteiro);
						}

						imovel.setQuadra(quadra);
					}

					// seta a empresa na rota
					rotaImovel.setEmpresa(empresa);
					// instancia o faturamento
					FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
					if(arrayImoveisPorRota[20] != null){
						// seta o id no faturamentGrupo
						faturamentoGrupo.setId((Integer) arrayImoveisPorRota[20]);

					}
					if(arrayImoveisPorRota[21] != null){
						// seta o descrição no faturamentGrupo
						faturamentoGrupo.setDescricao((String) arrayImoveisPorRota[21]);
					}
					// seta o faturamento na rota
					rotaImovel.setFaturamentoGrupo(faturamentoGrupo);
					if(arrayImoveisPorRota[22] != null){
						// instancia a ligação esgoto situação
						LeituraTipo leituraTipo = new LeituraTipo();
						// seta o id na ligação esgoto situação
						leituraTipo.setId((Integer) arrayImoveisPorRota[22]);
						// seta a ligação esgoto situação no imovel
						rotaImovel.setLeituraTipo(leituraTipo);
					}

					// seta a rota na quadra
					quadra.setRota(rotaImovel);

					// Área Tipo
					if(arrayImoveisPorRota[37] != null){

						AreaTipo areaTipo = new AreaTipo();
						areaTipo.setDescricao((String) arrayImoveisPorRota[37]);
						quadra.setAreaTipo(areaTipo);
					}

					// seta a quadra no imovel
					imovel.setQuadra(quadra);
					imovel.setRota(rotaImovel);
					if(arrayImoveisPorRota[23] != null){
						// instancia a ligação agua situação
						LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
						// seta o id na ligação agua situação
						ligacaoAguaSituacao.setId((Integer) arrayImoveisPorRota[23]);
						ligacaoAguaSituacao.setIndicadorFaturamentoSituacao((Short) arrayImoveisPorRota[33]);
						// seta a ligação agua situação no imovel
						imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
					}
					if(arrayImoveisPorRota[24] != null){
						// instancia a ligação esgoto situação
						LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
						// seta o id na ligação esgoto situação
						ligacaoEsgotoSituacao.setId((Integer) arrayImoveisPorRota[24]);
						ligacaoEsgotoSituacao.setIndicadorFaturamentoSituacao((Short) arrayImoveisPorRota[34]);
						// seta a ligação esgoto situação no imovel
						imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
					}

					if(arrayImoveisPorRota[25] != null){
						// instancia o faturamento situacao tipo
						FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
						// seta o id no faturamento situacao tipo
						faturamentoSituacaoTipo.setIndicadorParalisacaoLeitura((Short) arrayImoveisPorRota[25]);
						// seta a ligação esgoto situação no imovel
						imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
					}

					// Consumo Tarifa
					if(arrayImoveisPorRota[35] != null){

						ConsumoTarifa consumoTarifa = new ConsumoTarifa();
						consumoTarifa.setId((Integer) arrayImoveisPorRota[35]);
						imovel.setConsumoTarifa(consumoTarifa);
					}

					// adiciona na coleção de imoveis
					// System.out.println("Adicionando imovel:" + imovel.getId()
					// + " na colecao");
					objetosImoveis.add(imovel);

				}

			}

			Collection<FaturamentoAtividadeCriterio> colecaoFaturamentoAtividadeCriterio = this
							.pesquisarFaturamentoAtividadeCriterioPorLeituraTipo(FaturamentoAtividade.GERAR_ARQUIVO_LEITURA,
											collLeituraTipo);

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// Instancia uma coleção que será usada para gerar o arquivo txt.
			Collection<Imovel> imoveisParaSerGerados = new ArrayList();

			Iterator imovelIterator = objetosImoveis.iterator();
			while(imovelIterator.hasNext()){
				// Recupera o imovel da coleção
				Imovel imovel = (Imovel) imovelIterator.next();

				// variavel responsável para entrar em uma das 4 condicões
				// abaixo
				boolean achouImovel = this.selecionarImovelParaFaturamento(imovel, anoMesCorrente, colecaoFaturamentoAtividadeCriterio);
				if(achouImovel){
					imoveisParaSerGerados.add(imovel);
				}
			}
			String idGrupoFaturamento = null;

			if(imoveisParaSerGerados != null && !imoveisParaSerGerados.isEmpty()){

				repositorioMicromedicao.removerMovimentoRoteiroEmpresa(anoMesCorrente, idGrupoFaturamentoRota);

				String nomeEmpresaAbreviado = null;

				// pega o id da empresa do objeto imovel.
				Integer idEmpresaOld = null;

				// cria uma variavel do tipo boolean para saber se é a mesma
				// empresa
				// ou
				// outra empresa.
				boolean mesmaEmpresa = false;

				// é usado para na faixa falsa saber se o hidrometro foi
				// selecionado
				// ou
				// não
				boolean hidrometroSelecionado = false;

				// é usado para criar o header do arquivo de leitura
				boolean headerArquivo = true;

				boolean headerFiscalizacao = true;

				Integer quantidadeRegistros = 0;

				Integer quantidadeImoveis = 0;

				Integer quantidadeRegistrosFiscalizacao = 0;

				String quantidadeRegistrosString = null;
				String quantidadeRegistrosFiscalizacaoString = null;

				StringBuilder arquivoTxt = new StringBuilder();

				StringBuilder arquivoHeaderFiscalizacao = new StringBuilder();

				StringBuilder arquivoTxtFiscalizacao = new StringBuilder();

				// cria as strings para mandar para o email
				String emailReceptor = null;
				String emailRemetente = null;
				String tituloMensagem = null;
				String corpoMensagem = null;

				Calendar dataCalendar = new GregorianCalendar();

				String ano = null;
				String mes = null;
				String dia = null;

				ListIterator imovelParaSerGeradoIterator = ((List) imoveisParaSerGerados).listIterator(0);

				Imovel imovelParaSerGerado = null;

				while(imovelParaSerGeradoIterator.hasNext()){
					boolean ligacaoAgua = false;
					boolean ligacaoPoco = false;

					// cria uma string builder para adicionar no arquivo que
					// será
					// mandado para a empresa
					// como também para ser adicionado no arquivo de
					// fiscalização.
					StringBuilder arquivoTxtLinha = new StringBuilder();

					imovelParaSerGerado = (Imovel) imovelParaSerGeradoIterator.next();

					// se for para criar o header do arquivo
					if(headerArquivo){

						// pega o id da empresa do objeto imovel.
						idEmpresaOld = imovelParaSerGerado.getRota().getEmpresa().getId();

						nomeEmpresaAbreviado = completaString(imovelParaSerGerado.getRota().getEmpresa().getDescricaoAbreviada(), 1);
						idGrupoFaturamento = completaString(imovelParaSerGerado.getRota().getFaturamentoGrupo().getId().toString(), 2);

						ano = "" + dataCalendar.get(Calendar.YEAR);
						mes = "" + (dataCalendar.get(Calendar.MONTH) + 1);
						dia = "" + dataCalendar.get(Calendar.DAY_OF_MONTH);

						mes = Util.adicionarZerosEsquedaNumero(2, mes);
						dia = Util.adicionarZerosEsquedaNumero(2, dia);

						arquivoTxt.append(nomeEmpresaAbreviado + "T" + idGrupoFaturamento + anoMesCorrente + dia + mes + ano + "000000");

						// manda o header do arquivo para falso
						headerArquivo = false;

						arquivoHeaderFiscalizacao.append(arquivoTxt);
						arquivoTxt.append(System.getProperty("line.separator"));

					}

					// Verifica se a empresa da rota que está na coleção é igual
					// a
					// empresa anterior
					if(imovelParaSerGerado.getRota().getEmpresa().getId().equals(idEmpresaOld)){
						mesmaEmpresa = true;

					}else{
						mesmaEmpresa = false;

					}

					if(mesmaEmpresa){
						// incrementa a quantidade de registros
						quantidadeRegistros = quantidadeRegistros + 1;

						quantidadeImoveis = quantidadeImoveis + 1;

						if(imovelParaSerGerado.getLigacaoAgua() != null && imovelParaSerGerado.getLigacaoAgua().getId() != null
										&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
										&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null){
							ligacaoAgua = true;
						}
						if(imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null
										&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId() != null){
							ligacaoPoco = true;
						}

						// inscrição do imovel

						arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovelParaSerGerado.getLocalidade().getId()));
						arquivoTxtLinha.append(Util
										.adicionarZerosEsquedaNumero(3, "" + imovelParaSerGerado.getSetorComercial().getCodigo()));
						arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovelParaSerGerado.getQuadra().getNumeroQuadra()));

						arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + +imovelParaSerGerado.getLote()));

						arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovelParaSerGerado.getSubLote()));

						// caso seja tipo ligação agua e poço cria a string
						// primeiro
						// com
						// tipo
						// ligação agua
						if(ligacaoAgua && ligacaoPoco){

							if(imovelParaSerGerado.getLigacaoAgua() != null
											&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
											&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null
											&& !imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId().equals("")){
								arquivoTxtLinha.append(Util.completaString(""
												+ imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getMedicaoTipo()
																.getId(), 1));
							}
							// caso não seja
						}else{
							// caso seja tipo ligação agua cria a string com
							// tipo
							// ligação agua
							if(ligacaoAgua){
								if(imovelParaSerGerado.getLigacaoAgua() != null
												&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
												&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null
												&& !imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId().equals(
																"")){
									arquivoTxtLinha.append(Util.completaString(""
													+ imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico()
																	.getMedicaoTipo().getId(), 1));
								}
							}else{
								// caso seja tipo ligação poço cria a string com
								// tipo
								// ligação poço
								if(ligacaoPoco){
									if(imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null
													&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId() != null
													&& !imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId().equals("")){
										arquivoTxtLinha.append(Util.completaString(""
														+ imovelParaSerGerado.getHidrometroInstalacaoHistorico().getMedicaoTipo().getId(),
														1));
									}
								}
							}
						}

						// id do grupo de faturamento
						arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, ""
										+ imovelParaSerGerado.getRota().getFaturamentoGrupo().getId()));

						// matricula do imóvel
						arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, "" + +imovelParaSerGerado.getId()));

						// id do perfil do imovel
						arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(1, "" + imovelParaSerGerado.getImovelPerfil().getId()));

						String nomeClienteUsuario = null;
						try{
							// Pesquisa o nome do cliente que tem o tipo de
							// relação
							// usuário.
							nomeClienteUsuario = repositorioClienteImovel.pesquisarNomeClientePorImovel(imovelParaSerGerado.getId());
						}catch(ErroRepositorioException e){
							throw new ControladorException("erro.sistema", e);
						}

						// nome do cliente usuário
						if(nomeClienteUsuario == null){
							nomeClienteUsuario = "";
						}

						// nome do cliente usuário
						arquivoTxtLinha.append(completaString(nomeClienteUsuario, 25));

						// Pesquisa o endereço do imovel passando o id
						String enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(imovelParaSerGerado.getId());
						if(enderecoImovel != null && !enderecoImovel.equals("")){
							// endereço do imóvel
							arquivoTxtLinha.append(completaString(enderecoImovel, 50));
						}else{
							arquivoTxtLinha.append(completaString("", 50));
						}

						// Dados do Hidrometro

						// caso seja tipo ligação agua e poço cria a string
						// primeiro
						// com
						// tipo
						// ligação agua
						Short numeroDigitosHidrometro = null;
						StringBuilder dadosHidrometro = null;
						if(ligacaoAgua && ligacaoPoco){
							Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);
							dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
							numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];
							arquivoTxtLinha.append(dadosHidrometro);
							// caso não seja
						}else{
							// caso seja tipo ligação agua cria a string com
							// tipo
							// ligação agua
							if(ligacaoAgua){
								Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovelParaSerGerado);
								dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
								numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];
								arquivoTxtLinha.append(dadosHidrometro);
								// caso não seja
							}else{
								// caso seja tipo ligação poço cria a string com
								// tipo
								// ligação poço
								if(ligacaoPoco){
									Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);
									dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
									numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];
									arquivoTxtLinha.append(dadosHidrometro);

									// caso não seja nem um nem outro então pode
									// chamar
									// qualquer um dos métodos
									// pois os dois fazem a verificação e
									// retorna
									// strings
									// vazia e
									// a data cpm zeros
								}else{
									Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);
									dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
									numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];
									arquivoTxtLinha.append(dadosHidrometro);
								}
							}
						}

						// id da ligacao agua situação
						if(imovelParaSerGerado.getLigacaoAguaSituacao() != null
										&& imovelParaSerGerado.getLigacaoAguaSituacao().getId() != null){
							// Situação da ligação de agua
							arquivoTxtLinha.append(completaString("" + imovelParaSerGerado.getLigacaoAguaSituacao().getId(), 1));
						}else{
							// Situação da ligação de agua
							arquivoTxtLinha.append(completaString("", 1));
						}
						// id da ligacao esgoto situação
						if(imovelParaSerGerado.getLigacaoEsgotoSituacao() != null
										&& imovelParaSerGerado.getLigacaoEsgotoSituacao().getId() != null){
							// Situação de ligação esgoto
							arquivoTxtLinha.append(completaString("" + imovelParaSerGerado.getLigacaoEsgotoSituacao().getId(), 1));
						}else{
							// Situação de ligação esgoto
							arquivoTxtLinha.append(completaString("", 1));

						}

						// pega as descrições das categorias do imovel

						Categoria categoria = getControladorImovel().obterDescricoesCategoriaImovel(imovelParaSerGerado);

						// quantidade de economias
						arquivoTxtLinha.append(completaString(categoria.getDescricaoAbreviada(), 3));
						// [UC0086 - Obter quantidade de economias]
						int quantidadeEconomias = getControladorImovel().obterQuantidadeEconomias(imovelParaSerGerado);
						// quantidade de economias
						arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + quantidadeEconomias));

						// Leitura anterior

						Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);
						String leituraAnterior = null;
						Integer idMedicaoTipo = null;
						MedicaoHistorico medicaoHistorico = null;
						Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior, imovelParaSerGerado);
						// verifica se a leitura anterior é diferente de nula
						if(retorno[0] != null){
							leituraAnterior = retorno[0].toString();
						}
						// verifica se a leitura situação atual é diferente de
						// nula
						if(retorno[1] != null){
							medicaoHistorico = (MedicaoHistorico) retorno[1];
						}
						// verifica se o id da medição tipo é diferente de nula
						if(retorno[2] != null){
							idMedicaoTipo = (Integer) retorno[2];
						}

						// verifica se a leitura anterior é diferente de nula
						// para
						// ser
						// jogado no arquivo
						// txt
						if(leituraAnterior != null){
							arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, "" + leituraAnterior));
							// caso contrario coloca a string com zeros
						}else{
							arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, ""));
						}

						// Faixa de leitura esperada

						Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovelParaSerGerado, dadosHidrometro, leituraAnterior,
										medicaoHistorico, idMedicaoTipo, sistemaParametro, hidrometroSelecionado, numeroDigitosHidrometro);

						StringBuilder faixaInicialFinalString = (StringBuilder) faixaInicialFinal[0];
						hidrometroSelecionado = Boolean.parseBoolean(faixaInicialFinal[1].toString());

						boolean faixaFalsaLeitura = Boolean.parseBoolean(faixaInicialFinal[2].toString());

						int faixaInicialEsperada = 0;
						int faixaFinalEsperada = 0;
						if(faixaFalsaLeitura){
							faixaInicialEsperada = Integer.parseInt(faixaInicialFinal[3].toString());

							faixaFinalEsperada = Integer.parseInt(faixaInicialFinal[4].toString());
						}

						arquivoTxtLinha.append(faixaInicialFinalString);

						arquivoTxt.append(arquivoTxtLinha);

						// Gerar Fiscalização de leitura
						Short indicadorLeituraParametro = sistemaParametro.getIndicadorUsoFiscalizadorLeitura();

						Short indicadorGerarFiscalizacao = imovelParaSerGerado.getRota().getIndicadorGerarFiscalizacao();

						boolean gerarArquivoFiscalizacao = false;

						if(indicadorLeituraParametro.equals(SistemaParametro.INDICADOR_USO_FISCALIZADOR_LEITURA_SISTEMA_PARAMETRO)
										|| indicadorLeituraParametro.equals(SistemaParametro.INDICADOR_USO_FISCALIZADOR_LEITURA_ROTA)){
							if(indicadorGerarFiscalizacao != null && indicadorGerarFiscalizacao.equals(Rota.INDICADOR_GERAR_FISCALIZACAO)){
								if(headerFiscalizacao){
									arquivoTxtFiscalizacao.append(arquivoHeaderFiscalizacao);
									arquivoTxtFiscalizacao.append(System.getProperty("line.separator"));
								}
								headerFiscalizacao = false;

								quantidadeRegistrosFiscalizacao = quantidadeRegistrosFiscalizacao + 1;
								gerarArquivoFiscalizacao = true;
								// caso seja indicado que seja gerado
								// fiscalização
								// de
								// leitura
								// verifica se foi gerado a faixa falsa se foi
								// então pega o txt da leitura (arquivoTxt)
								// mudando
								// so a
								// faixa de leitura
								// para a esperada.
								if(faixaFalsaLeitura){
									arquivoTxtLinha.replace(139, 145, Util.adicionarZerosEsquedaNumero(6, "" + faixaInicialEsperada));

									arquivoTxtLinha.replace(145, 151, Util.adicionarZerosEsquedaNumero(6, "" + faixaFinalEsperada));

									arquivoTxtFiscalizacao.append(arquivoTxtLinha);
								}else{
									arquivoTxtFiscalizacao.append(arquivoTxtLinha);
								}

								arquivoTxtFiscalizacao.append(System.getProperty("line.separator"));
							}
						}

						arquivoTxt.append(System.getProperty("line.separator"));

						// caso seja ligação de agua e de poço então é
						// necessario
						// criar
						// duas linhas txt
						// uma para agua e outra para poço mudando só os dados
						// do
						// hidrometro
						if(ligacaoAgua && ligacaoPoco){
							// cria uma variavel para pegar os dados do
							// arquivoTxt
							StringBuilder arquivoTxtLigacaoPoco = new StringBuilder();
							arquivoTxtLigacaoPoco.append(arquivoTxtLinha);
							// dados do hidrometro tipo poco
							Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovelParaSerGerado);
							dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
							numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

							// muda os dados do hidrometro do arquivoTxt para os
							// dados
							// do hidrometro
							// tipo poço
							arquivoTxtLigacaoPoco.replace(103, 125, Util.completaString(dadosHidrometro.toString(), 22));

							if(imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId() != null
											&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getId().equals("")){
								arquivoTxtLigacaoPoco.replace(16, 17, ""
												+ imovelParaSerGerado.getHidrometroInstalacaoHistorico().getMedicaoTipo().getId());
							}

							// Leitura anterior

							// ligação agua recebe falso, pois ja foi calculado
							// para
							// tipo agua e agora é preciso
							// ver a leitura anterior do tipo poco
							ligacaoAgua = false;

							String leituraAnteriorTipoPoco = null;

							Object[] retornoTipoPoco = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior,
											imovelParaSerGerado);
							// verifica se a leitura anterior é diferente de
							// nula
							if(retornoTipoPoco[0] != null){
								leituraAnteriorTipoPoco = retornoTipoPoco[0].toString();
							}
							// verifica se a medicao historico é diferente de
							// nula
							if(retornoTipoPoco[1] != null){
								medicaoHistorico = (MedicaoHistorico) retornoTipoPoco[1];
							}
							// verifica se o id da medição tipo é diferente de
							// nula
							if(retornoTipoPoco[2] != null){
								idMedicaoTipo = (Integer) retornoTipoPoco[2];
							}

							// verifica se a leitura anterior é diferente de
							// nula
							// para
							// ser
							// jogado no arquivo
							// txt
							if(leituraAnteriorTipoPoco != null){
								// muda os dados do hidrometro para os dados do
								// hidrometro tipo poço
								arquivoTxtLigacaoPoco.replace(133, 139, leituraAnteriorTipoPoco);
							}else{

								// muda os dados do hidrometro para os dados do
								// hidrometro tipo poço
								arquivoTxtLigacaoPoco.replace(133, 139, Util.adicionarZerosEsquedaNumero(6, ""));
							}

							// Faixa de leitura esperada
							Object[] faixaInicialFinalTipoPoco = pesquisarFaixaEsperadaOuFalsa(imovelParaSerGerado, dadosHidrometro,
											leituraAnteriorTipoPoco, medicaoHistorico, idMedicaoTipo, sistemaParametro,
											hidrometroSelecionado, numeroDigitosHidrometro);

							faixaInicialFinalString = (StringBuilder) faixaInicialFinalTipoPoco[0];
							hidrometroSelecionado = Boolean.parseBoolean(faixaInicialFinal[1].toString());

							faixaFalsaLeitura = Boolean.parseBoolean(faixaInicialFinal[2].toString());

							faixaInicialEsperada = 0;
							faixaFinalEsperada = 0;
							if(faixaFalsaLeitura){
								faixaInicialEsperada = Integer.parseInt(faixaInicialFinal[3].toString());

								faixaFinalEsperada = Integer.parseInt(faixaInicialFinal[4].toString());
							}

							// muda os dados do hidrometro para os dados do
							// hidrometro tipo poço
							arquivoTxtLigacaoPoco.replace(139, 151, faixaInicialFinalString.toString());

							arquivoTxt.append(arquivoTxtLigacaoPoco);

							arquivoTxt.append(System.getProperty("line.separator"));

							quantidadeRegistros = quantidadeRegistros + 1;

							// Gerar Fiscalização de leitura

							// caso seja indicado que seja gerado fiscalização
							// de
							// leitura
							// verifica se foi gerado a faixa falsa se foi
							// então pega o txt da leitura (arquivoTxt) mudando
							// so a
							// faixa de leitura
							// para a esperada.
							if(gerarArquivoFiscalizacao){
								quantidadeRegistrosFiscalizacao = quantidadeRegistrosFiscalizacao + 1;

								if(faixaInicialEsperada != 0 && faixaFinalEsperada != 0){
									arquivoTxtLigacaoPoco.replace(139, 145, Util.adicionarZerosEsquedaNumero(6, "" + faixaInicialEsperada));

									arquivoTxtLigacaoPoco.replace(145, 151, Util.adicionarZerosEsquedaNumero(6, "" + faixaFinalEsperada));
									arquivoTxtFiscalizacao.append(arquivoTxtLigacaoPoco);

								}else{
									arquivoTxtFiscalizacao.append(arquivoTxtLigacaoPoco);
								}

								arquivoTxtFiscalizacao.append(System.getProperty("line.separator"));
							}

						}

					}else{

						// cria o header final da string para mandar para a
						// empresa.
						Imovel ultimoImovelEmpresa = (Imovel) ((List) imoveisParaSerGerados).get(quantidadeImoveis - 1);
						ano = "" + dataCalendar.get(Calendar.YEAR);
						mes = "" + (dataCalendar.get(Calendar.MONTH) + 1);
						dia = "" + dataCalendar.get(Calendar.DAY_OF_MONTH);

						mes = Util.adicionarZerosEsquedaNumero(2, mes);
						dia = Util.adicionarZerosEsquedaNumero(2, dia);

						nomeEmpresaAbreviado = completaString(ultimoImovelEmpresa.getRota().getEmpresa().getDescricaoAbreviada(), 1);
						idGrupoFaturamento = completaString(ultimoImovelEmpresa.getRota().getFaturamentoGrupo().getId().toString(), 2);

						quantidadeRegistrosString = Util.adicionarZerosEsquedaNumero(6, "" + quantidadeRegistros);
						quantidadeRegistrosFiscalizacaoString = Util.adicionarZerosEsquedaNumero(6, "" + quantidadeRegistrosFiscalizacao);

						arquivoTxt.append(nomeEmpresaAbreviado + "T" + idGrupoFaturamento + anoMesCorrente + dia + mes + ano
										+ quantidadeRegistrosString);

						if(!headerFiscalizacao){
							quantidadeRegistrosFiscalizacaoString = Util.adicionarZerosEsquedaNumero(6, ""
											+ quantidadeRegistrosFiscalizacao);
							arquivoTxtFiscalizacao.append(nomeEmpresaAbreviado + "T" + idGrupoFaturamento + anoMesCorrente + dia + mes
											+ ano + quantidadeRegistrosFiscalizacaoString);

							headerFiscalizacao = true;
						}

						// manda o header do arquivo para true,pois agora será
						// outra
						// empresa e precisa-se de um outro header
						headerArquivo = true;

						headerFiscalizacao = true;

						if(imovelParaSerGerado.getRota().getEmpresa().getEmail() != null){
							emailReceptor = imovelParaSerGerado.getRota().getEmpresa().getEmail().trim();
						}else{
							emailReceptor = envioEmail.getEmailReceptor();
						}
						if(sistemaParametro.getDescricaoEmail() != null){
							emailRemetente = sistemaParametro.getDescricaoEmail().trim();
						}else{
							emailRemetente = envioEmail.getEmailReceptor();
						}

						tituloMensagem = imovelParaSerGerado.getRota().getFaturamentoGrupo().getDescricao();

						corpoMensagem = imovelParaSerGerado.getRota().getFaturamentoGrupo().getDescricao();

						String nomeArquivo = ultimoImovelEmpresa.getRota().getEmpresa().getDescricao() + "_GR" + idGrupoFaturamento + ano
										+ mes;
						if(arquivoTxt != null && arquivoTxt.length() != 0){
							// chama o metodo que cria o txt e manda para o
							// e-mail
							// arquivo de leitura que será mandado para a
							// empresa.
							mandaArquivoLeituraEmail(arquivoTxt, emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, nomeArquivo);
						}
						if(arquivoTxtFiscalizacao != null && arquivoTxtFiscalizacao.length() != 0){
							// chama o metodo que cria o txt e manda para o
							// e-mail
							// arquivo de leitura de fiscalização que será
							// mandado
							// para
							// a
							// compesa.
							mandaArquivoLeituraEmail(arquivoTxtFiscalizacao, emailReceptor, emailRemetente, tituloMensagem, corpoMensagem,
											nomeArquivo);
						}

						// pega o id da empresa do objeto imovel.
						idEmpresaOld = imovelParaSerGerado.getRota().getEmpresa().getId();

						// manda a string para formar o txt e mandar para o
						// e-mail

						// retorna o iterator para criar a primeira linha do
						// proximo
						// txt.
						imovelParaSerGeradoIterator.previous();
						// cria outra string para começar a criar o txt.
						// limpa os campos para serem usados na próxima empresa
						arquivoTxt = new StringBuilder();
						quantidadeRegistros = 0;
						quantidadeRegistrosFiscalizacao = 0;
						arquivoTxtFiscalizacao = new StringBuilder();
						arquivoHeaderFiscalizacao = new StringBuilder();

					}

					// [SB0003] - Gerar Movimento Roteiro da Empresa
					inserirMovimentoRoteiroEmpresa(sistemaParametro, imovelParaSerGerado, anoMesCorrente, funcionalidade,
									dataPrevistaAtividadeLeitura, idGrupoFaturamentoRota);
				}
				// cria o header final da ultima string para mandar para a
				// empresa
				Imovel ultimoImovelEmpresa = (Imovel) ((List) imoveisParaSerGerados).get(quantidadeImoveis - 1);
				ano = "" + dataCalendar.get(Calendar.YEAR);
				mes = "" + (dataCalendar.get(Calendar.MONTH) + 1);
				dia = "" + dataCalendar.get(Calendar.DAY_OF_MONTH);

				mes = Util.adicionarZerosEsquedaNumero(2, "" + mes);
				dia = Util.adicionarZerosEsquedaNumero(2, "" + dia);

				nomeEmpresaAbreviado = completaString(ultimoImovelEmpresa.getRota().getEmpresa().getDescricaoAbreviada(), 1);
				idGrupoFaturamento = completaString(ultimoImovelEmpresa.getRota().getFaturamentoGrupo().getId().toString(), 2);

				quantidadeRegistrosString = Util.adicionarZerosEsquedaNumero(6, "" + quantidadeRegistros);

				arquivoTxt.append(nomeEmpresaAbreviado + "T" + idGrupoFaturamento + anoMesCorrente + dia + mes + ano
								+ quantidadeRegistrosString);

				if(!headerFiscalizacao){
					quantidadeRegistrosFiscalizacaoString = Util.adicionarZerosEsquedaNumero(6, "" + quantidadeRegistrosFiscalizacao);
					arquivoTxtFiscalizacao.append(nomeEmpresaAbreviado + "T" + idGrupoFaturamento + anoMesCorrente + ano + mes + dia
									+ quantidadeRegistrosFiscalizacaoString);

					headerFiscalizacao = true;
				}

				if(imovelParaSerGerado.getRota().getEmpresa().getEmail() != null){
					emailReceptor = imovelParaSerGerado.getRota().getEmpresa().getEmail().trim();
				}else{
					emailReceptor = envioEmail.getEmailReceptor();
				}
				if(sistemaParametro.getDescricaoEmail() != null){
					emailRemetente = sistemaParametro.getDescricaoEmail().trim();
				}else{
					emailRemetente = envioEmail.getEmailRemetente();
				}
				tituloMensagem = imovelParaSerGerado.getRota().getFaturamentoGrupo().getDescricao();

				corpoMensagem = imovelParaSerGerado.getRota().getFaturamentoGrupo().getDescricao();

				String nomeArquivo = ultimoImovelEmpresa.getRota().getEmpresa().getDescricao() + "_GR" + idGrupoFaturamento + ano + mes;
				// chama o metodo que cria o txt e manda para o e-mail
				// arquivo de leitura que será mandado para a empresa.
				if(arquivoTxt != null && arquivoTxt.length() != 0){
					mandaArquivoLeituraEmail(arquivoTxt, emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, nomeArquivo);
				}

			}else{

				// [FS0005 - Verificar seleção de imóveis]
				throw new ControladorException("atencao.imovel_nao_selecionado");
			}

			// atualiza a data e a hora da realização da atividade com a data e
			// a hora correntes
			try{

				repositorioMicromedicao.atualizarFaturamentoAtividadeCronograma(idGrupoFaturamentoRota, anoMesCorrente);
			}catch(ErroRepositorioException e){

				throw new ControladorException("erro.sistema", e);
			}

			// Encerra a unidade de Faturamento

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			e.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
		return null;

	}

	/*
	 * [UC0121] - Filtrar Exceções de Leituras e Consumos Flávio Leonardo
	 * Cavalcanti Cordeiro
	 */
	public Collection filtrarExcecoesLeiturasConsumos(FaturamentoGrupo faturamentoGrupo,
					FiltroMedicaoHistoricoSql filtroMedicaoHistoricoSql, Integer numeroPagina, boolean todosRegistros)
					throws ControladorException{

		Collection colecaoObject = new ArrayList();

		Collection colecaoImovelMedicao = new ArrayList();

		try{
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			Integer anoMesReferencia = sistemaParametro.getAnoMesFaturamento();

			colecaoObject = repositorioMicromedicao.pesquisarImovelExcecoesLeituras(filtroMedicaoHistoricoSql, numeroPagina,
							todosRegistros, anoMesReferencia);

			Iterator iteratorObject = colecaoObject.iterator();
			while(iteratorObject.hasNext()){
				Object[] arrayObject = (Object[]) iteratorObject.next();
				if(arrayObject != null){
					// instancia um imovelMedição que é um helper
					ImovelMicromedicao imovelMicromedicao = new ImovelMicromedicao();
					// instancia um imovel
					Imovel imovel = new Imovel();
					// id imovel
					if(arrayObject[0] != null){
						imovel.setId((Integer) arrayObject[0]);
					}
					// instancia um imovel
					Localidade localidade = new Localidade();
					// id da localidade
					if(arrayObject[1] != null){
						localidade.setId(((Integer) arrayObject[1]));
						imovel.setLocalidade(localidade);
					}

					// lote

					SetorComercial setorComercial = new SetorComercial();
					// codigo do setor comercial
					if(arrayObject[2] != null){

						setorComercial.setCodigo(((Integer) arrayObject[2]).intValue());
						imovel.setSetorComercial(setorComercial);
					}
					Quadra quadra = new Quadra();
					if(arrayObject[3] != null){
						// número da quadra
						quadra.setNumeroQuadra(((Integer) arrayObject[3]));

					}
					imovel.setQuadra(quadra);
					// lote
					if(arrayObject[4] != null){
						imovel.setLote(((Short) arrayObject[4]));
					}
					// sublote
					if(arrayObject[5] != null){

						imovel.setSubLote(((Short) arrayObject[5]));
					}
					ImovelPerfil imovelPerfil = new ImovelPerfil();
					// descrição imovel perfil
					if(arrayObject[6] != null){
						imovelPerfil.setDescricao((String) arrayObject[6]);

					}
					imovel.setImovelPerfil(imovelPerfil);
					imovelMicromedicao.setImovel(imovel);

					MedicaoHistorico medicaoHistorico = new MedicaoHistorico();

					MedicaoTipo medicaoTipo = new MedicaoTipo();
					// descrição medição tipo
					if(arrayObject[7] != null){
						medicaoTipo.setDescricao((String) arrayObject[7]);
					}

					ConsumoHistorico consumoHistorico = new ConsumoHistorico();
					// numero consumo faturado mes
					if(arrayObject[8] != null){
						consumoHistorico.setNumeroConsumoFaturadoMes((Integer) arrayObject[8]);
					}
					LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
					if(arrayObject[9] != null){
						leituraAnormalidade.setDescricao((String) arrayObject[9]);
					}
					medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);

					ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
					if(arrayObject[10] != null){
						consumoAnormalidade.setDescricao((String) arrayObject[10]);
					}

					if(arrayObject[11] != null){
						medicaoTipo.setId((Integer) arrayObject[11]);
					}

					medicaoHistorico.setMedicaoTipo(medicaoTipo);

					consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

					imovelMicromedicao.setConsumoHistorico(consumoHistorico);
					imovelMicromedicao.setMedicaoHistorico(medicaoHistorico);

					colecaoImovelMedicao.add(imovelMicromedicao);
				}
			}
		}catch(ErroRepositorioException e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoImovelMedicao;
	}

	/*
	 * [UC0121] - Filtrar Exceções de Leituras e Consumos Flávio Leonardo
	 * Cavalcanti Cordeiro
	 */
	public Integer filtrarExcecoesLeiturasConsumosCount(FaturamentoGrupo faturamentoGrupo,
					FiltroMedicaoHistoricoSql filtroMedicaoHistoricoSql) throws ControladorException{

		try{
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			Integer anoMesReferencia = sistemaParametro.getAnoMesFaturamento();
			return repositorioMicromedicao.pesquisarImovelExcecoesLeiturasCount(filtroMedicaoHistoricoSql, anoMesReferencia);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/*
	 * [UC0121] - Filtrar Exceções de Leituras e Consumos Flávio Leonardo
	 * Cavalcanti Cordeiro
	 */
	public Collection pesquisarLigacoesMedicaoIndividualizada(Integer idImovel, String anoMes) throws ControladorException{

		try{

			Collection retorno = new ArrayList();
			Collection colecaoObjetos = repositorioMicromedicao.pesqusiarLigacoesMedicaoIndividualizada(idImovel, anoMes);

			if(!colecaoObjetos.isEmpty()){
				Iterator iterator = colecaoObjetos.iterator();
				LigacaoMedicaoIndividualizadaHelper ligacaoMedicaoIndividualizadaHelper = null;
				while(iterator.hasNext()){
					Object[] objeto = (Object[]) iterator.next();
					ligacaoMedicaoIndividualizadaHelper = new LigacaoMedicaoIndividualizadaHelper();

					// idimovel
					if(objeto[0] != null){
						ligacaoMedicaoIndividualizadaHelper.setIdImovel((Integer) objeto[0]);

						String inscricao = getControladorImovel().pesquisarInscricaoImovel((Integer) objeto[0], true);
						ligacaoMedicaoIndividualizadaHelper.setInscricaoImovel(inscricao);
					}
					// qtdEconomias
					if(objeto[1] != null){
						ligacaoMedicaoIndividualizadaHelper.setQtdEconomias((Integer) objeto[1]);
					}
					// idMedicaoHistorico
					if(objeto[2] != null){
						ligacaoMedicaoIndividualizadaHelper.setIdMedicaoHistorico((Integer) objeto[2]);
					}
					// dataLeituraAnterior
					if(objeto[3] != null){
						ligacaoMedicaoIndividualizadaHelper.setDataLeituraAnterior(Util.formatarData((Date) objeto[3]));
					}
					// leituraAnterior
					if(objeto[4] != null){
						ligacaoMedicaoIndividualizadaHelper.setLeituraAnterior((Integer) objeto[4]);
					}
					// dataLeituraAtual
					if(objeto[5] != null){
						ligacaoMedicaoIndividualizadaHelper.setDataLeituraAtual(Util.formatarData((Date) objeto[5]));
					}
					// leituraAtual
					if(objeto[6] != null){
						ligacaoMedicaoIndividualizadaHelper.setLeituraAtual((Integer) objeto[6]);
					}
					// consumoMedido
					if(objeto[7] != null){
						ligacaoMedicaoIndividualizadaHelper.setConsumoMedido((Integer) objeto[7]);
					}
					// idAnormalidadeLeitura
					if(objeto[8] != null){
						ligacaoMedicaoIndividualizadaHelper.setIdLeituraAnormalidade((Integer) objeto[8]);
					}
					// idConsumoHistorico
					if(objeto[9] != null){
						ligacaoMedicaoIndividualizadaHelper.setIdConsumoHistorico((Integer) objeto[9]);
					}
					// consumoMedio
					if(objeto[10] != null){
						ligacaoMedicaoIndividualizadaHelper.setConsumoMedia((Integer) objeto[10]);
					}
					// consumoFaturado
					if(objeto[11] != null){
						ligacaoMedicaoIndividualizadaHelper.setConsumoFaturado((Integer) objeto[11]);
					}
					// rateio
					if(objeto[12] != null){
						ligacaoMedicaoIndividualizadaHelper.setRateio((Integer) objeto[12]);
					}
					// dsAbreviadaAnormalidadeConsumo
					if(objeto[13] != null){
						ligacaoMedicaoIndividualizadaHelper.setDsAbreviadaAnormalidadeConsumo((String) objeto[13]);
					}
					// dsAbreviadaAnormalidadeConsumo
					if(objeto[14] != null){
						ligacaoMedicaoIndividualizadaHelper.setDsAbreviadaTipoConsumo((String) objeto[14]);
					}

					// tipoMedicao
					if(objeto[15] != null){
						ligacaoMedicaoIndividualizadaHelper.setIdTipoMedicao((Integer) objeto[15]);
					}

					// consumoEsgoto
					if(objeto[16] != null){
						ligacaoMedicaoIndividualizadaHelper.setConsumoEsgoto((Integer) objeto[16]);
					}

					// consumoInformado
					if(objeto[17] != null){
						ligacaoMedicaoIndividualizadaHelper.setConsumoInformado((Integer) objeto[17]);
					}

					// consumosVinculados
					if(objeto[18] != null){
						ligacaoMedicaoIndividualizadaHelper.setConsumosVinculados((Integer) objeto[18]);
					}

					retorno.add(ligacaoMedicaoIndividualizadaHelper);

				}
			}

			return retorno;
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/*
	 * [UC0083] - Gerar dados para Leitura Pesquisa os dados do hidrometro do
	 * tipo ligação agua e rotorna os dados exigidos no caso de uso. Autor:Sávio
	 * Luiz. Data:27/12/2005
	 */

	public Object[] pesquisarDadosHidrometroTipoLigacaoAgua(Imovel imovel) throws ControladorException{

		Object[] dadosHidrometroNumeroLeitura = new Object[5];
		StringBuilder dadosHidrometro = new StringBuilder();
		Short numeroDigitosLeitura = null;
		String codigoHidrometroCapacidade = null;
		Integer idHidrometroCapacidade = null;
		Integer idHidrometroMarca = null;
		String numeroHidrometro = null;

		if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getId() != null
						&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
						&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null){
			Collection hidrometros = null;
			try{
				// recupera todos os hidrometros e seus historicos do tipo
				// ligacao agua
				hidrometros = repositorioMicromedicao.pesquisarDadosHidrometroTipoLigacaoAgua(imovel.getId());
			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			Iterator hidrometroIterator = hidrometros.iterator();
			while(hidrometroIterator.hasNext()){
				// cria um array de objetos para pegar os parametros de
				// retorno da pesquisa
				Object[] arrayhidrometros = (Object[]) hidrometroIterator.next();

				// Alterado por Sávio data:21/03/2007 de acordo com o caso de
				// uso
				if(arrayhidrometros[0] != null){
					String codigoHidrometroMarca = (String) arrayhidrometros[0];
					// marca do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, codigoHidrometroMarca));

				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
				}
				// numero do hidrometro
				if(arrayhidrometros[1] != null){

					numeroHidrometro = (String) arrayhidrometros[1];

					dadosHidrometro.append(Util.completaString("" + arrayhidrometros[1], 10));
				}else{
					dadosHidrometro.append(Util.completaString("", 10));
				}
				if(arrayhidrometros[2] != null){
					codigoHidrometroCapacidade = (String) arrayhidrometros[2];
					// marca do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, codigoHidrometroCapacidade));

				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
				}

				if(arrayhidrometros[3] != null){
					// local de instalação do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, "" + arrayhidrometros[3]));
				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
				}

				// data de instalação do hidrometro
				if(arrayhidrometros[4] != null){
					String dataInstalacao = "" + arrayhidrometros[4];
					String dataInstalacaoFormatada = dataInstalacao.substring(0, 4) + dataInstalacao.substring(5, 7)
									+ dataInstalacao.substring(8, 10);

					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8, dataInstalacaoFormatada));

				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8, ""));
				}

				if(arrayhidrometros[5] != null){
					// protecao do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, "" + arrayhidrometros[5]));
				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
				}

				if(arrayhidrometros[7] != null){
					// numero de digitos do hidrometro
					numeroDigitosLeitura = (Short) arrayhidrometros[7];
				}

				if(arrayhidrometros[8] != null){

					idHidrometroCapacidade = (Integer) arrayhidrometros[8];
				}

				if(arrayhidrometros[9] != null){

					idHidrometroMarca = (Integer) arrayhidrometros[9];
				}

			}

		}else{
			// marca do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// numero do hidrometro
			dadosHidrometro.append(Util.completaString("", 10));
			// capacidade do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// local de instalação do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// data de instalação do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8, ""));
			// protecao do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
		}
		dadosHidrometroNumeroLeitura[0] = dadosHidrometro;
		dadosHidrometroNumeroLeitura[1] = numeroDigitosLeitura;
		dadosHidrometroNumeroLeitura[2] = idHidrometroCapacidade;
		dadosHidrometroNumeroLeitura[3] = idHidrometroMarca;
		dadosHidrometroNumeroLeitura[4] = numeroHidrometro;
		return dadosHidrometroNumeroLeitura;
	} /*
	 * [UC0083] - Gerar dados para Leitura Pesquisa os dados do hidrometro do
	 * tipo poço e rotorna os dados exigidos no caso de uso. Autor:Sávio Luiz.
	 * Data:27/12/2005
	 */

	public Object[] pesquisarDadosHidrometroTipoPoco(Imovel imovel) throws ControladorException{

		Object[] dadosHidrometroNumeroLeitura = new Object[5];
		StringBuilder dadosHidrometro = new StringBuilder();
		Short numeroDigitosLeitura = null;
		String codigoHidrometroCapacidade = null;
		Integer idHidrometroCapacidade = null;
		Integer idHidrometroMarca = null;
		String numeroHidrometro = null;

		if(imovel.getHidrometroInstalacaoHistorico() != null && imovel.getHidrometroInstalacaoHistorico().getId() != null){
			Collection hidrometros = null;
			try{
				// recupera todos os hidrometros e seus historicos do tipo
				// poco
				hidrometros = repositorioMicromedicao.pesquisarDadosHidrometroTipoPoco(imovel.getId());
			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			Iterator hidrometroIterator = hidrometros.iterator();
			while(hidrometroIterator.hasNext()){
				// cria um array de objetos para pegar os parametros de
				// retorno da pesquisa
				Object[] arrayhidrometros = (Object[]) hidrometroIterator.next();

				if(arrayhidrometros[0] != null){
					// Alterado por Sávio data:20/06/2007 de acordo com o caso
					// de uso
					String codigoHidrometroMarca = (String) arrayhidrometros[0];
					// marca do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, codigoHidrometroMarca));

				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
				}
				// numero do hidrometro
				if(arrayhidrometros[1] != null){
					numeroHidrometro = (String) arrayhidrometros[1];
					dadosHidrometro.append(Util.completaString("" + arrayhidrometros[1], 10));
				}else{
					dadosHidrometro.append(Util.completaString("", 10));
				}
				if(arrayhidrometros[2] != null){
					codigoHidrometroCapacidade = (String) arrayhidrometros[2];
					// marca do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, codigoHidrometroCapacidade));

				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
				}

				if(arrayhidrometros[3] != null){
					// local de instalação do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, "" + arrayhidrometros[3]));
				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
				}

				// data de instalação do hidrometro
				if(arrayhidrometros[4] != null){
					String dataInstalacao = "" + arrayhidrometros[4];
					String dataInstalacaoFormatada = dataInstalacao.substring(0, 4) + dataInstalacao.substring(5, 7)
									+ dataInstalacao.substring(8, 10);

					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8, dataInstalacaoFormatada));

				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8, ""));
				}

				if(arrayhidrometros[5] != null){
					// protecao do hidrometro
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, "" + arrayhidrometros[5]));
				}else{
					dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
				}

				if(arrayhidrometros[7] != null){
					// numero de digitos do hidrometro
					numeroDigitosLeitura = (Short) arrayhidrometros[7];
				}

				if(arrayhidrometros[8] != null){

					idHidrometroCapacidade = (Integer) arrayhidrometros[8];
				}

				if(arrayhidrometros[9] != null){
					// numero de digitos do hidrometro
					idHidrometroMarca = (Integer) arrayhidrometros[9];
				}

			}

		}else{
			// marca do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// numero do hidrometro
			dadosHidrometro.append(Util.completaString("", 10));
			// capacidade do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// local de instalação do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));
			// data de instalação do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(8, ""));
			// protecao do hidrometro
			dadosHidrometro.append(Util.adicionarZerosEsquedaNumero(1, ""));

		}
		dadosHidrometroNumeroLeitura[0] = dadosHidrometro;
		dadosHidrometroNumeroLeitura[1] = numeroDigitosLeitura;
		dadosHidrometroNumeroLeitura[2] = idHidrometroCapacidade;
		dadosHidrometroNumeroLeitura[3] = idHidrometroMarca;
		dadosHidrometroNumeroLeitura[4] = numeroHidrometro;
		return dadosHidrometroNumeroLeitura;
	}

	// Complementa o tamanho da string com espaços em branco.
	protected String completaString(String str, int tm){

		char[] temp = new char[tm];
		Arrays.fill(temp, ' ');
		int tamanho = str.length();
		StringBuilder stringBuilder = null;
		// caso o tamanho da string seja maior do que o tamanho especificado
		if(tamanho > tm){
			// trunca a String
			String strTruncado = str.substring(0, tm);
			stringBuilder = new StringBuilder(strTruncado);
			// coloca o tamanho para o tamanho truncado
			tamanho = strTruncado.length();
		}else{
			stringBuilder = new StringBuilder(str);
		}

		stringBuilder.append(temp, tamanho, tm - tamanho);
		return stringBuilder.toString();
	}

	/**
	 * [UC0087] - Calcular Faixa de Leitura Falsa [FS0002] - Verificar Leitura
	 * Anterior e Média Autor: Sávio Luiz Data: 30/12/2005
	 */
	public boolean verificarLeituraAnteriorMedia(int media, MedicaoHistorico medicaoHistorico){

		boolean hidrometroSelecionado = true;

		if(medicaoHistorico.getLeituraSituacaoAtual().getId().equals(LeituraSituacao.NAO_REALIZADA)
						|| medicaoHistorico.getLeituraAnteriorFaturamento() == 0 || media == 0){
			hidrometroSelecionado = false;
		}

		return hidrometroSelecionado;
	}

	/**
	 * [UC0087] - Calcular Faixa de Leitura Falsa [FS0003] - Verificar Leitura
	 * Anterior Falsa Negativa Autor: Sávio Luiz Data: 30/12/2005
	 */

	public Integer verificarLeituraAnteriorFalsaNegativa(Integer leituraAnteriorFalsa, Hidrometro hidrometro){

		double leituraAnteriorFalsaNegativa = leituraAnteriorFalsa;
		double numeroDigitosLeitura = hidrometro.getNumeroDigitosLeitura();

		double numeroDigitosLeituraElevadoDez = (int) Math.pow(10, numeroDigitosLeitura);

		leituraAnteriorFalsa = new Double(leituraAnteriorFalsaNegativa + numeroDigitosLeituraElevadoDez).intValue();

		return leituraAnteriorFalsa;
	}

	/**
	 * Retorna o consumo munimo da tarifa. [UC0087] - Calcular Faixa de Leitura
	 * Falsa Autor: Sávio Luiz Data: 02/01/2006
	 */
	public Integer pesquisarConsumoMinimoTarifa(Integer idImovel) throws ControladorException{

		Integer consumoMinimo = null;

		Collection colecaoConsumoTarifaCategoria = null;

		try{
			colecaoConsumoTarifaCategoria = repositorioMicromedicao.pesquisarIdConsumoTarifaCategoria(idImovel);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		Iterator colecaoConsumoTarifaCategoriaIterator = colecaoConsumoTarifaCategoria.iterator();
		Integer idConsumoTarifa = null;

		Integer idCategoria = null;

		while(colecaoConsumoTarifaCategoriaIterator.hasNext()){

			// cria um array de objetos para pegar os parametros de
			// retorno da pesquisa
			Object[] arrayConsumoTarifaCategoria = (Object[]) colecaoConsumoTarifaCategoriaIterator.next();
			idConsumoTarifa = (Integer) arrayConsumoTarifaCategoria[0];
			idCategoria = (Integer) arrayConsumoTarifaCategoria[1];

		}
		Integer idConsumoTarifaVigencia = null;
		try{
			idConsumoTarifaVigencia = repositorioMicromedicao.pesquisarMaiorDataVigencia(idConsumoTarifa);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		try{
			consumoMinimo = repositorioMicromedicao.pesquisarConsumoMinimoTarifaCategoria(idConsumoTarifaVigencia, idCategoria);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return consumoMinimo;
	}

	/**
	 * [UC0087] - Calcular Faixa de Leitura Falsa Autor: Sávio Luiz Data:
	 * 29/12/2005
	 */
	public Object[] calcularFaixaLeituraFalsa(Imovel imovel, int media, Integer leituraAnterior, MedicaoHistorico medicaoHistorico,
					boolean hidrometroSelecionado, Hidrometro hidrometro) throws ControladorException{

		Object[] retorno = new Object[3];

		int[] retornoEsperado = new int[2];

		Calendar dataCalendar = new GregorianCalendar();
		// dataCalendar.setTime(data);
		int segundos = dataCalendar.get(Calendar.SECOND);

		Integer somaImovelSegundo = null;

		// soma os segundos com o id do imovel
		somaImovelSegundo = imovel.getId() + segundos;

		BigDecimal multiplicaFaxaFalsa = null;

		// cria uma flag para saber se o hidrometro é para ser selecionado ou
		// não
		boolean hidrometroSelecionar = hidrometroSelecionado;

		// recupera o percentual da geração da faixa falsa
		BigDecimal percentualGeracaoFaixaFalsaRota = imovel.getRota().getPercentualGeracaoFaixaFalsa();
		// recupera o sistema parametro
		SistemaParametro sistemaParametro = null;
		sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		// recupera o percentual falsa do sistema parametro
		BigDecimal percentualFaixaFalsaSistemaParametro = sistemaParametro.getPercentualFaixaFalsa();
		// verifica se o indicador udo da faixa falsa é igual a 2
		if(sistemaParametro.getIndicadorUsoFaixaFalsa().equals(SistemaParametro.INDICADOR_USO_FAIXA_FALSA_ROTA)){

			// caso percentual geracao faixa falsa rota seja diferente de nulo
			if(percentualGeracaoFaixaFalsaRota != null && !percentualGeracaoFaixaFalsaRota.equals(new BigDecimal(0.0))){
				// multiplica com geracao faixa falsa rota
				multiplicaFaxaFalsa = percentualGeracaoFaixaFalsaRota.multiply(new BigDecimal(somaImovelSegundo));

			}
		}else{
			if(sistemaParametro.getIndicadorUsoFaixaFalsa().equals(SistemaParametro.INDICADOR_USO_FAIXA_FALSA_SISTEMA_PARAMETRO)){
				if(!percentualFaixaFalsaSistemaParametro.equals(new BigDecimal(0.0))){
					// multiplica percentual faixa falsa sistema parametro
					multiplicaFaxaFalsa = percentualFaixaFalsaSistemaParametro.multiply(new BigDecimal(somaImovelSegundo));

				}
			}
		}

		// cria uma variável da leitura anterior falsa
		Integer leituraAnteriorFalsa = null;

		if(multiplicaFaxaFalsa != null){

			// chama o método para verificar se o hidrometro será
			// selecionado ou não.
			hidrometroSelecionar = verificarLeituraAnteriorMedia(media, medicaoHistorico);

			// se multiplicaFaxaFalsa for divisivel por 100 ou o hidrometro for
			// selecionado
			if((multiplicaFaxaFalsa.doubleValue() % 100 == 0) || (hidrometroSelecionar)){

				// recupera o numero de meses do sistema parametro
				Integer numeroMeses = Integer.valueOf(sistemaParametro.getMesesMediaConsumo());
				// chama o método pesquisar consumo minimo tarifa para recuperar
				// o consumo minimo
				Integer consumoMinimo = null;
				try{
					consumoMinimo = pesquisarConsumoMinimoTarifa(imovel.getId());
				}catch(ControladorException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				if(leituraAnterior != null && numeroMeses != null && media != 0){

					// calcula a leitura anterior falsa
					leituraAnteriorFalsa = leituraAnterior - (numeroMeses * media) - (consumoMinimo + 1);

					// se a leitura anterior falsa for negativo
					if(leituraAnteriorFalsa.intValue() < 0){
						// chama o método verificarLeituraAnteriorFalsa
						leituraAnteriorFalsa = verificarLeituraAnteriorFalsaNegativa(leituraAnteriorFalsa, hidrometro);
					}

					// seta a leitura anterior falsa na medição historico para
					// ser
					// usado calcularFaixaLeituraEsperada
					medicaoHistorico.setLeituraAtualInformada(leituraAnteriorFalsa);
					// seta a leitura anterior falsa na medição historico para
					// ser
					// usado calcularFaixaLeituraEsperada
					medicaoHistorico.setLeituraAnteriorInformada(leituraAnteriorFalsa);
					retornoEsperado = calcularFaixaLeituraEsperada(media, null, hidrometro, leituraAnteriorFalsa);
				}

			}
		}
		// recupera a faixa inicial
		retorno[0] = retornoEsperado[0];
		// recupera a faixa final
		retorno[1] = retornoEsperado[1];
		// manda um boolena para saber se o próximo hidrometro será selecionado
		retorno[2] = hidrometroSelecionar;

		return retorno;
	}

	public Collection pesquisarLeituraAnteriorTipoLigacaoAgua(Integer idImovel, Integer anoMesAnterior) throws ControladorException{

		Collection leituraAnterior = null;

		try{
			leituraAnterior = repositorioMicromedicao.pesquisarLeituraAnteriorTipoLigacaoAgua(idImovel, anoMesAnterior);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return leituraAnterior;
	}

	protected boolean verificarFaixaFalsa(Rota rota, SistemaParametro sistemaParametro){

		boolean seFaixaFalsa = true;
		if(sistemaParametro.getIndicadorFaixaFalsa().equals(SistemaParametro.INDICADOR_FAIXA_FALSA_NAO_USO)
						|| sistemaParametro.getIndicadorFaixaFalsa().equals(SistemaParametro.INDICADOR_FAIXA_FALSA_ROTA)){

			if(rota.getIndicadorGerarFalsaFaixa() != null
							&& rota.getIndicadorGerarFalsaFaixa().equals(Rota.INDICADOR_NAO_GERAR_FAIXA_FALSA)){
				seFaixaFalsa = false;
			}

		}

		return seFaixaFalsa;
	}

	protected Object[] pesquisaLeituraAnterior(boolean ligacaoAgua, boolean ligacaoPoco, Integer anoMesAnterior, Imovel imovelParaSerGerado)
					throws ControladorException{

		Object[] retorno = new Object[4];
		Collection leituraAnteriores = null;
		String leituraAnterior = null;
		Integer idMedicaoTipo = null;
		MedicaoHistorico medicaoHistorioco = new MedicaoHistorico();
		// caso seja tipo ligação agua e poço cria a string primeiro com
		// tipo
		// ligação agua
		if(ligacaoAgua && ligacaoPoco){

			idMedicaoTipo = MedicaoTipo.LIGACAO_AGUA;
			try{
				leituraAnteriores = repositorioMicromedicao.pesquisarLeituraAnteriorTipoLigacaoAgua(imovelParaSerGerado.getId(),
								anoMesAnterior);
			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
			// verifica se a leitura é diferente de nula
			if(leituraAnteriores != null && !leituraAnteriores.isEmpty()){
				Iterator iteratorLeituraAnterior = leituraAnteriores.iterator();
				while(iteratorLeituraAnterior.hasNext()){
					Object[] leituraSituacao = (Object[]) iteratorLeituraAnterior.next();
					if(leituraSituacao[0] != null){
						leituraAnterior = "" + leituraSituacao[0];
					}
					if(leituraSituacao[1] != null){
						LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
						leituraSituacaoAtual.setId((Integer) leituraSituacao[1]);
						medicaoHistorioco.setLeituraSituacaoAtual(leituraSituacaoAtual);
					}
					if(leituraSituacao[2] != null){
						medicaoHistorioco.setId((Integer) leituraSituacao[2]);
					}

					if(leituraSituacao[3] != null){
						medicaoHistorioco.setLeituraAnteriorInformada((Integer) leituraSituacao[3]);
					}
					if(leituraSituacao[4] != null){
						medicaoHistorioco.setLeituraAtualInformada((Integer) leituraSituacao[4]);
					}

				}

			}
			// caso não seja
		}else{
			// caso seja tipo ligação agua cria a string com tipo
			// ligação agua
			if(ligacaoAgua){
				idMedicaoTipo = MedicaoTipo.LIGACAO_AGUA;
				try{
					leituraAnteriores = repositorioMicromedicao.pesquisarLeituraAnteriorTipoLigacaoAgua(imovelParaSerGerado.getId(),
									anoMesAnterior);
				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
				// verifica se a leitura é diferente de nula
				if(leituraAnteriores != null && !leituraAnteriores.isEmpty()){
					Iterator iteratorLeituraAnterior = leituraAnteriores.iterator();
					while(iteratorLeituraAnterior.hasNext()){
						Object[] leituraSituacao = (Object[]) iteratorLeituraAnterior.next();
						if(leituraSituacao[0] != null){
							leituraAnterior = "" + leituraSituacao[0];
						}
						if(leituraSituacao[1] != null){
							LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
							leituraSituacaoAtual.setId((Integer) leituraSituacao[1]);
							medicaoHistorioco.setLeituraSituacaoAtual(leituraSituacaoAtual);
						}
						if(leituraSituacao[2] != null){
							medicaoHistorioco.setId((Integer) leituraSituacao[2]);
						}

						if(leituraSituacao[3] != null){
							medicaoHistorioco.setLeituraAnteriorInformada((Integer) leituraSituacao[3]);
						}
						if(leituraSituacao[4] != null){
							medicaoHistorioco.setLeituraAtualInformada((Integer) leituraSituacao[4]);
						}
					}

				}
				// caso não seja ,caso seja tipo ligação poço cria a string com
				// tipo
				// ligação poço
			}else{

				idMedicaoTipo = MedicaoTipo.POCO;
				try{
					leituraAnteriores = repositorioMicromedicao.pesquisarLeituraAnteriorTipoPoco(imovelParaSerGerado.getId(),
									anoMesAnterior);
				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
				// verifica se a leitura é diferente de nula
				if(leituraAnteriores != null && !leituraAnteriores.isEmpty()){
					Iterator iteratorLeituraAnterior = leituraAnteriores.iterator();
					while(iteratorLeituraAnterior.hasNext()){
						Object[] leituraSituacao = (Object[]) iteratorLeituraAnterior.next();
						if(leituraSituacao[0] != null){
							leituraAnterior = "" + leituraSituacao[0];
						}
						if(leituraSituacao[1] != null){
							LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
							leituraSituacaoAtual.setId((Integer) leituraSituacao[1]);
							medicaoHistorioco.setLeituraSituacaoAtual(leituraSituacaoAtual);
						}
						if(leituraSituacao[2] != null){
							medicaoHistorioco.setId((Integer) leituraSituacao[2]);
						}

						if(leituraSituacao[3] != null){
							medicaoHistorioco.setLeituraAnteriorInformada((Integer) leituraSituacao[3]);
						}
						if(leituraSituacao[4] != null){
							medicaoHistorioco.setLeituraAtualInformada((Integer) leituraSituacao[4]);
						}
					}

				}

			}
		}
		retorno[0] = leituraAnterior;
		retorno[1] = medicaoHistorioco;
		retorno[2] = idMedicaoTipo;

		return retorno;
	}

	protected Object[] pesquisarFaixaEsperadaOuFalsaCelular(Imovel imovelParaSerGerado, StringBuilder dadosHidrometro,
					String leituraAnterior, MedicaoHistorico medicaoHistorico, Integer idMedicaoTipo, SistemaParametro sistemaParametro,
					boolean hidrometroSelecionado, Short numeroDigitosHidrometro) throws ControladorException{

		Object[] retorno = new Object[5];

		// Manda a faixa false de leitura para caso precise gerar um arquivo
		// de fiscalizacao então será gerado a faixa esperada.
		boolean faixaFalsaLeitura = false;
		boolean hidrometroParaselecionar = hidrometroSelecionado;
		int faixaInicial = 0;
		int faixaFinal = 0;

		if(dadosHidrometro.toString().trim().equals("") || leituraAnterior == null || leituraAnterior.equals("")){

			// Faixa de leitura esperada
			// arquivoTxt.append(Util.adicionarZerosEsquedaNumero(12, ""));
		}else{

			// Faixa de leitura esperada
			MedicaoTipo medicaoTipo = new MedicaoTipo();

			medicaoTipo.setId(idMedicaoTipo);
			Hidrometro hidrometro = new Hidrometro();
			hidrometro.setNumeroDigitosLeitura(numeroDigitosHidrometro);

			int[] obterConsumo = obterConsumoMedioHidrometro(imovelParaSerGerado, sistemaParametro, medicaoTipo);
			int mediaConsumoHidrometro = obterConsumo[0];

			// Rota rota = imovelParaSerGerado.getQuadra().getRota();
			Integer leituraAnteriorPesquisada = null;
			if(leituraAnterior != null && !leituraAnterior.equals("")){
				leituraAnteriorPesquisada = Util.converterStringParaInteger(leituraAnterior);
			}

			int[] faixas = calcularFaixaLeituraEsperada(mediaConsumoHidrometro, null, hidrometro, leituraAnteriorPesquisada);

			faixaInicial = faixas[0];
			faixaFinal = faixas[1];

			/*
			 * boolean seFaixaFalsa = verificarFaixaFalsa(rota,
			 * sistemaParametro); Integer leituraAnteriorInteger = null; if
			 * (leituraAnterior != null) { leituraAnteriorInteger = new
			 * Integer(leituraAnterior); } if (seFaixaFalsa) { Object[]
			 * faixasFalsas = calcularFaixaLeituraFalsa( imovelParaSerGerado,
			 * mediaConsumoHidrometro, leituraAnteriorInteger, medicaoHistorico,
			 * hidrometroSelecionado, hidrometro); int faixaInicialFalsa =
			 * Integer.parseInt(faixasFalsas[0] .toString()); int
			 * faixaFinalFalsa = Integer.parseInt(faixasFalsas[1] .toString());
			 * if (faixaInicialFalsa != 0 && faixaFinalFalsa != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixasFalsas[0]));
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixasFalsas[1])); // Insere o objeto leitura faixa falsa na base
			 * LeituraFaixaFalsa leituraFaixaFalsa = new LeituraFaixaFalsa();
			 * leituraFaixaFalsa.setId(medicaoHistorico.getId());
			 * leituraFaixaFalsa .setNumeroFalsaInferior((Integer)
			 * faixasFalsas[0]); leituraFaixaFalsa
			 * .setNumeroFalsaSuperior((Integer) faixasFalsas[1]);
			 * leituraFaixaFalsa.setNumeroCorretaInferior(faixaInicial);
			 * leituraFaixaFalsa.setNumeroCorretaSuperior(faixaFinal);
			 * leituraFaixaFalsa.setUltimaAlteracao(new Date());
			 * leituraFaixaFalsa.setMedicaoHistorico(medicaoHistorico); try {
			 * repositorioUtil.inserir(leituraFaixaFalsa); } catch
			 * (ErroRepositorioException e) { e.printStackTrace(); throw new
			 * ControladorException("erro.sistema", e); } faixaFalsaLeitura =
			 * true; } else { if (faixaInicial != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixaInicial)); } else {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "")); } if
			 * (faixaFinal != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixaFinal)); } else {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "")); } }
			 * hidrometroParaselecionar = Boolean.parseBoolean(faixasFalsas[2]
			 * .toString()); } else { if (faixaInicial != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixaInicial)); } else {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "")); } if
			 * (faixaFinal != 0) {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" +
			 * faixaFinal)); } else {
			 * arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "")); } }
			 */
		}

		// retorno[0] = arquivoTxt;
		retorno[1] = Boolean.valueOf(hidrometroParaselecionar);
		retorno[2] = Boolean.valueOf(faixaFalsaLeitura);
		// if (faixaFalsaLeitura) {
		retorno[3] = faixaInicial;
		retorno[4] = faixaFinal;
		// }

		return retorno;
	}

	protected Object[] pesquisarFaixaEsperadaOuFalsa(Imovel imovelParaSerGerado, StringBuilder dadosHidrometro, String leituraAnterior,
					MedicaoHistorico medicaoHistorico, Integer idMedicaoTipo, SistemaParametro sistemaParametro,
					boolean hidrometroSelecionado, Short numeroDigitosHidrometro) throws ControladorException{

		Object[] retorno = new Object[5];
		StringBuilder arquivoTxt = new StringBuilder();

		// Manda a faixa false de leitura para caso precise gerar um arquivo
		// de fiscalizacao então será gerado a faixa esperada.
		boolean faixaFalsaLeitura = false;
		boolean hidrometroParaselecionar = hidrometroSelecionado;
		int faixaInicial = 0;
		int faixaFinal = 0;

		if(dadosHidrometro.toString().trim().equals("") || leituraAnterior == null || leituraAnterior.equals("")){

			// Faixa de leitura esperada
			arquivoTxt.append(Util.adicionarZerosEsquedaNumero(12, ""));
		}else{

			// Faixa de leitura esperada
			MedicaoTipo medicaoTipo = new MedicaoTipo();

			medicaoTipo.setId(idMedicaoTipo);
			Hidrometro hidrometro = new Hidrometro();
			hidrometro.setNumeroDigitosLeitura(numeroDigitosHidrometro);

			int[] obterConsumo = obterConsumoMedioHidrometro(imovelParaSerGerado, sistemaParametro, medicaoTipo);
			int mediaConsumoHidrometro = obterConsumo[0];

			Rota rota = imovelParaSerGerado.getRota();
			Integer leituraAnteriorPesquisada = null;
			if(leituraAnterior != null && !leituraAnterior.equals("")){
				leituraAnteriorPesquisada = Util.converterStringParaInteger(leituraAnterior);
			}

			int[] faixas = calcularFaixaLeituraEsperada(mediaConsumoHidrometro, null, hidrometro, leituraAnteriorPesquisada);

			faixaInicial = faixas[0];
			faixaFinal = faixas[1];

			boolean seFaixaFalsa = verificarFaixaFalsa(rota, sistemaParametro);
			Integer leituraAnteriorInteger = null;
			if(leituraAnterior != null){
				leituraAnteriorInteger = Integer.valueOf(leituraAnterior);
			}

			if(seFaixaFalsa){

				Object[] faixasFalsas = calcularFaixaLeituraFalsa(imovelParaSerGerado, mediaConsumoHidrometro, leituraAnteriorInteger,
								medicaoHistorico, hidrometroSelecionado, hidrometro);

				int faixaInicialFalsa = Integer.parseInt(faixasFalsas[0].toString());
				int faixaFinalFalsa = Integer.parseInt(faixasFalsas[1].toString());

				if(faixaInicialFalsa != 0 && faixaFinalFalsa != 0){

					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" + faixasFalsas[0]));
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" + faixasFalsas[1]));

					// Insere o objeto leitura faixa falsa na base
					LeituraFaixaFalsa leituraFaixaFalsa = new LeituraFaixaFalsa();
					leituraFaixaFalsa.setId(medicaoHistorico.getId());
					leituraFaixaFalsa.setNumeroFalsaInferior((Integer) faixasFalsas[0]);
					leituraFaixaFalsa.setNumeroFalsaSuperior((Integer) faixasFalsas[1]);
					leituraFaixaFalsa.setNumeroCorretaInferior(faixaInicial);
					leituraFaixaFalsa.setNumeroCorretaSuperior(faixaFinal);
					leituraFaixaFalsa.setUltimaAlteracao(new Date());
					leituraFaixaFalsa.setMedicaoHistorico(medicaoHistorico);

					try{
						repositorioUtil.inserir(leituraFaixaFalsa);
					}catch(ErroRepositorioException e){
						e.printStackTrace();
						throw new ControladorException("erro.sistema", e);
					}

					faixaFalsaLeitura = true;
				}else{

					if(faixaInicial != 0){
						arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" + faixaInicial));
					}else{
						arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""));
					}
					if(faixaFinal != 0){
						arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" + faixaFinal));
					}else{
						arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""));
					}
				}
				hidrometroParaselecionar = Boolean.parseBoolean(faixasFalsas[2].toString());

			}else{

				if(faixaInicial != 0){
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" + faixaInicial));
				}else{
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""));
				}
				if(faixaFinal != 0){
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, "" + faixaFinal));
				}else{
					arquivoTxt.append(Util.adicionarZerosEsquedaNumero(6, ""));
				}
			}
		}

		retorno[0] = arquivoTxt;
		retorno[1] = Boolean.valueOf(hidrometroParaselecionar);
		retorno[2] = Boolean.valueOf(faixaFalsaLeitura);
		if(faixaFalsaLeitura){
			retorno[3] = faixaInicial;
			retorno[4] = faixaFinal;
		}

		return retorno;
	}

	/**
	 * [UC0099] - Selecionar Fiscalização de Leitura Autor: Sávio Luiz Data:
	 * 04/01/2006
	 */

	public boolean selecionarFiscalizacaoLeitura(Imovel imovel, SistemaParametro sistemaParametro) throws ControladorException{

		boolean leituraSelecionada = false;

		try{
			Rota rota = imovel.getRota();

			Calendar dataCalendar = new GregorianCalendar();
			// obtem a hora corrente
			int segundos = dataCalendar.get(Calendar.SECOND);

			Integer somaImovelSegundo = null;

			// soma os segundos com o id do imovel
			somaImovelSegundo = imovel.getId() + segundos;

			BigDecimal multiplica = null;

			// recupera o percentual de fiscalização de rota
			BigDecimal percentualFiscalizacaoRota = rota.getPercentualGeracaoFiscalizacao();
			// recupera o percentual de fiscalização de sistema parametro
			BigDecimal percentualFiscalizacaoSistemaParametro = sistemaParametro.getPercentualFiscalizacaoLeitura();

			if((percentualFiscalizacaoRota != null && !percentualFiscalizacaoRota.equals(""))
							&& (percentualFiscalizacaoSistemaParametro != null && !percentualFiscalizacaoSistemaParametro.equals(""))){

				if(percentualFiscalizacaoSistemaParametro.equals(SistemaParametro.INDICADOR_PERCENTUAL_FISCALIZACAO_LEITURA_ROTA)){
					multiplica = percentualFiscalizacaoRota.multiply(new BigDecimal(somaImovelSegundo));
				}else{
					multiplica = percentualFiscalizacaoRota.multiply(new BigDecimal(somaImovelSegundo));
				}
				if(multiplica != null){
					if(multiplica.doubleValue() % 100 == 0){
						leituraSelecionada = true;
					}
				}

			}
		}catch(Exception e){
			throw new ControladorException("erro.sistema", e);
		}

		return leituraSelecionada;
	}

	protected void mandaArquivoLeituraEmail(StringBuilder arquivo, String emailReceptor, String emailRemetente, String tituloMensagem,
					String corpoMensagem, String nomeArquivo)

	throws ControladorException{

		try{
			File leitura = new File(nomeArquivo + ".txt");
			BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leitura.getAbsolutePath())));
			out.write(arquivo.toString());
			out.close();

			ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

			// leitura.delete();
		}catch(IOException e){
			e.printStackTrace();
			// throw new ControladorException("erro.sistema", e);
		}catch(Exception e){
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0098] Manter Vínculos de Imóveis para Rateio de Consumo Atualizar Tipo
	 * Rateio com Vinculo com o Imovel Author: Rafael Santos Data: 12/01/2006
	 * 
	 * @imovel Imovel
	 * @throws ControladorException
	 */
	public void atualizarTipoRateio(Imovel imovel, HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoAgua,
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoPoco, Usuario usuarioLogado) throws ControladorException{

		FiltroImovel filtroImovel = new FiltroImovel();

		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));

		// Procura Imovel na base
		Imovel imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);

		// Verificar se Imovel já foi atualizada por outro usuário durante esta
		// atualização
		// [FS0007] Atualização realizada por outro usuário
		if(imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// [SB0001]Atualizar o Tipo Rateio do Imovel
		// atualizar o tipo rateio de agua
		if(hidrometroInstalacaoHistoricoAgua != null){
			hidrometroInstalacaoHistoricoAgua.setUltimaAlteracao(new Date());

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{

				getControladorUtil().registrarOperacao(hidrometroInstalacaoHistoricoAgua, usuarioLogado,
								Operacao.OPERACAO_ESTABELECER_VINCULO, "id");

				getControladorUtil().atualizar(hidrometroInstalacaoHistoricoAgua);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

		// atualizar tipo poco
		if(hidrometroInstalacaoHistoricoPoco != null){
			hidrometroInstalacaoHistoricoPoco.setUltimaAlteracao(new Date());

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{

				getControladorUtil().registrarOperacao(hidrometroInstalacaoHistoricoPoco, usuarioLogado,
								Operacao.OPERACAO_ESTABELECER_VINCULO, "id");

				getControladorUtil().atualizar(hidrometroInstalacaoHistoricoPoco);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

	}

	/**
	 * [UC0098] Manter Vínculos de Imóveis para Rateio de Consumo Atualizar Tipo
	 * Rateio com Vinculo com o Imovel Author: Rafael Santos Data: 16/01/2006
	 * Estabelecer Vinculo ao Imovel
	 * 
	 * @imovel Imovel
	 * @param imoveisASerVinculados
	 * @param imoveisASerDesvinculados
	 * @throws ControladorException
	 */
	public void estabelecerVinculo(Imovel imovel, Collection imoveisASerVinculados, Collection imoveisASerDesvinculados,
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoAgua,
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoPoco, Usuario usuarioLogado) throws ControladorException{

		// Procura Imovel na base
		Imovel imovelNaBase = getControladorImovel().pesquisarImovel(imovel.getId());
		imovel.setUltimaAlteracao(new Date());
		// Verificar se Imovel já foi atualizada por outro usuário durante esta
		// atualização
		// [FS0007] Atualização realizada por outro usuário
		if(imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// [SB0001]Atualizar o Tipo Rateio do Imovel
		// atualizar o tipo rateio de agua
		if(hidrometroInstalacaoHistoricoAgua != null){
			hidrometroInstalacaoHistoricoAgua.setUltimaAlteracao(new Date());

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{

				getControladorUtil().registrarOperacao(hidrometroInstalacaoHistoricoAgua, usuarioLogado,
								Operacao.OPERACAO_ESTABELECER_VINCULO, "id");

				getControladorUtil().atualizar(hidrometroInstalacaoHistoricoAgua);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

		// atualizar tipo poco
		if(hidrometroInstalacaoHistoricoPoco != null){
			hidrometroInstalacaoHistoricoPoco.setUltimaAlteracao(new Date());

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{

				getControladorUtil().registrarOperacao(hidrometroInstalacaoHistoricoPoco, usuarioLogado,
								Operacao.OPERACAO_ESTABELECER_VINCULO, "id");

				getControladorUtil().atualizar(hidrometroInstalacaoHistoricoPoco);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

		// atualizar o indicador de imovel condominio
		if(imovel != null){
			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{
				getControladorUtil().atualizar(imovel);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

		// Desvicular imoveis
		if(imoveisASerDesvinculados != null && !imoveisASerDesvinculados.isEmpty()){
			Iterator iImoveisASerDesvinculados = imoveisASerDesvinculados.iterator();

			while(iImoveisASerDesvinculados.hasNext()){
				Imovel imovelASerDesvinculado = (Imovel) iImoveisASerDesvinculados.next();

				// Procura Imovel na base
				imovelNaBase = getControladorImovel().pesquisarImovel(imovel.getId());
				imovelASerDesvinculado.setUltimaAlteracao(new Date());
				// Verificar se Imovel já foi atualizada por outro usuário
				// durante esta
				// atualização
				// [FS0007] Atualização realizada por outro usuário
				if(imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");
				}

				/**
				 * alterado por pedro alexandre dia 20/11/2006 alteração feita
				 * para acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

				if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				}else{
					getControladorUtil().atualizar(imovelASerDesvinculado);
				}
				// ------------ FIM CONTROLE DE ABRANGENCIA -------------
			}

		}

		// estebelcer os imoveis aos condominios
		if(imoveisASerVinculados != null && !imoveisASerVinculados.isEmpty()){
			Iterator iImoveisASerVinculados = imoveisASerVinculados.iterator();

			while(iImoveisASerVinculados.hasNext()){
				Imovel imovelASerVinculado = (Imovel) iImoveisASerVinculados.next();

				// Procura Imovel na base
				imovelNaBase = getControladorImovel().pesquisarImovel(imovelASerVinculado.getId());
				imovelASerVinculado.setUltimaAlteracao(new Date());
				// Verificar se Imovel já foi atualizada por outro usuário
				// durante esta
				// atualização
				// [FS0007] Atualização realizada por outro usuário
				if(imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");
				}

				/**
				 * alterado por pedro alexandre dia 20/11/2006 alteração feita
				 * para acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

				if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				}else{
					getControladorUtil().atualizar(imovelASerVinculado);
				}
				// ------------ FIM CONTROLE DE ABRANGENCIA -------------
			}

		}else{

			// Procura Imovel na base
			imovelNaBase = getControladorImovel().pesquisarImovel(imovel.getId());
			imovel.setUltimaAlteracao(new Date());
			// Verificar se Imovel já foi atualizada por outro usuário durante
			// esta
			// atualização
			// [FS0007] Atualização realizada por outro usuário
			if(imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}
			// imovel sem ninguem vinculado a ele
			imovel.setIndicadorImovelCondominio(Imovel.IMOVEL_NAO_CONDOMINIO);

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{
				getControladorUtil().atualizar(imovel);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

	}

	/**
	 * [UC0098] Manter Vínculos de Imóveis para Rateio de Consumo Atualizar Tipo
	 * Rateio com Vinculo com o Imovel Author: Rafael Santos, Pedro Alexandre
	 * Data: 16/01/2006, 20/11/2006 Desfazer Vinculo ao Imovel
	 * 
	 * @param Imovel
	 * @param imoveisASerVinculados
	 * @throws ControladorException
	 */
	public void desfazerVinculo(Imovel imovel, String[] ids, boolean desvincular, Usuario usuarioLogado) throws ControladorException{

		FiltroImovel filtroImovel = new FiltroImovel();

		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));

		// Procura Imovel na base
		Imovel imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);
		imovel.setUltimaAlteracao(new Date());
		// Verificar se Imovel já foi atualizada por outro usuário durante esta
		// atualização
		// [FS0007] Atualização realizada por outro usuário
		if(imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// desvincular
		if(desvincular){
			imovel.setIndicadorImovelCondominio(Imovel.IMOVEL_NAO_CONDOMINIO);

			/**
			 * alterado por pedro alexandre dia 20/11/2006 alteração feita para
			 * acoplar o controle de abrangência de usuário
			 */
			// ------------ CONTROLE DE ABRANGENCIA ----------------
			Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

			if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.acesso.negado.abrangencia");
			}else{
				getControladorUtil().atualizar(imovel);
			}
			// ------------ FIM CONTROLE DE ABRANGENCIA -------------
		}

		if(ids != null){
			for(int i = 0; i < ids.length; i++){
				String id = ids[i];

				filtroImovel = new FiltroImovel();

				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, id.trim()));

				imovel = (Imovel) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()).iterator().next());

				// imovel = (Imovel) ((List) ()).get(0);

				imovel.setImovelCondominio(null);

				filtroImovel = new FiltroImovel();

				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, imovel.getId()));
				imovel.setUltimaAlteracao(new Date());
				// Procura Imovel na base
				imovelNaBase = (Imovel) ((List) (getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()))).get(0);
				imovel.setUltimaAlteracao(new Date());
				// Verificar se Imovel já foi atualizada por outro usuário
				// durante esta
				// atualização
				// [FS0007] Atualização realizada por outro usuário
				if(imovelNaBase.getUltimaAlteracao().after(imovel.getUltimaAlteracao())){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.atualizacao.timestamp");
				}

				/**
				 * alterado por pedro alexandre dia 20/11/2006 alteração feita
				 * para acoplar o controle de abrangência de usuário
				 */
				// ------------ CONTROLE DE ABRANGENCIA ----------------
				Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

				if(!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				}else{
					getControladorUtil().atualizar(imovel);
				}
				// ------------ FIM CONTROLE DE ABRANGENCIA -------------
			}
		}
	}

	/**
	 * [UC0082] / [UC0712] - Registrar Leituras e Anormalidades Autor: Sávio
	 * Luiz Data: 04/01/2006
	 * 
	 * @author eduardo henrique
	 * @date 11/09/2008 Alterações na geração da Medição Histórico, adição da
	 *       informação de Créditos de Consumo.
	 * @author eduardo henrique
	 * @date 07/01/2009 Alteração no método para somente marcar a atividade como
	 *       concluída, quando não existir nenhhum MovimentRoteiroEmpresa com
	 *       indicador de Fase <> '2'
	 * @author eduardo henrique
	 * @date 17/01/2009 Aumento do nr. de imóveis por consulta de medição, para
	 *       otimização de performance Oracle.
	 * @author eduardo henrique
	 * @date 19/01/2009 Alteração na definição de confirmação de Leitura
	 *       Realizada.
	 * @author eduardo henrique
	 * @date 21/01/2009 Alteração no critério de considerar Leitura
	 *       Realizada/Não Realizada.
	 */
	public void registrarLeiturasAnormalidades(Collection<MedicaoHistorico> colecaoMedicaoHistorico, Integer idFaturamentoGrupo,
					Integer anoMesReferencia, Usuario usuario) throws ControladorException{

		atualizarLeituraAnormalidade(colecaoMedicaoHistorico, idFaturamentoGrupo, anoMesReferencia, usuario);
	}

	private void atualizarLeituraAnormalidade(Collection<MedicaoHistorico> colecaoMedicaoHistorico, Integer idFaturamentoGrupo,
					Integer anoMesReferencia, Usuario usuario) throws ControladorException{

		// Entidades para o relatório;
		Empresa empresa = null;
		Localidade localidade = null;
		List<MedicaoHistorico> colecaoMedicaoHistoricoRelatorio = new ArrayList<MedicaoHistorico>(colecaoMedicaoHistorico);
		// O grupo de faturamento é obrigatório.
		if((idFaturamentoGrupo == null) || (idFaturamentoGrupo.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.faturamento_grupo_nao_informado");
		}

		try{
			// busca o Ano/Mês Referência do Faturamento Grupo a ser Processado
			if(anoMesReferencia == null){
				FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
				filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, idFaturamentoGrupo));

				Collection<FaturamentoGrupo> colecaoGrupoFaturamento = getControladorUtil().pesquisar(filtroFaturamentoGrupo,
								FaturamentoGrupo.class.getName());
				if(colecaoGrupoFaturamento != null && !colecaoGrupoFaturamento.isEmpty()){
					FaturamentoGrupo grupoFaturamento = (FaturamentoGrupo) Util.retonarObjetoDeColecao(colecaoGrupoFaturamento);

					// Realiza a verificação dos Parâmetros
					if(grupoFaturamento.getAnoMesReferencia() == null){
						throw new ControladorException("atencao.ano_mes.invalido");
					}
					anoMesReferencia = grupoFaturamento.getAnoMesReferencia();
				}else{
					throw new ControladorException("atencao.faturamento_grupo_nao_informado");
				}
			}

			// cria uma coleção das leituras e anormalidades (objetos Medicao
			// Historico) que não serão registradas e sim
			// para gerar um relatório.
			Collection gerarRelatorioObjetosNaoRegistrados = new ArrayList();

			Calendar dataAtualCalendar = Calendar.getInstance();
			dataAtualCalendar.set(Calendar.MILLISECOND, 0);
			dataAtualCalendar.set(Calendar.SECOND, 0);

			Date dataAtual = dataAtualCalendar.getTime();

			Integer idImovelValido = null;

			// cria uma coleção de leituras e anormalidades (objetos Medicao
			// Historico) queserão registradas
			Collection registrarLeiturasAnormalidades = new ArrayList();
			Collection<Integer> idImoveisRegistrarMovimentoRoteiroEmpresa = new ArrayList<Integer>();
			// TODO Adicionar coleção de Movimento_Roteiro_Empresa que será
			// atualizado também
			if(Util.isVazioOrNulo(colecaoMedicaoHistorico)){
				throw new ControladorException("atencao.nao_ha_leitura_anormalidades_grupo_faturamento", null, idFaturamentoGrupo
								.toString(), Util.formatarAnoMesParaMesAno(anoMesReferencia));
			}
			Iterator medicaoHistoricoIterator = colecaoMedicaoHistorico.iterator();

			Integer quantidadeMedicoesTipo = null;
			// Integer idImovelPesquisa = null;

			Collection colecaoIdsImoveisAgua = new ArrayList();
			Collection colecaoIdsImoveisPoco = new ArrayList();
			Map<Integer, MedicaoHistorico> mapTxtAgua = new HashMap();
			Map<Integer, MedicaoHistorico> mapTxtPoco = new HashMap();
			Map<Integer, MedicaoHistorico> mapTxtSemMedicao = new HashMap();
			// verifica a quantidade de ano mes que repete mais para ser inserido em cronograma
			// faturamento atividade
			Map<Date, Integer> mapQuantidadeAnoMesRepetidos = new HashMap();
			// passa a data que está como string para data e verifica se é válida
			Date dataLeituraAtualInformada = null;

			while(medicaoHistoricoIterator.hasNext()){
				StringBuilder dadosRelatorio = new StringBuilder();

				// verifica se a medição historico vai ser gerada no relatório ou se
				// registrado se false será registrado se true será gerado no relatório
				boolean gerarRelatorio = false;

				MedicaoHistorico medicaoHistoricoTxt = (MedicaoHistorico) medicaoHistoricoIterator.next();
				Integer quantidadeFuncionariosNaBase = null;
				if(medicaoHistoricoTxt.getFuncionario() != null && medicaoHistoricoTxt.getFuncionario().getId() != null){
					try{
						quantidadeFuncionariosNaBase = repositorioFuncionario.verificarExistenciaFuncionario(medicaoHistoricoTxt
										.getFuncionario().getId());

					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}
				// verifica se existe o funcionario na base
				if(quantidadeFuncionariosNaBase != null && quantidadeFuncionariosNaBase <= 0){
					dadosRelatorio.append("Matrícula do Funcionário Inexistente.");
					dadosRelatorio.append(System.getProperty("line.separator"));
					log.error("** RLA - Matrícula do Funcionário Inexistente.");
				}

				// recupera a data como string do da medicaoHistoricoTxt
				boolean dataInvalida = false;
				String dataLeituraAtualString = medicaoHistoricoTxt.getDataLeituraParaRegistrar();
				if(dataLeituraAtualString != null){
					SimpleDateFormat dataTxt = new SimpleDateFormat("yyyyMMdd");

					try{
						dataLeituraAtualInformada = dataTxt.parse(dataLeituraAtualString);
					}catch(ParseException e){
						dataInvalida = true;
					}

					// Obtém o anoMes da data de leitura atual informada
					Integer anoMes = Util.formataAnoMes(dataLeituraAtualInformada);

					String anoMesString = "" + anoMes;
					String anoMesReferenciaString = "" + anoMesReferencia;
					if((anoMesString != null && anoMesString.length() >= 6)
									&& (anoMesReferenciaString != null && anoMesReferenciaString.length() >= 6)){

						// Compara o anoMes com o anoMesReferencia
						if(!Util.compararAnoMesReferencia(anoMes, anoMesReferencia, "=")){

							// Adiciona mais um mês
							Integer anoMesReferenciaMaisUmMes = Util.somarData(anoMesReferencia);
							Integer anoMesReferenciaMenosUmMes = Util.subtrairData(anoMesReferencia);

							if(!Util.compararAnoMesReferencia(anoMes, anoMesReferenciaMaisUmMes, "=")){
								if(!Util.compararAnoMesReferencia(anoMes, anoMesReferenciaMenosUmMes, "=")){
									gerarRelatorio = true;
									dadosRelatorio.append("Data de leitura incompatível com o mês/ano de faturamento.");
									dadosRelatorio.append(System.getProperty("line.separator"));
									log.error("** RLA - Data de leitura incompatível com o mês/ano de faturamento.");
								}
							}

						}
					}
				}

				// caso a data seja válida e seja depois a atual cria uma string
				// para criar um relatório
				if(dataInvalida || (dataLeituraAtualInformada != null && dataLeituraAtualInformada.after(new Date()))){
					gerarRelatorio = true;
					dadosRelatorio.append("Data de leitura inválida.");
					dadosRelatorio.append(System.getProperty("line.separator"));
					log.error("** RLA - Data de leitura inválida.");
				}

				Integer quantidadeImoveisNaBase = null;
				if(medicaoHistoricoTxt.getImovel().getId() != null){
					try{
						quantidadeImoveisNaBase = repositorioImovel.verificarExistenciaImovel(medicaoHistoricoTxt.getImovel().getId());
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}

				// verifica a existência do imóvel na base
				if(quantidadeImoveisNaBase == null || quantidadeImoveisNaBase <= 0){
					gerarRelatorio = true;
					dadosRelatorio.append("Matrícula do Imóvel Inexistente.");
					dadosRelatorio.append(System.getProperty("line.separator"));
					log.error("** RLA - Matrícula do Imóvel Inexistente.");
					// recupera empresa e localidade do imóvel do primeiro registro selecionado da
					// tabela MOVIMENTO_ROTEIRO_EMPRESA
				}else if(empresa == null && localidade == null){
					FiltroImovel filtroImovel = new FiltroImovel();
					filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOCALIDADE);
					filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.EMPRESA);
					filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, medicaoHistoricoTxt.getImovel().getId()));
					Imovel imovel = (Imovel) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroImovel,
									Imovel.class.getName()));
					empresa = imovel.getRota().getEmpresa();
					localidade = imovel.getLocalidade();
				}
				// verifica a existência da leitura anormalidade
				Object[] leituraAnormalidade = null;
				Integer idLeituraAnormalidade = null;
				Short indicadorImovelSemHidrometro = null;
				if(medicaoHistoricoTxt.getLeituraAnormalidadeInformada() != null
								&& medicaoHistoricoTxt.getLeituraAnormalidadeInformada().getId() != null){
					try{
						leituraAnormalidade = repositorioMicromedicao.pesquisarLeituraAnormalidade(medicaoHistoricoTxt
										.getLeituraAnormalidadeInformada().getId());
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}

				if(leituraAnormalidade != null){

					if(leituraAnormalidade[0] != null){
						idLeituraAnormalidade = (Integer) leituraAnormalidade[0];
					}

					if(leituraAnormalidade[1] != null){
						indicadorImovelSemHidrometro = (Short) leituraAnormalidade[1];
					}
				}

				// verificar tipo de medicao

				// verifica se existe hidrometro instalação histórico para o
				// imóvel
				// da medição histórico
				Integer idHidrometroInstalacaoHistorico = null;
				if(medicaoHistoricoTxt.getImovel().getId() != null){

					if(medicaoHistoricoTxt.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){
						try{
							idHidrometroInstalacaoHistorico = repositorioMicromedicao
											.verificarExistenciaHidrometroInstalacaoHistoricoTipoAgua(medicaoHistoricoTxt.getImovel()
															.getId());
						}catch(ErroRepositorioException e){
							throw new ControladorException("erro.sistema", e);
						}
					}else{
						if(medicaoHistoricoTxt.getMedicaoTipo().getId().equals(MedicaoTipo.POCO)){
							try{
								idHidrometroInstalacaoHistorico = repositorioMicromedicao
												.verificarExistenciaHidrometroInstalacaoHistoricoTipoPoco(medicaoHistoricoTxt.getImovel()
																.getId());
							}catch(ErroRepositorioException e){
								throw new ControladorException("erro.sistema", e);
							}
						}
					}
				}

				if(medicaoHistoricoTxt.getMedicaoTipo().getId() != null){

					try{
						quantidadeMedicoesTipo = repositorioMicromedicao.verificarExistenciaMedicaoTipo(medicaoHistoricoTxt
										.getMedicaoTipo().getId());
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}

				// verifica se existe a medição tipo na base
				if(quantidadeMedicoesTipo == null || quantidadeMedicoesTipo <= 0){
					if(medicaoHistoricoTxt.getMedicaoTipo().getId() != 0){
						gerarRelatorio = true;
						dadosRelatorio.append("Tipo de Medição Inexistente.");
						dadosRelatorio.append(System.getProperty("line.separator"));
						log.error("** RLA - Tipo de Medição Inexistente.");

					}else{

						// verificar se existe hidrometro instalado e a leitura
						// informada seja maior que 0
						if(medicaoHistoricoTxt.getLeituraAtualInformada() > 0 && idHidrometroInstalacaoHistorico == null){

							gerarRelatorio = true;
							dadosRelatorio.append("Movimentação para ligação sem hidrômetro.");
							dadosRelatorio.append(System.getProperty("line.separator"));
							log.error("** RLA - Movimentação para ligação sem hidrômetro.");
						}else{
							// caso a anromalidade informada não seja compatível com ligação sem
							// hidrometro e o hidrometro instalação histórico sejá nulo
							if(indicadorImovelSemHidrometro.equals(ConstantesSistema.NAO)){
								gerarRelatorio = true;
								dadosRelatorio.append("Anormalidade não permitida para ligação sem hidrômetro.");
								dadosRelatorio.append(System.getProperty("line.separator"));
								log.error("** RLA - Anormalidade não permitida para ligação sem hidrômetro.");
							}
						}

					}
				}else{

					if(medicaoHistoricoTxt.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){
						if(idHidrometroInstalacaoHistorico == null){
							gerarRelatorio = true;
							dadosRelatorio.append("Movimento para ligação de agua sem hidrômetro.");
							dadosRelatorio.append(System.getProperty("line.separator"));
							log.error("** RLA - Movimento para ligação de agua sem hidrômetro.");
						}

					}else{
						if(medicaoHistoricoTxt.getMedicaoTipo().getId().equals(MedicaoTipo.POCO)){
							if(idHidrometroInstalacaoHistorico == null){
								gerarRelatorio = true;
								dadosRelatorio.append("Movimento para poço sem hidrômetro.");
								dadosRelatorio.append(System.getProperty("line.separator"));
								log.error("** RLA - Movimento para poço sem hidrômetro.");
							}

						}
					}
				}

				Integer idLeituraAnormalidadeInformada = null;
				if(medicaoHistoricoTxt.getLeituraAnormalidadeInformada() != null){
					idLeituraAnormalidadeInformada = medicaoHistoricoTxt.getLeituraAnormalidadeInformada().getId();
				}

				// verificar existencia de código de anormalidade de leitura
				if(idLeituraAnormalidade == null && idLeituraAnormalidadeInformada != null && !idLeituraAnormalidadeInformada.equals(0)){
					gerarRelatorio = true;
					dadosRelatorio.append("Código da Anormalidade de Leitura inexistente.");
					dadosRelatorio.append(System.getProperty("line.separator"));
					log.error("** RLA - Código da Anormalidade de Leitura inexistente.");

				}

				// verificar existencia de código de anormalidade de leitura
				if(medicaoHistoricoTxt.getIndicadorConfirmacaoLeitura() != null
								&& (medicaoHistoricoTxt.getIndicadorConfirmacaoLeitura().equals(
												MedicaoHistorico.INDICADOR_CONFIRMACAO_LEITURA_ZERO) || medicaoHistoricoTxt
												.getIndicadorConfirmacaoLeitura().equals(MedicaoHistorico.INDICADOR_CONFIRMACAO_LEITURA_UM))){
					gerarRelatorio = true;
					dadosRelatorio.append("Indicador de confirmação de Leitura inválido.");
					dadosRelatorio.append(System.getProperty("line.separator"));
					log.error("** RLA - Indicador de confirmação de Leitura inválido.");

				}

				// se a medição histórico passar por algum fluxo secundário
				// então essa medição histórico irá para o relatório
				if(gerarRelatorio){
					medicaoHistoricoTxt.setGerarRelatorio(dadosRelatorio.toString());
					gerarRelatorioObjetosNaoRegistrados.add(medicaoHistoricoTxt);
				}else{
					Integer idImovel = medicaoHistoricoTxt.getImovel().getId();
					// idImovelPesquisa = idImovel;
					// Integer idImovelVerificado = idImovel;
					// System.out.println("idImovel 1:" + idImovel);
					Integer idMedicaoTipo = medicaoHistoricoTxt.getMedicaoTipo().getId();
					// caso a map não esteja vazio
					if(mapQuantidadeAnoMesRepetidos != null && !mapQuantidadeAnoMesRepetidos.isEmpty()){
						// recupe a quantidade de vezes que aquele anoMes foi repetido
						Integer quantidadeRegistros = mapQuantidadeAnoMesRepetidos.get(dataLeituraAtualInformada);
						// caso a quantidade de amoMes não tenha sido inserido no map ainda
						// então inseri uma nova tupla no map
						if(quantidadeRegistros == null || quantidadeRegistros.equals("")){
							mapQuantidadeAnoMesRepetidos.put(dataLeituraAtualInformada, 1);
						}else{
							// caso contrário atualiza o valor
							mapQuantidadeAnoMesRepetidos.put(dataLeituraAtualInformada, quantidadeRegistros + 1);
						}
					}else{
						mapQuantidadeAnoMesRepetidos.put(dataLeituraAtualInformada, 1);
					}

					medicaoHistoricoTxt.setGerarRelatorio(dadosRelatorio.toString());
					FiltroLigacaoAgua filtroLigacaoAgua = new FiltroLigacaoAgua();
					filtroLigacaoAgua.adicionarCaminhoParaCarregamentoEntidade(FiltroLigacaoAgua.HIDROMETRO_INSTALACAO_HISTORICO);
					filtroLigacaoAgua.adicionarParametro(new ParametroSimples(FiltroLigacaoAgua.ID, idImovel));
					LigacaoAgua ligacaoAgua = (LigacaoAgua) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroLigacaoAgua,
									LigacaoAgua.class.getName()));
					Imovel imovel = getControladorImovel().pesquisarImovel(idImovel);
					// caso o imóvel não tenha nem ligação agua nem ligação poço
					if(idMedicaoTipo != null && idMedicaoTipo.equals(0) && ligacaoAgua.getHidrometroInstalacaoHistorico() == null
									&& imovel.getHidrometroInstalacaoHistorico() == null){
						mapTxtSemMedicao.put(idImovel, medicaoHistoricoTxt);
					}else{
						if(idMedicaoTipo != null && idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)
										&& ligacaoAgua.getHidrometroInstalacaoHistorico() != null){
							colecaoIdsImoveisAgua.add(idImovel);
							mapTxtAgua.put(idImovel, medicaoHistoricoTxt);
						}else if(idMedicaoTipo != null && idMedicaoTipo.equals(MedicaoTipo.POCO)
										&& imovel.getHidrometroInstalacaoHistorico() != null){
							colecaoIdsImoveisPoco.add(idImovel);
							mapTxtPoco.put(idImovel, medicaoHistoricoTxt);
						}
					}
				}
			}

			Collection colecaoParmsMedicao = null;
			Object[] idsImoveisLimitadoAguaArray = colecaoIdsImoveisAgua.toArray();
			Object[] idsImoveisLimitadoPocoArray = colecaoIdsImoveisPoco.toArray();
			boolean terminou = false;
			int limiteInferior = 0;
			int limiteSuperior = 0;
			// começa com a medição tipo Agua
			Integer idMedicaoTipo = MedicaoTipo.LIGACAO_AGUA;
			Collection colecaoLimitadaIdsImoveis = null;
			while(!terminou){
				colecaoLimitadaIdsImoveis = new ArrayList();
				if(idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)){
					if((limiteSuperior + 1000) <= idsImoveisLimitadoAguaArray.length){
						limiteSuperior = limiteSuperior + 1000;
					}else{
						limiteSuperior = idsImoveisLimitadoAguaArray.length;
					}
				}
				if(idMedicaoTipo.equals(MedicaoTipo.POCO)){
					if((limiteSuperior + 1000) <= idsImoveisLimitadoPocoArray.length){
						limiteSuperior = limiteSuperior + 1000;
					}else{
						limiteSuperior = idsImoveisLimitadoPocoArray.length;
					}
				}

				for(; limiteInferior < limiteSuperior; limiteInferior++){
					if(idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)){
						colecaoLimitadaIdsImoveis.add(idsImoveisLimitadoAguaArray[limiteInferior]);
					}
					if(idMedicaoTipo.equals(MedicaoTipo.POCO)){
						colecaoLimitadaIdsImoveis.add(idsImoveisLimitadoPocoArray[limiteInferior]);
					}

				}

				Collection colecaoParmsMedicaoLimitada = null;
				if(colecaoLimitadaIdsImoveis != null && !colecaoLimitadaIdsImoveis.isEmpty()){
					try{
						colecaoParmsMedicaoLimitada = repositorioMicromedicao.pesquisarMedicaoHistorico(colecaoLimitadaIdsImoveis,
										anoMesReferencia, idMedicaoTipo);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
					colecaoParmsMedicao = new ArrayList();
					colecaoParmsMedicao.addAll(colecaoParmsMedicaoLimitada);
				}

				Collection colecaoIdsImoveisAtualizar = new ArrayList();

				Collection colecaoMedicaoHistoricoAtualizar = new ArrayList();

				if(colecaoParmsMedicao != null && !colecaoParmsMedicao.isEmpty()){

					Iterator iteParmsMedicao = colecaoParmsMedicao.iterator();

					// id medição histórico
					Integer idMedicaoHistorico = null;
					Integer idImovel = null;

					while(iteParmsMedicao.hasNext()){
						Object[] parmsMedicao = (Object[]) iteParmsMedicao.next();
						if(parmsMedicao != null){

							if(parmsMedicao[0] != null){
								idMedicaoHistorico = (Integer) parmsMedicao[0];
							}
							// id do imóvel
							if(parmsMedicao[1] != null){
								idImovel = (Integer) parmsMedicao[1];
								if(idImovelValido == null){
									idImovelValido = idImovel;
								}
							}

						}
						// System.out.println("idImovel:" + idImovel);

						if(idMedicaoHistorico != null){
							// cria um objeto de medição histórico para ser
							// atualizado
							MedicaoHistorico medicaoHistoricoAtualizar = new MedicaoHistorico();

							MedicaoHistorico medicaoHistoricoTxt = null;

							if(idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)){
								medicaoHistoricoTxt = mapTxtAgua.get(idImovel);
							}
							if(idMedicaoTipo.equals(MedicaoTipo.POCO)){
								medicaoHistoricoTxt = mapTxtPoco.get(idImovel);
							}

							// caso a medição não tenha funcionario na base então inserir com nulo o
							// funcionario e manda essa medição para o relatório
							if(medicaoHistoricoTxt.getGerarRelatorio() != null
											&& medicaoHistoricoTxt.getGerarRelatorio().trim().equalsIgnoreCase(
															"Matrícula do Funcionário Inexistente.")){

								/*
								 * gerarRelatorioObjetosNaoRegistrados
								 * .add(medicaoHistoricoTxt);
								 */
								if(medicaoHistoricoTxt.getFuncionario() != null){
									Funcionario funcionario = new Funcionario();
									funcionario.setId(medicaoHistoricoTxt.getFuncionario().getId());
									medicaoHistoricoAtualizar.setFuncionario(funcionario);
								}
							}else{
								// atualiza o id funcionario com null caso não exista na base ou com
								// o valor do txt
								if(medicaoHistoricoTxt.getFuncionario() != null){
									Funcionario funcionario = new Funcionario();
									funcionario.setId(medicaoHistoricoTxt.getFuncionario().getId());
									medicaoHistoricoAtualizar.setFuncionario(funcionario);
								}
							}

							// codigo da anormalidade de leitura informada
							if(medicaoHistoricoTxt.getLeituraAnormalidadeInformada() == null
											|| medicaoHistoricoTxt.getLeituraAnormalidadeInformada().getId() == null
											|| medicaoHistoricoTxt.getLeituraAnormalidadeInformada().getId().intValue() == 0){
								medicaoHistoricoAtualizar.setLeituraAnormalidadeInformada(null);
							}else{
								medicaoHistoricoAtualizar.setLeituraAnormalidadeInformada(medicaoHistoricoTxt
												.getLeituraAnormalidadeInformada());
							}

							// data atual da leitura informada - mesma para o
							// Faturamento
							medicaoHistoricoAtualizar.setDataLeituraAtualInformada(dataLeituraAtualInformada);
							medicaoHistoricoAtualizar.setDataLeituraAtualFaturamento(dataLeituraAtualInformada);

							// com a leitura informada
							if(medicaoHistoricoTxt.getLeituraAtualInformada() == null
											|| medicaoHistoricoTxt.getLeituraAtualInformada().intValue() == 0){
								medicaoHistoricoAtualizar.setLeituraAtualInformada(null);
								medicaoHistoricoAtualizar.setLeituraAtualFaturamento(null);
							}else{
								medicaoHistoricoAtualizar.setLeituraAtualInformada(medicaoHistoricoTxt.getLeituraAtualInformada());
								medicaoHistoricoAtualizar.setLeituraAtualFaturamento(medicaoHistoricoTxt.getLeituraAtualInformada());
							}
							medicaoHistoricoAtualizar.setAnoMesReferencia(anoMesReferencia);
							medicaoHistoricoAtualizar.setId(idMedicaoHistorico);
							medicaoHistoricoAtualizar.setUltimaAlteracao(dataAtual);

							/*
							 * Atualização da coluna situação da leitura quando
							 * já existe o MEDICAO_HISTORICO. Alteração feita no
							 * [FS0011]- inclusão do item 5 data: 30/07/2007
							 */
							LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();

							if(medicaoHistoricoTxt.getLeituraAtualInformada() == null){
								leituraSituacaoAtual.setId(LeituraSituacao.NAO_REALIZADA);
								medicaoHistoricoAtualizar.setLeituraSituacaoAtual(leituraSituacaoAtual);
							}else{
								if((medicaoHistoricoTxt.getIndicadorConfirmacaoLeitura() != null && Integer.valueOf(
												medicaoHistoricoTxt.getIndicadorConfirmacaoLeitura()).equals(
												MedicaoHistorico.INDICADOR_LEITURA_CONFIRMADA))){
									leituraSituacaoAtual.setId(LeituraSituacao.CONFIRMADA);
									medicaoHistoricoAtualizar.setLeituraSituacaoAtual(leituraSituacaoAtual);
								}else{
									leituraSituacaoAtual.setId(LeituraSituacao.REALIZADA);

									medicaoHistoricoAtualizar.setLeituraSituacaoAtual(leituraSituacaoAtual);
								}
							}

							// ----------------------------------------------------------------------------------
							// Solicitação de ADA - Caso leitura = null e
							// anormalidadade = null ,
							// informar anormalidade de Leitura Não Realizada
							// ----------------------------------------------------------------------------------
							LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
							if(medicaoHistoricoTxt.getLeituraAtualInformada() == null
											&& (medicaoHistoricoTxt.getLeituraAnormalidadeInformada() == null || medicaoHistoricoTxt
															.getLeituraAnormalidadeInformada().getId() == null)){
								if(!LeituraAnormalidade.LEITURA_NAO_REALIZADA.equals(ConstantesSistema.INVALIDO_ID)){
									leituraAnormalidade.setId(LeituraAnormalidade.LEITURA_NAO_REALIZADA);
									medicaoHistoricoAtualizar.setLeituraAnormalidadeInformada(leituraAnormalidade);
								}

							}
							// ----------------------------------------------------------------------------------

							// verifica se não contem a medição historico na
							// coleção
							// que irá inserir
							if(!colecaoMedicaoHistoricoAtualizar.contains(medicaoHistoricoAtualizar)){

								colecaoMedicaoHistoricoAtualizar.add(medicaoHistoricoAtualizar);

								// adiciona o id do Imóvel para a atualização
								// dos Movimentos Empresa
								if(!idImoveisRegistrarMovimentoRoteiroEmpresa.contains(medicaoHistoricoTxt.getImovel().getId())){
									idImoveisRegistrarMovimentoRoteiroEmpresa.add(medicaoHistoricoTxt.getImovel().getId());
								}
							}

						}

						colecaoIdsImoveisAtualizar.add(idImovel);
					}
				}
				colecaoParmsMedicao = null;

				// remove todos os ids dos imóveis que foram ser atualizados

				colecaoLimitadaIdsImoveis.removeAll(colecaoIdsImoveisAtualizar);

				Collection colecaoParmsMedicaoAnterior = null;

				// caso não tenha dados do mes anterior,então é guardado os
				// imoveis e pesquisado novamento com 2 meses anteriores
				Collection colecaoIdsImoveisNaoAnterior = new ArrayList();
				colecaoIdsImoveisNaoAnterior.addAll(colecaoLimitadaIdsImoveis);

				int anoMesAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia, 1);

				if(colecaoLimitadaIdsImoveis != null && !colecaoLimitadaIdsImoveis.isEmpty()){
					try{
						colecaoParmsMedicaoAnterior = repositorioMicromedicao.pesquisarMedicaoHistoricoAnterior(colecaoLimitadaIdsImoveis,
										anoMesAnterior, idMedicaoTipo);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
				}
				Map<Integer, MedicaoHistoricoAnteriorHelper> mapMedicaoHistoricoAnterior = null;

				if(colecaoParmsMedicaoAnterior != null && !colecaoParmsMedicaoAnterior.isEmpty()){

					Iterator iteParmsMedicaoAnterior = colecaoParmsMedicaoAnterior.iterator();

					mapMedicaoHistoricoAnterior = new HashMap();

					while(iteParmsMedicaoAnterior.hasNext()){
						Object[] dadosAnterioresMedicaoHistorico = (Object[]) iteParmsMedicaoAnterior.next();

						if(dadosAnterioresMedicaoHistorico != null){
							Integer idImovel = null;
							MedicaoHistoricoAnteriorHelper medicaoHistoricoAnteriorHelper = new MedicaoHistoricoAnteriorHelper();

							if(dadosAnterioresMedicaoHistorico[0] != null){
								medicaoHistoricoAnteriorHelper.setDataLeituraAnteriorFaturamento((Date) dadosAnterioresMedicaoHistorico[0]);
							}else{
								medicaoHistoricoAnteriorHelper.setDataLeituraAnteriorFaturamento(null);
							}

							if(dadosAnterioresMedicaoHistorico[1] != null){
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorFaturamento(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[1].toString()));
							}else{
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorFaturamento(0);
							}

							if(dadosAnterioresMedicaoHistorico[2] != null){
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorInformada(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[2].toString()));
							}else{
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorInformada(0);
							}

							if(dadosAnterioresMedicaoHistorico[3] != null){
								medicaoHistoricoAnteriorHelper.setIdLeituraSituacaoAnterior((Integer) dadosAnterioresMedicaoHistorico[3]);
							}else{
								medicaoHistoricoAnteriorHelper.setIdLeituraSituacaoAnterior(null);
							}
							if(dadosAnterioresMedicaoHistorico[4] != null){
								medicaoHistoricoAnteriorHelper
												.setIdHidrometroInstalacaoHistorico((Integer) dadosAnterioresMedicaoHistorico[4]);
							}

							if(dadosAnterioresMedicaoHistorico[5] != null){
								medicaoHistoricoAnteriorHelper.setDataInstacao((Date) dadosAnterioresMedicaoHistorico[5]);
							}
							// se for por imovel então 5 senão se for por
							// ligação agua então
							if(dadosAnterioresMedicaoHistorico[6] != null){
								idImovel = (Integer) dadosAnterioresMedicaoHistorico[6];
							}

							if(dadosAnterioresMedicaoHistorico[7] != null){
								medicaoHistoricoAnteriorHelper
												.setNumeroConsumoCreditoAnterior((Integer) dadosAnterioresMedicaoHistorico[7]);
							}

							mapMedicaoHistoricoAnterior.put(idImovel, medicaoHistoricoAnteriorHelper);
							colecaoIdsImoveisNaoAnterior.remove(idImovel);
						}
					}
				}

				colecaoParmsMedicaoAnterior = null;

				// caso algum imovel não foi retornado no ano mês anterior então faz uma nova
				// pesquisa passando 2 meses anteriores
				if(colecaoIdsImoveisNaoAnterior != null && !colecaoIdsImoveisNaoAnterior.isEmpty()){

					int doisAnoMesAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia, 2);

					if(mapMedicaoHistoricoAnterior == null || mapMedicaoHistoricoAnterior.size() == 0){
						mapMedicaoHistoricoAnterior = new HashMap();
					}

					try{
						colecaoParmsMedicaoAnterior = repositorioMicromedicao.pesquisarMedicaoHistoricoAnterior(
										colecaoIdsImoveisNaoAnterior, doisAnoMesAnterior, idMedicaoTipo);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}

					Iterator iteParmsMedicaoDoisMesesAnterior = colecaoParmsMedicaoAnterior.iterator();

					while(iteParmsMedicaoDoisMesesAnterior.hasNext()){
						Object[] dadosAnterioresMedicaoHistorico = (Object[]) iteParmsMedicaoDoisMesesAnterior.next();

						if(dadosAnterioresMedicaoHistorico != null){
							Integer idImovel = null;
							MedicaoHistoricoAnteriorHelper medicaoHistoricoAnteriorHelper = new MedicaoHistoricoAnteriorHelper();

							if(dadosAnterioresMedicaoHistorico[0] != null){
								medicaoHistoricoAnteriorHelper.setDataLeituraAnteriorFaturamento((Date) dadosAnterioresMedicaoHistorico[0]);
							}else{
								medicaoHistoricoAnteriorHelper.setDataLeituraAnteriorFaturamento(null);
							}

							if(dadosAnterioresMedicaoHistorico[1] != null){
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorFaturamento(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[1].toString()));
							}else{
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorFaturamento(0);
							}

							if(dadosAnterioresMedicaoHistorico[2] != null){
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorInformada(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[2].toString()));
							}else{
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorInformada(0);
							}

							if(dadosAnterioresMedicaoHistorico[3] != null){
								medicaoHistoricoAnteriorHelper.setIdLeituraSituacaoAnterior((Integer) dadosAnterioresMedicaoHistorico[3]);
							}else{
								medicaoHistoricoAnteriorHelper.setIdLeituraSituacaoAnterior(null);
							}
							if(dadosAnterioresMedicaoHistorico[4] != null){
								medicaoHistoricoAnteriorHelper
												.setIdHidrometroInstalacaoHistorico((Integer) dadosAnterioresMedicaoHistorico[4]);
							}

							if(dadosAnterioresMedicaoHistorico[5] != null){
								medicaoHistoricoAnteriorHelper.setDataInstacao((Date) dadosAnterioresMedicaoHistorico[5]);
							}
							// se for por imovel então 5 senão se for por
							// ligação agua então
							if(dadosAnterioresMedicaoHistorico[6] != null){
								idImovel = (Integer) dadosAnterioresMedicaoHistorico[6];
							}

							if(dadosAnterioresMedicaoHistorico[7] != null){
								medicaoHistoricoAnteriorHelper
												.setNumeroConsumoCreditoAnterior((Integer) dadosAnterioresMedicaoHistorico[7]);
							}

							mapMedicaoHistoricoAnterior.put(idImovel, medicaoHistoricoAnteriorHelper);
						}
					}
				}

				// caso algum imovel não foi retornado no ano mês anterior então faz uma nova
				// pesquisa passando 2 meses anteriores
				if(colecaoIdsImoveisNaoAnterior != null && !colecaoIdsImoveisNaoAnterior.isEmpty()){

					int doisAnoMesAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia, 2);

					if(mapMedicaoHistoricoAnterior == null || mapMedicaoHistoricoAnterior.size() == 0){
						mapMedicaoHistoricoAnterior = new HashMap();
					}

					try{
						colecaoParmsMedicaoAnterior = repositorioMicromedicao.pesquisarMaiorMedicaoHistoricoAnterior(
										colecaoIdsImoveisNaoAnterior, idMedicaoTipo);
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}

					Iterator iteParmsMedicaoDoisMesesAnterior = colecaoParmsMedicaoAnterior.iterator();

					while(iteParmsMedicaoDoisMesesAnterior.hasNext()){
						Object[] dadosAnterioresMedicaoHistorico = (Object[]) iteParmsMedicaoDoisMesesAnterior.next();

						if(dadosAnterioresMedicaoHistorico != null){
							Integer idImovel = null;
							MedicaoHistoricoAnteriorHelper medicaoHistoricoAnteriorHelper = new MedicaoHistoricoAnteriorHelper();

							if(dadosAnterioresMedicaoHistorico[0] != null){
								medicaoHistoricoAnteriorHelper.setDataLeituraAnteriorFaturamento((Date) dadosAnterioresMedicaoHistorico[0]);
							}else{
								medicaoHistoricoAnteriorHelper.setDataLeituraAnteriorFaturamento(null);
							}

							if(dadosAnterioresMedicaoHistorico[1] != null){
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorFaturamento(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[1].toString()));
							}else{
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorFaturamento(0);
							}

							if(dadosAnterioresMedicaoHistorico[2] != null){
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorInformada(Integer
												.parseInt(dadosAnterioresMedicaoHistorico[2].toString()));
							}else{
								medicaoHistoricoAnteriorHelper.setLeituraAtualMesAnteriorInformada(0);
							}

							if(dadosAnterioresMedicaoHistorico[3] != null){
								medicaoHistoricoAnteriorHelper.setIdLeituraSituacaoAnterior((Integer) dadosAnterioresMedicaoHistorico[3]);
							}else{
								medicaoHistoricoAnteriorHelper.setIdLeituraSituacaoAnterior(null);
							}
							if(dadosAnterioresMedicaoHistorico[4] != null){
								medicaoHistoricoAnteriorHelper
												.setIdHidrometroInstalacaoHistorico((Integer) dadosAnterioresMedicaoHistorico[4]);
							}

							if(dadosAnterioresMedicaoHistorico[5] != null){
								medicaoHistoricoAnteriorHelper.setDataInstacao((Date) dadosAnterioresMedicaoHistorico[5]);
							}
							// se for por imovel então 5 senão se for por
							// ligação agua então
							if(dadosAnterioresMedicaoHistorico[6] != null){
								idImovel = (Integer) dadosAnterioresMedicaoHistorico[6];
							}

							if(dadosAnterioresMedicaoHistorico[7] != null){
								medicaoHistoricoAnteriorHelper
												.setNumeroConsumoCreditoAnterior((Integer) dadosAnterioresMedicaoHistorico[7]);
							}

							mapMedicaoHistoricoAnterior.put(idImovel, medicaoHistoricoAnteriorHelper);
						}
					}
				}

				if(colecaoLimitadaIdsImoveis != null && !colecaoLimitadaIdsImoveis.isEmpty()){
					Iterator iteIdsImoveis = colecaoLimitadaIdsImoveis.iterator();

					while(iteIdsImoveis.hasNext()){
						Integer idImovelParaInsercao = (Integer) iteIdsImoveis.next();

						Date dataLeituraAnteriorFaturamento = null;
						Date dataInstacao = null;
						int leituraAtualMesAnteriorFaturamento = 0;
						int leituraAtualMesAnteriorInformada = 0;
						Integer idLeituraSituacaoAnterior = null;
						Integer idHidrometroInstalacaoHistorico = null;
						Integer numeroConsumoCreditoAnterior = null;

						MedicaoHistorico medicaoHistoricoRegistrar = new MedicaoHistorico();

						MedicaoHistorico medicaoHistoricoTxt = null;
						if(idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)){
							medicaoHistoricoTxt = mapTxtAgua.get(idImovelParaInsercao);
						}
						if(idMedicaoTipo.equals(MedicaoTipo.POCO)){
							medicaoHistoricoTxt = mapTxtPoco.get(idImovelParaInsercao);

						}

						MedicaoHistoricoAnteriorHelper medicaoHistoricoAnteriorHelper = null;
						if(mapMedicaoHistoricoAnterior != null && !mapMedicaoHistoricoAnterior.isEmpty()
										&& mapMedicaoHistoricoAnterior.containsKey(idImovelParaInsercao)){
							medicaoHistoricoAnteriorHelper = mapMedicaoHistoricoAnterior.get(idImovelParaInsercao);
						}

						if(medicaoHistoricoAnteriorHelper != null && !medicaoHistoricoAnteriorHelper.equals("")){
							dataLeituraAnteriorFaturamento = medicaoHistoricoAnteriorHelper.getDataLeituraAnteriorFaturamento();
							dataInstacao = medicaoHistoricoAnteriorHelper.getDataInstacao();
							leituraAtualMesAnteriorFaturamento = medicaoHistoricoAnteriorHelper.getLeituraAtualMesAnteriorFaturamento();
							leituraAtualMesAnteriorInformada = medicaoHistoricoAnteriorHelper.getLeituraAtualMesAnteriorInformada();
							idLeituraSituacaoAnterior = medicaoHistoricoAnteriorHelper.getIdLeituraSituacaoAnterior();
							idHidrometroInstalacaoHistorico = medicaoHistoricoAnteriorHelper.getIdHidrometroInstalacaoHistorico();

							numeroConsumoCreditoAnterior = medicaoHistoricoAnteriorHelper.getNumeroConsumoCreditoAnterior();
							// Não conseguiu localizar nenhum Historico de
							// Medicao, 1a Leitura --
							// tenta obter dados da Instalacao de Hidrom.
						}else{
							// casos de imoveis ligados sem hidrometro e 1a
							// leitura, vao considerar
							// Leitura Anterior como data do Processamento
							dataLeituraAnteriorFaturamento = dataLeituraAtualInformada;

							if(idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)){
								FiltroLigacaoAgua filtroLigacaoAgua = new FiltroLigacaoAgua();
								filtroLigacaoAgua
												.adicionarCaminhoParaCarregamentoEntidade(FiltroLigacaoAgua.HIDROMETRO_INSTALACAO_HISTORICO);
								filtroLigacaoAgua.adicionarParametro(new ParametroSimples(FiltroLigacaoAgua.ID, idImovelParaInsercao));
								Collection<LigacaoAgua> colecaoLigacaoAgua = getControladorUtil().pesquisar(filtroLigacaoAgua,
												LigacaoAgua.class.getName());
								LigacaoAgua ligacaoAgua = colecaoLigacaoAgua.iterator().next();

								/* filtro para hidrometro_instalacao_historio */
								if(ligacaoAgua.getHidrometroInstalacaoHistorico() != null){
									FiltroHidrometroInstalacaoHistorico filtroHidrometro = new FiltroHidrometroInstalacaoHistorico();
									filtroHidrometro.adicionarParametro(new ParametroSimples(FiltroHidrometroInstalacaoHistorico.ID,
													ligacaoAgua.getHidrometroInstalacaoHistorico().getId()));
									Collection<HidrometroInstalacaoHistorico> colecaoHidrometro = getControladorUtil().pesquisar(
													filtroHidrometro, HidrometroInstalacaoHistorico.class.getName());
									ligacaoAgua.setHidrometroInstalacaoHistorico(colecaoHidrometro.iterator().next());

									if(ligacaoAgua != null && ligacaoAgua.getHidrometroInstalacaoHistorico() != null){
										dataLeituraAnteriorFaturamento = ligacaoAgua.getHidrometroInstalacaoHistorico().getDataInstalacao();
										dataInstacao = ligacaoAgua.getHidrometroInstalacaoHistorico().getDataInstalacao();
										leituraAtualMesAnteriorFaturamento = ligacaoAgua.getHidrometroInstalacaoHistorico()
														.getNumeroLeituraInstalacao();
										leituraAtualMesAnteriorInformada = ligacaoAgua.getHidrometroInstalacaoHistorico()
														.getNumeroLeituraInstalacao();
										idLeituraSituacaoAnterior = LeituraSituacao.REALIZADA;
										idHidrometroInstalacaoHistorico = ligacaoAgua.getHidrometroInstalacaoHistorico().getId();
									}
								}
								filtroLigacaoAgua = null;

							}else{
								FiltroImovel filtroImovel = new FiltroImovel();
								filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.HIDROMETRO_INSTALACAO_HISTORICO);
								filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, idImovelParaInsercao));
								Collection<Imovel> colecaoImovel = getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
								Imovel imovel = colecaoImovel.iterator().next();

								/* filtro para hidrometro_instalacao_historio */
								if(imovel.getHidrometroInstalacaoHistorico() != null){
									FiltroHidrometroInstalacaoHistorico filtroHidrometro = new FiltroHidrometroInstalacaoHistorico();
									filtroHidrometro.adicionarParametro(new ParametroSimples(FiltroHidrometroInstalacaoHistorico.ID, imovel
													.getHidrometroInstalacaoHistorico().getId()));
									Collection<HidrometroInstalacaoHistorico> colecaoHidrometro = getControladorUtil().pesquisar(
													filtroHidrometro, HidrometroInstalacaoHistorico.class.getName());
									imovel.setHidrometroInstalacaoHistorico(colecaoHidrometro.iterator().next());

									if(imovel != null && imovel.getHidrometroInstalacaoHistorico() != null){
										dataLeituraAnteriorFaturamento = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();
										dataInstacao = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();
										leituraAtualMesAnteriorFaturamento = imovel.getHidrometroInstalacaoHistorico()
														.getNumeroLeituraInstalacao();
										leituraAtualMesAnteriorInformada = imovel.getHidrometroInstalacaoHistorico()
														.getNumeroLeituraInstalacao();
										idLeituraSituacaoAnterior = LeituraSituacao.REALIZADA;
										idHidrometroInstalacaoHistorico = imovel.getHidrometroInstalacaoHistorico().getId();
									}
								}
								filtroImovel = null;
							}
						}

						if(medicaoHistoricoTxt.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){
							// seta o id do imovel na ligação agua com null caso
							// não exista na base
							// ou com o valor do txt
							LigacaoAgua ligacaoAgua = new LigacaoAgua();
							ligacaoAgua.setId(medicaoHistoricoTxt.getImovel().getId());
							medicaoHistoricoRegistrar.setLigacaoAgua(ligacaoAgua);

						}else{
							if(medicaoHistoricoTxt.getMedicaoTipo().getId().equals(MedicaoTipo.POCO)){
								// seta o id do imovel com null caso não exista
								// na base ou com o
								// valor do txt
								Imovel imovel = new Imovel();
								imovel.setId(medicaoHistoricoTxt.getImovel().getId());
								medicaoHistoricoRegistrar.setImovel(imovel);
							}
						}

						// ano mes referência do header do arquivo
						medicaoHistoricoRegistrar.setAnoMesReferencia(anoMesReferencia);

						// seta o tipo de medição
						medicaoHistoricoRegistrar.setMedicaoTipo(medicaoHistoricoTxt.getMedicaoTipo());

						// numero de vezes consecutivas anormalidades
						medicaoHistoricoRegistrar.setNumeroVezesConsecutivasOcorrenciaAnormalidade(null);

						// verifica se o mes anterior é diferente de nulo
						if(dataLeituraAnteriorFaturamento != null){
							// seta a data de leitura anterior do faturamento
							medicaoHistoricoRegistrar.setDataLeituraAnteriorFaturamento(dataLeituraAnteriorFaturamento);
							// se não seta a data de instalação do historico
							// instalação hidrometro
						}else{
							if(dataInstacao == null){
								// seta a data de leitura anterior do
								// faturamento
								medicaoHistoricoRegistrar.setDataLeituraAnteriorFaturamento(new Date());
							}else{
								// seta a data de leitura anterior do
								// faturamento
								medicaoHistoricoRegistrar.setDataLeituraAnteriorFaturamento(dataInstacao);
							}
						}
						// leitura anterior faturamento
						medicaoHistoricoRegistrar.setLeituraAnteriorFaturamento(leituraAtualMesAnteriorFaturamento);

						// leitura anterior informada
						medicaoHistoricoRegistrar.setLeituraAnteriorInformada(leituraAtualMesAnteriorInformada);
						String dataLeituraAtualString = medicaoHistoricoTxt.getDataLeituraParaRegistrar();
						SimpleDateFormat dataTxt = new SimpleDateFormat("yyyyMMdd");

						if(dataLeituraAtualString != null){
							try{
								dataLeituraAtualInformada = dataTxt.parse(dataLeituraAtualString);
							}catch(ParseException e){
								dataLeituraAtualInformada = null;
							}
							// data leitura atual informada
							medicaoHistoricoRegistrar.setDataLeituraAtualInformada(dataLeituraAtualInformada);
						}
						// numero leitura atual informada com a leitura
						// informada
						if(medicaoHistoricoTxt.getLeituraAtualInformada() == null
										|| medicaoHistoricoTxt.getLeituraAtualInformada().intValue() == 0){

							medicaoHistoricoRegistrar.setLeituraAtualInformada(null);
							medicaoHistoricoRegistrar.setLeituraAtualFaturamento(null);

						}else{
							medicaoHistoricoRegistrar.setLeituraAtualInformada(medicaoHistoricoTxt.getLeituraAtualInformada());

							// numero leitura atual faturamento com o mesmo
							// numero de leitura
							// informada
							medicaoHistoricoRegistrar.setLeituraAtualFaturamento(medicaoHistoricoTxt.getLeituraAtualInformada());
						}
						// data leitura atual faturamento
						medicaoHistoricoRegistrar.setDataLeituraAtualFaturamento(dataLeituraAtualInformada);

						// consumo medido mes
						medicaoHistoricoRegistrar.setNumeroConsumoMes(null);

						// data leitura processamento motico
						medicaoHistoricoRegistrar.setNumeroConsumoInformado(null);

						// data de Processamento do Movimento
						medicaoHistoricoRegistrar.setLeituraProcessamentoMovimento(new Date());

						// caso a medição não tenha funcionario na base então
						// inseri com nulo o funcionario e manda essa medição
						// para o relatório
						if(medicaoHistoricoTxt.getFuncionario() == null){
							/*
							 * gerarRelatorioObjetosNaoRegistrados.add(medicaoHistoricoTxt
							 * );
							 */
							medicaoHistoricoRegistrar.setFuncionario(null);

						}else{
							// seta o funcionario na medição historico
							Funcionario funcionario = new Funcionario();
							funcionario.setId(medicaoHistoricoTxt.getFuncionario().getId());
							medicaoHistoricoRegistrar.setFuncionario(funcionario);
						}

						// leitura Anormalidade Informada com a leitura
						// anormalidade informada do txt ou do movimento celular
						// numero leitura atual informada
						// com a leitura informada
						if(medicaoHistoricoTxt.getLeituraAnormalidadeInformada() == null
										|| medicaoHistoricoTxt.getLeituraAnormalidadeInformada().getId() == null
										|| medicaoHistoricoTxt.getLeituraAnormalidadeInformada().getId().intValue() == 0){

							medicaoHistoricoRegistrar.setLeituraAnormalidadeInformada(null);
							medicaoHistoricoRegistrar.setLeituraAnormalidadeFaturamento(null);
						}else{
							medicaoHistoricoRegistrar
											.setLeituraAnormalidadeInformada(medicaoHistoricoTxt.getLeituraAnormalidadeInformada());
							medicaoHistoricoRegistrar.setLeituraAnormalidadeFaturamento(medicaoHistoricoTxt
											.getLeituraAnormalidadeInformada());
						}

						LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();

						if(medicaoHistoricoTxt.getLeituraAtualInformada() == null){
							leituraSituacaoAtual.setId(LeituraSituacao.NAO_REALIZADA);
							medicaoHistoricoRegistrar.setLeituraSituacaoAtual(leituraSituacaoAtual);
						}else{
							if((medicaoHistoricoTxt.getIndicadorConfirmacaoLeitura() != null && Integer.valueOf(
											medicaoHistoricoTxt.getIndicadorConfirmacaoLeitura()).equals(
											MedicaoHistorico.INDICADOR_LEITURA_CONFIRMADA))){
								leituraSituacaoAtual.setId(LeituraSituacao.CONFIRMADA);
								medicaoHistoricoRegistrar.setLeituraSituacaoAtual(leituraSituacaoAtual);
							}else{
								leituraSituacaoAtual.setId(LeituraSituacao.REALIZADA);
								medicaoHistoricoRegistrar.setLeituraSituacaoAtual(leituraSituacaoAtual);
							}
						}

						// leitura situacao anterior
						LeituraSituacao leituraSituacaoAnterior = new LeituraSituacao();
						// caso o id se situação anterior for nula seta o valor
						// da situação anterior
						// como não houve
						if(idLeituraSituacaoAnterior == null){
							leituraSituacaoAnterior.setId(LeituraSituacao.NAO_REALIZADA);
							medicaoHistoricoRegistrar.setLeituraSituacaoAnterior(leituraSituacaoAnterior);
						}else{
							// caso contrario seta com o valor de id da leitura
							// situação anterior
							leituraSituacaoAnterior.setId(idLeituraSituacaoAnterior);
							medicaoHistoricoRegistrar.setLeituraSituacaoAnterior(leituraSituacaoAnterior);
						}
						leituraSituacaoAnterior = null;

						// seta o hidrometro Instalação historico de acordo com
						// o tipo de medição
						if(idHidrometroInstalacaoHistorico != null){
							HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
							hidrometroInstalacaoHistorico.setId(idHidrometroInstalacaoHistorico);
							medicaoHistoricoRegistrar.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
						}

						if(numeroConsumoCreditoAnterior != null){
							medicaoHistoricoRegistrar.setConsumoCreditoAnterior(numeroConsumoCreditoAnterior);
						}

						// consumo medio hidrometro
						medicaoHistoricoRegistrar.setConsumoMedioHidrometro(null);

						// consumo Credito Gerado
						medicaoHistoricoRegistrar.setConsumoCreditoGerado(null);

						medicaoHistoricoRegistrar.setUltimaAlteracao(dataAtual);

						// ----------------------------------------------------------------------------------
						// Solicitação de ADA - Caso leitura = null e
						// anormalidadade = null ,
						// informar anormalidade de Leitura Não Realizada
						// ----------------------------------------------------------------------------------
						LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
						if(medicaoHistoricoTxt.getLeituraAtualInformada() == null
										&& (medicaoHistoricoTxt.getLeituraAnormalidadeInformada() == null || medicaoHistoricoTxt
														.getLeituraAnormalidadeInformada().getId() == null)){
							if(!LeituraAnormalidade.LEITURA_NAO_REALIZADA.equals(ConstantesSistema.INVALIDO_ID)){
								leituraAnormalidade.setId(LeituraAnormalidade.LEITURA_NAO_REALIZADA);
								medicaoHistoricoRegistrar.setLeituraAnormalidadeInformada(leituraAnormalidade);
							}
						}
						// ----------------------------------------------------------------------------------

						// verifica se não contem a medição historico na coleção
						// que irá inserir
						if(!registrarLeiturasAnormalidades.contains(medicaoHistoricoRegistrar)){

							registrarLeiturasAnormalidades.add(medicaoHistoricoRegistrar);
						}

						// adiciona o id do Imóvel para a atualização dos
						// Movimentos Empresa
						if(medicaoHistoricoTxt.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){

							if(!idImoveisRegistrarMovimentoRoteiroEmpresa.contains(medicaoHistoricoRegistrar.getLigacaoAgua().getId())){
								idImoveisRegistrarMovimentoRoteiroEmpresa.add(medicaoHistoricoRegistrar.getLigacaoAgua().getId());
							}

						}else{
							if(medicaoHistoricoTxt.getMedicaoTipo().getId().equals(MedicaoTipo.POCO)){

								if(!idImoveisRegistrarMovimentoRoteiroEmpresa.contains(medicaoHistoricoRegistrar.getImovel().getId())){
									idImoveisRegistrarMovimentoRoteiroEmpresa.add(medicaoHistoricoRegistrar.getImovel().getId());
								}
							}
						}

					}

				}

				// o else do gerar terminava aqui map contendo o id do imovel e
				// a leitura anormalidade que será atualizado

				if(registrarLeiturasAnormalidades != null && !registrarLeiturasAnormalidades.isEmpty()){
					try{
						repositorioMicromedicao.inseriMedicaoHistorico(registrarLeiturasAnormalidades);
					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				}

				if(colecaoMedicaoHistoricoAtualizar != null && !colecaoMedicaoHistoricoAtualizar.isEmpty()){
					try{
						repositorioMicromedicao.atualizarMedicaoHistorico(colecaoMedicaoHistoricoAtualizar);
					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
				}
				if(idMedicaoTipo.equals(MedicaoTipo.LIGACAO_AGUA)){
					if(limiteInferior == idsImoveisLimitadoAguaArray.length){
						idMedicaoTipo = MedicaoTipo.POCO;
						limiteInferior = 0;
						limiteSuperior = 0;
						mapTxtAgua = null;
					}
				}else{
					if(idMedicaoTipo.equals(MedicaoTipo.POCO)){
						if(limiteInferior == idsImoveisLimitadoPocoArray.length){
							terminou = true;
						}
					}
				}

				if(registrarLeiturasAnormalidades != null){
					registrarLeiturasAnormalidades.clear();
				}
				if(colecaoIdsImoveisAtualizar != null){
					colecaoIdsImoveisAtualizar.clear();
				}
				if(colecaoMedicaoHistoricoAtualizar != null){
					colecaoMedicaoHistoricoAtualizar.clear();
				}
				if(colecaoParmsMedicaoLimitada != null){
					colecaoParmsMedicaoLimitada.clear();
				}
				if(colecaoParmsMedicaoAnterior != null){
					colecaoParmsMedicaoAnterior.clear();
				}

			}

			// Atualiza Movimentos de Roteiro e Imóveis
			this.atualizarMovimentoRoteiroEmpresaImoveis(idImoveisRegistrarMovimentoRoteiroEmpresa, anoMesReferencia);

			getControladorImovel().atualizarImovelLeituraAnormalidade(mapTxtSemMedicao, dataAtual);

			Date dataComMaiorNumeroRegistroRepetidos = null;

			if(mapQuantidadeAnoMesRepetidos != null && !mapQuantidadeAnoMesRepetidos.isEmpty()){
				Collection colecaoQuantidadeRegistrosRepetidos = mapQuantidadeAnoMesRepetidos.entrySet();
				if(colecaoQuantidadeRegistrosRepetidos != null && !colecaoQuantidadeRegistrosRepetidos.isEmpty()){
					Iterator iteQuantidadeRegistrosRepetidos = colecaoQuantidadeRegistrosRepetidos.iterator();
					Integer qdtRegistrosAtual = 0;

					while(iteQuantidadeRegistrosRepetidos.hasNext()){
						Entry mapEntry = (Entry) iteQuantidadeRegistrosRepetidos.next();

						if(((Integer) mapEntry.getValue()) > qdtRegistrosAtual){
							qdtRegistrosAtual = (Integer) mapEntry.getValue();
							dataComMaiorNumeroRegistroRepetidos = (Date) mapEntry.getKey();
						}
					}

				}
			}

			// Caso todos os movimentos do Roteiro tenham sido processados,
			// atualiza as atividades
			// relacionadas no Cronograma e rola o período de faturamento para
			// grupo
			Integer quantidadeMovimentoRoteiroAProcessar = repositorioFaturamento
							.pesquisarQuantidadeMovimentosRoteiroEmpresaSemProcessamento(idFaturamentoGrupo, anoMesReferencia,
											MovimentoRoteiroEmpresa.FASE_PROCESSADO);
			if(quantidadeMovimentoRoteiroAProcessar == null || quantidadeMovimentoRoteiroAProcessar.equals(Integer.valueOf(0))){
				// atualiza o faturamento atividade cronograma com a data de realização com a data
				// corrente
				Integer idFaturamentoAtividadeCronogramaRegistrarLeiturasAnormalidades = null;
				Integer idFaturamentoAtividadeCronogramaEfetuarLeituras = null;
				Integer idFaturamentoGrupoCronogramaMensal = null;
				try{
					// pesquisa o id do faturamento grupo cronograma mensal
					idFaturamentoGrupoCronogramaMensal = repositorioFaturamento.pesquisarFaturamentoGrupoCronogramaMensal(
									idFaturamentoGrupo, anoMesReferencia);

					if(idFaturamentoGrupoCronogramaMensal != null){
						// pesquisa o id do faturamento atividade cronograma
						idFaturamentoAtividadeCronogramaRegistrarLeiturasAnormalidades = repositorioFaturamento
										.pesquisarFaturamentoAtividadeCronograma(idFaturamentoGrupoCronogramaMensal,
														FaturamentoAtividade.REGISTRAR_LEITURA_ANORMALIDADE);

						if(idFaturamentoAtividadeCronogramaRegistrarLeiturasAnormalidades != null){
							// atualiza o faturamento atividade cronograma para a data de realização
							// com a data corrente
							repositorioFaturamento.atualizarFaturamentoAtividadeCronograma(
											idFaturamentoAtividadeCronogramaRegistrarLeiturasAnormalidades, new Date());
						}

						// pesquisa o id do faturamento atividade cronograma
						idFaturamentoAtividadeCronogramaEfetuarLeituras = repositorioFaturamento.pesquisarFaturamentoAtividadeCronograma(
										idFaturamentoGrupoCronogramaMensal, FaturamentoAtividade.EFETUAR_LEITURA);

						if(idFaturamentoAtividadeCronogramaEfetuarLeituras != null){
							// atualiza o faturamento atividade cronograma para a data de realização
							// com a data corrente
							if(dataComMaiorNumeroRegistroRepetidos != null){
								repositorioFaturamento.atualizarFaturamentoAtividadeCronograma(
												idFaturamentoAtividadeCronogramaEfetuarLeituras, dataComMaiorNumeroRegistroRepetidos);
							}

						}

					}

				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
			}
			// comentado segundo solicitação de Alessandro e Fátima.
			// this.getControladorRegistroAtendimento().gerarRAColetor();

			// cria uma instância da classe do relatório
			RelatorioRegistrarLeiturasAnormalidades relatorioRegistrarLeiturasAnormalidades = new RelatorioRegistrarLeiturasAnormalidades(
							usuario);
			FiltroFaturamentoGrupo filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
			filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(FiltroFaturamentoGrupo.ID, idFaturamentoGrupo));

			FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(
							filtroFaturamentoGrupo, FaturamentoGrupo.class.getName()));

			relatorioRegistrarLeiturasAnormalidades.addParametro("colecaoMedicaoHistoricoRelatorio", colecaoMedicaoHistoricoRelatorio);
			relatorioRegistrarLeiturasAnormalidades.addParametro("faturamentoGrupo", faturamentoGrupo.getId() + " - "
							+ faturamentoGrupo.getDescricao());

			relatorioRegistrarLeiturasAnormalidades.addParametro("empresa", empresa.getId() + " - " + empresa.getDescricao());

			relatorioRegistrarLeiturasAnormalidades.addParametro("localidade", localidade.getDescricaoComId());

			relatorioRegistrarLeiturasAnormalidades.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);

			byte[] relatorioGerado = (byte[]) relatorioRegistrarLeiturasAnormalidades.executar();

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.REGISTRAR_LEITURAS_ANORMALIDADES);

			String emailRemetente = envioEmail.getEmailRemetente();

			String tituloMensagem = envioEmail.getTituloMensagem() + " " + idFaturamentoGrupo;

			String corpoMensagem = envioEmail.getCorpoMensagem();
			String emailReceptor = envioEmail.getEmailReceptor();

			try{
				File leitura = File.createTempFile("gcom", ".PDF");
				FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
				out.write(relatorioGerado);
				out.close();

				ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

				// leitura.delete();

			}catch(IOException e){
				throw new ControladorException("atencao.erro_permissao_gravacao_arquivo_email", e);
			}
		}catch(Exception e){

			e.printStackTrace();
			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.REGISTRAR_LEITURAS_ANORMALIDADES_COM_ERRO);

			String emailRemetente = envioEmail.getEmailRemetente();

			String tituloMensagem = envioEmail.getTituloMensagem() + " " + idFaturamentoGrupo;

			String emailReceptor = envioEmail.getEmailReceptor();

			String mensagem = e.getMessage();
			e.getStackTrace();
			if(mensagem == null){
				mensagem = "erro.metodo.nao.econtrado";
			}

			try{
				if(e instanceof ControladorException){
					ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, ((ControladorException) e).getMensagem());
				}else{
					ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, ConstantesAplicacao.get(mensagem));
				}
			}catch(ErroEmailException e1){

			}

		}
	}

	public Collection pesquisarHidrometroPorHidrometroMovimentacao(Filtro filtro) throws ControladorException{

		try{
			return repositorioHidrometro.pesquisarHidrometroPorHidrometroMovimentacao(filtro);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Consultar Dados do Cliente Imovel Vinculado Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param imovel
	 *            Imovel
	 * @return Dados do Imovel Vinculado
	 * @throws ControladorException
	 */
	public Cliente consultarDadosClienteImovelUsuario(Imovel imovel) throws ControladorException{

		Cliente cliente = null;

		Object[] colecaoClienteArray = null;

		try{
			colecaoClienteArray = repositorioMicromedicao.consultarDadosClienteImovelUsuario(imovel);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoClienteArray != null && !(colecaoClienteArray.length < 0)){

			cliente = new Cliente();

			// Seta o id do cliente
			if(colecaoClienteArray[0] != null){
				cliente.setId((Integer) colecaoClienteArray[0]);
			}
			// Seta o nome do cliente
			if(colecaoClienteArray[1] != null){
				cliente.setNome((String) colecaoClienteArray[1]);
			}
		}

		return cliente;
	}

	/**
	 * Consultar Dados do Cliente Imovel Vinculado Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return Consumo Tipo
	 * @throws ControladorException
	 */
	public ConsumoTipo consultarDadosConsumoTipoConsumoHistorico(ConsumoHistorico consumoHistorico) throws ControladorException{

		ConsumoTipo consumoTipo = null;

		Object[] colecaoConsumoTipoArray = null;

		try{
			colecaoConsumoTipoArray = repositorioMicromedicao.consultarDadosConsumoTipoConsumoHistorico(consumoHistorico);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoConsumoTipoArray != null && !(colecaoConsumoTipoArray.length < 0)){

			consumoTipo = new ConsumoTipo();

			// Descricao Abreviada
			if(colecaoConsumoTipoArray[0] != null){
				consumoTipo.setDescricaoAbreviada((String) colecaoConsumoTipoArray[0]);
			}

			// Id
			if(colecaoConsumoTipoArray[1] != null){
				consumoTipo.setId((Integer) colecaoConsumoTipoArray[1]);
			}

		}

		return consumoTipo;
	}

	/**
	 * Consultar Historico Medição Individualizada Auhtor: Rafael Santos Data:
	 * 23/01/2006 [UC001779] Consultar Histórico Medição Individualizada
	 * 
	 * @param imovelCondominio
	 *            Imovel Condominio
	 * @param anoMesFaturamento
	 *            Ano Mês Fauramento
	 * @return Dados do Historico Medição Individualizada
	 * @throws ControladorException
	 */
	public Collection consultarHistoricoMedicaoIndividualizada(Imovel imovelCondominio, String anoMesFaturamento)
					throws ControladorException{

		Collection colecaoHistoricosMedicaoIndividualizada = null;
		MedicaoHistorico medicaoHistorico = null;
		ConsumoHistorico consumoHistorico = null;
		ConsumoHistorico consumoHistoricoAgua = null;
		LigacaoTipo ligacaoTipo = null;
		Cliente cliente = null;
		ConsumoTipo consumoTipo = null;

		/*
		 * Matricula Nome do Cliente Tipo de Consumo Consumo de Água Medido
		 * Consumo de Água Faturado Consumo Esgoto Faturado Consumo do Rateio
		 */
		ConsultarHistoricoMedicaoIndividualizadaHelper consultarHistoricoMedicaoIndividualizadaHelper = null;

		if(imovelCondominio != null){

			colecaoHistoricosMedicaoIndividualizada = new ArrayList();

			// imovel condominio
			consultarHistoricoMedicaoIndividualizadaHelper = new ConsultarHistoricoMedicaoIndividualizadaHelper();

			ligacaoTipo = new LigacaoTipo();
			ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

			// consultar consumo Historico imovel condominio Ligacao Agua
			consumoHistoricoAgua = this.obterConsumoHistoricoMedicaoIndividualizada(imovelCondominio, ligacaoTipo, Integer.valueOf(
							anoMesFaturamento).intValue());

			// inscrição do imovel condominio
			consultarHistoricoMedicaoIndividualizadaHelper.setMatriculaImovel(imovelCondominio.getId().toString());

			cliente = this.consultarDadosClienteImovelUsuario(imovelCondominio);
			// nome do cliente do imovel condominio
			// consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario(cliente.getNome());
			if(cliente != null){
				consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario(cliente.getNome());
			}else{
				consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario("");
			}

			if(consumoHistoricoAgua == null){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.consumo.historico.inexistente.imovel.condominio");
			}
			consumoTipo = consultarDadosConsumoTipoConsumoHistorico(consumoHistoricoAgua);
			if(consumoTipo != null){
				// tipo de consumo do imovel condominio
				consultarHistoricoMedicaoIndividualizadaHelper.setTipoConsumo(consumoTipo.getDescricaoAbreviada());

			}else{
				// tipo de consumo do imovel condominio
				consultarHistoricoMedicaoIndividualizadaHelper.setTipoConsumo("");

			}

			try{
				medicaoHistorico = repositorioMicromedicao.pesquisarMedicaoHistoricoTipoAgua(imovelCondominio.getId(), Integer
								.valueOf(anoMesFaturamento));
			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
			if(medicaoHistorico != null && medicaoHistorico.getNumeroConsumoMes() != null){
				// consumo agua medido do imovel condominio
				consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaMedido(medicaoHistorico.getNumeroConsumoMes().toString());
			}else{
				consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaMedido("");
			}
			// consumo agua faturado do imovel condominio
			consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaFaturado(consumoHistoricoAgua.getNumeroConsumoFaturadoMes()
							.toString());
			// consumo rateio do imovel condominio
			if(consumoHistoricoAgua != null && consumoHistoricoAgua.getConsumoRateio() != null){
				consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio(consumoHistoricoAgua.getConsumoRateio().toString());
			}else{
				consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio("");
			}

			ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

			// consultar consumo Historico imovel condominio Ligacao Esgoto
			consumoHistorico = this.obterConsumoHistoricoCompleto(imovelCondominio, ligacaoTipo, Integer.valueOf(anoMesFaturamento)
							.intValue());

			// consumo esgoto do imovel condominio
			if(consumoHistorico != null && consumoHistorico.getNumeroConsumoFaturadoMes() != null){
				consultarHistoricoMedicaoIndividualizadaHelper.setConsumoEsgoto(consumoHistorico.getNumeroConsumoFaturadoMes().toString());
			}else{
				consultarHistoricoMedicaoIndividualizadaHelper.setConsumoEsgoto("");
			}

			// adicionando dados do imovel condominio
			colecaoHistoricosMedicaoIndividualizada.add(consultarHistoricoMedicaoIndividualizadaHelper);

			Collection colecaoConsumoHistoricoImoveisVinculados = this.consultarConsumoHistoricoImoveisVinculados(consumoHistoricoAgua);

			// obter os dados para os imoveis vinculados
			// coleção de ids dos imoveis vinculados ao condominio
			if(colecaoConsumoHistoricoImoveisVinculados != null && !colecaoConsumoHistoricoImoveisVinculados.isEmpty()){

				Iterator iColecaoConsumoHistoricoImoveisVinculados = colecaoConsumoHistoricoImoveisVinculados.iterator();

				while(iColecaoConsumoHistoricoImoveisVinculados.hasNext()){
					String idImovelVinculados = ((Integer) iColecaoConsumoHistoricoImoveisVinculados.next()).toString();

					// imovel vinculado
					consultarHistoricoMedicaoIndividualizadaHelper = new ConsultarHistoricoMedicaoIndividualizadaHelper();

					ligacaoTipo = new LigacaoTipo();
					ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

					Imovel imovelVinculado = new Imovel();
					imovelVinculado.setId(Integer.valueOf(idImovelVinculados));

					// consultar consumo Historico imovel vinculado Ligacao Agua
					consumoHistorico = this.obterConsumoHistoricoMedicaoIndividualizada(imovelVinculado, ligacaoTipo, Integer.valueOf(
									anoMesFaturamento).intValue());

					// inscrição do imovel vinculado
					consultarHistoricoMedicaoIndividualizadaHelper.setMatriculaImovel(imovelVinculado.getId().toString());

					cliente = this.consultarDadosClienteImovelUsuario(imovelVinculado);
					// nome do cliente do imovel vinculado
					if(cliente != null){
						consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario(cliente.getNome());
					}else{
						consultarHistoricoMedicaoIndividualizadaHelper.setNomeClienteUsuario("");
					}
					if(consumoHistorico != null){
						consumoTipo = consultarDadosConsumoTipoConsumoHistorico(consumoHistorico);
					}else{
						consumoTipo = null;
					}

					if(consumoTipo != null){
						// tipo de consumo do imovel vinculado
						consultarHistoricoMedicaoIndividualizadaHelper.setTipoConsumo(consumoTipo.getDescricaoAbreviada());

					}else{
						// tipo de consumo do imovel vinculado
						consultarHistoricoMedicaoIndividualizadaHelper.setTipoConsumo("");

					}

					try{
						medicaoHistorico = repositorioMicromedicao.pesquisarMedicaoHistoricoTipoAgua(imovelVinculado.getId(), Integer
										.valueOf(anoMesFaturamento));
					}catch(ErroRepositorioException e){
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", e);
					}
					if(medicaoHistorico != null && medicaoHistorico.getNumeroConsumoMes() != null){
						// consumo agua medido do imovel vinculado
						consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaMedido(medicaoHistorico.getNumeroConsumoMes()
										.toString());
					}else{
						consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaMedido("");
					}
					// consumo agua faturado do imovel vinculado
					if(consumoHistorico != null){
						if(consumoHistorico.getNumeroConsumoFaturadoMes() != null){
							consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaFaturado(consumoHistorico
											.getNumeroConsumoFaturadoMes().toString());
						}else{
							consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaFaturado("");
						}
						// consumo rateio do imovel vinculado
						if(consumoHistorico.getConsumoRateio() != null){
							consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio(consumoHistorico.getConsumoRateio().toString());
						}else{
							consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio("");
						}
					}else{
						consultarHistoricoMedicaoIndividualizadaHelper.setConsumoAguaFaturado("");
						// consumo rateio do imovel vinculado
						consultarHistoricoMedicaoIndividualizadaHelper.setConsumoRateio("");
					}

					ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

					// consultar consumo Historico imovel vinculado Ligacao
					// Esgoto
					consumoHistorico = this.obterConsumoHistoricoCompleto(imovelVinculado, ligacaoTipo, Integer.valueOf(anoMesFaturamento)
									.intValue());

					// consumo esgoto do imovel vinculado
					if(consumoHistorico != null && consumoHistorico.getNumeroConsumoFaturadoMes() != null){
						if(consumoHistorico.getNumeroConsumoFaturadoMes() != null){
							consultarHistoricoMedicaoIndividualizadaHelper.setConsumoEsgoto(consumoHistorico.getNumeroConsumoFaturadoMes()
											.toString());
						}else{
							consultarHistoricoMedicaoIndividualizadaHelper.setConsumoEsgoto("");
						}
					}else{
						consultarHistoricoMedicaoIndividualizadaHelper.setConsumoEsgoto("");
					}

					// adicionando dados do imovel vinculado
					colecaoHistoricosMedicaoIndividualizada.add(consultarHistoricoMedicaoIndividualizadaHelper);
				}
			}
		}

		return colecaoHistoricosMedicaoIndividualizada;
	}

	/**
	 * Consultar Matriculas dos Imoveis Vinculados do Imovel condominio Auhtor:
	 * Rafael Santos Data: 23/01/2006 [UC0179] Consultar Historico Medição
	 * Indiviualizada
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarConsumoHistoricoImoveisVinculados(ConsumoHistorico consumoHistorico) throws ControladorException{

		try{
			return repositorioMicromedicao.consultarConsumoHistoricoImoveisVinculados(consumoHistorico);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Consultar Matriculas dos Imoveis Vinculados do Imovel condominio Auhtor:
	 * Rafael Santos Data: 23/01/2006 [UC0179] Consultar Historico Medição
	 * Indiviualizada
	 * 
	 * @param imovel
	 *            Imovel
	 * @param ligcaoTipo
	 *            Tipo de Ligacação
	 * @param anoMesFaturamento
	 *            Ano Mes Faturamento
	 * @exception ControladorException
	 * @return Consumo Historico do Imovel
	 */
	public ConsumoHistorico obterConsumoHistoricoMedicaoIndividualizada(Imovel imovel, LigacaoTipo ligacaoTipo, int anoMesReferencia)
					throws ControladorException{

		ConsumoHistorico consumoHistorico = null;

		Object[] colecaoConsumoHistoricoArray = null;

		try{
			colecaoConsumoHistoricoArray = repositorioMicromedicao.obterConsumoHistoricoMedicaoIndividualizada(imovel, ligacaoTipo,
							anoMesReferencia);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoConsumoHistoricoArray != null && !(colecaoConsumoHistoricoArray.length < 0)){

			consumoHistorico = new ConsumoHistorico();

			// Seta o id do histórico
			if(colecaoConsumoHistoricoArray[0] != null){
				consumoHistorico.setId((Integer) colecaoConsumoHistoricoArray[0]);
			}
			// Seta Consumo Rateio
			if(colecaoConsumoHistoricoArray[1] != null){
				consumoHistorico.setConsumoRateio((Integer) colecaoConsumoHistoricoArray[1]);
			}
			// Seta o Numero Consumo Faturado Mes
			if(colecaoConsumoHistoricoArray[2] != null){
				consumoHistorico.setNumeroConsumoFaturadoMes((Integer) colecaoConsumoHistoricoArray[2]);
			}

			// Seta o Consumo Tipo
			if(colecaoConsumoHistoricoArray[3] != null){

				ConsumoTipo consumoTipo = new ConsumoTipo();
				consumoTipo.setId((Integer) colecaoConsumoHistoricoArray[3]);
				consumoHistorico.setConsumoTipo(consumoTipo);
			}

			// Seta o Indicador Faturamento
			if(colecaoConsumoHistoricoArray[4] != null){
				consumoHistorico.setIndicadorFaturamento((Short) colecaoConsumoHistoricoArray[4]);
			}

			// Seta o id co Consumo Anormalidade
			if(colecaoConsumoHistoricoArray[5] != null){
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				consumoAnormalidade.setId((Integer) colecaoConsumoHistoricoArray[5]);

				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
			}

		}

		return consumoHistorico;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento Author: Rafael Santos
	 * Data:03/02/2006 Consultar Medicao Historico do Tipo Agua
	 * 
	 * @param imovel
	 *            Id do Imovel Imovel
	 * @param anoMes
	 *            Ano Mes
	 * @return Medicao Historico
	 * @exception ControladorException
	 */
	public MedicaoHistorico pesquisarMedicaoHistoricoTipoAgua(Integer imovel, Integer anoMes) throws ControladorException{

		MedicaoHistorico retorno = null;

		// Pesquisa o histórico de medicao
		try{
			retorno = repositorioMicromedicao.pesquisarMedicaoHistoricoTipoAgua(imovel, anoMes);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * [UC0113] Faturar Grupo de Faturamento Author: Rafael Santos
	 * Data:03/02/2006 Consultar Medicao Historico do Tipo Poço
	 * 
	 * @param imovel
	 *            Id do Imovel Imovel
	 * @param anoMes
	 *            Ano Mes
	 * @return Medicao Historico
	 * @exception ControladorException
	 */
	public MedicaoHistorico pesquisarMedicaoHistoricoTipoPoco(Integer imovel, Integer anoMes) throws ControladorException{

		MedicaoHistorico retorno = null;

		// Pesquisa o histórico de medicao
		try{
			retorno = repositorioMicromedicao.pesquisarMedicaoHistoricoTipoPoco(imovel, anoMes);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		return retorno;
	}

	/**
	 * Consultar Consumo Historico da Medicao Individualizada [UC0113] Faturar
	 * Grupo Faturamento Auhtor: Rafael Santos Data: 20/02/2006
	 * 
	 * @param idImovel
	 * @param idAnormalidade
	 * @param anoMes
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ConsumoHistorico obterConsumoHistoricoAnormalidade(Integer idImovel, Integer idAnormalidade, int anoMes)
					throws ControladorException{

		ConsumoHistorico consumoHistorico = null;

		Object[] colecaoConsumoHistoricoArray = null;

		try{
			colecaoConsumoHistoricoArray = repositorioMicromedicao.obterConsumoHistoricoAnormalidade(idImovel, idAnormalidade, anoMes);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if(colecaoConsumoHistoricoArray != null && !(colecaoConsumoHistoricoArray.length < 0)){

			consumoHistorico = new ConsumoHistorico();

			// Seta o id do histórico
			if(colecaoConsumoHistoricoArray[0] != null){
				consumoHistorico.setId((Integer) colecaoConsumoHistoricoArray[0]);
			}

		}

		return consumoHistorico;
	}

	public void atualizarMedicaoHistorico(MedicaoHistorico medicaoHistorico) throws ControladorException{

		try{

			FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();
			filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.ID, medicaoHistorico.getId()));

			// Procura a medição historico na base
			MedicaoHistorico medicaoHistoricoNaBase = (MedicaoHistorico) ((List) (repositorioUtil.pesquisar(filtroMedicaoHistorico,
							MedicaoHistorico.class.getName()))).get(0);

			// Verificar se a medição historico já foi atualizado por outro
			// usuário
			// durante
			// esta atualização
			if(medicaoHistoricoNaBase.getUltimaAlteracao().after(medicaoHistorico.getUltimaAlteracao())){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

			// Atualiza a data de última alteração
			medicaoHistorico.setUltimaAlteracao(new Date());

			// Atualiza a medição histórico
			repositorioUtil.atualizar(medicaoHistorico);

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Consultar Imoveis com Medição Indiviualizada Auhtor: Sávio Luiz Data:
	 * 06/02/2006 [UC0180] Consultar Imoveis com Medição Indiviualizada
	 * 
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public String pesquisarDescricaoRateioTipoLigacaoAgua(Integer idImovel) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarDescricaoRateioTipoLigacaoAgua(idImovel);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Consultar Imoveis com Medição Indiviualizada Auhtor: Sávio Luiz Data:
	 * 06/02/2006 [UC0180] Consultar Imoveis com Medição Indiviualizada
	 * 
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public String pesquisarDescricaoRateioTipoLigacaoEsgoto(Integer idImovel) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarDescricaoRateioTipoLigacaoEsgoto(idImovel);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0038] Inserir Rota e [UC0039]Manter Rota Validar Inserir Rota e
	 * Alterar Rota
	 * 
	 * @author Vivianne Sousa
	 * @date 24/03/2006
	 * @param idLeiturista
	 *            TODO
	 * @param collectionRotaAcaoCriterio
	 *            return void
	 * @param idLocalidade
	 *            ,
	 * @param idSetorComercial
	 *            ,
	 * @param codigoRota
	 *            ,
	 * @param idCobrancaGrupo
	 *            ,
	 * @param idFaturamentoGrupo
	 *            ,
	 * @param idLeituraTipo
	 *            ,
	 * @param idEmpresaLeituristica
	 *            ,
	 * @param dataAjusteLeitura
	 *            ,
	 * @param indicadorAjusteConsumo
	 *            ,
	 * @param indicadorFiscalizarCortado
	 *            ,
	 * @param indicadorFiscalizarSuprimido
	 *            ,
	 * @param indicadorGerarFalsaFaixa
	 *            ,
	 * @param percentualGeracaoFaixaFalsa
	 *            ,
	 * @param indicadorGerarFiscalizacao
	 *            ,
	 * @param percentualGeracaoFiscalizacao
	 *            ,
	 * @param indicadorUso
	 *            ,
	 * @param acao
	 *            ,
	 * @throws ControladorException
	 */
	public void validacaoFinalRota(String idLocalidade, String idSetorComercial, String codigoRota, String idCobrancaGrupo,
					String idFaturamentoGrupo, String idLeituraTipo, String idEmpresaLeituristica, String indicadorFiscalizarCortado,
					String indicadorFiscalizarSuprimido, String indicadorGerarFalsaFaixa, String percentualGeracaoFaixaFalsa,
					String indicadorGerarFiscalizacao, String percentualGeracaoFiscalizacao, String indicadorUso, String idLeiturista,
					String acao, Collection collectionRotaAcaoCriterio, boolean criticar) throws ControladorException{

		// Localidade é obrigatório.
		if((idLocalidade == null) || (idLocalidade.equals(""))){
			throw new ControladorException("atencao.localidade_nao_informada");
		}
		// Setor Comercial é obrigatório.
		if((idSetorComercial == null) || (idSetorComercial.equals(""))){
			throw new ControladorException("atencao.codigo_setor_comercial_nao_informado");
		}

		// O código da rota é obrigatório.
		if((codigoRota == null) || (codigoRota.equals(""))){
			throw new ControladorException("atencao.rota_codigo_nao_informado");
		}else if(acao.equalsIgnoreCase("INSERIR")){
			FiltroRota filtroRota = new FiltroRota();

			filtroRota.adicionarCaminhoParaCarregamentoEntidade("setorComercial");
			filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.SETOR_COMERCIAL_ID, Integer.valueOf(idSetorComercial)));

			filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.CODIGO_ROTA, Integer.valueOf(codigoRota).intValue()));

			// Retorna caso já exista uma rota com o código informado
			Collection colecaoPesquisa = null;

			colecaoPesquisa = getControladorUtil().pesquisar(filtroRota, Rota.class.getName());

			if(colecaoPesquisa.size() != 0 || !colecaoPesquisa.isEmpty()){
				// Rota já cadastrado p setor informado
				throw new ControladorException("atencao.rota_ja_existente", null, codigoRota, idLocalidade, idSetorComercial);
			}
		}

		// O grupo de faturamento é obrigatório.
		if((idFaturamentoGrupo == null) || (idFaturamentoGrupo.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.faturamento_grupo_nao_informado");
		}

		// O grupo de cobrança é obrigatório.
		if((idCobrancaGrupo == null) || (idCobrancaGrupo.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.cobranca_grupo_nao_informado");
		}

		// O tipo de leitura é obrigatório.
		if((idLeituraTipo == null) || (idLeituraTipo.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.leitura_tipo_nao_informado");
		}

		// A empresa leituristica é obrigatória.
		if((idEmpresaLeituristica == null) || (idEmpresaLeituristica.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.empresa_leituristica_nao_informado");
		}

		// O Leiturista é obrigatório.
		if((idLeiturista == null) || (idLeiturista.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.leiturista_nao_informado");
		}
		// Leiturista deve ser da mesma Empresa Leiturista
		FiltroLeiturista filtroLeiturista = new FiltroLeiturista();
		filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.EMPRESA_ID, Integer.valueOf(idEmpresaLeituristica)));
		filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.ID, Integer.valueOf(idLeiturista)));

		Collection<Leiturista> leituristas = getControladorUtil().pesquisar(filtroLeiturista, Leiturista.class.getName());

		if(criticar && (leituristas == null || leituristas.isEmpty())){
			throw new ControladorException("atencao.leiturista_nao_encontrado");

		}

		// [FS0006] Validar Data do Ajuste de Leitura
		/*
		 * if (dataAjusteLeitura != null && !dataAjusteLeitura.equals("")) {
		 * Integer anoMesAjusteLeitura = Util
		 * .recuperaAnoMesDaData(dataAjusteLeitura); FiltroFaturamentoGrupo
		 * filtroFaturamentoGrupo = new FiltroFaturamentoGrupo();
		 * filtroFaturamentoGrupo.adicionarParametro(new ParametroSimples(
		 * FiltroFaturamentoGrupo.ID, idFaturamentoGrupo));
		 * Collection<FaturamentoGrupo> collectionFaturamentoGrupo =
		 * this.getControladorUtil() .pesquisar(filtroFaturamentoGrupo,
		 * FaturamentoGrupo.class.getName()); FaturamentoGrupo faturamentoGrupo
		 * = (FaturamentoGrupo) collectionFaturamentoGrupo .iterator().next();
		 * // FTGR_AMREFERENCIA da tabela FATURAMENTO_GRUPO Integer
		 * anoMesReferencia = faturamentoGrupo .getAnoMesReferencia(); if
		 * ((!anoMesAjusteLeitura.equals(anoMesReferencia)) &&
		 * (!anoMesAjusteLeitura.equals(Util.somarData(Integer .parseInt("" +
		 * anoMesReferencia))))) { // ano e mês da Data do Ajuste !=
		 * anoMesReferencia // corrente e do ano e mês seguinte throw new
		 * ControladorException(
		 * "atencao.ajuste_leitura_incompativel_ciclo_faturamento"); }
		 * FiltroFaturamentoAtividadeCronograma
		 * filtroFaturamentoAtividadeCronograma = new
		 * FiltroFaturamentoAtividadeCronograma();
		 * filtroFaturamentoAtividadeCronograma
		 * .adicionarCaminhoParaCarregamentoEntidade(
		 * "faturamentoGrupoCronogramaMensal.faturamentoGrupo" );
		 * filtroFaturamentoAtividadeCronograma .adicionarParametro(new
		 * ParametroSimples(
		 * FiltroFaturamentoAtividadeCronograma.
		 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_FATURAMENTO_GRUPO_ID ,
		 * idFaturamentoGrupo)); filtroFaturamentoAtividadeCronograma
		 * .adicionarParametro(new ParametroSimples(
		 * FiltroFaturamentoAtividadeCronograma.
		 * FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL_ANO_MES_REFERENCIA ,
		 * anoMesReferencia)); // FTAT_ID = 2 "Efetuar Leitura"
		 * filtroFaturamentoAtividadeCronograma .adicionarParametro(new
		 * ParametroSimples(
		 * FiltroFaturamentoAtividadeCronograma.FATURAMENTO_ATIVIDADE_ID, 2));
		 * Collection<FaturamentoAtividadeCronograma>
		 * collectionFaturamentoAtividadeCronograma;
		 * collectionFaturamentoAtividadeCronograma = this.getControladorUtil()
		 * .pesquisar(filtroFaturamentoAtividadeCronograma,
		 * FaturamentoAtividadeCronograma.class .getName()); if
		 * (collectionFaturamentoAtividadeCronograma == null ||
		 * collectionFaturamentoAtividadeCronograma .isEmpty()) { throw new
		 * ControladorException(
		 * "atencao.arrecadador_cronograma_grupo_inexistente"); } else {
		 * FaturamentoAtividadeCronograma faturamentoAtividadeCronograma =
		 * (FaturamentoAtividadeCronograma)
		 * collectionFaturamentoAtividadeCronograma .iterator().next(); //
		 * FTAC_TMREALIZACAO da tabela // FATURAMENTO_ATIVIDADE_CRONOGRAMA Date
		 * dataRealizacaoFaturamentoAtividadeCronograma =
		 * faturamentoAtividadeCronograma .getDataRealizacao(); if
		 * (dataRealizacaoFaturamentoAtividadeCronograma == null) { throw new
		 * ControladorException(
		 * "atencao.arrecadador_atividade_grupo_inexistente"); } // data do
		 * ajuste de leitura seja inferior a // data de Leitura do
		 * grupo(FTAC_TMREALIZACAO da tabela //
		 * FATURAMENTO_ATIVIDADE_CRONOGRAMA) Calendar dataAjusteLeituraCalendar
		 * = new GregorianCalendar();
		 * dataAjusteLeituraCalendar.setTime(dataAjusteLeitura); Calendar
		 * dataRealizacaoFaturamentoAtividadeCronogramaCalendar = new
		 * GregorianCalendar();
		 * dataRealizacaoFaturamentoAtividadeCronogramaCalendar
		 * .setTime(dataRealizacaoFaturamentoAtividadeCronograma); if
		 * (dataRealizacaoFaturamentoAtividadeCronogramaCalendar.compareTo(
		 * dataAjusteLeituraCalendar) == 1) { throw new ControladorException(
		 * "atencao.data_ajuste_menorque"); } } }
		 */
		// O identificador de ajusta consumo é obrigatório.
		/*
		 * if ((indicadorAjusteConsumo == null) ||
		 * (indicadorAjusteConsumo.equals("" +
		 * ConstantesSistema.NUMERO_NAO_INFORMADO))) { throw new
		 * ControladorException( "atencao.ajusta_consumo_nao_informado"); }
		 */

		// O identificador de fiscalizar cortado é obrigatório.
		if((indicadorFiscalizarCortado == null) || (indicadorFiscalizarCortado.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.fiscaliza_cortados_nao_informado");
		}

		// O identificador de fiscalizar suprido é obrigatório.
		if((indicadorFiscalizarSuprimido == null) || (indicadorFiscalizarSuprimido.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.fiscaliza_suprimidos_nao_informado");
		}

		// Sistema Parametro vai ser utilizado na validação de
		// Percentual de Faixa Falsa e
		// Percentual de Fiscalização de Leitura
		FiltroSistemaParametro filtroSistemaParametro = new FiltroSistemaParametro();

		Collection<SistemaParametro> collectionSistemaParametro = getControladorUtil().pesquisar(filtroSistemaParametro,
						SistemaParametro.class.getName());
		SistemaParametro sistemaParametro = (SistemaParametro) collectionSistemaParametro.iterator().next();

		// O identificador de gerar faixa falsa é obrigatório.
		if((indicadorGerarFalsaFaixa == null) || (indicadorGerarFalsaFaixa.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.gera_faixa_nao_informado");
		}else if((percentualGeracaoFaixaFalsa == null || percentualGeracaoFaixaFalsa.equalsIgnoreCase(""))
						&& indicadorGerarFalsaFaixa.equals("" + ConstantesSistema.SIM)
						&& sistemaParametro.getIndicadorUsoFaixaFalsa().equals(SistemaParametro.INDICADOR_USO_FAIXA_FALSA_ROTA)){
			// Percentual de Faixa Falsa é obrigatório
			// caso o indicador de geração de fiscalização de leitura seja SIM e
			// o indicador de uso do percentual para geração de fiscalização de
			// leitura
			// na tabela SISTEMA_PARAMETRO
			// (PARM_ICUSOPERCENTUALFISCALIZACAOLEITURA)
			// corresponda ao valor 2=USA PERCENTUAL DA ROTA

			throw new ControladorException("atencao.percentual_faixa_falsa_nao_informado");
		}

		// O identificador de gerar fiscalização é obrigatório.
		if((indicadorGerarFiscalizacao == null) || (indicadorGerarFiscalizacao.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.gera_fiscalizacao_leitura_nao_informado");
		}else if((percentualGeracaoFiscalizacao == null || percentualGeracaoFiscalizacao.equalsIgnoreCase(""))
						&& indicadorGerarFiscalizacao.equals("" + ConstantesSistema.SIM)
						&& sistemaParametro.getIndicadorPercentualFiscalizacaoLeitura().equals(
										SistemaParametro.INDICADOR_PERCENTUAL_FISCALIZACAO_LEITURA_ROTA)){
			// Percentual de Fiscalização de Leitura é obrigatório
			// caso o indicador de geração de faixa falsa seja SIM e
			// o indicador de uso do percentual para geração da faixa falsa
			// na tabela SISTEMA_PARAMETRO (PARM_ICUSOPERCENTUALFAIXAFALSA)
			// corresponda ao valor 2=USA PERCENTUAL DA ROTA
			throw new ControladorException("atencao.percentual_fiscalizacao_leitura_nao_informado");
		}

		// // [FS0010] Verificar inexistência de alguma ação de cobrança
		// if(collectionRotaAcaoCriterio == null){
		// // É necessário informar o critério de cobrança da rota para todas
		// // as ações de cobrança
		// throw new ControladorException("atencao.criterio_cobranca_rota.informar");
		//
		// }else{
		// FiltroCobrancaAcao filtroCobrancaAcao = new FiltroCobrancaAcao();
		//
		// filtroCobrancaAcao.adicionarParametro(new
		// ParametroSimples(FiltroCobrancaAcao.INDICADOR_USO,
		// ConstantesSistema.INDICADOR_USO_ATIVO));
		//
		// Collection<CobrancaGrupo> collectionCobrancaAcao =
		// this.getControladorUtil().pesquisar(filtroCobrancaAcao,
		// CobrancaAcao.class.getName());
		//
		// if(criticar && (collectionRotaAcaoCriterio.size() != collectionCobrancaAcao.size())){
		// // É necessário informar o critério de cobrança da rota para
		// // todas as ações de cobrança
		// throw new ControladorException("atencao.criterio_cobranca_rota.informar");
		// }
		// }

		if(acao.equalsIgnoreCase("ALTERAR")
						&& ((indicadorUso == null) || (indicadorUso.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)))){
			throw new ControladorException("atencao.indicador_uso_nao_informado");
		}

	}

	/**
	 * [UC0039] Manter Rota Altera um objeto do tipo rota no BD
	 * 
	 * @author Vivianne Sousa
	 * @date 06/04/2006
	 * @author eduardo henrique
	 * @date 26/08/2008 Alteração para obrigatoriedade do Leiturista/Agente
	 *       Comercial no cadastro da Rota
	 * @param rota
	 * @param idLocalidade
	 * @param collectionRotaAcaoCriterio
	 * @return void
	 * @throws ControladorException
	 */
	public void atualizarRota(Rota rota, String idLocalidade, Collection collectionRotaAcaoCriterio, Usuario usuarioLogado, boolean criticar)
					throws ControladorException{

		String idRota = "" + rota.getId();

		validacaoFinalRota(idLocalidade, "" + rota.getSetorComercial().getCodigo(), "" + rota.getCodigo(), ""
						+ rota.getCobrancaGrupo().getId(), "" + rota.getFaturamentoGrupo().getId(), "" + rota.getLeituraTipo().getId(), ""
						+ rota.getEmpresa().getId(), "" + rota.getIndicadorFiscalizarCortado(),
						"" + rota.getIndicadorFiscalizarSuprimido(), "" + rota.getIndicadorGerarFalsaFaixa(), ""
										+ rota.getPercentualGeracaoFaixaFalsa(), "" + rota.getIndicadorGerarFiscalizacao(), ""
										+ rota.getPercentualGeracaoFiscalizacao(), "" + rota.getIndicadorUso(), ""
										+ rota.getLeiturista().getId(), "ALTERAR", collectionRotaAcaoCriterio, criticar);

		FiltroRota filtroRota = new FiltroRota();
		// Seta o filtro para buscar a rota na base
		filtroRota.adicionarParametro(new ParametroSimples(FiltroRota.ID_ROTA, idRota));

		// Procura rota na base
		Collection rotaAtualizadas = getControladorUtil().pesquisar(filtroRota, Rota.class.getName());

		Rota rotaAtualizada = (Rota) Util.retonarObjetoDeColecao(rotaAtualizadas);

		if(rotaAtualizada == null){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.registro_remocao_nao_existente");
		}

		// Procura a rota na base
		Rota rotaNaBase = null;
		rotaNaBase = (Rota) ((List) (this.getControladorUtil().pesquisar(filtroRota, Rota.class.getName()))).get(0);

		// Verificar se a rota já foi atualizado por outro usuário
		// durante esta atualização

		if(rotaNaBase.getUltimaAlteracao().after(rota.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// Atualiza a data de última alteração
		rota.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSAÇÃO ROTA----------------------------
		RegistradorOperacao registradorOperacaoRota = new RegistradorOperacao(Operacao.OPERACAO_ROTA_ATUALIZAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacaoRota = new Operacao();
		operacaoRota.setId(Operacao.OPERACAO_ROTA_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuadaRota = new OperacaoEfetuada();
		operacaoEfetuadaRota.setOperacao(operacaoRota);

		rota.setOperacaoEfetuada(operacaoEfetuadaRota);
		rota.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacaoRota.registrarOperacao(rota);
		// ------------ REGISTRAR TRANSAÇÃO ROTA----------------------------
		// Atualiza a rota
		this.getControladorUtil().atualizar(rota);

		// -- codigo para atualizar rotaAcaoCriterio --

		Iterator iterator = collectionRotaAcaoCriterio.iterator();
		FiltroRotaAcaoCriterio filtroRotaAcaoCriterio = new FiltroRotaAcaoCriterio();

		filtroRotaAcaoCriterio.adicionarParametro(new ParametroSimples(FiltroRotaAcaoCriterio.ROTA_ID, rota.getId()));
		Collection colecaoRotaAcaoCriterioBase = getControladorUtil().pesquisar(filtroRotaAcaoCriterio, RotaAcaoCriterio.class.getName());

		while(iterator.hasNext()){

			RotaAcaoCriterio rotaAcaoCriterio = (RotaAcaoCriterio) iterator.next();
			rotaAcaoCriterio.setRota(rota);

			RotaAcaoCriterioPK rotaAcaoCriterioPK = new RotaAcaoCriterioPK();
			rotaAcaoCriterioPK.setCobrancaAcaoId(rotaAcaoCriterio.getCobrancaAcao().getId());
			rotaAcaoCriterioPK.setRotaId(rota.getId());

			rotaAcaoCriterio.setComp_id(rotaAcaoCriterioPK);

			rotaAcaoCriterio.setUltimaAlteracao(new Date());
			// ------------ REGISTRAR TRANSAÇÃO ROTAACAOCRITERIO----------------
			// rotaAcaoCriterio.setOperacaoEfetuada(operacaoEfetuadaRota);
			// rotaAcaoCriterio.adicionarUsuario(Usuario.USUARIO_TESTE,
			// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacaoRota.registrarOperacao(rotaAcaoCriterio);
			// ------------ REGISTRAR TRANSAÇÃO ROTAACAOCRITERIO----------------
			Iterator iteratorRotaAcaoCriterio = colecaoRotaAcaoCriterioBase.iterator();
			boolean atualizar = true;
			if(colecaoRotaAcaoCriterioBase.isEmpty()){
				this.getControladorUtil().inserir(rotaAcaoCriterio);
			}else{
				while(iteratorRotaAcaoCriterio.hasNext()){
					RotaAcaoCriterio rotaAcaoCriterioBase = (RotaAcaoCriterio) iteratorRotaAcaoCriterio.next();
					if(rotaAcaoCriterioBase.getComp_id().equals(rotaAcaoCriterio.getComp_id())){
						this.getControladorUtil().atualizar(rotaAcaoCriterio);
						atualizar = true;
						break;
					}else{
						atualizar = false;
					}
				}
				if(!atualizar){
					this.getControladorUtil().inserir(rotaAcaoCriterio);
				}
			}
		}
		// -- fim de codigo para atualizar rotaAcaoCriterio --

	}

	/**
	 * [UC0038] Inserir Rota Insere um objeto do tipo rota no BD
	 * 
	 * @author Vivianne Sousa
	 * @date 17/04/2006
	 * @param rota
	 * @param idLocalidade
	 * @param collectionRotaAcaoCriterio
	 * @return idRota
	 * @throws ControladorException
	 * @author Andre Nishimura
	 * @date 05/01/2009 Correçao na chamada para metodo validacaoFinalRota:
	 *       estava passando o id de leiturista fixo em null gerando erro de
	 *       nullpointerexception: leiturista é necessario.
	 */
	public Integer inserirRota(Rota rota, String idLocalidade, Collection collectionRotaAcaoCriterio, Usuario usuarioLogado,
					boolean criticar) throws ControladorException{

		validacaoFinalRota(idLocalidade, "" + rota.getSetorComercial().getCodigo(), "" + rota.getCodigo(), ""
						+ rota.getCobrancaGrupo().getId(), "" + rota.getFaturamentoGrupo().getId(), "" + rota.getLeituraTipo().getId(), ""
						+ rota.getEmpresa().getId(), "" + rota.getIndicadorFiscalizarCortado(),
						"" + rota.getIndicadorFiscalizarSuprimido(), "" + rota.getIndicadorGerarFalsaFaixa(), ""
										+ rota.getPercentualGeracaoFaixaFalsa(), "" + rota.getIndicadorGerarFiscalizacao(), ""
										+ rota.getPercentualGeracaoFiscalizacao(), null, "" + rota.getLeiturista().getId(), "INSERIR",
						collectionRotaAcaoCriterio, criticar);

		// ------------ REGISTRAR TRANSAÇÃO ROTA----------------------------
		RegistradorOperacao registradorOperacaoRota = new RegistradorOperacao(Operacao.OPERACAO_ROTA_INSERIR, new UsuarioAcaoUsuarioHelper(
						usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacaoRota = new Operacao();
		operacaoRota.setId(Operacao.OPERACAO_ROTA_INSERIR);

		OperacaoEfetuada operacaoEfetuadaRota = new OperacaoEfetuada();
		operacaoEfetuadaRota.setOperacao(operacaoRota);

		rota.setOperacaoEfetuada(operacaoEfetuadaRota);
		rota.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacaoRota.registrarOperacao(rota);
		// ------------ REGISTRAR TRANSAÇÃO ROTA----------------------------

		// Inserir a rota
		Integer idRota = (Integer) this.getControladorUtil().inserir(rota);

		// -- codigo para inserir rotaAcaoCriterio --
		rota.setId(idRota);
		/*
		 * Iterator iterator = collectionRotaAcaoCriterio.iterator();
		 * while(iterator.hasNext()){
		 * RotaAcaoCriterio rotaAcaoCriterio = (RotaAcaoCriterio) iterator.next();
		 * rotaAcaoCriterio.setRota(rota);
		 * RotaAcaoCriterioPK rotaAcaoCriterioPK = new RotaAcaoCriterioPK();
		 * rotaAcaoCriterioPK.setCobrancaAcaoId(rotaAcaoCriterio.getCobrancaAcao().getId());
		 * rotaAcaoCriterioPK.setRotaId(rota.getId());
		 * rotaAcaoCriterio.setComp_id(rotaAcaoCriterioPK);
		 * rotaAcaoCriterio.setUltimaAlteracao(new Date());
		 * // ------------ REGISTRAR TRANSAÇÃO ROTAACAOCRITERIO----------------
		 * rotaAcaoCriterio.setOperacaoEfetuada(operacaoEfetuadaRota);
		 * rotaAcaoCriterio.adicionarUsuario(usuarioLogado,
		 * UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		 * registradorOperacaoRota.registrarOperacao(rotaAcaoCriterio);
		 * // ------------ REGISTRAR TRANSAÇÃO ROTAACAOCRITERIO----------------
		 * this.getControladorUtil().inserir(rotaAcaoCriterio);
		 * }
		 */
		// -- fim de codigo para inserir rotaAcaoCriterio --
		return idRota;
	}

	/**
	 * Método que efetua o Rateio do consumo para todos os imóveis de uma rota
	 * que sejam imóvel condominio [UC0103] - Efetuar Rateio de Consumo
	 * 
	 * @author Thiago Toscano, Pedro Alexandre, Pedro Alexandre
	 * @date 07/04/2006, 04/08/2006, 29/05/2007
	 * @param rotas
	 * @param anoMesFaturamento
	 * @throws ControladorException
	 */
	public void efetuarRateioDeConsumo(Collection rotas, Integer anoMesFaturamento, int idFuncionalidadeIniciada)
					throws ControladorException{

		int idUnidadeIniciada = 0;
		try{

			// -------------------------
			//
			// Registrar o início do processamento da Unidade de
			// Processamento
			// do Batch
			//
			// -------------------------

			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
							((Rota) Util.retonarObjetoDeColecao(rotas)).getId());

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			Collection imoveisCondominio = null;

			// Caso a empresa seja ADA
			if(sistemaParametro.getParmId().equals(1)){

				/*
				 * Pesquisa todos os imóveis condominio que tenham situação de água
				 * igual a ligado ou cortado ou que tenham situação de esgoto igual
				 * a ligado ou que tenha hidrometro.
				 */
				imoveisCondominio = this.repositorioMicromedicao.getImovelCondominioParaCalculoDoRateioDasRotas(rotas);
			}else if(sistemaParametro.getParmId().equals(2)){

				/*
				 * Caso contrário caso a empresa seja DESO
				 * Obtém os imóveis condominiais ligados de água e/ou
				 * ligados de esgoto que possuam hidrômetro no poço das quadras pertencentes às
				 * rotas da lista
				 * recebida
				 */
				imoveisCondominio = this.repositorioMicromedicao.pesquisarImovelCondominioParaCalculoDoRateioDasRotasLigados(rotas);
			}

			/*
			 * Caso a pesquisa retorne algum imóvel correspondente a condomínio
			 * rateia o consumo para os imoveis vinculados a ele.
			 */
			if(imoveisCondominio != null && !imoveisCondominio.isEmpty()){

				// Cria o iterator para os imóveis condominio encontrados
				Iterator iteratorImoveisCondominio = imoveisCondominio.iterator();

				// Laço para ratear o consumo para os imóveis vinulados aos
				// imóveis condominio
				while(iteratorImoveisCondominio.hasNext()){

					// Recupera os dados do imovl condominio
					Object[] imovelCondominioDados = (Object[]) iteratorImoveisCondominio.next();

					// Seta os dados no imóvel condominio
					Integer idImovelCondominio = (Integer) imovelCondominioDados[0];
					Integer idSituacaoLigacaoAgua = (Integer) imovelCondominioDados[1];
					Integer idSituacaoLigacaoEsgoto = (Integer) imovelCondominioDados[2];
					Short indFatSitLigacaoAgua = (Short) imovelCondominioDados[3];
					Short indFatSitLigacaoEsgoto = (Short) imovelCondominioDados[4];

					LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
					ligacaoAguaSituacao.setId(idSituacaoLigacaoAgua);
					ligacaoAguaSituacao.setIndicadorFaturamentoSituacao(indFatSitLigacaoAgua);

					LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
					ligacaoEsgotoSituacao.setId(idSituacaoLigacaoEsgoto);
					ligacaoEsgotoSituacao.setIndicadorFaturamentoSituacao(indFatSitLigacaoEsgoto);

					Imovel imovelCondominio = new Imovel();
					imovelCondominio.setId(idImovelCondominio);
					imovelCondominio.setLigacaoAguaSituacao(ligacaoAguaSituacao);
					imovelCondominio.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);

					// Cria as variáveis que vai armazenas as quantidades de
					// economia e consumo
					int quantidadeEconomiasAguasMedidas = 0;
					int quantidadeEconomiasAguasNaoMedidas = 0;
					int quantidadeEconomiasEsgotoMedidas = 0;
					int quantidadeEconomiasEsgotoNaoMedidas = 0;
					int consumoMinimoLigacao = 0;
					int consumoAguaImoveisVinculados = 0;
					int consumoEsgotoImoveisVinculados = 0;
					int quantidadeLigacoes = 0;

					/*
					 * Pesquisa os imóveis que estão vinculados ao
					 * imóvel condominio e que tenham a situação de água igual a
					 * ligada ou cortada ou ligação de esgoto igual a ligado e
					 * tenha hidrometro
					 */
					Collection imoveisVinculados = new ArrayList();
					Collection imoveisVinculadosArrayObject = this.repositorioMicromedicao
									.getImovelVinculadosImovelCondominio(idImovelCondominio);
					Rota rotaImovelVinculado = null;
					FaturamentoGrupo faturamentoGrupoImovelVinculado = null;

					if(imoveisVinculadosArrayObject != null && !imoveisVinculadosArrayObject.isEmpty()){
						// Cria o iterator para os imóveis vinculados
						Iterator iteratorImoveisVinculados = imoveisVinculadosArrayObject.iterator();

						// Laço para ratear o consumo do imóvel condominio entre
						// os imoveis vinculados
						while(iteratorImoveisVinculados.hasNext()){

							// Recupera os dados do imóvel vinculado
							Object[] dadosImovelVinculado = (Object[]) iteratorImoveisVinculados.next();
							Integer idImovelVinculado = (Integer) dadosImovelVinculado[0];

							Integer idSituacaoLigacaoAguaImovelVinculado = (Integer) dadosImovelVinculado[2];
							Short indFatSitLigacaoAguaImovelVinculado = (Short) dadosImovelVinculado[8];
							Integer idSituacaoLigacaoEsgotoImovelVinculado = (Integer) dadosImovelVinculado[3];
							Short indFatSitLigacaoEsgotoImovelVinculado = (Short) dadosImovelVinculado[9];
							Integer idMedicaoPoco = (Integer) dadosImovelVinculado[4];
							Integer idConsumoTarifa = (Integer) dadosImovelVinculado[5];

							Integer idHidrometroInstalacaoHistorico;
							HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = null;
							if(dadosImovelVinculado[7] != null){
								idHidrometroInstalacaoHistorico = (Integer) dadosImovelVinculado[7];
								hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
								hidrometroInstalacaoHistorico.setId(idHidrometroInstalacaoHistorico);
							}

							Integer idLigacaoAgua = (Integer) dadosImovelVinculado[6];
							LigacaoAgua ligacaoAgua = new LigacaoAgua();
							ligacaoAgua.setId(idLigacaoAgua);
							ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);

							// Monta imóvel vinculado e seta os dados no objeto
							ConsumoTarifa consumoTarifa = new ConsumoTarifa();
							consumoTarifa.setId(idConsumoTarifa);

							LigacaoAguaSituacao ligacaoAguaSituacaoImovelVinculado = new LigacaoAguaSituacao();
							ligacaoAguaSituacaoImovelVinculado.setId(idSituacaoLigacaoAguaImovelVinculado);
							ligacaoAguaSituacaoImovelVinculado.setIndicadorFaturamentoSituacao(indFatSitLigacaoAguaImovelVinculado);

							LigacaoEsgotoSituacao ligacaoEsgotoSituacaoImovelVinculado = new LigacaoEsgotoSituacao();
							ligacaoEsgotoSituacaoImovelVinculado.setId(idSituacaoLigacaoEsgotoImovelVinculado);
							ligacaoEsgotoSituacaoImovelVinculado.setIndicadorFaturamentoSituacao(indFatSitLigacaoEsgotoImovelVinculado);
							HidrometroInstalacaoHistorico medicaoPoco = new HidrometroInstalacaoHistorico();
							medicaoPoco.setId(idMedicaoPoco);

							Imovel imovelVinculado = new Imovel();
							imovelVinculado.setId(idImovelVinculado);
							imovelVinculado.setLigacaoAgua(ligacaoAgua);
							imovelVinculado.setLigacaoAguaSituacao(ligacaoAguaSituacaoImovelVinculado);
							imovelVinculado.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacaoImovelVinculado);
							imovelVinculado.setHidrometroInstalacaoHistorico(medicaoPoco);
							imovelVinculado.setConsumoTarifa(consumoTarifa);

							rotaImovelVinculado = new Rota();
							faturamentoGrupoImovelVinculado = new FaturamentoGrupo();
							faturamentoGrupoImovelVinculado.setId((Integer) dadosImovelVinculado[10]);
							rotaImovelVinculado.setFaturamentoGrupo(faturamentoGrupoImovelVinculado);
							imovelVinculado.setRota(rotaImovelVinculado);

							imovelVinculado.setLocalidade(new Localidade((Integer) dadosImovelVinculado[11]));

							imovelVinculado.setQuadra(new Quadra((Integer) dadosImovelVinculado[12]));

							// <<Inclui>> [UC0064 – Obter Quantidade de Economias]
							Short quantidadeEconomia = Short.valueOf(String.valueOf(getControladorImovel().obterQuantidadeEconomias(
											imovelVinculado)));
							imovelVinculado.setQuantidadeEconomias(quantidadeEconomia);

							imoveisVinculados.add(imovelVinculado);

							// [UC0105 - Obter Consumo Mínimo da Ligação]
							int consumoMinimoLigacaoImovelVinculado = this.obterConsumoMinimoLigacao(imovelVinculado, null);

							// Caso o imóvel seja ligado de ou cortado
							// de água
							if(imovelVinculado.getLigacaoAguaSituacao() != null
											&& (LigacaoAguaSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado.getLigacaoAguaSituacao()
															.getIndicadorFaturamentoSituacao()))){
								/*
								 * Caso o imóvel seja medido na
								 * ligação de água (hidi_id preenchido na tabela
								 * ligacao_agua com lagu_id=imov_id) acumula a
								 * quantidade de economias do imóvelna
								 * quantidade de economias da água medida. Caso
								 * contrário acumula na quantidade de economias
								 * de água não medidas.
								 */
								if(imovelVinculado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){

									quantidadeEconomiasAguasMedidas = quantidadeEconomiasAguasMedidas + quantidadeEconomia.intValue();
								}else{

									quantidadeEconomiasAguasNaoMedidas = quantidadeEconomiasAguasNaoMedidas + quantidadeEconomia.intValue();
								}

								// Recupera os dados do consumo da ligação de
								// água do imóvel
								Object[] dadosConsumoLigacaoAguaImovel = (Object[]) this.repositorioMicromedicao
												.obterConsumoLigacaoAguaOuEsgotoDoImovel(imovelVinculado.getId(), anoMesFaturamento,
																LigacaoTipo.LIGACAO_AGUA);

								// Obtém o MovimentoRoteiroEmpresa do Imóvel e Ano/Mês Referência da
								// Conta
								FiltroMovimentoRoteiroEmpresa filtroMovimentoRoteiroEmpresa = new FiltroMovimentoRoteiroEmpresa();
								filtroMovimentoRoteiroEmpresa.limparListaParametros();
								filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(
												FiltroMovimentoRoteiroEmpresa.IMOVEL_ID, imovelVinculado.getId()));
								filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(
												FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO, anoMesFaturamento));

								Collection colecaoMovimentoRoteiroEmpresa = getControladorUtil().pesquisar(filtroMovimentoRoteiroEmpresa,
												MovimentoRoteiroEmpresa.class.getName());

								MovimentoRoteiroEmpresa movimentoRoteiroImovel = (MovimentoRoteiroEmpresa) Util
												.retonarObjetoDeColecao(colecaoMovimentoRoteiroEmpresa);

								String indicadorEmissaoCampo = null;

								if(movimentoRoteiroImovel != null){
									indicadorEmissaoCampo = movimentoRoteiroImovel.getIndicadorEmissaoCampo();
								}

								Integer consumoLigacaoAguaImovel = null;

								if(indicadorEmissaoCampo != null
												&& MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA
																.equals(indicadorEmissaoCampo)){
									consumoLigacaoAguaImovel = movimentoRoteiroImovel.getNumeroConsumoMedido();
								}else if(!Util.isVazioOrNulo(dadosConsumoLigacaoAguaImovel) && dadosConsumoLigacaoAguaImovel[1] != null){
									consumoLigacaoAguaImovel = (Integer) dadosConsumoLigacaoAguaImovel[1];
								}

								/*
								 * Acumula o consumo da ligação de
								 * água do imóvel para o mês de faturamento
								 * corrente no consumo de água dos imóveis
								 * vinculados caso exista.
								 */
								if(consumoLigacaoAguaImovel != null){

									// Consumo de Água a Ser Rateado = consumo da ligação de água do
									// imóvel condomínio para o mês de faturamento corrente
									// (CSHI_NNCONSUMOFATURADOMES na tabela CONSUMO_HISTORICO) –
									// consumo
									// de água dos imóveis vinculados. O consumo de água dos
									// imóveis vinculados devem considerar o maior entre o consumo
									// mínimo da ligação do imóvel
									// vinculado <<Inclui>> [UC0105 – Obter Consumo Mínimo da
									// Ligação] e
									// consumo faturado do consumo vinculado
									// (CSHI_NNCONSUMOFATURADOMES
									// na tabela CONSUMO_HISTORICO)

									if(consumoMinimoLigacaoImovelVinculado > consumoLigacaoAguaImovel.intValue()){

										consumoAguaImoveisVinculados = consumoAguaImoveisVinculados + consumoMinimoLigacaoImovelVinculado;

									}else{

										consumoAguaImoveisVinculados = consumoAguaImoveisVinculados + consumoLigacaoAguaImovel.intValue();

									}

								}

							}

							// Caso o imóvel seja ligado de esgoto
							if(imovelVinculado.getLigacaoEsgotoSituacao() != null
											&& LigacaoEsgotoSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado.getLigacaoEsgotoSituacao()
															.getIndicadorFaturamentoSituacao())){

								/*
								 * Caso seja medido de poço(hidi_id
								 * prenchido na tabela imovel), acumula a
								 * quantidade de economias do imóvel na
								 * quantidade de economias de esgoto medidas.
								 * Caso contrário acumula na quantidade de
								 * economias de esgoto não medidas.
								 */
								if(imovelVinculado.getHidrometroInstalacaoHistorico() != null){

									quantidadeEconomiasEsgotoMedidas = quantidadeEconomiasEsgotoMedidas + quantidadeEconomia.intValue();
								}else{

									quantidadeEconomiasEsgotoNaoMedidas = quantidadeEconomiasEsgotoNaoMedidas
													+ quantidadeEconomia.intValue();
								}

								// Recupera os dados do consumo da ligação de
								// esgoto do imóvel
								Object[] dadosConsumoLigacaoEsgotoImovel = (Object[]) this.repositorioMicromedicao
												.obterConsumoLigacaoAguaOuEsgotoDoImovel(imovelVinculado.getId(), anoMesFaturamento,
																LigacaoTipo.LIGACAO_ESGOTO);

								Integer consumoLigacaoEsgotoImovel = null;
								if(!Util.isVazioOrNulo(dadosConsumoLigacaoEsgotoImovel) && dadosConsumoLigacaoEsgotoImovel[1] != null){

									consumoLigacaoEsgotoImovel = (Integer) dadosConsumoLigacaoEsgotoImovel[1];
								}

								/*
								 * Acumula o consumo da ligação de
								 * esgoto do imóvel para o mês de faturamento
								 * corrente no consumo de esgoto dos imóveis
								 * vinculados caso exista.
								 */
								if(consumoLigacaoEsgotoImovel != null){

									consumoEsgotoImoveisVinculados = consumoEsgotoImoveisVinculados + consumoLigacaoEsgotoImovel.intValue();
								}
							}

							// Acumula o consumo mínimo da ligação na
							// soma dos consumos mínimos
							consumoMinimoLigacao = consumoMinimoLigacao + consumoMinimoLigacaoImovelVinculado;
							quantidadeLigacoes += 1;

						}// while dos imóveis vinculados

						/*
						 * Caso o imóvel condominio seja ligado de
						 * água (last_id da tabela imóvel, com o valor
						 * correspondente a ligado de água).
						 */

						// Alteração conforme OC0857313
						// .......................................................
						if(imovelCondominio.getLigacaoAguaSituacao() != null
										&& imovelCondominio.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao() != null
										&& imovelCondominio.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(
														LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

							// [SF0001] - Determinar Rateio de Agua
							determinarRateioAgua(imoveisVinculados, imovelCondominio, anoMesFaturamento, consumoAguaImoveisVinculados,
											consumoMinimoLigacao, sistemaParametro, quantidadeEconomiasAguasNaoMedidas,
											quantidadeEconomiasAguasMedidas, quantidadeLigacoes);
						}

						// OC777805: Trecho comentado pois não estava implementado de acordo com as
						// regras do caso
						// de uso e no caso de uso também foi atachado esse trecho
						// /*
						// * Caso o imóvel condomínio seja ligado de
						// * esgoto (lest_id da tabela imóvel, com o valor
						// * correspondente a ligado de esgoto).
						// */
						// if(imovelCondominio.getLigacaoEsgotoSituacao() != null
						// &&
						// imovelCondominio.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.LIGADO)){
						//
						// // [SF0002] - Determinar Rateio de Esgoto
						// determinarRateioEsgoto(imoveisVinculados, imovelCondominio,
						// anoMesFaturamento, consumoEsgotoImoveisVinculados,
						// consumoMinimoLigacao, sistemaParametro,
						// quantidadeEconomiasEsgotoNaoMedidas,
						// quantidadeEconomiasEsgotoMedidas, quantidadeLigacoes);
						// }
					}
				}// laço do for de imoveis condominio
			}

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}

	}

	/**
	 * [UC0103] - Efetuar Rateio de Consumo Determina o rateio de água entre os
	 * imóveis vinculados ao imóvel condominio. [SF0001] - Determinar Rateio de
	 * Agua
	 * 
	 * @author Thiago Toscano, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 07/04/2006, 04/08/2006, 14/12/2006, 17/01/2007
	 * @param imoveisVinculados
	 * @param imovelCondominio
	 * @param anoMesFaturamento
	 * @param consumoAguaImoveisVinculados
	 * @param consumoMinimoLigacao
	 * @param sistemaParametro
	 * @param quantidadeEconomiasAguasNaoMedidas
	 * @param quantidadeEconomiasAguasMedidas
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioAgua(Collection<Imovel> imoveisVinculados, Imovel imovelCondominio, Integer anoMesFaturamento,
					int consumoAguaImoveisVinculados, int consumoMinimoLigacao, SistemaParametro sistemaParametro,
					int quantidadeEconomiasAguasNaoMedidas, int quantidadeEconomiasAguasMedidas, int quantidadeLigacoes)
					throws ErroRepositorioException, ControladorException{

		// Recupera os dados do consumo da ligação de água do imóvel condominio
		Object[] dadosConsumoLigacaoAguaImovelCondominio = (Object[]) this.repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovel(
						imovelCondominio.getId(), anoMesFaturamento, LigacaoTipo.LIGACAO_AGUA);

		Integer idConsumoHistoricoLigacaoAguaImovelCondominio = null;
		Integer consumoLigacaoAguaImovelCondominio = null;

		if(dadosConsumoLigacaoAguaImovelCondominio != null){

			if(dadosConsumoLigacaoAguaImovelCondominio[0] != null){

				idConsumoHistoricoLigacaoAguaImovelCondominio = (Integer) dadosConsumoLigacaoAguaImovelCondominio[0];
			}

			if(dadosConsumoLigacaoAguaImovelCondominio[1] != null){

				consumoLigacaoAguaImovelCondominio = (Integer) dadosConsumoLigacaoAguaImovelCondominio[1];
			}
		}

		if(!Util.isVazioOrNulo(dadosConsumoLigacaoAguaImovelCondominio)){

			/*
			 * Consumo de Água a Ser Rateado = consumo da ligação de água do imóvel condomínio para
			 * o
			 * mês de faturamento corrente – consumo de água dos imóveis vinculados
			 */
			int consumoAguaSerRateado = 0;
			if(consumoLigacaoAguaImovelCondominio != null){

				consumoAguaSerRateado = consumoLigacaoAguaImovelCondominio - consumoAguaImoveisVinculados;
			}

			/*
			 * Caso o consumo de água a ser rateado seja superior a zero e o consumo
			 * da ligação de água do imóvel condomínio para o mês de faturamento
			 * corrente não seja superior a soma dos consumos mínimos calculados
			 * atribuir o valor zero ao Consumo de Água a Ser Rateado.
			 */
			if(consumoAguaSerRateado > 0 && consumoLigacaoAguaImovelCondominio != null
							&& !(consumoLigacaoAguaImovelCondominio > consumoMinimoLigacao)){

				consumoAguaSerRateado = 0;
			}

			/*
			 * Caso o valor do consumo de água a ser rateado não seja
			 * superior a consumo da ligação de água do imóvel condominio *
			 * percentual de tolerância para rateio do consumo, atribuir o valor zero ao Consumo de
			 * Água
			 * a Ser Rateado.
			 */
			if(consumoLigacaoAguaImovelCondominio != null){

				if(!(consumoAguaSerRateado > ((consumoLigacaoAguaImovelCondominio.doubleValue() * sistemaParametro
								.getPercentualToleranciaRateio().doubleValue()) / 100))){

					consumoAguaSerRateado = 0;
				}
			}

			// Obter tipo de rateio do imóvel condomínio
			RateioTipo rateioTipoImovelCondominio = repositorioMicromedicao.obterTipoRateioImovelPorTipoMedicao(imovelCondominio.getId(),
							MedicaoTipo.LIGACAO_AGUA);

			// Caso o tipo de rateio seja “rateio por imóvel”
			if(rateioTipoImovelCondominio.getId().equals(RateioTipo.RATEIO_POR_IMOVEL)){

				// [SB0008] - Determinar Rateio de Água por Imóvel
				determinarRateioAguaPorImovel(imoveisVinculados, imovelCondominio, anoMesFaturamento, consumoAguaImoveisVinculados,
								quantidadeLigacoes, idConsumoHistoricoLigacaoAguaImovelCondominio, consumoLigacaoAguaImovelCondominio,
								consumoAguaSerRateado);
			}
		}

		// OC777805: Trecho comentado pois não estava implementado de acordo com as regras do caso
		// de uso e no caso de uso também foi atachado esse trecho
		// /*
		// * Caso a quantidade de economias de água não medidas seja diferente de
		// * zero, o rateio incidirá apenas entre os não medidos. Caso contrário e
		// * caso a quantidade de economias de água medidas seja diferente de zero
		// * determinar rateio de água para medido.
		// */
		// if(quantidadeEconomiasAguasNaoMedidas != 0){
		//
		// // [SF0003] - Determinar Rateio de Água para Não Medido
		// determinarRateioAguaNaoMedido(imoveisVinculados, anoMesFaturamento,
		// quantidadeEconomiasAguasNaoMedidas,
		// idConsumoHistoricoLigacaoAgua, consumoAguaSerRateado, consumoAguaImoveisVinculados);
		//
		// }else if(quantidadeEconomiasAguasMedidas != 0){
		//
		// // [SF0004] - Determinar Rateio de Água para Medido
		// determinarRateioAguaParaMedido(imoveisVinculados, anoMesFaturamento, sistemaParametro,
		// quantidadeEconomiasAguasMedidas,
		// idConsumoHistoricoLigacaoAgua, consumoAguaSerRateado, consumoAguaImoveisVinculados,
		// idPocoImovelCondominio,
		// consumoMinimoLigacao, consumoLigacaoAguaImovelCondominio, imovelCondominio);
		// }
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo
	 * [SB0008] - Determinar Rateio de Água por Imóvel
	 * 
	 * @author Anderson Italo
	 * @date 22/05/2012
	 * @param imoveisVinculados
	 * @param imovelCondominio
	 * @param anoMesFaturamento
	 * @param consumoAguaImoveisVinculados
	 * @param quantidadeLigacoes
	 * @param idConsumoHistoricoLigacaoAguaImovelCondominio
	 * @param consumoLigacaoAguaImovelCondominio
	 * @param consumoAguaSerRateado
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	private void determinarRateioAguaPorImovel(Collection<Imovel> imoveisVinculados, Imovel imovelCondominio, Integer anoMesFaturamento,
					int consumoAguaImoveisVinculados, int quantidadeLigacoes, Integer idConsumoHistoricoLigacaoAguaImovelCondominio,
					Integer consumoLigacaoAguaImovelCondominio, int consumoAguaSerRateado) throws ErroRepositorioException,
					ControladorException{

		/*
		 * O sistema atualiza o consumo de água a ser rateado e o consumo de água dos imóveis
		 * vinculados na tabela CONSUMO_HISTORICO do imóvel condomínio
		 */
		this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(idConsumoHistoricoLigacaoAguaImovelCondominio,
						consumoAguaSerRateado, consumoAguaImoveisVinculados);

		int consumoRateadoPorImovelVinculado = Util.dividirTruncarResultado(consumoAguaSerRateado, quantidadeLigacoes);

		/*
		 * Para cada imóvel vinculado ao imóvel condomínio que seja ligado ou cortado de água, o
		 * sistema atualiza a tabela CONSUMO_HISTORICO
		 */
		ConsumoHistorico consumoHistoricoAguaImovelVinculado = null;
		ConsumoHistorico consumoHistoricoEsgotoImovelVinculado = null;
		MedicaoHistorico medicaoHistoricoAguaImovelVinculado = null;
		MedicaoHistorico medicaoHistoricoEsgotoImovelVinculado = null;
		BigDecimal valorFaturadoConsumoNormalImoveisVinculados = BigDecimal.ZERO;
		BigDecimal valorFaturadoConsumoNormalSomadoRateadoImoveisVinculados = BigDecimal.ZERO;

		for(Imovel imovelVinculado : imoveisVinculados){

			consumoHistoricoAguaImovelVinculado = this.repositorioMicromedicao.obterConsumoHistoricoImovel(imovelVinculado.getId(),
							anoMesFaturamento, LigacaoTipo.LIGACAO_AGUA);

			consumoHistoricoEsgotoImovelVinculado = this.repositorioMicromedicao.obterConsumoHistoricoImovel(imovelVinculado.getId(),
							anoMesFaturamento, LigacaoTipo.LIGACAO_ESGOTO);

			// <<Inclui>>[UC0108 Obter Quantidade de Economias por Categoria]
			Collection<Categoria> colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasCategoria(imovelVinculado);

			if(consumoHistoricoAguaImovelVinculado != null){

				// CSHI_NNCONSUMORATEIO = Consumo de Água a Ser Rateado por imovel
				consumoHistoricoAguaImovelVinculado.setConsumoRateio(consumoRateadoPorImovelVinculado);

				// CSHI_IDCONSUMOIMOVELCONDOMINIO=CSHI_ID do consumo da ligação de água do imóvel
				// condomínio
				consumoHistoricoAguaImovelVinculado.setConsumoImovelCondominio(idConsumoHistoricoLigacaoAguaImovelCondominio);

				// Atualiza o consumo histórico do imóvel vínculado
				getControladorUtil().atualizar(consumoHistoricoAguaImovelVinculado);
			}

			/*
			 * Determinar Valores para Faturamento de Água e/ou Esgoto passando o consumo
			 * normal(faturado).
			 */
			Short indicadorFaturarAgua = ConstantesSistema.NAO;
			Integer numeroConsumoFaturadoAguaMes = 0;
			Integer numeroConsumoFaturadoAguaMesSomadoAoRateado = 0;

			if(consumoHistoricoAguaImovelVinculado != null){

				if((imovelVinculado.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.FATURAMENTO_ATIVO
								.intValue())
								|| (imovelVinculado.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().intValue() == LigacaoAguaSituacao.NAO_FATURAVEL
												.intValue()
												&& consumoHistoricoAguaImovelVinculado.getNumeroConsumoFaturadoMes() != null && consumoHistoricoAguaImovelVinculado
												.getNumeroConsumoFaturadoMes().intValue() > 0)){

					// Indicador de faturamento de água
					indicadorFaturarAgua = ConstantesSistema.SIM;

					/*
					 * Caso exista indicador de Faturamento no Consumo, será assumido o do
					 * ConsumoHistorico.
					 */
					if(consumoHistoricoAguaImovelVinculado.getIndicadorFaturamento() != null){

						indicadorFaturarAgua = consumoHistoricoAguaImovelVinculado.getIndicadorFaturamento();
					}

					// Número do consumo de água faturado mês
					numeroConsumoFaturadoAguaMes = consumoHistoricoAguaImovelVinculado.getNumeroConsumoFaturadoMes();
					numeroConsumoFaturadoAguaMesSomadoAoRateado = numeroConsumoFaturadoAguaMes.intValue()
									+ consumoRateadoPorImovelVinculado;
				}
			}

			Short indicadorFaturarEsgoto = ConstantesSistema.NAO;
			Integer numeroConsumoFaturadoEsgotoMes = 0;
			Integer numeroConsumoFaturadoEsgotoMesSomadoAoRateado = 0;

			if(imovelVinculado.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.LIGADO)
							&& consumoHistoricoEsgotoImovelVinculado != null){

				// Indicador de faturamento de esgoto
				if(consumoHistoricoEsgotoImovelVinculado.getIndicadorFaturamento() != null){

					indicadorFaturarEsgoto = consumoHistoricoEsgotoImovelVinculado.getIndicadorFaturamento();
				}

				// Número do consumo de esgoto faturado mês
				if(consumoHistoricoEsgotoImovelVinculado.getNumeroConsumoFaturadoMes() != null){

					numeroConsumoFaturadoEsgotoMes = consumoHistoricoEsgotoImovelVinculado.getNumeroConsumoFaturadoMes();
					numeroConsumoFaturadoEsgotoMesSomadoAoRateado = numeroConsumoFaturadoEsgotoMes.intValue()
									+ consumoRateadoPorImovelVinculado;
				}
			}

			/* Consumo mínimo da ligação <<Inclui>> [UC0105 – Obter Consumo Mínimo da Ligação] */
			int consumoMinimoLigacaoImovelVinculado = obterConsumoMinimoLigacao(imovelVinculado, colecaoCategoria);

			// Determina a data de leitura atual e anterior do faturamento
			Date dataLeituraAnteriorFaturamento = null;
			Date dataLeituraAtualFaturamento = null;

			Calendar data = new GregorianCalendar();
			data.set(Calendar.YEAR, Integer.parseInt(anoMesFaturamento.toString().substring(0, 4)));
			data.set(Calendar.MONTH, Integer.parseInt(anoMesFaturamento.toString().substring(4, 6)) - 1);
			data.set(Calendar.DATE, 1);
			data.add(Calendar.MONTH, -1);

			String anoMesAnterior = "";
			anoMesAnterior = data.get(Calendar.YEAR) + "";
			if((data.get(Calendar.MONTH) + 1) < 10){

				anoMesAnterior = anoMesAnterior + "0" + (data.get(Calendar.MONTH) + 1);
			}else{

				anoMesAnterior = anoMesAnterior + (data.get(Calendar.MONTH) + 1);
			}

			try{

				// Data de letura anterior faturamento
				dataLeituraAnteriorFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
								imovelVinculado.getRota().getFaturamentoGrupo().getId(), FaturamentoAtividade.EFETUAR_LEITURA, (Integer
												.valueOf(anoMesAnterior)));

			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			try{

				// Data de leitura atual do faturamento
				dataLeituraAtualFaturamento = (Date) repositorioFaturamento.pesquisarFaturamentoAtividadeCronogramaDataRealizacao(
								imovelVinculado.getRota().getFaturamentoGrupo().getId(), FaturamentoAtividade.EFETUAR_LEITURA,
								anoMesFaturamento);

			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			// Verifica se existe medição histórico para o tipo de medição ligação de água
			medicaoHistoricoAguaImovelVinculado = this.pesquisarMedicaoHistoricoTipoAgua(imovelVinculado.getId(), anoMesFaturamento);

			if(medicaoHistoricoAguaImovelVinculado != null){

				// Data de letura anterior faturamento
				if(medicaoHistoricoAguaImovelVinculado.getDataLeituraAnteriorFaturamento() != null){

					dataLeituraAnteriorFaturamento = medicaoHistoricoAguaImovelVinculado.getDataLeituraAnteriorFaturamento();
				}

				// Data de leitura atual faturamento
				if(medicaoHistoricoAguaImovelVinculado.getDataLeituraAtualFaturamento() != null){

					dataLeituraAtualFaturamento = medicaoHistoricoAguaImovelVinculado.getDataLeituraAtualFaturamento();
				}
			}

			BigDecimal percentualEsgoto = BigDecimal.ZERO;
			LigacaoEsgoto ligacaoEsgotoImovelVinculado = getControladorFaturamento().obterLigacaoEsgotoImovel(imovelVinculado.getId());

			// Caso o imóvel seja ligado de esgoto
			if(ligacaoEsgotoImovelVinculado != null && imovelVinculado.getLigacaoEsgotoSituacao() != null
							&& imovelVinculado.getLigacaoEsgotoSituacao().getId().intValue() == LigacaoEsgotoSituacao.LIGADO.intValue()){

				// Obtém medicao histórico tipo poco
				medicaoHistoricoEsgotoImovelVinculado = this.pesquisarMedicaoHistoricoTipoPoco(imovelVinculado.getId(), anoMesFaturamento);

				// Verifica se existe medição histórico para poço
				if(medicaoHistoricoEsgotoImovelVinculado != null){

					// Data de leitura anterior faturamento
					if(medicaoHistoricoEsgotoImovelVinculado.getDataLeituraAnteriorFaturamento() != null){

						dataLeituraAnteriorFaturamento = medicaoHistoricoEsgotoImovelVinculado.getDataLeituraAnteriorFaturamento();
					}

					// Data atual de faturamento
					if(medicaoHistoricoEsgotoImovelVinculado.getDataLeituraAtualFaturamento() != null){

						dataLeituraAtualFaturamento = medicaoHistoricoEsgotoImovelVinculado.getDataLeituraAtualFaturamento();
					}
				}

				// Recupera o percentual de esgoto.
				percentualEsgoto = getControladorFaturamento().obterPercentualLigacaoEsgotoImovel(imovelVinculado.getId());
			}

			if(dataLeituraAnteriorFaturamento == null || dataLeituraAtualFaturamento == null){

				FaturamentoAtivCronRota faturamentoAtivCronRota = new FaturamentoAtivCronRota();
				faturamentoAtivCronRota.setRota(imovelVinculado.getRota());

				Date periodoLeitura[] = getControladorFaturamento()
								.gerarPeriodoLeituraFaturamento(dataLeituraAtualFaturamento, dataLeituraAnteriorFaturamento,
												faturamentoAtivCronRota, Integer.valueOf(anoMesAnterior), anoMesFaturamento);

				dataLeituraAnteriorFaturamento = periodoLeitura[0];
				dataLeituraAtualFaturamento = periodoLeitura[1];
			}

			/*
			 * O sistema calcula os valores de água e/ou esgoto <<Inclui>> [UC0120 – Calcular
			 * Valores de Água e/ou Esgoto]
			 */
			Collection<CalcularValoresAguaEsgotoHelper> colecaoCalcularValoresAguaEsgotoHelperConsumoNormal = getControladorFaturamento()
							.calcularValoresAguaEsgoto(anoMesFaturamento, imovelVinculado.getLigacaoAguaSituacao().getId(),
											imovelVinculado.getLigacaoEsgotoSituacao().getId(), indicadorFaturarAgua,
											indicadorFaturarEsgoto, colecaoCategoria, numeroConsumoFaturadoAguaMes,
											numeroConsumoFaturadoEsgotoMes, consumoMinimoLigacaoImovelVinculado,
											dataLeituraAnteriorFaturamento, dataLeituraAtualFaturamento, percentualEsgoto,
											imovelVinculado.getConsumoTarifa().getId(), imovelVinculado.getId());

			/*
			 * O sistema calcula o valor total de água e o valor total de esgoto, que é a soma
			 * dos valores de água e de esgoto, por categoria, retornado pelo [UC0120] chamado
			 * no passo 1 e acumula(guardar) a um valor faturado normal total dos micros
			 */
			for(Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelperConsumoNormal.iterator(); iteratorColecaoCalcularValoresAguaEsgotoHelper
							.hasNext();){

				CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
								.next();

				if(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria() != null){

					valorFaturadoConsumoNormalImoveisVinculados = valorFaturadoConsumoNormalImoveisVinculados
									.add(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria());
				}

				if(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria() != null){

					valorFaturadoConsumoNormalImoveisVinculados = valorFaturadoConsumoNormalImoveisVinculados
									.add(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria());
				}
			}

			/*
			 * O sistema calcula os valores de água e/ou esgoto <<Inclui>> [UC0120 – Calcular
			 * Valores de Água e/ou Esgoto]
			 */
			Collection<CalcularValoresAguaEsgotoHelper> colecaoCalcularValoresAguaEsgotoHelperConsumoSomado = getControladorFaturamento()
							.calcularValoresAguaEsgoto(anoMesFaturamento, imovelVinculado.getLigacaoAguaSituacao().getId(),
											imovelVinculado.getLigacaoEsgotoSituacao().getId(), indicadorFaturarAgua,
											indicadorFaturarEsgoto, colecaoCategoria, numeroConsumoFaturadoAguaMesSomadoAoRateado,
											numeroConsumoFaturadoEsgotoMesSomadoAoRateado, consumoMinimoLigacaoImovelVinculado,
											dataLeituraAnteriorFaturamento, dataLeituraAtualFaturamento, percentualEsgoto,
											imovelVinculado.getConsumoTarifa().getId(), imovelVinculado.getId());

			/*
			 * O sistema calcula o valor total de água e o valor total de esgoto, que é a soma
			 * dos valores de água e de esgoto, por categoria, retornado pelo [UC0120] e
			 * acumula(guardar) a um valor faturado normal + rateio total dos micros
			 */
			for(Iterator iteratorColecaoCalcularValoresAguaEsgotoHelper = colecaoCalcularValoresAguaEsgotoHelperConsumoSomado.iterator(); iteratorColecaoCalcularValoresAguaEsgotoHelper
							.hasNext();){

				CalcularValoresAguaEsgotoHelper calcularValoresAguaEsgotoHelper = (CalcularValoresAguaEsgotoHelper) iteratorColecaoCalcularValoresAguaEsgotoHelper
								.next();

				if(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria() != null){

					valorFaturadoConsumoNormalSomadoRateadoImoveisVinculados = valorFaturadoConsumoNormalSomadoRateadoImoveisVinculados
									.add(calcularValoresAguaEsgotoHelper.getValorFaturadoAguaCategoria());
				}

				if(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria() != null){

					valorFaturadoConsumoNormalSomadoRateadoImoveisVinculados = valorFaturadoConsumoNormalSomadoRateadoImoveisVinculados
									.add(calcularValoresAguaEsgotoHelper.getValorFaturadoEsgotoCategoria());
				}
			}
		}

		// Caso o consumo do macro seja maior que o mínimo(somatório) dos micros
		if(consumoLigacaoAguaImovelCondominio.intValue() > consumoAguaImoveisVinculados){

			/*
			 * Obter o valor a ratear, sendo a diferença entre o valor total(normal) dos micros
			 * e o valor total(normal + rateio) dos micros
			 */
			BigDecimal valorParaRatear = valorFaturadoConsumoNormalSomadoRateadoImoveisVinculados
							.subtract(valorFaturadoConsumoNormalImoveisVinculados);

			// Dividir o valor a ratear pela quantidade total de imóveis(micros)
			BigDecimal valorRatearPorImovel = Util.dividirArredondando(valorParaRatear, new BigDecimal(quantidadeLigacoes), 2);

			// Se o valor a ratear por imóvel for maior que 0,10
			if(valorRatearPorImovel.compareTo(new BigDecimal("0.10")) == 1){

				/*
				 * Para cada imóvel, gerar débito a cobrar de rateio para valor rateado obtido e
				 * o tipo de débito(DBTP_ID de DEBITO_TIPO) com valor em [Parâmetro =
				 * P_DEBITO_TIPO_RATEIO] <<Inclui>>[UC0183] Inserir Débito A Cobrar]
				 */
				String parametroDebitoTipoRateio = (String) ParametroMicromedicao.P_DEBITO_TIPO_RATEIO.executar(this, 0);

				DebitoACobrar debitoACobrar = null;
				DebitoTipo debitoTipo = (DebitoTipo) getControladorUtil().pesquisar(Util.obterInteger(parametroDebitoTipoRateio),
								DebitoTipo.class, true);
				CobrancaForma cobrancaForma = new CobrancaForma();
				cobrancaForma.setId(CobrancaForma.COBRANCA_EM_CONTA);

				Collection<OperacaoContabilHelper> collHelper = new ArrayList<OperacaoContabilHelper>();

				for(Imovel imovelParaRatear : imoveisVinculados){

					debitoACobrar = new DebitoACobrar();
					debitoACobrar.setDebitoTipo(debitoTipo);
					debitoACobrar.setValorDebito(valorRatearPorImovel);
					debitoACobrar.setImovel(imovelParaRatear);
					debitoACobrar.setGeracaoDebito(new Date());
					debitoACobrar.setLocalidade(imovelParaRatear.getLocalidade());
					debitoACobrar.setQuadra(imovelParaRatear.getQuadra());
					debitoACobrar.setAnoMesReferenciaDebito(anoMesFaturamento);
					debitoACobrar.setLancamentoItemContabil(debitoTipo.getLancamentoItemContabil());
					debitoACobrar.setFinanciamentoTipo(debitoTipo.getFinanciamentoTipo());
					debitoACobrar.setCobrancaForma(cobrancaForma);
					debitoACobrar.setUltimaAlteracao(new Date());
					debitoACobrar.setAnoMesCobrancaDebito(Util.somaMesAnoMesReferencia(anoMesFaturamento, 1));

					OperacaoContabilHelper helper = new OperacaoContabilHelper();

					Integer idGerarDebitoACobrar = repositorioFaturamento.pesquisarExistenciaRateio(imovelParaRatear.getId(),
									anoMesFaturamento.intValue(), parametroDebitoTipoRateio);

					if(idGerarDebitoACobrar.intValue() == ConstantesSistema.ZERO.intValue()){
						helper.setObjetoOrigem(this.getControladorFaturamento().inserirDebitoACobrarSemRegistrarLancamentoContabil(1,
										debitoACobrar, null, imovelParaRatear, null, null, Usuario.USUARIO_BATCH, false, null, null, null));
						helper.setOperacaoContabil(OperacaoContabil.INCLUIR_DEBITO_A_COBRAR);

						collHelper.add(helper);

					}
				}

				this.getControladorContabil().registrarLancamentoContabil(collHelper);
			}
		}
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo Determina o rateio de do consumo de
	 * água para os medidos [SF0004] - Determinar Rateio de Água para Medido
	 * 
	 * @author Pedro Alexandre,Pedro Alexandre
	 * @date 14/12/2006, 17/01/2007
	 * @param imoveisVinculados
	 * @param anoMesFaturamento
	 * @param sistemaParametro
	 * @param quantidadeEconomiasAguasMedidas
	 * @param idConsumoHistoricoLigacaoAgua
	 * @param consumoAguaSerRateada
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioAguaParaMedido(Collection<Imovel> imoveisVinculados, Integer anoMesFaturamento,
					SistemaParametro sistemaParametro, int quantidadeEconomiasAguasMedidas, Integer idConsumoHistoricoLigacaoAgua,
					int consumoAguaSerRateada, int consumoAguaImoveisVinculados, Integer idPocoImovelCondominio,
					Integer consumoMinimoLigacao, Integer consumoLigacaoAguaImovelCondominio, Imovel imovelCondomio)
					throws ErroRepositorioException, ControladorException{

		// [SF0004] - Determinar Rateio de Água para Medido

		/*
		 * Item 4.1 O consumo de água a ser rateado por economia vai ser igual
		 * ao consumo de água a ser rateado dividido pela quantidade de
		 * economias medidas
		 */
		int consumoAguaSerRateadaPorEconomia = (int) (consumoAguaSerRateada / quantidadeEconomiasAguasMedidas);

		/*
		 * Item 4.2 Caso o consumo de água a ser rateado por economia seja
		 * inferior ao negativo do decremento máximo de consumo por economia. O
		 * consumo de água a ser rateado por economia vai ser igual ao negativo
		 * do decremento máximo de consumo por economia.
		 */
		if(consumoAguaSerRateadaPorEconomia < (sistemaParametro.getDecrementoMaximoConsumoRateio() * -1)){
			consumoAguaSerRateadaPorEconomia = (sistemaParametro.getDecrementoMaximoConsumoRateio() * -1);
		}

		/*
		 * Item 4.3 Caso o consumo de água a ser rateado por economia seja
		 * inferior ao negativo do incremento máximo de consumo por economia. O
		 * consumo de água a ser rateado por economia vai ser igual ao negativo
		 * do incremento máximo de consumo por economia.
		 */
		if(consumoAguaSerRateadaPorEconomia > sistemaParametro.getIncrementoMaximoConsumoRateio()){
			consumoAguaSerRateadaPorEconomia = sistemaParametro.getIncrementoMaximoConsumoRateio();
		}

		// Cria o iterator de imóveis vinculados
		Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados.iterator();

		/*
		 * Item 4.4 Para cada imóvel vincuado ao imóvel condomínio que seja
		 * ligado ou cortado de água atualiza o consumo histórico.
		 */
		while(iteratorImoveisVinculados.hasNext()){
			// Recupera o imóvel vinculado
			Imovel imovelVinculado = iteratorImoveisVinculados.next();

			/*
			 * Caso a situação da ligação de água seja igual a ligado ou cortado
			 * atualiza os dados do consumo histórico do imóvel vinculado.
			 */
			if(imovelVinculado.getLigacaoAguaSituacao() != null
							&& (LigacaoAguaSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado.getLigacaoAguaSituacao()
											.getIndicadorFaturamentoSituacao()))){

				// Recupera o consumo histórico do imóvel vinculado para ser
				// atualizado
				ConsumoHistorico consumoHistorico = this.repositorioMicromedicao.obterConsumoHistoricoImovel(imovelVinculado.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_AGUA);

				if(consumoHistorico != null){
					// Obter quantidade de economias do imóvel condominio
					Short quantidadeEconomiasImovel = imovelVinculado.getQuantidadeEconomias();

					/**
					 * caso a quantidade de economias seja nulo atribuir o valor
					 * zero
					 */
					if(quantidadeEconomiasImovel == null){
						quantidadeEconomiasImovel = 0;
					}

					/*
					 * Item 4.4.1 Calcula o consumo rateio, que vai ser igual ao
					 * consumo de água a ser rateado por economia vezes a quantidade
					 * de economias do imóvel.
					 */
					Integer consumoRateio = Integer.valueOf((int) consumoAguaSerRateadaPorEconomia * quantidadeEconomiasImovel);
					consumoHistorico.setConsumoRateio(consumoRateio);

					/*
					 * Item 4.4.2 Caso o consumo faturado seja inferior ao consumo
					 * rateio assegura que o consumo a ser cobrado não vai ser
					 * negativo.
					 */
					if(consumoHistorico.getNumeroConsumoFaturadoMes() != null
									&& consumoHistorico.getConsumoRateio() != null
									&& consumoHistorico.getNumeroConsumoFaturadoMes().intValue() < (consumoHistorico.getConsumoRateio()
													.intValue() * -1)){

						consumoHistorico.setConsumoRateio(Integer.valueOf(consumoHistorico.getNumeroConsumoFaturadoMes().intValue() * -1));
					}

					/*
					 * Item 4.4.3 Caso o número do consumo faturado do mês seja
					 * diferente de nulo o consumo faturado do mês vai ser igual a
					 * ele mais o consumo de rateio.
					 */
					// Atualiza os dados do consumo histórico
					Integer numeroConsumoFaturadoMesAtual = consumoHistorico.getNumeroConsumoFaturadoMes();
					Integer numeroConsumoFaturadoMes = 0;
					if(numeroConsumoFaturadoMesAtual != null){
						numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual;
					}
					if(consumoHistorico.getConsumoRateio() != null){
						numeroConsumoFaturadoMes = numeroConsumoFaturadoMes + consumoHistorico.getConsumoRateio();
					}

					/*
					 * Caso o imóvel condomínio possua poço e o consumo da ligação
					 * de água do imóvel condomínio para o mês de faturamento
					 * corrente não seja superior a soma dos consumos mínimos
					 * calculados no passo 2.2.5 do fluxo principal.
					 */
					if((idPocoImovelCondominio != null && idPocoImovelCondominio.intValue() != 0)
									&& (consumoLigacaoAguaImovelCondominio != null && (consumoLigacaoAguaImovelCondominio.intValue() < consumoMinimoLigacao
													.intValue()))){
						numeroConsumoFaturadoMes = (consumoLigacaoAguaImovelCondominio / quantidadeEconomiasAguasMedidas)
										* quantidadeEconomiasImovel;
					}

					// Atualiza os dados do consumo histórico
					consumoHistorico.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
					consumoHistorico.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
					// Item 4.4.4
					consumoHistorico.setConsumoImovelCondominio(idConsumoHistoricoLigacaoAgua);
					consumoHistorico.setUltimaAlteracao(new Date());
					this.getControladorUtil().atualizar(consumoHistorico);

					/**
					 * Atualiza o consumo de água a ser rateado e o consumo de água dos
					 * imóveis vínculados do imóvel condomínio.
					 */
					this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(idConsumoHistoricoLigacaoAgua,
									consumoAguaSerRateada, consumoAguaImoveisVinculados);

				}

			}
		}

	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo Determina o rateio de do consumo de
	 * água para os não medidos. [SF0003] - Determinar Rateio de Água para Não
	 * Medido
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 14/12/2006, 17/01/2007
	 * @param imoveisVinculados
	 * @param anoMesFaturamento
	 * @param quantidadeEconomiasAguasNaoMedidas
	 * @param idConsumoHistoricoLigacaoAgua
	 * @param consumoAguaSerRateada
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioAguaNaoMedido(Collection<Imovel> imoveisVinculados, Integer anoMesFaturamento,
					int quantidadeEconomiasAguasNaoMedidas, Integer idConsumoHistoricoLigacaoAgua, int consumoAguaSerRateada,
					int consumoAguaImoveisVinculados) throws ErroRepositorioException, ControladorException{

		/*
		 * O consumo de água a ser rateado por economia vai ser igual ao consumo
		 * de água a ser rateado dividido pela quantidade de economia não
		 * medida.
		 */
		int consumoAguaSerRateadaPorEconomia = (int) (consumoAguaSerRateada / quantidadeEconomiasAguasNaoMedidas);

		/*
		 * Para cada imóvel vinculado ao imóvel condomínio que seja ligado ou
		 * cortado de água.
		 */
		Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados.iterator();

		// Laço para atualizar todos os consumos históricos dos imóveis
		// vinculados ao imóvel condomínio
		while(iteratorImoveisVinculados.hasNext()){

			// Recupera o imóvel vinculado
			Imovel imovelVinculado = iteratorImoveisVinculados.next();

			/*
			 * Caso o imóvel vinculado tenha a situação de água igual a ligado
			 * ou cortado e o imóvel vinculado não tenha ligação de água.
			 */
			if((imovelVinculado.getLigacaoAguaSituacao() != null && (LigacaoAguaSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado
							.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao())))){

				// Recupera o consumo histórico do imóvel vinculado
				ConsumoHistorico consumoHistorico = this.repositorioMicromedicao.obterConsumoHistoricoImovel(imovelVinculado.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_AGUA);

				Integer consumoRateio = null;

				/**
				 * Caso o imóvel não possua hidrômetro na ligação de água o nº
				 * do consumo do rateio é igual a o consumode água a ser rateado
				 * por economia vezes a quantidade de econômias do imóvel. Caso
				 * contrário atribui o valor zero ao nº do consumo do rateio.
				 */
				if(imovelVinculado.getLigacaoAgua().getHidrometroInstalacaoHistorico() == null){
					consumoRateio = Integer.valueOf((int) consumoAguaSerRateadaPorEconomia * imovelVinculado.getQuantidadeEconomias());
				}else{
					consumoRateio = 0;
				}

				consumoHistorico.setConsumoRateio(consumoRateio);

				/*
				 * Caso o consumo faturado (CSHI_NNCONSUMOFATURADOMES) seja
				 * inferior ao consumo rateio (CSHI_NNCONSUMORATEIO * (-1)), o
				 * consumo rateio vai ser igual ao consumo faturado mês vezes
				 * -1(menos um) assegurando, deste modo, queo consumo a ser
				 * cobrado não será um valor negativo.
				 */
				if(consumoHistorico.getNumeroConsumoFaturadoMes() != null
								&& consumoHistorico.getConsumoRateio() != null
								&& consumoHistorico.getNumeroConsumoFaturadoMes().intValue() < (consumoHistorico.getConsumoRateio()
												.intValue() * -1)){

					consumoHistorico.setConsumoRateio(Integer.valueOf(consumoHistorico.getNumeroConsumoFaturadoMes().intValue() * -1));
				}

				Integer numeroConsumoFaturadoMesAtual = consumoHistorico.getNumeroConsumoFaturadoMes();
				Integer numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual + consumoHistorico.getConsumoRateio();

				// Atualiza os dados do consumo histórico
				consumoHistorico.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
				consumoHistorico.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
				consumoHistorico.setConsumoImovelCondominio(idConsumoHistoricoLigacaoAgua);
				consumoHistorico.setUltimaAlteracao(new Date());
				this.getControladorUtil().atualizar(consumoHistorico);
			}
		}

		/**
		 * Atualiza o consumo de água a ser rateado e o consumo de água dos
		 * imóveis vínculados do imóvel condomínio.
		 */
		this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(idConsumoHistoricoLigacaoAgua, consumoAguaSerRateada,
						consumoAguaImoveisVinculados);
	}

	/**
	 * [UC0103] - Efetuar Rateio de Consumo Determina o rateio de esgoto entre
	 * os imóveis vinculados ao imóvel condominio. [SF0002] - Determinar Rateio
	 * de Esgoto
	 * 
	 * @author Thiago Toscano, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 07/04/2006, 04/08/2006, 14/12/2006, 17/01/2007
	 * @param imoveisVinculados
	 * @param imovelCondominio
	 * @param anoMesFaturamento
	 * @param consumoEsgotoImoveisVinculados
	 * @param consumoMinimoLigacao
	 * @param sistemaParametro
	 * @param quantidadeEconomiasEsgotosNaoMedidas
	 * @param quantidadeEconomiasEsgotosMedidas
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioEsgoto(Collection<Imovel> imoveisVinculados, Imovel imovelCondominio, Integer anoMesFaturamento,
					int consumoEsgotoImoveisVinculados, int consumoMinimoLigacao, SistemaParametro sistemaParametro,
					int quantidadeEconomiasEsgotosNaoMedidas, int quantidadeEconomiasEsgotosMedidas, int quantidadeLigacoes)
					throws ErroRepositorioException, ControladorException{

		// Recupera os dados do consumo da ligação de esgoto do imóvel
		// condomínio.
		Object[] dadosConsumoLigacaoEsgotoImovelCondominio = (Object[]) this.repositorioMicromedicao
						.obterConsumoLigacaoAguaOuEsgotoDoImovel(imovelCondominio.getId(), anoMesFaturamento, LigacaoTipo.LIGACAO_ESGOTO);
		Integer idConsumoHistoricoLigacaoEsgoto = (Integer) dadosConsumoLigacaoEsgotoImovelCondominio[0];
		Integer consumoLigacaoEsgotoImovelCondominio = (Integer) dadosConsumoLigacaoEsgotoImovelCondominio[1];

		/*
		 * Item 2.1 Calcula o consumo de esgoto que vai ser rateado que vai ser
		 * o consumo da ligação de esgoto do imóvel condomínio para o mês de
		 * faturamento corrente menos o consumo de esgoto dos imóveis vinculados
		 */
		int consumoEsgotoSerRateada = -consumoEsgotoImoveisVinculados;
		if(consumoLigacaoEsgotoImovelCondominio != null){
			consumoEsgotoSerRateada = consumoEsgotoSerRateada + consumoLigacaoEsgotoImovelCondominio;
		}

		/*
		 * Item 2.2 Caso o consumo de esgoto a ser rateado seja superior a zero
		 * e o consumo da ligação de esgoto do imóvel condomínio para o mês de
		 * faturamento corrente não seja superior a soma dos consumos mínimos
		 * vai para o próximo imóvel,atribuir o valor zero ao consumo de água a
		 * ser rateado.
		 */
		if(consumoEsgotoSerRateada > 0 && consumoLigacaoEsgotoImovelCondominio != null
						&& !(consumoLigacaoEsgotoImovelCondominio > consumoMinimoLigacao)){
			consumoEsgotoSerRateada = 0;
			// return;
		}

		/*
		 * Item 2.3 Caso o valor absoluto do consumo de esgoto a ser rateado não
		 * seja superior a resultado do consumo da ligação de esgoto do imóvel
		 * condomínio vezes o percentual de tolerância para rateio do consumo
		 * vai para o próximo imóvel,atribuir o valor zero ao consumo de água a
		 * ser rateado.
		 */
		if(!(Math.abs(consumoEsgotoSerRateada) > ((consumoEsgotoImoveisVinculados * sistemaParametro.getPercentualToleranciaRateio()
						.doubleValue()) / 100))){
			// return;
			consumoEsgotoSerRateada = 0;
		}

		/*
		 * Item 2.4 Caso a quantidade de economias de esgoto não medidas seja
		 * diferente de zero , o rateio incidirá apenas entre os não medidos.
		 * Caso contrário e caso a quantidade de economias de esgoto medidas
		 * seja diferente de zero determina o rateio de esgoto para medida.
		 */
		if(quantidadeEconomiasEsgotosNaoMedidas != 0){
			// [SF0005] - Determinar Rateio de Esgoto para Não Medido
			determinarRateioEsgotoNaoMedido(imoveisVinculados, anoMesFaturamento, quantidadeEconomiasEsgotosNaoMedidas,
							idConsumoHistoricoLigacaoEsgoto, consumoEsgotoSerRateada, consumoEsgotoImoveisVinculados);

		}else if(quantidadeEconomiasEsgotosMedidas != 0){
			// [SF0006] - Determinar Rateio de Esgoto para Medido
			determinarRateioEsgotoParaMedido(imoveisVinculados, anoMesFaturamento, sistemaParametro, quantidadeEconomiasEsgotosMedidas,
							idConsumoHistoricoLigacaoEsgoto, consumoEsgotoSerRateada, consumoEsgotoImoveisVinculados);
		}
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo Determina o rateio de esgoto para os
	 * imóveis medidos. [SF0006] - Determinar Rateio de Esgoto para Medido
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 14/12/2006, 17/01/2007
	 * @param imoveisVinculados
	 * @param anoMesFaturamento
	 * @param sistemaParametro
	 * @param quantidadeEconomiasEsgotosMedidas
	 * @param idConsumoHistoricoLigacaoEsgoto
	 * @param consumoEsgotoSerRateada
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioEsgotoParaMedido(Collection<Imovel> imoveisVinculados, Integer anoMesFaturamento,
					SistemaParametro sistemaParametro, int quantidadeEconomiasEsgotosMedidas, Integer idConsumoHistoricoLigacaoEsgoto,
					int consumoEsgotoSerRateada, int consumoEsgotoImoveisVinculados) throws ErroRepositorioException, ControladorException{

		/*
		 * Item 6.1 O consumo de esgoto a ser rateado por economia vai ser igual
		 * aso consumo de esgoto a ser rateado dividido pela quantidade de
		 * economias medidas.
		 */
		int consumoEsgotoSerRateadaPorEconomia = (int) (consumoEsgotoSerRateada / quantidadeEconomiasEsgotosMedidas);

		/*
		 * Item 6.2 Caso o consumo de esgoto a ser rateado por economia não seja
		 * superior a zero passa para o próximo imóvel.
		 */
		if(!(consumoEsgotoSerRateadaPorEconomia > 0)){
			// return;
			consumoEsgotoSerRateadaPorEconomia = 0;
		}

		/*
		 * Item 6.3 Caso o consumo de esgoto a ser rateado por economia seja
		 * superior ao incremento máximo de consumo por economia o consumo de
		 * esgoto a ser rateado por economia vai ser igual ao incremento máximo
		 * de consumo por economia.
		 */
		if(consumoEsgotoSerRateadaPorEconomia > sistemaParametro.getIncrementoMaximoConsumoRateio()){
			consumoEsgotoSerRateadaPorEconomia = sistemaParametro.getIncrementoMaximoConsumoRateio();
		}

		// Cria o iterator dos imóveis vinculados ao imóvel condomínio.
		Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados.iterator();

		/*
		 * Item 6.4 Laço para atualizar os dados do consumo históricodos imóveis
		 * vinculados ao imóvel condomínio.
		 */
		while(iteratorImoveisVinculados.hasNext()){
			// Recupera o imóvel vinculado.
			Imovel imovelVinculado = iteratorImoveisVinculados.next();

			/*
			 * Caso a situação da ligação de esgoto seja igual a ligado ou
			 * cortado atualiza os dados do consumo histórico do imóvel
			 * vinculado.
			 */
			if(imovelVinculado.getLigacaoEsgotoSituacao() != null
							&& LigacaoEsgotoSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado.getLigacaoEsgotoSituacao()
											.getIndicadorFaturamentoSituacao())){

				// Recupera o consumo histórico do imóvel.
				ConsumoHistorico consumoHistorico = this.repositorioMicromedicao.obterConsumoHistoricoImovel(imovelVinculado.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_ESGOTO);

				/*
				 * Item 6.4.1 O consumo para rateio vai ser o consumo do esgoto
				 * a ser rateado por economia vezes a quantidade de economias do
				 * imóvel.
				 */
				Integer consumoRateio = Integer
								.valueOf((int) consumoEsgotoSerRateadaPorEconomia * imovelVinculado.getQuantidadeEconomias());
				consumoHistorico.setConsumoRateio(consumoRateio);

				/*
				 * Item 6.4.2 Caso o consumo faturado seja inferior ao consumo
				 * rateio assegura que o consumo a ser cobrado não vai ser
				 * negativo.
				 */
				if(consumoHistorico.getNumeroConsumoFaturadoMes() != null
								&& consumoHistorico.getConsumoRateio() != null
								&& consumoHistorico.getNumeroConsumoFaturadoMes().intValue() < (consumoHistorico.getConsumoRateio()
												.intValue() * -1)){

					consumoHistorico.setConsumoRateio(Integer.valueOf(consumoHistorico.getNumeroConsumoFaturadoMes().intValue() * -1));
				}

				/*
				 * Item 6.4.3 Caso o número do consumo faturado do mês seja
				 * diferente de nulo o consumo faturado do mês vai ser igual a
				 * ele mais o consumo de rateio.
				 */
				int numeroConsumoFaturadoMes = 0;

				Integer numeroConsumoFaturadoMesAtual = consumoHistorico.getNumeroConsumoFaturadoMes();

				if(numeroConsumoFaturadoMesAtual != null){
					numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual;
				}
				if(consumoHistorico.getConsumoRateio() != null){
					numeroConsumoFaturadoMes = numeroConsumoFaturadoMes + consumoHistorico.getConsumoRateio();
				}

				// Atualiza os dados do consumo histórico
				consumoHistorico.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
				consumoHistorico.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
				// Item 6.4.6
				consumoHistorico.setConsumoImovelCondominio(idConsumoHistoricoLigacaoEsgoto);
				consumoHistorico.setUltimaAlteracao(new Date());
				this.getControladorUtil().atualizar(consumoHistorico);
			}
		}

		/**
		 * Atualiza o consumo de esgoto a ser rateado e o consumo de esgoto dos
		 * imóveis vínculados do imóvel condomínio.
		 */
		this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(idConsumoHistoricoLigacaoEsgoto, consumoEsgotoSerRateada,
						consumoEsgotoImoveisVinculados);
	}

	/**
	 * [UC0103] Efetuar Rateio de Consumo Determina o rateio de esgoto para os
	 * imóveis não medidos. [SF0005] - Determinar Rateio de Esgoto para Não
	 * Medido
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 14/12/2006, 17/01/2007
	 * @param imoveisVinculados
	 * @param anoMesFaturamento
	 * @param quantidadeEconomiasEsgotosNaoMedidas
	 * @param idConsumoHistoricoLigacaoEsgoto
	 * @param consumoEsgotoSerRateada
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void determinarRateioEsgotoNaoMedido(Collection<Imovel> imoveisVinculados, Integer anoMesFaturamento,
					int quantidadeEconomiasEsgotosNaoMedidas, Integer idConsumoHistoricoLigacaoEsgoto, int consumoEsgotoSerRateada,
					int consumoEsgotoImoveisVinculados) throws ErroRepositorioException, ControladorException{

		/*
		 * Item 5.1 Consumo de esgoto a ser rateado por economia vai ser igual
		 * ao consumo de esgoto a ser rateado dividido pela quantidade de
		 * economias não medidas.
		 */
		int consumoEsgotoSerRateadaPorEconomia = (int) (consumoEsgotoSerRateada / quantidadeEconomiasEsgotosNaoMedidas);

		/*
		 * Para cada imóvel vinculado ao imóvel condomínio que seja ligado de
		 * esgoto.
		 */
		// Cria o iterator dos imóveis vínculados ao imóvel condomínio.
		Iterator<Imovel> iteratorImoveisVinculados = imoveisVinculados.iterator();

		// Laço para atualizar os consumo histórico dos imóveis
		// vínculados
		while(iteratorImoveisVinculados.hasNext()){
			// Recupera o imóvel vínculado
			Imovel imovelVinculado = iteratorImoveisVinculados.next();

			/*
			 * Caso a situação de esgoto do imóvel seja igual a ligado ou
			 * cortado e o imóvel não tenha hidrometro atualiza os dados do
			 * consumo histórico.
			 */
			if(imovelVinculado.getLigacaoEsgotoSituacao() != null
							&& LigacaoEsgotoSituacao.FATURAMENTO_ATIVO.equals(imovelVinculado.getLigacaoEsgotoSituacao()
											.getIndicadorFaturamentoSituacao())){

				// Recupera o consumo histórico do imóvel.
				ConsumoHistorico consumoHistorico = this.repositorioMicromedicao.obterConsumoHistoricoImovel(imovelVinculado.getId(),
								anoMesFaturamento, LigacaoTipo.LIGACAO_ESGOTO);

				Integer consumoRateio = 0;

				/**
				 * Caso o imóvel não possu hidrômetro no poço o valor do consumo
				 * de rateio vai ser igual ao consumo de esgoto a ser rateado
				 * por economia vezes a quantidade de economias do imóvel. Caso
				 * contrário o valor do rateio de consumo vai ser igual a zero.
				 */
				if(imovelVinculado.getHidrometroInstalacaoHistorico() == null){
					consumoRateio = consumoEsgotoSerRateadaPorEconomia * imovelVinculado.getQuantidadeEconomias();
				}else{
					consumoRateio = 0;
				}
				consumoHistorico.setConsumoRateio(consumoRateio);

				/**
				 * Caso o consumo faturado (CSHI_NNCONSUMOFATURADOMES) seja
				 * inferior ao consumo rateio (CSHI_NNCONSUMORATEIO * (-1)), o
				 * consumo rateio vai ser igual ao consumo faturado mês vezes
				 * -1(menos um) assegurando, deste modo, queo consumo a ser
				 * cobrado não será um valor negativo.
				 */
				if(consumoHistorico.getNumeroConsumoFaturadoMes() != null
								&& consumoHistorico.getConsumoRateio() != null
								&& consumoHistorico.getNumeroConsumoFaturadoMes().intValue() < (consumoHistorico.getConsumoRateio()
												.intValue() * -1)){

					consumoHistorico.setConsumoRateio(Integer.valueOf(consumoHistorico.getNumeroConsumoFaturadoMes().intValue() * -1));
				}

				Integer numeroConsumoFaturadoMesAtual = consumoHistorico.getNumeroConsumoFaturadoMes();
				// Calcula o nº de consumo calculado no mês.
				Integer numeroConsumoFaturadoMes = numeroConsumoFaturadoMesAtual + consumoHistorico.getConsumoRateio();
				// Atualiza os dados do consumo histórico.
				consumoHistorico.setConsumoImovelVinculadosCondominio(numeroConsumoFaturadoMesAtual);
				consumoHistorico.setNumeroConsumoFaturadoMes(numeroConsumoFaturadoMes);
				consumoHistorico.setConsumoImovelCondominio(idConsumoHistoricoLigacaoEsgoto);
				consumoHistorico.setUltimaAlteracao(new Date());
				this.getControladorUtil().atualizar(consumoHistorico);
			}
		}

		/**
		 * Atualiza o consumo de esgoto a ser rateado e o consumo de esgoto dos
		 * imóveis vínculados do imóvel condomínio.
		 */
		this.repositorioMicromedicao.atualizarConsumoHistoricoImovelCondominio(idConsumoHistoricoLigacaoEsgoto, consumoEsgotoSerRateada,
						consumoEsgotoImoveisVinculados);
	}

	/**
	 * [UC0039] Manter Rota Remove um objeto do tipo rota no BD
	 * 
	 * @author Vivianne Sousa
	 * @date 05/05/2006
	 * @param ids
	 * @return void
	 * @throws ControladorException
	 */
	public void removerRota(String[] ids, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ROTA_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		if(!Util.isVazioOrNulo(ids)){
			FiltroRotaAcaoCriterio filtroRotaAcaoCriterio = null;

			Collection<RotaAcaoCriterio> colecaoRotaAcaoCriterio = null;

			for(String rotaId : ids){
				filtroRotaAcaoCriterio = new FiltroRotaAcaoCriterio();
				filtroRotaAcaoCriterio.adicionarParametro(new ParametroSimples(FiltroRotaAcaoCriterio.ROTA_ID, rotaId));

				colecaoRotaAcaoCriterio = this.getControladorUtil().pesquisar(filtroRotaAcaoCriterio, RotaAcaoCriterio.class.getName());

				if(!Util.isVazioOrNulo(colecaoRotaAcaoCriterio)){
					for(RotaAcaoCriterio rotaAcaoCriterio : colecaoRotaAcaoCriterio){
						this.getControladorUtil().remover(rotaAcaoCriterio);
					}
				}
			}

			this.getControladorUtil().remover(ids, Rota.class.getName(), operacaoEfetuada, colecaoUsuarios);
		}
	}

	/**
	 * Filtrar Hidrometro Faz a pesquisa da quantidade que o filtro vai retornar
	 * 
	 * @author Fernanda Paiva
	 * @date
	 * @throws ControladorException
	 */
	public Integer pesquisarNumeroHidrometroFaixaCount(String fixo, String faixaInicial, String faixaFinal) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarNumeroHidrometroFaixaCount(fixo, faixaInicial, faixaFinal);
		}catch(ErroRepositorioException ex){
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Método que retorna o maior código de Rota de um Setor Comercial
	 * 
	 * @author Vivianne Sousa
	 * @date 12/07/2006
	 * @param idSetorComercial
	 * @return
	 * @throws ControladorException
	 */

	public Short pesquisarMaximoCodigoRota(Integer idSetorComercial) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarMaximoCodigoRota(idSetorComercial);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * método que retorna o maior Código de Rota a partir de um Grupo de
	 * Faturamento
	 * 
	 * @author Virgínia Melo
	 * @date 18/02/2009
	 * @param idGrupoFaturamento
	 * @return
	 * @throws ControladorException
	 */
	public Short pesquisarMaximoCodigoRotaGrupoFaturamento(Integer idGrupoFaturamento) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarMaximoCodigoRotaGrupoFaturamento(idGrupoFaturamento);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Método que apresenta os dados do imovel [UC0153] Apresentar dados para
	 * Analise da medição e Consumo
	 * 
	 * @author Sávio Luiz
	 * @date 04/08/2006
	 * @param idImovel
	 * @return Collection
	 */
	public Collection pesquiarImovelExcecoesApresentaDados(Integer idImovel, boolean ligacaoAgua) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquiarImovelExcecoesApresentaDados(idImovel, ligacaoAgua);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Método que apresenta os dados do imovel [UC0153] Apresentar dados para
	 * Analise da medição e Consumo
	 * 
	 * @author Sávio Luiz
	 * @date 04/08/2006
	 * @param idImovel
	 * @return Collection
	 */
	public Collection pesquiarMedicaoConsumoHistoricoExcecoesApresentaDados(FaturamentoGrupo faturamentoGrupo, Integer idImovel,
					boolean ligacaoAgua) throws ControladorException{

		try{
			// SistemaParametro sistemaParametro =
			// repositorioUtil.pesquisarParametrosDoSistema();
			return repositorioMicromedicao.pesquiarMedicaoConsumoHistoricoExcecoesApresentaDados(faturamentoGrupo, idImovel, ligacaoAgua);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Método que apresenta os dados do imovel [UC0153] Apresentar dados para
	 * Analise da medição e Consumo
	 * 
	 * @author Sávio Luiz
	 * @date 04/08/2006
	 * @param idImovel
	 * @return Collection
	 */
	public Collection pesquisarMedicaoConsumoHistoricoExcecoesApresentaDadosConsultarImovel(Integer anoMesReferencia, Integer idImovel,
					boolean ligacaoAgua) throws ControladorException{

		try{
			// SistemaParametro sistemaParametro =
			// repositorioUtil.pesquisarParametrosDoSistema();
			return repositorioMicromedicao.pesquisarMedicaoConsumoHistoricoExcecoesApresentaDadosConsultarImovel(anoMesReferencia,
							idImovel, ligacaoAgua);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Retorna uma coleção com os dados das medicoes para apresentação [UC0153]
	 * Apresentar dados para Analise da medição e Consumo
	 * 
	 * @author eduardo henrique
	 * @date 30/01/2009 Alteração na consulta para inclusão do
	 *       CreditoConsumoAnterior para exibição na consulta de dados de
	 *       Imóvel.
	 */
	public Collection carregarDadosMedicao(Integer idImovel, boolean ligacaoAgua) throws ControladorException{

		Collection resultadoPesquisa = null;
		Collection retorno = null;

		try{
			resultadoPesquisa = repositorioMicromedicao.carregarDadosMedicao(idImovel, ligacaoAgua);

			if(!resultadoPesquisa.isEmpty()){
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				MedicaoHistorico medicaoHistorico = null;
				Object[] objetoMedicao = null;
				LeituraAnormalidade leituraAnormalidadeInformada = null;
				LeituraAnormalidade leituraAnormalidadeFaturada = null;
				LeituraSituacao leituraSituacao = null;

				while(iterator.hasNext()){
					objetoMedicao = (Object[]) iterator.next();
					medicaoHistorico = new MedicaoHistorico();

					medicaoHistorico.setAnoMesReferencia(((Integer) objetoMedicao[0]).intValue());
					medicaoHistorico.setDataLeituraAtualInformada((Date) objetoMedicao[1]);
					medicaoHistorico.setLeituraAtualInformada((Integer) objetoMedicao[2]);
					medicaoHistorico.setDataLeituraAtualFaturamento((Date) objetoMedicao[3]);
					medicaoHistorico.setLeituraAtualFaturamento((Integer) objetoMedicao[4]);

					if(objetoMedicao[11] != null){
						medicaoHistorico.setConsumoCreditoAnterior((Integer) objetoMedicao[11]);
					}

					if(objetoMedicao[12] != null && objetoMedicao[13] != null){
						Funcionario funcionario = new Funcionario();
						funcionario.setId((Integer) objetoMedicao[12]);
						funcionario.setNome((String) objetoMedicao[13]);
						medicaoHistorico.setFuncionario(funcionario);
					}

					// =============================== Leitura Anormalidade
					// Informada
					leituraAnormalidadeInformada = new LeituraAnormalidade();
					leituraAnormalidadeInformada.setId((Integer) objetoMedicao[9]);
					leituraAnormalidadeInformada.setDescricao((String) objetoMedicao[5]);
					medicaoHistorico.setLeituraAnormalidadeInformada(leituraAnormalidadeInformada);
					// =============================== Leitura Anormalidade
					// Informada
					leituraAnormalidadeFaturada = new LeituraAnormalidade();
					leituraAnormalidadeFaturada.setId((Integer) objetoMedicao[10]);
					leituraAnormalidadeFaturada.setDescricao((String) objetoMedicao[6]);
					medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturada);
					// =============================== Leitura Anormalidade
					// Informada
					leituraSituacao = new LeituraSituacao();
					leituraSituacao.setDescricao((String) objetoMedicao[7]);
					medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
					medicaoHistorico.setConsumoMedioHidrometro((Integer) objetoMedicao[8]);

					retorno.add(medicaoHistorico);
				}
			}
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Retorna uma coleção com os dados das medicoes para apresentação [UC0153]
	 * Apresentar dados para Analise da medição e Consumo
	 */
	public Collection carregarDadosMedicaoResumo(Integer idImovel, boolean ligacaoAgua) throws ControladorException{

		Collection resultadoPesquisa = null;
		Collection retorno = null;

		try{
			resultadoPesquisa = repositorioMicromedicao.carregarDadosMedicaoResumo(idImovel, ligacaoAgua);

			if(!resultadoPesquisa.isEmpty()){
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				MedicaoHistorico medicaoHistorico = null;
				Object[] objetoMedicao = null;
				LeituraAnormalidade leituraAnormalidadeInformada = null;
				LeituraAnormalidade leituraAnormalidadeFaturada = null;
				LeituraSituacao leituraSituacao = null;

				while(iterator.hasNext()){
					objetoMedicao = (Object[]) iterator.next();
					medicaoHistorico = new MedicaoHistorico();

					medicaoHistorico.setAnoMesReferencia(((Integer) objetoMedicao[0]).intValue());
					medicaoHistorico.setDataLeituraAtualInformada((Date) objetoMedicao[1]);
					medicaoHistorico.setLeituraAtualInformada((Integer) objetoMedicao[2]);
					medicaoHistorico.setDataLeituraAtualFaturamento((Date) objetoMedicao[3]);
					medicaoHistorico.setLeituraAtualFaturamento((Integer) objetoMedicao[4]);
					// =============================== Leitura Anormalidade
					// Informada
					leituraAnormalidadeInformada = new LeituraAnormalidade();
					leituraAnormalidadeInformada.setId((Integer) objetoMedicao[5]);
					leituraAnormalidadeInformada.setDescricaoAbreviada((String) objetoMedicao[8]);
					medicaoHistorico.setLeituraAnormalidadeInformada(leituraAnormalidadeInformada);
					// =============================== Leitura Anormalidade
					// Informada
					leituraAnormalidadeFaturada = new LeituraAnormalidade();
					leituraAnormalidadeFaturada.setId((Integer) objetoMedicao[6]);
					leituraAnormalidadeFaturada.setDescricaoAbreviada((String) objetoMedicao[9]);
					medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturada);
					// =============================== Leitura Anormalidade
					// Informada
					leituraSituacao = new LeituraSituacao();
					leituraSituacao.setDescricao((String) objetoMedicao[7]);
					medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);

					retorno.add(medicaoHistorico);
				}
			}
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Retorna uma coleção com os dados das medicoes para apresentação [UC0153]
	 * Apresentar dados para Analise da medição e Consumo
	 * 
	 * @author Eduardo Henrique
	 * @date 31/12/2008 Alteração no método para tratar consumos de imóveis que
	 *       não tenham sido medidos, como no caso de estimados.
	 */
	public Collection carregarDadosConsumo(Integer idImovel, int anoMes, boolean ligacaoAgua) throws ControladorException{

		Collection resultadoPesquisa = null;
		Collection retorno = null;

		try{
			resultadoPesquisa = repositorioMicromedicao.carregarDadosConsumo(idImovel, anoMes, ligacaoAgua);

			if(!resultadoPesquisa.isEmpty()){
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				while(iterator.hasNext()){
					Object[] objetoConsumo = (Object[]) iterator.next();

					retorno.add(this.montarHelperDadosMicromedicaoImovel(objetoConsumo, ligacaoAgua));
				}
			}
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Overload do método de CarregarDadosConsumo [UC0153], para carregar todos
	 * os Consumo_Histórico do Imóvel
	 * 
	 * @author eduardo henrique
	 * @date 31/12/2008
	 * @param idImovel
	 *            Id do Imóvel a ser consultado.
	 * @param tipoLigacao
	 *            Id do Tipo da Ligação do Imóvel.
	 */
	public Collection<ImovelMicromedicao> carregarDadosConsumo(Integer idImovel, Integer tipoLigacao) throws ControladorException{

		Collection resultadoPesquisa = null;
		Collection<ImovelMicromedicao> retorno = null;

		try{
			resultadoPesquisa = repositorioMicromedicao.carregarDadosConsumo(idImovel, tipoLigacao);

			if(!resultadoPesquisa.isEmpty()){
				Iterator iterator = resultadoPesquisa.iterator();
				retorno = new ArrayList();

				while(iterator.hasNext()){
					Object[] objetoConsumo = (Object[]) iterator.next();

					boolean ligacaoAgua = true;
					if(tipoLigacao.equals(LigacaoTipo.LIGACAO_ESGOTO)){
						ligacaoAgua = false;
					}

					retorno.add(this.montarHelperDadosMicromedicaoImovel(objetoConsumo, ligacaoAgua));
				}
			}
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * @author eduardo henrique
	 * @date 31/12/2008 Método responsável por montar um helper utilizado no
	 *       [UC0153]
	 */
	private ImovelMicromedicao montarHelperDadosMicromedicaoImovel(Object[] dadosConsumoImovel, boolean ligacaoAgua){

		ConsumoHistorico consumoHistorico = null;
		ConsumoHistorico consumoHistoricoEsgoto = null;
		ConsumoAnormalidade consumoAnormalidade = null;
		ConsumoTipo consumoTipo = null;
		MedicaoHistorico medicaoHistorico = null;
		ImovelMicromedicao imovelMicromedicao = null;

		if(dadosConsumoImovel != null){
			consumoHistorico = new ConsumoHistorico();
			consumoHistoricoEsgoto = new ConsumoHistorico();

			consumoHistorico.setReferenciaFaturamento(((Integer) dadosConsumoImovel[0]).intValue());
			// =============================== Consumo Medido
			medicaoHistorico = new MedicaoHistorico();

			if(dadosConsumoImovel[1] != null){
				medicaoHistorico.setNumeroConsumoMes((Integer) dadosConsumoImovel[1]);
			}

			consumoHistorico.setNumeroConsumoFaturadoMes((Integer) dadosConsumoImovel[2]);

			consumoHistorico.setConsumoRateio((Integer) dadosConsumoImovel[3]);

			// =============================== Anormalidade Consumo
			consumoAnormalidade = new ConsumoAnormalidade();
			consumoAnormalidade.setDescricao((String) dadosConsumoImovel[4]);
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

			// =============================== consumoTipo
			consumoTipo = new ConsumoTipo();
			consumoTipo.setDescricaoAbreviada((String) dadosConsumoImovel[5]);
			// consumoHistorico.setConsumoTipo(consumoTipo);

			// ==================== Dias de Consumo
			int diasConsumo = 0;
			if(dadosConsumoImovel[6] != null && dadosConsumoImovel[7] != null){
				diasConsumo = Util.obterQuantidadeDiasEntreDuasDatas((Date) dadosConsumoImovel[6], (Date) dadosConsumoImovel[7]);
			}
			if(ligacaoAgua){
				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes((Integer) dadosConsumoImovel[15]);
			}

			imovelMicromedicao = new ImovelMicromedicao();

			imovelMicromedicao.setConsumoHistorico(consumoHistorico);
			imovelMicromedicao.setConsumoHistoricoEsgoto(consumoHistoricoEsgoto);
			imovelMicromedicao.setMedicaoHistorico(medicaoHistorico);
			imovelMicromedicao.setQtdDias("" + diasConsumo);

			if(dadosConsumoImovel[9] != null){
				consumoHistorico.setConsumoMedio((Integer) dadosConsumoImovel[9]);
			}
			if(dadosConsumoImovel[10] != null){
				LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
				leituraAnormalidade.setId((Integer) dadosConsumoImovel[10]);

				medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
			}

			if(dadosConsumoImovel[11] != null){
				medicaoHistorico.setNumeroConsumoInformado((Integer) dadosConsumoImovel[11]);
			}
			if(dadosConsumoImovel[12] != null){
				consumoAnormalidade.setDescricaoAbreviada((String) dadosConsumoImovel[12]);
			}

			if(dadosConsumoImovel[13] != null){
				consumoHistorico.setConsumoRateio((Integer) dadosConsumoImovel[13]);
			}

			// Adicionado em 19/12/2008 v0.08 - vsm
			if(dadosConsumoImovel[14] != null){
				consumoHistorico.setConsumoMinimoCreditado((Integer) dadosConsumoImovel[14]);
			}

			if(dadosConsumoImovel[8] != null){
				consumoTipo.setDescricao((String) dadosConsumoImovel[8]);
				consumoHistorico.setConsumoTipo(consumoTipo);
			}

		}
		return imovelMicromedicao;
	}

	/**
	 * Método utilizado para pesquisar os consumo historicos a serem
	 * substituidos pelo caso de uso [UC0106] Substituir Consumos Anteriores
	 */
	public Collection<ImovelMicromedicao> pesquisaConsumoHistoricoSubstituirConsumo(Integer idImovel, Integer anoMesInicial,
					Integer anoMesFinal) throws ControladorException{

		Collection<ImovelMicromedicao> retorno = new ArrayList<ImovelMicromedicao>();

		try{
			Collection<Object[]> objetoResultado = repositorioMicromedicao.pesquisaConsumoHistoricoSubstituirConsumo(idImovel,
							anoMesInicial, anoMesFinal);

			if(!Util.isVazioOrNulo(objetoResultado)){
				ConsumoHistorico consumoHistoricoAgua = null;
				ConsumoHistorico consumoHistoricoEsgoto = null;
				Integer anoMesReferencia = null;

				ImovelMicromedicao imovelMicromedicao = null;

				for(Object[] resultado : objetoResultado){
					consumoHistoricoAgua = (ConsumoHistorico) resultado[0];

					consumoHistoricoEsgoto = (ConsumoHistorico) resultado[1];

					anoMesReferencia = (Integer) resultado[2];

					imovelMicromedicao = new ImovelMicromedicao();
					imovelMicromedicao.setConsumoHistorico(consumoHistoricoAgua);
					imovelMicromedicao.setConsumoHistoricoEsgoto(consumoHistoricoEsgoto);
					imovelMicromedicao.setAnoMesGrupoFaturamento(anoMesReferencia);

					retorno.add(imovelMicromedicao);
				}
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Atualiza o valor de cshi_nnconsumoFaturadomes consumo historico [UC0106]
	 * - Substituir Consumos Anteriores
	 * 
	 * @param consumoHistorico
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void atualizarConsumosAnteriores(ConsumoHistorico consumoHistorico, Usuario usuarioLogado) throws ControladorException{

		try{

			// ********************* Atualização realizada por outro usuário
			// *********************
			// [FS - Verificar a existência da ConsumoHistorico]
			FiltroConsumoHistorico filtroConsumoHistorico = new FiltroConsumoHistorico();
			filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ID, consumoHistorico.getId()));

			Collection<ConsumoHistorico> colecaoConsumoHistorico = getControladorUtil().pesquisar(filtroConsumoHistorico,
							ConsumoHistorico.class.getName());

			if(colecaoConsumoHistorico == null || colecaoConsumoHistorico.isEmpty()){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

			ConsumoHistorico consumoHistoricoBase = (ConsumoHistorico) colecaoConsumoHistorico.iterator().next();

			if(consumoHistoricoBase.getUltimaAlteracao().after(consumoHistorico.getUltimaAlteracao())){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}
			// ************************************************************************************

			consumoHistorico.setIndicadorAlteracaoUltimosConsumos(ConstantesSistema.SIM);
			consumoHistorico.setUltimaAlteracao(new Date());
			// [UC] - Registrar Transação
			// Início - Registrando as transações
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_SUBSTITUIR_CONSUMOS_ANTERIORES,
							consumoHistorico.getId(), consumoHistorico.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado,
											UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_SUBSTITUIR_CONSUMOS_ANTERIORES);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			consumoHistorico.setOperacaoEfetuada(operacaoEfetuada);
			consumoHistorico.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

			registradorOperacao.registrarOperacao(consumoHistorico);
			// Fim - Registrando as transações

			getControladorUtil().atualizar(consumoHistorico);
		}catch(ControladorException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Método que apresenta os dados do imovel [UC0153] Apresentar dados para
	 * Analise da medição e Consumo
	 * 
	 * @author Flávio Cordeiro
	 * @date 04/08/2006
	 * @param idImovel
	 * @return Collection
	 */
	public ImovelMicromedicao pesquiarImovelExcecoesApresentaDadosResumido(Integer idImovel, boolean ligacaoAgua)
					throws ControladorException{

		ImovelMicromedicao imovelMicromedicao = new ImovelMicromedicao();

		try{
			Collection resultado = repositorioMicromedicao.pesquiarImovelExcecoesApresentaDadosResumido(idImovel, ligacaoAgua);

			if(!resultado.isEmpty()){
				HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();

				Object[] objetoResultado = (Object[]) resultado.iterator().next();

				// faturamento grupo(id 0 , anomes 1)
				FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
				if(objetoResultado[0] != null){
					faturamentoGrupo.setId((Integer) objetoResultado[0]);
				}
				if(objetoResultado[1] != null){
					faturamentoGrupo.setAnoMesReferencia((Integer) objetoResultado[1]);
				}
				// Imovel (icCondominio 2)
				Imovel imovel = new Imovel();
				if(objetoResultado[2] != null){
					imovel.setIndicadorImovelCondominio((Short) objetoResultado[2]);
				}
				// Ligacao Agua Situacao (descricao 3)
				LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
				if(objetoResultado[3] != null){
					ligacaoAguaSituacao.setDescricao((String) objetoResultado[3]);
					imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
				}
				// Ligacao Esgoto Situacao (descricao 4)
				LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
				if(objetoResultado[4] != null){
					ligacaoEsgotoSituacao.setDescricao((String) objetoResultado[4]);
					imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
				}
				// Hidrometro (numero 5)
				Hidrometro hidrometro = new Hidrometro();
				if(objetoResultado[5] != null){
					hidrometro.setNumero((String) objetoResultado[5]);
					hidrometroInstalacaoHistorico.setHidrometro(hidrometro);
					imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);
				}
				// Hidrometro Instalacao Historico (data Instalcao 6)
				if(objetoResultado[6] != null){
					hidrometroInstalacaoHistorico.setDataInstalacao((Date) objetoResultado[6]);
				}
				// hidrometro (capacidade 7)
				HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
				if(objetoResultado[7] != null){
					hidrometroCapacidade.setDescricao((String) objetoResultado[7]);
					hidrometro.setHidrometroCapacidade(hidrometroCapacidade);
				}
				// Imovel Perfil (descricao 8)
				ImovelPerfil imovelPerfil = new ImovelPerfil();
				if(objetoResultado[8] != null){
					imovelPerfil.setDescricao((String) objetoResultado[8]);
					imovel.setImovelPerfil(imovelPerfil);
				}
				// Imovel Condominio (id 9)
				Imovel imovelCondominio = new Imovel();
				if(objetoResultado[9] != null){
					imovelCondominio.setId((Integer) objetoResultado[9]);
					imovel.setImovelCondominio(imovelCondominio);
				}
				// Imovel (qtdEconomias 10)
				if(objetoResultado[10] != null){
					imovel.setQuantidadeEconomias((Short) objetoResultado[10]);
				}
				// Imovel (idHidrometroHistorico 11)
				if(objetoResultado[11] != null){
					hidrometroInstalacaoHistorico.setId((Integer) objetoResultado[11]);
				}
				// numeroDigitosLeitura Hidrometro(12)
				if(objetoResultado[12] != null){
					hidrometro.setNumeroDigitosLeitura((Short) objetoResultado[12]);
				}

				// montagem do objeto imovelMicromedicao
				imovelMicromedicao.setImovel(imovel);
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return imovelMicromedicao;
	}

	/**
	 * Retorna um objeto com os dados das medicoes para apresentação Flávio
	 * [UC0153] Apresentar dados para Analise da medição e Consumo
	 */
	public ImovelMicromedicao carregarDadosMedicaoResumido(Integer idImovel, boolean ligacaoAgua, String anoMes)
					throws ControladorException{

		ImovelMicromedicao imovelMicromedicao = new ImovelMicromedicao();

		try{
			Object[] resultado = repositorioMicromedicao.carregarDadosMedicaoResumido(idImovel, ligacaoAgua, anoMes);

			MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
			if(resultado != null){
				// (anoMes 0)
				if(resultado[0] != null){
					medicaoHistorico.setAnoMesReferencia((Integer) resultado[0]);
				}
				// medicao hitorico (dataLeitura atual informada 1)
				if(resultado[1] != null){
					medicaoHistorico.setDataLeituraAtualInformada((Date) resultado[1]);
				}
				// medicao historico (numero leitura atual informada 2)
				if(resultado[2] != null){
					medicaoHistorico.setLeituraAtualInformada((Integer) resultado[2]);
				}
				// medicao historico (numero leitura anterior faturada 3)
				if(resultado[3] != null){
					medicaoHistorico.setDataLeituraAnteriorFaturamento((Date) resultado[3]);
				}
				// medicao historico (numeroLeituraAnteriorFaturada 4)
				if(resultado[4] != null){
					medicaoHistorico.setLeituraAnteriorFaturamento((Integer) resultado[4]);
				}
				// Anormalidade Leitura (descricaoAnormalidadeLeituraInformada
				// 5)
				LeituraAnormalidade leituraAnormalidadeInformada = new LeituraAnormalidade();
				if(resultado[5] != null){
					leituraAnormalidadeInformada.setDescricao((String) resultado[5]);
				}
				// Anormalidade Leitura (descricaoAnormalidadeLeituraInformada
				// 6)
				LeituraAnormalidade leituraAnormalidadeFaturada = new LeituraAnormalidade();
				if(resultado[6] != null){
					leituraAnormalidadeFaturada.setDescricao((String) resultado[6]);
				}
				// medicao historico (numeroVezesConsecutivosAnormalidade 7)
				if(resultado[7] != null){
					medicaoHistorico.setNumeroVezesConsecutivasOcorrenciaAnormalidade((Short) resultado[7]);
				}
				// medicao historico (idFuncionario 8)
				Funcionario funcionario = new Funcionario();
				if(resultado[8] != null){
					funcionario.setId((Integer) resultado[8]);
					medicaoHistorico.setFuncionario(funcionario);
				}
				// medicao historico (leituraSituacao 9)
				LeituraSituacao leituraSituacao = new LeituraSituacao();
				if(resultado[9] != null){
					leituraSituacao.setDescricao((String) resultado[9]);
					medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
				}
				// Data Leitura Anterior Faturada
				if(resultado[10] != null){
					medicaoHistorico.setDataLeituraAtualFaturamento((Date) resultado[10]);
				}
				// numero Leitura Anterior Faturada
				if(resultado[11] != null){
					medicaoHistorico.setLeituraAtualFaturamento((Integer) resultado[11]);
				}
				// Anormalidade Leitura Faturada
				if(resultado[12] != null){
					LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
					leituraAnormalidade.setId((Integer) resultado[12]);
					leituraAnormalidade.setDescricaoAbreviada((String) resultado[17]);
					medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
				}
				// consumo informado
				if(resultado[13] != null){
					medicaoHistorico.setNumeroConsumoInformado((Integer) resultado[13]);
				}
				// consumo informado
				if(resultado[14] != null){
					medicaoHistorico.setConsumoMedioHidrometro((Integer) resultado[14]);
				}
				// Anormalidade Leitura Informada
				if(resultado[15] != null){
					LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
					leituraAnormalidade.setId((Integer) resultado[15]);
					leituraAnormalidade.setDescricaoAbreviada((String) resultado[16]);
					medicaoHistorico.setLeituraAnormalidadeInformada(leituraAnormalidade);
				}
				imovelMicromedicao.setMedicaoHistorico(medicaoHistorico);
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return imovelMicromedicao;
	}

	/**
	 * Atualizar Analise excecoes consumo resumido
	 * 
	 * @author eduardo henrique
	 * @date 09/06/2009 Transferência e correção de Regras de Situação de
	 *       Leituras para o Controlador
	 * @param idImovel
	 *            [obrigatório]
	 * @param mesAno
	 *            [obrigatório]
	 * @param dataLeituraAnteriorFaturamento
	 * @param leituraAnteriorFaturamento
	 * @param dataLeituraAtualInformada
	 * @param leituraAtualInformada
	 *            [obrigatório]
	 * @param consumo
	 * @param ligacaoAgua
	 * @param idAnormalidadeLeitura
	 * @param idConfirmacaoLeitura
	 *            [obrigatório] (0 - Não Confirmada / 1 - Confirmada)
	 * @throws NullPointerException
	 *             , caso algum parâmetro obrigatório não seja informado.
	 *             ControladorException em caso de Erro de Atualização
	 */
	public void atualizarLeituraConsumoResumido(Integer idImovel, String mesAno, String dataLeituraAnteriorFaturamento,
					String leituraAnteriorFaturamento, String dataLeituraAtualInformada, String leituraAtualInformada, String consumo,
					boolean ligacaoAgua, Integer idAnormalidade, Integer idConfirmacaoLeitura, Usuario usuario) throws ControladorException{

		FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();

		if(ligacaoAgua){
			filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.LIGACAO_AGUA_ID, idImovel));
		}else{
			filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.IMOVEL_ID, idImovel));
		}

		filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO, Util
						.formatarMesAnoComBarraParaAnoMes(mesAno)));

		Collection colecaoMedicaoHistorico = getControladorUtil().pesquisar(filtroMedicaoHistorico, MedicaoHistorico.class.getName());

		MedicaoHistorico medicaoHistorico = new MedicaoHistorico();
		if(colecaoMedicaoHistorico != null){
			medicaoHistorico = (MedicaoHistorico) Util.retonarObjetoDeColecao(colecaoMedicaoHistorico);

			medicaoHistorico.setDataLeituraAtualInformada(Util.converteStringParaDate(dataLeituraAtualInformada));
			medicaoHistorico.setDataLeituraAnteriorFaturamento(Util.converteStringParaDate(dataLeituraAnteriorFaturamento));
			medicaoHistorico.setLeituraAnteriorFaturamento(Util.converterStringParaInteger(leituraAnteriorFaturamento));
			medicaoHistorico.setLeituraAtualInformada(Util.converterStringParaInteger(leituraAtualInformada));

			LeituraAnormalidade leituraAnormalidadeInformada = new LeituraAnormalidade();
			leituraAnormalidadeInformada.setId(idAnormalidade);
			medicaoHistorico.setLeituraAnormalidadeInformada(leituraAnormalidadeInformada);

			medicaoHistorico.setNumeroConsumoInformado(Util.converterStringParaInteger(consumo));

			LeituraSituacao leituraSituacao = new LeituraSituacao();

			if((idAnormalidade == null)
							&& ((leituraAtualInformada == null) || (leituraAtualInformada != null && !leituraAtualInformada.equals("") && Integer
											.valueOf(leituraAtualInformada).intValue() == 0))){
				leituraSituacao.setId(LeituraSituacao.NAO_REALIZADA);
			}else{
				if(idConfirmacaoLeitura.equals(Integer.valueOf(ConstantesSistema.CONFIRMADA))){
					leituraSituacao.setId(LeituraSituacao.CONFIRMADA);
				}else{
					leituraSituacao.setId(LeituraSituacao.REALIZADA);
				}
			}

			medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);
			medicaoHistorico.setUltimaAlteracao(new Date());

			// ------------ <REGISTRAR TRANSAÇÃO>----------------------------
			if(usuario != null){
				RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ATUALIZAR_EXECECOES_LEITURAS_RESUMO,
								medicaoHistorico.getLigacaoAgua() != null ? medicaoHistorico.getLigacaoAgua().getId() : medicaoHistorico
												.getImovel().getId(), medicaoHistorico.getId(), new UsuarioAcaoUsuarioHelper(usuario,
												UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

				registradorOperacao.registrarOperacao(medicaoHistorico);
				// getControladorTransacao().registrarTransacao(medicaoHistorico);
			}
			// ------------ </REGISTRAR TRANSAÇÃO>----------------------------

			getControladorUtil().atualizar(medicaoHistorico);

			// try {
			// repositorioMicromedicao.atualizarLeituraConsumoResumido(medicaoHistorico);
			//
			// } catch (ErroRepositorioException e) {
			// // TODO Auto-generated catch block
			// e.printStackTrace();
			// }
		}
	}

	protected ControladorBatchLocal getControladorBatch(){

		ControladorBatchLocalHome localHome = null;
		ControladorBatchLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorBatchLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_BATCH_SEJB);
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}

	}

	/**
	 * Método que retorna um arrey de Object com informações do histórico de
	 * consumo com tipo de medição poco [UC0348] Emitir Contas [SB0006] Obter
	 * Dados de consumo da conta
	 * 
	 * @author Sávio Luiz
	 * @date 19/05/2006
	 * @param idImovel
	 * @param anoMes
	 * @param idTipoLigacao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterDadosConsumoConta(Integer idImovel, int anoMesReferencia, Integer idTipoLigacao) throws ControladorException{

		try{
			return repositorioMicromedicao.obterDadosConsumoConta(idImovel, anoMesReferencia, idTipoLigacao);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}


	private String montarStringCategorias(Imovel imovel){

		// 5.2.10. Economias:
		// R-000 C-000 I-000 P-000, onde o R – Categoria Residencial, C –
		// Categoria Comercial,
		// I – Categoria Industrial e P – Categoria Pública e 000 – Número de
		// economias da
		// Categoria
		Collection colecaoCategoria = Fachada.getInstancia().obterQuantidadeEconomiasCategoria(imovel);
		Iterator colecaoCategoriaIterator = colecaoCategoria.iterator();
		String economias = "";

		while(colecaoCategoriaIterator.hasNext()){

			Categoria categoria = (Categoria) colecaoCategoriaIterator.next();
			String quantidadeEconomias = categoria.getQuantidadeEconomiasCategoria().toString();

			if(categoria.getId().intValue() == Categoria.COMERCIAL_INT){
				economias += " Com. " + Util.completarStringZeroEsquerda(quantidadeEconomias, 3);
			}else if(categoria.getId().intValue() == Categoria.PUBLICO_INT){
				economias += " Pub. " + Util.completarStringZeroEsquerda(quantidadeEconomias, 3);
			}else if(categoria.getId().intValue() == Categoria.RESIDENCIAL_INT){
				economias += " Res. " + Util.completarStringZeroEsquerda(quantidadeEconomias, 3);
			}else if(categoria.getId().intValue() == Categoria.INDUSTRIAL_INT){
				economias += " Ind. " + Util.completarStringZeroEsquerda(quantidadeEconomias, 3);
			}
		}

		return economias;
	}

	/**
	 * Método que retorna o número da leitura de retirada do hidrômetro
	 * 
	 * @author Ana Maria
	 * @date 25/09/2006
	 * @param idLigacaoAgua
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarNumeroLeituraRetiradaLigacaoAgua(Integer idLigacaoAgua) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarNumeroLeituraRetiradaLigacaoAgua(idLigacaoAgua);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Método que retorna o número da leitura de retirada do hidrômetro
	 * 
	 * @author Ana Maria
	 * @date 25/09/2006
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarNumeroLeituraRetiradaImovel(Integer idImovel) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarNumeroLeituraRetiradaImovel(idImovel);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0000] - Efetuar Retirada de Hidrômetro Pesquisa todos os campos do
	 * Hidrometro e seus relacionamentos obrigatórios.
	 * 
	 * @author Thiago Tenório
	 * @date 28/09/2006
	 * @param idHidrometro
	 * @throws ControladorException
	 */
	public Hidrometro pesquisarHidrometroPeloId(Integer idHidrometro) throws ControladorException{

		Hidrometro hidrometro = new Hidrometro();

		try{
			Object[] resultado = repositorioHidrometro.pesquisarHidrometroPeloId(idHidrometro);

			if(resultado != null){
				// Id do Hidrômetro
				if(resultado[0] != null){ // 0
					hidrometro.setId((Integer) resultado[0]);
				}
				// Número do Hidrômetro
				if(resultado[1] != null){ // 1
					hidrometro.setNumero((String) resultado[1]);
				}
				// Data de Aquisição do Hidrômetro
				if(resultado[2] != null){ // 2
					hidrometro.setDataAquisicao((Date) resultado[2]);
				}
				// Ano de Fabricação do Hidrômetro
				if(resultado[3] != null){ // 3
					hidrometro.setAnoFabricacao((Short) resultado[3]);
				}
				// Indicado Macromedidor do Hidrômetro
				if(resultado[4] != null){ // 4
					hidrometro.setIndicadorMacromedidor((Short) resultado[4]);
				}
				// Data da Última Revisão do Hidrômetro
				if(resultado[5] != null){ // 5
					hidrometro.setDataUltimaRevisao((Date) resultado[5]);
				}
				// Data da Baixa do Hidrômetro
				if(resultado[6] != null){ // 6
					hidrometro.setDataBaixa((Date) resultado[6]);
				}
				// Número da Leitura Acumulada do Hidrômetro
				if(resultado[7] != null){ // 7
					hidrometro.setNumeroLeituraAcumulada((Integer) resultado[7]);
				}
				// Número de Dígitos de Leitura do Hidrômetro
				if(resultado[8] != null){ // 8
					hidrometro.setNumeroDigitosLeitura((Short) resultado[8]);
				}
				// Tipo do Hidrômetro
				if(resultado[9] != null){ // 9
					HidrometroTipo hidrometroTipo = new HidrometroTipo();
					hidrometroTipo.setId((Integer) resultado[9]);
					hidrometro.setHidrometroTipo(hidrometroTipo);
				}
				// Situação do Hidrômetro
				if(resultado[10] != null){ // 10
					HidrometroSituacao hidrometroSituacao = new HidrometroSituacao();
					hidrometroSituacao.setId((Integer) resultado[10]);
					hidrometro.setHidrometroSituacao(hidrometroSituacao);
				}
				// Marca do Hidrômetro
				if(resultado[11] != null){ // 11
					HidrometroMarca hidrometroMarca = new HidrometroMarca();
					hidrometroMarca.setId((Integer) resultado[11]);
					hidrometro.setHidrometroMarca(hidrometroMarca);
				}
				// Capacidade do Hidrômetro
				if(resultado[12] != null){ // 12
					HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
					hidrometroCapacidade.setId((Integer) resultado[12]);
					hidrometro.setHidrometroCapacidade(hidrometroCapacidade);
				}
				// Classe Metrológica do Hidrômetro
				if(resultado[13] != null){ // 13
					HidrometroClasseMetrologica hidrometroClasseMetrologica = new HidrometroClasseMetrologica();
					hidrometroClasseMetrologica.setId((Integer) resultado[13]);
					hidrometro.setHidrometroClasseMetrologica(hidrometroClasseMetrologica);
				}
				// Diâmetro do Hidrômetro
				if(resultado[14] != null){ // 14
					HidrometroDiametro hidrometroDiametro = new HidrometroDiametro();
					hidrometroDiametro.setId((Integer) resultado[14]);
					hidrometro.setHidrometroDiametro(hidrometroDiametro);
				}
				// Indicador de hidrômetro composto
				if(resultado[15] != null){ // 15
					hidrometro.setIndicadorHidrometroComposto((Short) resultado[15]);
				}
				// Fator de conversão do hidrômetro
				if(resultado[16] != null){ // 16
					hidrometro.setFatorConversao((BigDecimal) resultado[16]);
				}

				if(resultado[17] != null){
					hidrometro.setCodigoFormatoNumeracao((Integer) resultado[17]);
				}

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return hidrometro;
	}

	/**
	 * Permite pesquisar imóvel doação baseando-se em rotas [UC0394] Gerar
	 * Débitos a Cobrar de Doações
	 * 
	 * @author César Araújo
	 * @date 05/08/2006
	 * @param Collection
	 *            <Rota> rotas - Coleção de rotas
	 * @return Collection<ImovelCobrarDoacaoHelper> - Coleção de
	 *         ImovelCobrarDoacaoHelper já com as informações necessárias para
	 *         registro da cobrança
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	public Collection<ImovelCobrarDoacaoHelper> pesquisarImovelDoacaoPorRota(Collection<Rota> rotas) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarImovelDoacaoPorRota(rotas);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Método que retorna o consumo médio do imóvel
	 * 
	 * @author Ana Maria
	 * @date 17/10/2006
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarConsumoMedioImovel(Integer idImovel) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarConsumoMedioImovel(idImovel);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * @author Sávio Luiz
	 * @date 15/11/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Integer pesquisarConsumoMedio(Integer idImovel, Integer tipoMedicao) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarConsumoMedio(idImovel, tipoMedicao);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2007
	 * @param Integer
	 *            idImovel, Integer tipoMedicao
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarUltimoAnoMesConsumoFaturado(Integer idImovel, Integer tipoMedicao) throws ControladorException{

		try{

			return repositorioMicromedicao.pesquisarUltimoAnoMesConsumoFaturado(idImovel, tipoMedicao);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * @author Sávio Luiz
	 * @date 15/11/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Integer pesquisarMaiorConsumoFaturadoQuantidadeMeses(Integer idImovel, Integer tipoMedicao, short qtdMeses)
					throws ControladorException{

		Collection colecaoConsumoFaturaMes = null;
		Integer retorno = null;

		try{
			colecaoConsumoFaturaMes = repositorioMicromedicao.pesquisarConsumoFaturadoQuantidadeMeses(idImovel, tipoMedicao, qtdMeses);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		if(colecaoConsumoFaturaMes != null && !colecaoConsumoFaturaMes.isEmpty()){

			Iterator iteratorConsumoFaturaMes = colecaoConsumoFaturaMes.iterator();

			Integer maiorValor = 0;
			Integer valorMomento = 0;

			while(iteratorConsumoFaturaMes.hasNext()){
				valorMomento = (Integer) iteratorConsumoFaturaMes.next();

				if(valorMomento != null && valorMomento > maiorValor){
					maiorValor = valorMomento;
				}
			}

			retorno = maiorValor;
		}

		return retorno;
	}

	/**
	 * Atualizar Hidrômetro Pesquisa o imóvel no qual o hidrômetro está
	 * instalado
	 * 
	 * @author Rafael Corrêa
	 * @date 23/11/2006
	 * @param idHidrometro
	 * @return String
	 * @throws ControladorException
	 */
	public String pesquisarImovelHidrometroInstalado(Integer idHidrometro) throws ControladorException{

		String idImovel = "";
		Object[] dadosHidrometro = null;

		try{

			dadosHidrometro = repositorioMicromedicao.pesquisarImovelHidrometroInstalado(idHidrometro);

			if(dadosHidrometro != null){

				// Id do Imóvel
				if(dadosHidrometro[0] != null){ // 0
					idImovel = ((Integer) dadosHidrometro[0]).toString();
				}
				// Id da Ligação de Água
				if(dadosHidrometro[1] != null){ // 1
					idImovel = ((Integer) dadosHidrometro[1]).toString();
				}
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return idImovel;
	}

	/**
	 * [UC0498] - Efetuar Ligação de Água com Instalaação de Hidrômetro Pesquisa
	 * o id do hidrômetro e a sua situação pelo número
	 * 
	 * @author Rafael Corrêa
	 * @date 29/11/2006
	 * @param numeroHidrometro
	 * @return Hidrometro
	 * @throws ControladorException
	 */
	public Hidrometro pesquisarHidrometroPeloNumero(String numeroHidrometro) throws ControladorException{

		Hidrometro hidrometro = null;
		Object[] dadosHidrometro = null;

		try{

			dadosHidrometro = repositorioMicromedicao.pesquisarHidrometroPeloNumero(numeroHidrometro);

			if(dadosHidrometro != null){

				hidrometro = new Hidrometro();

				// Id do Hidrômetro
				if(dadosHidrometro[0] != null){ // 0
					hidrometro.setId((Integer) dadosHidrometro[0]);
				}

				// Número do Hidrômetro
				if(dadosHidrometro[1] != null){ // 1
					hidrometro.setNumero((String) dadosHidrometro[1]);
				}

				// Situação do Hidrômetro
				if(dadosHidrometro[2] != null){ // 2

					HidrometroSituacao hidrometroSituacao = new HidrometroSituacao();
					hidrometroSituacao.setId((Integer) dadosHidrometro[2]);
					hidrometroSituacao.setDescricao((String) dadosHidrometro[3]);

					hidrometro.setHidrometroSituacao(hidrometroSituacao);

				}

				// Hidrômetro Capacidade
				if(dadosHidrometro[4] != null){ // 4

					HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
					hidrometroCapacidade.setId((Integer) dadosHidrometro[4]);
					hidrometroCapacidade.setDescricao((String) dadosHidrometro[5]);

					hidrometro.setHidrometroCapacidade(hidrometroCapacidade);

				}

			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return hidrometro;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura Convencional Txt - Cabeçalho [SB0002]
	 * Gerar Relação
	 * 
	 * @author Hebert Falcão
	 * @date 15/02/2011
	 * @param imovel
	 * @param nomeAbreviadoEmpresa
	 * @param anoMesCorrente
	 * @param pagina
	 * @param folha
	 * @param dataAtual
	 * @param dataLeituraAnteriro
	 */
	private StringBuilder gerarDadosPorLeituraConvencionalTxtCabecalho(Imovel imovel, String nomeAbreviadoEmpresa, Integer anoMesCorrente,
					int pagina, int folha, Date dataAtual, Date dataLeituraAnteriro){

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// #################### 1ª Linha ####################

		arquivoTxtLinha.append("1");

		arquivoTxtLinha.append(Util.completaString(nomeAbreviadoEmpresa, 24));

		arquivoTxtLinha.append(Util.completaString("R E L A C A O   D E   C O N S U M I D O R E S", 48));

		arquivoTxtLinha.append(Util.completaString("P A R A   L E I T U R A   E M", 32));

		// Mes
		String anoMes = Integer.toString(anoMesCorrente);

		String mes = anoMes.substring(4, 6);
		String descricaoMes = Util.retornaDescricaoMes(Integer.parseInt(mes)).toUpperCase();

		arquivoTxtLinha.append(Util.completaString(descricaoMes.substring(0, 3), 3));

		arquivoTxtLinha.append("/");

		// Ano
		String ano = anoMes.substring(0, 4);
		arquivoTxtLinha.append(Util.completaString(ano, 4));

		arquivoTxtLinha.append(Util.completaString("", 12));

		arquivoTxtLinha.append(Util.completaString("PAG-", 4));

		String paginaComZero = Util.adicionarZerosEsquedaNumero(2, Integer.toString(pagina));

		arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(paginaComZero, 4));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		// #################### 2ª Linha ####################

		arquivoTxtLinha.append(Util.completaString(" R87", 20));

		// Localidade Vinculada
		arquivoTxtLinha.append(Util.completaString("VINC-", 6));

		if(imovel.getLocalidade() != null && imovel.getLocalidade().getLocalidade() != null){
			int idLocalidadVinculada = imovel.getLocalidade().getLocalidade().getId();

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, Integer.toString(idLocalidadVinculada)));
		}else{
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 3));
		}

		arquivoTxtLinha.append(Util.completaString("", 10));

		// Localidade
		String nomeLocalidade = "";

		if(imovel.getLocalidade() != null){
			int idLocalidade = imovel.getLocalidade().getId();
			nomeLocalidade = imovel.getLocalidade().getDescricao();

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, Integer.toString(idLocalidade)));
		}else{
			arquivoTxtLinha.append(Util.completaString("", 3));
		}

		arquivoTxtLinha.append(Util.completaString(" -", 3));
		arquivoTxtLinha.append(Util.completaString(nomeLocalidade, 25));

		// Setor
		arquivoTxtLinha.append(Util.completaString("  SETOR -", 10));

		if(imovel.getSetorComercial() != null){
			int codigoSetor = imovel.getSetorComercial().getCodigo();

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, Integer.toString(codigoSetor)));
		}else{
			arquivoTxtLinha.append(Util.completaString("", 2));
		}

		// Rota
		arquivoTxtLinha.append(Util.completaString("   ROTA -", 9));

		String codigoRotaStr = "";

		Rota rota = imovel.getRota();

		if(rota != null){
			Short codigoRota = rota.getCodigo();

			if(codigoRota != null){
				codigoRotaStr = Short.toString(codigoRota);
			}
		}

		if(!Util.isVazioOuBranco(codigoRotaStr)){
			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, codigoRotaStr));
		}else{
			arquivoTxtLinha.append(Util.completaString("", 2));
		}

		// Faturamento Grupo
		arquivoTxtLinha.append(Util.completaString("  GRUPO -", 10));

		if(imovel.getRota() != null && imovel.getRota().getFaturamentoGrupo() != null){
			int idFaturamentoGrupo = imovel.getRota().getFaturamentoGrupo().getId();

			arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, Integer.toString(idFaturamentoGrupo)));
		}else{
			arquivoTxtLinha.append(Util.completaString("", 3));
		}

		// Folha
		arquivoTxtLinha.append(Util.completaString(" FOL.", 7));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, Integer.toString(folha)));

		arquivoTxtLinha.append(Util.completaString("", 8));

		// Data atual
		arquivoTxtLinha.append(Util.formatarData(dataAtual));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		// #################### 3ª Linha ####################

		arquivoTxtLinha.append(" ");

		arquivoTxtLinha.append(Util.repetirTexto("-", 132));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		// #################### 4ª Linha ####################

		arquivoTxtLinha.append(Util.completaString("", 4));

		arquivoTxtLinha.append(Util.completaString("LOCALIZACAO", 11));

		arquivoTxtLinha.append(Util.completaString("", 11));

		arquivoTxtLinha.append(Util.completaString("ENDERECO", 15));

		arquivoTxtLinha.append(Util.completaString("", 23));

		arquivoTxtLinha.append(Util.completaString("CAT HIDROMETRO  LOC  MATRIC.", 29));

		arquivoTxtLinha.append(Util.completaString("LEITURA OCOR CON", 17));

		arquivoTxtLinha.append(Util.completaString("CONS.INF FAIXA LEITURA", 22));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		// #################### 5ª Linha ####################

		arquivoTxtLinha.append(" ");

		arquivoTxtLinha.append(Util.repetirTexto("-", 132));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		// #################### 6ª Linha ####################

		arquivoTxtLinha.append("0");

		arquivoTxtLinha.append(Util.completaString("LEITURISTA -", 13));

		arquivoTxtLinha.append(Util.completaString("", 10));

		arquivoTxtLinha.append(Util.completaString("  DATA DE LEITURA -", 20));

		arquivoTxtLinha.append(Util.completaString("   /   /   ", 11));

		arquivoTxtLinha.append(Util.completaString("  HORA INICIAL -", 17));

		arquivoTxtLinha.append(Util.completaString("    :    ", 9));

		arquivoTxtLinha.append(Util.completaString("  HORA FINAL -", 15));

		arquivoTxtLinha.append(Util.completaString("    :    ", 9));

		arquivoTxtLinha.append(Util.completaString("", 4));

		arquivoTxtLinha.append(Util.completaString("DT.LEIT.ANT-", 13));

		// Data da leitura anterior
		arquivoTxtLinha.append(Util.formatarData(dataLeituraAnteriro));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * @author Sávio Luiz
	 * @date 06/12/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Date pesquisarDataInstalacaoHidrometroAgua(Integer idImovel) throws ControladorException{

		Date dataInstalacao = null;

		try{

			dataInstalacao = repositorioMicromedicao.pesquisarDataInstalacaoHidrometroAgua(idImovel);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return dataInstalacao;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * @author Sávio Luiz
	 * @date 06/12/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Date pesquisarDataInstalacaoHidrometroPoco(Integer idImovel) throws ControladorException{

		Date dataInstalacao = null;

		try{

			dataInstalacao = repositorioMicromedicao.pesquisarDataInstalacaoHidrometroPoco(idImovel);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return dataInstalacao;
	}

	/**
	 * [UC0488] Informar Retorno Ordem de Fiscalização
	 * 
	 * @author Sávio Luiz
	 * @date 14/11/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */
	public Integer pesquisarConsumoFaturaMes(Integer amReferencia, Integer idLigacao, Integer idImovel) throws ControladorException{

		Integer consumoHistoricoMes = null;

		try{

			consumoHistoricoMes = repositorioMicromedicao.pesquisarConsumoFaturaMes(amReferencia, idLigacao, idImovel);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return consumoHistoricoMes;
	}

	/**
	 * [] Ligacoes Medicao Individualizada
	 * 
	 * @author Flávio Cordeiro
	 * @date 17/12/2006
	 * @param colecaoLigacoesMedicao
	 * @throws ControladorException
	 */
	public void atualizarLigacoesMedicaoIndividualizada(Collection colecaoLigacoesMedicao, Usuario usuarioLogado, Integer anoMes)
					throws ControladorException{

		try{

			// itera a colecao para validar se existem as
			// anormalidades(Leitura,Consumo) digitadas.
			Iterator iterator = colecaoLigacoesMedicao.iterator();
			LigacaoMedicaoIndividualizadaHelper ligacaoMedicaoIndividualizadaHelper = null;
			Collection colecaoLeituraAnormalidade = null;

			while(iterator.hasNext()){
				ligacaoMedicaoIndividualizadaHelper = (LigacaoMedicaoIndividualizadaHelper) iterator.next();

				// testa se existe a anormalidade de leitura
				if(ligacaoMedicaoIndividualizadaHelper.getIdLeituraAnormalidade() != null){
					FiltroLeituraAnormalidade filtroLeituraAnormalidade = new FiltroLeituraAnormalidade();
					filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(FiltroLeituraAnormalidade.ID,
									ligacaoMedicaoIndividualizadaHelper.getIdLeituraAnormalidade()));
					colecaoLeituraAnormalidade = getControladorUtil().pesquisar(filtroLeituraAnormalidade,
									LeituraAnormalidade.class.getName());
					if(colecaoLeituraAnormalidade.isEmpty()){
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.anormalidade_ligacoes_invalida", null, ligacaoMedicaoIndividualizadaHelper
										.getIdImovel().toString());

					}
				}
				repositorioMicromedicao.atualizarLigacoesMedicaoIndividualizada(ligacaoMedicaoIndividualizadaHelper, anoMes);
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Obtém os ids de todas as rotas cadastradas menos as rotas que tiverem o
	 * emp_cobranca = 1 [UC0251] - Gerar Atividade de Ação de Cobrança [SB0002]
	 * - Gerar Atividade de Ação de Cobrança para os Imóveis da Lista de Rotas
	 * 
	 * @author Sávio Luiz
	 * @date 05/03/2007
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarListaRotas() throws ControladorException{

		Collection retorno = null;

		try{

			retorno = repositorioMicromedicao.pesquisarListaRotas();

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	public Collection pesquisarListaRotasEspecificas() throws ControladorException{

		Collection retorno = null;

		try{

			retorno = repositorioMicromedicao.pesquisarListaRotasEspecificas();

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura Convencional Txt - Totalização
	 * [SB0002] Gerar Relação
	 * 
	 * @author Hebert Falcão
	 * @date 15/02/2011
	 * @param totalMatricula
	 */
	private StringBuilder gerarDadosPorLeituraConvencionalTxtTotalizacao(int totalMatricula){

		StringBuilder arquivoTxtLinha = new StringBuilder();

		arquivoTxtLinha.append("-");

		arquivoTxtLinha.append(Util.completaString("", 26));

		arquivoTxtLinha.append(Util.completaString("*******  T O T A L I Z A C A O  *******", 40));

		arquivoTxtLinha.append(Util.completaString("", 17));

		arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(Integer.toString(totalMatricula), 9));

		arquivoTxtLinha.append(Util.completaString(" ------- ---- --- ------", 24));

		arquivoTxtLinha.append(Util.completaString("", 16));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura Convencional Txt - Total de ligação
	 * [SB0002] Gerar Relação
	 * 
	 * @author Hebert Falcão
	 * @date 15/02/2011
	 * @param texto
	 * @param total
	 */
	private StringBuilder gerarDadosPorLeituraConvencionalTxtTotalLigacao(String texto, int total){

		StringBuilder arquivoTxtLinha = new StringBuilder();

		arquivoTxtLinha.append("0");

		arquivoTxtLinha.append(Util.completaString("", 63));

		// Truncando o texto
		if(texto.length() > 7){
			texto = texto.substring(0, 7);
		}

		arquivoTxtLinha.append(Util.completaString("* TOTAL LIGACAO (" + texto + ")", 26));

		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(5, Integer.toString(total)));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * [SB0005] – Gera dados para leitura convencional(TXT)
	 * 
	 * @author Rafael Francisco Pinto
	 * @date 19/01/2007
	 * @param ano
	 *            e mes corrente
	 * @param id
	 *            grupo faturamento
	 * @throws ControladorException
	 */

	protected void gerarArquivoConvencional(Integer anoMesCorrente, Integer idGrupoFaturamentoRota, StringBuilder arquivoTxtLinha,
					Integer idRota, boolean ehSistemaLegado) throws ControladorException{

		try{

			String nomeZipRol = null;

			if(ehSistemaLegado){
				nomeZipRol = "ROL_SISTEMA_LEGADO_";
			}else{
				nomeZipRol = "ROL_";
			}

			System.out.println("GERA O ARQUIVO CONVENCIONAL " + nomeZipRol);

			/*
			 * Alterado por Raphael Rossiter em 30/03/2007 OBJ: Gerar apenas um
			 * arquivo para todas as rotas
			 */
			if(idRota != null){
				nomeZipRol = nomeZipRol + idGrupoFaturamentoRota + "_" + idRota + "_" + anoMesCorrente + "-";
			}else{
				nomeZipRol = nomeZipRol + idGrupoFaturamentoRota + "_" + anoMesCorrente + "-";
			}

			File compactadoTipoRol = new File(nomeZipRol + ".zip");
			File leituraTipoRol = File.createTempFile(nomeZipRol, ".txt");

			ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(compactadoTipoRol));

			BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(leituraTipoRol.getAbsolutePath())));

			out.write(arquivoTxtLinha.toString());
			out.flush();

			ZipUtil.adicionarArquivo(zos, leituraTipoRol);
			zos.close();

			leituraTipoRol.delete();
			out.close();
		}catch(IOException e){
			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");

			if(inicioMensagem != null && (inicioMensagem[0].equals("erro") || inicioMensagem[0].equals("atencao"))){
				throw new ControladorException(mensagem);
			}else{
				throw new ControladorException("erro.sistema", e);
			}
		}catch(Exception e){
			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");
			if(inicioMensagem != null && (inicioMensagem[0].equals("erro") || inicioMensagem[0].equals("atencao"))){

				throw new ControladorException(mensagem);
			}else{
				throw new ControladorException("erro.sistema", e);
			}
		}
	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0002] Gerar Relação(ROL) em TXT -
	 * Registro 0
	 * 
	 * @author Rafael Francisco Pinto, Raphael Rossiter
	 * @date 22/01/2007, 28/03/2007
	 * @param imovel
	 *            , pagina, anoMesFaturamento
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroZERO(Imovel imovel, int pagina, String anoMesFaturamento)
					throws ControladorException{

		System.out.println("****GERAR LEITURA CONVENCIONAL REGISTO 0(ZERO)*****");

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.1.1 - Tipo de Registro 0 (ZERO)
		arquivoTxtLinha.append("0");

		// 1.1.2 - Distrito (Gerencia Regional)
		arquivoTxtLinha.append(completaString(imovel.getLocalidade().getGerenciaRegional().getNome(), 13));

		// 1.1.3 - Cidade (Localidade)
		arquivoTxtLinha.append(completaString(imovel.getLocalidade().getDescricao(), 20));

		// 1.1.4 - Mês de Referência
		String ano = anoMesFaturamento.substring(0, 4);
		String mes = anoMesFaturamento.substring(4, 6);

		arquivoTxtLinha.append(completaString(Util.retornaDescricaoMes(Integer.parseInt(mes)) + "/" + ano, 14));

		// 1.1.5 - Cidade (Código da Localidade)
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovel.getLocalidade().getId()));

		// 1.1.6 - Setor (Setor Comercial)
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, ""
						+ (imovel.getSetorComercial() != null ? imovel.getSetorComercial().getCodigo() : "00")));

		// 1.1.7 - Rota
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, "" + (imovel.getRota() != null ? imovel.getRota().getCodigo() : "00")));

		// 1.1.8 - Página
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + pagina));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0002] Gerar Relação(ROL) em TXT -
	 * Registro 1
	 * 
	 * @author Rafael Francisco Pinto, Raphael Rossiter
	 * @date 22/01/2007, 28/03/2007
	 * @param imovel
	 *            , anoMesFaturamento
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroUM(Imovel imovel, int anoMesFaturamento) throws ControladorException{

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.2.1 - Tipo de Registro 1 (UM)
		arquivoTxtLinha.append("1");

		// 1.2.1.1 - Nome
		String nomeClienteUsuario = null;
		try{
			// Pesquisa o nome do cliente que tem o tipo de relação usuário.
			nomeClienteUsuario = repositorioClienteImovel.pesquisarNomeClientePorImovel(imovel.getId());
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		if(nomeClienteUsuario == null){
			nomeClienteUsuario = "";
		}
		arquivoTxtLinha.append(completaString(nomeClienteUsuario, 40));

		// 1.2.1.2 - Situação (RETIRAR - DEIXAR ESPAÇOS - COM TAMANHO = 06)
		arquivoTxtLinha.append(completaString("", 6));

		// 1.2.1.3
		Collection colecaoSubCategoria = this.getControladorImovel().obterQuantidadeEconomiasSubCategoria(imovel.getId());

		// 1.2.1.3.1 - SubCategoria 01
		// 1.2.1.3.2 - Quantidade 01
		// 1.2.1.3.3 - SubCategoria 02
		// 1.2.1.3.4 - Quantidade 02
		if(colecaoSubCategoria != null && !colecaoSubCategoria.isEmpty()){

			Iterator itera = colecaoSubCategoria.iterator();
			int tam = 0;
			while(itera.hasNext()){
				tam++;
				if(tam < 3){

					Subcategoria subcategoria = (Subcategoria) itera.next();

					// tipoEconomia = categoria_id(1 posição) +
					// subcategoria_codigo(3 posições)
					arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(1, subcategoria.getCategoria().getId() + ""));
					arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, subcategoria.getCodigo() + ""));

					// qtdeEconomia
					arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + subcategoria.getQuantidadeEconomias()));

				}else{
					break;
				}
			}

			if(tam < 2){
				arquivoTxtLinha.append(completaString("", 6));
			}
		}else{
			arquivoTxtLinha.append(completaString("", 12));
		}

		// 1.2.1.4 - Consumo
		Integer numeroConsumoFaturadoMes = null;

		try{

			// 1.2.1.4.1 - Consumo 01
			int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 1);

			numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovel.getId(),
							anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if(numeroConsumoFaturadoMes != null){
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + numeroConsumoFaturadoMes));
			}else{
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 4));
			}

			// 1.2.1.4.2 - Consumo 02
			anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 2);
			numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovel.getId(),
							anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if(numeroConsumoFaturadoMes != null){
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + numeroConsumoFaturadoMes));
			}else{
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 4));
			}

			// 1.2.1.4.3 - Consumo 03
			anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesFaturamento, 3);
			numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovel.getId(),
							anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if(numeroConsumoFaturadoMes != null){
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + numeroConsumoFaturadoMes));
			}else{
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 4));
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		// 1.2.1.5 - Condição
		String condicao = null;
		try{
			condicao = this.repositorioMicromedicao.obterDescricaoConsumoTipo(imovel.getId(), LigacaoTipo.LIGACAO_AGUA);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		if(condicao != null){
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("" + condicao, 8));
		}else{
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 8));
		}

		// 1.2.1.6 - Número do Lacre
		if(imovel.getLigacaoAgua().getNumeroLacre() != null){
			arquivoTxtLinha.append(completaString(imovel.getLigacaoAgua().getNumeroLacre(), 6));
		}else{
			arquivoTxtLinha.append(completaString("", 6));
		}

		// 1.2.1.7 - Matrícula do Imóvel
		arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(imovel.getId().toString(), 9));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0002] Gerar Relação(ROL) em TXT -
	 * Registro 2
	 * 
	 * @author Rafael Francisco Pinto, Raphael Rossiter
	 * @date 22/01/2007, 28/03/2007
	 * @param imovel
	 *            , anoMesCorrente, sistemaParametro
	 * @throws ControladorException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalRegistroDOIS(Imovel imovel, Integer anoMesCorrente,
					SistemaParametro sistemaParametro) throws ControladorException{

		StringBuilder arquivoTxtLinha = new StringBuilder();

		boolean ligacaoAgua = false;
		boolean ligacaoPoco = false;

		if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getId() != null
						&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
						&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null){

			ligacaoAgua = true;
		}

		if(imovel.getHidrometroInstalacaoHistorico() != null && imovel.getHidrometroInstalacaoHistorico().getId() != null){

			ligacaoPoco = true;
		}

		// Dados do Hidrometro

		Short numeroDigitosHidrometro = null;
		StringBuilder dadosHidrometro = null;

		if(ligacaoAgua && ligacaoPoco){

			Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

			dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
			numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

		}else{
			if(ligacaoAgua){

				Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

				dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
				numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

			}else{

				if(ligacaoPoco){

					Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

					dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
					numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

				}else{
					Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

					dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
					numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

				}
			}
		}

		// 1.2.2 - Tipo de Registro 2 (DOIS)
		arquivoTxtLinha.append("2");

		// 1.2.2.1 - Endereço
		// Pesquisa o endereço do imovel passando o id
		String enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(imovel.getId());
		if(enderecoImovel != null && !enderecoImovel.equals("")){
			// endereço do imóvel
			arquivoTxtLinha.append(completaString(enderecoImovel, 45));
		}else{
			arquivoTxtLinha.append(completaString("", 45));
		}

		// 1.2.2.2 - Hidrômetro
		if(ligacaoPoco && !ligacaoAgua){

			String numeroHidrometroFinal = imovel.getHidrometroInstalacaoHistorico().getHidrometro().getNumero().trim();

			if(numeroHidrometroFinal.length() > 8){

				numeroHidrometroFinal = numeroHidrometroFinal.substring(numeroHidrometroFinal.length() - 8, numeroHidrometroFinal.length());

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, numeroHidrometroFinal));
			}else{

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, numeroHidrometroFinal));
			}

		}else{

			String numeroHidrometroFinal = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro().getNumero().trim();

			if(numeroHidrometroFinal.length() > 8){

				numeroHidrometroFinal = numeroHidrometroFinal.substring(numeroHidrometroFinal.length() - 8, numeroHidrometroFinal.length());

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, numeroHidrometroFinal));
			}else{

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, numeroHidrometroFinal));
			}
		}

		// 1.2.2.3 - Inscrição do Imovel
		// 1.2.2.3.1 - Quadra
		// 1.2.2.3.2 - Lote
		// 1.2.2.3.3 - SubLote
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovel.getQuadra().getNumeroQuadra()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + imovel.getLote()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovel.getSubLote()));

		// 1.2.2.4 - Sequencial da Rota
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + imovel.getNumeroSequencialRota()));

		// 1.2.2.5 - Leitura Atual (Leitura anterior)
		/*
		 * Integer anoMesAnterior = Util.subtrairData(anoMesCorrente); String
		 * leituraAnterior = null; Integer idMedicaoTipo = null;
		 * MedicaoHistorico medicaoHistorico = null; Object[] retorno =
		 * pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior,
		 * imovel); // verifica se a leitura anterior é diferente de nula if
		 * (retorno[0] != null) { leituraAnterior = retorno[0].toString(); } //
		 * verifica se a leitura situação atual é diferente de // nula if
		 * (retorno[1] != null) { medicaoHistorico = (MedicaoHistorico)
		 * retorno[1]; } // verifica se o id da medição tipo é diferente de nula
		 * if (retorno[2] != null) { idMedicaoTipo = (Integer) retorno[2]; } if
		 * (leituraAnterior != null) {
		 * arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, "" +
		 * leituraAnterior)); } else {
		 * arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(6, "")); }
		 */

		// 1.2.2.6 - Leitura Esperada
		// 1.2.2.7
		// 1.2.2.8
		/*
		 * Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovel,
		 * dadosHidrometro, leituraAnterior, medicaoHistorico, idMedicaoTipo,
		 * sistemaParametro, false, numeroDigitosHidrometro); StringBuilder
		 * faixaInicialFinalString = (StringBuilder) faixaInicialFinal[0];
		 * arquivoTxtLinha.append(faixaInicialFinalString);
		 */

		/*
		 * Colocado por Raphael Rossiter em 30/03/2007 (Analista: Rosana) Obter
		 * a leitura atual e a leitura esperada da mesma forma que é feito para
		 * o sistema legado. 1.2.2.5 Leitura atual 1.2.2.6 Leitura esperada
		 */
		Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);

		String leituraAnterior = null;
		Integer idMedicaoTipo = null;

		MedicaoHistorico medicaoHistorico = null;

		Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior, imovel);

		// verifica se a leitura anterior é diferente de nula
		if(retorno[0] != null){
			leituraAnterior = retorno[0].toString();
		}
		// verifica se a leitura situação atual é diferente de
		// nula
		if(retorno[1] != null){
			medicaoHistorico = (MedicaoHistorico) retorno[1];
		}
		// verifica se o id da medição tipo é diferente de nula
		if(retorno[2] != null){
			idMedicaoTipo = (Integer) retorno[2];
		}

		Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovel, dadosHidrometro, leituraAnterior, medicaoHistorico,
						idMedicaoTipo, sistemaParametro, false, numeroDigitosHidrometro);

		StringBuilder faixaInicialFinalString = (StringBuilder) faixaInicialFinal[0];

		arquivoTxtLinha.append(faixaInicialFinalString);

		Integer numeroConsumoFaturadoMes = null;

		try{

			// 1.2.2.9 - Consumo 04
			int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesCorrente, 4);

			numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovel.getId(),
							anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if(numeroConsumoFaturadoMes != null){
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + numeroConsumoFaturadoMes));
			}else{
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 4));
			}

			// 1.2.2.10 - Consumo 05
			anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesCorrente, 5);
			numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovel.getId(),
							anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if(numeroConsumoFaturadoMes != null){
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + numeroConsumoFaturadoMes));
			}else{
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 4));
			}

			// 1.2.2.11 - Consumo 06
			anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMesCorrente, 6);
			numeroConsumoFaturadoMes = repositorioMicromedicao.obterConsumoLigacaoAguaOuEsgotoDoImovelPeloTipoLogacao(imovel.getId(),
							anoMesSubtraido, LigacaoTipo.LIGACAO_AGUA);

			// caso o numero consumo faturado do mes for diferente de nulo
			if(numeroConsumoFaturadoMes != null){
				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + numeroConsumoFaturadoMes));
			}else{
				arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 4));
			}

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		// 1.2.2.12 - Consumo Médio
		Integer numeroConsumoMedio = null;
		try{
			numeroConsumoMedio = this.repositorioMicromedicao.pesquisarNumeroConsumoMedioImovel(imovel.getId(), anoMesCorrente,
							LigacaoTipo.LIGACAO_AGUA);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		if(numeroConsumoMedio != null){
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("" + numeroConsumoMedio, 4));
		}else{
			arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda("", 4));
		}

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0003] Gerar Arquivo Entrada Sistema
	 * Legado
	 * 
	 * @author Rafael Francisco Pinto
	 * @date 09/02/2007
	 * @param Imovel
	 * @throws ErroRepositorioException
	 */
	protected StringBuilder gerarDadosLeituraConvencionalSistemaLegado(Imovel imovel, int pagina, Integer anoMesCorrente,
					SistemaParametro sistemaParametro) throws ControladorException{

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// 1.1 - Matricula do imovel Tam. 09
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(9, "" + imovel.getId()));

		// 1.2 - Cidade (codigo da localidade) Tam. 03
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovel.getLocalidade().getId()));

		// 1.3 - Setor (Setor Comercial) Tam. 03
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovel.getSetorComercial().getCodigo()));

		// 1.4 - Rota Tam. 02
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(2, "" + imovel.getRota().getCodigo()));

		/*
		 * Colocado por Raphael Rossiter em 19/05/2007 (Analista: Eduardo
		 * Borges)
		 */
		// Sequencial da Rota Tam. 04
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + imovel.getNumeroSequencialRota()));

		// 1.5 - Página
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + pagina));

		// 1.6 - Inscrição do Imovel
		// 1.6.1 - Quadra
		// 1.6.2 - Lote
		// 1.6.3 - SubLote
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovel.getQuadra().getNumeroQuadra()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(4, "" + imovel.getLote()));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, "" + imovel.getSubLote()));

		boolean ligacaoAgua = false;
		boolean ligacaoPoco = false;

		if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getId() != null
						&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
						&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getId() != null){

			ligacaoAgua = true;
		}

		if(imovel.getHidrometroInstalacaoHistorico() != null && imovel.getHidrometroInstalacaoHistorico().getId() != null){

			ligacaoPoco = true;
		}

		// Dados do Hidrometro
		Short numeroDigitosHidrometro = null;
		StringBuilder dadosHidrometro = null;

		if(ligacaoAgua && ligacaoPoco){

			Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

			dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
			numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

		}else{
			if(ligacaoAgua){

				Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

				dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
				numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

			}else{

				if(ligacaoPoco){

					Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

					dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
					numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

				}else{
					Object[] dadosHidroemtroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

					dadosHidrometro = (StringBuilder) dadosHidroemtroNumeroLeitura[0];
					numeroDigitosHidrometro = (Short) dadosHidroemtroNumeroLeitura[1];

				}
			}
		}

		Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);

		String leituraAnterior = null;
		Integer idMedicaoTipo = null;

		MedicaoHistorico medicaoHistorico = null;

		Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior, imovel);

		// verifica se a leitura anterior é diferente de nula
		if(retorno[0] != null){
			leituraAnterior = retorno[0].toString();
		}
		// verifica se a leitura situação atual é diferente de
		// nula
		if(retorno[1] != null){
			medicaoHistorico = (MedicaoHistorico) retorno[1];
		}
		// verifica se o id da medição tipo é diferente de nula
		if(retorno[2] != null){
			idMedicaoTipo = (Integer) retorno[2];
		}

		// 1.7 - Leitura Esperada Inicial e Esperada
		Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovel, dadosHidrometro, leituraAnterior, medicaoHistorico,
						idMedicaoTipo, sistemaParametro, false, numeroDigitosHidrometro);

		StringBuilder faixaInicialFinalString = (StringBuilder) faixaInicialFinal[0];

		arquivoTxtLinha.append(faixaInicialFinalString);

		// Numero do Hidrometro
		if(ligacaoPoco && !ligacaoAgua){

			String numeroHidrometroFinal = imovel.getHidrometroInstalacaoHistorico().getHidrometro().getNumero().trim();

			if(numeroHidrometroFinal.length() > 8){

				numeroHidrometroFinal = numeroHidrometroFinal.substring(numeroHidrometroFinal.length() - 8, numeroHidrometroFinal.length());

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, numeroHidrometroFinal));
			}else{

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, numeroHidrometroFinal));
			}

		}else{

			String numeroHidrometroFinal = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro().getNumero().trim();

			if(numeroHidrometroFinal.length() > 8){

				numeroHidrometroFinal = numeroHidrometroFinal.substring(numeroHidrometroFinal.length() - 8, numeroHidrometroFinal.length());

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, numeroHidrometroFinal));
			}else{

				arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(8, numeroHidrometroFinal));
			}
		}

		// Tipo de Medição
		arquivoTxtLinha.append(idMedicaoTipo);

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0002] Gerar Relação(ROL) em TXT
	 * Cria o objeto Imovel apartir da pesquisa
	 * 
	 * @param Object
	 *            [] arrayImoveis
	 * @return Imovel
	 * @author Rafael Francisco Pinto
	 * @date 19/01/2007
	 * @throws ControladorException
	 */
	public Imovel criarImovelApartirDadosPorLeituraConvencional(Object[] arrayImoveis){

		// instancia um imóvel
		Imovel imovel = new Imovel();

		if(arrayImoveis[0] != null){
			// seta o id no imovel
			imovel.setId((Integer) arrayImoveis[0]);
		}

		if(arrayImoveis[1] != null){
			// instancia uma localidade para ser setado no imóvel
			Localidade localidade = new Localidade();
			localidade.setId((Integer) arrayImoveis[1]);
			localidade.setDescricao((String) arrayImoveis[30]);

			if(arrayImoveis[63] != null){
				// instancia uma localidade para ser setado no imóvel
				Localidade elo = new Localidade();
				elo.setId((Integer) arrayImoveis[63]);
				localidade.setLocalidade(elo);
			}

			imovel.setLocalidade(localidade);
		}

		if(arrayImoveis[2] != null){
			// instancia um setor comercial para ser setado no
			// imóvel
			SetorComercial setorComercial = new SetorComercial();
			setorComercial.setCodigo(Integer.parseInt(arrayImoveis[2].toString()));
			imovel.setSetorComercial(setorComercial);
		}
		Quadra quadra = new Quadra();
		if(arrayImoveis[3] != null){

			// instancia uma quadra para ser setado no imóvel
			Integer numeroQuadra = (Integer) arrayImoveis[3];
			quadra.setNumeroQuadra(numeroQuadra);

			// Roteiro Empresa
			if(arrayImoveis[64] != null){

				RoteiroEmpresa roteiroEmpresa = new RoteiroEmpresa();
				roteiroEmpresa.setId((Integer) arrayImoveis[64]);

				// Empresa
				if(arrayImoveis[65] != null){

					Empresa empresa = new Empresa();
					empresa.setId((Integer) arrayImoveis[65]);
					quadra.getRoteiroEmpresa().setEmpresa(empresa);
				}

				quadra.setRoteiroEmpresa(roteiroEmpresa);
			}

			// Área Tipo
			if(arrayImoveis[66] != null){

				AreaTipo areaTipo = new AreaTipo();
				areaTipo.setDescricao((String) arrayImoveis[66]);
				quadra.setAreaTipo(areaTipo);
			}

			imovel.setQuadra(quadra);
		}

		if(arrayImoveis[4] != null){
			// seta o lote no imóvel
			imovel.setLote(Short.parseShort(arrayImoveis[4].toString()));
		}

		if(arrayImoveis[5] != null){
			// seta o lote no imóvel
			imovel.setSubLote(Short.parseShort(arrayImoveis[5].toString()));
		}

		if(arrayImoveis[34] != null){
			// seta numero sequencial rota
			imovel.setNumeroSequencialRota((Integer) arrayImoveis[34]);
		}

		if(arrayImoveis[6] != null){
			// instancia uma imovel perfil para ser setado no
			// imóvel
			ImovelPerfil imovelPerfil = new ImovelPerfil();
			imovelPerfil.setId((Integer) arrayImoveis[6]);
			imovel.setImovelPerfil(imovelPerfil);
		}

		LigacaoAgua ligacaoAgua = new LigacaoAgua();
		if(arrayImoveis[7] != null){
			// instancia uma ligação agua para ser setado no
			// imóvel

			ligacaoAgua.setId((Integer) arrayImoveis[7]);
			ligacaoAgua.setNumeroLacre((String) arrayImoveis[32]);
		}
		// instancia um hidrometro instalação historico para ser
		// colocado na ligacao agua
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoLigacaoAgua = new HidrometroInstalacaoHistorico();
		if(arrayImoveis[8] != null){

			hidrometroInstalacaoHistoricoLigacaoAgua.setId((Integer) arrayImoveis[8]);
			MedicaoTipo medicaoTipo = new MedicaoTipo();
			medicaoTipo.setId((Integer) arrayImoveis[26]);
			hidrometroInstalacaoHistoricoLigacaoAgua.setMedicaoTipo(medicaoTipo);

			if(arrayImoveis[33] != null){
				Hidrometro hidrometro = new Hidrometro();
				hidrometro.setNumero((String) arrayImoveis[33]);
				if(arrayImoveis[61] != null){
					hidrometro.setNumeroDigitosLeitura((Short) arrayImoveis[61]);
				}else{
					hidrometro.setNumeroDigitosLeitura(Util.obterShort("1"));
				}
				hidrometroInstalacaoHistoricoLigacaoAgua.setHidrometro(hidrometro);
			}

			if(arrayImoveis[40] != null){
				HidrometroLocalInstalacao hidrometroLocalInstalacao = new HidrometroLocalInstalacao();
				hidrometroLocalInstalacao.setDescricao((String) arrayImoveis[40].toString());
				hidrometroInstalacaoHistoricoLigacaoAgua.setHidrometroLocalInstalacao(hidrometroLocalInstalacao);
			}

			if(arrayImoveis[68] != null){

				hidrometroInstalacaoHistoricoLigacaoAgua.setDataInstalacao((Date) arrayImoveis[68]);
			}

			ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoLigacaoAgua);

		}
		imovel.setLigacaoAgua(ligacaoAgua);

		// Poco Tipo
		PocoTipo pocoTipo = new PocoTipo();
		if(arrayImoveis[67] != null){

			pocoTipo.setId((Integer) arrayImoveis[67]);
			imovel.setPocoTipo(pocoTipo);
		}

		// //instancia um hidrometro instalação historico para
		// ser colocado no imovel
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel = new HidrometroInstalacaoHistorico();
		if(arrayImoveis[9] != null){

			hidrometroInstalacaoHistoricoImovel.setId((Integer) arrayImoveis[9]);

			MedicaoTipo medicaoTipo = new MedicaoTipo();
			medicaoTipo.setId((Integer) arrayImoveis[27]);

			hidrometroInstalacaoHistoricoImovel.setMedicaoTipo(medicaoTipo);

			if(arrayImoveis[36] != null){
				Hidrometro hidrometro = new Hidrometro();
				hidrometro.setNumero((String) arrayImoveis[36]);
				if(arrayImoveis[62] != null){
					hidrometro.setNumeroDigitosLeitura((Short) arrayImoveis[62]);
				}else{
					hidrometro.setNumeroDigitosLeitura(Util.obterShort("1"));
				}
				hidrometroInstalacaoHistoricoImovel.setHidrometro(hidrometro);
			}

			if(arrayImoveis[41] != null){
				HidrometroLocalInstalacao hidrometroLocalInstalacao = new HidrometroLocalInstalacao();
				hidrometroLocalInstalacao.setDescricao((String) arrayImoveis[41]);
				hidrometroInstalacaoHistoricoImovel.setHidrometroLocalInstalacao(hidrometroLocalInstalacao);
			}

			if(arrayImoveis[69] != null){

				hidrometroInstalacaoHistoricoImovel.setDataInstalacao((Date) arrayImoveis[69]);
			}

			imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoImovel);

		}
		// instancia a rota
		Rota rotaImovel = new Rota();

		if(arrayImoveis[10] != null){
			// seta o id da rota
			rotaImovel.setId((Integer) arrayImoveis[10]);
		}

		if(arrayImoveis[43] != null){
			Leiturista leiturista = new Leiturista();
			leiturista.setId((Integer) arrayImoveis[43]);
			rotaImovel.setLeiturista(leiturista);
		}

		if(arrayImoveis[11] != null){
			// seta o indicador fiscalizador suprimido na rota
			rotaImovel.setIndicadorFiscalizarSuprimido(Short.parseShort(arrayImoveis[11].toString()));
		}

		if(arrayImoveis[12] != null){
			// seta o indicador fiscalizador cortado na rota
			rotaImovel.setIndicadorFiscalizarCortado(Short.parseShort(arrayImoveis[12].toString()));
		}

		if(arrayImoveis[13] != null){
			// seta o indicador gerar fiscalizacao na rota
			rotaImovel.setIndicadorGerarFiscalizacao(Short.parseShort(arrayImoveis[13].toString()));
		}

		if(arrayImoveis[14] != null){
			// seta o indicador fgerar falsa faixa na rota
			rotaImovel.setIndicadorGerarFalsaFaixa(Short.parseShort(arrayImoveis[14].toString()));
		}

		if(arrayImoveis[15] != null){
			// seta o percentual geracao fiscalizacao na rota
			rotaImovel.setPercentualGeracaoFiscalizacao((BigDecimal) (arrayImoveis[15]));
		}

		if(arrayImoveis[16] != null){
			// seta o percentual geracao faixa falsa na rota
			rotaImovel.setPercentualGeracaoFaixaFalsa((BigDecimal) (arrayImoveis[16]));
		}

		if(arrayImoveis[35] != null){
			// seta o codigo da rota
			rotaImovel.setCodigo((Short) (arrayImoveis[35]));
		}

		// instancia a empresa
		Empresa empresa = new Empresa();
		if(arrayImoveis[17] != null){
			// seta o id na empresa
			empresa.setId((Integer) arrayImoveis[17]);
		}

		if(arrayImoveis[18] != null){
			// seta a descrição abreviada na empresa
			empresa.setDescricaoAbreviada(arrayImoveis[18].toString());
		}

		if(arrayImoveis[19] != null){
			// seta email da empresa
			empresa.setEmail(arrayImoveis[19].toString());
		}

		// seta a empresa na rota
		rotaImovel.setEmpresa(empresa);
		// instancia o faturamento
		FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
		if(arrayImoveis[20] != null){
			// seta o id no faturamentGrupo
			faturamentoGrupo.setId((Integer) arrayImoveis[20]);

		}
		if(arrayImoveis[21] != null){
			// seta o descrição no faturamentGrupo
			faturamentoGrupo.setDescricao((String) arrayImoveis[21]);
		}

		if(arrayImoveis[73] != null){
			// seta o descrição no faturamentGrupo
			faturamentoGrupo.setAnoMesReferencia((Integer) arrayImoveis[73]);
		}
		// seta o faturamento na rota
		rotaImovel.setFaturamentoGrupo(faturamentoGrupo);
		if(arrayImoveis[22] != null){
			// instancia a ligação esgoto situação
			LeituraTipo leituraTipo = new LeituraTipo();
			// seta o id na ligação esgoto situação
			leituraTipo.setId((Integer) arrayImoveis[22]);
			// seta a ligação esgoto situação no imovel
			rotaImovel.setLeituraTipo(leituraTipo);
		}

		// seta a rota na quadra
		quadra.setRota(rotaImovel);
		// seta a quadra no imovel
		imovel.setQuadra(quadra);
		imovel.setRota(rotaImovel);
		if(arrayImoveis[23] != null){
			// instancia a ligação agua situação
			LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
			// seta o id na ligação agua situação
			ligacaoAguaSituacao.setId((Integer) arrayImoveis[23]);
			ligacaoAguaSituacao.setDescricao((String) arrayImoveis[31]);
			ligacaoAguaSituacao.setIndicadorFaturamentoSituacao((Short) arrayImoveis[37]);

			// seta a ligação agua situação no imovel
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		}
		if(arrayImoveis[24] != null){
			// instancia a ligação esgoto situação
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
			// seta o id na ligação esgoto situação
			ligacaoEsgotoSituacao.setId((Integer) arrayImoveis[24]);
			ligacaoEsgotoSituacao.setIndicadorFaturamentoSituacao((Short) arrayImoveis[38]);
			// seta a ligação esgoto situação no imovel
			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
		}

		if(arrayImoveis[25] != null){
			// instancia o faturamento situacao tipo
			FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
			// seta o id no faturamento situacao tipo
			faturamentoSituacaoTipo.setIndicadorParalisacaoLeitura((Short) arrayImoveis[25]);
			// seta a ligação esgoto situação no imovel
			imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
		}

		if(arrayImoveis[28] != null){
			// instancia o gerencia regional
			GerenciaRegional gerenciaRegional = new GerenciaRegional();

			// seta o id no faturamento situacao tipo
			gerenciaRegional.setId((Integer) arrayImoveis[28]);
			gerenciaRegional.setNome((String) arrayImoveis[29]);

			// seta a ligação esgoto situação no imovel
			imovel.getLocalidade().setGerenciaRegional(gerenciaRegional);
		}

		if(arrayImoveis[39] != null){
			imovel.setNumeroSegmento((Short) arrayImoveis[39]);
		}

		/*
		 * if(arrayImoveis[42] != null){
		 * Integer idRota = (Integer) arrayImoveis[42];
		 * Rota rota = new Rota();
		 * rota.setId(idRota);
		 * imovel.setRota(rota);
		 * }
		 */

		if(arrayImoveis[44] != null){
			ConsumoTarifa consumoTarifa = new ConsumoTarifa();
			consumoTarifa.setId((Integer) arrayImoveis[44]);
			imovel.setConsumoTarifa(consumoTarifa);
		}

		if(arrayImoveis[57] != null){
			LogradouroBairro logBairro = new LogradouroBairro();
			logBairro.setId((Integer) arrayImoveis[57]);

			if(arrayImoveis[45] != null){
				Logradouro logradouro = new Logradouro();
				logradouro.setId((Integer) arrayImoveis[45]);
				if(arrayImoveis[46] != null){
					logradouro.setNome((String) arrayImoveis[46]);
				}
				logBairro.setLogradouro(logradouro);
			}
			if(arrayImoveis[47] != null){
				Bairro bairro = new Bairro();
				bairro.setId((Integer) arrayImoveis[47]);
				if(arrayImoveis[48] != null){
					bairro.setNome((String) arrayImoveis[48]);
				}
				if(arrayImoveis[55] != null){
					Municipio municipio = new Municipio();
					municipio.setId((Integer) arrayImoveis[55]);
					if(arrayImoveis[56] != null){
						municipio.setNome((String) arrayImoveis[56]);
					}
					if(arrayImoveis[52] != null){
						UnidadeFederacao unidadeFederacao = new UnidadeFederacao();
						unidadeFederacao.setId((Integer) arrayImoveis[52]);
						if(arrayImoveis[53] != null){
							unidadeFederacao.setDescricao((String) arrayImoveis[53]);
						}
						if(arrayImoveis[54] != null){
							unidadeFederacao.setSigla((String) arrayImoveis[54]);
						}
						municipio.setUnidadeFederacao(unidadeFederacao);
					}
					bairro.setMunicipio(municipio);
				}
				logBairro.setBairro(bairro);
			}

			imovel.setLogradouroBairro(logBairro);
		}

		EnderecoReferencia enderecoReferencia = null;
		if(arrayImoveis[49] != null){
			enderecoReferencia = new EnderecoReferencia();
			enderecoReferencia.setId((Integer) arrayImoveis[49]);
			if(arrayImoveis[50] != null){
				enderecoReferencia.setDescricao((String) arrayImoveis[50]);
			}
			imovel.setEnderecoReferencia(enderecoReferencia);
		}

		if(arrayImoveis[58] != null){
			LogradouroCep logradouroCep = new LogradouroCep();
			logradouroCep.setId((Integer) arrayImoveis[58]);
			if(arrayImoveis[59] != null){
				Logradouro logradouro = new Logradouro();
				logradouro.setId((Integer) arrayImoveis[59]);
				if(arrayImoveis[60] != null){
					logradouro.setNome((String) arrayImoveis[60]);
				}
				if(arrayImoveis[71] != null){
					LogradouroTitulo logradouroTitulo = new LogradouroTitulo();
					logradouroTitulo.setDescricao((String) arrayImoveis[71]);

					logradouro.setLogradouroTitulo(logradouroTitulo);
				}
				if(arrayImoveis[72] != null){
					LogradouroTipo logradouroTipo = new LogradouroTipo();
					logradouroTipo.setDescricao((String) arrayImoveis[72]);

					logradouro.setLogradouroTipo(logradouroTipo);
				}

				logradouroCep.setLogradouro(logradouro);

				if(arrayImoveis[55] != null){
					Municipio municipio = new Municipio();
					municipio.setId((Integer) arrayImoveis[55]);
					if(arrayImoveis[56] != null){
						municipio.setNome((String) arrayImoveis[56]);
					}
					if(arrayImoveis[52] != null){
						UnidadeFederacao unidadeFederacao = new UnidadeFederacao();
						unidadeFederacao.setId((Integer) arrayImoveis[52]);
						if(arrayImoveis[53] != null){
							unidadeFederacao.setDescricao((String) arrayImoveis[53]);
						}
						if(arrayImoveis[54] != null){
							unidadeFederacao.setSigla((String) arrayImoveis[54]);
						}
						municipio.setUnidadeFederacao(unidadeFederacao);
					}
					logradouro.setMunicipio(municipio);
				}
			}
			if(arrayImoveis[51] != null){
				Cep cep = new Cep();
				cep.setCodigo((Integer) arrayImoveis[51]);
				logradouroCep.setCep(cep);
			}
			imovel.setLogradouroCep(logradouroCep);
		}

		if(arrayImoveis[70] != null){

			imovel.setNumeroImovel((String) arrayImoveis[70]);
		}

		return imovel;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * [SB0006] – Seleção imóveis para Faturamento
	 * 
	 * @param anoMesReferencia
	 *            [obrigatório] utilizado no consulta das Situações de
	 *            Faturamento do Imóvel.
	 * @param Imovel
	 *            [obrigatório]
	 * @return true se eh valido,false se não for
	 * @author Rafael Francisco Pinto
	 * @date 19/01/2007
	 * @author eduardo henrique
	 * @throws ControladorException
	 *             se pesquisa de Situações de Faturamento falhar
	 * @date 05/09/2008 Alterado para método ser chamada de todos os tipos de
	 *       geração de dados para Leitura, já que regras são comuns a todos os
	 *       tipos.
	 * @throws ControladorException
	 */
	protected boolean selecionarImovelParaFaturamento(Imovel imovel, Integer anoMesReferencia,
					Collection colecaoFaturamentoAtividadeCriterio) throws ControladorException{

		boolean achouImovel = false;

		// [FS0002] - Verificar situação especial de faturamento
		// caso no imovel o faturamento situação grupo seja diferente de nulo e
		// igual a leitura
		// não realizada então não seleciona o imovel caso contrario seleciona.
		// caso no imovel o faturamento situação grupo seja diferente de nulo e
		// igual a leitura
		// não realizada então não seleciona o imovel caso contrario seleciona.
		if(imovel.getFaturamentoSituacaoTipo() != null){
			// Verifica se há situação especial para o Imóvel em vigência
			Collection<FaturamentoSituacaoHistorico> situacoesVigentesImovel = getControladorFaturamento()
							.pesquisarFaturamentoSituacaoHistoricoImovel(imovel.getId(), anoMesReferencia);
			if(situacoesVigentesImovel != null){ // Caso alguma situação
				// vigente indique
				// paralisação
				// de leitura, retorna falso
				for(FaturamentoSituacaoHistorico faturamentoSituacaoHistorico : situacoesVigentesImovel){
					if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo() != null
									&& FaturamentoSituacaoTipo.INDICADOR_PARALIZACAO_LEITURA_NAO_REALIZADA
													.equals(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
																	.getIndicadorParalisacaoLeitura())){
						return false;
					}
				}
			}
		}

		achouImovel = verificarCorrespondenciaFaturamentoAtividadeCriterioEImovel(imovel, colecaoFaturamentoAtividadeCriterio);

		return achouImovel;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * [SB0006] – Seleção imóveis para Faturamento
	 * 
	 * @param anoMesReferencia
	 *            [obrigatório] utilizado no consulta das Situações de
	 *            Faturamento do Imóvel.
	 * @param Imovel
	 *            [obrigatório]
	 * @return true se eh valido,false se não for
	 * @author Rafael Francisco Pinto
	 * @date 19/01/2007
	 * @author eduardo henrique
	 * @throws ControladorException
	 *             se pesquisa de Situações de Faturamento falhar
	 * @date 05/09/2008 Alterado para método ser chamada de todos os tipos de
	 *       geração de dados para Leitura, já que regras são comuns a todos os
	 *       tipos.
	 * @throws ControladorException
	 * @deprecated
	 */
	public boolean validarImovelGerarDadosLeituraTxt(Imovel imovel, Integer anoMesReferencia, Collection colecaoFaturamentoAtividadeCriterio)
					throws ControladorException{

		boolean achouImovel = false;

		// [FS0002] - Verificar situação especial de faturamento
		// caso no imovel o faturamento situação grupo seja diferente de nulo e
		// igual a leitura
		// não realizada então não seleciona o imovel caso contrario seleciona.
		// caso no imovel o faturamento situação grupo seja diferente de nulo e
		// igual a leitura
		// não realizada então não seleciona o imovel caso contrario seleciona.
		if(imovel.getFaturamentoSituacaoTipo() != null){
			// Verifica se há situação especial para o Imóvel em vigência
			Collection<FaturamentoSituacaoHistorico> situacoesVigentesImovel = getControladorFaturamento()
							.pesquisarFaturamentoSituacaoHistoricoImovel(imovel.getId(), anoMesReferencia);
			if(situacoesVigentesImovel != null){ // Caso alguma situação
				// vigente indique
				// paralisação
				// de leitura, retorna falso
				for(FaturamentoSituacaoHistorico faturamentoSituacaoHistorico : situacoesVigentesImovel){
					if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo() != null
									&& FaturamentoSituacaoTipo.INDICADOR_PARALIZACAO_LEITURA_NAO_REALIZADA
													.equals(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
																	.getIndicadorParalisacaoLeitura())){
						return false;
					}
				}
			}
		}

		achouImovel = verificarCorrespondenciaFaturamentoAtividadeCriterioEImovel(imovel, colecaoFaturamentoAtividadeCriterio);

		return achouImovel;
	}

	/**
	 * Método que retorna o consumo de ligacao da agua ou esgoto (tipo passado)
	 * de um imovel em um determinado anoMes do faturamento. Método utilizado
	 * pra saber a ligacao de 2.2.2.2 e 2.2.3.2 do [UC0103] Efetuar Rateio de
	 * Consumo
	 * 
	 * @author Sávio Luiz
	 * @date 07/04/2006
	 * @param idImovel
	 * @param anoMes
	 * @param idLigacaoTipo
	 *            podendo ser agua ou esgoto
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterConsumoAnteriorAnormalidadeDoImovel(Integer idImovel, Integer anoMes, Integer idLigacaoTipo)
					throws ControladorException{

		Object[] parmsConsumoHistorico = null;

		try{

			parmsConsumoHistorico = repositorioMicromedicao.obterConsumoAnteriorAnormalidadeDoImovel(idImovel, anoMes, idLigacaoTipo);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return parmsConsumoHistorico;
	}

	/*
	 * Utilizado pelo caso de uso Substituir COnsumos anteriores
	 */
	public void atualizarConsumosMedio(Integer idImovel, Integer anoMesGrupoFaturamento, int consumoMedioImovel,
					int consumoMedioHidrometroAgua, int consumoMedioHidrometroEsgoto, Usuario usuario){

		try{

			ConsumoHistorico consumoHistorico = new ConsumoHistorico();

			Collection colecaoConsumo = new ArrayList();

			FiltroConsumoHistorico filtroConsumoHistorico = new FiltroConsumoHistorico();
			filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANO_MES_FATURAMENTO,
							anoMesGrupoFaturamento));
			filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, idImovel));

			colecaoConsumo = getControladorUtil().pesquisar(filtroConsumoHistorico, ConsumoHistorico.class.getName());

			if(colecaoConsumo.isEmpty()){
				anoMesGrupoFaturamento = Util.subtrairMesDoAnoMes(anoMesGrupoFaturamento, 1);

				filtroConsumoHistorico = new FiltroConsumoHistorico();
				filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANO_MES_FATURAMENTO,
								anoMesGrupoFaturamento));
				filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, idImovel));

				colecaoConsumo = getControladorUtil().pesquisar(filtroConsumoHistorico, ConsumoHistorico.class.getName());
				consumoHistorico = (ConsumoHistorico) Util.retonarObjetoDeColecao(colecaoConsumo);
				consumoHistorico.setConsumoMedio(consumoMedioImovel);
			}else{

				colecaoConsumo = getControladorUtil().pesquisar(filtroConsumoHistorico, ConsumoHistorico.class.getName());
				consumoHistorico = (ConsumoHistorico) Util.retonarObjetoDeColecao(colecaoConsumo);
				consumoHistorico.setConsumoMedio(consumoMedioImovel);

			}

			consumoHistorico.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_SUBSTITUIR_CONSUMOS_ANTERIORES,
							new UsuarioAcaoUsuarioHelper(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_SUBSTITUIR_CONSUMOS_ANTERIORES);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			consumoHistorico.setOperacaoEfetuada(operacaoEfetuada);
			consumoHistorico.adicionarUsuario(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(consumoHistorico);
			getControladorTransacao().registrarTransacao(consumoHistorico);
			// -----------------------------------------------------------------

			FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();
			filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO,
							anoMesGrupoFaturamento));
			filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, idImovel));

			MedicaoHistorico medicaoHistorico = (MedicaoHistorico) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(
							filtroMedicaoHistorico, MedicaoHistorico.class.getName()));

			if(medicaoHistorico != null){

				if(consumoMedioHidrometroAgua != 0){
					medicaoHistorico.setConsumoMedioHidrometro(consumoMedioHidrometroAgua);
				}else{
					medicaoHistorico.setConsumoMedioHidrometro(consumoMedioHidrometroEsgoto);
				}

				medicaoHistorico.setUltimaAlteracao(new Date());

				// ------------ REGISTRAR TRANSAÇÃO ------------
				operacaoEfetuada.setOperacao(operacao);
				medicaoHistorico.setOperacaoEfetuada(operacaoEfetuada);
				medicaoHistorico.adicionarUsuario(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(medicaoHistorico);
				getControladorTransacao().registrarTransacao(medicaoHistorico);
				// -----------------------------------------------------------------
			}

			repositorioMicromedicao.atualizarConsumosMedio(idImovel, anoMesGrupoFaturamento, consumoMedioImovel,
							consumoMedioHidrometroAgua, consumoMedioHidrometroEsgoto);

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(ControladorException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Pesquisa todas as rotas do sistema. Metódo usado no [UC0302] Gerar Débito
	 * a Cobrar de Acréscimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 20/03/2007
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarListaRotasCarregadas() throws ControladorException{

		Collection retorno = null;

		try{

			retorno = repositorioMicromedicao.pesquisarListaRotasCarregadas();

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC0105] Obter Consumo Mínimo da Ligação por Subcategoria
	 * 
	 * @author Raphael Rossiter
	 * @date 11/04/2007
	 * @return imovel, colecaoSubcategoria
	 * @throws ControladorException
	 */
	/*
	 * public int obterConsumoMinimoLigacaoPorSubcategoria(Imovel imovel,
	 * Collection colecaoSubcategoria) throws ControladorException { int
	 * consumoMinimoLigacao = 0; Collection colecaoDataVigencia = null; Integer
	 * consumoMinimo = null; // Obtém o id do consumo tarifa vigência da maior
	 * data de vigência da // tarifa do imóvel try { colecaoDataVigencia =
	 * repositorioMicromedicao
	 * .pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(), imovel); }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } // Obtém o id do array e
	 * atribui na variável Object[] consumoTarifaVigenciaIdArray = (Object[])
	 * Util .retonarObjetoDeColecaoArray(colecaoDataVigencia); Integer
	 * consumoTarifaVigenciaId = null; if (consumoTarifaVigenciaIdArray == null)
	 * { throw new ControladorException(
	 * "erro.nao_cadastrada_consumo_tarifa_vigencia", null, String
	 * .valueOf(imovel.getId())); } if (consumoTarifaVigenciaIdArray[0] != null)
	 * { consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0]; }
	 * // Cria o objeto consumo tarifa vigência e seta o id
	 * ConsumoTarifaVigencia consumoTarifaVigencia = new
	 * ConsumoTarifaVigencia();
	 * consumoTarifaVigencia.setId(consumoTarifaVigenciaId); // Obter Quantidade
	 * de Economias por Subcategoria if (colecaoSubcategoria == null) {
	 * colecaoSubcategoria = getControladorImovel()
	 * .obterQuantidadeEconomiasSubCategoria(imovel.getId()); } Iterator
	 * colecaoSubcategoriaIterator = colecaoSubcategoria.iterator(); while
	 * (colecaoSubcategoriaIterator.hasNext()) { Subcategoria subcategoria =
	 * (Subcategoria) colecaoSubcategoriaIterator .next(); try { // Obtém o
	 * consumo mínimo da tarifa da categoria do imóvel Object
	 * consumoMinimoObjeto = repositorioMicromedicao
	 * .pesquisarConsumoMinimoTarifaSubcategoriaVigencia( subcategoria,
	 * consumoTarifaVigencia); consumoMinimo = (Integer) consumoMinimoObjeto; }
	 * catch (ErroRepositorioException ex) { sessionContext.setRollbackOnly();
	 * throw new ControladorException("erro.sistema", ex); } /* Caso não exista tarifa
	 * cadastrada para a subcategoria em questao, utilizar a tarifa da categoria
	 */
	/*
	 * if (consumoMinimo == null) { Categoria categoria =
	 * subcategoria.getCategoria();
	 * categoria.setQuantidadeEconomiasCategoria(subcategoria
	 * .getQuantidadeEconomias()); Collection colecaoCategoria = new
	 * ArrayList(); colecaoCategoria.add(categoria); consumoMinimo =
	 * this.obterConsumoMinimoLigacao(imovel, colecaoCategoria); /* throw new
	 * ControladorException( "erro.nao_cadastrada_consumo_tarifa_categoria",
	 * null, subcategoria.getDescricao());
	 */

	/*
	 * } // Multiplica a quantidade de economias da categoria pelo consumo //
	 * mínimo e acumula consumoMinimoLigacao = consumoMinimoLigacao +
	 * (subcategoria.getQuantidadeEconomias().intValue() * consumoMinimo
	 * .intValue()); } // Retorna o consumo mínimo da ligação return
	 * consumoMinimoLigacao; }
	 */

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades [SB0001] - Gerar Relatório
	 * Resumo das Leituras e Anormalidades Pesquisa as Anormalidades de Leitura
	 * e suas quantidades
	 * 
	 * @author Rafael Corrêa
	 * @date 13/04/2007
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarAnormalidadesRelatorioComparativoLeiturasEAnormalidades(Integer idGrupoFaturamento, Integer idEmpresa,
					Integer anoMes) throws ControladorException{

		Collection retorno = new ArrayList();

		try{
			Collection colecaoObjetos = repositorioMicromedicao.pesquisarAnormalidadesRelatorioComparativoLeiturasEAnormalidades(
							idGrupoFaturamento, idEmpresa, anoMes);

			if(!colecaoObjetos.isEmpty()){

				Iterator iterator = colecaoObjetos.iterator();
				while(iterator.hasNext()){
					Object[] objeto = (Object[]) iterator.next();

					AnormalidadeLeituraHelper anormalidadeLeituraHelper = new AnormalidadeLeituraHelper();

					// id
					if(objeto[0] != null){
						anormalidadeLeituraHelper.setIdAnormalidadeLeitura((Integer) objeto[0]);
					}

					// descricao
					if(objeto[1] != null){
						anormalidadeLeituraHelper.setDescricaoAnormalidadeLeitura((String) objeto[1]);
					}

					// Id do Grupo de Faturamento
					if(objeto[2] != null){
						anormalidadeLeituraHelper.setIdGrupoFaturamento((Integer) objeto[2]);
					}

					// Id da Empresa
					if(objeto[3] != null){
						anormalidadeLeituraHelper.setIdEmpresa((Integer) objeto[3]);
					}

					// Descrição da Empresa
					if(objeto[4] != null){
						anormalidadeLeituraHelper.setNomeEmpresa((String) objeto[4]);
					}

					// qtd
					if(objeto[5] != null){
						anormalidadeLeituraHelper.setQuantidade((Integer) objeto[5]);
					}

					retorno.add(anormalidadeLeituraHelper);
				}
			}

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [UC0082] - Registrar Leituras e Anormalidades [SB0001] - Gerar Relatório
	 * Resumo das Leituras e Anormalidades Pesquisa os dados do relatório do
	 * comparativo de leituras e anormalidades
	 * 
	 * @author Rafael Corrêa
	 * @date 13/04/2007
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarDadosRelatorioComparativoLeiturasEAnormalidades(Integer idGrupoFaturamento, Integer idEmpresa, Integer anoMes)
					throws ControladorException{

		Collection retorno = new ArrayList();

		try{
			Collection colecaoObjetos = repositorioMicromedicao.pesquisarDadosRelatorioComparativoLeiturasEAnormalidades(
							idGrupoFaturamento, idEmpresa, anoMes);

			if(!colecaoObjetos.isEmpty()){

				Iterator iterator = colecaoObjetos.iterator();
				while(iterator.hasNext()){
					Object[] objeto = (Object[]) iterator.next();

					ComparativoLeiturasEAnormalidadesRelatorioHelper comparativoLeiturasEAnormalidadesRelatorioHelper = new ComparativoLeiturasEAnormalidadesRelatorioHelper();

					// id localidade
					if(objeto[0] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setIdLocalidade((Integer) objeto[0]);
					}

					// id setor comercial
					if(objeto[1] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setIdSetorComercial((Integer) objeto[1]);
					}

					// código setor comercial
					if(objeto[2] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setCodigoSetorComercial((Integer) objeto[2]);
					}

					// id grupo de faturamento
					if(objeto[3] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setIdGrupoFaturamento((Integer) objeto[3]);
					}

					// id empresa
					if(objeto[4] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setIdEmpresa((Integer) objeto[4]);
					}

					// nome empresa
					if(objeto[5] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setNomeEmpresa((String) objeto[5]);
					}

					// registros recebidos
					if(objeto[6] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setRegistrosRecebidos((Integer) objeto[6]);
					}

					// registros c/ leitura
					if(objeto[7] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setRegistrosComLeitura((Integer) objeto[7]);
					}

					// registros c/ anormalidade
					if(objeto[8] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setRegistrosComAnormalidade((Integer) objeto[8]);
					}

					// registros c/ leitura e anormalidade
					if(objeto[9] != null){
						comparativoLeiturasEAnormalidadesRelatorioHelper.setRegistrosComLeituraEAnormalidade((Integer) objeto[9]);
					}

					retorno.add(comparativoLeiturasEAnormalidadesRelatorioHelper);
				}
			}

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [UC0613] - Registrar Leituras e Anormalidades Pesquisa os imóveis com
	 * faixa falsa
	 * 
	 * @author Rafael Corrêa
	 * @date 18/06/2007
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarImovelFaixaFalsa(Integer anoMesReferencia) throws ControladorException{

		Collection retorno = new ArrayList();

		try{
			Collection colecaoDados = repositorioMicromedicao.pesquisarImovelFaixaFalsa(anoMesReferencia);

			if(!colecaoDados.isEmpty()){

				Iterator colecaoDadosIterator = colecaoDados.iterator();
				while(colecaoDadosIterator.hasNext()){
					Object[] dados = (Object[]) colecaoDadosIterator.next();

					FaixasFalsasLeituraRelatorioHelper faixasFalsasLeituraRelatorioHelper = new FaixasFalsasLeituraRelatorioHelper();

					// Id Grupo de Faturamento
					if(dados[0] != null){
						faixasFalsasLeituraRelatorioHelper.setIdGrupoFaturamento((Integer) dados[0]);
					}

					// Descrição Grupo de Faturamento
					if(dados[1] != null){
						faixasFalsasLeituraRelatorioHelper.setDescricaoGrupoFaturamento((String) dados[1]);
					}

					// Id da Empresa
					if(dados[2] != null){
						faixasFalsasLeituraRelatorioHelper.setIdEmpresa((Integer) dados[2]);
					}

					// Nome da Empresa
					if(dados[3] != null){
						faixasFalsasLeituraRelatorioHelper.setNomeEmpresa((String) dados[3]);
					}

					// Id da Localidade
					if(dados[4] != null){
						faixasFalsasLeituraRelatorioHelper.setIdLocalidade((Integer) dados[4]);
					}

					// Nome da Localidade
					if(dados[5] != null){
						faixasFalsasLeituraRelatorioHelper.setNomeLocalidade((String) dados[5]);
					}

					// Id do Setor Comercial
					if(dados[6] != null){
						faixasFalsasLeituraRelatorioHelper.setIdSetorComercial((Integer) dados[6]);
					}

					// Código do Setor Comercial
					if(dados[7] != null){
						faixasFalsasLeituraRelatorioHelper.setCodigoSetorComercial((Integer) dados[7]);
					}

					// Nome do Setor Comercial
					if(dados[8] != null){
						faixasFalsasLeituraRelatorioHelper.setNomeSetorComercial((String) dados[8]);
					}

					// Faixa Falsa Inferior
					if(dados[9] != null){
						faixasFalsasLeituraRelatorioHelper.setFaixaFalsaInferior((Integer) dados[9]);
					}

					// Leitura Atual
					if(dados[10] != null){
						faixasFalsasLeituraRelatorioHelper.setLeituraAtual((Integer) dados[10]);
					}

					// Faixa Falsa Superior
					if(dados[11] != null){
						faixasFalsasLeituraRelatorioHelper.setFaixaFalsaSuperior((Integer) dados[11]);
					}

					// Número da Quadra
					if(dados[12] != null){
						faixasFalsasLeituraRelatorioHelper.setNumeroQuadra((Integer) dados[12]);
					}

					// Lote
					if(dados[13] != null){
						faixasFalsasLeituraRelatorioHelper.setLote((Short) dados[13]);
					}

					// Sublote
					if(dados[14] != null){
						faixasFalsasLeituraRelatorioHelper.setSublote((Short) dados[14]);
					}

					// Id do Imóvel
					if(dados[15] != null){
						faixasFalsasLeituraRelatorioHelper.setIdImovel((Integer) dados[15]);
					}

					// Id do Leiturista
					if(dados[16] != null){
						faixasFalsasLeituraRelatorioHelper.setIdLeiturista((Integer) dados[16]);
					}

					// Faixa Correta Inferior
					if(dados[17] != null){
						faixasFalsasLeituraRelatorioHelper.setFaixaCorretaInferior((Integer) dados[17]);
					}

					// Faixa Correta Superior
					if(dados[18] != null){
						faixasFalsasLeituraRelatorioHelper.setFaixaCorretaSuperior((Integer) dados[18]);
					}

					// Data da Leitura
					if(dados[19] != null){
						faixasFalsasLeituraRelatorioHelper.setDataLeitura((Date) dados[19]);
					}

					// Descrição da Anormalidade de Leitura
					if(dados[20] != null){
						faixasFalsasLeituraRelatorioHelper.setDescricaoLeituraAnormalidade((String) dados[20]);
					}else{
						faixasFalsasLeituraRelatorioHelper.setDescricaoLeituraAnormalidade("");
					}

					// Descrição da Situação da Leitura
					if(dados[21] != null){
						faixasFalsasLeituraRelatorioHelper.setDescricaoSituacaoLeitura((String) dados[21]);
					}else{
						faixasFalsasLeituraRelatorioHelper.setDescricaoSituacaoLeitura("");
					}

					retorno.add(faixasFalsasLeituraRelatorioHelper);
				}
			}

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [UC0613] - Registrar Leituras e Anormalidades Retorna a quantidade de
	 * imóveis com faixa falsa
	 * 
	 * @author Rafael Corrêa
	 * @date 18/06/2007
	 * @return Collection
	 * @throws ControladorException
	 */
	public Integer pesquisarImovelFaixaFalsaCount(Integer anoMesReferencia) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarImovelFaixaFalsaCount(anoMesReferencia);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0100] Informar Leitura de Fiscalização
	 * 
	 * @author Rômulo Aurélio
	 * @date 19/05/2007
	 * @return
	 * @throws ControladorException
	 */

	public void informarLeituraFiscalizacao(Usuario usuarioLogado, LeituraFiscalizacao leituraFiscalizacao) throws ControladorException{

		/**
		 * Registrar Transacao
		 */

		// ------------ REGISTRAR TRANSAÇÃO ----------------

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_LEITURA_FISCALIZACAO_INFORMAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_LEITURA_FISCALIZACAO_INFORMAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		leituraFiscalizacao.setOperacaoEfetuada(operacaoEfetuada);
		leituraFiscalizacao.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(leituraFiscalizacao);
		getControladorTransacao().registrarTransacao(leituraFiscalizacao);

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		leituraFiscalizacao.setUltimaAlteracao(new Date());

		FiltroLeituraFiscalizacao filtroLeituraFiscalizacao = new FiltroLeituraFiscalizacao();

		filtroLeituraFiscalizacao.adicionarParametro(new ParametroSimples(FiltroLeituraFiscalizacao.ID, leituraFiscalizacao
						.getMedicaoHistorico().getId()));

		Collection colecaoLeituraFiscalizacaoBase = getControladorUtil().pesquisar(filtroLeituraFiscalizacao,
						LeituraFiscalizacao.class.getName());

		if(colecaoLeituraFiscalizacaoBase != null && !colecaoLeituraFiscalizacaoBase.isEmpty()){

			LeituraFiscalizacao leituraFiscalizacaoBase = (LeituraFiscalizacao) colecaoLeituraFiscalizacaoBase.iterator().next();

			if(leituraFiscalizacaoBase.getUltimaAlteracao() != null && leituraFiscalizacao.getUltimaAlteracao() != null
							&& leituraFiscalizacaoBase.getUltimaAlteracao().after(leituraFiscalizacao.getUltimaAlteracao())){
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

			// leituraFiscalizacao.setId(leituraFiscalizacaoBase.getId());

			getControladorUtil().atualizar(leituraFiscalizacao);

		}else{

			getControladorUtil().inserir(leituraFiscalizacao);

		}

	}

	/**
	 * Permite inserir uma Anormalidade de Leitura [UC0190] Inserir Anormalidade
	 * Leitura
	 * 
	 * @author Thiago Tenório
	 * @date 30/03/2006
	 * @author eduardo henrique
	 * @date 16/06/2008
	 */
	public Integer inserirAnormalidadeLeitura(LeituraAnormalidade leituraAnormalidade, Usuario usuarioLogado) throws ControladorException{

		// A Descrição é obrigatório.
		if(leituraAnormalidade.getDescricao() == null || leituraAnormalidade.getDescricao().equalsIgnoreCase("")){
			throw new ControladorException("atencao.informe_campo", null, "Descrição");
		}

		// A Anormalidade Relativa a Hidrômetro é obrigatório.
		if(leituraAnormalidade.getIndicadorRelativoHidrometro() == null){
			throw new ControladorException("atencao.informe_campo", null, "Anormalidade Relativa a Hidrômetro");
		}

		// Consumo a Ser Cobrado (anormalidade informada e leitura não
		// informada)
		if(leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura() == null){
			throw new ControladorException("atencao.informe_campo", null,
							"Consumo a Ser Cobrado (anormalidade informada e leitura não informada)");
		}
		// Consumo a Ser Cobrado (anormalidade informada e leitura informada)
		if(leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura() == null){
			throw new ControladorException("atencao.informe_campo", null,
							"Consumo a Ser Cobrado (anormalidade informada e leitura informada)");
		}

		// Leitura para faturamento (anormalidade informada e leitura não
		// informada)
		if(leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura() == null){
			throw new ControladorException("atencao.informe_campo", null,
							"Leitura para faturamento (anormalidade informada e leitura não informada)");
		}

		// Leitura para faturamento (anormalidade informada e leitura informada)
		if(leituraAnormalidade.getLeituraAnormalidadeLeituraComleitura() == null){
			throw new ControladorException("atencao.informe_campo", null,
							"Leitura para faturamento (anormalidade informada e leitura informada)");
		}

		// Anormalidade Emite OS Automática é obrigatório.
		if(leituraAnormalidade.getIndicadorEmissaoOrdemServico() == null){
			throw new ControladorException("atencao.informe_campo", null, "Anormalidade Emite OS Automática");
		}

		// [FS0003]
		FiltroLeituraAnormalidade filtroAnormalidade = new FiltroLeituraAnormalidade();
		filtroAnormalidade.adicionarParametro(new ComparacaoTextoCompleto(FiltroLeituraAnormalidade.DESCRICAO, leituraAnormalidade
						.getDescricao()));

		Collection colecaoAnormalidades = getControladorUtil().pesquisar(filtroAnormalidade, LeituraAnormalidade.class.getName());
		if(colecaoAnormalidades != null && !colecaoAnormalidades.isEmpty()){
			// // levanta a exceção para a próxima camada
			throw new ControladorException("atencao.anormalidade_ja_existe_cadastro", null, leituraAnormalidade.getDescricao());
		}

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ANORMALIDADE_LEITURA_INSERIR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ANORMALIDADE_LEITURA_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		leituraAnormalidade.setOperacaoEfetuada(operacaoEfetuada);
		leituraAnormalidade.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(leituraAnormalidade);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Integer id = (Integer) getControladorUtil().inserir(leituraAnormalidade);

		return id;

	}

	/**
	 * [UC0191] Atualização de Anormalidade de Leitura
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * @author eduardo henrique
	 * @date 16/06/2008
	 * @param usuarioLogado
	 * @param AnormalidadeLeitura
	 * @throws ControladorException
	 */

	public void atualizarAnormalidadeLeitura(LeituraAnormalidade leituraAnormalidade, Usuario usuarioLogado) throws ControladorException{

		// Verifica se todos os campos obrigatorios foram preenchidos

		if((leituraAnormalidade.getDescricao() == null || leituraAnormalidade.getDescricao().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (leituraAnormalidade.getIndicadorRelativoHidrometro() == 0)
						&& (leituraAnormalidade.getIndicadorEmissaoOrdemServico() == 0)
						&& (leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura() == null || leituraAnormalidade
										.getLeituraAnormalidadeConsumoSemleitura().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura() == null || leituraAnormalidade
										.getLeituraAnormalidadeConsumoComleitura().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura() == null || leituraAnormalidade
										.getLeituraAnormalidadeLeituraSemleitura().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))

						&& (leituraAnormalidade.getLeituraAnormalidadeLeituraComleitura() == null || leituraAnormalidade
										.getLeituraAnormalidadeLeituraComleitura().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Descrição foi preenchido

		if(leituraAnormalidade.getDescricao() == null
						|| leituraAnormalidade.getDescricao().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Descrição");
		}

		// Verifica se o campo Indicador Relativo à Hidrômetro foi preenchido

		if(leituraAnormalidade.getIndicadorRelativoHidrometro() == 0
						|| leituraAnormalidade.getIndicadorRelativoHidrometro().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Anormalidade Relativa a Hidrômetro");
		}

		// Verifica se o campo Indicador de Emissão de OS
		if(leituraAnormalidade.getIndicadorEmissaoOrdemServico() == 0
						|| leituraAnormalidade.getIndicadorEmissaoOrdemServico().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Anormalidade Emissão Automática de OS");
		}

		// Garante que , caso a Emissão de OS Não seja Automática, não será
		// informado tipo de
		// serviço e nr. de Incidências
		if(leituraAnormalidade.getIndicadorEmissaoOrdemServico().shortValue() == 2){
			leituraAnormalidade.setServicoTipo(null);
			leituraAnormalidade.setNumeroIncidenciasGeracaoOrdemServico(null);
		}

		if(leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura() == null
						|| leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura()
										.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null,
							" Consumo a Ser Cobrado (anormalidade informada e leitura não informada)");
		}

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if(leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura() == null
						|| leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura()
										.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null,
							" Consumo a Ser Cobrado (anormalidade informada e leitura informada)");
		}

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if(leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura() == null
						|| leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura()
										.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null,
							" Leitura para faturamento (anormalidade informada e leitura não informada)");
		}

		// Verifica se o campo Indicador de Troca de Serviço foi preenchido

		if(leituraAnormalidade.getLeituraAnormalidadeLeituraComleitura() == null
						|| leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura()
										.equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null,
							" Leitura para faturamento (anormalidade informada e leitura não informada)");
		}

		FiltroLeituraAnormalidade filtroAnormalidade = new FiltroLeituraAnormalidade();
		filtroAnormalidade.adicionarParametro(new ComparacaoTextoCompleto(FiltroLeituraAnormalidade.DESCRICAO, leituraAnormalidade
						.getDescricao()));
		filtroAnormalidade.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroLeituraAnormalidade.ID, leituraAnormalidade.getId()));

		Collection colecaoAnormalidades = getControladorUtil().pesquisar(filtroAnormalidade, LeituraAnormalidade.class.getName());
		if(colecaoAnormalidades != null && !colecaoAnormalidades.isEmpty()){
			// // levanta a exceção para a próxima camada
			throw new ControladorException("atencao.anormalidade_ja_existe_cadastro", null, leituraAnormalidade.getDescricao());
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroLeituraAnormalidade filtroLeituraAnormalidade = new FiltroLeituraAnormalidade();
		filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(FiltroLeituraAnormalidade.ID, leituraAnormalidade.getId()));

		LeituraAnormalidade leituraBase = null;

		try{
			leituraBase = (LeituraAnormalidade) ((List) (repositorioUtil.pesquisar(filtroLeituraAnormalidade, LeituraAnormalidade.class
							.getName()))).get(0);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// Verificar se o hidrometro já foi atualizado por outro usuário
		// durante
		// esta atualização
		if(leituraBase.getUltimaAlteracao().after(leituraAnormalidade.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		leituraAnormalidade.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(leituraAnormalidade);

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ANORMALIDADE_LEITURA_ALTERAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ANORMALIDADE_LEITURA_ALTERAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		leituraAnormalidade.setOperacaoEfetuada(operacaoEfetuada);
		leituraAnormalidade.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(leituraAnormalidade);

	}

	/**
	 * Valida anoMes para caso de uso análise excecoes leituras Alteração no
	 * método para permitir que a data da leitura seja de um mês anterior à
	 * referência do faturamento.
	 * 
	 * @author Virgínia Melo
	 * @date 29/12/2008
	 */
	public boolean validaDataFaturamentoIncompativel(String anoMesReferencia, String anoMesAtual){

		boolean retorno = true;

		// String anoMesReferenciaMaisUmMes = "" + Util.somarData(new
		// Integer(anoMesReferencia));
		String anoMesReferenciaMenosUmMes = "" + Util.subtrairMesDoAnoMes(Integer.valueOf(anoMesReferencia), 1);

		if(!((Util.compararAnoMesReferencia(Integer.valueOf(anoMesReferencia), Integer.valueOf(anoMesAtual), "=")) || (Util
						.compararAnoMesReferencia(Integer.valueOf(anoMesReferenciaMenosUmMes), Integer.valueOf(anoMesAtual), "=")))){
			retorno = false;
		}

		return retorno;
	}

	/**
	 * Valida anoMes para caso de uso análise excecoes leituras Alterações no
	 * método para permitir que a data da leitura anterior seja de até 2 meses
	 * anteriores à referência do faturamento.
	 * 
	 * @author Virgínia Melo
	 * @date 29/12/2008
	 */
	public boolean validaDataFaturamentoIncompativelInferior(String anoMesReferencia, String anoMesAnterior){

		boolean retorno = true;

		String anoMesReferenciaMenosUmMes = "" + Util.subtrairMesDoAnoMes(Integer.valueOf(anoMesReferencia), 1);
		String anoMesReferenciaMenosDoisMeses = "" + Util.subtrairMesDoAnoMes(Integer.valueOf(anoMesReferencia), 2);

		// Comparando data com os dois meses anteriores.
		if(!((Util.compararAnoMesReferencia(Integer.valueOf(anoMesReferenciaMenosUmMes), Integer.valueOf(anoMesAnterior), "=")) || (Util
						.compararAnoMesReferencia(Integer.valueOf(anoMesReferenciaMenosDoisMeses), Integer.valueOf(anoMesAnterior), "=")))){
			retorno = false;
		}

		return retorno;
	}

	/**
	 * relatório de regitro atendimento
	 * 
	 * @author Vivianne Sousa
	 * @date 07/06/2007
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public AnaliseConsumoRelatorioOSHelper obterDadosAnaliseConsumo(Integer idImovel) throws ControladorException{

		AnaliseConsumoRelatorioOSHelper analiseConsumoRelatorioOSHelper = new AnaliseConsumoRelatorioOSHelper();
		Integer anoMes = null;
		try{
			anoMes = repositorioMicromedicao.obterMaxAMFaturamentoConsumoHistoricoDoImovel(idImovel);
		}catch(ErroRepositorioException e1){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e1);
		}

		if(anoMes != null){

			for(int qtdMeses = 0; qtdMeses <= 5; qtdMeses++){

				int anoMesSubtraido = Util.subtrairMesDoAnoMes(anoMes, qtdMeses);
				Object[] dadosConsumoHistoricoDoImovel = null;
				Object[] dadosMedicaoHistoricoDoImovel = null;

				try{
					dadosConsumoHistoricoDoImovel = repositorioMicromedicao.obterDadosConsumoHistoricoDoImovel(idImovel, anoMesSubtraido);
				}catch(ErroRepositorioException e){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}

				try{
					dadosMedicaoHistoricoDoImovel = repositorioMicromedicao.obterDadosMedicaoHistoricoDoImovel(idImovel, anoMesSubtraido);
				}catch(ErroRepositorioException e2){
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e2);
				}

				switch(qtdMeses){

					case 0:
						analiseConsumoRelatorioOSHelper.setAnoMesHistoricoConsumo1(Util.formatarAnoMesParaMesAno(anoMesSubtraido));
						if(dadosConsumoHistoricoDoImovel != null){
							if(dadosConsumoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setConsumoFaturado1("" + (Integer) dadosConsumoHistoricoDoImovel[0]);
							}
							if(dadosConsumoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setDescAbrevAnormalidadeConsumo1((String) dadosConsumoHistoricoDoImovel[1]);
							}
						}
						if(dadosMedicaoHistoricoDoImovel != null){
							if(dadosMedicaoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setDtLeituraAtualInformada1(Util
												.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
							}
							if(dadosMedicaoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setLeituraAtualInformada1("" + (Integer) dadosMedicaoHistoricoDoImovel[1]);
							}
						}
						break;

					case 1:
						analiseConsumoRelatorioOSHelper.setAnoMesHistoricoConsumo2(Util.formatarAnoMesParaMesAno(anoMesSubtraido));
						if(dadosConsumoHistoricoDoImovel != null){
							if(dadosConsumoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setConsumoFaturado2("" + (Integer) dadosConsumoHistoricoDoImovel[0]);
							}
							if(dadosConsumoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setDescAbrevAnormalidadeConsumo2((String) dadosConsumoHistoricoDoImovel[1]);
							}
						}
						if(dadosMedicaoHistoricoDoImovel != null){
							if(dadosMedicaoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setDtLeituraAtualInformada2(Util
												.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
							}
							if(dadosMedicaoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setLeituraAtualInformada2("" + (Integer) dadosMedicaoHistoricoDoImovel[1]);
							}
						}
						break;

					case 2:
						analiseConsumoRelatorioOSHelper.setAnoMesHistoricoConsumo3(Util.formatarAnoMesParaMesAno(anoMesSubtraido));
						if(dadosConsumoHistoricoDoImovel != null){
							if(dadosConsumoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setConsumoFaturado3("" + (Integer) dadosConsumoHistoricoDoImovel[0]);
							}
							if(dadosConsumoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setDescAbrevAnormalidadeConsumo3((String) dadosConsumoHistoricoDoImovel[1]);
							}
						}
						if(dadosMedicaoHistoricoDoImovel != null){
							if(dadosMedicaoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setDtLeituraAtualInformada3(Util
												.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
							}
							if(dadosMedicaoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setLeituraAtualInformada3("" + (Integer) dadosMedicaoHistoricoDoImovel[1]);
							}
						}
						break;

					case 3:
						analiseConsumoRelatorioOSHelper.setAnoMesHistoricoConsumo4(Util.formatarAnoMesParaMesAno(anoMesSubtraido));
						if(dadosConsumoHistoricoDoImovel != null){
							if(dadosConsumoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setConsumoFaturado4("" + (Integer) dadosConsumoHistoricoDoImovel[0]);
							}
							if(dadosConsumoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setDescAbrevAnormalidadeConsumo4((String) dadosConsumoHistoricoDoImovel[1]);
							}
						}
						if(dadosMedicaoHistoricoDoImovel != null){
							if(dadosMedicaoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setDtLeituraAtualInformada4(Util
												.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
							}
							if(dadosMedicaoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setLeituraAtualInformada4("" + (Integer) dadosMedicaoHistoricoDoImovel[1]);
							}
						}
						break;

					case 4:
						analiseConsumoRelatorioOSHelper.setAnoMesHistoricoConsumo5(Util.formatarAnoMesParaMesAno(anoMesSubtraido));
						if(dadosConsumoHistoricoDoImovel != null){
							if(dadosConsumoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setConsumoFaturado5("" + (Integer) dadosConsumoHistoricoDoImovel[0]);
							}
							if(dadosConsumoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setDescAbrevAnormalidadeConsumo5((String) dadosConsumoHistoricoDoImovel[1]);
							}
						}
						if(dadosMedicaoHistoricoDoImovel != null){
							if(dadosMedicaoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setDtLeituraAtualInformada5(Util
												.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
							}
							if(dadosMedicaoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setLeituraAtualInformada5("" + (Integer) dadosMedicaoHistoricoDoImovel[1]);
							}
						}
						break;

					case 5:
						analiseConsumoRelatorioOSHelper.setAnoMesHistoricoConsumo6(Util.formatarAnoMesParaMesAno(anoMesSubtraido));
						if(dadosConsumoHistoricoDoImovel != null){
							if(dadosConsumoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setConsumoFaturado6("" + (Integer) dadosConsumoHistoricoDoImovel[0]);
							}
							if(dadosConsumoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setDescAbrevAnormalidadeConsumo6((String) dadosConsumoHistoricoDoImovel[1]);
							}
						}
						if(dadosMedicaoHistoricoDoImovel != null){
							if(dadosMedicaoHistoricoDoImovel[0] != null){
								analiseConsumoRelatorioOSHelper.setDtLeituraAtualInformada6(Util
												.formatarData((Date) dadosMedicaoHistoricoDoImovel[0]));
							}
							if(dadosMedicaoHistoricoDoImovel[1] != null){
								analiseConsumoRelatorioOSHelper.setLeituraAtualInformada6("" + (Integer) dadosMedicaoHistoricoDoImovel[1]);
							}
						}
						break;

				}
			}
		}

		return analiseConsumoRelatorioOSHelper;
	}

	/**
	 * relatório de regitro atendimento
	 * 
	 * @author Vivianne Sousa
	 * @date 08/06/2007
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public HidrometroRelatorioOSHelper obterDadosHidrometro(Integer idImovel) throws ControladorException{

		HidrometroRelatorioOSHelper hidrometroRelatorioOSHelper = new HidrometroRelatorioOSHelper();
		Object[] dadosHidrometro = null;

		try{
			dadosHidrometro = repositorioMicromedicao.obterDadosHidrometro(idImovel);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(dadosHidrometro != null){

			if(dadosHidrometro[0] != null){

				String numeroHidrometro = (String) dadosHidrometro[0];
				hidrometroRelatorioOSHelper.setHidrometroFixo(numeroHidrometro.substring(0, 4));
				numeroHidrometro = Util.adicionarZerosEsquedaNumero(10, numeroHidrometro.substring(4, numeroHidrometro.length()));
				hidrometroRelatorioOSHelper.setHidrometroNumero(numeroHidrometro.substring(4, 10));

			}

			if(dadosHidrometro[1] != null){
				hidrometroRelatorioOSHelper.setHidrometroMarca((String) dadosHidrometro[1]);
			}

			if(dadosHidrometro[2] != null){
				hidrometroRelatorioOSHelper.setHidrometroCapacidade((String) dadosHidrometro[2]);
			}

			if(dadosHidrometro[3] != null){
				hidrometroRelatorioOSHelper.setHidrometroDiametro((String) dadosHidrometro[3]);
			}

			if(dadosHidrometro[4] != null){
				hidrometroRelatorioOSHelper.setHidrometroLocal((String) dadosHidrometro[4]);
			}

			if(dadosHidrometro[5] != null){
				hidrometroRelatorioOSHelper.setHidrometroLeitura(Util.formatarData((Date) dadosHidrometro[5]));
			}

			if(dadosHidrometro[6] != null){
				hidrometroRelatorioOSHelper.setHidrometroNumeroDigitos("" + (Short) dadosHidrometro[6]);
			}

			if(dadosHidrometro[7] != null){
				hidrometroRelatorioOSHelper.setDataInstalacaoHidrometo(Util.formatarData((Date) dadosHidrometro[7]));
			}

			if(dadosHidrometro[9] != null){
				hidrometroRelatorioOSHelper.setIdProtecaoHidrometro(((Integer) dadosHidrometro[8]).toString());
				hidrometroRelatorioOSHelper.setDescricaoProtecaoHidrometro((String) dadosHidrometro[9]);
			}

			if(dadosHidrometro[11] != null){
				hidrometroRelatorioOSHelper.setIdTipoHidrometro(((Integer) dadosHidrometro[10]).toString());
				hidrometroRelatorioOSHelper.setDescricaoTipoHidrometro((String) dadosHidrometro[11]);
			}

		}

		return hidrometroRelatorioOSHelper;
	}

	/**
	 * Permite inserir uma Capacidade de Hidrometro [UC0217] Inserir Capacidade
	 * hidrometro
	 * 
	 * @author Thiago Tenório
	 * @date 26/06/2007
	 */
	public Integer inserirCapacidadeHidrometro(HidrometroCapacidade hidrometroCapacidade, Usuario usuarioLogado)
					throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_CAPACIDADE_HIDROMETRO_INSERIR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_CAPACIDADE_HIDROMETRO_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		hidrometroCapacidade.setOperacaoEfetuada(operacaoEfetuada);
		hidrometroCapacidade.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(hidrometroCapacidade);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Integer id = (Integer) getControladorUtil().inserir(hidrometroCapacidade);

		return id;

	}

	/**
	 * [UC0298] Manter Agência bancária [] Atualizar Agência Bancária Metodo que
	 * atualiza a Agência Bancária
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * @throws ControladorException
	 */

	public void atualizarCapacidadeHidrometro(HidrometroCapacidade hidrometroCapacidade) throws ControladorException{

		// Verifica se todos os campos obrigatorios foram preenchidos

		if((hidrometroCapacidade.getId() == null || hidrometroCapacidade.getId().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (hidrometroCapacidade.getDescricao() == null || hidrometroCapacidade.getDescricao().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (hidrometroCapacidade.getDescricaoAbreviada() == null || hidrometroCapacidade.getDescricaoAbreviada().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (hidrometroCapacidade.getLeituraMinimo() == null || hidrometroCapacidade.getLeituraMinimo().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (hidrometroCapacidade.getLeituraMaximo() == null || hidrometroCapacidade.getLeituraMaximo().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (hidrometroCapacidade.getIndicadorUso() == null || hidrometroCapacidade.getIndicadorUso().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
		// && (hidrometroCapacidade.getNumeroOrdem() == null ||
		// hidrometroCapacidade.getNumeroOrdem().equals(
		// "" + ConstantesSistema.NUMERO_NAO_INFORMADO)
		){
			throw new ControladorException("atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Identicador da capacidade de Hidrômetro foi
		// preenchido

		if(hidrometroCapacidade.getId() == null || hidrometroCapacidade.getId().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Identicador da capacidade de Hidrômetro");
		}

		// Verifica se o campo Descrição foi preenchido
		if(hidrometroCapacidade.getDescricao() == null
						|| hidrometroCapacidade.getDescricao().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Descrição");
		}

		// Verifica se o campo Número mínimo de dígitos de leitura do hidrômetro
		// foi preenchido
		if(hidrometroCapacidade.getLeituraMinimo() == null
						|| hidrometroCapacidade.getLeituraMinimo().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Número mínimo de dígitos de leitura do hidrômetro");
		}

		// Verifica se o campo Número máximo de dígitos de leitura do hidrômetro
		// foi preenchido
		if(hidrometroCapacidade.getLeituraMaximo() == null
						|| hidrometroCapacidade.getLeituraMaximo().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Número máximo de dígitos de leitura do hidrômetro");
		}

		// // Verifica se o campo Número de ordem da capacidade do hidrômetro foi
		// // preenchido
		// if(hidrometroCapacidade.getNumeroOrdem() == null
		// || hidrometroCapacidade.getNumeroOrdem().equals("" +
		// ConstantesSistema.NUMERO_NAO_INFORMADO)){
		// throw new ControladorException("atencao.Informe_entidade", null,
		// " Número de ordem da capacidade do hidrômetro");
		// }

		// Verifica se o campo Código da Capacidade do hidrômetro foi preenchido
		if(hidrometroCapacidade.getCodigoHidrometroCapacidade() == null
						|| hidrometroCapacidade.getCodigoHidrometroCapacidade().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Código da Capacidade do hidrômetro");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroHidrometroCapacidade filtroHidrometroCapacidade = new FiltroHidrometroCapacidade();
		filtroHidrometroCapacidade.adicionarParametro(new ParametroSimples(FiltroHidrometroCapacidade.ID, hidrometroCapacidade.getId()));

		Collection colecaoHidrometroCapacidadeBase = getControladorUtil().pesquisar(filtroHidrometroCapacidade,
						HidrometroCapacidade.class.getName());

		if(colecaoHidrometroCapacidadeBase == null || colecaoHidrometroCapacidadeBase.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		HidrometroCapacidade hidrometroCapacidadeBase = (HidrometroCapacidade) colecaoHidrometroCapacidadeBase.iterator().next();

		if(hidrometroCapacidadeBase.getUltimaAlteracao().after(hidrometroCapacidade.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		hidrometroCapacidade.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(hidrometroCapacidade);

	}

	/**
	 * [UC0595] Gerar Histórico de Medicao
	 * 
	 * @param medicaoTipo
	 *            Tipo de medição
	 * @param imovel
	 *            Imovel a ter a medicao gerada
	 * @param faturamentoGrupo
	 *            Grupo de faturamento
	 * @return
	 * @throws ControladorException
	 */
	public MedicaoHistorico gerarHistoricoMedicao(MedicaoTipo medicaoTipo, Imovel imovel, FaturamentoGrupo faturamentoGrupo,
					SistemaParametro sistemaParametro) throws ControladorException{

		// Criação de coleções
		Collection colecaoMedicaoHistoricoMesAnterior = null;

		MedicaoHistorico medicaoHistorico = new MedicaoHistorico();

		// Caso seja ligação de água
		if(medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()){

			medicaoHistorico.setLigacaoAgua(imovel.getLigacaoAgua());
			medicaoHistorico.setHidrometroInstalacaoHistorico(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico());

			// Caso seja ligação de poço
		}else if(medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()){

			medicaoHistorico.setImovel(imovel);
			medicaoHistorico.setHidrometroInstalacaoHistorico(imovel.getHidrometroInstalacaoHistorico());

		}

		medicaoHistorico.setNumeroVezesConsecutivasOcorrenciaAnormalidade(Short.valueOf("0"));

		medicaoHistorico.setMedicaoTipo(medicaoTipo);
		// medicaoHistorico.setAnoMesReferencia(faturamentoGrupo
		// .getAnoMesReferencia());
		// String anoMes = faturamentoGrupo.getAnoMesReferencia() + "";
		medicaoHistorico.setAnoMesReferencia(sistemaParametro.getAnoMesFaturamento());

		String anoMes = "" + sistemaParametro.getAnoMesFaturamento();

		int anoMesAnterior = Util.subtrairMesDoAnoMes(Integer.valueOf(anoMes).intValue(), 1);

		// Define o mês de faturamento anterior
		SistemaParametro sistemaParametroMesAnteriorFaturamento = new SistemaParametro();

		sistemaParametroMesAnteriorFaturamento.setAnoMesFaturamento(Integer.valueOf(anoMesAnterior).intValue());

		// Pesquisa historico medição do mês anterior
		try{
			colecaoMedicaoHistoricoMesAnterior = repositorioMicromedicao.pesquisarObterDadosHistoricoMedicao(imovel, medicaoTipo,
							sistemaParametroMesAnteriorFaturamento);
		}catch(ErroRepositorioException ex){
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// caso não seja o ano mes anterior, então pesquisa os dados
		// anteriores de dois meses atrás
		if(colecaoMedicaoHistoricoMesAnterior == null || colecaoMedicaoHistoricoMesAnterior.isEmpty()){
			int anoMesDoisMesesAnteriores = Util.subtrairMesDoAnoMes(Integer.valueOf(anoMes).intValue(), 2);
			sistemaParametroMesAnteriorFaturamento.setAnoMesFaturamento(anoMesDoisMesesAnteriores);

			// Pesquisa historico medição do mês anterior
			try{
				colecaoMedicaoHistoricoMesAnterior = repositorioMicromedicao.pesquisarObterDadosHistoricoMedicao(imovel, medicaoTipo,
								sistemaParametroMesAnteriorFaturamento);
			}catch(ErroRepositorioException ex){
				// sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}

		LeituraSituacao leituraSituacao = new LeituraSituacao();

		FiltroLeituraSituacao filtro = new FiltroLeituraSituacao();
		filtro.adicionarParametro(new ParametroSimples(FiltroLeituraSituacao.ID, LeituraSituacao.NAO_REALIZADA));

		Collection colFiltros = getControladorUtil().pesquisar(filtro, leituraSituacao.getClass().getName());

		// Selecionamos a situacao da leitura
		leituraSituacao = (LeituraSituacao) colFiltros.toArray()[0];

		// Com o valor da Data Prevista para a atividade de efetuar leitura
		// no cronograma do grupo de faturamento do mês corrente
		// (FTAC_DTPREVISTA),
		// limitada à data corrente
		Object[] datas = obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(faturamentoGrupo, sistemaParametro.getAnoMesFaturamento());

		Date dataPrevista = null;

		if(datas != null){
			dataPrevista = (Date) datas[0];
		}

		// Caso exista histórico de medição do mês anterior
		if(colecaoMedicaoHistoricoMesAnterior != null && !colecaoMedicaoHistoricoMesAnterior.isEmpty()){

			// Pega coleção e cria o histórico de medição
			MedicaoHistorico medicaoHistoricoMesAnterior = obterHistoricoMedicao(colecaoMedicaoHistoricoMesAnterior, imovel, medicaoTipo);

			// Recebe a data de leitura atual faturada do mês anterior
			medicaoHistorico.setDataLeituraAnteriorFaturamento(medicaoHistoricoMesAnterior.getDataLeituraAtualFaturamento());
			// Recebe a leitura atual faturada no mês anterior
			medicaoHistorico.setLeituraAnteriorFaturamento(medicaoHistoricoMesAnterior.getLeituraAtualFaturamento());
			// Recebe a leitura atual informada no mês anterior
			medicaoHistorico.setLeituraAnteriorInformada(medicaoHistoricoMesAnterior.getLeituraAtualInformada());
			// Recebe a situaçao da leitura atual do mês anterior
			medicaoHistorico.setLeituraSituacaoAnterior(medicaoHistoricoMesAnterior.getLeituraSituacaoAtual());
			// Recebe o crédito de consumos anteriores
			medicaoHistorico.setConsumoCreditoAnterior(medicaoHistoricoMesAnterior.getConsumoCreditoAnterior());

		}else{

			Object[] maiorMedicaoHistorico = null;

			// Pesquisa a maior medicao histórico para o imóvel
			try{
				maiorMedicaoHistorico = (Object[]) repositorioMicromedicao.pesquisarObterDadosMaiorHistoricoMedicao(imovel, medicaoTipo,
								sistemaParametro);
			}catch(ErroRepositorioException ex){
				// sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if(maiorMedicaoHistorico != null){

				medicaoHistorico.setDataLeituraAnteriorFaturamento((Date) maiorMedicaoHistorico[0]);
				medicaoHistorico.setLeituraAnteriorFaturamento(((Integer) maiorMedicaoHistorico[1]));
				medicaoHistorico.setLeituraAnteriorInformada((Integer) maiorMedicaoHistorico[2]);
			}
			// Caso não exista a maior medição historico
			else{

				// e a data de Realização para a atividade de efetuar
				// leitura no cronograma do grupo
				// de faturamento do mês anterior (FTAC_TMREALIZACAO).
				Integer anoMesFaturamentoAnterior = Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(), 1);

				Object[] datasAnterior = obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(faturamentoGrupo,
								anoMesFaturamentoAnterior);

				/*
				 * Alterado por Raphael Rossiter em 06/08/2007 OBJ: Consistir
				 * imóveis sem leitura anterior
				 */
				Date dataRealizada = null;

				if(datasAnterior == null){
					dataRealizada = this.gerarDataRealizacaoLeituraAnterior(faturamentoGrupo, sistemaParametro);
				}else if(datasAnterior[1] == null){
					dataRealizada = this.gerarDataRealizacaoLeituraAnterior(faturamentoGrupo, sistemaParametro);
				}else{
					dataRealizada = (Date) datasAnterior[1];
				}

				Date dataLeituraAnteriorFaturamento = null;

				// Caso seja ligação de água
				if(medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()){

					if(Util.compararData(dataRealizada, imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao()) == 1){

						dataLeituraAnteriorFaturamento = dataRealizada;
					}else{
						dataLeituraAnteriorFaturamento = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();
					}

					// Caso seja ligação de poço
				}else if(medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()){

					if(Util.compararData(dataRealizada, imovel.getHidrometroInstalacaoHistorico().getDataInstalacao()) == 1){

						dataLeituraAnteriorFaturamento = dataRealizada;
					}else{
						dataLeituraAnteriorFaturamento = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();
					}
				}

				medicaoHistorico.setDataLeituraAnteriorFaturamento(dataLeituraAnteriorFaturamento);
			}

			// Seta a situação da leitura anterior como não realizada
			medicaoHistorico.setLeituraSituacaoAnterior(leituraSituacao);

		}

		if(dataPrevista != null){
			medicaoHistorico.setDataLeituraAtualFaturamento(dataPrevista);
		}else{
			medicaoHistorico.setDataLeituraAtualFaturamento(Util.adicionarNumeroDiasDeUmaData(medicaoHistorico
							.getDataLeituraAnteriorFaturamento(), 30));
		}

		medicaoHistorico.setLeituraSituacaoAtual(leituraSituacao);

		// Seja o timestamp
		medicaoHistorico.setUltimaAlteracao(new Date());

		return medicaoHistorico;
	}

	/**
	 * relatório de extrato de debito
	 * 
	 * @author Vivianne Sousa
	 * @date 17/07/2007
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public String obterRotaESequencialRotaDoImovel(Integer idImovel) throws ControladorException{

		String codigoRotaESequencialRota = "";
		Object[] dados = null;

		try{
			dados = repositorioMicromedicao.obterRotaESequencialRotaDoImovel(idImovel);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(dados != null){
			if(dados[0] != null){
				codigoRotaESequencialRota = "" + (Short) dados[0];
			}
			if(dados[1] != null){
				codigoRotaESequencialRota = codigoRotaESequencialRota + "." + (Integer) dados[1];
			}
		}

		return codigoRotaESequencialRota;
	}

	/**
	 * [UC0623] Gerar Resumo de Metas CAERN
	 * 
	 * @author Sávio Luiz
	 * @date 15/11/2006
	 * @param idOS
	 * @return OrdemServico
	 * @throws ControladorException
	 */

	public Integer pesquisarConsumoFaturado(Integer idImovel, Integer tipoLigacao, Integer idConsumoTipoMediaImovel,
					Integer idConsumoTipoMediaHidrometro, Integer amArrecadacao) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarConsumoFaturado(idImovel, tipoLigacao, idConsumoTipoMediaImovel,
							idConsumoTipoMediaHidrometro, amArrecadacao);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Permite inserir um Leiturista [UC0588] Inserir Leiturista
	 * 
	 * @author Thiago Tenório
	 * @date 22/07/2007
	 * @author eduardo henrique
	 * @date 09/06/2008 (Adição da validação dos campos obrigatórios e outras
	 *       condições requeridas) OBS: Validação do IMEI está na GUI
	 */
	public Integer inserirLeiturista(Leiturista leiturista, Usuario usuarioLogado) throws ControladorException{

		/*
		 * Validação de Campos Obrigatórios e outros
		 */
		if(leiturista.getFuncionario() == null && leiturista.getCliente() == null){
			throw new ControladorException("atencao.informe_campo", null, "Funcionário ou Cliente");
		}

		if(leiturista.getCliente() != null && leiturista.getEmpresa() == null){
			throw new ControladorException("atencao.informe_campo", null, "Empresa do Cliente");
		}

		if(leiturista.getCodigoDDD() == null || leiturista.getCodigoDDD().equalsIgnoreCase("")){
			throw new ControladorException("atencao.informe_campo", null, "Código DDD do Município");
		}

		if(leiturista.getNumeroFone() == null || leiturista.getNumeroFone().equalsIgnoreCase("")){
			throw new ControladorException("atencao.informe_campo", null, "Número do Telefone");
		}

		// [FS0007]
		if(leiturista.getFuncionario() != null && leiturista.getCliente() != null){
			throw new ControladorException("atencao.informe_campo", null, "somente Funcionario ou Cliente para o Agente Comercial");
		}

		if(leiturista.getFuncionario() != null){
			// [FS0001]
			FiltroFuncionario filtroFuncionario = new FiltroFuncionario();
			filtroFuncionario.adicionarParametro(new ParametroSimples(FiltroFuncionario.ID, leiturista.getFuncionario().getId()));

			Collection colecaoFuncionarios = getControladorUtil().pesquisar(filtroFuncionario, Funcionario.class.getName());

			if(colecaoFuncionarios == null || colecaoFuncionarios.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_funcionario_inexistente", null, "" + leiturista.getFuncionario().getId());
			}

			// [FS0005] -- Verifica se o funcionário já foi cadastrado
			// anteriormente
			FiltroLeiturista filtroLeiturista = new FiltroLeiturista();
			filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.FUNCIONARIO_ID, leiturista.getFuncionario().getId()));

			Collection colecaoLeituristas = getControladorUtil().pesquisar(filtroLeiturista, Leiturista.class.getName());
			if(colecaoLeituristas != null && !colecaoLeituristas.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_funcionario_ja_existe_cadastro", null, ""
								+ leiturista.getFuncionario().getId());
			}
		}else{ // Funcionário ou cliente devem ser informados
			// [FS0002]
			FiltroCliente filtroCliente = new FiltroCliente();
			filtroCliente.adicionarParametro(new ParametroSimples(FiltroCliente.ID, leiturista.getCliente().getId()));

			Collection colecaoClientes = getControladorUtil().pesquisar(filtroCliente, Cliente.class.getName());

			if(colecaoClientes == null || colecaoClientes.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_cliente_inexistente", null, "" + leiturista.getCliente().getId());
			}

			// [FS0005] -- Verifica se o cliente já foi cadastrado anteriormente
			FiltroLeiturista filtroLeiturista = new FiltroLeiturista();
			filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.CLIENTE_ID, leiturista.getCliente().getId()));

			Collection colecaoLeituristas = getControladorUtil().pesquisar(filtroLeiturista, Leiturista.class.getName());
			if(colecaoLeituristas != null && !colecaoLeituristas.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_cliente_ja_existe_cadastro", null, "" + leiturista.getCliente().getId());
			}
		}
		// [FS0003] -- Verifica se existe o DDD para algum Município
		FiltroMunicipio filtroMunicipio = new FiltroMunicipio();
		filtroMunicipio.adicionarParametro(new ParametroSimples(FiltroMunicipio.DDD, leiturista.getCodigoDDD()));

		Collection colecaoDDDs = getControladorUtil().pesquisar(filtroMunicipio, Municipio.class.getName());
		if(colecaoDDDs == null || colecaoDDDs.isEmpty()){
			// // levanta a exceção para a próxima camada
			throw new ControladorException("atencao.leiturista_municipio_inexistente", null, "" + leiturista.getCodigoDDD());
		}

		// FiltroLeituraAnormalidade filtroLeituraAnormalidade = new
		// FiltroLeituraAnormalidade();

		/*
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.DESCRICAO, leituraAnormalidade
		 * .getDescricao())); filtroLeituraAnormalidade.adicionarParametro(new
		 * ParametroSimples( FiltroLeituraAnormalidade.DESCRICAO_ABREVIADA,
		 * leituraAnormalidade.getDescricaoAbreviada()));
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_RELATIVO_HIDROMETRO,
		 * leituraAnormalidade.getIndicadorRelativoHidrometro()));
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_IMOVEL_SEM_HIDROMETRO,
		 * leituraAnormalidade.getIndicadorImovelSemHidrometro()));
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_USO_SISTEMA,
		 * leituraAnormalidade.getIndicadorSistema()));
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.INDICADOR_EMISSAO_ORDEM_SERVICO,
		 * leituraAnormalidade.getIndicadorEmissaoOrdemServico()));
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_TIPO_SERVICO, leituraAnormalidade
		 * .getServicoTipo())); filtroLeituraAnormalidade.adicionarParametro(new
		 * ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_CONSUMO_A_COBRAR_SEM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeConsumoSemleitura()));
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_CONSUMO_A_COBRAR_COM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeConsumoComleitura()));
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_LEITURA_A_FATURAR_SEM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeLeituraSemleitura()));
		 * filtroLeituraAnormalidade.adicionarParametro(new ParametroSimples(
		 * FiltroLeituraAnormalidade.ID_LEITURA_A_FATURAR_COM_LEITURA,
		 * leituraAnormalidade.getLeituraAnormalidadeLeituraComleitura()));
		 */
		// Collection colecaoAnormalidadeLeitura =
		// getControladorUtil().pesquisar(
		// filtroLeituraAnormalidade, LeituraAnormalidade.class.getName());
		// if (colecaoAnormalidadeLeitura != null
		// && !colecaoAnormalidadeLeitura.isEmpty()) {
		// throw new ControladorException(
		// "atencao.endereco_localidade_nao_informado");
		// }
		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_LEITURISTA_INSERIR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_LEITURISTA_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		leiturista.setOperacaoEfetuada(operacaoEfetuada);
		leiturista.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(leiturista);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		Integer id = (Integer) getControladorUtil().inserir(leiturista);

		return id;

	}

	/**
	 * [UC0583] Inserir Roteiro Empresa Insere um objeto do tipo roteiro empresa
	 * no BD
	 * 
	 * @author Francisco Nascimento
	 * @date 24/07/2007
	 * @param roteiro
	 *            empresa
	 * @param idLocalidade
	 * @param quadras
	 * @return idRota
	 * @throws ControladorException
	 */
	public Integer inserirRoteiroEmpresa(RoteiroEmpresa roteiroEmpresa, String[] idQuadrasAdicionar, Usuario usuarioLogado)
					throws ControladorException{

		validacaoFinalRoteiroEmpresa("" + roteiroEmpresa.getEmpresa().getId(), roteiroEmpresa.getLeiturista(), ""
						+ roteiroEmpresa.getIndicadorUso(), "INSERIR", idQuadrasAdicionar);

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ROTEIRO_EMPRESA_INSERIR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		roteiroEmpresa.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

		registradorOperacao.registrarOperacao(roteiroEmpresa);

		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// Inserir o roteiro empresa
		Integer idRoteiroEmpresa = (Integer) this.getControladorUtil().inserir(roteiroEmpresa);
		roteiroEmpresa.setId(idRoteiroEmpresa);

		// -- codigo para atualizar quadras do roteiro empresa
		roteiroEmpresa.setId(idRoteiroEmpresa);
		String quadrasJaPertencentes = "";
		for(int i = 0; i < idQuadrasAdicionar.length; i++){

			// Cria o filtro
			FiltroQuadra filtroQuadra = new FiltroQuadra();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = Quadra.class.getName();

			// Seta os parametros do filtro
			filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID, idQuadrasAdicionar[i]));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection quadras = getControladorUtil().pesquisar(filtroQuadra, nomePacoteObjeto);

			Quadra quadraNaBase = (Quadra) Util.retonarObjetoDeColecao(quadras);

			// [FS0007] - Verificar duplicidade de roteiro empresa para a quadra
			if(quadraNaBase.getRoteiroEmpresa() != null
							&& !quadraNaBase.getRoteiroEmpresa().getId().equals(Integer.valueOf(ConstantesSistema.NUMERO_NAO_INFORMADO))){
				quadrasJaPertencentes += quadraNaBase.getNumeroQuadra() + ", ";
			}else{
				quadraNaBase.setRoteiroEmpresa(roteiroEmpresa);
				// quadraNaBase.setOperacaoEfetuada(operacaoEfetuada);
				quadraNaBase.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(quadraNaBase);
				getControladorLocalidade().atualizarQuadra(quadraNaBase, usuarioLogado);
			}
		}
		if(!quadrasJaPertencentes.equals("")){
			ControladorException ce = new ControladorException("atencao.quadra_ja_pertence_roteiro_empresa");
			String parametros[] = {quadrasJaPertencentes.substring(0, quadrasJaPertencentes.length() - 2)};
			ce.setParametroMensagem(parametros);
			throw ce;
		}
		return idRoteiroEmpresa;
	}

	private void validacaoFinalRoteiroEmpresa(String empresa, Leiturista leiturista, String indicadorUso, String acao, String[] quadras)
					throws ControladorException{

		// Empresa é obrigatório.
		if((empresa == null) || (empresa.equals(""))){
			throw new ControladorException("atencao.empresa_nao_informada");
		}

		// Leiturista é obrigatório.
		if(leiturista == null || leiturista.getId() == null || leiturista.getId().intValue() == ConstantesSistema.NUMERO_NAO_INFORMADO){
			throw new ControladorException("atencao.leiturista_tipo_nao_informado");
		}

		if(quadras == null || quadras.length == 0){
			throw new ControladorException("atencao.quadras.informar");
		}

	}

	/**
	 * Retorna o valor de controladorLocalidade
	 * 
	 * @return O valor de controladorLocalidade
	 */
	private ControladorLocalidadeLocal getControladorLocalidade(){

		ControladorLocalidadeLocalHome localHome = null;
		ControladorLocalidadeLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try{
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorLocalidadeLocalHome) locator.getLocalHome(ConstantesJNDI.CONTROLADOR_LOCALIDADE_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		}catch(CreateException e){
			throw new SistemaException(e);
		}catch(ServiceLocatorException e){
			throw new SistemaException(e);
		}
	}

	/**
	 * Permite gerar o arquivo texto do roteiro empresa para o leiturista.
	 * [UC0627] Gerar Arquivo Texto para Leitura
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 02/08/2007, 15/10/2007
	 * @param colecaoRoteirosEmpresa
	 * @param colecaoRotas
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void gerarArquivoTextoParaLeiturista(Collection colecaoRoteirosEmpresa, Collection colecaoRotas, Integer anoMesFaturamento,
					FaturamentoGrupo faturamentoGrupo, int idFuncionalidadeIniciada) throws ControladorException{

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.FUNCIONALIDADE, 0);

		try{
			/*
			 * recupera o indicador de roteiro empresa da tabela de parametros
			 * do sistema
			 */
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			Short indicadorRoteiroEmpresa = sistemaParametro.getIndicadorRoteiroEmpresa();

			/*
			 * Caso o indicador de roteiro empresa esteja com valor igual a 1
			 * (SIM) processar todos que estão na lista de roteiro empresa Caso
			 * contrario, processar todas as rotas que estão na lista de rotas.
			 */
			if(indicadorRoteiroEmpresa.equals(ConstantesSistema.SIM)){
				// [SB0001 - Processar Movimento Roteiro Empresa por Roteiro
				// Empresa]
				processarMovimentoRoteiroEmpresaPorRoteiroEmpresa(colecaoRoteirosEmpresa, anoMesFaturamento, faturamentoGrupo);
			}else{
				// [SB0002 - Processar Movimento Roteiro Empresa por Rota]
				processarMovimentoRoteiroEmpresaPorRota(colecaoRotas, anoMesFaturamento, faturamentoGrupo);
			}

			/* fecha a unidade de processamento com sucesso */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception ex){

			ex.printStackTrace();

			/* fecha a unidade de processamento com erro */
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0627] Gerar Arquivo Texto para Leitura [SB0001] Processar Movimento
	 * Roteiro Empresa por Roteiro Empresa
	 * 
	 * @author Pedro Alexandre
	 * @date 15/10/2007
	 * @param colecaoRoteirosEmpresa
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	private void processarMovimentoRoteiroEmpresaPorRoteiroEmpresa(Collection colecaoRoteirosEmpresa, Integer anoMesFaturamento,
					FaturamentoGrupo faturamentoGrupo) throws ControladorException{

		// Caso a coleção de roteiros empresa não esteja vazia
		if(colecaoRoteirosEmpresa != null && !colecaoRoteirosEmpresa.isEmpty()){

			Integer idLocalidadeTemp = null;
			Integer sequencial = 1;
			boolean flagPrimeiraVez = true;

			try{
				// o sistema classifica a lista de roteiros empresas recebidas
				// por empresa
				Collections.sort((List) colecaoRoteirosEmpresa, new Comparator() {

					public int compare(Object a, Object b){

						Integer codigo1 = ((RoteiroEmpresa) a).getEmpresa().getId();
						Integer codigo2 = ((RoteiroEmpresa) b).getEmpresa().getId();
						if(codigo1 == null || codigo1.equals("")){
							return -1;
						}else{
							return codigo1.compareTo(codigo2);
						}
					}
				});

				Iterator iteratorRoteirosEmpresa = colecaoRoteirosEmpresa.iterator();

				// Para cada roteiro empresa gera o arquivo texto para leitura.
				while(iteratorRoteirosEmpresa.hasNext()){

					RoteiroEmpresa roteiroEmpresa = (RoteiroEmpresa) iteratorRoteirosEmpresa.next();

					// [FS005] Verificar existência do arquivo texto roteiro
					// empresa
					this.repositorioMicromedicao.excluirArquivoTextoParaLeiturista(anoMesFaturamento, roteiroEmpresa.getId(),
									faturamentoGrupo.getId());

					System.out.println("Roteiro Empresa " + roteiroEmpresa.getId());

					// [FS0004] Verificar quantidade de setores comerciais
					int qtdSetorComercial = this.repositorioMicromedicao.pesquisarQuantidadeSetorComercialPorRoteiroEmpresa(roteiroEmpresa
									.getId(), anoMesFaturamento, faturamentoGrupo.getId());

					// caso a quantidade de setor comercial não exceda 3,
					// processa a coleção de movimento roteiro empresa.
					if(qtdSetorComercial <= 3){
						// pesquisa os dados do movimento roteiro empresa
						Collection<Object[]> colecaoDadosMovimentoRoteiroEmpresa = this.repositorioMicromedicao
										.pesquisarMovimentoRoteiroEmpresa(roteiroEmpresa.getId(), anoMesFaturamento, faturamentoGrupo
														.getId());

						// [FS0001 - Verificar Seleção de imóvel]
						if(colecaoDadosMovimentoRoteiroEmpresa != null && !colecaoDadosMovimentoRoteiroEmpresa.isEmpty()){

							// gera o arquivo txt para o roteiro empresa
							// e retorna as informações necessárias para inserir
							// o ArquivoTextoParaRoteiroEmpresa
							Object[] dadosRoteiroEmpresa = this.gerarArquivoTextoParaRoteiroEmpresa(colecaoDadosMovimentoRoteiroEmpresa,
											faturamentoGrupo);

							byte[] arquivoRoteiroEmpresaByte = null;
							StringBuilder arquivoRoteiroEmpresa = null;

							// recupera o arquivo txt gerado
							arquivoRoteiroEmpresa = (StringBuilder) dadosRoteiroEmpresa[0];
							arquivoRoteiroEmpresaByte = IoUtil.transformarObjetoParaBytes(arquivoRoteiroEmpresa);

							// dados necessários para inserir o
							// ArquivoTextoParaRoteiroEmpresa
							Integer codigoSetorComercial1 = (Integer) dadosRoteiroEmpresa[1];
							Integer numeroQuadraInicial1 = (Integer) dadosRoteiroEmpresa[2];
							Integer numeroQuadraFinal1 = (Integer) dadosRoteiroEmpresa[3];
							Integer codigoSetorComercial2 = (Integer) dadosRoteiroEmpresa[4];
							Integer numeroQuadraInicial2 = (Integer) dadosRoteiroEmpresa[5];
							Integer numeroQuadraFinal2 = (Integer) dadosRoteiroEmpresa[6];
							Integer codigoSetorComercial3 = (Integer) dadosRoteiroEmpresa[7];
							Integer numeroQuadraInicial3 = (Integer) dadosRoteiroEmpresa[8];
							Integer numeroQuadraFinal3 = (Integer) dadosRoteiroEmpresa[9];
							Integer qtdImoveis = (Integer) dadosRoteiroEmpresa[10];

							Integer idLocalidadePrimeiroImovel = (Integer) dadosRoteiroEmpresa[11];
							Localidade localidadePrimeiroImovel = new Localidade();
							localidadePrimeiroImovel.setId(idLocalidadePrimeiroImovel);

							// define se o vai incrementar o sequencia
							// dependendo se a localidade permanece a mesma
							// para o roteiro empresa diferente, cso contrario
							// inicia o sequencial com 1.
							if(flagPrimeiraVez){
								flagPrimeiraVez = false;
								idLocalidadeTemp = idLocalidadePrimeiroImovel;
							}else{
								if(idLocalidadeTemp.equals(idLocalidadePrimeiroImovel)){
									sequencial++;
								}else{
									sequencial = 1;
									idLocalidadeTemp = idLocalidadePrimeiroImovel;
								}
							}

							/*
							 * instância a situação da transmissão de leitura
							 * para "LIBERADO"
							 */
							SituacaoTransmissaoLeitura situacaoTransmissaoLeitura = new SituacaoTransmissaoLeitura();
							situacaoTransmissaoLeitura.setId(SituacaoTransmissaoLeitura.LIBERADO);

							// [FS0003] - Nome do Arquivo Texto
							String nomeArquivo = this.gerarNomeArquivoTextoParaRoteiroEmpresa(idLocalidadePrimeiroImovel, faturamentoGrupo
											.getId(), sequencial);

							// cria o ArquivoTextoRoteiroEmpresa para ser
							// inserido.
							ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = new ArquivoTextoRoteiroEmpresa();
							arquivoTextoRoteiroEmpresa.setAnoMesReferencia(anoMesFaturamento);
							arquivoTextoRoteiroEmpresa.setRoteiroEmpresa(roteiroEmpresa);
							arquivoTextoRoteiroEmpresa.setFaturamentoGrupo(faturamentoGrupo);
							arquivoTextoRoteiroEmpresa.setEmpresa(roteiroEmpresa.getEmpresa());
							arquivoTextoRoteiroEmpresa.setLocalidade(localidadePrimeiroImovel);
							arquivoTextoRoteiroEmpresa.setCodigoSetorComercial1(codigoSetorComercial1);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraInicial1(numeroQuadraInicial1);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraFinal1(numeroQuadraFinal1);
							arquivoTextoRoteiroEmpresa.setCodigoSetorComercial2(codigoSetorComercial2);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraInicial2(numeroQuadraInicial2);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraFinal2(numeroQuadraFinal2);
							arquivoTextoRoteiroEmpresa.setCodigoSetorComercial3(codigoSetorComercial3);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraInicial3(numeroQuadraInicial3);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraFinal3(numeroQuadraFinal3);
							arquivoTextoRoteiroEmpresa.setQuantidadeImovel(qtdImoveis);
							arquivoTextoRoteiroEmpresa.setNumeroArquivo(nomeArquivo);
							arquivoTextoRoteiroEmpresa.setLeiturista(roteiroEmpresa.getLeiturista());
							arquivoTextoRoteiroEmpresa.setCodigoLeiturista(roteiroEmpresa.getLeiturista().getCodigoDDD());
							arquivoTextoRoteiroEmpresa.setNumeroFoneLeiturista(roteiroEmpresa.getLeiturista().getNumeroFone());
							arquivoTextoRoteiroEmpresa.setArquivoTexto(arquivoRoteiroEmpresaByte);
							arquivoTextoRoteiroEmpresa.setUltimaAlteracao(new Date());
							arquivoTextoRoteiroEmpresa.setTempoEnvioEmpresa(null);
							arquivoTextoRoteiroEmpresa.setSituacaoTransmissaoLeitura(situacaoTransmissaoLeitura);
							arquivoTextoRoteiroEmpresa.setNumeroImei(roteiroEmpresa.getLeiturista().getNumeroImei());
							arquivoTextoRoteiroEmpresa.setRota(null);

							getControladorUtil().inserir(arquivoTextoRoteiroEmpresa);
						}
					}else{
						throw new ControladorException("atencao.limite.excedente.setorcomercial");
					}
				}

				// Erro no repositório
			}catch(Exception ex){
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}
		}
	}

	/**
	 * [UC0627] Gerar Arquivo Texto para Leitura [SB0002] Processar Movimento
	 * Roteiro Empresa por Rota
	 * 
	 * @author Pedro Alexandre
	 * @date 15/10/2007
	 * @param colecaoRotas
	 * @param anoMesFaturamento
	 * @param faturamentoGrupo
	 * @throws ControladorException
	 */
	private void processarMovimentoRoteiroEmpresaPorRota(Collection colecaoRotas, Integer anoMesFaturamento,
					FaturamentoGrupo faturamentoGrupo) throws ControladorException{

		// Caso a coleção de rotas não esteja vazia
		if(colecaoRotas != null && !colecaoRotas.isEmpty()){

			Integer idLocalidadeTemp = null;
			Integer sequencial = 1;
			boolean flagPrimeiraVez = true;

			try{
				// o sistema classifica a lista de rotas recebidas
				// por empresa
				Collections.sort((List) colecaoRotas, new Comparator() {

					public int compare(Object a, Object b){

						Integer codigo1 = ((Rota) a).getEmpresa().getId();

						Integer codigo2 = ((Rota) b).getEmpresa().getId();

						if(codigo1 == null || codigo1.equals("")){
							return -1;
						}else{
							return codigo1.compareTo(codigo2);
						}
					}
				});

				Iterator iteratorRotas = colecaoRotas.iterator();

				// Para cada rota gera o arquivo texto para leitura.
				while(iteratorRotas.hasNext()){
					// recupera a rota
					Rota rota = (Rota) iteratorRotas.next();

					// [FS005] Verificar existência do arquivo texto roteiro
					// empresa por rota
					this.repositorioMicromedicao.excluirArquivoTextoParaLeituristaPorRota(anoMesFaturamento, rota.getId(), faturamentoGrupo
									.getId());

					System.out.println("Rota " + rota.getId());

					// [FS0004] Verificar quantidade de setores comerciais por
					// rota
					int qtdSetorComercial = this.repositorioMicromedicao.pesquisarQuantidadeSetorComercialPorRota(rota.getId(),
									anoMesFaturamento, faturamentoGrupo.getId());

					// caso a quantidade de setor comercial não exceda 3,
					// processa a coleção de movimento roteiro empresa.
					if(qtdSetorComercial <= 3){

						// pesquisa os dados do movimento roteiro empresa por
						// rota
						Collection<Object[]> colecaoDadosMovimentoRoteiroEmpresa = this.repositorioMicromedicao
										.pesquisarMovimentoRoteiroEmpresaPorRota(rota.getId(), anoMesFaturamento, faturamentoGrupo.getId());

						// [FS0001 - Verificar Seleção de imóvel]
						if(colecaoDadosMovimentoRoteiroEmpresa != null && !colecaoDadosMovimentoRoteiroEmpresa.isEmpty()){

							// gera o arquivo txt para o rota
							// e retorna as informações necessárias para inserir
							// o ArquivoTextoParaRoteiroEmpresa
							Object[] dadosRoteiroEmpresa = this.gerarArquivoTextoParaRoteiroEmpresa(colecaoDadosMovimentoRoteiroEmpresa,
											faturamentoGrupo);

							byte[] arquivoRoteiroEmpresaByte = null;
							StringBuilder arquivoRoteiroEmpresa = null;

							// recupera o arquivo txt gerado
							arquivoRoteiroEmpresa = (StringBuilder) dadosRoteiroEmpresa[0];
							arquivoRoteiroEmpresaByte = IoUtil.transformarObjetoParaBytes(arquivoRoteiroEmpresa);

							// dados necessários para inserir o
							// ArquivoTextoParaRoteiroEmpresa
							Integer codigoSetorComercial1 = (Integer) dadosRoteiroEmpresa[1];
							Integer numeroQuadraInicial1 = (Integer) dadosRoteiroEmpresa[2];
							Integer numeroQuadraFinal1 = (Integer) dadosRoteiroEmpresa[3];
							Integer codigoSetorComercial2 = (Integer) dadosRoteiroEmpresa[4];
							Integer numeroQuadraInicial2 = (Integer) dadosRoteiroEmpresa[5];
							Integer numeroQuadraFinal2 = (Integer) dadosRoteiroEmpresa[6];
							Integer codigoSetorComercial3 = (Integer) dadosRoteiroEmpresa[7];
							Integer numeroQuadraInicial3 = (Integer) dadosRoteiroEmpresa[8];
							Integer numeroQuadraFinal3 = (Integer) dadosRoteiroEmpresa[9];
							Integer qtdImoveis = (Integer) dadosRoteiroEmpresa[10];

							Integer idLocalidadePrimeiroImovel = (Integer) dadosRoteiroEmpresa[11];
							Localidade localidadePrimeiroImovel = new Localidade();
							localidadePrimeiroImovel.setId(idLocalidadePrimeiroImovel);

							// define se o vai incrementar o sequencia
							// dependendo se a localidade permanece a mesma
							// para o roteiro empresa diferente, cso contrario
							// inicia o sequencial com 1.
							if(flagPrimeiraVez){
								flagPrimeiraVez = false;
								idLocalidadeTemp = idLocalidadePrimeiroImovel;
							}else{
								if(idLocalidadeTemp.equals(idLocalidadePrimeiroImovel)){
									sequencial++;
								}else{
									sequencial = 1;
									idLocalidadeTemp = idLocalidadePrimeiroImovel;
								}
							}

							/*
							 * instância a situação da transmissão de leitura
							 * para "LIBERADO"
							 */
							SituacaoTransmissaoLeitura situacaoTransmissaoLeitura = new SituacaoTransmissaoLeitura();
							situacaoTransmissaoLeitura.setId(SituacaoTransmissaoLeitura.LIBERADO);

							// [FS0003] - Nome do Arquivo Texto
							String nomeArquivo = this.gerarNomeArquivoTextoParaRoteiroEmpresa(idLocalidadePrimeiroImovel, faturamentoGrupo
											.getId(), sequencial);

							// cria o ArquivoTextoRoteiroEmpresa para ser
							// inserido.
							ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = new ArquivoTextoRoteiroEmpresa();
							arquivoTextoRoteiroEmpresa.setAnoMesReferencia(anoMesFaturamento);
							arquivoTextoRoteiroEmpresa.setRoteiroEmpresa(null);
							arquivoTextoRoteiroEmpresa.setFaturamentoGrupo(faturamentoGrupo);
							arquivoTextoRoteiroEmpresa.setEmpresa(rota.getEmpresa());
							arquivoTextoRoteiroEmpresa.setLocalidade(localidadePrimeiroImovel);
							arquivoTextoRoteiroEmpresa.setCodigoSetorComercial1(codigoSetorComercial1);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraInicial1(numeroQuadraInicial1);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraFinal1(numeroQuadraFinal1);
							arquivoTextoRoteiroEmpresa.setCodigoSetorComercial2(codigoSetorComercial2);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraInicial2(numeroQuadraInicial2);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraFinal2(numeroQuadraFinal2);
							arquivoTextoRoteiroEmpresa.setCodigoSetorComercial3(codigoSetorComercial3);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraInicial3(numeroQuadraInicial3);
							arquivoTextoRoteiroEmpresa.setNumeroQuadraFinal3(numeroQuadraFinal3);
							arquivoTextoRoteiroEmpresa.setQuantidadeImovel(qtdImoveis);
							arquivoTextoRoteiroEmpresa.setNumeroArquivo(nomeArquivo);
							arquivoTextoRoteiroEmpresa.setLeiturista(rota.getLeiturista());
							arquivoTextoRoteiroEmpresa.setCodigoLeiturista(rota.getLeiturista().getCodigoDDD());
							arquivoTextoRoteiroEmpresa.setNumeroFoneLeiturista(rota.getLeiturista().getNumeroFone());
							arquivoTextoRoteiroEmpresa.setArquivoTexto(arquivoRoteiroEmpresaByte);
							arquivoTextoRoteiroEmpresa.setUltimaAlteracao(new Date());
							arquivoTextoRoteiroEmpresa.setTempoEnvioEmpresa(null);
							arquivoTextoRoteiroEmpresa.setSituacaoTransmissaoLeitura(situacaoTransmissaoLeitura);
							arquivoTextoRoteiroEmpresa.setNumeroImei(rota.getLeiturista().getNumeroImei());
							arquivoTextoRoteiroEmpresa.setRota(rota);

							getControladorUtil().inserir(arquivoTextoRoteiroEmpresa);
						}
					}else{
						throw new ControladorException("atencao.limite.excedente.setorcomercial");
					}
				}

				// Erro no repositório
			}catch(Exception ex){
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}
		}
	}

	/**
	 * [UC0627] Gerar Arquivo Texto para Leiturista Gera o arquivo texto para o
	 * roteiro empresa. [SB0001] - Gerar Arquivo Texto
	 * 
	 * @author Pedro Alexandre
	 * @date 03/08/2007
	 * @param colecaoDadosMovimentoRoteiroEmpresa
	 * @param faturamentoGrupo
	 * @return
	 * @throws ControladorException
	 */
	private Object[] gerarArquivoTextoParaRoteiroEmpresa(Collection<Object[]> colecaoDadosMovimentoRoteiroEmpresa,
					FaturamentoGrupo faturamentoGrupo) throws ControladorException{

		Object[] dadosRoteiroEmpresa = new Object[12];
		StringBuilder arquivoRoteiroEmpresa = new StringBuilder();

		// declara os maps que ira armazenar os setores comerciais e as quadras
		Map<Integer, Integer> mapSetorComercial = new HashMap();
		Map<Integer, Integer> mapQuadraInicial = new HashMap();
		Map<Integer, Integer> mapQuadraFinal = new HashMap();

		Integer cont = 1;

		Integer codigoSetorComercial1 = null;
		Integer numeroQuadraInicial1 = null;
		Integer numeroQuadraFinal1 = null;

		Integer codigoSetorComercial2 = null;
		Integer numeroQuadraInicial2 = null;
		Integer numeroQuadraFinal2 = null;

		Integer codigoSetorComercial3 = null;
		Integer numeroQuadraInicial3 = null;
		Integer numeroQuadraFinal3 = null;

		// contador da quantidade de imóveis
		Integer qtdImoveis = 0;

		Integer idLocalidadePrimeiroImovel = null;
		boolean primeiraVez = true;

		Integer setorComercialTemp = null;
		Integer idQuadraAnterior = null;

		/*
		 * 0 - id da localidade 1 - código do setor comercial 2 - número da
		 * quadra 3 - número do lote do imóvel 4 - número do sublote do imóvel 5
		 * - id do tipo de medição 6 - inscrição do imóvel 7 - id do perfil do
		 * imóvel 8 - nome do cliente usuário 9 - endereço do imóvel 10 - id da
		 * marca do hidrômetro 11 - número do hidrometro 12 - id da capacidade
		 * do hidrômetro 13 - id do local da instalação de hidrômetro 14 - data
		 * da instalação de hidrômetro 15 - id da proteção do hidrômetro 16 - id
		 * da situação da ligação de água 17 - id da situação da ligação de
		 * esgoto 18 - descrição abreviada da categoria do imóvel 19 -
		 * quantidades de economias 20 - leitura anterior 21 - faixa de leitura
		 * esperada inicial 22 - faixa de leitura esperada final
		 */
		for(Object[] dadosMovimentoRoteiroEmpresa : colecaoDadosMovimentoRoteiroEmpresa){

			// recupera as informações do movimento roteiro empresa
			Integer idLocalidade = (Integer) dadosMovimentoRoteiroEmpresa[0];
			Integer codigoSetorComercial = (Integer) dadosMovimentoRoteiroEmpresa[1];
			Integer numeroQuadra = (Integer) dadosMovimentoRoteiroEmpresa[2];
			String numeroLote = (String) dadosMovimentoRoteiroEmpresa[3];
			String numeroSubLote = (String) dadosMovimentoRoteiroEmpresa[4];
			Integer idTipoMedicao = (Integer) dadosMovimentoRoteiroEmpresa[5];
			Integer matriculaImovel = (Integer) dadosMovimentoRoteiroEmpresa[6];
			Integer idPerfilImovel = (Integer) dadosMovimentoRoteiroEmpresa[7];
			String nomeCliente = (String) dadosMovimentoRoteiroEmpresa[8];
			String enderecoImovel = (String) dadosMovimentoRoteiroEmpresa[9];
			Integer idMarcaHidrometro = (Integer) dadosMovimentoRoteiroEmpresa[10];
			String numeroHidrometro = (String) dadosMovimentoRoteiroEmpresa[11];
			Integer idCapacidadeHidrometro = (Integer) dadosMovimentoRoteiroEmpresa[12];
			Integer idLocalInstalacaoHidrometro = (Integer) dadosMovimentoRoteiroEmpresa[13];
			Date dataInstalacaoHidrometro = (Date) dadosMovimentoRoteiroEmpresa[14];
			Integer idProtecaoHidrometro = (Integer) dadosMovimentoRoteiroEmpresa[15];
			Integer idSituacaoLigacaoAgua = (Integer) dadosMovimentoRoteiroEmpresa[16];
			Integer idSituacaoLigacaoEsgoto = (Integer) dadosMovimentoRoteiroEmpresa[17];
			String descricaoAbreviadaCategoriaImovel = (String) dadosMovimentoRoteiroEmpresa[18];
			Short quantidadeEconomia = (Short) dadosMovimentoRoteiroEmpresa[19];
			Integer numeroLeituraAnterior = (Integer) dadosMovimentoRoteiroEmpresa[20];
			Integer numeroFaixaLeituraEsperadaInicial = (Integer) dadosMovimentoRoteiroEmpresa[21];
			Integer numeroFaixaLeituraEsperadaFinal = (Integer) dadosMovimentoRoteiroEmpresa[22];
			Integer idFaturamentoGrupo = faturamentoGrupo.getId();

			// caso a datade instalação do hidrômetro estiver nula
			// adiciona zeros no lugar
			String dataInstalacaoHidrometroFormatada = "";
			if(dataInstalacaoHidrometro == null){
				dataInstalacaoHidrometroFormatada = "000000";
			}else{
				dataInstalacaoHidrometroFormatada = Util.formatarDataSemBarra(dataInstalacaoHidrometro).substring(2);
			}

			// caso o tipo de medição não tenha sido informada atribui 0(zero)
			if(idTipoMedicao == null){
				idTipoMedicao = 0;
			}

			// caso o nome do cliente não for informado adicionar espaços em
			// branco
			if(nomeCliente == null){
				nomeCliente = "";
			}

			// caso o endereço do imóvel não for informado adicionar espaços em
			// branco
			if(enderecoImovel == null){
				enderecoImovel = "";
			}

			// caso a marca do hidrômetro não for informada
			// adicionar espaço em braco , caso contrário
			// informar o id da marca do hidrômetro
			String marcaHidrometro = null;
			// Obs: Vai ficar com 1 digito por enquanto
			// depois ira mudar para dois digitos
			if(idMarcaHidrometro == null){
				marcaHidrometro = " ";
			}else{
				if(idMarcaHidrometro.toString().length() > 1){
					marcaHidrometro = (Util.adicionarZerosEsquedaNumero(1, idMarcaHidrometro + "")).substring(0, 1);
				}else{
					marcaHidrometro = idMarcaHidrometro + "";
				}
			}

			/*
			 * if (idMarcaHidrometro == null) { marcaHidrometro = " "; } else {
			 * marcaHidrometro = Util.adicionarZerosEsquedaNumero(2,
			 * idMarcaHidrometro+ ""); }
			 */
			// caso o número do hidrômetro não for informado
			// adicionar espaço em braco , caso contrário
			// informar o id o número do hidrômetro
			String numeroHidrometroFormatado = null;
			if(numeroHidrometro == null || numeroHidrometro.trim().equals("")){
				numeroHidrometroFormatado = "          ";
			}else{
				numeroHidrometroFormatado = Util.adicionarZerosEsquedaNumero(10, numeroHidrometro);
			}

			// caso a capacidade do hidrômetro não for informada
			// adicionar espaço em braco , caso contrário
			// informar o id da capacidade do hidrômetro
			String capacidadeHidrometro = null;
			if(idCapacidadeHidrometro == null){
				capacidadeHidrometro = " ";
			}else{
				capacidadeHidrometro = idCapacidadeHidrometro.toString();
			}

			// caso local de instalação do hidrômetro não for informado
			// adicionar espaço em braco , caso contrário
			// informar o id do local da instalação do hidrômetro
			String localInstalacaoHidrometro = null;
			if(idLocalInstalacaoHidrometro == null){
				localInstalacaoHidrometro = " ";
			}else{
				localInstalacaoHidrometro = idLocalInstalacaoHidrometro.toString();
			}

			// caso a proteção do hidrômetro não for informada
			// adicionar espaço em braco , caso contrário
			// informar o id da proteção do hidrômetro
			String protecaoInstalacaoHidrometro = null;
			if(idProtecaoHidrometro == null){
				protecaoInstalacaoHidrometro = " ";
			}else{
				protecaoInstalacaoHidrometro = idProtecaoHidrometro.toString();
			}

			// caso a descrição abreviada da categoria do imóvel não for
			// informada
			// adicionar espaço em braco
			if(descricaoAbreviadaCategoriaImovel == null){
				descricaoAbreviadaCategoriaImovel = "";
			}

			// caso a quantidade de economias não for informada
			// informar zero
			if(quantidadeEconomia == null){
				quantidadeEconomia = 0;
			}

			// caso o nº da leitura anterior não for informada
			// informar zero
			// caso contrario criptografar a leitura anterior
			String leituraAnteriorCriptografada = null;
			if(numeroLeituraAnterior == null){
				leituraAnteriorCriptografada = Criptografia.encrypt("000000");
			}else{
				leituraAnteriorCriptografada = Criptografia.encrypt(Util.adicionarZerosEsquedaNumero(6, numeroLeituraAnterior + ""));
			}

			// caso o nº de faixa leitura esperada inicial
			// não for informada, informar zero
			String numeroFaixaLeituraEsperadaInicialCriptografada = null;
			if(numeroFaixaLeituraEsperadaInicial == null){
				numeroFaixaLeituraEsperadaInicialCriptografada = Criptografia.encrypt("000000");
			}else{
				numeroFaixaLeituraEsperadaInicialCriptografada = Criptografia.encrypt(Util.adicionarZerosEsquedaNumero(6,
								numeroFaixaLeituraEsperadaInicial + ""));
			}

			// caso o nº de faixa leitura esperada final
			// não for informada, informar zero
			String numeroFaixaLeituraEsperadaFinalCriptografada = null;
			if(numeroFaixaLeituraEsperadaFinal == null){
				numeroFaixaLeituraEsperadaFinalCriptografada = Criptografia.encrypt("000000");
			}else{
				numeroFaixaLeituraEsperadaFinalCriptografada = Criptografia.encrypt(Util.adicionarZerosEsquedaNumero(6,
								numeroFaixaLeituraEsperadaFinal + ""));
			}

			// adiciona as informações no txt
			arquivoRoteiroEmpresa.append(Util.adicionarZerosEsquedaNumero(3, idLocalidade + ""));
			arquivoRoteiroEmpresa.append(Util.adicionarZerosEsquedaNumero(3, codigoSetorComercial + ""));
			arquivoRoteiroEmpresa.append(Util.adicionarZerosEsquedaNumero(3, numeroQuadra + ""));
			arquivoRoteiroEmpresa.append(Util.adicionarZerosEsquedaNumero(4, numeroLote));
			arquivoRoteiroEmpresa.append(Util.adicionarZerosEsquedaNumero(3, numeroSubLote));
			arquivoRoteiroEmpresa.append(idTipoMedicao);
			arquivoRoteiroEmpresa.append(Util.adicionarZerosEsquedaNumero(2, idFaturamentoGrupo + ""));
			arquivoRoteiroEmpresa.append(Util.adicionarZerosEsquedaNumero(8, matriculaImovel + ""));
			arquivoRoteiroEmpresa.append(idPerfilImovel);
			arquivoRoteiroEmpresa.append(Util.completaString(nomeCliente, 25));
			arquivoRoteiroEmpresa.append(Util.completaString(enderecoImovel, 50));
			arquivoRoteiroEmpresa.append(marcaHidrometro);
			arquivoRoteiroEmpresa.append(numeroHidrometroFormatado);
			arquivoRoteiroEmpresa.append(capacidadeHidrometro);
			arquivoRoteiroEmpresa.append(localInstalacaoHidrometro);
			arquivoRoteiroEmpresa.append(dataInstalacaoHidrometroFormatada);
			arquivoRoteiroEmpresa.append(protecaoInstalacaoHidrometro);
			arquivoRoteiroEmpresa.append(idSituacaoLigacaoAgua);
			arquivoRoteiroEmpresa.append(idSituacaoLigacaoEsgoto);
			arquivoRoteiroEmpresa.append(Util.completaString(descricaoAbreviadaCategoriaImovel, 3));
			arquivoRoteiroEmpresa.append(Util.adicionarZerosEsquedaNumero(3, quantidadeEconomia + ""));
			arquivoRoteiroEmpresa.append(leituraAnteriorCriptografada);
			arquivoRoteiroEmpresa.append(numeroFaixaLeituraEsperadaInicialCriptografada);
			arquivoRoteiroEmpresa.append(numeroFaixaLeituraEsperadaFinalCriptografada);
			arquivoRoteiroEmpresa.append(System.getProperty("line.separator"));

			// incrementa a quantidade de imoveis
			qtdImoveis++;

			// caso seja a primeira vez
			if(primeiraVez){
				primeiraVez = false;
				mapSetorComercial.put(cont, codigoSetorComercial);
				mapQuadraInicial.put(cont, numeroQuadra);

				idLocalidadePrimeiroImovel = idLocalidade;
				setorComercialTemp = codigoSetorComercial;

				// caso só exista um único registro a quadra final
				// sera a mesma que a inicial.
				if(colecaoDadosMovimentoRoteiroEmpresa.size() == 1){
					mapQuadraFinal.put(cont, numeroQuadra);
				}

			}else{
				// caso o setor comercial tenha mudado
				if(!setorComercialTemp.equals(codigoSetorComercial)){
					mapSetorComercial.put(cont + 1, codigoSetorComercial);
					mapQuadraFinal.put(cont, idQuadraAnterior);
					mapQuadraInicial.put(cont + 1, numeroQuadra);
					cont++;
					setorComercialTemp = codigoSetorComercial;
				}
			}
			// armazena a quadra anterior para utilizar como a quadra final do
			// setor comercial
			idQuadraAnterior = numeroQuadra;
		}

		// caso o o ultimo setor comercial ainda não estiver com a quadra final
		if(mapSetorComercial.get(cont) != null){
			mapQuadraFinal.put(cont, idQuadraAnterior);
		}

		/*
		 * Recupera os setores comerciais e as quadras inicial e final
		 * dependendo da quantidade inserida no map.
		 */
		if(mapSetorComercial.size() == 1){
			codigoSetorComercial1 = mapSetorComercial.get(1);
			numeroQuadraInicial1 = mapQuadraInicial.get(1);
			numeroQuadraFinal1 = mapQuadraFinal.get(1);

			codigoSetorComercial2 = null;
			numeroQuadraInicial2 = null;
			numeroQuadraFinal2 = null;

			codigoSetorComercial3 = null;
			numeroQuadraInicial3 = null;
			numeroQuadraFinal3 = null;

		}else if(mapSetorComercial.size() == 2){
			codigoSetorComercial1 = mapSetorComercial.get(1);
			numeroQuadraInicial1 = mapQuadraInicial.get(1);
			numeroQuadraFinal1 = mapQuadraFinal.get(1);

			codigoSetorComercial2 = mapSetorComercial.get(2);
			numeroQuadraInicial2 = mapQuadraInicial.get(2);
			numeroQuadraFinal2 = mapQuadraFinal.get(2);

			codigoSetorComercial3 = null;
			numeroQuadraInicial3 = null;
			numeroQuadraFinal3 = null;

		}else if(mapSetorComercial.size() == 3){
			codigoSetorComercial1 = mapSetorComercial.get(1);
			numeroQuadraInicial1 = mapQuadraInicial.get(1);
			numeroQuadraFinal1 = mapQuadraFinal.get(1);

			codigoSetorComercial2 = mapSetorComercial.get(2);
			numeroQuadraInicial2 = mapQuadraInicial.get(2);
			numeroQuadraFinal2 = mapQuadraFinal.get(2);

			codigoSetorComercial3 = mapSetorComercial.get(3);
			numeroQuadraInicial3 = mapQuadraInicial.get(3);
			numeroQuadraFinal3 = mapQuadraFinal.get(3);
		}

		// armazena os dados necessarios para inserir o
		// ArquivoTextoParaRoteiroEmpresa
		// no array de retorno.
		dadosRoteiroEmpresa[0] = arquivoRoteiroEmpresa;
		dadosRoteiroEmpresa[1] = codigoSetorComercial1;
		dadosRoteiroEmpresa[2] = numeroQuadraInicial1;
		dadosRoteiroEmpresa[3] = numeroQuadraFinal1;
		dadosRoteiroEmpresa[4] = codigoSetorComercial2;
		dadosRoteiroEmpresa[5] = numeroQuadraInicial2;
		dadosRoteiroEmpresa[6] = numeroQuadraFinal2;
		dadosRoteiroEmpresa[7] = codigoSetorComercial3;
		dadosRoteiroEmpresa[8] = numeroQuadraInicial3;
		dadosRoteiroEmpresa[9] = numeroQuadraFinal3;
		dadosRoteiroEmpresa[10] = qtdImoveis;
		dadosRoteiroEmpresa[11] = idLocalidadePrimeiroImovel;

		return dadosRoteiroEmpresa;
	}

	/**
	 * [UC0627] Gerar Arquivo Texto para Leituristas Gera o nome do arquivo
	 * texto para o roteiro empresa. [FS0003] Nome do arquivo texto
	 * 
	 * @author Pedro Alexandre
	 * @date 06/08/2007
	 * @param idLocalidade
	 * @param idFaturamentoGrupo
	 * @param sequencial
	 * @return
	 * @throws ControladorException
	 */
	private String gerarNomeArquivoTextoParaRoteiroEmpresa(Integer idLocalidade, Integer idFaturamentoGrupo, Integer sequencial)
					throws ControladorException{

		// variável que vai armazenar o nome do arquivo gerado.
		String nomeArquivo = null;

		/*
		 * concatena o nome do arquivo com : LL - loca_id do 1º imóvel
		 * processado SS - sequencial G - letra "G" fixo FF - ftgr_id id do
		 * grupo de faturamento
		 */
		nomeArquivo = Util.adicionarZerosEsquedaNumero(3, idLocalidade + "") + Util.adicionarZerosEsquedaNumero(2, sequencial + "") + "G"
						+ Util.adicionarZerosEsquedaNumero(2, idFaturamentoGrupo + "") + ".txt";

		return nomeArquivo;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0005] Gerar Relação(ROL) em TXT -
	 * CAER
	 * 
	 * @author Sávio Luiz
	 * @date 13/08/2007
	 * @param idRota
	 * @param idLeituraTipo
	 * @throws ErroRepositorioException
	 */
	protected boolean gerarRelacaoTxt(StringBuilder arquivoTxtLinha, Object[] arrayImoveisPorRota, Integer anoMesCorrente,
					boolean hidrometroSelecionado, SistemaParametro sistemaParametro){

		boolean ligacaoAgua = false;
		boolean ligacaoPoco = false;
		Imovel imovelParaSerGerado = new Imovel();
		Short numeroDigitosHidrometro = null;
		StringBuilder dadosHidrometro = new StringBuilder();
		StringBuilder arquivoTxtLinhaAux = new StringBuilder();
		// parte que coloca alguma dado para não entrar eu uma situação não
		// desejada do metodo pesquisarFaixaEsperadaOuFalsa
		dadosHidrometro.append("Qualquer dado");

		Object[] dadosLinhaTxtHidSelecionaldo = new Object[2];

		try{

			if(arrayImoveisPorRota != null){
				arquivoTxtLinhaAux.append(System.getProperty("line.separator"));
				// id do imovel
				if(arrayImoveisPorRota[0] != null){
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(7, "" + (Integer) arrayImoveisPorRota[0]));
					imovelParaSerGerado.setId((Integer) arrayImoveisPorRota[0]);

				}else{
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(7, ""));
				}

				// id da rota
				if(arrayImoveisPorRota[1] != null){
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(4, "" + arrayImoveisPorRota[1]));
					Rota rota = new Rota();
					rota.setId((Integer) arrayImoveisPorRota[1]);
					rota.setCodigo((Short) arrayImoveisPorRota[18]);
					if(arrayImoveisPorRota[15] != null){
						rota.setPercentualGeracaoFaixaFalsa((BigDecimal) arrayImoveisPorRota[15]);
					}
					Quadra quadra = new Quadra();
					quadra.setRota(rota);
					imovelParaSerGerado.setQuadra(quadra);
					imovelParaSerGerado.setRota(rota);
				}else{
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(4, ""));
				}

				// numero quadra
				if(arrayImoveisPorRota[2] != null){
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(4, "" + arrayImoveisPorRota[2]));
				}else{
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(4, ""));
				}

				// lote do imovel
				if(arrayImoveisPorRota[3] != null){
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(3, "" + arrayImoveisPorRota[3]));
				}else{
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(3, ""));
				}

				// situação de ligação de agua
				if(arrayImoveisPorRota[4] != null){
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(3, "" + arrayImoveisPorRota[4]));
				}else{
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(3, ""));
				}

				// id logradouro
				if(arrayImoveisPorRota[5] != null){
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(4, "" + arrayImoveisPorRota[5]));
				}else{
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(4, ""));
				}

				// nome logradouro
				if(arrayImoveisPorRota[6] != null){
					String logradouroCompleto = "";

					// descrição abreviado tipo
					if(arrayImoveisPorRota[17] != null){
						logradouroCompleto += "" + arrayImoveisPorRota[17];
					}
					// descrição abreviado titulo
					if(arrayImoveisPorRota[16] != null){
						logradouroCompleto += "" + arrayImoveisPorRota[16];
					}

					logradouroCompleto += "" + arrayImoveisPorRota[6];

					arquivoTxtLinhaAux.append(Util.completaString(logradouroCompleto, 25));

				}else{
					arquivoTxtLinhaAux.append(Util.completaString("", 25));
				}

				// numero do imovel
				if(arrayImoveisPorRota[7] != null){
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(5, "" + arrayImoveisPorRota[7]));
				}else{
					arquivoTxtLinhaAux.append(Util.adicionarZerosEsquedaNumero(5, ""));
				}

				// complemento do imovel
				if(arrayImoveisPorRota[8] != null){
					arquivoTxtLinhaAux.append(Util.completaString("" + arrayImoveisPorRota[8], 3));
				}else{
					arquivoTxtLinhaAux.append(Util.completaString("", 3));
				}

				String numeroHidrometroAgua = null;
				String numeroHidrometroPoco = null;

				// medição tipo Agua
				if(arrayImoveisPorRota[9] != null){
					ligacaoAgua = true;
					if(arrayImoveisPorRota[10] != null){
						numeroHidrometroAgua = "" + arrayImoveisPorRota[10];
						numeroDigitosHidrometro = (Short) arrayImoveisPorRota[11];
					}
				}

				// medição tipo Poco
				if(arrayImoveisPorRota[12] != null){
					ligacaoPoco = true;
					if(arrayImoveisPorRota[13] != null){
						numeroHidrometroPoco = "" + arrayImoveisPorRota[13];
						numeroDigitosHidrometro = (Short) arrayImoveisPorRota[14];
					}
				}

				// caso sela ligacao de agua e ligação de esgoto então é gerado
				// 2 linhas
				Integer anoMesAnterior = Util.subtrairData(anoMesCorrente);
				if(ligacaoAgua && ligacaoPoco){
					Object[] dadosAuxSegundaParte = retornaDadosFaixa(anoMesAnterior, imovelParaSerGerado, ligacaoAgua, ligacaoPoco,
									hidrometroSelecionado, dadosHidrometro, sistemaParametro, numeroDigitosHidrometro);
					StringBuilder arquivoTxtAuxSegundaParte = (StringBuilder) dadosAuxSegundaParte[0];
					hidrometroSelecionado = (Boolean) dadosAuxSegundaParte[1];
					arquivoTxtLinha.append(arquivoTxtLinhaAux);
					if(numeroHidrometroAgua != null){
						arquivoTxtLinha.append(Util.completaString("" + numeroHidrometroAgua, 10));
					}else{
						arquivoTxtLinha.append(Util.completaString("", 10));
					}
					arquivoTxtLinha.append(arquivoTxtAuxSegundaParte);
					// faz a segunda parte com ligação agua igual a false, pois
					// quando os 2 são true ele pega os dados de ligação agua.
					ligacaoAgua = false;

					// cria outra linha com os dados de ligação esgoto
					dadosAuxSegundaParte = retornaDadosFaixa(anoMesAnterior, imovelParaSerGerado, ligacaoAgua, ligacaoPoco,
									hidrometroSelecionado, dadosHidrometro, sistemaParametro, numeroDigitosHidrometro);
					arquivoTxtAuxSegundaParte = (StringBuilder) dadosAuxSegundaParte[0];
					hidrometroSelecionado = (Boolean) dadosAuxSegundaParte[1];
					arquivoTxtLinha.append(arquivoTxtLinhaAux);
					if(numeroHidrometroPoco != null){
						arquivoTxtLinha.append(Util.completaString("" + numeroHidrometroPoco, 10));
					}else{
						arquivoTxtLinha.append(Util.completaString("", 10));
					}

					arquivoTxtLinha.append(arquivoTxtAuxSegundaParte);

				}else{
					Object[] dadosAuxSegundaParte = retornaDadosFaixa(anoMesAnterior, imovelParaSerGerado, ligacaoAgua, ligacaoPoco,
									hidrometroSelecionado, dadosHidrometro, sistemaParametro, numeroDigitosHidrometro);
					StringBuilder arquivoTxtAuxSegundaParte = (StringBuilder) dadosAuxSegundaParte[0];
					hidrometroSelecionado = (Boolean) dadosAuxSegundaParte[1];
					arquivoTxtLinha.append(arquivoTxtLinhaAux);
					if(ligacaoAgua){
						if(numeroHidrometroAgua != null){
							arquivoTxtLinha.append(Util.completaString("" + numeroHidrometroAgua, 10));
						}else{
							arquivoTxtLinha.append(Util.completaString("", 10));
						}
					}else{
						if(numeroHidrometroPoco != null){
							arquivoTxtLinha.append(Util.completaString("" + numeroHidrometroPoco, 10));
						}else{
							arquivoTxtLinha.append(Util.completaString("", 10));
						}
					}
					arquivoTxtLinha.append(arquivoTxtAuxSegundaParte);

				}

			}

		}catch(Exception e){ // Este catch serve para interceptar
			e.printStackTrace();

			throw new EJBException(e);
		}
		dadosLinhaTxtHidSelecionaldo[0] = arquivoTxtLinha;
		dadosLinhaTxtHidSelecionaldo[1] = hidrometroSelecionado;

		return hidrometroSelecionado;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0005] Gerar Relação(ROL) em TXT -
	 * CAER
	 * 
	 * @author Sávio Luiz
	 * @date 13/08/2007
	 * @param idRota
	 * @param idLeituraTipo
	 * @throws ErroRepositorioException
	 */
	protected Object[] retornaDadosFaixa(Integer anoMesAnterior, Imovel imovelParaSerGerado, boolean ligacaoAgua, boolean ligacaoPoco,
					boolean hidrometroSelecionado, StringBuilder dadosHidrometro, SistemaParametro sistemaParametro,
					Short numeroDigitosHidrometro){

		StringBuilder dadosFaixaTxt = new StringBuilder();
		Object[] dadosLinhaTxtHidSelecionaldo = new Object[2];

		try{

			// Leitura anterior

			String leituraAnterior = null;
			Integer idMedicaoTipo = null;
			MedicaoHistorico medicaoHistorico = null;
			Object[] retorno = pesquisaLeituraAnterior(ligacaoAgua, ligacaoPoco, anoMesAnterior, imovelParaSerGerado);
			// verifica se a leitura anterior é diferente de nula
			if(retorno[0] != null){
				leituraAnterior = retorno[0].toString();
			}
			// verifica se a leitura situação atual é diferente de
			// nula
			if(retorno[1] != null){
				medicaoHistorico = (MedicaoHistorico) retorno[1];
			}
			// verifica se o id da medição tipo é diferente de nula
			if(retorno[2] != null){
				idMedicaoTipo = (Integer) retorno[2];
			}

			// leitura minima
			// Faixa de leitura esperada

			Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovelParaSerGerado, dadosHidrometro, leituraAnterior,
							medicaoHistorico, idMedicaoTipo, sistemaParametro, hidrometroSelecionado, numeroDigitosHidrometro);

			StringBuilder faixaInicialFinalString = (StringBuilder) faixaInicialFinal[0];
			hidrometroSelecionado = Boolean.parseBoolean(faixaInicialFinal[1].toString());

			boolean faixaFalsaLeitura = Boolean.parseBoolean(faixaInicialFinal[2].toString());

			int faixaInicialEsperada = 0;
			int faixaFinalEsperada = 0;
			if(faixaFalsaLeitura){
				faixaInicialEsperada = Integer.parseInt(faixaInicialFinal[3].toString());

				faixaFinalEsperada = Integer.parseInt(faixaInicialFinal[4].toString());

				dadosFaixaTxt.append(Util.adicionarZerosEsquedaNumero(7, "" + faixaInicialEsperada));
				// leitura maxima
				dadosFaixaTxt.append(Util.adicionarZerosEsquedaNumero(7, "" + faixaFinalEsperada));
			}else{
				dadosFaixaTxt.append(Util.adicionarZerosEsquedaNumero(14, "" + faixaInicialFinalString));
			}

			// zeros
			dadosFaixaTxt.append(Util.adicionarZerosEsquedaNumero(30, ""));
		}catch(Exception e){ // Este catch serve para interceptar
			e.printStackTrace();

			throw new EJBException(e);
		}
		dadosLinhaTxtHidSelecionaldo[0] = dadosFaixaTxt;
		dadosLinhaTxtHidSelecionaldo[1] = hidrometroSelecionado;
		return dadosLinhaTxtHidSelecionaldo;
	}

	/**
	 * Pesquisa os roteiros empresa de acordo com os parâmetros informado pelo
	 * usuário [UC0370] - Filtrar Roteiro Empresa
	 * 
	 * @author Thiago Tenório
	 * @date 29/08/2007
	 * @param empresa
	 * @param idLocalidade
	 * @param idLeiturista
	 * @param idSetorComercial
	 * @param indicadorUso
	 * @param numeroPagina
	 * @return Collection
	 */
	public Collection pesquisarRoteiroEmpresa(String idEmpresa, String idLocalidade, String codigoSetorComercial, String idLeiturista,
					String indicadorUso, Integer numeroPagina) throws ControladorException{

		Collection roteiros = new ArrayList();

		try{

			Collection retorno = repositorioMicromedicao.pesquisarRoteiroEmpresa(idEmpresa, idLocalidade, codigoSetorComercial,
							idLeiturista, indicadorUso, numeroPagina);

			// verifica se a houve algum elemento de retorno
			/*
			 * consulta = "select distinct(re.roem_id) as id, " + //[0] id
			 * roteiro empresa "re.empr_id as empresa, " + // [1] id da empresa
			 * "emp.empr_nmempresa, " + // [2] nome da empresa "loc.loca_id, " +
			 * // [3] id da localidade "loc.loca_nmlocalidade, " + // [4] nome
			 * da localidade "re.leit_id as leit, " + // [5] id leiturista
			 * "cli.clie_nmcliente, " + // [6] nome do cliente
			 * "func.func_nmfuncionario, " + // [7] nome do funcionario
			 * "sc.stcm_cdsetorcomercial " + // [8] Código setor comercial
			 */
			if(retorno != null && !retorno.isEmpty()){
				Iterator iteratorRetorno = retorno.iterator();
				while(iteratorRetorno.hasNext()){
					Object[] dadosRetorno = (Object[]) iteratorRetorno.next();
					RoteiroEmpresaHelper roteiroEmpresaHelper = new RoteiroEmpresaHelper();
					roteiroEmpresaHelper.setIdRoteiroEmpresa((Integer) dadosRetorno[0]);
					roteiroEmpresaHelper.setIdEmpresa((Integer) dadosRetorno[1]);
					roteiroEmpresaHelper.setNomeEmpresa((String) dadosRetorno[2]);
					roteiroEmpresaHelper.setIdLocalidade((Integer) dadosRetorno[3]);
					roteiroEmpresaHelper.setNomeLocalidade((String) dadosRetorno[4]);
					if(dadosRetorno[7] != null){
						roteiroEmpresaHelper.setNomeLeiturista((String) dadosRetorno[7]);
					}else{
						roteiroEmpresaHelper.setNomeLeiturista((String) dadosRetorno[6]);
					}
					roteiroEmpresaHelper.setCodigoSetorComercial((Integer) dadosRetorno[8]);
					roteiros.add(roteiroEmpresaHelper);
				}
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return roteiros;

	}

	/**
	 * Verifica a quantidade de registros retornados da pesquisa de equipe
	 * [UC0370] - Filtrar Equipe
	 * 
	 * @author Rafael Corrêa
	 * @date 09/11/06
	 * @param idEquipe
	 * @param nome
	 * @param placa
	 * @param cargaTrabalho
	 * @param idUnidade
	 * @param idFuncionario
	 * @param idPerfilServico
	 * @param indicadorUso
	 * @return int
	 */
	public int pesquisarRoteiroEmpresaCount(String idEmpresa, String idLocalidade, String codigoSetorComercial, String idLeiturista,
					String indicadorUso) throws ControladorException{

		int retorno = 0;

		try{

			retorno = repositorioMicromedicao.pesquisarRoteiroEmpresaCount(idEmpresa, idLocalidade, codigoSetorComercial, idLeiturista,
							indicadorUso);

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0005] Gerar Relação(ROL) em TXT -
	 * CAER
	 * 
	 * @author Sávio Luiz
	 * @date 24/08/2007
	 * @param idRota
	 * @param idLeituraTipo
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosLocalProtecaoTipoLigacaoAgua(Integer idImovel) throws ControladorException{

		Object[] dados = null;
		try{
			dados = repositorioMicromedicao.pesquisarDadosLocalProtecaoTipoLigacaoAgua(idImovel);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return dados;
	}

	/**
	 * [UC00083] Gerar Dados para Leitura [SB0005] Gerar Relação(ROL) em TXT -
	 * CAER
	 * 
	 * @author Sávio Luiz
	 * @date 24/08/2007
	 * @param idRota
	 * @param idLeituraTipo
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosLocalProtecaoTipoTipoPoco(Integer idImovel) throws ControladorException{

		Object[] dados = null;
		try{
			dados = repositorioMicromedicao.pesquisarDadosLocalProtecaoTipoTipoPoco(idImovel);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return dados;
	}

	/**
	 * [UC0631] Processar Requisições do Dispositivo Móvel. [SB0001] Baixar
	 * Arquivo Texto para o Leiturista.
	 * 
	 * @author Thiago Nascimento
	 * @date 14/08/2007
	 * @param imei
	 * @return
	 * @throws ControladorException
	 */
	public byte[] baixarArquivoTextoParaLeitura(long imei) throws ControladorException{

		try{
			return this.repositorioMicromedicao.baixarArquivoTextoParaLeitura(imei);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0631] Processar Requisições do Dispositivo Móvel. Atualizar Situação
	 * do Arquivo Texto.
	 * 
	 * @author Thiago Nascimento
	 * @date 14/08/2007
	 * @param imei
	 * @param situacaoAnterior
	 * @param situacaoNova
	 * @throws ControladorException
	 */
	public void atualizarArquivoTextoEnviado(long imei, int situacaoAnterior, int situacaoNova) throws ControladorException{

		try{
			this.repositorioMicromedicao.atualizarArquivoTextoEnviado(imei, situacaoAnterior, situacaoNova);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0631] Processar Requisições do Dispositivo Móvel. [SB0002] Atualizar o
	 * movimento roteiro empresa.
	 * 
	 * @author Thiago Nascimento
	 * @date 14/08/2007
	 * @param dados
	 * @throws ControladorException
	 */
	public void atualiarRoteiro(Collection<DadosMovimentacao> dados) throws ControladorException{

		try{
			this.repositorioMicromedicao.atualiarRoteiro(dados);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos Gerar uma data de
	 * realização da atividade efetuar leitura para os imóveis que não tenha
	 * sido efetuado leitura no mês anterior.
	 * 
	 * @author Raphael Rossiter
	 * @data 05/09/2007
	 */
	public Date gerarDataRealizacaoLeituraAnterior(FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro)
					throws ControladorException{

		Date dataRealizada = null;

		Object[] cronogramaAtual = obterDataPrevistaRealizadaFaturamentoAtividadeCronograma(faturamentoGrupo, sistemaParametro
						.getAnoMesFaturamento());

		Date dataPrevistaLeituraAtual = null;
		if(cronogramaAtual != null && cronogramaAtual[0] != null){
			dataPrevistaLeituraAtual = (Date) cronogramaAtual[0];
		}

		Date dataRealizacaoLeituraAtual = null;
		if(cronogramaAtual != null && cronogramaAtual[1] != null){
			dataRealizacaoLeituraAtual = (Date) cronogramaAtual[1];
		}

		/*
		 * Caso exista data de realização da atividade efetuar leitura para o
		 * ano/mês de faturamento da tabela SistemaParametro com o grupo de
		 * faturamento informado: A data de realização será gerada a partir da
		 * data de realização atual menos 30 dias.
		 */
		if(dataRealizacaoLeituraAtual != null){
			dataRealizada = Util.subtrairNumeroDiasDeUmaData(dataRealizacaoLeituraAtual, 30);
		}

		/*
		 * Caso contrário: A data de realização será a data prevista do
		 * cronograma atual menos 30 dias
		 */
		else{

			if(dataPrevistaLeituraAtual == null){
				throw new ControladorException("atencao.pesquisa.cronograma_mensal_grupo_inexistente");
			}else{
				dataRealizada = Util.subtrairNumeroDiasDeUmaData(dataPrevistaLeituraAtual, 30);
			}
		}

		return dataRealizada;
	}

	/**
	 * [UC0712] (old[UC00082]) - Registrar Leituras e Anormalidades
	 * 
	 * @author Sávio Luiz
	 * @date 29/08/2007
	 * @author eduardo henrique
	 * @date 11/09/2008 Alterado para ser incluído o crédito de consumo,
	 *       volumeFaturadoAgua e volumeFaturadoEsgoto do Movimento_Roteiro,
	 *       para posterior cálculo no registro de histórico da medição.
	 * @author eduardo henrique
	 * @date 10/12/2008 Inclusão do ano/mês referência na consulta dos
	 *       Movimentos que serão processados.
	 * @param idGrupoFaturamento
	 * @param anoMesReferencia
	 * @throws ErroRepositorioException
	 */
	public Collection<MedicaoHistorico> criarMedicoesHistoricoRegistrarLeituraAnormalidade(Integer idGrupoFaturamento,
					Integer anoMesReferencia, Collection<Rota> colecaoRota) throws ControladorException{

		Collection<MedicaoHistorico> colecaoMedicaoHistorico = null;
		Collection<Integer> idRotas = new ArrayList<Integer>();
		if(!Util.isVazioOrNulo(colecaoRota)){
			for(Rota rota : colecaoRota){
				idRotas.add(rota.getId());
			}
		}
		try{
			Collection<MovimentoRoteiroEmpresa> colecaoMovimentoRoteiroEmpresa = repositorioMicromedicao
							.pesquisarColecaoMovimentoRoteiroEmpresaRegistrarLeituraAnormalidade(idGrupoFaturamento, anoMesReferencia,
											idRotas);

			if(colecaoMovimentoRoteiroEmpresa != null && !colecaoMovimentoRoteiroEmpresa.isEmpty()){

				colecaoMedicaoHistorico = new ArrayList();

				Iterator<MovimentoRoteiroEmpresa> iteMovimentoRoteiroEmpresa = colecaoMovimentoRoteiroEmpresa.iterator();
				MedicaoHistorico medicaoHistorico = null;
				while(iteMovimentoRoteiroEmpresa.hasNext()){
					medicaoHistorico = new MedicaoHistorico();
					MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = iteMovimentoRoteiroEmpresa.next();

					Imovel imovel = new Imovel();
					Localidade localidade = new Localidade();
					SetorComercial setorComercial = new SetorComercial();
					Quadra quadra = new Quadra();

					// imovel
					if(movimentoRoteiroEmpresa.getImovel() != null){

						imovel.setId(movimentoRoteiroEmpresa.getImovel().getId());
						// localidade
						if(movimentoRoteiroEmpresa.getLocalidade() != null){
							localidade.setId(movimentoRoteiroEmpresa.getLocalidade().getId());
						}
						imovel.setLocalidade(localidade);
						// setor comercial
						if(movimentoRoteiroEmpresa.getCodigoSetorComercial() != null){
							setorComercial.setCodigo(movimentoRoteiroEmpresa.getCodigoSetorComercial());
						}
						imovel.setSetorComercial(setorComercial);
						// Quadra
						if(movimentoRoteiroEmpresa.getNumeroQuadra() != null){
							quadra.setNumeroQuadra(movimentoRoteiroEmpresa.getNumeroQuadra());
						}
						imovel.setQuadra(quadra);
						// lote
						if(movimentoRoteiroEmpresa.getNumeroLoteImovel() != null){
							imovel.setLote(Short.valueOf(movimentoRoteiroEmpresa.getNumeroLoteImovel()));
						}
						// sublote
						if(movimentoRoteiroEmpresa.getNumeroSubLoteImovel() != null){
							imovel.setSubLote(Short.valueOf(movimentoRoteiroEmpresa.getNumeroSubLoteImovel()));
						}

					}
					medicaoHistorico.setImovel(imovel);

					// medição tipo
					if(movimentoRoteiroEmpresa.getMedicaoTipo() != null){

						MedicaoTipo medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId(movimentoRoteiroEmpresa.getMedicaoTipo().getId());
						medicaoHistorico.setMedicaoTipo(medicaoTipo);
					}


					// leitura do hidrometro
					if(movimentoRoteiroEmpresa.getNumeroLeitura() != null){
						medicaoHistorico.setLeituraAtualInformada(Integer.valueOf(movimentoRoteiroEmpresa.getNumeroLeitura()));
					}

					// leitura anormalidade informada
					if(movimentoRoteiroEmpresa.getLeituraAnormalidade() != null){
						medicaoHistorico.setLeituraAnormalidadeInformada(movimentoRoteiroEmpresa.getLeituraAnormalidade());
					}

					// data de leitura
					if(movimentoRoteiroEmpresa.getDataLeitura() != null){
						medicaoHistorico.setDataLeituraParaRegistrar(Util.formatarDataSemBarra(movimentoRoteiroEmpresa.getDataLeitura()));
					}

					// indicador de leitura
					if(movimentoRoteiroEmpresa.getIndicadorConfirmacaoLeitura() != null){
						medicaoHistorico.setIndicadorConfirmacaoLeitura("" + movimentoRoteiroEmpresa.getIndicadorConfirmacaoLeitura());
					}

					if(movimentoRoteiroEmpresa.getNumeroConsumoCreditoFaturado() != null){
						medicaoHistorico.setNumeroConsumoFaturadoLeitura(movimentoRoteiroEmpresa.getNumeroConsumoCreditoFaturado());
					}

					if(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoAgua() != null){
						medicaoHistorico.setNumeroConsumoFaturadoAguaLeitura(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoAgua());
					}

					if(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoEsgoto() != null){
						medicaoHistorico.setNumeroConsumoFaturadoEsgotoLeitura(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoEsgoto());
					}
					// seta o Funcionario
					if(movimentoRoteiroEmpresa.getLeiturista() != null && movimentoRoteiroEmpresa.getLeiturista().getFuncionario() != null){
						Funcionario funcionario = new Funcionario();
						funcionario.setId(movimentoRoteiroEmpresa.getLeiturista().getFuncionario().getId().intValue());
						medicaoHistorico.setFuncionario(funcionario);
					}
					if(movimentoRoteiroEmpresa.getLocalidade() != null){
						medicaoHistorico.setLocalidade(movimentoRoteiroEmpresa.getLocalidade());
					}
					if(movimentoRoteiroEmpresa.getRota() != null){
						medicaoHistorico.setRota(movimentoRoteiroEmpresa.getRota());
					}

					colecaoMedicaoHistorico.add(medicaoHistorico);
					medicaoHistorico = null;
				}
			}
		}catch(ErroRepositorioException e){
			e.printStackTrace();
		}
		return colecaoMedicaoHistorico;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 06/09/2007
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer obterConsumoMedioEmConsumoHistorico(Integer idImovel, Integer idLigacaoTipo) throws ControladorException{

		try{
			return this.repositorioMicromedicao.obterConsumoMedioEmConsumoHistorico(idImovel, idLigacaoTipo);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Pesquisa os roteiros empresas pelo grupo de faturamento [UC0627] Gerar
	 * Arquivo Texto para Leitura
	 * 
	 * @author Pedro Alexandre
	 * @date 13/09/2007
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarRoteiroEmpresaPorGrupoFaturamento(Integer idFaturamentoGrupo) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarRoteiroEmpresaPorGrupoFaturamento(idFaturamentoGrupo);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0629] Liberar Arquivo Texto para Leitura
	 * 
	 * @author Thiago Tenório
	 * @date 18/09/2007
	 * @throws ControladorException
	 */

	public void liberarArquivoTextoLeitura(ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa) throws ControladorException{

		// Verifica se todos os campos obrigatorios foram preenchidos

		if((arquivoTextoRoteiroEmpresa.getSituacaoTransmissaoLeitura() == null || arquivoTextoRoteiroEmpresa
						.getSituacaoTransmissaoLeitura().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Situação Texto para Leitura foi preenchido
		if(arquivoTextoRoteiroEmpresa.getSituacaoTransmissaoLeitura() == null
						|| arquivoTextoRoteiroEmpresa.getSituacaoTransmissaoLeitura().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO)){
			throw new ControladorException("atencao.Informe_entidade", null, " Situação Texto para Leitura");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroArquivoTextoRoteiroEmpresa filtroArquivoTextoRoteiroEmpresa = new FiltroArquivoTextoRoteiroEmpresa();
		filtroArquivoTextoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroArquivoTextoRoteiroEmpresa.ID,
						arquivoTextoRoteiroEmpresa.getId()));

		Collection colecaoArquivoTextoRoteiroEmpresaBase = getControladorUtil().pesquisar(filtroArquivoTextoRoteiroEmpresa,
						ArquivoTextoRoteiroEmpresa.class.getName());

		if(colecaoArquivoTextoRoteiroEmpresaBase == null || colecaoArquivoTextoRoteiroEmpresaBase.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresaBase = (ArquivoTextoRoteiroEmpresa) colecaoArquivoTextoRoteiroEmpresaBase
						.iterator().next();

		if(arquivoTextoRoteiroEmpresaBase.getUltimaAlteracao().after(arquivoTextoRoteiroEmpresa.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		arquivoTextoRoteiroEmpresa.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(arquivoTextoRoteiroEmpresa);

	}

	/**
	 * [UC0298] Manter Leiturista [] Atualizar Leiturista Metodo que atualiza o
	 * Leiturista
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * @throws ControladorException
	 */

	public void atualizarLeiturista(Leiturista leiturista) throws ControladorException{

		// Verifica se todos os campos obrigatorios foram preenchidos

		if((leiturista.getId() == null || leiturista.getId().equals("" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (leiturista.getCodigoDDD() == null || leiturista.getCodigoDDD().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
						&& (leiturista.getNumeroFone() == null || leiturista.getNumeroFone().equals(
										"" + ConstantesSistema.NUMERO_NAO_INFORMADO))){
			throw new ControladorException("atencao.filtro.nenhum_parametro_informado");

		}

		if(leiturista.getFuncionario() == null && leiturista.getCliente() == null){
			throw new ControladorException("atencao.informe_campo", null, "Funcionário ou Cliente");
		}

		if(leiturista.getCliente() != null && leiturista.getEmpresa() == null){
			throw new ControladorException("atencao.informe_campo", null, "Empresa do Cliente");
		}

		if(leiturista.getCodigoDDD() == null || leiturista.getCodigoDDD().equalsIgnoreCase("")){
			throw new ControladorException("atencao.informe_campo", null, "Código DDD do Município");
		}

		if(leiturista.getNumeroFone() == null || leiturista.getNumeroFone().equalsIgnoreCase("")){
			throw new ControladorException("atencao.informe_campo", null, "Número do Telefone");
		}

		// [FS0008]
		if(leiturista.getFuncionario() != null && leiturista.getCliente() != null){
			throw new ControladorException("atencao.informe_campo", null, "somente Funcionario ou Cliente para o Agente Comercial");
		}

		if(leiturista.getFuncionario() != null){
			// [FS0001]
			FiltroFuncionario filtroFuncionario = new FiltroFuncionario();
			filtroFuncionario.adicionarParametro(new ParametroSimples(FiltroFuncionario.ID, leiturista.getFuncionario().getId()));

			Collection colecaoFuncionarios = getControladorUtil().pesquisar(filtroFuncionario, Funcionario.class.getName());

			if(colecaoFuncionarios == null || colecaoFuncionarios.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_funcionario_inexistente", null, "" + leiturista.getFuncionario().getId());
			}

			// [FS0006] -- Verifica se o funcionário já foi cadastrado
			// anteriormente
			FiltroLeiturista filtroLeiturista = new FiltroLeiturista();
			filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.FUNCIONARIO_ID, leiturista.getFuncionario().getId()));
			filtroLeiturista.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroLeiturista.ID, leiturista.getId()));

			Collection colecaoLeituristas = getControladorUtil().pesquisar(filtroLeiturista, Leiturista.class.getName());
			if(colecaoLeituristas != null && !colecaoLeituristas.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_funcionario_ja_existe_cadastro", null, ""
								+ leiturista.getFuncionario().getId());
			}
		}else{ // Funcionário ou cliente devem ser informados
			// [FS0002]
			FiltroCliente filtroCliente = new FiltroCliente();
			filtroCliente.adicionarParametro(new ParametroSimples(FiltroCliente.ID, leiturista.getCliente().getId()));

			Collection colecaoClientes = getControladorUtil().pesquisar(filtroCliente, Cliente.class.getName());

			if(colecaoClientes == null || colecaoClientes.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_cliente_inexistente", null, "" + leiturista.getCliente().getId());
			}

			// [FS0006] -- Verifica se o cliente já foi cadastrado anteriormente
			FiltroLeiturista filtroLeiturista = new FiltroLeiturista();
			filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.CLIENTE_ID, leiturista.getCliente().getId()));
			filtroLeiturista.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroLeiturista.ID, leiturista.getId()));

			Collection colecaoLeituristas = getControladorUtil().pesquisar(filtroLeiturista, Leiturista.class.getName());
			if(colecaoLeituristas != null && !colecaoLeituristas.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_cliente_ja_existe_cadastro", null, "" + leiturista.getCliente().getId());
			}
		}
		// [FS0003] -- Verifica se existe o DDD para algum Município
		FiltroMunicipio filtroMunicipio = new FiltroMunicipio();
		filtroMunicipio.adicionarParametro(new ParametroSimples(FiltroMunicipio.DDD, leiturista.getCodigoDDD()));

		Collection colecaoDDDs = getControladorUtil().pesquisar(filtroMunicipio, Municipio.class.getName());
		if(colecaoDDDs == null || colecaoDDDs.isEmpty()){
			// // levanta a exceção para a próxima camada
			throw new ControladorException("atencao.leiturista_municipio_inexistente", null, "" + leiturista.getCodigoDDD());
		}

		// [FS0009] -- Verifica se existe o IMEI para outro Leiturista
		if(leiturista.getNumeroImei() != null){
			FiltroLeiturista filtroLeiturista = new FiltroLeiturista();
			filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.NUMERO_IMEI, leiturista.getNumeroImei()));
			filtroLeiturista.adicionarParametro(new ParametroSimplesDiferenteDe(FiltroLeiturista.ID, leiturista.getId()));

			Collection colecaoLeituristas = getControladorUtil().pesquisar(filtroLeiturista, Leiturista.class.getName());
			if(colecaoLeituristas != null && !colecaoLeituristas.isEmpty()){
				// // levanta a exceção para a próxima camada
				throw new ControladorException("atencao.leiturista_imei_ja_existe_cadastro", null, ""
								+ leiturista.getNumeroImei().toString());
			}
		}

		// [FS0005] - Atualização realizada por outro usuário
		FiltroLeiturista filtroLeiturista = new FiltroLeiturista();
		filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.ID, leiturista.getId()));

		Collection colecaoLeituristaBase = getControladorUtil().pesquisar(filtroLeiturista, Leiturista.class.getName());

		if(colecaoLeituristaBase == null || colecaoLeituristaBase.isEmpty()){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		Leiturista leituristaBase = (Leiturista) colecaoLeituristaBase.iterator().next();

		if(leituristaBase.getUltimaAlteracao().after(leiturista.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		leiturista.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(leiturista);

	}

	public void atualizarRoteiroEmpresa(RoteiroEmpresa roteiroEmpresa, String[] idQuadras, Usuario usuarioLogado)
					throws ControladorException{

		String idRoteiro = "" + roteiroEmpresa.getId();

		validacaoFinalRoteiroEmpresa("" + roteiroEmpresa.getEmpresa().getId(), roteiroEmpresa.getLeiturista(), ""
						+ roteiroEmpresa.getIndicadorUso(), "ALTERAR", idQuadras);

		FiltroRoteiroEmpresa filtro = (FiltroRoteiroEmpresa) roteiroEmpresa.retornaFiltro();

		// Procura roteiro na base
		Collection roteirosNaBase = getControladorUtil().pesquisar(filtro, RoteiroEmpresa.class.getName());

		RoteiroEmpresa roteiroNaBase = (RoteiroEmpresa) Util.retonarObjetoDeColecao(roteirosNaBase);

		if(roteiroNaBase == null){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.registro_remocao_nao_existente");
		}

		// Verificar se a roteiro já foi atualizado por outro usuário
		// durante esta atualização

		if(roteiroNaBase.getUltimaAlteracao().after(roteiroEmpresa.getUltimaAlteracao())){
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		// Atualiza a data de última alteração
		roteiroEmpresa.setUltimaAlteracao(new Date());

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_ROTEIRO_EMPRESA_ATUALIZAR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		roteiroEmpresa.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

		registradorOperacao.registrarOperacao(roteiroEmpresa);

		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// Atualiza o roteiro empresa
		this.getControladorUtil().atualizar(roteiroEmpresa);

		// Atualizar as quadras
		// 1o. retirar o roteiro empresa das quadras que estavam com este
		// roteiro
		// 2o. atualizar as novas quadras com este roteiro empresa
		Collection quadrasRoteiro = getControladorLocalidade().pesquisarQuadrasPorRoteiroEmpresa(Integer.parseInt(idRoteiro));
		for(Iterator iter = quadrasRoteiro.iterator(); iter.hasNext();){
			Quadra quadra = (Quadra) iter.next();

			// Cria o filtro
			FiltroQuadra filtroQuadra = new FiltroQuadra();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = Quadra.class.getName();

			// Seta os parametros do filtro
			filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID, quadra.getId()));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection quadrasNaBase = getControladorUtil().pesquisar(filtroQuadra, nomePacoteObjeto);

			Quadra quadraNaBase = (Quadra) Util.retonarObjetoDeColecao(quadrasNaBase);

			quadraNaBase.setRoteiroEmpresa(null);

			quadraNaBase.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(quadraNaBase);
			getControladorLocalidade().atualizarQuadra(quadraNaBase, usuarioLogado);
		}

		for(int i = 0; i < idQuadras.length; i++){

			// Cria o filtro
			FiltroQuadra filtroQuadra = new FiltroQuadra();
			// Pega o nome do pacote do objeto
			String nomePacoteObjeto = Quadra.class.getName();

			// Seta os parametros do filtro
			filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID, idQuadras[i]));

			// Pesquisa a coleção de acordo com o filtro passado
			Collection quadras = getControladorUtil().pesquisar(filtroQuadra, nomePacoteObjeto);

			Quadra quadraNaBase = (Quadra) Util.retonarObjetoDeColecao(quadras);

			// [FS0007] - Verificar duplicidade de roteiro empresa para a quadra
			if(quadraNaBase.getRoteiroEmpresa() == null){
				quadraNaBase.setRoteiroEmpresa(roteiroEmpresa);
				quadraNaBase.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(quadraNaBase);
				getControladorLocalidade().atualizarQuadra(quadraNaBase, usuarioLogado);
			}
		}

	}

	/**
	 * Remover roteiros empresa
	 * 
	 * @author Francisco do Nascimento
	 * @date 20/09/07
	 * @param ids
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void removerRoteiroEmpresa(String[] ids, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ROTEIRO_EMPRESA_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// retirar a associação do roteiro empresa às quadras antes de remover
		for(int i = 0; i < ids.length; i++){
			int idRoteiro = Integer.parseInt(ids[i]);
			Collection quadras = getControladorLocalidade().pesquisarQuadrasPorRoteiroEmpresa(idRoteiro);
			for(Iterator iter = quadras.iterator(); iter.hasNext();){
				Quadra quadra = (Quadra) iter.next();

				// Cria o filtro
				FiltroQuadra filtroQuadra = new FiltroQuadra();
				// Pega o nome do pacote do objeto
				String nomePacoteObjeto = Quadra.class.getName();

				// Seta os parametros do filtro
				filtroQuadra.adicionarParametro(new ParametroSimples(FiltroQuadra.ID, quadra.getId()));

				// Pesquisa a coleção de acordo com o filtro passado
				Collection quadrasNaBase = getControladorUtil().pesquisar(filtroQuadra, nomePacoteObjeto);

				Quadra quadraNaBase = (Quadra) Util.retonarObjetoDeColecao(quadrasNaBase);

				quadraNaBase.setRoteiroEmpresa(null);

				quadraNaBase.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				quadraNaBase.setOperacaoEfetuada(operacaoEfetuada);

				getControladorUtil().atualizar(quadraNaBase);
			}
		}

		// remover roteiro(s) empresa
		this.getControladorUtil().remover(ids, RoteiroEmpresa.class.getName(), operacaoEfetuada, colecaoUsuarios);

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotas(String codigoSetorComercial, String rotaInicial, String rotaFinal, String idLocalidade,
					String idCobrancaAcao) throws ControladorException{

		String[] retorno = null;

		try{
			retorno = repositorioMicromedicao.pesquisarQuantidadeRotas(codigoSetorComercial, rotaInicial, rotaFinal, idLocalidade,
							idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloSetor(String codigoSetorComercialInicial, String codigoSetorComercialFinal,
					String idLocalidade, String idCobrancaAcao) throws ControladorException{

		String[] retorno = null;

		try{
			retorno = repositorioMicromedicao.pesquisarQuantidadeRotasIntervaloSetor(codigoSetorComercialInicial,
							codigoSetorComercialFinal, idLocalidade, idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloLocalidade(String idLocalidadeInicial, String idLocalidadeFinal, String idCobrancaAcao)
					throws ControladorException{

		String[] retorno = null;

		try{
			retorno = repositorioMicromedicao.pesquisarQuantidadeRotasIntervaloLocalidade(idLocalidadeInicial, idLocalidadeFinal,
							idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloGerencia(String idGerenciaRegional, String idCobrancaAcao) throws ControladorException{

		String[] retorno = null;

		try{
			retorno = repositorioMicromedicao.pesquisarQuantidadeRotasIntervaloGerencia(idGerenciaRegional, idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloGrupo(String idGrupoCobranca, String idCobrancaAcao) throws ControladorException{

		String[] retorno = null;

		try{
			retorno = repositorioMicromedicao.pesquisarQuantidadeRotasIntervaloGrupo(idGrupoCobranca, idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public String[] pesquisarQuantidadeRotasIntervaloUnidadeNegocio(String idUnidadeNegocio, String idCobrancaAcao)
					throws ControladorException{

		String[] retorno = null;

		try{
			retorno = repositorioMicromedicao.pesquisarQuantidadeRotasIntervaloUnidadeNegocio(idUnidadeNegocio, idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;
	}

	/**
	 * Pesquisa as rotas pelo grupo de faturamento [UC0627] Gerar Arquivo Texto
	 * para Leitura
	 * 
	 * @author Pedro Alexandre
	 * @date 15/10/2007
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarRotaPorGrupoFaturamento(Integer idFaturamentoGrupo) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarRotasPorGrupoFaturamento(idFaturamentoGrupo);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloRotas(String codigoSetorComercial, String rotaInicial, String rotaFinal, String idLocalidade,
					String idCobrancaAcao, String idCriterioCobranca) throws ControladorException{

		try{
			repositorioMicromedicao.desassociarRotasIntervaloRotas(codigoSetorComercial, rotaInicial, rotaFinal, idLocalidade,
							idCobrancaAcao, idCriterioCobranca);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloSetor(String codigoSetorComercialInicial, String codigoSetorComercialFinal, String idLocalidade,
					String idCobrancaAcao) throws ControladorException{

		try{
			repositorioMicromedicao.desassociarRotasIntervaloSetor(codigoSetorComercialInicial, codigoSetorComercialFinal, idLocalidade,
							idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloLocalidade(String idLocalidadeInicial, String idLocalidadeFinal, String idCobrancaAcao)
					throws ControladorException{

		try{
			repositorioMicromedicao.desassociarRotasIntervaloLocalidade(idLocalidadeInicial, idLocalidadeFinal, idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloGerencia(String idGerenciaRegional, String idCobrancaAcao) throws ControladorException{

		try{
			repositorioMicromedicao.desassociarRotasIntervaloGerencia(idGerenciaRegional, idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloGrupo(String idGrupoCobranca, String idCobrancaAcao) throws ControladorException{

		try{
			repositorioMicromedicao.desassociarRotasIntervaloGrupo(idGrupoCobranca, idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public void desassociarRotasIntervaloUnidadeNegocio(String idUnidadeNegocio, String idCobrancaAcao) throws ControladorException{

		String[] retorno = null;

		try{
			repositorioMicromedicao.desassociarRotasIntervaloUnidadeNegocio(idUnidadeNegocio, idCobrancaAcao);
		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * pesquisa o consumo historico passando o imovel e o anomes referencia e o
	 * consumo anormalidade correspondente ao faturameto antecipado. [UC0113]
	 * Faturar Grupo de Faturamento
	 * 
	 * @author Sávio Luiz
	 * @date 08/11/2007
	 * @param idRota
	 * @param anoMesFaturamento
	 * @param idFaturamentoGrupo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarConsumoHistoricoAntecipado(Integer idImovel, Integer anoMes) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarConsumoHistoricoAntecipado(idImovel, anoMes);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Relatório Analise de Consumo Flávio Leonardo 26/12/2007
	 * 
	 * @param idImovel
	 * @param anomes
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarLeiturasImovel(String idImovel, String anoMes) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarLeiturasImovel(idImovel, anoMes);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Relatório Manter Hidrometro Flávio Leonardo pesquisa o id do imovel do
	 * hidrometro instalado
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarImovelPeloHidrometro(Integer hidrometroId) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarImovelPeloHidrometro(hidrometroId);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0589] Manter Leiturista (Remover)
	 * 
	 * @author Eduardo Henrique
	 * @date 13/06/2008
	 */

	public void removerLeiturista(String[] ids, Usuario usuarioLogado) throws ControladorException{

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_LEITURISTA_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		this.getControladorUtil().remover(ids, Leiturista.class.getName(), operacaoEfetuada, colecaoUsuarios);

	}

	/**
	 * [UC0583] - Inserir Roteiro de Empresa [UC0584] - Manter Roteiro de
	 * Empresa Realiza a consulta de Setores Comerciais cujas quadras possuam
	 * rotas contidas num determinado Grupo de Faturamento e determinada
	 * localidade.
	 * 
	 * @author eduardo henrique
	 * @date 30/06/2008
	 */
	public Collection pesquisarSetoresComerciaisPorLocalidadeGrupoFaturamento(Integer idLocalidade, Integer grupoFaturamento)
					throws ControladorException{

		try{
			return repositorioSetorComercial.pesquisarSetoresComerciaisPorLocalidadeGrupoFaturamento(idLocalidade, grupoFaturamento);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0082] / [UC0712] - Registrar Leituras e Anormalidades Autor: Sávio
	 * Luiz Data: 04/01/2006
	 * 
	 * @author eduardo henrique
	 * @date 12/09/2008
	 * @param idImoveis
	 *            - Coleção de Imóveis que terão seus Movimentos de Roteiro de
	 *            Leitura Atualizados
	 * @param anoMesReferencia
	 *            - Integer com o valor do Ano/Mês Referência que se deseja ser
	 *            atualizado.
	 */
	private void atualizarMovimentoRoteiroEmpresaImoveis(Collection<Integer> idImoveis, Integer anoMesReferencia)
					throws ControladorException{

		Collection colecaoRoteiroEmpresa = new ArrayList<MovimentoRoteiroEmpresa>();
		if(idImoveis != null && anoMesReferencia != null){

			for(Iterator iterator = idImoveis.iterator(); iterator.hasNext();){
				Integer idImovel = (Integer) iterator.next();

				FiltroMovimentoRoteiroEmpresa filtroMovimentoRoteiroEmpresa = new FiltroMovimentoRoteiroEmpresa();
				filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO,
								anoMesReferencia));
				filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.IMOVEL_ID, idImovel));

				Collection<MovimentoRoteiroEmpresa> colecaoPesquisa = getControladorUtil().pesquisar(filtroMovimentoRoteiroEmpresa,
								MovimentoRoteiroEmpresa.class.getName());
				if(colecaoPesquisa != null && colecaoPesquisa.size() > 0){
					MovimentoRoteiroEmpresa movimentoRoteiroEmpresaBanco = (MovimentoRoteiroEmpresa) Util
									.retonarObjetoDeColecao(colecaoPesquisa);

					movimentoRoteiroEmpresaBanco.setIndicadorFase(MovimentoRoteiroEmpresa.FASE_PROCESSADO);
					movimentoRoteiroEmpresaBanco.setUltimaAlteracao(new Date());
					movimentoRoteiroEmpresaBanco.setIndicadorAtualizarLeitura(ConstantesSistema.SIM);

					colecaoRoteiroEmpresa.add(movimentoRoteiroEmpresaBanco);
				}
			}

			getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoRoteiroEmpresa);
		}

	}

	/**
	 * Método responsável por verificar se foi concedido desconto de alto
	 * consumo para o imóvel nos últimos doze meses.
	 */
	public Boolean verificarDescontoAltoConsumoUltimosDozeMeses(Imovel imovel, Integer anoMesReferenciaFaturamento)
					throws ControladorException{

		Boolean retorno = false;

		// Checa Anormalidade de Consumo
		Integer anoMesReferenciaAnoAnterior = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesReferenciaFaturamento, 12);
		FiltroConsumoHistorico filtroConsumoHistorico = new FiltroConsumoHistorico();
		filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, imovel.getId()));
		filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANORMALIDADE_CONSUMO,
						ConsumoAnormalidade.ALTO_CONSUMO_COM_DESCONTO));
		filtroConsumoHistorico.adicionarParametro(new Intervalo(FiltroConsumoHistorico.ANO_MES_FATURAMENTO, anoMesReferenciaAnoAnterior,
						anoMesReferenciaFaturamento));

		Collection colecaoConsumoHistorico = getControladorUtil().pesquisar(filtroConsumoHistorico, ConsumoHistorico.class.getName());
		if(colecaoConsumoHistorico != null && !colecaoConsumoHistorico.isEmpty()){
			retorno = true;
		}else{
			retorno = false;
		}

		return retorno;

	}

	/**
	 * [UC0088] Registrar Faturamento Imediato
	 * 
	 * @author eduardo henrique
	 * @date 09/10/2008
	 * @param colecaoMedicaoHistorico
	 *            (Coleções de MediçõesHistórico para Inserção/Atualização
	 * @exception ControladorException
	 */
	public void inserirOuAtualizarMedicaoHistorico(Collection<MedicaoHistorico> colecaoMedicaoHistorico) throws ControladorException{

		try{
			repositorioMicromedicao.inseriOuAtualizaMedicaoHistorico(colecaoMedicaoHistorico);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0088] Registrar Faturamento Imediato
	 * 
	 * @author eduardo henrique
	 * @date 15/10/2008
	 * @param colecaoConsumoHistorico
	 *            (Coleções de ConsumosHistórico para Inserção/Atualização
	 * @exception ControladorException
	 */
	public void inserirOuAtualizarConsumoHistorico(Collection<ConsumoHistorico> colecaoConsumoHistorico) throws ControladorException{

		try{
			repositorioMicromedicao.inseriOuAtualizaConsumoHistorico(colecaoConsumoHistorico);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Publicação do método PesquisarConsumoHistorico
	 * 
	 * @author eduardo henrique
	 * @date 21/10/2008
	 * @return Collection<Object[]>
	 * @exception ControladorException
	 */
	public Collection pesquisarConsumoHistorico(Imovel imovel, LigacaoTipo ligacaoTipo, int anoMesReferencia) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarConsumoHistorico(imovel, ligacaoTipo, anoMesReferencia);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0353] Efetuar Ligação de Água. [SB0001] Gerar Ligação de Água
	 * 
	 * @author eduardo henrique
	 * @date 18/03/2009
	 * @param numeroPontosUtilizacao
	 *            Inteiro que representa os pontos de utilizacao do imovel
	 *            (normalmente obtido por imovel.getNumeroPontosUtilizacao)
	 * @return Integer volume do Consumo Fixo da Faixa baseada nos Pontos de
	 *         Utilização.
	 * @throws ControladorException
	 */
	public Integer obterVolumeConsumoFixoFaixaImovel(Integer numeroPontosUtilizacao) throws ControladorException{

		try{
			return repositorioMicromedicao.obterVolumeConsumoFixoFaixaImovel(numeroPontosUtilizacao);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public Integer obterUltimaLeituraDoImovel(Integer idImovel) throws ControladorException{

		Integer retorno = null;
		try{
			retorno = repositorioMicromedicao.obterUltimaLeituraDoImovel(idImovel);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Relatório Analise de Consumo Yara Souza 28/04/2010
	 * 
	 * @param idImovel
	 * @param qtdMeses
	 * @return
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarConsumoPorQuantidadeMeses(Integer idImovel, Integer anoMesFaturamentoMinimo, Integer anoMesFaturamento)
					throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarConsumoPorQuantidadeMeses(idImovel, anoMesFaturamentoMinimo, anoMesFaturamento);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Description of the Method
	 * 
	 * @param hidrometro
	 *            Description of the Parameter
	 * @throws ControladorException
	 */
	public void atualizarHidrometro(Hidrometro hidrometro, Usuario usuarioLogado) throws ControladorException{

		FiltroHidrometro filtroHidrometro = new FiltroHidrometro();

		try{
			// -------------Parte que atualiza um logradouro na
			// base----------------------
			filtroHidrometro.adicionarParametro(new ParametroSimples(FiltroHidrometro.NUMERO_HIDROMETRO, hidrometro.getNumero()));

			Collection hidrometrosPesquisados = repositorioUtil.pesquisar(filtroHidrometro, Hidrometro.class.getName());

			if(hidrometrosPesquisados != null && !hidrometrosPesquisados.isEmpty()){
				Hidrometro hidrometroPesquisado = (Hidrometro) ((List) hidrometrosPesquisados).get(0);

				if(!hidrometro.getId().equals(hidrometroPesquisado.getId())){
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.hidrometro_ja_existente", null, hidrometro.getNumero());
				}
			}

			filtroHidrometro.limparListaParametros();
			// Seta o filtro para buscar o hidrometro na base
			filtroHidrometro.adicionarParametro(new ParametroSimples(FiltroHidrometro.ID, hidrometro.getId()));

			// Procura o hidrometro na base
			Hidrometro hidrometroNaBase = (Hidrometro) ((List) (repositorioUtil.pesquisar(filtroHidrometro, Hidrometro.class.getName())))
							.get(0);

			// Verificar se o hidrometro já foi atualizado por outro usuário
			// durante
			// esta atualização
			if(hidrometroNaBase.getUltimaAlteracao().after(hidrometro.getUltimaAlteracao())){
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}

			// Atualiza a data de última alteração
			hidrometro.setUltimaAlteracao(new Date());

			// [UC] - Registrar Transação
			// Início - Registrando as transações
			// RegistradorOperacao registradorOperacao = new
			// RegistradorOperacao(Operacao.OPERACAO_HIDROMETRO_ATUALIZAR,
			// new UsuarioAcaoUsuarioHelper(usuarioLogado,
			// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_HIDROMETRO_ATUALIZAR, hidrometro.getId(),
							hidrometro.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_HIDROMETRO_ATUALIZAR);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			hidrometro.setOperacaoEfetuada(operacaoEfetuada);
			hidrometro.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

			registradorOperacao.registrarOperacao(hidrometro);
			// Fim - Registrando as transações

			// Atualiza o hidrometro
			repositorioUtil.atualizar(hidrometro);

			// OC0984207
			// Atualizar o número do hidrômetro no histórico de instalação quando o número for
			// alterado.
			if(!hidrometro.getNumero().equals(hidrometroNaBase.getNumero())){
				FiltroHidrometroInstalacaoHistorico filtroHidrometroInstalacaoHist = new FiltroHidrometroInstalacaoHistorico();
				filtroHidrometroInstalacaoHist.adicionarParametro(new ParametroSimples(FiltroHidrometroInstalacaoHistorico.HIDROMETRO_ID,
								hidrometro.getId()));

				// Procura os históricos na base
				Collection colecaoRetorno = repositorioUtil.pesquisar(filtroHidrometroInstalacaoHist, HidrometroInstalacaoHistorico.class
								.getName());
				Iterator iColecaoRetorno = colecaoRetorno.iterator();

				HidrometroInstalacaoHistorico hidrometroInstalacaoHist = null;
				while(iColecaoRetorno.hasNext()){
					hidrometroInstalacaoHist = (HidrometroInstalacaoHistorico) iColecaoRetorno.next();
					if(hidrometroInstalacaoHist.getDataRetirada() == null){
						hidrometroInstalacaoHist.setNumeroHidrometro(hidrometro.getNumero());

						// Atualiza o hidrometroInstalacaoHistorico
						repositorioUtil.atualizar(hidrometroInstalacaoHist);
					}
				}

			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC00083] Gerar Dados para Leitura Convencional Txt - Populando Objeto
	 * MedicaoHistorico [SB0002] Gerar Relação
	 * 
	 * @author Hebert Falcão
	 * @date 15/02/2011
	 * @param arrayMedicaoHistorico
	 */
	private MedicaoHistorico criarMedicaoHistoricoApartirDeArray(Object[] arrayMedicaoHistorico){

		MedicaoHistorico medicaoHistoricoAnterior = null;

		if(arrayMedicaoHistorico != null){
			medicaoHistoricoAnterior = new MedicaoHistorico();

			if(arrayMedicaoHistorico[0] != null){
				medicaoHistoricoAnterior.setDataLeituraAtualFaturamento((Date) arrayMedicaoHistorico[0]);
			}

			if(arrayMedicaoHistorico[1] != null){
				medicaoHistoricoAnterior.setLeituraAtualFaturamento((Integer) arrayMedicaoHistorico[1]);
			}

			if(arrayMedicaoHistorico[2] != null){
				medicaoHistoricoAnterior.setLeituraAtualInformada((Integer) arrayMedicaoHistorico[2]);
			}

			if(arrayMedicaoHistorico[3] != null){
				LeituraSituacao leituraSituacaoAtual = new LeituraSituacao();
				leituraSituacaoAtual.setId((Integer) arrayMedicaoHistorico[3]);

				medicaoHistoricoAnterior.setLeituraSituacaoAtual(leituraSituacaoAtual);
			}

			if(arrayMedicaoHistorico[4] != null){
				medicaoHistoricoAnterior.setConsumoCreditoGerado((Integer) arrayMedicaoHistorico[4]);
			}

			if(arrayMedicaoHistorico[5] != null){
				medicaoHistoricoAnterior.setDataLeituraAnteriorFaturamento((Date) arrayMedicaoHistorico[5]);
			}

			if(arrayMedicaoHistorico[6] != null){
				medicaoHistoricoAnterior.setNumeroConsumoMes((Integer) arrayMedicaoHistorico[6]);
			}

			if(arrayMedicaoHistorico[7] != null){
				medicaoHistoricoAnterior.setConsumoCreditoAnterior((Integer) arrayMedicaoHistorico[7]);
			}

			if(arrayMedicaoHistorico[8] != null){
				medicaoHistoricoAnterior.setLeituraAnteriorFaturamento((Integer) arrayMedicaoHistorico[8]);
			}

			if(arrayMedicaoHistorico[9] != null){
				medicaoHistoricoAnterior.setLeituraAnteriorInformada((Integer) arrayMedicaoHistorico[9]);
			}

			if(arrayMedicaoHistorico[10] != null){
				medicaoHistoricoAnterior.setId((Integer) arrayMedicaoHistorico[10]);
			}
		}

		return medicaoHistoricoAnterior;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SB0011] - Dados para
	 * Faturamento com Anormalidade de Leitura (Tipo de Ligação Água)
	 * 
	 * @author Hebert Falcão
	 */
	@Deprecated
	protected boolean dadosFaturamentoAnormalidadeLeituraImovel(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico,
					int[] consumoMedioImovel, int leituraAnterior, Imovel imovel, int consumoMinimoLigacao,
					boolean indicadorDiferencaLeitura, int ligacaoTipo) throws ControladorException{

		boolean retorno = indicadorDiferencaLeitura;
		// Cria objeto consumo tipo
		ConsumoTipo consumoTipo = new ConsumoTipo();

		Collection colecaoAnormalidadeLeitura = null;

		LeituraAnormalidade leituraAnormalidadeFaturamento = medicaoHistorico.getLeituraAnormalidadeFaturamento();

		try{
			// Pesquisa a anormalidade de leitura de faturamento
			colecaoAnormalidadeLeitura = repositorioMicromedicao.pesquisarAnormalidadeLeitura(leituraAnormalidadeFaturamento);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém a leitura anormalidade
		LeituraAnormalidade leituraAnormalidade = obterAnormalidadeLeitura(colecaoAnormalidadeLeitura);

		// Seta a leitura anormalidade faturamento
		leituraAnormalidadeFaturamento.setLeituraAnormalidadeConsumoSemleitura(leituraAnormalidade
						.getLeituraAnormalidadeConsumoSemleitura());
		leituraAnormalidadeFaturamento.setLeituraAnormalidadeConsumoComleitura(leituraAnormalidade
						.getLeituraAnormalidadeConsumoComleitura());
		leituraAnormalidadeFaturamento.setLeituraAnormalidadeLeituraSemleitura(leituraAnormalidade
						.getLeituraAnormalidadeLeituraSemleitura());
		leituraAnormalidadeFaturamento.setLeituraAnormalidadeLeituraComleitura(leituraAnormalidade
						.getLeituraAnormalidadeLeituraComleitura());
		leituraAnormalidadeFaturamento.setIndicadorCreditoConsumo(leituraAnormalidade.getIndicadorCreditoConsumo());

		Integer leituraAtualInformada = medicaoHistorico.getLeituraAtualInformada();

		if(leituraAtualInformada == null){
			// Leitura atual informada com valor nulo (leitura não informada)
			// Consumo a ser cobrado no mes com base no id consumo sem
			// leitura
			LeituraAnormalidadeConsumo leituraAnormalidadeConsumoSemLeitura = leituraAnormalidadeFaturamento
							.getLeituraAnormalidadeConsumoSemleitura();
			Integer idLeituraAnormalidadeConsumoSemLeitura = leituraAnormalidadeConsumoSemLeitura.getId();

			if(LeituraAnormalidadeConsumo.NAO_OCORRE.equals(idLeituraAnormalidadeConsumoSemLeitura)){

				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

				consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

			}else if(LeituraAnormalidadeConsumo.MINIMO.equals(idLeituraAnormalidadeConsumoSemLeitura)){

				consumoHistorico.setNumeroConsumoFaturadoMes(0);

				consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

			}else if(LeituraAnormalidadeConsumo.MEDIA.equals(idLeituraAnormalidadeConsumoSemLeitura)){

				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

				consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

			}

			// Leitura Atual de Faturamento com base no id leitura sem
			// Leitura
			LeituraAnormalidadeLeitura leituraAnormalidadeLeituraSemLeitura = leituraAnormalidadeFaturamento
							.getLeituraAnormalidadeLeituraSemleitura();
			Integer idLeituraAnormalidadeLeituraSemLeitura = leituraAnormalidadeLeituraSemLeitura.getId();

			if(LeituraAnormalidadeLeitura.NAO_OCORRE.equals(idLeituraAnormalidadeLeituraSemLeitura)){

				int leituraAtualFaturamento = leituraAnterior + consumoMedioImovel[0];
				medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);

				// A situação da leitura atual deverá ter valor correspondente a “não realizada”
				medicaoHistorico.getLeituraSituacaoAtual().setId(LeituraSituacao.NAO_REALIZADA);

			}else if(LeituraAnormalidadeLeitura.ANTERIOR.equals(idLeituraAnormalidadeLeituraSemLeitura)){

				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

			}else if(LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA.equals(idLeituraAnormalidadeLeituraSemLeitura)){

				Integer consumoCobrado = consumoHistorico.getNumeroConsumoFaturadoMes();
				if(consumoCobrado == null){
					consumoCobrado = 0;
				}

				int leituraAtualFaturamento = leituraAnterior + consumoCobrado;
				medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);

			}

		}else if(leituraAtualInformada != null){

			/*
			 * Leitura Atual Informada com o valor diferente de nulo (leitura informada):
			 * Calcular multiplicação de consumo conforme segue:
			 * Consumo Calculado = (Leitura Atual – Leitura Anterior) * Fator de conversão
			 * do Hidrômetro instalado no Imóvel (HIDI_NNFATORCONVERSAO da Tabela HIDROMETRO com
			 * HIDR_ID = HIDR_ID da Tabela HIDROMETRO_INSTALACAO_HIST com LAGU_ID = Id do Imovel se
			 * Tipo Ligação água ou IMOV_ID = Id do Imovel se Tipo de Ligação Poço)
			 */
			int consumoCalculado = leituraAtualInformada - leituraAnterior;

			// Caso seja Ligação de Água
			if(LigacaoTipo.LIGACAO_AGUA.intValue() == ligacaoTipo){

				LigacaoAgua ligacaoAgua = imovel.getLigacaoAgua();
				HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = ligacaoAgua.getHidrometroInstalacaoHistorico();
				Hidrometro hidrometro = hidrometroInstalacaoHistorico.getHidrometro();

				if(hidrometro != null && hidrometro.getFatorConversao() != null){
					consumoCalculado = new BigDecimal(String.valueOf(consumoCalculado)).multiply(hidrometro.getFatorConversao()).intValue();
				}

			}else{

				// caso contrário Poço/Ligação de Esgoto
				HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = imovel.getHidrometroInstalacaoHistorico();
				Hidrometro hidrometro = hidrometroInstalacaoHistorico.getHidrometro();

				if(hidrometro != null && hidrometro.getFatorConversao() != null){
					consumoCalculado = new BigDecimal(String.valueOf(consumoCalculado)).multiply(hidrometro.getFatorConversao()).intValue();
				}

			}

			// Consumo a ser cobrado no mês
			LeituraAnormalidadeConsumo leituraAnormalidadeConsumoComLeitura = leituraAnormalidadeFaturamento
							.getLeituraAnormalidadeConsumoComleitura();
			Integer idLeituraAnormalidadeConsumoComLeitura = leituraAnormalidadeConsumoComLeitura.getId();

			if(LeituraAnormalidadeConsumo.NAO_OCORRE.equals(idLeituraAnormalidadeConsumoComLeitura)){

				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

				consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

			}else if(LeituraAnormalidadeConsumo.MINIMO.equals(idLeituraAnormalidadeConsumoComLeitura)){

				consumoHistorico.setNumeroConsumoFaturadoMes(0);

				consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

			}else if(LeituraAnormalidadeConsumo.MEDIA.equals(idLeituraAnormalidadeConsumoComLeitura)){

				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

				consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

			}else if(consumoCalculado >= 0){
				if(LeituraAnormalidadeConsumo.NORMAL.equals(idLeituraAnormalidadeConsumoComLeitura)){

					int consumoFaturadoMes = leituraAtualInformada - leituraAnterior;
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoFaturadoMes);
					consumoTipo = definirConsumoTipoLeituraImovel(medicaoHistorico, null);
					retorno = true;

				}else if(LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_IMOVEL_CONSUMO_CALCULADO
								.equals(idLeituraAnormalidadeConsumoComLeitura)){

					if(consumoMedioImovel[0] > consumoCalculado){
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

						consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);
					}else{
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);
						consumoTipo = definirConsumoTipoLeituraImovel(medicaoHistorico, null);
						retorno = true;
					}

				}else if(LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_IMOVEL_CONSUMO_CALCULADO
								.equals(idLeituraAnormalidadeConsumoComLeitura)){

					if(consumoMedioImovel[0] < consumoCalculado){
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

						consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);
					}else{
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);
						consumoTipo = definirConsumoTipoLeituraImovel(medicaoHistorico, null);
						retorno = true;
					}

				}
			}

			// Leitura atual de faturamento com base no id leitura com
			// leitura
			LeituraAnormalidadeLeitura leituraAnormalidadeLeituraComLeitura = leituraAnormalidadeFaturamento
							.getLeituraAnormalidadeLeituraComleitura();
			Integer idLeituraAnormalidadeLeituraComLeitura = leituraAnormalidadeLeituraComLeitura.getId();

			if(LeituraAnormalidadeLeitura.NAO_OCORRE.equals(idLeituraAnormalidadeLeituraComLeitura)){

				int leituraAtualFaturamento = leituraAnterior + consumoMedioImovel[0];
				medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);
				medicaoHistorico.getLeituraSituacaoAtual().setId(LeituraSituacao.NAO_REALIZADA);

			}else if(LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA.equals(idLeituraAnormalidadeLeituraComLeitura)){

				Integer consumoCobrado = consumoHistorico.getNumeroConsumoFaturadoMes();
				if(consumoCobrado == null){
					consumoCobrado = 0;
				}

				int leituraAtualFaturamento = leituraAnterior + consumoCobrado;
				medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);

			}else if(LeituraAnormalidadeLeitura.ANTERIOR.equals(idLeituraAnormalidadeLeituraComLeitura)){

				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

			}else if(LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO.equals(idLeituraAnormalidadeLeituraComLeitura)){

				medicaoHistorico.setLeituraAtualFaturamento(leituraAtualInformada);

			}else if(LeituraAnormalidadeLeitura.INFORMADA.equals(idLeituraAnormalidadeLeituraComLeitura)){

				medicaoHistorico.setLeituraAtualFaturamento(leituraAtualInformada);

			}

		}

		if(leituraAnormalidadeFaturamento != null && leituraAnormalidadeFaturamento.getIndicadorCreditoConsumo() != null
						&& leituraAnormalidadeFaturamento.getIndicadorCreditoConsumo() == 1){

			int consumoCobrado = consumoHistorico.getNumeroConsumoFaturadoMes();
			if(consumoCobrado > 0){
				consumoCobrado = consumoCobrado * -1;
			}

			// O Crédito Gerado será o Consumo a Ser Cobrado no Mês com sinal
			// negativo.
			medicaoHistorico.setConsumoCreditoGerado(consumoCobrado);

			Integer consumoCreditoAnterior = medicaoHistorico.getConsumoCreditoAnterior();
			if(consumoCreditoAnterior == null){
				consumoCreditoAnterior = 0;
			}

			medicaoHistorico.setConsumoCreditoAnterior(consumoCreditoAnterior + consumoCobrado);
		}

		// Atualiza o consumo histórico
		if(consumoTipo.getId() != null){
			consumoHistorico.setConsumoTipo(consumoTipo);
		}

		return retorno;
	}

	/**
	 * Remover Hidrometro
	 * 
	 * @author Hebert Falcão
	 * @date 18/02/2011
	 * @param ids
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void removerHidrometro(String[] ids, Usuario usuarioLogado) throws ControladorException{

		for(int i = 0; i < ids.length; i++){
			FiltroHidrometro filtro = new FiltroHidrometro();
			filtro.adicionarParametro(new ParametroSimples(FiltroHidrometro.ID, new Integer(ids[i])));

			Collection colecaoRetorno = getControladorUtil().pesquisar(filtro, Hidrometro.class.getName());

			Hidrometro hidrometro = (Hidrometro) Util.retonarObjetoDeColecao(colecaoRetorno);

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorHidrometro = new RegistradorOperacao(Operacao.OPERACAO_HIDROMETRO_REMOVER, hidrometro.getId(),
							hidrometro.getId(), new UsuarioAcaoUsuarioHelper(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_HIDROMETRO_REMOVER);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			hidrometro.setOperacaoEfetuada(operacaoEfetuada);

			registradorHidrometro.registrarOperacao(hidrometro);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			this.getControladorUtil().remover(hidrometro);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SB0015] - Verificar
	 * alto consumo utilizando a quantidade de economias
	 * 
	 * @author Hebert Falcão, Anderson Italo
	 * @date 16/03/2011, 23/03/2012
	 * @throws ControladorException
	 */
	protected boolean verificarAltoConsumoPorQuantidadeEconomiasNaoPublico(ConsumoHistorico consumoHistorico, int consumoMedioImovel,
					Imovel imovel, MedicaoTipo medicaoTipo, MedicaoHistorico medicaoHistorico, int leituraAnterior, int consumoMinimoLigacao)
					throws ControladorException{

		boolean retorno = false;

		// Obtém o consumo a ser cobrado no mês
		Integer consumoASerCobradoMes = consumoHistorico.getNumeroConsumoFaturadoMes();
		if(consumoASerCobradoMes == null){

			consumoASerCobradoMes = 0;
		}

		// Obtém o ano e mês de referência anterior
		Integer anoMesReferenciaAtual = Integer.valueOf(consumoHistorico.getReferenciaFaturamento());
		Integer anoMesReferenciaAnterior = Util.subtrairData(anoMesReferenciaAtual);

		// Obtém quantidade de economia da categoria pública
		int quantidadeEconomiasPublica = 0;

		Collection<Categoria> colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		if(colecaoCategorias != null && !colecaoCategorias.isEmpty()){
			for(Categoria categoria : colecaoCategorias){
				Integer idCategoria = categoria.getId();
				Integer quantidadeEconomias = categoria.getQuantidadeEconomiasCategoria();

				if(quantidadeEconomias != null){
					if(Categoria.PUBLICO.equals(idCategoria)){

						quantidadeEconomiasPublica = quantidadeEconomias;
					}
				}
			}
		}

		// Obtém data de instalção do hidrômetro
		Date dataInstalacaoHidrometro = null;

		Integer idMedicaoTipo = medicaoTipo.getId();
		if(MedicaoTipo.LIGACAO_AGUA.equals(idMedicaoTipo)){
			LigacaoAgua ligacaoAgua = imovel.getLigacaoAgua();

			if(ligacaoAgua != null){
				HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = ligacaoAgua.getHidrometroInstalacaoHistorico();

				if(hidrometroInstalacaoHistorico != null){

					dataInstalacaoHidrometro = hidrometroInstalacaoHistorico.getDataInstalacao();
				}
			}
		}else{
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = imovel.getHidrometroInstalacaoHistorico();

			if(hidrometroInstalacaoHistorico != null){

				dataInstalacaoHidrometro = hidrometroInstalacaoHistorico.getDataInstalacao();
			}
		}

		/* Número de meses entre a data de instalação do hidrômetro e a data corrente */
		int mesesInstalacao = 0;

		if(dataInstalacaoHidrometro != null){

			Date dataAtual = new Date();
			int anoDataAtual = Util.getAno(dataAtual);
			int mesDataAtual = Util.getMes(dataAtual);
			int qtdMesesDataAtual = ((anoDataAtual - 1) * 12) + mesDataAtual;

			int anoDataInstalacaoHidrometro = Util.getAno(dataInstalacaoHidrometro);
			int mesDataInstalacaoHidrometro = Util.getMes(dataInstalacaoHidrometro);
			int qtdMesesDataInstalacaoHidrometro = ((anoDataInstalacaoHidrometro - 1) * 12) + mesDataInstalacaoHidrometro;

			if(qtdMesesDataAtual > qtdMesesDataInstalacaoHidrometro){

				mesesInstalacao = qtdMesesDataAtual - qtdMesesDataInstalacaoHidrometro;
			}else{

				mesesInstalacao = 0;
			}
		}

		/*
		 * Parâmetro que indica a quantidades de meses com da instalação a partir da qual e
		 * verificado o alto consumo (exclusive).
		 */
		String parametroQtdMesesVerificacaoAltoConsumo = (String) ParametroMicromedicao.P_QTD_MESES_VERIFICACAO_ALTO_CONSUMO.executar(this,
						0);


		/*
		 * Caso a quantidade de Economias da categoria pública seja igual a Zero e não exista
		 * ligação de esgoto ou, caso exista, o valor do consumo mínimo fixado de esgoto
		 * (LESG_NNCONSUMOMINIMOESGOTO) seja igual a nulo
		 */
		if(quantidadeEconomiasPublica == 0 && (imovel.getLigacaoEsgoto() == null || imovel.getLigacaoEsgoto().getConsumoMinimo() == null)){

			/*
			 * O sistema obtém o Consumo Total de Referência acumulando o consumo por economia
			 * de referência de cada categoria multiplicado pelo número de economias do imóvel na
			 * categoria.
			 */
			Integer consumoTotalReferenciaAcumulado = 0;

			for(Categoria categoria : colecaoCategorias){

				if(categoria.getConsumoAlto() != null){

					consumoTotalReferenciaAcumulado += categoria.getConsumoAlto() * categoria.getQuantidadeEconomiasCategoria();
				}

			}

			/*
			 * Obtendo o fator de multiplicação da média da categoria do imóvel que tenha o
			 * maior número de economias
			 */
			Collections.sort((List) colecaoCategorias, new Comparator() {

				public int compare(Object a, Object b){

					Integer quatidadeEconomias1 = ((Categoria) a).getQuantidadeEconomiasCategoria();
					Integer quatidadeEconomias2 = ((Categoria) b).getQuantidadeEconomiasCategoria();

					return quatidadeEconomias1.compareTo(quatidadeEconomias2);

				}
			});

			Categoria categoriaComMaiorNumeroEconomias = (Categoria) colecaoCategorias.iterator().next();

			/*
			 * Obtém o consumo médio do imóvel multiplicado pelo fator de multiplicação da média
			 * da categoria
			 */
			Integer consumoMedioMultiplicado = Util.arredondar(new BigDecimal(consumoMedioImovel).multiply(categoriaComMaiorNumeroEconomias
							.getVezesMediaAltoConsumo()));

			Short pVerificarQtdMesesVerificacaoAltoConsumo = Util
							.converterStringParaShort(ParametroMicromedicao.P_VERIFICAR_QTD_MESES_VERIFICACAO_ALTO_CONSUMO.executar());

			/*
			 * Caso o Número de Meses entre a Data de Instalação do Hidrômetro e a Data Corrente não
			 * ultrapasse a quantidade de meses para determinação de alto consumo
			 */
			if(mesesInstalacao <= Util.obterInteger(parametroQtdMesesVerificacaoAltoConsumo).intValue()){
				/*
				 * Caso o Consumo a Ser Cobrado no Mês seja superior ao Consumo Total de Referência
				 * obtido e ao consumo médio do imóvel multiplicado pelo fator de multiplicação da
				 * média
				 * da categoria do imóvel que tenha o maior número de economias
				 * (CATG_NNVEZESMEDIAALTOCONSUMO)
				 */
				if(consumoASerCobradoMes > consumoTotalReferenciaAcumulado && (consumoASerCobradoMes > consumoMedioMultiplicado)){

					/*
					 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “alto
					 * consumo”
					 */
					ConsumoAnormalidade consumoAnormalidade = null;
					try{

						consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.ALTO_CONSUMO);
					}catch(ErroRepositorioException ex){

						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
					consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

					// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
					verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico, consumoMedioImovel,
									consumoMinimoLigacao, consumoAnormalidade, consumoASerCobradoMes);

					retorno = true;
				}
				
			}else if(pVerificarQtdMesesVerificacaoAltoConsumo != null
							&& pVerificarQtdMesesVerificacaoAltoConsumo.equals(ConstantesSistema.SIM)){
				// ############# Alterado por Luciano - OC1034808 ############# - Inicio

				// Esta regra só deve ser considerada se o parâmetro P_VERIFICAR_
				// QTD_MESES_VERIFICACAO_ALTO_CONSUMO = 1 (Sim)

				// Caso contrário, ou seja, o Número de Meses entre a Data de Instalação do
				// Hidrômetro e a Data Corrente ultrapasse a quantidade de meses para determinação
				// de alto consumo
				
				Integer pConsumoMinimoASerCobrado = Util.converterStringParaInteger(ParametroMicromedicao.P_CONSUMO_COBRADO_MINIMO
								.executar());

				if(pConsumoMinimoASerCobrado == null){
					throw new ControladorException("atencao.param_nao_cadastrado", null,
									ParametroMicromedicao.P_CONSUMO_COBRADO_MINIMO.getCodigo());
				}

				// Caso o Consumo a Ser Cobrado no Mês seja superior a 40m3 (parâmetro
				// P_CONSUMO_COBRADO_MINIMO) e ao consumo médio do imóvel multiplicado pelo fator de
				// multiplicação da média da categoria do imóvel (CATG_NNVEZESMEDIAALTOCONSUMO) e
				// sem anormalidades de consumo igual a “AC” nos últimos seis meses
				if(consumoASerCobradoMes > pConsumoMinimoASerCobrado && (consumoASerCobradoMes > consumoMedioMultiplicado)){

					// Verifica se o imóvel possui anormalidades de consumo do tipo ALTO CONSUMO nos
					// últimos 6 meses
					boolean imovelComAltoConsumoUltimosSeisMeses = verificarAnormalidadesConsumoUltimosMeses(imovel.getId(),
									anoMesReferenciaAnterior, ConsumoAnormalidade.ALTO_CONSUMO, 6);

					if(imovelComAltoConsumoUltimosSeisMeses){

						// Define o tipo de ligação
						LigacaoTipo ligacaoTipo = new LigacaoTipo();

						if(medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()){

							ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

						}else if(medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()){

							ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

						}

						Collection consumoHistoricoAnterior = null;

						// Pesquisa o consumo histórico para obter anormalidade do mês anterior
						try{

							consumoHistoricoAnterior = repositorioMicromedicao.pesquisarConsumoHistoricoConsumoAnormalidade(imovel,
											ligacaoTipo, anoMesReferenciaAnterior);
						}catch(ErroRepositorioException ex){

							sessionContext.setRollbackOnly();
							new ControladorException("erro.sistema", ex);

						}

						ConsumoAnormalidade consumoAnormalidadeMesAnterior = null;

						if(!Util.isVazioOrNulo(consumoHistoricoAnterior)){

							Object[] consumoHistoricoAnteriorArray = Util.retonarObjetoDeColecaoArray(consumoHistoricoAnterior);

							consumoAnormalidadeMesAnterior = new ConsumoAnormalidade();
							consumoAnormalidadeMesAnterior.setId((Integer) consumoHistoricoAnteriorArray[1]);
						}

						// Pesquisa a medição histórico do mês anterior para verificar a
						// anormalidade de leitura
						FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();
						filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.IMOVEL_ID, imovel.getId()));
						filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(
										FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO, anoMesReferenciaAnterior));
						filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.MEDICAO_TIPO_ID, medicaoTipo
										.getId()));
						filtroMedicaoHistorico
										.adicionarCaminhoParaCarregamentoEntidade(FiltroMedicaoHistorico.LEITURA_ANORMALIDADE_FATURADA);

						MedicaoHistorico medicaoHistoricoMesAnterior = (MedicaoHistorico) Util.retonarObjetoDeColecao(getControladorUtil()
										.pesquisar(filtroMedicaoHistorico, MedicaoHistorico.class.getName()));

						// Caso a anormalidade de consumo do mês anterior for igual a espaço (sem
						// anormalidade de consumo) e a anormalidade de leitura do mês anterior for
						// igual a zero (sem anormalidade de leitura)
						if(consumoAnormalidadeMesAnterior == null || consumoAnormalidadeMesAnterior.getId() == null
										|| medicaoHistoricoMesAnterior == null
										|| medicaoHistoricoMesAnterior.getLeituraAnormalidadeFaturamento() == null){
							
							boolean definirConsumoPelaAnormalidade = false;

							if(consumoHistorico.getConsumoAnormalidade() != null){

								// [SB0026 – Verificar Definição de Consumo pela Anormalidade de
								// Consumo]
								definirConsumoPelaAnormalidade = verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
												medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao,
												consumoHistorico.getConsumoAnormalidade(), consumoASerCobradoMes);
							}

							if(!definirConsumoPelaAnormalidade){

								// O Consumo a Ser Cobrado no Mês será igual ao consumo médio do
								// imóvel multiplicado pelo fator de multiplicação da média da
								// categoria do imóvel (CATG_NNVEZESMEDIAALTOCONSUMO)
								consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioMultiplicado);

								// Gera a Anormalidade de Consumo com o valor correspondente a “alto
								// consumo” (AC)
								ConsumoAnormalidade consumoAnormalidade = null;
								try{
									consumoAnormalidade = repositorioMicromedicao
													.pesquisarConsumoAnormalidade(ConsumoAnormalidade.ALTO_CONSUMO);
								}catch(ErroRepositorioException ex){

									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema", ex);
								}
								consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
							}

						}else if(consumoAnormalidadeMesAnterior != null
										&& consumoAnormalidadeMesAnterior.getId().equals(ConsumoAnormalidade.LEITURA_NAO_INFORMADA)){
							// Caso a anormalidade de consumo do mês anterior for igual a "leitura
							// não informada"

							boolean definirConsumoPelaAnormalidade = false;

							if(consumoHistorico.getConsumoAnormalidade() != null){

								// [SB0026 – Verificar Definição de Consumo pela Anormalidade de
								// Consumo]
								definirConsumoPelaAnormalidade = verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
												medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao,
												consumoHistorico.getConsumoAnormalidade(), consumoASerCobradoMes);
							}

							if(!definirConsumoPelaAnormalidade){

								// Gera a Anormalidade de Consumo com o valor correspondente a
								// "alto consumo falta leitura" (AF)
								ConsumoAnormalidade consumoAnormalidade = null;
								try{
									consumoAnormalidade = repositorioMicromedicao
													.pesquisarConsumoAnormalidade(ConsumoAnormalidade.ALTO_CONSUMO_FALTA_LEITURA);
								}catch(ErroRepositorioException ex){

									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema", ex);
								}
								consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

								// Recupera a última leitura real do imóvel
								Integer valorUltimaLeituraReal = null;
								Integer anoMesUltimaLeituraReal = null;
								Object[] dadosUltimaLeituraReal = null;

								try{
									dadosUltimaLeituraReal = repositorioMicromedicao.pesquisarDadosUltimaLeituraReal(imovel.getId());
								}catch(ErroRepositorioException ex){

									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema", ex);
								}
								
								if(!Util.isVazioOrNulo(dadosUltimaLeituraReal)) {
									valorUltimaLeituraReal = (Integer)dadosUltimaLeituraReal[0];
									anoMesUltimaLeituraReal = (Integer)dadosUltimaLeituraReal[1];
								}
								
								// O Consumo a Ser Cobrado no Mês será igual a diferença entre a
								// última leitura real e a leitura atual, dividido pelo numero de
								// meses compreendido entre as leituras								
								if(valorUltimaLeituraReal != null && anoMesUltimaLeituraReal != null
												&& medicaoHistorico.getLeituraAtualFaturamento() != null && anoMesReferenciaAtual != null
												&& anoMesReferenciaAtual.intValue() != anoMesUltimaLeituraReal.intValue()){

									consumoASerCobradoMes = (valorUltimaLeituraReal - medicaoHistorico.getLeituraAtualFaturamento())
													/ (anoMesReferenciaAtual - anoMesUltimaLeituraReal);
								}
								
								consumoHistorico.setNumeroConsumoFaturadoMes(consumoASerCobradoMes);
								
							}
							
						}else if(medicaoHistoricoMesAnterior != null
										&& medicaoHistoricoMesAnterior.getLeituraAnormalidadeFaturamento() != null){
							// Caso a anormalidade de leitura do mês anterior for diferente de zeros

							boolean definirConsumoPelaAnormalidade = false;

							if(consumoHistorico.getConsumoAnormalidade() != null){

								// [SB0026 – Verificar Definição de Consumo pela Anormalidade de
								// Consumo]
								definirConsumoPelaAnormalidade = verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
												medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao,
												consumoHistorico.getConsumoAnormalidade(), consumoASerCobradoMes);
							}

							if(!definirConsumoPelaAnormalidade){

								// O sistema gera a Anormalidade de Consumo com o valor
								// correspondente a "alto consumo anormalidade leitura" (AA)
								ConsumoAnormalidade consumoAnormalidade = null;
								try{
									consumoAnormalidade = repositorioMicromedicao
													.pesquisarConsumoAnormalidade(ConsumoAnormalidade.ALTO_CONSUMO_ANORMALIDADE_LEITURA);
								}catch(ErroRepositorioException ex){

									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema", ex);
								}
								consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

								// O Consumo a Ser Cobrado no Mês será igual ao consumo médio do
								// imóvel multiplicado pelo fator de multiplicação da média da
								// categoria do imóvel (CATG_NNVEZESMEDIAALTOCONSUMO)
								consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioMultiplicado);
							}

						}

					}
				}
				// ############# Alterado por Luciano - OC1034808 ############# - Fim
			}
		}

		return retorno;
	}
	
	/**
	 * Método responsável por verificar se há anormalidades de consumo do tipo ALTO_CONSUMO para o imóvel nos últimos seis meses
	 * 
	 * @author Luciano Galvao
	 * @date 04/08/2013 
	 */
	public Boolean verificarAnormalidadesConsumoUltimosMeses(Integer imovelId, Integer anoMesReferenciaFaturamento, Integer anormalidadeConsumo, Integer qtdeMeses)
					throws ControladorException{

		Boolean retorno = false;

		// Checa Anormalidade de Consumo
		Integer anoMesReferenciaAnoAnterior = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesReferenciaFaturamento, qtdeMeses);
		FiltroConsumoHistorico filtroConsumoHistorico = new FiltroConsumoHistorico();
		filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, imovelId));
		filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANORMALIDADE_CONSUMO, anormalidadeConsumo));
		filtroConsumoHistorico.adicionarParametro(new Intervalo(FiltroConsumoHistorico.ANO_MES_FATURAMENTO, anoMesReferenciaAnoAnterior,
						anoMesReferenciaFaturamento));

		Collection colecaoConsumoHistorico = getControladorUtil().pesquisar(filtroConsumoHistorico, ConsumoHistorico.class.getName());
		if(colecaoConsumoHistorico != null && !colecaoConsumoHistorico.isEmpty()){
			retorno = true;
		}else{
			retorno = false;
		}

		return retorno;

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SB0016] - Verificar
	 * Baixo Consumo pelo consumo médio
	 * 
	 * @date 21/03/2011
	 * @author Hebert Falcão
	 */
	protected void verificarBaixoConsumoPeloConsumoMedio(ConsumoHistorico consumoHistorico, int consumoMedioImovel, Imovel imovel,
					int consumoMinimoLigacao, MedicaoHistorico medicaoHistorico) throws ControladorException{

		// Obtém o consumo a ser cobrado no mês
		Integer consumoASerCobradoMes = consumoHistorico.getNumeroConsumoFaturadoMes();
		if(consumoASerCobradoMes == null){

			consumoASerCobradoMes = 0;
		}

		Integer pConsumoCobradoMinimo = Util.converterStringParaInteger(ParametroMicromedicao.P_CONSUMO_COBRADO_MINIMO.executar());
		if(pConsumoCobradoMinimo == null){
			throw new ControladorException("atencao.param_nao_cadastrado", null, ParametroMicromedicao.P_CONSUMO_COBRADO_MINIMO.getCodigo());
		}

		// Obtém situação da ligação de água
		LigacaoAguaSituacao ligacaoAguaSituacao = imovel.getLigacaoAguaSituacao();

		// Alteração conforme OC0857313
		// .......................................................
		Short indicadorFaturamentoSituacao = null;
		if(ligacaoAguaSituacao != null){
			if(ligacaoAguaSituacao.getIndicadorFaturamentoSituacao() != null){

				indicadorFaturamentoSituacao = ligacaoAguaSituacao.getIndicadorFaturamentoSituacao();
			}else{
				ligacaoAguaSituacao = this.getControladorLigacaoAgua().pesquisarLigacaoAguaSituacao(ligacaoAguaSituacao.getId());
				indicadorFaturamentoSituacao = ligacaoAguaSituacao.getIndicadorFaturamentoSituacao();

			}
		}

		// Verifica se o consumo mínimo de qualquer uma das categorias a qual o
		// imóvel pertence seja
		// maior que 40
		boolean consumoMinimoMaiorQueQuarenta = false;

		HashMap<Integer, Integer> consumoMinimoLigacaoPorCategoria = this.obterConsumoMinimoLigacaoPorCategoria(imovel, null);

		if(consumoMinimoLigacaoPorCategoria != null && !consumoMinimoLigacaoPorCategoria.isEmpty()){

			Set<Integer> keys = consumoMinimoLigacaoPorCategoria.keySet();

			for(Integer key : keys){
				Integer consumoMinimoCategoria = consumoMinimoLigacaoPorCategoria.get(key);

				// Desconsiderar o primeiro registro, pois ele é um totatlizador
				if(key != 0 && consumoMinimoCategoria != null && consumoMinimoCategoria > pConsumoCobradoMinimo){

					consumoMinimoMaiorQueQuarenta = true;
					break;
				}
			}
		}

		Collection<Categoria> colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		/*
		 * Obtendo a categoria do imóvel que tenha o maior
		 * número de economias
		 */
		Collections.sort((List) colecaoCategorias, new Comparator() {

			public int compare(Object a, Object b){

				Integer quatidadeEconomias1 = ((Categoria) a).getQuantidadeEconomiasCategoria();
				Integer quatidadeEconomias2 = ((Categoria) b).getQuantidadeEconomiasCategoria();

				return quatidadeEconomias1.compareTo(quatidadeEconomias2);

			}
		});

		Categoria categoriaComMaiorNumeroEconomias = (Categoria) colecaoCategorias.iterator().next();

		/*
		 * Obtém o consumo médio do imóvel multiplicado
		 * pelo percentual para determinação de baixo consumo da categoria
		 * com maior quantidade de ecônomias
		 */

		BigDecimal percentualBaixoConsumo = categoriaComMaiorNumeroEconomias.getPorcentagemMediaBaixoConsumo().divide(
						BigDecimal.valueOf(100));
		Integer consumoMedioMultiplicado = Util.arredondar(new BigDecimal(consumoMedioImovel).multiply(percentualBaixoConsumo));

		/*
		 * Caso o Consumo a Ser Cobrado no Mês seja inferior ao consumo médio do imóvel multiplicado
		 * pelo percentual para determinação de baixo consumo da categoria do imóvel que tenha o
		 * maior número de economias e a situação da ligação de água do imóvel igual a ligado
		 */
		if(consumoASerCobradoMes.intValue() < consumoMedioMultiplicado.intValue()
						&& LigacaoAguaSituacao.FATURAMENTO_ATIVO.equals(indicadorFaturamentoSituacao)){

			// ############# Alterado por Luciano - OC1034808 ############# - Inicio
			
			Short pVerificarBaixoConsumoSemAnormalidadeBC = Util
							.converterStringParaShort(ParametroMicromedicao.P_VERIFICAR_BAIXO_CONSUMO_SEM_ANORMALIDADE_BC.executar());

			// Caso o imóvel possua anormalidades de Baixo Consumo (BC)
			if(consumoHistorico.getConsumoAnormalidade() != null && consumoHistorico.getConsumoAnormalidade().getId() != null && consumoHistorico.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.BAIXO_CONSUMO)){
				
				// Consumo Mínimo de qualquer uma das Categorias a qual o imóvel pertence seja maior que 40 (P_CONSUMO_COBRADO_MINIMO)
				if(consumoMinimoMaiorQueQuarenta){

					/*
					 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “baixo
					 * consumo”
					 */
					ConsumoAnormalidade consumoAnormalidade = null;
					try{
						
						consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.BAIXO_CONSUMO);
					}catch(ErroRepositorioException ex){
						
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
					consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
					
					// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
					this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico, consumoMedioImovel,
									consumoMinimoLigacao, consumoAnormalidade, consumoASerCobradoMes);
				}
			}else if(pVerificarBaixoConsumoSemAnormalidadeBC != null
							&& pVerificarBaixoConsumoSemAnormalidadeBC.equals(ConstantesSistema.SIM)){
				// Esta regra só deve ser realizada se o parâmetro
				// P_VERIFICAR_BAIXO_CONSUMO_SEM_ANORMALIDADE_BC = 1 (Sim)

				// Caso o imóvel esteja sem anormalidades de Baixo Consumo (BC)

				if(consumoMedioImovel > pConsumoCobradoMinimo){

					/*
					 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “baixo
					 * consumo”
					 */
					ConsumoAnormalidade consumoAnormalidade = null;
					try{
						
						consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.BAIXO_CONSUMO);
					}catch(ErroRepositorioException ex){
						
						sessionContext.setRollbackOnly();
						throw new ControladorException("erro.sistema", ex);
					}
					consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
					
					// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
					this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico, consumoMedioImovel,
									consumoMinimoLigacao, consumoAnormalidade, consumoASerCobradoMes);
				}

			}

			// ############# Alterado por Luciano - OC1034808 ############# - Fim
		}
	}

	/**
	 * [UC00083] Gerar Dados para Leitura Convencional Txt - Detalhe [SB0002]
	 * Gerar Relação
	 * 
	 * @author Hebert Falcão
	 * @date 15/02/2011
	 * @param imovel
	 * @param anoMesAnterior
	 * @param sistemaParametro
	 * @param idMedicaoTipo
	 * @param medicaoHistoricoAnterior
	 * @throws ControladorException
	 *             , ErroRepositorioException
	 */
	private StringBuilder gerarDadosPorLeituraConvencionalTxtDetalhe(Imovel imovel, int anoMesAnterior, SistemaParametro sistemaParametro,
					Integer idMedicaoTipo, MedicaoHistorico medicaoHistoricoAnterior) throws ControladorException, ErroRepositorioException{

		StringBuilder arquivoTxtLinha = new StringBuilder();

		// ###### Início da Linha ######
		arquivoTxtLinha.append("0");

		// ###### Indicador de Corte ######
		String indicadorCorte = "";

		if(imovel.getLigacaoAguaSituacao() != null
						&& (LigacaoAguaSituacao.CORTADO.equals(imovel.getLigacaoAguaSituacao().getId()) || LigacaoAguaSituacao.CORTADO_PEDIDO
										.equals(imovel.getLigacaoAguaSituacao().getId()))){
			indicadorCorte = "**";
		}else{
			if(medicaoHistoricoAnterior != null
							&& medicaoHistoricoAnterior.getLeituraAnteriorFaturamento() != null
							&& medicaoHistoricoAnterior.getLeituraAtualInformada() != null
							&& medicaoHistoricoAnterior.getLeituraAnteriorFaturamento().equals(
											medicaoHistoricoAnterior.getLeituraAtualInformada())){
				indicadorCorte = "*P";
			}else{
				indicadorCorte = "";
			}
		}

		arquivoTxtLinha.append(Util.completaString(indicadorCorte, 3));

		// ###### Inscrição ######

		// Segmento
		String segmento = "00";

		if(imovel.getNumeroSegmento() != null){
			segmento = Util.adicionarZerosEsquedaNumero(2, String.valueOf(imovel.getNumeroSegmento()));
		}

		// Lote
		String lote = Util.adicionarZerosEsquedaNumero(4, String.valueOf(imovel.getLote()));

		// SubLote
		String subLote = Util.adicionarZerosEsquedaNumero(2, String.valueOf(imovel.getSubLote()));

		arquivoTxtLinha.append(segmento + "." + lote + "." + subLote);

		arquivoTxtLinha.append(Util.completaString("", 3));

		// ###### Endereço ######
		String enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatado(imovel.getId());

		if(enderecoImovel != null){
			arquivoTxtLinha.append(Util.completaString(enderecoImovel, 46));
		}else{
			arquivoTxtLinha.append(Util.completaString("", 46));
		}

		arquivoTxtLinha.append(" ");

		// ###### Dados da Categoria ######
		String descricaoCategoria = "";
		int quantidadeEconomia = 0;

		// UC0123 - Obter descrições da categoria do imóvel
		// UC0064 - Obter quantidade de economias
		Collection colecaoSubCategoria = this.getControladorImovel().obterQuantidadeEconomiasSubCategoria(imovel.getId());

		if(colecaoSubCategoria != null && !colecaoSubCategoria.isEmpty()){
			Iterator itera = colecaoSubCategoria.iterator();

			while(itera.hasNext()){
				Subcategoria subcategoria = (Subcategoria) itera.next();

				if(descricaoCategoria.equals("")){
					descricaoCategoria = subcategoria.getCategoria().getDescricao();
				}else if(descricaoCategoria != subcategoria.getCategoria().getDescricao()){
					descricaoCategoria = "MISTO";
				}

				quantidadeEconomia = quantidadeEconomia + subcategoria.getQuantidadeEconomias();
			}
		}

		arquivoTxtLinha.append(Util.completaString(descricaoCategoria, 1));
		arquivoTxtLinha.append(Util.adicionarZerosEsquedaNumero(3, Integer.toString(quantidadeEconomia)));

		arquivoTxtLinha.append(" ");

		// ###### Hidrômetro ######
		String numeroHidrometro = "";
		String localInstalacaoHidrometro = "";

		if(MedicaoTipo.POCO.equals(idMedicaoTipo)){
			if(imovel.getHidrometroInstalacaoHistorico() != null && imovel.getHidrometroInstalacaoHistorico().getHidrometro() != null){
				numeroHidrometro = imovel.getHidrometroInstalacaoHistorico().getHidrometro().getNumero().trim();
			}

			if(imovel.getHidrometroInstalacaoHistorico() != null
							&& imovel.getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao() != null){
				localInstalacaoHidrometro = imovel.getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao().getDescricao();
			}
		}else{
			if(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
							&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro() != null){
				numeroHidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro().getNumero().trim();
			}

			if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
							&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao() != null){
				localInstalacaoHidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometroLocalInstalacao()
								.getDescricao();
			}
		}

		arquivoTxtLinha.append(Util.completaString(numeroHidrometro, 10));

		arquivoTxtLinha.append(" ");

		arquivoTxtLinha.append(Util.completaString(localInstalacaoHidrometro, 3));

		arquivoTxtLinha.append(" ");

		// ###### Matrícula do Imóvel ######
		arquivoTxtLinha.append(Util.completaStringComEspacoAEsquerda(Integer.toString(imovel.getId()), 9));

		arquivoTxtLinha.append(" ");

		arquivoTxtLinha.append(Util.completaString("------- I  I --- ------", 23));

		arquivoTxtLinha.append("  ");

		// ###### Leitura Esperada ######
		Short numeroDigitosHidrometro = null;
		StringBuilder dadosHidrometro = null;

		if(MedicaoTipo.LIGACAO_AGUA.equals(idMedicaoTipo)){
			Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoLigacaoAgua(imovel);

			dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
			numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
		}else{
			Object[] dadosHidrometroNumeroLeitura = pesquisarDadosHidrometroTipoPoco(imovel);

			dadosHidrometro = (StringBuilder) dadosHidrometroNumeroLeitura[0];
			numeroDigitosHidrometro = (Short) dadosHidrometroNumeroLeitura[1];
		}

		String leituraAnterior = null;

		if(medicaoHistoricoAnterior != null && medicaoHistoricoAnterior.getLeituraAtualFaturamento() != null){
			leituraAnterior = Integer.toString(medicaoHistoricoAnterior.getLeituraAtualFaturamento());
		}

		Object[] faixaInicialFinal = pesquisarFaixaEsperadaOuFalsa(imovel, dadosHidrometro, leituraAnterior, medicaoHistoricoAnterior,
						idMedicaoTipo, sistemaParametro, false, numeroDigitosHidrometro);

		StringBuilder faixa = (StringBuilder) faixaInicialFinal[0];

		arquivoTxtLinha.append(faixa.substring(0, 6));

		arquivoTxtLinha.append("  ");

		arquivoTxtLinha.append(faixa.substring(6, 12));

		arquivoTxtLinha.append(System.getProperty("line.separator"));

		return arquivoTxtLinha;
	}

	/**
	 * @author Ailton Sousa
	 * @date 16/02/2011 [UCXXXX] - Obter Consumo Mínimo da Ligação Por Categoria
	 * @param imovel
	 * @param colecaoCategorias
	 * @return HashMap
	 * @throws ControladorException
	 */
	public HashMap obterConsumoMinimoLigacaoPorCategoria(Imovel imovel, Collection colecaoCategorias) throws ControladorException{

		// Declaração de variáveis
		int consumoMinimoLigacao = 0;

		// Declaração de objetos
		Collection colecaoDataVigencia = null;
		Integer consumoMinimo = null;
		HashMap<Integer, Integer> mapConsumoMinimoPorCategoria = new HashMap();

		// Obtém o id do consumo tarifa vigência da maior data de vigência da
		// tarifa do imóvel
		try{
			colecaoDataVigencia = repositorioMicromedicao.pesquisarMaiorDataVigenciaConsumoTarifaImovel(new Date(), imovel
							.getConsumoTarifa().getId());
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Obtém o id do array e atribui na variável
		Object[] consumoTarifaVigenciaIdArray = (Object[]) Util.retonarObjetoDeColecaoArray(colecaoDataVigencia);
		Integer consumoTarifaVigenciaId = null;

		if(consumoTarifaVigenciaIdArray == null){
			// String usada para "SimularCalculoConta", no qual não vem o Id do
			// imóvel.
			String mensagemImovel = "na simulação";
			if(imovel != null && imovel.getId() != null){
				mensagemImovel = String.valueOf(imovel.getId());
			}
			throw new ControladorException("atencao.nao_cadastrada_consumo_tarifa_vigencia", null, mensagemImovel);
		}

		if(consumoTarifaVigenciaIdArray[0] != null){
			consumoTarifaVigenciaId = (Integer) consumoTarifaVigenciaIdArray[0];
		}

		// Cria o objeto consumo tarifa vigência e seta o id
		ConsumoTarifaVigencia consumoTarifaVigencia = new ConsumoTarifaVigencia();
		consumoTarifaVigencia.setId(consumoTarifaVigenciaId);

		// [UC0108] - Obter Quantidade de Economias por Categoria
		if(colecaoCategorias == null){
			colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
		}

		Iterator colecaoCategoriasIterator = colecaoCategorias.iterator();

		while(colecaoCategoriasIterator.hasNext()){

			Categoria categoria = (Categoria) colecaoCategoriasIterator.next();

			try{
				// Obtém o consumo mínimo da tarifa da categoria do imóvel
				Object consumoMinimoObjeto = repositorioMicromedicao.pesquisarConsumoMinimoTarifaCategoriaVigencia(categoria,
								consumoTarifaVigencia);
				consumoMinimo = (Integer) consumoMinimoObjeto;
			}catch(ErroRepositorioException ex){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			if(consumoMinimo != null){
				// Multiplica a quantidade de economias da categoria pelo
				// consumo
				// mínimo e acumula
				consumoMinimoLigacao = consumoMinimoLigacao
								+ (categoria.getQuantidadeEconomiasCategoria().intValue() * consumoMinimo.intValue());

				// Salva o consumo mínimo para cada categoria e mapeia pelo ID
				// da Categoria
				mapConsumoMinimoPorCategoria.put(categoria.getId(), (categoria.getQuantidadeEconomiasCategoria().intValue() * consumoMinimo
								.intValue()));
			}

		}

		// Acrescenta o Consumo Mínimo Total da Ligação e Mapeia com zero (0)
		mapConsumoMinimoPorCategoria.put(new Integer(0), consumoMinimoLigacao);

		// Retorna o Map com o consumo mínimo por categoria e consumo mínimo
		// total da ligação
		return mapConsumoMinimoPorCategoria;
	}

	/**
	 * [UC0XXX] Gerar Relatório Grandes Consumidores
	 * 
	 * @author Anderson Italo
	 * @date 16/02/2011 Obter média de consumo do hidrômetro por imóvel
	 */
	public Integer pesquisarMediaConsumoHidrometro(Integer matricula) throws ControladorException{

		Integer retorno = null;
		try{
			retorno = this.repositorioMicromedicao.pesquisarMediaConsumoHidrometro(matricula);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * @author isilva
	 * @date 23/05/2011 Obtem as últimas referências dos Dados de Leitura e
	 *       Consumo do imóvel
	 * @param idImovel
	 *            Identificador do Imóvel
	 * @param maximoResultado
	 *            Resultado máximo, se informado null ou um número menor ou
	 *            igual a zero, a consulta retornará quantidades de linhas
	 *            ilimitadas
	 * @return
	 * @throws ControladorException
	 */
	public Collection<LeituraConsumoHelper> obterDadosLeituraEConsumo(Integer idImovel, Integer maximoResultado)
					throws ControladorException{

		Collection<LeituraConsumoHelper> retorno = null;
		try{
			retorno = this.repositorioMicromedicao.obterDadosLeituraEConsumo(idImovel, maximoResultado);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Relatório de Ordem de Serviço de Ligação de Água
	 * 
	 * @author Anderson Italo
	 * @date 25/05/2011
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public HidrometroRelatorioOSHelper obterDadosHidrometroPorImovel(Integer idImovel) throws ControladorException{

		HidrometroRelatorioOSHelper hidrometroRelatorioOSHelper = new HidrometroRelatorioOSHelper();
		Object[] dadosHidrometro = null;

		try{
			dadosHidrometro = repositorioMicromedicao.obterDadosHidrometroPorImovel(idImovel);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(dadosHidrometro != null){

			if(dadosHidrometro[0] != null){

				String numeroHidrometro = (String) dadosHidrometro[0];
				hidrometroRelatorioOSHelper.setHidrometroFixo(numeroHidrometro.substring(0, 4));
				numeroHidrometro = Util.adicionarZerosEsquedaNumero(10, numeroHidrometro.substring(4, numeroHidrometro.length()));
				hidrometroRelatorioOSHelper.setHidrometroNumero(numeroHidrometro.substring(4, 10));

			}

			if(dadosHidrometro[1] != null){
				hidrometroRelatorioOSHelper.setHidrometroMarca((String) dadosHidrometro[1]);
			}

			if(dadosHidrometro[2] != null){
				hidrometroRelatorioOSHelper.setHidrometroCapacidade((String) dadosHidrometro[2]);
			}

			if(dadosHidrometro[3] != null){
				hidrometroRelatorioOSHelper.setHidrometroDiametro((String) dadosHidrometro[3]);
			}

			if(dadosHidrometro[4] != null){
				hidrometroRelatorioOSHelper.setHidrometroLocal((String) dadosHidrometro[4]);
			}

			if(dadosHidrometro[5] != null){
				hidrometroRelatorioOSHelper.setHidrometroNumeroDigitos("" + (Short) dadosHidrometro[5]);
			}

			if(dadosHidrometro[6] != null){
				hidrometroRelatorioOSHelper.setDataInstalacaoHidrometo(Util.formatarData((Date) dadosHidrometro[6]));
			}

			if(dadosHidrometro[8] != null){
				hidrometroRelatorioOSHelper.setIdProtecaoHidrometro(((Integer) dadosHidrometro[7]).toString());
				hidrometroRelatorioOSHelper.setDescricaoProtecaoHidrometro((String) dadosHidrometro[8]);
			}

			if(dadosHidrometro[10] != null){
				hidrometroRelatorioOSHelper.setIdTipoHidrometro(((Integer) dadosHidrometro[9]).toString());
				hidrometroRelatorioOSHelper.setDescricaoTipoHidrometro((String) dadosHidrometro[10]);
			}

			if(dadosHidrometro[11] != null){

				if(((Short) dadosHidrometro[11]) == 1){
					hidrometroRelatorioOSHelper.setIndicadorCavalete("Sim");
				}else{
					hidrometroRelatorioOSHelper.setIndicadorCavalete("Não");
				}
			}else{
				hidrometroRelatorioOSHelper.setIndicadorCavalete("Não");
			}

			if(dadosHidrometro[12] != null){

				hidrometroRelatorioOSHelper.setAnoFabricacaoHidrometro(((Short) dadosHidrometro[12]).toString());
			}

		}

		return hidrometroRelatorioOSHelper;
	}

	/**
	 * Relatório Ordem de Serviço de Substituição de Hidrômetro Obter dados da
	 * leitura e consumo do imóvel
	 * 
	 * @author Anderson Italo
	 * @date 26/05/2011
	 */
	public Object[] pesquisarLeituraConsumoImovel(Integer matricula) throws ControladorException{

		Object[] retorno = null;
		try{
			retorno = this.repositorioMicromedicao.pesquisarLeituraConsumoImovel(matricula);
		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Pesquisar Medição Histório para Substituição de Leitura [UC3009] -
	 * Substituir Leituras Anteriores
	 * 
	 * @author Hebert Falcão
	 * @date 09/06/2011
	 */
	public Collection<MedicaoHistorico> pesquisaMedicaoHistoricoSubstituirLeitura(Integer idImovel) throws ControladorException{

		Collection<MedicaoHistorico> retorno = new ArrayList<MedicaoHistorico>();

		try{
			Integer anoMesInicial = null;
			Integer anoMesFinal = null;

			Integer anoMesFaturamento = repositorioFaturamento.retornaAnoMesFaturamentoGrupo(idImovel);

			Short pPermiteSubstituirTodasLeiturasAnteriores = Util
							.converterStringParaShort(ParametroMicromedicao.P_PERMITE_SUBSTITUIR_TODAS_LEITURAS_ANTERIORES.executar());

			if(pPermiteSubstituirTodasLeiturasAnteriores != null && pPermiteSubstituirTodasLeiturasAnteriores.equals(ConstantesSistema.NAO)){
				anoMesInicial = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesFaturamento, new Integer(1));

				anoMesFinal = anoMesFaturamento;
			}else{
				SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

				anoMesInicial = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesFaturamento,
								new Integer(sistemaParametro.getMesesMediaLeitura()));

				anoMesFinal = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesFaturamento, new Integer(1));
			}

			Collection resultado = repositorioMicromedicao.pesquisaMedicaoHistoricoSubstituirLeitura(idImovel, anoMesInicial, anoMesFinal);

			if(!Util.isVazioOrNulo(resultado)){
				Integer consumoMedio = this.obterConsumoMedio(idImovel);

				MedicaoHistorico medicaoHistorico = null;

				Object[] objetoResultado = null;
				Iterator iterator = resultado.iterator();

				Integer maiorAnoMesReferencia = null;
				Integer anoMesReferencia = null;

				while(iterator.hasNext()){
					medicaoHistorico = new MedicaoHistorico();

					objetoResultado = (Object[]) iterator.next();

					// Medição Tipo
					MedicaoTipo medicaoTipo = null;

					if(objetoResultado[0] != null){
						// Água
						Integer id = (Integer) objetoResultado[0];

						medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId(id);
						medicaoTipo.setDescricao(MedicaoTipo.DESC_LIGACAO_AGUA);
					}else if(objetoResultado[1] != null){
						// Poço
						Integer id = (Integer) objetoResultado[1];

						medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId(id);
						medicaoTipo.setDescricao(MedicaoTipo.DESC_POCO);
					}

					medicaoHistorico.setMedicaoTipo(medicaoTipo);

					// Medição Histórico
					if(objetoResultado[2] != null){
						// Água
						Integer id = (Integer) objetoResultado[2];
						medicaoHistorico.setId(id);
					}else if(objetoResultado[3] != null){
						// Poço
						Integer id = (Integer) objetoResultado[3];
						medicaoHistorico.setId(id);
					}

					anoMesReferencia = null;

					// Ano / Mês de Referência
					if(objetoResultado[4] != null){
						// Água
						anoMesReferencia = (Integer) objetoResultado[4];
						medicaoHistorico.setAnoMesReferencia(anoMesReferencia);
					}else if(objetoResultado[5] != null){
						// Poço
						anoMesReferencia = (Integer) objetoResultado[5];
						medicaoHistorico.setAnoMesReferencia(anoMesReferencia);
					}

					// Leitura
					if(objetoResultado[6] != null){
						// Água
						Integer leituraAtualFaturamento = (Integer) objetoResultado[6];
						medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);
					}else if(objetoResultado[7] != null){
						// Poço
						Integer leituraAtualFaturamento = (Integer) objetoResultado[7];
						medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);
					}

					// Leitura Situação
					LeituraSituacao leituraSituacaoAtual = null;

					if(objetoResultado[8] != null){
						// Água
						String descricao = (String) objetoResultado[8];

						leituraSituacaoAtual = new LeituraSituacao();
						leituraSituacaoAtual.setDescricao(descricao);
					}else if(objetoResultado[9] != null){
						// Poço
						String descricao = (String) objetoResultado[9];

						leituraSituacaoAtual = new LeituraSituacao();
						leituraSituacaoAtual.setDescricao(descricao);
					}

					medicaoHistorico.setLeituraSituacaoAtual(leituraSituacaoAtual);

					// Anormalidade
					LeituraAnormalidade leituraAnormalidadeFaturamento = null;

					if(objetoResultado[10] != null){
						// Água
						String descricaoAbreviada = (String) objetoResultado[10];

						leituraAnormalidadeFaturamento = new LeituraAnormalidade();
						leituraAnormalidadeFaturamento.setDescricaoAbreviada(descricaoAbreviada);
					}else if(objetoResultado[11] != null){
						// Poço
						String descricaoAbreviada = (String) objetoResultado[11];

						leituraAnormalidadeFaturamento = new LeituraAnormalidade();
						leituraAnormalidadeFaturamento.setDescricaoAbreviada(descricaoAbreviada);
					}

					medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidadeFaturamento);

					if(maiorAnoMesReferencia == null
									|| (maiorAnoMesReferencia != null && anoMesReferencia != null && maiorAnoMesReferencia < anoMesReferencia)){
						maiorAnoMesReferencia = anoMesReferencia;
					}

					if(pPermiteSubstituirTodasLeiturasAnteriores != null
									&& pPermiteSubstituirTodasLeiturasAnteriores.equals(ConstantesSistema.NAO)){
						medicaoHistorico.setPermiteAlterarConsumoMedio(ConstantesSistema.SIM);
					}else{
						medicaoHistorico.setPermiteAlterarConsumoMedio(ConstantesSistema.NAO);
					}

					if(consumoMedio != null){
						medicaoHistorico.setConsumoMedioAux(consumoMedio);
					}

					retorno.add(medicaoHistorico);
				}

				Collections.sort((List) retorno, new Comparator() {

					public int compare(Object o1, Object o2){

						MedicaoHistorico r1 = (MedicaoHistorico) o1;
						MedicaoHistorico r2 = (MedicaoHistorico) o2;
						return r1.getAnoMesReferencia() < r2.getAnoMesReferencia() ? -1 : (r1.getAnoMesReferencia() > r2
										.getAnoMesReferencia() ? +1 : 0);
					}
				});

				Collections.reverse((List) retorno);

				if(pPermiteSubstituirTodasLeiturasAnteriores != null
								&& pPermiteSubstituirTodasLeiturasAnteriores.equals(ConstantesSistema.NAO)){
					Collection<MedicaoHistorico> colecaoMedicaoHistoricoMaiorReferencia = new ArrayList<MedicaoHistorico>();

					for(MedicaoHistorico medicaoHistoricoAux : retorno){
						anoMesReferencia = medicaoHistoricoAux.getAnoMesReferencia();

						if(anoMesReferencia != null && maiorAnoMesReferencia != null
										&& anoMesReferencia.intValue() == maiorAnoMesReferencia.intValue()){
							colecaoMedicaoHistoricoMaiorReferencia.add(medicaoHistorico);
						}
					}

					retorno = colecaoMedicaoHistoricoMaiorReferencia;
				}
			}

		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Atualizar Leituras Anteriores [UC3009] - Substituir Leituras Anteriores
	 * 
	 * @author Hebert Falcão
	 * @date 09/06/2011
	 */
	public void atualizarLeiturasAnteriores(MedicaoHistorico medicaoHistorico, Usuario usuarioLogado, Integer consumoMedio)
					throws ControladorException{

		Integer idMedicaoHistorico = medicaoHistorico.getId();
		Integer leituraAtualFaturamento = medicaoHistorico.getLeituraAtualFaturamento();
		Integer leituraAtualAnteriorFaturamento = medicaoHistorico.getLeituraAnteriorFaturamento();

		FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();
		filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.ID, idMedicaoHistorico));

		Collection<MedicaoHistorico> colecaoMedicaoHistorico = this.getControladorUtil().pesquisar(filtroMedicaoHistorico,
						MedicaoHistorico.class.getName());

		if(!Util.isVazioOrNulo(colecaoMedicaoHistorico)){
			MedicaoHistorico medicaoHistoricoBase = (MedicaoHistorico) Util.retonarObjetoDeColecao(colecaoMedicaoHistorico);
			medicaoHistoricoBase.setUltimaAlteracao(new Date());
			medicaoHistoricoBase.setLeituraAtualFaturamento(leituraAtualFaturamento);

			if(leituraAtualAnteriorFaturamento != null){

				medicaoHistoricoBase.setLeituraAnteriorFaturamento(leituraAtualAnteriorFaturamento);
			}

			// Registrar Transação - Início
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(Operacao.OPERACAO_SUBSTITUIR_LEITURAS_ANTERIORES,
							idMedicaoHistorico, idMedicaoHistorico, new UsuarioAcaoUsuarioHelper(usuarioLogado,
											UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_SUBSTITUIR_LEITURAS_ANTERIORES);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);

			medicaoHistoricoBase.setOperacaoEfetuada(operacaoEfetuada);
			medicaoHistoricoBase.adicionarUsuario(usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

			registradorOperacao.registrarOperacao(medicaoHistoricoBase);
			// Registrar Transação - Fim

			try{
				this.getControladorUtil().atualizar(medicaoHistoricoBase);

				if(consumoMedio != null){
					Integer idImovel = null;

					MedicaoTipo medicaoTipo = medicaoHistoricoBase.getMedicaoTipo();

					if(medicaoTipo != null){
						Integer idMedicaoTipo = medicaoTipo.getId();

						if(idMedicaoTipo.intValue() == MedicaoTipo.LIGACAO_AGUA){
							LigacaoAgua ligacaoAgua = medicaoHistoricoBase.getLigacaoAgua();

							if(ligacaoAgua != null){
								idImovel = ligacaoAgua.getId();
							}
						}else{
							Imovel imovel = medicaoHistoricoBase.getImovel();

							if(imovel != null){
								idImovel = imovel.getId();
							}
						}
					}

					if(idImovel != null){
						Imovel imovel = new Imovel();
						imovel.setId(idImovel);

						int qtdeEconomias = this.getControladorImovel().obterQuantidadeEconomias(imovel);

						Integer consumoMedioAtualizar = consumoMedio / qtdeEconomias;

						if(consumoMedioAtualizar.intValue() == ConstantesSistema.ZERO.intValue()){
							consumoMedioAtualizar = qtdeEconomias;
						}else{
							consumoMedioAtualizar = consumoMedioAtualizar * qtdeEconomias;
						}

						String idImovelStr = Integer.toString(idImovel);

						ConsumoHistorico consumoHistorico = this.obterUltimoConsumoHistoricoImovel(idImovelStr);

						if(consumoHistorico != null){
							Integer idConsumoHistorico = consumoHistorico.getId();

							this.atualizarUltimoConsumoHistorico(idConsumoHistorico, consumoMedio);
						}
					}
				}
			}catch(ControladorException ex){
				sessionContext.setRollbackOnly();
				throw ex;
			}
		}
	}

	/**
	 * @author Isaac Silva
	 * @date 10/06/2011
	 * @param colecaoImovelMicromedicao
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void atualizarConsumosAnterioresEConsumosMedio(Collection<ImovelMicromedicao> colecaoImovelMicromedicao, Usuario usuarioLogado,
					boolean atualizarConsumoMedio) throws ControladorException{

		if(!Util.isVazioOrNulo(colecaoImovelMicromedicao)){

			try{
				ConsumoHistorico consumoHistoricoAgua = null;
				ConsumoHistorico consumoHistoricoEsgoto = null;

				for(ImovelMicromedicao imovelMicromedicao : colecaoImovelMicromedicao){
					consumoHistoricoAgua = imovelMicromedicao.getConsumoHistorico();

					if(consumoHistoricoAgua != null){
						this.atualizarConsumosAnteriores(consumoHistoricoAgua, usuarioLogado);
					}

					consumoHistoricoEsgoto = imovelMicromedicao.getConsumoHistoricoEsgoto();

					if(consumoHistoricoEsgoto != null){
						this.atualizarConsumosAnteriores(consumoHistoricoEsgoto, usuarioLogado);
					}
				}

				if(atualizarConsumoMedio){
					SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();

					Imovel imovel = null;
					Integer idImovel = null;

					Integer anoMesGrupoFaturamento = null;

					MedicaoTipo medicaoTipo = null;

					for(ImovelMicromedicao imovelMicromedicao : colecaoImovelMicromedicao){
						imovel = imovelMicromedicao.getImovel();
						idImovel = imovel.getId();

						anoMesGrupoFaturamento = imovelMicromedicao.getAnoMesGrupoFaturamento();
						sistemaParametro.setAnoMesFaturamento(anoMesGrupoFaturamento);

						int[] consumoMedioImovel = this.obterConsumoMedioImovel(imovel, sistemaParametro);

						medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);

						int[] consumoMedioHidrometroAgua = this.obterConsumoMedioHidrometro(imovel, sistemaParametro, medicaoTipo);

						medicaoTipo = new MedicaoTipo();
						medicaoTipo.setId(MedicaoTipo.POCO);

						int[] consumoMedioHidrometroEsgoto = this.obterConsumoMedioHidrometro(imovel, sistemaParametro, medicaoTipo);

						this.atualizarConsumosMedioHistoricoConsumos(idImovel, anoMesGrupoFaturamento, consumoMedioImovel[0],
										consumoMedioHidrometroAgua[0], consumoMedioHidrometroEsgoto[0], usuarioLogado);

						break;
					}
				}
			}catch(Exception e){
				sessionContext.setRollbackOnly();
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}
		}

	}

	/**
	 * @author Isaac Silva
	 * @date 13/06/2011
	 * @param idImovel
	 * @param anoMesGrupoFaturamento
	 * @param consumoMedioImovel
	 * @param consumoMedioHidrometroAgua
	 * @param consumoMedioHidrometroEsgoto
	 * @param usuario
	 * @throws ControladorException
	 */
	public void atualizarConsumosMedioHistoricoConsumos(Integer idImovel, Integer anoMesGrupoFaturamento, int consumoMedioImovel,
					int consumoMedioHidrometroAgua, int consumoMedioHidrometroEsgoto, Usuario usuario) throws ControladorException{

		try{

			Collection colecaoConsumo = repositorioMicromedicao.pesquisarConsumoHistoricoPorReferenciaFaturamentoImovel(idImovel,
							anoMesGrupoFaturamento);

			if(Util.isVazioOrNulo(colecaoConsumo)){
				anoMesGrupoFaturamento = Util.subtrairMesDoAnoMes(anoMesGrupoFaturamento, 1);
			}

			Collection<ConsumoHistorico> colecaoConsumoHistorico = (ArrayList<ConsumoHistorico>) repositorioMicromedicao
							.pesquisarConsumoHistoricoPorReferenciaFaturamentoImovel(idImovel, anoMesGrupoFaturamento);

			if(!Util.isVazioOrNulo(colecaoConsumoHistorico)){

				for(ConsumoHistorico consumo : colecaoConsumoHistorico){

					consumo.setConsumoMedio(consumoMedioImovel);
					consumo.setUltimaAlteracao(new Date());

					// ------------ REGISTRAR TRANSAÇÃO ------------
					RegistradorOperacao registradorOperacaoMedicao = new RegistradorOperacao(
									Operacao.OPERACAO_SUBSTITUIR_CONSUMOS_ANTERIORES, consumo.getId(), consumo.getId(),
									new UsuarioAcaoUsuarioHelper(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					Operacao operacaoMedicao = new Operacao();
					operacaoMedicao.setId(Operacao.OPERACAO_SUBSTITUIR_CONSUMOS_ANTERIORES);

					OperacaoEfetuada operacaoEfetuadaMedicao = new OperacaoEfetuada();
					operacaoEfetuadaMedicao.setOperacao(operacaoMedicao);

					consumo.setOperacaoEfetuada(operacaoEfetuadaMedicao);
					consumo.adicionarUsuario(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

					registradorOperacaoMedicao.registrarOperacao(consumo);
					// Fim - Registrando as transações

					getControladorUtil().atualizar(consumo);

				}
			}

			Collection<MedicaoHistorico> colecaoMedicaoHistoricoAtualizar = (ArrayList<MedicaoHistorico>) repositorioMicromedicao
							.pesquisarMedicaoHistoricoAguaOuEsgotoPorImovelEReferencia(idImovel, anoMesGrupoFaturamento,
											consumoMedioHidrometroAgua, null);

			if(!Util.isVazioOrNulo(colecaoMedicaoHistoricoAtualizar)){

				for(MedicaoHistorico medicao : colecaoMedicaoHistoricoAtualizar){

					if(consumoMedioHidrometroAgua != 0){
						medicao.setConsumoMedioHidrometro(consumoMedioHidrometroAgua);
					}else{
						medicao.setConsumoMedioHidrometro(consumoMedioHidrometroEsgoto);
					}

					medicao.setUltimaAlteracao(new Date());

					// ------------ REGISTRAR TRANSAÇÃO ------------
					RegistradorOperacao registradorOperacaoMedicao = new RegistradorOperacao(
									Operacao.OPERACAO_ATUALIZAR_EXECECOES_LEITURAS_RESUMO, medicao.getId(), medicao.getId(),
									new UsuarioAcaoUsuarioHelper(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

					Operacao operacaoMedicao = new Operacao();
					operacaoMedicao.setId(Operacao.OPERACAO_ATUALIZAR_EXECECOES_LEITURAS_RESUMO);

					OperacaoEfetuada operacaoEfetuadaMedicao = new OperacaoEfetuada();
					operacaoEfetuadaMedicao.setOperacao(operacaoMedicao);

					medicao.setOperacaoEfetuada(operacaoEfetuadaMedicao);
					medicao.adicionarUsuario(usuario, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);

					registradorOperacaoMedicao.registrarOperacao(medicao);
					// Fim - Registrando as transações

					getControladorUtil().atualizar(medicao);

				}
			}

		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}catch(ControladorException e){
			sessionContext.setRollbackOnly();
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Consultar última medição histórico do imóvel
	 * 
	 * @author Hebert Falcão
	 * @date 22/06/2011
	 */
	public MedicaoHistorico consultarUltimaMedicaoHistoricoDoImovel(Integer idImovel, Integer idHidrometro) throws ControladorException{

		MedicaoHistorico retorno = null;

		try{
			retorno = repositorioMicromedicao.consultarUltimaMedicaoHistoricoDoImovel(idImovel, idHidrometro);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * [UC0083] Gerar Dados para Leitura
	 * [SB0006] – Seleção imóveis para Faturamento
	 * O sistema obtém os gera a lista dos critérios caracterizadores da situação específica do
	 * imóvel para atividade de faturamento e para o tipo de leitura da rota do imóvel, caso exista
	 * critério específico para o tipo de leitura (seleciona a partir da tabela
	 * FATURAMENTO_ATIVIDADE_CRITERIO com FTAT_ID correspondente a “gerar e enviar arq. Leitura” e
	 * (LTTP_ID=LTTP_ID da tabela ROTA, caso exista ou LTTP_ID=nulo)).
	 * 
	 * @author Isaac Silva, Anderson Italo
	 * @date 29/06/2011, 15/08/2011
	 * @param imovel
	 * @param anoMesReferencia
	 * @return boolean
	 * @throws ControladorException
	 */
	protected boolean verificarCorrespondenciaFaturamentoAtividadeCriterioEImovel(Imovel imovel,
					Collection colecaoFaturamentoAtividadeCriterio) throws ControladorException{

		short indicadorAtendimentoCriterioFaturamentoImovel = ConstantesSistema.NAO;
		boolean retorno = false;

		if(Util.isVazioOrNulo(colecaoFaturamentoAtividadeCriterio)){
			return true;
		}

		/*
		 * Para cada imóvel da rota:
		 * O sistema verifica se o imóvel atende a um dos critérios
		 * <<Inclui>> [UC3010 – Verificar Atendimento do Critério de Faturamento pelo Imóvel],
		 * passando o imóvel (IMOV_ID da tabela IMOVEL) e a lista dos critérios gerada
		 */
		indicadorAtendimentoCriterioFaturamentoImovel = verificarAtendimentoCriterioFaturamentoImovel(imovel,
						colecaoFaturamentoAtividadeCriterio);

		/*
		 * Caso o imóvel não atenda a nenhum dos critérios (Indicador Atendimento dos Critérios pelo
		 * Imóvel retornado pelo UC3010 com o valor 2 (dois)), não selecionar
		 * o imóvel para a geração de dados para leitura
		 */
		if(indicadorAtendimentoCriterioFaturamentoImovel == ConstantesSistema.SIM.shortValue()){

			retorno = true;
		}

		return retorno;
	}

	/**
	 * Verifica Limites de Anormalidades Aceitavel para a empresa.
	 * 
	 * @author Péricles Tavares
	 * @date 02/08/2011
	 * @param idFaturamentoGrupo
	 * @throws ControladorException
	 */
	public Map<ControladorException, Collection<Object[]>> verificarLimiteAnormalidadesAceitavel(Integer idFaturamentoGrupo)
					throws ControladorException{

		Map<ControladorException, Collection<Object[]>> retorno = new HashMap<ControladorException, Collection<Object[]>>();
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) getControladorUtil().pesquisar(idFaturamentoGrupo, FaturamentoGrupo.class,
						false);
		Collection<Object[]> movimentosRoteiroEmpresa = new ArrayList<Object[]>();
		if(Util.validarNumeroMaiorQueZERO(sistemaParametro.getCodigoLimiteAceitavelAnormalidades())){
			try{
				switch(sistemaParametro.getCodigoLimiteAceitavelAnormalidades()){
					case 1:
						Integer qtidadeAnormalidades = repositorioMicromedicao.quantidadeAnormalidadesGrupoFaturamento(idFaturamentoGrupo);
						if(Util.validarNumeroMaiorQueZERO(qtidadeAnormalidades)){
							Integer qtidadeLeituras = repositorioMicromedicao.quantidadeLeiturasGrupoFaturamento(idFaturamentoGrupo);
							BigDecimal percentual = sistemaParametro.getPercentualAnormalidadeAceitavel().divide(new BigDecimal(100));
							BigDecimal qtidadeAceitavelAnormalidades = new BigDecimal(qtidadeLeituras).multiply(percentual);
							if(qtidadeAnormalidades > qtidadeAceitavelAnormalidades.doubleValue()){
								movimentosRoteiroEmpresa = repositorioMicromedicao
												.recuperarAnormalidadesGrupoFaturamento(idFaturamentoGrupo);
								retorno.put(new ControladorException("atencao.quantidade_anormalidades_superior_aceitavel", null,
												qtidadeAnormalidades.toString(), faturamentoGrupo.getDescricao(),
												qtidadeAceitavelAnormalidades.toString()), movimentosRoteiroEmpresa);
							}
						}
						break;
					case 2:
						Collection<Object[]> anormalidadesSetorComercial = repositorioMicromedicao
										.quantidadeAnormalidadesGrupoFaturamentoPorSetorComercial(idFaturamentoGrupo);
						if(anormalidadesSetorComercial != null){
							boolean indicadorExcessoAnormalidadeSetorComercial = false;
							Integer qtidadeAnormalidadesSetorComercial;
							Integer qtidadeLeiturasSetorComercial;
							Integer idLocalidade;
							Integer codigoSetorComercial;
							Collection<String> codigoSetoresComerciaisAnormalidade = new ArrayList<String>();
							BigDecimal percentual = null;
							BigDecimal qtidadeAceitavelAnormalidadesSetorComercial = null;
							for(Object[] array : anormalidadesSetorComercial){
								qtidadeAnormalidadesSetorComercial = ((Number) array[0]).intValue();
								qtidadeLeiturasSetorComercial = ((Number) array[3]).intValue();
								idLocalidade = (Integer) array[1];
								codigoSetorComercial = (Integer) array[2];
								percentual = sistemaParametro.getPercentualAnormalidadeAceitavel().divide(new BigDecimal(100));
								qtidadeAceitavelAnormalidadesSetorComercial = new BigDecimal(qtidadeLeiturasSetorComercial)
												.multiply(percentual);
								if(qtidadeAnormalidadesSetorComercial > qtidadeAceitavelAnormalidadesSetorComercial.doubleValue()){
									indicadorExcessoAnormalidadeSetorComercial = true;
									codigoSetoresComerciaisAnormalidade.add(codigoSetorComercial.toString());
									movimentosRoteiroEmpresa.addAll(repositorioMicromedicao
													.recuperarAnormalidadesGrupoFaturamentoSetorComercial(idFaturamentoGrupo, idLocalidade,
																	codigoSetorComercial));
								}
							}
							if(indicadorExcessoAnormalidadeSetorComercial){
								retorno.put(new ControladorException("atencao.quantidade_anormalidades_superior_aceitavel_setor_comercial",
												null, montarParametrosMensagemErro(codigoSetoresComerciaisAnormalidade)),
												movimentosRoteiroEmpresa);
							}
						}
						break;
					case 3:
						Collection<Object[]> anormalidadesRota = repositorioMicromedicao
										.quantidadeAnormalidadesGrupoFaturamentoPorRota(idFaturamentoGrupo);
						if(anormalidadesRota != null){
							boolean indicadorExcessoAnormalidadeRota = false;
							Integer qtidadeAnormalidadesRota;
							Integer qtidadeLeiturasRota;
							Integer idRota;
							Collection<String> codigoRotasAnormalidade = new ArrayList<String>();
							BigDecimal percentual = null;
							BigDecimal qtidadeAceitavelAnormalidadesRota = null;
							for(Object[] array : anormalidadesRota){
								qtidadeAnormalidadesRota = ((Number) array[0]).intValue();
								qtidadeLeiturasRota = ((Number) array[2]).intValue();
								idRota = (Integer) array[1];
								percentual = sistemaParametro.getPercentualAnormalidadeAceitavel().divide(new BigDecimal(100));
								qtidadeAceitavelAnormalidadesRota = new BigDecimal(qtidadeLeiturasRota).multiply(percentual);
								if(qtidadeAnormalidadesRota > qtidadeAceitavelAnormalidadesRota.doubleValue()){
									indicadorExcessoAnormalidadeRota = true;
									codigoRotasAnormalidade.add(idRota.toString());
									movimentosRoteiroEmpresa.addAll(repositorioMicromedicao.recuperarAnormalidadesGrupoFaturamentoRota(
													idFaturamentoGrupo, idRota));
								}
							}
							if(indicadorExcessoAnormalidadeRota){
								retorno.put(new ControladorException("atencao.quantidade_anormalidades_superior_aceitavel_rota", null,
												montarParametrosMensagemErro(codigoRotasAnormalidade)), movimentosRoteiroEmpresa);
							}
						}
						break;
				}
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

		}
		return retorno;
	}

	private String montarParametrosMensagemErro(Collection<String> collection){

		StringBuffer mensagemErro = new StringBuffer();
		for(Iterator<String> iterator = collection.iterator(); iterator.hasNext();){
			mensagemErro.append(iterator.next());
			if(iterator.hasNext()){
				mensagemErro.append(" ,");
			}
		}
		return mensagemErro.toString();
	}

	public ExecutorParametro getExecutorParametro(){

		return ExecutorParametrosMicromedicao.getInstancia();
	}

	/**
	 * [UC3010 – Verificar Atendimento do Critério de Faturamento pelo Imóvel]
	 * verifica se o imóvel satisfaz um dos critérios definidos para a atividade de faturamento e o
	 * tipo de leitura da rota à qual o imóvel pertence.
	 * 
	 * @author Anderson Italo
	 * @date 15/08/2011
	 * @param imovel
	 * @param colecaoFaturamentoAtividadeCriterio
	 * @throws ControladorException
	 */
	public short verificarAtendimentoCriterioFaturamentoImovel(Imovel imovel,
					Collection<FaturamentoAtividadeCriterio> colecaoFaturamentoAtividadeCriterio) throws ControladorException{

		short indicadorAtendimentoCriterioImovel = ConstantesSistema.NAO;

		try{

			// [UC0409 Obter Indicador de existência de hidrômetro na Ligação
			// de Água e poço
			ObterIndicadorExistenciaHidrometroHelper indicadorHidrometroAguaPoco = this.getControladorRegistroAtendimento()
							.obterIndicadorExistenciaHidrometroLigacaoAguaPoco(imovel.getId(), false);
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			Short hidrometroLigacaoAguaImovel = indicadorHidrometroAguaPoco.getIndicadorLigacaoAgua();
			Short hidrometroLigacaoPocoImovel = indicadorHidrometroAguaPoco.getIndicadorPoco();

			Short indicadorLeituraFiscalizacaoCortado = null;

			Short indicadorLeituraFiscalizacaoSuprimido = null;

			if(imovel.getRota() != null && imovel.getRota().getIndicadorFiscalizarCortado() != null){
				indicadorLeituraFiscalizacaoCortado = imovel.getRota().getIndicadorFiscalizarCortado();
			}

			if(imovel.getRota() != null && imovel.getRota().getIndicadorFiscalizarSuprimido() != null){
				indicadorLeituraFiscalizacaoSuprimido = imovel.getRota().getIndicadorFiscalizarSuprimido();
			}

			Integer consumoMedidoReferenciaCortado = Util
							.obterInteger(ParametroMicromedicao.P_CONSUMO_MEDIDO_REFERENCIA_CORTADO.executar());
			Date dataLeituraReferenciaCortado = null;
			Integer numeroDiasCortadoSemConsumo = Util.obterInteger(ParametroMicromedicao.P_NUMERO_DIAS_CORTADO_SEM_CONSUMO.executar());
			Date dataCorrenteMenosNumeroDiasCortado = Util.subtrairNumeroDiasDeUmaData(new Date(), numeroDiasCortadoSemConsumo);

			/*
			 * Caso a situação de ligação de água do imóvel seja correspondente a "Cortado" e o
			 * imóvel não tenha atendido o critério de seleção por débito a cobrar, ou seja, ele
			 * não tenha débitos a serem lançados em conta
			 */
			if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO) && imovel.getLigacaoAgua() != null){

				// [FS0002] - Determinar Data de Referencia para Corte
				dataLeituraReferenciaCortado = repositorioMicromedicao.obterDataUltimaLeituraReferenciaCortado(ConsumoTipo.REAL,
								LigacaoTipo.LIGACAO_AGUA, MedicaoTipo.LIGACAO_AGUA, imovel.getId(), consumoMedidoReferenciaCortado);

				if(dataLeituraReferenciaCortado != null){

					if(imovel.getLigacaoAgua().getDataCorte() != null
									&& imovel.getLigacaoAgua().getDataCorte().compareTo(dataLeituraReferenciaCortado) == 1){

						dataLeituraReferenciaCortado = imovel.getLigacaoAgua().getDataCorte();
					}
				}else if(imovel.getLigacaoAgua().getDataCorte() != null){

					dataLeituraReferenciaCortado = imovel.getLigacaoAgua().getDataCorte();
				}else{

					dataLeituraReferenciaCortado = new Date();
				}
			}

			Integer numeroDiasEntreLigacaoNovaEDataCorrente = null;
			Date dataLeituraAnterior = null;
			Integer numeroDiasEntreCorteELeituraAnterior = null;
			Date dataCorrenteMaisNumeroDiasFaturarReligacao = null;
			Integer qtdDiasEntreDatasReligacaoECorrente = null;

			if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO) && imovel.getLigacaoAgua() != null){

				if(imovel.getLigacaoAgua().getDataLigacao() != null){

					numeroDiasEntreLigacaoNovaEDataCorrente = Util.obterQuantidadeDiasEntreDuasDatas(imovel.getLigacaoAgua()
									.getDataLigacao(),
								new Date());
				}

				// Obtém Histórico de Medição Anterior
				Object[] dadosUltimoMedicaoHistorico = repositorioMicromedicao.obterMedicaoHistoricoAnterior(imovel.getId(), imovel
								.getRota().getFaturamentoGrupo().getAnoMesReferencia(), MedicaoTipo.LIGACAO_AGUA);

				if(!Util.isVazioOrNulo(dadosUltimoMedicaoHistorico) && imovel.getLigacaoAgua().getDataReligacao() != null){

					dataLeituraAnterior = (Date) dadosUltimoMedicaoHistorico[0];

					if(dataLeituraAnterior != null && imovel.getLigacaoAgua().getDataReligacao() != null
									&& imovel.getLigacaoAgua().getDataCorte() != null){
						
						// Verificar se o corte ocorreu entre a data de leitura anterior e a data
						// corrente
						if(imovel.getLigacaoAgua().getDataReligacao().compareTo(dataLeituraAnterior) == 1
										&& imovel.getLigacaoAgua().getDataCorte().compareTo(dataLeituraAnterior) == 1){

							numeroDiasEntreCorteELeituraAnterior = Util.obterQuantidadeDiasEntreDuasDatas(dataLeituraAnterior, imovel
											.getLigacaoAgua().getDataCorte());

							dataCorrenteMaisNumeroDiasFaturarReligacao = Util.adicionarNumeroDiasDeUmaData(new Date(),
											numeroDiasEntreCorteELeituraAnterior);

							qtdDiasEntreDatasReligacaoECorrente = Util.obterQuantidadeDiasEntreDuasDatas(imovel.getLigacaoAgua()
											.getDataReligacao(), dataCorrenteMaisNumeroDiasFaturarReligacao);
						}
					}
				}
			}

			Integer numeroDiasFaturarLigacaoNova = Util.obterInteger(ParametroMicromedicao.P_NUMERO_DIAS_PARA_FATURAR_LIGACAO_NOVA
							.executar());
			Integer numeroDiasFaturarReligacao = Util.obterInteger(ParametroMicromedicao.P_NUMERO_DIAS_PARA_FATURAR_RELIGADO.executar());

			boolean encontrouLigacaoAguaSituacao;
			boolean encontrouLigacaoEsgotoSituacao;
			boolean encontrouIndicadorSituacaoLigacaoAguaFaturavel;
			boolean encontrouIndicadorSituacaoLigacaoEsgotoFaturavel;
			boolean encontrouIndicadorHidrometroLigacaoAgua;
			boolean encontrouIndicadorHidrometroLigacaoPoco;
			boolean encontrouIndicadorLeituraFiscalizacaoCortado;
			boolean encontrouIndicadorLeituraFiscalizacaoSuprimido;
			boolean encontrouLeituraTipo;
			boolean encontrouIndicadorDebitoACobrar;
			boolean encontrouIndicadorDebitoACobrarParcelamento;
			boolean encontrouImovelCortadoFaturavel;
			boolean imovelSemDebitosASeremLancadosEmConta;
			boolean encontrouImovelLigacaoNovaOuReligadoFaturavel;

			for(FaturamentoAtividadeCriterio faturamentoAtividadeCriterio : colecaoFaturamentoAtividadeCriterio){

				encontrouLigacaoAguaSituacao = true;
				encontrouLigacaoEsgotoSituacao = true;
				encontrouIndicadorSituacaoLigacaoAguaFaturavel = true;
				encontrouIndicadorSituacaoLigacaoEsgotoFaturavel = true;
				encontrouIndicadorHidrometroLigacaoAgua = true;
				encontrouIndicadorHidrometroLigacaoPoco = true;
				encontrouIndicadorLeituraFiscalizacaoCortado = true;
				encontrouIndicadorLeituraFiscalizacaoSuprimido = true;
				encontrouLeituraTipo = true;
				encontrouIndicadorDebitoACobrar = true;
				encontrouIndicadorDebitoACobrarParcelamento = true;
				encontrouImovelCortadoFaturavel = true;
				imovelSemDebitosASeremLancadosEmConta = true;
				encontrouImovelLigacaoNovaOuReligadoFaturavel = true;

				/*
				 * O sistema verifica se o imóvel atende a todas as condições do critério de acordo
				 * com
				 * as regras
				 */
				if(faturamentoAtividadeCriterio.getLigacaoAguaSituacao() != null){

					if(faturamentoAtividadeCriterio.getLigacaoAguaSituacao().getId().intValue() == imovel.getLigacaoAguaSituacao().getId()
									.intValue()){

						encontrouLigacaoAguaSituacao = true;
					}else{

						encontrouLigacaoAguaSituacao = false;
					}
				}

				if(faturamentoAtividadeCriterio.getIndicadorSituacaoLigacaoAguaFaturavel() != null){

					if(faturamentoAtividadeCriterio.getIndicadorSituacaoLigacaoAguaFaturavel().shortValue() == imovel
									.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().shortValue()){

						encontrouIndicadorSituacaoLigacaoAguaFaturavel = true;
					}else{

						encontrouIndicadorSituacaoLigacaoAguaFaturavel = false;
					}
				}

				if(faturamentoAtividadeCriterio.getLigacaoEsgotoSituacao() != null){

					if(faturamentoAtividadeCriterio.getLigacaoEsgotoSituacao().getId().intValue() == imovel.getLigacaoEsgotoSituacao()
									.getId().intValue()){

						encontrouLigacaoEsgotoSituacao = true;
					}else{

						encontrouLigacaoEsgotoSituacao = false;
					}
				}

				if(faturamentoAtividadeCriterio.getIndicadorSituacaoLigacaoEsgotoFaturavel() != null){

					if(faturamentoAtividadeCriterio.getIndicadorSituacaoLigacaoEsgotoFaturavel().shortValue() == imovel
									.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao().shortValue()){

						encontrouIndicadorSituacaoLigacaoEsgotoFaturavel = true;
					}else{

						encontrouIndicadorSituacaoLigacaoEsgotoFaturavel = false;
					}
				}

				if(faturamentoAtividadeCriterio.getIndicadorHidrometroLigacaoAgua() != null){
					if(hidrometroLigacaoAguaImovel != null
									&& faturamentoAtividadeCriterio.getIndicadorHidrometroLigacaoAgua().shortValue() == hidrometroLigacaoAguaImovel
													.shortValue()){

						encontrouIndicadorHidrometroLigacaoAgua = true;
					}else{

						encontrouIndicadorHidrometroLigacaoAgua = false;
					}
				}

				if(faturamentoAtividadeCriterio.getIndicadorHidrometroLigacaoPoco() != null){

					if(hidrometroLigacaoPocoImovel != null
									&& faturamentoAtividadeCriterio.getIndicadorHidrometroLigacaoPoco().shortValue() == hidrometroLigacaoPocoImovel
													.shortValue()){

						encontrouIndicadorHidrometroLigacaoPoco = true;
					}else{

						encontrouIndicadorHidrometroLigacaoPoco = false;
					}
				}

				if(faturamentoAtividadeCriterio.getIndicadorLeituraFiscalizacaoCortado() != null){

					if(indicadorLeituraFiscalizacaoCortado != null
									&& faturamentoAtividadeCriterio.getIndicadorLeituraFiscalizacaoCortado().shortValue() == indicadorLeituraFiscalizacaoCortado
													.shortValue()){

						encontrouIndicadorLeituraFiscalizacaoCortado = true;
					}else{

						encontrouIndicadorLeituraFiscalizacaoCortado = false;
					}
				}

				if(faturamentoAtividadeCriterio.getIndicadorLeituraFiscalizacaoSuprimido() != null){

					if(indicadorLeituraFiscalizacaoSuprimido != null
									&& faturamentoAtividadeCriterio.getIndicadorLeituraFiscalizacaoSuprimido().shortValue() == indicadorLeituraFiscalizacaoSuprimido
													.shortValue()){

						encontrouIndicadorLeituraFiscalizacaoSuprimido = true;
					}else{

						encontrouIndicadorLeituraFiscalizacaoSuprimido = false;
					}

				}

				if(faturamentoAtividadeCriterio.getLeituraTipo() != null && imovel.getRota() != null){

					if(faturamentoAtividadeCriterio.getLeituraTipo().getId().intValue() == imovel.getRota().getLeituraTipo().getId()
									.intValue()){

						encontrouLeituraTipo = true;
					}else{

						encontrouLeituraTipo = false;
					}
				}

				if(faturamentoAtividadeCriterio.getIndicadorDebitoACobrar() != null){

					if(this.verificarImovelComDebitosACobrarFaturaveis(imovel,
									imovel.getRota().getFaturamentoGrupo().getAnoMesReferencia(), sistemaParametro, false)){

						encontrouIndicadorDebitoACobrar = true;
						imovelSemDebitosASeremLancadosEmConta = false;
					}else{

						encontrouIndicadorDebitoACobrar = false;
					}
				}

				if(faturamentoAtividadeCriterio.getIndicadorDebitoACobrarParcelamento() != null){

					if(this.verificarImovelComDebitosACobrarFaturaveis(imovel,
									imovel.getRota().getFaturamentoGrupo().getAnoMesReferencia(), sistemaParametro, true)){

						encontrouIndicadorDebitoACobrarParcelamento = true;
						imovelSemDebitosASeremLancadosEmConta = false;
					}else{

						encontrouIndicadorDebitoACobrarParcelamento = false;
					}
				}

				/*
				 * Caso a situação de ligação de água do imóvel seja correspondente a "Cortado" e a
				 * situação de ligação de esgoto não seja "Ligado" e o imóvel não tenha atendido o
				 * critério de seleção por débito a cobrar, ou seja, ele não tenha débitos a serem
				 * lançados em conta
				 */
				if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO)
								&& !imovel.getLigacaoEsgotoSituacao().getId().equals(LigacaoEsgotoSituacao.LIGADO)
								&& imovelSemDebitosASeremLancadosEmConta && dataLeituraReferenciaCortado != null){

					/*
					 * Verificar se a maior data entre a data de corte e a data da ultima
					 * leitura com consumo do imóvel é maior que a data correspondente a data
					 * corrente menos um número de dias de cortado
					 */
					if(dataLeituraReferenciaCortado.compareTo(dataCorrenteMenosNumeroDiasCortado) == 1){

						encontrouImovelCortadoFaturavel = true;
					}else{

						encontrouImovelCortadoFaturavel = false;
					}
				}

				/*
				 * Caso a situação de ligação de água do imóvel seja correspondente a "Ligado" e o
				 * imóvel não tenha atendido o critério de seleção por débito a cobrar, ou seja, ele
				 * não tenha débitos a serem lançados em conta
				 */
				if(imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO) && imovelSemDebitosASeremLancadosEmConta
								&& (numeroDiasEntreLigacaoNovaEDataCorrente != null || qtdDiasEntreDatasReligacaoECorrente != null)){

					// Caso seja ligação nova ou religação só envia para leitura se tiver mais de 15
					// dias de consumo
					// Obs: Esta regra só é válida caso os parâmetros
					// P_NUMERO_DIAS_PARA_FATURAR_LIGACAO_NOVA e P_NUMERO_DIAS_PARA_FATURAR_RELIGADO
					// estejam preenchidos, ou seja, se seus valores forem maior que 0. Caso
					// contrário, considera o imóvel para o faturamento
					if(numeroDiasFaturarLigacaoNova > 0 && numeroDiasEntreLigacaoNovaEDataCorrente != null
									&& numeroDiasEntreLigacaoNovaEDataCorrente.intValue() <= numeroDiasFaturarLigacaoNova){

						encontrouImovelLigacaoNovaOuReligadoFaturavel = false;
					}else if(numeroDiasFaturarReligacao > 0 && qtdDiasEntreDatasReligacaoECorrente != null
									&& qtdDiasEntreDatasReligacaoECorrente.intValue() <= numeroDiasFaturarReligacao){

						encontrouImovelLigacaoNovaOuReligadoFaturavel = false;
					}else{

						encontrouImovelLigacaoNovaOuReligadoFaturavel = true;
					}
				}

				// Caso o imóvel satisfaça todas as condições do critério
				if(encontrouLigacaoAguaSituacao && encontrouLigacaoEsgotoSituacao && encontrouIndicadorHidrometroLigacaoAgua
								&& encontrouIndicadorHidrometroLigacaoPoco && encontrouIndicadorLeituraFiscalizacaoCortado
								&& encontrouIndicadorLeituraFiscalizacaoSuprimido && encontrouIndicadorSituacaoLigacaoAguaFaturavel
								&& encontrouIndicadorSituacaoLigacaoEsgotoFaturavel && encontrouLeituraTipo
								&& encontrouIndicadorDebitoACobrar && encontrouIndicadorDebitoACobrarParcelamento
								&& encontrouImovelCortadoFaturavel && encontrouImovelLigacaoNovaOuReligadoFaturavel){

					// O sistema atribui o valor 1 (um) ao Indicador Atendimento dos Critérios pelo
					// Imóvel
					indicadorAtendimentoCriterioImovel = ConstantesSistema.SIM;
					break;
				}

			}

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return indicadorAtendimentoCriterioImovel;
	}

	public Collection<FaturamentoAtividadeCriterio> pesquisarFaturamentoAtividadeCriterioPorLeituraTipo(Integer idFaturamentoAtividade,
					Collection collLeituraTipo) throws ControladorException{

		Collection retorno = null;

		try{
			retorno = repositorioMicromedicao.pesquisarFaturamentoAtividadeCriterioPorLeituraTipo(idFaturamentoAtividade, collLeituraTipo);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaHidrometroInstalacaoHistoricoTipoAgua(Integer idImovel) throws ControladorException{

		Integer retorno = null;

		try{
			retorno = repositorioMicromedicao.verificarExistenciaHidrometroInstalacaoHistoricoTipoAgua(idImovel);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaHidrometroInstalacaoHistoricoTipoPoco(Integer idImovel) throws ControladorException{

		Integer retorno = null;

		try{
			retorno = repositorioMicromedicao.verificarExistenciaHidrometroInstalacaoHistoricoTipoPoco(idImovel);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;
	}

	/**
	 * Método que gera o resumo das ligações e economias
	 * [UC0275] - Gerar Resumo das Ligações/Economias
	 * 
	 * @author Thiago Toscano, Bruno Barros
	 * @date 19/04/2006 17/04/2007
	 * @author Ailton Sousa
	 * @date 10/08/2011 Mudou o parâmetro recebido, antes era o Id do Setor Comercial. Mudou a forma
	 *       como é inserida/atualizada a entidade ResumoLigacoesEconomias. Antes era uma colecao,
	 *       agora é individulamente por imóvel.
	 */
	public void gerarResumoLigacoesEconomias(int imovelId, Integer referenciaFaturamento, Integer idRota, boolean batchEventual)
					throws ControladorException{

		Integer anoMesFaturamento = null;
		if(Util.isVazioOuBranco(referenciaFaturamento)){
			anoMesFaturamento = getControladorUtil().pesquisarParametrosDoSistema().getAnoMesFaturamento();
		}else{
			anoMesFaturamento = referenciaFaturamento;
		}

		try{

			List imoveisResumoLigacaoEconomias = this.repositorioMicromedicao.getImoveisResumoLigacaoEconomias(imovelId, idRota);

			Imovel imovelObterQtdEconomia = null;

			// Integer idResumoLigacaoEconomia = null;

			// pra cada objeto obter a categoria
			// caso ja tenha um igual soma a quantidade de economias e a
			// quantidade de ligacoes
			// for(int i = 0; i < imoveisResumoLigacaoEconomias.size(); i++){
			if(!Util.isVazioOrNulo(imoveisResumoLigacaoEconomias)){

				for(Object obj : imoveisResumoLigacaoEconomias){

					// Object obj = imoveisResumoLigacaoEconomias.get(0);

					if(obj instanceof Object[]){
						Object[] retorno = (Object[]) obj;

						// Pesquisamos as quantidades de economia do imovel corrente
						imovelObterQtdEconomia = new Imovel();
						imovelObterQtdEconomia.setId((Integer) retorno[0]);
						Integer quantidadeEconomia = this.getControladorImovel().obterQuantidadeEconomias(imovelObterQtdEconomia);
						if(quantidadeEconomia == null){
							quantidadeEconomia = 0;
						}

						// Montamos um objeto de resumo, com as informacoes do retorno
						ResumoLigacaoEconomiaHelper helper = new ResumoLigacaoEconomiaHelper((Integer) retorno[1], // Gerencia
										// Regional
										(Integer) retorno[2], // Unidade de negocio
										(Integer) retorno[3], // Localidade
										(Integer) retorno[4], // Elo
										(Integer) retorno[5], // Id Setor Comercial
										(Integer) retorno[6], // id Rota
										(Integer) retorno[7], // Id Quadra
										(Integer) retorno[8], // Codigo do Setor Comercial
										(Integer) retorno[9], // Numero da quadra
										(Integer) retorno[10], // Perfil do imovel
										(Integer) retorno[11], // Situacao da ligacao da agua
										(Integer) retorno[12], // Situacao da ligacao do esgoto
										(Integer) retorno[13], // Perfil da ligacao de agua
										(Integer) retorno[14], // Perfil da ligacao de esgoto
										(Integer) retorno[15], // Possue hidrometro instalado ?
										(Integer) retorno[16], // Possue hidrometro instalado no
																// poco ?
										(Integer) retorno[17], // Possue volume minimo de agua
																// fixado ?
										(Integer) retorno[18], // Possue volume minimo de esgoto
																// fixado?
										(Integer) retorno[19], // Possue poco
										(Integer) retorno[22]); // Tipo de Tarifa de Consumo

						Integer idImovel = (Integer) retorno[0]; // Codigo do imovel que esta sendo
						// processado

						// Pesquisamos a esfera de poder do cliente responsavel
						helper.setIdEsfera(this.repositorioGerencialCadastro.pesquisarEsferaPoderClienteResponsavelImovel(idImovel));
						// Pesquisamos o tipo de cliente responsavel do imovel
						helper.setIdTipoClienteResponsavel(this.repositorioGerencialCadastro
										.pesquisarTipoClienteClienteResponsavelImovel(idImovel));

						// pesquisando a categoria
						// [UC0306] - Obtter principal categoria do imóvel

						Categoria categoriaAux = null;
						categoriaAux = this.getControladorImovel().obterPrincipalCategoriaImovel(idImovel);
						if(categoriaAux != null){
							helper.setIdCategoria(categoriaAux.getId());

							// Pesquisando a principal subcategoria
							ImovelSubcategoria subcategoria = this.getControladorImovel().obterPrincipalSubcategoria(categoriaAux.getId(),
											idImovel);

							if(subcategoria != null){
								helper.setIdSubCategoria(subcategoria.getComp_id().getSubcategoria().getId());
							}
						}

						// Verificamos se a esfera de poder foi encontrada
						// [FS0002] Verificar existencia de cliente responsavel
						if(helper.getIdEsfera().equals(0)){
							Imovel imovel = new Imovel();
							imovel.setId(idImovel);
							Cliente clienteTemp = this.getControladorImovel().consultarClienteUsuarioImovel(imovel);

							if(clienteTemp != null && clienteTemp.getClienteTipo().getEsferaPoder() != null){

								helper.setIdEsfera(clienteTemp.getClienteTipo().getEsferaPoder().getId());
							}
						}
						if(helper.getIdTipoClienteResponsavel().equals(0)){
							Imovel imovel = new Imovel();
							imovel.setId(idImovel);
							Cliente clienteTemp = this.getControladorImovel().consultarClienteUsuarioImovel(imovel);
							if(clienteTemp != null){
								helper.setIdTipoClienteResponsavel(clienteTemp.getClienteTipo().getId());
							}
						}

						// Verifica seu a rotina veio do batch gerarResumoLigacoesEconomiasEventual,
						// se não, veio do faturamento, executa normalmente.
						if(batchEventual){
							// Verificar se existe alterações anteriores.
							// Essa rotina só irá executar se for o batch que irá gerar os resumos
							// antigos.
							boolean gerar = this.verificarLigacoesAnterioes(helper, idImovel, referenciaFaturamento);
							if(gerar){
								this.inserirAtualizarResumoLigacoesEconomias(anoMesFaturamento, quantidadeEconomia, helper, idImovel);
							}
						}else{
							this.inserirAtualizarResumoLigacoesEconomias(anoMesFaturamento, quantidadeEconomia, helper, idImovel);
						}

					}
				}
			}

		}catch(Exception e){
			e.printStackTrace();

			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * 
	 * @author Ailton Sousa
	 * @date 18/08/2011
	 * @param colecaoRotas
	 * @param anoMesFaturamento
	 * @param idGrupoFaturamento
	 * @throws ControladorException
	 */
	public void gerarArquivoTextoFaturamentoImediato(Collection colecaoRotas, Integer anoMesFaturamento, Integer idFaturamentoGrupo,
					Integer idFuncionalidadeIniciada) throws ControladorException{

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		int idUnidadeIniciada = 0;

		if(colecaoRotas != null && !colecaoRotas.isEmpty()){
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
							((Rota) Util.retonarObjetoDeColecao(colecaoRotas)).getId());

			try{

				List rotasOrdenadas = new ArrayList(colecaoRotas);
				Iterator itRotas = null;

				Integer idEmpresaAtual = null;
				Integer idEmpresaAnterior = null;
				Integer idRotaAtual = null;
				Integer idRotaAnterior = null;
				String idsRotas = "";

				Rota rota = null;

				// Ordena a lista de Rotas por Empresa
				Collections.sort(rotasOrdenadas, new Comparator() {

					public int compare(Object o1, Object o2){

						Rota r1 = (Rota) o1;
						Rota r2 = (Rota) o2;
						return r1.getEmpresa().getId() < r2.getEmpresa().getId() ? -1
										: (r1.getEmpresa().getId() > r2.getEmpresa().getId() ? +1 : 0);
					}
				});

				itRotas = rotasOrdenadas.iterator();

				while(itRotas.hasNext()){
					rota = (Rota) itRotas.next();
					idEmpresaAtual = rota.getEmpresa().getId();
					idRotaAtual = rota.getId();

					if(idEmpresaAnterior == null){
						idEmpresaAnterior = idEmpresaAtual;
					}

					if(idRotaAnterior == null){
						idRotaAnterior = idRotaAtual;
						idsRotas = idRotaAtual.toString();
					}else if(!idRotaAtual.equals(idRotaAnterior) && idEmpresaAtual.equals(idEmpresaAnterior)){
						idRotaAnterior = idRotaAtual;
						idsRotas = idsRotas + ", " + idRotaAtual.toString();
					}else if(!idRotaAtual.equals(idRotaAnterior) && !idEmpresaAtual.equals(idEmpresaAnterior)){
						idRotaAnterior = idRotaAtual;
					}

					if(!idEmpresaAtual.equals(idEmpresaAnterior) || !itRotas.hasNext()){

						Collection colecaoMovimentoRoteiroEmpresa = new ArrayList();

						try{
							for(String idsRotasComLimite : Util.retornaListaStringComLimiteItemConsulta(idsRotas)){
								colecaoMovimentoRoteiroEmpresa.addAll(repositorioMicromedicao
												.pesquisarMovimentoRoteiroEmpresaPorColecaoRotas(idsRotasComLimite, anoMesFaturamento,
																idFaturamentoGrupo, idEmpresaAnterior));
							}

						}catch(ErroRepositorioException ex){
							ex.printStackTrace();
							throw new ControladorException("erro.sistema", ex);
						}
						// [FS0001 - Verificar existência de movimento para as rotas]
						if(colecaoMovimentoRoteiroEmpresa != null && !colecaoMovimentoRoteiroEmpresa.isEmpty()){

							/*
							 * O sistema gera o arquivo texto do faturamento imediato de acordo com
							 * o
							 * modelo utilizado
							 */
							ParametroMicromedicao.P_GERACAO_ARQUIVO_FATURAMENTO_IMEDIATO_ENVIO.executar(this, -1, idFuncionalidadeIniciada,
											anoMesFaturamento, idFaturamentoGrupo, idFuncionalidadeIniciada, idEmpresaAnterior, idsRotas,
											colecaoMovimentoRoteiroEmpresa);
						}

						// Inicializa novamente a String com o valor inicial da primeira rota da
						// nova
						// empresa.
						idsRotas = idRotaAtual.toString();
						idEmpresaAnterior = idEmpresaAtual;
					}
				}

				// --------------------------------------------------------
				//
				// Registrar o fim da execução da Unidade de Processamento
				//
				// --------------------------------------------------------
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

			}catch(Exception e){

				sessionContext.setRollbackOnly();
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
				throw new EJBException(e);
			}

		}else{
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
							0);
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
		}

	}

	public Collection pesquisarConsumoMedidoHidrometroPeriodoInformadoLigacaoAgua(Imovel imovel, int anoMesReferencia,
					int periodoInformado, LigacaoTipo ligacaoTipo) throws ControladorException{

		Collection retorno = null;
		try{
			retorno = repositorioMicromedicao.pesquisarConsumoMedidoHidrometroPeriodoInformadoLigacaoAgua(imovel, anoMesReferencia,
							periodoInformado, ligacaoTipo);

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	public Collection pesquisarConsumoMedidoHidrometroPeriodoInformadoPoco(Imovel imovel, int anoMesReferencia, int periodoInformado)
					throws ControladorException{

		Collection retorno = null;
		try{
			retorno = repositorioMicromedicao.pesquisarConsumoMedidoHidrometroPeriodoInformadoPoco(imovel, anoMesReferencia,
							periodoInformado);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * @param imovel
	 *            [obrigatorio]
	 * @param anoMesReferencia
	 *            [obrigatorio]
	 * @return
	 * @throws ErroRepositorioException
	 *             NullPointer se Imovel ou AnoMesReferencia nulos
	 */
	public MovimentoRoteiroEmpresa obterMovimentoRoteiroPorImovel(Imovel imovel, Integer anoMesReferencia) throws ControladorException{

		MovimentoRoteiroEmpresa retorno = null;
		try{
			retorno = repositorioMicromedicao.obterMovimentoRoteiroPorImovel(imovel, anoMesReferencia);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * Consulta que retorna a quantidade de Movimento Roteiro Empresa por FaturamentoGrupo e
	 * AnoMesReferencia.
	 * 
	 * @author Ailton Sousa
	 * @date 29/08/2011
	 * @param idFaturamentoGrupo
	 * @param anoMesReferencia
	 * @return
	 * @throws ControladorException
	 */
	public Integer obterQuantidadeMovimentoRoteiroPorGrupoAnoMes(Integer idFaturamentoGrupo, Integer anoMesReferencia)
					throws ControladorException{

		Integer retorno = null;
		try{
			retorno = repositorioMicromedicao.obterQuantidadeMovimentoRoteiroPorGrupoAnoMes(idFaturamentoGrupo, anoMesReferencia);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * [UC0948] Informar Dados de Leituras e Anormalidades
	 * [FS0017 – Validar data de leitura]
	 * 
	 * @param dataLeituraString
	 * @param erros
	 * @param anoMesReferencia
	 * @return
	 */
	private Date validarDataLeitura(String dataLeituraString, StringBuilder erros, Integer anoMesReferencia){

		Date dataLeitura = null;
		SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");

		try{
			if(Util.validarDiaMesAnoSemBarra(dataLeituraString)){
				erros.append("Data de leitura ");
				erros.append(dataLeituraString);
				erros.append(" inválida. \n");
			}
			dataLeitura = sdf.parse(dataLeituraString);
			if(dataLeitura.after(new Date())){
				erros.append("Data de leitura ");
				erros.append(dataLeituraString);
				erros.append(" inválida. \n");
			}

			Integer anoMesReferenciaAnterior = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesReferencia, 1);
			Integer anoMesReferenciaPosterior = Util.somaUmMesAnoMesReferencia(anoMesReferencia);

			if((anoMesReferencia.intValue() != Util.getAnoMesComoInt(dataLeitura))
							&& (anoMesReferenciaAnterior.intValue() != Util.getAnoMesComoInteger(dataLeitura))
							&& (anoMesReferenciaPosterior.intValue() != Util.getAnoMesComoInteger(dataLeitura))){
				erros.append("Data de leitura ");
				erros.append(dataLeituraString);
				erros.append(" incompatível com o mês/ano de faturamento. \n");
			}

		}catch(ParseException e){
			erros.append("Data de leitura ");
			erros.append(dataLeituraString);
			erros.append(" inválida. \n");
		}

		return dataLeitura;
	}

	/**
	 * [UC0948] Informar Dados de Leituras e Anormalidades
	 * [FS0017 – Validar data de leitura]
	 * 
	 * @param dataLeituraString
	 * @param erros
	 * @param anoMesReferencia
	 * @return
	 */
	private StringBuilder validarDataVencimento(String dataVencimento, StringBuilder erros){

		// Date data = null;
		// SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");

		if(Util.validarDiaMesAnoSemBarra(dataVencimento)){
			erros.append("Data de Vencimento ");
			erros.append(dataVencimento);
			erros.append(" inválida. \n");
		}
		// data = sdf.parse(dataVencimento);
		// if(data.after(new Date())){
		// erros.append("Data de Vencimento ");
		// erros.append(dataVencimento);
		// erros.append(" inválida. \n");
		// }

		return erros;
	}

	/**
	 * Processa o arquivo de leitura
	 * 
	 * @author Péricles Tavares
	 * @date 11/08/2011
	 * @param idFaturamentoGrupo
	 * @param arquivoLeitura
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void processarArquivoLeituraAnormalidades(Integer idFaturamentoGrupo, File arquivoLeitura, Usuario usuarioLogado,
					Integer idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		try{

			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
							UnidadeProcessamento.FUNCIONALIDADE, Funcionalidade.INFORMAR_DADOS_LEITURA_E_ANORMALIDADE);

			FaturamentoGrupo faturamentoGrupo = (FaturamentoGrupo) getControladorUtil().pesquisar(idFaturamentoGrupo,
							FaturamentoGrupo.class, false);
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			File arquivoDefinitivo = arquivoLeitura;

			// 2. Caso o arquivo de leitura da empresa não esteja no formato padrão
			// (PARM_ICLAYOUTARQLEITURAPADRAO com o valor 2 (dois) na tabela SISTEMA_PARAMETROS),
			// converter o arquivo da empresa para o formato padrão do sistema
			// [SB0005 – Converter Arquivo Leitura para Formato Padrão].

			if(ConstantesSistema.NAO.equals(sistemaParametro.getIndicadorLayoutArquivoLeituraPadrao())){
				arquivoDefinitivo = converterLayoutArquivoLeituraEmpresaLayoutArquivoLeituraPadrao(arquivoLeitura, faturamentoGrupo);
			}

			Map<Integer, String> mapaErros = new LinkedHashMap<Integer, String>();
			Map<Integer, String> mapaAdvertencias = new LinkedHashMap<Integer, String>();
			FileReader fileReader = new FileReader(arquivoDefinitivo);
			BufferedReader br = new BufferedReader(fileReader);
			br.readLine();
			String linha = null;
			StringBuilder erros = null;
			StringBuilder advertencias = null;
			String codigoRegistro = null;
			Integer codigoAgenteComercial = null;
			String dataLeituraString = null;
			String matriculaImovel = null;
			String localidade = null;
			String setorComercial = null;
			String quadra = null;
			String lote = null;
			String subLote = null;
			Integer tipoMedicao = null;
			String leituraHidrometro = null;
			String codigoAnormalidadeLeitura = null;
			String indicadorConfirmacaoLeitura = null;
			FiltroLeiturista filtroLeiturista = null;
			String leituraFaturada = null;
			String consumoFaturado = null;
			String codigoAnormalidadeConsumo = null;
			String tipoConsumo = null;
			String diasConsumo = null;
			String valorAgua = null;
			String valorEsgoto = null;
			String valorDebitos = null;
			String valorCreditos = null;
			String indicadorGrandeConsumidor = null;
			String indicadorEmissaoCampo = null;

			String valorImpostoFederal = null;
			String dataVencimentoRetornada = null;
			String dataLeituraFaturada = null;
			String valorRateio = null;
			String indicadorModoFaturamento = null;

			SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");
			Date dataLeitura = null;
			MedicaoTipo medicaoTipo = null;
			LigacaoAgua ligacaoAgua = null;
			Imovel imovel = null;
			Localidade localidadePrimeiroImovel = null;
			Empresa empresaPrimeiroImovel = null;
			LeituraAnormalidade leituraAnormalidade = null;
			FiltroMovimentoRoteiroEmpresa filtroMovimentoRoteiroEmpresa = null;
			MovimentoRoteiroEmpresa movimentoRoteiroEmpresa = null;
			Integer i = 1;
			Integer posicaoAnterior;
			Integer qtidadeCaracteres;
			List<String> listaEmissaoGrupo = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "L", "N");
			List<String> listaEmissaoGrupoVerificacao = Arrays.asList("7", "8", "9");
			FiltroConsumoAnormalidade filtroConsumoAnormalidade = null;
			ConsumoAnormalidade consumoAnormalidade = null;
			FiltroConsumoTipo filtroConsumoTipo = null;
			ConsumoTipo consumoTipo = null;
			ConsumoTipo consumoTipoNaoMedido = null;
			FiltroImovel filtroImovel = null;
			FiltroLigacaoAgua filtroLigacaoAgua = null;

			String consumoMedido = null;
			Integer consumoMedidoInt = null;
			String indicadorReligacaoAgua = null;
			String codigoServicoReligacao = null;
			Integer codigoServicoReligacaoInt = null;
			String valorReligacao = null;
			String codigoServicoSancao = null;
			Integer codigoServicoSancaoInt = null;
			String valorSancao = null;
			String alteracaoNumeroImovel = null;
			String indicadorSuspeitaLigacaoSemHidr = null;
			String indicadorChecarNumHidr = null;
			String indicadorChecarCategEconom = null;
			String indicadorChecarLogradouro = null;
			String indicadorRevisarQuadra = null;
			String indicadorFiscalizarConsumo = null;
			String indicadorNaoMedidoComHidr = null;
			String statusRegistro = null;
			String indicadorFaturaRetida = null;

			Short indicadorReligacaoAguaShort = null;

			StringBuffer arquivoReligacaoAutomaticaConsumidor = null;
			String linhaReligacaoAutomaticaConsumidor = null;

			while((linha = br.readLine()) != null){
				erros = new StringBuilder();
				advertencias = new StringBuilder();
				posicaoAnterior = 0;
				qtidadeCaracteres = 0;

				// adicionando a qtidade de caracteres para a posicaoAnterior.
				codigoRegistro = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
				if("9".equals(codigoRegistro)){
					break;
				}
				codigoAgenteComercial = Util.obterInteger(recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres,
								qtidadeCaracteres = 6));
				dataLeituraString = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 8);
				matriculaImovel = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 8);
				localidade = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 3);
				setorComercial = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 3);
				quadra = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 4);
				lote = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 4);
				subLote = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 3);
				tipoMedicao = Util.obterInteger(recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1));
				leituraHidrometro = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 6);
				leituraFaturada = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 6);
				consumoFaturado = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 6);
				codigoAnormalidadeLeitura = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 3);
				codigoAnormalidadeConsumo = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 3);
				tipoConsumo = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 2);
				diasConsumo = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 2);
				valorAgua = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 11);
				valorEsgoto = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 11);
				valorDebitos = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 11);
				valorCreditos = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 11);
				indicadorGrandeConsumidor = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);

				indicadorEmissaoCampo = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
				indicadorConfirmacaoLeitura = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
				valorImpostoFederal = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 11);
				dataVencimentoRetornada = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 8);
				dataLeituraFaturada = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 8);
				valorRateio = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 11);
				indicadorModoFaturamento = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);

				if(linha.length() > 155){
					consumoMedido = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 6);
					indicadorReligacaoAgua = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
					codigoServicoReligacao = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 3);
					valorReligacao = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 11);
					codigoServicoSancao = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 3);
					valorSancao = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 11);
					alteracaoNumeroImovel = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 5);
					indicadorSuspeitaLigacaoSemHidr = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres,
									qtidadeCaracteres = 1);
					indicadorChecarNumHidr = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
					indicadorChecarCategEconom = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
					indicadorChecarLogradouro = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
					indicadorRevisarQuadra = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
					indicadorFiscalizarConsumo = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
					indicadorNaoMedidoComHidr = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
					statusRegistro = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
					indicadorFaturaRetida = recuperarValorLinha(linha, posicaoAnterior += qtidadeCaracteres, qtidadeCaracteres = 1);
				}

				// [FS0016] – Verificar existência do agente comercial
				// filtroLeiturista = new FiltroLeiturista();
				// filtroLeiturista.adicionarParametro(new ParametroSimples(FiltroLeiturista.ID,
				// codigoAgenteComercial));
				//
				// if(Util.isVazioOrNulo(getControladorUtil().pesquisar(filtroLeiturista,
				// Leiturista.class.getName()))){
				// erros.append("Código do Agente Comercial ");
				// erros.append(codigoAgenteComercial);
				// erros.append(" inexistente. \n");
				// }

				// [FS0017] - Verificar data de leitura
				dataLeitura = this.validarDataLeitura(dataLeituraString, erros, faturamentoGrupo.getAnoMesReferencia());

				filtroImovel = new FiltroImovel();
				filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.QUADRA);
				filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOCALIDADE);
				filtroImovel.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.SETOR_COMERCIAL);
				filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.ID, Util.obterInteger(matriculaImovel)));
				imovel = (Imovel) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName()));
				// [FS0018] - Verificar existência da matrícula do imóvel
				if(imovel == null){
					erros.append("Matrícula do Imóvel ");
					erros.append(matriculaImovel);
					erros.append(" inexistente. \n");
				}else{
					filtroLigacaoAgua = new FiltroLigacaoAgua();
					filtroLigacaoAgua.adicionarCaminhoParaCarregamentoEntidade(FiltroLigacaoAgua.HIDROMETRO_INSTALACAO_HISTORICO);
					filtroLigacaoAgua.adicionarParametro(new ParametroSimples(FiltroLigacaoAgua.ID, Util.obterInteger(matriculaImovel)));
					ligacaoAgua = (LigacaoAgua) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroLigacaoAgua,
									LigacaoAgua.class.getName()));
				}
				if(empresaPrimeiroImovel == null && localidadePrimeiroImovel == null && imovel != null){
					FiltroImovel filtroImovelCabecalho = new FiltroImovel();
					filtroImovelCabecalho.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.EMPRESA);
					filtroImovelCabecalho.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.QUADRA);
					filtroImovelCabecalho.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.ROTA);
					filtroImovelCabecalho.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.LOCALIDADE);
					filtroImovelCabecalho.adicionarCaminhoParaCarregamentoEntidade(FiltroImovel.SETOR_COMERCIAL);
					filtroImovelCabecalho.adicionarParametro(new ParametroSimples(FiltroImovel.ID, Util.obterInteger(matriculaImovel)));
					imovel = (Imovel) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroImovelCabecalho,
									Imovel.class.getName()));
					empresaPrimeiroImovel = imovel.getRota().getEmpresa();
					localidadePrimeiroImovel = imovel.getLocalidade();
				}

				if(Util.obterInteger(codigoAnormalidadeLeitura).intValue() == 0){
					leituraAnormalidade = null;
				}else{
					leituraAnormalidade = (LeituraAnormalidade) getControladorUtil().pesquisar(
									Util.obterInteger(codigoAnormalidadeLeitura), LeituraAnormalidade.class, false);
				}

				// [FS0019] - Verificar tipo de medição
				if(tipoMedicao != 0){
					medicaoTipo = (MedicaoTipo) getControladorUtil().pesquisar(tipoMedicao, MedicaoTipo.class, false);
					if(medicaoTipo == null){
						erros.append("Tipo de Medição ");
						erros.append(tipoMedicao);
						erros.append(" inexistente. \n");
					}else if(medicaoTipo.getDescricao().equals(MedicaoTipo.DESC_LIGACAO_AGUA)){
						if(imovel != null){
							if(ligacaoAgua == null || ligacaoAgua.getHidrometroInstalacaoHistorico() == null){
								advertencias.append("Matrícula: " + matriculaImovel
												+ " - Movimento para ligação de água sem hidrômetro. \n");
							}
						}
					}else if(medicaoTipo.getDescricao().equals(MedicaoTipo.DESC_POCO)){
						if(imovel == null || imovel.getHidrometroInstalacaoHistorico() == null){
							advertencias.append("Matrícula: " + matriculaImovel + " - Movimento para poço sem hidrômetro. \n");
						}
					}
				}else{
					if(!Util.isVazioOuBranco(leituraHidrometro) && Util.obterInteger(leituraHidrometro) > 0){
						if(imovel != null){

							if((ligacaoAgua == null || ligacaoAgua.getHidrometroInstalacaoHistorico() == null)
											&& (imovel == null || imovel.getHidrometroInstalacaoHistorico() == null)){
								advertencias.append("Matrícula: " + matriculaImovel + " - Movimento para ligação sem hidrômetro. \n");
							}
						}
					}
					if(leituraAnormalidade != null && ConstantesSistema.NAO.equals(leituraAnormalidade.getIndicadorImovelSemHidrometro())){
						if(imovel != null){
							if((ligacaoAgua == null || ligacaoAgua.getHidrometroInstalacaoHistorico() == null)
											&& (imovel == null || imovel.getHidrometroInstalacaoHistorico() == null)){
								erros.append("Anormalidade não permitida para ligação sem hidrômetro. \n");
							}
						}

					}

				}

				// [FS0020] – Verificar existência do código da anormalidade de leitura
				if(leituraAnormalidade == null && Util.obterInteger(codigoAnormalidadeLeitura).intValue() != 0){
					erros.append("Código da Anormalidade de Leitura ");
					erros.append(codigoAnormalidadeLeitura);
					erros.append(" inexistente. \n");
				}

				// [FS0021] - Validar indicador de confirmação de leitura
				if(!Util.isVazioOuBranco(indicadorConfirmacaoLeitura)){

					LeituraSituacao leituraSituacaoAtualExiste = (LeituraSituacao) getControladorUtil().pesquisar(
									Util.obterInteger(indicadorConfirmacaoLeitura), LeituraSituacao.class, false);

					if(leituraSituacaoAtualExiste == null){

						erros.append("Indicador de Confirmação de Leitura ");
						erros.append(indicadorConfirmacaoLeitura);
						erros.append(" inválido. \n");
					}

				}else{

					erros.append("Indicador de Confirmação de Leitura ");
					erros.append(indicadorConfirmacaoLeitura);
					erros.append(" inválido. \n");
				}

				// [FS0026] – Verificar existência do código da anormalidade de consumo
				if(!Util.isVazioOuBranco(codigoAnormalidadeConsumo)){
					if(Util.obterInteger(codigoAnormalidadeConsumo).intValue() == 0){
						consumoAnormalidade = null;
					}else{
						filtroConsumoAnormalidade = new FiltroConsumoAnormalidade();
						filtroConsumoAnormalidade.adicionarParametro(new ParametroSimples(FiltroConsumoAnormalidade.ID, Util
										.obterInteger(codigoAnormalidadeConsumo)));
						consumoAnormalidade = (ConsumoAnormalidade) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(
										filtroConsumoAnormalidade, ConsumoAnormalidade.class.getName()));
						if(consumoAnormalidade == null){
							erros.append("Código da Anormalidade de Consumo ");
							erros.append(codigoAnormalidadeConsumo);
							erros.append(" inexistente. \n");
						}
					}
				}

				// [FS0027] – Validar tipo do consumo
				filtroConsumoTipo = new FiltroConsumoTipo();
				filtroConsumoTipo.adicionarParametro(new ParametroSimples(FiltroConsumoTipo.CODIGO, ConsumoTipo.NAO_MEDIDO));
				consumoTipoNaoMedido = (ConsumoTipo) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroConsumoTipo,
								ConsumoTipo.class.getName()));
				filtroConsumoTipo.limparListaParametros();
				filtroConsumoTipo.adicionarParametro(new ParametroSimples(FiltroConsumoTipo.CODIGO, Util.obterInteger(tipoConsumo)));
				consumoTipo = (ConsumoTipo) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(filtroConsumoTipo,
								ConsumoTipo.class.getName()));
				if(consumoTipo != null){
					if(consumoTipo.getId().intValue() != consumoTipoNaoMedido.getId().intValue()){
						if(ligacaoAgua != null){
							if(ligacaoAgua.getHidrometroInstalacaoHistorico() == null){
								if(imovel != null){
									advertencias.append("Imóvel " + imovel.getId() + " Inscrição " + imovel.getInscricaoFormatada());
									advertencias.append(" sem hidrômetro na ligação de água. Tipo do Consumo informado ");
									advertencias.append(consumoTipo.getDescricao());
									advertencias.append(" incompatível. \n");
								}
							}
						}
					}else{
						if(ligacaoAgua != null){
							if(ligacaoAgua.getHidrometroInstalacaoHistorico() != null){
								if(imovel != null){
									advertencias.append("Imóvel " + imovel.getId() + " Inscrição " + imovel.getInscricaoFormatada());
									advertencias.append(" com hidrômetro na ligação de água. Tipo do Consumo informado ");
									advertencias.append(consumoTipo.getDescricao());
									advertencias.append(" incompatível. \n");
								}
							}
						}
					}
				}else{
					erros.append("Consumo tipo ");
					erros.append(consumoTipo);
					erros.append(" inválido. \n");
				}
				// [FS0028] – Validar Indicador de Emissão em Campo
				if(indicadorEmissaoCampo != null){
					if(!listaEmissaoGrupo.contains(indicadorEmissaoCampo)){
						erros.append("Indicador de Emissão em Campo com valor inválido. \n");
					}

					if(listaEmissaoGrupoVerificacao.contains(indicadorEmissaoCampo)){
						if(imovel != null){
							if(ConstantesSistema.NAO.equals(imovel.getIndicadorDebitoConta())){
								advertencias.append("Imóvel ");
								advertencias.append(matriculaImovel);
								advertencias
												.append(" não é débito automático. Indicador de Emissão em Campo incompatível com situação do imóvel. \n");
							}
						}

						indicadorEmissaoCampo = MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_IMPRESSA.toString();
					}

					if("3".equals(indicadorEmissaoCampo)){
						if(imovel != null){
							if(ConstantesSistema.SIM.equals(imovel.getIndicadorDebitoConta())){
								advertencias.append("Consumo para análise – débito automático. Imóvel ");
								advertencias.append(matriculaImovel);
								advertencias.append(". \n");
							}else{
								advertencias.append("Consumo para análise. Imóvel ");
								advertencias.append(matriculaImovel);
								advertencias.append(". \n");
							}
						}
					}
				}else{
					erros.append("Indicador de Emissão em Campo com valor inválido. \n");
				}

				if(!Util.isVazioOuBranco(dataVencimentoRetornada)){

					// [FS0027 – Validar data de vencimento]
					erros = validarDataVencimento(dataVencimentoRetornada, erros);
				}

				if(!Util.isVazioOuBranco(dataLeituraFaturada)){

					// FS0017 – Validar data de leitura]
					dataLeitura = this.validarDataLeitura(dataLeituraFaturada, erros, faturamentoGrupo.getAnoMesReferencia());
				}

				if(!Util.isVazioOuBranco(codigoServicoReligacao)){
					codigoServicoReligacaoInt = Integer.valueOf(codigoServicoReligacao);

					// [FS0036] – Verificar a existência do tipo de serviço
					if(codigoServicoReligacaoInt != 0){
						this.validarServicoTipo(erros, codigoServicoReligacaoInt);
					}
				}

				if(!Util.isVazioOuBranco(codigoServicoSancao)){
					codigoServicoSancaoInt = Integer.valueOf(codigoServicoSancao);

					// [FS0036] – Verificar a existência do tipo de serviço
					if(codigoServicoSancaoInt != 0){
						this.validarServicoTipo(erros, codigoServicoSancaoInt);
					}
				}

				if(!Util.isVazioOuBranco(indicadorSuspeitaLigacaoSemHidr)
								&& indicadorSuspeitaLigacaoSemHidr.equals(ConstantesSistema.SIM.toString())){
					advertencias.append("Suspeita de imóvel ligado e sem hidrômetro. \n");
				}

				if(!Util.isVazioOuBranco(indicadorChecarNumHidr) && indicadorChecarNumHidr.equals(ConstantesSistema.SIM.toString())){
					advertencias.append("Checar numeração do hidrômetro. \n");
				}

				if(!Util.isVazioOuBranco(indicadorChecarCategEconom) && indicadorChecarCategEconom.equals(ConstantesSistema.SIM.toString())){
					advertencias.append("Checar a categoria e numero de economias do imovel. \n");
				}

				if(!Util.isVazioOuBranco(indicadorChecarLogradouro) && indicadorChecarLogradouro.equals(ConstantesSistema.SIM.toString())){
					advertencias.append("Checar nome do logradouro. \n");
				}

				if(!Util.isVazioOuBranco(indicadorRevisarQuadra) && indicadorRevisarQuadra.equals(ConstantesSistema.SIM.toString())){
					advertencias.append("Revisar a quadra do imóvel. \n");
				}

				if(!Util.isVazioOuBranco(indicadorFiscalizarConsumo) && indicadorFiscalizarConsumo.equals(ConstantesSistema.SIM.toString())){
					advertencias.append("Fiscalizar consumo do imóvel. \n");
				}

				if(!Util.isVazioOuBranco(indicadorNaoMedidoComHidr) && indicadorNaoMedidoComHidr.equals(ConstantesSistema.SIM.toString())){
					advertencias.append("Imóvel com hidrômetro consta como não medido. \n");
				}

				if(erros.length() > 0){

					mapaErros.put(i, erros.toString());
				}else{

					filtroMovimentoRoteiroEmpresa = new FiltroMovimentoRoteiroEmpresa();
					filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.ANO_MES_MOVIMENTO,
									faturamentoGrupo.getAnoMesReferencia()));
					filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(
									FiltroMovimentoRoteiroEmpresa.FATURAMENTO_GRUPO_ID, faturamentoGrupo.getId()));
					filtroMovimentoRoteiroEmpresa.adicionarParametro(new ParametroSimples(FiltroMovimentoRoteiroEmpresa.IMOVEL_ID, imovel
									.getId()));
					filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.IMOVEL);
					filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.HIDROMETRO);
					filtroMovimentoRoteiroEmpresa.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.MEDICAO_TIPO);
					filtroMovimentoRoteiroEmpresa
									.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.LEITURA_ANORMALIDADE);
					filtroMovimentoRoteiroEmpresa
									.adicionarCaminhoParaCarregamentoEntidade(FiltroMovimentoRoteiroEmpresa.LIGACAO_AGUA_SITUACAO);
					movimentoRoteiroEmpresa = (MovimentoRoteiroEmpresa) Util.retonarObjetoDeColecao(getControladorUtil().pesquisar(
									filtroMovimentoRoteiroEmpresa, MovimentoRoteiroEmpresa.class.getName()));

					if(movimentoRoteiroEmpresa == null){

						erros.append("Movimento de retorno para imóvel " + matriculaImovel + " não pré-faturado.");
						mapaErros.put(i, erros.toString());

					}else if(movimentoRoteiroEmpresa.getIndicadorFase() == null
									|| !(movimentoRoteiroEmpresa.getIndicadorFase().equals(MovimentoRoteiroEmpresa.FASE_GERADO) || movimentoRoteiroEmpresa
													.getIndicadorFase().equals(MovimentoRoteiroEmpresa.FASE_LEITURA_RETORNADA))){

						erros.append("Não há dados no movimento de leituras e anormalidades para o imóvel " + matriculaImovel + ".");
						mapaErros.put(i, erros.toString());
					}else{

						int consumoMinimoLigacao = imovel != null ? this.obterConsumoMinimoLigacao(imovel, null) : 0;
						int leituraAtual = Util.obterInteger(leituraHidrometro);
						int leituraAnterior = movimentoRoteiroEmpresa.getNumeroLeituraAnterior() != null ? movimentoRoteiroEmpresa
										.getNumeroLeituraAnterior().intValue() : 0;
						int numeroConsumoMedio = movimentoRoteiroEmpresa.getNumeroConsumoMedio() != null ? movimentoRoteiroEmpresa
										.getNumeroConsumoMedio().intValue() : 0;

						// [SB0008 – Determinar Consumo Faturado Água]
						Integer consumoFaturadoAgua = determinarConsumoFaturadoAgua(consumoFaturado, consumoTipo, consumoMinimoLigacao,
										leituraAtual, leituraAnterior, numeroConsumoMedio);

						movimentoRoteiroEmpresa.setNumeroConsumoFaturadoAgua(consumoFaturadoAgua);

						movimentoRoteiroEmpresa.setIndicadorConfirmacaoLeitura(Util.obterShort(indicadorConfirmacaoLeitura));
						boolean situacoesLeituraPermitidasMaiorAnterior = false;
						boolean leituraHidroMaiorOuIgualLeituraAnterior = (leituraAtual >= leituraAnterior);

						Integer idLeituraSituacaoAtual = movimentoRoteiroEmpresa.getIndicadorConfirmacaoLeitura().intValue();
						Integer idLeituraSituacaoAnterior = movimentoRoteiroEmpresa.getIdLeituraSituacaoAnterior();

						if(idLeituraSituacaoAnterior != null){

							if(leituraHidroMaiorOuIgualLeituraAnterior
											&& (idLeituraSituacaoAtual.equals(LeituraSituacao.REALIZADA)
															|| idLeituraSituacaoAtual.equals(LeituraSituacao.CONFIRMADA) || idLeituraSituacaoAtual
																.equals(LeituraSituacao.RECONFIRMADA))
											&& (idLeituraSituacaoAnterior.equals(LeituraSituacao.REALIZADA)
															|| idLeituraSituacaoAnterior.equals(LeituraSituacao.CONFIRMADA) || idLeituraSituacaoAnterior
																.equals(LeituraSituacao.RECONFIRMADA))){

								situacoesLeituraPermitidasMaiorAnterior = true;
							}
						}

						Boolean consumoReal = consumoTipo != null && consumoTipo.getId().equals(ConsumoTipo.REAL) ? Boolean.TRUE
										: Boolean.FALSE;

						if((consumoReal && leituraHidroMaiorOuIgualLeituraAnterior) || (situacoesLeituraPermitidasMaiorAnterior)){

							movimentoRoteiroEmpresa.setNumeroConsumoMedido(leituraAtual - leituraAnterior);
						}

						movimentoRoteiroEmpresa.setDataLeitura(dataLeitura);
						movimentoRoteiroEmpresa.setNumeroLeitura(Util.obterInteger(leituraHidrometro));
						movimentoRoteiroEmpresa.setLeituraAnormalidade(leituraAnormalidade);
						movimentoRoteiroEmpresa.setIndicadorFase(MovimentoRoteiroEmpresa.FASE_LEITURA_RETORNADA);
						movimentoRoteiroEmpresa.setNumeroConsumoFaturadoEsgoto(movimentoRoteiroEmpresa.getNumeroConsumoFaturadoAgua());
						movimentoRoteiroEmpresa.setConsumoAnormalidade(consumoAnormalidade);
						movimentoRoteiroEmpresa.setConsumoTipo(consumoTipo);
						movimentoRoteiroEmpresa.setNumeroDiasConsumo(Util.obterShort(diasConsumo));
						movimentoRoteiroEmpresa.setValorAgua(new BigDecimal(valorAgua.substring(0, 9) + "." + valorAgua.substring(9, 11)));
						movimentoRoteiroEmpresa.setValorEsgoto(new BigDecimal(valorEsgoto.substring(0, 9) + "."
										+ valorEsgoto.substring(9, 11)));
						movimentoRoteiroEmpresa.setValorDebitos(new BigDecimal(valorDebitos.substring(0, 9) + "."
										+ valorDebitos.substring(9, 11)));
						movimentoRoteiroEmpresa.setIndicadorGrandeCliente(Util.obterShort(indicadorGrandeConsumidor));
						movimentoRoteiroEmpresa.setIndicadorEmissaoCampo(indicadorEmissaoCampo);
						movimentoRoteiroEmpresa.setUltimaAlteracao(new Date());
						movimentoRoteiroEmpresa.setDataProcessamento(new Date());

						Short indicadorImovelNaoLidoFaturarMedia = ConstantesSistema.NAO;
						if(!Util.isVazioOuBranco(statusRegistro)){

							movimentoRoteiroEmpresa.setIndicadorStatusRegistSistLegado(Short.valueOf(statusRegistro));

							if(movimentoRoteiroEmpresa.getIndicadorStatusRegistSistLegado().equals(
															MovimentoRoteiroEmpresa.INDICADOR_STATUS_REGISTRO_NAO_LIDO)
											&& movimentoRoteiroEmpresa.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)){

								indicadorImovelNaoLidoFaturarMedia = ConstantesSistema.SIM;
							}
						}

						if((indicadorEmissaoCampo.equals(MovimentoRoteiroEmpresa.INDICADOR_EMISSAO_CAMPO_CONTA_RETIDA)
										&& (movimentoRoteiroEmpresa.getValorAgua().compareTo(BigDecimal.ZERO) == 0 && movimentoRoteiroEmpresa
														.getValorEsgoto().compareTo(BigDecimal.ZERO) == 0) && movimentoRoteiroEmpresa
										.getNumeroHidrometro() != null) || indicadorImovelNaoLidoFaturarMedia.equals(ConstantesSistema.SIM)){

							movimentoRoteiroEmpresa.setNumeroLeituraFaturada(leituraAnterior
											+ movimentoRoteiroEmpresa.getNumeroConsumoMedio().intValue());
						}else{

							movimentoRoteiroEmpresa.setNumeroLeituraFaturada(Util.obterInteger(leituraFaturada));
						}

						if(!Util.isVazioOuBranco(valorCreditos)){

							tratarValorCreditosArquivoRetornoFaturamentoImediato(new BigDecimal(valorCreditos.substring(0, 9) + "."
											+ valorCreditos.substring(9, 11)),
											movimentoRoteiroEmpresa);
						}

						if(!Util.isVazioOuBranco(valorImpostoFederal)){

							movimentoRoteiroEmpresa.setValorImpostoFederal(new BigDecimal(valorImpostoFederal.substring(0, 9) + "."
											+ valorImpostoFederal.substring(9, 11)));
						}

						if(!Util.isVazioOuBranco(dataVencimentoRetornada) && Util.validarAnoMesDiaSemBarra(dataVencimentoRetornada)){

							movimentoRoteiroEmpresa.setDataVencimentoRetorno(Util.converteStringSemBarraParaDate(dataVencimentoRetornada));
						}

						if(!Util.isVazioOuBranco(dataLeituraFaturada)){

							movimentoRoteiroEmpresa.setDataLeituraFaturada(Util.converteStringSemBarraParaDate(dataLeituraFaturada));
						}

						if(!Util.isVazioOuBranco(valorRateio)){

							movimentoRoteiroEmpresa.setValorRateio(new BigDecimal(valorRateio.substring(0, 9) + "."
											+ valorRateio.substring(9, 11)));
						}

						if(!Util.isVazioOuBranco(indicadorModoFaturamento)){

							movimentoRoteiroEmpresa.setIndicadorModoFaturarRateio(new Short(indicadorModoFaturamento));
						}

						if(!Util.isVazioOuBranco(indicadorReligacaoAgua)){
							if(indicadorReligacaoAgua.equals("0")){
								movimentoRoteiroEmpresa.setIndicadorReligacaoAgua(ConstantesSistema.NAO);
							}else if(indicadorReligacaoAgua.equals("2")){
								movimentoRoteiroEmpresa.setIndicadorReligacaoAgua(ConstantesSistema.SIM);
							}
						}

						if(!Util.isVazioOuBranco(codigoServicoReligacao)){
							movimentoRoteiroEmpresa.setIdServicoReligacao(Integer.valueOf(codigoServicoReligacao));
						}

						if(!Util.isVazioOuBranco(valorReligacao)){
							movimentoRoteiroEmpresa.setValorReligacao(new BigDecimal(valorReligacao.substring(0, 9) + "."
											+ valorReligacao.substring(9, 11)));
						}

						if(!Util.isVazioOuBranco(codigoServicoSancao)){
							movimentoRoteiroEmpresa.setIdServicoSancao(Integer.valueOf(codigoServicoSancao));
						}

						if(!Util.isVazioOuBranco(valorSancao)){
							movimentoRoteiroEmpresa.setValorSancao(new BigDecimal(valorSancao.substring(0, 9) + "."
											+ valorSancao.substring(9, 11)));
						}

						if(!Util.isVazioOuBranco(alteracaoNumeroImovel)){
							movimentoRoteiroEmpresa.setNumeroImovelAlteracao(alteracaoNumeroImovel);
						}

						if(!Util.isVazioOuBranco(indicadorFaturaRetida)){
							if(indicadorFaturaRetida.equals("0")){
								movimentoRoteiroEmpresa.setIndicadorFaturaRetida(ConstantesSistema.NAO);
							}else{
								movimentoRoteiroEmpresa.setIndicadorFaturaRetida(ConstantesSistema.SIM);
							}
						}

						getControladorUtil().atualizar(movimentoRoteiroEmpresa);

						indicadorReligacaoAguaShort = movimentoRoteiroEmpresa.getIndicadorReligacaoAgua();

						if(indicadorReligacaoAguaShort != null && indicadorReligacaoAguaShort.equals(ConstantesSistema.SIM)){
							// Gera linha no arquivo Religação Automática de Consumidor

							if(arquivoReligacaoAutomaticaConsumidor == null){
								arquivoReligacaoAutomaticaConsumidor = new StringBuffer();
							}

							linhaReligacaoAutomaticaConsumidor = this.gerarLinhaReligacaoAutomaticaConsumidor(movimentoRoteiroEmpresa);

							arquivoReligacaoAutomaticaConsumidor.append(linhaReligacaoAutomaticaConsumidor);
							arquivoReligacaoAutomaticaConsumidor.append(System.getProperty("line.separator"));
						}
					}
				}

				if(advertencias.length() > 0){

					mapaAdvertencias.put(i, advertencias.toString());
				}

				i++;
			}
			if(!mapaErros.isEmpty() || !mapaAdvertencias.isEmpty()){

				Processo processoLeitura = new Processo();
				processoLeitura.setId(Processo.GERAR_RELATORIO_PROCESSAR_ARQUIVO_DADOS_LEITURA_E_ANORMALIDADE);

				ProcessoSituacao processoSituacaoLeitura = new ProcessoSituacao();
				processoSituacaoLeitura.setId(ProcessoSituacao.CONCLUIDO);

				ProcessoIniciado processoIniciadoLeitura = new ProcessoIniciado();
				processoIniciadoLeitura.setProcessoSituacao(processoSituacaoLeitura);
				processoIniciadoLeitura.setProcesso(processoLeitura);
				processoIniciadoLeitura.setDataHoraAgendamento(new Date());
				processoIniciadoLeitura.setDataHoraComando(new Date());
				processoIniciadoLeitura.setUsuario(usuarioLogado);
				processoIniciadoLeitura.setDataHoraInicio(new Date());

				this.getControladorUtil().inserir(processoIniciadoLeitura);

				FiltroProcessoFuncionalidade filtroProcessoFuncionalidadeLeitura = new FiltroProcessoFuncionalidade();
				filtroProcessoFuncionalidadeLeitura.adicionarParametro(new ParametroSimples(FiltroProcessoFuncionalidade.ID_PROCESSO,
								processoIniciadoLeitura.getProcesso().getId()));
				filtroProcessoFuncionalidadeLeitura.adicionarParametro(new ParametroSimples(FiltroProcessoFuncionalidade.INDICADOR_USO,
								ConstantesSistema.INDICADOR_USO_ATIVO));

				ProcessoFuncionalidade processoFuncionalidadeLeitura = (ProcessoFuncionalidade) this.getControladorUtil().pesquisar(
								filtroProcessoFuncionalidadeLeitura, ProcessoFuncionalidade.class.getName()).iterator().next();

				FuncionalidadeSituacao funcionalidadeSituacaoLeitura = new FuncionalidadeSituacao();
				funcionalidadeSituacaoLeitura.setId(FuncionalidadeSituacao.CONCLUIDA);

				FuncionalidadeIniciada funcionalidadeIniciadaLeitura = new FuncionalidadeIniciada();
				funcionalidadeIniciadaLeitura.setFuncionalidadeSituacao(funcionalidadeSituacaoLeitura);
				funcionalidadeIniciadaLeitura.setProcessoIniciado(processoIniciadoLeitura);
				funcionalidadeIniciadaLeitura.setProcessoFuncionalidade(processoFuncionalidadeLeitura);
				funcionalidadeIniciadaLeitura.setDataHoraInicio(new Date());
				funcionalidadeIniciadaLeitura.setId((Integer) this.getControladorUtil().inserir(funcionalidadeIniciadaLeitura));

				RelatorioProcessarArquivoInformarAnormalidadesLeitura relatorio = new RelatorioProcessarArquivoInformarAnormalidadesLeitura(
								usuarioLogado, ConstantesRelatorios.RELATORIO_PROCESSAR_ARQUIVO_INFORMAR_ANORMALIDADES_LEITURA);

				relatorio.addParametro("faturamentoGrupo", faturamentoGrupo.getId() + " - " + faturamentoGrupo.getDescricao());

				relatorio.setIdFuncionalidadeIniciada(funcionalidadeIniciadaLeitura.getId());

				if(empresaPrimeiroImovel != null){
					relatorio.addParametro("empresa", empresaPrimeiroImovel.getId() + " - " + empresaPrimeiroImovel.getDescricao());
				}else{
					relatorio.addParametro("empresa", "");
				}
				if(localidadePrimeiroImovel != null){
					relatorio.addParametro("localidade", localidadePrimeiroImovel.getDescricaoComId());
				}else{
					relatorio.addParametro("localidade", "");
				}

				relatorio.addParametro("total", i - 1);
				relatorio.addParametro("erros", mapaErros);
				relatorio.addParametro("advertencias", mapaAdvertencias);

				// this.enviarRelatorioParaBatch(usuarioLogado, relatorio);
				relatorio.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);

				funcionalidadeIniciadaLeitura.setTarefaBatch(IoUtil.transformarObjetoParaBytes(relatorio));
				funcionalidadeIniciadaLeitura.setDataHoraTermino(new Date());
				this.getControladorUtil().atualizar(funcionalidadeIniciadaLeitura);

				processoIniciadoLeitura.setDataHoraTermino(new Date());
				this.getControladorUtil().atualizar(processoIniciadoLeitura);

				byte[] pdf = (byte[]) relatorio.executar();

				gerarArquivoEnviarEmail(pdf);

			}

			if(arquivoReligacaoAutomaticaConsumidor != null){
				RelatorioArquivoReligacaoAutomaticaConsumidor relatorio = new RelatorioArquivoReligacaoAutomaticaConsumidor(usuarioLogado);
				relatorio.addParametro("idFaturamentoGrupo", faturamentoGrupo.getId());
				relatorio.addParametro("anoMesReferencia", faturamentoGrupo.getAnoMesReferencia());
				relatorio.addParametro("arquivoReligacaoAutomaticaConsumidor", arquivoReligacaoAutomaticaConsumidor);
				relatorio.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_ZIP);

				this.getControladorBatch().iniciarProcessoRelatorio(relatorio);
			}

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			// gerar email de erro.
			this.gerarEmailErroProcessarArquivoLeituraAnormalidade(e, EnvioEmail.PROCESSAR_ARQUIVO_LEITURA_ANORMALIDADES);
			e.printStackTrace();
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);

		}

	}

	private void tratarValorCreditosArquivoRetornoFaturamentoImediato(BigDecimal valorTotalCreditos,
					MovimentoRoteiroEmpresa movimentoRoteiroEmpresa){

		// Esse trecho não trata os créditos de parcelamento que já foram descontados no valor do
		// líquido débito enviado no arquivo.
		if(valorTotalCreditos.compareTo(BigDecimal.ZERO) == 1){

			BigDecimal saldoContaMovimento = movimentoRoteiroEmpresa.getValorTotalContaSemCreditos().subtract(valorTotalCreditos);
			BigDecimal valorCreditadoEmConta = BigDecimal.ZERO;
			BigDecimal valorCreditadoEmContaAtualizarMovimento = BigDecimal.ZERO;

			// Caso o valor da conta após abater os créditos fique negativo
			if(saldoContaMovimento.compareTo(BigDecimal.ZERO) == -1){

				// O valor creditado no mês é o valor da conta
				valorCreditadoEmConta = movimentoRoteiroEmpresa.getValorTotalContaSemCreditos();
			}else{

				// Caso contrário, o valor créditado no mês é o valor total dos créditos devolvidos
				// no retorno do arquivo
				valorCreditadoEmConta = valorTotalCreditos;
			}

			// Dilui o valor creditado para os respectivos créditos enviados
			if(movimentoRoteiroEmpresa.getValorCreditado1() == null && movimentoRoteiroEmpresa.getValorCredito1() != null
							&& movimentoRoteiroEmpresa.getValorCredito1().compareTo(BigDecimal.ZERO) == 1
							&& valorCreditadoEmConta.compareTo(BigDecimal.ZERO) == 1){

				// Caso o valor creditado na conta seja menor ou igual ao valor
				// do crédito enviado
				if(valorCreditadoEmConta.compareTo(movimentoRoteiroEmpresa.getValorCredito1()) <= 0){

					// Credita todo o valor no crédito enviado
					movimentoRoteiroEmpresa.setValorCreditado1(valorCreditadoEmConta);
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(valorCreditadoEmConta);
					valorCreditadoEmConta = BigDecimal.ZERO;
				}else{

					// Credita parte do valor no crédito enviado e deixa um
					// saldo restante a ser abatido posteriormente em outros
					// créditos existentes ou como valor residual para o próximo
					// mês caso não tenha mais créditos para abater
					movimentoRoteiroEmpresa.setValorCreditado1(movimentoRoteiroEmpresa.getValorCredito1());
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(movimentoRoteiroEmpresa
									.getValorCredito1());
					valorCreditadoEmConta = valorCreditadoEmConta.subtract(movimentoRoteiroEmpresa.getValorCredito1());
				}
			}

			if(movimentoRoteiroEmpresa.getValorCreditado2() == null && movimentoRoteiroEmpresa.getValorCredito2() != null
							&& movimentoRoteiroEmpresa.getValorCredito2().compareTo(BigDecimal.ZERO) == 1
							&& valorCreditadoEmConta.compareTo(BigDecimal.ZERO) == 1){

				// Caso o valor creditado na conta seja menor ou igual ao valor
				// do crédito enviado
				if(valorCreditadoEmConta.compareTo(movimentoRoteiroEmpresa.getValorCredito2()) <= 0){

					// Credita todo o valor no crédito enviado
					movimentoRoteiroEmpresa.setValorCreditado2(valorCreditadoEmConta);
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(valorCreditadoEmConta);
					valorCreditadoEmConta = BigDecimal.ZERO;
				}else{

					// Credita parte do valor no crédito enviado e deixa um
					// saldo restante a ser abatido posteriormente em outros
					// créditos existentes ou como valor residual para o próximo
					// mês caso não tenha mais créditos para abater
					movimentoRoteiroEmpresa.setValorCreditado2(movimentoRoteiroEmpresa.getValorCredito2());
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(movimentoRoteiroEmpresa
									.getValorCredito2());
					valorCreditadoEmConta = valorCreditadoEmConta.subtract(movimentoRoteiroEmpresa.getValorCredito2());
				}
			}

			if(movimentoRoteiroEmpresa.getValorCreditado3() == null && movimentoRoteiroEmpresa.getValorCredito3() != null
							&& movimentoRoteiroEmpresa.getValorCredito3().compareTo(BigDecimal.ZERO) == 1
							&& valorCreditadoEmConta.compareTo(BigDecimal.ZERO) == 1){

				// Caso o valor creditado na conta seja menor ou igual ao valor
				// do crédito enviado
				if(valorCreditadoEmConta.compareTo(movimentoRoteiroEmpresa.getValorCredito3()) <= 0){

					// Credita todo o valor no crédito enviado
					movimentoRoteiroEmpresa.setValorCreditado3(valorCreditadoEmConta);
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(valorCreditadoEmConta);
					valorCreditadoEmConta = BigDecimal.ZERO;
				}else{

					// Credita parte do valor no crédito enviado e deixa um
					// saldo restante a ser abatido posteriormente em outros
					// créditos existentes ou como valor residual para o próximo
					// mês caso não tenha mais créditos para abater
					movimentoRoteiroEmpresa.setValorCreditado3(movimentoRoteiroEmpresa.getValorCredito3());
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(movimentoRoteiroEmpresa
									.getValorCredito3());
					valorCreditadoEmConta = valorCreditadoEmConta.subtract(movimentoRoteiroEmpresa.getValorCredito3());
				}
			}

			if(movimentoRoteiroEmpresa.getValorCreditado4() == null && movimentoRoteiroEmpresa.getValorCredito4() != null
							&& movimentoRoteiroEmpresa.getValorCredito4().compareTo(BigDecimal.ZERO) == 1
							&& valorCreditadoEmConta.compareTo(BigDecimal.ZERO) == 1){

				// Caso o valor creditado na conta seja menor ou igual ao valor
				// do crédito enviado
				if(valorCreditadoEmConta.compareTo(movimentoRoteiroEmpresa.getValorCredito4()) <= 0){

					// Credita todo o valor no crédito enviado
					movimentoRoteiroEmpresa.setValorCreditado4(valorCreditadoEmConta);
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(valorCreditadoEmConta);
					valorCreditadoEmConta = BigDecimal.ZERO;
				}else{

					// Credita parte do valor no crédito enviado e deixa um
					// saldo restante a ser abatido posteriormente em outros
					// créditos existentes ou como valor residual para o próximo
					// mês caso não tenha mais créditos para abater
					movimentoRoteiroEmpresa.setValorCreditado4(movimentoRoteiroEmpresa.getValorCredito4());
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(movimentoRoteiroEmpresa
									.getValorCredito4());
					valorCreditadoEmConta = valorCreditadoEmConta.subtract(movimentoRoteiroEmpresa.getValorCredito4());
				}
			}

			if(movimentoRoteiroEmpresa.getValorCreditado5() == null && movimentoRoteiroEmpresa.getValorCredito5() != null
							&& movimentoRoteiroEmpresa.getValorCredito5().compareTo(BigDecimal.ZERO) == 1
							&& valorCreditadoEmConta.compareTo(BigDecimal.ZERO) == 1){

				// Caso o valor creditado na conta seja menor ou igual ao valor
				// do crédito enviado
				if(valorCreditadoEmConta.compareTo(movimentoRoteiroEmpresa.getValorCredito5()) <= 0){

					// Credita todo o valor no crédito enviado
					movimentoRoteiroEmpresa.setValorCreditado5(valorCreditadoEmConta);
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(valorCreditadoEmConta);
					valorCreditadoEmConta = BigDecimal.ZERO;
				}else{

					// Credita parte do valor no crédito enviado e deixa um
					// saldo restante a ser abatido posteriormente em outros
					// créditos existentes ou como valor residual para o próximo
					// mês caso não tenha mais créditos para abater
					movimentoRoteiroEmpresa.setValorCreditado5(movimentoRoteiroEmpresa.getValorCredito5());
					valorCreditadoEmContaAtualizarMovimento = valorCreditadoEmContaAtualizarMovimento.add(movimentoRoteiroEmpresa
									.getValorCredito5());
					valorCreditadoEmConta = valorCreditadoEmConta.subtract(movimentoRoteiroEmpresa.getValorCredito5());
				}
			}

			// atualiza movimento roteiro empresa com o valor de créditos que foi descontado na
			// conta
			movimentoRoteiroEmpresa.setValorCreditos(valorCreditadoEmContaAtualizarMovimento);
		}
	}

	/**
	 * [UC0948] Informar Dados de Leituras e Anormalidades
	 * [SB0008] – Determinar Consumo Faturado Água
	 * 
	 * @author Luciano Galvao
	 * @date 21/06/2013
	 */
	private Integer determinarConsumoFaturadoAgua(String consumoFaturado, ConsumoTipo consumoTipo, int consumoMinimoLigacao,
					int leituraAtual, int leituraAnterior, int numeroConsumoMedio) throws ControladorException{

		// Condições utilizadas durante o subfluxo
		Boolean consumoFaturadoMenorMinimo = Short.valueOf(ParametroFaturamento.P_CONSUMO_FATURADO_MENOR_MINIMO.executar()).equals(
						ConstantesSistema.SIM);
		Boolean consFaturadoIgualConsMinimo = (Util.obterInteger(consumoFaturado).intValue() == consumoMinimoLigacao);
		Boolean consFaturadoMenorConsMinimo = (Util.obterInteger(consumoFaturado).intValue() < consumoMinimoLigacao);
		Boolean leituraHidroMaiorLeituraAnterior = (leituraAtual > leituraAnterior);
		Boolean consFaturadoMaiorLeitHidro = (Util.obterInteger(consumoFaturado).intValue() > (leituraAtual - leituraAnterior));
		Boolean consumoMedia = consumoTipo != null && consumoTipo.getId().equals(ConsumoTipo.MEDIA_IMOVEL) ? Boolean.TRUE : Boolean.FALSE;
		Boolean consumoReal = consumoTipo != null && consumoTipo.getId().equals(ConsumoTipo.REAL) ? Boolean.TRUE : Boolean.FALSE;

		Boolean consFaturadoMaiorConsMedio = (Util.obterInteger(consumoFaturado).intValue() > numeroConsumoMedio);

		// Consumo faturado que será considerado
		Integer consumoFaturadoAgua = Util.obterInteger(consumoFaturado);

		// 1.2. Caso o parâmetro de consumo faturado menor que mínimo for verdadeiro
		if(consumoFaturadoMenorMinimo){
			// 1.2.1. Caso Tipo do Consumo for REAL
			if(consumoReal){

				// 1.2.1.1. Caso Consumo Faturado igual ao Consumo mínimo da Ligação
				// (<<Inclui>> [UC0105 Obter Consumo Mínimo da Ligação]) e Leitura
				// do Hidrômetro maior que a Leitura Anterior e Consumo Faturado
				// maior que Leitura do Hidrômetro menos Leitura Anterior
				if(consFaturadoIgualConsMinimo && leituraHidroMaiorLeituraAnterior && consFaturadoMaiorLeitHidro){
					consumoFaturadoAgua = leituraAtual - leituraAnterior;
				}

				// 1.2.2. Caso Tipo do Consumo for MEDIA
			}else if(consumoMedia){

				// 1.2.2.1. Caso Consumo Faturado igual ao Consumo mínimo da Ligação
				// (<<Inclui>> [UC0105 Obter Consumo Mínimo da Ligação]) e Consumo
				// Faturado maior que a Média
				if(consFaturadoIgualConsMinimo && consFaturadoMaiorConsMedio){
					consumoFaturadoAgua = numeroConsumoMedio;
				}
			}

			// 1.3. Caso o parâmetro de consumo faturado menor que mínimo NÃO for
			// verdadeiro
			// 1.3.1. Caso Consumo Faturado menor que Consumo mínimo da Ligação
			// (<<Inclui>> [UC0105 Obter Consumo Mínimo da Ligação])
		}else if(consFaturadoMenorConsMinimo){
			consumoFaturadoAgua = consumoMinimoLigacao;
		}
		return consumoFaturadoAgua;
	}

	// public void enviarRelatorioParaBatch(Usuario usuarioLogado,
	// RelatorioProcessarArquivoInformarAnormalidadesLeitura relatorio)
	// throws ControladorException{
	//
	// relatorio.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
	//
	// byte[] pdf = (byte[]) relatorio.executar();
	// try{
	// gerarArquivoEnviarEmail(pdf);
	// }catch(Exception e){
	// e.printStackTrace();
	// }
	//
	// this.getControladorBatch().iniciarProcessoRelatorio(relatorio);
	//
	// }

	private File converterLayoutArquivoLeituraEmpresaLayoutArquivoLeituraPadrao(File arquivoLeitura, FaturamentoGrupo faturamentoGrupo)
					throws IOException, ControladorException{

		File arquivoDefinitivo = (File) ParametroMicromedicao.P_CONVERTER_ARQUIVO_LEITURA_PARA_FORMATO_PADRAO.executar(this, -1,
						arquivoLeitura, faturamentoGrupo);
		return arquivoDefinitivo;
	}

	/**
	 * Gera e envia por email o arquivo de retorno de baixa de ordem de serviço
	 * 
	 * @author wpereira
	 * @date 22/07/2010
	 * @param linhas
	 * @throws Exception
	 */
	private void gerarArquivoEnviarEmail(byte[] pdf) throws Exception{

		EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.PROCESSAR_ARQUIVO_LEITURA_ANORMALIDADES);

		File leitura = new File("Relatório Processar Arquivo Informar Anormalidades Leitura.pdf");
		FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
		out.write(pdf);
		out.flush();
		out.close();

		String emailRemetente = envioEmail.getEmailRemetente();
		String tituloMensagem = envioEmail.getTituloMensagem();
		String corpoMensagem = envioEmail.getCorpoMensagem();
		String emailReceptor = envioEmail.getEmailReceptor();

		ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);
		// leitura.delete();

	}

	private void gerarEmailErroProcessarArquivoLeituraAnormalidade(Exception e, Integer idEnvioEmail) throws ControladorException{

		try{
			String mensagem = e.getMessage();
			if(mensagem != null){
				if(!mensagem.startsWith("erro.") && !mensagem.startsWith("atencao.")){
					mensagem = "erro.sistema";
				}
			}else{
				mensagem = "erro.sistema";
			}

			EnvioEmail envioEmailError = getControladorCadastro().pesquisarEnvioEmail(idEnvioEmail);

			String emailRemetente = envioEmailError.getEmailRemetente();
			String tituloMensagem = envioEmailError.getTituloMensagem();
			String emailReceptor = envioEmailError.getEmailReceptor();
			if(e instanceof ControladorException){
				ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, ((ControladorException) e).getMensagem());
			}else{
				ServicosEmail.enviarMensagem(emailRemetente, emailReceptor, tituloMensagem, ConstantesAplicacao.get(mensagem));
			}

		}catch(Exception e2){
			e2.printStackTrace();
			// throw new ControladorException("erro.sistema", e2);
		}finally{
			// sessionContext.setRollbackOnly();

		}
	}

	private static String recuperarValorLinha(String linha, int posicaoAnterior, int qtidadeCaracteres){

		String retorno = "";

		try{

			retorno = linha.substring(posicaoAnterior, posicaoAnterior + qtidadeCaracteres);

		}catch(StringIndexOutOfBoundsException ex){
			System.out.println(linha);
			ex.printStackTrace();
		}

		return retorno;

	}

	// ----------

	/**
	 * [UC0083] - Gerar Dados para Leitura
	 * 
	 * @author eduardo henrique
	 * @date 05/09/2008
	 *       Método customizado para ADA que realiza a geração de um relatório (em .pdf) e o envia
	 *       por e-mail
	 *       para leitura Convencional.
	 * @author eduardo henrique
	 * @date 06/01/2008
	 *       Alteração no método de consulta para não realizar paginação (Hibernate utiliza rownum
	 *       no Oracle como default).
	 */
	public void gerarDadosPorLeituraConvencional(Collection<Rota> colecaoRota, Integer anoMesCorrente, Integer idGrupoFaturamentoRota,
					FuncionalidadeIniciada funcionalidade, Date dataPrevistaAtividadeLeitura, Collection collLeituraTipo)
					throws ControladorException{

		int idUnidadeIniciada = 0;

		try{

			SistemaParametro sistemaParametro = null;

			sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			// Registrar o início do processamento da Unidade de Processamento
			// do Batch
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(funcionalidade.getId(),
							UnidadeProcessamento.FUNCIONALIDADE, 0);

			// cria uma coleção de imóvel por rota
			Collection imoveisPorRota = new ArrayList();

			try{

				// recupera todos os imóveis da coleção de rotas do tipo Convencional
				Collection arrayImoveis = repositorioMicromedicao.pesquisarImoveisParaLeituraPorColecaoRota(colecaoRota, sistemaParametro);

				imoveisPorRota.addAll(arrayImoveis);

			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			Collection<FaturamentoAtividadeCriterio> colecaoFaturamentoAtividadeCriterio = null;

			colecaoFaturamentoAtividadeCriterio = this.pesquisarFaturamentoAtividadeCriterioPorLeituraTipo(
							FaturamentoAtividade.GERAR_ARQUIVO_LEITURA, collLeituraTipo);

			// Instancia uma coleção que será usada para gerar o relatório
			Collection<Imovel> imoveisParaSerGerados = new ArrayList();

			if(imoveisPorRota != null && !imoveisPorRota.isEmpty()){

				Iterator imovelporRotaIterator = imoveisPorRota.iterator();

				while(imovelporRotaIterator.hasNext()){

					// cria um array de objetos para pegar os parametros de
					// retorno da pesquisa
					Object[] arrayImoveisPorRota = (Object[]) imovelporRotaIterator.next();

					Imovel imovel = this.criarImovelApartirDadosPorLeituraConvencional(arrayImoveisPorRota);

					boolean ehValido = this.selecionarImovelParaFaturamento(imovel, anoMesCorrente, colecaoFaturamentoAtividadeCriterio);

					if(ehValido){
						imoveisParaSerGerados.add(imovel);
					}

				}
			}

			Map<Integer, Collection<GerarDadosParaLeituraHelper>> mapDadosParaLeituraPorRota = new HashMap<Integer, Collection<GerarDadosParaLeituraHelper>>();
			if(imoveisParaSerGerados != null && !imoveisParaSerGerados.isEmpty()){

				repositorioMicromedicao.removerMovimentoRoteiroEmpresa(anoMesCorrente, idGrupoFaturamentoRota);

				ListIterator imovelParaSerGeradoIterator = ((List) imoveisParaSerGerados).listIterator(0);

				while(imovelParaSerGeradoIterator.hasNext()){

					Imovel imovelParaSerGerado = (Imovel) imovelParaSerGeradoIterator.next();

					Integer codigoRota = Integer.valueOf(0);
					Integer codigoSetorComercial = imovelParaSerGerado.getSetorComercial().getCodigo();

					GerarDadosParaLeituraHelper gerarDadosParaLeituraHelper = new GerarDadosParaLeituraHelper();

					gerarDadosParaLeituraHelper.setAnoMesReferncia(Util.formatarAnoMesParaMesAno(anoMesCorrente));
					gerarDadosParaLeituraHelper.setGrupo(idGrupoFaturamentoRota.toString());

					gerarDadosParaLeituraHelper.setMatriculaImovel(imovelParaSerGerado.getId().toString());
					gerarDadosParaLeituraHelper.setDescricaoLocalidade(imovelParaSerGerado.getLocalidade().getDescricao());
					gerarDadosParaLeituraHelper.setInscricao(imovelParaSerGerado.getInscricaoFormatada());

					if(imovelParaSerGerado.getSetorComercial() != null){
						gerarDadosParaLeituraHelper.setCodigoSetor(String.valueOf(imovelParaSerGerado.getSetorComercial().getCodigo()));
					}
					// Dados da Rota
					if(imovelParaSerGerado.getRota() != null){
						gerarDadosParaLeituraHelper.setCodigoRota(imovelParaSerGerado.getRota().getCodigo().toString());
						codigoRota = imovelParaSerGerado.getRota().getCodigo().intValue();
					}

					if(imovelParaSerGerado.getNumeroSequencialRota() != null){
						gerarDadosParaLeituraHelper.setSequencialRota(imovelParaSerGerado.getNumeroSequencialRota().toString());
					}

					String nomeClienteUsuario = null;
					try{
						// Pesquisa o nome do cliente que tem o tipo de relação usuário.
						nomeClienteUsuario = repositorioClienteImovel.pesquisarNomeClientePorImovel(imovelParaSerGerado.getId());
					}catch(ErroRepositorioException e){
						throw new ControladorException("erro.sistema", e);
					}
					// nome do cliente usuário
					if(nomeClienteUsuario == null){
						nomeClienteUsuario = "";
					}

					// Pesquisa o endereço do imovel passando o id
					String[] enderecoImovel = getControladorEndereco().pesquisarEnderecoFormatadoDividido(imovelParaSerGerado.getId());
					if(enderecoImovel != null){
						if(enderecoImovel[0] != null){
							gerarDadosParaLeituraHelper.setEnderecoImovel(enderecoImovel[0]);
						}else{
							gerarDadosParaLeituraHelper.setEnderecoImovel(completaString("", 10));
						}

						if(enderecoImovel[3] != null){
							gerarDadosParaLeituraHelper.setEnderecoImovel(gerarDadosParaLeituraHelper.getEnderecoImovel() + " "
											+ enderecoImovel[3]);
						}

						if(enderecoImovel[4] != null){
							gerarDadosParaLeituraHelper.setEnderecoImovel(gerarDadosParaLeituraHelper.getEnderecoImovel() + " "
											+ enderecoImovel[4]);
						}
					}

					gerarDadosParaLeituraHelper.setNomeClienteUsuario(nomeClienteUsuario);

					if(imovelParaSerGerado.getHidrometroInstalacaoHistorico() != null
									&& imovelParaSerGerado.getHidrometroInstalacaoHistorico().getHidrometro() != null){
						gerarDadosParaLeituraHelper.setNumeroHidrometro(imovelParaSerGerado.getHidrometroInstalacaoHistorico()
										.getHidrometro().getNumero());
					}else if(imovelParaSerGerado.getLigacaoAgua() != null
									&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
									&& imovelParaSerGerado.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro() != null){
						gerarDadosParaLeituraHelper.setNumeroHidrometro(imovelParaSerGerado.getLigacaoAgua()
										.getHidrometroInstalacaoHistorico().getHidrometro().getNumero());
					}

					// descrição do local de instalação e proteção
					Object[] dadosLocalProtecaoAgua = this.pesquisarDadosLocalProtecaoTipoLigacaoAgua(imovelParaSerGerado.getId());

					if(dadosLocalProtecaoAgua != null){
						// descrição local de armazenagem
						if(dadosLocalProtecaoAgua[0] != null){
							gerarDadosParaLeituraHelper.setLocalInstalacao("" + dadosLocalProtecaoAgua[0]);
						}
						// descrição proteção
						if(dadosLocalProtecaoAgua[1] != null){
							gerarDadosParaLeituraHelper.setProtecao("" + dadosLocalProtecaoAgua[1]);
						}

					}else{
						Object[] dadosLocalProtecaPoco = this.pesquisarDadosLocalProtecaoTipoTipoPoco(imovelParaSerGerado.getId());
						if(dadosLocalProtecaPoco != null){
							// descrição local de armazenagem
							if(dadosLocalProtecaPoco[0] != null){
								gerarDadosParaLeituraHelper.setLocalInstalacao("" + dadosLocalProtecaPoco[0]);
							}
							// descrição proteção
							if(dadosLocalProtecaPoco[1] != null){
								gerarDadosParaLeituraHelper.setProtecao("" + dadosLocalProtecaPoco[1]);
							}
						}
					}
					gerarDadosParaLeituraHelper.setDataPrevistaFaturamento(Util.formatarData(dataPrevistaAtividadeLeitura));

					// preenche os indicadores de totalização do relatório de consumidores para
					// leitura (RelatorioGerarDadosParaLeitura)
					preencherTotalizadoresRelatorioGerarDadosParaLeitura(gerarDadosParaLeituraHelper, imovelParaSerGerado, anoMesCorrente);

					Integer agrupamentoRelatorio = codigoRota.intValue() + codigoSetorComercial.intValue();

					if(!mapDadosParaLeituraPorRota.containsKey(agrupamentoRelatorio)){
						Collection<GerarDadosParaLeituraHelper> colecaoHelperRelatorio = new ArrayList<GerarDadosParaLeituraHelper>();
						colecaoHelperRelatorio.add(gerarDadosParaLeituraHelper);

						mapDadosParaLeituraPorRota.put(agrupamentoRelatorio, colecaoHelperRelatorio);
					}else{
						Collection<GerarDadosParaLeituraHelper> colecaoMapRelatorio = mapDadosParaLeituraPorRota.get(agrupamentoRelatorio);

						colecaoMapRelatorio.add(gerarDadosParaLeituraHelper);
					}

					// [SB0003] - Gerar Movimento Roteiro da Empresa
					inserirMovimentoRoteiroEmpresa(sistemaParametro, imovelParaSerGerado, anoMesCorrente, funcionalidade,
									dataPrevistaAtividadeLeitura, idGrupoFaturamentoRota);
				}
			}else{

				// [FS0005 - Verificar seleção de imóveis]
				throw new ControladorException("atencao.imovel_nao_selecionado");
			}

			EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(
							EnvioEmail.GERAR_DADOS_PARA_LEITURA_RELATORIO_LEITURA_CONVENCIONAL);

			String emailRemetente = envioEmail.getEmailRemetente();
			String tituloMensagem = envioEmail.getTituloMensagem();
			String corpoMensagem = envioEmail.getCorpoMensagem();
			String emailReceptor = envioEmail.getEmailReceptor();

			// Itera no Map , e envia mensagens por Rota
			for(Iterator iterator = mapDadosParaLeituraPorRota.keySet().iterator(); iterator.hasNext();){
				Integer idAgrupamentoMap = (Integer) iterator.next();

				// Parte que gera o relatório e envia por email
				// cria uma instância da classe do relatório
				// Monta o relatório
				RelatorioGerarDadosParaleitura relatorioGerarDadosParaleitura = new RelatorioGerarDadosParaleitura(funcionalidade
								.getProcessoIniciado().getUsuario());

				relatorioGerarDadosParaleitura.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);

				relatorioGerarDadosParaleitura.addParametro("colecaoGerarDadosParaLeituraHelper", mapDadosParaLeituraPorRota
								.get(idAgrupamentoMap));

				relatorioGerarDadosParaleitura.addParametro("indicadorExibirTotalizacoes",
								ParametroMicromedicao.P_EXIBIR_TOTALIZACOES_RELAT_CONSUMIDORES_LEITURA.executar());


				byte[] relatorioGerado = (byte[]) relatorioGerarDadosParaleitura.executar();

				try{
					File leitura = new File("gsan.PDF");
					FileOutputStream out = new FileOutputStream(leitura.getAbsolutePath());
					out.write(relatorioGerado);
					out.flush();
					out.close();

					ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, emailRemetente, tituloMensagem, corpoMensagem, leitura);

					// leitura.delete();
				}catch(IOException e){
					e.printStackTrace();
					// throw new ControladorException("erro.sistema", e);
				}catch(Exception e){
					throw new ControladorException("erro.sistema", e);
				}

			}

			// atualiza a data e a hora da realização da atividade com a data e
			// a hora correntes
			try{

				repositorioMicromedicao.atualizarFaturamentoAtividadeCronograma(idGrupoFaturamentoRota, anoMesCorrente);

			}catch(ErroRepositorioException e){
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}

			// Encerra a unidade de Faturamento
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){ // Este catch serve para interceptar

			// qualquer exceção que o processo batch
			// venha a lançar e garantir que a unidade
			// de processamento do batch será atualizada
			// com o erro ocorrido

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}

	}

	/**
	 * [UC00083] Gerar Dados para Leitura
	 * 
	 * @param Imovel
	 * @return true se eh valido,false se não for
	 * @author eduardo henrique
	 * @throws ControladorException
	 *             se pesquisa de Situações de Faturamento falhar
	 * @date 09/12/2008
	 *       Override do método padrão para geração de Imóveis para Leitura baseado nas regras de
	 *       ADA.
	 * @throws ControladorException
	 */
	protected boolean validarImovelGerarDadosLeitura(Imovel imovel, Integer anoMesReferencia) throws ControladorException{

		// variavel responsável para entrar em uma das 4 condicões
		// abaixo
		boolean achouImovel = false;

		// [SF0002] - Verificar situação especial de faturamento

		// caso no imovel o faturamento situação grupo seja diferente de nulo e
		// igual a leitura
		// não realizada então não seleciona o imovel caso contrario seleciona.
		if(imovel.getFaturamentoSituacaoTipo() != null){
			// Verifica se há situação especial para o Imóvel em vigência
			Collection<FaturamentoSituacaoHistorico> situacoesVigentesImovel = getControladorFaturamento()
							.pesquisarFaturamentoSituacaoHistoricoImovel(imovel.getId(), anoMesReferencia);
			if(situacoesVigentesImovel != null){ // Caso alguma situação vigente indique paralisação
				// de leitura, retorna falso
				for(FaturamentoSituacaoHistorico faturamentoSituacaoHistorico : situacoesVigentesImovel){
					if(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo() != null
									&& FaturamentoSituacaoTipo.INDICADOR_PARALIZACAO_LEITURA_NAO_REALIZADA
													.equals(faturamentoSituacaoHistorico.getFaturamentoSituacaoTipo()
																	.getIndicadorParalisacaoLeitura())){
						return false;
					}
				}
			}
		}

		// Se for ligado ou cortado então
		// Verifica se a ligação agua é diferente de nulo
		// se for verifica se o id da ligação agua é igual
		// ao id do imovel e se o id do histórico da instalação do
		// hidrometro
		// é diferente de null
		if(imovel.getLigacaoAgua() != null
						&& imovel.getLigacaoAgua().getId() != null
						&& (imovel.getLigacaoAgua().getId().equals(imovel.getId())
										&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null && imovel.getLigacaoAgua()
										.getHidrometroInstalacaoHistorico().getId() != null)){

			achouImovel = true;

		}

		if(!achouImovel){
			// Verifica se o id do hidrometro historico é diferente de
			// nulo na tabela imovel
			if(imovel.getHidrometroInstalacaoHistorico() != null && imovel.getHidrometroInstalacaoHistorico().getId() != null){

				achouImovel = true;
			}
		}

		if(!achouImovel){
			// Verifica se a situação da ligação agua é diferente de nulo
			// Se for verifica se está suprimido
			if(imovel.getLigacaoAguaSituacao() != null && imovel.getLigacaoAguaSituacao().getId() != null
							&& imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.SUPRIMIDO)){

				// verifica se o indicador de fiscalização suprimido é
				// diferente de nulo se for verifica se está ativo
				if(imovel.getRota().getIndicadorFiscalizarSuprimido() != null
								&& imovel.getRota().getIndicadorFiscalizarSuprimido().equals(Rota.INDICADOR_SUPRIMIDO_ATIVO)){

					achouImovel = true;
				}

			}
		}
		if(!achouImovel){
			// Verifica se a situação da ligação agua é diferente de
			// nulo Se for verifica se está cortado
			if((imovel.getLigacaoAguaSituacao() != null && imovel.getLigacaoAguaSituacao().getId() != null)
							&& (imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.CORTADO))){

				// Se for cortado então verifica se a ligação agua é
				// diferente de nulo
				// se for verifica se o id da ligação agua é igual ao id do
				// imovel e se o id do histórico da instalação do hidrometro
				// é null
				if(imovel.getLigacaoAgua() != null
								&& imovel.getLigacaoAgua().getId() != null
								&& (imovel.getLigacaoAgua().getId().equals(imovel.getId()) && (imovel.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico() == null || imovel.getLigacaoAgua()
												.getHidrometroInstalacaoHistorico().getId() == null))){

					// verifica se o indicador de fiscalização cortado é
					// diferente de nulo se for verifica se está ativo
					if(imovel.getRota().getIndicadorFiscalizarCortado() != null
									&& imovel.getRota().getIndicadorFiscalizarCortado().equals(Rota.INDICADOR_CORTADO_ATIVO)){

						achouImovel = true;
					}
				}

			}
		}

		return achouImovel;
	}

	public Collection pesquisarHidrometroProtecaoPorDescricaoAbreviada(String protecao) throws ControladorException{

		Collection retorno = null;
		try{
			retorno = repositorioMicromedicao.pesquisarHidrometroProtecaoPorDescricaoAbreviada(protecao);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos.
	 * Permite consistir um conjunto de leituras e anormalidades e calcular os consumos para
	 * faturamento.
	 * 
	 * @author eduardo henrique
	 * @date 03/10/2008
	 */
	public void consistirLeiturasCalcularConsumosBatch(FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro,
					Collection<Rota> colecaoRotas, int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
						((Rota) Util.retonarObjetoDeColecao(colecaoRotas)).getId());

		try{
			Iterator rotasIterator = colecaoRotas.iterator();
			while(rotasIterator.hasNext()){

				Rota rota = (Rota) rotasIterator.next();

				// Criação dos objetos
				Imovel imovel = null;

				// Criação das coleções
				Collection colecaoImoveis = null;
				Object[] arrayImovel = null;

				/*
				 * O sistema seleciona os imóveis pertencentes as rotas da lista recebida, a partir
				 * das tabelas IMOVEL e ROTA
				 */
				colecaoImoveis = repositorioMicromedicao.pesquisarImoveisParaFaturamento(rota, sistemaParametro.getAnoMesFaturamento());

				if(!Util.isVazioOrNulo(colecaoImoveis)){

					Iterator iteratorColecaoImoveis = colecaoImoveis.iterator();
					while(iteratorColecaoImoveis.hasNext()){

						arrayImovel = (Object[]) iteratorColecaoImoveis.next();
						imovel = obterImovelLigadoCortadoAguaLigadoEsgoto(arrayImovel);

						EsferaPoder esferaPoder = null;

						if(arrayImovel[26] != null){

							esferaPoder = new EsferaPoder();
							esferaPoder.setId((Integer) arrayImovel[26]);
						}

						// Monta a quadra/Rota para ser utilizado na consistência
						if(imovel.getQuadra() == null){

							Quadra quadra = new Quadra();
							imovel.setQuadra(quadra);
						}

						imovel.getQuadra().setRota(rota);
						imovel.setRota(rota);

						// Chamada do Método novo consistir
						this.consistirLeiturasCalcularConsumos(imovel, faturamentoGrupo, sistemaParametro, esferaPoder);
					}

				}
			}

			// -----------------------------------------------------
			// Registrar o fim da execução da Unidade de Processamento
			// -----------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){

			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido

			e.printStackTrace();
			// sessionContext.setRollbackOnly();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * Método utilizado para obter dados do imóvel ligado ou cortado de água ou
	 * ligado de esgoto
	 */
	public Imovel obterImovelLigadoCortadoAguaLigadoEsgoto(Object[] arrayImovel){

		// Cria objetos
		Imovel imovel = new Imovel();
		LigacaoAgua ligacaoAgua = new LigacaoAgua();
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = new HidrometroInstalacaoHistorico();
		Hidrometro hidrometro = new Hidrometro();
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = new FaturamentoSituacaoTipo();
		PocoTipo pocoTipo = new PocoTipo();
		LigacaoAguaSituacao ligacaoAguaSituacao = new LigacaoAguaSituacao();
		LigacaoEsgotoSituacao ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
		LigacaoEsgoto ligacaoEsgoto = new LigacaoEsgoto();
		ConsumoTarifa consumoTarifa = new ConsumoTarifa();

		// Se existe ligação de água
		if(arrayImovel[3] != null){
			ligacaoAgua.setId((Integer) arrayImovel[3]);

			// Seta o consumo mínimo de água da ligação de água
			if(arrayImovel[12] != null){
				ligacaoAgua.setNumeroConsumoMinimoAgua((Integer) arrayImovel[12]);
			}

			// Seta a data de corte
			if(arrayImovel[36] != null){
				ligacaoAgua.setDataCorte((Date) arrayImovel[36]);
			}

			// Se existe hidrômetro instalado na ligação de água
			if(arrayImovel[4] != null){
				hidrometroInstalacaoHistorico.setId((Integer) arrayImovel[4]);

				// Seta a data de instalação do hidrômetro
				if(arrayImovel[18] != null){
					hidrometroInstalacaoHistorico.setDataInstalacao((Date) arrayImovel[18]);
				}

				// seta O Indicador de substituição da instalação
				if(arrayImovel[29] != null){
					hidrometroInstalacaoHistorico.setIndicadorInstalcaoSubstituicao((Short) arrayImovel[29]);
				}

				// Seta o hidrômetro
				if(arrayImovel[5] != null){
					hidrometro.setId((Integer) arrayImovel[5]);
					hidrometroInstalacaoHistorico.setHidrometro(hidrometro);
				}

				// Seta o hidrômetro instalação histórico na ligação de água
				ligacaoAgua.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);

				// Seta o número de digitos da leitura (esse valor será
				// usado no UC calcularFaixaLeituraEsperada)
				if(arrayImovel[6] != null){
					hidrometro.setNumeroDigitosLeitura((Short) arrayImovel[6]);
				}

				// Hidrômetro capacidade
				if(arrayImovel[32] != null){
					HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
					hidrometroCapacidade.setId((Integer) arrayImovel[32]);

					if(arrayImovel[33] != null){
						hidrometroCapacidade.setCodigoHidrometroCapacidade((String) arrayImovel[33]);
					}

					hidrometro.setHidrometroCapacidade(hidrometroCapacidade);
				}
			}
		}

		// Se existe ligação de esgoto
		if(arrayImovel[16] != null){
			ligacaoEsgoto.setId((Integer) arrayImovel[16]);

			// Seta o consumo mínimo de ligação de esgoto
			if(arrayImovel[17] != null){
				ligacaoEsgoto.setConsumoMinimo((Integer) arrayImovel[17]);
			}

			// Seta o percentual de coleta de ligação do esgoto
			if(arrayImovel[20] != null){
				ligacaoEsgoto.setPercentualAguaConsumidaColetada((BigDecimal) arrayImovel[20]);
			}

		}
		// Seta faturamento situacao tipo
		if(arrayImovel[7] != null){
			faturamentoSituacaoTipo.setId((Integer) arrayImovel[7]);
			// Seta o indicador de faturamento paralisação
			if(arrayImovel[14] != null){
				faturamentoSituacaoTipo.setIndicadorParalisacaoFaturamento((Short) arrayImovel[14]);
			}

			// Seta o indicador de validade de água
			if(arrayImovel[24] != null){
				faturamentoSituacaoTipo.setIndicadorValidoAgua((Short) arrayImovel[24]);
			}

			// Seta o indicador de validade de esgoto
			if(arrayImovel[25] != null){
				faturamentoSituacaoTipo.setIndicadorValidoEsgoto((Short) arrayImovel[25]);
			}

			// seta o indicador de Faturamento de paralisação de Esgoto
			if(arrayImovel[31] != null){
				faturamentoSituacaoTipo.setIndicadorFaturamentoParalisacaoEsgoto((Short) arrayImovel[31]);
			}

			imovel.setFaturamentoSituacaoTipo(faturamentoSituacaoTipo);
		}

		// Seta o tipo do poço
		if(arrayImovel[8] != null){
			pocoTipo.setId((Integer) arrayImovel[8]);
			imovel.setPocoTipo(pocoTipo);
		}

		// Seta o indicador imóvel condomínio
		if(arrayImovel[13] != null){
			imovel.setIndicadorImovelCondominio((Short) arrayImovel[13]);
		}

		// Seta o consumo tipo
		if(arrayImovel[19] != null){
			consumoTarifa.setId((Integer) arrayImovel[19]);
			imovel.setConsumoTarifa(consumoTarifa);
		}

		// Seta o indicador débito conta
		if(arrayImovel[15] != null){
			imovel.setIndicadorDebitoConta((Short) arrayImovel[15]);
		}

		if(arrayImovel[1] != null){
			ligacaoAguaSituacao.setId((Integer) arrayImovel[1]);
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		}

		if(arrayImovel[27] != null){
			ligacaoAguaSituacao.setIndicadorFaturamentoSituacao((Short) arrayImovel[27]);
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		}

		if(arrayImovel[62] != null){
			ligacaoAguaSituacao.setIndicadorAjusteConsumo((Short) arrayImovel[62]);
			imovel.setLigacaoAguaSituacao(ligacaoAguaSituacao);
		}

		if(arrayImovel[2] != null){
			ligacaoEsgotoSituacao.setId((Integer) arrayImovel[2]);
			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
		}

		if(arrayImovel[28] != null){
			ligacaoEsgotoSituacao.setIndicadorFaturamentoSituacao((Short) arrayImovel[28]);
			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
		}

		if(arrayImovel[61] != null){
			ligacaoEsgotoSituacao.setIndicadorAjusteConsumo((Short) arrayImovel[61]);
			imovel.setLigacaoEsgotoSituacao(ligacaoEsgotoSituacao);
		}

		if(arrayImovel[21] != null){
			imovel.setQuantidadeEconomias((Short) arrayImovel[21]);
		}

		if(arrayImovel[9] != null){

			HidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoPoco = new HidrometroInstalacaoHistorico();
			hidrometroInstalacaoHistoricoPoco.setId((Integer) arrayImovel[9]);

			// Seta a data de instalação do hidrômetro
			if(arrayImovel[23] != null){
				hidrometroInstalacaoHistoricoPoco.setDataInstalacao((Date) arrayImovel[23]);
			}

			// seta O Indicador de substituição da instalação
			if(arrayImovel[30] != null){
				hidrometroInstalacaoHistorico.setIndicadorInstalcaoSubstituicao((Short) arrayImovel[30]);
			}

			// Seta o hidrômetro
			Hidrometro hidrometroPoco = null;
			if(arrayImovel[10] != null){

				hidrometroPoco = new Hidrometro();
				hidrometroPoco.setId((Integer) arrayImovel[10]);

				// Seta o número de digitos da leitura (esse valor será
				// usado no UC calcularFaixaLeituraEsperada)
				if(arrayImovel[22] != null){
					hidrometroPoco.setNumeroDigitosLeitura((Short) arrayImovel[22]);
				}

				// Hidrômetro capacidade
				if(arrayImovel[34] != null){
					HidrometroCapacidade hidrometroCapacidade = new HidrometroCapacidade();
					hidrometroCapacidade.setId((Integer) arrayImovel[34]);

					if(arrayImovel[35] != null){
						hidrometroCapacidade.setCodigoHidrometroCapacidade((String) arrayImovel[35]);
					}

					hidrometroPoco.setHidrometroCapacidade(hidrometroCapacidade);
				}
			}

			hidrometroInstalacaoHistoricoPoco.setHidrometro(hidrometroPoco);

			imovel.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistoricoPoco);
		}

		// Seta o id do imóvel
		imovel.setId((Integer) arrayImovel[0]);
		// Seta a ligação de água
		if(ligacaoAgua.getId() != null){
			imovel.setLigacaoAgua(ligacaoAgua);
		}
		// Seta a ligacao de esgoto
		if(ligacaoEsgoto.getId() != null){
			imovel.setLigacaoEsgoto(ligacaoEsgoto);
		}
		return imovel;

	}

	// /**
	// * [UC0101] - Consistir Leituras e Calcular Consumos
	// *
	// * @author eduardo henrique
	// * @date 03/10/2008
	// * Alteração para método receber coleção de imóveis e consistir/calcular seus consumos.
	// * Rota do imóvel deve vir populada para funcionamento correto.
	// */
	// public void consistirLeiturasCalcularConsumos(Imovel imovelRota, FaturamentoGrupo
	// faturamentoGrupo, SistemaParametro sistemaParametro,
	// EsferaPoder esferaPoder) throws ControladorException{
	//
	// try{
	// if(imovelRota != null){
	//
	// if("1023640".equals(imovelRota.getId().toString()) ||
	// "1023721".equals(imovelRota.getId().toString())){
	// System.out.println("IMOVEL = " + imovelRota.getId());
	// }
	//
	// // Criação das coleções que serão usadas para persistir
	// Collection colecaoInserirMedicaoHistoricoAgua = new ArrayList();
	// Collection colecaoAtualizarMedicaoHistoricoAgua = new ArrayList();
	// Collection colecaoInserirConsumoHistoricoAgua = new ArrayList();
	//
	// Collection colecaoInserirMedicaoHistoricoEsgoto = new ArrayList();
	// Collection colecaoAtualizarMedicaoHistoricoEsgoto = new ArrayList();
	// Collection colecaoInserirConsumoHistoricoEsgoto = new ArrayList();
	//
	// // *******IMPRESSÃO EM TELA PARA TESTE********//
	// // System.out.println("---consistirLeiturasCalcularConsumos...-> Imovel ID: " +
	// // imovelRota.getId());
	// // System.out.println("Indicador faturamento água...-> " +
	// // imovelRota.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao());
	// // System.out.println("Indicador faturamento esgoto...-> " +
	// // imovelRota.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao());
	//
	// Integer idConta = (Integer)
	// this.getControladorImovel().pesquisarImovelIdComConta(imovelRota.getId(),
	// sistemaParametro.getAnoMesFaturamento());
	//
	// // CASO NÃO EXISTA CONTA PARA O IMÓVEL NO ANO/MÊS DE REFERÊNCIA
	// if(idConta == null || idConta.equals("")){
	//
	// /*
	// * Alterado por Raphael Rossiter em 17/09/2007 (Analistas: Aryed Lins e Eduardo
	// * Borges)
	// * OBJ: Apagar apenas o consumo dos imóveis que não tenham contas geradas para o
	// * anoMesfaturamento
	// */
	//
	// // Deleta os consumos históricos existentes na base para a rota no ano mês de
	// // faturamento.
	// repositorioMicromedicao.deletarConsumoHistoricoCondominioRETIRAR(imovelRota.getId(),
	// sistemaParametro
	// .getAnoMesFaturamento().intValue());
	//
	// repositorioMicromedicao.deletarConsumoHistoricoRETIRAR(imovelRota.getId(),
	// sistemaParametro.getAnoMesFaturamento()
	// .intValue());
	//
	// // Alterado por Sávio Luiz Data:21/11/2007 Analista:Aryed Lins
	// // Se o mês de faturamento for igual a 11 e o indicador faturamento antecipado
	// // for igual a 1,
	// // então seta o mes de faturamento igual a 12 para deletar os consumos
	// // historicos.
	// if(Util.obterMes(sistemaParametro.getAnoMesFaturamento()) == 11){
	//
	// if(sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){
	//
	// Integer anoMesReferenciaFaturamentoAntecipado =
	// Util.somarData(sistemaParametro.getAnoMesFaturamento());
	//
	// // Deleta os consumos históricos existentes na base para a rota no ano
	// // mês de faturamento.
	// repositorioMicromedicao.deletarConsumoHistoricoCondominioRETIRAR(imovelRota.getId(),
	// anoMesReferenciaFaturamentoAntecipado);
	//
	// repositorioMicromedicao.deletarConsumoHistoricoRETIRAR(imovelRota.getId(),
	// anoMesReferenciaFaturamentoAntecipado);
	// }
	// }
	//
	// // [UC0068] - Obter Consumo Médio do Imóvel
	// int[] consumoMedioImovel = this.obterConsumoMedioImovel(imovelRota, sistemaParametro);
	//
	// // [UC0105] - Obter Consumo Mínimo da Ligação
	// int consumoMinimoLigacao = this.obterConsumoMinimoLigacao(imovelRota, null);
	//
	// // Obtém Quantidade de Economias
	// int quantidadeEconomias = imovelRota.getQuantidadeEconomias();
	//
	// // *******IMPRESSÃO EM TELA PARA TESTE********//
	// // System.out.println("---Consumo médio imovel: " + consumoMedioImovel[0]);
	// // System.out.println("---Quantidade economias: " + quantidadeEconomias);
	//
	// // Cria o objeto histórico de medição e histórico de consumos
	// MedicaoHistorico medicaoHistorico = null;
	// ConsumoHistorico consumoHistoricoAgua = null;
	// ConsumoHistorico consumoHistoricoEsgoto = null;
	//
	// LigacaoTipo ligacaoTipo = new LigacaoTipo();
	//
	// // Obtém a situação da ligacao de água
	// /*
	// * int ligacaoAguaSituacao = imovel
	// * .getLigacaoAguaSituacao().getId()
	// * .intValue();
	// */
	//
	// Short ligacaoAguaSituacaoIndicadorFaturamento =
	// imovelRota.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao();
	//
	// // Obtém a situação da ligacao de esgoto
	// /*
	// * int ligacaoEsgotoSituacao = imovel
	// * .getLigacaoEsgotoSituacao().getId()
	// * .intValue();
	// */
	//
	// // Obtém a situação da ligacao de esgoto
	// Short ligacaoEsgotoSituacaoIndicadorFaturamento = imovelRota.getLigacaoEsgotoSituacao()
	// .getIndicadorFaturamentoSituacao();
	//
	// // CASO O IMÓVEL SEJA LIGADO OU CORTADO DE ÁGUA
	// if(ligacaoAguaSituacaoIndicadorFaturamento.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){
	//
	// ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);
	//
	// consumoHistoricoAgua = new ConsumoHistorico();
	// consumoHistoricoAgua.setRota(imovelRota.getQuadra().getRota());
	// consumoHistoricoAgua.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
	//
	// // [SF0001] - Determinar Dados para Faturamento de Água (Para cada imóvel
	// // selecionado)
	// this.determinarDadosFaturamentoAgua(medicaoHistorico, consumoHistoricoAgua, imovelRota,
	// faturamentoGrupo,
	// sistemaParametro, consumoMedioImovel, quantidadeEconomias, imovelRota.getQuadra().getRota(),
	// colecaoInserirMedicaoHistoricoAgua, colecaoAtualizarMedicaoHistoricoAgua,
	// colecaoInserirConsumoHistoricoAgua, esferaPoder, consumoMinimoLigacao);
	// }
	//
	// // CASO O IMÓVEL SEJA LIGADO DE ESGOTO
	// if(ligacaoEsgotoSituacaoIndicadorFaturamento.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)){
	//
	// ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
	//
	// consumoHistoricoEsgoto = new ConsumoHistorico();
	// consumoHistoricoEsgoto.setRota(imovelRota.getQuadra().getRota());
	// consumoHistoricoEsgoto.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());
	//
	// // [SF0002] - Determinar Dados para Faturamento de Esgoto
	// this.determinarDadosFaturamentoEsgoto(imovelRota, consumoMedioImovel, consumoHistoricoEsgoto,
	// consumoHistoricoAgua,
	// quantidadeEconomias, sistemaParametro, imovelRota.getQuadra().getRota(),
	// colecaoInserirConsumoHistoricoEsgoto, faturamentoGrupo, colecaoInserirMedicaoHistoricoEsgoto,
	// colecaoAtualizarMedicaoHistoricoEsgoto, esferaPoder, consumoMinimoLigacao);
	// }
	// }
	//
	// // System.out.println("Atualizar coleção medição água...: " +
	// // colecaoAtualizarMedicaoHistoricoAgua.size());
	// // System.out.println("Atualizar coleção medição esgoto...: " +
	// // colecaoAtualizarMedicaoHistoricoEsgoto.size());
	//
	// // System.out.println("Atualizar coleção consumo água...: " +
	// // colecaoInserirConsumoHistoricoAgua.size());
	// // System.out.println("Atualizar coleção consumo esgoto...: " +
	// // colecaoInserirConsumoHistoricoEsgoto.size());
	//
	// this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirMedicaoHistoricoAgua);
	// this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoAtualizarMedicaoHistoricoAgua);
	// this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirConsumoHistoricoAgua);
	//
	// this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirMedicaoHistoricoEsgoto);
	// this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoAtualizarMedicaoHistoricoEsgoto);
	// this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirConsumoHistoricoEsgoto);
	// }
	//
	// }catch(Exception e){
	// // Este catch serve para interceptar qualquer exceção que o processo
	// // batch venha a lançar e garantir que a unidade de processamento do
	// // batch será atualizada com o erro ocorrido
	//
	// e.printStackTrace();
	// // sessionContext.setRollbackOnly();
	// throw new ControladorException("erro.sistema", e);
	// }
	// }

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SF0001] - Determinar Dados para Faturamento de Água
	 * 
	 * @author eduardo henrique
	 * @date 12/12/2008
	 * @author Saulo Lima
	 * @date 29/12/2008
	 *       Ajuste para não cobrar o mínimo dos imóveis "não fatuáveis" sem consumo
	 *       Alteração para reinicialização do Crédito de Consumo Gerado, caso existe dados
	 *       anteriores.
	 *       Alteração para ajuste do Consumo Mínimo da Ligação para utilizar
	 * @author eduardo henrique
	 * @date 17/01/2008
	 *       Alteração na forma de obtenção do valor do Mínimo de Ligação do Imóvel.
	 * @author eduardo henrique
	 * @date 30/01/2009
	 *       Correção na atribuição de Tipo de Consumo e Anormalidade após verificação do mínimo de
	 *       Ligação.
	 * @author eduardo henrique
	 * @date 14/02/2009
	 *       Alteracao para Baixo Consumo ser verificado independente da indicacao de Poco
	 */
	protected void determinarDadosFaturamentoAgua(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico, Imovel imovel,
					FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro, int[] consumoMedioImovel,
					int quantidadeEconomias, Rota rota, Collection colecaoInserirMedicaoHistoricoAgua,
					Collection colecaoAtualizarMedicaoHistoricoAgua, Collection colecaoInserirConsumoHistoricoAgua,
					EsferaPoder esferaPoder, int consumoMinimoLigacao) throws ControladorException{

		medicaoHistorico = new MedicaoHistorico();

		// Seta a referência de faturamento
		consumoHistorico.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());

		// Define a medição tipo como água
		MedicaoTipo medicaoTipo = new MedicaoTipo();
		medicaoTipo.setId(MedicaoTipo.LIGACAO_AGUA);

		/*
		 * Caso o imóvel possua hidrômetro na ligação de água.o sistema determina os dados para
		 * faturamento de água do medido [SB0003 – Determinar Dados para Faturamento de Água do
		 * Medido].
		 */
		if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){

			medicaoHistorico = this.determinarDadosFaturamentoAguaMedido(consumoHistorico, imovel, faturamentoGrupo, sistemaParametro,
							consumoMedioImovel, quantidadeEconomias, rota, consumoMinimoLigacao, medicaoTipo);

		}else{

			/*
			 * Verificar se a Situação da ligação de água (LAST_ID da tabela IMOVEL) ocorre em algum
			 * dos valores da lista (posições pares com tamanho de 2) ( PASI_VLPARAMETRO da tabela
			 * PARAMETRO_SISTEMA com PASI_CDPARAMETRO = "P_SIT_LIGAGUA_VERIFICA_CONSUMO_FATURAVEL").
			 * Caso a Situação de ligação de água seja localizada na lista, não será registrado
			 * nenhum Dado para Faturamento de Água (tabela MEDICAO_HISTORICO e CONSUMO_HISTORICO),
			 * retornar ao fluxo principal
			 */
			Map<Integer, Integer> situacoes = obterSituacaoLigacaoMinimoFaturavel();
			if(situacoes.containsKey(imovel.getLigacaoAguaSituacao().getId())){

				return;
			}else{

				// Caso contrário, [SB0004] - Determinar Dados para Faturamento de Água do Não
				// Medido
				this.determinarDadosFaturamentoAguaNaoMedido(consumoHistorico, imovel, consumoMedioImovel, consumoMinimoLigacao,
								sistemaParametro, medicaoHistorico);
			}
		}

		// Caso a situação da ligação de água que não permita faturamento
		if(imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.NAO_FATURAVEL)){

			/*
			 * [OC891812][UC0101][SB0003][ITEM 15.1]: Verificar se a Situação da ligação de água
			 * ocorre em algum dos valores da lista "P_SIT_LIGAGUA_VERIFICA_CONSUMO_FATURAVEL"
			 * obter o consumo minimo faturável para ligação, e calcular o consumo por economia
			 */
			Map<Integer, Integer> situacaoLigacaoXMinimoFaturavel = obterSituacaoLigacaoMinimoFaturavel();
			boolean consumoNaoFaturavel = false;

			if(situacaoLigacaoXMinimoFaturavel.containsKey(imovel.getLigacaoAguaSituacao().getId())){

				// Obtendo a quantidade de economias
				int qtdEconomias = getControladorImovel().obterQuantidadeEconomias(imovel);
				int consumoPorEconomia = 0;

				if(medicaoHistorico.getNumeroConsumoMes() != null && medicaoHistorico.getNumeroConsumoMes() > ConstantesSistema.ZERO){

					consumoPorEconomia = medicaoHistorico.getNumeroConsumoMes() / qtdEconomias;
				}

				Integer consumoMinFaturavel = situacaoLigacaoXMinimoFaturavel.get(imovel.getLigacaoAguaSituacao().getId());

				if(consumoPorEconomia <= consumoMinFaturavel.intValue()){

					consumoNaoFaturavel = true;
				}
			}

			if(consumoNaoFaturavel){

				return;
			}
		}

		/*
		 * Parâmetro para indicar se o consumo deverá ser ajustado para múltiplo da quantidade de
		 * economias
		 */
		String parametroAjustarConsumoMultiploQuantidadeEconomias = (String) ParametroFaturamento.P_AJUSTAR_CONSUMO.executar(this, 0);

		/*
		 * Caso a quantidade de economias seja maior que 1 e a empresa ajusta o consumo pela
		 * quantidade de economias
		 */
		if(quantidadeEconomias > 1
						&& parametroAjustarConsumoMultiploQuantidadeEconomias.equals(AjustarConsumoMultiploQtdeEconomias.UM.getValor())){

			// [SF0018] - Ajuste do Consumo Múltiplo da Quantidade de Economias
			this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistorico, consumoHistorico, quantidadeEconomias,
							consumoMinimoLigacao);
		}

		// Seta o funcionário
		// medicaoHistorico.setFuncionario(funcionario);
		// Seta a data de última alteração
		medicaoHistorico.setUltimaAlteracao(new Date());

		// Caso o imóvel possua hidromêtro com ligação de água
		if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){

			if(medicaoHistorico.getId() == null){
				colecaoInserirMedicaoHistoricoAgua.add(medicaoHistorico);
			}else{
				colecaoAtualizarMedicaoHistoricoAgua.add(medicaoHistorico);
			}

			int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());

			if(sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){

				// Verifica se é faturamento antecipado
				if(imovel.getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
								&& (mes == 11)
								&& esferaPoder != null
								&& esferaPoder.getId() != null
								&& (esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.MUNICIPAL))
												|| esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.ESTADUAL)) || esferaPoder.getId()
												.equals(Integer.valueOf(EsferaPoder.FEDERAL)))){

					MedicaoHistorico medicaoHistoricoPosterior = new MedicaoHistorico();

					// Adiciona 1 ao mês/ano de faturamento para gerar o mês de dezembro
					sistemaParametro.setAnoMesFaturamento(Util.somaMesAnoMesReferencia(sistemaParametro.getAnoMesFaturamento(), 1));

					medicaoHistoricoPosterior = this.obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo, sistemaParametro);

					// // [UC0102] - Obter Consumo Médio do Hidrômetro
					// int[] consumoMedioHidrometroPosterior =
					// obterConsumoMedioHidrometro(imovel,
					// sistemaParametro, medicaoTipo);

					// Retorna ao mês de referência atual
					sistemaParametro.setAnoMesFaturamento(Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(), 1));

					medicaoHistoricoPosterior.setLeituraAnormalidadeFaturamento(medicaoHistorico.getLeituraAnormalidadeFaturamento());
					medicaoHistoricoPosterior.setLeituraAnteriorFaturamento(medicaoHistorico.getLeituraAtualFaturamento());
					medicaoHistoricoPosterior.setDataLeituraAnteriorFaturamento(medicaoHistorico.getDataLeituraAtualFaturamento());

					Date dataAtual = new Date();
					medicaoHistoricoPosterior.setDataLeituraAtualFaturamento(Util.adicionarNumeroDiasDeUmaData(dataAtual, 30));

					Integer leituraAtual = medicaoHistorico.getLeituraAtualFaturamento() + consumoHistorico.getNumeroConsumoFaturadoMes();

					medicaoHistoricoPosterior.setLeituraAtualFaturamento(leituraAtual);

					// // Seta o consumo médio do hidrômetro
					// medicaoHistoricoPosterior.setConsumoMedioHidrometro(new
					// Integer(
					// consumoMedioHidrometroPosterior[0]));

					medicaoHistoricoPosterior.setConsumoMedioHidrometro(medicaoHistorico.getConsumoMedioHidrometro());

					medicaoHistoricoPosterior.setUltimaAlteracao(new Date());

					if(medicaoHistoricoPosterior.getId() == null){
						colecaoInserirMedicaoHistoricoAgua.add(medicaoHistoricoPosterior);
					}else{
						colecaoAtualizarMedicaoHistoricoAgua.add(medicaoHistoricoPosterior);
					}
				}
			}
		}

		// Seta o imóvel
		consumoHistorico.setImovel(imovel);

		// Seta a Rota
		consumoHistorico.setRota(imovel.getRota());

		// Seta o tipo de ligação
		LigacaoTipo ligacaoTipo = new LigacaoTipo();

		ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);
		consumoHistorico.setLigacaoTipo(ligacaoTipo);

		// Seta o indicador alteração últimos consumos
		consumoHistorico.setIndicadorAlteracaoUltimosConsumos(ConstantesSistema.NAO);

		// Seta o indicador ajuste
		consumoHistorico.setIndicadorAjuste(rota.getIndicadorAjusteConsumo());

		// Seta o consumo rateio
		consumoHistorico.setConsumoRateio(null);

		// Seta o consumo histórico condomínio
		consumoHistorico.setConsumoHistoricoCondominio(null);

		// Seta o indicador imóvel condomínio
		consumoHistorico.setIndicadorImovelCondominio(imovel.getIndicadorImovelCondominio());

		// Seta o consumo médio do imóvel
		consumoHistorico.setConsumoMedio(Integer.valueOf(consumoMedioImovel[0]));

		// Seta o consumo mínimo de água
		consumoHistorico.setConsumoMinimo(imovel.getLigacaoAgua() != null ? imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua() : null);

		// Seta o percentual de coleta
		// consumoHistorico.setPercentualColeta(null);

		if(imovel != null){
			Integer idLigacaoEsgoto = imovel.getId();
			BigDecimal percentualColeta = this.getControladorLigacaoEsgoto().recuperarPercentualColetaEsgoto(idLigacaoEsgoto);
			if(percentualColeta != null){
				consumoHistorico.setPercentualColeta(percentualColeta);
			}else{
				consumoHistorico.setPercentualColeta(Util.formatarMoedaRealparaBigDecimal("100"));
			}

		}else{
			consumoHistorico.setPercentualColeta(Util.formatarMoedaRealparaBigDecimal("100"));
		}

		// Seta a última alteração
		consumoHistorico.setUltimaAlteracao(new Date());

		// Seta o rateio tipo
		if(consumoHistorico.getId() == null){
			RateioTipo rateioTipo = new RateioTipo();
			rateioTipo.setId(RateioTipo.SEM_RATEIO);
			consumoHistorico.setRateioTipo(rateioTipo);
		}
		// Seta o poco tipo
		consumoHistorico.setPocoTipo(imovel.getPocoTipo());

		// Seta o faturamento situação tipo
		consumoHistorico.setFaturamentoSituacaoTipo(imovel.getFaturamentoSituacaoTipo());

		/*
		 * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson
		 * Carvalho Seta o indicador de faturamento paralisação
		 */
		if(imovel.getFaturamentoSituacaoTipo() == null){
			consumoHistorico.setIndicadorFaturamento(Short.valueOf("1"));
		}else if(imovel.getFaturamentoSituacaoTipo().getIndicadorParalisacaoFaturamento().intValue() == 1
						&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue() == 1){
			consumoHistorico.setIndicadorFaturamento(Short.valueOf("2"));
		}else{
			consumoHistorico.setIndicadorFaturamento(Short.valueOf("1"));
		}

		colecaoInserirConsumoHistoricoAgua.add(consumoHistorico);

		int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());

		if(sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){

			// Verifica se é faturamento antecipado
			if(imovel.getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
							&& (mes == 11)
							&& esferaPoder != null
							&& esferaPoder.getId() != null
							&& (esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.MUNICIPAL))
											|| esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.ESTADUAL)) || esferaPoder.getId()
											.equals(Integer.valueOf(EsferaPoder.FEDERAL)))){

				ConsumoHistorico consumoHistoricoPosterior = new ConsumoHistorico(consumoHistorico);

				consumoHistoricoPosterior.setReferenciaFaturamento(Util.somaMesAnoMesReferencia(
								consumoHistorico.getReferenciaFaturamento(), 1));

				consumoHistoricoPosterior.setUltimaAlteracao(new Date());

				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

				consumoAnormalidade.setId(ConsumoAnormalidade.FATURAMENTO_ANTECIPADO);

				consumoHistoricoPosterior.setConsumoAnormalidade(consumoAnormalidade);

				colecaoInserirConsumoHistoricoAgua.add(consumoHistoricoPosterior);
			}
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0007] - Dados para Faturamento para Leitura Maior que a Anterior
	 * 
	 * @date 19/03/2012
	 * @throws ControladorException
	 */
	protected void dadosFaturamentoLeituraMaiorAnterior(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico,
					int consumoMedioHidrometro, Imovel imovel, SistemaParametro sistemaParametro, int leituraAnterior)
					throws ControladorException{

		/*
		 * O sistema calcula o Consumo Medido do Mês e o Consumo a Ser Cobrado no Mês pela diferença
		 * entre a Leitura Atual Informada e Leitura Anterior Obtida
		 */
		int consumoMedidoCobradoMes = medicaoHistorico.getLeituraAtualInformada() - leituraAnterior;

		medicaoHistorico.setNumeroConsumoMes(Integer.valueOf(consumoMedidoCobradoMes));
		consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedidoCobradoMes));

		medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

		// Seta o consumo tipo no consumo histórico
		consumoHistorico.setConsumoTipo(this.definirConsumoTipoLeituraImovel(medicaoHistorico, null));

		// O sistema verifica se é um hidrômetro novo
		String parametroHidrometoNovo = (String) ParametroMicromedicao.P_HIDROMETRO_NOVO.executar(this, 0);

		Date dataInstalacao = null;
		Date dataLeituraAnterior = medicaoHistorico.getDataLeituraAnteriorFaturamento();

		if(medicaoHistorico.getMedicaoTipo().getId().intValue() == MedicaoTipo.POCO){

			dataInstalacao = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();
		}else{
			dataInstalacao = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();
		}

		Date dataLeituraAtualInformada = medicaoHistorico.getDataLeituraAtualInformada();

		// Caso o valor indique Data de Instalação igual à Data de Leitura
		if(parametroHidrometoNovo.equals(HidrometroNovo.DOIS.getValor())){

			if(dataInstalacao.compareTo(dataLeituraAnterior) == 0){
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				consumoAnormalidade.setId(ConsumoAnormalidade.HIDROMETRO_NOVO);
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
			}
		}else if(parametroHidrometoNovo.equals(HidrometroNovo.UM.getValor())){

			// Caso o valor indique Quantidade de dias de consumo
			String parametroQtdDiasHidrometoNovo = (String) ParametroMicromedicao.P_QTD_DIAS_HIDROMETRO_NOVO.executar(this, 0);

			int diferencaDiasInstalacaoELeituraAtual = Util.obterQuantidadeDiasEntreDuasDatas(dataInstalacao, dataLeituraAtualInformada);

			/*
			 * Caso diferença de dias entre HIDI_DTINSTALACAOHIDROMETRO da tabela
			 * HIDROMETRO_INSTALACAO_HISTORICO e a data da leitura atual seja menor que a
			 * quantidade de dias parametrizada
			 */
			if(diferencaDiasInstalacaoELeituraAtual < Util.obterInteger(parametroQtdDiasHidrometoNovo)){

				/*
				 * Indicador se é para faturar o consumo normal para os imóveis que tiveram
				 * instalação
				 * ou substituição menor que P_QTD_DIAS_HIDROMETRO_NOVO
				 */
				short indicadorConsumoNormalInstalacaoHidrometro = sistemaParametro.getIndicadorConsumoNormalInstalacaoHidrometro();

				if(indicadorConsumoNormalInstalacaoHidrometro == ConstantesSistema.SIM.shortValue()){

					consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(0));
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.REAL));
				}
			}
		}

		/* Parametro que indica se deve ser verificado a leitura está fora da faixa esperada. */
		String parametroVerificarLeituraForaFaixa = (String) ParametroMicromedicao.P_VERIFICA_LEITURA_FORA_FAIXA.executar(this, 0);

		// Caso a empresa verifique consumo fora de faixa
		if(parametroVerificarLeituraForaFaixa.equals(VerificarLeituraForaFaixa.UM.getValor())){

			// [UC0086 – Calcular Faixa de Leitura Esperada]
			int[] faixaLeituraEsperada = null;
			Hidrometro hidrometro = null;

			if(medicaoHistorico.getMedicaoTipo().getId().intValue() == MedicaoTipo.POCO){

				hidrometro = imovel.getHidrometroInstalacaoHistorico().getHidrometro();
			}else{

				hidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro();
			}

			faixaLeituraEsperada = this.calcularFaixaLeituraEsperada(consumoMedioHidrometro, medicaoHistorico, hidrometro, null);

			// Caso a leitura atual informada esteja fora da faixa de leitura esperada
			if(medicaoHistorico.getLeituraAtualInformada().intValue() < faixaLeituraEsperada[0]
							|| medicaoHistorico.getLeituraAtualInformada().intValue() > faixaLeituraEsperada[1]){

				/*
				 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “consumo
				 * fora de faixa”
				 */
				consumoHistorico.setConsumoAnormalidade(new ConsumoAnormalidade(ConsumoAnormalidade.FORA_FAIXA));
			}
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SF0008] - Dados para Faturamento para Leitura Igual que a Anterior
	 * 
	 * @throws ControladorException
	 * @author Saulo Lima, Anderson Italo
	 * @date 29/12/2008, 19/03/2012
	 */
	protected void dadosFaturamentoLeituraIgualAnterior(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico,
					MedicaoTipo medicaoTipo, Imovel imovel, ConsumoHistorico consumoHistoricoAgua, FaturamentoGrupo faturamentoGrupo,
					SistemaParametro sistemaParametro, int consumoMinimoLigacao, int consumoMedioImovel) throws ControladorException{

		// O consumo medido do mês será zero
		medicaoHistorico.setNumeroConsumoMes(0);

		// Parametro que indica valor atribuído ao consumo do mês quando for definida a cobrança de
		// mínimo na consistência de leitura
		String parametroCobrancaConsumoMinimo = (String) ParametroMicromedicao.P_COBRANCA_CONSUMO_MINIMO.executar(this, 0);

		// Consumo a Ser Cobrado será o consumo mínimo da ligação, caso ativo
		if(imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

			// Caso seja para tratar mínimo com valor zero (0)
			if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.DOIS.getValor())){

				consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
			}else if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.UM.getValor())){

				/*
				 * Caso contrário, o Consumo a Ser Cobrado no Mês será o mínimo da ligação
				 * <<Inclui>>
				 * [UC0105 – Obter Consumo Mínimo da Ligação]
				 */
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
			}
		}else{

			consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
		}

		/*
		 * Caso a Situação da Leitura Anterior esteja com o valor correspondente a “realizada” ou
		 * “confirmada” na tabela LEITURA_SITUACAO, o Tipo de Consumo será o valor correspondente a
		 * “real” na tabela CONSUMO_TIPO
		 */
		consumoHistorico.setConsumoTipo(this.definirConsumoTipoLeituraImovel(medicaoHistorico, null));

		// A leitura atual faturada será igual a leitura atual informada
		medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

		/*
		 * Parametro que indica quantidade de meses que a leitura deve se repetir para indicar
		 * leitura igual a anterior, considerando a leitura atual
		 */
		String parametroQtdMesesLeituraIgual = (String) ParametroMicromedicao.P_QTD_MESES_LEITURA_IGUAL.executar(this, 0);

		// Verifica repetição de leitura de acordo coma quantidade de mêses parametrizada
		int periodoInformado = Util.obterInteger(parametroQtdMesesLeituraIgual);

		if(faturamentoGrupo == null || faturamentoGrupo.getAnoMesReferencia() == null){

			throw new ControladorException("erro.parametros_obrigatorios_faturamento_nao_informados");
		}

		faturamentoGrupo.getAnoMesReferencia();

		Collection colecaoMedicaoHistorico = null;

		try{

			int anoMesReferencia = Util.somarData(faturamentoGrupo.getAnoMesReferencia());

			LigacaoTipo ligacaoTipo = new LigacaoTipo();

			if(MedicaoTipo.LIGACAO_AGUA.equals(medicaoTipo.getId())){

				ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);
				colecaoMedicaoHistorico = repositorioMicromedicao.pesquisarConsumoMedidoHidrometroPeriodoInformadoLigacaoAgua(imovel,
								anoMesReferencia, periodoInformado, ligacaoTipo);
			}else if(MedicaoTipo.POCO.equals(medicaoTipo.getId())){

				ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
				colecaoMedicaoHistorico = repositorioMicromedicao.pesquisarConsumoMedidoHidrometroPeriodoInformadoPoco(imovel,
								anoMesReferencia, periodoInformado);
			}

		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		// Verifica se existe registro em histórico de medição para o período parametrizado
		if(!Util.isVazioOrNulo(colecaoMedicaoHistorico)){

			boolean leiturarRepetida = true;

			Iterator<Object[]> colecaoMedicaoHistoricoIterator = colecaoMedicaoHistorico.iterator();

			/*
			 * Percorre os registros do histórico de medição para verificar se houve repetição de
			 * leitura para os últimos mêses.
			 */
			while(colecaoMedicaoHistoricoIterator.hasNext()){

				Object[] medicaoHistoricoArray = (Object[]) colecaoMedicaoHistoricoIterator.next();

				Integer leituraAtualInformada = ConstantesSistema.NUMERO_NAO_INFORMADO;

				if(medicaoHistoricoArray[7] != null){

					leituraAtualInformada = (Integer) medicaoHistoricoArray[7];
				}

				if(!leituraAtualInformada.equals(medicaoHistorico.getLeituraAtualInformada())){

					leiturarRepetida = false;
					break;
				}
			}

			// Caso a Leitura Atual Informada tenha se repetido nos últimos meses
			if(leiturarRepetida){

				// Gera a Anormalidade de Consumo com o valor correspondente a “Leitura Igual”
				ConsumoAnormalidade consumoAnormalidade = null;
				try{

					consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.LEITURA_IGUAL_ANTERIOR);
				}catch(ErroRepositorioException ex){

					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

				// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
				this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico, consumoMedioImovel,
								consumoMinimoLigacao, consumoAnormalidade, consumoHistorico.getNumeroConsumoFaturadoMes());
				
				Short criterioLeituraAnormalidadeLeituraIgualAnterior = Util
								.converterStringParaShort(ParametroMicromedicao.P_CRITERIO_LEITURA_ANORMALIDADE_LEITURA_IGUAL_ANTERIOR
												.executar());

				// ############# Alterado por Luciano - OC1034808 ############# - Inicio
				// Caso a empresa verifique leitura anormalidade para leitura igual a anterior
				if(criterioLeituraAnormalidadeLeituraIgualAnterior != null
								&& criterioLeituraAnormalidadeLeituraIgualAnterior.equals(ConstantesSistema.SIM)){
					LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade(LeituraAnormalidade.LEITURA_IGUAL_ANTERIOR);
					medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
				}
				// ############# Alterado por Luciano - OC1034808 ############# - Fim
			}
		}

		// Parametro que indica a forma de verificar se é uma nova instalação de hidrômetro
		String parametroHidrometroNovo = (String) ParametroMicromedicao.P_HIDROMETRO_NOVO.executar(this, 0);
		Date dataInstalacaoHidrometro = null;
		Date dataLeituraAtual = medicaoHistorico.getDataLeituraAtualInformada();

		if(MedicaoTipo.LIGACAO_AGUA.equals(medicaoTipo.getId())){

			dataInstalacaoHidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();
		}else{

			dataInstalacaoHidrometro = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();
		}

		if(dataInstalacaoHidrometro != null && dataLeituraAtual != null){

			// Caso seja um hidrômetro novo de acordo com a forma parametrizada
			if(parametroHidrometroNovo.equals(HidrometroNovo.UM.getValor())){

				// ############# Alterado por Luciano - OC1034808 ############# - Inicio

				Short pCompararDatasParaHidrometroNovo = Util
								.converterStringParaShort(ParametroMicromedicao.P_COMPARAR_DATAS_INSTALACAO_E_LEITURA_ANTERIOR_PARA_HIDR_NOVO
												.executar());

				// A regra abaixo só será realizada se o parâmetro
				// P_COMPARAR_DATAS_INSTALACAO_E_LEITURA_ANTERIOR_PARA_HIDR_NOVO = 1 (Sim)
				if(pCompararDatasParaHidrometroNovo != null && pCompararDatasParaHidrometroNovo.equals(ConstantesSistema.SIM)){

					// Caso o valor indique Data de Instalação igual ou maior que a Data de Leitura
					// Anterior
					Date dataLeituraAnterior = medicaoHistorico.getDataLeituraAnteriorFaturamento();
					if(dataLeituraAnterior != null && dataInstalacaoHidrometro.compareTo(dataLeituraAnterior) >= 0){

						// Gerar Anormalidade de Consumo com o valor correspondente a
						// "Hidrômetro Novo"
						ConsumoAnormalidade consumoAnormalidade = null;
						try{
							consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.HIDROMETRO_NOVO);
						}catch(ErroRepositorioException ex){

							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", ex);
						}
						consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
					}
				}
				// ############# Alterado por Luciano - OC1034808 ############# - Fim

				// Quantidade de dias para identificação de hidrômetro novo
				String parametroQtdDiasHidrometroNovo = (String) ParametroMicromedicao.P_QTD_DIAS_HIDROMETRO_NOVO.executar(this, 0);
				int diferencaDiasInstalacaoLeituraAtual = Util
								.obterQuantidadeDiasEntreDuasDatas(dataInstalacaoHidrometro, dataLeituraAtual);

				if(diferencaDiasInstalacaoLeituraAtual < Util.obterInteger(parametroQtdDiasHidrometroNovo).intValue()
								&& sistemaParametro.getIndicadorConsumoNormalInstalacaoHidrometro() == ConstantesSistema.SIM.shortValue()){

					/*
					 * Consumo a Ser Cobrado no Mês será zero e o Tipo de Consumo será o valor
					 * correspondente a “real”
					 */
					consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.REAL));
				}
			}
		}

		// Caso a empresa verifique hidrômetro parado
		// Parametro que indica se irá verificar se o hidrômetro está parado quando a leitura é
		// igual anterior
		String parametroVerificaHidrometroParado = (String) ParametroMicromedicao.P_VERIFICA_HIDROMETRO_PARADO.executar(this, 0);

		if(parametroVerificaHidrometroParado.equals(VerificaHidrometroParado.UM.getValor())){

			/*
			 * Caso a Leitura Atual Informada seja maior que um e a Anormalidade de Leitura de
			 * Faturamento esteja com o valor nulo.
			 */
			if(medicaoHistorico.getLeituraAtualInformada().intValue() > 1 && medicaoHistorico.getLeituraAnormalidadeFaturamento() == null){

				// O sistema verifica se não houve consumo ou se o hidrômetro está parado.
				// Caso o tipo de medição seja ligação de água
				if(medicaoHistorico.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){

					// [SB0019 – Verificar Hidrômetro Parado para Ligação de Água
					this.verificarHidrometroParadoParaLigacaoAgua(medicaoHistorico, imovel);
				}else{

					// Caso contrário, [SB0020 – Verificar Hidrômetro Parado para Poço].
					this.verificaHidrometroParadoParaPoco(medicaoHistorico, consumoHistorico, imovel);

				}
			}
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SF0009] - Dados para Faturamento para Leitura Menor que a Anterior
	 * 
	 * @throws ControladorException
	 */
	@Deprecated
	protected void dadosFaturamentoLeituraMenorAnteriorAntigo(Imovel imovel, ConsumoHistorico consumoHistorico,
					MedicaoHistorico medicaoHistorico, SistemaParametro sistemaParametro, int leituraAnterior, MedicaoTipo medicaoTipo,
					int[] consumoMedioImovel, int[] consumoMedioHidrometro, int consumoMinimoLigacao, boolean verificarViradaHidrometro)
					throws ControladorException{

		int numeroDigitosLeitura = 0;
		Hidrometro hidrometro = null;
		Date dataInstalacao = null;

		// Identifica e armazena a data de instalação de acordo com o tipo de medição
		if(medicaoTipo.getId() == MedicaoTipo.LIGACAO_AGUA){

			// Obtém a data de instalação do hidrômetro
			dataInstalacao = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();

			// Obtém o hidrômetro
			hidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro();

			// Obtém o número de digitos da leitura
			numeroDigitosLeitura = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro().getNumeroDigitosLeitura()
							.intValue();

			// Caso seja medição de <<<POÇO>>>
		}else if(medicaoTipo.getId() == MedicaoTipo.POCO){

			// Obtém a data de instalação do hidrômetro
			dataInstalacao = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();

			// Obtém o hidrômetro
			hidrometro = imovel.getHidrometroInstalacaoHistorico().getHidrometro();

			// Obtém o número de digitos da leitura
			numeroDigitosLeitura = imovel.getHidrometroInstalacaoHistorico().getHidrometro().getNumeroDigitosLeitura().intValue();
		}

		// Criação de objetos
		ConsumoTipo consumoTipo = new ConsumoTipo();
		ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

		Double valor = new Double((Math.pow(10.0, numeroDigitosLeitura)));

		// Obtém o consumo calculado
		int consumoCalculado = (medicaoHistorico.getLeituraAtualInformada() + valor.intValue()) - leituraAnterior;

		// Obtém 2x o consumo médio do imóvel
		int duasVezesConsumoMedioImovel = (consumoMedioImovel[0] * 2);

		// Obtem 10x o consumo médio do imóvel
		int dezVezesConsumoMedioImovel = (consumoMedioImovel[0] * 10);

		// Leitura anormalidade informada
		Integer idLeituraAnormalidadeInformada = null;

		if(medicaoHistorico.getLeituraAnormalidadeInformada() != null){
			idLeituraAnormalidadeInformada = medicaoHistorico.getLeituraAnormalidadeInformada().getId();
		}

		// começa aqui!!!

		// Caso exista virada de hidrômetro
		if(!verificarViradaHidrometro && (consumoCalculado <= 200 || consumoCalculado <= duasVezesConsumoMedioImovel)
						&& (consumoCalculado > 0)){

			// O Consumo medido e cobrado no mês serão iguais ao consumo calculado

			medicaoHistorico.setNumeroConsumoMes(Integer.valueOf(consumoCalculado));
			consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoCalculado));

			// Seta a anormalidade de consumo como virada de hidrômetro
			consumoAnormalidade.setId(ConsumoAnormalidade.VIRADA_HIDROMETRO);

			consumoTipo = this.definirConsumoTipoLeituraImovel(medicaoHistorico, consumoAnormalidade);

			consumoHistorico.setConsumoTipo(consumoTipo);

			// Calcula a faixa de leitura esperada
			int[] faixaLeituraEsperada = calcularFaixaLeituraEsperada(consumoMedioHidrometro[0], medicaoHistorico, hidrometro, null);

			// Verifica se ouve virada de hidrômetro
			if(faixaLeituraEsperada[0] > faixaLeituraEsperada[1]){

				Double numeroLimite = (Math.pow(10.0, numeroDigitosLeitura) - 1);
				boolean numeroForaFaixaInicial = false;
				boolean numeroForaFaixaFinal = false;

				if(medicaoHistorico.getLeituraAtualInformada() < faixaLeituraEsperada[0]
								|| medicaoHistorico.getLeituraAtualInformada() > numeroLimite.intValue()){
					numeroForaFaixaInicial = true;
				}

				if(medicaoHistorico.getLeituraAtualInformada() > faixaLeituraEsperada[1]){
					numeroForaFaixaFinal = true;
				}

				if(numeroForaFaixaInicial && numeroForaFaixaFinal){
					// Define a anormalidade de consumo como fora da faixa
					consumoAnormalidade.setId(ConsumoAnormalidade.FORA_FAIXA);
				}

				// Faixa leitura espera [0] inicial
				// Faixa leitura esperada [1] final
			}else if(medicaoHistorico.getLeituraAtualInformada() < faixaLeituraEsperada[0]
							|| medicaoHistorico.getLeituraAtualInformada() > faixaLeituraEsperada[1]){

				// Define a anormalidade de consumo como fora da faixa
				consumoAnormalidade.setId(ConsumoAnormalidade.FORA_FAIXA);
			}
			// Verifica se ocorreu substituição de hidrômetro
			// Caso exista substituição de hidrômetro

			/*
			 * (!dataInstalacao.before(medicaoHistorico
			 * .getDataLeituraAnteriorFaturamento()) &&
			 * !dataInstalacao.after(medicaoHistorico
			 * .getDataLeituraAtualFaturamento()))
			 */

		}else if(verificarViradaHidrometro && valor > 1000 && (consumoCalculado <= 150 || consumoCalculado <= dezVezesConsumoMedioImovel)
						&& consumoCalculado > 0 && idLeituraAnormalidadeInformada == null){

			// Seta leitura atual faturamento
			int leituraAtualInformada = medicaoHistorico.getLeituraAtualInformada();
			medicaoHistorico.setLeituraAtualFaturamento(leituraAtualInformada);

			// Seta o número consumo medido mês
			medicaoHistorico.setNumeroConsumoMes(consumoCalculado);

			// Seta o consumo a ser cobrado mês
			consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);

		}else if((Util.compararData(dataInstalacao, medicaoHistorico.getDataLeituraAnteriorFaturamento()) != -1)
						&& (Util.compararData(dataInstalacao, medicaoHistorico.getDataLeituraAtualFaturamento()) != 1)){

			consumoAnormalidade.setId(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO);
			medicaoHistorico.setLeituraAnormalidadeFaturamento(null);

			int diasConsumo = (int) IoUtil.diferencaEntreDatas(dataInstalacao, medicaoHistorico.getDataLeituraAtualInformada());

			// customização v0.05
			// if (diasConsumo > 9 && diasConsumo < 60) {

			// ---------------------------------------------------------------------------------------
			// Alterado por: Yara Souza
			// Data: 25/05/2010
			// Acrescentado diasConsumo > 0 pois estava ocorrendo erro de / by zero quando data de
			// leitura igual a data da instalação hidrometro.
			// ---------------------------------------------------------------------------------------
			if(dataInstalacao != null && diasConsumo > 0){

				// Seta o número consumo medido mês
				medicaoHistorico.setNumeroConsumoMes(Integer.valueOf(medicaoHistorico.getLeituraAtualInformada()));

				// Calcula o consumo a ser cobrado no mês
				BigDecimal numerador = new BigDecimal(medicaoHistorico.getLeituraAtualInformada());
				BigDecimal denominador = new BigDecimal(diasConsumo);
				BigDecimal resultadoDivisao = numerador.divide(denominador, 3, BigDecimal.ROUND_HALF_UP);
				BigDecimal resultado = resultadoDivisao.multiply(new BigDecimal(30));
				// Seta o consumo a ser cobrado mês
				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(Util.arredondar(resultado)));

				consumoTipo.setId(ConsumoTipo.ESTIMADO);

			}else{
				medicaoHistorico.setNumeroConsumoMes(Integer.valueOf(medicaoHistorico.getLeituraAtualInformada()));
				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedioHidrometro[0]));

				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
			}

			// Caso esteja determinando faturamento de água do medido
			if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null){
				medicaoHistorico.setHidrometroInstalacaoHistorico(imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico());
			}else{
				medicaoHistorico.setHidrometroInstalacaoHistorico(imovel.getHidrometroInstalacaoHistorico());
			}

			// Caso a leitura atual informada não seja maior que o consumo médio do hidrômetro
		}else if(medicaoHistorico.getLeituraAtualInformada() <= consumoMedioHidrometro[0]){

			// Seta anormalidade de consumo
			consumoAnormalidade.setId(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_NAO_INFORMADO);

			// Consumo medido do mês = consumo médio do hidrômetro
			medicaoHistorico.setNumeroConsumoMes(Integer.valueOf(medicaoHistorico.getLeituraAtualInformada()));
			consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedioHidrometro[0]));

			// Seta tipo de consumo
			consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

			// Caso a situação da leitura anterior tenha sido real
		}else if(medicaoHistorico.getLeituraSituacaoAnterior().getId().intValue() == LeituraSituacao.REALIZADA.intValue()
						|| medicaoHistorico.getLeituraSituacaoAnterior().getId().intValue() == LeituraSituacao.CONFIRMADA.intValue()){

			if(!verificarViradaHidrometro){
				// Seta a anormalidade de consumo
				consumoAnormalidade.setId(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_ANTERIOR);

				medicaoHistorico.setNumeroConsumoMes(null);
				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedioHidrometro[0]));

				// Seta tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
			}else if(valor < 1000 || consumoCalculado > 150 || consumoCalculado > dezVezesConsumoMedioImovel || consumoCalculado == 0
							|| idLeituraAnormalidadeInformada != null){
				// Não é virada de hidrômetro

				// Seta a anormalidade de consumo
				consumoAnormalidade.setId(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_ANTERIOR);

				// Seta o número consumo medido mês
				medicaoHistorico.setNumeroConsumoMes(null);

				// Seta o consumo a ser cobrado mês
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

				// Seta tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);
			}

		}else if(medicaoHistorico.getLeituraSituacaoAnterior().getId().intValue() != LeituraSituacao.REALIZADA.intValue()
						&& medicaoHistorico.getLeituraSituacaoAnterior().getId().intValue() != LeituraSituacao.CONFIRMADA.intValue()){

			if(!verificarViradaHidrometro){
				// Seta a anormalidade de consumo
				consumoAnormalidade.setId(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_PROJETADA);

				medicaoHistorico.setNumeroConsumoMes(null);
				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedioHidrometro[0]));

				// Seta tipo de consumo
				consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);
			}else if(valor < 1000 || consumoCalculado > 150 || consumoCalculado > dezVezesConsumoMedioImovel || consumoCalculado == 0
							|| idLeituraAnormalidadeInformada != null){
				// Não é virada de hidrômetro

				// Seta a anormalidade de consumo
				consumoAnormalidade.setId(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_PROJETADA);

				// Seta o número consumo medido mês
				medicaoHistorico.setNumeroConsumoMes(null);

				// Seta o consumo a ser cobrado mês
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);

				// Seta tipo de consumo
				consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

				// Seta leitura atual faturamento
				int leituraAtualInformada = medicaoHistorico.getLeituraAtualInformada();
				medicaoHistorico.setLeituraAtualFaturamento(leituraAtualInformada);
			}

		}

		// Atualiza o consumo histórico
		if(consumoAnormalidade.getId() != null){
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
		}
		if(consumoTipo.getId() != null){
			consumoHistorico.setConsumoTipo(consumoTipo);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SF0009] - Dados para Faturamento para Leitura Menor que a Anterior
	 * 
	 * @author Anderson Italo
	 * @date 22/03/2012
	 * @throws ControladorException
	 */
	protected void dadosFaturamentoLeituraMenorAnterior(Imovel imovel, ConsumoHistorico consumoHistorico,
					MedicaoHistorico medicaoHistorico, SistemaParametro sistemaParametro, int leituraAnterior, MedicaoTipo medicaoTipo,
					int consumoMedioImovel, int consumoMedioHidrometro, int consumoMinimoLigacao) throws ControladorException{

		int numeroDigitosLeitura = 0;
		Hidrometro hidrometro = null;
		HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = null;
		Date dataInstalacao = null;

		/*
		 * Identifica e armazena a data de instalação, o hidrômetro e o número de dígitos de leitura
		 * de acordo com o tipo de medição.
		 */
		if(medicaoTipo.getId() == MedicaoTipo.LIGACAO_AGUA){

			// Obtém a data de instalação do hidrômetro
			dataInstalacao = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();

			// Obtém o hidrômetro
			hidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro();

			// Obtém o hidrômetro instalação histórico
			hidrometroInstalacaoHistorico = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico();

			// Obtém o número de digitos da leitura
			numeroDigitosLeitura = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro().getNumeroDigitosLeitura()
							.intValue();

			// Caso seja medição de <<<POÇO>>>
		}else if(medicaoTipo.getId() == MedicaoTipo.POCO){

			// Obtém a data de instalação do hidrômetro
			dataInstalacao = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();

			// Obtém o hidrômetro
			hidrometro = imovel.getHidrometroInstalacaoHistorico().getHidrometro();

			// Obtém o hidrômetro instalação histórico
			hidrometroInstalacaoHistorico = imovel.getHidrometroInstalacaoHistorico();

			// Obtém o número de digitos da leitura
			numeroDigitosLeitura = imovel.getHidrometroInstalacaoHistorico().getHidrometro().getNumeroDigitosLeitura().intValue();
		}
		
		// ############# Alterado por Luciano - OC1034808 ############# - Inicio

		Short pIgnorarHidrometroInvertido = Util
						.converterStringParaShort(ParametroMicromedicao.P_IGNORAR_HIDROMETRO_INVERTIDO_LEITURA_MENOR_QUE_ANTERIOR
										.executar());

		// A regra abaixo só será realizada se o parâmetro
		// P_IGNORAR_HIDROMETRO_INVERTIDO_LEITURA_MENOR_QUE_ANTERIOR = 1 (Sim)
		if(pIgnorarHidrometroInvertido != null && pIgnorarHidrometroInvertido.equals(ConstantesSistema.SIM)){

			// Caso hidrômetro invertido
			if(medicaoHistorico != null
							&& medicaoHistorico.getLeituraAnormalidadeFaturamento() != null
							&& LeituraAnormalidade.HIDROMETRO_INVERTIDO != null
							&& medicaoHistorico.getLeituraAnormalidadeFaturamento().getId()
											.equals(LeituraAnormalidade.HIDROMETRO_INVERTIDO)){

				// Retorna para o passo correspondente no subfluxo que o chamou
				return;
			}
		}
		// ############# Alterado por Luciano - OC1034808 ############# - Fim

		// [SB0025] – Verificar Virada de Hidrômetro
		Double valor = new Double((Math.pow(10.0, numeroDigitosLeitura)));

		// Consumo calculado
		int consumoCalculado = (medicaoHistorico.getLeituraAtualInformada() + valor.intValue()) - leituraAnterior;

		boolean viradaHidrometro = this.verificarViradaHidrometro(imovel, medicaoHistorico, leituraAnterior, consumoMedioImovel,
						consumoCalculado, numeroDigitosLeitura);

		// Caso tenha havido virada de hidrômetro
		if(viradaHidrometro){

			// O Consumo Medido do Mês será igual ao Consumo Calculado
			medicaoHistorico.setNumeroConsumoMes(consumoCalculado);

			// Gera a Anormalidade de Consumo com o valor correspondente a “virada de hidrômetro”
			ConsumoAnormalidade consumoAnormalidade = null;
			try{

				consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.VIRADA_HIDROMETRO);
			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

			// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
			boolean definirConsumoPelaAnormalidade = this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
							medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao, consumoAnormalidade, consumoCalculado);

			if(definirConsumoPelaAnormalidade == false){

				// O Consumo a Ser Cobrado no Mês será igual ao Consumo Calculado
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);

				/*
				 * Caso a Situação da Leitura Anterior esteja com o valor correspondente a
				 * “realizada” ou “confirmada”
				 */
				if(medicaoHistorico.getLeituraSituacaoAnterior() != null
								&& (medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.REALIZADA) || medicaoHistorico
												.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.CONFIRMADA))){

					// O Tipo de Consumo será o valor correspondente a “real”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.REAL));
				}else{

					// Caso contrário, o Tipo de Consumo será o valor correspondente a “estimado”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.ESTIMADO));
				}

				// A Leitura Atual Faturada será igual à Leitura Atual Informada
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());
			}

			/* Parametro que indica se deve ser verificado a leitura está fora da faixa esperada. */
			String parametroVerificarLeituraForaFaixa = (String) ParametroMicromedicao.P_VERIFICA_LEITURA_FORA_FAIXA.executar(this, 0);

			// Caso a empresa verifique consumo fora de faixa
			if(parametroVerificarLeituraForaFaixa.equals(VerificarLeituraForaFaixa.UM.getValor())){

				// [UC0086 – Calcular Faixa de Leitura Esperada]
				int[] faixaLeituraEsperada = this.calcularFaixaLeituraEsperada(consumoMedioHidrometro, medicaoHistorico, hidrometro, null);

				// Caso a leitura atual informada esteja fora da faixa de leitura esperada
				if((faixaLeituraEsperada[0] < faixaLeituraEsperada[1] && medicaoHistorico.getLeituraAtualInformada().intValue() < faixaLeituraEsperada[0])
								|| medicaoHistorico.getLeituraAtualInformada().intValue() > faixaLeituraEsperada[1]){

					/*
					 * O sistema gera a Anormalidade de Consumo com o valor correspondente a
					 * “consumo
					 * fora de faixa”
					 */
					consumoHistorico.setConsumoAnormalidade(new ConsumoAnormalidade(ConsumoAnormalidade.FORA_FAIXA));
				}
			}

			// (Sai do método) Retorna para o passo correspondente no subfluxo que o chamou
			return;
		}

		/*
		 * O sistema verifica se ocorreu substituição de hidrômetro. Caso a data de instalação
		 * do hidrômetro da ligação de água ou do poço, conforme o tipo de medição, não seja
		 * menor que a Data da Leitura Anterior de Faturamento, não seja maior que a Data da
		 * Leitura Atual Informada, o sistema considera que houve substituição de hidrômetro.
		 */
		if(!(medicaoHistorico.getDataLeituraAnteriorFaturamento() != null && dataInstalacao.compareTo(medicaoHistorico
						.getDataLeituraAnteriorFaturamento()) < 0)
						&& !(medicaoHistorico.getDataLeituraAtualInformada() != null && dataInstalacao.compareTo(medicaoHistorico
										.getDataLeituraAtualInformada()) > 0)){

			/*
			 * Gera a Anormalidade de Consumo com o valor correspondente a “hidrômetro
			 * substituído informado” e atribui o valor nulo para a Anormalidade de Leitura de
			 * Faturamento
			 */
			ConsumoAnormalidade consumoAnormalidade = null;
			try{

				consumoAnormalidade = repositorioMicromedicao
								.pesquisarConsumoAnormalidade(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_INFORMADO);
			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
			medicaoHistorico.setLeituraAnormalidadeFaturamento(null);

			/*
			 * Caso esteja determinando Dados para Faturamento de Água do Medido, o Id do
			 * Histórico de Instalação do Hidrômetro será o Id do Histórico de Instalação do
			 * Hidrômetro instalado na ligação de água (HIDI_ID da tabela LIGACAO_AGUA); caso
			 * contrário será o Id do Histórico de Instalação do Hidrômetro instalado no poço
			 * (HIDI_ID da tabela IMOVEL)
			 */
			medicaoHistorico.setHidrometroInstalacaoHistorico(hidrometroInstalacaoHistorico);

			// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
			boolean definirConsumoPelaAnormalidade = this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
							medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao, consumoAnormalidade, medicaoHistorico
											.getLeituraAtualInformada());

			if(definirConsumoPelaAnormalidade == false){

				// O Consumo Medido do Mês será igual ao valor da Leitura Atual Informada
				medicaoHistorico.setNumeroConsumoMes(medicaoHistorico.getLeituraAtualInformada());

				/*
				 * O sistema calcula os dias de consumo, que será a diferença entre a
				 * data de instalação do hidrômetro e a data de leitura atual informada
				 */
				int diasConsumo = (int) IoUtil.diferencaEntreDatas(dataInstalacao, medicaoHistorico.getDataLeituraAtualInformada());

				/*
				 * O Consumo Medido do Mês será igual ao valor da Leitura Atual Informada, o
				 * Consumo a Ser Cobrado no Mês = ((Leitura Atual Informada / Dias de Consumo) *
				 * 30)
				 */
				if(diasConsumo > 0){

					BigDecimal numerador = new BigDecimal(medicaoHistorico.getLeituraAtualInformada());
					BigDecimal denominador = new BigDecimal(diasConsumo);
					BigDecimal resultadoDivisao = numerador.divide(denominador, 3, BigDecimal.ROUND_HALF_UP);
					BigDecimal resultado = resultadoDivisao.multiply(new BigDecimal(30));

					consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(Util.arredondar(resultado)));
				}else{

					consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getLeituraAtualInformada());
				}

				// O Tipo de Consumo será o valor correspondente a “estimado”
				consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.ESTIMADO));

				// A Leitura Atual Faturada será igual à Leitura Atual Informada
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

			}
			// (Sai do método) Retorna para o passo correspondente no subfluxo que o chamou
			return;
		}

		/*
		 * Parametro que indica se a empresa verifica uma substituição de hidrômetro ainda
		 * não informada.
		 */
		String parametroVerificarPossivelSubstituicaoHidrometro = (String) ParametroMicromedicao.P_VERIFICA_POSSIVEL_SUBSTITUICAO_HIDROMETRO
						.executar(this, 0);

		// Caso a empresa verifique hidrômetro substituído e não informado
		if(parametroVerificarPossivelSubstituicaoHidrometro.equals(VerificaPossivelSubstituicaoHidrometro.UM.getValor())
						&& medicaoHistorico.getLeituraAtualInformada() <= consumoMedioImovel){

			/*
			 * Gera a Anormalidade de Consumo com o valor correspondente a “hidrômetro
			 * substituído não informado”.
			 */
			ConsumoAnormalidade consumoAnormalidade = null;
			try{

				consumoAnormalidade = repositorioMicromedicao
								.pesquisarConsumoAnormalidade(ConsumoAnormalidade.HIDROMETRO_SUBSTITUIDO_NAO_INFORMADO);
			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

			// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
			boolean definirConsumoPelaAnormalidade = this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
							medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao, consumoAnormalidade, consumoMedioImovel);

			if(definirConsumoPelaAnormalidade == false){

				// O Consumo Medido do Mês = Leitura Atual Informada
				medicaoHistorico.setNumeroConsumoMes(medicaoHistorico.getLeituraAtualInformada());

				// Consumo a Ser Cobrado no Mês = Leitura Atual Informada
				consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getLeituraAtualInformada());

				// O Tipo de Consumo será o valor correspondente a “média do hidrômetro”
				consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_HIDROMETRO));

				// A Leitura Atual Faturada será igual à Leitura Atual Informada
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

			}
			// (Sai do método) Retorna para o passo correspondente no subfluxo que o chamou
			return;
		}

		/*
		 * Caso a Situação da Leitura Anterior esteja com o valor correspondente a
		 * “realizada” ou “confirmada”
		 */
		if(medicaoHistorico.getLeituraSituacaoAnterior() != null){

			Short pTratarSituacaoLeituraAnteriorNaoReal = Util
							.converterStringParaShort(ParametroMicromedicao.P_TRATAR_SIT_LEIT_ANT_NAO_REAL_LEITURA_MENOR_QUE_ANTERIOR
											.executar());

			if(medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.REALIZADA)
							|| medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.CONFIRMADA)){

				/*
				 * Gera a Anormalidade de Consumo com o valor correspondente a “leitura atual menor
				 * que
				 * a anterior”
				 */
				ConsumoAnormalidade consumoAnormalidade = null;
				try{

					consumoAnormalidade = repositorioMicromedicao
									.pesquisarConsumoAnormalidade(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_ANTERIOR);
				}catch(ErroRepositorioException ex){

					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

				// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
				boolean definirConsumoPelaAnormalidade = this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
								medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao, consumoAnormalidade, consumoMedioImovel);

				if(definirConsumoPelaAnormalidade == false){

					// o Consumo Medido do Mês = Nulo
					medicaoHistorico.setNumeroConsumoMes(null);

					// Consumo a Ser Cobrado no Mês = consumo médio do Imóvel
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

					// O Tipo de Consumo será o valor correspondente a “média do imóvel”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

					// A Leitura Atual Faturada será igual à Leitura Atual Informada
					medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

					// (Sai do método) Retorna para o passo correspondente no subfluxo que o chamou
				}

				// ############# Alterado por Luciano - OC1034808 ############# - Inicio
			}else if(pTratarSituacaoLeituraAnteriorNaoReal != null && pTratarSituacaoLeituraAnteriorNaoReal.equals(ConstantesSistema.SIM)
							&& !medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.REALIZADA)
							&& !medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.CONFIRMADA)){
				// Esta regra será realizada apenas se o parâmetro
				// P_TRATAR_SIT_LEIT_ANT_NAO_REAL_LEITURA_MENOR_QUE_ANTERIOR = 1 (Sim)

				// Caso a Situação da Leitura Anterior não tenha sido real (com o valor diferente de
				// “confirmada” e de “realizada” da tabela LEITURA_SITUACAO)

				// o Consumo Medido do Mês = Nulo
				medicaoHistorico.setNumeroConsumoMes(null);

				// A Leitura Atual Faturada será igual à Leitura Atual Informada
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

				String pCriterioLeituraAtual = ParametroMicromedicao.P_CRITERIO_LEITURA_ATUAL.executar();
				
				if(!Util.isVazioOuBranco(pCriterioLeituraAtual)){
					// Caso critério de determinação de leitura atual menor projetada indique pela Leitura atual menor que projetada
					if(pCriterioLeituraAtual.equals(CriterioLeituraAtual.UM.getValor())){
						
						// Gerar a Anormalidade de Consumo com o valor correspondente a “leitura
						// atual menor que a projetada”
						ConsumoAnormalidade consumoAnormalidade = null;
						try{
							consumoAnormalidade = repositorioMicromedicao
											.pesquisarConsumoAnormalidade(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_PROJETADA);
						}catch(ErroRepositorioException ex){

							sessionContext.setRollbackOnly();
							throw new ControladorException("erro.sistema", ex);
						}
						consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

						// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
						boolean definirConsumoPelaAnormalidade = verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
										medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao, consumoAnormalidade, consumoCalculado);

						// Caso contrário, ou seja, caso não verifique o consumo pela anormalidade
						// de consumo
						if(!definirConsumoPelaAnormalidade){
							// Consumo a Ser Cobrado no Mês = consumo médio do Imóvel
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

							// O Tipo de Consumo será o valor correspondente a “média do imóvel”
							consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));
						}

					}else if(pCriterioLeituraAtual.equals(CriterioLeituraAtual.DOIS.getValor())){
						// Caso contrário, indique pela Leitura atual menor ou igual à média
						
						boolean definirConsumoPelaAnormalidade = false;
						
						if(consumoHistorico.getConsumoAnormalidade() != null) {
							
							// [SB0026 – Verificar Definição de Consumo pela Anormalidade de
							// Consumo]
							definirConsumoPelaAnormalidade = verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao, consumoHistorico.getConsumoAnormalidade(), consumoCalculado);
						}
						
						if(!definirConsumoPelaAnormalidade) {
							
							// Caso Leitura Atual menor ou igual que o Consumo médio do imóvel
							if(medicaoHistorico.getLeituraAtualInformada() != null
											&& medicaoHistorico.getLeituraAtualInformada().compareTo(consumoMedioImovel) <= 0){

								// Consumo a Ser Cobrado no Mês = consumo médio do Imóvel
								consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

								// O Tipo de Consumo será o valor correspondente a “média do imóvel”
								consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

								// Gerar a Anormalidade de Consumo com o valor correspondente a
								// “leitura
								// atual menor que a projetada”
								ConsumoAnormalidade consumoAnormalidade = null;
								try{
									consumoAnormalidade = repositorioMicromedicao
													.pesquisarConsumoAnormalidade(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_PROJETADA);
								}catch(ErroRepositorioException ex){

									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema", ex);
								}
								consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

							}else{
								// Caso contrário

								// O Consumo a Ser Cobrado no Mês = 0 (zero – Mínimo)
								consumoHistorico.setNumeroConsumoFaturadoMes(0);

								// O Tipo de Consumo será o valor correspondente a “média do imóvel”
								consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.ESTIMADO));

								// Gerar a Anormalidade de Consumo com o valor correspondente a
								// “leitura
								// atual menor que a projetada”
								ConsumoAnormalidade consumoAnormalidade = null;
								try{
									consumoAnormalidade = repositorioMicromedicao
													.pesquisarConsumoAnormalidade(ConsumoAnormalidade.LEITURA_ATUAL_MENOR_PROJETADA_CREDITO_CONSUMO);
								}catch(ErroRepositorioException ex){

									sessionContext.setRollbackOnly();
									throw new ControladorException("erro.sistema", ex);
								}
								consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
							}
						}						
					}
				}else{
					throw new ControladorException("atencao.param_nao_cadastrado", null,
									ParametroMicromedicao.P_CRITERIO_LEITURA_ATUAL.getCodigo());
				}
			}
			// ############# Alterado por Luciano - OC1034808 ############# - Fim
			
		}

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0026] – Verificar Definição de Consumo pela Anormalidade de Consumo
	 * 
	 * @author Anderson Italo
	 * @date 21/03/2012
	 * @param consumoCalculado
	 *            TODO
	 */
	private boolean verificarDefinicaoConsumoPelaAnormalidadeConsumo(ConsumoHistorico consumoHistorico, MedicaoHistorico medicaoHistorico,
					int consumoMedioImovel, int consumoMinimoLigacao, ConsumoAnormalidade consumoAnormalidade, int consumoCalculado)
					throws ControladorException{

		boolean retorno = false;

		/*
		 * Caso a Situação da Leitura Anterior esteja com o valor correspondente a “realizada”
		 * ou “confirmada”
		 */
		boolean primeiraCondicao = false;
		boolean segundaCondicao = false;

		if(medicaoHistorico.getLeituraSituacaoAnterior() != null
						&& (medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.REALIZADA) || !medicaoHistorico
										.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.CONFIRMADA))){

			/*
			 * Caso os dados de definição de consumo para leitura anterior real esteja informado
			 * para a anormalidade de consumo.
			 */
			if(consumoAnormalidade != null && consumoAnormalidade.getConsumoTipoLeituraAnteriorReal() != null
							&& consumoAnormalidade.getConsumoAnormalidadeLeituraAnteriorReal() != null
							&& consumoAnormalidade.getConsumoAnormalidadeConsumoLeituraAnteriorReal() != null){

				primeiraCondicao = true;
			}
		}

		/*
		 * Caso a Situação da Leitura Anterior esteja com valor diferente de “realizada” e
		 * “confirmada”.
		 */
		if(medicaoHistorico.getLeituraSituacaoAnterior() != null
						&& !medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.REALIZADA)
						&& medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.CONFIRMADA)){

			/*
			 * Caso o tipo de consumo para leitura anterior projetada esteja informado para a
			 * anormalidade de consumo.
			 */
			if(consumoAnormalidade != null && consumoAnormalidade.getConsumoTipoLeituraAnteriorProjetada() != null
							&& consumoAnormalidade.getConsumoAnormalidadeLeituraAnteriorProjetada() != null
							&& consumoAnormalidade.getConsumoAnormalidadeConsumoLeituraAnteriorProjetada() != null){

				segundaCondicao = true;
			}
		}

		if(primeiraCondicao || segundaCondicao){

			/*
			 * Parametro que indica valor atribuído ao consumo do mês quando for definida a
			 * cobrança de mínimo na consistência de leitura
			 */
			String parametroCobrancaConsumoMinimo = (String) ParametroMicromedicao.P_COBRANCA_CONSUMO_MINIMO.executar(this, 0);

			/*
			 * Os dados de leitura e consumo são definidos pela ação configurada na anormalidade
			 * de consumo detectada, [SB0027 – Definir Consumo pela Anormalidade de Consumo]
			 */
			this.definirConsumoPelaAnormalidadeConsumo(medicaoHistorico, consumoHistorico, consumoMinimoLigacao, consumoMedioImovel,
							parametroCobrancaConsumoMinimo, consumoAnormalidade, consumoCalculado);

			retorno = true;
		}

		return retorno;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0025] – Verificar Virada de Hidrômetro
	 * 
	 * @author Anderson Italo
	 * @date 21/03/2012
	 */
	private boolean verificarViradaHidrometro(Imovel imovel, MedicaoHistorico medicaoHistorico, int leituraAnterior,
					int consumoMedioImovel, int consumoCalculado, int numeroDigitosLeitura) throws ControladorException{

		boolean retorno = false;

		// <<Inclui>> [UC0108 – Obter Quantidade Economias por Categoria]
		Collection<Categoria> colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		if(!Util.isVazioOrNulo(colecaoCategoria)){

			/*
			 * O sistema obtém o Consumo Total de Referência acumulando o consumo por economia de
			 * referência de cada categoria multiplicado pelo número de economias do imóvel na
			 * categoria.
			 */
			Integer consumoTotalReferenciaAcumulado = 0;

			for(Categoria categoria : colecaoCategoria){

				if(categoria.getConsumoViradaHidrometro() != null){

					consumoTotalReferenciaAcumulado += categoria.getConsumoViradaHidrometro() * categoria.getQuantidadeEconomiasCategoria();
				}

			}

			/*
			 * Obtendo o fator de multiplicação da média da categoria do imóvel que tenha o maior
			 * número de economias
			 */
			Collections.sort((List) colecaoCategoria, new Comparator() {

				public int compare(Object a, Object b){

					Integer quatidadeEconomias1 = ((Categoria) a).getQuantidadeEconomiasCategoria();
					Integer quatidadeEconomias2 = ((Categoria) b).getQuantidadeEconomiasCategoria();

					return quatidadeEconomias1.compareTo(quatidadeEconomias2);

				}
			});

			Categoria categoriaComMaiorNumeroEconomias = (Categoria) colecaoCategoria.iterator().next();

			/*
			 * Caso o Consumo a Ser Cobrado no Mês seja superior ao Consumo Total de Referência
			 * obtido e
			 * ao consumo médio do imóvel multiplicado pelo fator de multiplicação da média da
			 * categoria
			 * do imóvel que tenha o maior número de economias (CATG_NNVEZESMEDIAVIRADAHD)
			 */
			Integer consumoMedioVezesFatorViradaCategoria = consumoMedioImovel
							* categoriaComMaiorNumeroEconomias.getNumeroVezesMediaViradaHidrometro();
			if(consumoCalculado < consumoTotalReferenciaAcumulado.intValue() || consumoCalculado < consumoMedioVezesFatorViradaCategoria){

				/*
				 * Parametro que indica o numero mínimo de dígitos no medidor para validação de
				 * virada de hidrômetro (inclusive)
				 */
				String parametroNumeroDigitosHidrometroVirada = (String) ParametroMicromedicao.P_NUM_DIGITOS_HIDROMETRO_VIRADA.executar(
								this, 0);

				/*
				 * Caso o número de dígitos de leitura do hidrômetro seja igual ou superior ao
				 * número de dígitos para verificação de virada de hidrômetro e e não tenha havido
				 * anormalidade de leitura.
				 */
				if(numeroDigitosLeitura >= Util.obterInteger(parametroNumeroDigitosHidrometroVirada).intValue()){

					// O Sistema considera que houve uma vidada de hidrômetro
					retorno = true;

					/*
					 * Caso seja para verificar existência de anormalidade
					 * (CATG_ICVALIDANORMALVIRADAHD = “Sim” da categoria do imóvel que tenha o maior
					 * número de economias)
					 */
					if(categoriaComMaiorNumeroEconomias.getIndicadorValidarViradaHidrometro() != null
									&& categoriaComMaiorNumeroEconomias.getIndicadorValidarViradaHidrometro().equals(ConstantesSistema.SIM)
									&& medicaoHistorico.getLeituraAnormalidadeFaturamento() != null){
						retorno = false;
					}
				}
			}
		}

		return retorno;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0010] - Dados para Faturamento para Leitura Não Informada e Sem Anormalidade de Leitura
	 * Verificando quantidade de dias de consumo.
	 */
	@Deprecated
	protected void dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeituraQtdDiasConsumo(MedicaoHistorico medicaoHistorico,
					ConsumoHistorico consumoHistorico, int[] consumoMedioHidrometro, int leituraAnterior){

		// Cria objeto consumo anormalidade
		ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

		// Cria objeto tipo consumo
		ConsumoTipo consumoTipo = new ConsumoTipo();

		// Seta o consumo anormalidade para leitura não informada
		consumoAnormalidade.setId(ConsumoAnormalidade.LEITURA_NAO_INFORMADA);

		// Obtém a quantidade de dias de consumo
		long quantidadeDiasConsumo = IoUtil.diferencaEntreDatas(medicaoHistorico.getDataLeituraAnteriorFaturamento(), medicaoHistorico
						.getDataLeituraAtualFaturamento());

		// Caso a quantidade de dias seja menor que zero, seta a quantidade zero
		if(quantidadeDiasConsumo < 0){
			quantidadeDiasConsumo = 0;
		}

		// Caso a quantidade de dias esteja entre 27 e 33
		if(quantidadeDiasConsumo >= 27 && quantidadeDiasConsumo <= 33){

			// O consumo a ser cobrado mês será o consumo médio do hidrometro
			consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedioHidrometro[0]));

			// Seta o tipo de consumo como médio
			consumoTipo.setId(ConsumoTipo.MEDIA_HIDROMETRO);

		}else{

			// Realiza cálculo para obter o consumo cobrado no mês
			// Consumo cobrado mês = (consumo médio hidrômetro / 30) *
			// quantidade dias consumo
			BigDecimal numerador = new BigDecimal(consumoMedioHidrometro[0]);
			BigDecimal denominador = new BigDecimal("30");
			BigDecimal resultado = numerador.divide(denominador, 3, BigDecimal.ROUND_HALF_UP);
			BigDecimal diasConsumo = new BigDecimal(quantidadeDiasConsumo);
			resultado = resultado.multiply(diasConsumo);

			// Seta o consumo a ser faturado mês (consumo cobrado mês)
			consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(Util.arredondar(resultado)));

			// Seta o tipo de consumo com consumo médio ajustado
			consumoTipo.setId(ConsumoTipo.CONSUMO_MEDIO_AJUSTADO);

		}

		// customização para v0.05
		// A leitura atual de faturamento será a leitura anterior.
		medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

		// Seta o consumo tipo
		consumoHistorico.setConsumoTipo(consumoTipo);
		// Seta o consumo anormalidade
		consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0010] - Dados para Faturamento para Leitura Não Informada e Sem Anormalidade de Leitura
	 * 
	 * @author Anderson Italo
	 * @date 22/03/2012
	 * @throws ControladorException
	 */
	protected void dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(MedicaoHistorico medicaoHistorico,
					ConsumoHistorico consumoHistorico, int leituraAnterior, int consumoMedioImovel, int consumoMinimoLigacao)
					throws ControladorException{

		/*
		 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “leitura não
		 * informada”
		 */
		ConsumoAnormalidade consumoAnormalidade = null;
		try{

			consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.LEITURA_NAO_INFORMADA);
		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

		// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
		boolean definirConsumoPelaAnormalidade = verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico,
						consumoMedioImovel, consumoMinimoLigacao, consumoAnormalidade, consumoMedioImovel);

		if(definirConsumoPelaAnormalidade == false){

			/*
			 * O sistema obtém a Quantidade de Dias de Consumo (Data da Leitura Atual de Faturamento
			 * - Data da Leitura Anterior de Faturamento)
			 */
			int diasConsumo = (int) IoUtil.diferencaEntreDatas(medicaoHistorico.getDataLeituraAnteriorFaturamento(), medicaoHistorico
							.getDataLeituraAtualFaturamento());

			/*
			 * O sistema aceita como normal uma variação na Quantidade de Dias de Consumo, para mais
			 * ou para menos, de três dias, ou seja, caso a quantidade de dias esteja entre 27 e 33
			 */
			if(diasConsumo >= 27 && diasConsumo <= 33){

				// O Consumo a Ser Cobrado no Mês será o consumo médio do imóvel
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

			}else{

				/*
				 * O Consumo a Ser Cobrado no Mês = (consumo médio do imóvel / 30) x Quantidade de
				 * Dias de Consumo (utilizando a regra padrão de arredondamento)
				 */
				BigDecimal numerador = new BigDecimal(consumoMedioImovel);
				BigDecimal denominador = new BigDecimal(30);
				BigDecimal resultadoDivisao = numerador.divide(denominador, 3, BigDecimal.ROUND_HALF_UP);
				BigDecimal resultado = resultadoDivisao.multiply(new BigDecimal(diasConsumo));

				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(Util.arredondar(resultado)));
			}

			// O Tipo de Consumo será o valor correspondente à “média do imóvel”
			consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

			// A leitura atual de faturamento será a leitura anterior
			medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0011] - Dados para Faturamento com Anormalidade de Leitura (Tipo de Ligação Água)
	 * 
	 * @author Hebert Falcão
	 */
	@Deprecated
	protected boolean dadosFaturamentoAnormalidadeLeituraImovelTipoAgua(MedicaoHistorico medicaoHistorico,
					ConsumoHistorico consumoHistorico, int[] consumoMedioImovel, int leituraAnterior, Imovel imovel,
					int consumoMinimoLigacao) throws ControladorException{

		boolean diferencaLeitura = false;

		// Cria objeto consumo tipo
		ConsumoTipo consumoTipo = new ConsumoTipo();

		Collection colecaoAnormalidadeLeitura = null;

		LeituraAnormalidade leituraAnormalidadeFaturamento = medicaoHistorico.getLeituraAnormalidadeFaturamento();

		try{
			// Pesquisa a anormalidade de leitura de faturamento
			colecaoAnormalidadeLeitura = repositorioMicromedicao.pesquisarAnormalidadeLeitura(leituraAnormalidadeFaturamento);
		}catch(ErroRepositorioException ex){
			new ControladorException("erro.sistema", ex);
		}

		// Obtém a leitura anormalidade
		LeituraAnormalidade leituraAnormalidade = obterAnormalidadeLeitura(colecaoAnormalidadeLeitura);

		// Seta a leitura anormalidade faturamento
		leituraAnormalidadeFaturamento.setLeituraAnormalidadeConsumoSemleitura(leituraAnormalidade
						.getLeituraAnormalidadeConsumoSemleitura());
		leituraAnormalidadeFaturamento.setLeituraAnormalidadeConsumoComleitura(leituraAnormalidade
						.getLeituraAnormalidadeConsumoComleitura());
		leituraAnormalidadeFaturamento.setLeituraAnormalidadeLeituraSemleitura(leituraAnormalidade
						.getLeituraAnormalidadeLeituraSemleitura());
		leituraAnormalidadeFaturamento.setLeituraAnormalidadeLeituraComleitura(leituraAnormalidade
						.getLeituraAnormalidadeLeituraComleitura());
		leituraAnormalidadeFaturamento.setIndicadorCreditoConsumo(leituraAnormalidade.getIndicadorCreditoConsumo());

		// Tipo de medição
		MedicaoTipo medicaoTipo = medicaoHistorico.getMedicaoTipo();
		Integer idMedicaoTipo = medicaoTipo.getId();

		// Situação da ligação
		LigacaoAguaSituacao ligacaoAguaSituacao = imovel.getLigacaoAguaSituacao();
		Short indicadorFaturamentoSituacao = ligacaoAguaSituacao.getIndicadorFaturamentoSituacao();

		Integer leituraAtualInformada = medicaoHistorico.getLeituraAtualInformada();

		if(leituraAtualInformada == null){
			// Leitura atual informada com valor nulo (leitura não informada)

			if((MedicaoTipo.LIGACAO_AGUA.equals(idMedicaoTipo) && LigacaoAguaSituacao.FATURAMENTO_ATIVO
							.equals(indicadorFaturamentoSituacao))){

				// Consumo a ser cobrado no mes com base no id consumo sem leitura
				LeituraAnormalidadeConsumo leituraAnormalidadeConsumoSemLeitura = leituraAnormalidadeFaturamento
								.getLeituraAnormalidadeConsumoSemleitura();
				Integer idLeituraAnormalidadeConsumoSemLeitura = leituraAnormalidadeConsumoSemLeitura.getId();

				if(LeituraAnormalidadeConsumo.NAO_OCORRE.equals(idLeituraAnormalidadeConsumoSemLeitura)){

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

					consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

				}else if(LeituraAnormalidadeConsumo.MINIMO.equals(idLeituraAnormalidadeConsumoSemLeitura)){

					consumoHistorico.setNumeroConsumoFaturadoMes(0);

					consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

				}else if(LeituraAnormalidadeConsumo.MEDIA.equals(idLeituraAnormalidadeConsumoSemLeitura)){

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

					consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

				}

				// Leitura Atual de Faturamento com base no id leitura sem Leitura
				LeituraAnormalidadeLeitura leituraAnormalidadeLeituraSemLeitura = leituraAnormalidadeFaturamento
								.getLeituraAnormalidadeLeituraSemleitura();
				Integer idLeituraAnormalidadeLeituraSemLeitura = leituraAnormalidadeLeituraSemLeitura.getId();

				if(LeituraAnormalidadeLeitura.NAO_OCORRE.equals(idLeituraAnormalidadeLeituraSemLeitura)){

					int leituraAtualFaturamento = leituraAnterior + consumoMedioImovel[0];
					medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);

				}else if(LeituraAnormalidadeLeitura.ANTERIOR.equals(idLeituraAnormalidadeLeituraSemLeitura)){

					medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

				}else if(LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA.equals(idLeituraAnormalidadeLeituraSemLeitura)){

					Integer consumoCobrado = consumoHistorico.getNumeroConsumoFaturadoMes();
					if(consumoCobrado == null){
						consumoCobrado = 0;
					}

					int leituraAtualFaturamento = leituraAnterior + consumoCobrado;
					medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);

				}
			}else{

				consumoHistorico.setNumeroConsumoFaturadoMes(0);

				consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);

				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

			}
		}else if(leituraAtualInformada != null){
			// Leitura Atual Informada com o valor diferente de nulo (leitura informada)

			if(MedicaoTipo.LIGACAO_AGUA.equals(idMedicaoTipo)
							&& (LigacaoAguaSituacao.FATURAMENTO_ATIVO.equals(indicadorFaturamentoSituacao) || (LigacaoAguaSituacao.NAO_FATURAVEL
											.equals(indicadorFaturamentoSituacao)))){

				// Calcular multiplicação de consumo
				int consumoCalculado = leituraAtualInformada - leituraAnterior;

				if(imovel.getLigacaoAgua() != null
								&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
								&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro() != null
								&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro().getHidrometroCapacidade() != null){
					LigacaoAgua ligacaoAgua = imovel.getLigacaoAgua();
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = ligacaoAgua.getHidrometroInstalacaoHistorico();
					Hidrometro hidrometro = hidrometroInstalacaoHistorico.getHidrometro();
					HidrometroCapacidade hidrometroCapacidade = hidrometro.getHidrometroCapacidade();

					String codigoHidrometroCapacidade = hidrometroCapacidade.getCodigoHidrometroCapacidade();

					if(HidrometroCapacidade.CAPACIDADE_K.equals(codigoHidrometroCapacidade)
									|| HidrometroCapacidade.CAPACIDADE_M.equals(codigoHidrometroCapacidade)
									|| HidrometroCapacidade.CAPACIDADE_N.equals(codigoHidrometroCapacidade)
									|| HidrometroCapacidade.CAPACIDADE_P.equals(codigoHidrometroCapacidade)){
						consumoCalculado = consumoCalculado * 10;
					}else if(HidrometroCapacidade.CAPACIDADE_Q.equals(codigoHidrometroCapacidade)
									|| HidrometroCapacidade.CAPACIDADE_R.equals(codigoHidrometroCapacidade)){
						consumoCalculado = consumoCalculado * 100;
					}
				}

				// Consumo a ser cobrado no mês
				LeituraAnormalidadeConsumo leituraAnormalidadeConsumoComLeitura = leituraAnormalidadeFaturamento
								.getLeituraAnormalidadeConsumoComleitura();
				Integer idLeituraAnormalidadeConsumoComLeitura = leituraAnormalidadeConsumoComLeitura.getId();

				if(LeituraAnormalidadeConsumo.NAO_OCORRE.equals(idLeituraAnormalidadeConsumoComLeitura)){

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

					consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

				}else if(LeituraAnormalidadeConsumo.MINIMO.equals(idLeituraAnormalidadeConsumoComLeitura)){

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);

					consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

				}else if(LeituraAnormalidadeConsumo.MEDIA.equals(idLeituraAnormalidadeConsumoComLeitura)){

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

					consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

				}else if(consumoCalculado >= 0){
					if(LeituraAnormalidadeConsumo.NORMAL.equals(idLeituraAnormalidadeConsumoComLeitura)){

						int consumoFaturadoMes = leituraAtualInformada - leituraAnterior;
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoFaturadoMes);

						consumoTipo.setId(ConsumoTipo.REAL);

						diferencaLeitura = true;

					}else if(LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_IMOVEL_CONSUMO_CALCULADO
									.equals(idLeituraAnormalidadeConsumoComLeitura)){

						if(consumoMedioImovel[0] > consumoCalculado){
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

							consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);
						}else{
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);

							consumoTipo.setId(ConsumoTipo.REAL);

							diferencaLeitura = true;
						}

					}else if(LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_IMOVEL_CONSUMO_CALCULADO
									.equals(idLeituraAnormalidadeConsumoComLeitura)){

						if(consumoMedioImovel[0] < consumoCalculado){
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel[0]);

							consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);
						}else{
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);

							consumoTipo.setId(ConsumoTipo.REAL);

							diferencaLeitura = true;
						}

					}
				}

				// Leitura atual de faturamento com base no id leitura com leitura
				LeituraAnormalidadeLeitura leituraAnormalidadeLeituraComLeitura = leituraAnormalidadeFaturamento
								.getLeituraAnormalidadeLeituraComleitura();
				Integer idLeituraAnormalidadeLeituraComLeitura = leituraAnormalidadeLeituraComLeitura.getId();

				if(LeituraAnormalidadeLeitura.NAO_OCORRE.equals(idLeituraAnormalidadeLeituraComLeitura)){

					int leituraAtualFaturamento = leituraAnterior + consumoMedioImovel[0];
					medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);

				}else if(LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA.equals(idLeituraAnormalidadeLeituraComLeitura)){

					Integer consumoCobrado = consumoHistorico.getNumeroConsumoFaturadoMes();
					if(consumoCobrado == null){
						consumoCobrado = 0;
					}

					int leituraAtualFaturamento = leituraAnterior + consumoCobrado;
					medicaoHistorico.setLeituraAtualFaturamento(leituraAtualFaturamento);

				}else if(LeituraAnormalidadeLeitura.ANTERIOR.equals(idLeituraAnormalidadeLeituraComLeitura)){

					medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

				}else if(LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO.equals(idLeituraAnormalidadeLeituraComLeitura)){

					medicaoHistorico.setLeituraAtualFaturamento(leituraAtualInformada);

				}else if(LeituraAnormalidadeLeitura.INFORMADA.equals(idLeituraAnormalidadeLeituraComLeitura)){

					medicaoHistorico.setLeituraAtualFaturamento(leituraAtualInformada);

				}
			}else{

				consumoHistorico.setNumeroConsumoFaturadoMes(0);

				consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);

				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

			}
		}

		if(leituraAnormalidadeFaturamento != null && leituraAnormalidadeFaturamento.getIndicadorCreditoConsumo() != null
						&& leituraAnormalidadeFaturamento.getIndicadorCreditoConsumo() == 1){

			int consumoCobrado = consumoHistorico.getNumeroConsumoFaturadoMes();
			if(consumoCobrado > 0){
				consumoCobrado = consumoCobrado * -1;
			}

			// O Crédito Gerado será o Consumo a Ser Cobrado no Mês com sinal negativo.
			medicaoHistorico.setConsumoCreditoGerado(consumoCobrado);

			Integer consumoCreditoAnterior = medicaoHistorico.getConsumoCreditoAnterior();
			if(consumoCreditoAnterior == null){
				consumoCreditoAnterior = 0;
			}

			medicaoHistorico.setConsumoCreditoAnterior(consumoCreditoAnterior + consumoCobrado);
		}

		// Atualiza o consumo histórico
		if(consumoTipo.getId() != null){
			consumoHistorico.setConsumoTipo(consumoTipo);
		}

		return diferencaLeitura;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0023] - Consistência Datas de Leitura Atual e Anterior
	 * 
	 * @author Hebert Falcão
	 * @date 14/03/2010
	 */
	protected void consistirDatasLeituraAtualAnterior(MedicaoHistorico medicaoHistorico, Imovel imovel, MedicaoTipo medicaoTipo)
					throws ControladorException{

		Date dataLeituraAnteriorFaturamento = medicaoHistorico.getDataLeituraAnteriorFaturamento();
		Date dataLeituraAtualInformada = medicaoHistorico.getDataLeituraAtualInformada();
		Date dataCorrente = new Date();

		// Data de leitura anterior faturamento com valor igual a nulos
		if(dataLeituraAnteriorFaturamento == null){

			Date dataCalculada = null;

			if(dataLeituraAtualInformada != null){
				dataCalculada = Util.subtrairNumeroDiasDeUmaData(dataLeituraAtualInformada, 30);
			}else{
				dataCalculada = Util.subtrairNumeroDiasDeUmaData(dataCorrente, 30);
			}

			medicaoHistorico.setDataLeituraAnteriorFaturamento(dataCalculada);
		}

		// Data de leitura atual informada seja menor que a data de leitura anterior faturada
		if(dataLeituraAtualInformada != null && dataLeituraAnteriorFaturamento != null
						&& Util.compararData(dataLeituraAtualInformada, dataLeituraAnteriorFaturamento) == -1){

			Date dataCalculada = Util.subtrairNumeroDiasDeUmaData(dataLeituraAtualInformada, 30);

			// ############# Alterado por Luciano - OC1034808 ############# - Inicio

			Date dataInstalacaoHidrometro = null;

			if(medicaoTipo.getId().equals(MedicaoTipo.LIGACAO_AGUA)){

				if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null
								&& imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao() != null){

					LigacaoAgua ligacaoAgua = imovel.getLigacaoAgua();
					HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = ligacaoAgua.getHidrometroInstalacaoHistorico();

					dataInstalacaoHidrometro = hidrometroInstalacaoHistorico.getDataInstalacao();
				}
			}else{

				if(imovel.getHidrometroInstalacaoHistorico() != null
								&& imovel.getHidrometroInstalacaoHistorico().getDataInstalacao() != null){

					HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = imovel.getHidrometroInstalacaoHistorico();

					dataInstalacaoHidrometro = hidrometroInstalacaoHistorico.getDataInstalacao();
				}
			}

			Short pCriterioDataLeituraAnterior = Util.converterStringParaShort(ParametroMicromedicao.P_CRITERIO_DATA_LEITURA_ANTERIOR
							.executar());

			if(pCriterioDataLeituraAnterior != null){

				// Caso Data Leitura anterior recebe calculada ou instalação
				// (P_CRITERIO_DATA_LEITURA_ANTERIOR = 1)
				if(pCriterioDataLeituraAnterior.equals(CriterioDataLeituraAnterior.UM.getValor())){

					if(dataCalculada != null && dataInstalacaoHidrometro != null
									&& Util.compararData(dataCalculada, dataInstalacaoHidrometro) == 1){

						medicaoHistorico.setDataLeituraAnteriorFaturamento(dataCalculada);
					}else{

						medicaoHistorico.setDataLeituraAnteriorFaturamento(dataInstalacaoHidrometro);
					}

				}else if(pCriterioDataLeituraAnterior.equals(CriterioDataLeituraAnterior.DOIS.getValor())){
					// Caso Data Leitura anterior recebe instalação ou calculada
					// (P_CRITERIO_DATA_LEITURA_ANTERIOR = 2)

					if(dataCalculada != null && dataInstalacaoHidrometro != null
									&& Util.compararData(dataCalculada, dataInstalacaoHidrometro) == 1){

						medicaoHistorico.setDataLeituraAnteriorFaturamento(dataInstalacaoHidrometro);
					}else{

						medicaoHistorico.setDataLeituraAnteriorFaturamento(dataCalculada);
					}

				}

			}else{
				throw new ControladorException("atencao.param_nao_cadastrado", null,
								ParametroMicromedicao.P_CRITERIO_DATA_LEITURA_ANTERIOR.getCodigo());
			}

			// ############# Alterado por Luciano - OC1034808 ############# - Fim
		}

		// Data de leitura atual informada com valor nulo
		if(dataLeituraAtualInformada == null){

			Calendar calendar = GregorianCalendar.getInstance();
			calendar.setTime(dataLeituraAnteriorFaturamento);

			int ultimoDiaMes = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

			Date dataProjetada = Util.adicionarNumeroDiasDeUmaData(dataLeituraAnteriorFaturamento, ultimoDiaMes);
			Date dataCalculada = Util.subtrairNumeroDiasDeUmaData(dataCorrente, 30);

			if(Util.compararData(dataProjetada, dataCorrente) == 1 || Util.compararData(dataCalculada, dataProjetada) == 1){
				medicaoHistorico.setDataLeituraAtualInformada(dataCorrente);
				medicaoHistorico.setDataLeituraAtualFaturamento(dataCorrente);
			}else{
				medicaoHistorico.setDataLeituraAtualInformada(dataProjetada);
				medicaoHistorico.setDataLeituraAtualFaturamento(dataProjetada);
			}
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SF0021] - Dados para Faturamento Especial Medido
	 * Customização para v0.05
	 * 
	 * @author Virgínia Melo
	 * @date 23/09/2008
	 */
	protected void dadosFaturamentoEspecialMedido(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico, Imovel imovel,
					int consumoMedioImovel, int leituraAnterior, int consumoMinimoLigacao) throws ControladorException{

		Collection colecaoFaturamentoSituacaoTipo = null;

		try{

			// Pesquisa a anormalidade de leitura de faturamento
			colecaoFaturamentoSituacaoTipo = repositorioMicromedicao.pesquisarFaturamentoSituacaoTipo(imovel.getFaturamentoSituacaoTipo());

		}catch(ErroRepositorioException ex){

			sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		// Obtém a leitura anormalidade
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = obterFaturamentoSituacaoTipo(colecaoFaturamentoSituacaoTipo);

		// Seta a leitura anormalidade faturamento
		imovel.getFaturamentoSituacaoTipo().setLeituraAnormalidadeConsumoSemLeitura(
						faturamentoSituacaoTipo.getLeituraAnormalidadeConsumoSemLeitura());
		imovel.getFaturamentoSituacaoTipo().setLeituraAnormalidadeConsumoComLeitura(
						faturamentoSituacaoTipo.getLeituraAnormalidadeConsumoComLeitura());
		imovel.getFaturamentoSituacaoTipo().setLeituraAnormalidadeLeituraSemLeitura(
						faturamentoSituacaoTipo.getLeituraAnormalidadeLeituraSemLeitura());
		imovel.getFaturamentoSituacaoTipo().setLeituraAnormalidadeLeituraComLeitura(
						faturamentoSituacaoTipo.getLeituraAnormalidadeLeituraComLeitura());

		/*
		 * O sistema determina o consumo e a leitura para faturamento de acordo com os parâmetros
		 * definidos para o Tipo de Situação do Faturamento (FTST_ID da tabela
		 * FATURAMENTO_SITUACAO_TIPO)
		 */

		// Leitura Atual Informada com o valor nulo
		if(medicaoHistorico.getLeituraAtualInformada() == null){

			/*
			 * Consumo a Ser Cobrado no Mês (LACS_IDCONSUMOACOBRARSEMLEITURA com os seguintes
			 * valores na tabela LEITURA_ANORMALIDADE_CONSUMO):
			 */

			// Não ocorre
			if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
							.intValue()){

				// O Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedioImovel));

				// O Tipo de Consumo será o valor correspondente à “média do imóvel”
				consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_HIDROMETRO));

			}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MINIMO
							.intValue()){

				// Mínimo
				// O Tipo de Consumo será o valor correspondente a “consumo mínimo”
				consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.CONSUMO_MINIMO_FIXADO));

				// Caso seja para tratar mínimo com valor zero (0)
				/*
				 * Parametro que indica valor atribuído ao consumo do mês quando for definida a
				 * cobrança de mínimo na consistência de leitura
				 */
				String parametroCobrancaConsumoMinimo = (String) ParametroMicromedicao.P_COBRANCA_CONSUMO_MINIMO.executar(this, 0);

				// Caso seja para tratar mínimo com valor zero (0)
				if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.DOIS.getValor())){

					// O Consumo Ser Cobrado no Mês será igual a zero (0)
					consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
				}else{

					/*
					 * O Consumo a Ser Cobrado no Mês será o mínimo da ligação <<Inclui>>
					 * [UC0105 –
					 * Obter Consumo Mínimo da Ligação]
					 */
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
				}

			}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MEDIA
							.intValue()){

				/*
				 * Parametro que indica a regra a ser utilizada quando a média for igual a zero (0).
				 */
				String parametroTratamentoMediaZerada = (String) ParametroMicromedicao.P_TRATAMENTO_MEDIA_ZERADA.executar(this, 0);

				/* O sistema Calcula Consumo a Ser Cobrado no Mês */
				if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.UM.getValor())){

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
				}else if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.DOIS.getValor())){

					// Caso o consumo médio do imóvel seja igual “zero”
					if(consumoMedioImovel == 0){

						/*
						 * Consumo a Ser Cobrado no Mês será o Consumo Medido
						 * (MDHI_NNCONSUMOMEDIDOMES),
						 * caso esse seja maior que zero, caso contrário, o Consumo a Ser Cobrado no
						 * Mês
						 * será o mínimo da ligação <<Inclui>> [UC0105 – Obter Consumo Mínimo da
						 * Ligação]
						 */
						if(medicaoHistorico.getNumeroConsumoMes() != null && medicaoHistorico.getNumeroConsumoMes() > 0){

							consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoMes());
						}else{

							int consumoMinimo = 0;
							consumoMinimo = obterConsumoMinimoLigacao(imovel, null);
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimo);
						}
					}else{

						// Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
					}
				}

				// O Tipo de Consumo será o valor correspondente à “média do imóvel”
				consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

			}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.LIMITE
							.intValue()){

				/*
				 * O Consumo a Ser Cobrado no Mês será o consumo informado na situação especial de
				 * faturamento.
				 */
				Integer volumeFaturamentoSituacaoHistorico = getControladorFaturamento().pesquisarVolumeFaturamentoSituacaoHistorico(
								imovel.getId(), consumoHistorico.getReferenciaFaturamento());

				if(volumeFaturamentoSituacaoHistorico != null){

					consumoHistorico.setNumeroConsumoFaturadoMes(volumeFaturamentoSituacaoHistorico);
				}

				// O Tipo de Consumo será o valor correspondente a “informado”"
				consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.INFORMADO));
			}

			/*
			 * Leitura Atual de Faturamento (LALT_IDLEITURAAFATURARSEMLEITURA com os seguintes
			 * valores correspondentes na tabela LEITURA_ANORMALIDADE_LEITURA)
			 */
			if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraSemLeitura() != null){

				// Não ocorre
				if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraSemLeitura().getId().intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA
								.intValue()){

					/*
					 * Anterior mais a média : A Leitura atual de faturamento será a anterior mais a
					 * média
					 */
					medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior + consumoMedioImovel);
				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraSemLeitura().getId().intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA
								.intValue()){

					/*
					 * Anterior mais a média : A Leitura atual de faturamento será a anterior mais a
					 * média
					 */
					medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior + consumoMedioImovel);

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraSemLeitura().getId().intValue() == LeituraAnormalidadeLeitura.ANTERIOR
								.intValue()){

					// Anterior: A Leitura atual de faturamento será a igual a anterior
					medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraSemLeitura().getId().intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO
								.intValue()){

					/*
					 * Anterior mais o consumo: A Leitura Atual de Faturamento será a anterior mais
					 * o
					 * Consumo a Ser Cobrado no Mês
					 */
					medicaoHistorico
									.setLeituraAtualFaturamento(leituraAnterior + consumoHistorico.getNumeroConsumoFaturadoMes().intValue());
				}
			}

		}else if(medicaoHistorico.getLeituraAtualInformada() != null){

			// Leitura Atual Informada com o valor diferente de nulo
			/*
			 * Consumo a Ser Cobrado no Mês (LACS_IDCONSUMOACOBRARCOMLEITURA com os seguintes
			 * valores correspondentes na tabela LEITURA_ANORMALIDADE_CONSUMO)
			 */
			if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura() != null){

				// Não ocorre
				if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
								.intValue()){

					// O Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

					// O Tipo de Consumo será o valor correspondente à “média do imóvel”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MINIMO
								.intValue()){

					// Mínimo
					// O Tipo de Consumo será o valor correspondente a “consumo mínimo”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.CONSUMO_MINIMO_FIXADO));

					// Caso seja para tratar mínimo com valor zero (0)
					/*
					 * Parametro que indica valor atribuído ao consumo do mês quando for definida a
					 * cobrança de mínimo na consistência de leitura
					 */
					String parametroCobrancaConsumoMinimo = (String) ParametroMicromedicao.P_COBRANCA_CONSUMO_MINIMO.executar(this, 0);

					// Caso seja para tratar mínimo com valor zero (0)
					if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.DOIS.getValor())){

						// O Consumo Ser Cobrado no Mês será igual a zero (0)
						consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
					}else{

						/*
						 * O Consumo a Ser Cobrado no Mês será o mínimo da ligação <<Inclui>>
						 * [UC0105 –
						 * Obter Consumo Mínimo da Ligação]
						 */
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
					}

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MEDIA
								.intValue()){

					/*
					 * Parametro que indica a regra a ser utilizada quando a média for igual a zero
					 * (0).
					 */
					String parametroTratamentoMediaZerada = (String) ParametroMicromedicao.P_TRATAMENTO_MEDIA_ZERADA.executar(this, 0);

					/* O sistema Calcula Consumo a Ser Cobrado no Mês */
					if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.UM.getValor())){

						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
					}else if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.DOIS.getValor())){

						// Caso o consumo médio do imóvel seja igual “zero”
						if(consumoMedioImovel == 0){

							/*
							 * Consumo a Ser Cobrado no Mês será o Consumo Medido
							 * (MDHI_NNCONSUMOMEDIDOMES),
							 * caso esse seja maior que zero, caso contrário, o Consumo a Ser
							 * Cobrado no
							 * Mês
							 * será o mínimo da ligação <<Inclui>> [UC0105 – Obter Consumo Mínimo da
							 * Ligação]
							 */
							if(medicaoHistorico.getNumeroConsumoMes() != null && medicaoHistorico.getNumeroConsumoMes() > 0){

								consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoMes());
							}else{

								int consumoMinimo = 0;
								consumoMinimo = obterConsumoMinimoLigacao(imovel, null);
								consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimo);
							}
						}else{

							// Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
						}
					}

					// O Tipo de Consumo será o valor correspondente à “média do imóvel”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MAIOR_ENTRE_CONSUMO_MEDIO_IMOVEL_CONSUMO_CALCULADO
								.intValue()){

					/*
					 * Maior entre o consumo médio do imóvel e o consumo calculado: o Consumo a Ser
					 * Cobrado no Mês será o maior entre o Consumo Médio do Imóvel e o Consumo a Ser
					 * Cobrado no Mês já calculado.
					 */
					if(consumoMedioImovel > consumoHistorico.getNumeroConsumoFaturadoMes().intValue()){

						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

					}

					// O Tipo de Consumo será o valor correspondente à “média do imóvel”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MENOR_ENTRE_CONSUMO_MEDIO_IMOVEL_CONSUMO_CALCULADO
								.intValue()){

					/*
					 * Menor entre o consumo médio do imóvel e o consumo calculado: o Consumo a Ser
					 * Cobrado no Mês será o maior entre o Consumo Médio do Imóvel e o Consumo a Ser
					 * Cobrado no Mês já calculado.
					 */
					if(consumoMedioImovel < consumoHistorico.getNumeroConsumoFaturadoMes().intValue()){

						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);

					}

					// O Tipo de Consumo será o valor correspondente à “média do imóvel”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.ATE_LIMITE
								.intValue()){

					/*
					 * O Consumo a Ser Cobrado no Mês será o menor entre o consumo informado na
					 * situação especial de faturamento e o Consumo a Ser Cobrado no Mês já
					 * calculado.
					 */
					Integer consumoCalculado = 0;
					Integer consumoInformado = 0;
					consumoCalculado = consumoHistorico.getNumeroConsumoFaturadoMes();
					consumoInformado = getControladorFaturamento().pesquisarVolumeFaturamentoSituacaoHistorico(imovel.getId(),
									consumoHistorico.getReferenciaFaturamento());

					if(consumoInformado != null && consumoCalculado != null && consumoInformado.intValue() < consumoCalculado.intValue()){

						consumoHistorico.setNumeroConsumoFaturadoMes(consumoInformado);
					}

					// Tipo de Consumo será o valor correspondente à “média informado”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_INFORMADO));

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.LIMITE
								.intValue()){

					/*
					 * O Consumo a Ser Cobrado no Mês será o consumo informado na situação especial
					 * de faturamento
					 */
					Integer consumoInformado = 0;
					consumoInformado = getControladorFaturamento().pesquisarVolumeFaturamentoSituacaoHistorico(imovel.getId(),
									consumoHistorico.getReferenciaFaturamento());

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoInformado);

					// Tipo de Consumo será o valor correspondente à “informado”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.INFORMADO));

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.APENAS_EXCESSO
								.intValue()){

					// O Consumo a Ser Cobrado no Mês será o consumo excedente
					// TODO -> Será implementado futuramente.

					// Tipo de Consumo será o valor correspondente a “excedente”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.EXCEDENTE));
				}
			}

			/*
			 * Leitura Atual de Faturamento (LALT_CDLEITURAAFATURARCOMLEITURA com os seguintes
			 * valores correspondentes na tabela LEITURA_ANORMALIDADE_LEITURA)
			 */
			if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraComLeitura() != null){

				if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraComLeitura().getId().intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA
								.intValue()){

					// <<anterior mais média>>
					// A Leitura Atual de Faturamento será a anterior mais a média
					medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior + consumoMedioImovel);

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraComLeitura().getId().intValue() == LeituraAnormalidadeLeitura.ANTERIOR
								.intValue()){

					// <<anterior>>
					// A Leitura Atual de Faturamento será igual à anterior
					medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);

				}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeLeituraComLeitura().getId().intValue() == LeituraAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO
								.intValue()){

					// <<anterior mais consumo>>
					// A Leitura Atual de Faturamento será a anterior mais o Consumo a Ser Cobrado
					// no Mês
					medicaoHistorico
									.setLeituraAtualFaturamento(leituraAnterior + consumoHistorico.getNumeroConsumoFaturadoMes().intValue());

				}
			}
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0014] - Verificar Estouro de Consumo pelo consumo médio
	 * 
	 * @date 16/03/2011
	 * @author Hebert Falcão
	 */
	@Deprecated
	protected boolean verificarEstouroPeloConsumoMedio(ConsumoHistorico consumoHistorico, Imovel imovel, int[] consumoMedioImovel,
					SistemaParametro sistemaParametro, MedicaoTipo medicaoTipo, MedicaoHistorico medicaoHistorico){

		boolean retorno = false;

		// Obtém o consumo médio do imóvel
		int consumoMedio = consumoMedioImovel[0];

		// Obtém o consumo a ser cobrado no mês
		Integer consumoASerCobradoMes = consumoHistorico.getNumeroConsumoFaturadoMes();
		if(consumoASerCobradoMes == null){
			consumoASerCobradoMes = 0;
		}

		// Obtém 5x o consumo médio do imóvel
		int cincoVezesConsumoMedioImovel = (consumoMedio * 5);

		// Obtem 7x o consumo médio do imóvel
		int seteVezesConsumoMedioImovel = (consumoMedio * 7);

		// Obtem 8x o consumo médio do imóvel
		int oitoVezesConsumoMedioImovel = (consumoMedio * 8);

		// Obtem 9x o consumo médio do imóvel
		int noveVezesConsumoMedioImovel = (consumoMedio * 9);

		// Obtem 20x o consumo médio do imóvel
		int vinteVezesConsumoMedioImovel = (consumoMedio * 20);

		if((consumoMedio >= 30 && consumoASerCobradoMes > cincoVezesConsumoMedioImovel)
						|| (consumoMedio < 30 && consumoMedio >= 20 && consumoASerCobradoMes > seteVezesConsumoMedioImovel)
						|| (consumoMedio < 20 && consumoMedio >= 10 && consumoASerCobradoMes > oitoVezesConsumoMedioImovel)
						|| (consumoMedio < 10 && consumoMedio >= 5 && consumoASerCobradoMes > noveVezesConsumoMedioImovel)
						|| (consumoMedio < 5 && consumoASerCobradoMes > vinteVezesConsumoMedioImovel)){

			// Cria o objeto ligação tipo
			LigacaoTipo ligacaoTipo = new LigacaoTipo();

			Integer idMedicaoTipo = medicaoTipo.getId();
			if(MedicaoTipo.LIGACAO_AGUA.equals(idMedicaoTipo)){
				ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);
			}else if(MedicaoTipo.POCO.equals(idMedicaoTipo)){
				ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
			}

			// Obtém o ano e mês de referência anterior
			int anoMesFaturamento = sistemaParametro.getAnoMesFaturamento();
			int anoMesReferenciaAnterior = Util.subtrairData(anoMesFaturamento);

			Collection consumoHistoricoAnterior = null;

			// Pesquisa o consumo histórico
			try{
				consumoHistoricoAnterior = repositorioMicromedicao.pesquisarConsumoHistoricoConsumoAnormalidade(imovel, ligacaoTipo,
								anoMesReferenciaAnterior);
			}catch(ErroRepositorioException ex){
				new ControladorException("erro.sistema", ex);

			}

			Integer idConsumoAnormalidadeAnterior = null;

			// Verifica se a pesquisa retornou objetos
			if(consumoHistoricoAnterior != null && !consumoHistoricoAnterior.isEmpty()){
				Object[] consumoHistoricoAnteriorArray = Util.retonarObjetoDeColecaoArray(consumoHistoricoAnterior);
				idConsumoAnormalidadeAnterior = (Integer) consumoHistoricoAnteriorArray[1];
			}

			if(!ConsumoAnormalidade.ESTOURO_CONSUMO.equals(idConsumoAnormalidadeAnterior)){
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				consumoAnormalidade.setId(ConsumoAnormalidade.ESTOURO_CONSUMO);
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedio);

				ConsumoTipo consumoTipo = new ConsumoTipo();
				consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);
				consumoHistorico.setConsumoTipo(consumoTipo);

				Integer leituraAtualInformada = medicaoHistorico.getLeituraAtualInformada();
				medicaoHistorico.setLeituraAtualFaturamento(leituraAtualInformada);

				retorno = true;
			}
		}

		return retorno;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SF0014]
	 * [SF0014] - Verificar Estouro de Consumo
	 * 
	 * @date 14/07/2009
	 * @author eduardo henrique
	 *         Correcao para nao verificar estouro de consumo caso tenha se detectado instalação de
	 *         hidrômetro no período.
	 * @throws ControladorException
	 */
	protected boolean verificarEstouroConsumo(ConsumoHistorico consumoHistorico, Imovel imovel, int consumoMedioImovel,
					SistemaParametro sistemaParametro, MedicaoTipo medicaoTipo, Collection colecaoCategoria,
					MedicaoHistorico medicaoHistorico, int leituraAnterior, int consumoMinimoLigacao) throws ControladorException{

		boolean retorno = false;
		boolean estouroMesCorrente = false;

		// [SB0024 – Verificar a existência de hidrômetro substituído no mês]
		boolean existeHidrometroSusbtituidoMes = this.verificarExistenciaHidrometroSubstituidoMes(medicaoHistorico, imovel);

		// Caso tenha tido instalação de hidrômetro no mês
		if(existeHidrometroSusbtituidoMes || consumoMedioImovel == 0){

			// O sistema não verifica estouro de consumo
			return false;
		}

		// O sistema determina se houve estouro de consumo
		int consumoTotalReferencia = 0;
		int consumoMaximoCobrancaEstouroConsumo = 0;
		int maiorQuantidadeEconomia = 0;
		
		// ############# Alterado por Luciano - OC1034808 ############# - Inicio
		// Identifica se o consumo a ser cobrado por categoria é maior que o limite (200 m3)
		boolean consumoASerCobradoPorCategoriaMaiorQueLimite = false; 
		
		Integer pLimiteConsumoASerCobradoPorCategoria = Util.converterStringParaInteger(ParametroMicromedicao.P_LIMITE_CONSUMO_COBRADO_POR_CATEGORIA.executar());
		
		if(pLimiteConsumoASerCobradoPorCategoria == null) {
			throw new ControladorException("atencao.param_nao_cadastrado", null,
							ParametroMicromedicao.P_LIMITE_CONSUMO_COBRADO_POR_CATEGORIA.getCodigo());
		}
		// ############# Alterado por Luciano - OC1034808 ############# - Fim
		
		BigDecimal vezesMediaEstouro = BigDecimal.ZERO;

		Iterator colecaoCategoriaIterator = colecaoCategoria.iterator();

		while(colecaoCategoriaIterator.hasNext()){

			Categoria categoria = (Categoria) colecaoCategoriaIterator.next();

			int qtdEconomias = categoria.getQuantidadeEconomiasCategoria().intValue();

			/*
			 * O sistema obtém o Consumo Máximo para Cobrança de Estouro de Consumo acumulando o
			 * consumo
			 * máximo por economia para cobrança de estouro de consumo de cada categoria
			 * (CATG_NNCONSUMOMAXIMOEC) multiplicado pelo número de economias do imóvel na categoria
			 * retornado pelo [UC0108]
			 */
			consumoMaximoCobrancaEstouroConsumo = consumoMaximoCobrancaEstouroConsumo
							+ (categoria.getNumeroConsumoMaximoEc().intValue() * qtdEconomias);

			/*
			 * O sistema obtém o Consumo Total de Referência acumulando o consumo por economia de
			 * referência de cada categoria (CATG_NNCONSUMOESTOURO) multiplicado pelo número de
			 * economias do imóvel na categoria <<Inclui>> [UC0108 – Obter Quantidade Economias por
			 * Categoria]
			 */
			consumoTotalReferencia = consumoTotalReferencia + (categoria.getConsumoEstouro().intValue() * qtdEconomias);

			/*
			 * Obtém a maior quantidade de economias e o fator de multiplicação da média da
			 * categoria do imóvel que tenha o maior número de economias
			 */
			if(maiorQuantidadeEconomia < qtdEconomias){

				maiorQuantidadeEconomia = qtdEconomias;
				vezesMediaEstouro = categoria.getVezesMediaEstouro();
			}
			
			// ############# Alterado por Luciano - OC1034808 ############# - Inicio
			if(categoria.getConsumoViradaHidrometro() > pLimiteConsumoASerCobradoPorCategoria) {
				consumoASerCobradoPorCategoriaMaiorQueLimite = true;
			}
			// ############# Alterado por Luciano - OC1034808 ############# - Fim
			
		}

		// Obtém o consumo a ser cobrado no mês
		Integer consumoASerCobradoMes = consumoHistorico.getNumeroConsumoFaturadoMes();

		if(consumoASerCobradoMes == null){

			consumoASerCobradoMes = 0;
		}

		/*
		 * Parâmetro que indica o critério utilizado para determinar um estouro de consumo.
		 */
		String parametroCriterioEstouroConsumo = (String) ParametroMicromedicao.P_CRITERIO_ESTOURO_CONSUMO.executar(this, 0);

		// Caso o parâmetro indique pela categoria
		if(parametroCriterioEstouroConsumo.equals(CriterioEstouroConsumo.UM.getValor())){

			// Converte o consumo médio para big decimal
			BigDecimal consumoMedioImovelAuxiliar = new BigDecimal(String.valueOf(consumoMedioImovel));

			// Multiplica o consumo médio do imóvel pela média da categoria do
			// imóvel que tenha maior número de economias
			BigDecimal resultado = consumoMedioImovelAuxiliar.multiply(vezesMediaEstouro);

			// Arredonda o resultado
			int consumoMedioFatorMultiplicacao = Util.arredondar(resultado);

			/*
			 * Consumo a Ser Cobrado no Mês seja superior ao Consumo Total de Referência obtido e ao
			 * consumo médio do imóvel multiplicado pelo fator de multiplicação da média da
			 * categoria do imóvel que tenha o maior número de economias (CATG_NNVEZESMEDIAESTOURO)
			 */
			if(consumoASerCobradoMes > consumoTotalReferencia && consumoASerCobradoMes > consumoMedioFatorMultiplicacao){

				estouroMesCorrente = true;
			}
		}else if(parametroCriterioEstouroConsumo.equals(CriterioEstouroConsumo.DOIS.getValor())){

			// Ou caso o valor indique Pela Faixa de Consumo
			List<ConsumoAnormalidadeFaixa> colecaoConsumoAnormalidadeFaixa = null;
			try{

				colecaoConsumoAnormalidadeFaixa = repositorioMicromedicao.pesquisarConsumoAnormalidadeFaixa();
			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);
			}

			if(!Util.isVazioOrNulo(colecaoConsumoAnormalidadeFaixa)){

				for(ConsumoAnormalidadeFaixa consumoAnormalidadeFaixa : colecaoConsumoAnormalidadeFaixa){

					/*
					 * Caso Consumo a ser Cobrado no Mês seja superior ao consumo médio do imóvel
					 * multiplicado
					 * pelo Fator de Multiplicação da Média obtido através da faixa de consumo da
					 * anormalidade
					 */
					if(consumoAnormalidadeFaixa.getNumeroFaixaInicio() <= consumoMedioImovel
									&& consumoAnormalidadeFaixa.getNumeroFaixaFim() >= consumoMedioImovel){
						if(consumoASerCobradoMes.intValue() > (consumoMedioImovel * consumoAnormalidadeFaixa.getNumeroVezesMedia()
										.intValue())){

							estouroMesCorrente = true;
						}

					}
				}
			}

			// ############# Alterado por Luciano - OC1034808 ############# - Inicio
		}else if(parametroCriterioEstouroConsumo.equals(CriterioEstouroConsumo.TRES.getValor())){
			

			// Ou caso o valor indique Pela Média de Consumo e pela Categoria

			Integer pFatorMultiplicacaoMediaConsumo = Util.converterStringParaInteger(ParametroMicromedicao.P_FATOR_MULTIPLICACAO_MEDIA_CONSUMO.executar());
			
			if(pFatorMultiplicacaoMediaConsumo == null){
				throw new ControladorException("atencao.param_nao_cadastrado", null,
								ParametroMicromedicao.P_FATOR_MULTIPLICACAO_MEDIA_CONSUMO.getCodigo());
			}

			// Consumo a ser Cobrado no Mês seja superior ao consumo médio do imóvel multiplicado
			// pelo Fator de Multiplicação da Média e o Consumo a ser cobrado por categoria
			// seja maior que limite de consumo a ser cobrado por categoria
			if(consumoASerCobradoMes > (consumoMedioImovel * pFatorMultiplicacaoMediaConsumo) && consumoASerCobradoPorCategoriaMaiorQueLimite) {
				estouroMesCorrente = true;
			}
			// ############# Alterado por Luciano - OC1034808 ############# - Fim
		}


		if(estouroMesCorrente){

			retorno = true;

			// Define o tipo de ligação
			LigacaoTipo ligacaoTipo = new LigacaoTipo();

			if(medicaoTipo.getId().intValue() == MedicaoTipo.LIGACAO_AGUA.intValue()){

				ligacaoTipo.setId(LigacaoTipo.LIGACAO_AGUA);

			}else if(medicaoTipo.getId().intValue() == MedicaoTipo.POCO.intValue()){

				ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);

			}

			// Obtém o ano e mês de referência anterior
			int anoMesReferenciaAnterior = Util.subtrairData(sistemaParametro.getAnoMesFaturamento());

			Collection consumoHistoricoAnterior = null;

			// Pesquisa o consumo histórico para obter anormalidade do mês anterior
			try{

				consumoHistoricoAnterior = repositorioMicromedicao.pesquisarConsumoHistoricoConsumoAnormalidade(imovel, ligacaoTipo,
								anoMesReferenciaAnterior);
			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				new ControladorException("erro.sistema", ex);

			}

			ConsumoAnormalidade consumoAnormalidadeMesAnterior = null;

			if(!Util.isVazioOrNulo(consumoHistoricoAnterior)){

				Object[] consumoHistoricoAnteriorArray = Util.retonarObjetoDeColecaoArray(consumoHistoricoAnterior);

				consumoAnormalidadeMesAnterior = new ConsumoAnormalidade();
				consumoAnormalidadeMesAnterior.setId((Integer) consumoHistoricoAnteriorArray[1]);
			}

			/*
			 * Caso não tenha ocorrido estouro de consumo com cobrança de média nem estouro de
			 * consumo no mês anterior ou o Consumo a Ser Cobrado no Mês seja superior ao Consumo
			 * Máximo para Cobrança de Estouro de Consumo obtido.
			 */
			if((consumoAnormalidadeMesAnterior != null && consumoAnormalidadeMesAnterior.getId() != null
							&& consumoAnormalidadeMesAnterior.getId().intValue() != ConsumoAnormalidade.ESTOURO_CONSUMO.intValue() && consumoAnormalidadeMesAnterior
							.getId().intValue() != ConsumoAnormalidade.ESTOURO_CONSUMO_COBRANCA_MEDIA)
							|| (consumoASerCobradoMes > consumoMaximoCobrancaEstouroConsumo)){

				/*
				 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “estouro de
				 * consumo com cobrança de média”
				 */
				ConsumoAnormalidade consumoAnormalidade = null;
				try{

					consumoAnormalidade = repositorioMicromedicao
									.pesquisarConsumoAnormalidade(ConsumoAnormalidade.ESTOURO_CONSUMO_COBRANCA_MEDIA);
				}catch(ErroRepositorioException ex){

					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

				// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
				boolean definirConsumoPelaAnormalidade = this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico,
								medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao, consumoAnormalidade, consumoASerCobradoMes);

				if(definirConsumoPelaAnormalidade == false){

					/*
					 * Parametro que indica a regra a ser utilizada quando a média for igual a zero
					 * (0).
					 */
					String parametroTratamentoMediaZerada = (String) ParametroMicromedicao.P_TRATAMENTO_MEDIA_ZERADA.executar(this, 0);

					/* O sistema Calcula Consumo a Ser Cobrado no Mês */
					if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.UM.getValor())){

						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
					}else if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.DOIS.getValor())){

						// Caso o consumo médio do imóvel seja igual “zero”
						if(consumoMedioImovel == 0){

							/*
							 * Consumo a Ser Cobrado no Mês será o Consumo Medido
							 * (MDHI_NNCONSUMOMEDIDOMES),
							 * caso esse seja maior que zero, caso contrário, o Consumo a Ser
							 * Cobrado no
							 * Mês
							 * será o mínimo da ligação <<Inclui>> [UC0105 – Obter Consumo Mínimo da
							 * Ligação]
							 */
							if(medicaoHistorico.getNumeroConsumoMes() != null && medicaoHistorico.getNumeroConsumoMes() > 0){

								consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoMes());
							}else{

								int consumoMinimo = 0;
								consumoMinimo = obterConsumoMinimoLigacao(imovel, null);
								consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimo);
							}
						}else{

							// Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
							consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
						}
					}

					// O Tipo de Consumo será o valor correspondente à “média do imóvel”
					consumoHistorico.setConsumoTipo(new ConsumoTipo(ConsumoTipo.MEDIA_IMOVEL));

					// A Leitura Atual de Faturamento será a Leitura Atual Informada
					medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());
				}

			}else{

				/*
				 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “estouro de
				 * consumo”
				 */
				ConsumoAnormalidade consumoAnormalidade = null;
				try{

					consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.ESTOURO_CONSUMO);
				}catch(ErroRepositorioException ex){

					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", ex);
				}

				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

				// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
				this.verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico, consumoMedioImovel,
								consumoMinimoLigacao, consumoAnormalidade, consumoASerCobradoMes);
			}
		}

		return retorno;
	}

	// protected void ajusteMensalConsumo(MedicaoHistorico medicaoHistorico, ConsumoHistorico
	// consumoHistorico, Imovel imovel,
	// MedicaoTipo medicaoTipo, Rota rota, int consumoMinimoImovel, SistemaParametro
	// sistemaParametro){
	//
	// int quantidadeDiasConsumoAjustado = 0;
	//
	// // Obtém a quantidade de dias de consumo
	// int quantidadeDiasConsumo = (int)
	// IoUtil.diferencaEntreDatas(medicaoHistorico.getDataLeituraAnteriorFaturamento(),
	// medicaoHistorico
	// .getDataLeituraAtualFaturamento());
	//
	// // Verifica se a data do ajuste é não nula
	// if(rota.getDataAjusteLeitura() != null){
	// // Obtém a quantidade de dias de consumo ajustado
	// quantidadeDiasConsumoAjustado = (int)
	// IoUtil.diferencaEntreDatas(medicaoHistorico.getDataLeituraAnteriorFaturamento(), rota
	// .getDataAjusteLeitura());
	//
	// }else{
	//
	// // Cria objeto
	// Calendar data = Calendar.getInstance();
	//
	// // Seta a data com a data de leitura anterior faturamento
	// data.setTime(medicaoHistorico.getDataLeituraAnteriorFaturamento());
	//
	// // Obtém a quantidade de dias
	// int dias = data.getActualMaximum(Calendar.DAY_OF_MONTH);
	//
	// // Obtém a quantidade de dias de consumo ajustado
	// quantidadeDiasConsumoAjustado = dias;
	// }
	//
	// // Obtém os dias de ajuste
	// int diasAjuste = quantidadeDiasConsumoAjustado - quantidadeDiasConsumo;
	//
	// if(diasAjuste < -3 || diasAjuste > 3){
	//
	// // Cálculo para obter a leitura ajustada
	// int leituraAjustada = medicaoHistorico.getLeituraAtualFaturamento()
	// + Util.divideDepoisMultiplica(consumoHistorico.getNumeroConsumoFaturadoMes().intValue(),
	// quantidadeDiasConsumo,
	// diasAjuste);
	//
	// int numeroDigitosHidrometro = 0;
	//
	// // Verifica qual o tipo de medicação e obtém o número de dígitos do
	// // hidrômetro
	// if(medicaoTipo.getId() == MedicaoTipo.LIGACAO_AGUA){
	// numeroDigitosHidrometro =
	// imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getHidrometro()
	// .getNumeroDigitosLeitura().intValue();
	// }else if(medicaoTipo.getId() == MedicaoTipo.POCO){
	// numeroDigitosHidrometro =
	// imovel.getHidrometroInstalacaoHistorico().getHidrometro().getNumeroDigitosLeitura().intValue();
	// }
	//
	// // Obtém 10 elevado ao numeroDigitosHidrometro
	// int dezElevadoNumeroDigitos = (int) Math.pow(10, numeroDigitosHidrometro);
	//
	// // Obtém 10 elevado ao numeroDigitosHidrometro - 1
	// int dezElevadoNumeroDigitosMenosUm = ((int) Math.pow(10, numeroDigitosHidrometro)) - 1;
	//
	// // Caso a leitura ajustada menor que 0
	// if(leituraAjustada < 0){
	// medicaoHistorico.setLeituraAtualFaturamento(leituraAjustada + dezElevadoNumeroDigitos);
	//
	// // Caso a leitura ajustada maior dez elevado ao número de dígitos menos um
	// }else if(leituraAjustada > dezElevadoNumeroDigitosMenosUm){
	// medicaoHistorico.setLeituraAtualFaturamento(leituraAjustada - dezElevadoNumeroDigitos);
	//
	// // Caso demais casos
	// }else{
	// medicaoHistorico.setLeituraAtualFaturamento(leituraAjustada);
	// }
	//
	// // Obtém o consumo a ser cobrado mês
	// int consumoASerCobradoMes =
	// Util.divideDepoisMultiplica(consumoHistorico.getNumeroConsumoFaturadoMes(),
	// quantidadeDiasConsumo,
	// quantidadeDiasConsumoAjustado);
	//
	// // Seta o consumo a ser cobrado mês
	// consumoHistorico.setNumeroConsumoFaturadoMes(consumoASerCobradoMes);
	//
	// // Adiciona ou subtrai de acordo com os dias de ajuste
	// Date dataLeituraAtualFaturamento =
	// IoUtil.adicionarDias(medicaoHistorico.getDataLeituraAtualFaturamento(), diasAjuste);
	//
	// // Seta a data da leitura atual de faturamento
	// medicaoHistorico.setDataLeituraAtualFaturamento(dataLeituraAtualFaturamento);
	// }
	// }

	// /**
	// * @author eduardo henrique
	// * @date 10/12/2008
	// * @exception ControladorException
	// */
	// protected void determinarAjusteConsumoMinimoLigacao(Imovel imovel, MedicaoHistorico
	// medicaoHistorico,
	// ConsumoHistorico consumoHistorico, ConsumoTipo consumoTipo, ConsumoAnormalidade
	// consumoAnormalidade)
	// throws ControladorException{
	//
	// // Caso o consumo a ser cobrado no mês seja menor que o consumo
	// // mínimo de água
	// try{
	// if(medicaoHistorico.getNumeroConsumoInformado() != null){
	//
	// // Seta o consumo histórico
	// consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoInformado());
	//
	// // Seta o consumo anormalidade
	// consumoTipo.setId(ConsumoTipo.INFORMADO);
	//
	// consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_INFORMADO);
	//
	// }
	// }catch(Exception ex){
	// throw new ControladorException("erro.sistema", ex);
	// }
	// }

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SF0018] - Ajuste do Consumo para Múltiplo da Quantidade de Economias
	 * Correção no Ajuste Consumo Multiplo Quantidade Economias - vsm - 20/12/2008
	 * 
	 * @author eduardo henrique
	 * @date 30/01/2009
	 *       Correção no método para atribuir o 'ConsumoMinimoCreditado' (credito efetivamente
	 *       utilizado) no Consumo Historico.
	 */
	public void ajusteConsumoMultiploQuantidadeEconomias(Imovel imovel, MedicaoHistorico medicaoHistorico,
					ConsumoHistorico consumoHistorico, int quantidadeEconomias, int consumoMinimoLigacao) throws ControladorException{

		// ############# Alterado por Luciano - OC1034808 ############# - Inicio

		ParametroMicromedicao.P_AJUSTAR_CONSUMO_MULTIPLO_QTD_ECONOMIAS.executar(this, -1, imovel, medicaoHistorico, consumoHistorico,
						quantidadeEconomias, consumoMinimoLigacao);

		// ############# Alterado por Luciano - OC1034808 ############# - Fim
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SF0022] - Dados para Faturamento Especial do Não Medido
	 * Customização para v0.05
	 * 
	 * @author Virgínia Melo
	 * @Date 23/09/2008
	 * @author eduardo henrique
	 * @date 14/02/2009
	 *       Alteração no método para incluir situação do ATE_LIMITE
	 *       //TODO unificar método junto com o EspecialMedido para facilitar futuras manutenções
	 */
	protected void dadosFaturamentoEspecialNaoMedido(ConsumoHistorico consumoHistorico, int consumoMedioImovel, Imovel imovel,
					int consumoMinimoLigacao, MedicaoHistorico medicaoHistorico) throws ControladorException{

		Collection colecaoFaturamentoSituacaoTipo = null;

		ConsumoTipo consumoTipo = new ConsumoTipo();

		try{
			// Pesquisa a anormalidade de leitura de faturamento
			colecaoFaturamentoSituacaoTipo = repositorioMicromedicao.pesquisarFaturamentoSituacaoTipo(imovel.getFaturamentoSituacaoTipo());

		}catch(ErroRepositorioException ex){
			// sessionContext.setRollbackOnly();
			new ControladorException("erro.sistema", ex);
		}

		// Obtém a leitura anormalidade
		FaturamentoSituacaoTipo faturamentoSituacaoTipo = obterFaturamentoSituacaoTipo(colecaoFaturamentoSituacaoTipo);

		// Seta a leitura anormalidade faturamento
		imovel.getFaturamentoSituacaoTipo().setLeituraAnormalidadeConsumoSemLeitura(
						faturamentoSituacaoTipo.getLeituraAnormalidadeConsumoSemLeitura());
		imovel.getFaturamentoSituacaoTipo().setLeituraAnormalidadeConsumoComLeitura(
						faturamentoSituacaoTipo.getLeituraAnormalidadeConsumoComLeitura());
		imovel.getFaturamentoSituacaoTipo().setLeituraAnormalidadeLeituraSemLeitura(
						faturamentoSituacaoTipo.getLeituraAnormalidadeLeituraSemLeitura());
		imovel.getFaturamentoSituacaoTipo().setLeituraAnormalidadeLeituraComLeitura(
						faturamentoSituacaoTipo.getLeituraAnormalidadeLeituraComLeitura());

		if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.NAO_OCORRE
						.intValue()){

			// Consumo a ser cobrado no mês será o consumo médio do imóvel
			consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMedioImovel));

			// Seta o tipo de consumo
			consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

			// Caso a leitura anormalidade consumo sem leitura seja igual a leitura anormalidade
			// consumo mínimo
		}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MINIMO
						.intValue()){

			// Mínimo
			// O Tipo de Consumo será o valor correspondente a “consumo mínimo”
			consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

			// Caso seja para tratar mínimo com valor zero (0)
			/*
			 * Parametro que indica valor atribuído ao consumo do mês quando for definida a
			 * cobrança de mínimo na consistência de leitura
			 */
			String parametroCobrancaConsumoMinimo = (String) ParametroMicromedicao.P_COBRANCA_CONSUMO_MINIMO.executar(this, 0);

			// Caso seja para tratar mínimo com valor zero (0)
			if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.DOIS.getValor())){

				// O Consumo Ser Cobrado no Mês será igual a zero (0)
				consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
			}else{

				/*
				 * O Consumo a Ser Cobrado no Mês será o mínimo da ligação <<Inclui>>
				 * [UC0105 –
				 * Obter Consumo Mínimo da Ligação]
				 */
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
			}

		}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.MEDIA
						.intValue()){

			/*
			 * Parametro que indica a regra a ser utilizada quando a média for igual a zero
			 * (0).
			 */
			String parametroTratamentoMediaZerada = (String) ParametroMicromedicao.P_TRATAMENTO_MEDIA_ZERADA.executar(this, 0);

			/* O sistema Calcula Consumo a Ser Cobrado no Mês */
			if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.UM.getValor())){

				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
			}else if(parametroTratamentoMediaZerada.equals(TratamentoMediaZerada.DOIS.getValor())){

				// Caso o consumo médio do imóvel seja igual “zero”
				if(consumoMedioImovel == 0){

					/*
					 * Consumo a Ser Cobrado no Mês será o Consumo Medido
					 * (MDHI_NNCONSUMOMEDIDOMES),
					 * caso esse seja maior que zero, caso contrário, o Consumo a Ser
					 * Cobrado no
					 * Mês
					 * será o mínimo da ligação <<Inclui>> [UC0105 – Obter Consumo Mínimo da
					 * Ligação]
					 */
					if(medicaoHistorico != null && medicaoHistorico.getNumeroConsumoMes() != null
									&& medicaoHistorico.getNumeroConsumoMes() > 0){

						consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoMes());
					}else{

						int consumoMinimo = 0;
						consumoMinimo = obterConsumoMinimoLigacao(imovel, null);
						consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimo);
					}
				}else{

					// Consumo a Ser Cobrado no Mês será o Consumo Médio do Imóvel
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
				}
			}

			// O Tipo de Consumo será o valor correspondente à “média do imóvel”
			consumoTipo.setId(ConsumoTipo.MEDIA_IMOVEL);

			// LIMITE.
		}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoSemLeitura().getId().intValue() == LeituraAnormalidadeConsumo.LIMITE
						.intValue()){

			// O Consumo a Ser Cobrado no Mês será o consumo informado
			Integer volumeFaturamentoSituacaoHistorico = Integer.valueOf(0);
			volumeFaturamentoSituacaoHistorico = getControladorFaturamento().pesquisarVolumeFaturamentoSituacaoHistorico(imovel.getId(),
							consumoHistorico.getReferenciaFaturamento());

			if(volumeFaturamentoSituacaoHistorico != null){
				consumoHistorico.setNumeroConsumoFaturadoMes(volumeFaturamentoSituacaoHistorico);
			}

			// O Tipo de Consumo será o valor correspondente a “consumo mínimo fixado”
			consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

		}else if(imovel.getFaturamentoSituacaoTipo().getLeituraAnormalidadeConsumoComLeitura().getId().intValue() == LeituraAnormalidadeConsumo.ATE_LIMITE
						.intValue()){

			// O Consumo a Ser Cobrado no Mês será o menor entre o consumo informado na situação
			// especial de faturamento (FTSH_NNVOLUME da tabela FATURAMENTO_SITUACAO_HISTORICO)
			// e o Consumo a Ser Cobrado no Mês já calculado anteriormente
			Integer consumoCalculado = 0;
			Integer consumoInformado = 0;
			consumoCalculado = consumoHistorico.getNumeroConsumoFaturadoMes();
			consumoInformado = getControladorFaturamento().pesquisarVolumeFaturamentoSituacaoHistorico(imovel.getId(),
							consumoHistorico.getReferenciaFaturamento());

			if(consumoInformado != null && consumoCalculado != null && consumoInformado.intValue() < consumoCalculado.intValue()){

				// Consumo informado
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoInformado);

				// Seta o tipo de consumo
				consumoTipo.setId(ConsumoTipo.INFORMADO);

			}else{
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);
			}

		}

		// Seta o consumo tipo
		if(consumoTipo.getId() != null){
			consumoHistorico.setConsumoTipo(consumoTipo);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0002] - Determinar Dados para Faturamento de Esgoto
	 * 
	 * @author Leonardo Vieira
	 * @date 06/12/2006
	 * @author eduardo henrique
	 * @date 31/01/2009
	 *       Adição de tratamento para não determinação de Consumo.
	 * @author Saulo Lima
	 * @date 05/10/2009
	 *       Alterações para TEE (Tratamento Esgoto Especial)
	 */
	public void determinarDadosFaturamentoEsgoto(Imovel imovel, int[] consumoMedioImovel, ConsumoHistorico consumoHistoricoEsgoto,
					ConsumoHistorico consumoHistoricoAgua, int quantidadeEconomias, SistemaParametro sistemaParametro, Rota rota,
					Collection colecaoInserirConsumoHistoricoEsgoto, FaturamentoGrupo faturamentoGrupo,
					Collection colecaoInserirMedicaoHistoricoEsgoto, Collection colecaoAtualizarMedicaoHistoricoEsgoto,
					EsferaPoder esferaPoder, int consumoMinimoLigacao) throws ControladorException{

		// Cria objeto
		MedicaoHistorico medicaoHistoricoPoco = null;
		MedicaoTipo medicaoTipo = null;

		// Caso o imóvel possua hidrômetro no poco
		if(imovel.getHidrometroInstalacaoHistorico() != null){

			// [SB0005] - Determinar Dados para Faturamento de Esgoto Medido no Poço
			medicaoHistoricoPoco = new MedicaoHistorico();

			medicaoTipo = new MedicaoTipo();
			medicaoTipo.setId(MedicaoTipo.POCO);

			// [SB0013] - Obter Dados do Histórico de Medição
			medicaoHistoricoPoco = this.obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo, sistemaParametro);

			medicaoHistoricoPoco.setImovel(imovel);

			// Alteração solicitada por Luciene em 08/10/2008. Implementada por Virgínia Melo.
			// Iniciando este campo sempre com o valor do Mês anterior, não haverá problema
			// de crédito quando esta funcionalidade for executada mais de uma vez.
			Collection colecaoParmsMedicaoAnterior = null;
			int anoMesReferencia = medicaoHistoricoPoco.getAnoMesReferencia();
			int anoMesAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia, 1);

			// Pesquisa pela Medição Histórico do Mês Anterior.
			try{
				colecaoParmsMedicaoAnterior = repositorioMicromedicao.pesquisarMedicaoHistoricoAnterior(Collections.singletonList(imovel),
								anoMesAnterior, medicaoTipo.getId());
			}catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}

			// Caso não encontre registro, o Crédito Anterior será ZERO.
			if(colecaoParmsMedicaoAnterior == null || colecaoParmsMedicaoAnterior.isEmpty()){
				medicaoHistoricoPoco.setConsumoCreditoAnterior(Integer.valueOf(0));
			}

			Iterator colecaoParmsMedicaoAnteriorIterator = colecaoParmsMedicaoAnterior.iterator();

			while(colecaoParmsMedicaoAnteriorIterator.hasNext()){
				Object[] dadosAnterioresMedicaoHistorico = (Object[]) colecaoParmsMedicaoAnteriorIterator.next();

				if(dadosAnterioresMedicaoHistorico[7] != null){
					medicaoHistoricoPoco.setConsumoCreditoAnterior((Integer) dadosAnterioresMedicaoHistorico[7]);
				}
			}
			// Fim nova alteração - 08/10/2008

			// Alteração solicitada por Aryed 10/12/2007 e realizada por Leonardo Vieira na mesma
			// data
			// O consumo médio do hidrômetro deve ser igual do do imóvel

			// [UC0102] - Obter Consumo Médio do Hidrômetro
			int[] consumoMedioHidrometro = consumoMedioImovel;

			/* obterConsumoMedioHidrometro(imovel, sistemaParametro, medicaoTipo); */

			medicaoHistoricoPoco.setConsumoMedioHidrometro(Integer.valueOf(consumoMedioHidrometro[0]));

			// [SB0012] - Obter Leitura Anterior
			int leituraAnterior = this.obterLeituraAnterior(medicaoHistoricoPoco);

			// *******IMPRESSÃO EM TELA PARA TESTE********//
			System.out.println("---Matrícula do Imóvel: " + imovel.getId() + " ---Consumo médio hidrômetro: " + consumoMedioHidrometro[0]);
			System.out.println("---Leitura Anterior:    " + leituraAnterior + " ---Leitura Atual Informada: "
							+ medicaoHistoricoPoco.getLeituraAtualInformada());

			// Leitura atual informada diferente de nulo
			if(medicaoHistoricoPoco.getLeituraAtualInformada() != null){

				// Leitura atual informada <<<MAIOR>>> que a leitura anterior obtida
				if(medicaoHistoricoPoco.getLeituraAtualInformada().intValue() > leituraAnterior){

					// [SB0007] - Dados para Faturamento para Leitura Maior que a Anterior
					this.dadosFaturamentoLeituraMaiorAnterior(medicaoHistoricoPoco, consumoHistoricoEsgoto, consumoMedioHidrometro[0],
									imovel, sistemaParametro, leituraAnterior);

					// Leitura atual informada <<<IGUAL>>> a leitura anterior obtida
				}else if(medicaoHistoricoPoco.getLeituraAtualInformada().intValue() == leituraAnterior){

					// [SB0008] - Dados para Faturamento para Leitura Igual a Anterior
					this.dadosFaturamentoLeituraIgualAnterior(medicaoHistoricoPoco, consumoHistoricoEsgoto, medicaoTipo, imovel,
									consumoHistoricoAgua, faturamentoGrupo, sistemaParametro, consumoMinimoLigacao, consumoMedioImovel[0]);

					// Leitura atual informada <<<MENOR>>> a leitura anterior obtida
				}else if(medicaoHistoricoPoco.getLeituraAtualInformada().intValue() < leituraAnterior){

					// [SB0009] - Dados para Faturamento para Leitura Menor que a Anterior
					this.dadosFaturamentoLeituraMenorAnterior(imovel, consumoHistoricoEsgoto, medicaoHistoricoPoco, sistemaParametro,
									leituraAnterior, medicaoTipo, consumoMedioImovel[0], consumoMedioHidrometro[0], consumoMinimoLigacao);
				}

				// Caso a leitura atual inforamda seja igual 0 e a leitura anormalidade de
				// faturamento seja nula
			}else if(medicaoHistoricoPoco.getLeituraAtualInformada() == null
							&& medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() == null){

				// [SB0010] - Dados para Faturamento para Leitura Não Informada e Sem Anormalidade
				// de Leitura
				this.dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(medicaoHistoricoPoco, consumoHistoricoEsgoto,
								leituraAnterior, consumoMedioImovel[0], consumoMinimoLigacao);
			}

			// Sistema determina os dados para faturamento caso a anormalidade
			// de faturamento seja diferente de nulo
			if(medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() != null){

				// [SB0011] - Dados para Faturamento Com Anormalidade de Leitura
				this.dadosFaturamentoComAnormalidadeLeitura(medicaoHistoricoPoco, consumoHistoricoEsgoto, consumoMedioHidrometro[0],
								leituraAnterior, imovel, consumoMinimoLigacao);
			}

			/*
			 * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson Carvalho
			 * Sistema determina os dados para faturamento caso o imóvel esteja com situação de
			 * faturamento especial (DIFERENTE DE NULO) e que seja
			 * válido para esgoto.
			 */
			if(imovel.getFaturamentoSituacaoTipo() != null && imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto() != null
							&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().intValue() == 1){

				// [SB0021] - Dados para Faturamento Especial do Medido
				this.dadosFaturamentoEspecialMedido(medicaoHistoricoPoco, consumoHistoricoEsgoto, imovel, consumoMedioImovel[0],
								leituraAnterior, consumoMinimoLigacao);
			}

			// se não conseguiu determinar Consumo, atribui-se 0
			if(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() == null){
				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(Integer.valueOf(0));
			}

			// Parâmetro que indica a ação a ser realizada no ajuste mensal
			String parametroAcaoAjusteConsumo = (String) ParametroMicromedicao.P_ACAO_AJUSTE_CONSUMO.executar(this, 0);

			// Caso o valor indique Data de Instalação igual à Data de Leitura
			if(parametroAcaoAjusteConsumo.equals(AcaoAjusteConsumo.DOIS.getValor())
							|| parametroAcaoAjusteConsumo.equals(AcaoAjusteConsumo.TRES.getValor())){

				// [SB0023] - Consistência Datas de Leitura Atual e Anterior
				this.consistirDatasLeituraAtualAnterior(medicaoHistoricoPoco, imovel, medicaoTipo);
			}

			// Obtém a quantidade de economias por categoria
			Collection colecaoCategoria = this.getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

			// [SB0014] - Verificar Estouro de Consumo
			if(!verificarEstouroConsumo(consumoHistoricoEsgoto, imovel, consumoMedioImovel[0], sistemaParametro, medicaoTipo,
							colecaoCategoria, medicaoHistoricoPoco, leituraAnterior, consumoMinimoLigacao)){

				// [SB0015] - Verificar Alto Consumo
				this.verificarAltoConsumo(consumoHistoricoEsgoto, consumoMedioImovel[0], colecaoCategoria, imovel, medicaoTipo,
								medicaoHistoricoPoco, leituraAnterior, consumoMinimoLigacao);
			}

			if((medicaoHistoricoPoco.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.CONFIRMADA.intValue() || medicaoHistoricoPoco
							.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.REALIZADA.intValue())
							&& medicaoHistoricoPoco.getLeituraAnormalidadeFaturamento() == null){

				// [SB0016] - Verificar Baixo Consumo
				this.verificarBaixoConsumo(consumoHistoricoEsgoto, consumoMedioImovel[0], colecaoCategoria, imovel, medicaoTipo,
								consumoMinimoLigacao, medicaoHistoricoPoco);
			}

			// Customização para v0.05 - vsm 11.3
			int minimoLigacao = 0;
			int creditoExistente = 0;
			int consumoCobrado = 0;

			// Caso esteja indicado o ajuste mensal do consumo e a situação de ligação indicar
			// ajuste mensal de consumo e o imóvel NÃO esteja com situação de faturamento especial
			// válida para esgoto, o sistema efetua o ajuste mensal
			if(rota.getIndicadorAjusteConsumo() != null
							&& rota.getIndicadorAjusteConsumo().intValue() == Rota.INDICADOR_AJUSTE_MENSAL
							&& imovel.getLigacaoEsgotoSituacao() != null
							&& imovel.getLigacaoEsgotoSituacao().getIndicadorAjusteConsumo().intValue() == ConstantesSistema.SIM.intValue()
							&& (imovel.getFaturamentoSituacaoTipo() == null || (imovel.getFaturamentoSituacaoTipo()
											.getIndicadorValidoEsgoto() != null && imovel.getFaturamentoSituacaoTipo()
											.getIndicadorValidoEsgoto().equals(ConstantesSistema.NAO)))){

				// [SB0017] - Ajuste Mensal do Consumo
				this.ajusteMensalConsumo(medicaoHistoricoPoco, consumoHistoricoEsgoto, imovel, medicaoTipo, rota, minimoLigacao,
								sistemaParametro);
			}

			// Caso exista Consumo a Ser Cobrado no Mês da ligação de água,
			// o Consumo a Ser Cobrado no Mês de esgoto = (Cobrado no Mês da ligação de água + //
			// Consumo a Ser Cobrado no Mês);
			// caso contrário, o Consumo a Ser Cobrado no Mês de esgoto = Consumo a Ser Cobrado no
			// Mês.
			if(consumoHistoricoAgua != null && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null){

				// Seta o consumo histórico
				Integer consumoFaturadoMes = consumoHistoricoAgua.getNumeroConsumoFaturadoMes()
								+ consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();

				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoFaturadoMes);
			}

			if(imovel.getLigacaoEsgoto().getConsumoMinimo() != null){
				minimoLigacao = imovel.getLigacaoEsgoto().getConsumoMinimo().intValue();
			}

			if(medicaoHistoricoPoco.getConsumoCreditoAnterior() != null){
				creditoExistente = medicaoHistoricoPoco.getConsumoCreditoAnterior().intValue();
			}

			if(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes() != null){
				consumoCobrado = consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue();
			}

			if(consumoHistoricoEsgoto.getConsumoTipo() == null){
				ConsumoTipo consumoTipoTemp = new ConsumoTipo();
				consumoTipoTemp.setId(ConsumoTipo.INDEFINIDO);
				consumoHistoricoEsgoto.setConsumoTipo(consumoTipoTemp);
			}else if(consumoHistoricoEsgoto.getConsumoTipo().getId() == null){
				consumoHistoricoEsgoto.getConsumoTipo().setId(ConsumoTipo.INDEFINIDO);
			}

			if(medicaoHistoricoPoco.getConsumoCreditoAnterior() != null
							&& consumoHistoricoEsgoto.getConsumoTipo().getId() == ConsumoTipo.REAL && consumoCobrado >= minimoLigacao){

				if(creditoExistente > 0){

					// Seta o consumo histórico
					consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoCobrado + creditoExistente);

					// Credito Faturado será o crédito existente;
					consumoHistoricoEsgoto.setConsumoMinimoCreditado(creditoExistente);

					// Zera o credito anterior pois utilizou tudo
					medicaoHistoricoPoco.setConsumoCreditoAnterior(Integer.valueOf(0));

					/*
					 * Parâmetro para indicar se o consumo deverá ser ajustado para múltiplo da
					 * quantidade de
					 * economias
					 */
					String parametroAjustarConsumoMultiploQuantidadeEconomias = (String) ParametroFaturamento.P_AJUSTAR_CONSUMO.executar(
									this, 0);

					/*
					 * Caso a quantidade de economias seja maior que 1 e a empresa ajusta o consumo
					 * pela
					 * quantidade de economias
					 */
					if(quantidadeEconomias > 1
									&& parametroAjustarConsumoMultiploQuantidadeEconomias.equals(AjustarConsumoMultiploQtdeEconomias.UM
													.getValor())){
						// [SF0018] - Ajuste do Consumo Múltiplo da Quantidade de Economias
						// Ajuste, pois ao utilizar todo o crédito, pode ser q o valor n seja
						// divisivel
						// pela qtd de economias
						this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistoricoPoco, consumoHistoricoEsgoto,
										quantidadeEconomias, consumoMinimoLigacao);
					}

				}else{
					// o Consumo a Ser Cobrado no mês será o proprio consumo + crédito existente
					// limitando o
					// resultado ao mínimo da ligação e o Crédito Faturado será o crédito utilizado.

					// Pode ser utilizado todo o crédito que mesmo assim não chega ao mínimo da
					// ligação
					if(consumoCobrado + creditoExistente >= minimoLigacao){

						consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoCobrado + creditoExistente);
						consumoHistoricoEsgoto.setConsumoMinimoCreditado(creditoExistente);

						// Zera o credito anterior pois utilizou tudo
						medicaoHistoricoPoco.setConsumoCreditoAnterior(Integer.valueOf(0));

						// Ajuste, pois ao utilizar todo o crédito, pode ser q o valor n seja
						// divisivel pela qtd de economias
						this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistoricoPoco, consumoHistoricoEsgoto,
										quantidadeEconomias, consumoMinimoLigacao);

						// Não pode usar todo o crédito pois tornará o valor a ser pago menor que o
						// mínimo
					}else{

						// Valor que seria cobrado caso pudesse ser menor que o mínimo.
						int valorMenorQueMinimo = consumoCobrado + creditoExistente;

						// Calcula em quanto passou do mínimo
						int valorUltrapassado = minimoLigacao - valorMenorQueMinimo;

						consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(minimoLigacao);
						consumoHistoricoEsgoto.setConsumoMinimoCreditado(creditoExistente + valorUltrapassado);

						// Atualiza o credito anterior
						medicaoHistoricoPoco.setConsumoCreditoAnterior(medicaoHistoricoPoco.getConsumoCreditoAnterior()
										- (creditoExistente + valorUltrapassado));
					}
				}
			}

			// Fim do SB0005
		}else{

			// [SB0006] - Determinar Dados Para Faturamento de Esgoto Sem Poço ou Com Poço Sem
			// Medição

			// Caso exista consumo a ser cobrado para ligação de água
			if(imovel.getLigacaoAgua() != null && consumoHistoricoAgua != null
							&& consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null){

				// O consumo a ser cobrado de esgoto será igual ao de ligação de agua juntamente
				// com
				// o consumo tipo
				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoHistoricoAgua.getNumeroConsumoFaturadoMes());
				consumoHistoricoEsgoto.setConsumoTipo(consumoHistoricoAgua.getConsumoTipo());

			}else{

				/*
				 * Verificar se a Situação da ligação de esgoto (LEST_ID da tabela IMOVEL) ocorre em
				 * algum dos valores da lista (posições pares com tamanho de 2) ( PASI_VLPARAMETRO
				 * da
				 * tabela PARAMETRO_SISTEMA com PASI_CDPARAMETRO =
				 * "P_SIT_LIGAGUA_VERIFICA_CONSUMO_FATURAVEL").
				 * Caso a Situação de ligação de esgoto seja localizada na lista, não será
				 * registrado nenhum Dado para Faturamento de Água (tabela MEDICAO_HISTORICO e
				 * CONSUMO_HISTORICO),
				 * retornar ao fluxo principal
				 */
				Map<Integer, Integer> situacoes = obterSituacaoLigacaoMinimoFaturavel();
				if(situacoes.containsKey(imovel.getLigacaoEsgotoSituacao().getId())){

					return;
				}

				// Parâmetro que indica a a forma de cobrar o consumo do no mês
				String parametroCalculoConsumoMinimoNaoMedidos = (String) ParametroMicromedicao.P_CALCULO_CONSUMO_MINIMO_NAO_MEDIDOS
								.executar(this, 0);

				// Caso o valor indique Data de Instalação igual à Data de Leitura
				if(parametroCalculoConsumoMinimoNaoMedidos.equals(CalculoConsumoMinimoNaoMedidos.CONSUMO_MINIMO_FIXO.toString())){

					// // Caso exista consumo a ser cobrado para ligação de água
					// if(imovel.getLigacaoAgua() != null && consumoHistoricoAgua != null
					// && consumoHistoricoAgua.getNumeroConsumoFaturadoMes() != null){
					//
					// // O consumo a ser cobrado de esgoto será igual ao de ligação de agua
					// juntamente
					// // com
					// // o consumo tipo
					// consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoHistoricoAgua.getNumeroConsumoFaturadoMes());
					// consumoHistoricoEsgoto.setConsumoTipo(consumoHistoricoAgua.getConsumoTipo());
					//
					// }else{

					if(imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

						if(ParametroMicromedicao.P_FATURAR_CONSUMO_FIXO_MENOR_MINIMO.executar(this, 0) == null){

							throw new ControladorException("atencao.parametro_sem_correspondente");
						}

						Short parametroFaturarConsumoFixoMenorQueMinimo = Util
										.obterShort((String) ParametroMicromedicao.P_FATURAR_CONSUMO_FIXO_MENOR_MINIMO.executar(this, 0));

						Integer consumoMinimoFixadoAguaOuEsgoto = null;

						if(imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua() != null){

							consumoMinimoFixadoAguaOuEsgoto = imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua();
						}else if(imovel.getLigacaoEsgoto() != null && imovel.getLigacaoEsgoto().getConsumoMinimo() != null){

							consumoMinimoFixadoAguaOuEsgoto = imovel.getLigacaoEsgoto().getConsumoMinimo();
						}

						// Caso tenha consumo mínimo de água definido (caso exista) -> e não seja
						// inferior ao mínimo da ligação exceto se o parâmetro
						// P_FATURAR_CONSUMO_FIXO_MENOR_MINIMO seja 1 - "Sim"
						if(consumoMinimoFixadoAguaOuEsgoto != null
										&& (consumoMinimoFixadoAguaOuEsgoto.intValue() >= consumoMinimoLigacao || parametroFaturarConsumoFixoMenorQueMinimo
														.equals(ConstantesSistema.SIM))){

							// O consumo a ser cobrado será o consumo minimo fixado
							consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoMinimoFixadoAguaOuEsgoto);

							// Seta o tipo de consumo mínimo fixado
							ConsumoTipo consumoTipo = new ConsumoTipo();
							consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);
							consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);

						}else{

							// O consumo a ser cobrado será o consumo mínimo da ligação
							consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);

							// Seta o tipo de consumo não medido
							ConsumoTipo consumoTipo = new ConsumoTipo();
							consumoTipo.setId(ConsumoTipo.NAO_MEDIDO);
							consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);
						}
					}

					/*
					 * if (medicaoHistorico.getNumeroConsumoInformado() != null) {
					 * consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(medicaoHistorico.
					 * getNumeroConsumoInformado());
					 * consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_INFORMADO);
					 * }
					 */
				}else if(parametroCalculoConsumoMinimoNaoMedidos
								.equals(CalculoConsumoMinimoNaoMedidos.CONSUMO_ESTIMADO_FAIXA_AREA_CATEGORIA.toString())){

					Integer consumoCobradoMes = this.obterConsumoFixadoPorCategoriaPorAreaConstruida(imovel.getId());

					consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoCobradoMes);

					ConsumoTipo consumoTipo = new ConsumoTipo();
					consumoTipo.setId(ConsumoTipo.ESTIMADO);
					// Seta o consumo tipo
					consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);

				}else{
					throw new ControladorException("atencao.parametro_sem_correspondente");
				}
			}

			/*
			 * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson Carvalho
			 * Sistema determina os dados para faturamento caso o imóvel esteja com situação de
			 * faturamento especial (DIFERENTE DE NULO) e que seja válido para esgoto.
			 */
			if(imovel.getFaturamentoSituacaoTipo() != null && imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto() != null
							&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().intValue() == 1){

				// [SB0022] - Dados para Faturamento Especial do Não Medido.
				this.dadosFaturamentoEspecialNaoMedido(consumoHistoricoEsgoto, consumoMedioImovel[0], imovel, consumoMinimoLigacao,
								medicaoHistoricoPoco);
			}

			// TODO - Confirmar com Luciene se realmente este código fonte deve FICAR
			// Saulo Lima - 24/03/2012

			if(imovel.getLigacaoEsgoto() == null || imovel.getLigacaoEsgoto().getPercentualAguaConsumidaColetada() == null){
				System.out.println("imovel = " + imovel.getId());
			}

			// Calcula (percentualColeta / 100) * consumo a ser cobrado mês
			BigDecimal fatorColeta = fatorColeta = imovel.getLigacaoEsgoto().getPercentualAguaConsumidaColetada().divide(
							new BigDecimal("100"));
			fatorColeta = fatorColeta.multiply(new BigDecimal(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue()));
			// Arrendonda o resultado (CRIA O FATOR DE COLETA)
			int consumoSerCobradoMes = Util.arredondar(fatorColeta);

			consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoSerCobradoMes));
			// Caso o consumo a ser cobrado mês seja inferior ao consumo mínimo

			if((imovel.getLigacaoEsgoto().getConsumoMinimo() != null)
							&& (consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue() < imovel.getLigacaoEsgoto()
											.getConsumoMinimo().intValue())){
				// O consumo a ser cobrado mês será o consumo mínimo
				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(imovel.getLigacaoEsgoto().getConsumoMinimo());
				// A anormalidade de consumo será o consumo mínimo fixado de esgoto
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_MINIMO_FIXADO);
				consumoHistoricoEsgoto.setConsumoAnormalidade(consumoAnormalidade);
			}

			// TODO - Fim do to do (Saulo)

			// Fim do SB0006
		}

		if(imovel.getHidrometroInstalacaoHistorico() != null){

			// Caso o consumo informado tenha sido informado
			if(medicaoHistoricoPoco.getNumeroConsumoInformado() != null){

				// Seta o consumo histórico
				consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(medicaoHistoricoPoco.getNumeroConsumoInformado());

				ConsumoTipo consumoTipo = new ConsumoTipo();
				consumoTipo.setId(ConsumoTipo.INFORMADO);
				consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);

				// Seta o consumo anormalidade
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_INFORMADO);
				consumoHistoricoEsgoto.setConsumoAnormalidade(consumoAnormalidade);
			}
		}

		// Customização v5.05
		/*
		 * 2.4. Caso o Consumo a Ser Cobrado no Mês seja inferior ao mínimo da ligação <<Inclui>>
		 * [UC0105 – Obter Consumo Mínimo da Ligação], o
		 * Consumo a Ser Cobrado no Mês de esgoto será o consumo mínimo da ligação e o de Tipo de
		 * Consumo será o valor correspondente a “mínimo
		 * fixado” na tabela CONSUMO_TIPO.
		 */
		if(consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes().intValue() < consumoMinimoLigacao){

			consumoHistoricoEsgoto.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);

			ConsumoTipo consumoTipo = new ConsumoTipo();
			consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);
			consumoHistoricoEsgoto.setConsumoTipo(consumoTipo);
		}

		/*
		 * Parâmetro para indicar se o consumo deverá ser ajustado para múltiplo da quantidade de
		 * economias
		 */
		String parametroAjustarConsumoMultiploQuantidadeEconomias = (String) ParametroFaturamento.P_AJUSTAR_CONSUMO.executar(this, 0);

		/*
		 * Caso a quantidade de economias seja maior que 1 e a empresa ajusta o consumo pela
		 * quantidade de economias
		 */
		if(quantidadeEconomias > 1
						&& parametroAjustarConsumoMultiploQuantidadeEconomias.equals(AjustarConsumoMultiploQtdeEconomias.UM.getValor())){

			// [SF0018] - Ajuste do Consumo Múltiplo da Quantidade de Economias
			this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistoricoPoco, consumoHistoricoEsgoto, quantidadeEconomias,
							consumoMinimoLigacao);
		}

		if(imovel.getHidrometroInstalacaoHistorico() != null){

			// Seta o timestamp do histórico de medição do poço
			medicaoHistoricoPoco.setUltimaAlteracao(new Date());

			if(medicaoHistoricoPoco.getId() == null){
				colecaoInserirMedicaoHistoricoEsgoto.add(medicaoHistoricoPoco);
			}else{
				colecaoAtualizarMedicaoHistoricoEsgoto.add(medicaoHistoricoPoco);
			}

			int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());

			if(sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){

				// Verifica se é faturamento antecipado
				if(imovel.getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
								&& (mes == 11)
								&& esferaPoder != null
								&& esferaPoder.getId() != null
								&& (esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.MUNICIPAL))
												|| esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.ESTADUAL)) || esferaPoder.getId()
												.equals(Integer.valueOf(EsferaPoder.FEDERAL)))){

					MedicaoHistorico medicaoHistoricoPosteriorPoco = new MedicaoHistorico();

					// Adiciona 1 ao mês/ano de faturamento para gerar o mês de dezembro
					sistemaParametro.setAnoMesFaturamento(Util.somaMesAnoMesReferencia(sistemaParametro.getAnoMesFaturamento(), 1));

					medicaoHistoricoPosteriorPoco = this
									.obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo, sistemaParametro);

					// [UC0102] - Obter Consumo Médio do Hidrômetro
					// int[] consumoMedioHidrometroPosterior = obterConsumoMedioHidrometro(imovel,
					// sistemaParametro, medicaoTipo);

					// Retorna ao mês de referência atual
					sistemaParametro.setAnoMesFaturamento(Util.subtrairMesDoAnoMes(sistemaParametro.getAnoMesFaturamento(), 1));

					medicaoHistoricoPosteriorPoco.setLeituraAnormalidadeFaturamento(medicaoHistoricoPoco
									.getLeituraAnormalidadeFaturamento());
					medicaoHistoricoPosteriorPoco.setLeituraAnteriorFaturamento(medicaoHistoricoPoco.getLeituraAtualFaturamento());
					medicaoHistoricoPosteriorPoco.setDataLeituraAnteriorFaturamento(medicaoHistoricoPoco.getDataLeituraAtualFaturamento());

					Date dataAtual = new Date();
					medicaoHistoricoPosteriorPoco.setDataLeituraAtualFaturamento(Util.adicionarNumeroDiasDeUmaData(dataAtual, 30));

					Integer leituraAtual = medicaoHistoricoPoco.getLeituraAtualFaturamento()
									+ consumoHistoricoEsgoto.getNumeroConsumoFaturadoMes();
					medicaoHistoricoPosteriorPoco.setLeituraAtualFaturamento(leituraAtual);

					// Seta o consumo médio do hidrômetro
					// medicaoHistoricoPosterior.setConsumoMedioHidrometro(new
					// Integer(consumoMedioHidrometroPosterior[0]));

					medicaoHistoricoPosteriorPoco.setConsumoMedioHidrometro(medicaoHistoricoPoco.getConsumoMedioHidrometro());
					medicaoHistoricoPosteriorPoco.setUltimaAlteracao(new Date());

					if(medicaoHistoricoPosteriorPoco.getId() == null){
						colecaoInserirMedicaoHistoricoEsgoto.add(medicaoHistoricoPosteriorPoco);
					}else{
						colecaoAtualizarMedicaoHistoricoEsgoto.add(medicaoHistoricoPosteriorPoco);
					}
				}
			}
		}

		// Seta o imóvel
		consumoHistoricoEsgoto.setImovel(imovel);

		// Seta o tipo de ligação
		LigacaoTipo ligacaoTipo = new LigacaoTipo();

		ligacaoTipo.setId(LigacaoTipo.LIGACAO_ESGOTO);
		consumoHistoricoEsgoto.setLigacaoTipo(ligacaoTipo);

		// Seta a referência de faturamento
		consumoHistoricoEsgoto.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());

		// Seta o indicador alteração últimos consumos
		consumoHistoricoEsgoto.setIndicadorAlteracaoUltimosConsumos(ConstantesSistema.NAO);

		// Seta o indicador ajuste
		consumoHistoricoEsgoto.setIndicadorAjuste(rota.getIndicadorAjusteConsumo());

		// Seta o consumo rateio
		consumoHistoricoEsgoto.setConsumoRateio(null);

		// Seta o consumo histórico condomínio
		consumoHistoricoEsgoto.setConsumoHistoricoCondominio(null);

		// Seta o indicador imóvel condomínio
		consumoHistoricoEsgoto.setIndicadorImovelCondominio(imovel.getIndicadorImovelCondominio());

		// Seta o consumo médio do imóvel
		consumoHistoricoEsgoto.setConsumoMedio(Integer.valueOf(consumoMedioImovel[0]));

		// Seta o consumo mínimo de água
		if(imovel.getLigacaoEsgoto() != null){
			consumoHistoricoEsgoto.setConsumoMinimo(imovel.getLigacaoEsgoto().getConsumoMinimo());

			// Seta o percentual de coleta
			if(imovel.getLigacaoEsgoto() != null && imovel.getLigacaoEsgoto().getPercentualAguaConsumidaColetada() != null){
				consumoHistoricoEsgoto.setPercentualColeta(imovel.getLigacaoEsgoto().getPercentualAguaConsumidaColetada());
			}else{
				Integer idLigacaoEsgoto = imovel.getId();
				BigDecimal percentualColeta = this.getControladorLigacaoEsgoto().recuperarPercentualColetaEsgoto(idLigacaoEsgoto);
				if(percentualColeta != null){
					consumoHistoricoEsgoto.setPercentualColeta(percentualColeta);
				}else{
					consumoHistoricoEsgoto.setPercentualColeta(Util.formatarMoedaRealparaBigDecimal("100"));
				}
			}

		}else{
			consumoHistoricoEsgoto.setPercentualColeta(Util.formatarMoedaRealparaBigDecimal("100"));
		}

		// Seta a última alteração
		consumoHistoricoEsgoto.setUltimaAlteracao(new Date());

		// Seta o poco tipo
		consumoHistoricoEsgoto.setPocoTipo(imovel.getPocoTipo());

		// Seta o faturamento situação tipo
		consumoHistoricoEsgoto.setFaturamentoSituacaoTipo(imovel.getFaturamentoSituacaoTipo());

		// Faturar os imóveis sem consumo de água que sejam TEE
		boolean faturaEsgotoSemConsumo = this.verificarFaturamentoEsgotoSemConsumoAgua(imovel, consumoHistoricoAgua);

		/*
		 * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson Carvalho
		 * Seta o indicador de faturamento paralisação
		 */
		if(!faturaEsgotoSemConsumo
						|| (imovel.getFaturamentoSituacaoTipo() != null
										&& imovel.getFaturamentoSituacaoTipo().getIndicadorFaturamentoParalisacaoEsgoto() != null
										&& imovel.getFaturamentoSituacaoTipo().getIndicadorFaturamentoParalisacaoEsgoto().intValue() == 1
										&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto() != null && imovel
										.getFaturamentoSituacaoTipo().getIndicadorValidoEsgoto().intValue() == 1)){
			consumoHistoricoEsgoto.setIndicadorFaturamento(ConstantesSistema.NAO);
		}else{
			consumoHistoricoEsgoto.setIndicadorFaturamento(ConstantesSistema.SIM);
		}

		// Seta o rateio tipo
		if(consumoHistoricoEsgoto.getId() == null){
			RateioTipo rateioTipo = new RateioTipo();
			rateioTipo.setId(RateioTipo.SEM_RATEIO);
			consumoHistoricoEsgoto.setRateioTipo(rateioTipo);
		}

		colecaoInserirConsumoHistoricoEsgoto.add(consumoHistoricoEsgoto);

		int mes = Util.obterMes(sistemaParametro.getAnoMesFaturamento());

		if(sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){

			// Verifica se é faturamento antecipado
			if(imovel.getIndicadorDebitoConta().equals(Imovel.INDICADOR_NAO_DEBITO_AUTOMATICO)
							&& (mes == 11)
							&& esferaPoder != null
							&& esferaPoder.getId() != null
							&& (esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.MUNICIPAL))
											|| esferaPoder.getId().equals(Integer.valueOf(EsferaPoder.ESTADUAL)) || esferaPoder.getId()
											.equals(Integer.valueOf(EsferaPoder.FEDERAL)))){

				ConsumoHistorico consumoHistoricoEsgotoPosterior = new ConsumoHistorico(consumoHistoricoEsgoto);

				consumoHistoricoEsgotoPosterior.setReferenciaFaturamento(Util.somaMesAnoMesReferencia(consumoHistoricoEsgoto
								.getReferenciaFaturamento(), 1));

				consumoHistoricoEsgotoPosterior.setUltimaAlteracao(new Date());

				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				consumoAnormalidade.setId(ConsumoAnormalidade.FATURAMENTO_ANTECIPADO);
				consumoHistoricoEsgotoPosterior.setConsumoAnormalidade(consumoAnormalidade);
				colecaoInserirConsumoHistoricoEsgoto.add(consumoHistoricoEsgotoPosterior);
			}
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * 
	 * @author eduardo henrique
	 * @date 10/12/2008
	 *       Reescrita do método para regras de faturamento de ADA
	 */
	public void consistirLeiturasCalcularConsumos(Imovel imovelRota, FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro,
					EsferaPoder esferaPoder) throws ControladorException{

		try{

			Collection colecaoInserirMedicaoHistoricoAgua = new ArrayList();
			Collection colecaoAtualizarMedicaoHistoricoAgua = new ArrayList();
			Collection colecaoInserirConsumoHistoricoAgua = new ArrayList();

			Collection colecaoInserirMedicaoHistoricoEsgoto = new ArrayList();
			Collection colecaoAtualizarMedicaoHistoricoEsgoto = new ArrayList();
			Collection colecaoInserirConsumoHistoricoEsgoto = new ArrayList();

			if(imovelRota != null){

				// Criação das coleções que serão usadas para persistir
				colecaoInserirMedicaoHistoricoAgua.clear();
				colecaoAtualizarMedicaoHistoricoAgua.clear();
				colecaoInserirConsumoHistoricoAgua.clear();
				colecaoInserirConsumoHistoricoEsgoto.clear();

				Integer idConta = null;
				int quantidadeEconomias = 0;

				/*
				 * Para cada imóvel selecionado ou informado o sistema [FS0005 - Verificar
				 * existência da conta]
				 */
				idConta = (Integer) getControladorFaturamento().verificarExistenciaConta(imovelRota.getId(),
								sistemaParametro.getAnoMesFaturamento());

				/*
				 * Caso já exista conta para o imóvel para o ano e mês de faturamento , o sistema
				 * não determina os dados para faturamento e passa para o próximo imóvel.
				 */
				if(idConta == null){

					/*
					 * Alterado por Raphael Rossiter em 17/09/2007 (Analistas: Aryed Lins e Eduardo
					 * Borges)
					 * OBS: Apagar apenas o consumo dos imóveis que não tenham contas geradas para o
					 * anoMesfaturamento
					 */

					// Deleta os consumos históricos existentes na base para a rota no ano mês de
					// faturamento.
					repositorioMicromedicao.deletarConsumoHistoricoCondominioRETIRAR(imovelRota.getId(), sistemaParametro
									.getAnoMesFaturamento().intValue());

					repositorioMicromedicao.deletarConsumoHistoricoRETIRAR(imovelRota.getId(), sistemaParametro.getAnoMesFaturamento()
									.intValue());

					// Método que limpa os dados de medição histórico já consistidos para o imóvel
					// na referência informada
					repositorioMicromedicao.limparDadosFaturamentoConsitidosMedicaoHistorico(imovelRota.getId(), sistemaParametro
									.getAnoMesFaturamento());

					/*
					 * Alterado por Sávio Luiz Data:21/11/2007 Analista:Aryed Lins
					 * Se o mês de faturamento for igual a 11 e o indicador faturamento
					 * antecipado for igual a 1, então seta o mes de faturamentoigual a 12 para
					 * deletar os consumos historicos.
					 */
					if(Util.obterMes(sistemaParametro.getAnoMesFaturamento()) == 11){
						if(sistemaParametro.getIndicadorFaturamentoAntecipado().equals(ConstantesSistema.SIM)){
							Integer anoMesReferenciaFaturamentoAntecipado = Util.somarData(sistemaParametro.getAnoMesFaturamento());

							// Deleta os consumos históricos existentes na base para a rota no ano
							// mês de faturamento.
							repositorioMicromedicao.deletarConsumoHistoricoCondominioRETIRAR(imovelRota.getId(),
											anoMesReferenciaFaturamentoAntecipado);

							repositorioMicromedicao.deletarConsumoHistoricoRETIRAR(imovelRota.getId(),
											anoMesReferenciaFaturamentoAntecipado);
						}
					}

					// [UC0068] - Obter Consumo Médio do Imóvel
					int[] consumoMedioImovel = obterConsumoMedioImovel(imovelRota, sistemaParametro);

					// [UC0105] - Obter Consumo Mínimo da Ligação
					int consumoMinimoLigacao = this.obterConsumoMinimoLigacao(imovelRota, null);

					// Obtém Quantidade de Economias
					quantidadeEconomias = imovelRota.getQuantidadeEconomias();

					// Cria o objeto histórico de medição e histórico de consumos
					MedicaoHistorico medicaoHistorico = null;
					ConsumoHistorico consumoHistoricoAgua = null;
					ConsumoHistorico consumoHistoricoEsgoto = null;

					// Indicador de Permisão Faturamento da Ligação de Água
					Short ligacaoAguaSituacaoIndicadorFaturamento = imovelRota.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao();

					// Indicador de Permisão Faturamento da Ligação de Esgoto
					Short ligacaoEsgotoSituacaoIndicadorFaturamento = imovelRota.getLigacaoEsgotoSituacao()
									.getIndicadorFaturamentoSituacao();

					// Caso a situação da ligação de água que permita faturamento
					if(ligacaoAguaSituacaoIndicadorFaturamento.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
									|| (imovelRota.getLigacaoAgua() != null && imovelRota.getLigacaoAgua()
													.getHidrometroInstalacaoHistorico() != null)){

						consumoHistoricoAgua = new ConsumoHistorico();

						// [SF0001] - Determinar Dados para Faturamento de Água (Para cada imóvel
						// selecionado)
						this.determinarDadosFaturamentoAgua(medicaoHistorico, consumoHistoricoAgua, imovelRota, faturamentoGrupo,
										sistemaParametro, consumoMedioImovel, quantidadeEconomias, imovelRota.getRota(),
										colecaoInserirMedicaoHistoricoAgua, colecaoAtualizarMedicaoHistoricoAgua,
										colecaoInserirConsumoHistoricoAgua, esferaPoder, consumoMinimoLigacao);
					}

					// CASO O IMÓVEL SEJA LIGADO DE ESGOTO
					if(ligacaoEsgotoSituacaoIndicadorFaturamento.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)){

						consumoHistoricoEsgoto = new ConsumoHistorico();
						consumoHistoricoEsgoto.setRota(imovelRota.getRota());
						consumoHistoricoEsgoto.setReferenciaFaturamento(sistemaParametro.getAnoMesFaturamento());

						// [SF0002] - Determinar Dados para Faturamento de Esgoto
						this.determinarDadosFaturamentoEsgoto(imovelRota, consumoMedioImovel, consumoHistoricoEsgoto, consumoHistoricoAgua,
										quantidadeEconomias, sistemaParametro, imovelRota.getRota(), colecaoInserirConsumoHistoricoEsgoto,
										faturamentoGrupo, colecaoInserirMedicaoHistoricoEsgoto, colecaoAtualizarMedicaoHistoricoEsgoto,
										esferaPoder, consumoMinimoLigacao);
					}
				}

				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirMedicaoHistoricoAgua);
				this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoAtualizarMedicaoHistoricoAgua);
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirConsumoHistoricoAgua);

				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirMedicaoHistoricoEsgoto);
				this.getControladorBatch().atualizarColecaoObjetoParaBatch(colecaoAtualizarMedicaoHistoricoEsgoto);
				this.getControladorBatch().inserirColecaoObjetoParaBatch(colecaoInserirConsumoHistoricoEsgoto);
			}

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do batch será
			// atualizada com o erro ocorrido

			e.printStackTrace();
			// sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * @author eduardo henrique
	 * @date 10/12/2008
	 *       Override no método para atender às regras de ADA
	 *       Principal alteração está na verificação final se o valor final definido é menor que o
	 *       mínimo da tarifa.
	 *       se sim, seta o mínimo da tarifa
	 * @exception ControladorException
	 */
	protected void determinarAjusteConsumoMinimoLigacao(Imovel imovel, MedicaoHistorico medicaoHistorico,
					ConsumoHistorico consumoHistorico, ConsumoTipo consumoTipo, ConsumoAnormalidade consumoAnormalidade)
					throws ControladorException{

		// Caso o consumo a ser cobrado no mês seja menor que o consumo
		// mínimo de água
		try{
			if(medicaoHistorico.getNumeroConsumoInformado() != null){

				// Seta o consumo histórico
				consumoHistorico.setNumeroConsumoFaturadoMes(medicaoHistorico.getNumeroConsumoInformado());

				// Seta o consumo anormalidade
				consumoTipo.setId(ConsumoTipo.INFORMADO);

				consumoAnormalidade.setId(ConsumoAnormalidade.CONSUMO_INFORMADO);

			}

			int consumoMinimoTarifa = this.obterConsumoMinimoLigacao(imovel, null);

			// Indicador de Permisão Faturamento da Ligação de Água
			Short ligacaoAguaSituacaoIndicadorFaturamento = imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao();

			if(ligacaoAguaSituacaoIndicadorFaturamento.equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
							|| (ligacaoAguaSituacaoIndicadorFaturamento.equals(LigacaoAguaSituacao.NAO_FATURAVEL) && consumoHistorico
											.getNumeroConsumoFaturadoMes().intValue() > 0)){

				/*
				 * [OC891812][UC0101][SB0003][ITEM 15.1]: Verificar se a Situação da ligação de água
				 * ocorre em algum dos valores da lista "P_SIT_LIGAGUA_VERIFICA_CONSUMO_FATURAVEL"
				 * obter o consumo minimo faturável para ligação, e calcular o consumo por economia
				 */
				Map<Integer, Integer> situacaoLigacaoXMinimoFaturavel = obterSituacaoLigacaoMinimoFaturavel();
				boolean consumoNaoFaturavel = false;
				if(situacaoLigacaoXMinimoFaturavel.containsKey(imovel.getLigacaoAguaSituacao().getId())){
					// Obtendo a quantidade de economias
					int qtdEconomias = getControladorImovel().obterQuantidadeEconomias(imovel);
					int consumoPorEconomia = 0;
					if(medicaoHistorico.getNumeroConsumoMes() != null && medicaoHistorico.getNumeroConsumoMes() > ConstantesSistema.ZERO){
						consumoPorEconomia = medicaoHistorico.getNumeroConsumoMes() / qtdEconomias;
					}
					Integer consumoMinFaturavel = situacaoLigacaoXMinimoFaturavel.get(imovel.getLigacaoAguaSituacao().getId());
					consumoNaoFaturavel = consumoPorEconomia <= consumoMinFaturavel.intValue();
					LOGGER.debug("IMOVEL[" + imovel.getId() + "] " + //
									"CONSUMO[" + consumoHistorico.getNumeroConsumoFaturadoMes() + "] " + //
									"ECONOMIA[" + qtdEconomias + "] " + //
									"CONS_MIN_FAT[" + consumoMinFaturavel + "] " + //
									"consumoNaoFaturavel[" + consumoNaoFaturavel + "] ");
				}
				if(consumoNaoFaturavel){
					consumoHistorico.setNumeroConsumoFaturadoMes(Integer.parseInt(ConstantesSistema.ZERO.toString()));
					Integer tipoConsumo = null;

					// if(medicaoHistorico.getLeituraAnteriorInformada() == null){
					// tipoConsumo = ConsumoTipo.SEM_CONSUMO;
					// }else
					if(medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.REALIZADA) //
									|| medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.CONFIRMADA)){
						tipoConsumo = ConsumoTipo.REAL;
					}else{
						tipoConsumo = ConsumoTipo.ESTIMADO;
					}

					if(consumoTipo == null){
						consumoTipo = new ConsumoTipo();
						consumoTipo.setId(tipoConsumo);
					}else if(consumoTipo.getId() == null){
						consumoTipo.setId(tipoConsumo);
					}
				}else{
					if(consumoHistorico.getNumeroConsumoFaturadoMes().intValue() < consumoMinimoTarifa){
						consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoMinimoTarifa));
						// Seta o consumo anormalidade
						consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);
					}
				}

			}

		}catch(Exception ex){
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * @author eduardo henrique
	 * @date 11/02/2009
	 *       Override no método para atender às regras de ADA
	 * @author Virgínia Melo
	 * @throws ControladorException
	 * @date 06/03/2009
	 *       Se a quantidade de Dias de Consumo ficar entre 29 e 32 dias OU
	 *       for menor que 29 dias e não houve instalação de hidrômetro, nenhum ajuste será
	 *       realizado.
	 * @exception ControladorException
	 *                [UC0101] - Consistir Leituras e Calcular Consumos
	 *                [SF0017] - Ajuste Mensal de Consumo
	 */
	protected void ajusteMensalConsumo(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico, Imovel imovel,
					MedicaoTipo medicaoTipo, Rota rota, int consumoMinimoLigacao, SistemaParametro sistemaParametro)
					throws ControladorException{

		int quantidadeDiasConsumoAjustado = 0;

		if(medicaoHistorico.getDataLeituraAnteriorFaturamento() == null || medicaoHistorico.getDataLeituraAtualFaturamento() == null){
			System.out.println(" MEDICAO ERRO " + medicaoHistorico.getId());
		}

		// Obtém a quantidade de dias de consumo
		int quantidadeDiasConsumo = (int) IoUtil.diferencaEntreDatas(medicaoHistorico.getDataLeituraAnteriorFaturamento(), medicaoHistorico
						.getDataLeituraAtualFaturamento());

		// Verifica se a data do ajuste é não nula
		if(rota.getDataAjusteLeitura() != null){

			// Obtém a quantidade de dias de consumo ajustado
			quantidadeDiasConsumoAjustado = (int) IoUtil.diferencaEntreDatas(medicaoHistorico.getDataLeituraAnteriorFaturamento(), rota
							.getDataAjusteLeitura());
		}else{

			/*
			 * Parametro que define o mês para tratamento de ajuste de consumo
			 */
			String parametroDefinicaoMesAjusteConsumo = (String) ParametroMicromedicao.P_DEFINICAO_MES_AJUSTE_CONSUMO.executar(this, 0);

			// Caso indique Mês Civil
			if(parametroDefinicaoMesAjusteConsumo.equals(DefinicaoMesAjusteConsumo.UM.getValor())){

				/* Será a quantidade de dias do mês da Data da Leitura Anterior de Faturamento */
				Calendar data = Calendar.getInstance();
				data.setTime(medicaoHistorico.getDataLeituraAnteriorFaturamento());

				// Obtém a quantidade de dias
				quantidadeDiasConsumoAjustado = data.getActualMaximum(Calendar.DAY_OF_MONTH);

			}else{

				// Em ADA a quantidade de Dias de Consumo Ajustado é sempre 30 dias
				quantidadeDiasConsumoAjustado = 30;
			}
		}

		// Parametro que define a quantidade de dias aceita como margem para ajuste de consumo
		String parametroVariacaoDiasAjusteConsumo = (String) ParametroMicromedicao.P_VARIACAO_DIAS_AJUSTE_CONSUMO.executar(this, 0);

		/*
		 * Caso os Dias de Ajuste (Quantidade Ajustada de Dias de Consumo - Quantidade de Dias de
		 * Consumo) não seja superior a variação de dias para ajuste de consumo para mais ou para
		 * menos
		 */
		int diasAjuste = quantidadeDiasConsumoAjustado - quantidadeDiasConsumo;
		int variacaoAceita = Util.obterInteger(parametroVariacaoDiasAjusteConsumo);
		int variacaoAceitaMenos = variacaoAceita * (-1);

		if(diasAjuste > variacaoAceitaMenos && diasAjuste < variacaoAceita){
			return;
		}

		// Parâmetro que indica a ação a ser realizada no ajuste mensal
		String parametroAcaoAjusteConsumo = (String) ParametroMicromedicao.P_ACAO_AJUSTE_CONSUMO.executar(this, 0);

		if(parametroAcaoAjusteConsumo.equals(AcaoAjusteConsumo.UM.getValor())
						|| parametroAcaoAjusteConsumo.equals(AcaoAjusteConsumo.TRES.getValor())){

			// Caso a quantidade de dias de consumo seja maior que 32 então
			if(quantidadeDiasConsumo > 32){

				short indicadorAjusteTarifaLeituraProjetada = sistemaParametro.getIndicadorAjusteTarifaLeituraProjetada();

				/*
				 * Caso o indicador de ajuste de tarifa para leitura maior que 30 esteja com
				 * valor igual 2
				 */
				if(indicadorAjusteTarifaLeituraProjetada == ConstantesSistema.NAO){

					/*
					 * Consumo a Ser Cobrado no Mês = (Consumo a Ser Cobrado no Mês /
					 * Quantidade de Dias de Consumo) * Quantidade Ajustada de Dias de Consumo
					 */
					int consumoCalculadoMes = Util.divideDepoisMultiplica(consumoHistorico.getNumeroConsumoFaturadoMes(),
									quantidadeDiasConsumo, quantidadeDiasConsumoAjustado);
					consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(consumoCalculadoMes));
				}
			}else{

				/*
				 * Caso contrário, Caso tenha tido instalação de hidrômetro no mês e a
				 * Quantidade de Dias de Consumo seja menor que 29
				 */
				// [SB0024 – Verificar a existência de hidrômetro substituído no mês]
				boolean existeHidrometroSusbtituido = verificarExistenciaHidrometroSubstituidoMes(medicaoHistorico, imovel);

				if(existeHidrometroSusbtituido && quantidadeDiasConsumo < 29){

					/*
					 * Calcula a Quantidade de dias de projeção = Quantidade Ajustada de Dias de
					 * Consumo - Quantidade de Dias de Consumo
					 */
					int quantidadeDiasProjecao = quantidadeDiasConsumoAjustado - quantidadeDiasConsumo;

					/*
					 * Consumo Projetado Mês = (Consumo mínimo da Ligação /Quantidade Ajustada
					 * de Dias de Consumo) * Quantidade de dias de projeção
					 */
					int consumoProjetadoMes = Util.divideDepoisMultiplica(consumoMinimoLigacao, quantidadeDiasConsumoAjustado,
									quantidadeDiasProjecao);

					// Obtém o consumo a ser cobrado mês
					int consumoCobradoMes = 0;
					if(consumoHistorico.getNumeroConsumoFaturadoMes() != null){

						consumoCobradoMes = consumoHistorico.getNumeroConsumoFaturadoMes().intValue();
					}

					/*
					 * Consumo a Ser Cobrado no Mês = Consumo a Ser Cobrado no Mês + Consumo
					 * Projetado Mês
					 */
					consumoCobradoMes += consumoProjetadoMes;
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoCobradoMes);
				}
			}
		}

		if(parametroAcaoAjusteConsumo.equals(AcaoAjusteConsumo.DOIS.getValor())
						|| parametroAcaoAjusteConsumo.equals(AcaoAjusteConsumo.TRES.getValor())){

			/*
			 * Caso os Dias de Ajuste ultrapasse 30 dias para mais ou para menos,
			 * considerar dias de ajuste como 30 para mais ou para menos
			 */
			if(diasAjuste > 30 || diasAjuste < -30){

				diasAjuste = 30;
			}

			// Data leitura projetada = data de leitura atual informada + Dias de Ajuste
			Date dataLeituraProjetada = Util.adicionarNumeroDiasDeUmaData(medicaoHistorico.getDataLeituraAtualInformada(), diasAjuste);

			// A data de leitura atual do Faturamento será a data de leitura projetada
			medicaoHistorico.setDataLeituraAtualFaturamento(dataLeituraProjetada);

			Integer leituraAtualInformada = medicaoHistorico.getLeituraAtualInformada();
			if(leituraAtualInformada == null){

				leituraAtualInformada = 0;
			}

			Integer consumoASerCobradoMes = consumoHistorico.getNumeroConsumoFaturadoMes();
			if(consumoASerCobradoMes == null){

				consumoASerCobradoMes = 0;
			}

			/*
			 * Leitura ajustada = Leitura Atual Informada + (Consumo a Ser Cobrado no Mês *
			 * Dias de Ajuste) / Quantidade de Dias de Consumo (utilizando a regra padrão de
			 * arredondamento)
			 */
			int leituraAjustada = leituraAtualInformada
							+ Util.dividirArredondarResultado((consumoASerCobradoMes * diasAjuste), quantidadeDiasConsumo);

			Integer leituraAnteriorFaturamento = medicaoHistorico.getLeituraAnteriorFaturamento();
			if(leituraAnteriorFaturamento == null){

				leituraAnteriorFaturamento = 0;
			}

			// Leitura Mês = Leitura Anterior de Faturamento + Consumo a ser cobrado no Mês
			int leituraMes = leituraAnteriorFaturamento + consumoASerCobradoMes;

			Integer leituraAtualFaturamento = medicaoHistorico.getLeituraAtualFaturamento();
			if(leituraAtualFaturamento == null){

				leituraAtualFaturamento = 0;
			}

			/*
			 * Caso Leitura Atual de Faturamento seja igual à Leitura Mês, a Leitura Atual
			 * de Faturamento (MDHI_NNLEITURAATUALFATURAMENTO) passa a ser a Leitura
			 * Ajustada
			 */
			if(leituraAtualFaturamento == leituraMes){

				medicaoHistorico.setLeituraAtualFaturamento(leituraAjustada);
			}

		}

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos.
	 * [SB0024] – Verificar a existência de hidrômetro substituído no mês.
	 * 
	 * @author Anderson Italo
	 * @date 24/03/2012
	 */
	private boolean verificarExistenciaHidrometroSubstituidoMes(MedicaoHistorico medicaoHistorico, Imovel imovel){

		Date dataInstalacaoHidrometro = null;
		Short indicadorInstalacaoSubstituicao = null;
		boolean retorno = false;

		// Caso a medição seja do tipo Água
		if(medicaoHistorico.getMedicaoTipo().getId().equals(MedicaoTipo.LIGACAO_AGUA)){

			dataInstalacaoHidrometro = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico().getDataInstalacao();
			indicadorInstalacaoSubstituicao = imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico()
							.getIndicadorInstalcaoSubstituicao();
		}else{

			// Caso a medição seja do tipo Esgoto
			dataInstalacaoHidrometro = imovel.getHidrometroInstalacaoHistorico().getDataInstalacao();
			indicadorInstalacaoSubstituicao = imovel.getHidrometroInstalacaoHistorico().getIndicadorInstalcaoSubstituicao();
		}

		// Verifica se houve substituição do hidrômetro no mês
		if((Util.compararData(medicaoHistorico.getDataLeituraAnteriorFaturamento(), dataInstalacaoHidrometro) == -1)
						|| (Util.compararData(medicaoHistorico.getDataLeituraAnteriorFaturamento(), dataInstalacaoHidrometro) == 0)
						&& (indicadorInstalacaoSubstituicao != null && indicadorInstalacaoSubstituicao.intValue() == HidrometroInstalacaoHistorico.INDICADOR_INSTALACAO_HIDROMETRO)){

			retorno = true;
		}
		return retorno;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0001] - Determinar Dados para Faturamento de Água
	 * [SB0002] - Determinar Dados para Faturamento de Esgoto
	 * Método sobrescrito para ADA, que considera somente a Situação Atual de Leitura para definição
	 * de Tipo de Consumo
	 * 
	 * @author eduardo henrique
	 * @date 29/06/2009
	 * @param medicaoHistoricoImovel
	 *            [obrigatório] com LeituraSituacaoAtual e Anterior setados
	 * @param consumoAnormalidadeLeitura
	 *            [opcional]
	 */
	protected ConsumoTipo definirConsumoTipoLeituraImovel(MedicaoHistorico medicaoHistoricoImovel,
					ConsumoAnormalidade consumoAnormalidadeLeitura){

		ConsumoTipo consumoTipo = new ConsumoTipo();

		if(medicaoHistoricoImovel == null){
			throw new IllegalArgumentException("erro.parametro_medicao_nulo");
		}

		if(medicaoHistoricoImovel.getLeituraSituacaoAtual() == null || medicaoHistoricoImovel.getLeituraSituacaoAnterior() == null){
			throw new IllegalStateException("erro.parametro_medicao_situacao_leitura_nulo");
		}

		if(consumoAnormalidadeLeitura != null && ConsumoAnormalidade.VIRADA_HIDROMETRO.equals(consumoAnormalidadeLeitura.getId())){
			if((medicaoHistoricoImovel.getLeituraSituacaoAnterior().getId().intValue() == LeituraSituacao.REALIZADA.intValue() || medicaoHistoricoImovel
							.getLeituraSituacaoAnterior().getId().intValue() == LeituraSituacao.CONFIRMADA.intValue())
							&& (medicaoHistoricoImovel.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.REALIZADA.intValue() || medicaoHistoricoImovel
											.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.CONFIRMADA.intValue())){
				consumoTipo.setId(ConsumoTipo.REAL);
			}else{
				consumoTipo.setId(ConsumoTipo.ESTIMADO);
			}

		}else{

			// Determinação para casos sem anormalidade
			if(medicaoHistoricoImovel.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.CONFIRMADA.intValue()
							|| medicaoHistoricoImovel.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.REALIZADA.intValue()){
				consumoTipo.setId(ConsumoTipo.REAL);
			}else{
				consumoTipo.setId(ConsumoTipo.ESTIMADO);
			}

		}

		return consumoTipo;
	}

	/**
	 * Método que verifica anormalidades de consumo nos movimentos do faturamento e gera relatorios
	 * [UC3033] Verificar Anormalidades de Consumo nos Movimentos do Faturamento
	 * 
	 * @author Hugo Lima
	 * @date 11/01/2012
	 * @param colecaoRotas
	 * @param anoMesFaturamento
	 * @param idFuncionalidadeIniciada
	 */
	public void verificarAnormalidadesConsumo(Collection rotas, Integer anoMesFaturamento, FaturamentoGrupo faturamentoGrupo,
					int idFuncionalidadeIniciada) throws ControladorException{

		int idUnidadeIniciada = 0;
		boolean existemRotasVerificaveis = false;
		try{

			// -------------------------
			//
			// Registrar o início do processamento da Unidade de
			// Processamento
			// do Batch
			//
			// -------------------------

			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
							((Rota) Util.retonarObjetoDeColecao(rotas)).getId());

			ArrayList<AnormalidadeEntidadeControleDetalheHelper> listaDetalheHelper = new ArrayList<AnormalidadeEntidadeControleDetalheHelper>();

			// Verifica se a empresa adota o controle do limite aceitável de anormalidades
			String parametroControleAnormalidadeConsumo = ParametroMicromedicao.P_COD_ENTIDADE_CONTROLE_ANORMALIDADES_CONSUMO.executar();

			// 1. Caso a empresa não adote um controle do limite aceitável de anormalidades de
			// consumo o sistema ENCERRA o caso de uso, mas a execução deve ser concluída com
			// sucesso.
			if(!Util.isVazioOuBranco(parametroControleAnormalidadeConsumo)
							&& !Short.valueOf(parametroControleAnormalidadeConsumo).equals(ConstantesSistema.ZERO)){

				// 2. O sistema obtém as rotas do grupo de faturamento
				// [FS0002 – Verificar existência de rotas para o grupo de faturamento].
				if(Util.isVazioOrNulo(rotas)){
					throw new ControladorException("atencao.nao_ha_rotas_grupo_faturamento", null, faturamentoGrupo.getId().toString());
				}else{
					// 3. Para o conjunto de rotas com o tipo de leitura diferente de “faturamento
					// imediato” , o sistema verifica se o limite aceitável de anormalidades de
					// consumo foi excedido
					for(Object objetoRota : rotas){
						Rota rota = (Rota) objetoRota;

						if(!rota.getLeituraTipo().getId().equals(LeituraTipo.LEITURA_E_ENTRADA_SIMULTANEA)){
							// Existe pelo menos uma rota que pode ser verificada
							existemRotasVerificaveis = true;
							break;
						}
					}
				}

				// Se existirem rotas aptas - chama rotina de verificacao de limites para
				// anormalidades
				if(existemRotasVerificaveis){
					listaDetalheHelper.addAll(this.verificarLimiteAnormalidadesConsumoAceitavel(faturamentoGrupo,
									parametroControleAnormalidadeConsumo));

					if(!Util.isVazioOrNulo(listaDetalheHelper)){
						// Envia a coleção de anormalidades para o relatório
						String mensagemArquivo = "relatorio";
						RelatorioResumoAnormalidadesConsumo relatorioResumoAnormalidadesConsumo = new RelatorioResumoAnormalidadesConsumo(
										Usuario.USUARIO_BATCH);
						relatorioResumoAnormalidadesConsumo.addParametro("listaDetalheHelper", listaDetalheHelper);
						relatorioResumoAnormalidadesConsumo.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
						relatorioResumoAnormalidadesConsumo.addParametro("descricaoArquivo", mensagemArquivo);

						this.getControladorBatch().iniciarProcessoRelatorio(relatorioResumoAnormalidadesConsumo);
					}
				}
			}

			// --------------------------------------------------------
			//
			// Registrar o fim da execução da Unidade de Processamento
			//
			// --------------------------------------------------------
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception e){
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			sessionContext.setRollbackOnly();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(e);
		}

	}

	/**
	 * Método privado que verifica o limite de anormalidades de consumo nos movimentos do
	 * faturamento
	 * [UC3033] Verificar Anormalidades de Consumo nos Movimentos do Faturamento
	 * [SB0001] – Verificar Limite de Anormalidades de Consumo Aceitável
	 * 
	 * @author Hugo Lima
	 * @date 12/01/2012
	 * @param colecaoRotas
	 * @throws ControladorException
	 */
	private Collection verificarLimiteAnormalidadesConsumoAceitavel(FaturamentoGrupo faturamentoGrupo,
					String parametroControleAnormalidadeConsumo) throws ControladorException{

		try{

			String parametroLista = ParametroMicromedicao.P_LISTA_COD_PERCENTUAL_ANORMALIDADE_CONSUMO_CONTROLADA.executar();

			Collection<String> listaAnormalidades = new ArrayList<String>();
			Collection<Integer[]> retornoQuantidadeImoveis = new ArrayList<Integer[]>();
			Integer retornoQuantidadeAnormalidades = 0;

			ArrayList<AnormalidadeEntidadeControleHelper> listaAnormalidadeEntidadeControle = new ArrayList<AnormalidadeEntidadeControleHelper>();

			// coleção de registros verificados do relatório
			ArrayList<AnormalidadeEntidadeControleDetalheHelper> listaDetalheHelper = new ArrayList<AnormalidadeEntidadeControleDetalheHelper>();

			// [FS0003] – Nenhuma anormalidade encontrada.
			if(Util.isVazioOuBranco(parametroLista)){
				throw new ControladorException("atencao.movimento_valores_coerentes", null, faturamentoGrupo.getId().toString());
			}

			// Converte a lista do formato String vinda do parametro para um ArrayList
			listaAnormalidades = Arrays.asList(parametroLista.split(","));

			// Preenche a Lista com as entidade de controle de anormalidades
			for(String anormalidadeControle : listaAnormalidades){
				// 1. O sistema cria a lista das anormalidades de consumo controladas
				// o atributo idExcessoAnormalidades já é setadO para "NÃO" por padrão
				AnormalidadeEntidadeControleHelper anormalidadeEntidadeControleHelper = new AnormalidadeEntidadeControleHelper();

				// 1.1. Código da Entidade de Controle (valor zero).
				anormalidadeEntidadeControleHelper.setIdAnormalidadeEntidadeControle(0);

				// 1.2. Código da Anormalidade de Consumo
				anormalidadeEntidadeControleHelper.setIdAnormalidade(Integer.valueOf(anormalidadeControle.substring(0, 3)));

				// 1.3. Percentual do Limite de Anormalidade Aceitável
				anormalidadeEntidadeControleHelper.setPercentualLimiteAnormalidades(new BigDecimal(anormalidadeControle.substring(3)));

				// 1.4. Quantidade da Anormalidade de Consumo (valor zero).
				anormalidadeEntidadeControleHelper.setQuantidadeAnormalidades(0);

				// Adiciona o helper na lista de Entidades de controle
				listaAnormalidadeEntidadeControle.add(anormalidadeEntidadeControleHelper);
			}

			// Varifica a quantidade de imóveis. A consulta possui 3 configurações e pode retornar
			// resultados com 1, 2 ou 3 colunas dependendo do parametro de controle de anormalidade
			retornoQuantidadeImoveis = this.repositorioMicromedicao.pesquisarImovelLigacaoAguaGrupoFaturamento(faturamentoGrupo.getId(),
							Integer.parseInt(parametroControleAnormalidadeConsumo));

			// [FS0004] – Nenhum registro encontrado.
			if((Integer) ((Object[]) Util.retonarObjetoDeColecao(retornoQuantidadeImoveis))[0] == 0){
				throw new ControladorException("atencao.nao_ha_imoveis_ligacao_agua_grupo_faturamento", null, faturamentoGrupo.getId()
								.toString());
			}

			// Percorre a lista com os detalhes de imóveis
			for(Object[] detalheImoveis : retornoQuantidadeImoveis){

				if(Integer.parseInt(parametroControleAnormalidadeConsumo) == ConstantesSistema.CD_CONTROLE_ANORMALIDADE_GRUPO_FATURAMENTO){
					// Para cada anormalidade é feita a verificação
					for(AnormalidadeEntidadeControleHelper anormalidadeEntidadeControleHelper : listaAnormalidadeEntidadeControle){
						anormalidadeEntidadeControleHelper.setIdAnormalidadeEntidadeControle(faturamentoGrupo.getId());

						double quantidadeImoveisHidrometroLigacaoAgua = 0;
						int quantidadeAnormalidadesGrupoConsumo = 0;
						double limiteAceitavelAnormalidade = 0;

						// Obtém a quantidade de anormalidades de consumo no grupo de faturamento

						quantidadeImoveisHidrometroLigacaoAgua = (Integer) detalheImoveis[0];
						quantidadeAnormalidadesGrupoConsumo = (Integer) this.repositorioMicromedicao
										.pesquisarAnormalidadesConsumoGrupoFaturamento(faturamentoGrupo.getId(),
														anormalidadeEntidadeControleHelper.getIdAnormalidade(), Integer
																		.parseInt(parametroControleAnormalidadeConsumo), null, null, null);

						limiteAceitavelAnormalidade = quantidadeImoveisHidrometroLigacaoAgua
										* (anormalidadeEntidadeControleHelper.getPercentualLimiteAnormalidades().doubleValue() / 100);

						// 2.2.3. Caso a quantidade de anormalidades de consumo no grupo de
						// faturamento
						// ultrapasse o limite aceitável de anormalidades o sistema atribui a
						// quantidade
						// de anormalidades de consumo no grupo de faturamento à Quantidade da
						// Anormalidade de Consumo da lista.
						if(Double.parseDouble(quantidadeAnormalidadesGrupoConsumo + "") > limiteAceitavelAnormalidade){
							// anormalidadeEntidadeControleHelper.setQuantidadeAnormalidades(quantidadeAnormalidadesGrupoConsumo);

							AnormalidadeEntidadeControleDetalheHelper detalheHelper = anormalidadeEntidadeControleHelper
											.gerarDetalhe(AnormalidadeEntidadeControleDetalheHelper.DS_ENTIDATE_CONTROLE_GRUPO_FATURAMENTO);
							detalheHelper.setQuantidadeImoveisHidrometroLigacaoAgua(quantidadeImoveisHidrometroLigacaoAgua);
							detalheHelper.setLimiteAceitavelAnormalidade(BigDecimal.valueOf(limiteAceitavelAnormalidade));
							detalheHelper.setQuantidadeAnormalidades(quantidadeAnormalidadesGrupoConsumo);

							listaDetalheHelper.add(detalheHelper);
						}
					}
				}else if(Integer.parseInt(parametroControleAnormalidadeConsumo) == ConstantesSistema.CD_CONTROLE_ANORMALIDADE_SETOR_COMERCIAL){
					// Para cada anormalidade é feita a verificação
					for(AnormalidadeEntidadeControleHelper anormalidadeEntidadeControleHelper : listaAnormalidadeEntidadeControle){

						Integer idLocalidade = (Integer) detalheImoveis[1];
						Integer cdSetorComercial = (Integer) detalheImoveis[2];

						anormalidadeEntidadeControleHelper.setIdAnormalidadeEntidadeControle(cdSetorComercial);

						double quantidadeImoveisHidrometroLigacaoAguaSetor = 0;
						int quantidadeAnormalidadesGrupoConsumoSetor = 0;
						double limiteAceitavelAnormalidade = 0;

						quantidadeImoveisHidrometroLigacaoAguaSetor = (Integer) detalheImoveis[0];
						quantidadeAnormalidadesGrupoConsumoSetor = (Integer) this.repositorioMicromedicao
										.pesquisarAnormalidadesConsumoGrupoFaturamento(faturamentoGrupo.getId(),
														anormalidadeEntidadeControleHelper.getIdAnormalidade(), Integer
																		.parseInt(parametroControleAnormalidadeConsumo), idLocalidade,
														cdSetorComercial, null);

						limiteAceitavelAnormalidade = quantidadeImoveisHidrometroLigacaoAguaSetor
										* (anormalidadeEntidadeControleHelper.getPercentualLimiteAnormalidades().doubleValue() / 100);

						// 3.2.2.3. Caso a quantidade de anormalidades de consumo no setor
						// comercial ultrapasse o limite aceitável de anormalidades (quantidade
						// de imóveis com hidrômetro na ligação de água no setor comercial *
						// (Percentual do Limite de Anormalidade Aceitável / 100)):
						if(Double.parseDouble(quantidadeAnormalidadesGrupoConsumoSetor + "") > limiteAceitavelAnormalidade){
							// anormalidadeEntidadeControleHelper.setQuantidadeAnormalidades(quantidadeAnormalidadesGrupoConsumo);

							AnormalidadeEntidadeControleDetalheHelper detalheHelper = anormalidadeEntidadeControleHelper
											.gerarDetalhe(AnormalidadeEntidadeControleDetalheHelper.DS_ENTIDATE_CONTROLE_SETOR_COMERCIAL);
							detalheHelper.setQuantidadeImoveisHidrometroLigacaoAgua(quantidadeImoveisHidrometroLigacaoAguaSetor);
							detalheHelper.setLimiteAceitavelAnormalidade(BigDecimal.valueOf(limiteAceitavelAnormalidade));
							detalheHelper.setQuantidadeAnormalidades(quantidadeAnormalidadesGrupoConsumoSetor);
							detalheHelper.setComplementoEntidadeControle(idLocalidade + " - ");

							listaDetalheHelper.add(detalheHelper);
						}
					}
				}else if(Integer.parseInt(parametroControleAnormalidadeConsumo) == ConstantesSistema.CD_CONTROLE_ANORMALIDADE_ROTA){

					// Para cada anormalidade é feita a verificação
					for(AnormalidadeEntidadeControleHelper anormalidadeEntidadeControleHelper : listaAnormalidadeEntidadeControle){

						Integer idRota = (Integer) detalheImoveis[1];

						anormalidadeEntidadeControleHelper.setIdAnormalidadeEntidadeControle(idRota);

						double quantidadeImoveisHidrometroLigacaoAguaRota = 0;
						int quantidadeAnormalidadesGrupoConsumoRota = 0;
						double limiteAceitavelAnormalidade = 0;

						quantidadeImoveisHidrometroLigacaoAguaRota = (Integer) detalheImoveis[0];
						quantidadeAnormalidadesGrupoConsumoRota = (Integer) this.repositorioMicromedicao
										.pesquisarAnormalidadesConsumoGrupoFaturamento(faturamentoGrupo.getId(),
														anormalidadeEntidadeControleHelper.getIdAnormalidade(), Integer
																		.parseInt(parametroControleAnormalidadeConsumo), null, null, idRota);

						limiteAceitavelAnormalidade = quantidadeImoveisHidrometroLigacaoAguaRota
										* (anormalidadeEntidadeControleHelper.getPercentualLimiteAnormalidades().doubleValue() / 100);

						// 4.2.2.3. Caso a quantidade de anormalidades de consumo na rota
						// ultrapasse o limite aceitável de anormalidades (quantidade de imóveis
						// com hidrômetro na ligação de água na rota * (Percentual do Limite de
						// Anormalidade Aceitável / 100)):
						if(Double.parseDouble(quantidadeAnormalidadesGrupoConsumoRota + "") > limiteAceitavelAnormalidade){
							// anormalidadeEntidadeControleHelper.setQuantidadeAnormalidades(quantidadeAnormalidadesGrupoConsumo);

							AnormalidadeEntidadeControleDetalheHelper detalheHelper = anormalidadeEntidadeControleHelper
											.gerarDetalhe(AnormalidadeEntidadeControleDetalheHelper.DS_ENTIDATE_CONTROLE_ROTA);
							detalheHelper.setQuantidadeImoveisHidrometroLigacaoAgua(quantidadeImoveisHidrometroLigacaoAguaRota);
							detalheHelper.setLimiteAceitavelAnormalidade(BigDecimal.valueOf(limiteAceitavelAnormalidade));
							detalheHelper.setQuantidadeAnormalidades(quantidadeAnormalidadesGrupoConsumoRota);

							listaDetalheHelper.add(detalheHelper);
						}
					}
				}
			}

			return listaDetalheHelper;

		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * 
	 * @param consumoHistorico
	 * @param imovel
	 * @param consumoMedioImovel
	 * @param consumoMinimoLigacao
	 * @throws ControladorException
	 */
	private void determinarDadosFaturamentoAguaNaoMedido(ConsumoHistorico consumoHistorico, Imovel imovel, int[] consumoMedioImovel,
					int consumoMinimoLigacao, SistemaParametro sistemaParametro, MedicaoHistorico medicaoHistorico)
					throws ControladorException{

		/*
		 * Parâmetro que Indica a forma de calcular o consumo mínimo para Faturamento de água dos
		 * imóveis não-medidos
		 */
		String parametroCalculoConsumoMinimoNaoMedidos = (String) ParametroMicromedicao.P_CALCULO_CONSUMO_MINIMO_NAO_MEDIDOS.executar(this,
						0);

		if(parametroCalculoConsumoMinimoNaoMedidos.equals(CalculoConsumoMinimoNaoMedidos.CONSUMO_MINIMO_FIXO.toString())){

			ConsumoTipo consumoTipo = new ConsumoTipo();

			// Customização v0.05
			if(imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){
				
				Short parametroFaturarConsumoFixoMenorQueMinimo = Util
								.obterShort((String) ParametroMicromedicao.P_FATURAR_CONSUMO_FIXO_MENOR_MINIMO.executar(this, 0));
				
				// Caso tenha consumo mínimo de água definido (caso exista) -> e não seja
				// inferior ao mínimo da ligação exceto se o parâmetro
				// P_FATURAR_CONSUMO_FIXO_MENOR_MINIMO seja 1 - "Sim"
				if(imovel.getLigacaoAgua() != null
								&& imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua() != null
								&& (imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua().intValue() >= consumoMinimoLigacao || parametroFaturarConsumoFixoMenorQueMinimo
												.equals(ConstantesSistema.SIM))){

					// Seta o consumo histórico - consumo a ser cobrado mês
					consumoHistorico.setNumeroConsumoFaturadoMes(imovel.getLigacaoAgua().getNumeroConsumoMinimoAgua());

					// Seta o consumo tipo
					consumoTipo.setId(ConsumoTipo.CONSUMO_MINIMO_FIXADO);

				}else{

					// Seta o consumo histórico - consumo a ser cobrado mês
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);

					// Seta o consumo tipo
					consumoTipo.setId(ConsumoTipo.NAO_MEDIDO);
				}

				// Seta o consumo tipo no consumo histórico
				if(consumoTipo.getId() != null){
					consumoHistorico.setConsumoTipo(consumoTipo);
				}
			}

		}else{

			Integer consumoCobradoMes = this.obterConsumoFixadoPorCategoriaPorAreaConstruida(imovel.getId());

			ConsumoTipo consumoTipo = new ConsumoTipo();
			consumoTipo.setId(ConsumoTipo.NAO_MEDIDO);

			consumoHistorico.setConsumoTipo(consumoTipo);
			consumoHistorico.setNumeroConsumoFaturadoMes(consumoCobradoMes);
		}

		if(imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

			/*
			 * Alterado por Raphael Rossiter em 23/10/2007 - Analista: Nelson Carvalho
			 * Sistema determina os dados para faturamento caso o imóvel esteja com situação
			 * de faturamento especial (DIFERENTE DE NULO) e que
			 * seja válido para água.
			 */
			if(imovel.getFaturamentoSituacaoTipo() != null && imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua() != null
							&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().intValue() == 1){

				// [SF0022] - Dados para Faturamento Especial do Não Medido.
				this.dadosFaturamentoEspecialNaoMedido(consumoHistorico, consumoMedioImovel[0], imovel, consumoMinimoLigacao,
								medicaoHistorico);
			}
		}
	}

	/**
	 * @param imovelId
	 * @return
	 * @throws ControladorException
	 */
	private Integer obterConsumoFixadoPorCategoriaPorAreaConstruida(Integer imovelId) throws ControladorException{

		int consumoCobradoMes = 0;

		// Coleção Consumo por Faixa de Área e Categoria
		FiltroImovelConsumoFaixaAreaCategoria filroImovelConsumoFaixaAreaCategoria = new FiltroImovelConsumoFaixaAreaCategoria();
		filroImovelConsumoFaixaAreaCategoria.adicionarParametro(new ParametroSimples(FiltroImovelConsumoFaixaAreaCategoria.IMOVEL_ID,
						imovelId));
		filroImovelConsumoFaixaAreaCategoria.adicionarParametro(new ParametroSimples(FiltroImovelConsumoFaixaAreaCategoria.INDICADOR_USO,
						ConstantesSistema.INDICADOR_USO_ATIVO));
		filroImovelConsumoFaixaAreaCategoria.adicionarCaminhoParaCarregamentoEntidade(FiltroImovelConsumoFaixaAreaCategoria.CATEGORIA);
		filroImovelConsumoFaixaAreaCategoria
						.adicionarCaminhoParaCarregamentoEntidade(FiltroImovelConsumoFaixaAreaCategoria.CONSUMO_FAIXA_AREA_CATEGORIA);

		Collection<ImovelConsumoFaixaAreaCategoria> collImovelConsumoFaixaAreaCategoria = Fachada.getInstancia().pesquisar(
						filroImovelConsumoFaixaAreaCategoria, ImovelConsumoFaixaAreaCategoria.class.getName());

		if(collImovelConsumoFaixaAreaCategoria != null && !collImovelConsumoFaixaAreaCategoria.isEmpty()){
			for(ImovelConsumoFaixaAreaCategoria imovelConsumoFaixaAreaCategoria : collImovelConsumoFaixaAreaCategoria){
				ImovelConsumoFaixaAreaCategoriaPK compId = imovelConsumoFaixaAreaCategoria.getComp_id();

				if(compId != null && compId.getConsumoFaixaAreaCategoria() != null){
					ConsumoFaixaAreaCategoria consumoFaixaAreaCategoria = compId.getConsumoFaixaAreaCategoria();
					Integer consumoEstimadoArea = consumoFaixaAreaCategoria.getConsumoEstimadoArea();

					if(consumoEstimadoArea != null){
						consumoCobradoMes = consumoCobradoMes + consumoEstimadoArea;
					}
				}
			}
		}else{
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.nao_cadastrado.consumo_faixa_area_categoria", null, Integer.toString(imovelId));
		}

		return consumoCobradoMes;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos.
	 * [SB0003] - Determinar Dados para Faturamento de Água do Medido.
	 * 
	 * @date 17/03/2012
	 * @throws ControladorException
	 */
	private MedicaoHistorico determinarDadosFaturamentoAguaMedido(ConsumoHistorico consumoHistorico, Imovel imovel,
					FaturamentoGrupo faturamentoGrupo, SistemaParametro sistemaParametro, int[] consumoMedioImovel,
					int quantidadeEconomias, Rota rota, int consumoMinimoLigacao, MedicaoTipo medicaoTipo) throws ControladorException{

		/*
		 * O sistema obtém dados do histórico de medição [SB0013 – Obter Dados do Histórico de
		 * Medição]
		 */
		MedicaoHistorico medicaoHistorico = this.obterDadosHistoricoMedicao(faturamentoGrupo, imovel, medicaoTipo, sistemaParametro);

		// Alteração solicitada por Luciene em 08/10/2008
		// Implementada por Virgínia Melo.
		// Iniciando este campo sempre com o valor do Mês anterior, não haverá problema
		// de crédito quando esta funcionalidade for executada mais de uma vez.
		Collection colecaoParmsMedicaoAnterior = null;
		int anoMesReferencia = medicaoHistorico.getAnoMesReferencia();
		int anoMesAnterior = Util.subtrairMesDoAnoMes(anoMesReferencia, 1);

		// Pesquisa pela Medição Histórico do Mês Anterior.
		try{

			colecaoParmsMedicaoAnterior = repositorioMicromedicao.pesquisarMedicaoHistoricoAnterior(Collections.singletonList(imovel),
							anoMesAnterior, medicaoTipo.getId());
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		// Caso não encontre registro, o Crédito Anterior será ZERO. o Crédito Gerado será
		// sempre inicializado
		if(colecaoParmsMedicaoAnterior == null || colecaoParmsMedicaoAnterior.isEmpty()){

			medicaoHistorico.setConsumoCreditoAnterior(Integer.valueOf(0));
		}

		Iterator colecaoParmsMedicaoAnteriorIterator = colecaoParmsMedicaoAnterior.iterator();

		while(colecaoParmsMedicaoAnteriorIterator.hasNext()){

			Object[] dadosAnterioresMedicaoHistorico = (Object[]) colecaoParmsMedicaoAnteriorIterator.next();

			if(dadosAnterioresMedicaoHistorico[7] != null){

				medicaoHistorico.setConsumoCreditoAnterior((Integer) dadosAnterioresMedicaoHistorico[7]);
			}
		}
		medicaoHistorico.setConsumoCreditoGerado(Integer.valueOf(0));
		// Fim nova alteração - 08/10/2008

		// Alteração solicitada por Aryed 10/12/2007 e realizada por Leonardo Vieira na mesma
		// data
		// O consumo médio do hidrômetro deve ser igual ao do imóvel

		// [UC0102] - Obter Consumo Médio do Hidrômetro
		int[] consumoMedioHidrometro = consumoMedioImovel;

		/*
		 * obterConsumoMedioHidrometro(imovel,
		 * sistemaParametro, medicaoTipo);
		 */

		// Seta o consumo médio do hidrômetro
		medicaoHistorico.setConsumoMedioHidrometro(Integer.valueOf(consumoMedioHidrometro[0]));

		// [SB0012] - Obter Leitura Anterior
		int leituraAnterior = this.obterLeituraAnterior(medicaoHistorico);

		// Leitura atual informada diferente de nulo
		if(medicaoHistorico.getLeituraAtualInformada() != null){

			// Leitura atual informada <<<MAIOR>>> que a leitura anterior obtida
			if(medicaoHistorico.getLeituraAtualInformada().intValue() > leituraAnterior){

				// [SB0007] - Dados para Faturamento para Leitura Maior que a Anterior
				this.dadosFaturamentoLeituraMaiorAnterior(medicaoHistorico, consumoHistorico, consumoMedioHidrometro[0], imovel,
								sistemaParametro, leituraAnterior);

				// Leitura atual informada <<<IGUAL>>> a leitura anterior obtida
			}else if(medicaoHistorico.getLeituraAtualInformada().intValue() == leituraAnterior){

				// [SB0008] - Dados para Faturamento para Leitura Igual a Anterior
				this.dadosFaturamentoLeituraIgualAnterior(medicaoHistorico, consumoHistorico, medicaoTipo, imovel, null, faturamentoGrupo,
								sistemaParametro, consumoMinimoLigacao, consumoMedioImovel[0]);

				// Leitura atual informada <<<MENOR>>> a leitura anterior obtida
			}else if(medicaoHistorico.getLeituraAtualInformada().intValue() < leituraAnterior){

				// [SB0009] - Dados para Faturamento para Leitura Menor que a Anterior
				this.dadosFaturamentoLeituraMenorAnterior(imovel, consumoHistorico, medicaoHistorico, sistemaParametro, leituraAnterior,
								medicaoTipo, consumoMedioImovel[0], consumoMedioHidrometro[0], consumoMinimoLigacao);

			}

		}else if(medicaoHistorico.getLeituraAtualInformada() == null && medicaoHistorico.getLeituraAnormalidadeFaturamento() == null){

			if(imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)){

				/*
				 * Leitura Atual Informada com o valor nulo e Anormalidade de Leitura de Faturamento
				 * com
				 * o valor nulo. [SB0010] - Dados para Faturamento para Leitura Não Informada e Sem
				 * Anormalidade de Leitura.
				 */
				this.dadosFaturamentoLeituraNaoInformadaSemAnormalidadeLeitura(medicaoHistorico, consumoHistorico, leituraAnterior,
								consumoMedioImovel[0], consumoMinimoLigacao);
			}else{

				// Seta consumo igual a zero
				consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(0));

				// Seta o tipo de consumo
				ConsumoTipo consumoTipo = new ConsumoTipo();
				consumoTipo.setId(ConsumoTipo.SEM_CONSUMO);
				consumoHistorico.setConsumoTipo(consumoTipo);

				// Seta o consumo anormalidade para leitura não informada
				ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();
				consumoAnormalidade.setId(ConsumoAnormalidade.LEITURA_NAO_INFORMADA);
				consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

				// Leitura atual de faturamento será a igual a anterior
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnterior);
			}

		}

		/*
		 * O sistema determina os dados para faturamento, caso a Anormalidade de Leitura de
		 * Faturamento esteja com o valor diferente de nulo.
		 */
		if(medicaoHistorico.getLeituraAnormalidadeFaturamento() != null){

			// [SF0011] - Dados para Faturamento Com Anormalidade de Leitura
			this.dadosFaturamentoComAnormalidadeLeitura(medicaoHistorico, consumoHistorico, consumoMedioImovel[0], leituraAnterior, imovel,
							consumoMinimoLigacao);
		}

		/*
		 * O sistema determina os dados para faturamento, caso o imóvel esteja com situação de
		 * faturamento especial e a mesma seja válida para água
		 */
		if(imovel.getFaturamentoSituacaoTipo() != null && imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua() != null
						&& imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().equals(ConstantesSistema.SIM)){

			// [SF0021] - Dados para Faturamento Especial do Medido.
			this.dadosFaturamentoEspecialMedido(medicaoHistorico, consumoHistorico, imovel, consumoMedioImovel[0], leituraAnterior,
							consumoMinimoLigacao);
		}

		// Parâmetro que indica a ação a ser realizada no ajuste mensal
		String parametroAcaoAjusteConsumo = (String) ParametroMicromedicao.P_ACAO_AJUSTE_CONSUMO.executar(this, 0);

		// Caso indique para ajustar a leitura
		if(parametroAcaoAjusteConsumo.equals(AcaoAjusteConsumo.DOIS.getValor())
						|| parametroAcaoAjusteConsumo.equals(AcaoAjusteConsumo.TRES.getValor())){

			// [SB0023] - Consistência Datas de Leitura Atual e Anterior
			this.consistirDatasLeituraAtualAnterior(medicaoHistorico, imovel, medicaoTipo);
		}

		// Caso o consumo a ser cobrado no mês esteja nulo, considerá-lo ZERO
		if(consumoHistorico.getNumeroConsumoFaturadoMes() == null){

			consumoHistorico.setNumeroConsumoFaturadoMes(Integer.valueOf(0));
		}

		// Obtém a quantidade de economias por categoria
		Collection colecaoCategoria = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		// [SF0014] - Verificar Estouro de Consumo
		boolean estouroConsumo = this.verificarEstouroConsumo(consumoHistorico, imovel, consumoMedioImovel[0], sistemaParametro,
						medicaoTipo, colecaoCategoria, medicaoHistorico, leituraAnterior, consumoMinimoLigacao);

		if(estouroConsumo == false){

			// [SF0015] - Verificar Alto Consumo
			this.verificarAltoConsumo(consumoHistorico, consumoMedioImovel[0], colecaoCategoria, imovel, medicaoTipo, medicaoHistorico,
							leituraAnterior, consumoMinimoLigacao);
		}

		/*
		 * Caso o imóvel não possua poço (POCO_ID da tabela IMOVEL com o valor correspondente a não
		 * há poço na tabela POCO_TIPO), e a Situação da Leitura Atual tenha sido real (com o valor
		 * correspondente a “realizada” ou “confirmada”) e a Anormalidade
		 * de Leitura de Faturamento esteja com o valor nulo
		 */
		if((medicaoHistorico.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.CONFIRMADA.intValue() || medicaoHistorico
						.getLeituraSituacaoAtual().getId().intValue() == LeituraSituacao.REALIZADA.intValue())
						&& medicaoHistorico.getLeituraAnormalidadeFaturamento() == null){

			// [SF0016] - Verificar Baixo Consumo
			this.verificarBaixoConsumo(consumoHistorico, consumoMedioImovel[0], colecaoCategoria, imovel, medicaoTipo,
							consumoMinimoLigacao, medicaoHistorico);
		}

		// Customização para v0.05 - vsm 11.3
		int creditoExistente = 0;
		int consumoCobrado = 0;

		/*
		 * Caso esteja indicado o ajuste mensal do consumo e a situação de ligação indicar ajuste
		 * mensal de consumo e o imóvel NÃO esteja com situação de faturamento especial válida para
		 * água
		 */
		if(rota.getIndicadorAjusteConsumo() != null
						&& rota.getIndicadorAjusteConsumo().intValue() == Rota.INDICADOR_AJUSTE_MENSAL
						&& imovel.getLigacaoAguaSituacao().getIndicadorAjusteConsumo().equals(ConstantesSistema.SIM)
						&& (imovel.getFaturamentoSituacaoTipo() == null || (imovel.getFaturamentoSituacaoTipo().getIndicadorValidoAgua() != null && imovel
										.getFaturamentoSituacaoTipo().getIndicadorValidoAgua().equals(ConstantesSistema.NAO)))){

			// [SF0017] - Ajuste Mensal do Consumo
			this.ajusteMensalConsumo(medicaoHistorico, consumoHistorico, imovel, medicaoTipo, rota, consumoMinimoLigacao, sistemaParametro);
		}

		// Cria o objeto consumo tipo
		ConsumoTipo consumoTipo = new ConsumoTipo();
		ConsumoAnormalidade consumoAnormalidade = new ConsumoAnormalidade();

		// [UC0101][SB0003][ITEM 15]
		this.determinarAjusteConsumoMinimoLigacao(imovel, medicaoHistorico, consumoHistorico, consumoTipo, consumoAnormalidade);

		// Verifica se foi definido o consumo tipo para mínimo fixado ou informado
		if(consumoTipo.getId() != null){
			consumoHistorico.setConsumoTipo(consumoTipo);
		}
		// Verifica se foi definido uma anormalidade de consumo
		if(consumoAnormalidade.getId() != null){
			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);
		}

		if(medicaoHistorico.getConsumoCreditoAnterior() != null){
			creditoExistente = medicaoHistorico.getConsumoCreditoAnterior().intValue();
		}

		if(consumoHistorico.getNumeroConsumoFaturadoMes() != null){
			consumoCobrado = consumoHistorico.getNumeroConsumoFaturadoMes().intValue();
		}

		// Seta indefinido para ser verificado - Saulo 25/01/2009
		if(consumoHistorico.getConsumoTipo() == null){
			ConsumoTipo consumoTipoTemp = new ConsumoTipo();
			consumoTipoTemp.setId(ConsumoTipo.INDEFINIDO);
			consumoHistorico.setConsumoTipo(consumoTipoTemp);
		}else if(consumoHistorico.getConsumoTipo().getId() == null){
			consumoHistorico.getConsumoTipo().setId(ConsumoTipo.INDEFINIDO);
		}

		if(medicaoHistorico.getConsumoCreditoAnterior() != null && consumoHistorico.getConsumoTipo() != null
						&& consumoHistorico.getConsumoTipo().getId().equals(ConsumoTipo.REAL) && consumoCobrado >= consumoMinimoLigacao){

			/*
			 * Parâmetro para indicar se o consumo deverá ser ajustado para múltiplo da
			 * quantidade de
			 * economias
			 */
			String parametroAjustarConsumoMultiploQuantidadeEconomias = (String) ParametroFaturamento.P_AJUSTAR_CONSUMO.executar(this, 0);
			if(creditoExistente > 0){

				// Seta o consumo histórico
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoCobrado + creditoExistente);

				// Credito Faturado será o crédito existente;
				consumoHistorico.setConsumoMinimoCreditado(creditoExistente);

				// Zera o credito anterior pois utilizou tudo
				medicaoHistorico.setConsumoCreditoAnterior(Integer.valueOf(0));

				/*
				 * Caso a quantidade de economias seja maior que 1 e a empresa ajusta o consumo pela
				 * quantidade de economias
				 */
				if(quantidadeEconomias > 1
								&& parametroAjustarConsumoMultiploQuantidadeEconomias.equals(AjustarConsumoMultiploQtdeEconomias.UM
												.getValor())){

					// [SF0018] - Ajuste do Consumo Múltiplo da Quantidade de Economias
					// Ajuste, pois ao utilizar todo o crédito, pode ser q o valor n seja divisivel
					// pela qtd de economias
					this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistorico, consumoHistorico, quantidadeEconomias,
									consumoMinimoLigacao);

				}

			}else{
				// o Consumo a Ser Cobrado no mês será o proprio consumo + crédito existente
				// limitando o
				// resultado ao mínimo da ligação e o Crédito Faturado será o crédito utilizado.

				// Pode ser utilizado todo o crédito que mesmo assim não chega ao mínimo da
				// ligação
				if(consumoCobrado + creditoExistente >= consumoMinimoLigacao){

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoCobrado + creditoExistente);
					consumoHistorico.setConsumoMinimoCreditado(creditoExistente);

					// Zera o credito anterior pois utilizou tudo
					medicaoHistorico.setConsumoCreditoAnterior(Integer.valueOf(0));

					if(quantidadeEconomias > 1
									&& parametroAjustarConsumoMultiploQuantidadeEconomias.equals(AjustarConsumoMultiploQtdeEconomias.UM
													.getValor())){
						// Ajuste, pois ao utilizar todo o crédito, pode ser q o valor n seja
						// divisivel pela qtd de economias
						this.ajusteConsumoMultiploQuantidadeEconomias(imovel, medicaoHistorico, consumoHistorico, quantidadeEconomias,
										consumoMinimoLigacao);
					}

					// Não pode usar todo o crédito pois tornará o valor a ser pago menor que o
					// mínimo
				}else{

					// Valor que seria cobrado caso pudesse ser menor que o mínimo.
					int valorMenorQueMinimo = consumoCobrado + creditoExistente;

					// Calcula em quanto passou do mínimo
					int valorUltrapassado = consumoMinimoLigacao - valorMenorQueMinimo;

					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
					consumoHistorico.setConsumoMinimoCreditado(creditoExistente + valorUltrapassado);

					// Atualiza o credito anterior
					medicaoHistorico.setConsumoCreditoAnterior(medicaoHistorico.getConsumoCreditoAnterior()
									- (creditoExistente + valorUltrapassado));

				}
			}
		}
		return medicaoHistorico;
	}

	private Map<Integer, Integer> obterSituacaoLigacaoMinimoFaturavel() throws ControladorException{

		Map<Integer, Integer> situacaoLigacaoXMinimoFaturavel = null;
		String listaSituacoesXMinimoFaturavel = ParametroMicromedicao.P_SIT_LIGAGUA_VERIFICA_CONSUMO_FATURAVEL.executar();
		if(Util.isVazioOuBranco(listaSituacoesXMinimoFaturavel)){
			LOGGER.error("Parametro 'P_SIT_LIGAGUA_VERIFICA_CONSUMO_FATURAVEL' não está definido na base de dados.");
		}else{
			situacaoLigacaoXMinimoFaturavel = new HashMap<Integer, Integer>();
			Integer situacao = null;
			for(String vlParam : listaSituacoesXMinimoFaturavel.split(",")){
				if(situacao == null){
					situacao = Integer.valueOf(vlParam);
				}else{
					situacaoLigacaoXMinimoFaturavel.put(situacao, Integer.valueOf(vlParam));
					situacao = null;
				}
			}
		}
		return situacaoLigacaoXMinimoFaturavel;
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0027] – Definir Consumo pela Anormalidade de Consumo.
	 * O sistema determina o consumo, o tipo de consumo e a leitura para faturamento de acordo com
	 * os parâmetros definidos para a Anormalidade de Consumo.
	 * 
	 * @author Anderson Italo
	 * @date 20/03/2012
	 * @param consumoCalculado
	 *            TODO
	 * @throws ControladorException
	 */
	private void definirConsumoPelaAnormalidadeConsumo(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico,
					int consumoMinimoLigacao, int consumoMedioImovel, String parametroCobrancaConsumoMinimo,
					ConsumoAnormalidade consumoAnormalidade, int consumoCalculado) throws ControladorException{

		/*
		 * Caso a Situação da Leitura Anterior tenha sido real (com o valor correspondente a
		 * “confirmada” ou “realizada”
		 */
		if(medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.REALIZADA.intValue())
						|| medicaoHistorico.getLeituraSituacaoAnterior().getId().equals(LeituraSituacao.CONFIRMADA.intValue())){

			/*
			 * Tipo de Consumo será o valor correspondente ao tipo de consumo com
			 * leitura anterior realizada.
			 */
			consumoHistorico.setConsumoTipo(consumoAnormalidade.getConsumoTipoLeituraAnteriorReal());

			// Consumo a ser cobrado
			if(consumoAnormalidade.getConsumoAnormalidadeConsumoLeituraAnteriorReal().getId().equals(ConsumoAnormalidadeConsumo.MINIMO)){

				// Caso seja para tratar mínimo com valor zero (0)
				if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.DOIS.getValor())){

					// Zera o consumo
					consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
				}else{

					/*
					 * Caso contrário, o consumo a ser cobrado no mês será o mínimo da
					 * ligação <<Inclui>> [UC0105 – Obter Consumo Mínimo da Ligação]
					 */
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
				}
			}else if(consumoAnormalidade.getConsumoAnormalidadeConsumoLeituraAnteriorReal().getId()
							.equals(ConsumoAnormalidadeConsumo.MEDIA)){

				// O Consumo a Ser Cobrado será o consumo médio do imóvel
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
			}else{
				// O Consumo a Ser Cobrado será o já calculado
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);

			}

			/*
			 * Para os casos de consumo real e estimado, o consumo a ser cobrado será o
			 * consumo já calculado.
			 */

			// Leitura atual de faturamento
			if(consumoAnormalidade.getConsumoAnormalidadeLeituraAnteriorReal().getId()
							.equals(ConsumoAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA)){

				// A Leitura Atual de Faturamento será a anterior mais a média
				Integer leituraAnteriorFaturamento = 0;
				if(medicaoHistorico.getLeituraAnteriorFaturamento() != null){
					leituraAnteriorFaturamento = medicaoHistorico.getLeituraAnteriorFaturamento();
					medicaoHistorico.setLeituraAtualFaturamento(leituraAnteriorFaturamento + consumoMedioImovel);
				}else{
					medicaoHistorico.setLeituraAtualFaturamento(leituraAnteriorFaturamento + consumoMedioImovel);
				}
			}else if(consumoAnormalidade.getConsumoAnormalidadeLeituraAnteriorReal().getId().equals(ConsumoAnormalidadeLeitura.ANTERIOR)){

				// A Leitura Atual de Faturamento será igual a anterior
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAnteriorFaturamento());
			}else if(consumoAnormalidade.getConsumoAnormalidadeLeituraAnteriorReal().getId()
							.equals(ConsumoAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO)){

				// A Leitura Atual de Faturamento será a anterior mais o consumo a ser
				// cobrado no mês
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAnteriorFaturamento()
								+ consumoHistorico.getNumeroConsumoFaturadoMes());
			}else{
				// A Leitura Atual de Faturamento será a informada
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());

			}

			/*
			 * Caso o consumo anormalidade leitura seja informada a leitura atual de
			 * faturamento será a já determinada anteriormente.
			 */
		}else{

			/*
			 * Tipo de Consumo será o valor correspondente ao tipo de consumo com
			 * leitura anterior projetada.
			 */
			consumoHistorico.setConsumoTipo(consumoAnormalidade.getConsumoTipoLeituraAnteriorProjetada());

			// Consumo a ser cobrado
			if(consumoAnormalidade.getConsumoAnormalidadeConsumoLeituraAnteriorProjetada().getId()
							.equals(ConsumoAnormalidadeConsumo.MINIMO)){

				// Caso seja para tratar mínimo com valor zero (0)
				if(parametroCobrancaConsumoMinimo.equals(CobrancaConsumoMinimo.DOIS.getValor())){

					// Zera o consumo
					consumoHistorico.setNumeroConsumoFaturadoMes(ConstantesSistema.ZERO.intValue());
				}else{

					/*
					 * Caso contrário, o consumo a ser cobrado no mês será o mínimo da
					 * ligação <<Inclui>> [UC0105 – Obter Consumo Mínimo da Ligação].
					 */
					consumoHistorico.setNumeroConsumoFaturadoMes(consumoMinimoLigacao);
				}
			}else if(consumoAnormalidade.getConsumoAnormalidadeConsumoLeituraAnteriorProjetada().getId()
							.equals(ConsumoAnormalidadeConsumo.MEDIA)){

				// O Consumo a Ser Cobrado será o consumo médio do imóvel
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoMedioImovel);
			}else{
				// O Consumo a Ser Cobrado será o já calculado
				consumoHistorico.setNumeroConsumoFaturadoMes(consumoCalculado);
			}

			/*
			 * Para os casos de consumo real e estimado, o consumo a ser cobrado será o
			 * consumo já calculado.
			 */

			// Leitura atual de faturamento
			if(consumoAnormalidade.getConsumoAnormalidadeLeituraAnteriorProjetada().getId()
							.equals(ConsumoAnormalidadeLeitura.ANTERIOR_MAIS_MEDIA)){

				// A Leitura Atual de Faturamento será a anterior mais a média
				// medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAnteriorFaturamento()
				// + consumoMedioImovel);

				Integer leituraAnteriorFaturamento = Integer.valueOf(0);
				if(medicaoHistorico.getLeituraAnteriorFaturamento() != null){
					leituraAnteriorFaturamento = medicaoHistorico.getLeituraAnteriorFaturamento();
				}
				medicaoHistorico.setLeituraAtualFaturamento(leituraAnteriorFaturamento + consumoMedioImovel);

			}else if(consumoAnormalidade.getConsumoAnormalidadeLeituraAnteriorProjetada().getId()
							.equals(ConsumoAnormalidadeLeitura.ANTERIOR)){

				// A Leitura Atual de Faturamento será igual a anterior
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAnteriorFaturamento());
			}else if(consumoAnormalidade.getConsumoAnormalidadeLeituraAnteriorProjetada().getId()
							.equals(ConsumoAnormalidadeLeitura.ANTERIOR_MAIS_CONSUMO)){

				// A Leitura Atual de Faturamento será a anterior mais o consumo a ser
				// cobrado no mês
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAnteriorFaturamento()
								+ consumoHistorico.getNumeroConsumoFaturadoMes());
			}else{
				// A Leitura Atual de Faturamento será a informada
				medicaoHistorico.setLeituraAtualFaturamento(medicaoHistorico.getLeituraAtualInformada());
			}

			/*
			 * Caso o consumo anormalidade leitura seja informada a leitura atual de
			 * faturamento será a já determinada anteriormente.
			 */
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0020] – Verificar Hidrômetro Parado para Poço
	 * 
	 * @author Anderson Italo
	 * @date 21/03/2012
	 */
	private void verificaHidrometroParadoParaPoco(MedicaoHistorico medicaoHistorico, ConsumoHistorico consumoHistorico, Imovel imovel){

		LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();
		/*
		 * Caso o imóvel não seja ligado de água ou caso tenha hidrômetro e tenha
		 * Anormalidade de Consumo com o valor correspondente a “baixo consumo”.
		 */
		Short indicadorFaturamento = null;
		if(imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao() != null){
			indicadorFaturamento = imovel.getLigacaoAguaSituacao().getIndicadorFaturamentoSituacao();
		}else{
			try{
				LigacaoAguaSituacao ligacaoAguaSituacao = this.getControladorLigacaoAgua().pesquisarLigacaoAguaSituacao(
								imovel.getLigacaoAguaSituacao().getId());
				indicadorFaturamento = ligacaoAguaSituacao.getIndicadorFaturamentoSituacao();
			}catch(ControladorException e){
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

		// Alteração conforme OC0857313
		// .......................................................

		// if(!imovel.getLigacaoAguaSituacao().getId().equals(LigacaoAguaSituacao.LIGADO)
		// || ((imovel.getLigacaoAgua() != null &&
		// imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) || imovel
		// .getHidrometroInstalacaoHistorico() != null)
		// &&
		// consumoHistorico.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.BAIXO_CONSUMO)){

		LigacaoAguaSituacao ligacaoAguaSituacao = null;
		try{
			ligacaoAguaSituacao = this.getControladorLigacaoAgua().pesquisarLigacaoAguaSituacao(imovel.getLigacaoAguaSituacao().getId());
		}catch(ControladorException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		if(ligacaoAguaSituacao != null
						&& !ligacaoAguaSituacao.getIndicadorFaturamentoSituacao().equals(LigacaoAguaSituacao.FATURAMENTO_ATIVO)
						|| ((imovel.getLigacaoAgua() != null && imovel.getLigacaoAgua().getHidrometroInstalacaoHistorico() != null) || imovel
										.getHidrometroInstalacaoHistorico() != null)
						&& (consumoHistorico != null && consumoHistorico.getConsumoAnormalidade() != null
										&& consumoHistorico.getConsumoAnormalidade().getId() != null && consumoHistorico
										.getConsumoAnormalidade().getId().equals(ConsumoAnormalidade.BAIXO_CONSUMO))){

			/*
			 * O sistema gera a Anormalidade de Leitura de Faturamento com o valor
			 * correspondente a “hidrômetro parado”
			 */
			if(!LeituraAnormalidade.HIDROMETRO_PARADO.equals(ConstantesSistema.INVALIDO_ID)){
				leituraAnormalidade.setId(LeituraAnormalidade.HIDROMETRO_PARADO);
				medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
			}

		}else{

			/*
			 * Caso contrário, o sistema gera a Anormalidade de Leitura de Faturamento
			 * com o valor correspondente a hidrômetro parado sem consumo
			 */
			if(!LeituraAnormalidade.HIDROMETRO_PARADO_SEM_CONSUMO.equals(ConstantesSistema.INVALIDO_ID)){
				leituraAnormalidade.setId(LeituraAnormalidade.HIDROMETRO_PARADO_SEM_CONSUMO);
				medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
			}
		}
	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos
	 * [SB0019] – Verificar Hidrômetro Parado para Ligação de Água
	 * 
	 * @author Anderson Italo
	 * @throws ControladorException
	 * @date 21/03/2012
	 */
	private void verificarHidrometroParadoParaLigacaoAgua(MedicaoHistorico medicaoHistorico, Imovel imovel) throws ControladorException{

		LeituraAnormalidade leituraAnormalidade = new LeituraAnormalidade();

		/*
		 * Caso todas as condições seguintes sejam satisfeitas, o sistema gera a
		 * Anormalidade de Leitura de Faturamento com o valor correspondente a
		 * “hidrômetro parado.
		 * Caso Não exista ligação de esgoto, ou caso exista, o valor do consumo mínimo
		 * fixado de esgoto seja igual a nulo.
		 */
		// Alteração conforme OC0857313
		// .......................................................
		Short indicadorFaturamento = null;
		if(imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao() != null){
			indicadorFaturamento = imovel.getLigacaoEsgotoSituacao().getIndicadorFaturamentoSituacao();
		}else{
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao;
			try{
				ligacaoEsgotoSituacao = this.getControladorLigacaoEsgoto().pesquisarLigacaoEsgotoSituacao(
								imovel.getLigacaoEsgotoSituacao().getId());
			}catch(ControladorException e){
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			indicadorFaturamento = ligacaoEsgotoSituacao.getIndicadorFaturamentoSituacao();
		}

		if(!indicadorFaturamento.equals(LigacaoEsgotoSituacao.FATURAMENTO_ATIVO)
						|| (imovel.getLigacaoEsgoto() != null && imovel.getLigacaoEsgoto().getConsumoMinimo() == null)){

			// Caso não exista poço no imóvel
			if(imovel.getPocoTipo() == null){

				if(!LeituraAnormalidade.HIDROMETRO_PARADO.equals(ConstantesSistema.INVALIDO_ID)){
					leituraAnormalidade.setId(LeituraAnormalidade.HIDROMETRO_PARADO);
					medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
				}
			}
		}

		/*
		 * Caso a condição seguinte seja satisfeita, o sistema gera a Anormalidade de
		 * Leitura de Faturamento com o valor correspondente a “hidrômetro parado sem
		 * consumo”. Caso exista poço no imóvel ou exista ligação de esgoto com valor do
		 * consumo mínimo fixado de esgoto diferente de nulo.
		 */
		if((imovel.getPocoTipo() != null && imovel.getPocoTipo().getId().intValue() > 1)
						|| (imovel.getLigacaoEsgoto() != null && imovel.getLigacaoEsgoto().getConsumoMinimo() != null)){

			if(!LeituraAnormalidade.HIDROMETRO_PARADO_SEM_CONSUMO.equals(ConstantesSistema.INVALIDO_ID)){
				leituraAnormalidade.setId(LeituraAnormalidade.HIDROMETRO_PARADO_SEM_CONSUMO);
				medicaoHistorico.setLeituraAnormalidadeFaturamento(leituraAnormalidade);
			}
		}
	}

	/**
	 * Método que obtem os dados de um hidrometro a partir do tipo de medicao
	 * [UC0713] Emitir Ordem de Serviço Seletiva
	 * [SB9002] – Obter Dados do Hidrômetro
	 * 
	 * @author Hugo Lima
	 * @date 21/03/2012
	 * @param
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */
	public HidrometroRelatorioOSHelper obterDadosHidrometroPorTipoMedicao(Integer idImovel, Integer idTipoMedicao)
					throws ControladorException{

		HidrometroRelatorioOSHelper hidrometroRelatorioOSHelper = new HidrometroRelatorioOSHelper();
		Object[] dadosHidrometro = null;

		try{
			dadosHidrometro = repositorioMicromedicao.obterDadosHidrometroPorTipoMedicao(idImovel, idTipoMedicao);
		}catch(ErroRepositorioException e){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		if(dadosHidrometro != null){

			if(dadosHidrometro[0] != null){
				hidrometroRelatorioOSHelper.setHidrometroNumero((String) dadosHidrometro[0]);
			}

			if(dadosHidrometro[1] != null){
				hidrometroRelatorioOSHelper.setHidrometroMarca((String) dadosHidrometro[1]);
			}

			if(dadosHidrometro[2] != null){
				hidrometroRelatorioOSHelper.setHidrometroCapacidade((String) dadosHidrometro[2]);
			}

			if(dadosHidrometro[3] != null){
				hidrometroRelatorioOSHelper.setHidrometroDiametro((String) dadosHidrometro[3]);
			}

			if(dadosHidrometro[4] != null){
				hidrometroRelatorioOSHelper.setHidrometroLocal((String) dadosHidrometro[4]);
			}

			if(dadosHidrometro[5] != null){
				hidrometroRelatorioOSHelper.setHidrometroNumeroDigitos("" + (Short) dadosHidrometro[5]);
			}

			if(dadosHidrometro[6] != null){
				hidrometroRelatorioOSHelper.setDataInstalacaoHidrometo(Util.formatarData((Date) dadosHidrometro[6]));
			}

			if(dadosHidrometro[8] != null){
				hidrometroRelatorioOSHelper.setIdProtecaoHidrometro(((Integer) dadosHidrometro[7]).toString());
				hidrometroRelatorioOSHelper.setDescricaoProtecaoHidrometro((String) dadosHidrometro[8]);
			}

			if(dadosHidrometro[10] != null){
				hidrometroRelatorioOSHelper.setIdTipoHidrometro(((Integer) dadosHidrometro[9]).toString());
				hidrometroRelatorioOSHelper.setDescricaoTipoHidrometro((String) dadosHidrometro[10]);
			}

			if(dadosHidrometro[11] != null){

				if(((Short) dadosHidrometro[11]) == 1){
					hidrometroRelatorioOSHelper.setIndicadorCavalete("Sim");
				}else{
					hidrometroRelatorioOSHelper.setIndicadorCavalete("Não");
				}
			}else{
				hidrometroRelatorioOSHelper.setIndicadorCavalete("Não");
			}

			if(dadosHidrometro[12] != null){

				hidrometroRelatorioOSHelper.setAnoFabricacaoHidrometro(((Short) dadosHidrometro[12]).toString());
			}

		}

		return hidrometroRelatorioOSHelper;
	}

	/**
	 * Retorna uma coleção com os dados dos Consumos para apresentação
	 * com a maior referencia para ano/mes de faturamento
	 * [UC0713] Emitir Ordem de Serviço Seletiva
	 * [SB9004] – Obter Dados de Consumo
	 * 
	 * @author Hugo Lima
	 * @date 22/03/2012
	 * @param idImovel
	 * @param tipoLigacao
	 * @return
	 * @throws ControladorException
	 */
	public ImovelDadosConsumoHistoricoHelper obterDadosConsumoMaiorReferenciaFaturamento(Imovel imovel, Integer tipoLigacao)
					throws ControladorException{

		Object[] resultadoPesquisa = null;
		ImovelDadosConsumoHistoricoHelper imovelDadosConsumoHistoricoHelper = null;

		try{
			resultadoPesquisa = repositorioMicromedicao.obterDadosConsumoMaiorReferenciaFaturamento(imovel.getId(), tipoLigacao);

			if(!Util.isVazioOrNulo(resultadoPesquisa)){
				imovelDadosConsumoHistoricoHelper = new ImovelDadosConsumoHistoricoHelper();
				imovelDadosConsumoHistoricoHelper.setIdTipoConsumo((Integer) resultadoPesquisa[0]);
				imovelDadosConsumoHistoricoHelper.setDescricaoTipoConsumo((String) resultadoPesquisa[1]);
				imovelDadosConsumoHistoricoHelper.setIdAnormalidadeConsumo((Integer) resultadoPesquisa[2]);
				imovelDadosConsumoHistoricoHelper.setDescricaoAnormalidadeConsumo((String) resultadoPesquisa[3]);
				imovelDadosConsumoHistoricoHelper.setConsumoRateio((Integer) resultadoPesquisa[4]);
				imovelDadosConsumoHistoricoHelper.setConsumoMes((Integer) resultadoPesquisa[5]);

				SistemaParametro sistemaParametro = new SistemaParametro();
				sistemaParametro.setMesesMediaConsumo(Short.valueOf("6"));
				sistemaParametro.setAnoMesFaturamento(Integer.valueOf(Util.getAnoMesComoInt(new Date())));
				int[] consumoMediaImovel = this.obterConsumoMedioImovel(imovel, sistemaParametro);

				imovelDadosConsumoHistoricoHelper.setConsumoMedioImovel(Integer.valueOf(consumoMediaImovel[0]));
			}

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return imovelDadosConsumoHistoricoHelper;
	}

	/**
	 * Retorna uma coleção com os dados dos Consumos para apresentação
	 * com a maior referencia para ano/mes de faturamento
	 * [UC0713] Emitir Ordem de Serviço Seletiva
	 * [SB9003] - Obter Dados de Medição
	 * 
	 * @author Hugo Lima
	 * @date 22/03/2012
	 * @param idImovel
	 * @param tipoLigacao
	 * @return
	 * @throws ControladorException
	 */
	public ImovelDadosMedicaoHistoricoHelper obterDadosMedicaoMaiorReferenciaLeitura(Imovel imovel, Integer tipoLigacao)
					throws ControladorException{

		Object[] resultadoPesquisa = null;
		ImovelDadosMedicaoHistoricoHelper imovelDadosMedicaoHistoricoHelper = null;

		try{
			resultadoPesquisa = repositorioMicromedicao.obterDadosMedicaoMaiorReferenciaLeitura(imovel.getId(), tipoLigacao);

			if(!Util.isVazioOrNulo(resultadoPesquisa)){
				imovelDadosMedicaoHistoricoHelper = new ImovelDadosMedicaoHistoricoHelper();

				if(resultadoPesquisa[0] != null){
					imovelDadosMedicaoHistoricoHelper.setLeituraAnterior((Integer) resultadoPesquisa[0]);
				}
				if(resultadoPesquisa[1] != null){
					imovelDadosMedicaoHistoricoHelper.setLeituraAtual((Integer) resultadoPesquisa[1]);
				}
				if(resultadoPesquisa[2] != null){
					imovelDadosMedicaoHistoricoHelper.setDataLeituraAnterior(Util.formatarData((Date) resultadoPesquisa[2]));
				}
				if(resultadoPesquisa[3] != null){
					imovelDadosMedicaoHistoricoHelper.setDataLeituraAtual(Util.formatarData((Date) resultadoPesquisa[3]));
				}
				if(resultadoPesquisa[2] != null && resultadoPesquisa[3] != null){
					imovelDadosMedicaoHistoricoHelper.setQuantidadeDiasConsumo(Util.calcularDiferencaEntreDatas(
									(Date) resultadoPesquisa[2], (Date) resultadoPesquisa[3], ConstantesSistema.DIFERENCA_DIAS).intValue());
				}
				if(resultadoPesquisa[4] != null){
					imovelDadosMedicaoHistoricoHelper.setIdSituacaoLeituraAtual((Integer) resultadoPesquisa[4]);
				}
				if(resultadoPesquisa[5] != null){
					imovelDadosMedicaoHistoricoHelper.setIdAnormalidadeLeitura((Integer) resultadoPesquisa[5]);
				}
				if(resultadoPesquisa[6] != null){
					imovelDadosMedicaoHistoricoHelper.setConsumoMedioMes((Integer) resultadoPesquisa[6]);
				}

			}

		}catch(ErroRepositorioException ex){
			throw new ControladorException("erro.sistema", ex);
		}

		return imovelDadosMedicaoHistoricoHelper;
	}

	/**
	 * [UC3012] – Gerar Arquivo com Dados e Tabelas do Faturamento Imediado
	 * 
	 * @author Hebert Falcão
	 * @date 12/04/2012
	 */
	private void enviarArquivosFaturamentoImediatoParaBatch(Object[] arquivoTabelas, Object[] arquivoDados) throws ControladorException{

		StringBuffer conteudoArquivoTabelas = null;
		String nomeArquivoTabelas = null;

		if(arquivoTabelas != null){
			conteudoArquivoTabelas = (StringBuffer) arquivoTabelas[0];
			nomeArquivoTabelas = (String) arquivoTabelas[1];
		}

		StringBuffer conteudoArquivoDados = null;
		String nomeArquivoDados = null;

		if(arquivoDados != null){
			conteudoArquivoDados = (StringBuffer) arquivoDados[0];
			nomeArquivoDados = (String) arquivoDados[1];
		}

		Usuario usuario = new Usuario();
		usuario.setId(Usuario.ID_USUARIO_ADM_SISTEMA);

		EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(EnvioEmail.ARQUIVO_DADOS_TABELAS_FATURAMENTO_IMEDIATO);

		RelatorioDadosTabelasFaturamentoImediato relatorio = new RelatorioDadosTabelasFaturamentoImediato(usuario);

		relatorio.addParametro("conteudoArquivoDados", conteudoArquivoDados);
		relatorio.addParametro("conteudoArquivoTabelas", conteudoArquivoTabelas);
		relatorio.addParametro("nomeArquivoDados", nomeArquivoDados);
		relatorio.addParametro("nomeArquivoTabelas", nomeArquivoTabelas);
		relatorio.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_ZIP);
		relatorio.addParametro("envioEmail", envioEmail);

		this.getControladorBatch().iniciarProcessoRelatorio(relatorio);
	}

	/**
	 * Relatório de Ocorrência da Geração do Pré-Faturamento (Resumo)
	 * 
	 * @author Hebert Falcão
	 * @date 06/04/2012
	 */
	private void iniciarProcessamentoRelatorioOcorrenciaGeracaoPreFatResumo(Integer idFaturamentoGrupo, Integer anoMesReferencia,
					Integer idFuncionalidadeIniciada,
					HashMap<Integer, RelatorioOcorrenciaGeracaoPreFatResumoHelper> geracaoPreFatResumoHelperMap, Date dataVencimento)
					throws ControladorException{

		String idFaturamentoGrupoStr = Integer.toString(idFaturamentoGrupo);

		String anoMesReferenciaStr = "";

		if(anoMesReferencia != null){
			anoMesReferenciaStr = Util.formatarAnoMesSemBarraParaMesAnoComBarra(anoMesReferencia);
		}

		Usuario usuarioProcessamento = null;

		if(idFuncionalidadeIniciada != null){
			usuarioProcessamento = this.getControladorBatch().obterUsuarioFuncionalidadeIniciada(idFuncionalidadeIniciada);
		}else{
			usuarioProcessamento = Usuario.USUARIO_BATCH;
		}

		String dataVencimentoStr = "";

		if(dataVencimento != null){
			dataVencimentoStr = Util.formatarData(dataVencimento);
		}

		RelatorioOcorrenciaGeracaoPreFatResumo relatorio = new RelatorioOcorrenciaGeracaoPreFatResumo(usuarioProcessamento);
		relatorio.addParametro("tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
		relatorio.addParametro("anoMesReferencia", anoMesReferenciaStr);
		relatorio.addParametro("idGrupoFaturamento", idFaturamentoGrupoStr);
		relatorio.addParametro("geracaoPreFatResumoHelperMap", geracaoPreFatResumoHelperMap);
		relatorio.addParametro("dataVencimento", dataVencimentoStr);
		relatorio.addParametro("referenciaTarifa", anoMesReferenciaStr);

		this.getControladorBatch().iniciarProcessoRelatorio(relatorio);
	}

	/**
	 * @param idImovel
	 * @param anoMes
	 * @param idMedicaoTipo
	 * @return
	 * @throws ControladorException
	 */

	public MedicaoHistorico pesquisarMedicaoHistorico(Integer idImovel, Integer anoMes, Integer idMedicaoTipo) throws ControladorException{

		try{
			MedicaoHistorico medicaoHistorico = null;

			Object[] resultadoPesquisa = repositorioMicromedicao.pesquisarMedicaoHistorico(idImovel, anoMes, idMedicaoTipo);

			if(!Util.isVazioOrNulo(resultadoPesquisa)){
				medicaoHistorico = new MedicaoHistorico();

				if(resultadoPesquisa[0] != null){
					medicaoHistorico.setDataLeituraAtualFaturamento((Date) resultadoPesquisa[0]);
				}
				if(resultadoPesquisa[1] != null){
					medicaoHistorico.setDataLeituraAnteriorFaturamento((Date) resultadoPesquisa[1]);
				}
				if(resultadoPesquisa[2] != null){
					medicaoHistorico.setLeituraAtualFaturamento((Integer) resultadoPesquisa[2]);
				}
				if(resultadoPesquisa[3] != null){
					medicaoHistorico.setNumeroConsumoMes((Integer) resultadoPesquisa[3]);
				}

			}

			return medicaoHistorico;

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Consulta o historico de mediçoes de um imovel.
	 * 
	 * @author Marlos Ribeiro
	 * @param matriculaImovel
	 * @return colecao de {@link MedicaoHistorico}
	 */
	public Collection<MedicaoHistorico> consultarMedicaoHistorio(String matriculaImovel) throws ControladorException{

		// Mudar isso quando tiver esquema de segurança
		// HttpSession sessao = httpServletRequest.getSession(false);
		FiltroMedicaoHistorico filtroMedicaoHistorico = new FiltroMedicaoHistorico();

		// MedicaoHistorico
		filtroMedicaoHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
		filtroMedicaoHistorico.adicionarCaminhoParaCarregamentoEntidade("leituraAnormalidadeFaturamento");
		filtroMedicaoHistorico.adicionarCaminhoParaCarregamentoEntidade("leituraAnormalidadeInformada");
		filtroMedicaoHistorico.adicionarCaminhoParaCarregamentoEntidade("leituraSituacaoAtual");
		filtroMedicaoHistorico.adicionarCaminhoParaCarregamentoEntidade("ligacaoAgua");

		FiltroLigacaoAgua filtroLigacaoAgua = new FiltroLigacaoAgua();
		filtroLigacaoAgua.adicionarCaminhoParaCarregamentoEntidade("imovel");
		filtroLigacaoAgua.adicionarParametro(new ParametroSimples(FiltroLigacaoAgua.ID, matriculaImovel));
		Collection<LigacaoAgua> ligacoesAgua = ServiceLocator.getInstancia().getControladorUtil()
						.pesquisar(filtroLigacaoAgua, LigacaoAgua.class.getName());

		filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.IMOVEL_ID, matriculaImovel,
						ParametroSimples.CONECTOR_OR));
		filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.LIGACAO_AGUA_ID, matriculaImovel));
		filtroMedicaoHistorico.setCampoOrderBy(FiltroMedicaoHistorico.ANO_MES_REFERENCIA_FATURAMENTO);

		if(!ligacoesAgua.isEmpty()){
			filtroMedicaoHistorico
							.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.MEDICAO_TIPO_ID, MedicaoTipo.LIGACAO_AGUA));
		}else{
			filtroMedicaoHistorico.adicionarParametro(new ParametroSimples(FiltroMedicaoHistorico.MEDICAO_TIPO_ID, MedicaoTipo.POCO));
		}
		return Collections.checkedCollection(
						ServiceLocator.getInstancia().getControladorUtil()
										.pesquisar(filtroMedicaoHistorico, MedicaoHistorico.class.getName()), MedicaoHistorico.class);
	}

	/**
	 * Consulta o Historio de medicao de consumo de um imovel.
	 * 
	 * @author Marlos Ribeiro
	 * @param matriculaImovel
	 * @return colecao de {@link ImovelMicromedicao}.
	 */
	public Collection<ImovelMicromedicao> consultarConsumoHistorio(String matriculaImovel) throws ControladorException{

		Collection<MedicaoHistorico> medicoesHistorico = consultarMedicaoHistorio(matriculaImovel);
		Collection<ImovelMicromedicao> imoveisMicromedicao = new ArrayList<ImovelMicromedicao>();
		if(!medicoesHistorico.isEmpty()){
			FiltroConsumoHistorico filtroConsumoHistorico = new FiltroConsumoHistorico();
			// Consumo Historico
			filtroConsumoHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
			filtroConsumoHistorico.adicionarCaminhoParaCarregamentoEntidade("consumoTipo");
			filtroConsumoHistorico.adicionarCaminhoParaCarregamentoEntidade("consumoAnormalidade");

			for(MedicaoHistorico medicaoHistoricoConsumo : medicoesHistorico){
				if(medicaoHistoricoConsumo.getAnoMesReferencia() != 0){
					filtroConsumoHistorico.limparListaParametros();
					filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.ANO_MES_FATURAMENTO,
									medicaoHistoricoConsumo.getAnoMesReferencia()));
					filtroConsumoHistorico.adicionarParametro(new ParametroSimples(FiltroConsumoHistorico.IMOVEL_ID, matriculaImovel));
					filtroConsumoHistorico.setCampoOrderBy(FiltroConsumoHistorico.ANO_MES_FATURAMENTO);

					Collection<ConsumoHistorico> collectionConsumoHistorico = ServiceLocator.getInstancia().getControladorUtil()
									.pesquisar(filtroConsumoHistorico, ConsumoHistorico.class.getName());
					if(!collectionConsumoHistorico.isEmpty()){
						for(ConsumoHistorico consumoHistoricoNovo : collectionConsumoHistorico){
							ImovelMicromedicao imovelMicromedicao = new ImovelMicromedicao();
							imovelMicromedicao.setConsumoHistorico(consumoHistoricoNovo);
							imovelMicromedicao.setMedicaoHistorico(medicaoHistoricoConsumo);
							// if(!imoveisMicromedicao.contains(imovelMicromedicao)){
							imoveisMicromedicao.add(imovelMicromedicao);
							// }
							// obtem qtd de dias do consumo
							if(medicaoHistoricoConsumo.getDataLeituraAnteriorFaturamento() != null
											&& medicaoHistoricoConsumo.getDataLeituraAtualFaturamento() != null){
								int qtdDias = Util.obterQuantidadeDiasEntreDuasDatas(
												medicaoHistoricoConsumo.getDataLeituraAnteriorFaturamento(),
												medicaoHistoricoConsumo.getDataLeituraAtualFaturamento());
								imovelMicromedicao.setQtdDias("" + qtdDias);
							}
						}
					}
				}
			}
		}
		return imoveisMicromedicao;
	}

	/**
	 * Consulta o histórico de cosumo leitura de uma imóvel.
	 * 
	 * @author Marlos Ribeiro
	 * @param matricula
	 * @return Coleção de {@link ImovelConsumoLeituraHistorico}
	 */
	public Collection<ImovelConsumoLeituraHistorico> consultarConsumoLeituraHistorico(String matriculaImovel) throws ControladorException{

		List<ImovelMicromedicao> consumos = (List<ImovelMicromedicao>) consultarConsumoHistorio(matriculaImovel);
		Collection<ImovelConsumoLeituraHistorico> consumoLeituraHistoricos = new ArrayList<ImovelConsumoLeituraHistorico>();
		if(!consumos.isEmpty()){
			for(ImovelMicromedicao consumo : consumos){
				ImovelConsumoLeituraHistorico conumoLeituraHistorico = new ImovelConsumoLeituraHistorico();
				conumoLeituraHistorico.setReferencia(Util.formatarAnoMesParaMesAno(consumo.getMedicaoHistorico().getAnoMesReferencia()));
				conumoLeituraHistorico.setDataLeituraAnterior(consumo.getMedicaoHistorico().getDataLeituraAnteriorFaturamento());
				conumoLeituraHistorico.setDataLeituraAtual(consumo.getMedicaoHistorico().getDataLeituraAtualFaturamento());
				conumoLeituraHistorico.setConsumo(consumo.getConsumoHistorico().getNumeroConsumoFaturadoMes());
				conumoLeituraHistorico.setNumeroLeitura(consumo.getMedicaoHistorico().getLeituraAtualFaturamento());
				consumoLeituraHistoricos.add(conumoLeituraHistorico);
			}
		}

		Collections.reverse((List<ImovelConsumoLeituraHistorico>) consumoLeituraHistoricos);
		return consumoLeituraHistoricos;
	}

	/**
	 * Relação dos imóveis faturados/pré-faturados no grupo
	 * 
	 * @date 26/08/2012
	 * @author Hebert Falcão
	 */
	public Collection<Integer> pesquisarImoveisFaturadosOuPreFaturadosNoGrupo(Integer idFaturamentoGrupo, Integer anoMesFaturamento)
					throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarImoveisFaturadosOuPreFaturadosNoGrupo(idFaturamentoGrupo, anoMesFaturamento);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0337] Calculo Consumo Estimado
	 * 
	 * @author Marlos Ribeiro
	 * @param dataLeituraAnterior
	 * @param dataLeituraAtual
	 * @param leituraAnterior
	 * @param leituraAtual
	 * @return Mapa com as chaves: qtdDiasConsumo, consumidoEstimado, totalConsumidoPeriodo
	 */
	public Map<String, BigDecimal> calcularConsumoEstimado(Date dataLeituraAnterior, Date dataLeituraAtual, Integer leituraAnterior,
					Integer leituraAtual) throws ControladorException, NegocioException{

		if(dataLeituraAtual.compareTo(dataLeituraAnterior) < 0){
			throw new NegocioException(Constantes.RESOURCE_BUNDLE, "atencao.filtrar_data_final_maior_que_inicial");
		}
		Map<String, BigDecimal> consumoEstimado = new HashMap<String, BigDecimal>();
		consumoEstimado.put("qtdDiasConsumo", Calculos.calcularDiasConsumo(dataLeituraAnterior, dataLeituraAtual));
		consumoEstimado.put("totalConsumidoPeriodo", BigDecimal.valueOf(leituraAtual.intValue() - leituraAnterior.intValue()));
		consumoEstimado.put("consumoEstimado",
						Calculos.calcularConsumoEstimado(dataLeituraAnterior, dataLeituraAtual, leituraAnterior, leituraAtual));
		return consumoEstimado;

	}

	/**
	 * [UC0101] - Consistir Leituras e Calcular Consumos [SB0015] - Verificar
	 * alto consumo utilizando a quantidade de economias
	 * 
	 * @author Anderson Italo
	 * @date 31/10/2012
	 * @throws ControladorException
	 */
	protected boolean verificarAltoConsumoPorQuantidadeEconomias(ConsumoHistorico consumoHistorico, int consumoMedioImovel, Imovel imovel,
					MedicaoTipo medicaoTipo, MedicaoHistorico medicaoHistorico, int leituraAnterior, int consumoMinimoLigacao)
					throws ControladorException{

		boolean retorno = false;

		// Obtém o consumo a ser cobrado no mês
		Integer consumoASerCobradoMes = consumoHistorico.getNumeroConsumoFaturadoMes();
		if(consumoASerCobradoMes == null){

			consumoASerCobradoMes = 0;
		}

		// Obtém as categorias
		Collection<Categoria> colecaoCategorias = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);

		/*
		 * O sistema obtém o Consumo Total de Referência acumulando o consumo por economia de
		 * referência de cada categoria multiplicado pelo número de economias do imóvel na
		 * categoria.
		 */
		Integer consumoTotalReferenciaAcumulado = 0;

		for(Categoria categoria : colecaoCategorias){

			if(categoria.getConsumoAlto() != null){

				consumoTotalReferenciaAcumulado += categoria.getConsumoAlto() * categoria.getQuantidadeEconomiasCategoria();
			}

		}

		/*
		 * Obtendo o fator de multiplicação da média da categoria do imóvel que tenha o maior
		 * número de economias
		 */
		Collections.sort((List) colecaoCategorias, new Comparator() {

			public int compare(Object a, Object b){

				Integer quatidadeEconomias1 = ((Categoria) a).getQuantidadeEconomiasCategoria();
				Integer quatidadeEconomias2 = ((Categoria) b).getQuantidadeEconomiasCategoria();

				return quatidadeEconomias1.compareTo(quatidadeEconomias2);

			}
		});

		Categoria categoriaComMaiorNumeroEconomias = (Categoria) colecaoCategorias.iterator().next();

		/*
		 * Obtém o consumo médio do imóvel multiplicado pelo fator de multiplicação da média
		 * da categoria
		 */
		Integer consumoMedioMultiplicado = Util.arredondar(new BigDecimal(consumoMedioImovel).multiply(categoriaComMaiorNumeroEconomias
						.getVezesMediaAltoConsumo()));

		/*
		 * Caso o Consumo a Ser Cobrado no Mês seja superior ao Consumo Total de Referência
		 * obtido e ao consumo médio do imóvel multiplicado pelo fator de multiplicação da média
		 * da categoria do imóvel que tenha o maior número de economias
		 * (CATG_NNVEZESMEDIAALTOCONSUMO)
		 */
		if(consumoASerCobradoMes > consumoTotalReferenciaAcumulado && (consumoASerCobradoMes > consumoMedioMultiplicado)){

			/*
			 * O sistema gera a Anormalidade de Consumo com o valor correspondente a “alto
			 * consumo”
			 */
			ConsumoAnormalidade consumoAnormalidade = null;
			try{

				consumoAnormalidade = repositorioMicromedicao.pesquisarConsumoAnormalidade(ConsumoAnormalidade.ALTO_CONSUMO);
			}catch(ErroRepositorioException ex){

				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}

			consumoHistorico.setConsumoAnormalidade(consumoAnormalidade);

			// [SB0026 – Verificar Definição de Consumo pela Anormalidade de Consumo]
			verificarDefinicaoConsumoPelaAnormalidadeConsumo(consumoHistorico, medicaoHistorico, consumoMedioImovel, consumoMinimoLigacao,
							consumoAnormalidade, consumoASerCobradoMes);

			retorno = true;
		}

		return retorno;
	}

	/**
	 * [UC3012 – Gerar Arquivo Texto Faturamento Imediado]
	 * 
	 * @author Josenildo Neves
	 * @date 07/02/2013
	 * @param idRota
	 * @param referenciaFaturamento
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void encerrarFaturamentoGerarResumoLigacoesEconomias(Integer idRota, Integer referenciaFaturamento,
					Integer idFuncionalidadeIniciada) throws ControladorException{

		// -------------------------
		// Registrar o início do processamento da Unidade de Processamento do Batch
		// -------------------------
		int idUnidadeIniciada = 0;

		if(idRota != null){
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
							idRota);

			try{

				this.repositorioMicromedicao.deletarResumoLigacoesEconomia(idRota, referenciaFaturamento);

				this.gerarResumoLigacoesEconomias(ConstantesSistema.ZERO, referenciaFaturamento, idRota, false);
				
				this.getControladorAcesso().registrarLogExecucaoProcesso(idFuncionalidadeIniciada,
								"Processou a rota: " + idRota + ", na referencia: " + referenciaFaturamento + ".");

				// --------------------------------------------------------
				// Registrar o fim da execução da Unidade de Processamento
				// --------------------------------------------------------
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

			}catch(Exception e){
				
				this.getControladorAcesso().registrarLogExecucaoProcesso(idFuncionalidadeIniciada,
								"Ocorreu um erro na rota: " + idRota + ", EXCEPTION: " + e);

				sessionContext.setRollbackOnly();
				getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);
				throw new EJBException(e);
			}

		}else{
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
							0);
			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);
		}

	}

	/**
	 * @param anoMesFaturamento
	 * @param quantidadeEconomia
	 * @param helper
	 * @param idImovel
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	private void inserirAtualizarResumoLigacoesEconomias(Integer anoMesFaturamento, Integer quantidadeEconomia,
					ResumoLigacaoEconomiaHelper helper, Integer idImovel) throws ErroRepositorioException, ControladorException{

		Integer idResumoLigacaoEconomia;
		ResumoLigacoesEconomia resumoLigacoesEconomia = null;

		idResumoLigacaoEconomia = repositorioMicromedicao.pesquisarExistenciaResumoLigacaoEconomia(helper, anoMesFaturamento);

		// Caso já exista registro equivalente na base, acumula as quantidades de
		// economia e ligações e atualiza a base.
		// Caso não exista, atualiza as quantidades de ligações e economia e insere
		// na
		// base.
		if(idResumoLigacaoEconomia != null){

			// Recupera o Objeto, alterar os contadores de quantidades que forem
			// necessários e atualiza a entidade ResumoLigacoesEconomia.
			resumoLigacoesEconomia = repositorioMicromedicao.pesquisarResumoLigacaoEconomia(idResumoLigacaoEconomia);

			// 2.1.1. Somar 1 ao acumulador de quantidade de ligações
			// (RELE_QTLIGACOES);
			// Incrementamos as ligacoes
			resumoLigacoesEconomia.setQuantidadeLigacoes(resumoLigacoesEconomia.getQuantidadeLigacoes().intValue() + 1);

			// 2.1.2. Caso o imóvel seja um imóvel condomínio
			// (IMOV_ICIMOVELCONDOMINIO
			// na tabela IMOVEL com o valor um), acumular 1 a cada imóvel; Caso
			// Contrário, ou seja, o imóvel não seja um imóvel condomínio
			// (IMOV_ICIMOVELCONDOMINIO na tabela IMOVEL com o valor dois, somar a
			// quantidade de economias do imóvel (IMOV_QTECONOMIA) ao acumulador de
			// quantidade de economias (RELE_QTECONOMIAS)
			if(repositorioImovel.isImovelCondominio(idImovel)){
				// Somamos as economias
				resumoLigacoesEconomia.setQuantidadeEconomias(resumoLigacoesEconomia.getQuantidadeEconomias().intValue() + 1);
			}else{
				// Somamos as economias
				resumoLigacoesEconomia.setQuantidadeEconomias(resumoLigacoesEconomia.getQuantidadeEconomias().intValue()
								+ quantidadeEconomia);
			}

			LigacaoAgua ligacaoAgua = repositorioLigacaoAgua.pesquisarLigacaoAgua(idImovel);

			// 2.1.3. Caso o ano/mês da data da ligação de água seja igual ao
			// ano/mês da
			// arrecadação (ano/mês de LAGU_DTLIGACAOAGUA da tabela LIGACAO_AGUA com
			// LAGU_ID=IMOV_ID da tabela IMOVEL), somar 1 ao acumulador de
			// quantidade de
			// novas ligações de água cadastradas no mês
			// (RELE_QTLIGACOESNOVASAGUA)-futuro;
			if(ligacaoAgua != null && ligacaoAgua.getDataLigacao() != null
							&& Util.getAnoMesComoInteger(ligacaoAgua.getDataLigacao()).equals(anoMesFaturamento)){
				// Incrementamos as ligacoes novas de agua
				resumoLigacoesEconomia
								.setQuantidadeLigacoesNovasAgua(resumoLigacoesEconomia.getQuantidadeLigacoesNovasAgua().intValue() + 1);
			}

			LigacaoEsgoto ligacaoEsgoto = repositorioLigacaoEsgoto.pesquisarLigacaoEsgoto(idImovel);

			// 2.1.4. Caso o ano/mês da data da ligação de esgoto seja igual ao
			// ano/mês
			// da arrecadação (ano/mês de LESG_DTLIGACAO da tabela LIGACAO_ESGOTO
			// com
			// LESG_ID=IMOV_ID da tabela IMOVEL), somar 1 ao acumulador de
			// quantidade de
			// novas ligações de água cadastradas no mês
			// (RELE_QTLIGACOESNOVASESGOTO)-futuro
			if(ligacaoEsgoto != null && ligacaoEsgoto.getDataLigacao() != null
							&& Util.getAnoMesComoInteger(ligacaoEsgoto.getDataLigacao()).equals(anoMesFaturamento)){
				// Incrementamos as ligacoes novas de esgoto
				resumoLigacoesEconomia.setQuantidadeLigacoesNovasEsgoto(resumoLigacoesEconomia.getQuantidadeLigacoesNovasEsgoto()
								.intValue() + 1);
			}

			getControladorUtil().atualizar(resumoLigacoesEconomia);

		}else{
			// Incrementamos as ligacoes
			helper.setQtdLigacoes(1);

			// 2.1.2. Caso o imóvel seja um imóvel condomínio
			// (IMOV_ICIMOVELCONDOMINIO
			// na tabela IMOVEL com o valor um), acumular 1 a cada imóvel; Caso
			// Contrário, ou seja, o imóvel não seja um imóvel condomínio
			// (IMOV_ICIMOVELCONDOMINIO na tabela IMOVEL com o valor dois, somar a
			// quantidade de economias do imóvel (IMOV_QTECONOMIA) ao acumulador de
			// quantidade de economias (RELE_QTECONOMIAS)
			if(repositorioImovel.isImovelCondominio(idImovel)){
				// Somamos as economias
				helper.setQtdEconomias(1);
			}else{
				// Somamos as economias
				helper.setQtdEconomias(quantidadeEconomia);
			}

			LigacaoAgua ligacaoAgua = repositorioLigacaoAgua.pesquisarLigacaoAgua(idImovel);
			// Incrementamos as ligacoes novas de agua
			if(ligacaoAgua != null && ligacaoAgua.getDataLigacao() != null
							&& Util.getAnoMesComoInteger(ligacaoAgua.getDataLigacao()).equals(anoMesFaturamento)){
				helper.setQtdLigacoesNovasAgua(1);
			}

			LigacaoEsgoto ligacaoEsgoto = repositorioLigacaoEsgoto.pesquisarLigacaoEsgoto(idImovel);
			// Incrementamos as ligacoes novas de esgoto
			if(ligacaoEsgoto != null && ligacaoEsgoto.getDataLigacao() != null
							&& Util.getAnoMesComoInteger(ligacaoEsgoto.getDataLigacao()).equals(anoMesFaturamento)){
				helper.setQtdLigacoesNovasEsgoto(1);
			}

			// Cria e inicializa as entidades chaves para Inserir o
			// ResumoLigacoesEconomia.

			// Gerencia regional
			GerenciaRegional gerenciaRegional = null;
			if(helper.getIdGerenciaRegional() != null){
				gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setId(helper.getIdGerenciaRegional());
			}

			// Unidade de Negocio
			UnidadeNegocio unidadeNegocio = null;
			if(helper.getIdUnidadeNegocio() != null){
				unidadeNegocio = new UnidadeNegocio();
				unidadeNegocio.setId(helper.getIdUnidadeNegocio());
			}

			// Localidade
			Localidade localidade = null;
			if(helper.getIdLocalidade() != null){
				localidade = new Localidade();
				localidade.setId(helper.getIdLocalidade());
			}

			// Elo
			Localidade elo = null;
			if(helper.getIdElo() != null){
				elo = new Localidade();
				elo.setId(helper.getIdElo());
			}

			// Setor comercial
			SetorComercial setorComercial = null;
			if(helper.getIdSetorComercial() != null){
				setorComercial = new SetorComercial();
				setorComercial.setId(helper.getIdSetorComercial());
			}

			// Rota
			Rota rota = null;
			if(helper.getIdRota() != null){
				rota = new Rota();
				rota.setId(helper.getIdRota());
			}

			// Quadra
			Quadra quadra = null;
			if(helper.getIdQuadra() != null){
				quadra = new Quadra();
				quadra.setId(helper.getIdQuadra());
			}

			// Codigo do setor comercial
			Integer codigoSetorComercial = null;
			if(helper.getCodigoSetorComercial() != null){
				codigoSetorComercial = (helper.getCodigoSetorComercial());
			}

			// Numero da quadra
			Integer numeroQuadra = null;
			if(helper.getNumeroQuadra() != null){
				numeroQuadra = (helper.getNumeroQuadra());
			}

			// Perfil do imovel
			ImovelPerfil imovelPerfil = null;
			if(helper.getIdPerfilImovel() != null){
				imovelPerfil = new ImovelPerfil();
				imovelPerfil.setId(helper.getIdPerfilImovel());
			}

			// Esfera de poder do cliente responsavel
			EsferaPoder esferaPoder = null;
			if(helper.getIdEsfera() != null){
				esferaPoder = new EsferaPoder();
				esferaPoder.setId(helper.getIdEsfera());
			}

			// Tipo do cliente responsavel
			ClienteTipo clienteTipo = null;
			if(helper.getIdTipoClienteResponsavel() != null){
				clienteTipo = new ClienteTipo();
				clienteTipo.setId(helper.getIdTipoClienteResponsavel());
			}

			// Situacao da ligacao de agua
			LigacaoAguaSituacao ligacaoAguaSituacao = null;
			if(helper.getIdSituacaoLigacaoAgua() != null){
				ligacaoAguaSituacao = new LigacaoAguaSituacao();
				ligacaoAguaSituacao.setId(helper.getIdSituacaoLigacaoAgua());
			}

			// Situacao da ligacao de esgoto
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = null;
			if(helper.getIdSituacaoLigacaoEsgoto() != null){
				ligacaoEsgotoSituacao = new LigacaoEsgotoSituacao();
				ligacaoEsgotoSituacao.setId(helper.getIdSituacaoLigacaoEsgoto());
			}

			// Categoria
			Categoria categoria = null;
			if(helper.getIdCategoria() != null){
				categoria = new Categoria();
				categoria.setId(helper.getIdCategoria());
			}

			// Subcategoria
			Subcategoria subcategoria = null;
			if(helper.getIdSubCategoria() != null){
				subcategoria = new Subcategoria();
				subcategoria.setId(helper.getIdSubCategoria());
			}

			// Perfil da ligacao de agua
			LigacaoAguaPerfil perfilLigacaoAgua = null;
			if(helper.getIdPerfilLigacaoAgua() != null){
				perfilLigacaoAgua = new LigacaoAguaPerfil();
				perfilLigacaoAgua.setId(helper.getIdPerfilLigacaoAgua());
			}

			// Perfil da ligacao de esgoto
			LigacaoEsgotoPerfil perfilLigacaoEsgoto = null;
			if(helper.getIdPerfilLigacaoEsgoto() != null){
				perfilLigacaoEsgoto = new LigacaoEsgotoPerfil();
				perfilLigacaoEsgoto.setId(helper.getIdPerfilLigacaoEsgoto());
			}

			// Indicador de hidrometro
			Short indicadorHidrometro = null;
			if(helper.getIdHidrometro() != null){
				indicadorHidrometro = helper.getIdHidrometro().shortValue();
			}

			// Indicador de hidrometro no poco
			Short indicadorHidrometroPoco = null;
			if(helper.getIdHidrometroPoco() != null){
				indicadorHidrometroPoco = helper.getIdHidrometroPoco().shortValue();
			}

			// Indicador de volume minimo de agua fixado
			Short indicadorVolumeFixadoAgua = null;
			if(helper.getIdVolFixadoAgua() != null){
				indicadorVolumeFixadoAgua = helper.getIdVolFixadoAgua().shortValue();
			}

			// Indicador de volume minimo de esgoto fixado
			Short indicadorVolumeFixadoEsgoto = null;
			if(helper.getIdVolFixadoEsgoto() != null){
				indicadorVolumeFixadoEsgoto = helper.getIdVolFixadoEsgoto().shortValue();
			}

			// Indicador de poco
			Short indicadorPoco = null;
			if(helper.getIdPoco() != null){
				indicadorPoco = helper.getIdPoco().shortValue();
			}

			// Tipo de Tarifa de Consumo
			ConsumoTarifa consumoTarifa = null;
			if(helper.getIdTipoTarifaConsumo() != null){
				consumoTarifa = new ConsumoTarifa();
				consumoTarifa.setId(helper.getIdTipoTarifaConsumo());
			}

			// Quantidade ligacoes
			Integer qtdLigacoes = helper.getQtdLigacoes();

			// Quantidade economias
			Integer qtdEconomias = helper.getQtdEconomias();

			// Quantidade ligacoes
			Integer qtdLigacoesNovasAgua = helper.getQtdLigacoesNovasAgua();

			// Quantidade ligacoes
			Integer qtdLigacoesNovasEsgoto = helper.getQtdLigacoesNovasEsgoto();

			// Criamos um resumo de ligacao economia (***UFA***)
			resumoLigacoesEconomia = new ResumoLigacoesEconomia(anoMesFaturamento, indicadorHidrometro, indicadorVolumeFixadoAgua,
							indicadorVolumeFixadoEsgoto, indicadorHidrometroPoco, indicadorPoco, numeroQuadra, codigoSetorComercial,
							qtdLigacoes, qtdEconomias, qtdLigacoesNovasAgua, qtdLigacoesNovasEsgoto, gerenciaRegional, localidade,
							setorComercial, rota, quadra, imovelPerfil, ligacaoAguaSituacao, ligacaoEsgotoSituacao, categoria, esferaPoder,
							unidadeNegocio, elo, subcategoria, clienteTipo, perfilLigacaoAgua, perfilLigacaoEsgoto, consumoTarifa);

			getControladorUtil().inserir(resumoLigacoesEconomia);
		}
	}

	/**
	 * Método que gera o resumo das ligações economias
	 * [UC0275] - Gerar Resumo das Ligações conomias
	 * 
	 * @author Josenildo Neves
	 * @date 17/01/2013
	 */
	public void gerarResumoLigacoesEconomias(Integer idRota, String referenciaFaturamento, int idFuncionalidadeIniciada, Usuario usuario)
					throws ControladorException{

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.ROTA,
						idRota);

		try{

			Integer refFaturamento = null;

			if(!Util.isVazioOuBranco(referenciaFaturamento)){

				for(String referencia : referenciaFaturamento.split(",")){

					refFaturamento = Integer.valueOf(referencia);

					this.repositorioMicromedicao.deletarResumoLigacoesEconomia(idRota, refFaturamento);

					this.gerarResumoLigacoesEconomias(ConstantesSistema.ZERO, refFaturamento, idRota, true);

					this.getControladorAcesso().registrarLogExecucaoProcesso(idFuncionalidadeIniciada,
									"Rota: " + idRota + " executada com sucesso.");

				}

			}else{
				this.getControladorAcesso().registrarLogExecucaoProcesso(idFuncionalidadeIniciada,
								"Não existem referências cadastradas no parametro P_GERAR_RESUMO_LIGACOES_ECONOMIA_REFERENCIAS.");
			}

			// Fim verificação.

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, false);

		}catch(Exception ex){

			this.getControladorAcesso().registrarLogExecucaoProcesso(idFuncionalidadeIniciada,
							"Ocorreu um erro na rota: " + idRota + ", EXCEPTION: " + ex);

			getControladorBatch().encerrarUnidadeProcessamentoBatch(idUnidadeIniciada, true);

			throw new EJBException(ex);
		}
	}

	/**
	 * Este método irá verificar se em uma determinada referencia, o imóvel teve alterações nas
	 * ligações de água e/ou esgoto.
	 * 
	 * @param helper
	 */
	private boolean verificarLigacoesAnterioes(ResumoLigacaoEconomiaHelper helper, Integer idImovel, Integer referencia)
					throws ControladorException{

		Date referenciaInicial = Util.converterAnoMesParaDataInicial(referencia.toString());
		Date referenciaFinal = Util.converterAnoMesParaDataFinal(referencia.toString());
		Collection colecaoLigacaoAgua = null;
		boolean gerar = true;

		try{
			colecaoLigacaoAgua = this.repositorioMicromedicao.pesquisarLigacaoAguaPorImovel(idImovel, referenciaInicial, referenciaFinal);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		Object[] retorno = (Object[]) Util.retonarObjetoDeColecao(colecaoLigacaoAgua);

		if(!Util.isVazioOuBranco(retorno)){

			Date dataLigacao = (Date) retorno[1];
			Date dataSupressao = (Date) retorno[2]; // 2
			Date dataCorte = (Date) retorno[3]; // 3
			Date dataReligacao = (Date) retorno[4]; // 4
			// Date ultimaAlteracao = (Date) retorno[5]; // 5
			Date dataRestabelecimentoAgua = (Date) retorno[6]; // 6
			// Date dataCorteAdministrativo = (Date) retorno[7]; // 7
			Date dataImplantacao = (Date) retorno[8]; // 8

			// LAGU_DTCORTE is null
			// and LAGU_DTSUPRESSAOAGUA is null
			// and LAGU_DTRELIGACAOAGUA is null
			// and LAGU_DTRESTABELECIMENTOAGUA is null
			// and ((LAGU_DTIMPLANTACAO > to_date ('30/11/2012','DD/MM/YYYY') and
			// LAGU_DTLIGACAOAGUA > to_date ('30/11/2012','DD/MM/YYYY') ) or
			// (LAGU_DTIMPLANTACAO is null and
			// LAGU_DTLIGACAOAGUA > to_date ('30/11/2012','DD/MM/YYYY') ) or
			// (LAGU_DTLIGACAOAGUA is null and
			// LAGU_DTIMPLANTACAO > to_date ('30/11/2012','DD/MM/YYYY') ))
			// --===> excluir da lista
			if(Util.isVazioOuBranco(dataCorte)
							&& Util.isVazioOuBranco(dataSupressao)
							&& Util.isVazioOuBranco(dataReligacao)
							&& Util.isVazioOuBranco(dataRestabelecimentoAgua)
							&& (((!Util.isVazioOuBranco(dataImplantacao) && Util.compararData(dataImplantacao, referenciaFinal) == ConstantesSistema.SIM) && (!Util
											.isVazioOuBranco(dataLigacao) && Util.compararData(dataLigacao, referenciaFinal) == ConstantesSistema.SIM))
											|| (Util.isVazioOuBranco(dataImplantacao) && (!Util.isVazioOuBranco(dataLigacao) && Util
															.compararData(dataLigacao, referenciaFinal) == ConstantesSistema.SIM)) || (Util
											.isVazioOuBranco(dataLigacao) && (!Util.isVazioOuBranco(dataImplantacao) && Util.compararData(
											dataImplantacao, referenciaFinal) == ConstantesSistema.SIM)))){

				gerar = false;
			}else{
				// LAGU_DTCORTE is null
				// and LAGU_DTSUPRESSAOAGUA is null
				// and LAGU_DTRELIGACAOAGUA is null
				// and LAGU_DTRESTABELECIMENTOAGUA is null
				// and LAGU_DTIMPLANTACAO <= to_date ('30/11/2012','DD/MM/YYYY')
				// and LAGU_DTLIGACAOAGUA > to_date ('30/11/2012','DD/MM/YYYY')
				// and LAST_ID NOT IN (1,2)
				// --===> alterar para 2
				if(Util.isVazioOuBranco(dataCorte)
								&& Util.isVazioOuBranco(dataSupressao)
								&& Util.isVazioOuBranco(dataReligacao)
								&& Util.isVazioOuBranco(dataRestabelecimentoAgua)
								&& (!Util.isVazioOuBranco(dataImplantacao) && Util.compararData(dataImplantacao, referenciaFinal) != ConstantesSistema.SIM)
								&& (!Util.isVazioOuBranco(dataLigacao) && Util.compararData(dataLigacao, referenciaFinal) == ConstantesSistema.SIM)
								&& !helper.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.POTENCIAL)
								&& !helper.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.FACTIVEL)){

					helper.setIdSituacaoLigacaoAgua(LigacaoAguaSituacao.FACTIVEL);
				}else{
					// LAGU_DTCORTE <= to_date ('30/11/2012','DD/MM/YYYY')
					// and (LAGU_DTRELIGACAOAGUA > to_date ('30/11/2012','DD/MM/YYYY') or
					// LAGU_DTRESTABELECIMENTOAGUA > to_date ('30/11/2012','DD/MM/YYYY') or
					// LAGU_DTSUPRESSAOAGUA > to_date ('30/11/2012','DD/MM/YYYY') )
					// and (LAGU_DTRELIGACAOAGUA is null or
					// (LAGU_DTRELIGACAOAGUA is not null and
					// (LAGU_DTRELIGACAOAGUA < LAGU_DTCORTE or
					// LAGU_DTRELIGACAOAGUA > to_date ('30/11/2012','DD/MM/YYYY') )))
					// and (LAGU_DTRESTABELECIMENTOAGUA is null or
					// (LAGU_DTRESTABELECIMENTOAGUA is not null and
					// (LAGU_DTRESTABELECIMENTOAGUA < LAGU_DTCORTE or
					// LAGU_DTRESTABELECIMENTOAGUA > to_date ('30/11/2012','DD/MM/YYYY') )))
					// and (LAGU_DTSUPRESSAOAGUA is null or
					// (LAGU_DTSUPRESSAOAGUA is not null and
					// (LAGU_DTSUPRESSAOAGUA < LAGU_DTCORTE or
					// LAGU_DTSUPRESSAOAGUA > to_date ('30/11/2012','DD/MM/YYYY') )))
					// and LAST_ID NOT IN (4,5)
					// --===> alterar para 5
					if((!Util.isVazioOuBranco(dataCorte) && Util.compararData(dataCorte, referenciaFinal) != ConstantesSistema.SIM)
									&& ((!Util.isVazioOuBranco(dataReligacao) && Util.compararData(dataReligacao, referenciaFinal) == ConstantesSistema.SIM)
													|| (!Util.isVazioOuBranco(dataRestabelecimentoAgua) && Util.compararData(
																	dataRestabelecimentoAgua, referenciaFinal) == ConstantesSistema.SIM) || (!Util
													.isVazioOuBranco(dataSupressao) && Util.compararData(dataSupressao, referenciaFinal) == ConstantesSistema.SIM))
									&& (Util.isVazioOuBranco(dataReligacao) || (!Util.isVazioOuBranco(dataReligacao) && (Util.compararData(
													dataReligacao, dataCorte) == ConstantesSistema.VALOR_MENOR || Util.compararData(
													dataReligacao, referenciaFinal) == ConstantesSistema.SIM)))
									&& (Util.isVazioOuBranco(dataRestabelecimentoAgua) || (!Util.isVazioOuBranco(dataRestabelecimentoAgua) && (Util
													.compararData(dataRestabelecimentoAgua, dataCorte) == ConstantesSistema.VALOR_MENOR || Util
													.compararData(dataRestabelecimentoAgua, referenciaFinal) == ConstantesSistema.SIM)))
									&& (Util.isVazioOuBranco(dataSupressao) || (!Util.isVazioOuBranco(dataSupressao) && (Util.compararData(
													dataSupressao, dataCorte) == ConstantesSistema.VALOR_MENOR || Util.compararData(
													dataSupressao, referenciaFinal) == ConstantesSistema.SIM)))
									&& (!helper.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.CORTADO_PEDIDO) && !helper
													.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.CORTADO))){

						helper.setIdSituacaoLigacaoAgua(LigacaoAguaSituacao.CORTADO);
					}else{
						// LAGU_DTSUPRESSAOAGUA <= to_date ('30/11/2012','DD/MM/YYYY')
						// and (LAGU_DTRELIGACAOAGUA > to_date ('30/11/2012','DD/MM/YYYY') or
						// LAGU_DTRESTABELECIMENTOAGUA > to_date ('30/11/2012','DD/MM/YYYY') or
						// LAGU_DTCORTE > to_date ('30/11/2012','DD/MM/YYYY') )
						// and (LAGU_DTRELIGACAOAGUA is null or
						// (LAGU_DTRELIGACAOAGUA is not null and
						// (LAGU_DTRELIGACAOAGUA < LAGU_DTSUPRESSAOAGUA or
						// LAGU_DTRELIGACAOAGUA > to_date ('30/11/2012','DD/MM/YYYY') )))
						// and (LAGU_DTRESTABELECIMENTOAGUA is null or
						// (LAGU_DTRESTABELECIMENTOAGUA is not null and
						// (LAGU_DTRESTABELECIMENTOAGUA < LAGU_DTSUPRESSAOAGUA or
						// LAGU_DTRESTABELECIMENTOAGUA > to_date ('30/11/2012','DD/MM/YYYY') )))
						// and (LAGU_DTCORTE is null or
						// (LAGU_DTCORTE is not null and
						// (LAGU_DTCORTE < LAGU_DTSUPRESSAOAGUA or
						// LAGU_DTCORTE > to_date ('30/11/2012','DD/MM/YYYY')) ))
						// and LAST_ID NOT IN (6,7,8)
						// --===> alterar para 6
						if((!Util.isVazioOuBranco(dataSupressao) && Util.compararData(dataSupressao, referenciaFinal) != ConstantesSistema.SIM)
										&& ((!Util.isVazioOuBranco(dataReligacao) && Util.compararData(dataReligacao, referenciaFinal) == ConstantesSistema.SIM)
														|| (!Util.isVazioOuBranco(dataRestabelecimentoAgua) && Util.compararData(
																		dataRestabelecimentoAgua, referenciaFinal) == ConstantesSistema.SIM) || (!Util
														.isVazioOuBranco(dataCorte) && Util.compararData(dataCorte, referenciaFinal) == ConstantesSistema.SIM))
										&& (Util.isVazioOuBranco(dataReligacao) || (!Util.isVazioOuBranco(dataReligacao) && (Util
														.compararData(dataReligacao, dataSupressao) == ConstantesSistema.VALOR_MENOR || Util
														.compararData(dataReligacao, referenciaFinal) == ConstantesSistema.SIM)))
										&& (Util.isVazioOuBranco(dataRestabelecimentoAgua) || (!Util
														.isVazioOuBranco(dataRestabelecimentoAgua) && (Util.compararData(
														dataRestabelecimentoAgua, dataSupressao) == ConstantesSistema.VALOR_MENOR || Util
														.compararData(dataRestabelecimentoAgua, referenciaFinal) == ConstantesSistema.SIM)))
										&& (Util.isVazioOuBranco(dataCorte) || (!Util.isVazioOuBranco(dataCorte) && (Util.compararData(
														dataCorte, dataSupressao) == ConstantesSistema.VALOR_MENOR || Util.compararData(
														dataCorte, referenciaFinal) == ConstantesSistema.SIM)))
										&& (!helper.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.SUPR_PARC)
														&& !helper.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.SUPRIMIDO) && !helper
														.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.SUPRIMIDO_DEFINITIVO))){

							helper.setIdSituacaoLigacaoAgua(LigacaoAguaSituacao.SUPR_PARC);
						}else{
							// LAGU_DTSUPRESSAOAGUA > to_date ('30/11/2012','DD/MM/YYYY')
							// and (LAGU_DTCORTE is null
							// or (LAGU_DTRELIGACAOAGUA is null and
							// (LAGU_DTRESTABELECIMENTOAGUA <= to_date ('30/11/2012','DD/MM/YYYY')
							// and LAGU_DTRESTABELECIMENTOAGUA > LAGU_DTCORTE) )
							// or (LAGU_DTRESTABELECIMENTOAGUA is null and
							// (LAGU_DTRELIGACAOAGUA <= to_date ('30/11/2012','DD/MM/YYYY') and
							// LAGU_DTRELIGACAOAGUA > LAGU_DTCORTE) )
							// or ((LAGU_DTRELIGACAOAGUA <= to_date ('30/11/2012','DD/MM/YYYY') and
							// LAGU_DTRELIGACAOAGUA > LAGU_DTCORTE)
							// and (LAGU_DTRESTABELECIMENTOAGUA <= to_date
							// ('30/11/2012','DD/MM/YYYY')
							// and LAGU_DTRESTABELECIMENTOAGUA > LAGU_DTCORTE) ))
							// and LAST_ID NOT IN (3)
							// --===> alterar supr para 3
							if((!Util.isVazioOuBranco(dataSupressao) && Util.compararData(dataSupressao, referenciaFinal) == ConstantesSistema.SIM)
											&& (Util.isVazioOuBranco(dataCorte)
															|| (Util.isVazioOuBranco(dataReligacao) && (!Util
																			.isVazioOuBranco(dataRestabelecimentoAgua)
																			&& Util.compararData(dataRestabelecimentoAgua, referenciaFinal) != ConstantesSistema.SIM && Util
																			.compararData(dataRestabelecimentoAgua, dataCorte) == ConstantesSistema.SIM))
															|| (Util.isVazioOuBranco(dataRestabelecimentoAgua) && (!Util
																			.isVazioOuBranco(dataReligacao)
																			&& Util.compararData(dataReligacao, referenciaFinal) != ConstantesSistema.SIM && Util
																			.compararData(dataReligacao, dataCorte) == ConstantesSistema.SIM)) || ((!Util
															.isVazioOuBranco(dataReligacao)
															&& Util.compararData(dataReligacao, referenciaFinal) != ConstantesSistema.SIM && Util
															.compararData(dataReligacao, dataCorte) == ConstantesSistema.SIM) && (!Util
															.isVazioOuBranco(dataRestabelecimentoAgua)
															&& Util.compararData(dataRestabelecimentoAgua, referenciaFinal) != ConstantesSistema.SIM && Util
															.compararData(dataRestabelecimentoAgua, dataCorte) == ConstantesSistema.SIM)))
											&& (!helper.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.LIGADO))){

								helper.setIdSituacaoLigacaoAgua(LigacaoAguaSituacao.LIGADO);
							}else{
								// LAGU_DTCORTE > to_date ('30/11/2012','DD/MM/YYYY')
								// and (LAGU_DTSUPRESSAOAGUA is null
								// or (LAGU_DTRELIGACAOAGUA is null and
								// (LAGU_DTRESTABELECIMENTOAGUA <= to_date
								// ('30/11/2012','DD/MM/YYYY') and
								// LAGU_DTRESTABELECIMENTOAGUA > LAGU_DTSUPRESSAOAGUA) )
								// or (LAGU_DTRESTABELECIMENTOAGUA is null and
								// (LAGU_DTRELIGACAOAGUA <= to_date ('30/11/2012','DD/MM/YYYY') and
								// LAGU_DTRELIGACAOAGUA > LAGU_DTSUPRESSAOAGUA) )
								// or ((LAGU_DTRELIGACAOAGUA <= to_date ('30/11/2012','DD/MM/YYYY')
								// and LAGU_DTRELIGACAOAGUA > LAGU_DTSUPRESSAOAGUA)
								// and (LAGU_DTRESTABELECIMENTOAGUA <= to_date
								// ('30/11/2012','DD/MM/YYYY') and
								// LAGU_DTRESTABELECIMENTOAGUA > LAGU_DTSUPRESSAOAGUA) ))
								// and LAST_ID NOT IN (3)
								// --===> alterar cort para 3
								if((!Util.isVazioOuBranco(dataCorte) && Util.compararData(dataCorte, referenciaFinal) == ConstantesSistema.SIM)
												&& (Util.isVazioOuBranco(dataSupressao) || (Util.isVazioOuBranco(dataReligacao)
																&& ((!Util.isVazioOuBranco(dataRestabelecimentoAgua)
																				&& Util.compararData(dataRestabelecimentoAgua,
																								referenciaFinal) != ConstantesSistema.SIM && Util
																				.compararData(dataRestabelecimentoAgua, dataSupressao) == ConstantesSistema.SIM))
																|| (Util.isVazioOuBranco(dataRestabelecimentoAgua) && (!Util
																				.isVazioOuBranco(dataReligacao)
																				&& Util.compararData(dataReligacao, referenciaFinal) != ConstantesSistema.SIM && Util
																				.compararData(dataReligacao, dataSupressao) == ConstantesSistema.SIM)) || (!Util
																.isVazioOuBranco(dataReligacao)
																&& Util.compararData(dataReligacao, referenciaFinal) != ConstantesSistema.SIM && Util
																.compararData(dataReligacao, dataSupressao) == ConstantesSistema.SIM)
																&& (!Util.isVazioOuBranco(dataRestabelecimentoAgua)
																				&& Util.compararData(dataRestabelecimentoAgua,
																								referenciaFinal) != ConstantesSistema.SIM && Util
																				.compararData(dataRestabelecimentoAgua, dataSupressao) == ConstantesSistema.SIM)))
												&& (!helper.getIdSituacaoLigacaoAgua().equals(LigacaoAguaSituacao.LIGADO))){

									helper.setIdSituacaoLigacaoAgua(LigacaoAguaSituacao.LIGADO);
								}
							}
						}
					}
				}
			}
		}

		// PARA LIGAÇÃO ESGOTO
		//
		// se LESG_TMULTIMAALTERACAO >= primeiro dia da REF informada: Faça
		//
		// Se LESG_DTLIGACAO is NOT null
		// Se LESG_DTLIGACAO > ultimo dia da REF informada
		// e LEST_ID NOT IN (1,2)
		// ALTERAR LEST_ID=2 do imovel;
		boolean dataLigacaoMaiorQueReferencia = false;
		try{
			dataLigacaoMaiorQueReferencia = this.repositorioMicromedicao.verificarDateLigacaoEsgotoPorImovel(idImovel, referenciaInicial,
							referenciaFinal);
		}catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}

		if(dataLigacaoMaiorQueReferencia
						&& (helper.getIdSituacaoLigacaoEsgoto() != LigacaoEsgotoSituacao.POTENCIAL && helper.getIdSituacaoLigacaoEsgoto() != LigacaoEsgotoSituacao.FACTIVEL)){
			helper.setIdSituacaoLigacaoEsgoto(LigacaoEsgotoSituacao.FACTIVEL);
			// gerar = true;
		}

		return gerar;

	}

	/*
	 * Obter Consumo Médio passando id Imóvel
	 */

	public Integer obterConsumoMedio(Integer idImovel) throws ControladorException{

		Integer consumoMedio = null;
		
		try{
			consumoMedio = repositorioMicromedicao.obterConsumoMedio(idImovel);
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		return consumoMedio;
	}

	public ConsumoHistorico obterUltimoConsumoHistoricoImovel(String idImovel) throws ControladorException{

		Object[] dadosConsumoHistorico;
		ConsumoHistorico consumoHistorico = null;

		try{

			dadosConsumoHistorico = repositorioMicromedicao.obterIDReferenciaConsumoHistorico(idImovel);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

		if(dadosConsumoHistorico[0] != null){

			Integer idConsumoHistorico=Integer.parseInt(dadosConsumoHistorico[0].toString());

			consumoHistorico = (ConsumoHistorico) this.getControladorUtil().pesquisar(idConsumoHistorico, ConsumoHistorico.class, false);

			}


		return consumoHistorico;
	}

	/**
	 * Obtêm ConsumoHistórico para aterar dados do faturamento (consumoMedio).
	 */
	public void atualizarUltimoConsumoHistorico(Integer idConsumoHistorico, Integer valor) throws ControladorException{

		try{
			repositorioMicromedicao.atualizarUltimoConsumoHistorico(idConsumoHistorico, valor);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC3010 – Verificar Atendimento do Critério de Faturamento pelo Imóvel]
	 * [SB0001] – Obter Valor dos Débitos a Cobrar Faturáveis
	 * Verifica se o imóvel possui débitos a cobrar faturáveis
	 * 
	 * @author Anderson Italo
	 * @date 24/04/2013
	 */
	private boolean verificarImovelComDebitosACobrarFaturaveis(Imovel imovel, Integer anoMesReferencia, SistemaParametro sistemaParametro,
					boolean apenasDebitoTipoParcelamento)
					throws ControladorException{

		boolean achouImovel = false;
		boolean situacaoLigacaoAguaPermitida = false;

		String[] pLigacaoAguaSituacaoPermitida = ((String) ParametroFaturamento.P_SITUACOES_LIGACAO_AGUA_QUE_COBRAM_VALOR_SERVICO
						.executar()).split(",");

		for(int x = 0; x < pLigacaoAguaSituacaoPermitida.length; x++){

			if(pLigacaoAguaSituacaoPermitida[x].equals(imovel.getLigacaoAguaSituacao().getId().toString())){

				situacaoLigacaoAguaPermitida = true;
				break;
			}
		}

		// Caso a situação de ligação de água do imóvel permita cobrar valor de serviço
		if(situacaoLigacaoAguaPermitida){

			BigDecimal somatorioValorDebitosACobrar = getControladorFaturamento().calcularValorDebitoACobrar(imovel.getId(),
							anoMesReferencia, apenasDebitoTipoParcelamento);

			// Caso existam débitos a cobrar possíveis de serem faturados em conta
			if(somatorioValorDebitosACobrar.compareTo(BigDecimal.ZERO) > 0){

				/*
				 * Caso o somatório dos débitos a cobrar seja maior ou igual ao valor mínimo para
				 * emissão de conta
				 */
				if(somatorioValorDebitosACobrar.compareTo(sistemaParametro.getValorMinimoEmissaoConta()) >= 0){

					achouImovel = true;
				}
			}
		}

		return achouImovel;
	}

	/**
	 * [UC0948] Informar Dados de Leituras e Anormalidades
	 * [FS0036] – Verificar a existência do tipo de serviço
	 * 
	 * @author Hebert Falcão
	 * @date 21/07/2013
	 */
	private void validarServicoTipo(StringBuilder erros, Integer id) throws ControladorException{

		FiltroServicoTipo filtroServicoTipo = new FiltroServicoTipo();
		filtroServicoTipo.adicionarParametro(new ParametroSimples(FiltroServicoTipo.ID, id));

		Collection<ServicoTipo> colecaoServicoTipo = this.getControladorUtil().pesquisar(filtroServicoTipo, ServicoTipo.class.getName());

		if(Util.isVazioOrNulo(colecaoServicoTipo)){
			erros.append("Arquivo de Retorno de Leitura com Tipo de Serviço inválido.");
		}
	}

	/**
	 * [UC0948] Informar Dados de Leituras e Anormalidades
	 * Religação Automática de Consumidor
	 * 
	 * @author Hebert Falcão
	 * @created 04/08/2013
	 */
	private String gerarLinhaReligacaoAutomaticaConsumidor(MovimentoRoteiroEmpresa movimentoRoteiroEmpresa) throws ControladorException{

		StringBuilder linha = new StringBuilder();

		// RAC-MATRIC-CONS
		String idImovelStr = "";
		Integer idImovel = null;

		Imovel imovel = movimentoRoteiroEmpresa.getImovel();

		if(imovel != null){
			idImovel = imovel.getId();

			if(idImovel != null){
				idImovelStr = Integer.toString(idImovel);
			}
		}

		idImovelStr = Util.completarStringZeroEsquerda(idImovelStr, 9);
		linha.append(idImovelStr);

		// Gerência Regional
		String idGerenciaRegionalStr = "";

		// Localidade
		String idLocalidadeStr = "";
		Localidade localidade = movimentoRoteiroEmpresa.getLocalidade();

		if(localidade != null){
			Integer idLocalidade = localidade.getId();

			if(idLocalidade != null){
				idLocalidadeStr = Integer.toString(idLocalidade);

				FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, idLocalidade));

				Collection<Localidade> colecaoLocalidade = this.getControladorUtil()
								.pesquisar(filtroLocalidade, Localidade.class.getName());

				if(!Util.isVazioOrNulo(colecaoLocalidade)){
					localidade = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidade);

					GerenciaRegional gerenciaRegional = localidade.getGerenciaRegional();

					if(gerenciaRegional != null){
						Integer idGerenciaRegional = gerenciaRegional.getId();

						if(idGerenciaRegional != null){
							idGerenciaRegionalStr = Integer.toString(idGerenciaRegional);
						}
					}
				}
			}
		}

		idGerenciaRegionalStr = Util.completarStringZeroEsquerda(idGerenciaRegionalStr, 2);
		idLocalidadeStr = Util.completarStringZeroEsquerda(idLocalidadeStr, 3);

		// Setor Comercial
		String codigoSetorComercialStr = "";
		Integer codigoSetorComercial = movimentoRoteiroEmpresa.getCodigoSetorComercial();

		if(codigoSetorComercial != null){
			codigoSetorComercialStr = Integer.toString(codigoSetorComercial);
		}

		codigoSetorComercialStr = Util.completarStringZeroEsquerda(codigoSetorComercialStr, 2);

		// Quadra
		String numeroQuadraStr = "";
		Integer numeroQuadra = movimentoRoteiroEmpresa.getNumeroQuadra();

		if(numeroQuadra != null){
			numeroQuadraStr = Integer.toString(numeroQuadra);
		}

		numeroQuadraStr = Util.completarStringZeroEsquerda(numeroQuadraStr, 3);

		// Lote
		String numeroLoteImovelStr = "";
		Short numeroLoteImovel = movimentoRoteiroEmpresa.getNumeroLoteImovel();

		if(numeroLoteImovel != null){
			numeroLoteImovelStr = Short.toString(numeroLoteImovel);
		}

		numeroLoteImovelStr = Util.completarStringZeroEsquerda(numeroLoteImovelStr, 4);

		// RAC-REGIONAL
		linha.append(idGerenciaRegionalStr);

		// RAC-INSCRICAO
		linha.append(idLocalidadeStr + codigoSetorComercialStr + numeroQuadraStr + numeroLoteImovelStr);

		// RAC-LOCAL
		linha.append(idLocalidadeStr);

		// RAC-SFT
		linha.append(codigoSetorComercialStr);

		// RAC-QUADRA
		linha.append(numeroQuadraStr);

		// RAC-LOTE
		linha.append(numeroLoteImovelStr);

		// RAC-INSCRICAO-R
		linha.append(idLocalidadeStr + codigoSetorComercialStr + numeroQuadraStr + numeroLoteImovelStr);

		// RAC-DATA-CORTE
		String dataCorteStr = "";
		Date dataCorte = null;

		LigacaoAgua ligacaoAgua = null;

		if(idImovel != null){
			FiltroLigacaoAgua filtroLigacaoAgua = new FiltroLigacaoAgua();
			filtroLigacaoAgua.adicionarParametro(new ParametroSimples(FiltroLigacaoAgua.ID, idImovel));
			filtroLigacaoAgua.adicionarCaminhoParaCarregamentoEntidade(FiltroLigacaoAgua.HIDROMETRO_INSTALACAO_HISTORICO);

			Collection<LigacaoAgua> colecaoLigacaoAgua = this.getControladorUtil()
							.pesquisar(filtroLigacaoAgua, LigacaoAgua.class.getName());

			if(!Util.isVazioOrNulo(colecaoLigacaoAgua)){
				ligacaoAgua = (LigacaoAgua) Util.retonarObjetoDeColecao(colecaoLigacaoAgua);

				dataCorte = ligacaoAgua.getDataCorte();

				if(dataCorte != null){
					dataCorteStr = Util.formatarData(dataCorte);
				}
			}
		}

		dataCorteStr = Util.completaString(dataCorteStr, 10);
		linha.append(dataCorteStr);

		// RAC-DATA-LEITURA
		String dataLeituraStr = "";
		Date dataLeitura = movimentoRoteiroEmpresa.getDataLeitura();

		if(dataLeitura != null){
			dataLeituraStr = Util.formatarData(dataLeitura);
		}

		dataLeituraStr = Util.completaString(dataLeituraStr, 10);
		linha.append(dataLeituraStr);

		// RAC-LEIT-CORTE
		String numeroLeituraCorteStr = "";
		Integer numeroLeituraCorte = null;

		if(ligacaoAgua != null){
			HidrometroInstalacaoHistorico hidrometroInstalacaoHistorico = ligacaoAgua.getHidrometroInstalacaoHistorico();

			if(hidrometroInstalacaoHistorico != null){
				numeroLeituraCorte = hidrometroInstalacaoHistorico.getNumeroLeituraCorte();

				if(numeroLeituraCorte != null){
					numeroLeituraCorteStr = Integer.toString(numeroLeituraCorte);
				}
			}
		}

		numeroLeituraCorteStr = Util.completarStringZeroEsquerda(numeroLeituraCorteStr, 7);
		linha.append(numeroLeituraCorteStr);

		// RAC-LEIT-ATUAL
		String numeroLeituraAtualStr = "";
		Integer numeroLeituraAtual = movimentoRoteiroEmpresa.getNumeroLeitura();

		if(numeroLeituraAtual != null){
			numeroLeituraAtualStr = Integer.toString(numeroLeituraAtual);
		}

		numeroLeituraAtualStr = Util.completarStringZeroEsquerda(numeroLeituraAtualStr, 7);
		linha.append(numeroLeituraAtualStr);

		// RAC-CONSUMO-CORTADO
		String consumoCortadoStr = "";
		Integer consumoCortado = null;

		if(numeroLeituraAtual != null && numeroLeituraCorte != null){
			if(numeroLeituraAtual < numeroLeituraCorte){
				consumoCortado = 1000000 - numeroLeituraCorte + numeroLeituraAtual;
			}else{
				consumoCortado = numeroLeituraAtual - numeroLeituraCorte;
			}
		}

		if(consumoCortado != null){
			consumoCortadoStr = Integer.toString(consumoCortado);
		}

		consumoCortadoStr = Util.completarStringZeroEsquerda(consumoCortadoStr, 6);
		linha.append(consumoCortadoStr);

		// RAC-CONSUMO-MES
		String numeroConsumoFaturadoAguaStr = "";
		Integer numeroConsumoFaturadoAgua = movimentoRoteiroEmpresa.getNumeroConsumoFaturadoAgua();

		if(numeroConsumoFaturadoAgua != null){
			numeroConsumoFaturadoAguaStr = Integer.toString(numeroConsumoFaturadoAgua);
		}

		numeroConsumoFaturadoAguaStr = Util.completarStringZeroEsquerda(numeroConsumoFaturadoAguaStr, 6);
		linha.append(numeroConsumoFaturadoAguaStr);

		// RAC-NRO-MESES
		String numeroMesesStr = "";

		if(dataLeitura != null && dataCorte != null){
			long numeroMeses = 0;

			if(dataLeitura.compareTo(dataCorte) >= 0){
				numeroMeses = Util.calcularDiferencaDeMes(dataCorte, dataLeitura);
			}

			numeroMesesStr = Long.toString(numeroMeses);
		}

		numeroMesesStr = Util.completarStringZeroEsquerda(numeroMesesStr, 3);
		linha.append(numeroMesesStr);

		// RAC-ANO-MES-FAT
		String anoMesMovimentoStr = "";
		Integer anoMesMovimento = movimentoRoteiroEmpresa.getAnoMesMovimento();

		if(anoMesMovimento != null){
			anoMesMovimentoStr = Integer.toString(anoMesMovimento);
		}

		anoMesMovimentoStr = Util.completarStringZeroEsquerda(anoMesMovimentoStr, 6);
		linha.append(anoMesMovimentoStr);

		// RAC-DATA-PROCESS
		String dataAtual = Util.formatarData(new Date());
		linha.append(dataAtual);

		// Quantidade de Economias
		Short quantidadeEconomiasResidencial = movimentoRoteiroEmpresa.getQuantidadeEconomiasResidencial();
		Short quantidadeEconomiasComercial = movimentoRoteiroEmpresa.getQuantidadeEconomiasComercial();
		Short quantidadeEconomiasIndustrial = movimentoRoteiroEmpresa.getQuantidadeEconomiasIndustrial();
		Short quantidadeEconomiasPublica = movimentoRoteiroEmpresa.getQuantidadeEconomiasPublica();

		// RAC-CATEGORIA
		String categoriaStr = "";

		if(quantidadeEconomiasResidencial != null && !quantidadeEconomiasResidencial.equals(Short.parseShort("0"))){
			if(Util.isVazioOuBranco(categoriaStr)){
				categoriaStr = "1";
			}else{
				categoriaStr = "5";
			}
		}

		if(quantidadeEconomiasComercial != null && !quantidadeEconomiasComercial.equals(Short.parseShort("0"))){
			if(Util.isVazioOuBranco(categoriaStr)){
				categoriaStr = "2";
			}else{
				categoriaStr = "5";
			}
		}

		if(quantidadeEconomiasIndustrial != null && !quantidadeEconomiasIndustrial.equals(Short.parseShort("0"))){
			if(Util.isVazioOuBranco(categoriaStr)){
				categoriaStr = "3";
			}else{
				categoriaStr = "5";
			}
		}

		if(quantidadeEconomiasPublica != null && !quantidadeEconomiasPublica.equals(Short.parseShort("0"))){
			if(Util.isVazioOuBranco(categoriaStr)){
				categoriaStr = "4";
			}else{
				categoriaStr = "5";
			}
		}

		categoriaStr = Util.completarStringZeroEsquerda(categoriaStr, 1);
		linha.append(categoriaStr);

		// RAC-NUM-ECONOMIA
		String numeroEconomiaStr = "";
		Integer numeroEconomia = 0;

		if(quantidadeEconomiasResidencial != null){
			numeroEconomia = numeroEconomia + quantidadeEconomiasResidencial;
		}

		if(quantidadeEconomiasComercial != null){
			numeroEconomia = numeroEconomia + quantidadeEconomiasComercial;
		}

		if(quantidadeEconomiasIndustrial != null){
			numeroEconomia = numeroEconomia + quantidadeEconomiasIndustrial;
		}

		if(quantidadeEconomiasPublica != null){
			numeroEconomia = numeroEconomia + quantidadeEconomiasPublica;
		}

		if(numeroEconomia != null){
			numeroEconomiaStr = Integer.toString(numeroEconomia);
		}

		numeroEconomiaStr = Util.completarStringZeroEsquerda(numeroEconomiaStr, 4);
		linha.append(numeroEconomiaStr);

		// RAC-COD-SER-RELIG
		String idServicoReligacaoStr = "";
		Integer idServicoReligacao = movimentoRoteiroEmpresa.getIdServicoReligacao();

		if(idServicoReligacao != null){
			idServicoReligacaoStr = Integer.toString(idServicoReligacao);
		}

		idServicoReligacaoStr = Util.completarStringZeroEsquerda(idServicoReligacaoStr, 2);
		linha.append(idServicoReligacaoStr);

		// RAC-VALOR-RELIG
		String valorReligacaoStr = "";
		BigDecimal valorReligacao = movimentoRoteiroEmpresa.getValorReligacao();

		if(valorReligacao != null){
			valorReligacaoStr = Util.formatarMoedaReal(valorReligacao, 2);
			valorReligacaoStr = valorReligacaoStr.replace(",", "");
		}

		valorReligacaoStr = Util.completarStringZeroEsquerda(valorReligacaoStr, 7);
		linha.append(valorReligacaoStr);

		// RAC-COD-SER-SANCAO
		String idServicoSancaoStr = "";
		Integer idServicoSancao = movimentoRoteiroEmpresa.getIdServicoSancao();

		if(idServicoSancao != null){
			idServicoSancaoStr = Integer.toString(idServicoSancao);
		}

		idServicoSancaoStr = Util.completarStringZeroEsquerda(idServicoSancaoStr, 2);
		linha.append(idServicoSancaoStr);

		// RAC-VALOR-SANCAO
		String valorSancaoStr = "";
		BigDecimal valorSancao = movimentoRoteiroEmpresa.getValorSancao();

		if(valorSancao != null){
			valorSancaoStr = Util.formatarMoedaReal(valorSancao, 2);
			valorSancaoStr = valorSancaoStr.replace(",", "");
		}

		valorSancaoStr = Util.completarStringZeroEsquerda(valorSancaoStr, 7);
		linha.append(valorSancaoStr);

		return linha.toString();
	}

	public Integer pesquisarLeiturasImovelCount(String idImovel, String anoMes) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarLeiturasImovelCount(idImovel, anoMes);
		}catch(ErroRepositorioException ex){
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC3112][UC3113] Atualizacao Cadastral Coletor de Dados
	 * 
	 * @author Victon Malcolm
	 * @since 08/10/2013
	 */
	public Collection pesquisarAtualizacaoCadastralColetorDados(Integer referenciaInicial,
 Integer referenciaFinal, Integer matricula,
					Integer localidade, Integer setorComercial, Integer rota, Boolean relatorio)
					throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarAtualizacaoCadastralColetorDados(referenciaInicial, referenciaFinal, matricula,
							localidade, setorComercial, rota, relatorio);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC3113] Atualizacao Cadastral Coletor de Dados
	 * 
	 * @author Victon Malcolm
	 * @since 08/10/2013
	 */
	public Collection pesquisarConsultaAtualizacaoCadastralColetorDados(Integer id) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarConsultaAtualizacaoCadastralColetorDados(id);

		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}
	}
	/**
	 * [UC3117] Gerar Relatório Auditoria leitura
	 * Seleciona os grupos de faturamento que já tiveram processo de retorno do faturamento
	 * imediato iniciado ou concluido na referência atual.
	 * 
	 * @author Felipe Rosacruz
	 * @date 29/09/2013
	 * @return Collection<FaturamentoGrupo>
	 * @throws FachadaException
	 */
	public Collection<FaturamentoGrupo> pesquisarGrupoFatProcessoRetornoImedInicConc() throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarGrupoFatProcessoRetornoImedInicConc();
		}catch(ErroRepositorioException e){

			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [OC0791503] - Relatório Quadro de Hidrômetros
	 * 
	 * @author Ado Rocha
	 * @date 03/12/2013
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarQuadroHidrometros(Date dataReferencia) throws ControladorException{

		Collection retorno = new ArrayList();

		try{
			Collection colecaoDados = repositorioMicromedicao.pesquisarQuadroHidrometros(dataReferencia);

			if(!colecaoDados.isEmpty()){

				Iterator colecaoDadosIterator = colecaoDados.iterator();
				while(colecaoDadosIterator.hasNext()){
					Object[] dados = (Object[]) colecaoDadosIterator.next();

					QuadroHidrometrosRelatorioHelper quadroHidrometrosRelatorioHelper = new QuadroHidrometrosRelatorioHelper();

					// Hidrometro Capacidade
					if(dados[0] != null){
						quadroHidrometrosRelatorioHelper.setCapacidade((String) dados[0]);
					}

					// Diametro
					if(dados[1] != null){
						quadroHidrometrosRelatorioHelper.setDiametro((String) dados[1]);
					}

					// Marca
					if(dados[2] != null){
						quadroHidrometrosRelatorioHelper.setMarca((String) dados[2]);
					}

					// idLocalidade
					if(dados[3] != null){
						quadroHidrometrosRelatorioHelper.setIdlocalidade((Integer) dados[3]);
					}

					// descricaoLocalidade
					if(dados[4] != null){
						quadroHidrometrosRelatorioHelper.setDescricaoLocalidade((String) dados[4]);
					}

					// idGerencia
					if(dados[5] != null){
						quadroHidrometrosRelatorioHelper.setIdGerencia((Integer) dados[5]);
					}

					// descricaoGerencia
					if(dados[6] != null){
						quadroHidrometrosRelatorioHelper.setDescricaoGerencia((String) dados[6]);
					}

					// Quantidade
					if(dados[7] != null){
						quadroHidrometrosRelatorioHelper.setQuantidade((Integer) dados[7]);
					}

					retorno.add(quadroHidrometrosRelatorioHelper);
				}
			}

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [OC0791503] - Count Relatório Quadro de Hidrômetros
	 * 
	 * @author Ado Rocha
	 * @date 03/12/2013
	 * @return Collection
	 * @throws ControladorException
	 */
	public Integer pesquisarQuadroHidrometrosCount(Date dataReferencia) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarQuadroHidrometrosCount(dataReferencia);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [OC0791503] - Relatório Quadro de Hidrômetros
	 * 
	 * @author Ado Rocha
	 * @date 03/12/2013
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarQuadroHidrometrosAnoInstalacao() throws ControladorException{

		Collection retorno = new ArrayList();

		try{
			Collection colecaoDados = repositorioMicromedicao.pesquisarQuadroHidrometrosAnoInstalacao();

			if(!colecaoDados.isEmpty()){

				Iterator colecaoDadosIterator = colecaoDados.iterator();
				while(colecaoDadosIterator.hasNext()){
					Object[] dados = (Object[]) colecaoDadosIterator.next();

					QuadroHidrometrosRelatorioAnoInstalacaoHelper quadroHidrometrosRelatorioHelper = new QuadroHidrometrosRelatorioAnoInstalacaoHelper();

					// idMarca
					if(dados[0] != null){
						quadroHidrometrosRelatorioHelper.setIdMarca((Integer) dados[0]);
					}

					// marca
					if(dados[1] != null){
						quadroHidrometrosRelatorioHelper.setMarca((String) dados[1]);
					}

					// idLocalidade
					if(dados[2] != null){
						quadroHidrometrosRelatorioHelper.setIdLocalidade((Integer) dados[2]);
					}

					// localidade
					if(dados[3] != null){
						quadroHidrometrosRelatorioHelper.setLocalidade((String) dados[3]);
					}

					// ano
					if(dados[4] != null){
						quadroHidrometrosRelatorioHelper.setAno((Integer) dados[4]);
					}

					// quantidade
					if(dados[5] != null){
						quadroHidrometrosRelatorioHelper.setQuantidade((Integer) dados[5]);
					}

					retorno.add(quadroHidrometrosRelatorioHelper);
				}
			}

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;

	}

	/**
	 * [OC0791503] - Count Relatório Quadro de Hidrômetros Ano Instalação
	 * 
	 * @author Ado Rocha
	 * @date 03/12/2013
	 * @return Collection
	 * @throws ControladorException
	 */
	public Integer pesquisarQuadroHidrometrosAnoInstalacaoCount() throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarQuadroHidrometrosAnoInstalacaoCount();
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [OC0791503] - Count Relatório Quadro de Hidrômetros Situação
	 * 
	 * @author Ado Rocha
	 * @date 03/12/2013
	 * @return Collection
	 * @throws ControladorException
	 */
	public Integer pesquisarQuadroHidrometrosSituacaoCount(Date dataInicial, Date dataFinal) throws ControladorException{

		try{
			return repositorioMicromedicao.pesquisarQuadroHidrometrosSituacaoCount(dataInicial, dataFinal);
		}catch(ErroRepositorioException ex){

			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [OC0791503] - Relatório Quadro de Hidrômetros Situação
	 * 
	 * @author Ado Rocha
	 * @date 03/12/2013
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarQuadroHidrometrosSituacao(Date dataInicial, Date dataFinal) throws ControladorException{

		Collection retorno = new ArrayList();

		try{
			Collection colecaoDados = repositorioMicromedicao.pesquisarQuadroHidrometrosSituacao(dataInicial, dataFinal);

			if(!colecaoDados.isEmpty()){
				
				Iterator colecaoDadosIterator = colecaoDados.iterator();
				while(colecaoDadosIterator.hasNext()){
					Object[] dados = (Object[]) colecaoDadosIterator.next();

					QuadroHidrometrosSituacaoRelatorioHelper quadroHidrometrosRelatorioHelper = new QuadroHidrometrosSituacaoRelatorioHelper();

					// capacidade
					if(dados[0] != null){
						quadroHidrometrosRelatorioHelper.setCapacidade((String) dados[0]);
					}

					// diametro
					if(dados[1] != null){
						quadroHidrometrosRelatorioHelper.setDiametro((String) dados[1]);
					}

					// marca
					if(dados[2] != null){
						quadroHidrometrosRelatorioHelper.setMarca((String) dados[2]);
					}

					// idLocalidade
					if(dados[3] != null){
						quadroHidrometrosRelatorioHelper.setIdLocalidade((Integer) dados[3]);
					}

					// descricaoLocalidade
					if(dados[4] != null){
						quadroHidrometrosRelatorioHelper.setDescricaoLocalidade((String) dados[4]);
					}

					// idGerencia
					if(dados[5] != null){
						quadroHidrometrosRelatorioHelper.setIdGerencia((Integer) dados[5]);
					}

					// descricaoGerencia
					if(dados[6] != null){
						quadroHidrometrosRelatorioHelper.setDescricaoGerencia((String) dados[6]);
					}

					// Quantidade
					if(dados[7] != null){
						quadroHidrometrosRelatorioHelper.setQuantidade((Integer) dados[7]);
					}
					
					// idLeituraAnormalidade
					if(dados[8] != null){
						quadroHidrometrosRelatorioHelper.setIdLeituraAnormalidade((Integer) dados[8]);
					}

					// descricaoLeituraAnormalidade
					if(dados[9] != null){
						quadroHidrometrosRelatorioHelper.setDescricaoLeituraAnormalidade((String) dados[9]);
					}

					retorno.add(quadroHidrometrosRelatorioHelper);
				}
			}

		}catch(ErroRepositorioException e){
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retorno;

	}
}
